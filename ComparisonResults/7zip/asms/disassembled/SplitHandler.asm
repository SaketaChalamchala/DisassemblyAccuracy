.rdata:00000000 ;
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.rdata:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.rdata:00000000 ; |                      License info: 48-3677-7074-51                      |
.rdata:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ;
.rdata:00000000 ; Input MD5   : A107E9F5023475256A0091447685EA34
.rdata:00000000 ; Input CRC32 : EA0C06D7
.rdata:00000000
.rdata:00000000 ; File Name   : C:\workspace\7z1505-src\CPP\7zip\Bundles\Alone\Debug\SplitHandler.obj
.rdata:00000000 ; Format      : COFF (X386MAGIC)
.rdata:00000000 ; includelib "uuid.lib"
.rdata:00000000 ; includelib "MSVCRTD"
.rdata:00000000 ; includelib "OLDNAMES"
.rdata:00000000
.rdata:00000000                 .686p
.rdata:00000000                 .mmx
.rdata:00000000                 .model flat
.rdata:00000000
.rdata:00000000 ; ===========================================================================
.rdata:00000000
.rdata:00000000 ; Segment type: Pure data
.rdata:00000000 ; Segment permissions: Read
.rdata:00000000 _rdata          segment dword public 'DATA' use32
.rdata:00000000                 assume cs:_rdata
.rdata:00000000 _kProps         db 3                    ; DATA XREF: NArchive::NSplit::CHandler::GetPropertyInfo(uint,wchar_t * *,ulong *,ushort *)+13r
.rdata:00000001                 db    7
.rdata:00000002                 db    0
.rdata:00000003                 db    0
.rdata:00000004 _kArcProps      db 27h                  ; DATA XREF: NArchive::NSplit::CHandler::GetArchivePropertyInfo(uint,wchar_t * *,ulong *,ushort *)+13r
.rdata:00000005                 db  4Fh ; O
.rdata:00000006                 db    0
.rdata:00000007                 db    0
.rdata:00000008 ; char _SG69239[3]
.rdata:00000008 $SG69239        db 'aa',0               ; DATA XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+244o
.rdata:0000000B                 db    0
.rdata:0000000C ; char _SG69246[]
.rdata:0000000C $SG69246        dd offset loc_312E+2    ; DATA XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+2CEo
.rdata:00000010 ; char _SG69260[]
.rdata:00000010 $SG69260        db 'file',0             ; DATA XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+4E5o
.rdata:00000015                 align 4
.rdata:00000018 $SG69522        db 'Split',0            ; DATA XREF: .rdata:00000030o
.rdata:0000001E                 align 10h
.rdata:00000020 $SG69523        db '001',0              ; DATA XREF: .rdata:00000034o
.rdata:00000024 ; struct CArcInfo g_ArcInfo
.rdata:00000024 _g_ArcInfo      db    0                 ; DATA XREF: NArchive::NSplit::CRegisterArc::CRegisterArc(void)+Eo
.rdata:00000025                 db    0
.rdata:00000026                 db 0EAh ; O
.rdata:00000027                 db    0
.rdata:00000028                 db    0
.rdata:00000029                 db    0
.rdata:0000002A                 db    0
.rdata:0000002B                 db    0
.rdata:0000002C                 db    0
.rdata:0000002D                 db    0
.rdata:0000002E                 db    0
.rdata:0000002F                 db    0
.rdata:00000030                 dd offset $SG69522      ; "Split"
.rdata:00000034                 dd offset $SG69523      ; "001"
.rdata:00000038                 db    0
.rdata:00000039                 db    0
.rdata:0000003A                 db    0
.rdata:0000003B                 db    0
.rdata:0000003C                 dd offset ?CreateArc@NSplit@NArchive@@YGPAUIInArchive@@XZ ; NArchive::NSplit::CreateArc(void)
.rdata:00000040 unk_40          db    0                 ; DATA XREF: .xdata$x:__catchsym$?Open@CHandler@NSplit@NArchive@@UAGJPAUIInStream@@PB_KPAUIArchiveOpenCallback@@@Z$2o
.rdata:00000040                                         ; .xdata$x:__catchsym$?Extract@CHandler@NSplit@NArchive@@UAGJPBIIHPAUIArchiveExtractCallback@@@Z$7o ...
.rdata:00000041                 db    0
.rdata:00000042                 db    0
.rdata:00000043                 db    0
.rdata:00000044                 db    0
.rdata:00000045                 db    0
.rdata:00000046                 db    0
.rdata:00000047                 db    0
.rdata:00000047 _rdata          ends
.rdata:00000047
.text:00000048 ; ===========================================================================
.text:00000048
.text:00000048 ; Segment type: Pure code
.text:00000048 ; Segment permissions: Read/Execute
.text:00000048 _text           segment para public 'CODE' use32
.text:00000048                 assume cs:_text
.text:00000048                 ;org 48h
.text:00000048                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000048
.text:00000048 ; =============== S U B R O U T I N E =======================================
.text:00000048
.text:00000048 ; Attributes: bp-based frame
.text:00000048
.text:00000048 ; __int32 __stdcall NArchive::NSplit::CHandler::GetNumberOfProperties(NArchive::NSplit::CHandler *this, unsigned int *)
.text:00000048                 public ?GetNumberOfProperties@CHandler@NSplit@NArchive@@UAGJPAI@Z
.text:00000048 ?GetNumberOfProperties@CHandler@NSplit@NArchive@@UAGJPAI@Z proc near
.text:00000048                                         ; DATA XREF: .rdata:00003294o
.text:00000048
.text:00000048 this            = dword ptr  8
.text:00000048 arg_4           = dword ptr  0Ch
.text:00000048
.text:00000048                 push    ebp
.text:00000049                 mov     ebp, esp
.text:0000004B                 mov     eax, [ebp+arg_4]
.text:0000004E                 mov     dword ptr [eax], 2
.text:00000054                 xor     eax, eax
.text:00000056                 pop     ebp
.text:00000057                 retn    8
.text:00000057 ?GetNumberOfProperties@CHandler@NSplit@NArchive@@UAGJPAI@Z endp
.text:00000057
.text:00000057 ; ---------------------------------------------------------------------------
.text:0000005A                 db 0Eh dup(0CCh)
.text:00000068
.text:00000068 ; =============== S U B R O U T I N E =======================================
.text:00000068
.text:00000068 ; Attributes: bp-based frame
.text:00000068
.text:00000068 ; __int32 __stdcall NArchive::NSplit::CHandler::GetPropertyInfo(NArchive::NSplit::CHandler *this, unsigned int, wchar_t **, unsigned __int32 *, unsigned __int16 *)
.text:00000068                 public ?GetPropertyInfo@CHandler@NSplit@NArchive@@UAGJIPAPA_WPAKPAG@Z
.text:00000068 ?GetPropertyInfo@CHandler@NSplit@NArchive@@UAGJIPAPA_WPAKPAG@Z proc near
.text:00000068                                         ; DATA XREF: .rdata:00003298o
.text:00000068
.text:00000068 this            = dword ptr  8
.text:00000068 arg_4           = dword ptr  0Ch
.text:00000068 arg_8           = dword ptr  10h
.text:00000068 arg_C           = dword ptr  14h
.text:00000068 arg_10          = dword ptr  18h
.text:00000068
.text:00000068                 push    ebp
.text:00000069                 mov     ebp, esp
.text:0000006B                 cmp     [ebp+arg_4], 2
.text:0000006F                 jb      short loc_78
.text:00000071                 mov     eax, 80070057h
.text:00000076                 jmp     short loc_A5
.text:00000078 ; ---------------------------------------------------------------------------
.text:00000078
.text:00000078 loc_78:                                 ; CODE XREF: NArchive::NSplit::CHandler::GetPropertyInfo(uint,wchar_t * *,ulong *,ushort *)+7j
.text:00000078                 mov     eax, [ebp+arg_4]
.text:0000007B                 movzx   ecx, _kProps[eax]
.text:00000082                 mov     edx, [ebp+arg_C]
.text:00000085                 mov     [edx], ecx
.text:00000087                 mov     eax, [ebp+arg_C]
.text:0000008A                 mov     ecx, [eax]
.text:0000008C                 movzx   dx, byte ptr ds:?k7z_PROPID_To_VARTYPE@@3QBEB[ecx] ; uchar const * const k7z_PROPID_To_VARTYPE
.text:00000094                 mov     eax, [ebp+arg_10]
.text:00000097                 mov     [eax], dx
.text:0000009A                 mov     ecx, [ebp+arg_8]
.text:0000009D                 mov     dword ptr [ecx], 0
.text:000000A3                 xor     eax, eax
.text:000000A5
.text:000000A5 loc_A5:                                 ; CODE XREF: NArchive::NSplit::CHandler::GetPropertyInfo(uint,wchar_t * *,ulong *,ushort *)+Ej
.text:000000A5                 pop     ebp
.text:000000A6                 retn    14h
.text:000000A6 ?GetPropertyInfo@CHandler@NSplit@NArchive@@UAGJIPAPA_WPAKPAG@Z endp
.text:000000A6
.text:000000A6 ; ---------------------------------------------------------------------------
.text:000000A9                 db 0Fh dup(0CCh)
.text:000000B8
.text:000000B8 ; =============== S U B R O U T I N E =======================================
.text:000000B8
.text:000000B8 ; Attributes: bp-based frame
.text:000000B8
.text:000000B8 ; __int32 __stdcall NArchive::NSplit::CHandler::GetNumberOfArchiveProperties(NArchive::NSplit::CHandler *this, unsigned int *)
.text:000000B8                 public ?GetNumberOfArchiveProperties@CHandler@NSplit@NArchive@@UAGJPAI@Z
.text:000000B8 ?GetNumberOfArchiveProperties@CHandler@NSplit@NArchive@@UAGJPAI@Z proc near
.text:000000B8                                         ; DATA XREF: .rdata:0000329Co
.text:000000B8
.text:000000B8 this            = dword ptr  8
.text:000000B8 arg_4           = dword ptr  0Ch
.text:000000B8
.text:000000B8                 push    ebp
.text:000000B9                 mov     ebp, esp
.text:000000BB                 mov     eax, [ebp+arg_4]
.text:000000BE                 mov     dword ptr [eax], 2
.text:000000C4                 xor     eax, eax
.text:000000C6                 pop     ebp
.text:000000C7                 retn    8
.text:000000C7 ?GetNumberOfArchiveProperties@CHandler@NSplit@NArchive@@UAGJPAI@Z endp
.text:000000C7
.text:000000C7 ; ---------------------------------------------------------------------------
.text:000000CA                 db 0Eh dup(0CCh)
.text:000000D8
.text:000000D8 ; =============== S U B R O U T I N E =======================================
.text:000000D8
.text:000000D8 ; Attributes: bp-based frame
.text:000000D8
.text:000000D8 ; __int32 __stdcall NArchive::NSplit::CHandler::GetArchivePropertyInfo(NArchive::NSplit::CHandler *this, unsigned int, wchar_t **, unsigned __int32 *, unsigned __int16 *)
.text:000000D8                 public ?GetArchivePropertyInfo@CHandler@NSplit@NArchive@@UAGJIPAPA_WPAKPAG@Z
.text:000000D8 ?GetArchivePropertyInfo@CHandler@NSplit@NArchive@@UAGJIPAPA_WPAKPAG@Z proc near
.text:000000D8                                         ; DATA XREF: .rdata:000032A0o
.text:000000D8
.text:000000D8 this            = dword ptr  8
.text:000000D8 arg_4           = dword ptr  0Ch
.text:000000D8 arg_8           = dword ptr  10h
.text:000000D8 arg_C           = dword ptr  14h
.text:000000D8 arg_10          = dword ptr  18h
.text:000000D8
.text:000000D8                 push    ebp
.text:000000D9                 mov     ebp, esp
.text:000000DB                 cmp     [ebp+arg_4], 2
.text:000000DF                 jb      short loc_E8
.text:000000E1                 mov     eax, 80070057h
.text:000000E6                 jmp     short loc_115
.text:000000E8 ; ---------------------------------------------------------------------------
.text:000000E8
.text:000000E8 loc_E8:                                 ; CODE XREF: NArchive::NSplit::CHandler::GetArchivePropertyInfo(uint,wchar_t * *,ulong *,ushort *)+7j
.text:000000E8                 mov     eax, [ebp+arg_4]
.text:000000EB                 movzx   ecx, _kArcProps[eax]
.text:000000F2                 mov     edx, [ebp+arg_C]
.text:000000F5                 mov     [edx], ecx
.text:000000F7                 mov     eax, [ebp+arg_C]
.text:000000FA                 mov     ecx, [eax]
.text:000000FC                 movzx   dx, byte ptr ds:?k7z_PROPID_To_VARTYPE@@3QBEB[ecx] ; uchar const * const k7z_PROPID_To_VARTYPE
.text:00000104                 mov     eax, [ebp+arg_10]
.text:00000107                 mov     [eax], dx
.text:0000010A                 mov     ecx, [ebp+arg_8]
.text:0000010D                 mov     dword ptr [ecx], 0
.text:00000113                 xor     eax, eax
.text:00000115
.text:00000115 loc_115:                                ; CODE XREF: NArchive::NSplit::CHandler::GetArchivePropertyInfo(uint,wchar_t * *,ulong *,ushort *)+Ej
.text:00000115                 pop     ebp
.text:00000116                 retn    14h
.text:00000116 ?GetArchivePropertyInfo@CHandler@NSplit@NArchive@@UAGJIPAPA_WPAKPAG@Z endp
.text:00000116
.text:00000116 ; ---------------------------------------------------------------------------
.text:00000119                 db 0Fh dup(0CCh)
.text:00000128
.text:00000128 ; =============== S U B R O U T I N E =======================================
.text:00000128
.text:00000128 ; Attributes: bp-based frame
.text:00000128
.text:00000128 ; __int32 __stdcall NArchive::NSplit::CHandler::GetArchiveProperty(NArchive::NSplit::CHandler *this, unsigned __int32, struct tagPROPVARIANT *)
.text:00000128                 public ?GetArchiveProperty@CHandler@NSplit@NArchive@@UAGJKPAUtagPROPVARIANT@@@Z
.text:00000128 ?GetArchiveProperty@CHandler@NSplit@NArchive@@UAGJKPAUtagPROPVARIANT@@@Z proc near
.text:00000128                                         ; DATA XREF: .rdata:00003290o
.text:00000128
.text:00000128 var_20          = dword ptr -20h
.text:00000128 var_1C          = dword ptr -1Ch
.text:00000128 var_18          = dword ptr -18h
.text:00000128 var_14          = dword ptr -14h
.text:00000128 var_10          = dword ptr -10h
.text:00000128 var_C           = dword ptr -0Ch
.text:00000128 var_8           = dword ptr -8
.text:00000128 var_4           = dword ptr -4
.text:00000128 this            = dword ptr  8
.text:00000128 arg_4           = dword ptr  0Ch
.text:00000128 arg_8           = dword ptr  10h
.text:00000128
.text:00000128                 push    ebp
.text:00000129                 mov     ebp, esp
.text:0000012B                 sub     esp, 20h
.text:0000012E                 mov     eax, 0CCCCCCCCh
.text:00000133                 mov     [ebp+var_20], eax
.text:00000136                 mov     [ebp+var_1C], eax
.text:00000139                 mov     [ebp+var_18], eax
.text:0000013C                 mov     [ebp+var_14], eax
.text:0000013F                 mov     [ebp+var_10], eax
.text:00000142                 mov     [ebp+var_C], eax
.text:00000145                 mov     [ebp+var_8], eax
.text:00000148                 mov     [ebp+var_4], eax
.text:0000014B                 lea     ecx, [ebp+var_14] ; this
.text:0000014E                 call    ??0CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::CPropVariant(void)
.text:00000153                 mov     eax, [ebp+arg_4]
.text:00000156                 mov     [ebp+var_20], eax
.text:00000159                 mov     ecx, [ebp+var_20]
.text:0000015C                 sub     ecx, 1
.text:0000015F                 mov     [ebp+var_20], ecx
.text:00000162                 cmp     [ebp+var_20], 4Eh ; 'N' ; switch 79 cases
.text:00000166                 ja      short $LN6      ; jumptable 00000172 default case
.text:00000168                 mov     edx, [ebp+var_20]
.text:0000016B                 movzx   eax, ds:$LN10[edx]
.text:00000172                 jmp     ds:$LN14[eax*4] ; switch jump
.text:00000179 ; ---------------------------------------------------------------------------
.text:00000179
.text:00000179 $LN5:                                   ; CODE XREF: NArchive::NSplit::CHandler::GetArchiveProperty(ulong,tagPROPVARIANT *)+4Aj
.text:00000179                                         ; DATA XREF: .text:$LN14o
.text:00000179                 push    0               ; jumptable 00000172 case 0
.text:0000017B                 lea     ecx, [ebp+var_14]
.text:0000017E                 call    ??4CPropVariant@NCOM@NWindows@@QAEAAV012@I@Z ; NWindows::NCOM::CPropVariant::operator=(uint)
.text:00000183                 jmp     short $LN6      ; jumptable 00000172 default case
.text:00000185 ; ---------------------------------------------------------------------------
.text:00000185
.text:00000185 $LN4:                                   ; CODE XREF: NArchive::NSplit::CHandler::GetArchiveProperty(ulong,tagPROPVARIANT *)+4Aj
.text:00000185                                         ; DATA XREF: .text:$LN14o
.text:00000185                 mov     ecx, [ebp+this] ; jumptable 00000172 case 43
.text:00000188                 add     ecx, 18h
.text:0000018B                 call    ?IsEmpty@?$CRecordVector@_K@@QBE_NXZ ; CRecordVector<unsigned __int64>::IsEmpty(void)
.text:00000190                 movzx   ecx, al
.text:00000193                 test    ecx, ecx
.text:00000195                 jnz     short loc_1B3
.text:00000197                 push    0
.text:00000199                 mov     ecx, [ebp+this]
.text:0000019C                 add     ecx, 18h
.text:0000019F                 call    ??A?$CRecordVector@_K@@QAEAA_KI@Z ; CRecordVector<unsigned __int64>::operator[](uint)
.text:000001A4                 mov     edx, [eax+4]
.text:000001A7                 push    edx
.text:000001A8                 mov     eax, [eax]
.text:000001AA                 push    eax
.text:000001AB                 lea     ecx, [ebp+var_14]
.text:000001AE                 call    ??4CPropVariant@NCOM@NWindows@@QAEAAV012@_K@Z ; NWindows::NCOM::CPropVariant::operator=(unsigned __int64)
.text:000001B3
.text:000001B3 loc_1B3:                                ; CODE XREF: NArchive::NSplit::CHandler::GetArchiveProperty(ulong,tagPROPVARIANT *)+6Dj
.text:000001B3                 jmp     short $LN6      ; jumptable 00000172 default case
.text:000001B5 ; ---------------------------------------------------------------------------
.text:000001B5
.text:000001B5 $LN2:                                   ; CODE XREF: NArchive::NSplit::CHandler::GetArchiveProperty(ulong,tagPROPVARIANT *)+4Aj
.text:000001B5                                         ; DATA XREF: .text:$LN14o
.text:000001B5                 mov     ecx, [ebp+this] ; jumptable 00000172 case 78
.text:000001B8                 mov     edx, [ecx+34h]
.text:000001BB                 push    edx
.text:000001BC                 mov     eax, [ecx+30h]
.text:000001BF                 push    eax
.text:000001C0                 lea     ecx, [ebp+var_14]
.text:000001C3                 call    ??4CPropVariant@NCOM@NWindows@@QAEAAV012@_K@Z ; NWindows::NCOM::CPropVariant::operator=(unsigned __int64)
.text:000001C8                 jmp     short $LN6      ; jumptable 00000172 default case
.text:000001CA ; ---------------------------------------------------------------------------
.text:000001CA
.text:000001CA $LN1:                                   ; CODE XREF: NArchive::NSplit::CHandler::GetArchiveProperty(ulong,tagPROPVARIANT *)+4Aj
.text:000001CA                                         ; DATA XREF: .text:$LN14o
.text:000001CA                 mov     ecx, [ebp+this] ; jumptable 00000172 case 38
.text:000001CD                 add     ecx, 0Ch
.text:000001D0                 call    ?Size@?$CObjectVector@V?$CMyComPtr@UIInStream@@@@@@QBEIXZ ; CObjectVector<CMyComPtr<IInStream>>::Size(void)
.text:000001D5                 push    eax
.text:000001D6                 lea     ecx, [ebp+var_14]
.text:000001D9                 call    ??4CPropVariant@NCOM@NWindows@@QAEAAV012@I@Z ; NWindows::NCOM::CPropVariant::operator=(uint)
.text:000001DE
.text:000001DE $LN6:                                   ; CODE XREF: NArchive::NSplit::CHandler::GetArchiveProperty(ulong,tagPROPVARIANT *)+3Ej
.text:000001DE                                         ; NArchive::NSplit::CHandler::GetArchiveProperty(ulong,tagPROPVARIANT *)+4Aj ...
.text:000001DE                 mov     ecx, [ebp+arg_8] ; jumptable 00000172 default case
.text:000001E1                 push    ecx             ; struct tagPROPVARIANT *
.text:000001E2                 lea     ecx, [ebp+var_14] ; this
.text:000001E5                 call    ?Detach@CPropVariant@NCOM@NWindows@@QAEJPAUtagPROPVARIANT@@@Z ; NWindows::NCOM::CPropVariant::Detach(tagPROPVARIANT *)
.text:000001EA                 mov     [ebp+var_1C], 0
.text:000001F1                 lea     ecx, [ebp+var_14] ; this
.text:000001F4                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:000001F9                 mov     eax, [ebp+var_1C]
.text:000001FC                 push    edx
.text:000001FD                 mov     ecx, ebp
.text:000001FF                 push    eax
.text:00000200                 lea     edx, $LN13
.text:00000206                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:0000020B                 pop     eax
.text:0000020C                 pop     edx
.text:0000020D                 add     esp, 20h
.text:00000210                 cmp     ebp, esp
.text:00000212                 call    __RTC_CheckEsp
.text:00000217                 mov     esp, ebp
.text:00000219                 pop     ebp
.text:0000021A                 retn    0Ch
.text:0000021A ?GetArchiveProperty@CHandler@NSplit@NArchive@@UAGJKPAUtagPROPVARIANT@@@Z endp
.text:0000021A
.text:0000021A ; ---------------------------------------------------------------------------
.text:0000021D                 align 10h
.text:00000220 $LN13           dd 1                    ; DATA XREF: NArchive::NSplit::CHandler::GetArchiveProperty(ulong,tagPROPVARIANT *)+D8o
.text:00000224                 dd offset $LN12
.text:00000228 $LN12           dd 0FFFFFFECh, 10h      ; DATA XREF: .text:00000224o
.text:00000230                 dd offset $LN11         ; "prop"
.text:00000234 $LN11           db 'prop',0             ; DATA XREF: .text:00000230o
.text:00000239                 align 4
.text:0000023C $LN14           dd offset $LN5, offset $LN1, offset $LN4, offset $LN2
.text:0000023C                                         ; DATA XREF: NArchive::NSplit::CHandler::GetArchiveProperty(ulong,tagPROPVARIANT *)+4Ar
.text:0000023C                 dd offset $LN6          ; jump table for switch statement
.text:00000250 $LN10           db      0,     4,     4,     4
.text:00000250                                         ; DATA XREF: NArchive::NSplit::CHandler::GetArchiveProperty(ulong,tagPROPVARIANT *)+43r
.text:00000250                 db      4,     4,     4,     4 ; indirect table for switch statement
.text:00000250                 db      4,     4,     4,     4
.text:00000250                 db      4,     4,     4,     4
.text:00000250                 db      4,     4,     4,     4
.text:00000250                 db      4,     4,     4,     4
.text:00000250                 db      4,     4,     4,     4
.text:00000250                 db      4,     4,     4,     4
.text:00000250                 db      4,     4,     4,     4
.text:00000250                 db      4,     4,     1,     4
.text:00000250                 db      4,     4,     4,     2
.text:00000250                 db      4,     4,     4,     4
.text:00000250                 db      4,     4,     4,     4
.text:00000250                 db      4,     4,     4,     4
.text:00000250                 db      4,     4,     4,     4
.text:00000250                 db      4,     4,     4,     4
.text:00000250                 db      4,     4,     4,     4
.text:00000250                 db      4,     4,     4,     4
.text:00000250                 db      4,     4,     4,     4
.text:00000250                 db      4,     4,     3
.text:0000029F                 db 9 dup(0CCh)
.text:000002A8
.text:000002A8 ; =============== S U B R O U T I N E =======================================
.text:000002A8
.text:000002A8 ; Attributes: bp-based frame
.text:000002A8
.text:000002A8 ; __int32 __thiscall NArchive::NSplit::CHandler::Open2(NArchive::NSplit::CHandler *this, struct IInStream *, struct IArchiveOpenCallback *)
.text:000002A8                 public ?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z
.text:000002A8 ?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z proc near
.text:000002A8                                         ; CODE XREF: NArchive::NSplit::CHandler::Open(IInStream *,unsigned __int64 const *,IArchiveOpenCallback *)+53p
.text:000002A8
.text:000002A8 var_1B8         = dword ptr -1B8h
.text:000002A8 var_1B4         = dword ptr -1B4h
.text:000002A8 var_1B0         = dword ptr -1B0h
.text:000002A8 var_1AC         = dword ptr -1ACh
.text:000002A8 var_1A8         = dword ptr -1A8h
.text:000002A8 var_1A4         = dword ptr -1A4h
.text:000002A8 var_1A0         = dword ptr -1A0h
.text:000002A8 var_19C         = dword ptr -19Ch
.text:000002A8 var_198         = dword ptr -198h
.text:000002A8 var_194         = dword ptr -194h
.text:000002A8 var_190         = dword ptr -190h
.text:000002A8 var_18C         = dword ptr -18Ch
.text:000002A8 var_188         = dword ptr -188h
.text:000002A8 var_184         = dword ptr -184h
.text:000002A8 var_180         = dword ptr -180h
.text:000002A8 var_17C         = byte ptr -17Ch
.text:000002A8 var_178         = dword ptr -178h
.text:000002A8 var_174         = dword ptr -174h
.text:000002A8 var_170         = byte ptr -170h
.text:000002A8 var_164         = byte ptr -164h
.text:000002A8 var_158         = dword ptr -158h
.text:000002A8 var_154         = dword ptr -154h
.text:000002A8 var_150         = dword ptr -150h
.text:000002A8 var_14C         = dword ptr -14Ch
.text:000002A8 var_148         = dword ptr -148h
.text:000002A8 var_144         = dword ptr -144h
.text:000002A8 var_13C         = dword ptr -13Ch
.text:000002A8 var_138         = dword ptr -138h
.text:000002A8 var_130         = dword ptr -130h
.text:000002A8 var_128         = word ptr -128h
.text:000002A8 var_120         = dword ptr -120h
.text:000002A8 var_11C         = dword ptr -11Ch
.text:000002A8 var_114         = dword ptr -114h
.text:000002A8 var_10C         = byte ptr -10Ch
.text:000002A8 var_100         = byte ptr -100h
.text:000002A8 var_F0          = dword ptr -0F0h
.text:000002A8 var_E8          = dword ptr -0E8h
.text:000002A8 var_E4          = dword ptr -0E4h
.text:000002A8 var_DC          = dword ptr -0DCh
.text:000002A8 var_D4          = word ptr -0D4h
.text:000002A8 var_CC          = dword ptr -0CCh
.text:000002A8 var_C8          = dword ptr -0C8h
.text:000002A8 var_C0          = dword ptr -0C0h
.text:000002A8 var_BC          = dword ptr -0BCh
.text:000002A8 var_B5          = byte ptr -0B5h
.text:000002A8 var_B4          = dword ptr -0B4h
.text:000002A8 var_AC          = byte ptr -0ACh
.text:000002A8 var_A0          = byte ptr -0A0h
.text:000002A8 var_94          = byte ptr -94h
.text:000002A8 var_88          = byte ptr -88h
.text:000002A8 var_74          = byte ptr -74h
.text:000002A8 var_60          = byte ptr -60h
.text:000002A8 var_50          = dword ptr -50h
.text:000002A8 var_4C          = dword ptr -4Ch
.text:000002A8 var_44          = word ptr -44h
.text:000002A8 var_3C          = dword ptr -3Ch
.text:000002A8 var_2C          = byte ptr -2Ch
.text:000002A8 var_18          = byte ptr -18h
.text:000002A8 var_10          = dword ptr -10h
.text:000002A8 var_C           = dword ptr -0Ch
.text:000002A8 var_4           = dword ptr -4
.text:000002A8 arg_0           = dword ptr  8
.text:000002A8 arg_4           = dword ptr  0Ch
.text:000002A8
.text:000002A8                 push    ebp
.text:000002A9                 mov     ebp, esp
.text:000002AB                 push    0FFFFFFFFh
.text:000002AD                 push    offset __ehhandler$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z
.text:000002B2                 mov     eax, large fs:0
.text:000002B8                 push    eax
.text:000002B9                 sub     esp, 1ACh
.text:000002BF                 push    esi
.text:000002C0                 push    edi
.text:000002C1                 push    ecx
.text:000002C2                 lea     edi, [ebp+var_1B8]
.text:000002C8                 mov     ecx, 6Bh ; 'k'
.text:000002CD                 mov     eax, 0CCCCCCCCh
.text:000002D2                 rep stosd
.text:000002D4                 pop     ecx
.text:000002D5                 mov     eax, dword ptr ds:___security_cookie
.text:000002DA                 xor     eax, ebp
.text:000002DC                 push    eax
.text:000002DD                 lea     eax, [ebp+var_C]
.text:000002E0                 mov     large fs:0, eax
.text:000002E6                 mov     [ebp+var_10], ecx
.text:000002E9                 mov     eax, [ebp+var_10]
.text:000002EC                 mov     ecx, [eax]
.text:000002EE                 mov     esi, esp
.text:000002F0                 mov     edx, [ebp+var_10]
.text:000002F3                 push    edx
.text:000002F4                 mov     eax, [ecx+10h]
.text:000002F7                 call    eax
.text:000002F9                 cmp     esi, esp
.text:000002FB                 call    __RTC_CheckEsp
.text:00000300                 cmp     [ebp+arg_4], 0
.text:00000304                 jnz     short loc_310
.text:00000306                 mov     eax, 1
.text:0000030B                 jmp     loc_F99
.text:00000310 ; ---------------------------------------------------------------------------
.text:00000310
.text:00000310 loc_310:                                ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+5Cj
.text:00000310                 lea     ecx, [ebp+var_18]
.text:00000313                 call    ??0?$CMyComPtr@UIArchiveOpenVolumeCallback@@@@QAE@XZ ; CMyComPtr<IArchiveOpenVolumeCallback>::CMyComPtr<IArchiveOpenVolumeCallback>(void)
.text:00000318                 mov     [ebp+var_4], 0
.text:0000031F                 lea     ecx, [ebp+var_18]
.text:00000322                 call    ??I?$CMyComPtr@UIArchiveOpenVolumeCallback@@@@QAEPAPAUIArchiveOpenVolumeCallback@@XZ ; CMyComPtr<IArchiveOpenVolumeCallback>::operator&(void)
.text:00000327                 mov     esi, esp
.text:00000329                 push    eax
.text:0000032A                 push    offset _IID_IArchiveOpenVolumeCallback
.text:0000032F                 mov     ecx, [ebp+arg_4]
.text:00000332                 mov     edx, [ecx]
.text:00000334                 mov     eax, [ebp+arg_4]
.text:00000337                 push    eax
.text:00000338                 mov     ecx, [edx]
.text:0000033A                 call    ecx
.text:0000033C                 cmp     esi, esp
.text:0000033E                 call    __RTC_CheckEsp
.text:00000343                 lea     ecx, [ebp+var_18]
.text:00000346                 call    ??7?$CMyComPtr@UIArchiveOpenVolumeCallback@@@@QBE_NXZ ; CMyComPtr<IArchiveOpenVolumeCallback>::operator!(void)
.text:0000034B                 movzx   edx, al
.text:0000034E                 test    edx, edx
.text:00000350                 jz      short loc_376
.text:00000352                 mov     [ebp+var_148], 1
.text:0000035C                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000363                 lea     ecx, [ebp+var_18]
.text:00000366                 call    ??1?$CMyComPtr@UIArchiveOpenVolumeCallback@@@@QAE@XZ ; CMyComPtr<IArchiveOpenVolumeCallback>::~CMyComPtr<IArchiveOpenVolumeCallback>(void)
.text:0000036B                 mov     eax, [ebp+var_148]
.text:00000371                 jmp     loc_F99
.text:00000376 ; ---------------------------------------------------------------------------
.text:00000376
.text:00000376 loc_376:                                ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+A8j
.text:00000376                 lea     ecx, [ebp+var_2C]
.text:00000379                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:0000037E                 mov     byte ptr [ebp+var_4], 1
.text:00000382                 lea     ecx, [ebp+var_44] ; this
.text:00000385                 call    ??0CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::CPropVariant(void)
.text:0000038A                 mov     byte ptr [ebp+var_4], 2
.text:0000038E                 lea     ecx, [ebp+var_18]
.text:00000391                 call    ??C?$CMyComPtr@UIArchiveOpenVolumeCallback@@@@QBEPAUIArchiveOpenVolumeCallback@@XZ ; CMyComPtr<IArchiveOpenVolumeCallback>::operator->(void)
.text:00000396                 mov     [ebp+var_19C], eax
.text:0000039C                 mov     esi, esp
.text:0000039E                 lea     eax, [ebp+var_44]
.text:000003A1                 push    eax
.text:000003A2                 push    4
.text:000003A4                 mov     ecx, [ebp+var_19C]
.text:000003AA                 push    ecx
.text:000003AB                 mov     edx, [ebp+var_19C]
.text:000003B1                 mov     eax, [edx]
.text:000003B3                 mov     ecx, [eax+0Ch]
.text:000003B6                 call    ecx
.text:000003B8                 cmp     esi, esp
.text:000003BA                 call    __RTC_CheckEsp
.text:000003BF                 mov     [ebp+var_4C], eax
.text:000003C2                 cmp     [ebp+var_4C], 0
.text:000003C6                 jz      short loc_403
.text:000003C8                 mov     edx, [ebp+var_4C]
.text:000003CB                 mov     [ebp+var_14C], edx
.text:000003D1                 mov     byte ptr [ebp+var_4], 1
.text:000003D5                 lea     ecx, [ebp+var_44] ; this
.text:000003D8                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:000003DD                 mov     byte ptr [ebp+var_4], 0
.text:000003E1                 lea     ecx, [ebp+var_2C] ; this
.text:000003E4                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000003E9                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000003F0                 lea     ecx, [ebp+var_18]
.text:000003F3                 call    ??1?$CMyComPtr@UIArchiveOpenVolumeCallback@@@@QAE@XZ ; CMyComPtr<IArchiveOpenVolumeCallback>::~CMyComPtr<IArchiveOpenVolumeCallback>(void)
.text:000003F8                 mov     eax, [ebp+var_14C]
.text:000003FE                 jmp     loc_F99
.text:00000403 ; ---------------------------------------------------------------------------
.text:00000403
.text:00000403 loc_403:                                ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+11Ej
.text:00000403                 movzx   eax, [ebp+var_44]
.text:00000407                 cmp     eax, 8
.text:0000040A                 jz      short loc_448
.text:0000040C                 mov     [ebp+var_150], 1
.text:00000416                 mov     byte ptr [ebp+var_4], 1
.text:0000041A                 lea     ecx, [ebp+var_44] ; this
.text:0000041D                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:00000422                 mov     byte ptr [ebp+var_4], 0
.text:00000426                 lea     ecx, [ebp+var_2C] ; this
.text:00000429                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000042E                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000435                 lea     ecx, [ebp+var_18]
.text:00000438                 call    ??1?$CMyComPtr@UIArchiveOpenVolumeCallback@@@@QAE@XZ ; CMyComPtr<IArchiveOpenVolumeCallback>::~CMyComPtr<IArchiveOpenVolumeCallback>(void)
.text:0000043D                 mov     eax, [ebp+var_150]
.text:00000443                 jmp     loc_F99
.text:00000448 ; ---------------------------------------------------------------------------
.text:00000448
.text:00000448 loc_448:                                ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+162j
.text:00000448                 mov     ecx, [ebp+var_3C]
.text:0000044B                 push    ecx
.text:0000044C                 lea     ecx, [ebp+var_2C]
.text:0000044F                 call    ??4UString@@QAEAAV0@PB_W@Z ; UString::operator=(wchar_t const *)
.text:00000454                 mov     byte ptr [ebp+var_4], 1
.text:00000458                 lea     ecx, [ebp+var_44] ; this
.text:0000045B                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:00000460                 lea     ecx, [ebp+var_2C] ; this
.text:00000463                 call    ?ReverseFind_Dot@UString@@QBEHXZ ; UString::ReverseFind_Dot(void)
.text:00000468                 mov     [ebp+var_50], eax
.text:0000046B                 mov     edx, [ebp+var_50]
.text:0000046E                 add     edx, 1
.text:00000471                 push    edx
.text:00000472                 lea     eax, [ebp+var_60]
.text:00000475                 push    eax
.text:00000476                 lea     ecx, [ebp+var_2C]
.text:00000479                 call    ?Left@UString@@QBE?AV1@I@Z ; UString::Left(uint)
.text:0000047E                 mov     byte ptr [ebp+var_4], 3
.text:00000482                 mov     ecx, [ebp+var_50]
.text:00000485                 add     ecx, 1
.text:00000488                 push    ecx             ; unsigned int
.text:00000489                 lea     ecx, [ebp+var_2C] ; this
.text:0000048C                 call    ?Ptr@UString@@QBEPB_WI@Z ; UString::Ptr(uint)
.text:00000491                 push    eax
.text:00000492                 lea     ecx, [ebp+var_74]
.text:00000495                 call    ??0UString@@QAE@PB_W@Z ; UString::UString(wchar_t const *)
.text:0000049A                 mov     byte ptr [ebp+var_4], 4
.text:0000049E                 lea     edx, [ebp+var_74]
.text:000004A1                 push    edx
.text:000004A2                 lea     ecx, [ebp+var_88]
.text:000004A8                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:000004AD                 mov     byte ptr [ebp+var_4], 5
.text:000004B1                 lea     ecx, [ebp+var_88] ; this
.text:000004B7                 call    ?MakeLower_Ascii@UString@@QAEXXZ ; UString::MakeLower_Ascii(void)
.text:000004BC                 lea     ecx, [ebp+var_AC] ; this
.text:000004C2                 call    ??0CSeqName@NSplit@NArchive@@QAE@XZ ; NArchive::NSplit::CSeqName::CSeqName(void)
.text:000004C7                 mov     byte ptr [ebp+var_4], 6
.text:000004CB                 mov     [ebp+var_B4], 2
.text:000004D5                 mov     [ebp+var_B5], 0
.text:000004DC                 lea     ecx, [ebp+var_88] ; this
.text:000004E2                 call    ?Len@UString@@QBEIXZ ; UString::Len(void)
.text:000004E7                 cmp     eax, 2
.text:000004EA                 jb      short loc_565
.text:000004EC                 push    offset $SG69239 ; "aa"
.text:000004F1                 push    2               ; unsigned int
.text:000004F3                 lea     ecx, [ebp+var_88] ; this
.text:000004F9                 call    ?RightPtr@UString@@QBEPB_WI@Z ; UString::RightPtr(uint)
.text:000004FE                 push    eax             ; wchar_t *
.text:000004FF                 call    ?StringsAreEqual_Ascii@@YG_NPB_WPBD@Z ; StringsAreEqual_Ascii(wchar_t const *,char const *)
.text:00000504                 movzx   eax, al
.text:00000507                 test    eax, eax
.text:00000509                 jz      short loc_565
.text:0000050B                 mov     [ebp+var_B5], 1
.text:00000512
.text:00000512 loc_512:                                ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+2B6j
.text:00000512                 lea     ecx, [ebp+var_88] ; this
.text:00000518                 call    ?Len@UString@@QBEIXZ ; UString::Len(void)
.text:0000051D                 cmp     [ebp+var_B4], eax
.text:00000523                 jnb     short loc_560
.text:00000525                 lea     ecx, [ebp+var_88]
.text:0000052B                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00000530                 mov     esi, eax
.text:00000532                 lea     ecx, [ebp+var_88] ; this
.text:00000538                 call    ?Len@UString@@QBEIXZ ; UString::Len(void)
.text:0000053D                 sub     eax, [ebp+var_B4]
.text:00000543                 movzx   ecx, word ptr [esi+eax*2-2]
.text:00000548                 cmp     ecx, 61h ; 'a'
.text:0000054B                 jz      short loc_54F
.text:0000054D                 jmp     short loc_560
.text:0000054F ; ---------------------------------------------------------------------------
.text:0000054F
.text:0000054F loc_54F:                                ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+2A3j
.text:0000054F                 mov     edx, [ebp+var_B4]
.text:00000555                 add     edx, 1
.text:00000558                 mov     [ebp+var_B4], edx
.text:0000055E                 jmp     short loc_512
.text:00000560 ; ---------------------------------------------------------------------------
.text:00000560
.text:00000560 loc_560:                                ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+27Bj
.text:00000560                                         ; NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+2A5j
.text:00000560                 jmp     loc_6C5
.text:00000565 ; ---------------------------------------------------------------------------
.text:00000565
.text:00000565 loc_565:                                ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+242j
.text:00000565                                         ; NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+261j
.text:00000565                 lea     ecx, [ebp+var_74] ; this
.text:00000568                 call    ?Len@UString@@QBEIXZ ; UString::Len(void)
.text:0000056D                 cmp     eax, 2
.text:00000570                 jb      loc_65F
.text:00000576                 push    offset $SG69246 ; char *
.text:0000057B                 push    2               ; unsigned int
.text:0000057D                 lea     ecx, [ebp+var_88] ; this
.text:00000583                 call    ?RightPtr@UString@@QBEPB_WI@Z ; UString::RightPtr(uint)
.text:00000588                 push    eax             ; wchar_t *
.text:00000589                 call    ?StringsAreEqual_Ascii@@YG_NPB_WPBD@Z ; StringsAreEqual_Ascii(wchar_t const *,char const *)
.text:0000058E                 movzx   eax, al
.text:00000591                 test    eax, eax
.text:00000593                 jz      loc_65F
.text:00000599
.text:00000599 loc_599:                                ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+33Dj
.text:00000599                 lea     ecx, [ebp+var_88] ; this
.text:0000059F                 call    ?Len@UString@@QBEIXZ ; UString::Len(void)
.text:000005A4                 cmp     [ebp+var_B4], eax
.text:000005AA                 jnb     short loc_5E7
.text:000005AC                 lea     ecx, [ebp+var_88]
.text:000005B2                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000005B7                 mov     esi, eax
.text:000005B9                 lea     ecx, [ebp+var_88] ; this
.text:000005BF                 call    ?Len@UString@@QBEIXZ ; UString::Len(void)
.text:000005C4                 sub     eax, [ebp+var_B4]
.text:000005CA                 movzx   ecx, word ptr [esi+eax*2-2]
.text:000005CF                 cmp     ecx, 30h ; '0'
.text:000005D2                 jz      short loc_5D6
.text:000005D4                 jmp     short loc_5E7
.text:000005D6 ; ---------------------------------------------------------------------------
.text:000005D6
.text:000005D6 loc_5D6:                                ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+32Aj
.text:000005D6                 mov     edx, [ebp+var_B4]
.text:000005DC                 add     edx, 1
.text:000005DF                 mov     [ebp+var_B4], edx
.text:000005E5                 jmp     short loc_599
.text:000005E7 ; ---------------------------------------------------------------------------
.text:000005E7
.text:000005E7 loc_5E7:                                ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+302j
.text:000005E7                                         ; NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+32Cj
.text:000005E7                 lea     ecx, [ebp+var_74] ; this
.text:000005EA                 call    ?Len@UString@@QBEIXZ ; UString::Len(void)
.text:000005EF                 cmp     [ebp+var_B4], eax
.text:000005F5                 jz      short loc_65D
.text:000005F7                 mov     [ebp+var_154], 1
.text:00000601                 mov     byte ptr [ebp+var_4], 5
.text:00000605                 lea     ecx, [ebp+var_AC] ; this
.text:0000060B                 call    ??1CSeqName@NSplit@NArchive@@QAE@XZ ; NArchive::NSplit::CSeqName::~CSeqName(void)
.text:00000610                 mov     byte ptr [ebp+var_4], 4
.text:00000614                 lea     ecx, [ebp+var_88] ; this
.text:0000061A                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000061F                 mov     byte ptr [ebp+var_4], 3
.text:00000623                 lea     ecx, [ebp+var_74] ; this
.text:00000626                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000062B                 mov     byte ptr [ebp+var_4], 1
.text:0000062F                 lea     ecx, [ebp+var_60] ; this
.text:00000632                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000637                 mov     byte ptr [ebp+var_4], 0
.text:0000063B                 lea     ecx, [ebp+var_2C] ; this
.text:0000063E                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000643                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000064A                 lea     ecx, [ebp+var_18]
.text:0000064D                 call    ??1?$CMyComPtr@UIArchiveOpenVolumeCallback@@@@QAE@XZ ; CMyComPtr<IArchiveOpenVolumeCallback>::~CMyComPtr<IArchiveOpenVolumeCallback>(void)
.text:00000652                 mov     eax, [ebp+var_154]
.text:00000658                 jmp     loc_F99
.text:0000065D ; ---------------------------------------------------------------------------
.text:0000065D
.text:0000065D loc_65D:                                ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+34Dj
.text:0000065D                 jmp     short loc_6C5
.text:0000065F ; ---------------------------------------------------------------------------
.text:0000065F
.text:0000065F loc_65F:                                ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+2C8j
.text:0000065F                                         ; NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+2EBj
.text:0000065F                 mov     [ebp+var_158], 1
.text:00000669                 mov     byte ptr [ebp+var_4], 5
.text:0000066D                 lea     ecx, [ebp+var_AC] ; this
.text:00000673                 call    ??1CSeqName@NSplit@NArchive@@QAE@XZ ; NArchive::NSplit::CSeqName::~CSeqName(void)
.text:00000678                 mov     byte ptr [ebp+var_4], 4
.text:0000067C                 lea     ecx, [ebp+var_88] ; this
.text:00000682                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000687                 mov     byte ptr [ebp+var_4], 3
.text:0000068B                 lea     ecx, [ebp+var_74] ; this
.text:0000068E                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000693                 mov     byte ptr [ebp+var_4], 1
.text:00000697                 lea     ecx, [ebp+var_60] ; this
.text:0000069A                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000069F                 mov     byte ptr [ebp+var_4], 0
.text:000006A3                 lea     ecx, [ebp+var_2C] ; this
.text:000006A6                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000006AB                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000006B2                 lea     ecx, [ebp+var_18]
.text:000006B5                 call    ??1?$CMyComPtr@UIArchiveOpenVolumeCallback@@@@QAE@XZ ; CMyComPtr<IArchiveOpenVolumeCallback>::~CMyComPtr<IArchiveOpenVolumeCallback>(void)
.text:000006BA                 mov     eax, [ebp+var_158]
.text:000006C0                 jmp     loc_F99
.text:000006C5 ; ---------------------------------------------------------------------------
.text:000006C5
.text:000006C5 loc_6C5:                                ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *):loc_560j
.text:000006C5                                         ; NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *):loc_65Dj
.text:000006C5                 lea     ecx, [ebp+var_88] ; this
.text:000006CB                 call    ?Len@UString@@QBEIXZ ; UString::Len(void)
.text:000006D0                 sub     eax, [ebp+var_B4]
.text:000006D6                 push    eax
.text:000006D7                 lea     eax, [ebp+var_164]
.text:000006DD                 push    eax
.text:000006DE                 lea     ecx, [ebp+var_74]
.text:000006E1                 call    ?Left@UString@@QBE?AV1@I@Z ; UString::Left(uint)
.text:000006E6                 mov     [ebp+var_1A0], eax
.text:000006EC                 mov     ecx, [ebp+var_1A0]
.text:000006F2                 mov     [ebp+var_1A4], ecx
.text:000006F8                 mov     byte ptr [ebp+var_4], 7
.text:000006FC                 mov     edx, [ebp+var_1A4]
.text:00000702                 push    edx
.text:00000703                 lea     eax, [ebp+var_60]
.text:00000706                 push    eax
.text:00000707                 lea     ecx, [ebp+var_170]
.text:0000070D                 push    ecx
.text:0000070E                 call    ??H@YG?AVUString@@ABV0@0@Z ; operator+(UString const &,UString const &)
.text:00000713                 mov     [ebp+var_1A8], eax
.text:00000719                 mov     edx, [ebp+var_1A8]
.text:0000071F                 mov     [ebp+var_1AC], edx
.text:00000725                 mov     byte ptr [ebp+var_4], 8
.text:00000729                 mov     eax, [ebp+var_1AC]
.text:0000072F                 push    eax
.text:00000730                 lea     ecx, [ebp+var_AC]
.text:00000736                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:0000073B                 mov     byte ptr [ebp+var_4], 7
.text:0000073F                 lea     ecx, [ebp+var_170] ; this
.text:00000745                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000074A                 mov     byte ptr [ebp+var_4], 6
.text:0000074E                 lea     ecx, [ebp+var_164] ; this
.text:00000754                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000759                 mov     ecx, [ebp+var_B4]
.text:0000075F                 push    ecx             ; unsigned int
.text:00000760                 lea     ecx, [ebp+var_74] ; this
.text:00000763                 call    ?RightPtr@UString@@QBEPB_WI@Z ; UString::RightPtr(uint)
.text:00000768                 push    eax
.text:00000769                 lea     ecx, [ebp+var_A0]
.text:0000076F                 call    ??4UString@@QAEAAV0@PB_W@Z ; UString::operator=(wchar_t const *)
.text:00000774                 mov     dl, [ebp+var_B5]
.text:0000077A                 mov     [ebp+var_94], dl
.text:00000780                 lea     ecx, [ebp+var_60] ; this
.text:00000783                 call    ?Len@UString@@QBEIXZ ; UString::Len(void)
.text:00000788                 cmp     eax, 1
.text:0000078B                 jnb     short loc_79F
.text:0000078D                 push    offset $SG69260 ; "file"
.text:00000792                 mov     ecx, [ebp+var_10]
.text:00000795                 add     ecx, 24h ; '$'  ; this
.text:00000798                 call    ?SetFromAscii@UString@@QAEXPBD@Z ; UString::SetFromAscii(char const *)
.text:0000079D                 jmp     short loc_7BF
.text:0000079F ; ---------------------------------------------------------------------------
.text:0000079F
.text:0000079F loc_79F:                                ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+4E3j
.text:0000079F                 lea     ecx, [ebp+var_60] ; this
.text:000007A2                 call    ?Len@UString@@QBEIXZ ; UString::Len(void)
.text:000007A7                 sub     eax, 1
.text:000007AA                 push    eax             ; unsigned int
.text:000007AB                 lea     ecx, [ebp+var_60]
.text:000007AE                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000007B3                 push    eax             ; wchar_t *
.text:000007B4                 mov     ecx, [ebp+var_10]
.text:000007B7                 add     ecx, 24h ; '$'  ; this
.text:000007BA                 call    ?SetFrom@UString@@QAEXPB_WI@Z ; UString::SetFrom(wchar_t const *,uint)
.text:000007BF
.text:000007BF loc_7BF:                                ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+4F5j
.text:000007BF                 lea     ecx, [ebp+var_D4] ; this
.text:000007C5                 call    ??0CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::CPropVariant(void)
.text:000007CA                 mov     byte ptr [ebp+var_4], 9
.text:000007CE                 lea     ecx, [ebp+var_18]
.text:000007D1                 call    ??C?$CMyComPtr@UIArchiveOpenVolumeCallback@@@@QBEPAUIArchiveOpenVolumeCallback@@XZ ; CMyComPtr<IArchiveOpenVolumeCallback>::operator->(void)
.text:000007D6                 mov     [ebp+var_1B0], eax
.text:000007DC                 mov     esi, esp
.text:000007DE                 lea     eax, [ebp+var_D4]
.text:000007E4                 push    eax
.text:000007E5                 push    7
.text:000007E7                 mov     ecx, [ebp+var_1B0]
.text:000007ED                 push    ecx
.text:000007EE                 mov     edx, [ebp+var_1B0]
.text:000007F4                 mov     eax, [edx]
.text:000007F6                 mov     ecx, [eax+0Ch]
.text:000007F9                 call    ecx
.text:000007FB                 cmp     esi, esp
.text:000007FD                 call    __RTC_CheckEsp
.text:00000802                 mov     [ebp+var_DC], eax
.text:00000808                 cmp     [ebp+var_DC], 0
.text:0000080F                 jz      short loc_888
.text:00000811                 mov     edx, [ebp+var_DC]
.text:00000817                 mov     [ebp+var_174], edx
.text:0000081D                 mov     byte ptr [ebp+var_4], 6
.text:00000821                 lea     ecx, [ebp+var_D4] ; this
.text:00000827                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:0000082C                 mov     byte ptr [ebp+var_4], 5
.text:00000830                 lea     ecx, [ebp+var_AC] ; this
.text:00000836                 call    ??1CSeqName@NSplit@NArchive@@QAE@XZ ; NArchive::NSplit::CSeqName::~CSeqName(void)
.text:0000083B                 mov     byte ptr [ebp+var_4], 4
.text:0000083F                 lea     ecx, [ebp+var_88] ; this
.text:00000845                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000084A                 mov     byte ptr [ebp+var_4], 3
.text:0000084E                 lea     ecx, [ebp+var_74] ; this
.text:00000851                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000856                 mov     byte ptr [ebp+var_4], 1
.text:0000085A                 lea     ecx, [ebp+var_60] ; this
.text:0000085D                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000862                 mov     byte ptr [ebp+var_4], 0
.text:00000866                 lea     ecx, [ebp+var_2C] ; this
.text:00000869                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000086E                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000875                 lea     ecx, [ebp+var_18]
.text:00000878                 call    ??1?$CMyComPtr@UIArchiveOpenVolumeCallback@@@@QAE@XZ ; CMyComPtr<IArchiveOpenVolumeCallback>::~CMyComPtr<IArchiveOpenVolumeCallback>(void)
.text:0000087D                 mov     eax, [ebp+var_174]
.text:00000883                 jmp     loc_F99
.text:00000888 ; ---------------------------------------------------------------------------
.text:00000888
.text:00000888 loc_888:                                ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+567j
.text:00000888                 movzx   eax, [ebp+var_D4]
.text:0000088F                 cmp     eax, 15h
.text:00000892                 jz      short loc_909
.text:00000894                 mov     [ebp+var_178], 80070057h
.text:0000089E                 mov     byte ptr [ebp+var_4], 6
.text:000008A2                 lea     ecx, [ebp+var_D4] ; this
.text:000008A8                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:000008AD                 mov     byte ptr [ebp+var_4], 5
.text:000008B1                 lea     ecx, [ebp+var_AC] ; this
.text:000008B7                 call    ??1CSeqName@NSplit@NArchive@@QAE@XZ ; NArchive::NSplit::CSeqName::~CSeqName(void)
.text:000008BC                 mov     byte ptr [ebp+var_4], 4
.text:000008C0                 lea     ecx, [ebp+var_88] ; this
.text:000008C6                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000008CB                 mov     byte ptr [ebp+var_4], 3
.text:000008CF                 lea     ecx, [ebp+var_74] ; this
.text:000008D2                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000008D7                 mov     byte ptr [ebp+var_4], 1
.text:000008DB                 lea     ecx, [ebp+var_60] ; this
.text:000008DE                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000008E3                 mov     byte ptr [ebp+var_4], 0
.text:000008E7                 lea     ecx, [ebp+var_2C] ; this
.text:000008EA                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000008EF                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000008F6                 lea     ecx, [ebp+var_18]
.text:000008F9                 call    ??1?$CMyComPtr@UIArchiveOpenVolumeCallback@@@@QAE@XZ ; CMyComPtr<IArchiveOpenVolumeCallback>::~CMyComPtr<IArchiveOpenVolumeCallback>(void)
.text:000008FE                 mov     eax, [ebp+var_178]
.text:00000904                 jmp     loc_F99
.text:00000909 ; ---------------------------------------------------------------------------
.text:00000909
.text:00000909 loc_909:                                ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+5EAj
.text:00000909                 mov     ecx, [ebp+var_CC]
.text:0000090F                 mov     [ebp+var_C0], ecx
.text:00000915                 mov     edx, [ebp+var_C8]
.text:0000091B                 mov     [ebp+var_BC], edx
.text:00000921                 mov     byte ptr [ebp+var_4], 6
.text:00000925                 lea     ecx, [ebp+var_D4] ; this
.text:0000092B                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:00000930                 mov     eax, [ebp+var_10]
.text:00000933                 mov     ecx, [eax+30h]
.text:00000936                 add     ecx, [ebp+var_C0]
.text:0000093C                 mov     edx, [eax+34h]
.text:0000093F                 adc     edx, [ebp+var_BC]
.text:00000945                 mov     eax, [ebp+var_10]
.text:00000948                 mov     [eax+30h], ecx
.text:0000094B                 mov     [eax+34h], edx
.text:0000094E                 mov     ecx, [ebp+var_BC]
.text:00000954                 push    ecx
.text:00000955                 mov     edx, [ebp+var_C0]
.text:0000095B                 push    edx
.text:0000095C                 mov     ecx, [ebp+var_10]
.text:0000095F                 add     ecx, 18h
.text:00000962                 call    ?Add@?$CRecordVector@_K@@QAEI_K@Z ; CRecordVector<unsigned __int64>::Add(unsigned __int64)
.text:00000967                 mov     eax, [ebp+arg_0]
.text:0000096A                 push    eax
.text:0000096B                 lea     ecx, [ebp+var_17C]
.text:00000971                 call    ??0?$CMyComPtr@UIInStream@@@@QAE@PAUIInStream@@@Z ; CMyComPtr<IInStream>::CMyComPtr<IInStream>(IInStream *)
.text:00000976                 mov     byte ptr [ebp+var_4], 0Ah
.text:0000097A                 lea     ecx, [ebp+var_17C]
.text:00000980                 push    ecx
.text:00000981                 mov     ecx, [ebp+var_10]
.text:00000984                 add     ecx, 0Ch
.text:00000987                 call    ?Add@?$CObjectVector@V?$CMyComPtr@UIInStream@@@@@@QAEIABV?$CMyComPtr@UIInStream@@@@@Z ; CObjectVector<CMyComPtr<IInStream>>::Add(CMyComPtr<IInStream> const &)
.text:0000098C                 mov     byte ptr [ebp+var_4], 6
.text:00000990                 lea     ecx, [ebp+var_17C]
.text:00000996                 call    ??1?$CMyComPtr@UIInStream@@@@QAE@XZ ; CMyComPtr<IInStream>::~CMyComPtr<IInStream>(void)
.text:0000099B                 mov     ecx, [ebp+var_10]
.text:0000099E                 add     ecx, 0Ch
.text:000009A1                 call    ?Size@?$CObjectVector@V?$CMyComPtr@UIInStream@@@@@@QBEIXZ ; CObjectVector<CMyComPtr<IInStream>>::Size(void)
.text:000009A6                 xor     edx, edx
.text:000009A8                 mov     [ebp+var_E8], eax
.text:000009AE                 mov     [ebp+var_E4], edx
.text:000009B4                 mov     esi, esp
.text:000009B6                 push    0
.text:000009B8                 lea     eax, [ebp+var_E8]
.text:000009BE                 push    eax
.text:000009BF                 mov     ecx, [ebp+arg_4]
.text:000009C2                 mov     edx, [ecx]
.text:000009C4                 mov     eax, [ebp+arg_4]
.text:000009C7                 push    eax
.text:000009C8                 mov     ecx, [edx+10h]
.text:000009CB                 call    ecx
.text:000009CD                 cmp     esi, esp
.text:000009CF                 call    __RTC_CheckEsp
.text:000009D4                 mov     [ebp+var_F0], eax
.text:000009DA                 cmp     [ebp+var_F0], 0
.text:000009E1                 jz      short loc_A4B
.text:000009E3                 mov     edx, [ebp+var_F0]
.text:000009E9                 mov     [ebp+var_180], edx
.text:000009EF                 mov     byte ptr [ebp+var_4], 5
.text:000009F3                 lea     ecx, [ebp+var_AC] ; this
.text:000009F9                 call    ??1CSeqName@NSplit@NArchive@@QAE@XZ ; NArchive::NSplit::CSeqName::~CSeqName(void)
.text:000009FE                 mov     byte ptr [ebp+var_4], 4
.text:00000A02                 lea     ecx, [ebp+var_88] ; this
.text:00000A08                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000A0D                 mov     byte ptr [ebp+var_4], 3
.text:00000A11                 lea     ecx, [ebp+var_74] ; this
.text:00000A14                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000A19                 mov     byte ptr [ebp+var_4], 1
.text:00000A1D                 lea     ecx, [ebp+var_60] ; this
.text:00000A20                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000A25                 mov     byte ptr [ebp+var_4], 0
.text:00000A29                 lea     ecx, [ebp+var_2C] ; this
.text:00000A2C                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000A31                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000A38                 lea     ecx, [ebp+var_18]
.text:00000A3B                 call    ??1?$CMyComPtr@UIArchiveOpenVolumeCallback@@@@QAE@XZ ; CMyComPtr<IArchiveOpenVolumeCallback>::~CMyComPtr<IArchiveOpenVolumeCallback>(void)
.text:00000A40                 mov     eax, [ebp+var_180]
.text:00000A46                 jmp     loc_F99
.text:00000A4B ; ---------------------------------------------------------------------------
.text:00000A4B
.text:00000A4B loc_A4B:                                ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+739j
.text:00000A4B                                         ; NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+C0Dj
.text:00000A4B                 lea     ecx, [ebp+var_100]
.text:00000A51                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00000A56                 mov     byte ptr [ebp+var_4], 0Bh
.text:00000A5A                 lea     eax, [ebp+var_100]
.text:00000A60                 push    eax             ; struct UString *
.text:00000A61                 lea     ecx, [ebp+var_AC] ; this
.text:00000A67                 call    ?GetNextName@CSeqName@NSplit@NArchive@@QAE_NAAVUString@@@Z ; NArchive::NSplit::CSeqName::GetNextName(UString &)
.text:00000A6C                 movzx   ecx, al
.text:00000A6F                 test    ecx, ecx
.text:00000A71                 jnz     short loc_A87
.text:00000A73                 mov     byte ptr [ebp+var_4], 6
.text:00000A77                 lea     ecx, [ebp+var_100] ; this
.text:00000A7D                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000A82                 jmp     loc_EBA
.text:00000A87 ; ---------------------------------------------------------------------------
.text:00000A87
.text:00000A87 loc_A87:                                ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+7C9j
.text:00000A87                 lea     ecx, [ebp+var_10C]
.text:00000A8D                 call    ??0?$CMyComPtr@UIInStream@@@@QAE@XZ ; CMyComPtr<IInStream>::CMyComPtr<IInStream>(void)
.text:00000A92                 mov     byte ptr [ebp+var_4], 0Ch
.text:00000A96                 lea     ecx, [ebp+var_18]
.text:00000A99                 call    ??C?$CMyComPtr@UIArchiveOpenVolumeCallback@@@@QBEPAUIArchiveOpenVolumeCallback@@XZ ; CMyComPtr<IArchiveOpenVolumeCallback>::operator->(void)
.text:00000A9E                 mov     [ebp+var_1B4], eax
.text:00000AA4                 lea     ecx, [ebp+var_10C]
.text:00000AAA                 call    ??I?$CMyComPtr@UIInStream@@@@QAEPAPAUIInStream@@XZ ; CMyComPtr<IInStream>::operator&(void)
.text:00000AAF                 mov     esi, esp
.text:00000AB1                 push    eax
.text:00000AB2                 lea     ecx, [ebp+var_100]
.text:00000AB8                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00000ABD                 push    eax
.text:00000ABE                 mov     edx, [ebp+var_1B4]
.text:00000AC4                 push    edx
.text:00000AC5                 mov     eax, [ebp+var_1B4]
.text:00000ACB                 mov     ecx, [eax]
.text:00000ACD                 mov     edx, [ecx+10h]
.text:00000AD0                 call    edx
.text:00000AD2                 cmp     esi, esp
.text:00000AD4                 call    __RTC_CheckEsp
.text:00000AD9                 mov     [ebp+var_114], eax
.text:00000ADF                 cmp     [ebp+var_114], 1
.text:00000AE6                 jnz     short loc_B0B
.text:00000AE8                 mov     byte ptr [ebp+var_4], 0Bh
.text:00000AEC                 lea     ecx, [ebp+var_10C]
.text:00000AF2                 call    ??1?$CMyComPtr@UIInStream@@@@QAE@XZ ; CMyComPtr<IInStream>::~CMyComPtr<IInStream>(void)
.text:00000AF7                 mov     byte ptr [ebp+var_4], 6
.text:00000AFB                 lea     ecx, [ebp+var_100] ; this
.text:00000B01                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000B06                 jmp     loc_EBA
.text:00000B0B ; ---------------------------------------------------------------------------
.text:00000B0B
.text:00000B0B loc_B0B:                                ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+83Ej
.text:00000B0B                 cmp     [ebp+var_114], 0
.text:00000B12                 jz      loc_B9E
.text:00000B18                 mov     eax, [ebp+var_114]
.text:00000B1E                 mov     [ebp+var_184], eax
.text:00000B24                 mov     byte ptr [ebp+var_4], 0Bh
.text:00000B28                 lea     ecx, [ebp+var_10C]
.text:00000B2E                 call    ??1?$CMyComPtr@UIInStream@@@@QAE@XZ ; CMyComPtr<IInStream>::~CMyComPtr<IInStream>(void)
.text:00000B33                 mov     byte ptr [ebp+var_4], 6
.text:00000B37                 lea     ecx, [ebp+var_100] ; this
.text:00000B3D                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000B42                 mov     byte ptr [ebp+var_4], 5
.text:00000B46                 lea     ecx, [ebp+var_AC] ; this
.text:00000B4C                 call    ??1CSeqName@NSplit@NArchive@@QAE@XZ ; NArchive::NSplit::CSeqName::~CSeqName(void)
.text:00000B51                 mov     byte ptr [ebp+var_4], 4
.text:00000B55                 lea     ecx, [ebp+var_88] ; this
.text:00000B5B                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000B60                 mov     byte ptr [ebp+var_4], 3
.text:00000B64                 lea     ecx, [ebp+var_74] ; this
.text:00000B67                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000B6C                 mov     byte ptr [ebp+var_4], 1
.text:00000B70                 lea     ecx, [ebp+var_60] ; this
.text:00000B73                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000B78                 mov     byte ptr [ebp+var_4], 0
.text:00000B7C                 lea     ecx, [ebp+var_2C] ; this
.text:00000B7F                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000B84                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000B8B                 lea     ecx, [ebp+var_18]
.text:00000B8E                 call    ??1?$CMyComPtr@UIArchiveOpenVolumeCallback@@@@QAE@XZ ; CMyComPtr<IArchiveOpenVolumeCallback>::~CMyComPtr<IArchiveOpenVolumeCallback>(void)
.text:00000B93                 mov     eax, [ebp+var_184]
.text:00000B99                 jmp     loc_F99
.text:00000B9E ; ---------------------------------------------------------------------------
.text:00000B9E
.text:00000B9E loc_B9E:                                ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+86Aj
.text:00000B9E                 cmp     [ebp+arg_0], 0
.text:00000BA2                 jnz     short loc_BC7
.text:00000BA4                 mov     byte ptr [ebp+var_4], 0Bh
.text:00000BA8                 lea     ecx, [ebp+var_10C]
.text:00000BAE                 call    ??1?$CMyComPtr@UIInStream@@@@QAE@XZ ; CMyComPtr<IInStream>::~CMyComPtr<IInStream>(void)
.text:00000BB3                 mov     byte ptr [ebp+var_4], 6
.text:00000BB7                 lea     ecx, [ebp+var_100] ; this
.text:00000BBD                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000BC2                 jmp     loc_EBA
.text:00000BC7 ; ---------------------------------------------------------------------------
.text:00000BC7
.text:00000BC7 loc_BC7:                                ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+8FAj
.text:00000BC7                 lea     ecx, [ebp+var_128] ; this
.text:00000BCD                 call    ??0CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::CPropVariant(void)
.text:00000BD2                 mov     byte ptr [ebp+var_4], 0Dh
.text:00000BD6                 lea     ecx, [ebp+var_18]
.text:00000BD9                 call    ??C?$CMyComPtr@UIArchiveOpenVolumeCallback@@@@QBEPAUIArchiveOpenVolumeCallback@@XZ ; CMyComPtr<IArchiveOpenVolumeCallback>::operator->(void)
.text:00000BDE                 mov     [ebp+var_1B8], eax
.text:00000BE4                 mov     esi, esp
.text:00000BE6                 lea     ecx, [ebp+var_128]
.text:00000BEC                 push    ecx
.text:00000BED                 push    7
.text:00000BEF                 mov     edx, [ebp+var_1B8]
.text:00000BF5                 push    edx
.text:00000BF6                 mov     eax, [ebp+var_1B8]
.text:00000BFC                 mov     ecx, [eax]
.text:00000BFE                 mov     edx, [ecx+0Ch]
.text:00000C01                 call    edx
.text:00000C03                 cmp     esi, esp
.text:00000C05                 call    __RTC_CheckEsp
.text:00000C0A                 mov     [ebp+var_130], eax
.text:00000C10                 cmp     [ebp+var_130], 0
.text:00000C17                 jz      loc_CB2
.text:00000C1D                 mov     eax, [ebp+var_130]
.text:00000C23                 mov     [ebp+var_188], eax
.text:00000C29                 mov     byte ptr [ebp+var_4], 0Ch
.text:00000C2D                 lea     ecx, [ebp+var_128] ; this
.text:00000C33                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:00000C38                 mov     byte ptr [ebp+var_4], 0Bh
.text:00000C3C                 lea     ecx, [ebp+var_10C]
.text:00000C42                 call    ??1?$CMyComPtr@UIInStream@@@@QAE@XZ ; CMyComPtr<IInStream>::~CMyComPtr<IInStream>(void)
.text:00000C47                 mov     byte ptr [ebp+var_4], 6
.text:00000C4B                 lea     ecx, [ebp+var_100] ; this
.text:00000C51                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000C56                 mov     byte ptr [ebp+var_4], 5
.text:00000C5A                 lea     ecx, [ebp+var_AC] ; this
.text:00000C60                 call    ??1CSeqName@NSplit@NArchive@@QAE@XZ ; NArchive::NSplit::CSeqName::~CSeqName(void)
.text:00000C65                 mov     byte ptr [ebp+var_4], 4
.text:00000C69                 lea     ecx, [ebp+var_88] ; this
.text:00000C6F                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000C74                 mov     byte ptr [ebp+var_4], 3
.text:00000C78                 lea     ecx, [ebp+var_74] ; this
.text:00000C7B                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000C80                 mov     byte ptr [ebp+var_4], 1
.text:00000C84                 lea     ecx, [ebp+var_60] ; this
.text:00000C87                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000C8C                 mov     byte ptr [ebp+var_4], 0
.text:00000C90                 lea     ecx, [ebp+var_2C] ; this
.text:00000C93                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000C98                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000C9F                 lea     ecx, [ebp+var_18]
.text:00000CA2                 call    ??1?$CMyComPtr@UIArchiveOpenVolumeCallback@@@@QAE@XZ ; CMyComPtr<IArchiveOpenVolumeCallback>::~CMyComPtr<IArchiveOpenVolumeCallback>(void)
.text:00000CA7                 mov     eax, [ebp+var_188]
.text:00000CAD                 jmp     loc_F99
.text:00000CB2 ; ---------------------------------------------------------------------------
.text:00000CB2
.text:00000CB2 loc_CB2:                                ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+96Fj
.text:00000CB2                 movzx   ecx, [ebp+var_128]
.text:00000CB9                 cmp     ecx, 15h
.text:00000CBC                 jz      loc_D55
.text:00000CC2                 mov     [ebp+var_18C], 80070057h
.text:00000CCC                 mov     byte ptr [ebp+var_4], 0Ch
.text:00000CD0                 lea     ecx, [ebp+var_128] ; this
.text:00000CD6                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:00000CDB                 mov     byte ptr [ebp+var_4], 0Bh
.text:00000CDF                 lea     ecx, [ebp+var_10C]
.text:00000CE5                 call    ??1?$CMyComPtr@UIInStream@@@@QAE@XZ ; CMyComPtr<IInStream>::~CMyComPtr<IInStream>(void)
.text:00000CEA                 mov     byte ptr [ebp+var_4], 6
.text:00000CEE                 lea     ecx, [ebp+var_100] ; this
.text:00000CF4                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000CF9                 mov     byte ptr [ebp+var_4], 5
.text:00000CFD                 lea     ecx, [ebp+var_AC] ; this
.text:00000D03                 call    ??1CSeqName@NSplit@NArchive@@QAE@XZ ; NArchive::NSplit::CSeqName::~CSeqName(void)
.text:00000D08                 mov     byte ptr [ebp+var_4], 4
.text:00000D0C                 lea     ecx, [ebp+var_88] ; this
.text:00000D12                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000D17                 mov     byte ptr [ebp+var_4], 3
.text:00000D1B                 lea     ecx, [ebp+var_74] ; this
.text:00000D1E                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000D23                 mov     byte ptr [ebp+var_4], 1
.text:00000D27                 lea     ecx, [ebp+var_60] ; this
.text:00000D2A                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000D2F                 mov     byte ptr [ebp+var_4], 0
.text:00000D33                 lea     ecx, [ebp+var_2C] ; this
.text:00000D36                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000D3B                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000D42                 lea     ecx, [ebp+var_18]
.text:00000D45                 call    ??1?$CMyComPtr@UIArchiveOpenVolumeCallback@@@@QAE@XZ ; CMyComPtr<IArchiveOpenVolumeCallback>::~CMyComPtr<IArchiveOpenVolumeCallback>(void)
.text:00000D4A                 mov     eax, [ebp+var_18C]
.text:00000D50                 jmp     loc_F99
.text:00000D55 ; ---------------------------------------------------------------------------
.text:00000D55
.text:00000D55 loc_D55:                                ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+A14j
.text:00000D55                 mov     edx, [ebp+var_120]
.text:00000D5B                 mov     [ebp+var_C0], edx
.text:00000D61                 mov     eax, [ebp+var_11C]
.text:00000D67                 mov     [ebp+var_BC], eax
.text:00000D6D                 mov     byte ptr [ebp+var_4], 0Ch
.text:00000D71                 lea     ecx, [ebp+var_128] ; this
.text:00000D77                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:00000D7C                 mov     ecx, [ebp+var_10]
.text:00000D7F                 mov     edx, [ecx+30h]
.text:00000D82                 add     edx, [ebp+var_C0]
.text:00000D88                 mov     eax, [ecx+34h]
.text:00000D8B                 adc     eax, [ebp+var_BC]
.text:00000D91                 mov     ecx, [ebp+var_10]
.text:00000D94                 mov     [ecx+30h], edx
.text:00000D97                 mov     [ecx+34h], eax
.text:00000D9A                 mov     edx, [ebp+var_BC]
.text:00000DA0                 push    edx
.text:00000DA1                 mov     eax, [ebp+var_C0]
.text:00000DA7                 push    eax
.text:00000DA8                 mov     ecx, [ebp+var_10]
.text:00000DAB                 add     ecx, 18h
.text:00000DAE                 call    ?Add@?$CRecordVector@_K@@QAEI_K@Z ; CRecordVector<unsigned __int64>::Add(unsigned __int64)
.text:00000DB3                 lea     ecx, [ebp+var_10C]
.text:00000DB9                 push    ecx
.text:00000DBA                 mov     ecx, [ebp+var_10]
.text:00000DBD                 add     ecx, 0Ch
.text:00000DC0                 call    ?Add@?$CObjectVector@V?$CMyComPtr@UIInStream@@@@@@QAEIABV?$CMyComPtr@UIInStream@@@@@Z ; CObjectVector<CMyComPtr<IInStream>>::Add(CMyComPtr<IInStream> const &)
.text:00000DC5                 mov     ecx, [ebp+var_10]
.text:00000DC8                 add     ecx, 0Ch
.text:00000DCB                 call    ?Size@?$CObjectVector@V?$CMyComPtr@UIInStream@@@@@@QBEIXZ ; CObjectVector<CMyComPtr<IInStream>>::Size(void)
.text:00000DD0                 xor     edx, edx
.text:00000DD2                 mov     [ebp+var_13C], eax
.text:00000DD8                 mov     [ebp+var_138], edx
.text:00000DDE                 mov     esi, esp
.text:00000DE0                 push    0
.text:00000DE2                 lea     eax, [ebp+var_13C]
.text:00000DE8                 push    eax
.text:00000DE9                 mov     ecx, [ebp+arg_4]
.text:00000DEC                 mov     edx, [ecx]
.text:00000DEE                 mov     eax, [ebp+arg_4]
.text:00000DF1                 push    eax
.text:00000DF2                 mov     ecx, [edx+10h]
.text:00000DF5                 call    ecx
.text:00000DF7                 cmp     esi, esp
.text:00000DF9                 call    __RTC_CheckEsp
.text:00000DFE                 mov     [ebp+var_144], eax
.text:00000E04                 cmp     [ebp+var_144], 0
.text:00000E0B                 jz      loc_E97
.text:00000E11                 mov     edx, [ebp+var_144]
.text:00000E17                 mov     [ebp+var_190], edx
.text:00000E1D                 mov     byte ptr [ebp+var_4], 0Bh
.text:00000E21                 lea     ecx, [ebp+var_10C]
.text:00000E27                 call    ??1?$CMyComPtr@UIInStream@@@@QAE@XZ ; CMyComPtr<IInStream>::~CMyComPtr<IInStream>(void)
.text:00000E2C                 mov     byte ptr [ebp+var_4], 6
.text:00000E30                 lea     ecx, [ebp+var_100] ; this
.text:00000E36                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000E3B                 mov     byte ptr [ebp+var_4], 5
.text:00000E3F                 lea     ecx, [ebp+var_AC] ; this
.text:00000E45                 call    ??1CSeqName@NSplit@NArchive@@QAE@XZ ; NArchive::NSplit::CSeqName::~CSeqName(void)
.text:00000E4A                 mov     byte ptr [ebp+var_4], 4
.text:00000E4E                 lea     ecx, [ebp+var_88] ; this
.text:00000E54                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000E59                 mov     byte ptr [ebp+var_4], 3
.text:00000E5D                 lea     ecx, [ebp+var_74] ; this
.text:00000E60                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000E65                 mov     byte ptr [ebp+var_4], 1
.text:00000E69                 lea     ecx, [ebp+var_60] ; this
.text:00000E6C                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000E71                 mov     byte ptr [ebp+var_4], 0
.text:00000E75                 lea     ecx, [ebp+var_2C] ; this
.text:00000E78                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000E7D                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000E84                 lea     ecx, [ebp+var_18]
.text:00000E87                 call    ??1?$CMyComPtr@UIArchiveOpenVolumeCallback@@@@QAE@XZ ; CMyComPtr<IArchiveOpenVolumeCallback>::~CMyComPtr<IArchiveOpenVolumeCallback>(void)
.text:00000E8C                 mov     eax, [ebp+var_190]
.text:00000E92                 jmp     loc_F99
.text:00000E97 ; ---------------------------------------------------------------------------
.text:00000E97
.text:00000E97 loc_E97:                                ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+B63j
.text:00000E97                 mov     byte ptr [ebp+var_4], 0Bh
.text:00000E9B                 lea     ecx, [ebp+var_10C]
.text:00000EA1                 call    ??1?$CMyComPtr@UIInStream@@@@QAE@XZ ; CMyComPtr<IInStream>::~CMyComPtr<IInStream>(void)
.text:00000EA6                 mov     byte ptr [ebp+var_4], 6
.text:00000EAA                 lea     ecx, [ebp+var_100] ; this
.text:00000EB0                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000EB5                 jmp     loc_A4B
.text:00000EBA ; ---------------------------------------------------------------------------
.text:00000EBA
.text:00000EBA loc_EBA:                                ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+7DAj
.text:00000EBA                                         ; NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+85Ej ...
.text:00000EBA                 mov     ecx, [ebp+var_10]
.text:00000EBD                 add     ecx, 0Ch
.text:00000EC0                 call    ?Size@?$CObjectVector@V?$CMyComPtr@UIInStream@@@@@@QBEIXZ ; CObjectVector<CMyComPtr<IInStream>>::Size(void)
.text:00000EC5                 cmp     eax, 1
.text:00000EC8                 jnz     short loc_F38
.text:00000ECA                 movzx   eax, [ebp+var_B5]
.text:00000ED1                 test    eax, eax
.text:00000ED3                 jz      short loc_F38
.text:00000ED5                 mov     [ebp+var_194], 1
.text:00000EDF                 mov     byte ptr [ebp+var_4], 5
.text:00000EE3                 lea     ecx, [ebp+var_AC] ; this
.text:00000EE9                 call    ??1CSeqName@NSplit@NArchive@@QAE@XZ ; NArchive::NSplit::CSeqName::~CSeqName(void)
.text:00000EEE                 mov     byte ptr [ebp+var_4], 4
.text:00000EF2                 lea     ecx, [ebp+var_88] ; this
.text:00000EF8                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000EFD                 mov     byte ptr [ebp+var_4], 3
.text:00000F01                 lea     ecx, [ebp+var_74] ; this
.text:00000F04                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000F09                 mov     byte ptr [ebp+var_4], 1
.text:00000F0D                 lea     ecx, [ebp+var_60] ; this
.text:00000F10                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000F15                 mov     byte ptr [ebp+var_4], 0
.text:00000F19                 lea     ecx, [ebp+var_2C] ; this
.text:00000F1C                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000F21                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000F28                 lea     ecx, [ebp+var_18]
.text:00000F2B                 call    ??1?$CMyComPtr@UIArchiveOpenVolumeCallback@@@@QAE@XZ ; CMyComPtr<IArchiveOpenVolumeCallback>::~CMyComPtr<IArchiveOpenVolumeCallback>(void)
.text:00000F30                 mov     eax, [ebp+var_194]
.text:00000F36                 jmp     short loc_F99
.text:00000F38 ; ---------------------------------------------------------------------------
.text:00000F38
.text:00000F38 loc_F38:                                ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+C20j
.text:00000F38                                         ; NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+C2Bj
.text:00000F38                 mov     [ebp+var_198], 0
.text:00000F42                 mov     byte ptr [ebp+var_4], 5
.text:00000F46                 lea     ecx, [ebp+var_AC] ; this
.text:00000F4C                 call    ??1CSeqName@NSplit@NArchive@@QAE@XZ ; NArchive::NSplit::CSeqName::~CSeqName(void)
.text:00000F51                 mov     byte ptr [ebp+var_4], 4
.text:00000F55                 lea     ecx, [ebp+var_88] ; this
.text:00000F5B                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000F60                 mov     byte ptr [ebp+var_4], 3
.text:00000F64                 lea     ecx, [ebp+var_74] ; this
.text:00000F67                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000F6C                 mov     byte ptr [ebp+var_4], 1
.text:00000F70                 lea     ecx, [ebp+var_60] ; this
.text:00000F73                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000F78                 mov     byte ptr [ebp+var_4], 0
.text:00000F7C                 lea     ecx, [ebp+var_2C] ; this
.text:00000F7F                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000F84                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000F8B                 lea     ecx, [ebp+var_18]
.text:00000F8E                 call    ??1?$CMyComPtr@UIArchiveOpenVolumeCallback@@@@QAE@XZ ; CMyComPtr<IArchiveOpenVolumeCallback>::~CMyComPtr<IArchiveOpenVolumeCallback>(void)
.text:00000F93                 mov     eax, [ebp+var_198]
.text:00000F99
.text:00000F99 loc_F99:                                ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+63j
.text:00000F99                                         ; NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+C9j ...
.text:00000F99                 push    edx
.text:00000F9A                 mov     ecx, ebp
.text:00000F9C                 push    eax
.text:00000F9D                 lea     edx, $LN63
.text:00000FA3                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00000FA8                 pop     eax
.text:00000FA9                 pop     edx
.text:00000FAA                 mov     ecx, [ebp+var_C]
.text:00000FAD                 mov     large fs:0, ecx
.text:00000FB4                 pop     ecx
.text:00000FB5                 pop     edi
.text:00000FB6                 pop     esi
.text:00000FB7                 add     esp, 1B8h
.text:00000FBD                 cmp     ebp, esp
.text:00000FBF                 call    __RTC_CheckEsp
.text:00000FC4                 mov     esp, ebp
.text:00000FC6                 pop     ebp
.text:00000FC7                 retn    8
.text:00000FC7 ?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z endp
.text:00000FC7
.text:00000FC7 ; ---------------------------------------------------------------------------
.text:00000FCA                 align 4
.text:00000FCC $LN63           dd 0Dh                  ; DATA XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+CF5o
.text:00000FD0                 dd offset $LN62
.text:00000FD4 $LN62           dd 0FFFFFFE8h, 4        ; DATA XREF: .text:00000FD0o
.text:00000FDC                 dd offset $LN48         ; "volumeCallback"
.text:00000FE0                 dd 0FFFFFFD4h, 0Ch
.text:00000FE8                 dd offset $LN49         ; "name"
.text:00000FEC                 dd 0FFFFFFBCh, 10h
.text:00000FF4                 dd offset $LN50         ; "prop"
.text:00000FF8                 dd 0FFFFFFA0h, 0Ch
.text:00001000                 dd offset $LN51         ; "prefix"
.text:00001004                 dd 0FFFFFF8Ch, 0Ch
.text:0000100C                 dd offset $LN52         ; "ext"
.text:00001010                 dd 0FFFFFF78h, 0Ch
.text:00001018                 dd offset $LN53         ; "ext2"
.text:0000101C                 dd 0FFFFFF54h, 1Ch
.text:00001024                 dd offset $LN54         ; "seqName"
.text:00001028                 dd 0FFFFFF2Ch, 10h
.text:00001030                 dd offset $LN55         ; "prop"
.text:00001034                 dd 0FFFFFF18h, 8
.text:0000103C                 dd offset $LN56         ; "numFiles"
.text:00001040                 dd 0FFFFFF00h, 0Ch
.text:00001048                 dd offset $LN57         ; "fullName"
.text:0000104C                 dd 0FFFFFEF4h, 4
.text:00001054                 dd offset $LN58         ; "nextStream"
.text:00001058                 dd 0FFFFFED8h, 10h
.text:00001060                 dd offset $LN59         ; "prop"
.text:00001064                 dd 0FFFFFEC4h, 8
.text:0000106C                 dd offset $LN60         ; "numFiles"
.text:00001070 $LN60           db 'numFiles',0         ; DATA XREF: .text:0000106Co
.text:00001079 $LN59           db 'prop',0             ; DATA XREF: .text:00001060o
.text:0000107E $LN58           db 'nextStream',0       ; DATA XREF: .text:00001054o
.text:00001089 $LN57           db 'fullName',0         ; DATA XREF: .text:00001048o
.text:00001092 $LN56           db 'numFiles',0         ; DATA XREF: .text:0000103Co
.text:0000109B $LN55           db 'prop',0             ; DATA XREF: .text:00001030o
.text:000010A0 $LN54           db 'seqName',0          ; DATA XREF: .text:00001024o
.text:000010A8 $LN53           db 'ext2',0             ; DATA XREF: .text:00001018o
.text:000010AD $LN52           db 'ext',0              ; DATA XREF: .text:0000100Co
.text:000010B1 $LN51           db 'prefix',0           ; DATA XREF: .text:00001000o
.text:000010B8 $LN50           db 'prop',0             ; DATA XREF: .text:00000FF4o
.text:000010BD $LN49           db 'name',0             ; DATA XREF: .text:00000FE8o
.text:000010C2 $LN48           db 'volumeCallback',0   ; DATA XREF: .text:00000FDCo
.text:000010D1                 align 8
.text:000010D8
.text:000010D8 ; =============== S U B R O U T I N E =======================================
.text:000010D8
.text:000010D8 ; Attributes: bp-based frame
.text:000010D8
.text:000010D8 ; __int32 __cdecl NArchive::NSplit::CHandler::Open(NArchive::NSplit::CHandler *this, struct IInStream *, const unsigned __int64 *, struct IArchiveOpenCallback *)
.text:000010D8                 public ?Open@CHandler@NSplit@NArchive@@UAGJPAUIInStream@@PB_KPAUIArchiveOpenCallback@@@Z
.text:000010D8 ?Open@CHandler@NSplit@NArchive@@UAGJPAUIInStream@@PB_KPAUIArchiveOpenCallback@@@Z proc near
.text:000010D8                                         ; DATA XREF: .rdata:0000327Co
.text:000010D8
.text:000010D8 var_1C          = dword ptr -1Ch
.text:000010D8 var_18          = dword ptr -18h
.text:000010D8 var_14          = dword ptr -14h
.text:000010D8 var_10          = dword ptr -10h
.text:000010D8 var_C           = dword ptr -0Ch
.text:000010D8 var_4           = dword ptr -4
.text:000010D8 this            = dword ptr  8
.text:000010D8 arg_4           = dword ptr  0Ch
.text:000010D8 arg_C           = dword ptr  14h
.text:000010D8
.text:000010D8 ; FUNCTION CHUNK AT .text:00001181 SIZE 0000001E BYTES
.text:000010D8
.text:000010D8                 push    ebp
.text:000010D9                 mov     ebp, esp
.text:000010DB                 push    0FFFFFFFFh
.text:000010DD                 push    offset __ehhandler$?Open@CHandler@NSplit@NArchive@@UAGJPAUIInStream@@PB_KPAUIArchiveOpenCallback@@@Z
.text:000010E2                 mov     eax, large fs:0
.text:000010E8                 push    eax
.text:000010E9                 push    ecx
.text:000010EA                 sub     esp, 0Ch
.text:000010ED                 push    ebx
.text:000010EE                 push    esi
.text:000010EF                 push    edi
.text:000010F0                 mov     [ebp+var_1C], 0CCCCCCCCh
.text:000010F7                 mov     [ebp+var_18], 0CCCCCCCCh
.text:000010FE                 mov     [ebp+var_14], 0CCCCCCCCh
.text:00001105                 mov     eax, dword ptr ds:___security_cookie
.text:0000110A                 xor     eax, ebp
.text:0000110C                 push    eax
.text:0000110D                 lea     eax, [ebp+var_C]
.text:00001110                 mov     large fs:0, eax
.text:00001116                 mov     [ebp+var_10], esp
.text:00001119                 mov     [ebp+var_4], 0
.text:00001120                 mov     eax, [ebp+arg_C]
.text:00001123                 push    eax             ; struct IArchiveOpenCallback *
.text:00001124                 mov     ecx, [ebp+arg_4]
.text:00001127                 push    ecx             ; struct IInStream *
.text:00001128                 mov     ecx, [ebp+this] ; this
.text:0000112B                 call    ?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z ; NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)
.text:00001130                 mov     [ebp+var_1C], eax
.text:00001133                 mov     edx, [ebp+var_1C]
.text:00001136                 mov     [ebp+var_14], edx
.text:00001139                 cmp     [ebp+var_14], 0
.text:0000113D                 jz      short loc_1156
.text:0000113F                 mov     esi, esp
.text:00001141                 mov     eax, [ebp+this]
.text:00001144                 push    eax
.text:00001145                 mov     ecx, [ebp+this]
.text:00001148                 mov     edx, [ecx]
.text:0000114A                 mov     eax, [edx+10h]
.text:0000114D                 call    eax
.text:0000114F                 cmp     esi, esp
.text:00001151                 call    __RTC_CheckEsp
.text:00001156
.text:00001156 loc_1156:                               ; CODE XREF: NArchive::NSplit::CHandler::Open(IInStream *,unsigned __int64 const *,IArchiveOpenCallback *)+65j
.text:00001156                 mov     eax, [ebp+var_14]
.text:00001159                 jmp     short loc_1181
.text:00001159 ?Open@CHandler@NSplit@NArchive@@UAGJPAUIInStream@@PB_KPAUIArchiveOpenCallback@@@Z endp
.text:00001159
.text:0000115B
.text:0000115B ; =============== S U B R O U T I N E =======================================
.text:0000115B
.text:0000115B
.text:0000115B __catch$?Open@CHandler@NSplit@NArchive@@UAGJPAUIInStream@@PB_KPAUIArchiveOpenCallback@@@Z$0 proc near
.text:0000115B                                         ; DATA XREF: .xdata$x:00001DD8o
.text:0000115B                 mov     dword ptr [ebp-18h], 8007000Eh
.text:00001162                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text:00001169                 mov     eax, offset $LN8
.text:0000116E                 retn
.text:0000116E __catch$?Open@CHandler@NSplit@NArchive@@UAGJPAUIInStream@@PB_KPAUIArchiveOpenCallback@@@Z$0 endp
.text:0000116E
.text:0000116F ; ---------------------------------------------------------------------------
.text:0000116F                 mov     eax, offset __tryend$?Open@CHandler@NSplit@NArchive@@UAGJPAUIInStream@@PB_KPAUIArchiveOpenCallback@@@Z$1
.text:00001174                 retn
.text:00001175 ; ---------------------------------------------------------------------------
.text:00001175
.text:00001175 __tryend$?Open@CHandler@NSplit@NArchive@@UAGJPAUIInStream@@PB_KPAUIArchiveOpenCallback@@@Z$1:
.text:00001175                                         ; DATA XREF: .text:0000116Fo
.text:00001175                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text:0000117C                 jmp     short loc_1181
.text:0000117E ; ---------------------------------------------------------------------------
.text:0000117E
.text:0000117E $LN8:                                   ; DATA XREF: __catch$?Open@CHandler@NSplit@NArchive@@UAGJPAUIInStream@@PB_KPAUIArchiveOpenCallback@@@Z$0+Eo
.text:0000117E                 mov     eax, [ebp-18h]
.text:00001181 ; START OF FUNCTION CHUNK FOR ?Open@CHandler@NSplit@NArchive@@UAGJPAUIInStream@@PB_KPAUIArchiveOpenCallback@@@Z
.text:00001181
.text:00001181 loc_1181:                               ; CODE XREF: NArchive::NSplit::CHandler::Open(IInStream *,unsigned __int64 const *,IArchiveOpenCallback *)+81j
.text:00001181                                         ; .text:0000117Cj
.text:00001181                 mov     ecx, [ebp+var_C]
.text:00001184                 mov     large fs:0, ecx
.text:0000118B                 pop     ecx
.text:0000118C                 pop     edi
.text:0000118D                 pop     esi
.text:0000118E                 pop     ebx
.text:0000118F                 add     esp, 1Ch
.text:00001192                 cmp     ebp, esp
.text:00001194                 call    __RTC_CheckEsp
.text:00001199                 mov     esp, ebp
.text:0000119B                 pop     ebp
.text:0000119C                 retn    10h
.text:0000119C ; END OF FUNCTION CHUNK FOR ?Open@CHandler@NSplit@NArchive@@UAGJPAUIInStream@@PB_KPAUIArchiveOpenCallback@@@Z
.text:0000119C ; ---------------------------------------------------------------------------
.text:0000119F                 db 9 dup(0CCh)
.text:000011A8
.text:000011A8 ; =============== S U B R O U T I N E =======================================
.text:000011A8
.text:000011A8 ; Attributes: bp-based frame
.text:000011A8
.text:000011A8 ; __int32 __stdcall NArchive::NSplit::CHandler::Close(NArchive::NSplit::CHandler *this)
.text:000011A8                 public ?Close@CHandler@NSplit@NArchive@@UAGJXZ
.text:000011A8 ?Close@CHandler@NSplit@NArchive@@UAGJXZ proc near
.text:000011A8                                         ; DATA XREF: .rdata:00003280o
.text:000011A8
.text:000011A8 this            = dword ptr  8
.text:000011A8
.text:000011A8                 push    ebp
.text:000011A9                 mov     ebp, esp
.text:000011AB                 mov     eax, [ebp+this]
.text:000011AE                 mov     dword ptr [eax+30h], 0
.text:000011B5                 mov     dword ptr [eax+34h], 0
.text:000011BC                 mov     ecx, [ebp+this]
.text:000011BF                 add     ecx, 24h ; '$'  ; this
.text:000011C2                 call    ?Empty@UString@@QAEXXZ ; UString::Empty(void)
.text:000011C7                 mov     ecx, [ebp+this]
.text:000011CA                 add     ecx, 0Ch
.text:000011CD                 call    ?Clear@?$CObjectVector@V?$CMyComPtr@UIInStream@@@@@@QAEXXZ ; CObjectVector<CMyComPtr<IInStream>>::Clear(void)
.text:000011D2                 mov     ecx, [ebp+this]
.text:000011D5                 add     ecx, 18h
.text:000011D8                 call    ?Clear@?$CRecordVector@_K@@QAEXXZ ; CRecordVector<unsigned __int64>::Clear(void)
.text:000011DD                 xor     eax, eax
.text:000011DF                 cmp     ebp, esp
.text:000011E1                 call    __RTC_CheckEsp
.text:000011E6                 pop     ebp
.text:000011E7                 retn    4
.text:000011E7 ?Close@CHandler@NSplit@NArchive@@UAGJXZ endp
.text:000011E7
.text:000011E7 ; ---------------------------------------------------------------------------
.text:000011EA                 db 0Eh dup(0CCh)
.text:000011F8
.text:000011F8 ; =============== S U B R O U T I N E =======================================
.text:000011F8
.text:000011F8 ; Attributes: bp-based frame
.text:000011F8
.text:000011F8 ; __int32 __stdcall NArchive::NSplit::CHandler::GetNumberOfItems(NArchive::NSplit::CHandler *this, unsigned int *)
.text:000011F8                 public ?GetNumberOfItems@CHandler@NSplit@NArchive@@UAGJPAI@Z
.text:000011F8 ?GetNumberOfItems@CHandler@NSplit@NArchive@@UAGJPAI@Z proc near
.text:000011F8                                         ; DATA XREF: .rdata:00003284o
.text:000011F8
.text:000011F8 this            = dword ptr  8
.text:000011F8 arg_4           = dword ptr  0Ch
.text:000011F8
.text:000011F8                 push    ebp
.text:000011F9                 mov     ebp, esp
.text:000011FB                 mov     ecx, [ebp+this]
.text:000011FE                 add     ecx, 0Ch
.text:00001201                 call    ?IsEmpty@?$CObjectVector@V?$CMyComPtr@UIInStream@@@@@@QBE_NXZ ; CObjectVector<CMyComPtr<IInStream>>::IsEmpty(void)
.text:00001206                 movzx   eax, al
.text:00001209                 neg     eax
.text:0000120B                 sbb     eax, eax
.text:0000120D                 add     eax, 1
.text:00001210                 mov     ecx, [ebp+arg_4]
.text:00001213                 mov     [ecx], eax
.text:00001215                 xor     eax, eax
.text:00001217                 cmp     ebp, esp
.text:00001219                 call    __RTC_CheckEsp
.text:0000121E                 pop     ebp
.text:0000121F                 retn    8
.text:0000121F ?GetNumberOfItems@CHandler@NSplit@NArchive@@UAGJPAI@Z endp
.text:0000121F
.text:0000121F ; ---------------------------------------------------------------------------
.text:00001222                 align 8
.text:00001228
.text:00001228 ; =============== S U B R O U T I N E =======================================
.text:00001228
.text:00001228 ; Attributes: bp-based frame
.text:00001228
.text:00001228 ; __int32 __stdcall NArchive::NSplit::CHandler::GetProperty(NArchive::NSplit::CHandler *this, unsigned int, unsigned __int32, struct tagPROPVARIANT *)
.text:00001228                 public ?GetProperty@CHandler@NSplit@NArchive@@UAGJIKPAUtagPROPVARIANT@@@Z
.text:00001228 ?GetProperty@CHandler@NSplit@NArchive@@UAGJIKPAUtagPROPVARIANT@@@Z proc near
.text:00001228                                         ; DATA XREF: .rdata:00003288o
.text:00001228
.text:00001228 var_20          = dword ptr -20h
.text:00001228 var_1C          = dword ptr -1Ch
.text:00001228 var_18          = dword ptr -18h
.text:00001228 var_14          = dword ptr -14h
.text:00001228 var_10          = dword ptr -10h
.text:00001228 var_C           = dword ptr -0Ch
.text:00001228 var_8           = dword ptr -8
.text:00001228 var_4           = dword ptr -4
.text:00001228 this            = dword ptr  8
.text:00001228 arg_8           = dword ptr  10h
.text:00001228 arg_C           = dword ptr  14h
.text:00001228
.text:00001228                 push    ebp
.text:00001229                 mov     ebp, esp
.text:0000122B                 sub     esp, 20h
.text:0000122E                 mov     eax, 0CCCCCCCCh
.text:00001233                 mov     [ebp+var_20], eax
.text:00001236                 mov     [ebp+var_1C], eax
.text:00001239                 mov     [ebp+var_18], eax
.text:0000123C                 mov     [ebp+var_14], eax
.text:0000123F                 mov     [ebp+var_10], eax
.text:00001242                 mov     [ebp+var_C], eax
.text:00001245                 mov     [ebp+var_8], eax
.text:00001248                 mov     [ebp+var_4], eax
.text:0000124B                 lea     ecx, [ebp+var_14] ; this
.text:0000124E                 call    ??0CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::CPropVariant(void)
.text:00001253                 mov     eax, [ebp+arg_8]
.text:00001256                 mov     [ebp+var_20], eax
.text:00001259                 cmp     [ebp+var_20], 3
.text:0000125D                 jz      short loc_126D
.text:0000125F                 cmp     [ebp+var_20], 6
.text:00001263                 jbe     short loc_1291
.text:00001265                 cmp     [ebp+var_20], 8
.text:00001269                 jbe     short loc_127E
.text:0000126B                 jmp     short loc_1291
.text:0000126D ; ---------------------------------------------------------------------------
.text:0000126D
.text:0000126D loc_126D:                               ; CODE XREF: NArchive::NSplit::CHandler::GetProperty(uint,ulong,tagPROPVARIANT *)+35j
.text:0000126D                 mov     ecx, [ebp+this]
.text:00001270                 add     ecx, 24h ; '$'
.text:00001273                 push    ecx
.text:00001274                 lea     ecx, [ebp+var_14]
.text:00001277                 call    ??4CPropVariant@NCOM@NWindows@@QAEAAV012@ABVUString@@@Z ; NWindows::NCOM::CPropVariant::operator=(UString const &)
.text:0000127C                 jmp     short loc_1291
.text:0000127E ; ---------------------------------------------------------------------------
.text:0000127E
.text:0000127E loc_127E:                               ; CODE XREF: NArchive::NSplit::CHandler::GetProperty(uint,ulong,tagPROPVARIANT *)+41j
.text:0000127E                 mov     edx, [ebp+this]
.text:00001281                 mov     eax, [edx+34h]
.text:00001284                 push    eax
.text:00001285                 mov     ecx, [edx+30h]
.text:00001288                 push    ecx
.text:00001289                 lea     ecx, [ebp+var_14]
.text:0000128C                 call    ??4CPropVariant@NCOM@NWindows@@QAEAAV012@_K@Z ; NWindows::NCOM::CPropVariant::operator=(unsigned __int64)
.text:00001291
.text:00001291 loc_1291:                               ; CODE XREF: NArchive::NSplit::CHandler::GetProperty(uint,ulong,tagPROPVARIANT *)+3Bj
.text:00001291                                         ; NArchive::NSplit::CHandler::GetProperty(uint,ulong,tagPROPVARIANT *)+43j ...
.text:00001291                 mov     edx, [ebp+arg_C]
.text:00001294                 push    edx             ; struct tagPROPVARIANT *
.text:00001295                 lea     ecx, [ebp+var_14] ; this
.text:00001298                 call    ?Detach@CPropVariant@NCOM@NWindows@@QAEJPAUtagPROPVARIANT@@@Z ; NWindows::NCOM::CPropVariant::Detach(tagPROPVARIANT *)
.text:0000129D                 mov     [ebp+var_1C], 0
.text:000012A4                 lea     ecx, [ebp+var_14] ; this
.text:000012A7                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:000012AC                 mov     eax, [ebp+var_1C]
.text:000012AF                 push    edx
.text:000012B0                 mov     ecx, ebp
.text:000012B2                 push    eax
.text:000012B3                 lea     edx, $LN9
.text:000012B9                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:000012BE                 pop     eax
.text:000012BF                 pop     edx
.text:000012C0                 add     esp, 20h
.text:000012C3                 cmp     ebp, esp
.text:000012C5                 call    __RTC_CheckEsp
.text:000012CA                 mov     esp, ebp
.text:000012CC                 pop     ebp
.text:000012CD                 retn    10h
.text:000012CD ?GetProperty@CHandler@NSplit@NArchive@@UAGJIKPAUtagPROPVARIANT@@@Z endp
.text:000012CD
.text:000012CD ; ---------------------------------------------------------------------------
.text:000012D0 $LN9            dd 1                    ; DATA XREF: NArchive::NSplit::CHandler::GetProperty(uint,ulong,tagPROPVARIANT *)+8Bo
.text:000012D4                 dd offset $LN8_0
.text:000012D8 $LN8_0          dd 0FFFFFFECh, 10h      ; DATA XREF: .text:000012D4o
.text:000012E0                 dd offset $LN7          ; "prop"
.text:000012E4 $LN7            db 'prop',0             ; DATA XREF: .text:000012E0o
.text:000012E9                 db 0Fh dup(0CCh)
.text:000012F8
.text:000012F8 ; =============== S U B R O U T I N E =======================================
.text:000012F8
.text:000012F8 ; Attributes: bp-based frame
.text:000012F8
.text:000012F8 ; __int32 __cdecl NArchive::NSplit::CHandler::Extract(NArchive::NSplit::CHandler *this, const unsigned int *, unsigned int, int, struct IArchiveExtractCallback *)
.text:000012F8                 public ?Extract@CHandler@NSplit@NArchive@@UAGJPBIIHPAUIArchiveExtractCallback@@@Z
.text:000012F8 ?Extract@CHandler@NSplit@NArchive@@UAGJPBIIHPAUIArchiveExtractCallback@@@Z proc near
.text:000012F8                                         ; DATA XREF: .rdata:0000328Co
.text:000012F8
.text:000012F8 var_F4          = dword ptr -0F4h
.text:000012F8 var_F0          = dword ptr -0F0h
.text:000012F8 var_EC          = dword ptr -0ECh
.text:000012F8 var_E8          = dword ptr -0E8h
.text:000012F8 var_E4          = dword ptr -0E4h
.text:000012F8 var_E0          = dword ptr -0E0h
.text:000012F8 var_DC          = dword ptr -0DCh
.text:000012F8 var_D8          = dword ptr -0D8h
.text:000012F8 var_D4          = dword ptr -0D4h
.text:000012F8 var_D0          = dword ptr -0D0h
.text:000012F8 var_CC          = dword ptr -0CCh
.text:000012F8 var_C8          = dword ptr -0C8h
.text:000012F8 var_C4          = dword ptr -0C4h
.text:000012F8 var_C0          = dword ptr -0C0h
.text:000012F8 var_BC          = dword ptr -0BCh
.text:000012F8 var_B8          = dword ptr -0B8h
.text:000012F8 var_B4          = dword ptr -0B4h
.text:000012F8 var_B0          = dword ptr -0B0h
.text:000012F8 var_A9          = byte ptr -0A9h
.text:000012F8 var_A8          = dword ptr -0A8h
.text:000012F8 var_A4          = dword ptr -0A4h
.text:000012F8 var_A0          = dword ptr -0A0h
.text:000012F8 var_9C          = dword ptr -9Ch
.text:000012F8 var_94          = dword ptr -94h
.text:000012F8 var_90          = dword ptr -90h
.text:000012F8 var_8C          = dword ptr -8Ch
.text:000012F8 var_88          = dword ptr -88h
.text:000012F8 var_84          = dword ptr -84h
.text:000012F8 var_80          = dword ptr -80h
.text:000012F8 var_7C          = dword ptr -7Ch
.text:000012F8 var_78          = dword ptr -78h
.text:000012F8 var_74          = dword ptr -74h
.text:000012F8 var_70          = dword ptr -70h
.text:000012F8 var_6C          = dword ptr -6Ch
.text:000012F8 var_68          = dword ptr -68h
.text:000012F8 var_64          = dword ptr -64h
.text:000012F8 var_60          = dword ptr -60h
.text:000012F8 var_5C          = dword ptr -5Ch
.text:000012F8 var_58          = dword ptr -58h
.text:000012F8 var_50          = byte ptr -50h
.text:000012F8 var_48          = dword ptr -48h
.text:000012F8 var_40          = byte ptr -40h
.text:000012F8 var_38          = dword ptr -38h
.text:000012F8 var_34          = dword ptr -34h
.text:000012F8 var_30          = dword ptr -30h
.text:000012F8 var_2C          = dword ptr -2Ch
.text:000012F8 var_24          = byte ptr -24h
.text:000012F8 var_1C          = dword ptr -1Ch
.text:000012F8 var_18          = dword ptr -18h
.text:000012F8 var_14          = dword ptr -14h
.text:000012F8 var_10          = dword ptr -10h
.text:000012F8 var_C           = dword ptr -0Ch
.text:000012F8 var_4           = dword ptr -4
.text:000012F8 this            = dword ptr  8
.text:000012F8 arg_4           = dword ptr  0Ch
.text:000012F8 arg_8           = dword ptr  10h
.text:000012F8 arg_C           = dword ptr  14h
.text:000012F8 arg_10          = dword ptr  18h
.text:000012F8
.text:000012F8 ; FUNCTION CHUNK AT .text:00001845 SIZE 00000032 BYTES
.text:000012F8
.text:000012F8                 push    ebp
.text:000012F9                 mov     ebp, esp
.text:000012FB                 push    0FFFFFFFFh
.text:000012FD                 push    offset __ehhandler$?Extract@CHandler@NSplit@NArchive@@UAGJPBIIHPAUIArchiveExtractCallback@@@Z
.text:00001302                 mov     eax, large fs:0
.text:00001308                 push    eax
.text:00001309                 push    ecx
.text:0000130A                 sub     esp, 0E4h
.text:00001310                 push    ebx
.text:00001311                 push    esi
.text:00001312                 push    edi
.text:00001313                 lea     edi, [ebp+var_F4]
.text:00001319                 mov     ecx, 39h ; '9'
.text:0000131E                 mov     eax, 0CCCCCCCCh
.text:00001323                 rep stosd
.text:00001325                 mov     eax, dword ptr ds:___security_cookie
.text:0000132A                 xor     eax, ebp
.text:0000132C                 push    eax
.text:0000132D                 lea     eax, [ebp+var_C]
.text:00001330                 mov     large fs:0, eax
.text:00001336                 mov     [ebp+var_10], esp
.text:00001339                 mov     [ebp+var_4], 0
.text:00001340                 cmp     [ebp+arg_8], 0
.text:00001344                 jnz     short loc_134D
.text:00001346                 xor     eax, eax
.text:00001348                 jmp     loc_1845
.text:0000134D ; ---------------------------------------------------------------------------
.text:0000134D
.text:0000134D loc_134D:                               ; CODE XREF: NArchive::NSplit::CHandler::Extract(uint const *,uint,int,IArchiveExtractCallback *)+4Cj
.text:0000134D                 cmp     [ebp+arg_8], 0FFFFFFFFh
.text:00001351                 jz      short loc_136B
.text:00001353                 cmp     [ebp+arg_8], 1
.text:00001357                 jnz     short loc_1361
.text:00001359                 mov     eax, [ebp+arg_4]
.text:0000135C                 cmp     dword ptr [eax], 0
.text:0000135F                 jz      short loc_136B
.text:00001361
.text:00001361 loc_1361:                               ; CODE XREF: NArchive::NSplit::CHandler::Extract(uint const *,uint,int,IArchiveExtractCallback *)+5Fj
.text:00001361                 mov     eax, 80070057h
.text:00001366                 jmp     loc_1845
.text:0000136B ; ---------------------------------------------------------------------------
.text:0000136B
.text:0000136B loc_136B:                               ; CODE XREF: NArchive::NSplit::CHandler::Extract(uint const *,uint,int,IArchiveExtractCallback *)+59j
.text:0000136B                                         ; NArchive::NSplit::CHandler::Extract(uint const *,uint,int,IArchiveExtractCallback *)+67j
.text:0000136B                 mov     [ebp+var_18], 0
.text:00001372                 mov     [ebp+var_14], 0
.text:00001379                 mov     esi, esp
.text:0000137B                 mov     ecx, [ebp+this]
.text:0000137E                 mov     edx, [ecx+34h]
.text:00001381                 push    edx
.text:00001382                 mov     eax, [ecx+30h]
.text:00001385                 push    eax
.text:00001386                 mov     ecx, [ebp+arg_10]
.text:00001389                 push    ecx
.text:0000138A                 mov     edx, [ebp+arg_10]
.text:0000138D                 mov     eax, [edx]
.text:0000138F                 mov     ecx, [eax+0Ch]
.text:00001392                 call    ecx
.text:00001394                 cmp     esi, esp
.text:00001396                 call    __RTC_CheckEsp
.text:0000139B                 mov     [ebp+var_9C], eax
.text:000013A1                 mov     edx, [ebp+var_9C]
.text:000013A7                 mov     [ebp+var_1C], edx
.text:000013AA                 cmp     [ebp+var_1C], 0
.text:000013AE                 jz      short loc_13B8
.text:000013B0                 mov     eax, [ebp+var_1C]
.text:000013B3                 jmp     loc_1845
.text:000013B8 ; ---------------------------------------------------------------------------
.text:000013B8
.text:000013B8 loc_13B8:                               ; CODE XREF: NArchive::NSplit::CHandler::Extract(uint const *,uint,int,IArchiveExtractCallback *)+B6j
.text:000013B8                 lea     ecx, [ebp+var_24]
.text:000013BB                 call    ??0?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::CMyComPtr<ISequentialOutStream>(void)
.text:000013C0                 mov     [ebp+var_A0], eax
.text:000013C6                 mov     byte ptr [ebp+var_4], 1
.text:000013CA                 xor     eax, eax
.text:000013CC                 cmp     [ebp+arg_C], 0
.text:000013D0                 setnz   al
.text:000013D3                 mov     [ebp+var_2C], eax
.text:000013D6                 lea     ecx, [ebp+var_24]
.text:000013D9                 call    ??I?$CMyComPtr@UISequentialOutStream@@@@QAEPAPAUISequentialOutStream@@XZ ; CMyComPtr<ISequentialOutStream>::operator&(void)
.text:000013DE                 mov     [ebp+var_A4], eax
.text:000013E4                 mov     esi, esp
.text:000013E6                 mov     ecx, [ebp+var_2C]
.text:000013E9                 push    ecx
.text:000013EA                 mov     edx, [ebp+var_A4]
.text:000013F0                 push    edx
.text:000013F1                 push    0
.text:000013F3                 mov     eax, [ebp+arg_10]
.text:000013F6                 push    eax
.text:000013F7                 mov     ecx, [ebp+arg_10]
.text:000013FA                 mov     edx, [ecx]
.text:000013FC                 mov     eax, [edx+14h]
.text:000013FF                 call    eax
.text:00001401                 cmp     esi, esp
.text:00001403                 call    __RTC_CheckEsp
.text:00001408                 mov     [ebp+var_A8], eax
.text:0000140E                 mov     ecx, [ebp+var_A8]
.text:00001414                 mov     [ebp+var_30], ecx
.text:00001417                 cmp     [ebp+var_30], 0
.text:0000141B                 jz      short loc_1437
.text:0000141D                 mov     edx, [ebp+var_30]
.text:00001420                 mov     [ebp+var_6C], edx
.text:00001423                 mov     byte ptr [ebp+var_4], 0
.text:00001427                 lea     ecx, [ebp+var_24]
.text:0000142A                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:0000142F                 mov     eax, [ebp+var_6C]
.text:00001432                 jmp     loc_1845
.text:00001437 ; ---------------------------------------------------------------------------
.text:00001437
.text:00001437 loc_1437:                               ; CODE XREF: NArchive::NSplit::CHandler::Extract(uint const *,uint,int,IArchiveExtractCallback *)+123j
.text:00001437                 cmp     [ebp+arg_C], 0
.text:0000143B                 jnz     short loc_1471
.text:0000143D                 lea     ecx, [ebp+var_24]
.text:00001440                 call    ??7?$CMyComPtr@UISequentialOutStream@@@@QBE_NXZ ; CMyComPtr<ISequentialOutStream>::operator!(void)
.text:00001445                 mov     [ebp+var_A9], al
.text:0000144B                 movzx   eax, [ebp+var_A9]
.text:00001452                 test    eax, eax
.text:00001454                 jz      short loc_1471
.text:00001456                 mov     [ebp+var_70], 0
.text:0000145D                 mov     byte ptr [ebp+var_4], 0
.text:00001461                 lea     ecx, [ebp+var_24]
.text:00001464                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00001469                 mov     eax, [ebp+var_70]
.text:0000146C                 jmp     loc_1845
.text:00001471 ; ---------------------------------------------------------------------------
.text:00001471
.text:00001471 loc_1471:                               ; CODE XREF: NArchive::NSplit::CHandler::Extract(uint const *,uint,int,IArchiveExtractCallback *)+143j
.text:00001471                                         ; NArchive::NSplit::CHandler::Extract(uint const *,uint,int,IArchiveExtractCallback *)+15Cj
.text:00001471                 mov     esi, esp
.text:00001473                 mov     ecx, [ebp+var_2C]
.text:00001476                 push    ecx
.text:00001477                 mov     edx, [ebp+arg_10]
.text:0000147A                 push    edx
.text:0000147B                 mov     eax, [ebp+arg_10]
.text:0000147E                 mov     ecx, [eax]
.text:00001480                 mov     edx, [ecx+18h]
.text:00001483                 call    edx
.text:00001485                 cmp     esi, esp
.text:00001487                 call    __RTC_CheckEsp
.text:0000148C                 mov     [ebp+var_B0], eax
.text:00001492                 mov     eax, [ebp+var_B0]
.text:00001498                 mov     [ebp+var_34], eax
.text:0000149B                 cmp     [ebp+var_34], 0
.text:0000149F                 jz      short loc_14BB
.text:000014A1                 mov     ecx, [ebp+var_34]
.text:000014A4                 mov     [ebp+var_74], ecx
.text:000014A7                 mov     byte ptr [ebp+var_4], 0
.text:000014AB                 lea     ecx, [ebp+var_24]
.text:000014AE                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:000014B3                 mov     eax, [ebp+var_74]
.text:000014B6                 jmp     loc_1845
.text:000014BB ; ---------------------------------------------------------------------------
.text:000014BB
.text:000014BB loc_14BB:                               ; CODE XREF: NArchive::NSplit::CHandler::Extract(uint const *,uint,int,IArchiveExtractCallback *)+1A7j
.text:000014BB                 push    28h ; '('       ; unsigned int
.text:000014BD                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:000014C2                 add     esp, 4
.text:000014C5                 mov     [ebp+var_B4], eax
.text:000014CB                 mov     edx, [ebp+var_B4]
.text:000014D1                 mov     [ebp+var_7C], edx
.text:000014D4                 mov     byte ptr [ebp+var_4], 2
.text:000014D8                 cmp     [ebp+var_7C], 0
.text:000014DC                 jz      short loc_14FA
.text:000014DE                 mov     ecx, [ebp+var_7C] ; this
.text:000014E1                 call    ??0CCopyCoder@NCompress@@QAE@XZ ; NCompress::CCopyCoder::CCopyCoder(void)
.text:000014E6                 mov     [ebp+var_B8], eax
.text:000014EC                 mov     eax, [ebp+var_B8]
.text:000014F2                 mov     [ebp+var_BC], eax
.text:000014F8                 jmp     short loc_1504
.text:000014FA ; ---------------------------------------------------------------------------
.text:000014FA
.text:000014FA loc_14FA:                               ; CODE XREF: NArchive::NSplit::CHandler::Extract(uint const *,uint,int,IArchiveExtractCallback *)+1E4j
.text:000014FA                 mov     [ebp+var_BC], 0
.text:00001504
.text:00001504 loc_1504:                               ; CODE XREF: NArchive::NSplit::CHandler::Extract(uint const *,uint,int,IArchiveExtractCallback *)+200j
.text:00001504                 mov     ecx, [ebp+var_BC]
.text:0000150A                 mov     [ebp+var_78], ecx
.text:0000150D                 mov     byte ptr [ebp+var_4], 1
.text:00001511                 mov     edx, [ebp+var_78]
.text:00001514                 mov     [ebp+var_38], edx
.text:00001517                 mov     eax, [ebp+var_38]
.text:0000151A                 push    eax
.text:0000151B                 lea     ecx, [ebp+var_40]
.text:0000151E                 call    ??0?$CMyComPtr@UICompressCoder@@@@QAE@PAUICompressCoder@@@Z ; CMyComPtr<ICompressCoder>::CMyComPtr<ICompressCoder>(ICompressCoder *)
.text:00001523                 mov     byte ptr [ebp+var_4], 3
.text:00001527                 push    38h ; '8'       ; unsigned int
.text:00001529                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0000152E                 add     esp, 4
.text:00001531                 mov     [ebp+var_C0], eax
.text:00001537                 mov     ecx, [ebp+var_C0]
.text:0000153D                 mov     [ebp+var_84], ecx
.text:00001543                 mov     byte ptr [ebp+var_4], 4
.text:00001547                 cmp     [ebp+var_84], 0
.text:0000154E                 jz      short loc_156F
.text:00001550                 mov     ecx, [ebp+var_84]
.text:00001556                 call    ??0CLocalProgress@@QAE@XZ ; CLocalProgress::CLocalProgress(void)
.text:0000155B                 mov     [ebp+var_C4], eax
.text:00001561                 mov     edx, [ebp+var_C4]
.text:00001567                 mov     [ebp+var_C8], edx
.text:0000156D                 jmp     short loc_1579
.text:0000156F ; ---------------------------------------------------------------------------
.text:0000156F
.text:0000156F loc_156F:                               ; CODE XREF: NArchive::NSplit::CHandler::Extract(uint const *,uint,int,IArchiveExtractCallback *)+256j
.text:0000156F                 mov     [ebp+var_C8], 0
.text:00001579
.text:00001579 loc_1579:                               ; CODE XREF: NArchive::NSplit::CHandler::Extract(uint const *,uint,int,IArchiveExtractCallback *)+275j
.text:00001579                 mov     eax, [ebp+var_C8]
.text:0000157F                 mov     [ebp+var_80], eax
.text:00001582                 mov     byte ptr [ebp+var_4], 3
.text:00001586                 mov     ecx, [ebp+var_80]
.text:00001589                 mov     [ebp+var_48], ecx
.text:0000158C                 mov     edx, [ebp+var_48]
.text:0000158F                 push    edx
.text:00001590                 lea     ecx, [ebp+var_50]
.text:00001593                 call    ??0?$CMyComPtr@UICompressProgressInfo@@@@QAE@PAUICompressProgressInfo@@@Z ; CMyComPtr<ICompressProgressInfo>::CMyComPtr<ICompressProgressInfo>(ICompressProgressInfo *)
.text:00001598                 mov     byte ptr [ebp+var_4], 5
.text:0000159C                 push    0               ; bool
.text:0000159E                 mov     eax, [ebp+arg_10]
.text:000015A1                 push    eax             ; struct IProgress *
.text:000015A2                 mov     ecx, [ebp+var_48] ; this
.text:000015A5                 call    ?Init@CLocalProgress@@QAEXPAUIProgress@@_N@Z ; CLocalProgress::Init(IProgress *,bool)
.text:000015AA                 mov     [ebp+var_58], 0
.text:000015B1                 jmp     short loc_15BC
.text:000015B3 ; ---------------------------------------------------------------------------
.text:000015B3
.text:000015B3 loc_15B3:                               ; CODE XREF: NArchive::NSplit::CHandler::Extract(uint const *,uint,int,IArchiveExtractCallback *)+4BDj
.text:000015B3                 mov     ecx, [ebp+var_58]
.text:000015B6                 add     ecx, 1
.text:000015B9                 mov     [ebp+var_58], ecx
.text:000015BC
.text:000015BC loc_15BC:                               ; CODE XREF: NArchive::NSplit::CHandler::Extract(uint const *,uint,int,IArchiveExtractCallback *)+2B9j
.text:000015BC                 mov     ecx, [ebp+this]
.text:000015BF                 add     ecx, 0Ch
.text:000015C2                 call    ?Size@?$CObjectVector@V?$CMyComPtr@UIInStream@@@@@@QBEIXZ ; CObjectVector<CMyComPtr<IInStream>>::Size(void)
.text:000015C7                 mov     [ebp+var_CC], eax
.text:000015CD                 mov     edx, [ebp+var_58]
.text:000015D0                 cmp     edx, [ebp+var_CC]
.text:000015D6                 jnb     loc_17BA
.text:000015DC                 mov     eax, [ebp+var_48]
.text:000015DF                 mov     ecx, [ebp+var_18]
.text:000015E2                 mov     [eax+28h], ecx
.text:000015E5                 mov     edx, [ebp+var_14]
.text:000015E8                 mov     [eax+2Ch], edx
.text:000015EB                 mov     eax, [ebp+var_48]
.text:000015EE                 mov     ecx, [ebp+var_18]
.text:000015F1                 mov     [eax+20h], ecx
.text:000015F4                 mov     edx, [ebp+var_14]
.text:000015F7                 mov     [eax+24h], edx
.text:000015FA                 mov     ecx, [ebp+var_48] ; this
.text:000015FD                 call    ?SetCur@CLocalProgress@@QAEJXZ ; CLocalProgress::SetCur(void)
.text:00001602                 mov     [ebp+var_D0], eax
.text:00001608                 mov     eax, [ebp+var_D0]
.text:0000160E                 mov     [ebp+var_5C], eax
.text:00001611                 cmp     [ebp+var_5C], 0
.text:00001615                 jz      short loc_164F
.text:00001617                 mov     ecx, [ebp+var_5C]
.text:0000161A                 mov     [ebp+var_88], ecx
.text:00001620                 mov     byte ptr [ebp+var_4], 3
.text:00001624                 lea     ecx, [ebp+var_50]
.text:00001627                 call    ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ ; CMyComPtr<ICompressProgressInfo>::~CMyComPtr<ICompressProgressInfo>(void)
.text:0000162C                 mov     byte ptr [ebp+var_4], 1
.text:00001630                 lea     ecx, [ebp+var_40]
.text:00001633                 call    ??1?$CMyComPtr@UICompressCoder@@@@QAE@XZ ; CMyComPtr<ICompressCoder>::~CMyComPtr<ICompressCoder>(void)
.text:00001638                 mov     byte ptr [ebp+var_4], 0
.text:0000163C                 lea     ecx, [ebp+var_24]
.text:0000163F                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00001644                 mov     eax, [ebp+var_88]
.text:0000164A                 jmp     loc_1845
.text:0000164F ; ---------------------------------------------------------------------------
.text:0000164F
.text:0000164F loc_164F:                               ; CODE XREF: NArchive::NSplit::CHandler::Extract(uint const *,uint,int,IArchiveExtractCallback *)+31Dj
.text:0000164F                 mov     edx, [ebp+var_58]
.text:00001652                 push    edx
.text:00001653                 mov     ecx, [ebp+this]
.text:00001656                 add     ecx, 0Ch
.text:00001659                 call    ??A?$CObjectVector@V?$CMyComPtr@UIInStream@@@@@@QAEAAV?$CMyComPtr@UIInStream@@@@I@Z ; CObjectVector<CMyComPtr<IInStream>>::operator[](uint)
.text:0000165E                 mov     [ebp+var_D4], eax
.text:00001664                 mov     ecx, [ebp+var_D4]
.text:0000166A                 call    ??B?$CMyComPtr@UIInStream@@@@QBEPAUIInStream@@XZ ; CMyComPtr<IInStream>::operator IInStream *(void)
.text:0000166F                 mov     [ebp+var_D8], eax
.text:00001675                 mov     eax, [ebp+var_D8]
.text:0000167B                 mov     [ebp+var_60], eax
.text:0000167E                 mov     esi, esp
.text:00001680                 push    0
.text:00001682                 push    0
.text:00001684                 push    0
.text:00001686                 push    0
.text:00001688                 mov     ecx, [ebp+var_60]
.text:0000168B                 push    ecx
.text:0000168C                 mov     edx, [ebp+var_60]
.text:0000168F                 mov     eax, [edx]
.text:00001691                 mov     ecx, [eax+10h]
.text:00001694                 call    ecx
.text:00001696                 cmp     esi, esp
.text:00001698                 call    __RTC_CheckEsp
.text:0000169D                 mov     [ebp+var_DC], eax
.text:000016A3                 mov     edx, [ebp+var_DC]
.text:000016A9                 mov     [ebp+var_64], edx
.text:000016AC                 cmp     [ebp+var_64], 0
.text:000016B0                 jz      short loc_16EA
.text:000016B2                 mov     eax, [ebp+var_64]
.text:000016B5                 mov     [ebp+var_8C], eax
.text:000016BB                 mov     byte ptr [ebp+var_4], 3
.text:000016BF                 lea     ecx, [ebp+var_50]
.text:000016C2                 call    ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ ; CMyComPtr<ICompressProgressInfo>::~CMyComPtr<ICompressProgressInfo>(void)
.text:000016C7                 mov     byte ptr [ebp+var_4], 1
.text:000016CB                 lea     ecx, [ebp+var_40]
.text:000016CE                 call    ??1?$CMyComPtr@UICompressCoder@@@@QAE@XZ ; CMyComPtr<ICompressCoder>::~CMyComPtr<ICompressCoder>(void)
.text:000016D3                 mov     byte ptr [ebp+var_4], 0
.text:000016D7                 lea     ecx, [ebp+var_24]
.text:000016DA                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:000016DF                 mov     eax, [ebp+var_8C]
.text:000016E5                 jmp     loc_1845
.text:000016EA ; ---------------------------------------------------------------------------
.text:000016EA
.text:000016EA loc_16EA:                               ; CODE XREF: NArchive::NSplit::CHandler::Extract(uint const *,uint,int,IArchiveExtractCallback *)+3B8j
.text:000016EA                 lea     ecx, [ebp+var_40]
.text:000016ED                 call    ??C?$CMyComPtr@UICompressCoder@@@@QBEPAUICompressCoder@@XZ ; CMyComPtr<ICompressCoder>::operator->(void)
.text:000016F2                 mov     [ebp+var_E0], eax
.text:000016F8                 mov     ecx, [ebp+var_E0]
.text:000016FE                 mov     [ebp+var_E4], ecx
.text:00001704                 lea     ecx, [ebp+var_50]
.text:00001707                 call    ??B?$CMyComPtr@UICompressProgressInfo@@@@QBEPAUICompressProgressInfo@@XZ ; CMyComPtr<ICompressProgressInfo>::operator ICompressProgressInfo *(void)
.text:0000170C                 mov     [ebp+var_E8], eax
.text:00001712                 lea     ecx, [ebp+var_24]
.text:00001715                 call    ??B?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ ; CMyComPtr<ISequentialOutStream>::operator ISequentialOutStream *(void)
.text:0000171A                 mov     [ebp+var_EC], eax
.text:00001720                 mov     esi, esp
.text:00001722                 mov     edx, [ebp+var_E8]
.text:00001728                 push    edx
.text:00001729                 push    0
.text:0000172B                 push    0
.text:0000172D                 mov     eax, [ebp+var_EC]
.text:00001733                 push    eax
.text:00001734                 mov     ecx, [ebp+var_60]
.text:00001737                 push    ecx
.text:00001738                 mov     edx, [ebp+var_E4]
.text:0000173E                 push    edx
.text:0000173F                 mov     eax, [ebp+var_E4]
.text:00001745                 mov     ecx, [eax]
.text:00001747                 mov     edx, [ecx+0Ch]
.text:0000174A                 call    edx
.text:0000174C                 cmp     esi, esp
.text:0000174E                 call    __RTC_CheckEsp
.text:00001753                 mov     [ebp+var_F0], eax
.text:00001759                 mov     eax, [ebp+var_F0]
.text:0000175F                 mov     [ebp+var_68], eax
.text:00001762                 cmp     [ebp+var_68], 0
.text:00001766                 jz      short loc_17A0
.text:00001768                 mov     ecx, [ebp+var_68]
.text:0000176B                 mov     [ebp+var_90], ecx
.text:00001771                 mov     byte ptr [ebp+var_4], 3
.text:00001775                 lea     ecx, [ebp+var_50]
.text:00001778                 call    ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ ; CMyComPtr<ICompressProgressInfo>::~CMyComPtr<ICompressProgressInfo>(void)
.text:0000177D                 mov     byte ptr [ebp+var_4], 1
.text:00001781                 lea     ecx, [ebp+var_40]
.text:00001784                 call    ??1?$CMyComPtr@UICompressCoder@@@@QAE@XZ ; CMyComPtr<ICompressCoder>::~CMyComPtr<ICompressCoder>(void)
.text:00001789                 mov     byte ptr [ebp+var_4], 0
.text:0000178D                 lea     ecx, [ebp+var_24]
.text:00001790                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00001795                 mov     eax, [ebp+var_90]
.text:0000179B                 jmp     loc_1845
.text:000017A0 ; ---------------------------------------------------------------------------
.text:000017A0
.text:000017A0 loc_17A0:                               ; CODE XREF: NArchive::NSplit::CHandler::Extract(uint const *,uint,int,IArchiveExtractCallback *)+46Ej
.text:000017A0                 mov     edx, [ebp+var_38]
.text:000017A3                 mov     eax, [ebp+var_18]
.text:000017A6                 add     eax, [edx+20h]
.text:000017A9                 mov     ecx, [ebp+var_14]
.text:000017AC                 adc     ecx, [edx+24h]
.text:000017AF                 mov     [ebp+var_18], eax
.text:000017B2                 mov     [ebp+var_14], ecx
.text:000017B5                 jmp     loc_15B3
.text:000017BA ; ---------------------------------------------------------------------------
.text:000017BA
.text:000017BA loc_17BA:                               ; CODE XREF: NArchive::NSplit::CHandler::Extract(uint const *,uint,int,IArchiveExtractCallback *)+2DEj
.text:000017BA                 lea     ecx, [ebp+var_24]
.text:000017BD                 call    ?Release@?$CMyComPtr@UISequentialOutStream@@@@QAEXXZ ; CMyComPtr<ISequentialOutStream>::Release(void)
.text:000017C2                 mov     esi, esp
.text:000017C4                 push    0
.text:000017C6                 mov     edx, [ebp+arg_10]
.text:000017C9                 push    edx
.text:000017CA                 mov     eax, [ebp+arg_10]
.text:000017CD                 mov     ecx, [eax]
.text:000017CF                 mov     edx, [ecx+1Ch]
.text:000017D2                 call    edx
.text:000017D4                 cmp     esi, esp
.text:000017D6                 call    __RTC_CheckEsp
.text:000017DB                 mov     [ebp+var_F4], eax
.text:000017E1                 mov     eax, [ebp+var_F4]
.text:000017E7                 mov     [ebp+var_94], eax
.text:000017ED                 mov     byte ptr [ebp+var_4], 3
.text:000017F1                 lea     ecx, [ebp+var_50]
.text:000017F4                 call    ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ ; CMyComPtr<ICompressProgressInfo>::~CMyComPtr<ICompressProgressInfo>(void)
.text:000017F9                 mov     byte ptr [ebp+var_4], 1
.text:000017FD                 lea     ecx, [ebp+var_40]
.text:00001800                 call    ??1?$CMyComPtr@UICompressCoder@@@@QAE@XZ ; CMyComPtr<ICompressCoder>::~CMyComPtr<ICompressCoder>(void)
.text:00001805                 mov     byte ptr [ebp+var_4], 0
.text:00001809                 lea     ecx, [ebp+var_24]
.text:0000180C                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00001811                 mov     eax, [ebp+var_94]
.text:00001817                 jmp     short loc_1845
.text:00001817 ?Extract@CHandler@NSplit@NArchive@@UAGJPBIIHPAUIArchiveExtractCallback@@@Z endp
.text:00001817
.text:00001819
.text:00001819 ; =============== S U B R O U T I N E =======================================
.text:00001819
.text:00001819
.text:00001819 __catch$?Extract@CHandler@NSplit@NArchive@@UAGJPBIIHPAUIArchiveExtractCallback@@@Z$0 proc near
.text:00001819                                         ; DATA XREF: .xdata$x:00001E30o
.text:00001819                 mov     dword ptr [ebp-98h], 8007000Eh
.text:00001823                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text:0000182A                 mov     eax, offset $LN29
.text:0000182F                 retn
.text:0000182F __catch$?Extract@CHandler@NSplit@NArchive@@UAGJPBIIHPAUIArchiveExtractCallback@@@Z$0 endp
.text:0000182F
.text:00001830 ; ---------------------------------------------------------------------------
.text:00001830                 mov     eax, offset __tryend$?Extract@CHandler@NSplit@NArchive@@UAGJPBIIHPAUIArchiveExtractCallback@@@Z$1
.text:00001835                 retn
.text:00001836 ; ---------------------------------------------------------------------------
.text:00001836
.text:00001836 __tryend$?Extract@CHandler@NSplit@NArchive@@UAGJPBIIHPAUIArchiveExtractCallback@@@Z$1:
.text:00001836                                         ; DATA XREF: .text:00001830o
.text:00001836                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text:0000183D                 jmp     short loc_1845
.text:0000183F ; ---------------------------------------------------------------------------
.text:0000183F
.text:0000183F $LN29:                                  ; DATA XREF: __catch$?Extract@CHandler@NSplit@NArchive@@UAGJPBIIHPAUIArchiveExtractCallback@@@Z$0+11o
.text:0000183F                 mov     eax, [ebp-98h]
.text:00001845 ; START OF FUNCTION CHUNK FOR ?Extract@CHandler@NSplit@NArchive@@UAGJPBIIHPAUIArchiveExtractCallback@@@Z
.text:00001845
.text:00001845 loc_1845:                               ; CODE XREF: NArchive::NSplit::CHandler::Extract(uint const *,uint,int,IArchiveExtractCallback *)+50j
.text:00001845                                         ; NArchive::NSplit::CHandler::Extract(uint const *,uint,int,IArchiveExtractCallback *)+6Ej ...
.text:00001845                 push    edx
.text:00001846                 mov     ecx, ebp
.text:00001848                 push    eax
.text:00001849                 lea     edx, $LN36
.text:0000184F                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00001854                 pop     eax
.text:00001855                 pop     edx
.text:00001856                 mov     ecx, [ebp+var_C]
.text:00001859                 mov     large fs:0, ecx
.text:00001860                 pop     ecx
.text:00001861                 pop     edi
.text:00001862                 pop     esi
.text:00001863                 pop     ebx
.text:00001864                 add     esp, 0F4h
.text:0000186A                 cmp     ebp, esp
.text:0000186C                 call    __RTC_CheckEsp
.text:00001871                 mov     esp, ebp
.text:00001873                 pop     ebp
.text:00001874                 retn    14h
.text:00001874 ; END OF FUNCTION CHUNK FOR ?Extract@CHandler@NSplit@NArchive@@UAGJPBIIHPAUIArchiveExtractCallback@@@Z
.text:00001874 ; ---------------------------------------------------------------------------
.text:00001877                 align 4
.text:00001878 $LN36           dd 3                    ; DATA XREF: NArchive::NSplit::CHandler::Extract(uint const *,uint,int,IArchiveExtractCallback *)+551o
.text:0000187C                 dd offset $LN35
.text:00001880 $LN35           dd 0FFFFFFDCh, 4        ; DATA XREF: .text:0000187Co
.text:00001888                 dd offset $LN31         ; "outStream"
.text:0000188C                 dd 0FFFFFFC0h, 4
.text:00001894                 dd offset $LN32         ; "copyCoder"
.text:00001898                 dd 0FFFFFFB0h, 4
.text:000018A0                 dd offset $LN33         ; "progress"
.text:000018A4 $LN33           db 'progress',0         ; DATA XREF: .text:000018A0o
.text:000018AD $LN32           db 'copyCoder',0        ; DATA XREF: .text:00001894o
.text:000018B7 $LN31           db 'outStream',0        ; DATA XREF: .text:00001888o
.text:000018C1                 align 8
.text:000018C8
.text:000018C8 ; =============== S U B R O U T I N E =======================================
.text:000018C8
.text:000018C8 ; Attributes: bp-based frame
.text:000018C8
.text:000018C8 ; __int32 __cdecl NArchive::NSplit::CHandler::GetStream(NArchive::NSplit::CHandler *this, unsigned int, struct ISequentialInStream **)
.text:000018C8                 public ?GetStream@CHandler@NSplit@NArchive@@UAGJIPAPAUISequentialInStream@@@Z
.text:000018C8 ?GetStream@CHandler@NSplit@NArchive@@UAGJIPAPAUISequentialInStream@@@Z proc near
.text:000018C8                                         ; DATA XREF: .rdata:00003268o
.text:000018C8
.text:000018C8 var_7C          = dword ptr -7Ch
.text:000018C8 var_78          = dword ptr -78h
.text:000018C8 var_74          = dword ptr -74h
.text:000018C8 var_70          = dword ptr -70h
.text:000018C8 var_6C          = dword ptr -6Ch
.text:000018C8 var_68          = dword ptr -68h
.text:000018C8 var_64          = dword ptr -64h
.text:000018C8 var_60          = dword ptr -60h
.text:000018C8 var_58          = dword ptr -58h
.text:000018C8 var_54          = dword ptr -54h
.text:000018C8 var_50          = dword ptr -50h
.text:000018C8 var_48          = byte ptr -48h
.text:000018C8 var_40          = dword ptr -40h
.text:000018C8 var_3C          = dword ptr -3Ch
.text:000018C8 var_24          = dword ptr -24h
.text:000018C8 var_1C          = byte ptr -1Ch
.text:000018C8 var_14          = dword ptr -14h
.text:000018C8 var_10          = dword ptr -10h
.text:000018C8 var_C           = dword ptr -0Ch
.text:000018C8 var_4           = dword ptr -4
.text:000018C8 this            = dword ptr  8
.text:000018C8 arg_4           = dword ptr  0Ch
.text:000018C8 arg_8           = dword ptr  10h
.text:000018C8
.text:000018C8 ; FUNCTION CHUNK AT .text:00001A68 SIZE 0000002F BYTES
.text:000018C8
.text:000018C8                 push    ebp
.text:000018C9                 mov     ebp, esp
.text:000018CB                 push    0FFFFFFFFh
.text:000018CD                 push    offset __ehhandler$?GetStream@CHandler@NSplit@NArchive@@UAGJIPAPAUISequentialInStream@@@Z
.text:000018D2                 mov     eax, large fs:0
.text:000018D8                 push    eax
.text:000018D9                 push    ecx
.text:000018DA                 sub     esp, 6Ch
.text:000018DD                 push    ebx
.text:000018DE                 push    esi
.text:000018DF                 push    edi
.text:000018E0                 lea     edi, [ebp+var_7C]
.text:000018E3                 mov     ecx, 1Bh
.text:000018E8                 mov     eax, 0CCCCCCCCh
.text:000018ED                 rep stosd
.text:000018EF                 mov     eax, dword ptr ds:___security_cookie
.text:000018F4                 xor     eax, ebp
.text:000018F6                 push    eax
.text:000018F7                 lea     eax, [ebp+var_C]
.text:000018FA                 mov     large fs:0, eax
.text:00001900                 mov     [ebp+var_10], esp
.text:00001903                 mov     [ebp+var_4], 0
.text:0000190A                 cmp     [ebp+arg_4], 0
.text:0000190E                 jz      short loc_191A
.text:00001910                 mov     eax, 80070057h
.text:00001915                 jmp     loc_1A68
.text:0000191A ; ---------------------------------------------------------------------------
.text:0000191A
.text:0000191A loc_191A:                               ; CODE XREF: NArchive::NSplit::CHandler::GetStream(uint,ISequentialInStream * *)+46j
.text:0000191A                 mov     eax, [ebp+arg_8]
.text:0000191D                 mov     dword ptr [eax], 0
.text:00001923                 push    28h ; '('       ; unsigned int
.text:00001925                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0000192A                 add     esp, 4
.text:0000192D                 mov     [ebp+var_60], eax
.text:00001930                 mov     ecx, [ebp+var_60]
.text:00001933                 mov     [ebp+var_54], ecx
.text:00001936                 mov     byte ptr [ebp+var_4], 1
.text:0000193A                 cmp     [ebp+var_54], 0
.text:0000193E                 jz      short loc_1953
.text:00001940                 mov     ecx, [ebp+var_54]
.text:00001943                 call    ??0CMultiStream@@QAE@XZ ; CMultiStream::CMultiStream(void)
.text:00001948                 mov     [ebp+var_64], eax
.text:0000194B                 mov     edx, [ebp+var_64]
.text:0000194E                 mov     [ebp+var_68], edx
.text:00001951                 jmp     short loc_195A
.text:00001953 ; ---------------------------------------------------------------------------
.text:00001953
.text:00001953 loc_1953:                               ; CODE XREF: NArchive::NSplit::CHandler::GetStream(uint,ISequentialInStream * *)+76j
.text:00001953                 mov     [ebp+var_68], 0
.text:0000195A
.text:0000195A loc_195A:                               ; CODE XREF: NArchive::NSplit::CHandler::GetStream(uint,ISequentialInStream * *)+89j
.text:0000195A                 mov     eax, [ebp+var_68]
.text:0000195D                 mov     [ebp+var_50], eax
.text:00001960                 mov     byte ptr [ebp+var_4], 0
.text:00001964                 mov     ecx, [ebp+var_50]
.text:00001967                 mov     [ebp+var_14], ecx
.text:0000196A                 mov     edx, [ebp+var_14]
.text:0000196D                 push    edx
.text:0000196E                 lea     ecx, [ebp+var_1C]
.text:00001971                 call    ??0?$CMyComPtr@UISequentialInStream@@@@QAE@PAUISequentialInStream@@@Z ; CMyComPtr<ISequentialInStream>::CMyComPtr<ISequentialInStream>(ISequentialInStream *)
.text:00001976                 mov     byte ptr [ebp+var_4], 2
.text:0000197A                 mov     [ebp+var_24], 0
.text:00001981                 jmp     short loc_198C
.text:00001983 ; ---------------------------------------------------------------------------
.text:00001983
.text:00001983 loc_1983:                               ; CODE XREF: NArchive::NSplit::CHandler::GetStream(uint,ISequentialInStream * *)+142j
.text:00001983                 mov     eax, [ebp+var_24]
.text:00001986                 add     eax, 1
.text:00001989                 mov     [ebp+var_24], eax
.text:0000198C
.text:0000198C loc_198C:                               ; CODE XREF: NArchive::NSplit::CHandler::GetStream(uint,ISequentialInStream * *)+B9j
.text:0000198C                 mov     ecx, [ebp+this]
.text:0000198F                 add     ecx, 8
.text:00001992                 call    ?Size@?$CObjectVector@V?$CMyComPtr@UIInStream@@@@@@QBEIXZ ; CObjectVector<CMyComPtr<IInStream>>::Size(void)
.text:00001997                 mov     [ebp+var_6C], eax
.text:0000199A                 mov     ecx, [ebp+var_24]
.text:0000199D                 cmp     ecx, [ebp+var_6C]
.text:000019A0                 jnb     short loc_1A0F
.text:000019A2                 lea     ecx, [ebp+var_48] ; this
.text:000019A5                 call    ??0CSubStreamInfo@CMultiStream@@QAE@XZ ; CMultiStream::CSubStreamInfo::CSubStreamInfo(void)
.text:000019AA                 mov     [ebp+var_70], eax
.text:000019AD                 mov     byte ptr [ebp+var_4], 3
.text:000019B1                 mov     edx, [ebp+var_24]
.text:000019B4                 push    edx
.text:000019B5                 mov     ecx, [ebp+this]
.text:000019B8                 add     ecx, 8
.text:000019BB                 call    ??A?$CObjectVector@V?$CMyComPtr@UIInStream@@@@@@QAEAAV?$CMyComPtr@UIInStream@@@@I@Z ; CObjectVector<CMyComPtr<IInStream>>::operator[](uint)
.text:000019C0                 mov     [ebp+var_74], eax
.text:000019C3                 mov     eax, [ebp+var_74]
.text:000019C6                 push    eax
.text:000019C7                 lea     ecx, [ebp+var_48]
.text:000019CA                 call    ??4?$CMyComPtr@UIInStream@@@@QAEPAUIInStream@@ABV0@@Z ; CMyComPtr<IInStream>::operator=(CMyComPtr<IInStream> const &)
.text:000019CF                 mov     ecx, [ebp+var_24]
.text:000019D2                 push    ecx
.text:000019D3                 mov     ecx, [ebp+this]
.text:000019D6                 add     ecx, 14h
.text:000019D9                 call    ??A?$CRecordVector@_K@@QAEAA_KI@Z ; CRecordVector<unsigned __int64>::operator[](uint)
.text:000019DE                 mov     [ebp+var_78], eax
.text:000019E1                 mov     edx, [ebp+var_78]
.text:000019E4                 mov     eax, [edx]
.text:000019E6                 mov     [ebp+var_40], eax
.text:000019E9                 mov     ecx, [edx+4]
.text:000019EC                 mov     [ebp+var_3C], ecx
.text:000019EF                 lea     edx, [ebp+var_48]
.text:000019F2                 push    edx             ; struct CMultiStream::CSubStreamInfo *
.text:000019F3                 mov     ecx, [ebp+var_14]
.text:000019F6                 add     ecx, 1Ch
.text:000019F9                 call    ?Add@?$CObjectVector@UCSubStreamInfo@CMultiStream@@@@QAEIABUCSubStreamInfo@CMultiStream@@@Z ; CObjectVector<CMultiStream::CSubStreamInfo>::Add(CMultiStream::CSubStreamInfo const &)
.text:000019FE                 mov     byte ptr [ebp+var_4], 2
.text:00001A02                 lea     ecx, [ebp+var_48] ; this
.text:00001A05                 call    ??1CSubStreamInfo@CMultiStream@@QAE@XZ ; CMultiStream::CSubStreamInfo::~CSubStreamInfo(void)
.text:00001A0A                 jmp     loc_1983
.text:00001A0F ; ---------------------------------------------------------------------------
.text:00001A0F
.text:00001A0F loc_1A0F:                               ; CODE XREF: NArchive::NSplit::CHandler::GetStream(uint,ISequentialInStream * *)+D8j
.text:00001A0F                 mov     ecx, [ebp+var_14] ; this
.text:00001A12                 call    ?Init@CMultiStream@@QAEJXZ ; CMultiStream::Init(void)
.text:00001A17                 lea     ecx, [ebp+var_1C]
.text:00001A1A                 call    ?Detach@?$CMyComPtr@UISequentialInStream@@@@QAEPAUISequentialInStream@@XZ ; CMyComPtr<ISequentialInStream>::Detach(void)
.text:00001A1F                 mov     [ebp+var_7C], eax
.text:00001A22                 mov     eax, [ebp+arg_8]
.text:00001A25                 mov     ecx, [ebp+var_7C]
.text:00001A28                 mov     [eax], ecx
.text:00001A2A                 mov     [ebp+var_58], 0
.text:00001A31                 mov     byte ptr [ebp+var_4], 0
.text:00001A35                 lea     ecx, [ebp+var_1C]
.text:00001A38                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:00001A3D                 mov     eax, [ebp+var_58]
.text:00001A40                 jmp     short loc_1A68
.text:00001A40 ?GetStream@CHandler@NSplit@NArchive@@UAGJIPAPAUISequentialInStream@@@Z endp
.text:00001A40
.text:00001A42
.text:00001A42 ; =============== S U B R O U T I N E =======================================
.text:00001A42
.text:00001A42
.text:00001A42 __catch$?GetStream@CHandler@NSplit@NArchive@@UAGJIPAPAUISequentialInStream@@@Z$0 proc near
.text:00001A42                                         ; DATA XREF: .xdata$x:00001EB0o
.text:00001A42                 mov     dword ptr [ebp-5Ch], 8007000Eh
.text:00001A49                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text:00001A50                 mov     eax, offset $LN16
.text:00001A55                 retn
.text:00001A55 __catch$?GetStream@CHandler@NSplit@NArchive@@UAGJIPAPAUISequentialInStream@@@Z$0 endp
.text:00001A55
.text:00001A56 ; ---------------------------------------------------------------------------
.text:00001A56                 mov     eax, offset __tryend$?GetStream@CHandler@NSplit@NArchive@@UAGJIPAPAUISequentialInStream@@@Z$1
.text:00001A5B                 retn
.text:00001A5C ; ---------------------------------------------------------------------------
.text:00001A5C
.text:00001A5C __tryend$?GetStream@CHandler@NSplit@NArchive@@UAGJIPAPAUISequentialInStream@@@Z$1:
.text:00001A5C                                         ; DATA XREF: .text:00001A56o
.text:00001A5C                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text:00001A63                 jmp     short loc_1A68
.text:00001A65 ; ---------------------------------------------------------------------------
.text:00001A65
.text:00001A65 $LN16:                                  ; DATA XREF: __catch$?GetStream@CHandler@NSplit@NArchive@@UAGJIPAPAUISequentialInStream@@@Z$0+Eo
.text:00001A65                 mov     eax, [ebp-5Ch]
.text:00001A68 ; START OF FUNCTION CHUNK FOR ?GetStream@CHandler@NSplit@NArchive@@UAGJIPAPAUISequentialInStream@@@Z
.text:00001A68
.text:00001A68 loc_1A68:                               ; CODE XREF: NArchive::NSplit::CHandler::GetStream(uint,ISequentialInStream * *)+4Dj
.text:00001A68                                         ; NArchive::NSplit::CHandler::GetStream(uint,ISequentialInStream * *)+178j ...
.text:00001A68                 push    edx
.text:00001A69                 mov     ecx, ebp
.text:00001A6B                 push    eax
.text:00001A6C                 lea     edx, $LN22
.text:00001A72                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00001A77                 pop     eax
.text:00001A78                 pop     edx
.text:00001A79                 mov     ecx, [ebp+var_C]
.text:00001A7C                 mov     large fs:0, ecx
.text:00001A83                 pop     ecx
.text:00001A84                 pop     edi
.text:00001A85                 pop     esi
.text:00001A86                 pop     ebx
.text:00001A87                 add     esp, 7Ch
.text:00001A8A                 cmp     ebp, esp
.text:00001A8C                 call    __RTC_CheckEsp
.text:00001A91                 mov     esp, ebp
.text:00001A93                 pop     ebp
.text:00001A94                 retn    0Ch
.text:00001A94 ; END OF FUNCTION CHUNK FOR ?GetStream@CHandler@NSplit@NArchive@@UAGJIPAPAUISequentialInStream@@@Z
.text:00001A94 ; ---------------------------------------------------------------------------
.text:00001A97                 align 4
.text:00001A98 $LN22           dd 2                    ; DATA XREF: NArchive::NSplit::CHandler::GetStream(uint,ISequentialInStream * *)+1A4o
.text:00001A9C                 dd offset $LN21
.text:00001AA0 $LN21           dd 0FFFFFFE4h, 4        ; DATA XREF: .text:00001A9Co
.text:00001AA8                 dd offset $LN18         ; "streamTemp"
.text:00001AAC                 dd 0FFFFFFB8h, 20h
.text:00001AB4                 dd offset $LN19         ; "subStreamInfo"
.text:00001AB8 $LN19           db 'subStreamInfo',0    ; DATA XREF: .text:00001AB4o
.text:00001AC6 $LN18           db 'streamTemp',0       ; DATA XREF: .text:00001AA8o
.text:00001AD1                 align 8
.text:00001AD8
.text:00001AD8 ; =============== S U B R O U T I N E =======================================
.text:00001AD8
.text:00001AD8 ; Attributes: bp-based frame
.text:00001AD8
.text:00001AD8 ; struct IInArchive * __stdcall NArchive::NSplit::CreateArc(void)
.text:00001AD8 ?CreateArc@NSplit@NArchive@@YGPAUIInArchive@@XZ proc near
.text:00001AD8                                         ; DATA XREF: .rdata:0000003Co
.text:00001AD8
.text:00001AD8 var_18          = dword ptr -18h
.text:00001AD8 var_14          = dword ptr -14h
.text:00001AD8 var_10          = dword ptr -10h
.text:00001AD8 var_C           = dword ptr -0Ch
.text:00001AD8 var_4           = dword ptr -4
.text:00001AD8
.text:00001AD8                 push    ebp
.text:00001AD9                 mov     ebp, esp
.text:00001ADB                 push    0FFFFFFFFh
.text:00001ADD                 push    offset __ehhandler$?CreateArc@NSplit@NArchive@@YGPAUIInArchive@@XZ
.text:00001AE2                 mov     eax, large fs:0
.text:00001AE8                 push    eax
.text:00001AE9                 sub     esp, 0Ch
.text:00001AEC                 mov     [ebp+var_18], 0CCCCCCCCh
.text:00001AF3                 mov     [ebp+var_14], 0CCCCCCCCh
.text:00001AFA                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00001B01                 mov     eax, dword ptr ds:___security_cookie
.text:00001B06                 xor     eax, ebp
.text:00001B08                 push    eax
.text:00001B09                 lea     eax, [ebp+var_C]
.text:00001B0C                 mov     large fs:0, eax
.text:00001B12                 push    38h ; '8'       ; unsigned int
.text:00001B14                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00001B19                 add     esp, 4
.text:00001B1C                 mov     [ebp+var_14], eax
.text:00001B1F                 mov     [ebp+var_4], 0
.text:00001B26                 cmp     [ebp+var_14], 0
.text:00001B2A                 jz      short loc_1B39
.text:00001B2C                 mov     ecx, [ebp+var_14] ; this
.text:00001B2F                 call    ??0CHandler@NSplit@NArchive@@QAE@XZ ; NArchive::NSplit::CHandler::CHandler(void)
.text:00001B34                 mov     [ebp+var_18], eax
.text:00001B37                 jmp     short loc_1B40
.text:00001B39 ; ---------------------------------------------------------------------------
.text:00001B39
.text:00001B39 loc_1B39:                               ; CODE XREF: NArchive::NSplit::CreateArc(void)+52j
.text:00001B39                 mov     [ebp+var_18], 0
.text:00001B40
.text:00001B40 loc_1B40:                               ; CODE XREF: NArchive::NSplit::CreateArc(void)+5Fj
.text:00001B40                 mov     eax, [ebp+var_18]
.text:00001B43                 mov     [ebp+var_10], eax
.text:00001B46                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001B4D                 mov     eax, [ebp+var_10]
.text:00001B50                 mov     ecx, [ebp+var_C]
.text:00001B53                 mov     large fs:0, ecx
.text:00001B5A                 pop     ecx
.text:00001B5B                 add     esp, 18h
.text:00001B5E                 cmp     ebp, esp
.text:00001B60                 call    __RTC_CheckEsp
.text:00001B65                 mov     esp, ebp
.text:00001B67                 pop     ebp
.text:00001B68                 retn
.text:00001B68 ?CreateArc@NSplit@NArchive@@YGPAUIInArchive@@XZ endp
.text:00001B68
.text:00001B68 ; ---------------------------------------------------------------------------
.text:00001B69                 align 4
.text:00001B69 _text           ends
.text:00001B69
.rtc$TMZ:00001B6C ; ===========================================================================
.rtc$TMZ:00001B6C
.rtc$TMZ:00001B6C ; Segment type: Pure data
.rtc$TMZ:00001B6C ; Segment permissions: Read
.rtc$TMZ:00001B6C _rtc$TMZ        segment dword public 'DATA' use32
.rtc$TMZ:00001B6C                 assume cs:_rtc$TMZ
.rtc$TMZ:00001B6C                 ;org 1B6Ch
.rtc$TMZ:00001B6C ; COMDAT (pick any)
.rtc$TMZ:00001B6C __RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
.rtc$TMZ:00001B6C _rtc$TMZ        ends
.rtc$TMZ:00001B6C
.rtc$IMZ:00001B70 ; ===========================================================================
.rtc$IMZ:00001B70
.rtc$IMZ:00001B70 ; Segment type: Pure data
.rtc$IMZ:00001B70 ; Segment permissions: Read
.rtc$IMZ:00001B70 _rtc$IMZ        segment dword public 'DATA' use32
.rtc$IMZ:00001B70                 assume cs:_rtc$IMZ
.rtc$IMZ:00001B70                 ;org 1B70h
.rtc$IMZ:00001B70 ; COMDAT (pick any)
.rtc$IMZ:00001B70 __RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
.rtc$IMZ:00001B70 _rtc$IMZ        ends
.rtc$IMZ:00001B70
.text:00001B74 ; ===========================================================================
.text:00001B74
.text:00001B74 ; Segment type: Pure code
.text:00001B74 ; Segment permissions: Read/Execute
.text:00001B74 _text           segment para public 'CODE' use32
.text:00001B74                 assume cs:_text
.text:00001B74                 ;org 1B74h
.text:00001B74 ; COMDAT (pick any)
.text:00001B74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001B74
.text:00001B74 ; =============== S U B R O U T I N E =======================================
.text:00001B74
.text:00001B74 ; Attributes: bp-based frame
.text:00001B74
.text:00001B74 ; _DWORD __thiscall NWindows::NCOM::CPropVariant::CPropVariant(NWindows::NCOM::CPropVariant *__hidden this)
.text:00001B74                 public ??0CPropVariant@NCOM@NWindows@@QAE@XZ
.text:00001B74 ??0CPropVariant@NCOM@NWindows@@QAE@XZ proc near
.text:00001B74                                         ; CODE XREF: NArchive::NSplit::CHandler::GetArchiveProperty(ulong,tagPROPVARIANT *)+26p
.text:00001B74                                         ; NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+DDp ...
.text:00001B74
.text:00001B74 var_4           = dword ptr -4
.text:00001B74
.text:00001B74                 push    ebp
.text:00001B75                 mov     ebp, esp
.text:00001B77                 push    ecx
.text:00001B78                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001B7F                 mov     [ebp+var_4], ecx
.text:00001B82                 xor     eax, eax
.text:00001B84                 mov     ecx, [ebp+var_4]
.text:00001B87                 mov     [ecx], ax
.text:00001B8A                 xor     edx, edx
.text:00001B8C                 mov     eax, [ebp+var_4]
.text:00001B8F                 mov     [eax+2], dx
.text:00001B93                 mov     ecx, [ebp+var_4]
.text:00001B96                 mov     dword ptr [ecx+8], 0
.text:00001B9D                 mov     eax, [ebp+var_4]
.text:00001BA0                 mov     esp, ebp
.text:00001BA2                 pop     ebp
.text:00001BA3                 retn
.text:00001BA3 ??0CPropVariant@NCOM@NWindows@@QAE@XZ endp
.text:00001BA3
.text:00001BA3 _text           ends
.text:00001BA3
.text:00001BA4 ; ===========================================================================
.text:00001BA4
.text:00001BA4 ; Segment type: Pure code
.text:00001BA4 ; Segment permissions: Read/Execute
.text:00001BA4 _text           segment para public 'CODE' use32
.text:00001BA4                 assume cs:_text
.text:00001BA4                 ;org 1BA4h
.text:00001BA4 ; COMDAT (pick any)
.text:00001BA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001BA4
.text:00001BA4 ; =============== S U B R O U T I N E =======================================
.text:00001BA4
.text:00001BA4 ; Attributes: bp-based frame
.text:00001BA4
.text:00001BA4 ; _DWORD __thiscall NWindows::NCOM::CPropVariant::~CPropVariant(NWindows::NCOM::CPropVariant *__hidden this)
.text:00001BA4                 public ??1CPropVariant@NCOM@NWindows@@QAE@XZ
.text:00001BA4 ??1CPropVariant@NCOM@NWindows@@QAE@XZ proc near
.text:00001BA4                                         ; CODE XREF: NArchive::NSplit::CHandler::GetArchiveProperty(ulong,tagPROPVARIANT *)+CCp
.text:00001BA4                                         ; NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+130p ...
.text:00001BA4
.text:00001BA4 var_4           = dword ptr -4
.text:00001BA4
.text:00001BA4                 push    ebp
.text:00001BA5                 mov     ebp, esp
.text:00001BA7                 push    ecx
.text:00001BA8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001BAF                 mov     [ebp+var_4], ecx
.text:00001BB2                 mov     ecx, [ebp+var_4] ; this
.text:00001BB5                 call    ?Clear@CPropVariant@NCOM@NWindows@@QAEJXZ ; NWindows::NCOM::CPropVariant::Clear(void)
.text:00001BBA                 add     esp, 4
.text:00001BBD                 cmp     ebp, esp
.text:00001BBF                 call    __RTC_CheckEsp
.text:00001BC4                 mov     esp, ebp
.text:00001BC6                 pop     ebp
.text:00001BC7                 retn
.text:00001BC7 ??1CPropVariant@NCOM@NWindows@@QAE@XZ endp
.text:00001BC7
.text:00001BC7 _text           ends
.text:00001BC7
.text$x:00001BC8 ; ===========================================================================
.text$x:00001BC8
.text$x:00001BC8 ; Segment type: Pure code
.text$x:00001BC8 ; Segment permissions: Read/Execute
.text$x:00001BC8 _text$x         segment para public 'CODE' use32
.text$x:00001BC8                 assume cs:_text$x
.text$x:00001BC8                 ;org 1BC8h
.text$x:00001BC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001BC8
.text$x:00001BC8 ; =============== S U B R O U T I N E =======================================
.text$x:00001BC8
.text$x:00001BC8
.text$x:00001BC8 __unwindfunclet$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z$0 proc near
.text$x:00001BC8                                         ; DATA XREF: .xdata$x:00001D60o
.text$x:00001BC8                 lea     ecx, [ebp-18h]
.text$x:00001BCB                 jmp     ??1?$CMyComPtr@UIArchiveOpenVolumeCallback@@@@QAE@XZ ; CMyComPtr<IArchiveOpenVolumeCallback>::~CMyComPtr<IArchiveOpenVolumeCallback>(void)
.text$x:00001BCB __unwindfunclet$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z$0 endp
.text$x:00001BCB
.text$x:00001BD0
.text$x:00001BD0 ; =============== S U B R O U T I N E =======================================
.text$x:00001BD0
.text$x:00001BD0
.text$x:00001BD0 __unwindfunclet$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z$1 proc near
.text$x:00001BD0                                         ; DATA XREF: .xdata$x:00001D68o
.text$x:00001BD0                 lea     ecx, [ebp-2Ch]  ; this
.text$x:00001BD3                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00001BD3 __unwindfunclet$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z$1 endp
.text$x:00001BD3
.text$x:00001BD8
.text$x:00001BD8 ; =============== S U B R O U T I N E =======================================
.text$x:00001BD8
.text$x:00001BD8
.text$x:00001BD8 __unwindfunclet$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z$2 proc near
.text$x:00001BD8                                         ; DATA XREF: .xdata$x:00001D70o
.text$x:00001BD8                 lea     ecx, [ebp-44h]  ; this
.text$x:00001BDB                 jmp     ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text$x:00001BDB __unwindfunclet$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z$2 endp
.text$x:00001BDB
.text$x:00001BE0
.text$x:00001BE0 ; =============== S U B R O U T I N E =======================================
.text$x:00001BE0
.text$x:00001BE0
.text$x:00001BE0 __unwindfunclet$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z$3 proc near
.text$x:00001BE0                                         ; DATA XREF: .xdata$x:00001D78o
.text$x:00001BE0                 lea     ecx, [ebp-60h]  ; this
.text$x:00001BE3                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00001BE3 __unwindfunclet$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z$3 endp
.text$x:00001BE3
.text$x:00001BE8
.text$x:00001BE8 ; =============== S U B R O U T I N E =======================================
.text$x:00001BE8
.text$x:00001BE8
.text$x:00001BE8 __unwindfunclet$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z$4 proc near
.text$x:00001BE8                                         ; DATA XREF: .xdata$x:00001D80o
.text$x:00001BE8                 lea     ecx, [ebp-74h]  ; this
.text$x:00001BEB                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00001BEB __unwindfunclet$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z$4 endp
.text$x:00001BEB
.text$x:00001BF0
.text$x:00001BF0 ; =============== S U B R O U T I N E =======================================
.text$x:00001BF0
.text$x:00001BF0
.text$x:00001BF0 __unwindfunclet$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z$5 proc near
.text$x:00001BF0                                         ; DATA XREF: .xdata$x:00001D88o
.text$x:00001BF0                 lea     ecx, [ebp-88h]  ; this
.text$x:00001BF6                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00001BF6 __unwindfunclet$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z$5 endp
.text$x:00001BF6
.text$x:00001BFB
.text$x:00001BFB ; =============== S U B R O U T I N E =======================================
.text$x:00001BFB
.text$x:00001BFB
.text$x:00001BFB __unwindfunclet$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z$6 proc near
.text$x:00001BFB                                         ; DATA XREF: .xdata$x:00001D90o
.text$x:00001BFB                 lea     ecx, [ebp-0ACh] ; this
.text$x:00001C01                 jmp     ??1CSeqName@NSplit@NArchive@@QAE@XZ ; NArchive::NSplit::CSeqName::~CSeqName(void)
.text$x:00001C01 __unwindfunclet$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z$6 endp
.text$x:00001C01
.text$x:00001C06
.text$x:00001C06 ; =============== S U B R O U T I N E =======================================
.text$x:00001C06
.text$x:00001C06
.text$x:00001C06 __unwindfunclet$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z$7 proc near
.text$x:00001C06                                         ; DATA XREF: .xdata$x:00001D98o
.text$x:00001C06                 lea     ecx, [ebp-164h] ; this
.text$x:00001C0C                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00001C0C __unwindfunclet$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z$7 endp
.text$x:00001C0C
.text$x:00001C11
.text$x:00001C11 ; =============== S U B R O U T I N E =======================================
.text$x:00001C11
.text$x:00001C11
.text$x:00001C11 __unwindfunclet$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z$8 proc near
.text$x:00001C11                                         ; DATA XREF: .xdata$x:00001DA0o
.text$x:00001C11                 lea     ecx, [ebp-170h] ; this
.text$x:00001C17                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00001C17 __unwindfunclet$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z$8 endp
.text$x:00001C17
.text$x:00001C1C
.text$x:00001C1C ; =============== S U B R O U T I N E =======================================
.text$x:00001C1C
.text$x:00001C1C
.text$x:00001C1C __unwindfunclet$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z$9 proc near
.text$x:00001C1C                                         ; DATA XREF: .xdata$x:00001DA8o
.text$x:00001C1C                 lea     ecx, [ebp-0D4h] ; this
.text$x:00001C22                 jmp     ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text$x:00001C22 __unwindfunclet$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z$9 endp
.text$x:00001C22
.text$x:00001C27
.text$x:00001C27 ; =============== S U B R O U T I N E =======================================
.text$x:00001C27
.text$x:00001C27
.text$x:00001C27 __unwindfunclet$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z$10 proc near
.text$x:00001C27                                         ; DATA XREF: .xdata$x:00001DB0o
.text$x:00001C27                 lea     ecx, [ebp-17Ch]
.text$x:00001C2D                 jmp     ??1?$CMyComPtr@UIInStream@@@@QAE@XZ ; CMyComPtr<IInStream>::~CMyComPtr<IInStream>(void)
.text$x:00001C2D __unwindfunclet$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z$10 endp
.text$x:00001C2D
.text$x:00001C32
.text$x:00001C32 ; =============== S U B R O U T I N E =======================================
.text$x:00001C32
.text$x:00001C32
.text$x:00001C32 __unwindfunclet$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z$11 proc near
.text$x:00001C32                                         ; DATA XREF: .xdata$x:00001DB8o
.text$x:00001C32                 lea     ecx, [ebp-100h] ; this
.text$x:00001C38                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00001C38 __unwindfunclet$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z$11 endp
.text$x:00001C38
.text$x:00001C3D
.text$x:00001C3D ; =============== S U B R O U T I N E =======================================
.text$x:00001C3D
.text$x:00001C3D
.text$x:00001C3D __unwindfunclet$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z$12 proc near
.text$x:00001C3D                                         ; DATA XREF: .xdata$x:00001DC0o
.text$x:00001C3D                 lea     ecx, [ebp-10Ch]
.text$x:00001C43                 jmp     ??1?$CMyComPtr@UIInStream@@@@QAE@XZ ; CMyComPtr<IInStream>::~CMyComPtr<IInStream>(void)
.text$x:00001C43 __unwindfunclet$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z$12 endp
.text$x:00001C43
.text$x:00001C48
.text$x:00001C48 ; =============== S U B R O U T I N E =======================================
.text$x:00001C48
.text$x:00001C48
.text$x:00001C48 __unwindfunclet$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z$13 proc near
.text$x:00001C48                                         ; DATA XREF: .xdata$x:00001DC8o
.text$x:00001C48                 lea     ecx, [ebp-128h] ; this
.text$x:00001C4E                 jmp     ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text$x:00001C4E __unwindfunclet$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z$13 endp
.text$x:00001C4E
.text$x:00001C53
.text$x:00001C53 ; =============== S U B R O U T I N E =======================================
.text$x:00001C53
.text$x:00001C53
.text$x:00001C53 __ehhandler$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z proc near
.text$x:00001C53                                         ; DATA XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+5o
.text$x:00001C53
.text$x:00001C53 arg_4           = dword ptr  8
.text$x:00001C53
.text$x:00001C53                 mov     edx, [esp+arg_4]
.text$x:00001C57                 lea     eax, [edx+0Ch]
.text$x:00001C5A                 mov     ecx, [edx-1B8h]
.text$x:00001C60                 xor     ecx, eax
.text$x:00001C62                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001C67                 mov     eax, offset __ehfuncinfo$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z
.text$x:00001C6C                 jmp     ___CxxFrameHandler3
.text$x:00001C6C __ehhandler$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z endp
.text$x:00001C6C
.text$x:00001C71
.text$x:00001C71 ; =============== S U B R O U T I N E =======================================
.text$x:00001C71
.text$x:00001C71
.text$x:00001C71 __ehhandler$?Open@CHandler@NSplit@NArchive@@UAGJPAUIInStream@@PB_KPAUIArchiveOpenCallback@@@Z proc near
.text$x:00001C71                                         ; DATA XREF: NArchive::NSplit::CHandler::Open(IInStream *,unsigned __int64 const *,IArchiveOpenCallback *)+5o
.text$x:00001C71
.text$x:00001C71 arg_4           = dword ptr  8
.text$x:00001C71
.text$x:00001C71                 mov     edx, [esp+arg_4]
.text$x:00001C75                 lea     eax, [edx+0Ch]
.text$x:00001C78                 mov     ecx, [edx-20h]
.text$x:00001C7B                 xor     ecx, eax
.text$x:00001C7D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001C82                 mov     eax, offset __ehfuncinfo$?Open@CHandler@NSplit@NArchive@@UAGJPAUIInStream@@PB_KPAUIArchiveOpenCallback@@@Z
.text$x:00001C87                 jmp     ___CxxFrameHandler3
.text$x:00001C87 __ehhandler$?Open@CHandler@NSplit@NArchive@@UAGJPAUIInStream@@PB_KPAUIArchiveOpenCallback@@@Z endp
.text$x:00001C87
.text$x:00001C8C
.text$x:00001C8C ; =============== S U B R O U T I N E =======================================
.text$x:00001C8C
.text$x:00001C8C
.text$x:00001C8C __unwindfunclet$?Extract@CHandler@NSplit@NArchive@@UAGJPBIIHPAUIArchiveExtractCallback@@@Z$2 proc near
.text$x:00001C8C                                         ; DATA XREF: .xdata$x:00001E78o
.text$x:00001C8C                 lea     ecx, [ebp-24h]
.text$x:00001C8F                 jmp     ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text$x:00001C8F __unwindfunclet$?Extract@CHandler@NSplit@NArchive@@UAGJPBIIHPAUIArchiveExtractCallback@@@Z$2 endp
.text$x:00001C8F
.text$x:00001C94
.text$x:00001C94 ; =============== S U B R O U T I N E =======================================
.text$x:00001C94
.text$x:00001C94
.text$x:00001C94 __unwindfunclet$?Extract@CHandler@NSplit@NArchive@@UAGJPBIIHPAUIArchiveExtractCallback@@@Z$3 proc near
.text$x:00001C94                                         ; DATA XREF: .xdata$x:00001E80o
.text$x:00001C94                 mov     eax, [ebp-7Ch]
.text$x:00001C97                 push    eax             ; void *
.text$x:00001C98                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00001C9D                 pop     ecx
.text$x:00001C9E                 retn
.text$x:00001C9E __unwindfunclet$?Extract@CHandler@NSplit@NArchive@@UAGJPBIIHPAUIArchiveExtractCallback@@@Z$3 endp
.text$x:00001C9E
.text$x:00001C9F
.text$x:00001C9F ; =============== S U B R O U T I N E =======================================
.text$x:00001C9F
.text$x:00001C9F
.text$x:00001C9F __unwindfunclet$?Extract@CHandler@NSplit@NArchive@@UAGJPBIIHPAUIArchiveExtractCallback@@@Z$4 proc near
.text$x:00001C9F                                         ; DATA XREF: .xdata$x:00001E88o
.text$x:00001C9F                 lea     ecx, [ebp-40h]
.text$x:00001CA2                 jmp     ??1?$CMyComPtr@UICompressCoder@@@@QAE@XZ ; CMyComPtr<ICompressCoder>::~CMyComPtr<ICompressCoder>(void)
.text$x:00001CA2 __unwindfunclet$?Extract@CHandler@NSplit@NArchive@@UAGJPBIIHPAUIArchiveExtractCallback@@@Z$4 endp
.text$x:00001CA2
.text$x:00001CA7
.text$x:00001CA7 ; =============== S U B R O U T I N E =======================================
.text$x:00001CA7
.text$x:00001CA7
.text$x:00001CA7 __unwindfunclet$?Extract@CHandler@NSplit@NArchive@@UAGJPBIIHPAUIArchiveExtractCallback@@@Z$5 proc near
.text$x:00001CA7                                         ; DATA XREF: .xdata$x:00001E90o
.text$x:00001CA7                 mov     eax, [ebp-84h]
.text$x:00001CAD                 push    eax             ; void *
.text$x:00001CAE                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00001CB3                 pop     ecx
.text$x:00001CB4                 retn
.text$x:00001CB4 __unwindfunclet$?Extract@CHandler@NSplit@NArchive@@UAGJPBIIHPAUIArchiveExtractCallback@@@Z$5 endp
.text$x:00001CB4
.text$x:00001CB5
.text$x:00001CB5 ; =============== S U B R O U T I N E =======================================
.text$x:00001CB5
.text$x:00001CB5
.text$x:00001CB5 __unwindfunclet$?Extract@CHandler@NSplit@NArchive@@UAGJPBIIHPAUIArchiveExtractCallback@@@Z$6 proc near
.text$x:00001CB5                                         ; DATA XREF: .xdata$x:00001E98o
.text$x:00001CB5                 lea     ecx, [ebp-50h]
.text$x:00001CB8                 jmp     ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ ; CMyComPtr<ICompressProgressInfo>::~CMyComPtr<ICompressProgressInfo>(void)
.text$x:00001CB8 __unwindfunclet$?Extract@CHandler@NSplit@NArchive@@UAGJPBIIHPAUIArchiveExtractCallback@@@Z$6 endp
.text$x:00001CB8
.text$x:00001CBD
.text$x:00001CBD ; =============== S U B R O U T I N E =======================================
.text$x:00001CBD
.text$x:00001CBD
.text$x:00001CBD __ehhandler$?Extract@CHandler@NSplit@NArchive@@UAGJPBIIHPAUIArchiveExtractCallback@@@Z proc near
.text$x:00001CBD                                         ; DATA XREF: NArchive::NSplit::CHandler::Extract(uint const *,uint,int,IArchiveExtractCallback *)+5o
.text$x:00001CBD
.text$x:00001CBD arg_4           = dword ptr  8
.text$x:00001CBD
.text$x:00001CBD                 mov     edx, [esp+arg_4]
.text$x:00001CC1                 lea     eax, [edx+0Ch]
.text$x:00001CC4                 mov     ecx, [edx-0F8h]
.text$x:00001CCA                 xor     ecx, eax
.text$x:00001CCC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001CD1                 mov     eax, offset __ehfuncinfo$?Extract@CHandler@NSplit@NArchive@@UAGJPBIIHPAUIArchiveExtractCallback@@@Z
.text$x:00001CD6                 jmp     ___CxxFrameHandler3
.text$x:00001CD6 __ehhandler$?Extract@CHandler@NSplit@NArchive@@UAGJPBIIHPAUIArchiveExtractCallback@@@Z endp
.text$x:00001CD6
.text$x:00001CDB
.text$x:00001CDB ; =============== S U B R O U T I N E =======================================
.text$x:00001CDB
.text$x:00001CDB
.text$x:00001CDB __unwindfunclet$?GetStream@CHandler@NSplit@NArchive@@UAGJIPAPAUISequentialInStream@@@Z$2 proc near
.text$x:00001CDB                                         ; DATA XREF: .xdata$x:00001EF8o
.text$x:00001CDB                 mov     eax, [ebp-54h]
.text$x:00001CDE                 push    eax             ; void *
.text$x:00001CDF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00001CE4                 pop     ecx
.text$x:00001CE5                 retn
.text$x:00001CE5 __unwindfunclet$?GetStream@CHandler@NSplit@NArchive@@UAGJIPAPAUISequentialInStream@@@Z$2 endp
.text$x:00001CE5
.text$x:00001CE6
.text$x:00001CE6 ; =============== S U B R O U T I N E =======================================
.text$x:00001CE6
.text$x:00001CE6
.text$x:00001CE6 __unwindfunclet$?GetStream@CHandler@NSplit@NArchive@@UAGJIPAPAUISequentialInStream@@@Z$3 proc near
.text$x:00001CE6                                         ; DATA XREF: .xdata$x:00001F00o
.text$x:00001CE6                 lea     ecx, [ebp-1Ch]
.text$x:00001CE9                 jmp     ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text$x:00001CE9 __unwindfunclet$?GetStream@CHandler@NSplit@NArchive@@UAGJIPAPAUISequentialInStream@@@Z$3 endp
.text$x:00001CE9
.text$x:00001CEE
.text$x:00001CEE ; =============== S U B R O U T I N E =======================================
.text$x:00001CEE
.text$x:00001CEE
.text$x:00001CEE __unwindfunclet$?GetStream@CHandler@NSplit@NArchive@@UAGJIPAPAUISequentialInStream@@@Z$4 proc near
.text$x:00001CEE                                         ; DATA XREF: .xdata$x:00001F08o
.text$x:00001CEE                 lea     ecx, [ebp-48h]  ; this
.text$x:00001CF1                 jmp     ??1CSubStreamInfo@CMultiStream@@QAE@XZ ; CMultiStream::CSubStreamInfo::~CSubStreamInfo(void)
.text$x:00001CF1 __unwindfunclet$?GetStream@CHandler@NSplit@NArchive@@UAGJIPAPAUISequentialInStream@@@Z$4 endp
.text$x:00001CF1
.text$x:00001CF6
.text$x:00001CF6 ; =============== S U B R O U T I N E =======================================
.text$x:00001CF6
.text$x:00001CF6
.text$x:00001CF6 __ehhandler$?GetStream@CHandler@NSplit@NArchive@@UAGJIPAPAUISequentialInStream@@@Z proc near
.text$x:00001CF6                                         ; DATA XREF: NArchive::NSplit::CHandler::GetStream(uint,ISequentialInStream * *)+5o
.text$x:00001CF6
.text$x:00001CF6 arg_4           = dword ptr  8
.text$x:00001CF6
.text$x:00001CF6                 mov     edx, [esp+arg_4]
.text$x:00001CFA                 lea     eax, [edx+0Ch]
.text$x:00001CFD                 mov     ecx, [edx-80h]
.text$x:00001D00                 xor     ecx, eax
.text$x:00001D02                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001D07                 mov     eax, offset __ehfuncinfo$?GetStream@CHandler@NSplit@NArchive@@UAGJIPAPAUISequentialInStream@@@Z
.text$x:00001D0C                 jmp     ___CxxFrameHandler3
.text$x:00001D0C __ehhandler$?GetStream@CHandler@NSplit@NArchive@@UAGJIPAPAUISequentialInStream@@@Z endp
.text$x:00001D0C
.text$x:00001D11
.text$x:00001D11 ; =============== S U B R O U T I N E =======================================
.text$x:00001D11
.text$x:00001D11
.text$x:00001D11 __unwindfunclet$?CreateArc@NSplit@NArchive@@YGPAUIInArchive@@XZ$0 proc near
.text$x:00001D11                                         ; DATA XREF: .xdata$x:00001F18o
.text$x:00001D11                 mov     eax, [ebp-14h]
.text$x:00001D14                 push    eax             ; void *
.text$x:00001D15                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00001D1A                 pop     ecx
.text$x:00001D1B                 retn
.text$x:00001D1B __unwindfunclet$?CreateArc@NSplit@NArchive@@YGPAUIInArchive@@XZ$0 endp
.text$x:00001D1B
.text$x:00001D1C
.text$x:00001D1C ; =============== S U B R O U T I N E =======================================
.text$x:00001D1C
.text$x:00001D1C
.text$x:00001D1C __ehhandler$?CreateArc@NSplit@NArchive@@YGPAUIInArchive@@XZ proc near
.text$x:00001D1C                                         ; DATA XREF: NArchive::NSplit::CreateArc(void)+5o
.text$x:00001D1C
.text$x:00001D1C arg_4           = dword ptr  8
.text$x:00001D1C
.text$x:00001D1C                 mov     edx, [esp+arg_4]
.text$x:00001D20                 lea     eax, [edx+0Ch]
.text$x:00001D23                 mov     ecx, [edx-10h]
.text$x:00001D26                 xor     ecx, eax
.text$x:00001D28                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001D2D                 mov     eax, offset __ehfuncinfo$?CreateArc@NSplit@NArchive@@YGPAUIInArchive@@XZ
.text$x:00001D32                 jmp     ___CxxFrameHandler3
.text$x:00001D32 __ehhandler$?CreateArc@NSplit@NArchive@@YGPAUIInArchive@@XZ endp
.text$x:00001D32
.text$x:00001D32 ; ---------------------------------------------------------------------------
.text$x:00001D37                 align 4
.text$x:00001D37 _text$x         ends
.text$x:00001D37
.xdata$x:00001D38 ; ===========================================================================
.xdata$x:00001D38
.xdata$x:00001D38 ; Segment type: Pure data
.xdata$x:00001D38 ; Segment permissions: Read
.xdata$x:00001D38 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001D38                 assume cs:_xdata$x
.xdata$x:00001D38                 ;org 1D38h
.xdata$x:00001D38 __ehfuncinfo$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z db  22h ; "
.xdata$x:00001D38                                         ; DATA XREF: __ehhandler$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z+14o
.xdata$x:00001D39                 db    5
.xdata$x:00001D3A                 db  93h ; ô
.xdata$x:00001D3B                 db  19h
.xdata$x:00001D3C                 db  0Eh
.xdata$x:00001D3D                 db    0
.xdata$x:00001D3E                 db    0
.xdata$x:00001D3F                 db    0
.xdata$x:00001D40                 dd offset __unwindtable$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z
.xdata$x:00001D44                 db    0
.xdata$x:00001D45                 db    0
.xdata$x:00001D46                 db    0
.xdata$x:00001D47                 db    0
.xdata$x:00001D48                 db    0
.xdata$x:00001D49                 db    0
.xdata$x:00001D4A                 db    0
.xdata$x:00001D4B                 db    0
.xdata$x:00001D4C                 db    0
.xdata$x:00001D4D                 db    0
.xdata$x:00001D4E                 db    0
.xdata$x:00001D4F                 db    0
.xdata$x:00001D50                 db    0
.xdata$x:00001D51                 db    0
.xdata$x:00001D52                 db    0
.xdata$x:00001D53                 db    0
.xdata$x:00001D54                 db    0
.xdata$x:00001D55                 db    0
.xdata$x:00001D56                 db    0
.xdata$x:00001D57                 db    0
.xdata$x:00001D58                 db    1
.xdata$x:00001D59                 db    0
.xdata$x:00001D5A                 db    0
.xdata$x:00001D5B                 db    0
.xdata$x:00001D5C __unwindtable$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z db 0FFh
.xdata$x:00001D5C                                         ; DATA XREF: .xdata$x:00001D40o
.xdata$x:00001D5D                 db 0FFh
.xdata$x:00001D5E                 db 0FFh
.xdata$x:00001D5F                 db 0FFh
.xdata$x:00001D60                 dd offset __unwindfunclet$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z$0
.xdata$x:00001D64                 align 8
.xdata$x:00001D68                 dd offset __unwindfunclet$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z$1
.xdata$x:00001D6C                 db    1
.xdata$x:00001D6D                 db    0
.xdata$x:00001D6E                 db    0
.xdata$x:00001D6F                 db    0
.xdata$x:00001D70                 dd offset __unwindfunclet$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z$2
.xdata$x:00001D74                 db    1
.xdata$x:00001D75                 db    0
.xdata$x:00001D76                 db    0
.xdata$x:00001D77                 db    0
.xdata$x:00001D78                 dd offset __unwindfunclet$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z$3
.xdata$x:00001D7C                 db    3
.xdata$x:00001D7D                 db    0
.xdata$x:00001D7E                 db    0
.xdata$x:00001D7F                 db    0
.xdata$x:00001D80                 dd offset __unwindfunclet$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z$4
.xdata$x:00001D84                 db    4
.xdata$x:00001D85                 db    0
.xdata$x:00001D86                 db    0
.xdata$x:00001D87                 db    0
.xdata$x:00001D88                 dd offset __unwindfunclet$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z$5
.xdata$x:00001D8C                 db    5
.xdata$x:00001D8D                 db    0
.xdata$x:00001D8E                 db    0
.xdata$x:00001D8F                 db    0
.xdata$x:00001D90                 dd offset __unwindfunclet$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z$6
.xdata$x:00001D94                 db    6
.xdata$x:00001D95                 db    0
.xdata$x:00001D96                 db    0
.xdata$x:00001D97                 db    0
.xdata$x:00001D98                 dd offset __unwindfunclet$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z$7
.xdata$x:00001D9C                 db    7
.xdata$x:00001D9D                 db    0
.xdata$x:00001D9E                 db    0
.xdata$x:00001D9F                 db    0
.xdata$x:00001DA0                 dd offset __unwindfunclet$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z$8
.xdata$x:00001DA4                 db    6
.xdata$x:00001DA5                 db    0
.xdata$x:00001DA6                 db    0
.xdata$x:00001DA7                 db    0
.xdata$x:00001DA8                 dd offset __unwindfunclet$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z$9
.xdata$x:00001DAC                 db    6
.xdata$x:00001DAD                 db    0
.xdata$x:00001DAE                 db    0
.xdata$x:00001DAF                 db    0
.xdata$x:00001DB0                 dd offset __unwindfunclet$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z$10
.xdata$x:00001DB4                 db    6
.xdata$x:00001DB5                 db    0
.xdata$x:00001DB6                 db    0
.xdata$x:00001DB7                 db    0
.xdata$x:00001DB8                 dd offset __unwindfunclet$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z$11
.xdata$x:00001DBC                 db  0Bh
.xdata$x:00001DBD                 db    0
.xdata$x:00001DBE                 db    0
.xdata$x:00001DBF                 db    0
.xdata$x:00001DC0                 dd offset __unwindfunclet$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z$12
.xdata$x:00001DC4                 db  0Ch
.xdata$x:00001DC5                 db    0
.xdata$x:00001DC6                 db    0
.xdata$x:00001DC7                 db    0
.xdata$x:00001DC8                 dd offset __unwindfunclet$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z$13
.xdata$x:00001DCC __catchsym$?Open@CHandler@NSplit@NArchive@@UAGJPAUIInStream@@PB_KPAUIArchiveOpenCallback@@@Z$2 dd offset unk_40
.xdata$x:00001DCC                                         ; DATA XREF: .xdata$x:00001DFCo
.xdata$x:00001DD0                 db    0
.xdata$x:00001DD1                 db    0
.xdata$x:00001DD2                 db    0
.xdata$x:00001DD3                 db    0
.xdata$x:00001DD4                 db    0
.xdata$x:00001DD5                 db    0
.xdata$x:00001DD6                 db    0
.xdata$x:00001DD7                 db    0
.xdata$x:00001DD8                 dd offset __catch$?Open@CHandler@NSplit@NArchive@@UAGJPAUIInStream@@PB_KPAUIArchiveOpenCallback@@@Z$0
.xdata$x:00001DDC __unwindtable$?Open@CHandler@NSplit@NArchive@@UAGJPAUIInStream@@PB_KPAUIArchiveOpenCallback@@@Z db 0FFh
.xdata$x:00001DDC                                         ; DATA XREF: .xdata$x:00001E08o
.xdata$x:00001DDD                 db 0FFh
.xdata$x:00001DDE                 db 0FFh
.xdata$x:00001DDF                 db 0FFh
.xdata$x:00001DE0                 db    0
.xdata$x:00001DE1                 db    0
.xdata$x:00001DE2                 db    0
.xdata$x:00001DE3                 db    0
.xdata$x:00001DE4                 db 0FFh
.xdata$x:00001DE5                 db 0FFh
.xdata$x:00001DE6                 db 0FFh
.xdata$x:00001DE7                 db 0FFh
.xdata$x:00001DE8                 db    0
.xdata$x:00001DE9                 db    0
.xdata$x:00001DEA                 db    0
.xdata$x:00001DEB                 db    0
.xdata$x:00001DEC __tryblocktable$?Open@CHandler@NSplit@NArchive@@UAGJPAUIInStream@@PB_KPAUIArchiveOpenCallback@@@Z db    0
.xdata$x:00001DEC                                         ; DATA XREF: .xdata$x:00001E10o
.xdata$x:00001DED                 db    0
.xdata$x:00001DEE                 db    0
.xdata$x:00001DEF                 db    0
.xdata$x:00001DF0                 db    0
.xdata$x:00001DF1                 db    0
.xdata$x:00001DF2                 db    0
.xdata$x:00001DF3                 db    0
.xdata$x:00001DF4                 db    1
.xdata$x:00001DF5                 db    0
.xdata$x:00001DF6                 db    0
.xdata$x:00001DF7                 db    0
.xdata$x:00001DF8                 db    1
.xdata$x:00001DF9                 db    0
.xdata$x:00001DFA                 db    0
.xdata$x:00001DFB                 db    0
.xdata$x:00001DFC                 dd offset __catchsym$?Open@CHandler@NSplit@NArchive@@UAGJPAUIInStream@@PB_KPAUIArchiveOpenCallback@@@Z$2
.xdata$x:00001E00 __ehfuncinfo$?Open@CHandler@NSplit@NArchive@@UAGJPAUIInStream@@PB_KPAUIArchiveOpenCallback@@@Z db  22h ; "
.xdata$x:00001E00                                         ; DATA XREF: __ehhandler$?Open@CHandler@NSplit@NArchive@@UAGJPAUIInStream@@PB_KPAUIArchiveOpenCallback@@@Z+11o
.xdata$x:00001E01                 db    5
.xdata$x:00001E02                 db  93h ; ô
.xdata$x:00001E03                 db  19h
.xdata$x:00001E04                 db    2
.xdata$x:00001E05                 db    0
.xdata$x:00001E06                 db    0
.xdata$x:00001E07                 db    0
.xdata$x:00001E08                 dd offset __unwindtable$?Open@CHandler@NSplit@NArchive@@UAGJPAUIInStream@@PB_KPAUIArchiveOpenCallback@@@Z
.xdata$x:00001E0C                 db    1
.xdata$x:00001E0D                 db    0
.xdata$x:00001E0E                 db    0
.xdata$x:00001E0F                 db    0
.xdata$x:00001E10                 dd offset __tryblocktable$?Open@CHandler@NSplit@NArchive@@UAGJPAUIInStream@@PB_KPAUIArchiveOpenCallback@@@Z
.xdata$x:00001E14                 align 10h
.xdata$x:00001E20                 db    1
.xdata$x:00001E21                 db    0
.xdata$x:00001E22                 db    0
.xdata$x:00001E23                 db    0
.xdata$x:00001E24 __catchsym$?Extract@CHandler@NSplit@NArchive@@UAGJPBIIHPAUIArchiveExtractCallback@@@Z$7 dd offset unk_40
.xdata$x:00001E24                                         ; DATA XREF: .xdata$x:00001E44o
.xdata$x:00001E28                 align 10h
.xdata$x:00001E30                 dd offset __catch$?Extract@CHandler@NSplit@NArchive@@UAGJPBIIHPAUIArchiveExtractCallback@@@Z$0
.xdata$x:00001E34 __tryblocktable$?Extract@CHandler@NSplit@NArchive@@UAGJPBIIHPAUIArchiveExtractCallback@@@Z db    0
.xdata$x:00001E34                                         ; DATA XREF: .xdata$x:00001E58o
.xdata$x:00001E35                 db    0
.xdata$x:00001E36                 db    0
.xdata$x:00001E37                 db    0
.xdata$x:00001E38                 db    5
.xdata$x:00001E39                 db    0
.xdata$x:00001E3A                 db    0
.xdata$x:00001E3B                 db    0
.xdata$x:00001E3C                 db    6
.xdata$x:00001E3D                 db    0
.xdata$x:00001E3E                 db    0
.xdata$x:00001E3F                 db    0
.xdata$x:00001E40                 db    1
.xdata$x:00001E41                 db    0
.xdata$x:00001E42                 db    0
.xdata$x:00001E43                 db    0
.xdata$x:00001E44                 dd offset __catchsym$?Extract@CHandler@NSplit@NArchive@@UAGJPBIIHPAUIArchiveExtractCallback@@@Z$7
.xdata$x:00001E48 __ehfuncinfo$?Extract@CHandler@NSplit@NArchive@@UAGJPBIIHPAUIArchiveExtractCallback@@@Z db  22h ; "
.xdata$x:00001E48                                         ; DATA XREF: __ehhandler$?Extract@CHandler@NSplit@NArchive@@UAGJPBIIHPAUIArchiveExtractCallback@@@Z+14o
.xdata$x:00001E49                 db    5
.xdata$x:00001E4A                 db  93h ; ô
.xdata$x:00001E4B                 db  19h
.xdata$x:00001E4C                 db    7
.xdata$x:00001E4D                 db    0
.xdata$x:00001E4E                 db    0
.xdata$x:00001E4F                 db    0
.xdata$x:00001E50                 dd offset __unwindtable$?Extract@CHandler@NSplit@NArchive@@UAGJPBIIHPAUIArchiveExtractCallback@@@Z
.xdata$x:00001E54                 db    1
.xdata$x:00001E55                 db    0
.xdata$x:00001E56                 db    0
.xdata$x:00001E57                 db    0
.xdata$x:00001E58                 dd offset __tryblocktable$?Extract@CHandler@NSplit@NArchive@@UAGJPBIIHPAUIArchiveExtractCallback@@@Z
.xdata$x:00001E5C                 db    0
.xdata$x:00001E5D                 db    0
.xdata$x:00001E5E                 db    0
.xdata$x:00001E5F                 db    0
.xdata$x:00001E60                 db    0
.xdata$x:00001E61                 db    0
.xdata$x:00001E62                 db    0
.xdata$x:00001E63                 db    0
.xdata$x:00001E64                 db    0
.xdata$x:00001E65                 db    0
.xdata$x:00001E66                 db    0
.xdata$x:00001E67                 db    0
.xdata$x:00001E68                 db    1
.xdata$x:00001E69                 db    0
.xdata$x:00001E6A                 db    0
.xdata$x:00001E6B                 db    0
.xdata$x:00001E6C __unwindtable$?Extract@CHandler@NSplit@NArchive@@UAGJPBIIHPAUIArchiveExtractCallback@@@Z db 0FFh
.xdata$x:00001E6C                                         ; DATA XREF: .xdata$x:00001E50o
.xdata$x:00001E6D                 db 0FFh
.xdata$x:00001E6E                 db 0FFh
.xdata$x:00001E6F                 db 0FFh
.xdata$x:00001E70                 db    0
.xdata$x:00001E71                 db    0
.xdata$x:00001E72                 db    0
.xdata$x:00001E73                 db    0
.xdata$x:00001E74                 db    0
.xdata$x:00001E75                 db    0
.xdata$x:00001E76                 db    0
.xdata$x:00001E77                 db    0
.xdata$x:00001E78                 dd offset __unwindfunclet$?Extract@CHandler@NSplit@NArchive@@UAGJPBIIHPAUIArchiveExtractCallback@@@Z$2
.xdata$x:00001E7C                 db    1
.xdata$x:00001E7D                 db    0
.xdata$x:00001E7E                 db    0
.xdata$x:00001E7F                 db    0
.xdata$x:00001E80                 dd offset __unwindfunclet$?Extract@CHandler@NSplit@NArchive@@UAGJPBIIHPAUIArchiveExtractCallback@@@Z$3
.xdata$x:00001E84                 db    1
.xdata$x:00001E85                 db    0
.xdata$x:00001E86                 db    0
.xdata$x:00001E87                 db    0
.xdata$x:00001E88                 dd offset __unwindfunclet$?Extract@CHandler@NSplit@NArchive@@UAGJPBIIHPAUIArchiveExtractCallback@@@Z$4
.xdata$x:00001E8C                 db    3
.xdata$x:00001E8D                 db    0
.xdata$x:00001E8E                 db    0
.xdata$x:00001E8F                 db    0
.xdata$x:00001E90                 dd offset __unwindfunclet$?Extract@CHandler@NSplit@NArchive@@UAGJPBIIHPAUIArchiveExtractCallback@@@Z$5
.xdata$x:00001E94                 db    3
.xdata$x:00001E95                 db    0
.xdata$x:00001E96                 db    0
.xdata$x:00001E97                 db    0
.xdata$x:00001E98                 dd offset __unwindfunclet$?Extract@CHandler@NSplit@NArchive@@UAGJPBIIHPAUIArchiveExtractCallback@@@Z$6
.xdata$x:00001E9C                 db 0FFh
.xdata$x:00001E9D                 db 0FFh
.xdata$x:00001E9E                 db 0FFh
.xdata$x:00001E9F                 db 0FFh
.xdata$x:00001EA0                 db    0
.xdata$x:00001EA1                 db    0
.xdata$x:00001EA2                 db    0
.xdata$x:00001EA3                 db    0
.xdata$x:00001EA4 __catchsym$?GetStream@CHandler@NSplit@NArchive@@UAGJIPAPAUISequentialInStream@@@Z$5 dd offset unk_40
.xdata$x:00001EA4                                         ; DATA XREF: .xdata$x:00001EC4o
.xdata$x:00001EA8                 align 10h
.xdata$x:00001EB0                 dd offset __catch$?GetStream@CHandler@NSplit@NArchive@@UAGJIPAPAUISequentialInStream@@@Z$0
.xdata$x:00001EB4 __tryblocktable$?GetStream@CHandler@NSplit@NArchive@@UAGJIPAPAUISequentialInStream@@@Z db    0
.xdata$x:00001EB4                                         ; DATA XREF: .xdata$x:00001ED8o
.xdata$x:00001EB5                 db    0
.xdata$x:00001EB6                 db    0
.xdata$x:00001EB7                 db    0
.xdata$x:00001EB8                 db    3
.xdata$x:00001EB9                 db    0
.xdata$x:00001EBA                 db    0
.xdata$x:00001EBB                 db    0
.xdata$x:00001EBC                 db    4
.xdata$x:00001EBD                 db    0
.xdata$x:00001EBE                 db    0
.xdata$x:00001EBF                 db    0
.xdata$x:00001EC0                 db    1
.xdata$x:00001EC1                 db    0
.xdata$x:00001EC2                 db    0
.xdata$x:00001EC3                 db    0
.xdata$x:00001EC4                 dd offset __catchsym$?GetStream@CHandler@NSplit@NArchive@@UAGJIPAPAUISequentialInStream@@@Z$5
.xdata$x:00001EC8 __ehfuncinfo$?GetStream@CHandler@NSplit@NArchive@@UAGJIPAPAUISequentialInStream@@@Z db  22h ; "
.xdata$x:00001EC8                                         ; DATA XREF: __ehhandler$?GetStream@CHandler@NSplit@NArchive@@UAGJIPAPAUISequentialInStream@@@Z+11o
.xdata$x:00001EC9                 db    5
.xdata$x:00001ECA                 db  93h ; ô
.xdata$x:00001ECB                 db  19h
.xdata$x:00001ECC                 db    5
.xdata$x:00001ECD                 db    0
.xdata$x:00001ECE                 db    0
.xdata$x:00001ECF                 db    0
.xdata$x:00001ED0                 dd offset __unwindtable$?GetStream@CHandler@NSplit@NArchive@@UAGJIPAPAUISequentialInStream@@@Z
.xdata$x:00001ED4                 db    1
.xdata$x:00001ED5                 db    0
.xdata$x:00001ED6                 db    0
.xdata$x:00001ED7                 db    0
.xdata$x:00001ED8                 dd offset __tryblocktable$?GetStream@CHandler@NSplit@NArchive@@UAGJIPAPAUISequentialInStream@@@Z
.xdata$x:00001EDC                 db    0
.xdata$x:00001EDD                 db    0
.xdata$x:00001EDE                 db    0
.xdata$x:00001EDF                 db    0
.xdata$x:00001EE0                 db    0
.xdata$x:00001EE1                 db    0
.xdata$x:00001EE2                 db    0
.xdata$x:00001EE3                 db    0
.xdata$x:00001EE4                 db    0
.xdata$x:00001EE5                 db    0
.xdata$x:00001EE6                 db    0
.xdata$x:00001EE7                 db    0
.xdata$x:00001EE8                 db    1
.xdata$x:00001EE9                 db    0
.xdata$x:00001EEA                 db    0
.xdata$x:00001EEB                 db    0
.xdata$x:00001EEC __unwindtable$?GetStream@CHandler@NSplit@NArchive@@UAGJIPAPAUISequentialInStream@@@Z db 0FFh
.xdata$x:00001EEC                                         ; DATA XREF: .xdata$x:00001ED0o
.xdata$x:00001EED                 db 0FFh
.xdata$x:00001EEE                 db 0FFh
.xdata$x:00001EEF                 db 0FFh
.xdata$x:00001EF0                 db    0
.xdata$x:00001EF1                 db    0
.xdata$x:00001EF2                 db    0
.xdata$x:00001EF3                 db    0
.xdata$x:00001EF4                 db    0
.xdata$x:00001EF5                 db    0
.xdata$x:00001EF6                 db    0
.xdata$x:00001EF7                 db    0
.xdata$x:00001EF8                 dd offset __unwindfunclet$?GetStream@CHandler@NSplit@NArchive@@UAGJIPAPAUISequentialInStream@@@Z$2
.xdata$x:00001EFC                 align 10h
.xdata$x:00001F00                 dd offset __unwindfunclet$?GetStream@CHandler@NSplit@NArchive@@UAGJIPAPAUISequentialInStream@@@Z$3
.xdata$x:00001F04                 db    2
.xdata$x:00001F05                 db    0
.xdata$x:00001F06                 db    0
.xdata$x:00001F07                 db    0
.xdata$x:00001F08                 dd offset __unwindfunclet$?GetStream@CHandler@NSplit@NArchive@@UAGJIPAPAUISequentialInStream@@@Z$4
.xdata$x:00001F0C                 db 0FFh
.xdata$x:00001F0D                 db 0FFh
.xdata$x:00001F0E                 db 0FFh
.xdata$x:00001F0F                 db 0FFh
.xdata$x:00001F10                 db    0
.xdata$x:00001F11                 db    0
.xdata$x:00001F12                 db    0
.xdata$x:00001F13                 db    0
.xdata$x:00001F14 __unwindtable$?CreateArc@NSplit@NArchive@@YGPAUIInArchive@@XZ db 0FFh
.xdata$x:00001F14                                         ; DATA XREF: .xdata$x:00001F24o
.xdata$x:00001F15                 db 0FFh
.xdata$x:00001F16                 db 0FFh
.xdata$x:00001F17                 db 0FFh
.xdata$x:00001F18                 dd offset __unwindfunclet$?CreateArc@NSplit@NArchive@@YGPAUIInArchive@@XZ$0
.xdata$x:00001F1C __ehfuncinfo$?CreateArc@NSplit@NArchive@@YGPAUIInArchive@@XZ db  22h ; "
.xdata$x:00001F1C                                         ; DATA XREF: __ehhandler$?CreateArc@NSplit@NArchive@@YGPAUIInArchive@@XZ+11o
.xdata$x:00001F1D                 db    5
.xdata$x:00001F1E                 db  93h ; ô
.xdata$x:00001F1F                 db  19h
.xdata$x:00001F20                 db    1
.xdata$x:00001F21                 db    0
.xdata$x:00001F22                 db    0
.xdata$x:00001F23                 db    0
.xdata$x:00001F24                 dd offset __unwindtable$?CreateArc@NSplit@NArchive@@YGPAUIInArchive@@XZ
.xdata$x:00001F28                 db    0
.xdata$x:00001F29                 db    0
.xdata$x:00001F2A                 db    0
.xdata$x:00001F2B                 db    0
.xdata$x:00001F2C                 db    0
.xdata$x:00001F2D                 db    0
.xdata$x:00001F2E                 db    0
.xdata$x:00001F2F                 db    0
.xdata$x:00001F30                 db    0
.xdata$x:00001F31                 db    0
.xdata$x:00001F32                 db    0
.xdata$x:00001F33                 db    0
.xdata$x:00001F34                 db    0
.xdata$x:00001F35                 db    0
.xdata$x:00001F36                 db    0
.xdata$x:00001F37                 db    0
.xdata$x:00001F38                 db    0
.xdata$x:00001F39                 db    0
.xdata$x:00001F3A                 db    0
.xdata$x:00001F3B                 db    0
.xdata$x:00001F3C                 db    1
.xdata$x:00001F3D                 db    0
.xdata$x:00001F3E                 db    0
.xdata$x:00001F3F                 db    0
.xdata$x:00001F3F _xdata$x        ends
.xdata$x:00001F3F
.text:00001F40 ; ===========================================================================
.text:00001F40
.text:00001F40 ; Segment type: Pure code
.text:00001F40 ; Segment permissions: Read/Execute
.text:00001F40 _text           segment para public 'CODE' use32
.text:00001F40                 assume cs:_text
.text:00001F40                 ;org 1F40h
.text:00001F40 ; COMDAT (pick any)
.text:00001F40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001F40
.text:00001F40 ; =============== S U B R O U T I N E =======================================
.text:00001F40
.text:00001F40 ; Attributes: bp-based frame
.text:00001F40
.text:00001F40 ; _DWORD __thiscall UString::~UString(UString *__hidden this)
.text:00001F40                 public ??1UString@@QAE@XZ
.text:00001F40 ??1UString@@QAE@XZ proc near            ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+13Cp
.text:00001F40                                         ; NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+181p ...
.text:00001F40
.text:00001F40 var_8           = dword ptr -8
.text:00001F40 var_4           = dword ptr -4
.text:00001F40
.text:00001F40                 push    ebp
.text:00001F41                 mov     ebp, esp
.text:00001F43                 sub     esp, 8
.text:00001F46                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00001F4D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001F54                 mov     [ebp+var_4], ecx
.text:00001F57                 mov     eax, [ebp+var_4]
.text:00001F5A                 mov     ecx, [eax]
.text:00001F5C                 mov     [ebp+var_8], ecx
.text:00001F5F                 mov     edx, [ebp+var_8]
.text:00001F62                 push    edx             ; void *
.text:00001F63                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00001F68                 add     esp, 4
.text:00001F6B                 add     esp, 8
.text:00001F6E                 cmp     ebp, esp
.text:00001F70                 call    __RTC_CheckEsp
.text:00001F75                 mov     esp, ebp
.text:00001F77                 pop     ebp
.text:00001F78                 retn
.text:00001F78 ??1UString@@QAE@XZ endp
.text:00001F78
.text:00001F78 ; ---------------------------------------------------------------------------
.text:00001F79                 align 4
.text:00001F79 _text           ends
.text:00001F79
.text:00001F7C ; ===========================================================================
.text:00001F7C
.text:00001F7C ; Segment type: Pure code
.text:00001F7C ; Segment permissions: Read/Execute
.text:00001F7C _text           segment para public 'CODE' use32
.text:00001F7C                 assume cs:_text
.text:00001F7C                 ;org 1F7Ch
.text:00001F7C ; COMDAT (pick any)
.text:00001F7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001F7C
.text:00001F7C ; =============== S U B R O U T I N E =======================================
.text:00001F7C
.text:00001F7C ; Attributes: bp-based frame
.text:00001F7C
.text:00001F7C ; unsigned int __thiscall UString::Len(UString *__hidden this)
.text:00001F7C                 public ?Len@UString@@QBEIXZ
.text:00001F7C ?Len@UString@@QBEIXZ proc near          ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+23Ap
.text:00001F7C                                         ; NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+270p ...
.text:00001F7C
.text:00001F7C var_4           = dword ptr -4
.text:00001F7C
.text:00001F7C                 push    ebp
.text:00001F7D                 mov     ebp, esp
.text:00001F7F                 push    ecx
.text:00001F80                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001F87                 mov     [ebp+var_4], ecx
.text:00001F8A                 mov     eax, [ebp+var_4]
.text:00001F8D                 mov     eax, [eax+4]
.text:00001F90                 mov     esp, ebp
.text:00001F92                 pop     ebp
.text:00001F93                 retn
.text:00001F93 ?Len@UString@@QBEIXZ endp
.text:00001F93
.text:00001F93 _text           ends
.text:00001F93
.text:00001F94 ; ===========================================================================
.text:00001F94
.text:00001F94 ; Segment type: Pure code
.text:00001F94 ; Segment permissions: Read/Execute
.text:00001F94 _text           segment para public 'CODE' use32
.text:00001F94                 assume cs:_text
.text:00001F94                 ;org 1F94h
.text:00001F94 ; COMDAT (pick any)
.text:00001F94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001F94
.text:00001F94 ; =============== S U B R O U T I N E =======================================
.text:00001F94
.text:00001F94 ; Attributes: bp-based frame
.text:00001F94
.text:00001F94 ; public: __thiscall UString::operator wchar_t const *(void)const
.text:00001F94                 public ??BUString@@QBEPB_WXZ
.text:00001F94 ??BUString@@QBEPB_WXZ proc near         ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+283p
.text:00001F94                                         ; NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+30Ap ...
.text:00001F94
.text:00001F94 var_4           = dword ptr -4
.text:00001F94
.text:00001F94                 push    ebp
.text:00001F95                 mov     ebp, esp
.text:00001F97                 push    ecx
.text:00001F98                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001F9F                 mov     [ebp+var_4], ecx
.text:00001FA2                 mov     eax, [ebp+var_4]
.text:00001FA5                 mov     eax, [eax]
.text:00001FA7                 mov     esp, ebp
.text:00001FA9                 pop     ebp
.text:00001FAA                 retn
.text:00001FAA ??BUString@@QBEPB_WXZ endp
.text:00001FAA
.text:00001FAA ; ---------------------------------------------------------------------------
.text:00001FAB                 align 4
.text:00001FAB _text           ends
.text:00001FAB
.text:00001FAC ; ===========================================================================
.text:00001FAC
.text:00001FAC ; Segment type: Pure code
.text:00001FAC ; Segment permissions: Read/Execute
.text:00001FAC _text           segment para public 'CODE' use32
.text:00001FAC                 assume cs:_text
.text:00001FAC                 ;org 1FACh
.text:00001FAC ; COMDAT (pick any)
.text:00001FAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001FAC
.text:00001FAC ; =============== S U B R O U T I N E =======================================
.text:00001FAC
.text:00001FAC ; Attributes: bp-based frame
.text:00001FAC
.text:00001FAC ; const wchar_t *__thiscall UString::Ptr(UString *this, unsigned int)
.text:00001FAC                 public ?Ptr@UString@@QBEPB_WI@Z
.text:00001FAC ?Ptr@UString@@QBEPB_WI@Z proc near      ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+1E4p
.text:00001FAC
.text:00001FAC var_4           = dword ptr -4
.text:00001FAC arg_0           = dword ptr  8
.text:00001FAC
.text:00001FAC                 push    ebp
.text:00001FAD                 mov     ebp, esp
.text:00001FAF                 push    ecx
.text:00001FB0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001FB7                 mov     [ebp+var_4], ecx
.text:00001FBA                 mov     eax, [ebp+var_4]
.text:00001FBD                 mov     ecx, [eax]
.text:00001FBF                 mov     edx, [ebp+arg_0]
.text:00001FC2                 lea     eax, [ecx+edx*2]
.text:00001FC5                 mov     esp, ebp
.text:00001FC7                 pop     ebp
.text:00001FC8                 retn    4
.text:00001FC8 ?Ptr@UString@@QBEPB_WI@Z endp
.text:00001FC8
.text:00001FC8 ; ---------------------------------------------------------------------------
.text:00001FCB                 align 4
.text:00001FCB _text           ends
.text:00001FCB
.text:00001FCC ; ===========================================================================
.text:00001FCC
.text:00001FCC ; Segment type: Pure code
.text:00001FCC ; Segment permissions: Read/Execute
.text:00001FCC _text           segment para public 'CODE' use32
.text:00001FCC                 assume cs:_text
.text:00001FCC                 ;org 1FCCh
.text:00001FCC ; COMDAT (pick any)
.text:00001FCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001FCC
.text:00001FCC ; =============== S U B R O U T I N E =======================================
.text:00001FCC
.text:00001FCC ; Attributes: bp-based frame
.text:00001FCC
.text:00001FCC ; const wchar_t *__thiscall UString::RightPtr(UString *this, unsigned int)
.text:00001FCC                 public ?RightPtr@UString@@QBEPB_WI@Z
.text:00001FCC ?RightPtr@UString@@QBEPB_WI@Z proc near ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+251p
.text:00001FCC                                         ; NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+2DBp ...
.text:00001FCC
.text:00001FCC var_4           = dword ptr -4
.text:00001FCC arg_0           = dword ptr  8
.text:00001FCC
.text:00001FCC                 push    ebp
.text:00001FCD                 mov     ebp, esp
.text:00001FCF                 push    ecx
.text:00001FD0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001FD7                 mov     [ebp+var_4], ecx
.text:00001FDA                 mov     eax, [ebp+var_4]
.text:00001FDD                 mov     ecx, [eax+4]
.text:00001FE0                 mov     edx, [ebp+var_4]
.text:00001FE3                 mov     eax, [edx]
.text:00001FE5                 lea     eax, [eax+ecx*2]
.text:00001FE8                 mov     ecx, [ebp+arg_0]
.text:00001FEB                 shl     ecx, 1
.text:00001FED                 sub     eax, ecx
.text:00001FEF                 mov     esp, ebp
.text:00001FF1                 pop     ebp
.text:00001FF2                 retn    4
.text:00001FF2 ?RightPtr@UString@@QBEPB_WI@Z endp
.text:00001FF2
.text:00001FF2 ; ---------------------------------------------------------------------------
.text:00001FF5                 align 4
.text:00001FF5 _text           ends
.text:00001FF5
.text:00001FF8 ; ===========================================================================
.text:00001FF8
.text:00001FF8 ; Segment type: Pure code
.text:00001FF8 ; Segment permissions: Read/Execute
.text:00001FF8 _text           segment para public 'CODE' use32
.text:00001FF8                 assume cs:_text
.text:00001FF8                 ;org 1FF8h
.text:00001FF8 ; COMDAT (pick any)
.text:00001FF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001FF8
.text:00001FF8 ; =============== S U B R O U T I N E =======================================
.text:00001FF8
.text:00001FF8 ; Attributes: bp-based frame
.text:00001FF8
.text:00001FF8 ; public: class UString __thiscall UString::Left(unsigned int)const
.text:00001FF8                 public ?Left@UString@@QBE?AV1@I@Z
.text:00001FF8 ?Left@UString@@QBE?AV1@I@Z proc near    ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+1D1p
.text:00001FF8                                         ; NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+439p
.text:00001FF8
.text:00001FF8 var_8           = dword ptr -8
.text:00001FF8 var_4           = dword ptr -4
.text:00001FF8 arg_0           = dword ptr  8
.text:00001FF8 arg_4           = dword ptr  0Ch
.text:00001FF8
.text:00001FF8                 push    ebp
.text:00001FF9                 mov     ebp, esp
.text:00001FFB                 sub     esp, 8
.text:00001FFE                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00002005                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000200C                 mov     [ebp+var_4], ecx
.text:0000200F                 mov     [ebp+var_8], 0
.text:00002016                 mov     eax, [ebp+var_4]
.text:00002019                 push    eax
.text:0000201A                 mov     ecx, [ebp+arg_4]
.text:0000201D                 push    ecx
.text:0000201E                 mov     ecx, [ebp+arg_0]
.text:00002021                 call    ??0UString@@AAE@IABV0@@Z ; UString::UString(uint,UString const &)
.text:00002026                 mov     edx, [ebp+var_8]
.text:00002029                 or      edx, 1
.text:0000202C                 mov     [ebp+var_8], edx
.text:0000202F                 mov     eax, [ebp+arg_0]
.text:00002032                 add     esp, 8
.text:00002035                 cmp     ebp, esp
.text:00002037                 call    __RTC_CheckEsp
.text:0000203C                 mov     esp, ebp
.text:0000203E                 pop     ebp
.text:0000203F                 retn    8
.text:0000203F ?Left@UString@@QBE?AV1@I@Z endp
.text:0000203F
.text:0000203F ; ---------------------------------------------------------------------------
.text:00002042                 align 4
.text:00002042 _text           ends
.text:00002042
.text:00002044 ; ===========================================================================
.text:00002044
.text:00002044 ; Segment type: Pure code
.text:00002044 ; Segment permissions: Read/Execute
.text:00002044 _text           segment para public 'CODE' use32
.text:00002044                 assume cs:_text
.text:00002044                 ;org 2044h
.text:00002044 ; COMDAT (pick any)
.text:00002044                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002044
.text:00002044 ; =============== S U B R O U T I N E =======================================
.text:00002044
.text:00002044 ; Attributes: bp-based frame
.text:00002044
.text:00002044 ; void __thiscall UString::MakeLower_Ascii(UString *__hidden this)
.text:00002044                 public ?MakeLower_Ascii@UString@@QAEXXZ
.text:00002044 ?MakeLower_Ascii@UString@@QAEXXZ proc near
.text:00002044                                         ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+20Fp
.text:00002044
.text:00002044 var_4           = dword ptr -4
.text:00002044
.text:00002044                 push    ebp
.text:00002045                 mov     ebp, esp
.text:00002047                 push    ecx
.text:00002048                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000204F                 mov     [ebp+var_4], ecx
.text:00002052                 mov     eax, [ebp+var_4]
.text:00002055                 mov     ecx, [eax]
.text:00002057                 push    ecx             ; wchar_t *
.text:00002058                 call    ?MyStringLower_Ascii@@YGXPA_W@Z ; MyStringLower_Ascii(wchar_t *)
.text:0000205D                 add     esp, 4
.text:00002060                 cmp     ebp, esp
.text:00002062                 call    __RTC_CheckEsp
.text:00002067                 mov     esp, ebp
.text:00002069                 pop     ebp
.text:0000206A                 retn
.text:0000206A ?MakeLower_Ascii@UString@@QAEXXZ endp
.text:0000206A
.text:0000206A ; ---------------------------------------------------------------------------
.text:0000206B                 align 4
.text:0000206B _text           ends
.text:0000206B
.text:0000206C ; ===========================================================================
.text:0000206C
.text:0000206C ; Segment type: Pure code
.text:0000206C ; Segment permissions: Read/Execute
.text:0000206C _text           segment para public 'CODE' use32
.text:0000206C                 assume cs:_text
.text:0000206C                 ;org 206Ch
.text:0000206C ; COMDAT (pick any)
.text:0000206C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000206C
.text:0000206C ; =============== S U B R O U T I N E =======================================
.text:0000206C
.text:0000206C ; Attributes: bp-based frame
.text:0000206C
.text:0000206C ; int __thiscall UString::ReverseFind_Dot(UString *__hidden this)
.text:0000206C                 public ?ReverseFind_Dot@UString@@QBEHXZ
.text:0000206C ?ReverseFind_Dot@UString@@QBEHXZ proc near
.text:0000206C                                         ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+1BBp
.text:0000206C
.text:0000206C var_4           = dword ptr -4
.text:0000206C
.text:0000206C                 push    ebp
.text:0000206D                 mov     ebp, esp
.text:0000206F                 push    ecx
.text:00002070                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002077                 mov     [ebp+var_4], ecx
.text:0000207A                 push    2Eh ; '.'       ; wchar_t
.text:0000207C                 mov     ecx, [ebp+var_4] ; this
.text:0000207F                 call    ?ReverseFind@UString@@QBEH_W@Z ; UString::ReverseFind(wchar_t)
.text:00002084                 add     esp, 4
.text:00002087                 cmp     ebp, esp
.text:00002089                 call    __RTC_CheckEsp
.text:0000208E                 mov     esp, ebp
.text:00002090                 pop     ebp
.text:00002091                 retn
.text:00002091 ?ReverseFind_Dot@UString@@QBEHXZ endp
.text:00002091
.text:00002091 ; ---------------------------------------------------------------------------
.text:00002092                 align 4
.text:00002092 _text           ends
.text:00002092
.text:00002094 ; ===========================================================================
.text:00002094
.text:00002094 ; Segment type: Pure code
.text:00002094 ; Segment permissions: Read/Execute
.text:00002094 _text           segment para public 'CODE' use32
.text:00002094                 assume cs:_text
.text:00002094                 ;org 2094h
.text:00002094 ; COMDAT (pick any)
.text:00002094                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002094
.text:00002094 ; =============== S U B R O U T I N E =======================================
.text:00002094
.text:00002094 ; Attributes: bp-based frame
.text:00002094
.text:00002094 ; bool __thiscall NArchive::NSplit::CSeqName::GetNextName(NArchive::NSplit::CSeqName *this, struct UString *)
.text:00002094                 public ?GetNextName@CSeqName@NSplit@NArchive@@QAE_NAAVUString@@@Z
.text:00002094 ?GetNextName@CSeqName@NSplit@NArchive@@QAE_NAAVUString@@@Z proc near
.text:00002094                                         ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+7BFp
.text:00002094
.text:00002094 var_2C          = dword ptr -2Ch
.text:00002094 var_28          = dword ptr -28h
.text:00002094 var_24          = dword ptr -24h
.text:00002094 var_20          = dword ptr -20h
.text:00002094 var_1C          = dword ptr -1Ch
.text:00002094 var_18          = dword ptr -18h
.text:00002094 var_14          = dword ptr -14h
.text:00002094 var_10          = dword ptr -10h
.text:00002094 var_C           = dword ptr -0Ch
.text:00002094 var_4           = dword ptr -4
.text:00002094 arg_0           = dword ptr  8
.text:00002094
.text:00002094                 push    ebp
.text:00002095                 mov     ebp, esp
.text:00002097                 push    0FFFFFFFFh
.text:00002099                 push    offset __ehhandler$?GetNextName@CSeqName@NSplit@NArchive@@QAE_NAAVUString@@@Z
.text:0000209E                 mov     eax, large fs:0
.text:000020A4                 push    eax
.text:000020A5                 sub     esp, 20h
.text:000020A8                 mov     eax, 0CCCCCCCCh
.text:000020AD                 mov     [ebp+var_2C], eax
.text:000020B0                 mov     [ebp+var_28], eax
.text:000020B3                 mov     [ebp+var_24], eax
.text:000020B6                 mov     [ebp+var_20], eax
.text:000020B9                 mov     [ebp+var_1C], eax
.text:000020BC                 mov     [ebp+var_18], eax
.text:000020BF                 mov     [ebp+var_14], eax
.text:000020C2                 mov     [ebp+var_10], eax
.text:000020C5                 mov     eax, dword ptr ds:___security_cookie
.text:000020CA                 xor     eax, ebp
.text:000020CC                 push    eax
.text:000020CD                 lea     eax, [ebp+var_C]
.text:000020D0                 mov     large fs:0, eax
.text:000020D6                 mov     [ebp+var_10], ecx
.text:000020D9                 mov     ecx, [ebp+var_10]
.text:000020DC                 add     ecx, 0Ch        ; this
.text:000020DF                 call    ?Len@UString@@QBEIXZ ; UString::Len(void)
.text:000020E4                 mov     [ebp+var_14], eax
.text:000020E7
.text:000020E7 loc_20E7:                               ; CODE XREF: NArchive::NSplit::CSeqName::GetNextName(UString &):loc_2138j
.text:000020E7                                         ; NArchive::NSplit::CSeqName::GetNextName(UString &):loc_2163j ...
.text:000020E7                 mov     eax, [ebp+var_14]
.text:000020EA                 sub     eax, 1
.text:000020ED                 mov     [ebp+var_14], eax
.text:000020F0                 mov     ecx, [ebp+var_10]
.text:000020F3                 add     ecx, 0Ch
.text:000020F6                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000020FB                 mov     ecx, [ebp+var_14]
.text:000020FE                 mov     dx, [eax+ecx*2]
.text:00002102                 mov     word ptr [ebp+var_18], dx
.text:00002106                 mov     eax, [ebp+var_10]
.text:00002109                 movzx   ecx, byte ptr [eax+18h]
.text:0000210D                 test    ecx, ecx
.text:0000210F                 jz      short loc_2167
.text:00002111                 movzx   edx, word ptr [ebp+var_18]
.text:00002115                 cmp     edx, 7Ah ; 'z'
.text:00002118                 jnz     short loc_213C
.text:0000211A                 push    61h ; 'a'       ; wchar_t
.text:0000211C                 mov     eax, [ebp+var_14]
.text:0000211F                 push    eax             ; unsigned int
.text:00002120                 mov     ecx, [ebp+var_10]
.text:00002123                 add     ecx, 0Ch        ; this
.text:00002126                 call    ?ReplaceOneCharAtPos@UString@@QAEXI_W@Z ; UString::ReplaceOneCharAtPos(uint,wchar_t)
.text:0000212B                 cmp     [ebp+var_14], 0
.text:0000212F                 jnz     short loc_2138
.text:00002131                 xor     al, al
.text:00002133                 jmp     loc_2203
.text:00002138 ; ---------------------------------------------------------------------------
.text:00002138
.text:00002138 loc_2138:                               ; CODE XREF: NArchive::NSplit::CSeqName::GetNextName(UString &)+9Bj
.text:00002138                 jmp     short loc_20E7
.text:0000213A ; ---------------------------------------------------------------------------
.text:0000213A                 jmp     short loc_2165
.text:0000213C ; ---------------------------------------------------------------------------
.text:0000213C
.text:0000213C loc_213C:                               ; CODE XREF: NArchive::NSplit::CSeqName::GetNextName(UString &)+84j
.text:0000213C                 movzx   ecx, word ptr [ebp+var_18]
.text:00002140                 cmp     ecx, 5Ah ; 'Z'
.text:00002143                 jnz     short loc_2165
.text:00002145                 push    41h ; 'A'       ; wchar_t
.text:00002147                 mov     edx, [ebp+var_14]
.text:0000214A                 push    edx             ; unsigned int
.text:0000214B                 mov     ecx, [ebp+var_10]
.text:0000214E                 add     ecx, 0Ch        ; this
.text:00002151                 call    ?ReplaceOneCharAtPos@UString@@QAEXI_W@Z ; UString::ReplaceOneCharAtPos(uint,wchar_t)
.text:00002156                 cmp     [ebp+var_14], 0
.text:0000215A                 jnz     short loc_2163
.text:0000215C                 xor     al, al
.text:0000215E                 jmp     loc_2203
.text:00002163 ; ---------------------------------------------------------------------------
.text:00002163
.text:00002163 loc_2163:                               ; CODE XREF: NArchive::NSplit::CSeqName::GetNextName(UString &)+C6j
.text:00002163                 jmp     short loc_20E7
.text:00002165 ; ---------------------------------------------------------------------------
.text:00002165
.text:00002165 loc_2165:                               ; CODE XREF: NArchive::NSplit::CSeqName::GetNextName(UString &)+A6j
.text:00002165                                         ; NArchive::NSplit::CSeqName::GetNextName(UString &)+AFj
.text:00002165                 jmp     short loc_219B
.text:00002167 ; ---------------------------------------------------------------------------
.text:00002167
.text:00002167 loc_2167:                               ; CODE XREF: NArchive::NSplit::CSeqName::GetNextName(UString &)+7Bj
.text:00002167                 movzx   eax, word ptr [ebp+var_18]
.text:0000216B                 cmp     eax, 39h ; '9'
.text:0000216E                 jnz     short loc_219B
.text:00002170                 push    30h ; '0'       ; wchar_t
.text:00002172                 mov     ecx, [ebp+var_14]
.text:00002175                 push    ecx             ; unsigned int
.text:00002176                 mov     ecx, [ebp+var_10]
.text:00002179                 add     ecx, 0Ch        ; this
.text:0000217C                 call    ?ReplaceOneCharAtPos@UString@@QAEXI_W@Z ; UString::ReplaceOneCharAtPos(uint,wchar_t)
.text:00002181                 cmp     [ebp+var_14], 0
.text:00002185                 jnz     short loc_2196
.text:00002187                 push    31h ; '1'       ; wchar_t
.text:00002189                 mov     ecx, [ebp+var_10]
.text:0000218C                 add     ecx, 0Ch        ; this
.text:0000218F                 call    ?InsertAtFront@UString@@QAEX_W@Z ; UString::InsertAtFront(wchar_t)
.text:00002194                 jmp     short loc_21C2
.text:00002196 ; ---------------------------------------------------------------------------
.text:00002196
.text:00002196 loc_2196:                               ; CODE XREF: NArchive::NSplit::CSeqName::GetNextName(UString &)+F1j
.text:00002196                 jmp     loc_20E7
.text:0000219B ; ---------------------------------------------------------------------------
.text:0000219B
.text:0000219B loc_219B:                               ; CODE XREF: NArchive::NSplit::CSeqName::GetNextName(UString &):loc_2165j
.text:0000219B                                         ; NArchive::NSplit::CSeqName::GetNextName(UString &)+DAj
.text:0000219B                 mov     dx, word ptr [ebp+var_18]
.text:0000219F                 add     dx, 1
.text:000021A3                 mov     word ptr [ebp+var_18], dx
.text:000021A7                 movzx   eax, word ptr [ebp+var_18]
.text:000021AB                 push    eax             ; wchar_t
.text:000021AC                 mov     ecx, [ebp+var_14]
.text:000021AF                 push    ecx             ; unsigned int
.text:000021B0                 mov     ecx, [ebp+var_10]
.text:000021B3                 add     ecx, 0Ch        ; this
.text:000021B6                 call    ?ReplaceOneCharAtPos@UString@@QAEXI_W@Z ; UString::ReplaceOneCharAtPos(uint,wchar_t)
.text:000021BB                 jmp     short loc_21C2
.text:000021BD ; ---------------------------------------------------------------------------
.text:000021BD                 jmp     loc_20E7
.text:000021C2 ; ---------------------------------------------------------------------------
.text:000021C2
.text:000021C2 loc_21C2:                               ; CODE XREF: NArchive::NSplit::CSeqName::GetNextName(UString &)+100j
.text:000021C2                                         ; NArchive::NSplit::CSeqName::GetNextName(UString &)+127j
.text:000021C2                 mov     edx, [ebp+var_10]
.text:000021C5                 add     edx, 0Ch
.text:000021C8                 push    edx
.text:000021C9                 mov     eax, [ebp+var_10]
.text:000021CC                 push    eax
.text:000021CD                 lea     ecx, [ebp+var_24]
.text:000021D0                 push    ecx
.text:000021D1                 call    ??H@YG?AVUString@@ABV0@0@Z ; operator+(UString const &,UString const &)
.text:000021D6                 mov     [ebp+var_28], eax
.text:000021D9                 mov     edx, [ebp+var_28]
.text:000021DC                 mov     [ebp+var_2C], edx
.text:000021DF                 mov     [ebp+var_4], 0
.text:000021E6                 mov     eax, [ebp+var_2C]
.text:000021E9                 push    eax
.text:000021EA                 mov     ecx, [ebp+arg_0]
.text:000021ED                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:000021F2                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000021F9                 lea     ecx, [ebp+var_24] ; this
.text:000021FC                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00002201                 mov     al, 1
.text:00002203
.text:00002203 loc_2203:                               ; CODE XREF: NArchive::NSplit::CSeqName::GetNextName(UString &)+9Fj
.text:00002203                                         ; NArchive::NSplit::CSeqName::GetNextName(UString &)+CAj
.text:00002203                 mov     ecx, [ebp+var_C]
.text:00002206                 mov     large fs:0, ecx
.text:0000220D                 pop     ecx
.text:0000220E                 add     esp, 2Ch
.text:00002211                 cmp     ebp, esp
.text:00002213                 call    __RTC_CheckEsp
.text:00002218                 mov     esp, ebp
.text:0000221A                 pop     ebp
.text:0000221B                 retn    4
.text:0000221B ?GetNextName@CSeqName@NSplit@NArchive@@QAE_NAAVUString@@@Z endp
.text:0000221B
.text:0000221B ; ---------------------------------------------------------------------------
.text:0000221E                 align 10h
.text:0000221E _text           ends
.text:0000221E
.text$x:00002220 ; ===========================================================================
.text$x:00002220
.text$x:00002220 ; Segment type: Pure code
.text$x:00002220 ; Segment permissions: Read/Execute
.text$x:00002220 _text$x         segment para public 'CODE' use32
.text$x:00002220                 assume cs:_text$x
.text$x:00002220                 ;org 2220h
.text$x:00002220 ; COMDAT (pick associative to section at 2094)
.text$x:00002220                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002220
.text$x:00002220 ; =============== S U B R O U T I N E =======================================
.text$x:00002220
.text$x:00002220
.text$x:00002220 __unwindfunclet$?GetNextName@CSeqName@NSplit@NArchive@@QAE_NAAVUString@@@Z$0 proc near
.text$x:00002220                                         ; DATA XREF: .xdata$x:00002248o
.text$x:00002220                 lea     ecx, [ebp-24h]  ; this
.text$x:00002223                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00002223 __unwindfunclet$?GetNextName@CSeqName@NSplit@NArchive@@QAE_NAAVUString@@@Z$0 endp
.text$x:00002223
.text$x:00002228
.text$x:00002228 ; =============== S U B R O U T I N E =======================================
.text$x:00002228
.text$x:00002228
.text$x:00002228 __ehhandler$?GetNextName@CSeqName@NSplit@NArchive@@QAE_NAAVUString@@@Z proc near
.text$x:00002228                                         ; DATA XREF: NArchive::NSplit::CSeqName::GetNextName(UString &)+5o
.text$x:00002228
.text$x:00002228 arg_4           = dword ptr  8
.text$x:00002228
.text$x:00002228                 mov     edx, [esp+arg_4]
.text$x:0000222C                 lea     eax, [edx+0Ch]
.text$x:0000222F                 mov     ecx, [edx-24h]
.text$x:00002232                 xor     ecx, eax
.text$x:00002234                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002239                 mov     eax, offset __ehfuncinfo$?GetNextName@CSeqName@NSplit@NArchive@@QAE_NAAVUString@@@Z
.text$x:0000223E                 jmp     ___CxxFrameHandler3
.text$x:0000223E __ehhandler$?GetNextName@CSeqName@NSplit@NArchive@@QAE_NAAVUString@@@Z endp
.text$x:0000223E
.text$x:0000223E ; ---------------------------------------------------------------------------
.text$x:00002243                 align 4
.text$x:00002243 _text$x         ends
.text$x:00002243
.xdata$x:00002244 ; ===========================================================================
.xdata$x:00002244
.xdata$x:00002244 ; Segment type: Pure data
.xdata$x:00002244 ; Segment permissions: Read
.xdata$x:00002244 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002244                 assume cs:_xdata$x
.xdata$x:00002244                 ;org 2244h
.xdata$x:00002244 ; COMDAT (pick associative to section at 2094)
.xdata$x:00002244 __unwindtable$?GetNextName@CSeqName@NSplit@NArchive@@QAE_NAAVUString@@@Z db 0FFh
.xdata$x:00002244                                         ; DATA XREF: .xdata$x:00002254o
.xdata$x:00002245                 db 0FFh
.xdata$x:00002246                 db 0FFh
.xdata$x:00002247                 db 0FFh
.xdata$x:00002248                 dd offset __unwindfunclet$?GetNextName@CSeqName@NSplit@NArchive@@QAE_NAAVUString@@@Z$0
.xdata$x:0000224C __ehfuncinfo$?GetNextName@CSeqName@NSplit@NArchive@@QAE_NAAVUString@@@Z db  22h ; "
.xdata$x:0000224C                                         ; DATA XREF: __ehhandler$?GetNextName@CSeqName@NSplit@NArchive@@QAE_NAAVUString@@@Z+11o
.xdata$x:0000224D                 db    5
.xdata$x:0000224E                 db  93h ; ô
.xdata$x:0000224F                 db  19h
.xdata$x:00002250                 db    1
.xdata$x:00002251                 db    0
.xdata$x:00002252                 db    0
.xdata$x:00002253                 db    0
.xdata$x:00002254                 dd offset __unwindtable$?GetNextName@CSeqName@NSplit@NArchive@@QAE_NAAVUString@@@Z
.xdata$x:00002258                 db    0
.xdata$x:00002259                 db    0
.xdata$x:0000225A                 db    0
.xdata$x:0000225B                 db    0
.xdata$x:0000225C                 db    0
.xdata$x:0000225D                 db    0
.xdata$x:0000225E                 db    0
.xdata$x:0000225F                 db    0
.xdata$x:00002260                 db    0
.xdata$x:00002261                 db    0
.xdata$x:00002262                 db    0
.xdata$x:00002263                 db    0
.xdata$x:00002264                 db    0
.xdata$x:00002265                 db    0
.xdata$x:00002266                 db    0
.xdata$x:00002267                 db    0
.xdata$x:00002268                 db    0
.xdata$x:00002269                 db    0
.xdata$x:0000226A                 db    0
.xdata$x:0000226B                 db    0
.xdata$x:0000226C                 db    1
.xdata$x:0000226D                 db    0
.xdata$x:0000226E                 db    0
.xdata$x:0000226F                 db    0
.xdata$x:0000226F _xdata$x        ends
.xdata$x:0000226F
.text:00002270 ; ===========================================================================
.text:00002270
.text:00002270 ; Segment type: Pure code
.text:00002270 ; Segment permissions: Read/Execute
.text:00002270 _text           segment para public 'CODE' use32
.text:00002270                 assume cs:_text
.text:00002270                 ;org 2270h
.text:00002270 ; COMDAT (pick any)
.text:00002270                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002270
.text:00002270 ; =============== S U B R O U T I N E =======================================
.text:00002270
.text:00002270 ; Attributes: bp-based frame
.text:00002270
.text:00002270 ; void __thiscall UString::ReplaceOneCharAtPos(UString *this, unsigned int, wchar_t)
.text:00002270                 public ?ReplaceOneCharAtPos@UString@@QAEXI_W@Z
.text:00002270 ?ReplaceOneCharAtPos@UString@@QAEXI_W@Z proc near
.text:00002270                                         ; CODE XREF: NArchive::NSplit::CSeqName::GetNextName(UString &)+92p
.text:00002270                                         ; NArchive::NSplit::CSeqName::GetNextName(UString &)+BDp ...
.text:00002270
.text:00002270 var_4           = dword ptr -4
.text:00002270 arg_0           = dword ptr  8
.text:00002270 arg_4           = word ptr  0Ch
.text:00002270
.text:00002270                 push    ebp
.text:00002271                 mov     ebp, esp
.text:00002273                 push    ecx
.text:00002274                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000227B                 mov     [ebp+var_4], ecx
.text:0000227E                 mov     eax, [ebp+var_4]
.text:00002281                 mov     ecx, [eax]
.text:00002283                 mov     edx, [ebp+arg_0]
.text:00002286                 mov     ax, [ebp+arg_4]
.text:0000228A                 mov     [ecx+edx*2], ax
.text:0000228E                 mov     esp, ebp
.text:00002290                 pop     ebp
.text:00002291                 retn    8
.text:00002291 ?ReplaceOneCharAtPos@UString@@QAEXI_W@Z endp
.text:00002291
.text:00002291 _text           ends
.text:00002291
.text:00002294 ; ===========================================================================
.text:00002294
.text:00002294 ; Segment type: Pure code
.text:00002294 ; Segment permissions: Read/Execute
.text:00002294 _text           segment para public 'CODE' use32
.text:00002294                 assume cs:_text
.text:00002294                 ;org 2294h
.text:00002294 ; COMDAT (pick any)
.text:00002294                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002294
.text:00002294 ; =============== S U B R O U T I N E =======================================
.text:00002294
.text:00002294 ; Attributes: bp-based frame
.text:00002294
.text:00002294 ; _DWORD __thiscall NArchive::NSplit::CSeqName::CSeqName(NArchive::NSplit::CSeqName *__hidden this)
.text:00002294                 public ??0CSeqName@NSplit@NArchive@@QAE@XZ
.text:00002294 ??0CSeqName@NSplit@NArchive@@QAE@XZ proc near
.text:00002294                                         ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+21Ap
.text:00002294
.text:00002294 var_10          = dword ptr -10h
.text:00002294 var_C           = dword ptr -0Ch
.text:00002294 var_4           = dword ptr -4
.text:00002294
.text:00002294                 push    ebp
.text:00002295                 mov     ebp, esp
.text:00002297                 push    0FFFFFFFFh
.text:00002299                 push    offset __ehhandler$??0CSeqName@NSplit@NArchive@@QAE@XZ
.text:0000229E                 mov     eax, large fs:0
.text:000022A4                 push    eax
.text:000022A5                 push    ecx
.text:000022A6                 mov     [ebp+var_10], 0CCCCCCCCh
.text:000022AD                 mov     eax, dword ptr ds:___security_cookie
.text:000022B2                 xor     eax, ebp
.text:000022B4                 push    eax
.text:000022B5                 lea     eax, [ebp+var_C]
.text:000022B8                 mov     large fs:0, eax
.text:000022BE                 mov     [ebp+var_10], ecx
.text:000022C1                 mov     ecx, [ebp+var_10]
.text:000022C4                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:000022C9                 mov     [ebp+var_4], 0
.text:000022D0                 mov     ecx, [ebp+var_10]
.text:000022D3                 add     ecx, 0Ch
.text:000022D6                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:000022DB                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000022E2                 mov     eax, [ebp+var_10]
.text:000022E5                 mov     ecx, [ebp+var_C]
.text:000022E8                 mov     large fs:0, ecx
.text:000022EF                 pop     ecx
.text:000022F0                 add     esp, 10h
.text:000022F3                 cmp     ebp, esp
.text:000022F5                 call    __RTC_CheckEsp
.text:000022FA                 mov     esp, ebp
.text:000022FC                 pop     ebp
.text:000022FD                 retn
.text:000022FD ??0CSeqName@NSplit@NArchive@@QAE@XZ endp
.text:000022FD
.text:000022FD ; ---------------------------------------------------------------------------
.text:000022FE                 align 10h
.text:000022FE _text           ends
.text:000022FE
.text$x:00002300 ; ===========================================================================
.text$x:00002300
.text$x:00002300 ; Segment type: Pure code
.text$x:00002300 ; Segment permissions: Read/Execute
.text$x:00002300 _text$x         segment para public 'CODE' use32
.text$x:00002300                 assume cs:_text$x
.text$x:00002300                 ;org 2300h
.text$x:00002300 ; COMDAT (pick associative to section at 2294)
.text$x:00002300                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002300
.text$x:00002300 ; =============== S U B R O U T I N E =======================================
.text$x:00002300
.text$x:00002300
.text$x:00002300 __unwindfunclet$??0CSeqName@NSplit@NArchive@@QAE@XZ$0 proc near
.text$x:00002300                                         ; DATA XREF: .xdata$x:00002328o
.text$x:00002300                 mov     ecx, [ebp-10h]  ; this
.text$x:00002303                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00002303 __unwindfunclet$??0CSeqName@NSplit@NArchive@@QAE@XZ$0 endp
.text$x:00002303
.text$x:00002308
.text$x:00002308 ; =============== S U B R O U T I N E =======================================
.text$x:00002308
.text$x:00002308
.text$x:00002308 __ehhandler$??0CSeqName@NSplit@NArchive@@QAE@XZ proc near
.text$x:00002308                                         ; DATA XREF: NArchive::NSplit::CSeqName::CSeqName(void)+5o
.text$x:00002308
.text$x:00002308 arg_4           = dword ptr  8
.text$x:00002308
.text$x:00002308                 mov     edx, [esp+arg_4]
.text$x:0000230C                 lea     eax, [edx+0Ch]
.text$x:0000230F                 mov     ecx, [edx-8]
.text$x:00002312                 xor     ecx, eax
.text$x:00002314                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002319                 mov     eax, offset __ehfuncinfo$??0CSeqName@NSplit@NArchive@@QAE@XZ
.text$x:0000231E                 jmp     ___CxxFrameHandler3
.text$x:0000231E __ehhandler$??0CSeqName@NSplit@NArchive@@QAE@XZ endp
.text$x:0000231E
.text$x:0000231E ; ---------------------------------------------------------------------------
.text$x:00002323                 align 4
.text$x:00002323 _text$x         ends
.text$x:00002323
.xdata$x:00002324 ; ===========================================================================
.xdata$x:00002324
.xdata$x:00002324 ; Segment type: Pure data
.xdata$x:00002324 ; Segment permissions: Read
.xdata$x:00002324 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002324                 assume cs:_xdata$x
.xdata$x:00002324                 ;org 2324h
.xdata$x:00002324 ; COMDAT (pick associative to section at 2294)
.xdata$x:00002324 __unwindtable$??0CSeqName@NSplit@NArchive@@QAE@XZ db 0FFh
.xdata$x:00002324                                         ; DATA XREF: .xdata$x:00002334o
.xdata$x:00002325                 db 0FFh
.xdata$x:00002326                 db 0FFh
.xdata$x:00002327                 db 0FFh
.xdata$x:00002328                 dd offset __unwindfunclet$??0CSeqName@NSplit@NArchive@@QAE@XZ$0
.xdata$x:0000232C __ehfuncinfo$??0CSeqName@NSplit@NArchive@@QAE@XZ db  22h ; "
.xdata$x:0000232C                                         ; DATA XREF: __ehhandler$??0CSeqName@NSplit@NArchive@@QAE@XZ+11o
.xdata$x:0000232D                 db    5
.xdata$x:0000232E                 db  93h ; ô
.xdata$x:0000232F                 db  19h
.xdata$x:00002330                 db    1
.xdata$x:00002331                 db    0
.xdata$x:00002332                 db    0
.xdata$x:00002333                 db    0
.xdata$x:00002334                 dd offset __unwindtable$??0CSeqName@NSplit@NArchive@@QAE@XZ
.xdata$x:00002338                 db    0
.xdata$x:00002339                 db    0
.xdata$x:0000233A                 db    0
.xdata$x:0000233B                 db    0
.xdata$x:0000233C                 db    0
.xdata$x:0000233D                 db    0
.xdata$x:0000233E                 db    0
.xdata$x:0000233F                 db    0
.xdata$x:00002340                 db    0
.xdata$x:00002341                 db    0
.xdata$x:00002342                 db    0
.xdata$x:00002343                 db    0
.xdata$x:00002344                 db    0
.xdata$x:00002345                 db    0
.xdata$x:00002346                 db    0
.xdata$x:00002347                 db    0
.xdata$x:00002348                 db    0
.xdata$x:00002349                 db    0
.xdata$x:0000234A                 db    0
.xdata$x:0000234B                 db    0
.xdata$x:0000234C                 db    1
.xdata$x:0000234D                 db    0
.xdata$x:0000234E                 db    0
.xdata$x:0000234F                 db    0
.xdata$x:0000234F _xdata$x        ends
.xdata$x:0000234F
.text:00002350 ; ===========================================================================
.text:00002350
.text:00002350 ; Segment type: Pure code
.text:00002350 ; Segment permissions: Read/Execute
.text:00002350 _text           segment para public 'CODE' use32
.text:00002350                 assume cs:_text
.text:00002350                 ;org 2350h
.text:00002350 ; COMDAT (pick any)
.text:00002350                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002350
.text:00002350 ; =============== S U B R O U T I N E =======================================
.text:00002350
.text:00002350 ; Attributes: bp-based frame
.text:00002350
.text:00002350 ; _DWORD __thiscall NArchive::NSplit::CSeqName::~CSeqName(NArchive::NSplit::CSeqName *__hidden this)
.text:00002350                 public ??1CSeqName@NSplit@NArchive@@QAE@XZ
.text:00002350 ??1CSeqName@NSplit@NArchive@@QAE@XZ proc near
.text:00002350                                         ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+363p
.text:00002350                                         ; NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+3CBp ...
.text:00002350
.text:00002350 var_10          = dword ptr -10h
.text:00002350 var_C           = dword ptr -0Ch
.text:00002350 var_4           = dword ptr -4
.text:00002350
.text:00002350                 push    ebp
.text:00002351                 mov     ebp, esp
.text:00002353                 push    0FFFFFFFFh
.text:00002355                 push    offset __ehhandler$??1CSeqName@NSplit@NArchive@@QAE@XZ
.text:0000235A                 mov     eax, large fs:0
.text:00002360                 push    eax
.text:00002361                 push    ecx
.text:00002362                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00002369                 mov     eax, dword ptr ds:___security_cookie
.text:0000236E                 xor     eax, ebp
.text:00002370                 push    eax
.text:00002371                 lea     eax, [ebp+var_C]
.text:00002374                 mov     large fs:0, eax
.text:0000237A                 mov     [ebp+var_10], ecx
.text:0000237D                 mov     [ebp+var_4], 0
.text:00002384                 mov     ecx, [ebp+var_10]
.text:00002387                 add     ecx, 0Ch        ; this
.text:0000238A                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000238F                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00002396                 mov     ecx, [ebp+var_10] ; this
.text:00002399                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000239E                 mov     ecx, [ebp+var_C]
.text:000023A1                 mov     large fs:0, ecx
.text:000023A8                 pop     ecx
.text:000023A9                 add     esp, 10h
.text:000023AC                 cmp     ebp, esp
.text:000023AE                 call    __RTC_CheckEsp
.text:000023B3                 mov     esp, ebp
.text:000023B5                 pop     ebp
.text:000023B6                 retn
.text:000023B6 ??1CSeqName@NSplit@NArchive@@QAE@XZ endp
.text:000023B6
.text:000023B6 ; ---------------------------------------------------------------------------
.text:000023B7                 align 4
.text:000023B7 _text           ends
.text:000023B7
.text$x:000023B8 ; ===========================================================================
.text$x:000023B8
.text$x:000023B8 ; Segment type: Pure code
.text$x:000023B8 ; Segment permissions: Read/Execute
.text$x:000023B8 _text$x         segment para public 'CODE' use32
.text$x:000023B8                 assume cs:_text$x
.text$x:000023B8                 ;org 23B8h
.text$x:000023B8 ; COMDAT (pick associative to section at 2350)
.text$x:000023B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000023B8
.text$x:000023B8 ; =============== S U B R O U T I N E =======================================
.text$x:000023B8
.text$x:000023B8
.text$x:000023B8 __unwindfunclet$??1CSeqName@NSplit@NArchive@@QAE@XZ$0 proc near
.text$x:000023B8                                         ; DATA XREF: .xdata$x:000023E0o
.text$x:000023B8                 mov     ecx, [ebp-10h]  ; this
.text$x:000023BB                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000023BB __unwindfunclet$??1CSeqName@NSplit@NArchive@@QAE@XZ$0 endp
.text$x:000023BB
.text$x:000023C0
.text$x:000023C0 ; =============== S U B R O U T I N E =======================================
.text$x:000023C0
.text$x:000023C0
.text$x:000023C0 __ehhandler$??1CSeqName@NSplit@NArchive@@QAE@XZ proc near
.text$x:000023C0                                         ; DATA XREF: NArchive::NSplit::CSeqName::~CSeqName(void)+5o
.text$x:000023C0
.text$x:000023C0 arg_4           = dword ptr  8
.text$x:000023C0
.text$x:000023C0                 mov     edx, [esp+arg_4]
.text$x:000023C4                 lea     eax, [edx+0Ch]
.text$x:000023C7                 mov     ecx, [edx-8]
.text$x:000023CA                 xor     ecx, eax
.text$x:000023CC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000023D1                 mov     eax, offset __ehfuncinfo$??1CSeqName@NSplit@NArchive@@QAE@XZ
.text$x:000023D6                 jmp     ___CxxFrameHandler3
.text$x:000023D6 __ehhandler$??1CSeqName@NSplit@NArchive@@QAE@XZ endp
.text$x:000023D6
.text$x:000023D6 ; ---------------------------------------------------------------------------
.text$x:000023DB                 align 4
.text$x:000023DB _text$x         ends
.text$x:000023DB
.xdata$x:000023DC ; ===========================================================================
.xdata$x:000023DC
.xdata$x:000023DC ; Segment type: Pure data
.xdata$x:000023DC ; Segment permissions: Read
.xdata$x:000023DC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000023DC                 assume cs:_xdata$x
.xdata$x:000023DC                 ;org 23DCh
.xdata$x:000023DC ; COMDAT (pick associative to section at 2350)
.xdata$x:000023DC __unwindtable$??1CSeqName@NSplit@NArchive@@QAE@XZ db 0FFh
.xdata$x:000023DC                                         ; DATA XREF: .xdata$x:000023ECo
.xdata$x:000023DD                 db 0FFh
.xdata$x:000023DE                 db 0FFh
.xdata$x:000023DF                 db 0FFh
.xdata$x:000023E0                 dd offset __unwindfunclet$??1CSeqName@NSplit@NArchive@@QAE@XZ$0
.xdata$x:000023E4 __ehfuncinfo$??1CSeqName@NSplit@NArchive@@QAE@XZ db  22h ; "
.xdata$x:000023E4                                         ; DATA XREF: __ehhandler$??1CSeqName@NSplit@NArchive@@QAE@XZ+11o
.xdata$x:000023E5                 db    5
.xdata$x:000023E6                 db  93h ; ô
.xdata$x:000023E7                 db  19h
.xdata$x:000023E8                 db    1
.xdata$x:000023E9                 db    0
.xdata$x:000023EA                 db    0
.xdata$x:000023EB                 db    0
.xdata$x:000023EC                 dd offset __unwindtable$??1CSeqName@NSplit@NArchive@@QAE@XZ
.xdata$x:000023F0                 db    0
.xdata$x:000023F1                 db    0
.xdata$x:000023F2                 db    0
.xdata$x:000023F3                 db    0
.xdata$x:000023F4                 db    0
.xdata$x:000023F5                 db    0
.xdata$x:000023F6                 db    0
.xdata$x:000023F7                 db    0
.xdata$x:000023F8                 db    0
.xdata$x:000023F9                 db    0
.xdata$x:000023FA                 db    0
.xdata$x:000023FB                 db    0
.xdata$x:000023FC                 db    0
.xdata$x:000023FD                 db    0
.xdata$x:000023FE                 db    0
.xdata$x:000023FF                 db    0
.xdata$x:00002400                 db    0
.xdata$x:00002401                 db    0
.xdata$x:00002402                 db    0
.xdata$x:00002403                 db    0
.xdata$x:00002404                 db    1
.xdata$x:00002405                 db    0
.xdata$x:00002406                 db    0
.xdata$x:00002407                 db    0
.xdata$x:00002407 _xdata$x        ends
.xdata$x:00002407
.text:00002408 ; ===========================================================================
.text:00002408
.text:00002408 ; Segment type: Pure code
.text:00002408 ; Segment permissions: Read/Execute
.text:00002408 _text           segment para public 'CODE' use32
.text:00002408                 assume cs:_text
.text:00002408                 ;org 2408h
.text:00002408 ; COMDAT (pick any)
.text:00002408                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002408
.text:00002408 ; =============== S U B R O U T I N E =======================================
.text:00002408
.text:00002408 ; Attributes: bp-based frame
.text:00002408
.text:00002408 ; void __thiscall UString::Empty(UString *__hidden this)
.text:00002408                 public ?Empty@UString@@QAEXXZ
.text:00002408 ?Empty@UString@@QAEXXZ proc near        ; CODE XREF: NArchive::NSplit::CHandler::Close(void)+1Ap
.text:00002408
.text:00002408 var_4           = dword ptr -4
.text:00002408
.text:00002408                 push    ebp
.text:00002409                 mov     ebp, esp
.text:0000240B                 push    ecx
.text:0000240C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002413                 mov     [ebp+var_4], ecx
.text:00002416                 mov     eax, [ebp+var_4]
.text:00002419                 mov     dword ptr [eax+4], 0
.text:00002420                 mov     ecx, [ebp+var_4]
.text:00002423                 mov     edx, [ecx]
.text:00002425                 xor     eax, eax
.text:00002427                 mov     [edx], ax
.text:0000242A                 mov     esp, ebp
.text:0000242C                 pop     ebp
.text:0000242D                 retn
.text:0000242D ?Empty@UString@@QAEXXZ endp
.text:0000242D
.text:0000242D ; ---------------------------------------------------------------------------
.text:0000242E                 align 10h
.text:0000242E _text           ends
.text:0000242E
.text:00002430 ; ===========================================================================
.text:00002430
.text:00002430 ; Segment type: Pure code
.text:00002430 ; Segment permissions: Read/Execute
.text:00002430 _text           segment para public 'CODE' use32
.text:00002430                 assume cs:_text
.text:00002430                 ;org 2430h
.text:00002430 ; COMDAT (pick any)
.text:00002430                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002430
.text:00002430 ; =============== S U B R O U T I N E =======================================
.text:00002430
.text:00002430 ; Attributes: bp-based frame
.text:00002430
.text:00002430 ; _DWORD __thiscall NCompress::CCopyCoder::CCopyCoder(NCompress::CCopyCoder *__hidden this)
.text:00002430                 public ??0CCopyCoder@NCompress@@QAE@XZ
.text:00002430 ??0CCopyCoder@NCompress@@QAE@XZ proc near
.text:00002430                                         ; CODE XREF: NArchive::NSplit::CHandler::Extract(uint const *,uint,int,IArchiveExtractCallback *)+1E9p
.text:00002430
.text:00002430 var_4           = dword ptr -4
.text:00002430
.text:00002430                 push    ebp
.text:00002431                 mov     ebp, esp
.text:00002433                 push    ecx
.text:00002434                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000243B                 mov     [ebp+var_4], ecx
.text:0000243E                 mov     ecx, [ebp+var_4] ; this
.text:00002441                 call    ??0ICompressCoder@@QAE@XZ ; ICompressCoder::ICompressCoder(void)
.text:00002446                 mov     ecx, [ebp+var_4]
.text:00002449                 add     ecx, 4          ; this
.text:0000244C                 call    ??0ICompressSetInStream@@QAE@XZ ; ICompressSetInStream::ICompressSetInStream(void)
.text:00002451                 mov     ecx, [ebp+var_4]
.text:00002454                 add     ecx, 8          ; this
.text:00002457                 call    ??0ISequentialInStream@@QAE@XZ ; ISequentialInStream::ISequentialInStream(void)
.text:0000245C                 mov     ecx, [ebp+var_4]
.text:0000245F                 add     ecx, 0Ch        ; this
.text:00002462                 call    ??0ICompressGetInStreamProcessedSize@@QAE@XZ ; ICompressGetInStreamProcessedSize::ICompressGetInStreamProcessedSize(void)
.text:00002467                 mov     ecx, [ebp+var_4]
.text:0000246A                 add     ecx, 10h        ; this
.text:0000246D                 call    ??0CMyUnknownImp@@QAE@XZ ; CMyUnknownImp::CMyUnknownImp(void)
.text:00002472                 mov     eax, [ebp+var_4]
.text:00002475                 mov     dword ptr [eax], offset ??_7CCopyCoder@NCompress@@6BICompressCoder@@@ ; const NCompress::CCopyCoder::`vftable'{for `ICompressCoder'}
.text:0000247B                 mov     ecx, [ebp+var_4]
.text:0000247E                 mov     dword ptr [ecx+4], offset ??_7CCopyCoder@NCompress@@6BICompressSetInStream@@@ ; const NCompress::CCopyCoder::`vftable'{for `ICompressSetInStream'}
.text:00002485                 mov     edx, [ebp+var_4]
.text:00002488                 mov     dword ptr [edx+8], offset ??_7CCopyCoder@NCompress@@6BISequentialInStream@@@ ; const NCompress::CCopyCoder::`vftable'{for `ISequentialInStream'}
.text:0000248F                 mov     eax, [ebp+var_4]
.text:00002492                 mov     dword ptr [eax+0Ch], offset ??_7CCopyCoder@NCompress@@6BICompressGetInStreamProcessedSize@@@ ; const NCompress::CCopyCoder::`vftable'{for `ICompressGetInStreamProcessedSize'}
.text:00002499                 mov     ecx, [ebp+var_4]
.text:0000249C                 mov     dword ptr [ecx+14h], 0
.text:000024A3                 mov     ecx, [ebp+var_4]
.text:000024A6                 add     ecx, 18h
.text:000024A9                 call    ??0?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::CMyComPtr<ISequentialInStream>(void)
.text:000024AE                 mov     edx, [ebp+var_4]
.text:000024B1                 mov     dword ptr [edx+20h], 0
.text:000024B8                 mov     dword ptr [edx+24h], 0
.text:000024BF                 mov     eax, [ebp+var_4]
.text:000024C2                 add     esp, 4
.text:000024C5                 cmp     ebp, esp
.text:000024C7                 call    __RTC_CheckEsp
.text:000024CC                 mov     esp, ebp
.text:000024CE                 pop     ebp
.text:000024CF                 retn
.text:000024CF ??0CCopyCoder@NCompress@@QAE@XZ endp
.text:000024CF
.text:000024CF _text           ends
.text:000024CF
.rdata:000024D0 ; ===========================================================================
.rdata:000024D0
.rdata:000024D0 ; Segment type: Pure data
.rdata:000024D0 ; Segment permissions: Read
.rdata:000024D0 _rdata          segment dword public 'DATA' use32
.rdata:000024D0                 assume cs:_rdata
.rdata:000024D0                 ;org 24D0h
.rdata:000024D0 ; COMDAT (pick largest)
.rdata:000024D0                 dd offset ??_R4CCopyCoder@NCompress@@6BICompressGetInStreamProcessedSize@@@ ; const NCompress::CCopyCoder::`RTTI Complete Object Locator'{for `ICompressGetInStreamProcessedSize'}
.rdata:000024D4                 public ??_7CCopyCoder@NCompress@@6BICompressGetInStreamProcessedSize@@@
.rdata:000024D4 ; const NCompress::CCopyCoder::`vftable'{for `ICompressGetInStreamProcessedSize'}
.rdata:000024D4 ??_7CCopyCoder@NCompress@@6BICompressGetInStreamProcessedSize@@@ dd offset ?QueryInterface@CCopyCoder@NCompress@@WM@AGJABU_GUID@@PAPAX@Z
.rdata:000024D4                                         ; DATA XREF: NCompress::CCopyCoder::CCopyCoder(void)+62o
.rdata:000024D4                                         ; [thunk]:NCompress::CCopyCoder::QueryInterface`adjustor{12}' (_GUID const &,void * *)
.rdata:000024D8                 dd offset ?AddRef@CCopyCoder@NCompress@@WM@AGKXZ ; [thunk]:NCompress::CCopyCoder::AddRef`adjustor{12}' (void)
.rdata:000024DC                 dd offset ?Release@CCopyCoder@NCompress@@WM@AGKXZ ; [thunk]:NCompress::CCopyCoder::Release`adjustor{12}' (void)
.rdata:000024E0                 dd offset ?GetInStreamProcessedSize@CCopyCoder@NCompress@@UAGJPA_K@Z ; NCompress::CCopyCoder::GetInStreamProcessedSize(unsigned __int64 *)
.rdata:000024E0 _rdata          ends
.rdata:000024E0
.rdata:000024E4 ; ===========================================================================
.rdata:000024E4
.rdata:000024E4 ; Segment type: Pure data
.rdata:000024E4 ; Segment permissions: Read
.rdata:000024E4 _rdata          segment dword public 'DATA' use32
.rdata:000024E4                 assume cs:_rdata
.rdata:000024E4                 ;org 24E4h
.rdata:000024E4 ; COMDAT (pick largest)
.rdata:000024E4                 dd offset ??_R4CCopyCoder@NCompress@@6BISequentialInStream@@@ ; const NCompress::CCopyCoder::`RTTI Complete Object Locator'{for `ISequentialInStream'}
.rdata:000024E8                 public ??_7CCopyCoder@NCompress@@6BISequentialInStream@@@
.rdata:000024E8 ; const NCompress::CCopyCoder::`vftable'{for `ISequentialInStream'}
.rdata:000024E8 ??_7CCopyCoder@NCompress@@6BISequentialInStream@@@ dd offset ?QueryInterface@CCopyCoder@NCompress@@W7AGJABU_GUID@@PAPAX@Z
.rdata:000024E8                                         ; DATA XREF: NCompress::CCopyCoder::CCopyCoder(void)+58o
.rdata:000024E8                                         ; [thunk]:NCompress::CCopyCoder::QueryInterface`adjustor{8}' (_GUID const &,void * *)
.rdata:000024EC                 dd offset ?AddRef@CCopyCoder@NCompress@@W7AGKXZ ; [thunk]:NCompress::CCopyCoder::AddRef`adjustor{8}' (void)
.rdata:000024F0                 dd offset ?Release@CCopyCoder@NCompress@@W7AGKXZ ; [thunk]:NCompress::CCopyCoder::Release`adjustor{8}' (void)
.rdata:000024F4                 dd offset ?Read@CCopyCoder@NCompress@@UAGJPAXIPAI@Z ; NCompress::CCopyCoder::Read(void *,uint,uint *)
.rdata:000024F4 _rdata          ends
.rdata:000024F4
.rdata:000024F8 ; ===========================================================================
.rdata:000024F8
.rdata:000024F8 ; Segment type: Pure data
.rdata:000024F8 ; Segment permissions: Read
.rdata:000024F8 _rdata          segment dword public 'DATA' use32
.rdata:000024F8                 assume cs:_rdata
.rdata:000024F8                 ;org 24F8h
.rdata:000024F8 ; COMDAT (pick largest)
.rdata:000024F8                 dd offset ??_R4CCopyCoder@NCompress@@6BICompressSetInStream@@@ ; const NCompress::CCopyCoder::`RTTI Complete Object Locator'{for `ICompressSetInStream'}
.rdata:000024FC                 public ??_7CCopyCoder@NCompress@@6BICompressSetInStream@@@
.rdata:000024FC ; const NCompress::CCopyCoder::`vftable'{for `ICompressSetInStream'}
.rdata:000024FC ??_7CCopyCoder@NCompress@@6BICompressSetInStream@@@ dd offset ?QueryInterface@CCopyCoder@NCompress@@W3AGJABU_GUID@@PAPAX@Z
.rdata:000024FC                                         ; DATA XREF: NCompress::CCopyCoder::CCopyCoder(void)+4Eo
.rdata:000024FC                                         ; [thunk]:NCompress::CCopyCoder::QueryInterface`adjustor{4}' (_GUID const &,void * *)
.rdata:00002500                 dd offset ?AddRef@CCopyCoder@NCompress@@W3AGKXZ ; [thunk]:NCompress::CCopyCoder::AddRef`adjustor{4}' (void)
.rdata:00002504                 dd offset ?Release@CCopyCoder@NCompress@@W3AGKXZ ; [thunk]:NCompress::CCopyCoder::Release`adjustor{4}' (void)
.rdata:00002508                 dd offset ?SetInStream@CCopyCoder@NCompress@@UAGJPAUISequentialInStream@@@Z ; NCompress::CCopyCoder::SetInStream(ISequentialInStream *)
.rdata:0000250C                 dd offset ?ReleaseInStream@CCopyCoder@NCompress@@UAGJXZ ; NCompress::CCopyCoder::ReleaseInStream(void)
.rdata:0000250C _rdata          ends
.rdata:0000250C
.rdata:00002510 ; ===========================================================================
.rdata:00002510
.rdata:00002510 ; Segment type: Pure data
.rdata:00002510 ; Segment permissions: Read
.rdata:00002510 _rdata          segment dword public 'DATA' use32
.rdata:00002510                 assume cs:_rdata
.rdata:00002510                 ;org 2510h
.rdata:00002510 ; COMDAT (pick largest)
.rdata:00002510                 dd offset ??_R4CCopyCoder@NCompress@@6BICompressCoder@@@ ; const NCompress::CCopyCoder::`RTTI Complete Object Locator'{for `ICompressCoder'}
.rdata:00002514                 public ??_7CCopyCoder@NCompress@@6BICompressCoder@@@
.rdata:00002514 ; const NCompress::CCopyCoder::`vftable'{for `ICompressCoder'}
.rdata:00002514 ??_7CCopyCoder@NCompress@@6BICompressCoder@@@ dd offset ?QueryInterface@CCopyCoder@NCompress@@UAGJABU_GUID@@PAPAX@Z
.rdata:00002514                                         ; DATA XREF: NCompress::CCopyCoder::CCopyCoder(void)+45o
.rdata:00002514                                         ; NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *)
.rdata:00002518                 dd offset ?AddRef@CCopyCoder@NCompress@@UAGKXZ ; NCompress::CCopyCoder::AddRef(void)
.rdata:0000251C                 dd offset ?Release@CCopyCoder@NCompress@@UAGKXZ ; NCompress::CCopyCoder::Release(void)
.rdata:00002520                 dd offset ?Code@CCopyCoder@NCompress@@UAGJPAUISequentialInStream@@PAUISequentialOutStream@@PB_K2PAUICompressProgressInfo@@@Z ; NCompress::CCopyCoder::Code(ISequentialInStream *,ISequentialOutStream *,unsigned __int64 const *,unsigned __int64 const *,ICompressProgressInfo *)
.rdata:00002520 _rdata          ends
.rdata:00002520
.rdata$r:00002524 ; ===========================================================================
.rdata$r:00002524
.rdata$r:00002524 ; Segment type: Pure data
.rdata$r:00002524 ; Segment permissions: Read
.rdata$r:00002524 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002524                 assume cs:_rdata$r
.rdata$r:00002524                 ;org 2524h
.rdata$r:00002524 ; COMDAT (pick any)
.rdata$r:00002524                 public ??_R4CCopyCoder@NCompress@@6BICompressCoder@@@
.rdata$r:00002524 ; const NCompress::CCopyCoder::`RTTI Complete Object Locator'{for `ICompressCoder'}
.rdata$r:00002524 ??_R4CCopyCoder@NCompress@@6BICompressCoder@@@ db    0
.rdata$r:00002524                                         ; DATA XREF: .rdata:00002510o
.rdata$r:00002525                 db    0
.rdata$r:00002526                 db    0
.rdata$r:00002527                 db    0
.rdata$r:00002528                 db    0
.rdata$r:00002529                 db    0
.rdata$r:0000252A                 db    0
.rdata$r:0000252B                 db    0
.rdata$r:0000252C                 db    0
.rdata$r:0000252D                 db    0
.rdata$r:0000252E                 db    0
.rdata$r:0000252F                 db    0
.rdata$r:00002530                 dd offset ??_R0?AVCCopyCoder@NCompress@@@8 ; NCompress::CCopyCoder `RTTI Type Descriptor'
.rdata$r:00002534                 dd offset ??_R3CCopyCoder@NCompress@@8 ; NCompress::CCopyCoder::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002534 _rdata$r        ends
.rdata$r:00002534
.data:00002538 ; ===========================================================================
.data:00002538
.data:00002538 ; Segment type: Pure data
.data:00002538 ; Segment permissions: Read/Write
.data:00002538 _data           segment dword public 'DATA' use32
.data:00002538                 assume cs:_data
.data:00002538                 ;org 2538h
.data:00002538 ; COMDAT (pick any)
.data:00002538                 public ??_R0?AVCCopyCoder@NCompress@@@8
.data:00002538 ; class NCompress::CCopyCoder `RTTI Type Descriptor'
.data:00002538 ??_R0?AVCCopyCoder@NCompress@@@8 dd offset ??_7type_info@@6B@
.data:00002538                                         ; DATA XREF: .rdata$r:00002530o
.data:00002538                                         ; .rdata$r:NCompress::CCopyCoder::`RTTI Base Class Descriptor at (0,-1,0,64)'o ...
.data:00002538                                         ; const type_info::`vftable'
.data:0000253C                 align 10h
.data:00002540 a_?avccopycoder db '.?AVCCopyCoder@NCompress@@',0
.data:0000255B                 align 4
.data:0000255B _data           ends
.data:0000255B
.rdata$r:0000255C ; ===========================================================================
.rdata$r:0000255C
.rdata$r:0000255C ; Segment type: Pure data
.rdata$r:0000255C ; Segment permissions: Read
.rdata$r:0000255C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000255C                 assume cs:_rdata$r
.rdata$r:0000255C                 ;org 255Ch
.rdata$r:0000255C ; COMDAT (pick any)
.rdata$r:0000255C                 public ??_R3CCopyCoder@NCompress@@8
.rdata$r:0000255C ; NCompress::CCopyCoder::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000255C ??_R3CCopyCoder@NCompress@@8 db    0    ; DATA XREF: .rdata$r:00002534o
.rdata$r:0000255C                                         ; .rdata$r:000025B0o ...
.rdata$r:0000255D                 db    0
.rdata$r:0000255E                 db    0
.rdata$r:0000255F                 db    0
.rdata$r:00002560                 db    5
.rdata$r:00002561                 db    0
.rdata$r:00002562                 db    0
.rdata$r:00002563                 db    0
.rdata$r:00002564                 db  0Ah
.rdata$r:00002565                 db    0
.rdata$r:00002566                 db    0
.rdata$r:00002567                 db    0
.rdata$r:00002568                 dd offset ??_R2CCopyCoder@NCompress@@8 ; NCompress::CCopyCoder::`RTTI Base Class Array'
.rdata$r:00002568 _rdata$r        ends
.rdata$r:00002568
.rdata$r:0000256C ; ===========================================================================
.rdata$r:0000256C
.rdata$r:0000256C ; Segment type: Pure data
.rdata$r:0000256C ; Segment permissions: Read
.rdata$r:0000256C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000256C                 assume cs:_rdata$r
.rdata$r:0000256C                 ;org 256Ch
.rdata$r:0000256C ; COMDAT (pick any)
.rdata$r:0000256C                 public ??_R2CCopyCoder@NCompress@@8
.rdata$r:0000256C ; NCompress::CCopyCoder::`RTTI Base Class Array'
.rdata$r:0000256C ??_R2CCopyCoder@NCompress@@8 dd offset ??_R1A@?0A@EA@CCopyCoder@NCompress@@8
.rdata$r:0000256C                                         ; DATA XREF: .rdata$r:00002568o
.rdata$r:0000256C                                         ; NCompress::CCopyCoder::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002570                 dd offset ??_R1A@?0A@EA@ICompressCoder@@8 ; ICompressCoder::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002574                 dd offset ??_R1A@?0A@EC@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,66)'
.rdata$r:00002578                 dd offset ??_R13?0A@EA@ICompressSetInStream@@8 ; ICompressSetInStream::`RTTI Base Class Descriptor at (4,-1,0,64)'
.rdata$r:0000257C                 dd offset ??_R13?0A@EC@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (4,-1,0,66)'
.rdata$r:00002580                 dd offset ??_R17?0A@EA@ISequentialInStream@@8 ; ISequentialInStream::`RTTI Base Class Descriptor at (8,-1,0,64)'
.rdata$r:00002584                 dd offset ??_R17?0A@EC@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (8,-1,0,66)'
.rdata$r:00002588                 dd offset ??_R1M@?0A@EA@ICompressGetInStreamProcessedSize@@8 ; ICompressGetInStreamProcessedSize::`RTTI Base Class Descriptor at (12,-1,0,64)'
.rdata$r:0000258C                 dd offset ??_R1M@?0A@EC@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (12,-1,0,66)'
.rdata$r:00002590                 dd offset ??_R1BA@?0A@EA@CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Base Class Descriptor at (16,-1,0,64)'
.rdata$r:00002594                 db    0
.rdata$r:00002595                 align 4
.rdata$r:00002595 _rdata$r        ends
.rdata$r:00002595
.rdata$r:00002598 ; ===========================================================================
.rdata$r:00002598
.rdata$r:00002598 ; Segment type: Pure data
.rdata$r:00002598 ; Segment permissions: Read
.rdata$r:00002598 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002598                 assume cs:_rdata$r
.rdata$r:00002598                 ;org 2598h
.rdata$r:00002598 ; COMDAT (pick any)
.rdata$r:00002598                 public ??_R1A@?0A@EA@CCopyCoder@NCompress@@8
.rdata$r:00002598 ; NCompress::CCopyCoder::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002598 ??_R1A@?0A@EA@CCopyCoder@NCompress@@8 dd offset ??_R0?AVCCopyCoder@NCompress@@@8
.rdata$r:00002598                                         ; DATA XREF: .rdata$r:NCompress::CCopyCoder::`RTTI Base Class Array'o
.rdata$r:00002598                                         ; NCompress::CCopyCoder `RTTI Type Descriptor'
.rdata$r:0000259C                 db    9
.rdata$r:0000259D                 db    0
.rdata$r:0000259E                 db    0
.rdata$r:0000259F                 db    0
.rdata$r:000025A0                 db    0
.rdata$r:000025A1                 db    0
.rdata$r:000025A2                 db    0
.rdata$r:000025A3                 db    0
.rdata$r:000025A4                 db 0FFh
.rdata$r:000025A5                 db 0FFh
.rdata$r:000025A6                 db 0FFh
.rdata$r:000025A7                 db 0FFh
.rdata$r:000025A8                 db    0
.rdata$r:000025A9                 db    0
.rdata$r:000025AA                 db    0
.rdata$r:000025AB                 db    0
.rdata$r:000025AC                 db  40h ; @
.rdata$r:000025AD                 db    0
.rdata$r:000025AE                 db    0
.rdata$r:000025AF                 db    0
.rdata$r:000025B0                 dd offset ??_R3CCopyCoder@NCompress@@8 ; NCompress::CCopyCoder::`RTTI Class Hierarchy Descriptor'
.rdata$r:000025B0 _rdata$r        ends
.rdata$r:000025B0
.rdata$r:000025B4 ; ===========================================================================
.rdata$r:000025B4
.rdata$r:000025B4 ; Segment type: Pure data
.rdata$r:000025B4 ; Segment permissions: Read
.rdata$r:000025B4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000025B4                 assume cs:_rdata$r
.rdata$r:000025B4                 ;org 25B4h
.rdata$r:000025B4 ; COMDAT (pick any)
.rdata$r:000025B4                 public ??_R1A@?0A@EA@ICompressCoder@@8
.rdata$r:000025B4 ; ICompressCoder::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000025B4 ??_R1A@?0A@EA@ICompressCoder@@8 dd offset ??_R0?AUICompressCoder@@@8
.rdata$r:000025B4                                         ; DATA XREF: .rdata$r:00002570o
.rdata$r:000025B4                                         ; .rdata$r:ICompressCoder::`RTTI Base Class Array'o
.rdata$r:000025B4                                         ; ICompressCoder `RTTI Type Descriptor'
.rdata$r:000025B8                 db    1
.rdata$r:000025B9                 db    0
.rdata$r:000025BA                 db    0
.rdata$r:000025BB                 db    0
.rdata$r:000025BC                 db    0
.rdata$r:000025BD                 db    0
.rdata$r:000025BE                 db    0
.rdata$r:000025BF                 db    0
.rdata$r:000025C0                 db 0FFh
.rdata$r:000025C1                 db 0FFh
.rdata$r:000025C2                 db 0FFh
.rdata$r:000025C3                 db 0FFh
.rdata$r:000025C4                 db    0
.rdata$r:000025C5                 db    0
.rdata$r:000025C6                 db    0
.rdata$r:000025C7                 db    0
.rdata$r:000025C8                 db  40h ; @
.rdata$r:000025C9                 db    0
.rdata$r:000025CA                 db    0
.rdata$r:000025CB                 db    0
.rdata$r:000025CC                 dd offset ??_R3ICompressCoder@@8 ; ICompressCoder::`RTTI Class Hierarchy Descriptor'
.rdata$r:000025CC _rdata$r        ends
.rdata$r:000025CC
.data:000025D0 ; ===========================================================================
.data:000025D0
.data:000025D0 ; Segment type: Pure data
.data:000025D0 ; Segment permissions: Read/Write
.data:000025D0 _data           segment dword public 'DATA' use32
.data:000025D0                 assume cs:_data
.data:000025D0                 ;org 25D0h
.data:000025D0 ; COMDAT (pick any)
.data:000025D0                 public ??_R0?AUICompressCoder@@@8
.data:000025D0 ; struct ICompressCoder `RTTI Type Descriptor'
.data:000025D0 ??_R0?AUICompressCoder@@@8 dd offset ??_7type_info@@6B@
.data:000025D0                                         ; DATA XREF: .rdata$r:ICompressCoder::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:000025D0                                         ; .rdata$r:00002B60o
.data:000025D0                                         ; const type_info::`vftable'
.data:000025D4                 align 8
.data:000025D8 a_?auicompressc db '.?AUICompressCoder@@',0
.data:000025ED                 align 10h
.data:000025ED _data           ends
.data:000025ED
.rdata$r:000025F0 ; ===========================================================================
.rdata$r:000025F0
.rdata$r:000025F0 ; Segment type: Pure data
.rdata$r:000025F0 ; Segment permissions: Read
.rdata$r:000025F0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000025F0                 assume cs:_rdata$r
.rdata$r:000025F0                 ;org 25F0h
.rdata$r:000025F0 ; COMDAT (pick any)
.rdata$r:000025F0                 public ??_R3ICompressCoder@@8
.rdata$r:000025F0 ; ICompressCoder::`RTTI Class Hierarchy Descriptor'
.rdata$r:000025F0 ??_R3ICompressCoder@@8 db    0          ; DATA XREF: .rdata$r:000025CCo
.rdata$r:000025F0                                         ; .rdata$r:00002B64o
.rdata$r:000025F1                 db    0
.rdata$r:000025F2                 db    0
.rdata$r:000025F3                 db    0
.rdata$r:000025F4                 db    0
.rdata$r:000025F5                 db    0
.rdata$r:000025F6                 db    0
.rdata$r:000025F7                 db    0
.rdata$r:000025F8                 db    2
.rdata$r:000025F9                 db    0
.rdata$r:000025FA                 db    0
.rdata$r:000025FB                 db    0
.rdata$r:000025FC                 dd offset ??_R2ICompressCoder@@8 ; ICompressCoder::`RTTI Base Class Array'
.rdata$r:000025FC _rdata$r        ends
.rdata$r:000025FC
.rdata$r:00002600 ; ===========================================================================
.rdata$r:00002600
.rdata$r:00002600 ; Segment type: Pure data
.rdata$r:00002600 ; Segment permissions: Read
.rdata$r:00002600 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002600                 assume cs:_rdata$r
.rdata$r:00002600                 ;org 2600h
.rdata$r:00002600 ; COMDAT (pick any)
.rdata$r:00002600                 public ??_R2ICompressCoder@@8
.rdata$r:00002600 ; ICompressCoder::`RTTI Base Class Array'
.rdata$r:00002600 ??_R2ICompressCoder@@8 dd offset ??_R1A@?0A@EA@ICompressCoder@@8
.rdata$r:00002600                                         ; DATA XREF: .rdata$r:000025FCo
.rdata$r:00002600                                         ; ICompressCoder::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002604                 dd offset ??_R1A@?0A@EA@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002608                 db    0
.rdata$r:00002609                 align 4
.rdata$r:00002609 _rdata$r        ends
.rdata$r:00002609
.rdata$r:0000260C ; ===========================================================================
.rdata$r:0000260C
.rdata$r:0000260C ; Segment type: Pure data
.rdata$r:0000260C ; Segment permissions: Read
.rdata$r:0000260C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000260C                 assume cs:_rdata$r
.rdata$r:0000260C                 ;org 260Ch
.rdata$r:0000260C ; COMDAT (pick any)
.rdata$r:0000260C                 public ??_R1A@?0A@EA@IUnknown@@8
.rdata$r:0000260C ; IUnknown::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000260C ??_R1A@?0A@EA@IUnknown@@8 dd offset ??_R0?AUIUnknown@@@8
.rdata$r:0000260C                                         ; DATA XREF: .rdata$r:00002604o
.rdata$r:0000260C                                         ; .rdata$r:IUnknown::`RTTI Base Class Array'o ...
.rdata$r:0000260C                                         ; IUnknown `RTTI Type Descriptor'
.rdata$r:00002610                 db    0
.rdata$r:00002611                 db    0
.rdata$r:00002612                 db    0
.rdata$r:00002613                 db    0
.rdata$r:00002614                 db    0
.rdata$r:00002615                 db    0
.rdata$r:00002616                 db    0
.rdata$r:00002617                 db    0
.rdata$r:00002618                 db 0FFh
.rdata$r:00002619                 db 0FFh
.rdata$r:0000261A                 db 0FFh
.rdata$r:0000261B                 db 0FFh
.rdata$r:0000261C                 db    0
.rdata$r:0000261D                 db    0
.rdata$r:0000261E                 db    0
.rdata$r:0000261F                 db    0
.rdata$r:00002620                 db  40h ; @
.rdata$r:00002621                 db    0
.rdata$r:00002622                 db    0
.rdata$r:00002623                 db    0
.rdata$r:00002624                 dd offset ??_R3IUnknown@@8 ; IUnknown::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002624 _rdata$r        ends
.rdata$r:00002624
.data:00002628 ; ===========================================================================
.data:00002628
.data:00002628 ; Segment type: Pure data
.data:00002628 ; Segment permissions: Read/Write
.data:00002628 _data           segment dword public 'DATA' use32
.data:00002628                 assume cs:_data
.data:00002628                 ;org 2628h
.data:00002628 ; COMDAT (pick any)
.data:00002628                 public ??_R0?AUIUnknown@@@8
.data:00002628 ; struct IUnknown `RTTI Type Descriptor'
.data:00002628 ??_R0?AUIUnknown@@@8 dd offset ??_7type_info@@6B@
.data:00002628                                         ; DATA XREF: .rdata$r:IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:00002628                                         ; .rdata$r:IUnknown::`RTTI Base Class Descriptor at (0,-1,0,66)'o ...
.data:00002628                                         ; const type_info::`vftable'
.data:0000262C                 align 10h
.data:00002630 a_?auiunknown@@ db '.?AUIUnknown@@',0
.data:0000263F                 align 10h
.data:0000263F _data           ends
.data:0000263F
.rdata$r:00002640 ; ===========================================================================
.rdata$r:00002640
.rdata$r:00002640 ; Segment type: Pure data
.rdata$r:00002640 ; Segment permissions: Read
.rdata$r:00002640 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002640                 assume cs:_rdata$r
.rdata$r:00002640                 ;org 2640h
.rdata$r:00002640 ; COMDAT (pick any)
.rdata$r:00002640                 public ??_R3IUnknown@@8
.rdata$r:00002640 ; IUnknown::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002640 ??_R3IUnknown@@8 db    0                ; DATA XREF: .rdata$r:00002624o
.rdata$r:00002640                                         ; .rdata$r:00002670o ...
.rdata$r:00002641                 db    0
.rdata$r:00002642                 db    0
.rdata$r:00002643                 db    0
.rdata$r:00002644                 db    0
.rdata$r:00002645                 db    0
.rdata$r:00002646                 db    0
.rdata$r:00002647                 db    0
.rdata$r:00002648                 db    1
.rdata$r:00002649                 db    0
.rdata$r:0000264A                 db    0
.rdata$r:0000264B                 db    0
.rdata$r:0000264C                 dd offset ??_R2IUnknown@@8 ; IUnknown::`RTTI Base Class Array'
.rdata$r:0000264C _rdata$r        ends
.rdata$r:0000264C
.rdata$r:00002650 ; ===========================================================================
.rdata$r:00002650
.rdata$r:00002650 ; Segment type: Pure data
.rdata$r:00002650 ; Segment permissions: Read
.rdata$r:00002650 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002650                 assume cs:_rdata$r
.rdata$r:00002650                 ;org 2650h
.rdata$r:00002650 ; COMDAT (pick any)
.rdata$r:00002650                 public ??_R2IUnknown@@8
.rdata$r:00002650 ; IUnknown::`RTTI Base Class Array'
.rdata$r:00002650 ??_R2IUnknown@@8 dd offset ??_R1A@?0A@EA@IUnknown@@8
.rdata$r:00002650                                         ; DATA XREF: .rdata$r:0000264Co
.rdata$r:00002650                                         ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002654                 db    0
.rdata$r:00002655                 align 4
.rdata$r:00002655 _rdata$r        ends
.rdata$r:00002655
.rdata$r:00002658 ; ===========================================================================
.rdata$r:00002658
.rdata$r:00002658 ; Segment type: Pure data
.rdata$r:00002658 ; Segment permissions: Read
.rdata$r:00002658 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002658                 assume cs:_rdata$r
.rdata$r:00002658                 ;org 2658h
.rdata$r:00002658 ; COMDAT (pick any)
.rdata$r:00002658                 public ??_R1A@?0A@EC@IUnknown@@8
.rdata$r:00002658 ; IUnknown::`RTTI Base Class Descriptor at (0, -1, 0, 66)'
.rdata$r:00002658 ??_R1A@?0A@EC@IUnknown@@8 dd offset ??_R0?AUIUnknown@@@8
.rdata$r:00002658                                         ; DATA XREF: .rdata$r:00002574o
.rdata$r:00002658                                         ; .rdata$r:0000332Co
.rdata$r:00002658                                         ; IUnknown `RTTI Type Descriptor'
.rdata$r:0000265C                 db    0
.rdata$r:0000265D                 db    0
.rdata$r:0000265E                 db    0
.rdata$r:0000265F                 db    0
.rdata$r:00002660                 db    0
.rdata$r:00002661                 db    0
.rdata$r:00002662                 db    0
.rdata$r:00002663                 db    0
.rdata$r:00002664                 db 0FFh
.rdata$r:00002665                 db 0FFh
.rdata$r:00002666                 db 0FFh
.rdata$r:00002667                 db 0FFh
.rdata$r:00002668                 db    0
.rdata$r:00002669                 db    0
.rdata$r:0000266A                 db    0
.rdata$r:0000266B                 db    0
.rdata$r:0000266C                 db  42h ; B
.rdata$r:0000266D                 db    0
.rdata$r:0000266E                 db    0
.rdata$r:0000266F                 db    0
.rdata$r:00002670                 dd offset ??_R3IUnknown@@8 ; IUnknown::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002670 _rdata$r        ends
.rdata$r:00002670
.rdata$r:00002674 ; ===========================================================================
.rdata$r:00002674
.rdata$r:00002674 ; Segment type: Pure data
.rdata$r:00002674 ; Segment permissions: Read
.rdata$r:00002674 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002674                 assume cs:_rdata$r
.rdata$r:00002674                 ;org 2674h
.rdata$r:00002674 ; COMDAT (pick any)
.rdata$r:00002674                 public ??_R13?0A@EA@ICompressSetInStream@@8
.rdata$r:00002674 ; ICompressSetInStream::`RTTI Base Class Descriptor at (4, -1, 0, 64)'
.rdata$r:00002674 ??_R13?0A@EA@ICompressSetInStream@@8 dd offset ??_R0?AUICompressSetInStream@@@8
.rdata$r:00002674                                         ; DATA XREF: .rdata$r:00002578o
.rdata$r:00002674                                         ; ICompressSetInStream `RTTI Type Descriptor'
.rdata$r:00002678                 db    1
.rdata$r:00002679                 db    0
.rdata$r:0000267A                 db    0
.rdata$r:0000267B                 db    0
.rdata$r:0000267C                 db    4
.rdata$r:0000267D                 db    0
.rdata$r:0000267E                 db    0
.rdata$r:0000267F                 db    0
.rdata$r:00002680                 db 0FFh
.rdata$r:00002681                 db 0FFh
.rdata$r:00002682                 db 0FFh
.rdata$r:00002683                 db 0FFh
.rdata$r:00002684                 db    0
.rdata$r:00002685                 db    0
.rdata$r:00002686                 db    0
.rdata$r:00002687                 db    0
.rdata$r:00002688                 db  40h ; @
.rdata$r:00002689                 db    0
.rdata$r:0000268A                 db    0
.rdata$r:0000268B                 db    0
.rdata$r:0000268C                 dd offset ??_R3ICompressSetInStream@@8 ; ICompressSetInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000268C _rdata$r        ends
.rdata$r:0000268C
.data:00002690 ; ===========================================================================
.data:00002690
.data:00002690 ; Segment type: Pure data
.data:00002690 ; Segment permissions: Read/Write
.data:00002690 _data           segment dword public 'DATA' use32
.data:00002690                 assume cs:_data
.data:00002690                 ;org 2690h
.data:00002690 ; COMDAT (pick any)
.data:00002690                 public ??_R0?AUICompressSetInStream@@@8
.data:00002690 ; struct ICompressSetInStream `RTTI Type Descriptor'
.data:00002690 ??_R0?AUICompressSetInStream@@@8 dd offset ??_7type_info@@6B@
.data:00002690                                         ; DATA XREF: .rdata$r:ICompressSetInStream::`RTTI Base Class Descriptor at (4,-1,0,64)'o
.data:00002690                                         ; .rdata$r:ICompressSetInStream::`RTTI Base Class Descriptor at (0,-1,0,64)'o ...
.data:00002690                                         ; const type_info::`vftable'
.data:00002694                 align 8
.data:00002698 a_?auicompresss db '.?AUICompressSetInStream@@',0
.data:000026B3                 align 4
.data:000026B3 _data           ends
.data:000026B3
.rdata$r:000026B4 ; ===========================================================================
.rdata$r:000026B4
.rdata$r:000026B4 ; Segment type: Pure data
.rdata$r:000026B4 ; Segment permissions: Read
.rdata$r:000026B4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000026B4                 assume cs:_rdata$r
.rdata$r:000026B4                 ;org 26B4h
.rdata$r:000026B4 ; COMDAT (pick any)
.rdata$r:000026B4                 public ??_R3ICompressSetInStream@@8
.rdata$r:000026B4 ; ICompressSetInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:000026B4 ??_R3ICompressSetInStream@@8 db    0    ; DATA XREF: .rdata$r:0000268Co
.rdata$r:000026B4                                         ; .rdata$r:000026E8o ...
.rdata$r:000026B5                 db    0
.rdata$r:000026B6                 db    0
.rdata$r:000026B7                 db    0
.rdata$r:000026B8                 db    0
.rdata$r:000026B9                 db    0
.rdata$r:000026BA                 db    0
.rdata$r:000026BB                 db    0
.rdata$r:000026BC                 db    2
.rdata$r:000026BD                 db    0
.rdata$r:000026BE                 db    0
.rdata$r:000026BF                 db    0
.rdata$r:000026C0                 dd offset ??_R2ICompressSetInStream@@8 ; ICompressSetInStream::`RTTI Base Class Array'
.rdata$r:000026C0 _rdata$r        ends
.rdata$r:000026C0
.rdata$r:000026C4 ; ===========================================================================
.rdata$r:000026C4
.rdata$r:000026C4 ; Segment type: Pure data
.rdata$r:000026C4 ; Segment permissions: Read
.rdata$r:000026C4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000026C4                 assume cs:_rdata$r
.rdata$r:000026C4                 ;org 26C4h
.rdata$r:000026C4 ; COMDAT (pick any)
.rdata$r:000026C4                 public ??_R2ICompressSetInStream@@8
.rdata$r:000026C4 ; ICompressSetInStream::`RTTI Base Class Array'
.rdata$r:000026C4 ??_R2ICompressSetInStream@@8 dd offset ??_R1A@?0A@EA@ICompressSetInStream@@8
.rdata$r:000026C4                                         ; DATA XREF: .rdata$r:000026C0o
.rdata$r:000026C4                                         ; ICompressSetInStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000026C8                 dd offset ??_R1A@?0A@EA@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000026CC                 db    0
.rdata$r:000026CD                 align 10h
.rdata$r:000026CD _rdata$r        ends
.rdata$r:000026CD
.rdata$r:000026D0 ; ===========================================================================
.rdata$r:000026D0
.rdata$r:000026D0 ; Segment type: Pure data
.rdata$r:000026D0 ; Segment permissions: Read
.rdata$r:000026D0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000026D0                 assume cs:_rdata$r
.rdata$r:000026D0                 ;org 26D0h
.rdata$r:000026D0 ; COMDAT (pick any)
.rdata$r:000026D0                 public ??_R1A@?0A@EA@ICompressSetInStream@@8
.rdata$r:000026D0 ; ICompressSetInStream::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000026D0 ??_R1A@?0A@EA@ICompressSetInStream@@8 dd offset ??_R0?AUICompressSetInStream@@@8
.rdata$r:000026D0                                         ; DATA XREF: .rdata$r:ICompressSetInStream::`RTTI Base Class Array'o
.rdata$r:000026D0                                         ; ICompressSetInStream `RTTI Type Descriptor'
.rdata$r:000026D4                 db    1
.rdata$r:000026D5                 db    0
.rdata$r:000026D6                 db    0
.rdata$r:000026D7                 db    0
.rdata$r:000026D8                 db    0
.rdata$r:000026D9                 db    0
.rdata$r:000026DA                 db    0
.rdata$r:000026DB                 db    0
.rdata$r:000026DC                 db 0FFh
.rdata$r:000026DD                 db 0FFh
.rdata$r:000026DE                 db 0FFh
.rdata$r:000026DF                 db 0FFh
.rdata$r:000026E0                 db    0
.rdata$r:000026E1                 db    0
.rdata$r:000026E2                 db    0
.rdata$r:000026E3                 db    0
.rdata$r:000026E4                 db  40h ; @
.rdata$r:000026E5                 db    0
.rdata$r:000026E6                 db    0
.rdata$r:000026E7                 db    0
.rdata$r:000026E8                 dd offset ??_R3ICompressSetInStream@@8 ; ICompressSetInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:000026E8 _rdata$r        ends
.rdata$r:000026E8
.rdata$r:000026EC ; ===========================================================================
.rdata$r:000026EC
.rdata$r:000026EC ; Segment type: Pure data
.rdata$r:000026EC ; Segment permissions: Read
.rdata$r:000026EC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000026EC                 assume cs:_rdata$r
.rdata$r:000026EC                 ;org 26ECh
.rdata$r:000026EC ; COMDAT (pick any)
.rdata$r:000026EC                 public ??_R13?0A@EC@IUnknown@@8
.rdata$r:000026EC ; IUnknown::`RTTI Base Class Descriptor at (4, -1, 0, 66)'
.rdata$r:000026EC ??_R13?0A@EC@IUnknown@@8 dd offset ??_R0?AUIUnknown@@@8
.rdata$r:000026EC                                         ; DATA XREF: .rdata$r:0000257Co
.rdata$r:000026EC                                         ; .rdata$r:00003334o
.rdata$r:000026EC                                         ; IUnknown `RTTI Type Descriptor'
.rdata$r:000026F0                 db    0
.rdata$r:000026F1                 db    0
.rdata$r:000026F2                 db    0
.rdata$r:000026F3                 db    0
.rdata$r:000026F4                 db    4
.rdata$r:000026F5                 db    0
.rdata$r:000026F6                 db    0
.rdata$r:000026F7                 db    0
.rdata$r:000026F8                 db 0FFh
.rdata$r:000026F9                 db 0FFh
.rdata$r:000026FA                 db 0FFh
.rdata$r:000026FB                 db 0FFh
.rdata$r:000026FC                 db    0
.rdata$r:000026FD                 db    0
.rdata$r:000026FE                 db    0
.rdata$r:000026FF                 db    0
.rdata$r:00002700                 db  42h ; B
.rdata$r:00002701                 db    0
.rdata$r:00002702                 db    0
.rdata$r:00002703                 db    0
.rdata$r:00002704                 dd offset ??_R3IUnknown@@8 ; IUnknown::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002704 _rdata$r        ends
.rdata$r:00002704
.rdata$r:00002708 ; ===========================================================================
.rdata$r:00002708
.rdata$r:00002708 ; Segment type: Pure data
.rdata$r:00002708 ; Segment permissions: Read
.rdata$r:00002708 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002708                 assume cs:_rdata$r
.rdata$r:00002708                 ;org 2708h
.rdata$r:00002708 ; COMDAT (pick any)
.rdata$r:00002708                 public ??_R17?0A@EA@ISequentialInStream@@8
.rdata$r:00002708 ; ISequentialInStream::`RTTI Base Class Descriptor at (8, -1, 0, 64)'
.rdata$r:00002708 ??_R17?0A@EA@ISequentialInStream@@8 dd offset ??_R0?AUISequentialInStream@@@8
.rdata$r:00002708                                         ; DATA XREF: .rdata$r:00002580o
.rdata$r:00002708                                         ; ISequentialInStream `RTTI Type Descriptor'
.rdata$r:0000270C                 db    1
.rdata$r:0000270D                 db    0
.rdata$r:0000270E                 db    0
.rdata$r:0000270F                 db    0
.rdata$r:00002710                 db    8
.rdata$r:00002711                 db    0
.rdata$r:00002712                 db    0
.rdata$r:00002713                 db    0
.rdata$r:00002714                 db 0FFh
.rdata$r:00002715                 db 0FFh
.rdata$r:00002716                 db 0FFh
.rdata$r:00002717                 db 0FFh
.rdata$r:00002718                 db    0
.rdata$r:00002719                 db    0
.rdata$r:0000271A                 db    0
.rdata$r:0000271B                 db    0
.rdata$r:0000271C                 db  40h ; @
.rdata$r:0000271D                 db    0
.rdata$r:0000271E                 db    0
.rdata$r:0000271F                 db    0
.rdata$r:00002720                 dd offset ??_R3ISequentialInStream@@8 ; ISequentialInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002720 _rdata$r        ends
.rdata$r:00002720
.data:00002724 ; ===========================================================================
.data:00002724
.data:00002724 ; Segment type: Pure data
.data:00002724 ; Segment permissions: Read/Write
.data:00002724 _data           segment dword public 'DATA' use32
.data:00002724                 assume cs:_data
.data:00002724                 ;org 2724h
.data:00002724 ; COMDAT (pick any)
.data:00002724                 public ??_R0?AUISequentialInStream@@@8
.data:00002724 ; struct ISequentialInStream `RTTI Type Descriptor'
.data:00002724 ??_R0?AUISequentialInStream@@@8 dd offset ??_7type_info@@6B@
.data:00002724                                         ; DATA XREF: .rdata$r:ISequentialInStream::`RTTI Base Class Descriptor at (8,-1,0,64)'o
.data:00002724                                         ; .rdata$r:ISequentialInStream::`RTTI Base Class Descriptor at (0,-1,0,64)'o ...
.data:00002724                                         ; const type_info::`vftable'
.data:00002728                 db    0
.data:00002729                 db    0
.data:0000272A                 db    0
.data:0000272B                 db    0
.data:0000272C                 db  2Eh ; .
.data:0000272D                 db  3Fh ; ?
.data:0000272E                 db  41h ; A
.data:0000272F                 db  55h ; U
.data:00002730                 db  49h ; I
.data:00002731                 db  53h ; S
.data:00002732                 db  65h ; e
.data:00002733                 db  71h ; q
.data:00002734                 db  75h ; u
.data:00002735                 db  65h ; e
.data:00002736                 db  6Eh ; n
.data:00002737                 db  74h ; t
.data:00002738                 db  69h ; i
.data:00002739                 db  61h ; a
.data:0000273A                 db  6Ch ; l
.data:0000273B                 db  49h ; I
.data:0000273C                 db  6Eh ; n
.data:0000273D                 db  53h ; S
.data:0000273E                 db  74h ; t
.data:0000273F                 db  72h ; r
.data:00002740                 db  65h ; e
.data:00002741                 db  61h ; a
.data:00002742                 db  6Dh ; m
.data:00002743                 db  40h ; @
.data:00002744                 db  40h ; @
.data:00002745                 db    0
.data:00002746                 align 4
.data:00002746 _data           ends
.data:00002746
.rdata$r:00002748 ; ===========================================================================
.rdata$r:00002748
.rdata$r:00002748 ; Segment type: Pure data
.rdata$r:00002748 ; Segment permissions: Read
.rdata$r:00002748 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002748                 assume cs:_rdata$r
.rdata$r:00002748                 ;org 2748h
.rdata$r:00002748 ; COMDAT (pick any)
.rdata$r:00002748                 public ??_R3ISequentialInStream@@8
.rdata$r:00002748 ; ISequentialInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002748 ??_R3ISequentialInStream@@8 db    0     ; DATA XREF: .rdata$r:00002720o
.rdata$r:00002748                                         ; .rdata$r:0000277Co ...
.rdata$r:00002749                 db    0
.rdata$r:0000274A                 db    0
.rdata$r:0000274B                 db    0
.rdata$r:0000274C                 db    0
.rdata$r:0000274D                 db    0
.rdata$r:0000274E                 db    0
.rdata$r:0000274F                 db    0
.rdata$r:00002750                 db    2
.rdata$r:00002751                 db    0
.rdata$r:00002752                 db    0
.rdata$r:00002753                 db    0
.rdata$r:00002754                 dd offset ??_R2ISequentialInStream@@8 ; ISequentialInStream::`RTTI Base Class Array'
.rdata$r:00002754 _rdata$r        ends
.rdata$r:00002754
.rdata$r:00002758 ; ===========================================================================
.rdata$r:00002758
.rdata$r:00002758 ; Segment type: Pure data
.rdata$r:00002758 ; Segment permissions: Read
.rdata$r:00002758 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002758                 assume cs:_rdata$r
.rdata$r:00002758                 ;org 2758h
.rdata$r:00002758 ; COMDAT (pick any)
.rdata$r:00002758                 public ??_R2ISequentialInStream@@8
.rdata$r:00002758 ; ISequentialInStream::`RTTI Base Class Array'
.rdata$r:00002758 ??_R2ISequentialInStream@@8 dd offset ??_R1A@?0A@EA@ISequentialInStream@@8
.rdata$r:00002758                                         ; DATA XREF: .rdata$r:00002754o
.rdata$r:00002758                                         ; ISequentialInStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000275C                 dd offset ??_R1A@?0A@EA@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002760                 db    0
.rdata$r:00002761                 align 4
.rdata$r:00002761 _rdata$r        ends
.rdata$r:00002761
.rdata$r:00002764 ; ===========================================================================
.rdata$r:00002764
.rdata$r:00002764 ; Segment type: Pure data
.rdata$r:00002764 ; Segment permissions: Read
.rdata$r:00002764 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002764                 assume cs:_rdata$r
.rdata$r:00002764                 ;org 2764h
.rdata$r:00002764 ; COMDAT (pick any)
.rdata$r:00002764                 public ??_R1A@?0A@EA@ISequentialInStream@@8
.rdata$r:00002764 ; ISequentialInStream::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002764 ??_R1A@?0A@EA@ISequentialInStream@@8 dd offset ??_R0?AUISequentialInStream@@@8
.rdata$r:00002764                                         ; DATA XREF: .rdata$r:ISequentialInStream::`RTTI Base Class Array'o
.rdata$r:00002764                                         ; .rdata$r:00002EE8o ...
.rdata$r:00002764                                         ; ISequentialInStream `RTTI Type Descriptor'
.rdata$r:00002768                 db    1
.rdata$r:00002769                 db    0
.rdata$r:0000276A                 db    0
.rdata$r:0000276B                 db    0
.rdata$r:0000276C                 db    0
.rdata$r:0000276D                 db    0
.rdata$r:0000276E                 db    0
.rdata$r:0000276F                 db    0
.rdata$r:00002770                 db 0FFh
.rdata$r:00002771                 db 0FFh
.rdata$r:00002772                 db 0FFh
.rdata$r:00002773                 db 0FFh
.rdata$r:00002774                 db    0
.rdata$r:00002775                 db    0
.rdata$r:00002776                 db    0
.rdata$r:00002777                 db    0
.rdata$r:00002778                 db  40h ; @
.rdata$r:00002779                 db    0
.rdata$r:0000277A                 db    0
.rdata$r:0000277B                 db    0
.rdata$r:0000277C                 dd offset ??_R3ISequentialInStream@@8 ; ISequentialInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000277C _rdata$r        ends
.rdata$r:0000277C
.rdata$r:00002780 ; ===========================================================================
.rdata$r:00002780
.rdata$r:00002780 ; Segment type: Pure data
.rdata$r:00002780 ; Segment permissions: Read
.rdata$r:00002780 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002780                 assume cs:_rdata$r
.rdata$r:00002780                 ;org 2780h
.rdata$r:00002780 ; COMDAT (pick any)
.rdata$r:00002780                 public ??_R17?0A@EC@IUnknown@@8
.rdata$r:00002780 ; IUnknown::`RTTI Base Class Descriptor at (8, -1, 0, 66)'
.rdata$r:00002780 ??_R17?0A@EC@IUnknown@@8 dd offset ??_R0?AUIUnknown@@@8
.rdata$r:00002780                                         ; DATA XREF: .rdata$r:00002584o
.rdata$r:00002780                                         ; IUnknown `RTTI Type Descriptor'
.rdata$r:00002784                 align 8
.rdata$r:00002788                 db    8
.rdata$r:00002789                 db    0
.rdata$r:0000278A                 db    0
.rdata$r:0000278B                 db    0
.rdata$r:0000278C                 db 0FFh
.rdata$r:0000278D                 db 0FFh
.rdata$r:0000278E                 db 0FFh
.rdata$r:0000278F                 db 0FFh
.rdata$r:00002790                 db    0
.rdata$r:00002791                 db    0
.rdata$r:00002792                 db    0
.rdata$r:00002793                 db    0
.rdata$r:00002794                 db  42h ; B
.rdata$r:00002795                 db    0
.rdata$r:00002796                 db    0
.rdata$r:00002797                 db    0
.rdata$r:00002798                 dd offset ??_R3IUnknown@@8 ; IUnknown::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002798 _rdata$r        ends
.rdata$r:00002798
.rdata$r:0000279C ; ===========================================================================
.rdata$r:0000279C
.rdata$r:0000279C ; Segment type: Pure data
.rdata$r:0000279C ; Segment permissions: Read
.rdata$r:0000279C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000279C                 assume cs:_rdata$r
.rdata$r:0000279C                 ;org 279Ch
.rdata$r:0000279C ; COMDAT (pick any)
.rdata$r:0000279C                 public ??_R1M@?0A@EA@ICompressGetInStreamProcessedSize@@8
.rdata$r:0000279C ; ICompressGetInStreamProcessedSize::`RTTI Base Class Descriptor at (12, -1, 0, 64)'
.rdata$r:0000279C ??_R1M@?0A@EA@ICompressGetInStreamProcessedSize@@8 dd offset ??_R0?AUICompressGetInStreamProcessedSize@@@8
.rdata$r:0000279C                                         ; DATA XREF: .rdata$r:00002588o
.rdata$r:0000279C                                         ; ICompressGetInStreamProcessedSize `RTTI Type Descriptor'
.rdata$r:000027A0                 db    1
.rdata$r:000027A1                 db    0
.rdata$r:000027A2                 db    0
.rdata$r:000027A3                 db    0
.rdata$r:000027A4                 db  0Ch
.rdata$r:000027A5                 db    0
.rdata$r:000027A6                 db    0
.rdata$r:000027A7                 db    0
.rdata$r:000027A8                 db 0FFh
.rdata$r:000027A9                 db 0FFh
.rdata$r:000027AA                 db 0FFh
.rdata$r:000027AB                 db 0FFh
.rdata$r:000027AC                 db    0
.rdata$r:000027AD                 db    0
.rdata$r:000027AE                 db    0
.rdata$r:000027AF                 db    0
.rdata$r:000027B0                 db  40h ; @
.rdata$r:000027B1                 db    0
.rdata$r:000027B2                 db    0
.rdata$r:000027B3                 db    0
.rdata$r:000027B4                 dd offset ??_R3ICompressGetInStreamProcessedSize@@8 ; ICompressGetInStreamProcessedSize::`RTTI Class Hierarchy Descriptor'
.rdata$r:000027B4 _rdata$r        ends
.rdata$r:000027B4
.data:000027B8 ; ===========================================================================
.data:000027B8
.data:000027B8 ; Segment type: Pure data
.data:000027B8 ; Segment permissions: Read/Write
.data:000027B8 _data           segment dword public 'DATA' use32
.data:000027B8                 assume cs:_data
.data:000027B8                 ;org 27B8h
.data:000027B8 ; COMDAT (pick any)
.data:000027B8                 public ??_R0?AUICompressGetInStreamProcessedSize@@@8
.data:000027B8 ; struct ICompressGetInStreamProcessedSize `RTTI Type Descriptor'
.data:000027B8 ??_R0?AUICompressGetInStreamProcessedSize@@@8 dd offset ??_7type_info@@6B@
.data:000027B8                                         ; DATA XREF: .rdata$r:ICompressGetInStreamProcessedSize::`RTTI Base Class Descriptor at (12,-1,0,64)'o
.data:000027B8                                         ; .rdata$r:ICompressGetInStreamProcessedSize::`RTTI Base Class Descriptor at (0,-1,0,64)'o ...
.data:000027B8                                         ; const type_info::`vftable'
.data:000027BC                 align 10h
.data:000027C0 a_?auicompressg db '.?AUICompressGetInStreamProcessedSize@@',0
.data:000027C0 _data           ends
.data:000027C0
.rdata$r:000027E8 ; ===========================================================================
.rdata$r:000027E8
.rdata$r:000027E8 ; Segment type: Pure data
.rdata$r:000027E8 ; Segment permissions: Read
.rdata$r:000027E8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000027E8                 assume cs:_rdata$r
.rdata$r:000027E8                 ;org 27E8h
.rdata$r:000027E8 ; COMDAT (pick any)
.rdata$r:000027E8                 public ??_R3ICompressGetInStreamProcessedSize@@8
.rdata$r:000027E8 ; ICompressGetInStreamProcessedSize::`RTTI Class Hierarchy Descriptor'
.rdata$r:000027E8 ??_R3ICompressGetInStreamProcessedSize@@8 db    0
.rdata$r:000027E8                                         ; DATA XREF: .rdata$r:000027B4o
.rdata$r:000027E8                                         ; .rdata$r:0000281Co ...
.rdata$r:000027E9                 db    0
.rdata$r:000027EA                 db    0
.rdata$r:000027EB                 db    0
.rdata$r:000027EC                 db    0
.rdata$r:000027ED                 db    0
.rdata$r:000027EE                 db    0
.rdata$r:000027EF                 db    0
.rdata$r:000027F0                 db    2
.rdata$r:000027F1                 db    0
.rdata$r:000027F2                 db    0
.rdata$r:000027F3                 db    0
.rdata$r:000027F4                 dd offset ??_R2ICompressGetInStreamProcessedSize@@8 ; ICompressGetInStreamProcessedSize::`RTTI Base Class Array'
.rdata$r:000027F4 _rdata$r        ends
.rdata$r:000027F4
.rdata$r:000027F8 ; ===========================================================================
.rdata$r:000027F8
.rdata$r:000027F8 ; Segment type: Pure data
.rdata$r:000027F8 ; Segment permissions: Read
.rdata$r:000027F8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000027F8                 assume cs:_rdata$r
.rdata$r:000027F8                 ;org 27F8h
.rdata$r:000027F8 ; COMDAT (pick any)
.rdata$r:000027F8                 public ??_R2ICompressGetInStreamProcessedSize@@8
.rdata$r:000027F8 ; ICompressGetInStreamProcessedSize::`RTTI Base Class Array'
.rdata$r:000027F8 ??_R2ICompressGetInStreamProcessedSize@@8 dd offset ??_R1A@?0A@EA@ICompressGetInStreamProcessedSize@@8
.rdata$r:000027F8                                         ; DATA XREF: .rdata$r:000027F4o
.rdata$r:000027F8                                         ; ICompressGetInStreamProcessedSize::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000027FC                 dd offset ??_R1A@?0A@EA@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002800                 db    0
.rdata$r:00002801                 align 4
.rdata$r:00002801 _rdata$r        ends
.rdata$r:00002801
.rdata$r:00002804 ; ===========================================================================
.rdata$r:00002804
.rdata$r:00002804 ; Segment type: Pure data
.rdata$r:00002804 ; Segment permissions: Read
.rdata$r:00002804 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002804                 assume cs:_rdata$r
.rdata$r:00002804                 ;org 2804h
.rdata$r:00002804 ; COMDAT (pick any)
.rdata$r:00002804                 public ??_R1A@?0A@EA@ICompressGetInStreamProcessedSize@@8
.rdata$r:00002804 ; ICompressGetInStreamProcessedSize::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002804 ??_R1A@?0A@EA@ICompressGetInStreamProcessedSize@@8 dd offset ??_R0?AUICompressGetInStreamProcessedSize@@@8
.rdata$r:00002804                                         ; DATA XREF: .rdata$r:ICompressGetInStreamProcessedSize::`RTTI Base Class Array'o
.rdata$r:00002804                                         ; ICompressGetInStreamProcessedSize `RTTI Type Descriptor'
.rdata$r:00002808                 db    1
.rdata$r:00002809                 db    0
.rdata$r:0000280A                 db    0
.rdata$r:0000280B                 db    0
.rdata$r:0000280C                 db    0
.rdata$r:0000280D                 db    0
.rdata$r:0000280E                 db    0
.rdata$r:0000280F                 db    0
.rdata$r:00002810                 db 0FFh
.rdata$r:00002811                 db 0FFh
.rdata$r:00002812                 db 0FFh
.rdata$r:00002813                 db 0FFh
.rdata$r:00002814                 db    0
.rdata$r:00002815                 db    0
.rdata$r:00002816                 db    0
.rdata$r:00002817                 db    0
.rdata$r:00002818                 db  40h ; @
.rdata$r:00002819                 db    0
.rdata$r:0000281A                 db    0
.rdata$r:0000281B                 db    0
.rdata$r:0000281C                 dd offset ??_R3ICompressGetInStreamProcessedSize@@8 ; ICompressGetInStreamProcessedSize::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000281C _rdata$r        ends
.rdata$r:0000281C
.rdata$r:00002820 ; ===========================================================================
.rdata$r:00002820
.rdata$r:00002820 ; Segment type: Pure data
.rdata$r:00002820 ; Segment permissions: Read
.rdata$r:00002820 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002820                 assume cs:_rdata$r
.rdata$r:00002820                 ;org 2820h
.rdata$r:00002820 ; COMDAT (pick any)
.rdata$r:00002820                 public ??_R1M@?0A@EC@IUnknown@@8
.rdata$r:00002820 ; IUnknown::`RTTI Base Class Descriptor at (12, -1, 0, 66)'
.rdata$r:00002820 ??_R1M@?0A@EC@IUnknown@@8 dd offset ??_R0?AUIUnknown@@@8
.rdata$r:00002820                                         ; DATA XREF: .rdata$r:0000258Co
.rdata$r:00002820                                         ; IUnknown `RTTI Type Descriptor'
.rdata$r:00002824                 align 8
.rdata$r:00002828                 db  0Ch
.rdata$r:00002829                 db    0
.rdata$r:0000282A                 db    0
.rdata$r:0000282B                 db    0
.rdata$r:0000282C                 db 0FFh
.rdata$r:0000282D                 db 0FFh
.rdata$r:0000282E                 db 0FFh
.rdata$r:0000282F                 db 0FFh
.rdata$r:00002830                 db    0
.rdata$r:00002831                 db    0
.rdata$r:00002832                 db    0
.rdata$r:00002833                 db    0
.rdata$r:00002834                 db  42h ; B
.rdata$r:00002835                 db    0
.rdata$r:00002836                 db    0
.rdata$r:00002837                 db    0
.rdata$r:00002838                 dd offset ??_R3IUnknown@@8 ; IUnknown::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002838 _rdata$r        ends
.rdata$r:00002838
.rdata$r:0000283C ; ===========================================================================
.rdata$r:0000283C
.rdata$r:0000283C ; Segment type: Pure data
.rdata$r:0000283C ; Segment permissions: Read
.rdata$r:0000283C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000283C                 assume cs:_rdata$r
.rdata$r:0000283C                 ;org 283Ch
.rdata$r:0000283C ; COMDAT (pick any)
.rdata$r:0000283C                 public ??_R1BA@?0A@EA@CMyUnknownImp@@8
.rdata$r:0000283C ; CMyUnknownImp::`RTTI Base Class Descriptor at (16, -1, 0, 64)'
.rdata$r:0000283C ??_R1BA@?0A@EA@CMyUnknownImp@@8 dd offset ??_R0?AVCMyUnknownImp@@@8
.rdata$r:0000283C                                         ; DATA XREF: .rdata$r:00002590o
.rdata$r:0000283C                                         ; CMyUnknownImp `RTTI Type Descriptor'
.rdata$r:00002840                 db    0
.rdata$r:00002841                 db    0
.rdata$r:00002842                 db    0
.rdata$r:00002843                 db    0
.rdata$r:00002844                 db  10h
.rdata$r:00002845                 db    0
.rdata$r:00002846                 db    0
.rdata$r:00002847                 db    0
.rdata$r:00002848                 db 0FFh
.rdata$r:00002849                 db 0FFh
.rdata$r:0000284A                 db 0FFh
.rdata$r:0000284B                 db 0FFh
.rdata$r:0000284C                 db    0
.rdata$r:0000284D                 db    0
.rdata$r:0000284E                 db    0
.rdata$r:0000284F                 db    0
.rdata$r:00002850                 db  40h ; @
.rdata$r:00002851                 db    0
.rdata$r:00002852                 db    0
.rdata$r:00002853                 db    0
.rdata$r:00002854                 dd offset ??_R3CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002854 _rdata$r        ends
.rdata$r:00002854
.data:00002858 ; ===========================================================================
.data:00002858
.data:00002858 ; Segment type: Pure data
.data:00002858 ; Segment permissions: Read/Write
.data:00002858 _data           segment dword public 'DATA' use32
.data:00002858                 assume cs:_data
.data:00002858                 ;org 2858h
.data:00002858 ; COMDAT (pick any)
.data:00002858                 public ??_R0?AVCMyUnknownImp@@@8
.data:00002858 ; class CMyUnknownImp `RTTI Type Descriptor'
.data:00002858 ??_R0?AVCMyUnknownImp@@@8 dd offset ??_7type_info@@6B@
.data:00002858                                         ; DATA XREF: .rdata$r:CMyUnknownImp::`RTTI Base Class Descriptor at (16,-1,0,64)'o
.data:00002858                                         ; .rdata$r:CMyUnknownImp::`RTTI Base Class Descriptor at (0,-1,0,64)'o ...
.data:00002858                                         ; const type_info::`vftable'
.data:0000285C                 align 10h
.data:00002860 a_?avcmyunknown db '.?AVCMyUnknownImp@@',0
.data:00002860 _data           ends
.data:00002860
.rdata$r:00002874 ; ===========================================================================
.rdata$r:00002874
.rdata$r:00002874 ; Segment type: Pure data
.rdata$r:00002874 ; Segment permissions: Read
.rdata$r:00002874 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002874                 assume cs:_rdata$r
.rdata$r:00002874                 ;org 2874h
.rdata$r:00002874 ; COMDAT (pick any)
.rdata$r:00002874                 public ??_R3CMyUnknownImp@@8
.rdata$r:00002874 ; CMyUnknownImp::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002874 ??_R3CMyUnknownImp@@8 db    0           ; DATA XREF: .rdata$r:00002854o
.rdata$r:00002874                                         ; .rdata$r:000028A4o ...
.rdata$r:00002875                 db    0
.rdata$r:00002876                 db    0
.rdata$r:00002877                 db    0
.rdata$r:00002878                 db    0
.rdata$r:00002879                 db    0
.rdata$r:0000287A                 db    0
.rdata$r:0000287B                 db    0
.rdata$r:0000287C                 db    1
.rdata$r:0000287D                 db    0
.rdata$r:0000287E                 db    0
.rdata$r:0000287F                 db    0
.rdata$r:00002880                 dd offset ??_R2CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Base Class Array'
.rdata$r:00002880 _rdata$r        ends
.rdata$r:00002880
.rdata$r:00002884 ; ===========================================================================
.rdata$r:00002884
.rdata$r:00002884 ; Segment type: Pure data
.rdata$r:00002884 ; Segment permissions: Read
.rdata$r:00002884 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002884                 assume cs:_rdata$r
.rdata$r:00002884                 ;org 2884h
.rdata$r:00002884 ; COMDAT (pick any)
.rdata$r:00002884                 public ??_R2CMyUnknownImp@@8
.rdata$r:00002884 ; CMyUnknownImp::`RTTI Base Class Array'
.rdata$r:00002884 ??_R2CMyUnknownImp@@8 dd offset ??_R1A@?0A@EA@CMyUnknownImp@@8
.rdata$r:00002884                                         ; DATA XREF: .rdata$r:00002880o
.rdata$r:00002884                                         ; CMyUnknownImp::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002888                 db    0
.rdata$r:00002889                 align 4
.rdata$r:00002889 _rdata$r        ends
.rdata$r:00002889
.rdata$r:0000288C ; ===========================================================================
.rdata$r:0000288C
.rdata$r:0000288C ; Segment type: Pure data
.rdata$r:0000288C ; Segment permissions: Read
.rdata$r:0000288C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000288C                 assume cs:_rdata$r
.rdata$r:0000288C                 ;org 288Ch
.rdata$r:0000288C ; COMDAT (pick any)
.rdata$r:0000288C                 public ??_R1A@?0A@EA@CMyUnknownImp@@8
.rdata$r:0000288C ; CMyUnknownImp::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000288C ??_R1A@?0A@EA@CMyUnknownImp@@8 dd offset ??_R0?AVCMyUnknownImp@@@8
.rdata$r:0000288C                                         ; DATA XREF: .rdata$r:CMyUnknownImp::`RTTI Base Class Array'o
.rdata$r:0000288C                                         ; CMyUnknownImp `RTTI Type Descriptor'
.rdata$r:00002890                 db    0
.rdata$r:00002891                 db    0
.rdata$r:00002892                 db    0
.rdata$r:00002893                 db    0
.rdata$r:00002894                 db    0
.rdata$r:00002895                 db    0
.rdata$r:00002896                 db    0
.rdata$r:00002897                 db    0
.rdata$r:00002898                 db 0FFh
.rdata$r:00002899                 db 0FFh
.rdata$r:0000289A                 db 0FFh
.rdata$r:0000289B                 db 0FFh
.rdata$r:0000289C                 db    0
.rdata$r:0000289D                 db    0
.rdata$r:0000289E                 db    0
.rdata$r:0000289F                 db    0
.rdata$r:000028A0                 db  40h ; @
.rdata$r:000028A1                 db    0
.rdata$r:000028A2                 db    0
.rdata$r:000028A3                 db    0
.rdata$r:000028A4                 dd offset ??_R3CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Class Hierarchy Descriptor'
.rdata$r:000028A4 _rdata$r        ends
.rdata$r:000028A4
.rdata$r:000028A8 ; ===========================================================================
.rdata$r:000028A8
.rdata$r:000028A8 ; Segment type: Pure data
.rdata$r:000028A8 ; Segment permissions: Read
.rdata$r:000028A8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000028A8                 assume cs:_rdata$r
.rdata$r:000028A8                 ;org 28A8h
.rdata$r:000028A8 ; COMDAT (pick any)
.rdata$r:000028A8                 public ??_R4CCopyCoder@NCompress@@6BICompressSetInStream@@@
.rdata$r:000028A8 ; const NCompress::CCopyCoder::`RTTI Complete Object Locator'{for `ICompressSetInStream'}
.rdata$r:000028A8 ??_R4CCopyCoder@NCompress@@6BICompressSetInStream@@@ db    0
.rdata$r:000028A8                                         ; DATA XREF: .rdata:000024F8o
.rdata$r:000028A9                 db    0
.rdata$r:000028AA                 db    0
.rdata$r:000028AB                 db    0
.rdata$r:000028AC                 db    4
.rdata$r:000028AD                 db    0
.rdata$r:000028AE                 db    0
.rdata$r:000028AF                 db    0
.rdata$r:000028B0                 db    0
.rdata$r:000028B1                 db    0
.rdata$r:000028B2                 db    0
.rdata$r:000028B3                 db    0
.rdata$r:000028B4                 dd offset ??_R0?AVCCopyCoder@NCompress@@@8 ; NCompress::CCopyCoder `RTTI Type Descriptor'
.rdata$r:000028B8                 dd offset ??_R3CCopyCoder@NCompress@@8 ; NCompress::CCopyCoder::`RTTI Class Hierarchy Descriptor'
.rdata$r:000028B8 _rdata$r        ends
.rdata$r:000028B8
.rdata$r:000028BC ; ===========================================================================
.rdata$r:000028BC
.rdata$r:000028BC ; Segment type: Pure data
.rdata$r:000028BC ; Segment permissions: Read
.rdata$r:000028BC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000028BC                 assume cs:_rdata$r
.rdata$r:000028BC                 ;org 28BCh
.rdata$r:000028BC ; COMDAT (pick any)
.rdata$r:000028BC                 public ??_R4CCopyCoder@NCompress@@6BISequentialInStream@@@
.rdata$r:000028BC ; const NCompress::CCopyCoder::`RTTI Complete Object Locator'{for `ISequentialInStream'}
.rdata$r:000028BC ??_R4CCopyCoder@NCompress@@6BISequentialInStream@@@ db    0
.rdata$r:000028BC                                         ; DATA XREF: .rdata:000024E4o
.rdata$r:000028BD                 db    0
.rdata$r:000028BE                 db    0
.rdata$r:000028BF                 db    0
.rdata$r:000028C0                 db    8
.rdata$r:000028C1                 db    0
.rdata$r:000028C2                 db    0
.rdata$r:000028C3                 db    0
.rdata$r:000028C4                 db    0
.rdata$r:000028C5                 db    0
.rdata$r:000028C6                 db    0
.rdata$r:000028C7                 db    0
.rdata$r:000028C8                 dd offset ??_R0?AVCCopyCoder@NCompress@@@8 ; NCompress::CCopyCoder `RTTI Type Descriptor'
.rdata$r:000028CC                 dd offset ??_R3CCopyCoder@NCompress@@8 ; NCompress::CCopyCoder::`RTTI Class Hierarchy Descriptor'
.rdata$r:000028CC _rdata$r        ends
.rdata$r:000028CC
.rdata$r:000028D0 ; ===========================================================================
.rdata$r:000028D0
.rdata$r:000028D0 ; Segment type: Pure data
.rdata$r:000028D0 ; Segment permissions: Read
.rdata$r:000028D0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000028D0                 assume cs:_rdata$r
.rdata$r:000028D0                 ;org 28D0h
.rdata$r:000028D0 ; COMDAT (pick any)
.rdata$r:000028D0                 public ??_R4CCopyCoder@NCompress@@6BICompressGetInStreamProcessedSize@@@
.rdata$r:000028D0 ; const NCompress::CCopyCoder::`RTTI Complete Object Locator'{for `ICompressGetInStreamProcessedSize'}
.rdata$r:000028D0 ??_R4CCopyCoder@NCompress@@6BICompressGetInStreamProcessedSize@@@ db    0
.rdata$r:000028D0                                         ; DATA XREF: .rdata:000024D0o
.rdata$r:000028D1                 db    0
.rdata$r:000028D2                 db    0
.rdata$r:000028D3                 db    0
.rdata$r:000028D4                 db  0Ch
.rdata$r:000028D5                 db    0
.rdata$r:000028D6                 db    0
.rdata$r:000028D7                 db    0
.rdata$r:000028D8                 db    0
.rdata$r:000028D9                 db    0
.rdata$r:000028DA                 db    0
.rdata$r:000028DB                 db    0
.rdata$r:000028DC                 dd offset ??_R0?AVCCopyCoder@NCompress@@@8 ; NCompress::CCopyCoder `RTTI Type Descriptor'
.rdata$r:000028E0                 dd offset ??_R3CCopyCoder@NCompress@@8 ; NCompress::CCopyCoder::`RTTI Class Hierarchy Descriptor'
.rdata$r:000028E0 _rdata$r        ends
.rdata$r:000028E0
.text:000028E4 ; ===========================================================================
.text:000028E4
.text:000028E4 ; Segment type: Pure code
.text:000028E4 ; Segment permissions: Read/Execute
.text:000028E4 _text           segment para public 'CODE' use32
.text:000028E4                 assume cs:_text
.text:000028E4                 ;org 28E4h
.text:000028E4 ; COMDAT (pick any)
.text:000028E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000028E4
.text:000028E4 ; =============== S U B R O U T I N E =======================================
.text:000028E4
.text:000028E4 ; Attributes: bp-based frame
.text:000028E4
.text:000028E4 ; _DWORD __thiscall CMyUnknownImp::CMyUnknownImp(CMyUnknownImp *__hidden this)
.text:000028E4                 public ??0CMyUnknownImp@@QAE@XZ
.text:000028E4 ??0CMyUnknownImp@@QAE@XZ proc near      ; CODE XREF: NCompress::CCopyCoder::CCopyCoder(void)+3Dp
.text:000028E4                                         ; CMultiStream::CMultiStream(void)+1Cp ...
.text:000028E4
.text:000028E4 var_4           = dword ptr -4
.text:000028E4
.text:000028E4                 push    ebp
.text:000028E5                 mov     ebp, esp
.text:000028E7                 push    ecx
.text:000028E8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000028EF                 mov     [ebp+var_4], ecx
.text:000028F2                 mov     eax, [ebp+var_4]
.text:000028F5                 mov     dword ptr [eax], 0
.text:000028FB                 mov     eax, [ebp+var_4]
.text:000028FE                 mov     esp, ebp
.text:00002900                 pop     ebp
.text:00002901                 retn
.text:00002901 ??0CMyUnknownImp@@QAE@XZ endp
.text:00002901
.text:00002901 ; ---------------------------------------------------------------------------
.text:00002902                 align 4
.text:00002902 _text           ends
.text:00002902
.text:00002904 ; ===========================================================================
.text:00002904
.text:00002904 ; Segment type: Pure code
.text:00002904 ; Segment permissions: Read/Execute
.text:00002904 _text           segment para public 'CODE' use32
.text:00002904                 assume cs:_text
.text:00002904                 ;org 2904h
.text:00002904 ; COMDAT (pick any)
.text:00002904                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002904
.text:00002904 ; =============== S U B R O U T I N E =======================================
.text:00002904
.text:00002904 ; Attributes: bp-based frame
.text:00002904
.text:00002904 ; __int32 __stdcall NCompress::CCopyCoder::QueryInterface(NCompress::CCopyCoder *this, const struct _GUID *Buf1, void **)
.text:00002904                 public ?QueryInterface@CCopyCoder@NCompress@@UAGJABU_GUID@@PAPAX@Z
.text:00002904 ?QueryInterface@CCopyCoder@NCompress@@UAGJABU_GUID@@PAPAX@Z proc near
.text:00002904                                         ; CODE XREF: [thunk]:NCompress::CCopyCoder::QueryInterface`adjustor{4}' (_GUID const &,void * *)+5j
.text:00002904                                         ; [thunk]:NCompress::CCopyCoder::QueryInterface`adjustor{8}' (_GUID const &,void * *)+5j ...
.text:00002904
.text:00002904 var_C           = dword ptr -0Ch
.text:00002904 var_8           = dword ptr -8
.text:00002904 var_4           = dword ptr -4
.text:00002904 this            = dword ptr  8
.text:00002904 Buf1            = dword ptr  0Ch
.text:00002904 arg_8           = dword ptr  10h
.text:00002904
.text:00002904                 push    ebp
.text:00002905                 mov     ebp, esp
.text:00002907                 sub     esp, 0Ch
.text:0000290A                 mov     [ebp+var_C], 0CCCCCCCCh
.text:00002911                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00002918                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000291F                 mov     eax, [ebp+arg_8]
.text:00002922                 mov     dword ptr [eax], 0
.text:00002928                 push    offset _IID_IUnknown ; Buf2
.text:0000292D                 mov     ecx, [ebp+Buf1]
.text:00002930                 push    ecx             ; Buf1
.text:00002931                 call    ___@8           ; __(x,x)
.text:00002936                 test    eax, eax
.text:00002938                 jz      short loc_2947
.text:0000293A                 mov     edx, [ebp+arg_8]
.text:0000293D                 mov     eax, [ebp+this]
.text:00002940                 mov     [edx], eax
.text:00002942                 jmp     loc_2A09
.text:00002947 ; ---------------------------------------------------------------------------
.text:00002947
.text:00002947 loc_2947:                               ; CODE XREF: NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *)+34j
.text:00002947                 push    offset _IID_ICompressCoder ; Buf2
.text:0000294C                 mov     ecx, [ebp+Buf1]
.text:0000294F                 push    ecx             ; Buf1
.text:00002950                 call    ___@8           ; __(x,x)
.text:00002955                 test    eax, eax
.text:00002957                 jz      short loc_2966
.text:00002959                 mov     edx, [ebp+arg_8]
.text:0000295C                 mov     eax, [ebp+this]
.text:0000295F                 mov     [edx], eax
.text:00002961                 jmp     loc_2A09
.text:00002966 ; ---------------------------------------------------------------------------
.text:00002966
.text:00002966 loc_2966:                               ; CODE XREF: NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *)+53j
.text:00002966                 push    offset _IID_ICompressSetInStream ; Buf2
.text:0000296B                 mov     ecx, [ebp+Buf1]
.text:0000296E                 push    ecx             ; Buf1
.text:0000296F                 call    ___@8           ; __(x,x)
.text:00002974                 test    eax, eax
.text:00002976                 jz      short loc_299A
.text:00002978                 cmp     [ebp+this], 0
.text:0000297C                 jz      short loc_2989
.text:0000297E                 mov     edx, [ebp+this]
.text:00002981                 add     edx, 4
.text:00002984                 mov     [ebp+var_4], edx
.text:00002987                 jmp     short loc_2990
.text:00002989 ; ---------------------------------------------------------------------------
.text:00002989
.text:00002989 loc_2989:                               ; CODE XREF: NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *)+78j
.text:00002989                 mov     [ebp+var_4], 0
.text:00002990
.text:00002990 loc_2990:                               ; CODE XREF: NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *)+83j
.text:00002990                 mov     eax, [ebp+arg_8]
.text:00002993                 mov     ecx, [ebp+var_4]
.text:00002996                 mov     [eax], ecx
.text:00002998                 jmp     short loc_2A09
.text:0000299A ; ---------------------------------------------------------------------------
.text:0000299A
.text:0000299A loc_299A:                               ; CODE XREF: NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *)+72j
.text:0000299A                 push    offset _IID_ISequentialInStream ; Buf2
.text:0000299F                 mov     edx, [ebp+Buf1]
.text:000029A2                 push    edx             ; Buf1
.text:000029A3                 call    ___@8           ; __(x,x)
.text:000029A8                 test    eax, eax
.text:000029AA                 jz      short loc_29CE
.text:000029AC                 cmp     [ebp+this], 0
.text:000029B0                 jz      short loc_29BD
.text:000029B2                 mov     eax, [ebp+this]
.text:000029B5                 add     eax, 8
.text:000029B8                 mov     [ebp+var_8], eax
.text:000029BB                 jmp     short loc_29C4
.text:000029BD ; ---------------------------------------------------------------------------
.text:000029BD
.text:000029BD loc_29BD:                               ; CODE XREF: NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *)+ACj
.text:000029BD                 mov     [ebp+var_8], 0
.text:000029C4
.text:000029C4 loc_29C4:                               ; CODE XREF: NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *)+B7j
.text:000029C4                 mov     ecx, [ebp+arg_8]
.text:000029C7                 mov     edx, [ebp+var_8]
.text:000029CA                 mov     [ecx], edx
.text:000029CC                 jmp     short loc_2A09
.text:000029CE ; ---------------------------------------------------------------------------
.text:000029CE
.text:000029CE loc_29CE:                               ; CODE XREF: NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *)+A6j
.text:000029CE                 push    offset _IID_ICompressGetInStreamProcessedSize ; Buf2
.text:000029D3                 mov     eax, [ebp+Buf1]
.text:000029D6                 push    eax             ; Buf1
.text:000029D7                 call    ___@8           ; __(x,x)
.text:000029DC                 test    eax, eax
.text:000029DE                 jz      short loc_2A02
.text:000029E0                 cmp     [ebp+this], 0
.text:000029E4                 jz      short loc_29F1
.text:000029E6                 mov     ecx, [ebp+this]
.text:000029E9                 add     ecx, 0Ch
.text:000029EC                 mov     [ebp+var_C], ecx
.text:000029EF                 jmp     short loc_29F8
.text:000029F1 ; ---------------------------------------------------------------------------
.text:000029F1
.text:000029F1 loc_29F1:                               ; CODE XREF: NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *)+E0j
.text:000029F1                 mov     [ebp+var_C], 0
.text:000029F8
.text:000029F8 loc_29F8:                               ; CODE XREF: NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *)+EBj
.text:000029F8                 mov     edx, [ebp+arg_8]
.text:000029FB                 mov     eax, [ebp+var_C]
.text:000029FE                 mov     [edx], eax
.text:00002A00                 jmp     short loc_2A09
.text:00002A02 ; ---------------------------------------------------------------------------
.text:00002A02
.text:00002A02 loc_2A02:                               ; CODE XREF: NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *)+DAj
.text:00002A02                 mov     eax, 80004002h
.text:00002A07                 jmp     short loc_2A1A
.text:00002A09 ; ---------------------------------------------------------------------------
.text:00002A09
.text:00002A09 loc_2A09:                               ; CODE XREF: NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *)+3Ej
.text:00002A09                                         ; NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *)+5Dj ...
.text:00002A09                 mov     ecx, [ebp+this]
.text:00002A0C                 mov     edx, [ecx+10h]
.text:00002A0F                 add     edx, 1
.text:00002A12                 mov     eax, [ebp+this]
.text:00002A15                 mov     [eax+10h], edx
.text:00002A18                 xor     eax, eax
.text:00002A1A
.text:00002A1A loc_2A1A:                               ; CODE XREF: NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *)+103j
.text:00002A1A                 add     esp, 0Ch
.text:00002A1D                 cmp     ebp, esp
.text:00002A1F                 call    __RTC_CheckEsp
.text:00002A24                 mov     esp, ebp
.text:00002A26                 pop     ebp
.text:00002A27                 retn    0Ch
.text:00002A27 ?QueryInterface@CCopyCoder@NCompress@@UAGJABU_GUID@@PAPAX@Z endp
.text:00002A27
.text:00002A27 ; ---------------------------------------------------------------------------
.text:00002A2A                 align 4
.text:00002A2A _text           ends
.text:00002A2A
.text:00002A2C ; ===========================================================================
.text:00002A2C
.text:00002A2C ; Segment type: Pure code
.text:00002A2C ; Segment permissions: Read/Execute
.text:00002A2C _text           segment para public 'CODE' use32
.text:00002A2C                 assume cs:_text
.text:00002A2C                 ;org 2A2Ch
.text:00002A2C ; COMDAT (pick any)
.text:00002A2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002A2C
.text:00002A2C ; =============== S U B R O U T I N E =======================================
.text:00002A2C
.text:00002A2C ; Attributes: bp-based frame
.text:00002A2C
.text:00002A2C ; int __stdcall __(void *Buf1, void *Buf2)
.text:00002A2C                 public ___@8
.text:00002A2C ___@8           proc near               ; CODE XREF: NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *)+2Dp
.text:00002A2C                                         ; NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *)+4Cp ...
.text:00002A2C
.text:00002A2C Buf1            = dword ptr  8
.text:00002A2C Buf2            = dword ptr  0Ch
.text:00002A2C
.text:00002A2C                 push    ebp
.text:00002A2D                 mov     ebp, esp
.text:00002A2F                 mov     eax, [ebp+Buf2]
.text:00002A32                 push    eax             ; Buf2
.text:00002A33                 mov     ecx, [ebp+Buf1]
.text:00002A36                 push    ecx             ; Buf1
.text:00002A37                 call    _IsEqualGUID@8  ; IsEqualGUID(x,x)
.text:00002A3C                 cmp     ebp, esp
.text:00002A3E                 call    __RTC_CheckEsp
.text:00002A43                 pop     ebp
.text:00002A44                 retn    8
.text:00002A44 ___@8           endp
.text:00002A44
.text:00002A44 ; ---------------------------------------------------------------------------
.text:00002A47                 align 4
.text:00002A47 _text           ends
.text:00002A47
.text:00002A48 ; ===========================================================================
.text:00002A48
.text:00002A48 ; Segment type: Pure code
.text:00002A48 ; Segment permissions: Read/Execute
.text:00002A48 _text           segment para public 'CODE' use32
.text:00002A48                 assume cs:_text
.text:00002A48                 ;org 2A48h
.text:00002A48 ; COMDAT (pick any)
.text:00002A48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002A48
.text:00002A48 ; =============== S U B R O U T I N E =======================================
.text:00002A48
.text:00002A48 ; Attributes: bp-based frame
.text:00002A48
.text:00002A48 ; int __stdcall IsEqualGUID(void *Buf1, void *Buf2)
.text:00002A48                 public _IsEqualGUID@8
.text:00002A48 _IsEqualGUID@8  proc near               ; CODE XREF: __(x,x)+Bp
.text:00002A48
.text:00002A48 Buf1            = dword ptr  8
.text:00002A48 Buf2            = dword ptr  0Ch
.text:00002A48
.text:00002A48                 push    ebp
.text:00002A49                 mov     ebp, esp
.text:00002A4B                 push    10h             ; Size
.text:00002A4D                 mov     eax, [ebp+Buf2]
.text:00002A50                 push    eax             ; Buf2
.text:00002A51                 mov     ecx, [ebp+Buf1]
.text:00002A54                 push    ecx             ; Buf1
.text:00002A55                 call    _memcmp
.text:00002A5A                 add     esp, 0Ch
.text:00002A5D                 neg     eax
.text:00002A5F                 sbb     eax, eax
.text:00002A61                 add     eax, 1
.text:00002A64                 cmp     ebp, esp
.text:00002A66                 call    __RTC_CheckEsp
.text:00002A6B                 pop     ebp
.text:00002A6C                 retn    8
.text:00002A6C _IsEqualGUID@8  endp
.text:00002A6C
.text:00002A6C ; ---------------------------------------------------------------------------
.text:00002A6F                 align 10h
.text:00002A6F _text           ends
.text:00002A6F
.text:00002A70 ; ===========================================================================
.text:00002A70
.text:00002A70 ; Segment type: Pure code
.text:00002A70 ; Segment permissions: Read/Execute
.text:00002A70 _text           segment para public 'CODE' use32
.text:00002A70                 assume cs:_text
.text:00002A70                 ;org 2A70h
.text:00002A70 ; COMDAT (pick any)
.text:00002A70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002A70
.text:00002A70 ; =============== S U B R O U T I N E =======================================
.text:00002A70
.text:00002A70 ; Attributes: bp-based frame
.text:00002A70
.text:00002A70 ; unsigned __int32 __stdcall NCompress::CCopyCoder::AddRef(NCompress::CCopyCoder *this)
.text:00002A70                 public ?AddRef@CCopyCoder@NCompress@@UAGKXZ
.text:00002A70 ?AddRef@CCopyCoder@NCompress@@UAGKXZ proc near
.text:00002A70                                         ; CODE XREF: [thunk]:NCompress::CCopyCoder::AddRef`adjustor{4}' (void)+5j
.text:00002A70                                         ; [thunk]:NCompress::CCopyCoder::AddRef`adjustor{8}' (void)+5j ...
.text:00002A70
.text:00002A70 var_4           = dword ptr -4
.text:00002A70 this            = dword ptr  8
.text:00002A70
.text:00002A70                 push    ebp
.text:00002A71                 mov     ebp, esp
.text:00002A73                 push    ecx
.text:00002A74                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002A7B                 mov     eax, [ebp+this]
.text:00002A7E                 mov     ecx, [eax+10h]
.text:00002A81                 add     ecx, 1
.text:00002A84                 mov     [ebp+var_4], ecx
.text:00002A87                 mov     edx, [ebp+this]
.text:00002A8A                 mov     eax, [ebp+var_4]
.text:00002A8D                 mov     [edx+10h], eax
.text:00002A90                 mov     eax, [ebp+var_4]
.text:00002A93                 mov     esp, ebp
.text:00002A95                 pop     ebp
.text:00002A96                 retn    4
.text:00002A96 ?AddRef@CCopyCoder@NCompress@@UAGKXZ endp
.text:00002A96
.text:00002A96 ; ---------------------------------------------------------------------------
.text:00002A99                 align 4
.text:00002A99 _text           ends
.text:00002A99
.text:00002A9C ; ===========================================================================
.text:00002A9C
.text:00002A9C ; Segment type: Pure code
.text:00002A9C ; Segment permissions: Read/Execute
.text:00002A9C _text           segment para public 'CODE' use32
.text:00002A9C                 assume cs:_text
.text:00002A9C                 ;org 2A9Ch
.text:00002A9C ; COMDAT (pick any)
.text:00002A9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002A9C
.text:00002A9C ; =============== S U B R O U T I N E =======================================
.text:00002A9C
.text:00002A9C ; Attributes: bp-based frame
.text:00002A9C
.text:00002A9C ; unsigned __int32 __stdcall NCompress::CCopyCoder::Release(NCompress::CCopyCoder *this)
.text:00002A9C                 public ?Release@CCopyCoder@NCompress@@UAGKXZ
.text:00002A9C ?Release@CCopyCoder@NCompress@@UAGKXZ proc near
.text:00002A9C                                         ; CODE XREF: [thunk]:NCompress::CCopyCoder::Release`adjustor{4}' (void)+5j
.text:00002A9C                                         ; [thunk]:NCompress::CCopyCoder::Release`adjustor{8}' (void)+5j ...
.text:00002A9C
.text:00002A9C var_10          = dword ptr -10h
.text:00002A9C var_C           = dword ptr -0Ch
.text:00002A9C var_8           = dword ptr -8
.text:00002A9C var_4           = dword ptr -4
.text:00002A9C this            = dword ptr  8
.text:00002A9C
.text:00002A9C                 push    ebp
.text:00002A9D                 mov     ebp, esp
.text:00002A9F                 sub     esp, 10h
.text:00002AA2                 mov     eax, 0CCCCCCCCh
.text:00002AA7                 mov     [ebp+var_10], eax
.text:00002AAA                 mov     [ebp+var_C], eax
.text:00002AAD                 mov     [ebp+var_8], eax
.text:00002AB0                 mov     [ebp+var_4], eax
.text:00002AB3                 mov     eax, [ebp+this]
.text:00002AB6                 mov     ecx, [eax+10h]
.text:00002AB9                 sub     ecx, 1
.text:00002ABC                 mov     [ebp+var_C], ecx
.text:00002ABF                 mov     edx, [ebp+this]
.text:00002AC2                 mov     eax, [ebp+var_C]
.text:00002AC5                 mov     [edx+10h], eax
.text:00002AC8                 cmp     [ebp+var_C], 0
.text:00002ACC                 jz      short loc_2AD6
.text:00002ACE                 mov     ecx, [ebp+this]
.text:00002AD1                 mov     eax, [ecx+10h]
.text:00002AD4                 jmp     short loc_2B00
.text:00002AD6 ; ---------------------------------------------------------------------------
.text:00002AD6
.text:00002AD6 loc_2AD6:                               ; CODE XREF: NCompress::CCopyCoder::Release(void)+30j
.text:00002AD6                 mov     edx, [ebp+this]
.text:00002AD9                 mov     [ebp+var_8], edx
.text:00002ADC                 mov     eax, [ebp+var_8]
.text:00002ADF                 mov     [ebp+var_4], eax
.text:00002AE2                 cmp     [ebp+var_4], 0
.text:00002AE6                 jz      short loc_2AF7
.text:00002AE8                 push    1
.text:00002AEA                 mov     ecx, [ebp+var_4]
.text:00002AED                 call    ??_GCCopyCoder@NCompress@@QAEPAXI@Z ; NCompress::CCopyCoder::`scalar deleting destructor'(uint)
.text:00002AF2                 mov     [ebp+var_10], eax
.text:00002AF5                 jmp     short loc_2AFE
.text:00002AF7 ; ---------------------------------------------------------------------------
.text:00002AF7
.text:00002AF7 loc_2AF7:                               ; CODE XREF: NCompress::CCopyCoder::Release(void)+4Aj
.text:00002AF7                 mov     [ebp+var_10], 0
.text:00002AFE
.text:00002AFE loc_2AFE:                               ; CODE XREF: NCompress::CCopyCoder::Release(void)+59j
.text:00002AFE                 xor     eax, eax
.text:00002B00
.text:00002B00 loc_2B00:                               ; CODE XREF: NCompress::CCopyCoder::Release(void)+38j
.text:00002B00                 add     esp, 10h
.text:00002B03                 cmp     ebp, esp
.text:00002B05                 call    __RTC_CheckEsp
.text:00002B0A                 mov     esp, ebp
.text:00002B0C                 pop     ebp
.text:00002B0D                 retn    4
.text:00002B0D ?Release@CCopyCoder@NCompress@@UAGKXZ endp
.text:00002B0D
.text:00002B0D _text           ends
.text:00002B0D
.text:00002B10 ; ===========================================================================
.text:00002B10
.text:00002B10 ; Segment type: Pure code
.text:00002B10 ; Segment permissions: Read/Execute
.text:00002B10 _text           segment para public 'CODE' use32
.text:00002B10                 assume cs:_text
.text:00002B10                 ;org 2B10h
.text:00002B10 ; COMDAT (pick any)
.text:00002B10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002B10
.text:00002B10 ; =============== S U B R O U T I N E =======================================
.text:00002B10
.text:00002B10 ; Attributes: bp-based frame
.text:00002B10
.text:00002B10 ; _DWORD __thiscall ICompressCoder::ICompressCoder(ICompressCoder *__hidden this)
.text:00002B10                 public ??0ICompressCoder@@QAE@XZ
.text:00002B10 ??0ICompressCoder@@QAE@XZ proc near     ; CODE XREF: NCompress::CCopyCoder::CCopyCoder(void)+11p
.text:00002B10
.text:00002B10 var_4           = dword ptr -4
.text:00002B10
.text:00002B10                 push    ebp
.text:00002B11                 mov     ebp, esp
.text:00002B13                 push    ecx
.text:00002B14                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002B1B                 mov     [ebp+var_4], ecx
.text:00002B1E                 mov     ecx, [ebp+var_4]
.text:00002B21                 call    ??0IUnknown@@QAE@XZ ; IUnknown::IUnknown(void)
.text:00002B26                 mov     eax, [ebp+var_4]
.text:00002B29                 mov     dword ptr [eax], offset ??_7ICompressCoder@@6B@ ; const ICompressCoder::`vftable'
.text:00002B2F                 mov     eax, [ebp+var_4]
.text:00002B32                 add     esp, 4
.text:00002B35                 cmp     ebp, esp
.text:00002B37                 call    __RTC_CheckEsp
.text:00002B3C                 mov     esp, ebp
.text:00002B3E                 pop     ebp
.text:00002B3F                 retn
.text:00002B3F ??0ICompressCoder@@QAE@XZ endp
.text:00002B3F
.text:00002B3F _text           ends
.text:00002B3F
.rdata:00002B40 ; ===========================================================================
.rdata:00002B40
.rdata:00002B40 ; Segment type: Pure data
.rdata:00002B40 ; Segment permissions: Read
.rdata:00002B40 _rdata          segment dword public 'DATA' use32
.rdata:00002B40                 assume cs:_rdata
.rdata:00002B40                 ;org 2B40h
.rdata:00002B40 ; COMDAT (pick largest)
.rdata:00002B40                 dd offset ??_R4ICompressCoder@@6B@ ; const ICompressCoder::`RTTI Complete Object Locator'
.rdata:00002B44                 public ??_7ICompressCoder@@6B@
.rdata:00002B44 ; const ICompressCoder::`vftable'
.rdata:00002B44 ??_7ICompressCoder@@6B@ dd offset __purecall
.rdata:00002B44                                         ; DATA XREF: ICompressCoder::ICompressCoder(void)+19o
.rdata:00002B48                 dd offset __purecall
.rdata:00002B4C                 dd offset __purecall
.rdata:00002B50                 dd offset __purecall
.rdata:00002B50 _rdata          ends
.rdata:00002B50
.rdata$r:00002B54 ; ===========================================================================
.rdata$r:00002B54
.rdata$r:00002B54 ; Segment type: Pure data
.rdata$r:00002B54 ; Segment permissions: Read
.rdata$r:00002B54 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002B54                 assume cs:_rdata$r
.rdata$r:00002B54                 ;org 2B54h
.rdata$r:00002B54 ; COMDAT (pick any)
.rdata$r:00002B54                 public ??_R4ICompressCoder@@6B@
.rdata$r:00002B54 ; const ICompressCoder::`RTTI Complete Object Locator'
.rdata$r:00002B54 ??_R4ICompressCoder@@6B@ db    0        ; DATA XREF: .rdata:00002B40o
.rdata$r:00002B55                 db    0
.rdata$r:00002B56                 db    0
.rdata$r:00002B57                 db    0
.rdata$r:00002B58                 db    0
.rdata$r:00002B59                 db    0
.rdata$r:00002B5A                 db    0
.rdata$r:00002B5B                 db    0
.rdata$r:00002B5C                 db    0
.rdata$r:00002B5D                 db    0
.rdata$r:00002B5E                 db    0
.rdata$r:00002B5F                 db    0
.rdata$r:00002B60                 dd offset ??_R0?AUICompressCoder@@@8 ; ICompressCoder `RTTI Type Descriptor'
.rdata$r:00002B64                 dd offset ??_R3ICompressCoder@@8 ; ICompressCoder::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002B64 _rdata$r        ends
.rdata$r:00002B64
.text:00002B68 ; ===========================================================================
.text:00002B68
.text:00002B68 ; Segment type: Pure code
.text:00002B68 ; Segment permissions: Read/Execute
.text:00002B68 _text           segment para public 'CODE' use32
.text:00002B68                 assume cs:_text
.text:00002B68                 ;org 2B68h
.text:00002B68 ; COMDAT (pick any)
.text:00002B68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002B68
.text:00002B68 ; =============== S U B R O U T I N E =======================================
.text:00002B68
.text:00002B68 ; Attributes: bp-based frame
.text:00002B68
.text:00002B68 ; _DWORD __thiscall ICompressSetInStream::ICompressSetInStream(ICompressSetInStream *__hidden this)
.text:00002B68                 public ??0ICompressSetInStream@@QAE@XZ
.text:00002B68 ??0ICompressSetInStream@@QAE@XZ proc near
.text:00002B68                                         ; CODE XREF: NCompress::CCopyCoder::CCopyCoder(void)+1Cp
.text:00002B68
.text:00002B68 var_4           = dword ptr -4
.text:00002B68
.text:00002B68                 push    ebp
.text:00002B69                 mov     ebp, esp
.text:00002B6B                 push    ecx
.text:00002B6C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002B73                 mov     [ebp+var_4], ecx
.text:00002B76                 mov     ecx, [ebp+var_4]
.text:00002B79                 call    ??0IUnknown@@QAE@XZ ; IUnknown::IUnknown(void)
.text:00002B7E                 mov     eax, [ebp+var_4]
.text:00002B81                 mov     dword ptr [eax], offset ??_7ICompressSetInStream@@6B@ ; const ICompressSetInStream::`vftable'
.text:00002B87                 mov     eax, [ebp+var_4]
.text:00002B8A                 add     esp, 4
.text:00002B8D                 cmp     ebp, esp
.text:00002B8F                 call    __RTC_CheckEsp
.text:00002B94                 mov     esp, ebp
.text:00002B96                 pop     ebp
.text:00002B97                 retn
.text:00002B97 ??0ICompressSetInStream@@QAE@XZ endp
.text:00002B97
.text:00002B97 _text           ends
.text:00002B97
.rdata:00002B98 ; ===========================================================================
.rdata:00002B98
.rdata:00002B98 ; Segment type: Pure data
.rdata:00002B98 ; Segment permissions: Read
.rdata:00002B98 _rdata          segment dword public 'DATA' use32
.rdata:00002B98                 assume cs:_rdata
.rdata:00002B98                 ;org 2B98h
.rdata:00002B98 ; COMDAT (pick largest)
.rdata:00002B98                 dd offset ??_R4ICompressSetInStream@@6B@ ; const ICompressSetInStream::`RTTI Complete Object Locator'
.rdata:00002B9C                 public ??_7ICompressSetInStream@@6B@
.rdata:00002B9C ; const ICompressSetInStream::`vftable'
.rdata:00002B9C ??_7ICompressSetInStream@@6B@ dd offset __purecall
.rdata:00002B9C                                         ; DATA XREF: ICompressSetInStream::ICompressSetInStream(void)+19o
.rdata:00002BA0                 dd offset __purecall
.rdata:00002BA4                 dd offset __purecall
.rdata:00002BA8                 dd offset __purecall
.rdata:00002BAC                 dd offset __purecall
.rdata:00002BAC _rdata          ends
.rdata:00002BAC
.rdata$r:00002BB0 ; ===========================================================================
.rdata$r:00002BB0
.rdata$r:00002BB0 ; Segment type: Pure data
.rdata$r:00002BB0 ; Segment permissions: Read
.rdata$r:00002BB0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002BB0                 assume cs:_rdata$r
.rdata$r:00002BB0                 ;org 2BB0h
.rdata$r:00002BB0 ; COMDAT (pick any)
.rdata$r:00002BB0                 public ??_R4ICompressSetInStream@@6B@
.rdata$r:00002BB0 ; const ICompressSetInStream::`RTTI Complete Object Locator'
.rdata$r:00002BB0 ??_R4ICompressSetInStream@@6B@ db    0  ; DATA XREF: .rdata:00002B98o
.rdata$r:00002BB1                 db    0
.rdata$r:00002BB2                 db    0
.rdata$r:00002BB3                 db    0
.rdata$r:00002BB4                 db    0
.rdata$r:00002BB5                 db    0
.rdata$r:00002BB6                 db    0
.rdata$r:00002BB7                 db    0
.rdata$r:00002BB8                 db    0
.rdata$r:00002BB9                 db    0
.rdata$r:00002BBA                 db    0
.rdata$r:00002BBB                 db    0
.rdata$r:00002BBC                 dd offset ??_R0?AUICompressSetInStream@@@8 ; ICompressSetInStream `RTTI Type Descriptor'
.rdata$r:00002BC0                 dd offset ??_R3ICompressSetInStream@@8 ; ICompressSetInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002BC0 _rdata$r        ends
.rdata$r:00002BC0
.text:00002BC4 ; ===========================================================================
.text:00002BC4
.text:00002BC4 ; Segment type: Pure code
.text:00002BC4 ; Segment permissions: Read/Execute
.text:00002BC4 _text           segment para public 'CODE' use32
.text:00002BC4                 assume cs:_text
.text:00002BC4                 ;org 2BC4h
.text:00002BC4 ; COMDAT (pick any)
.text:00002BC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002BC4
.text:00002BC4 ; =============== S U B R O U T I N E =======================================
.text:00002BC4
.text:00002BC4 ; Attributes: bp-based frame
.text:00002BC4
.text:00002BC4 ; _DWORD __thiscall ISequentialInStream::ISequentialInStream(ISequentialInStream *__hidden this)
.text:00002BC4                 public ??0ISequentialInStream@@QAE@XZ
.text:00002BC4 ??0ISequentialInStream@@QAE@XZ proc near
.text:00002BC4                                         ; CODE XREF: NCompress::CCopyCoder::CCopyCoder(void)+27p
.text:00002BC4                                         ; IInStream::IInStream(void)+11p
.text:00002BC4
.text:00002BC4 var_4           = dword ptr -4
.text:00002BC4
.text:00002BC4                 push    ebp
.text:00002BC5                 mov     ebp, esp
.text:00002BC7                 push    ecx
.text:00002BC8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002BCF                 mov     [ebp+var_4], ecx
.text:00002BD2                 mov     ecx, [ebp+var_4]
.text:00002BD5                 call    ??0IUnknown@@QAE@XZ ; IUnknown::IUnknown(void)
.text:00002BDA                 mov     eax, [ebp+var_4]
.text:00002BDD                 mov     dword ptr [eax], offset ??_7ISequentialInStream@@6B@ ; const ISequentialInStream::`vftable'
.text:00002BE3                 mov     eax, [ebp+var_4]
.text:00002BE6                 add     esp, 4
.text:00002BE9                 cmp     ebp, esp
.text:00002BEB                 call    __RTC_CheckEsp
.text:00002BF0                 mov     esp, ebp
.text:00002BF2                 pop     ebp
.text:00002BF3                 retn
.text:00002BF3 ??0ISequentialInStream@@QAE@XZ endp
.text:00002BF3
.text:00002BF3 _text           ends
.text:00002BF3
.rdata:00002BF4 ; ===========================================================================
.rdata:00002BF4
.rdata:00002BF4 ; Segment type: Pure data
.rdata:00002BF4 ; Segment permissions: Read
.rdata:00002BF4 _rdata          segment dword public 'DATA' use32
.rdata:00002BF4                 assume cs:_rdata
.rdata:00002BF4                 ;org 2BF4h
.rdata:00002BF4 ; COMDAT (pick largest)
.rdata:00002BF4                 dd offset ??_R4ISequentialInStream@@6B@ ; const ISequentialInStream::`RTTI Complete Object Locator'
.rdata:00002BF8                 public ??_7ISequentialInStream@@6B@
.rdata:00002BF8 ; const ISequentialInStream::`vftable'
.rdata:00002BF8 ??_7ISequentialInStream@@6B@ dd offset __purecall
.rdata:00002BF8                                         ; DATA XREF: ISequentialInStream::ISequentialInStream(void)+19o
.rdata:00002BFC                 dd offset __purecall
.rdata:00002C00                 dd offset __purecall
.rdata:00002C04                 dd offset __purecall
.rdata:00002C04 _rdata          ends
.rdata:00002C04
.rdata$r:00002C08 ; ===========================================================================
.rdata$r:00002C08
.rdata$r:00002C08 ; Segment type: Pure data
.rdata$r:00002C08 ; Segment permissions: Read
.rdata$r:00002C08 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002C08                 assume cs:_rdata$r
.rdata$r:00002C08                 ;org 2C08h
.rdata$r:00002C08 ; COMDAT (pick any)
.rdata$r:00002C08                 public ??_R4ISequentialInStream@@6B@
.rdata$r:00002C08 ; const ISequentialInStream::`RTTI Complete Object Locator'
.rdata$r:00002C08 ??_R4ISequentialInStream@@6B@ db    0   ; DATA XREF: .rdata:00002BF4o
.rdata$r:00002C09                 db    0
.rdata$r:00002C0A                 db    0
.rdata$r:00002C0B                 db    0
.rdata$r:00002C0C                 db    0
.rdata$r:00002C0D                 db    0
.rdata$r:00002C0E                 db    0
.rdata$r:00002C0F                 db    0
.rdata$r:00002C10                 db    0
.rdata$r:00002C11                 db    0
.rdata$r:00002C12                 db    0
.rdata$r:00002C13                 db    0
.rdata$r:00002C14                 dd offset ??_R0?AUISequentialInStream@@@8 ; ISequentialInStream `RTTI Type Descriptor'
.rdata$r:00002C18                 dd offset ??_R3ISequentialInStream@@8 ; ISequentialInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002C18 _rdata$r        ends
.rdata$r:00002C18
.text:00002C1C ; ===========================================================================
.text:00002C1C
.text:00002C1C ; Segment type: Pure code
.text:00002C1C ; Segment permissions: Read/Execute
.text:00002C1C _text           segment para public 'CODE' use32
.text:00002C1C                 assume cs:_text
.text:00002C1C                 ;org 2C1Ch
.text:00002C1C ; COMDAT (pick any)
.text:00002C1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002C1C
.text:00002C1C ; =============== S U B R O U T I N E =======================================
.text:00002C1C
.text:00002C1C ; Attributes: bp-based frame
.text:00002C1C
.text:00002C1C ; _DWORD __thiscall ICompressGetInStreamProcessedSize::ICompressGetInStreamProcessedSize(ICompressGetInStreamProcessedSize *__hidden this)
.text:00002C1C                 public ??0ICompressGetInStreamProcessedSize@@QAE@XZ
.text:00002C1C ??0ICompressGetInStreamProcessedSize@@QAE@XZ proc near
.text:00002C1C                                         ; CODE XREF: NCompress::CCopyCoder::CCopyCoder(void)+32p
.text:00002C1C
.text:00002C1C var_4           = dword ptr -4
.text:00002C1C
.text:00002C1C                 push    ebp
.text:00002C1D                 mov     ebp, esp
.text:00002C1F                 push    ecx
.text:00002C20                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002C27                 mov     [ebp+var_4], ecx
.text:00002C2A                 mov     ecx, [ebp+var_4]
.text:00002C2D                 call    ??0IUnknown@@QAE@XZ ; IUnknown::IUnknown(void)
.text:00002C32                 mov     eax, [ebp+var_4]
.text:00002C35                 mov     dword ptr [eax], offset ??_7ICompressGetInStreamProcessedSize@@6B@ ; const ICompressGetInStreamProcessedSize::`vftable'
.text:00002C3B                 mov     eax, [ebp+var_4]
.text:00002C3E                 add     esp, 4
.text:00002C41                 cmp     ebp, esp
.text:00002C43                 call    __RTC_CheckEsp
.text:00002C48                 mov     esp, ebp
.text:00002C4A                 pop     ebp
.text:00002C4B                 retn
.text:00002C4B ??0ICompressGetInStreamProcessedSize@@QAE@XZ endp
.text:00002C4B
.text:00002C4B _text           ends
.text:00002C4B
.rdata:00002C4C ; ===========================================================================
.rdata:00002C4C
.rdata:00002C4C ; Segment type: Pure data
.rdata:00002C4C ; Segment permissions: Read
.rdata:00002C4C _rdata          segment dword public 'DATA' use32
.rdata:00002C4C                 assume cs:_rdata
.rdata:00002C4C                 ;org 2C4Ch
.rdata:00002C4C ; COMDAT (pick largest)
.rdata:00002C4C                 dd offset ??_R4ICompressGetInStreamProcessedSize@@6B@ ; const ICompressGetInStreamProcessedSize::`RTTI Complete Object Locator'
.rdata:00002C50                 public ??_7ICompressGetInStreamProcessedSize@@6B@
.rdata:00002C50 ; const ICompressGetInStreamProcessedSize::`vftable'
.rdata:00002C50 ??_7ICompressGetInStreamProcessedSize@@6B@ dd offset __purecall
.rdata:00002C50                                         ; DATA XREF: ICompressGetInStreamProcessedSize::ICompressGetInStreamProcessedSize(void)+19o
.rdata:00002C54                 dd offset __purecall
.rdata:00002C58                 dd offset __purecall
.rdata:00002C5C                 dd offset __purecall
.rdata:00002C5C _rdata          ends
.rdata:00002C5C
.rdata$r:00002C60 ; ===========================================================================
.rdata$r:00002C60
.rdata$r:00002C60 ; Segment type: Pure data
.rdata$r:00002C60 ; Segment permissions: Read
.rdata$r:00002C60 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002C60                 assume cs:_rdata$r
.rdata$r:00002C60                 ;org 2C60h
.rdata$r:00002C60 ; COMDAT (pick any)
.rdata$r:00002C60                 public ??_R4ICompressGetInStreamProcessedSize@@6B@
.rdata$r:00002C60 ; const ICompressGetInStreamProcessedSize::`RTTI Complete Object Locator'
.rdata$r:00002C60 ??_R4ICompressGetInStreamProcessedSize@@6B@ db    0
.rdata$r:00002C60                                         ; DATA XREF: .rdata:00002C4Co
.rdata$r:00002C61                 db    0
.rdata$r:00002C62                 db    0
.rdata$r:00002C63                 db    0
.rdata$r:00002C64                 db    0
.rdata$r:00002C65                 db    0
.rdata$r:00002C66                 db    0
.rdata$r:00002C67                 db    0
.rdata$r:00002C68                 db    0
.rdata$r:00002C69                 db    0
.rdata$r:00002C6A                 db    0
.rdata$r:00002C6B                 db    0
.rdata$r:00002C6C                 dd offset ??_R0?AUICompressGetInStreamProcessedSize@@@8 ; ICompressGetInStreamProcessedSize `RTTI Type Descriptor'
.rdata$r:00002C70                 dd offset ??_R3ICompressGetInStreamProcessedSize@@8 ; ICompressGetInStreamProcessedSize::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002C70 _rdata$r        ends
.rdata$r:00002C70
.text:00002C74 ; ===========================================================================
.text:00002C74
.text:00002C74 ; Segment type: Pure code
.text:00002C74 ; Segment permissions: Read/Execute
.text:00002C74 _text           segment para public 'CODE' use32
.text:00002C74                 assume cs:_text
.text:00002C74                 ;org 2C74h
.text:00002C74 ; COMDAT (pick any)
.text:00002C74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002C74
.text:00002C74 ; =============== S U B R O U T I N E =======================================
.text:00002C74
.text:00002C74 ; Attributes: bp-based frame
.text:00002C74
.text:00002C74 ; public: void * __thiscall NCompress::CCopyCoder::`scalar deleting destructor'(unsigned int)
.text:00002C74                 public ??_GCCopyCoder@NCompress@@QAEPAXI@Z
.text:00002C74 ??_GCCopyCoder@NCompress@@QAEPAXI@Z proc near
.text:00002C74                                         ; CODE XREF: NCompress::CCopyCoder::Release(void)+51p
.text:00002C74
.text:00002C74 var_4           = dword ptr -4
.text:00002C74 arg_0           = dword ptr  8
.text:00002C74
.text:00002C74                 push    ebp
.text:00002C75                 mov     ebp, esp
.text:00002C77                 push    ecx
.text:00002C78                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002C7F                 mov     [ebp+var_4], ecx
.text:00002C82                 mov     ecx, [ebp+var_4] ; this
.text:00002C85                 call    ??1CCopyCoder@NCompress@@QAE@XZ ; NCompress::CCopyCoder::~CCopyCoder(void)
.text:00002C8A                 mov     eax, [ebp+arg_0]
.text:00002C8D                 and     eax, 1
.text:00002C90                 jz      short loc_2C9E
.text:00002C92                 mov     ecx, [ebp+var_4]
.text:00002C95                 push    ecx             ; void *
.text:00002C96                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00002C9B                 add     esp, 4
.text:00002C9E
.text:00002C9E loc_2C9E:                               ; CODE XREF: NCompress::CCopyCoder::`scalar deleting destructor'(uint)+1Cj
.text:00002C9E                 mov     eax, [ebp+var_4]
.text:00002CA1                 add     esp, 4
.text:00002CA4                 cmp     ebp, esp
.text:00002CA6                 call    __RTC_CheckEsp
.text:00002CAB                 mov     esp, ebp
.text:00002CAD                 pop     ebp
.text:00002CAE                 retn    4
.text:00002CAE ??_GCCopyCoder@NCompress@@QAEPAXI@Z endp
.text:00002CAE
.text:00002CAE ; ---------------------------------------------------------------------------
.text:00002CB1                 align 4
.text:00002CB1 _text           ends
.text:00002CB1
.text:00002CB4 ; ===========================================================================
.text:00002CB4
.text:00002CB4 ; Segment type: Pure code
.text:00002CB4 ; Segment permissions: Read/Execute
.text:00002CB4 _text           segment para public 'CODE' use32
.text:00002CB4                 assume cs:_text
.text:00002CB4                 ;org 2CB4h
.text:00002CB4 ; COMDAT (pick any)
.text:00002CB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002CB4
.text:00002CB4 ; =============== S U B R O U T I N E =======================================
.text:00002CB4
.text:00002CB4 ; Attributes: bp-based frame
.text:00002CB4
.text:00002CB4 ; public: __thiscall IUnknown::IUnknown(void)
.text:00002CB4                 public ??0IUnknown@@QAE@XZ
.text:00002CB4 ??0IUnknown@@QAE@XZ proc near           ; CODE XREF: ICompressCoder::ICompressCoder(void)+11p
.text:00002CB4                                         ; ICompressSetInStream::ICompressSetInStream(void)+11p ...
.text:00002CB4
.text:00002CB4 var_4           = dword ptr -4
.text:00002CB4
.text:00002CB4                 push    ebp
.text:00002CB5                 mov     ebp, esp
.text:00002CB7                 push    ecx
.text:00002CB8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002CBF                 mov     [ebp+var_4], ecx
.text:00002CC2                 mov     eax, [ebp+var_4]
.text:00002CC5                 mov     esp, ebp
.text:00002CC7                 pop     ebp
.text:00002CC8                 retn
.text:00002CC8 ??0IUnknown@@QAE@XZ endp
.text:00002CC8
.text:00002CC8 ; ---------------------------------------------------------------------------
.text:00002CC9                 align 4
.text:00002CC9 _text           ends
.text:00002CC9
.text:00002CCC ; ===========================================================================
.text:00002CCC
.text:00002CCC ; Segment type: Pure code
.text:00002CCC ; Segment permissions: Read/Execute
.text:00002CCC _text           segment para public 'CODE' use32
.text:00002CCC                 assume cs:_text
.text:00002CCC                 ;org 2CCCh
.text:00002CCC ; COMDAT (pick any)
.text:00002CCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002CCC
.text:00002CCC ; =============== S U B R O U T I N E =======================================
.text:00002CCC
.text:00002CCC ; Attributes: bp-based frame
.text:00002CCC
.text:00002CCC ; _DWORD __thiscall CMultiStream::CSubStreamInfo::CSubStreamInfo(CMultiStream::CSubStreamInfo *__hidden this)
.text:00002CCC                 public ??0CSubStreamInfo@CMultiStream@@QAE@XZ
.text:00002CCC ??0CSubStreamInfo@CMultiStream@@QAE@XZ proc near
.text:00002CCC                                         ; CODE XREF: NArchive::NSplit::CHandler::GetStream(uint,ISequentialInStream * *)+DDp
.text:00002CCC
.text:00002CCC var_4           = dword ptr -4
.text:00002CCC
.text:00002CCC                 push    ebp
.text:00002CCD                 mov     ebp, esp
.text:00002CCF                 push    ecx
.text:00002CD0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002CD7                 mov     [ebp+var_4], ecx
.text:00002CDA                 mov     ecx, [ebp+var_4]
.text:00002CDD                 call    ??0?$CMyComPtr@UIInStream@@@@QAE@XZ ; CMyComPtr<IInStream>::CMyComPtr<IInStream>(void)
.text:00002CE2                 mov     eax, [ebp+var_4]
.text:00002CE5                 mov     dword ptr [eax+8], 0
.text:00002CEC                 mov     dword ptr [eax+0Ch], 0
.text:00002CF3                 mov     ecx, [ebp+var_4]
.text:00002CF6                 mov     dword ptr [ecx+10h], 0
.text:00002CFD                 mov     dword ptr [ecx+14h], 0
.text:00002D04                 mov     edx, [ebp+var_4]
.text:00002D07                 mov     dword ptr [edx+18h], 0
.text:00002D0E                 mov     dword ptr [edx+1Ch], 0
.text:00002D15                 mov     eax, [ebp+var_4]
.text:00002D18                 add     esp, 4
.text:00002D1B                 cmp     ebp, esp
.text:00002D1D                 call    __RTC_CheckEsp
.text:00002D22                 mov     esp, ebp
.text:00002D24                 pop     ebp
.text:00002D25                 retn
.text:00002D25 ??0CSubStreamInfo@CMultiStream@@QAE@XZ endp
.text:00002D25
.text:00002D25 ; ---------------------------------------------------------------------------
.text:00002D26                 align 4
.text:00002D26 _text           ends
.text:00002D26
.text:00002D28 ; ===========================================================================
.text:00002D28
.text:00002D28 ; Segment type: Pure code
.text:00002D28 ; Segment permissions: Read/Execute
.text:00002D28 _text           segment para public 'CODE' use32
.text:00002D28                 assume cs:_text
.text:00002D28                 ;org 2D28h
.text:00002D28 ; COMDAT (pick any)
.text:00002D28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002D28
.text:00002D28 ; =============== S U B R O U T I N E =======================================
.text:00002D28
.text:00002D28 ; Attributes: bp-based frame
.text:00002D28
.text:00002D28 ; __int32 __thiscall CMultiStream::Init(CMultiStream *__hidden this)
.text:00002D28                 public ?Init@CMultiStream@@QAEJXZ
.text:00002D28 ?Init@CMultiStream@@QAEJXZ proc near    ; CODE XREF: NArchive::NSplit::CHandler::GetStream(uint,ISequentialInStream * *)+14Ap
.text:00002D28
.text:00002D28 var_1C          = dword ptr -1Ch
.text:00002D28 var_18          = dword ptr -18h
.text:00002D28 var_14          = dword ptr -14h
.text:00002D28 var_10          = dword ptr -10h
.text:00002D28 var_C           = dword ptr -0Ch
.text:00002D28 var_8           = dword ptr -8
.text:00002D28 var_4           = dword ptr -4
.text:00002D28
.text:00002D28                 push    ebp
.text:00002D29                 mov     ebp, esp
.text:00002D2B                 sub     esp, 1Ch
.text:00002D2E                 push    esi
.text:00002D2F                 mov     eax, 0CCCCCCCCh
.text:00002D34                 mov     [ebp+var_1C], eax
.text:00002D37                 mov     [ebp+var_18], eax
.text:00002D3A                 mov     [ebp+var_14], eax
.text:00002D3D                 mov     [ebp+var_10], eax
.text:00002D40                 mov     [ebp+var_C], eax
.text:00002D43                 mov     [ebp+var_8], eax
.text:00002D46                 mov     [ebp+var_4], eax
.text:00002D49                 mov     [ebp+var_4], ecx
.text:00002D4C                 mov     [ebp+var_C], 0
.text:00002D53                 mov     [ebp+var_8], 0
.text:00002D5A                 mov     [ebp+var_10], 0
.text:00002D61                 jmp     short loc_2D6C
.text:00002D63 ; ---------------------------------------------------------------------------
.text:00002D63
.text:00002D63 loc_2D63:                               ; CODE XREF: CMultiStream::Init(void):loc_2DFFj
.text:00002D63                 mov     eax, [ebp+var_10]
.text:00002D66                 add     eax, 1
.text:00002D69                 mov     [ebp+var_10], eax
.text:00002D6C
.text:00002D6C loc_2D6C:                               ; CODE XREF: CMultiStream::Init(void)+39j
.text:00002D6C                 mov     ecx, [ebp+var_4]
.text:00002D6F                 add     ecx, 1Ch
.text:00002D72                 call    ?Size@?$CObjectVector@UCSubStreamInfo@CMultiStream@@@@QBEIXZ ; CObjectVector<CMultiStream::CSubStreamInfo>::Size(void)
.text:00002D77                 cmp     [ebp+var_10], eax
.text:00002D7A                 jnb     loc_2E04
.text:00002D80                 mov     ecx, [ebp+var_10]
.text:00002D83                 push    ecx
.text:00002D84                 mov     ecx, [ebp+var_4]
.text:00002D87                 add     ecx, 1Ch
.text:00002D8A                 call    ??A?$CObjectVector@UCSubStreamInfo@CMultiStream@@@@QAEAAUCSubStreamInfo@CMultiStream@@I@Z ; CObjectVector<CMultiStream::CSubStreamInfo>::operator[](uint)
.text:00002D8F                 mov     [ebp+var_14], eax
.text:00002D92                 mov     edx, [ebp+var_14]
.text:00002D95                 mov     eax, [ebp+var_C]
.text:00002D98                 mov     [edx+10h], eax
.text:00002D9B                 mov     ecx, [ebp+var_8]
.text:00002D9E                 mov     [edx+14h], ecx
.text:00002DA1                 mov     edx, [ebp+var_10]
.text:00002DA4                 push    edx
.text:00002DA5                 mov     ecx, [ebp+var_4]
.text:00002DA8                 add     ecx, 1Ch
.text:00002DAB                 call    ??A?$CObjectVector@UCSubStreamInfo@CMultiStream@@@@QAEAAUCSubStreamInfo@CMultiStream@@I@Z ; CObjectVector<CMultiStream::CSubStreamInfo>::operator[](uint)
.text:00002DB0                 mov     ecx, [ebp+var_C]
.text:00002DB3                 add     ecx, [eax+8]
.text:00002DB6                 mov     edx, [ebp+var_8]
.text:00002DB9                 adc     edx, [eax+0Ch]
.text:00002DBC                 mov     [ebp+var_C], ecx
.text:00002DBF                 mov     [ebp+var_8], edx
.text:00002DC2                 mov     ecx, [ebp+var_14]
.text:00002DC5                 call    ??C?$CMyComPtr@UIInStream@@@@QBEPAUIInStream@@XZ ; CMyComPtr<IInStream>::operator->(void)
.text:00002DCA                 mov     [ebp+var_1C], eax
.text:00002DCD                 mov     eax, [ebp+var_14]
.text:00002DD0                 add     eax, 18h
.text:00002DD3                 mov     esi, esp
.text:00002DD5                 push    eax
.text:00002DD6                 push    1
.text:00002DD8                 push    0
.text:00002DDA                 push    0
.text:00002DDC                 mov     ecx, [ebp+var_1C]
.text:00002DDF                 push    ecx
.text:00002DE0                 mov     edx, [ebp+var_1C]
.text:00002DE3                 mov     eax, [edx]
.text:00002DE5                 mov     ecx, [eax+10h]
.text:00002DE8                 call    ecx
.text:00002DEA                 cmp     esi, esp
.text:00002DEC                 call    __RTC_CheckEsp
.text:00002DF1                 mov     [ebp+var_18], eax
.text:00002DF4                 cmp     [ebp+var_18], 0
.text:00002DF8                 jz      short loc_2DFF
.text:00002DFA                 mov     eax, [ebp+var_18]
.text:00002DFD                 jmp     short loc_2E30
.text:00002DFF ; ---------------------------------------------------------------------------
.text:00002DFF
.text:00002DFF loc_2DFF:                               ; CODE XREF: CMultiStream::Init(void)+D0j
.text:00002DFF                 jmp     loc_2D63
.text:00002E04 ; ---------------------------------------------------------------------------
.text:00002E04
.text:00002E04 loc_2E04:                               ; CODE XREF: CMultiStream::Init(void)+52j
.text:00002E04                 mov     edx, [ebp+var_4]
.text:00002E07                 mov     eax, [ebp+var_C]
.text:00002E0A                 mov     [edx+10h], eax
.text:00002E0D                 mov     ecx, [ebp+var_8]
.text:00002E10                 mov     [edx+14h], ecx
.text:00002E13                 mov     edx, [ebp+var_4]
.text:00002E16                 mov     dword ptr [edx+8], 0
.text:00002E1D                 mov     dword ptr [edx+0Ch], 0
.text:00002E24                 mov     eax, [ebp+var_4]
.text:00002E27                 mov     dword ptr [eax+18h], 0
.text:00002E2E                 xor     eax, eax
.text:00002E30
.text:00002E30 loc_2E30:                               ; CODE XREF: CMultiStream::Init(void)+D5j
.text:00002E30                 pop     esi
.text:00002E31                 add     esp, 1Ch
.text:00002E34                 cmp     ebp, esp
.text:00002E36                 call    __RTC_CheckEsp
.text:00002E3B                 mov     esp, ebp
.text:00002E3D                 pop     ebp
.text:00002E3E                 retn
.text:00002E3E ?Init@CMultiStream@@QAEJXZ endp
.text:00002E3E
.text:00002E3E ; ---------------------------------------------------------------------------
.text:00002E3F                 align 10h
.text:00002E3F _text           ends
.text:00002E3F
.text:00002E40 ; ===========================================================================
.text:00002E40
.text:00002E40 ; Segment type: Pure code
.text:00002E40 ; Segment permissions: Read/Execute
.text:00002E40 _text           segment para public 'CODE' use32
.text:00002E40                 assume cs:_text
.text:00002E40                 ;org 2E40h
.text:00002E40 ; COMDAT (pick any)
.text:00002E40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002E40
.text:00002E40 ; =============== S U B R O U T I N E =======================================
.text:00002E40
.text:00002E40 ; Attributes: bp-based frame
.text:00002E40
.text:00002E40 ; public: __thiscall CMultiStream::CMultiStream(void)
.text:00002E40                 public ??0CMultiStream@@QAE@XZ
.text:00002E40 ??0CMultiStream@@QAE@XZ proc near       ; CODE XREF: NArchive::NSplit::CHandler::GetStream(uint,ISequentialInStream * *)+7Bp
.text:00002E40
.text:00002E40 var_4           = dword ptr -4
.text:00002E40
.text:00002E40                 push    ebp
.text:00002E41                 mov     ebp, esp
.text:00002E43                 push    ecx
.text:00002E44                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002E4B                 mov     [ebp+var_4], ecx
.text:00002E4E                 mov     ecx, [ebp+var_4] ; this
.text:00002E51                 call    ??0IInStream@@QAE@XZ ; IInStream::IInStream(void)
.text:00002E56                 mov     ecx, [ebp+var_4]
.text:00002E59                 add     ecx, 4          ; this
.text:00002E5C                 call    ??0CMyUnknownImp@@QAE@XZ ; CMyUnknownImp::CMyUnknownImp(void)
.text:00002E61                 mov     eax, [ebp+var_4]
.text:00002E64                 mov     dword ptr [eax], offset ??_7CMultiStream@@6B@ ; const CMultiStream::`vftable'
.text:00002E6A                 mov     ecx, [ebp+var_4]
.text:00002E6D                 add     ecx, 1Ch
.text:00002E70                 call    ??0?$CObjectVector@UCSubStreamInfo@CMultiStream@@@@QAE@XZ ; CObjectVector<CMultiStream::CSubStreamInfo>::CObjectVector<CMultiStream::CSubStreamInfo>(void)
.text:00002E75                 mov     eax, [ebp+var_4]
.text:00002E78                 add     esp, 4
.text:00002E7B                 cmp     ebp, esp
.text:00002E7D                 call    __RTC_CheckEsp
.text:00002E82                 mov     esp, ebp
.text:00002E84                 pop     ebp
.text:00002E85                 retn
.text:00002E85 ??0CMultiStream@@QAE@XZ endp
.text:00002E85
.text:00002E85 ; ---------------------------------------------------------------------------
.text:00002E86                 align 4
.text:00002E86 _text           ends
.text:00002E86
.rdata:00002E88 ; ===========================================================================
.rdata:00002E88
.rdata:00002E88 ; Segment type: Pure data
.rdata:00002E88 ; Segment permissions: Read
.rdata:00002E88 _rdata          segment dword public 'DATA' use32
.rdata:00002E88                 assume cs:_rdata
.rdata:00002E88                 ;org 2E88h
.rdata:00002E88 ; COMDAT (pick largest)
.rdata:00002E88                 dd offset ??_R4CMultiStream@@6B@ ; const CMultiStream::`RTTI Complete Object Locator'
.rdata:00002E8C                 public ??_7CMultiStream@@6B@
.rdata:00002E8C ; const CMultiStream::`vftable'
.rdata:00002E8C ??_7CMultiStream@@6B@ dd offset ?QueryInterface@CMultiStream@@UAGJABU_GUID@@PAPAX@Z
.rdata:00002E8C                                         ; DATA XREF: CMultiStream::CMultiStream(void)+24o
.rdata:00002E8C                                         ; CMultiStream::QueryInterface(_GUID const &,void * *)
.rdata:00002E90                 dd offset ?AddRef@CMultiStream@@UAGKXZ ; CMultiStream::AddRef(void)
.rdata:00002E94                 dd offset ?Release@CMultiStream@@UAGKXZ ; CMultiStream::Release(void)
.rdata:00002E98                 dd offset ?Read@CMultiStream@@UAGJPAXIPAI@Z ; CMultiStream::Read(void *,uint,uint *)
.rdata:00002E9C                 dd offset ?Seek@CMultiStream@@UAGJ_JIPA_K@Z ; CMultiStream::Seek(__int64,uint,unsigned __int64 *)
.rdata:00002E9C _rdata          ends
.rdata:00002E9C
.rdata$r:00002EA0 ; ===========================================================================
.rdata$r:00002EA0
.rdata$r:00002EA0 ; Segment type: Pure data
.rdata$r:00002EA0 ; Segment permissions: Read
.rdata$r:00002EA0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002EA0                 assume cs:_rdata$r
.rdata$r:00002EA0                 ;org 2EA0h
.rdata$r:00002EA0 ; COMDAT (pick any)
.rdata$r:00002EA0                 public ??_R4CMultiStream@@6B@
.rdata$r:00002EA0 ; const CMultiStream::`RTTI Complete Object Locator'
.rdata$r:00002EA0 ??_R4CMultiStream@@6B@ db    0          ; DATA XREF: .rdata:00002E88o
.rdata$r:00002EA1                 db    0
.rdata$r:00002EA2                 db    0
.rdata$r:00002EA3                 db    0
.rdata$r:00002EA4                 db    0
.rdata$r:00002EA5                 db    0
.rdata$r:00002EA6                 db    0
.rdata$r:00002EA7                 db    0
.rdata$r:00002EA8                 db    0
.rdata$r:00002EA9                 db    0
.rdata$r:00002EAA                 db    0
.rdata$r:00002EAB                 db    0
.rdata$r:00002EAC                 dd offset ??_R0?AVCMultiStream@@@8 ; CMultiStream `RTTI Type Descriptor'
.rdata$r:00002EB0                 dd offset ??_R3CMultiStream@@8 ; CMultiStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002EB0 _rdata$r        ends
.rdata$r:00002EB0
.data:00002EB4 ; ===========================================================================
.data:00002EB4
.data:00002EB4 ; Segment type: Pure data
.data:00002EB4 ; Segment permissions: Read/Write
.data:00002EB4 _data           segment dword public 'DATA' use32
.data:00002EB4                 assume cs:_data
.data:00002EB4                 ;org 2EB4h
.data:00002EB4 ; COMDAT (pick any)
.data:00002EB4                 public ??_R0?AVCMultiStream@@@8
.data:00002EB4 ; class CMultiStream `RTTI Type Descriptor'
.data:00002EB4 ??_R0?AVCMultiStream@@@8 dd offset ??_7type_info@@6B@
.data:00002EB4                                         ; DATA XREF: .rdata$r:00002EACo
.data:00002EB4                                         ; .rdata$r:CMultiStream::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:00002EB4                                         ; const type_info::`vftable'
.data:00002EB8                 db    0
.data:00002EB9                 db    0
.data:00002EBA                 db    0
.data:00002EBB                 db    0
.data:00002EBC                 db  2Eh ; .
.data:00002EBD                 db  3Fh ; ?
.data:00002EBE                 db  41h ; A
.data:00002EBF                 db  56h ; V
.data:00002EC0                 db  43h ; C
.data:00002EC1                 db  4Dh ; M
.data:00002EC2                 db  75h ; u
.data:00002EC3                 db  6Ch ; l
.data:00002EC4                 db  74h ; t
.data:00002EC5                 db  69h ; i
.data:00002EC6                 db  53h ; S
.data:00002EC7                 db  74h ; t
.data:00002EC8                 db  72h ; r
.data:00002EC9                 db  65h ; e
.data:00002ECA                 db  61h ; a
.data:00002ECB                 db  6Dh ; m
.data:00002ECC                 db  40h ; @
.data:00002ECD                 db  40h ; @
.data:00002ECE                 db    0
.data:00002ECF                 align 10h
.data:00002ECF _data           ends
.data:00002ECF
.rdata$r:00002ED0 ; ===========================================================================
.rdata$r:00002ED0
.rdata$r:00002ED0 ; Segment type: Pure data
.rdata$r:00002ED0 ; Segment permissions: Read
.rdata$r:00002ED0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002ED0                 assume cs:_rdata$r
.rdata$r:00002ED0                 ;org 2ED0h
.rdata$r:00002ED0 ; COMDAT (pick any)
.rdata$r:00002ED0                 public ??_R3CMultiStream@@8
.rdata$r:00002ED0 ; CMultiStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002ED0 ??_R3CMultiStream@@8 db    0            ; DATA XREF: .rdata$r:00002EB0o
.rdata$r:00002ED0                                         ; .rdata$r:00002F10o
.rdata$r:00002ED1                 db    0
.rdata$r:00002ED2                 db    0
.rdata$r:00002ED3                 db    0
.rdata$r:00002ED4                 db    1
.rdata$r:00002ED5                 db    0
.rdata$r:00002ED6                 db    0
.rdata$r:00002ED7                 db    0
.rdata$r:00002ED8                 db    5
.rdata$r:00002ED9                 db    0
.rdata$r:00002EDA                 db    0
.rdata$r:00002EDB                 db    0
.rdata$r:00002EDC                 dd offset ??_R2CMultiStream@@8 ; CMultiStream::`RTTI Base Class Array'
.rdata$r:00002EDC _rdata$r        ends
.rdata$r:00002EDC
.rdata$r:00002EE0 ; ===========================================================================
.rdata$r:00002EE0
.rdata$r:00002EE0 ; Segment type: Pure data
.rdata$r:00002EE0 ; Segment permissions: Read
.rdata$r:00002EE0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002EE0                 assume cs:_rdata$r
.rdata$r:00002EE0                 ;org 2EE0h
.rdata$r:00002EE0 ; COMDAT (pick any)
.rdata$r:00002EE0                 public ??_R2CMultiStream@@8
.rdata$r:00002EE0 ; CMultiStream::`RTTI Base Class Array'
.rdata$r:00002EE0 ??_R2CMultiStream@@8 dd offset ??_R1A@?0A@EA@CMultiStream@@8
.rdata$r:00002EE0                                         ; DATA XREF: .rdata$r:00002EDCo
.rdata$r:00002EE0                                         ; CMultiStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002EE4                 dd offset ??_R1A@?0A@EA@IInStream@@8 ; IInStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002EE8                 dd offset ??_R1A@?0A@EA@ISequentialInStream@@8 ; ISequentialInStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002EEC                 dd offset ??_R1A@?0A@EA@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002EF0                 dd offset ??_R13?0A@EA@CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Base Class Descriptor at (4,-1,0,64)'
.rdata$r:00002EF4                 db    0
.rdata$r:00002EF5                 align 4
.rdata$r:00002EF5 _rdata$r        ends
.rdata$r:00002EF5
.rdata$r:00002EF8 ; ===========================================================================
.rdata$r:00002EF8
.rdata$r:00002EF8 ; Segment type: Pure data
.rdata$r:00002EF8 ; Segment permissions: Read
.rdata$r:00002EF8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002EF8                 assume cs:_rdata$r
.rdata$r:00002EF8                 ;org 2EF8h
.rdata$r:00002EF8 ; COMDAT (pick any)
.rdata$r:00002EF8                 public ??_R1A@?0A@EA@CMultiStream@@8
.rdata$r:00002EF8 ; CMultiStream::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002EF8 ??_R1A@?0A@EA@CMultiStream@@8 dd offset ??_R0?AVCMultiStream@@@8
.rdata$r:00002EF8                                         ; DATA XREF: .rdata$r:CMultiStream::`RTTI Base Class Array'o
.rdata$r:00002EF8                                         ; CMultiStream `RTTI Type Descriptor'
.rdata$r:00002EFC                 db    4
.rdata$r:00002EFD                 db    0
.rdata$r:00002EFE                 db    0
.rdata$r:00002EFF                 db    0
.rdata$r:00002F00                 db    0
.rdata$r:00002F01                 db    0
.rdata$r:00002F02                 db    0
.rdata$r:00002F03                 db    0
.rdata$r:00002F04                 db 0FFh
.rdata$r:00002F05                 db 0FFh
.rdata$r:00002F06                 db 0FFh
.rdata$r:00002F07                 db 0FFh
.rdata$r:00002F08                 db    0
.rdata$r:00002F09                 db    0
.rdata$r:00002F0A                 db    0
.rdata$r:00002F0B                 db    0
.rdata$r:00002F0C                 db  40h ; @
.rdata$r:00002F0D                 db    0
.rdata$r:00002F0E                 db    0
.rdata$r:00002F0F                 db    0
.rdata$r:00002F10                 dd offset ??_R3CMultiStream@@8 ; CMultiStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002F10 _rdata$r        ends
.rdata$r:00002F10
.rdata$r:00002F14 ; ===========================================================================
.rdata$r:00002F14
.rdata$r:00002F14 ; Segment type: Pure data
.rdata$r:00002F14 ; Segment permissions: Read
.rdata$r:00002F14 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002F14                 assume cs:_rdata$r
.rdata$r:00002F14                 ;org 2F14h
.rdata$r:00002F14 ; COMDAT (pick any)
.rdata$r:00002F14                 public ??_R1A@?0A@EA@IInStream@@8
.rdata$r:00002F14 ; IInStream::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002F14 ??_R1A@?0A@EA@IInStream@@8 dd offset ??_R0?AUIInStream@@@8
.rdata$r:00002F14                                         ; DATA XREF: .rdata$r:00002EE4o
.rdata$r:00002F14                                         ; .rdata$r:IInStream::`RTTI Base Class Array'o
.rdata$r:00002F14                                         ; IInStream `RTTI Type Descriptor'
.rdata$r:00002F18                 db    2
.rdata$r:00002F19                 db    0
.rdata$r:00002F1A                 db    0
.rdata$r:00002F1B                 db    0
.rdata$r:00002F1C                 db    0
.rdata$r:00002F1D                 db    0
.rdata$r:00002F1E                 db    0
.rdata$r:00002F1F                 db    0
.rdata$r:00002F20                 db 0FFh
.rdata$r:00002F21                 db 0FFh
.rdata$r:00002F22                 db 0FFh
.rdata$r:00002F23                 db 0FFh
.rdata$r:00002F24                 db    0
.rdata$r:00002F25                 db    0
.rdata$r:00002F26                 db    0
.rdata$r:00002F27                 db    0
.rdata$r:00002F28                 db  40h ; @
.rdata$r:00002F29                 db    0
.rdata$r:00002F2A                 db    0
.rdata$r:00002F2B                 db    0
.rdata$r:00002F2C                 dd offset ??_R3IInStream@@8 ; IInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002F2C _rdata$r        ends
.rdata$r:00002F2C
.data:00002F30 ; ===========================================================================
.data:00002F30
.data:00002F30 ; Segment type: Pure data
.data:00002F30 ; Segment permissions: Read/Write
.data:00002F30 _data           segment dword public 'DATA' use32
.data:00002F30                 assume cs:_data
.data:00002F30                 ;org 2F30h
.data:00002F30 ; COMDAT (pick any)
.data:00002F30                 public ??_R0?AUIInStream@@@8
.data:00002F30 ; struct IInStream `RTTI Type Descriptor'
.data:00002F30 ??_R0?AUIInStream@@@8 dd offset ??_7type_info@@6B@
.data:00002F30                                         ; DATA XREF: .rdata$r:IInStream::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:00002F30                                         ; .rdata$r:0000316Co
.data:00002F30                                         ; const type_info::`vftable'
.data:00002F34                 align 8
.data:00002F38 a_?auiinstream@ db '.?AUIInStream@@',0
.data:00002F38 _data           ends
.data:00002F38
.rdata$r:00002F48 ; ===========================================================================
.rdata$r:00002F48
.rdata$r:00002F48 ; Segment type: Pure data
.rdata$r:00002F48 ; Segment permissions: Read
.rdata$r:00002F48 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002F48                 assume cs:_rdata$r
.rdata$r:00002F48                 ;org 2F48h
.rdata$r:00002F48 ; COMDAT (pick any)
.rdata$r:00002F48                 public ??_R3IInStream@@8
.rdata$r:00002F48 ; IInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002F48 ??_R3IInStream@@8 db    0               ; DATA XREF: .rdata$r:00002F2Co
.rdata$r:00002F48                                         ; .rdata$r:00003170o
.rdata$r:00002F49                 db    0
.rdata$r:00002F4A                 db    0
.rdata$r:00002F4B                 db    0
.rdata$r:00002F4C                 db    0
.rdata$r:00002F4D                 db    0
.rdata$r:00002F4E                 db    0
.rdata$r:00002F4F                 db    0
.rdata$r:00002F50                 db    3
.rdata$r:00002F51                 db    0
.rdata$r:00002F52                 db    0
.rdata$r:00002F53                 db    0
.rdata$r:00002F54                 dd offset ??_R2IInStream@@8 ; IInStream::`RTTI Base Class Array'
.rdata$r:00002F54 _rdata$r        ends
.rdata$r:00002F54
.rdata$r:00002F58 ; ===========================================================================
.rdata$r:00002F58
.rdata$r:00002F58 ; Segment type: Pure data
.rdata$r:00002F58 ; Segment permissions: Read
.rdata$r:00002F58 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002F58                 assume cs:_rdata$r
.rdata$r:00002F58                 ;org 2F58h
.rdata$r:00002F58 ; COMDAT (pick any)
.rdata$r:00002F58                 public ??_R2IInStream@@8
.rdata$r:00002F58 ; IInStream::`RTTI Base Class Array'
.rdata$r:00002F58 ??_R2IInStream@@8 dd offset ??_R1A@?0A@EA@IInStream@@8
.rdata$r:00002F58                                         ; DATA XREF: .rdata$r:00002F54o
.rdata$r:00002F58                                         ; IInStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002F5C                 dd offset ??_R1A@?0A@EA@ISequentialInStream@@8 ; ISequentialInStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002F60                 dd offset ??_R1A@?0A@EA@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002F64                 db    0
.rdata$r:00002F65                 align 4
.rdata$r:00002F65 _rdata$r        ends
.rdata$r:00002F65
.rdata$r:00002F68 ; ===========================================================================
.rdata$r:00002F68
.rdata$r:00002F68 ; Segment type: Pure data
.rdata$r:00002F68 ; Segment permissions: Read
.rdata$r:00002F68 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002F68                 assume cs:_rdata$r
.rdata$r:00002F68                 ;org 2F68h
.rdata$r:00002F68 ; COMDAT (pick any)
.rdata$r:00002F68                 public ??_R13?0A@EA@CMyUnknownImp@@8
.rdata$r:00002F68 ; CMyUnknownImp::`RTTI Base Class Descriptor at (4, -1, 0, 64)'
.rdata$r:00002F68 ??_R13?0A@EA@CMyUnknownImp@@8 dd offset ??_R0?AVCMyUnknownImp@@@8
.rdata$r:00002F68                                         ; DATA XREF: .rdata$r:00002EF0o
.rdata$r:00002F68                                         ; CMyUnknownImp `RTTI Type Descriptor'
.rdata$r:00002F6C                 align 10h
.rdata$r:00002F70                 db    4
.rdata$r:00002F71                 db    0
.rdata$r:00002F72                 db    0
.rdata$r:00002F73                 db    0
.rdata$r:00002F74                 db 0FFh
.rdata$r:00002F75                 db 0FFh
.rdata$r:00002F76                 db 0FFh
.rdata$r:00002F77                 db 0FFh
.rdata$r:00002F78                 db    0
.rdata$r:00002F79                 db    0
.rdata$r:00002F7A                 db    0
.rdata$r:00002F7B                 db    0
.rdata$r:00002F7C                 db  40h ; @
.rdata$r:00002F7D                 db    0
.rdata$r:00002F7E                 db    0
.rdata$r:00002F7F                 db    0
.rdata$r:00002F80                 dd offset ??_R3CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002F80 _rdata$r        ends
.rdata$r:00002F80
.text:00002F84 ; ===========================================================================
.text:00002F84
.text:00002F84 ; Segment type: Pure code
.text:00002F84 ; Segment permissions: Read/Execute
.text:00002F84 _text           segment para public 'CODE' use32
.text:00002F84                 assume cs:_text
.text:00002F84                 ;org 2F84h
.text:00002F84 ; COMDAT (pick any)
.text:00002F84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002F84
.text:00002F84 ; =============== S U B R O U T I N E =======================================
.text:00002F84
.text:00002F84 ; Attributes: bp-based frame
.text:00002F84
.text:00002F84 ; __int32 __stdcall CMultiStream::QueryInterface(CMultiStream *this, const struct _GUID *Buf1, void **)
.text:00002F84                 public ?QueryInterface@CMultiStream@@UAGJABU_GUID@@PAPAX@Z
.text:00002F84 ?QueryInterface@CMultiStream@@UAGJABU_GUID@@PAPAX@Z proc near
.text:00002F84                                         ; DATA XREF: .rdata:const CMultiStream::`vftable'o
.text:00002F84
.text:00002F84 this            = dword ptr  8
.text:00002F84 Buf1            = dword ptr  0Ch
.text:00002F84 arg_8           = dword ptr  10h
.text:00002F84
.text:00002F84                 push    ebp
.text:00002F85                 mov     ebp, esp
.text:00002F87                 mov     eax, [ebp+arg_8]
.text:00002F8A                 mov     dword ptr [eax], 0
.text:00002F90                 push    offset _IID_IUnknown ; Buf2
.text:00002F95                 mov     ecx, [ebp+Buf1]
.text:00002F98                 push    ecx             ; Buf1
.text:00002F99                 call    ___@8           ; __(x,x)
.text:00002F9E                 test    eax, eax
.text:00002FA0                 jz      short loc_2FAC
.text:00002FA2                 mov     edx, [ebp+arg_8]
.text:00002FA5                 mov     eax, [ebp+this]
.text:00002FA8                 mov     [edx], eax
.text:00002FAA                 jmp     short loc_2FCF
.text:00002FAC ; ---------------------------------------------------------------------------
.text:00002FAC
.text:00002FAC loc_2FAC:                               ; CODE XREF: CMultiStream::QueryInterface(_GUID const &,void * *)+1Cj
.text:00002FAC                 push    offset _IID_IInStream ; Buf2
.text:00002FB1                 mov     ecx, [ebp+Buf1]
.text:00002FB4                 push    ecx             ; Buf1
.text:00002FB5                 call    ___@8           ; __(x,x)
.text:00002FBA                 test    eax, eax
.text:00002FBC                 jz      short loc_2FC8
.text:00002FBE                 mov     edx, [ebp+arg_8]
.text:00002FC1                 mov     eax, [ebp+this]
.text:00002FC4                 mov     [edx], eax
.text:00002FC6                 jmp     short loc_2FCF
.text:00002FC8 ; ---------------------------------------------------------------------------
.text:00002FC8
.text:00002FC8 loc_2FC8:                               ; CODE XREF: CMultiStream::QueryInterface(_GUID const &,void * *)+38j
.text:00002FC8                 mov     eax, 80004002h
.text:00002FCD                 jmp     short loc_2FE0
.text:00002FCF ; ---------------------------------------------------------------------------
.text:00002FCF
.text:00002FCF loc_2FCF:                               ; CODE XREF: CMultiStream::QueryInterface(_GUID const &,void * *)+26j
.text:00002FCF                                         ; CMultiStream::QueryInterface(_GUID const &,void * *)+42j
.text:00002FCF                 mov     ecx, [ebp+this]
.text:00002FD2                 mov     edx, [ecx+4]
.text:00002FD5                 add     edx, 1
.text:00002FD8                 mov     eax, [ebp+this]
.text:00002FDB                 mov     [eax+4], edx
.text:00002FDE                 xor     eax, eax
.text:00002FE0
.text:00002FE0 loc_2FE0:                               ; CODE XREF: CMultiStream::QueryInterface(_GUID const &,void * *)+49j
.text:00002FE0                 cmp     ebp, esp
.text:00002FE2                 call    __RTC_CheckEsp
.text:00002FE7                 pop     ebp
.text:00002FE8                 retn    0Ch
.text:00002FE8 ?QueryInterface@CMultiStream@@UAGJABU_GUID@@PAPAX@Z endp
.text:00002FE8
.text:00002FE8 ; ---------------------------------------------------------------------------
.text:00002FEB                 align 4
.text:00002FEB _text           ends
.text:00002FEB
.text:00002FEC ; ===========================================================================
.text:00002FEC
.text:00002FEC ; Segment type: Pure code
.text:00002FEC ; Segment permissions: Read/Execute
.text:00002FEC _text           segment para public 'CODE' use32
.text:00002FEC                 assume cs:_text
.text:00002FEC                 ;org 2FECh
.text:00002FEC ; COMDAT (pick any)
.text:00002FEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002FEC
.text:00002FEC ; =============== S U B R O U T I N E =======================================
.text:00002FEC
.text:00002FEC ; Attributes: bp-based frame
.text:00002FEC
.text:00002FEC ; unsigned __int32 __stdcall CMultiStream::AddRef(CMultiStream *this)
.text:00002FEC                 public ?AddRef@CMultiStream@@UAGKXZ
.text:00002FEC ?AddRef@CMultiStream@@UAGKXZ proc near  ; DATA XREF: .rdata:00002E90o
.text:00002FEC
.text:00002FEC var_4           = dword ptr -4
.text:00002FEC this            = dword ptr  8
.text:00002FEC
.text:00002FEC                 push    ebp
.text:00002FED                 mov     ebp, esp
.text:00002FEF                 push    ecx
.text:00002FF0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002FF7                 mov     eax, [ebp+this]
.text:00002FFA                 mov     ecx, [eax+4]
.text:00002FFD                 add     ecx, 1
.text:00003000                 mov     [ebp+var_4], ecx
.text:00003003                 mov     edx, [ebp+this]
.text:00003006                 mov     eax, [ebp+var_4]
.text:00003009                 mov     [edx+4], eax
.text:0000300C                 mov     eax, [ebp+var_4]
.text:0000300F                 mov     esp, ebp
.text:00003011                 pop     ebp
.text:00003012                 retn    4
.text:00003012 ?AddRef@CMultiStream@@UAGKXZ endp
.text:00003012
.text:00003012 ; ---------------------------------------------------------------------------
.text:00003015                 align 4
.text:00003015 _text           ends
.text:00003015
.text:00003018 ; ===========================================================================
.text:00003018
.text:00003018 ; Segment type: Pure code
.text:00003018 ; Segment permissions: Read/Execute
.text:00003018 _text           segment para public 'CODE' use32
.text:00003018                 assume cs:_text
.text:00003018                 ;org 3018h
.text:00003018 ; COMDAT (pick any)
.text:00003018                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003018
.text:00003018 ; =============== S U B R O U T I N E =======================================
.text:00003018
.text:00003018 ; Attributes: bp-based frame
.text:00003018
.text:00003018 ; unsigned __int32 __stdcall CMultiStream::Release(CMultiStream *this)
.text:00003018                 public ?Release@CMultiStream@@UAGKXZ
.text:00003018 ?Release@CMultiStream@@UAGKXZ proc near ; DATA XREF: .rdata:00002E94o
.text:00003018
.text:00003018 var_10          = dword ptr -10h
.text:00003018 var_C           = dword ptr -0Ch
.text:00003018 var_8           = dword ptr -8
.text:00003018 var_4           = dword ptr -4
.text:00003018 this            = dword ptr  8
.text:00003018
.text:00003018                 push    ebp
.text:00003019                 mov     ebp, esp
.text:0000301B                 sub     esp, 10h
.text:0000301E                 mov     eax, 0CCCCCCCCh
.text:00003023                 mov     [ebp+var_10], eax
.text:00003026                 mov     [ebp+var_C], eax
.text:00003029                 mov     [ebp+var_8], eax
.text:0000302C                 mov     [ebp+var_4], eax
.text:0000302F                 mov     eax, [ebp+this]
.text:00003032                 mov     ecx, [eax+4]
.text:00003035                 sub     ecx, 1
.text:00003038                 mov     [ebp+var_C], ecx
.text:0000303B                 mov     edx, [ebp+this]
.text:0000303E                 mov     eax, [ebp+var_C]
.text:00003041                 mov     [edx+4], eax
.text:00003044                 cmp     [ebp+var_C], 0
.text:00003048                 jz      short loc_3052
.text:0000304A                 mov     ecx, [ebp+this]
.text:0000304D                 mov     eax, [ecx+4]
.text:00003050                 jmp     short loc_307C
.text:00003052 ; ---------------------------------------------------------------------------
.text:00003052
.text:00003052 loc_3052:                               ; CODE XREF: CMultiStream::Release(void)+30j
.text:00003052                 mov     edx, [ebp+this]
.text:00003055                 mov     [ebp+var_8], edx
.text:00003058                 mov     eax, [ebp+var_8]
.text:0000305B                 mov     [ebp+var_4], eax
.text:0000305E                 cmp     [ebp+var_4], 0
.text:00003062                 jz      short loc_3073
.text:00003064                 push    1
.text:00003066                 mov     ecx, [ebp+var_4]
.text:00003069                 call    ??_GCMultiStream@@QAEPAXI@Z ; CMultiStream::`scalar deleting destructor'(uint)
.text:0000306E                 mov     [ebp+var_10], eax
.text:00003071                 jmp     short loc_307A
.text:00003073 ; ---------------------------------------------------------------------------
.text:00003073
.text:00003073 loc_3073:                               ; CODE XREF: CMultiStream::Release(void)+4Aj
.text:00003073                 mov     [ebp+var_10], 0
.text:0000307A
.text:0000307A loc_307A:                               ; CODE XREF: CMultiStream::Release(void)+59j
.text:0000307A                 xor     eax, eax
.text:0000307C
.text:0000307C loc_307C:                               ; CODE XREF: CMultiStream::Release(void)+38j
.text:0000307C                 add     esp, 10h
.text:0000307F                 cmp     ebp, esp
.text:00003081                 call    __RTC_CheckEsp
.text:00003086                 mov     esp, ebp
.text:00003088                 pop     ebp
.text:00003089                 retn    4
.text:00003089 ?Release@CMultiStream@@UAGKXZ endp
.text:00003089
.text:00003089 _text           ends
.text:00003089
.text:0000308C ; ===========================================================================
.text:0000308C
.text:0000308C ; Segment type: Pure code
.text:0000308C ; Segment permissions: Read/Execute
.text:0000308C _text           segment para public 'CODE' use32
.text:0000308C                 assume cs:_text
.text:0000308C                 ;org 308Ch
.text:0000308C ; COMDAT (pick any)
.text:0000308C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000308C
.text:0000308C ; =============== S U B R O U T I N E =======================================
.text:0000308C
.text:0000308C ; Attributes: bp-based frame
.text:0000308C
.text:0000308C ; public: void * __thiscall CMultiStream::`scalar deleting destructor'(unsigned int)
.text:0000308C                 public ??_GCMultiStream@@QAEPAXI@Z
.text:0000308C ??_GCMultiStream@@QAEPAXI@Z proc near   ; CODE XREF: CMultiStream::Release(void)+51p
.text:0000308C
.text:0000308C var_4           = dword ptr -4
.text:0000308C arg_0           = dword ptr  8
.text:0000308C
.text:0000308C                 push    ebp
.text:0000308D                 mov     ebp, esp
.text:0000308F                 push    ecx
.text:00003090                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003097                 mov     [ebp+var_4], ecx
.text:0000309A                 mov     ecx, [ebp+var_4] ; this
.text:0000309D                 call    ??1CMultiStream@@QAE@XZ ; CMultiStream::~CMultiStream(void)
.text:000030A2                 mov     eax, [ebp+arg_0]
.text:000030A5                 and     eax, 1
.text:000030A8                 jz      short loc_30B6
.text:000030AA                 mov     ecx, [ebp+var_4]
.text:000030AD                 push    ecx             ; void *
.text:000030AE                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:000030B3                 add     esp, 4
.text:000030B6
.text:000030B6 loc_30B6:                               ; CODE XREF: CMultiStream::`scalar deleting destructor'(uint)+1Cj
.text:000030B6                 mov     eax, [ebp+var_4]
.text:000030B9                 add     esp, 4
.text:000030BC                 cmp     ebp, esp
.text:000030BE                 call    __RTC_CheckEsp
.text:000030C3                 mov     esp, ebp
.text:000030C5                 pop     ebp
.text:000030C6                 retn    4
.text:000030C6 ??_GCMultiStream@@QAEPAXI@Z endp
.text:000030C6
.text:000030C6 ; ---------------------------------------------------------------------------
.text:000030C9                 align 4
.text:000030C9 _text           ends
.text:000030C9
.text:000030CC ; ===========================================================================
.text:000030CC
.text:000030CC ; Segment type: Pure code
.text:000030CC ; Segment permissions: Read/Execute
.text:000030CC _text           segment para public 'CODE' use32
.text:000030CC                 assume cs:_text
.text:000030CC                 ;org 30CCh
.text:000030CC ; COMDAT (pick any)
.text:000030CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000030CC
.text:000030CC ; =============== S U B R O U T I N E =======================================
.text:000030CC
.text:000030CC ; Attributes: bp-based frame
.text:000030CC
.text:000030CC ; _DWORD __thiscall CMultiStream::~CMultiStream(CMultiStream *__hidden this)
.text:000030CC                 public ??1CMultiStream@@QAE@XZ
.text:000030CC ??1CMultiStream@@QAE@XZ proc near       ; CODE XREF: CMultiStream::`scalar deleting destructor'(uint)+11p
.text:000030CC
.text:000030CC var_4           = dword ptr -4
.text:000030CC
.text:000030CC                 push    ebp
.text:000030CD                 mov     ebp, esp
.text:000030CF                 push    ecx
.text:000030D0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000030D7                 mov     [ebp+var_4], ecx
.text:000030DA                 mov     ecx, [ebp+var_4]
.text:000030DD                 add     ecx, 1Ch
.text:000030E0                 call    ??1?$CObjectVector@UCSubStreamInfo@CMultiStream@@@@QAE@XZ ; CObjectVector<CMultiStream::CSubStreamInfo>::~CObjectVector<CMultiStream::CSubStreamInfo>(void)
.text:000030E5                 add     esp, 4
.text:000030E8                 cmp     ebp, esp
.text:000030EA                 call    __RTC_CheckEsp
.text:000030EF                 mov     esp, ebp
.text:000030F1                 pop     ebp
.text:000030F2                 retn
.text:000030F2 ??1CMultiStream@@QAE@XZ endp
.text:000030F2
.text:000030F2 ; ---------------------------------------------------------------------------
.text:000030F3                 align 4
.text:000030F3 _text           ends
.text:000030F3
.text:000030F4 ; ===========================================================================
.text:000030F4
.text:000030F4 ; Segment type: Pure code
.text:000030F4 ; Segment permissions: Read/Execute
.text:000030F4 _text           segment para public 'CODE' use32
.text:000030F4                 assume cs:_text
.text:000030F4                 ;org 30F4h
.text:000030F4 ; COMDAT (pick any)
.text:000030F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000030F4
.text:000030F4 ; =============== S U B R O U T I N E =======================================
.text:000030F4
.text:000030F4 ; Attributes: bp-based frame
.text:000030F4
.text:000030F4 ; _DWORD __thiscall CMultiStream::CSubStreamInfo::~CSubStreamInfo(CMultiStream::CSubStreamInfo *__hidden this)
.text:000030F4                 public ??1CSubStreamInfo@CMultiStream@@QAE@XZ
.text:000030F4 ??1CSubStreamInfo@CMultiStream@@QAE@XZ proc near
.text:000030F4                                         ; CODE XREF: NArchive::NSplit::CHandler::GetStream(uint,ISequentialInStream * *)+13Dp
.text:000030F4                                         ; __unwindfunclet$?GetStream@CHandler@NSplit@NArchive@@UAGJIPAPAUISequentialInStream@@@Z$4+3j ...
.text:000030F4
.text:000030F4 var_4           = dword ptr -4
.text:000030F4
.text:000030F4                 push    ebp
.text:000030F5                 mov     ebp, esp
.text:000030F7                 push    ecx
.text:000030F8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000030FF                 mov     [ebp+var_4], ecx
.text:00003102                 mov     ecx, [ebp+var_4]
.text:00003105                 call    ??1?$CMyComPtr@UIInStream@@@@QAE@XZ ; CMyComPtr<IInStream>::~CMyComPtr<IInStream>(void)
.text:0000310A                 add     esp, 4
.text:0000310D                 cmp     ebp, esp
.text:0000310F                 call    __RTC_CheckEsp
.text:00003114                 mov     esp, ebp
.text:00003116                 pop     ebp
.text:00003117                 retn
.text:00003117 ??1CSubStreamInfo@CMultiStream@@QAE@XZ endp
.text:00003117
.text:00003117 _text           ends
.text:00003117
.text:00003118 ; ===========================================================================
.text:00003118
.text:00003118 ; Segment type: Pure code
.text:00003118 ; Segment permissions: Read/Execute
.text:00003118 _text           segment para public 'CODE' use32
.text:00003118                 assume cs:_text
.text:00003118                 ;org 3118h
.text:00003118 ; COMDAT (pick any)
.text:00003118                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003118
.text:00003118 ; =============== S U B R O U T I N E =======================================
.text:00003118
.text:00003118 ; Attributes: bp-based frame
.text:00003118
.text:00003118 ; _DWORD __thiscall IInStream::IInStream(IInStream *__hidden this)
.text:00003118                 public ??0IInStream@@QAE@XZ
.text:00003118 ??0IInStream@@QAE@XZ proc near          ; CODE XREF: CMultiStream::CMultiStream(void)+11p
.text:00003118
.text:00003118 var_4           = dword ptr -4
.text:00003118
.text:00003118                 push    ebp
.text:00003119                 mov     ebp, esp
.text:0000311B                 push    ecx
.text:0000311C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003123                 mov     [ebp+var_4], ecx
.text:00003126                 mov     ecx, [ebp+var_4] ; this
.text:00003129                 call    ??0ISequentialInStream@@QAE@XZ ; ISequentialInStream::ISequentialInStream(void)
.text:0000312E
.text:0000312E loc_312E:                               ; DATA XREF: .rdata:$SG69246o
.text:0000312E                 mov     eax, [ebp+var_4]
.text:00003131                 mov     dword ptr [eax], offset ??_7IInStream@@6B@ ; const IInStream::`vftable'
.text:00003137                 mov     eax, [ebp+var_4]
.text:0000313A                 add     esp, 4
.text:0000313D                 cmp     ebp, esp
.text:0000313F                 call    __RTC_CheckEsp
.text:00003144                 mov     esp, ebp
.text:00003146                 pop     ebp
.text:00003147                 retn
.text:00003147 ??0IInStream@@QAE@XZ endp
.text:00003147
.text:00003147 _text           ends
.text:00003147
.rdata:00003148 ; ===========================================================================
.rdata:00003148
.rdata:00003148 ; Segment type: Pure data
.rdata:00003148 ; Segment permissions: Read
.rdata:00003148 _rdata          segment dword public 'DATA' use32
.rdata:00003148                 assume cs:_rdata
.rdata:00003148                 ;org 3148h
.rdata:00003148 ; COMDAT (pick largest)
.rdata:00003148                 dd offset ??_R4IInStream@@6B@ ; const IInStream::`RTTI Complete Object Locator'
.rdata:0000314C                 public ??_7IInStream@@6B@
.rdata:0000314C ; const IInStream::`vftable'
.rdata:0000314C ??_7IInStream@@6B@ dd offset __purecall ; DATA XREF: IInStream::IInStream(void)+19o
.rdata:00003150                 dd offset __purecall
.rdata:00003154                 dd offset __purecall
.rdata:00003158                 dd offset __purecall
.rdata:0000315C                 dd offset __purecall
.rdata:0000315C _rdata          ends
.rdata:0000315C
.rdata$r:00003160 ; ===========================================================================
.rdata$r:00003160
.rdata$r:00003160 ; Segment type: Pure data
.rdata$r:00003160 ; Segment permissions: Read
.rdata$r:00003160 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003160                 assume cs:_rdata$r
.rdata$r:00003160                 ;org 3160h
.rdata$r:00003160 ; COMDAT (pick any)
.rdata$r:00003160                 public ??_R4IInStream@@6B@
.rdata$r:00003160 ; const IInStream::`RTTI Complete Object Locator'
.rdata$r:00003160 ??_R4IInStream@@6B@ db    0             ; DATA XREF: .rdata:00003148o
.rdata$r:00003161                 db    0
.rdata$r:00003162                 db    0
.rdata$r:00003163                 db    0
.rdata$r:00003164                 db    0
.rdata$r:00003165                 db    0
.rdata$r:00003166                 db    0
.rdata$r:00003167                 db    0
.rdata$r:00003168                 db    0
.rdata$r:00003169                 db    0
.rdata$r:0000316A                 db    0
.rdata$r:0000316B                 db    0
.rdata$r:0000316C                 dd offset ??_R0?AUIInStream@@@8 ; IInStream `RTTI Type Descriptor'
.rdata$r:00003170                 dd offset ??_R3IInStream@@8 ; IInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003170 _rdata$r        ends
.rdata$r:00003170
.text:00003174 ; ===========================================================================
.text:00003174
.text:00003174 ; Segment type: Pure code
.text:00003174 ; Segment permissions: Read/Execute
.text:00003174 _text           segment para public 'CODE' use32
.text:00003174                 assume cs:_text
.text:00003174                 ;org 3174h
.text:00003174 ; COMDAT (pick any)
.text:00003174                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003174
.text:00003174 ; =============== S U B R O U T I N E =======================================
.text:00003174
.text:00003174 ; Attributes: bp-based frame
.text:00003174
.text:00003174 ; _DWORD __thiscall NArchive::NSplit::CHandler::CHandler(NArchive::NSplit::CHandler *__hidden this)
.text:00003174                 public ??0CHandler@NSplit@NArchive@@QAE@XZ
.text:00003174 ??0CHandler@NSplit@NArchive@@QAE@XZ proc near
.text:00003174                                         ; CODE XREF: NArchive::NSplit::CreateArc(void)+57p
.text:00003174
.text:00003174 var_10          = dword ptr -10h
.text:00003174 var_C           = dword ptr -0Ch
.text:00003174 var_4           = dword ptr -4
.text:00003174
.text:00003174                 push    ebp
.text:00003175                 mov     ebp, esp
.text:00003177                 push    0FFFFFFFFh
.text:00003179                 push    offset __ehhandler$??0CHandler@NSplit@NArchive@@QAE@XZ
.text:0000317E                 mov     eax, large fs:0
.text:00003184                 push    eax
.text:00003185                 push    ecx
.text:00003186                 mov     [ebp+var_10], 0CCCCCCCCh
.text:0000318D                 mov     eax, dword ptr ds:___security_cookie
.text:00003192                 xor     eax, ebp
.text:00003194                 push    eax
.text:00003195                 lea     eax, [ebp+var_C]
.text:00003198                 mov     large fs:0, eax
.text:0000319E                 mov     [ebp+var_10], ecx
.text:000031A1                 mov     ecx, [ebp+var_10] ; this
.text:000031A4                 call    ??0IInArchive@@QAE@XZ ; IInArchive::IInArchive(void)
.text:000031A9                 mov     ecx, [ebp+var_10]
.text:000031AC                 add     ecx, 4          ; this
.text:000031AF                 call    ??0IInArchiveGetStream@@QAE@XZ ; IInArchiveGetStream::IInArchiveGetStream(void)
.text:000031B4                 mov     ecx, [ebp+var_10]
.text:000031B7                 add     ecx, 8          ; this
.text:000031BA                 call    ??0CMyUnknownImp@@QAE@XZ ; CMyUnknownImp::CMyUnknownImp(void)
.text:000031BF                 mov     eax, [ebp+var_10]
.text:000031C2                 mov     dword ptr [eax], offset ??_7CHandler@NSplit@NArchive@@6BIInArchive@@@ ; const NArchive::NSplit::CHandler::`vftable'{for `IInArchive'}
.text:000031C8                 mov     ecx, [ebp+var_10]
.text:000031CB                 mov     dword ptr [ecx+4], offset ??_7CHandler@NSplit@NArchive@@6BIInArchiveGetStream@@@ ; const NArchive::NSplit::CHandler::`vftable'{for `IInArchiveGetStream'}
.text:000031D2                 mov     ecx, [ebp+var_10]
.text:000031D5                 add     ecx, 0Ch
.text:000031D8                 call    ??0?$CObjectVector@V?$CMyComPtr@UIInStream@@@@@@QAE@XZ ; CObjectVector<CMyComPtr<IInStream>>::CObjectVector<CMyComPtr<IInStream>>(void)
.text:000031DD                 mov     [ebp+var_4], 0
.text:000031E4                 mov     ecx, [ebp+var_10]
.text:000031E7                 add     ecx, 18h
.text:000031EA                 call    ??0?$CRecordVector@_K@@QAE@XZ ; CRecordVector<unsigned __int64>::CRecordVector<unsigned __int64>(void)
.text:000031EF                 mov     byte ptr [ebp+var_4], 1
.text:000031F3                 mov     ecx, [ebp+var_10]
.text:000031F6                 add     ecx, 24h ; '$'
.text:000031F9                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:000031FE                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00003205                 mov     eax, [ebp+var_10]
.text:00003208                 mov     ecx, [ebp+var_C]
.text:0000320B                 mov     large fs:0, ecx
.text:00003212                 pop     ecx
.text:00003213                 add     esp, 10h
.text:00003216                 cmp     ebp, esp
.text:00003218                 call    __RTC_CheckEsp
.text:0000321D                 mov     esp, ebp
.text:0000321F                 pop     ebp
.text:00003220                 retn
.text:00003220 ??0CHandler@NSplit@NArchive@@QAE@XZ endp
.text:00003220
.text:00003220 ; ---------------------------------------------------------------------------
.text:00003221                 align 4
.text:00003221 _text           ends
.text:00003221
.text$x:00003224 ; ===========================================================================
.text$x:00003224
.text$x:00003224 ; Segment type: Pure code
.text$x:00003224 ; Segment permissions: Read/Execute
.text$x:00003224 _text$x         segment para public 'CODE' use32
.text$x:00003224                 assume cs:_text$x
.text$x:00003224                 ;org 3224h
.text$x:00003224 ; COMDAT (pick associative to section at 3174)
.text$x:00003224                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003224
.text$x:00003224 ; =============== S U B R O U T I N E =======================================
.text$x:00003224
.text$x:00003224
.text$x:00003224 __unwindfunclet$??0CHandler@NSplit@NArchive@@QAE@XZ$0 proc near
.text$x:00003224                                         ; DATA XREF: .xdata$x:000032A8o
.text$x:00003224                 mov     ecx, [ebp-10h]
.text$x:00003227                 add     ecx, 0Ch
.text$x:0000322A                 jmp     ??1?$CObjectVector@V?$CMyComPtr@UIInStream@@@@@@QAE@XZ ; CObjectVector<CMyComPtr<IInStream>>::~CObjectVector<CMyComPtr<IInStream>>(void)
.text$x:0000322A __unwindfunclet$??0CHandler@NSplit@NArchive@@QAE@XZ$0 endp
.text$x:0000322A
.text$x:0000322F
.text$x:0000322F ; =============== S U B R O U T I N E =======================================
.text$x:0000322F
.text$x:0000322F
.text$x:0000322F __unwindfunclet$??0CHandler@NSplit@NArchive@@QAE@XZ$1 proc near
.text$x:0000322F                                         ; DATA XREF: .xdata$x:000032B0o
.text$x:0000322F                 mov     ecx, [ebp-10h]
.text$x:00003232                 add     ecx, 18h
.text$x:00003235                 jmp     ??1?$CRecordVector@_K@@QAE@XZ ; CRecordVector<unsigned __int64>::~CRecordVector<unsigned __int64>(void)
.text$x:00003235 __unwindfunclet$??0CHandler@NSplit@NArchive@@QAE@XZ$1 endp
.text$x:00003235
.text$x:0000323A
.text$x:0000323A ; =============== S U B R O U T I N E =======================================
.text$x:0000323A
.text$x:0000323A
.text$x:0000323A __ehhandler$??0CHandler@NSplit@NArchive@@QAE@XZ proc near
.text$x:0000323A                                         ; DATA XREF: NArchive::NSplit::CHandler::CHandler(void)+5o
.text$x:0000323A
.text$x:0000323A arg_4           = dword ptr  8
.text$x:0000323A
.text$x:0000323A                 mov     edx, [esp+arg_4]
.text$x:0000323E                 lea     eax, [edx+0Ch]
.text$x:00003241                 mov     ecx, [edx-8]
.text$x:00003244                 xor     ecx, eax
.text$x:00003246                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000324B                 mov     eax, offset __ehfuncinfo$??0CHandler@NSplit@NArchive@@QAE@XZ
.text$x:00003250                 jmp     ___CxxFrameHandler3
.text$x:00003250 __ehhandler$??0CHandler@NSplit@NArchive@@QAE@XZ endp
.text$x:00003250
.text$x:00003250 ; ---------------------------------------------------------------------------
.text$x:00003255                 align 4
.text$x:00003255 _text$x         ends
.text$x:00003255
.rdata:00003258 ; ===========================================================================
.rdata:00003258
.rdata:00003258 ; Segment type: Pure data
.rdata:00003258 ; Segment permissions: Read
.rdata:00003258 _rdata          segment dword public 'DATA' use32
.rdata:00003258                 assume cs:_rdata
.rdata:00003258                 ;org 3258h
.rdata:00003258 ; COMDAT (pick largest)
.rdata:00003258                 dd offset ??_R4CHandler@NSplit@NArchive@@6BIInArchiveGetStream@@@ ; const NArchive::NSplit::CHandler::`RTTI Complete Object Locator'{for `IInArchiveGetStream'}
.rdata:0000325C                 public ??_7CHandler@NSplit@NArchive@@6BIInArchiveGetStream@@@
.rdata:0000325C ; const NArchive::NSplit::CHandler::`vftable'{for `IInArchiveGetStream'}
.rdata:0000325C ??_7CHandler@NSplit@NArchive@@6BIInArchiveGetStream@@@ dd offset ?QueryInterface@CHandler@NSplit@NArchive@@W3AGJABU_GUID@@PAPAX@Z
.rdata:0000325C                                         ; DATA XREF: NArchive::NSplit::CHandler::CHandler(void)+57o
.rdata:0000325C                                         ; [thunk]:NArchive::NSplit::CHandler::QueryInterface`adjustor{4}' (_GUID const &,void * *)
.rdata:00003260                 dd offset ?AddRef@CHandler@NSplit@NArchive@@W3AGKXZ ; [thunk]:NArchive::NSplit::CHandler::AddRef`adjustor{4}' (void)
.rdata:00003264                 dd offset ?Release@CHandler@NSplit@NArchive@@W3AGKXZ ; [thunk]:NArchive::NSplit::CHandler::Release`adjustor{4}' (void)
.rdata:00003268                 dd offset ?GetStream@CHandler@NSplit@NArchive@@UAGJIPAPAUISequentialInStream@@@Z ; NArchive::NSplit::CHandler::GetStream(uint,ISequentialInStream * *)
.rdata:00003268 _rdata          ends
.rdata:00003268
.rdata:0000326C ; ===========================================================================
.rdata:0000326C
.rdata:0000326C ; Segment type: Pure data
.rdata:0000326C ; Segment permissions: Read
.rdata:0000326C _rdata          segment dword public 'DATA' use32
.rdata:0000326C                 assume cs:_rdata
.rdata:0000326C                 ;org 326Ch
.rdata:0000326C ; COMDAT (pick largest)
.rdata:0000326C                 dd offset ??_R4CHandler@NSplit@NArchive@@6BIInArchive@@@ ; const NArchive::NSplit::CHandler::`RTTI Complete Object Locator'{for `IInArchive'}
.rdata:00003270                 public ??_7CHandler@NSplit@NArchive@@6BIInArchive@@@
.rdata:00003270 ; const NArchive::NSplit::CHandler::`vftable'{for `IInArchive'}
.rdata:00003270 ??_7CHandler@NSplit@NArchive@@6BIInArchive@@@ dd offset ?QueryInterface@CHandler@NSplit@NArchive@@UAGJABU_GUID@@PAPAX@Z
.rdata:00003270                                         ; DATA XREF: NArchive::NSplit::CHandler::CHandler(void)+4Eo
.rdata:00003270                                         ; NArchive::NSplit::CHandler::QueryInterface(_GUID const &,void * *)
.rdata:00003274                 dd offset ?AddRef@CHandler@NSplit@NArchive@@UAGKXZ ; NArchive::NSplit::CHandler::AddRef(void)
.rdata:00003278                 dd offset ?Release@CHandler@NSplit@NArchive@@UAGKXZ ; NArchive::NSplit::CHandler::Release(void)
.rdata:0000327C                 dd offset ?Open@CHandler@NSplit@NArchive@@UAGJPAUIInStream@@PB_KPAUIArchiveOpenCallback@@@Z ; NArchive::NSplit::CHandler::Open(IInStream *,unsigned __int64 const *,IArchiveOpenCallback *)
.rdata:00003280                 dd offset ?Close@CHandler@NSplit@NArchive@@UAGJXZ ; NArchive::NSplit::CHandler::Close(void)
.rdata:00003284                 dd offset ?GetNumberOfItems@CHandler@NSplit@NArchive@@UAGJPAI@Z ; NArchive::NSplit::CHandler::GetNumberOfItems(uint *)
.rdata:00003288                 dd offset ?GetProperty@CHandler@NSplit@NArchive@@UAGJIKPAUtagPROPVARIANT@@@Z ; NArchive::NSplit::CHandler::GetProperty(uint,ulong,tagPROPVARIANT *)
.rdata:0000328C                 dd offset ?Extract@CHandler@NSplit@NArchive@@UAGJPBIIHPAUIArchiveExtractCallback@@@Z ; NArchive::NSplit::CHandler::Extract(uint const *,uint,int,IArchiveExtractCallback *)
.rdata:00003290                 dd offset ?GetArchiveProperty@CHandler@NSplit@NArchive@@UAGJKPAUtagPROPVARIANT@@@Z ; NArchive::NSplit::CHandler::GetArchiveProperty(ulong,tagPROPVARIANT *)
.rdata:00003294                 dd offset ?GetNumberOfProperties@CHandler@NSplit@NArchive@@UAGJPAI@Z ; NArchive::NSplit::CHandler::GetNumberOfProperties(uint *)
.rdata:00003298                 dd offset ?GetPropertyInfo@CHandler@NSplit@NArchive@@UAGJIPAPA_WPAKPAG@Z ; NArchive::NSplit::CHandler::GetPropertyInfo(uint,wchar_t * *,ulong *,ushort *)
.rdata:0000329C                 dd offset ?GetNumberOfArchiveProperties@CHandler@NSplit@NArchive@@UAGJPAI@Z ; NArchive::NSplit::CHandler::GetNumberOfArchiveProperties(uint *)
.rdata:000032A0                 dd offset ?GetArchivePropertyInfo@CHandler@NSplit@NArchive@@UAGJIPAPA_WPAKPAG@Z ; NArchive::NSplit::CHandler::GetArchivePropertyInfo(uint,wchar_t * *,ulong *,ushort *)
.rdata:000032A0 _rdata          ends
.rdata:000032A0
.xdata$x:000032A4 ; ===========================================================================
.xdata$x:000032A4
.xdata$x:000032A4 ; Segment type: Pure data
.xdata$x:000032A4 ; Segment permissions: Read
.xdata$x:000032A4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000032A4                 assume cs:_xdata$x
.xdata$x:000032A4                 ;org 32A4h
.xdata$x:000032A4 ; COMDAT (pick associative to section at 3174)
.xdata$x:000032A4 __unwindtable$??0CHandler@NSplit@NArchive@@QAE@XZ db 0FFh
.xdata$x:000032A4                                         ; DATA XREF: .xdata$x:000032BCo
.xdata$x:000032A5                 db 0FFh
.xdata$x:000032A6                 db 0FFh
.xdata$x:000032A7                 db 0FFh
.xdata$x:000032A8                 dd offset __unwindfunclet$??0CHandler@NSplit@NArchive@@QAE@XZ$0
.xdata$x:000032AC                 align 10h
.xdata$x:000032B0                 dd offset __unwindfunclet$??0CHandler@NSplit@NArchive@@QAE@XZ$1
.xdata$x:000032B4 __ehfuncinfo$??0CHandler@NSplit@NArchive@@QAE@XZ db  22h ; "
.xdata$x:000032B4                                         ; DATA XREF: __ehhandler$??0CHandler@NSplit@NArchive@@QAE@XZ+11o
.xdata$x:000032B5                 db    5
.xdata$x:000032B6                 db  93h ; ô
.xdata$x:000032B7                 db  19h
.xdata$x:000032B8                 db    2
.xdata$x:000032B9                 db    0
.xdata$x:000032BA                 db    0
.xdata$x:000032BB                 db    0
.xdata$x:000032BC                 dd offset __unwindtable$??0CHandler@NSplit@NArchive@@QAE@XZ
.xdata$x:000032C0                 db    0
.xdata$x:000032C1                 db    0
.xdata$x:000032C2                 db    0
.xdata$x:000032C3                 db    0
.xdata$x:000032C4                 db    0
.xdata$x:000032C5                 db    0
.xdata$x:000032C6                 db    0
.xdata$x:000032C7                 db    0
.xdata$x:000032C8                 db    0
.xdata$x:000032C9                 db    0
.xdata$x:000032CA                 db    0
.xdata$x:000032CB                 db    0
.xdata$x:000032CC                 db    0
.xdata$x:000032CD                 db    0
.xdata$x:000032CE                 db    0
.xdata$x:000032CF                 db    0
.xdata$x:000032D0                 db    0
.xdata$x:000032D1                 db    0
.xdata$x:000032D2                 db    0
.xdata$x:000032D3                 db    0
.xdata$x:000032D4                 db    1
.xdata$x:000032D5                 db    0
.xdata$x:000032D6                 db    0
.xdata$x:000032D7                 db    0
.xdata$x:000032D7 _xdata$x        ends
.xdata$x:000032D7
.rdata$r:000032D8 ; ===========================================================================
.rdata$r:000032D8
.rdata$r:000032D8 ; Segment type: Pure data
.rdata$r:000032D8 ; Segment permissions: Read
.rdata$r:000032D8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000032D8                 assume cs:_rdata$r
.rdata$r:000032D8                 ;org 32D8h
.rdata$r:000032D8 ; COMDAT (pick any)
.rdata$r:000032D8                 public ??_R4CHandler@NSplit@NArchive@@6BIInArchive@@@
.rdata$r:000032D8 ; const NArchive::NSplit::CHandler::`RTTI Complete Object Locator'{for `IInArchive'}
.rdata$r:000032D8 ??_R4CHandler@NSplit@NArchive@@6BIInArchive@@@ db    0
.rdata$r:000032D8                                         ; DATA XREF: .rdata:0000326Co
.rdata$r:000032D9                 db    0
.rdata$r:000032DA                 db    0
.rdata$r:000032DB                 db    0
.rdata$r:000032DC                 db    0
.rdata$r:000032DD                 db    0
.rdata$r:000032DE                 db    0
.rdata$r:000032DF                 db    0
.rdata$r:000032E0                 db    0
.rdata$r:000032E1                 db    0
.rdata$r:000032E2                 db    0
.rdata$r:000032E3                 db    0
.rdata$r:000032E4                 dd offset ??_R0?AVCHandler@NSplit@NArchive@@@8 ; NArchive::NSplit::CHandler `RTTI Type Descriptor'
.rdata$r:000032E8                 dd offset ??_R3CHandler@NSplit@NArchive@@8 ; NArchive::NSplit::CHandler::`RTTI Class Hierarchy Descriptor'
.rdata$r:000032E8 _rdata$r        ends
.rdata$r:000032E8
.data:000032EC ; ===========================================================================
.data:000032EC
.data:000032EC ; Segment type: Pure data
.data:000032EC ; Segment permissions: Read/Write
.data:000032EC _data           segment dword public 'DATA' use32
.data:000032EC                 assume cs:_data
.data:000032EC                 ;org 32ECh
.data:000032EC ; COMDAT (pick any)
.data:000032EC                 public ??_R0?AVCHandler@NSplit@NArchive@@@8
.data:000032EC ; class NArchive::NSplit::CHandler `RTTI Type Descriptor'
.data:000032EC ??_R0?AVCHandler@NSplit@NArchive@@@8 dd offset ??_7type_info@@6B@
.data:000032EC                                         ; DATA XREF: .rdata$r:000032E4o
.data:000032EC                                         ; .rdata$r:NArchive::NSplit::CHandler::`RTTI Base Class Descriptor at (0,-1,0,64)'o ...
.data:000032EC                                         ; const type_info::`vftable'
.data:000032F0                 db    0
.data:000032F1                 db    0
.data:000032F2                 db    0
.data:000032F3                 db    0
.data:000032F4                 db  2Eh ; .
.data:000032F5                 db  3Fh ; ?
.data:000032F6                 db  41h ; A
.data:000032F7                 db  56h ; V
.data:000032F8                 db  43h ; C
.data:000032F9                 db  48h ; H
.data:000032FA                 db  61h ; a
.data:000032FB                 db  6Eh ; n
.data:000032FC                 db  64h ; d
.data:000032FD                 db  6Ch ; l
.data:000032FE                 db  65h ; e
.data:000032FF                 db  72h ; r
.data:00003300                 db  40h ; @
.data:00003301                 db  4Eh ; N
.data:00003302                 db  53h ; S
.data:00003303                 db  70h ; p
.data:00003304                 db  6Ch ; l
.data:00003305                 db  69h ; i
.data:00003306                 db  74h ; t
.data:00003307                 db  40h ; @
.data:00003308                 db  4Eh ; N
.data:00003309                 db  41h ; A
.data:0000330A                 db  72h ; r
.data:0000330B                 db  63h ; c
.data:0000330C                 db  68h ; h
.data:0000330D                 db  69h ; i
.data:0000330E                 db  76h ; v
.data:0000330F                 db  65h ; e
.data:00003310                 db  40h ; @
.data:00003311                 db  40h ; @
.data:00003312                 db    0
.data:00003313                 align 4
.data:00003313 _data           ends
.data:00003313
.rdata$r:00003314 ; ===========================================================================
.rdata$r:00003314
.rdata$r:00003314 ; Segment type: Pure data
.rdata$r:00003314 ; Segment permissions: Read
.rdata$r:00003314 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003314                 assume cs:_rdata$r
.rdata$r:00003314                 ;org 3314h
.rdata$r:00003314 ; COMDAT (pick any)
.rdata$r:00003314                 public ??_R3CHandler@NSplit@NArchive@@8
.rdata$r:00003314 ; NArchive::NSplit::CHandler::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003314 ??_R3CHandler@NSplit@NArchive@@8 db    0 ; DATA XREF: .rdata$r:000032E8o
.rdata$r:00003314                                         ; .rdata$r:00003358o ...
.rdata$r:00003315                 db    0
.rdata$r:00003316                 db    0
.rdata$r:00003317                 db    0
.rdata$r:00003318                 db    1
.rdata$r:00003319                 db    0
.rdata$r:0000331A                 db    0
.rdata$r:0000331B                 db    0
.rdata$r:0000331C                 db    6
.rdata$r:0000331D                 db    0
.rdata$r:0000331E                 db    0
.rdata$r:0000331F                 db    0
.rdata$r:00003320                 dd offset ??_R2CHandler@NSplit@NArchive@@8 ; NArchive::NSplit::CHandler::`RTTI Base Class Array'
.rdata$r:00003320 _rdata$r        ends
.rdata$r:00003320
.rdata$r:00003324 ; ===========================================================================
.rdata$r:00003324
.rdata$r:00003324 ; Segment type: Pure data
.rdata$r:00003324 ; Segment permissions: Read
.rdata$r:00003324 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003324                 assume cs:_rdata$r
.rdata$r:00003324                 ;org 3324h
.rdata$r:00003324 ; COMDAT (pick any)
.rdata$r:00003324                 public ??_R2CHandler@NSplit@NArchive@@8
.rdata$r:00003324 ; NArchive::NSplit::CHandler::`RTTI Base Class Array'
.rdata$r:00003324 ??_R2CHandler@NSplit@NArchive@@8 dd offset ??_R1A@?0A@EA@CHandler@NSplit@NArchive@@8
.rdata$r:00003324                                         ; DATA XREF: .rdata$r:00003320o
.rdata$r:00003324                                         ; NArchive::NSplit::CHandler::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003328                 dd offset ??_R1A@?0A@EA@IInArchive@@8 ; IInArchive::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000332C                 dd offset ??_R1A@?0A@EC@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,66)'
.rdata$r:00003330                 dd offset ??_R13?0A@EA@IInArchiveGetStream@@8 ; IInArchiveGetStream::`RTTI Base Class Descriptor at (4,-1,0,64)'
.rdata$r:00003334                 dd offset ??_R13?0A@EC@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (4,-1,0,66)'
.rdata$r:00003338                 dd offset ??_R17?0A@EA@CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Base Class Descriptor at (8,-1,0,64)'
.rdata$r:0000333C                 db    0
.rdata$r:0000333D                 align 10h
.rdata$r:0000333D _rdata$r        ends
.rdata$r:0000333D
.rdata$r:00003340 ; ===========================================================================
.rdata$r:00003340
.rdata$r:00003340 ; Segment type: Pure data
.rdata$r:00003340 ; Segment permissions: Read
.rdata$r:00003340 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003340                 assume cs:_rdata$r
.rdata$r:00003340                 ;org 3340h
.rdata$r:00003340 ; COMDAT (pick any)
.rdata$r:00003340                 public ??_R1A@?0A@EA@CHandler@NSplit@NArchive@@8
.rdata$r:00003340 ; NArchive::NSplit::CHandler::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00003340 ??_R1A@?0A@EA@CHandler@NSplit@NArchive@@8 dd offset ??_R0?AVCHandler@NSplit@NArchive@@@8
.rdata$r:00003340                                         ; DATA XREF: .rdata$r:NArchive::NSplit::CHandler::`RTTI Base Class Array'o
.rdata$r:00003340                                         ; NArchive::NSplit::CHandler `RTTI Type Descriptor'
.rdata$r:00003344                 db    5
.rdata$r:00003345                 db    0
.rdata$r:00003346                 db    0
.rdata$r:00003347                 db    0
.rdata$r:00003348                 db    0
.rdata$r:00003349                 db    0
.rdata$r:0000334A                 db    0
.rdata$r:0000334B                 db    0
.rdata$r:0000334C                 db 0FFh
.rdata$r:0000334D                 db 0FFh
.rdata$r:0000334E                 db 0FFh
.rdata$r:0000334F                 db 0FFh
.rdata$r:00003350                 db    0
.rdata$r:00003351                 db    0
.rdata$r:00003352                 db    0
.rdata$r:00003353                 db    0
.rdata$r:00003354                 db  40h ; @
.rdata$r:00003355                 db    0
.rdata$r:00003356                 db    0
.rdata$r:00003357                 db    0
.rdata$r:00003358                 dd offset ??_R3CHandler@NSplit@NArchive@@8 ; NArchive::NSplit::CHandler::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003358 _rdata$r        ends
.rdata$r:00003358
.rdata$r:0000335C ; ===========================================================================
.rdata$r:0000335C
.rdata$r:0000335C ; Segment type: Pure data
.rdata$r:0000335C ; Segment permissions: Read
.rdata$r:0000335C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000335C                 assume cs:_rdata$r
.rdata$r:0000335C                 ;org 335Ch
.rdata$r:0000335C ; COMDAT (pick any)
.rdata$r:0000335C                 public ??_R1A@?0A@EA@IInArchive@@8
.rdata$r:0000335C ; IInArchive::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000335C ??_R1A@?0A@EA@IInArchive@@8 dd offset ??_R0?AUIInArchive@@@8
.rdata$r:0000335C                                         ; DATA XREF: .rdata$r:00003328o
.rdata$r:0000335C                                         ; .rdata$r:IInArchive::`RTTI Base Class Array'o
.rdata$r:0000335C                                         ; IInArchive `RTTI Type Descriptor'
.rdata$r:00003360                 db    1
.rdata$r:00003361                 db    0
.rdata$r:00003362                 db    0
.rdata$r:00003363                 db    0
.rdata$r:00003364                 db    0
.rdata$r:00003365                 db    0
.rdata$r:00003366                 db    0
.rdata$r:00003367                 db    0
.rdata$r:00003368                 db 0FFh
.rdata$r:00003369                 db 0FFh
.rdata$r:0000336A                 db 0FFh
.rdata$r:0000336B                 db 0FFh
.rdata$r:0000336C                 db    0
.rdata$r:0000336D                 db    0
.rdata$r:0000336E                 db    0
.rdata$r:0000336F                 db    0
.rdata$r:00003370                 db  40h ; @
.rdata$r:00003371                 db    0
.rdata$r:00003372                 db    0
.rdata$r:00003373                 db    0
.rdata$r:00003374                 dd offset ??_R3IInArchive@@8 ; IInArchive::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003374 _rdata$r        ends
.rdata$r:00003374
.data:00003378 ; ===========================================================================
.data:00003378
.data:00003378 ; Segment type: Pure data
.data:00003378 ; Segment permissions: Read/Write
.data:00003378 _data           segment dword public 'DATA' use32
.data:00003378                 assume cs:_data
.data:00003378                 ;org 3378h
.data:00003378 ; COMDAT (pick any)
.data:00003378                 public ??_R0?AUIInArchive@@@8
.data:00003378 ; struct IInArchive `RTTI Type Descriptor'
.data:00003378 ??_R0?AUIInArchive@@@8 dd offset ??_7type_info@@6B@
.data:00003378                                         ; DATA XREF: .rdata$r:IInArchive::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:00003378                                         ; .rdata$r:00003738o
.data:00003378                                         ; const type_info::`vftable'
.data:0000337C                 align 10h
.data:00003380 a_?auiinarchive db '.?AUIInArchive@@',0
.data:00003391                 align 4
.data:00003391 _data           ends
.data:00003391
.rdata$r:00003394 ; ===========================================================================
.rdata$r:00003394
.rdata$r:00003394 ; Segment type: Pure data
.rdata$r:00003394 ; Segment permissions: Read
.rdata$r:00003394 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003394                 assume cs:_rdata$r
.rdata$r:00003394                 ;org 3394h
.rdata$r:00003394 ; COMDAT (pick any)
.rdata$r:00003394                 public ??_R3IInArchive@@8
.rdata$r:00003394 ; IInArchive::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003394 ??_R3IInArchive@@8 db    0              ; DATA XREF: .rdata$r:00003374o
.rdata$r:00003394                                         ; .rdata$r:0000373Co
.rdata$r:00003395                 db    0
.rdata$r:00003396                 db    0
.rdata$r:00003397                 db    0
.rdata$r:00003398                 db    0
.rdata$r:00003399                 db    0
.rdata$r:0000339A                 db    0
.rdata$r:0000339B                 db    0
.rdata$r:0000339C                 db    2
.rdata$r:0000339D                 db    0
.rdata$r:0000339E                 db    0
.rdata$r:0000339F                 db    0
.rdata$r:000033A0                 dd offset ??_R2IInArchive@@8 ; IInArchive::`RTTI Base Class Array'
.rdata$r:000033A0 _rdata$r        ends
.rdata$r:000033A0
.rdata$r:000033A4 ; ===========================================================================
.rdata$r:000033A4
.rdata$r:000033A4 ; Segment type: Pure data
.rdata$r:000033A4 ; Segment permissions: Read
.rdata$r:000033A4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000033A4                 assume cs:_rdata$r
.rdata$r:000033A4                 ;org 33A4h
.rdata$r:000033A4 ; COMDAT (pick any)
.rdata$r:000033A4                 public ??_R2IInArchive@@8
.rdata$r:000033A4 ; IInArchive::`RTTI Base Class Array'
.rdata$r:000033A4 ??_R2IInArchive@@8 dd offset ??_R1A@?0A@EA@IInArchive@@8
.rdata$r:000033A4                                         ; DATA XREF: .rdata$r:000033A0o
.rdata$r:000033A4                                         ; IInArchive::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000033A8                 dd offset ??_R1A@?0A@EA@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000033AC                 db    0
.rdata$r:000033AD                 align 10h
.rdata$r:000033AD _rdata$r        ends
.rdata$r:000033AD
.rdata$r:000033B0 ; ===========================================================================
.rdata$r:000033B0
.rdata$r:000033B0 ; Segment type: Pure data
.rdata$r:000033B0 ; Segment permissions: Read
.rdata$r:000033B0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000033B0                 assume cs:_rdata$r
.rdata$r:000033B0                 ;org 33B0h
.rdata$r:000033B0 ; COMDAT (pick any)
.rdata$r:000033B0                 public ??_R13?0A@EA@IInArchiveGetStream@@8
.rdata$r:000033B0 ; IInArchiveGetStream::`RTTI Base Class Descriptor at (4, -1, 0, 64)'
.rdata$r:000033B0 ??_R13?0A@EA@IInArchiveGetStream@@8 dd offset ??_R0?AUIInArchiveGetStream@@@8
.rdata$r:000033B0                                         ; DATA XREF: .rdata$r:00003330o
.rdata$r:000033B0                                         ; IInArchiveGetStream `RTTI Type Descriptor'
.rdata$r:000033B4                 db    1
.rdata$r:000033B5                 db    0
.rdata$r:000033B6                 db    0
.rdata$r:000033B7                 db    0
.rdata$r:000033B8                 db    4
.rdata$r:000033B9                 db    0
.rdata$r:000033BA                 db    0
.rdata$r:000033BB                 db    0
.rdata$r:000033BC                 db 0FFh
.rdata$r:000033BD                 db 0FFh
.rdata$r:000033BE                 db 0FFh
.rdata$r:000033BF                 db 0FFh
.rdata$r:000033C0                 db    0
.rdata$r:000033C1                 db    0
.rdata$r:000033C2                 db    0
.rdata$r:000033C3                 db    0
.rdata$r:000033C4                 db  40h ; @
.rdata$r:000033C5                 db    0
.rdata$r:000033C6                 db    0
.rdata$r:000033C7                 db    0
.rdata$r:000033C8                 dd offset ??_R3IInArchiveGetStream@@8 ; IInArchiveGetStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:000033C8 _rdata$r        ends
.rdata$r:000033C8
.data:000033CC ; ===========================================================================
.data:000033CC
.data:000033CC ; Segment type: Pure data
.data:000033CC ; Segment permissions: Read/Write
.data:000033CC _data           segment dword public 'DATA' use32
.data:000033CC                 assume cs:_data
.data:000033CC                 ;org 33CCh
.data:000033CC ; COMDAT (pick any)
.data:000033CC                 public ??_R0?AUIInArchiveGetStream@@@8
.data:000033CC ; struct IInArchiveGetStream `RTTI Type Descriptor'
.data:000033CC ??_R0?AUIInArchiveGetStream@@@8 dd offset ??_7type_info@@6B@
.data:000033CC                                         ; DATA XREF: .rdata$r:IInArchiveGetStream::`RTTI Base Class Descriptor at (4,-1,0,64)'o
.data:000033CC                                         ; .rdata$r:IInArchiveGetStream::`RTTI Base Class Descriptor at (0,-1,0,64)'o ...
.data:000033CC                                         ; const type_info::`vftable'
.data:000033D0                 db    0
.data:000033D1                 db    0
.data:000033D2                 db    0
.data:000033D3                 db    0
.data:000033D4                 db  2Eh ; .
.data:000033D5                 db  3Fh ; ?
.data:000033D6                 db  41h ; A
.data:000033D7                 db  55h ; U
.data:000033D8                 db  49h ; I
.data:000033D9                 db  49h ; I
.data:000033DA                 db  6Eh ; n
.data:000033DB                 db  41h ; A
.data:000033DC                 db  72h ; r
.data:000033DD                 db  63h ; c
.data:000033DE                 db  68h ; h
.data:000033DF                 db  69h ; i
.data:000033E0                 db  76h ; v
.data:000033E1                 db  65h ; e
.data:000033E2                 db  47h ; G
.data:000033E3                 db  65h ; e
.data:000033E4                 db  74h ; t
.data:000033E5                 db  53h ; S
.data:000033E6                 db  74h ; t
.data:000033E7                 db  72h ; r
.data:000033E8                 db  65h ; e
.data:000033E9                 db  61h ; a
.data:000033EA                 db  6Dh ; m
.data:000033EB                 db  40h ; @
.data:000033EC                 db  40h ; @
.data:000033ED                 db    0
.data:000033EE                 align 10h
.data:000033EE _data           ends
.data:000033EE
.rdata$r:000033F0 ; ===========================================================================
.rdata$r:000033F0
.rdata$r:000033F0 ; Segment type: Pure data
.rdata$r:000033F0 ; Segment permissions: Read
.rdata$r:000033F0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000033F0                 assume cs:_rdata$r
.rdata$r:000033F0                 ;org 33F0h
.rdata$r:000033F0 ; COMDAT (pick any)
.rdata$r:000033F0                 public ??_R3IInArchiveGetStream@@8
.rdata$r:000033F0 ; IInArchiveGetStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:000033F0 ??_R3IInArchiveGetStream@@8 db    0     ; DATA XREF: .rdata$r:000033C8o
.rdata$r:000033F0                                         ; .rdata$r:00003424o ...
.rdata$r:000033F1                 db    0
.rdata$r:000033F2                 db    0
.rdata$r:000033F3                 db    0
.rdata$r:000033F4                 db    0
.rdata$r:000033F5                 db    0
.rdata$r:000033F6                 db    0
.rdata$r:000033F7                 db    0
.rdata$r:000033F8                 db    2
.rdata$r:000033F9                 db    0
.rdata$r:000033FA                 db    0
.rdata$r:000033FB                 db    0
.rdata$r:000033FC                 dd offset ??_R2IInArchiveGetStream@@8 ; IInArchiveGetStream::`RTTI Base Class Array'
.rdata$r:000033FC _rdata$r        ends
.rdata$r:000033FC
.rdata$r:00003400 ; ===========================================================================
.rdata$r:00003400
.rdata$r:00003400 ; Segment type: Pure data
.rdata$r:00003400 ; Segment permissions: Read
.rdata$r:00003400 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003400                 assume cs:_rdata$r
.rdata$r:00003400                 ;org 3400h
.rdata$r:00003400 ; COMDAT (pick any)
.rdata$r:00003400                 public ??_R2IInArchiveGetStream@@8
.rdata$r:00003400 ; IInArchiveGetStream::`RTTI Base Class Array'
.rdata$r:00003400 ??_R2IInArchiveGetStream@@8 dd offset ??_R1A@?0A@EA@IInArchiveGetStream@@8
.rdata$r:00003400                                         ; DATA XREF: .rdata$r:000033FCo
.rdata$r:00003400                                         ; IInArchiveGetStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003404                 dd offset ??_R1A@?0A@EA@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003408                 db    0
.rdata$r:00003409                 align 4
.rdata$r:00003409 _rdata$r        ends
.rdata$r:00003409
.rdata$r:0000340C ; ===========================================================================
.rdata$r:0000340C
.rdata$r:0000340C ; Segment type: Pure data
.rdata$r:0000340C ; Segment permissions: Read
.rdata$r:0000340C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000340C                 assume cs:_rdata$r
.rdata$r:0000340C                 ;org 340Ch
.rdata$r:0000340C ; COMDAT (pick any)
.rdata$r:0000340C                 public ??_R1A@?0A@EA@IInArchiveGetStream@@8
.rdata$r:0000340C ; IInArchiveGetStream::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000340C ??_R1A@?0A@EA@IInArchiveGetStream@@8 dd offset ??_R0?AUIInArchiveGetStream@@@8
.rdata$r:0000340C                                         ; DATA XREF: .rdata$r:IInArchiveGetStream::`RTTI Base Class Array'o
.rdata$r:0000340C                                         ; IInArchiveGetStream `RTTI Type Descriptor'
.rdata$r:00003410                 db    1
.rdata$r:00003411                 db    0
.rdata$r:00003412                 db    0
.rdata$r:00003413                 db    0
.rdata$r:00003414                 db    0
.rdata$r:00003415                 db    0
.rdata$r:00003416                 db    0
.rdata$r:00003417                 db    0
.rdata$r:00003418                 db 0FFh
.rdata$r:00003419                 db 0FFh
.rdata$r:0000341A                 db 0FFh
.rdata$r:0000341B                 db 0FFh
.rdata$r:0000341C                 db    0
.rdata$r:0000341D                 db    0
.rdata$r:0000341E                 db    0
.rdata$r:0000341F                 db    0
.rdata$r:00003420                 db  40h ; @
.rdata$r:00003421                 db    0
.rdata$r:00003422                 db    0
.rdata$r:00003423                 db    0
.rdata$r:00003424                 dd offset ??_R3IInArchiveGetStream@@8 ; IInArchiveGetStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003424 _rdata$r        ends
.rdata$r:00003424
.rdata$r:00003428 ; ===========================================================================
.rdata$r:00003428
.rdata$r:00003428 ; Segment type: Pure data
.rdata$r:00003428 ; Segment permissions: Read
.rdata$r:00003428 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003428                 assume cs:_rdata$r
.rdata$r:00003428                 ;org 3428h
.rdata$r:00003428 ; COMDAT (pick any)
.rdata$r:00003428                 public ??_R17?0A@EA@CMyUnknownImp@@8
.rdata$r:00003428 ; CMyUnknownImp::`RTTI Base Class Descriptor at (8, -1, 0, 64)'
.rdata$r:00003428 ??_R17?0A@EA@CMyUnknownImp@@8 dd offset ??_R0?AVCMyUnknownImp@@@8
.rdata$r:00003428                                         ; DATA XREF: .rdata$r:00003338o
.rdata$r:00003428                                         ; CMyUnknownImp `RTTI Type Descriptor'
.rdata$r:0000342C                 align 10h
.rdata$r:00003430                 db    8
.rdata$r:00003431                 db    0
.rdata$r:00003432                 db    0
.rdata$r:00003433                 db    0
.rdata$r:00003434                 db 0FFh
.rdata$r:00003435                 db 0FFh
.rdata$r:00003436                 db 0FFh
.rdata$r:00003437                 db 0FFh
.rdata$r:00003438                 db    0
.rdata$r:00003439                 db    0
.rdata$r:0000343A                 db    0
.rdata$r:0000343B                 db    0
.rdata$r:0000343C                 db  40h ; @
.rdata$r:0000343D                 db    0
.rdata$r:0000343E                 db    0
.rdata$r:0000343F                 db    0
.rdata$r:00003440                 dd offset ??_R3CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003440 _rdata$r        ends
.rdata$r:00003440
.rdata$r:00003444 ; ===========================================================================
.rdata$r:00003444
.rdata$r:00003444 ; Segment type: Pure data
.rdata$r:00003444 ; Segment permissions: Read
.rdata$r:00003444 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003444                 assume cs:_rdata$r
.rdata$r:00003444                 ;org 3444h
.rdata$r:00003444 ; COMDAT (pick any)
.rdata$r:00003444                 public ??_R4CHandler@NSplit@NArchive@@6BIInArchiveGetStream@@@
.rdata$r:00003444 ; const NArchive::NSplit::CHandler::`RTTI Complete Object Locator'{for `IInArchiveGetStream'}
.rdata$r:00003444 ??_R4CHandler@NSplit@NArchive@@6BIInArchiveGetStream@@@ db    0
.rdata$r:00003444                                         ; DATA XREF: .rdata:00003258o
.rdata$r:00003445                 db    0
.rdata$r:00003446                 db    0
.rdata$r:00003447                 db    0
.rdata$r:00003448                 db    4
.rdata$r:00003449                 db    0
.rdata$r:0000344A                 db    0
.rdata$r:0000344B                 db    0
.rdata$r:0000344C                 db    0
.rdata$r:0000344D                 db    0
.rdata$r:0000344E                 db    0
.rdata$r:0000344F                 db    0
.rdata$r:00003450                 dd offset ??_R0?AVCHandler@NSplit@NArchive@@@8 ; NArchive::NSplit::CHandler `RTTI Type Descriptor'
.rdata$r:00003454                 dd offset ??_R3CHandler@NSplit@NArchive@@8 ; NArchive::NSplit::CHandler::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003454 _rdata$r        ends
.rdata$r:00003454
.text:00003458 ; ===========================================================================
.text:00003458
.text:00003458 ; Segment type: Pure code
.text:00003458 ; Segment permissions: Read/Execute
.text:00003458 _text           segment para public 'CODE' use32
.text:00003458                 assume cs:_text
.text:00003458                 ;org 3458h
.text:00003458 ; COMDAT (pick any)
.text:00003458                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003458
.text:00003458 ; =============== S U B R O U T I N E =======================================
.text:00003458
.text:00003458 ; Attributes: bp-based frame
.text:00003458
.text:00003458 ; __int32 __stdcall NArchive::NSplit::CHandler::QueryInterface(NArchive::NSplit::CHandler *this, const struct _GUID *Buf1, void **)
.text:00003458                 public ?QueryInterface@CHandler@NSplit@NArchive@@UAGJABU_GUID@@PAPAX@Z
.text:00003458 ?QueryInterface@CHandler@NSplit@NArchive@@UAGJABU_GUID@@PAPAX@Z proc near
.text:00003458                                         ; CODE XREF: [thunk]:NArchive::NSplit::CHandler::QueryInterface`adjustor{4}' (_GUID const &,void * *)+5j
.text:00003458                                         ; DATA XREF: .rdata:const NArchive::NSplit::CHandler::`vftable'{for `IInArchive'}o
.text:00003458
.text:00003458 var_4           = dword ptr -4
.text:00003458 this            = dword ptr  8
.text:00003458 Buf1            = dword ptr  0Ch
.text:00003458 arg_8           = dword ptr  10h
.text:00003458
.text:00003458                 push    ebp
.text:00003459                 mov     ebp, esp
.text:0000345B                 push    ecx
.text:0000345C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003463                 mov     eax, [ebp+arg_8]
.text:00003466                 mov     dword ptr [eax], 0
.text:0000346C                 push    offset _IID_IUnknown ; Buf2
.text:00003471                 mov     ecx, [ebp+Buf1]
.text:00003474                 push    ecx             ; Buf1
.text:00003475                 call    ___@8           ; __(x,x)
.text:0000347A                 test    eax, eax
.text:0000347C                 jz      short loc_3488
.text:0000347E                 mov     edx, [ebp+arg_8]
.text:00003481                 mov     eax, [ebp+this]
.text:00003484                 mov     [edx], eax
.text:00003486                 jmp     short loc_34DF
.text:00003488 ; ---------------------------------------------------------------------------
.text:00003488
.text:00003488 loc_3488:                               ; CODE XREF: NArchive::NSplit::CHandler::QueryInterface(_GUID const &,void * *)+24j
.text:00003488                 push    offset _IID_IInArchive ; Buf2
.text:0000348D                 mov     ecx, [ebp+Buf1]
.text:00003490                 push    ecx             ; Buf1
.text:00003491                 call    ___@8           ; __(x,x)
.text:00003496                 test    eax, eax
.text:00003498                 jz      short loc_34A4
.text:0000349A                 mov     edx, [ebp+arg_8]
.text:0000349D                 mov     eax, [ebp+this]
.text:000034A0                 mov     [edx], eax
.text:000034A2                 jmp     short loc_34DF
.text:000034A4 ; ---------------------------------------------------------------------------
.text:000034A4
.text:000034A4 loc_34A4:                               ; CODE XREF: NArchive::NSplit::CHandler::QueryInterface(_GUID const &,void * *)+40j
.text:000034A4                 push    offset _IID_IInArchiveGetStream ; Buf2
.text:000034A9                 mov     ecx, [ebp+Buf1]
.text:000034AC                 push    ecx             ; Buf1
.text:000034AD                 call    ___@8           ; __(x,x)
.text:000034B2                 test    eax, eax
.text:000034B4                 jz      short loc_34D8
.text:000034B6                 cmp     [ebp+this], 0
.text:000034BA                 jz      short loc_34C7
.text:000034BC                 mov     edx, [ebp+this]
.text:000034BF                 add     edx, 4
.text:000034C2                 mov     [ebp+var_4], edx
.text:000034C5                 jmp     short loc_34CE
.text:000034C7 ; ---------------------------------------------------------------------------
.text:000034C7
.text:000034C7 loc_34C7:                               ; CODE XREF: NArchive::NSplit::CHandler::QueryInterface(_GUID const &,void * *)+62j
.text:000034C7                 mov     [ebp+var_4], 0
.text:000034CE
.text:000034CE loc_34CE:                               ; CODE XREF: NArchive::NSplit::CHandler::QueryInterface(_GUID const &,void * *)+6Dj
.text:000034CE                 mov     eax, [ebp+arg_8]
.text:000034D1                 mov     ecx, [ebp+var_4]
.text:000034D4                 mov     [eax], ecx
.text:000034D6                 jmp     short loc_34DF
.text:000034D8 ; ---------------------------------------------------------------------------
.text:000034D8
.text:000034D8 loc_34D8:                               ; CODE XREF: NArchive::NSplit::CHandler::QueryInterface(_GUID const &,void * *)+5Cj
.text:000034D8                 mov     eax, 80004002h
.text:000034DD                 jmp     short loc_34F0
.text:000034DF ; ---------------------------------------------------------------------------
.text:000034DF
.text:000034DF loc_34DF:                               ; CODE XREF: NArchive::NSplit::CHandler::QueryInterface(_GUID const &,void * *)+2Ej
.text:000034DF                                         ; NArchive::NSplit::CHandler::QueryInterface(_GUID const &,void * *)+4Aj ...
.text:000034DF                 mov     edx, [ebp+this]
.text:000034E2                 mov     eax, [edx+8]
.text:000034E5                 add     eax, 1
.text:000034E8                 mov     ecx, [ebp+this]
.text:000034EB                 mov     [ecx+8], eax
.text:000034EE                 xor     eax, eax
.text:000034F0
.text:000034F0 loc_34F0:                               ; CODE XREF: NArchive::NSplit::CHandler::QueryInterface(_GUID const &,void * *)+85j
.text:000034F0                 add     esp, 4
.text:000034F3                 cmp     ebp, esp
.text:000034F5                 call    __RTC_CheckEsp
.text:000034FA                 mov     esp, ebp
.text:000034FC                 pop     ebp
.text:000034FD                 retn    0Ch
.text:000034FD ?QueryInterface@CHandler@NSplit@NArchive@@UAGJABU_GUID@@PAPAX@Z endp
.text:000034FD
.text:000034FD _text           ends
.text:000034FD
.text:00003500 ; ===========================================================================
.text:00003500
.text:00003500 ; Segment type: Pure code
.text:00003500 ; Segment permissions: Read/Execute
.text:00003500 _text           segment para public 'CODE' use32
.text:00003500                 assume cs:_text
.text:00003500                 ;org 3500h
.text:00003500 ; COMDAT (pick any)
.text:00003500                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003500
.text:00003500 ; =============== S U B R O U T I N E =======================================
.text:00003500
.text:00003500 ; Attributes: bp-based frame
.text:00003500
.text:00003500 ; unsigned __int32 __stdcall NArchive::NSplit::CHandler::AddRef(NArchive::NSplit::CHandler *this)
.text:00003500                 public ?AddRef@CHandler@NSplit@NArchive@@UAGKXZ
.text:00003500 ?AddRef@CHandler@NSplit@NArchive@@UAGKXZ proc near
.text:00003500                                         ; CODE XREF: [thunk]:NArchive::NSplit::CHandler::AddRef`adjustor{4}' (void)+5j
.text:00003500                                         ; DATA XREF: .rdata:00003274o
.text:00003500
.text:00003500 var_4           = dword ptr -4
.text:00003500 this            = dword ptr  8
.text:00003500
.text:00003500                 push    ebp
.text:00003501                 mov     ebp, esp
.text:00003503                 push    ecx
.text:00003504                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000350B                 mov     eax, [ebp+this]
.text:0000350E                 mov     ecx, [eax+8]
.text:00003511                 add     ecx, 1
.text:00003514                 mov     [ebp+var_4], ecx
.text:00003517                 mov     edx, [ebp+this]
.text:0000351A                 mov     eax, [ebp+var_4]
.text:0000351D                 mov     [edx+8], eax
.text:00003520                 mov     eax, [ebp+var_4]
.text:00003523                 mov     esp, ebp
.text:00003525                 pop     ebp
.text:00003526                 retn    4
.text:00003526 ?AddRef@CHandler@NSplit@NArchive@@UAGKXZ endp
.text:00003526
.text:00003526 ; ---------------------------------------------------------------------------
.text:00003529                 align 4
.text:00003529 _text           ends
.text:00003529
.text:0000352C ; ===========================================================================
.text:0000352C
.text:0000352C ; Segment type: Pure code
.text:0000352C ; Segment permissions: Read/Execute
.text:0000352C _text           segment para public 'CODE' use32
.text:0000352C                 assume cs:_text
.text:0000352C                 ;org 352Ch
.text:0000352C ; COMDAT (pick any)
.text:0000352C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000352C
.text:0000352C ; =============== S U B R O U T I N E =======================================
.text:0000352C
.text:0000352C ; Attributes: bp-based frame
.text:0000352C
.text:0000352C ; unsigned __int32 __stdcall NArchive::NSplit::CHandler::Release(NArchive::NSplit::CHandler *this)
.text:0000352C                 public ?Release@CHandler@NSplit@NArchive@@UAGKXZ
.text:0000352C ?Release@CHandler@NSplit@NArchive@@UAGKXZ proc near
.text:0000352C                                         ; CODE XREF: [thunk]:NArchive::NSplit::CHandler::Release`adjustor{4}' (void)+5j
.text:0000352C                                         ; DATA XREF: .rdata:00003278o
.text:0000352C
.text:0000352C var_10          = dword ptr -10h
.text:0000352C var_C           = dword ptr -0Ch
.text:0000352C var_8           = dword ptr -8
.text:0000352C var_4           = dword ptr -4
.text:0000352C this            = dword ptr  8
.text:0000352C
.text:0000352C                 push    ebp
.text:0000352D                 mov     ebp, esp
.text:0000352F                 sub     esp, 10h
.text:00003532                 mov     eax, 0CCCCCCCCh
.text:00003537                 mov     [ebp+var_10], eax
.text:0000353A                 mov     [ebp+var_C], eax
.text:0000353D                 mov     [ebp+var_8], eax
.text:00003540                 mov     [ebp+var_4], eax
.text:00003543                 mov     eax, [ebp+this]
.text:00003546                 mov     ecx, [eax+8]
.text:00003549                 sub     ecx, 1
.text:0000354C                 mov     [ebp+var_C], ecx
.text:0000354F                 mov     edx, [ebp+this]
.text:00003552                 mov     eax, [ebp+var_C]
.text:00003555                 mov     [edx+8], eax
.text:00003558                 cmp     [ebp+var_C], 0
.text:0000355C                 jz      short loc_3566
.text:0000355E                 mov     ecx, [ebp+this]
.text:00003561                 mov     eax, [ecx+8]
.text:00003564                 jmp     short loc_3590
.text:00003566 ; ---------------------------------------------------------------------------
.text:00003566
.text:00003566 loc_3566:                               ; CODE XREF: NArchive::NSplit::CHandler::Release(void)+30j
.text:00003566                 mov     edx, [ebp+this]
.text:00003569                 mov     [ebp+var_8], edx
.text:0000356C                 mov     eax, [ebp+var_8]
.text:0000356F                 mov     [ebp+var_4], eax
.text:00003572                 cmp     [ebp+var_4], 0
.text:00003576                 jz      short loc_3587
.text:00003578                 push    1
.text:0000357A                 mov     ecx, [ebp+var_4]
.text:0000357D                 call    ??_GCHandler@NSplit@NArchive@@QAEPAXI@Z ; NArchive::NSplit::CHandler::`scalar deleting destructor'(uint)
.text:00003582                 mov     [ebp+var_10], eax
.text:00003585                 jmp     short loc_358E
.text:00003587 ; ---------------------------------------------------------------------------
.text:00003587
.text:00003587 loc_3587:                               ; CODE XREF: NArchive::NSplit::CHandler::Release(void)+4Aj
.text:00003587                 mov     [ebp+var_10], 0
.text:0000358E
.text:0000358E loc_358E:                               ; CODE XREF: NArchive::NSplit::CHandler::Release(void)+59j
.text:0000358E                 xor     eax, eax
.text:00003590
.text:00003590 loc_3590:                               ; CODE XREF: NArchive::NSplit::CHandler::Release(void)+38j
.text:00003590                 add     esp, 10h
.text:00003593                 cmp     ebp, esp
.text:00003595                 call    __RTC_CheckEsp
.text:0000359A                 mov     esp, ebp
.text:0000359C                 pop     ebp
.text:0000359D                 retn    4
.text:0000359D ?Release@CHandler@NSplit@NArchive@@UAGKXZ endp
.text:0000359D
.text:0000359D _text           ends
.text:0000359D
.text:000035A0 ; ===========================================================================
.text:000035A0
.text:000035A0 ; Segment type: Pure code
.text:000035A0 ; Segment permissions: Read/Execute
.text:000035A0 _text           segment para public 'CODE' use32
.text:000035A0                 assume cs:_text
.text:000035A0                 ;org 35A0h
.text:000035A0 ; COMDAT (pick any)
.text:000035A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000035A0
.text:000035A0 ; =============== S U B R O U T I N E =======================================
.text:000035A0
.text:000035A0 ; Attributes: bp-based frame
.text:000035A0
.text:000035A0 ; public: void * __thiscall NArchive::NSplit::CHandler::`scalar deleting destructor'(unsigned int)
.text:000035A0                 public ??_GCHandler@NSplit@NArchive@@QAEPAXI@Z
.text:000035A0 ??_GCHandler@NSplit@NArchive@@QAEPAXI@Z proc near
.text:000035A0                                         ; CODE XREF: NArchive::NSplit::CHandler::Release(void)+51p
.text:000035A0
.text:000035A0 var_4           = dword ptr -4
.text:000035A0 arg_0           = dword ptr  8
.text:000035A0
.text:000035A0                 push    ebp
.text:000035A1                 mov     ebp, esp
.text:000035A3                 push    ecx
.text:000035A4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000035AB                 mov     [ebp+var_4], ecx
.text:000035AE                 mov     ecx, [ebp+var_4] ; this
.text:000035B1                 call    ??1CHandler@NSplit@NArchive@@QAE@XZ ; NArchive::NSplit::CHandler::~CHandler(void)
.text:000035B6                 mov     eax, [ebp+arg_0]
.text:000035B9                 and     eax, 1
.text:000035BC                 jz      short loc_35CA
.text:000035BE                 mov     ecx, [ebp+var_4]
.text:000035C1                 push    ecx             ; void *
.text:000035C2                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:000035C7                 add     esp, 4
.text:000035CA
.text:000035CA loc_35CA:                               ; CODE XREF: NArchive::NSplit::CHandler::`scalar deleting destructor'(uint)+1Cj
.text:000035CA                 mov     eax, [ebp+var_4]
.text:000035CD                 add     esp, 4
.text:000035D0                 cmp     ebp, esp
.text:000035D2                 call    __RTC_CheckEsp
.text:000035D7                 mov     esp, ebp
.text:000035D9                 pop     ebp
.text:000035DA                 retn    4
.text:000035DA ??_GCHandler@NSplit@NArchive@@QAEPAXI@Z endp
.text:000035DA
.text:000035DA ; ---------------------------------------------------------------------------
.text:000035DD                 align 10h
.text:000035DD _text           ends
.text:000035DD
.text:000035E0 ; ===========================================================================
.text:000035E0
.text:000035E0 ; Segment type: Pure code
.text:000035E0 ; Segment permissions: Read/Execute
.text:000035E0 _text           segment para public 'CODE' use32
.text:000035E0                 assume cs:_text
.text:000035E0                 ;org 35E0h
.text:000035E0 ; COMDAT (pick any)
.text:000035E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000035E0
.text:000035E0 ; =============== S U B R O U T I N E =======================================
.text:000035E0
.text:000035E0 ; Attributes: bp-based frame
.text:000035E0
.text:000035E0 ; _DWORD __thiscall NArchive::NSplit::CHandler::~CHandler(NArchive::NSplit::CHandler *__hidden this)
.text:000035E0                 public ??1CHandler@NSplit@NArchive@@QAE@XZ
.text:000035E0 ??1CHandler@NSplit@NArchive@@QAE@XZ proc near
.text:000035E0                                         ; CODE XREF: NArchive::NSplit::CHandler::`scalar deleting destructor'(uint)+11p
.text:000035E0
.text:000035E0 var_10          = dword ptr -10h
.text:000035E0 var_C           = dword ptr -0Ch
.text:000035E0 var_4           = dword ptr -4
.text:000035E0
.text:000035E0                 push    ebp
.text:000035E1                 mov     ebp, esp
.text:000035E3                 push    0FFFFFFFFh
.text:000035E5                 push    offset __ehhandler$??1CHandler@NSplit@NArchive@@QAE@XZ
.text:000035EA                 mov     eax, large fs:0
.text:000035F0                 push    eax
.text:000035F1                 push    ecx
.text:000035F2                 mov     [ebp+var_10], 0CCCCCCCCh
.text:000035F9                 mov     eax, dword ptr ds:___security_cookie
.text:000035FE                 xor     eax, ebp
.text:00003600                 push    eax
.text:00003601                 lea     eax, [ebp+var_C]
.text:00003604                 mov     large fs:0, eax
.text:0000360A                 mov     [ebp+var_10], ecx
.text:0000360D                 mov     [ebp+var_4], 1
.text:00003614                 mov     ecx, [ebp+var_10]
.text:00003617                 add     ecx, 24h ; '$'  ; this
.text:0000361A                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000361F                 mov     byte ptr [ebp+var_4], 0
.text:00003623                 mov     ecx, [ebp+var_10]
.text:00003626                 add     ecx, 18h
.text:00003629                 call    ??1?$CRecordVector@_K@@QAE@XZ ; CRecordVector<unsigned __int64>::~CRecordVector<unsigned __int64>(void)
.text:0000362E                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00003635                 mov     ecx, [ebp+var_10]
.text:00003638                 add     ecx, 0Ch
.text:0000363B                 call    ??1?$CObjectVector@V?$CMyComPtr@UIInStream@@@@@@QAE@XZ ; CObjectVector<CMyComPtr<IInStream>>::~CObjectVector<CMyComPtr<IInStream>>(void)
.text:00003640                 mov     ecx, [ebp+var_C]
.text:00003643                 mov     large fs:0, ecx
.text:0000364A                 pop     ecx
.text:0000364B                 add     esp, 10h
.text:0000364E                 cmp     ebp, esp
.text:00003650                 call    __RTC_CheckEsp
.text:00003655                 mov     esp, ebp
.text:00003657                 pop     ebp
.text:00003658                 retn
.text:00003658 ??1CHandler@NSplit@NArchive@@QAE@XZ endp
.text:00003658
.text:00003658 ; ---------------------------------------------------------------------------
.text:00003659                 align 4
.text:00003659 _text           ends
.text:00003659
.text$x:0000365C ; ===========================================================================
.text$x:0000365C
.text$x:0000365C ; Segment type: Pure code
.text$x:0000365C ; Segment permissions: Read/Execute
.text$x:0000365C _text$x         segment para public 'CODE' use32
.text$x:0000365C                 assume cs:_text$x
.text$x:0000365C                 ;org 365Ch
.text$x:0000365C ; COMDAT (pick associative to section at 35E0)
.text$x:0000365C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000365C
.text$x:0000365C ; =============== S U B R O U T I N E =======================================
.text$x:0000365C
.text$x:0000365C
.text$x:0000365C __unwindfunclet$??1CHandler@NSplit@NArchive@@QAE@XZ$0 proc near
.text$x:0000365C                                         ; DATA XREF: .xdata$x:00003694o
.text$x:0000365C                 mov     ecx, [ebp-10h]
.text$x:0000365F                 add     ecx, 0Ch
.text$x:00003662                 jmp     ??1?$CObjectVector@V?$CMyComPtr@UIInStream@@@@@@QAE@XZ ; CObjectVector<CMyComPtr<IInStream>>::~CObjectVector<CMyComPtr<IInStream>>(void)
.text$x:00003662 __unwindfunclet$??1CHandler@NSplit@NArchive@@QAE@XZ$0 endp
.text$x:00003662
.text$x:00003667
.text$x:00003667 ; =============== S U B R O U T I N E =======================================
.text$x:00003667
.text$x:00003667
.text$x:00003667 __unwindfunclet$??1CHandler@NSplit@NArchive@@QAE@XZ$1 proc near
.text$x:00003667                                         ; DATA XREF: .xdata$x:0000369Co
.text$x:00003667                 mov     ecx, [ebp-10h]
.text$x:0000366A                 add     ecx, 18h
.text$x:0000366D                 jmp     ??1?$CRecordVector@_K@@QAE@XZ ; CRecordVector<unsigned __int64>::~CRecordVector<unsigned __int64>(void)
.text$x:0000366D __unwindfunclet$??1CHandler@NSplit@NArchive@@QAE@XZ$1 endp
.text$x:0000366D
.text$x:00003672
.text$x:00003672 ; =============== S U B R O U T I N E =======================================
.text$x:00003672
.text$x:00003672
.text$x:00003672 __ehhandler$??1CHandler@NSplit@NArchive@@QAE@XZ proc near
.text$x:00003672                                         ; DATA XREF: NArchive::NSplit::CHandler::~CHandler(void)+5o
.text$x:00003672
.text$x:00003672 arg_4           = dword ptr  8
.text$x:00003672
.text$x:00003672                 mov     edx, [esp+arg_4]
.text$x:00003676                 lea     eax, [edx+0Ch]
.text$x:00003679                 mov     ecx, [edx-8]
.text$x:0000367C                 xor     ecx, eax
.text$x:0000367E                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003683                 mov     eax, offset __ehfuncinfo$??1CHandler@NSplit@NArchive@@QAE@XZ
.text$x:00003688                 jmp     ___CxxFrameHandler3
.text$x:00003688 __ehhandler$??1CHandler@NSplit@NArchive@@QAE@XZ endp
.text$x:00003688
.text$x:00003688 ; ---------------------------------------------------------------------------
.text$x:0000368D                 align 10h
.text$x:0000368D _text$x         ends
.text$x:0000368D
.xdata$x:00003690 ; ===========================================================================
.xdata$x:00003690
.xdata$x:00003690 ; Segment type: Pure data
.xdata$x:00003690 ; Segment permissions: Read
.xdata$x:00003690 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003690                 assume cs:_xdata$x
.xdata$x:00003690                 ;org 3690h
.xdata$x:00003690 ; COMDAT (pick associative to section at 35E0)
.xdata$x:00003690 __unwindtable$??1CHandler@NSplit@NArchive@@QAE@XZ db 0FFh
.xdata$x:00003690                                         ; DATA XREF: .xdata$x:000036A8o
.xdata$x:00003691                 db 0FFh
.xdata$x:00003692                 db 0FFh
.xdata$x:00003693                 db 0FFh
.xdata$x:00003694                 dd offset __unwindfunclet$??1CHandler@NSplit@NArchive@@QAE@XZ$0
.xdata$x:00003698                 db    0
.xdata$x:00003699                 db    0
.xdata$x:0000369A                 db    0
.xdata$x:0000369B                 db    0
.xdata$x:0000369C                 dd offset __unwindfunclet$??1CHandler@NSplit@NArchive@@QAE@XZ$1
.xdata$x:000036A0 __ehfuncinfo$??1CHandler@NSplit@NArchive@@QAE@XZ db  22h ; "
.xdata$x:000036A0                                         ; DATA XREF: __ehhandler$??1CHandler@NSplit@NArchive@@QAE@XZ+11o
.xdata$x:000036A1                 db    5
.xdata$x:000036A2                 db  93h ; ô
.xdata$x:000036A3                 db  19h
.xdata$x:000036A4                 db    2
.xdata$x:000036A5                 db    0
.xdata$x:000036A6                 db    0
.xdata$x:000036A7                 db    0
.xdata$x:000036A8                 dd offset __unwindtable$??1CHandler@NSplit@NArchive@@QAE@XZ
.xdata$x:000036AC                 align 20h
.xdata$x:000036C0                 db    1
.xdata$x:000036C1                 db    0
.xdata$x:000036C2                 db    0
.xdata$x:000036C3                 db    0
.xdata$x:000036C3 _xdata$x        ends
.xdata$x:000036C3
.text:000036C4 ; ===========================================================================
.text:000036C4
.text:000036C4 ; Segment type: Pure code
.text:000036C4 ; Segment permissions: Read/Execute
.text:000036C4 _text           segment para public 'CODE' use32
.text:000036C4                 assume cs:_text
.text:000036C4                 ;org 36C4h
.text:000036C4 ; COMDAT (pick any)
.text:000036C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000036C4
.text:000036C4 ; =============== S U B R O U T I N E =======================================
.text:000036C4
.text:000036C4 ; Attributes: bp-based frame
.text:000036C4
.text:000036C4 ; _DWORD __thiscall IInArchive::IInArchive(IInArchive *__hidden this)
.text:000036C4                 public ??0IInArchive@@QAE@XZ
.text:000036C4 ??0IInArchive@@QAE@XZ proc near         ; CODE XREF: NArchive::NSplit::CHandler::CHandler(void)+30p
.text:000036C4
.text:000036C4 var_4           = dword ptr -4
.text:000036C4
.text:000036C4                 push    ebp
.text:000036C5                 mov     ebp, esp
.text:000036C7                 push    ecx
.text:000036C8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000036CF                 mov     [ebp+var_4], ecx
.text:000036D2                 mov     ecx, [ebp+var_4]
.text:000036D5                 call    ??0IUnknown@@QAE@XZ ; IUnknown::IUnknown(void)
.text:000036DA                 mov     eax, [ebp+var_4]
.text:000036DD                 mov     dword ptr [eax], offset ??_7IInArchive@@6B@ ; const IInArchive::`vftable'
.text:000036E3                 mov     eax, [ebp+var_4]
.text:000036E6                 add     esp, 4
.text:000036E9                 cmp     ebp, esp
.text:000036EB                 call    __RTC_CheckEsp
.text:000036F0                 mov     esp, ebp
.text:000036F2                 pop     ebp
.text:000036F3                 retn
.text:000036F3 ??0IInArchive@@QAE@XZ endp
.text:000036F3
.text:000036F3 _text           ends
.text:000036F3
.rdata:000036F4 ; ===========================================================================
.rdata:000036F4
.rdata:000036F4 ; Segment type: Pure data
.rdata:000036F4 ; Segment permissions: Read
.rdata:000036F4 _rdata          segment dword public 'DATA' use32
.rdata:000036F4                 assume cs:_rdata
.rdata:000036F4                 ;org 36F4h
.rdata:000036F4 ; COMDAT (pick largest)
.rdata:000036F4                 dd offset ??_R4IInArchive@@6B@ ; const IInArchive::`RTTI Complete Object Locator'
.rdata:000036F8                 public ??_7IInArchive@@6B@
.rdata:000036F8 ; const IInArchive::`vftable'
.rdata:000036F8 ??_7IInArchive@@6B@ dd offset __purecall
.rdata:000036F8                                         ; DATA XREF: IInArchive::IInArchive(void)+19o
.rdata:000036FC                 dd offset __purecall
.rdata:00003700                 dd offset __purecall
.rdata:00003704                 dd offset __purecall
.rdata:00003708                 dd offset __purecall
.rdata:0000370C                 dd offset __purecall
.rdata:00003710                 dd offset __purecall
.rdata:00003714                 dd offset __purecall
.rdata:00003718                 dd offset __purecall
.rdata:0000371C                 dd offset __purecall
.rdata:00003720                 dd offset __purecall
.rdata:00003724                 dd offset __purecall
.rdata:00003728                 dd offset __purecall
.rdata:00003728 _rdata          ends
.rdata:00003728
.rdata$r:0000372C ; ===========================================================================
.rdata$r:0000372C
.rdata$r:0000372C ; Segment type: Pure data
.rdata$r:0000372C ; Segment permissions: Read
.rdata$r:0000372C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000372C                 assume cs:_rdata$r
.rdata$r:0000372C                 ;org 372Ch
.rdata$r:0000372C ; COMDAT (pick any)
.rdata$r:0000372C                 public ??_R4IInArchive@@6B@
.rdata$r:0000372C ; const IInArchive::`RTTI Complete Object Locator'
.rdata$r:0000372C ??_R4IInArchive@@6B@ db    0            ; DATA XREF: .rdata:000036F4o
.rdata$r:0000372D                 db    0
.rdata$r:0000372E                 db    0
.rdata$r:0000372F                 db    0
.rdata$r:00003730                 db    0
.rdata$r:00003731                 db    0
.rdata$r:00003732                 db    0
.rdata$r:00003733                 db    0
.rdata$r:00003734                 db    0
.rdata$r:00003735                 db    0
.rdata$r:00003736                 db    0
.rdata$r:00003737                 db    0
.rdata$r:00003738                 dd offset ??_R0?AUIInArchive@@@8 ; IInArchive `RTTI Type Descriptor'
.rdata$r:0000373C                 dd offset ??_R3IInArchive@@8 ; IInArchive::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000373C _rdata$r        ends
.rdata$r:0000373C
.text:00003740 ; ===========================================================================
.text:00003740
.text:00003740 ; Segment type: Pure code
.text:00003740 ; Segment permissions: Read/Execute
.text:00003740 _text           segment para public 'CODE' use32
.text:00003740                 assume cs:_text
.text:00003740                 ;org 3740h
.text:00003740 ; COMDAT (pick any)
.text:00003740                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003740
.text:00003740 ; =============== S U B R O U T I N E =======================================
.text:00003740
.text:00003740 ; Attributes: bp-based frame
.text:00003740
.text:00003740 ; _DWORD __thiscall IInArchiveGetStream::IInArchiveGetStream(IInArchiveGetStream *__hidden this)
.text:00003740                 public ??0IInArchiveGetStream@@QAE@XZ
.text:00003740 ??0IInArchiveGetStream@@QAE@XZ proc near
.text:00003740                                         ; CODE XREF: NArchive::NSplit::CHandler::CHandler(void)+3Bp
.text:00003740
.text:00003740 var_4           = dword ptr -4
.text:00003740
.text:00003740                 push    ebp
.text:00003741                 mov     ebp, esp
.text:00003743                 push    ecx
.text:00003744                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000374B                 mov     [ebp+var_4], ecx
.text:0000374E                 mov     ecx, [ebp+var_4]
.text:00003751                 call    ??0IUnknown@@QAE@XZ ; IUnknown::IUnknown(void)
.text:00003756                 mov     eax, [ebp+var_4]
.text:00003759                 mov     dword ptr [eax], offset ??_7IInArchiveGetStream@@6B@ ; const IInArchiveGetStream::`vftable'
.text:0000375F                 mov     eax, [ebp+var_4]
.text:00003762                 add     esp, 4
.text:00003765                 cmp     ebp, esp
.text:00003767                 call    __RTC_CheckEsp
.text:0000376C                 mov     esp, ebp
.text:0000376E                 pop     ebp
.text:0000376F                 retn
.text:0000376F ??0IInArchiveGetStream@@QAE@XZ endp
.text:0000376F
.text:0000376F _text           ends
.text:0000376F
.rdata:00003770 ; ===========================================================================
.rdata:00003770
.rdata:00003770 ; Segment type: Pure data
.rdata:00003770 ; Segment permissions: Read
.rdata:00003770 _rdata          segment dword public 'DATA' use32
.rdata:00003770                 assume cs:_rdata
.rdata:00003770                 ;org 3770h
.rdata:00003770 ; COMDAT (pick largest)
.rdata:00003770                 dd offset ??_R4IInArchiveGetStream@@6B@ ; const IInArchiveGetStream::`RTTI Complete Object Locator'
.rdata:00003774                 public ??_7IInArchiveGetStream@@6B@
.rdata:00003774 ; const IInArchiveGetStream::`vftable'
.rdata:00003774 ??_7IInArchiveGetStream@@6B@ dd offset __purecall
.rdata:00003774                                         ; DATA XREF: IInArchiveGetStream::IInArchiveGetStream(void)+19o
.rdata:00003778                 dd offset __purecall
.rdata:0000377C                 dd offset __purecall
.rdata:00003780                 dd offset __purecall
.rdata:00003780 _rdata          ends
.rdata:00003780
.rdata$r:00003784 ; ===========================================================================
.rdata$r:00003784
.rdata$r:00003784 ; Segment type: Pure data
.rdata$r:00003784 ; Segment permissions: Read
.rdata$r:00003784 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003784                 assume cs:_rdata$r
.rdata$r:00003784                 ;org 3784h
.rdata$r:00003784 ; COMDAT (pick any)
.rdata$r:00003784                 public ??_R4IInArchiveGetStream@@6B@
.rdata$r:00003784 ; const IInArchiveGetStream::`RTTI Complete Object Locator'
.rdata$r:00003784 ??_R4IInArchiveGetStream@@6B@ db    0   ; DATA XREF: .rdata:00003770o
.rdata$r:00003785                 db    0
.rdata$r:00003786                 db    0
.rdata$r:00003787                 db    0
.rdata$r:00003788                 db    0
.rdata$r:00003789                 db    0
.rdata$r:0000378A                 db    0
.rdata$r:0000378B                 db    0
.rdata$r:0000378C                 db    0
.rdata$r:0000378D                 db    0
.rdata$r:0000378E                 db    0
.rdata$r:0000378F                 db    0
.rdata$r:00003790                 dd offset ??_R0?AUIInArchiveGetStream@@@8 ; IInArchiveGetStream `RTTI Type Descriptor'
.rdata$r:00003794                 dd offset ??_R3IInArchiveGetStream@@8 ; IInArchiveGetStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003794 _rdata$r        ends
.rdata$r:00003794
.text:00003798 ; ===========================================================================
.text:00003798
.text:00003798 ; Segment type: Pure code
.text:00003798 ; Segment permissions: Read/Execute
.text:00003798 _text           segment para public 'CODE' use32
.text:00003798                 assume cs:_text
.text:00003798                 ;org 3798h
.text:00003798 ; COMDAT (pick any)
.text:00003798                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003798
.text:00003798 ; =============== S U B R O U T I N E =======================================
.text:00003798
.text:00003798 ; Attributes: bp-based frame
.text:00003798
.text:00003798 ; public: __thiscall CMyComPtr<struct ICompressProgressInfo>::CMyComPtr<struct ICompressProgressInfo>(struct ICompressProgressInfo *)
.text:00003798                 public ??0?$CMyComPtr@UICompressProgressInfo@@@@QAE@PAUICompressProgressInfo@@@Z
.text:00003798 ??0?$CMyComPtr@UICompressProgressInfo@@@@QAE@PAUICompressProgressInfo@@@Z proc near
.text:00003798                                         ; CODE XREF: NArchive::NSplit::CHandler::Extract(uint const *,uint,int,IArchiveExtractCallback *)+29Bp
.text:00003798
.text:00003798 var_4           = dword ptr -4
.text:00003798 arg_0           = dword ptr  8
.text:00003798
.text:00003798                 push    ebp
.text:00003799                 mov     ebp, esp
.text:0000379B                 push    ecx
.text:0000379C                 push    esi
.text:0000379D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000037A4                 mov     [ebp+var_4], ecx
.text:000037A7                 mov     eax, [ebp+var_4]
.text:000037AA                 mov     ecx, [ebp+arg_0]
.text:000037AD                 mov     [eax], ecx
.text:000037AF                 cmp     [ebp+arg_0], 0
.text:000037B3                 jz      short loc_37CC
.text:000037B5                 mov     edx, [ebp+arg_0]
.text:000037B8                 mov     eax, [edx]
.text:000037BA                 mov     esi, esp
.text:000037BC                 mov     ecx, [ebp+arg_0]
.text:000037BF                 push    ecx
.text:000037C0                 mov     edx, [eax+4]
.text:000037C3                 call    edx
.text:000037C5                 cmp     esi, esp
.text:000037C7                 call    __RTC_CheckEsp
.text:000037CC
.text:000037CC loc_37CC:                               ; CODE XREF: CMyComPtr<ICompressProgressInfo>::CMyComPtr<ICompressProgressInfo>(ICompressProgressInfo *)+1Bj
.text:000037CC                 mov     eax, [ebp+var_4]
.text:000037CF                 pop     esi
.text:000037D0                 add     esp, 4
.text:000037D3                 cmp     ebp, esp
.text:000037D5                 call    __RTC_CheckEsp
.text:000037DA                 mov     esp, ebp
.text:000037DC                 pop     ebp
.text:000037DD                 retn    4
.text:000037DD ??0?$CMyComPtr@UICompressProgressInfo@@@@QAE@PAUICompressProgressInfo@@@Z endp
.text:000037DD
.text:000037DD _text           ends
.text:000037DD
.text:000037E0 ; ===========================================================================
.text:000037E0
.text:000037E0 ; Segment type: Pure code
.text:000037E0 ; Segment permissions: Read/Execute
.text:000037E0 _text           segment para public 'CODE' use32
.text:000037E0                 assume cs:_text
.text:000037E0                 ;org 37E0h
.text:000037E0 ; COMDAT (pick any)
.text:000037E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000037E0
.text:000037E0 ; =============== S U B R O U T I N E =======================================
.text:000037E0
.text:000037E0 ; Attributes: bp-based frame
.text:000037E0
.text:000037E0 ; public: __thiscall CMyComPtr<struct ICompressProgressInfo>::~CMyComPtr<struct ICompressProgressInfo>(void)
.text:000037E0                 public ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ
.text:000037E0 ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ proc near
.text:000037E0                                         ; CODE XREF: NArchive::NSplit::CHandler::Extract(uint const *,uint,int,IArchiveExtractCallback *)+32Fp
.text:000037E0                                         ; NArchive::NSplit::CHandler::Extract(uint const *,uint,int,IArchiveExtractCallback *)+3CAp ...
.text:000037E0
.text:000037E0 var_4           = dword ptr -4
.text:000037E0
.text:000037E0                 push    ebp
.text:000037E1                 mov     ebp, esp
.text:000037E3                 push    ecx
.text:000037E4                 push    esi
.text:000037E5                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000037EC                 mov     [ebp+var_4], ecx
.text:000037EF                 mov     eax, [ebp+var_4]
.text:000037F2                 cmp     dword ptr [eax], 0
.text:000037F5                 jz      short loc_3812
.text:000037F7                 mov     ecx, [ebp+var_4]
.text:000037FA                 mov     edx, [ecx]
.text:000037FC                 mov     eax, [ebp+var_4]
.text:000037FF                 mov     ecx, [eax]
.text:00003801                 mov     edx, [edx]
.text:00003803                 mov     esi, esp
.text:00003805                 push    ecx
.text:00003806                 mov     eax, [edx+8]
.text:00003809                 call    eax
.text:0000380B                 cmp     esi, esp
.text:0000380D                 call    __RTC_CheckEsp
.text:00003812
.text:00003812 loc_3812:                               ; CODE XREF: CMyComPtr<ICompressProgressInfo>::~CMyComPtr<ICompressProgressInfo>(void)+15j
.text:00003812                 pop     esi
.text:00003813                 add     esp, 4
.text:00003816                 cmp     ebp, esp
.text:00003818                 call    __RTC_CheckEsp
.text:0000381D                 mov     esp, ebp
.text:0000381F                 pop     ebp
.text:00003820                 retn
.text:00003820 ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ endp
.text:00003820
.text:00003820 ; ---------------------------------------------------------------------------
.text:00003821                 align 4
.text:00003821 _text           ends
.text:00003821
.text:00003824 ; ===========================================================================
.text:00003824
.text:00003824 ; Segment type: Pure code
.text:00003824 ; Segment permissions: Read/Execute
.text:00003824 _text           segment para public 'CODE' use32
.text:00003824                 assume cs:_text
.text:00003824                 ;org 3824h
.text:00003824 ; COMDAT (pick any)
.text:00003824                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003824
.text:00003824 ; =============== S U B R O U T I N E =======================================
.text:00003824
.text:00003824 ; Attributes: bp-based frame
.text:00003824
.text:00003824 ; public: __thiscall CMyComPtr<struct ICompressProgressInfo>::operator struct ICompressProgressInfo *(void)const
.text:00003824                 public ??B?$CMyComPtr@UICompressProgressInfo@@@@QBEPAUICompressProgressInfo@@XZ
.text:00003824 ??B?$CMyComPtr@UICompressProgressInfo@@@@QBEPAUICompressProgressInfo@@XZ proc near
.text:00003824                                         ; CODE XREF: NArchive::NSplit::CHandler::Extract(uint const *,uint,int,IArchiveExtractCallback *)+40Fp
.text:00003824
.text:00003824 var_4           = dword ptr -4
.text:00003824
.text:00003824                 push    ebp
.text:00003825                 mov     ebp, esp
.text:00003827                 push    ecx
.text:00003828                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000382F                 mov     [ebp+var_4], ecx
.text:00003832                 mov     eax, [ebp+var_4]
.text:00003835                 mov     eax, [eax]
.text:00003837                 mov     esp, ebp
.text:00003839                 pop     ebp
.text:0000383A                 retn
.text:0000383A ??B?$CMyComPtr@UICompressProgressInfo@@@@QBEPAUICompressProgressInfo@@XZ endp
.text:0000383A
.text:0000383A ; ---------------------------------------------------------------------------
.text:0000383B                 align 4
.text:0000383B _text           ends
.text:0000383B
.text:0000383C ; ===========================================================================
.text:0000383C
.text:0000383C ; Segment type: Pure code
.text:0000383C ; Segment permissions: Read/Execute
.text:0000383C _text           segment para public 'CODE' use32
.text:0000383C                 assume cs:_text
.text:0000383C                 ;org 383Ch
.text:0000383C ; COMDAT (pick any)
.text:0000383C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000383C
.text:0000383C ; =============== S U B R O U T I N E =======================================
.text:0000383C
.text:0000383C ; Attributes: bp-based frame
.text:0000383C
.text:0000383C ; public: __thiscall CMyComPtr<struct ISequentialInStream>::CMyComPtr<struct ISequentialInStream>(void)
.text:0000383C                 public ??0?$CMyComPtr@UISequentialInStream@@@@QAE@XZ
.text:0000383C ??0?$CMyComPtr@UISequentialInStream@@@@QAE@XZ proc near
.text:0000383C                                         ; CODE XREF: NCompress::CCopyCoder::CCopyCoder(void)+79p
.text:0000383C
.text:0000383C var_4           = dword ptr -4
.text:0000383C
.text:0000383C                 push    ebp
.text:0000383D                 mov     ebp, esp
.text:0000383F                 push    ecx
.text:00003840                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003847                 mov     [ebp+var_4], ecx
.text:0000384A                 mov     eax, [ebp+var_4]
.text:0000384D                 mov     dword ptr [eax], 0
.text:00003853                 mov     eax, [ebp+var_4]
.text:00003856                 mov     esp, ebp
.text:00003858                 pop     ebp
.text:00003859                 retn
.text:00003859 ??0?$CMyComPtr@UISequentialInStream@@@@QAE@XZ endp
.text:00003859
.text:00003859 ; ---------------------------------------------------------------------------
.text:0000385A                 align 4
.text:0000385A _text           ends
.text:0000385A
.text:0000385C ; ===========================================================================
.text:0000385C
.text:0000385C ; Segment type: Pure code
.text:0000385C ; Segment permissions: Read/Execute
.text:0000385C _text           segment para public 'CODE' use32
.text:0000385C                 assume cs:_text
.text:0000385C                 ;org 385Ch
.text:0000385C ; COMDAT (pick any)
.text:0000385C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000385C
.text:0000385C ; =============== S U B R O U T I N E =======================================
.text:0000385C
.text:0000385C ; Attributes: bp-based frame
.text:0000385C
.text:0000385C ; public: __thiscall CMyComPtr<struct ISequentialInStream>::CMyComPtr<struct ISequentialInStream>(struct ISequentialInStream *)
.text:0000385C                 public ??0?$CMyComPtr@UISequentialInStream@@@@QAE@PAUISequentialInStream@@@Z
.text:0000385C ??0?$CMyComPtr@UISequentialInStream@@@@QAE@PAUISequentialInStream@@@Z proc near
.text:0000385C                                         ; CODE XREF: NArchive::NSplit::CHandler::GetStream(uint,ISequentialInStream * *)+A9p
.text:0000385C
.text:0000385C var_4           = dword ptr -4
.text:0000385C arg_0           = dword ptr  8
.text:0000385C
.text:0000385C                 push    ebp
.text:0000385D                 mov     ebp, esp
.text:0000385F                 push    ecx
.text:00003860                 push    esi
.text:00003861                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003868                 mov     [ebp+var_4], ecx
.text:0000386B                 mov     eax, [ebp+var_4]
.text:0000386E                 mov     ecx, [ebp+arg_0]
.text:00003871                 mov     [eax], ecx
.text:00003873                 cmp     [ebp+arg_0], 0
.text:00003877                 jz      short loc_3890
.text:00003879                 mov     edx, [ebp+arg_0]
.text:0000387C                 mov     eax, [edx]
.text:0000387E                 mov     esi, esp
.text:00003880                 mov     ecx, [ebp+arg_0]
.text:00003883                 push    ecx
.text:00003884                 mov     edx, [eax+4]
.text:00003887                 call    edx
.text:00003889                 cmp     esi, esp
.text:0000388B                 call    __RTC_CheckEsp
.text:00003890
.text:00003890 loc_3890:                               ; CODE XREF: CMyComPtr<ISequentialInStream>::CMyComPtr<ISequentialInStream>(ISequentialInStream *)+1Bj
.text:00003890                 mov     eax, [ebp+var_4]
.text:00003893                 pop     esi
.text:00003894                 add     esp, 4
.text:00003897                 cmp     ebp, esp
.text:00003899                 call    __RTC_CheckEsp
.text:0000389E                 mov     esp, ebp
.text:000038A0                 pop     ebp
.text:000038A1                 retn    4
.text:000038A1 ??0?$CMyComPtr@UISequentialInStream@@@@QAE@PAUISequentialInStream@@@Z endp
.text:000038A1
.text:000038A1 _text           ends
.text:000038A1
.text:000038A4 ; ===========================================================================
.text:000038A4
.text:000038A4 ; Segment type: Pure code
.text:000038A4 ; Segment permissions: Read/Execute
.text:000038A4 _text           segment para public 'CODE' use32
.text:000038A4                 assume cs:_text
.text:000038A4                 ;org 38A4h
.text:000038A4 ; COMDAT (pick any)
.text:000038A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000038A4
.text:000038A4 ; =============== S U B R O U T I N E =======================================
.text:000038A4
.text:000038A4 ; Attributes: bp-based frame
.text:000038A4
.text:000038A4 ; public: __thiscall CMyComPtr<struct ISequentialInStream>::~CMyComPtr<struct ISequentialInStream>(void)
.text:000038A4                 public ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ
.text:000038A4 ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ proc near
.text:000038A4                                         ; CODE XREF: NArchive::NSplit::CHandler::GetStream(uint,ISequentialInStream * *)+170p
.text:000038A4                                         ; __unwindfunclet$?GetStream@CHandler@NSplit@NArchive@@UAGJIPAPAUISequentialInStream@@@Z$3+3j
.text:000038A4
.text:000038A4 var_4           = dword ptr -4
.text:000038A4
.text:000038A4                 push    ebp
.text:000038A5                 mov     ebp, esp
.text:000038A7                 push    ecx
.text:000038A8                 push    esi
.text:000038A9                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000038B0                 mov     [ebp+var_4], ecx
.text:000038B3                 mov     eax, [ebp+var_4]
.text:000038B6                 cmp     dword ptr [eax], 0
.text:000038B9                 jz      short loc_38D6
.text:000038BB                 mov     ecx, [ebp+var_4]
.text:000038BE                 mov     edx, [ecx]
.text:000038C0                 mov     eax, [ebp+var_4]
.text:000038C3                 mov     ecx, [eax]
.text:000038C5                 mov     edx, [edx]
.text:000038C7                 mov     esi, esp
.text:000038C9                 push    ecx
.text:000038CA                 mov     eax, [edx+8]
.text:000038CD                 call    eax
.text:000038CF                 cmp     esi, esp
.text:000038D1                 call    __RTC_CheckEsp
.text:000038D6
.text:000038D6 loc_38D6:                               ; CODE XREF: CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)+15j
.text:000038D6                 pop     esi
.text:000038D7                 add     esp, 4
.text:000038DA                 cmp     ebp, esp
.text:000038DC                 call    __RTC_CheckEsp
.text:000038E1                 mov     esp, ebp
.text:000038E3                 pop     ebp
.text:000038E4                 retn
.text:000038E4 ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ endp
.text:000038E4
.text:000038E4 ; ---------------------------------------------------------------------------
.text:000038E5                 align 4
.text:000038E5 _text           ends
.text:000038E5
.text:000038E8 ; ===========================================================================
.text:000038E8
.text:000038E8 ; Segment type: Pure code
.text:000038E8 ; Segment permissions: Read/Execute
.text:000038E8 _text           segment para public 'CODE' use32
.text:000038E8                 assume cs:_text
.text:000038E8                 ;org 38E8h
.text:000038E8 ; COMDAT (pick any)
.text:000038E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000038E8
.text:000038E8 ; =============== S U B R O U T I N E =======================================
.text:000038E8
.text:000038E8 ; Attributes: bp-based frame
.text:000038E8
.text:000038E8 ; public: struct ISequentialInStream * __thiscall CMyComPtr<struct ISequentialInStream>::Detach(void)
.text:000038E8                 public ?Detach@?$CMyComPtr@UISequentialInStream@@@@QAEPAUISequentialInStream@@XZ
.text:000038E8 ?Detach@?$CMyComPtr@UISequentialInStream@@@@QAEPAUISequentialInStream@@XZ proc near
.text:000038E8                                         ; CODE XREF: NArchive::NSplit::CHandler::GetStream(uint,ISequentialInStream * *)+152p
.text:000038E8
.text:000038E8 var_8           = dword ptr -8
.text:000038E8 var_4           = dword ptr -4
.text:000038E8
.text:000038E8                 push    ebp
.text:000038E9                 mov     ebp, esp
.text:000038EB                 sub     esp, 8
.text:000038EE                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000038F5                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000038FC                 mov     [ebp+var_4], ecx
.text:000038FF                 mov     eax, [ebp+var_4]
.text:00003902                 mov     ecx, [eax]
.text:00003904                 mov     [ebp+var_8], ecx
.text:00003907                 mov     edx, [ebp+var_4]
.text:0000390A                 mov     dword ptr [edx], 0
.text:00003910                 mov     eax, [ebp+var_8]
.text:00003913                 mov     esp, ebp
.text:00003915                 pop     ebp
.text:00003916                 retn
.text:00003916 ?Detach@?$CMyComPtr@UISequentialInStream@@@@QAEPAUISequentialInStream@@XZ endp
.text:00003916
.text:00003916 ; ---------------------------------------------------------------------------
.text:00003917                 align 4
.text:00003917 _text           ends
.text:00003917
.text:00003918 ; ===========================================================================
.text:00003918
.text:00003918 ; Segment type: Pure code
.text:00003918 ; Segment permissions: Read/Execute
.text:00003918 _text           segment para public 'CODE' use32
.text:00003918                 assume cs:_text
.text:00003918                 ;org 3918h
.text:00003918 ; COMDAT (pick any)
.text:00003918                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003918
.text:00003918 ; =============== S U B R O U T I N E =======================================
.text:00003918
.text:00003918 ; Attributes: bp-based frame
.text:00003918
.text:00003918 ; public: __thiscall CMyComPtr<struct IInStream>::CMyComPtr<struct IInStream>(void)
.text:00003918                 public ??0?$CMyComPtr@UIInStream@@@@QAE@XZ
.text:00003918 ??0?$CMyComPtr@UIInStream@@@@QAE@XZ proc near
.text:00003918                                         ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+7E5p
.text:00003918                                         ; CMultiStream::CSubStreamInfo::CSubStreamInfo(void)+11p
.text:00003918
.text:00003918 var_4           = dword ptr -4
.text:00003918
.text:00003918                 push    ebp
.text:00003919                 mov     ebp, esp
.text:0000391B                 push    ecx
.text:0000391C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003923                 mov     [ebp+var_4], ecx
.text:00003926                 mov     eax, [ebp+var_4]
.text:00003929                 mov     dword ptr [eax], 0
.text:0000392F                 mov     eax, [ebp+var_4]
.text:00003932                 mov     esp, ebp
.text:00003934                 pop     ebp
.text:00003935                 retn
.text:00003935 ??0?$CMyComPtr@UIInStream@@@@QAE@XZ endp
.text:00003935
.text:00003935 ; ---------------------------------------------------------------------------
.text:00003936                 align 4
.text:00003936 _text           ends
.text:00003936
.text:00003938 ; ===========================================================================
.text:00003938
.text:00003938 ; Segment type: Pure code
.text:00003938 ; Segment permissions: Read/Execute
.text:00003938 _text           segment para public 'CODE' use32
.text:00003938                 assume cs:_text
.text:00003938                 ;org 3938h
.text:00003938 ; COMDAT (pick any)
.text:00003938                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003938
.text:00003938 ; =============== S U B R O U T I N E =======================================
.text:00003938
.text:00003938 ; Attributes: bp-based frame
.text:00003938
.text:00003938 ; public: __thiscall CMyComPtr<struct IInStream>::CMyComPtr<struct IInStream>(struct IInStream *)
.text:00003938                 public ??0?$CMyComPtr@UIInStream@@@@QAE@PAUIInStream@@@Z
.text:00003938 ??0?$CMyComPtr@UIInStream@@@@QAE@PAUIInStream@@@Z proc near
.text:00003938                                         ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+6C9p
.text:00003938
.text:00003938 var_4           = dword ptr -4
.text:00003938 arg_0           = dword ptr  8
.text:00003938
.text:00003938                 push    ebp
.text:00003939                 mov     ebp, esp
.text:0000393B                 push    ecx
.text:0000393C                 push    esi
.text:0000393D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003944                 mov     [ebp+var_4], ecx
.text:00003947                 mov     eax, [ebp+var_4]
.text:0000394A                 mov     ecx, [ebp+arg_0]
.text:0000394D                 mov     [eax], ecx
.text:0000394F                 cmp     [ebp+arg_0], 0
.text:00003953                 jz      short loc_396C
.text:00003955                 mov     edx, [ebp+arg_0]
.text:00003958                 mov     eax, [edx]
.text:0000395A                 mov     esi, esp
.text:0000395C                 mov     ecx, [ebp+arg_0]
.text:0000395F                 push    ecx
.text:00003960                 mov     edx, [eax+4]
.text:00003963                 call    edx
.text:00003965                 cmp     esi, esp
.text:00003967                 call    __RTC_CheckEsp
.text:0000396C
.text:0000396C loc_396C:                               ; CODE XREF: CMyComPtr<IInStream>::CMyComPtr<IInStream>(IInStream *)+1Bj
.text:0000396C                 mov     eax, [ebp+var_4]
.text:0000396F                 pop     esi
.text:00003970                 add     esp, 4
.text:00003973                 cmp     ebp, esp
.text:00003975                 call    __RTC_CheckEsp
.text:0000397A                 mov     esp, ebp
.text:0000397C                 pop     ebp
.text:0000397D                 retn    4
.text:0000397D ??0?$CMyComPtr@UIInStream@@@@QAE@PAUIInStream@@@Z endp
.text:0000397D
.text:0000397D _text           ends
.text:0000397D
.text:00003980 ; ===========================================================================
.text:00003980
.text:00003980 ; Segment type: Pure code
.text:00003980 ; Segment permissions: Read/Execute
.text:00003980 _text           segment para public 'CODE' use32
.text:00003980                 assume cs:_text
.text:00003980                 ;org 3980h
.text:00003980 ; COMDAT (pick any)
.text:00003980                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003980
.text:00003980 ; =============== S U B R O U T I N E =======================================
.text:00003980
.text:00003980 ; Attributes: bp-based frame
.text:00003980
.text:00003980 ; public: __thiscall CMyComPtr<struct IInStream>::~CMyComPtr<struct IInStream>(void)
.text:00003980                 public ??1?$CMyComPtr@UIInStream@@@@QAE@XZ
.text:00003980 ??1?$CMyComPtr@UIInStream@@@@QAE@XZ proc near
.text:00003980                                         ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+6EEp
.text:00003980                                         ; NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+84Ap ...
.text:00003980
.text:00003980 var_4           = dword ptr -4
.text:00003980
.text:00003980                 push    ebp
.text:00003981                 mov     ebp, esp
.text:00003983                 push    ecx
.text:00003984                 push    esi
.text:00003985                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000398C                 mov     [ebp+var_4], ecx
.text:0000398F                 mov     eax, [ebp+var_4]
.text:00003992                 cmp     dword ptr [eax], 0
.text:00003995                 jz      short loc_39B2
.text:00003997                 mov     ecx, [ebp+var_4]
.text:0000399A                 mov     edx, [ecx]
.text:0000399C                 mov     eax, [ebp+var_4]
.text:0000399F                 mov     ecx, [eax]
.text:000039A1                 mov     edx, [edx]
.text:000039A3                 mov     esi, esp
.text:000039A5                 push    ecx
.text:000039A6                 mov     eax, [edx+8]
.text:000039A9                 call    eax
.text:000039AB                 cmp     esi, esp
.text:000039AD                 call    __RTC_CheckEsp
.text:000039B2
.text:000039B2 loc_39B2:                               ; CODE XREF: CMyComPtr<IInStream>::~CMyComPtr<IInStream>(void)+15j
.text:000039B2                 pop     esi
.text:000039B3                 add     esp, 4
.text:000039B6                 cmp     ebp, esp
.text:000039B8                 call    __RTC_CheckEsp
.text:000039BD                 mov     esp, ebp
.text:000039BF                 pop     ebp
.text:000039C0                 retn
.text:000039C0 ??1?$CMyComPtr@UIInStream@@@@QAE@XZ endp
.text:000039C0
.text:000039C0 ; ---------------------------------------------------------------------------
.text:000039C1                 align 4
.text:000039C1 _text           ends
.text:000039C1
.text:000039C4 ; ===========================================================================
.text:000039C4
.text:000039C4 ; Segment type: Pure code
.text:000039C4 ; Segment permissions: Read/Execute
.text:000039C4 _text           segment para public 'CODE' use32
.text:000039C4                 assume cs:_text
.text:000039C4                 ;org 39C4h
.text:000039C4 ; COMDAT (pick any)
.text:000039C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000039C4
.text:000039C4 ; =============== S U B R O U T I N E =======================================
.text:000039C4
.text:000039C4 ; Attributes: bp-based frame
.text:000039C4
.text:000039C4 ; public: __thiscall CMyComPtr<struct IInStream>::operator struct IInStream *(void)const
.text:000039C4                 public ??B?$CMyComPtr@UIInStream@@@@QBEPAUIInStream@@XZ
.text:000039C4 ??B?$CMyComPtr@UIInStream@@@@QBEPAUIInStream@@XZ proc near
.text:000039C4                                         ; CODE XREF: NArchive::NSplit::CHandler::Extract(uint const *,uint,int,IArchiveExtractCallback *)+372p
.text:000039C4
.text:000039C4 var_4           = dword ptr -4
.text:000039C4
.text:000039C4                 push    ebp
.text:000039C5                 mov     ebp, esp
.text:000039C7                 push    ecx
.text:000039C8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000039CF                 mov     [ebp+var_4], ecx
.text:000039D2                 mov     eax, [ebp+var_4]
.text:000039D5                 mov     eax, [eax]
.text:000039D7                 mov     esp, ebp
.text:000039D9                 pop     ebp
.text:000039DA                 retn
.text:000039DA ??B?$CMyComPtr@UIInStream@@@@QBEPAUIInStream@@XZ endp
.text:000039DA
.text:000039DA ; ---------------------------------------------------------------------------
.text:000039DB                 align 4
.text:000039DB _text           ends
.text:000039DB
.text:000039DC ; ===========================================================================
.text:000039DC
.text:000039DC ; Segment type: Pure code
.text:000039DC ; Segment permissions: Read/Execute
.text:000039DC _text           segment para public 'CODE' use32
.text:000039DC                 assume cs:_text
.text:000039DC                 ;org 39DCh
.text:000039DC ; COMDAT (pick any)
.text:000039DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000039DC
.text:000039DC ; =============== S U B R O U T I N E =======================================
.text:000039DC
.text:000039DC ; Attributes: bp-based frame
.text:000039DC
.text:000039DC ; public: struct IInStream * * __thiscall CMyComPtr<struct IInStream>::operator&(void)
.text:000039DC                 public ??I?$CMyComPtr@UIInStream@@@@QAEPAPAUIInStream@@XZ
.text:000039DC ??I?$CMyComPtr@UIInStream@@@@QAEPAPAUIInStream@@XZ proc near
.text:000039DC                                         ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+802p
.text:000039DC
.text:000039DC var_4           = dword ptr -4
.text:000039DC
.text:000039DC                 push    ebp
.text:000039DD                 mov     ebp, esp
.text:000039DF                 push    ecx
.text:000039E0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000039E7                 mov     [ebp+var_4], ecx
.text:000039EA                 mov     eax, [ebp+var_4]
.text:000039ED                 mov     esp, ebp
.text:000039EF                 pop     ebp
.text:000039F0                 retn
.text:000039F0 ??I?$CMyComPtr@UIInStream@@@@QAEPAPAUIInStream@@XZ endp
.text:000039F0
.text:000039F0 ; ---------------------------------------------------------------------------
.text:000039F1                 align 4
.text:000039F1 _text           ends
.text:000039F1
.text:000039F4 ; ===========================================================================
.text:000039F4
.text:000039F4 ; Segment type: Pure code
.text:000039F4 ; Segment permissions: Read/Execute
.text:000039F4 _text           segment para public 'CODE' use32
.text:000039F4                 assume cs:_text
.text:000039F4                 ;org 39F4h
.text:000039F4 ; COMDAT (pick any)
.text:000039F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000039F4
.text:000039F4 ; =============== S U B R O U T I N E =======================================
.text:000039F4
.text:000039F4 ; Attributes: bp-based frame
.text:000039F4
.text:000039F4 ; public: struct IInStream * __thiscall CMyComPtr<struct IInStream>::operator->(void)const
.text:000039F4                 public ??C?$CMyComPtr@UIInStream@@@@QBEPAUIInStream@@XZ
.text:000039F4 ??C?$CMyComPtr@UIInStream@@@@QBEPAUIInStream@@XZ proc near
.text:000039F4                                         ; CODE XREF: CMultiStream::Init(void)+9Dp
.text:000039F4
.text:000039F4 var_4           = dword ptr -4
.text:000039F4
.text:000039F4                 push    ebp
.text:000039F5                 mov     ebp, esp
.text:000039F7                 push    ecx
.text:000039F8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000039FF                 mov     [ebp+var_4], ecx
.text:00003A02                 mov     eax, [ebp+var_4]
.text:00003A05                 mov     eax, [eax]
.text:00003A07                 mov     esp, ebp
.text:00003A09                 pop     ebp
.text:00003A0A                 retn
.text:00003A0A ??C?$CMyComPtr@UIInStream@@@@QBEPAUIInStream@@XZ endp
.text:00003A0A
.text:00003A0A ; ---------------------------------------------------------------------------
.text:00003A0B                 align 4
.text:00003A0B _text           ends
.text:00003A0B
.text:00003A0C ; ===========================================================================
.text:00003A0C
.text:00003A0C ; Segment type: Pure code
.text:00003A0C ; Segment permissions: Read/Execute
.text:00003A0C _text           segment para public 'CODE' use32
.text:00003A0C                 assume cs:_text
.text:00003A0C                 ;org 3A0Ch
.text:00003A0C ; COMDAT (pick any)
.text:00003A0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003A0C
.text:00003A0C ; =============== S U B R O U T I N E =======================================
.text:00003A0C
.text:00003A0C ; Attributes: bp-based frame
.text:00003A0C
.text:00003A0C ; public: struct IInStream * __thiscall CMyComPtr<struct IInStream>::operator=(class CMyComPtr<struct IInStream> const &)
.text:00003A0C                 public ??4?$CMyComPtr@UIInStream@@@@QAEPAUIInStream@@ABV0@@Z
.text:00003A0C ??4?$CMyComPtr@UIInStream@@@@QAEPAUIInStream@@ABV0@@Z proc near
.text:00003A0C                                         ; CODE XREF: NArchive::NSplit::CHandler::GetStream(uint,ISequentialInStream * *)+102p
.text:00003A0C
.text:00003A0C var_4           = dword ptr -4
.text:00003A0C arg_0           = dword ptr  8
.text:00003A0C
.text:00003A0C                 push    ebp
.text:00003A0D                 mov     ebp, esp
.text:00003A0F                 push    ecx
.text:00003A10                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003A17                 mov     [ebp+var_4], ecx
.text:00003A1A                 mov     eax, [ebp+arg_0]
.text:00003A1D                 mov     ecx, [eax]
.text:00003A1F                 push    ecx
.text:00003A20                 mov     ecx, [ebp+var_4]
.text:00003A23                 call    ??4?$CMyComPtr@UIInStream@@@@QAEPAUIInStream@@PAU1@@Z ; CMyComPtr<IInStream>::operator=(IInStream *)
.text:00003A28                 add     esp, 4
.text:00003A2B                 cmp     ebp, esp
.text:00003A2D                 call    __RTC_CheckEsp
.text:00003A32                 mov     esp, ebp
.text:00003A34                 pop     ebp
.text:00003A35                 retn    4
.text:00003A35 ??4?$CMyComPtr@UIInStream@@@@QAEPAUIInStream@@ABV0@@Z endp
.text:00003A35
.text:00003A35 _text           ends
.text:00003A35
.text:00003A38 ; ===========================================================================
.text:00003A38
.text:00003A38 ; Segment type: Pure code
.text:00003A38 ; Segment permissions: Read/Execute
.text:00003A38 _text           segment para public 'CODE' use32
.text:00003A38                 assume cs:_text
.text:00003A38                 ;org 3A38h
.text:00003A38 ; COMDAT (pick any)
.text:00003A38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003A38
.text:00003A38 ; =============== S U B R O U T I N E =======================================
.text:00003A38
.text:00003A38 ; Attributes: bp-based frame
.text:00003A38
.text:00003A38 ; public: unsigned int __thiscall CObjectVector<struct CMultiStream::CSubStreamInfo>::Size(void)const
.text:00003A38                 public ?Size@?$CObjectVector@UCSubStreamInfo@CMultiStream@@@@QBEIXZ
.text:00003A38 ?Size@?$CObjectVector@UCSubStreamInfo@CMultiStream@@@@QBEIXZ proc near
.text:00003A38                                         ; CODE XREF: CMultiStream::Init(void)+4Ap
.text:00003A38
.text:00003A38 var_4           = dword ptr -4
.text:00003A38
.text:00003A38                 push    ebp
.text:00003A39                 mov     ebp, esp
.text:00003A3B                 push    ecx
.text:00003A3C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003A43                 mov     [ebp+var_4], ecx
.text:00003A46                 mov     ecx, [ebp+var_4]
.text:00003A49                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00003A4E                 add     esp, 4
.text:00003A51                 cmp     ebp, esp
.text:00003A53                 call    __RTC_CheckEsp
.text:00003A58                 mov     esp, ebp
.text:00003A5A                 pop     ebp
.text:00003A5B                 retn
.text:00003A5B ?Size@?$CObjectVector@UCSubStreamInfo@CMultiStream@@@@QBEIXZ endp
.text:00003A5B
.text:00003A5B _text           ends
.text:00003A5B
.text:00003A5C ; ===========================================================================
.text:00003A5C
.text:00003A5C ; Segment type: Pure code
.text:00003A5C ; Segment permissions: Read/Execute
.text:00003A5C _text           segment para public 'CODE' use32
.text:00003A5C                 assume cs:_text
.text:00003A5C                 ;org 3A5Ch
.text:00003A5C ; COMDAT (pick any)
.text:00003A5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003A5C
.text:00003A5C ; =============== S U B R O U T I N E =======================================
.text:00003A5C
.text:00003A5C ; Attributes: bp-based frame
.text:00003A5C
.text:00003A5C ; public: __thiscall CObjectVector<struct CMultiStream::CSubStreamInfo>::CObjectVector<struct CMultiStream::CSubStreamInfo>(void)
.text:00003A5C                 public ??0?$CObjectVector@UCSubStreamInfo@CMultiStream@@@@QAE@XZ
.text:00003A5C ??0?$CObjectVector@UCSubStreamInfo@CMultiStream@@@@QAE@XZ proc near
.text:00003A5C                                         ; CODE XREF: CMultiStream::CMultiStream(void)+30p
.text:00003A5C
.text:00003A5C var_4           = dword ptr -4
.text:00003A5C
.text:00003A5C                 push    ebp
.text:00003A5D                 mov     ebp, esp
.text:00003A5F                 push    ecx
.text:00003A60                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003A67                 mov     [ebp+var_4], ecx
.text:00003A6A                 mov     ecx, [ebp+var_4]
.text:00003A6D                 call    ??0?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::CRecordVector<void *>(void)
.text:00003A72                 mov     eax, [ebp+var_4]
.text:00003A75                 add     esp, 4
.text:00003A78                 cmp     ebp, esp
.text:00003A7A                 call    __RTC_CheckEsp
.text:00003A7F                 mov     esp, ebp
.text:00003A81                 pop     ebp
.text:00003A82                 retn
.text:00003A82 ??0?$CObjectVector@UCSubStreamInfo@CMultiStream@@@@QAE@XZ endp
.text:00003A82
.text:00003A82 ; ---------------------------------------------------------------------------
.text:00003A83                 align 4
.text:00003A83 _text           ends
.text:00003A83
.text:00003A84 ; ===========================================================================
.text:00003A84
.text:00003A84 ; Segment type: Pure code
.text:00003A84 ; Segment permissions: Read/Execute
.text:00003A84 _text           segment para public 'CODE' use32
.text:00003A84                 assume cs:_text
.text:00003A84                 ;org 3A84h
.text:00003A84 ; COMDAT (pick any)
.text:00003A84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003A84
.text:00003A84 ; =============== S U B R O U T I N E =======================================
.text:00003A84
.text:00003A84 ; Attributes: bp-based frame
.text:00003A84
.text:00003A84 ; public: struct CMultiStream::CSubStreamInfo & __thiscall CObjectVector<struct CMultiStream::CSubStreamInfo>::operator[](unsigned int)
.text:00003A84                 public ??A?$CObjectVector@UCSubStreamInfo@CMultiStream@@@@QAEAAUCSubStreamInfo@CMultiStream@@I@Z
.text:00003A84 ??A?$CObjectVector@UCSubStreamInfo@CMultiStream@@@@QAEAAUCSubStreamInfo@CMultiStream@@I@Z proc near
.text:00003A84                                         ; CODE XREF: CMultiStream::Init(void)+62p
.text:00003A84                                         ; CMultiStream::Init(void)+83p
.text:00003A84
.text:00003A84 var_4           = dword ptr -4
.text:00003A84 arg_0           = dword ptr  8
.text:00003A84
.text:00003A84                 push    ebp
.text:00003A85                 mov     ebp, esp
.text:00003A87                 push    ecx
.text:00003A88                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003A8F                 mov     [ebp+var_4], ecx
.text:00003A92                 mov     eax, [ebp+arg_0]
.text:00003A95                 push    eax
.text:00003A96                 mov     ecx, [ebp+var_4]
.text:00003A99                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00003A9E                 mov     eax, [eax]
.text:00003AA0                 add     esp, 4
.text:00003AA3                 cmp     ebp, esp
.text:00003AA5                 call    __RTC_CheckEsp
.text:00003AAA                 mov     esp, ebp
.text:00003AAC                 pop     ebp
.text:00003AAD                 retn    4
.text:00003AAD ??A?$CObjectVector@UCSubStreamInfo@CMultiStream@@@@QAEAAUCSubStreamInfo@CMultiStream@@I@Z endp
.text:00003AAD
.text:00003AAD _text           ends
.text:00003AAD
.text:00003AB0 ; ===========================================================================
.text:00003AB0
.text:00003AB0 ; Segment type: Pure code
.text:00003AB0 ; Segment permissions: Read/Execute
.text:00003AB0 _text           segment para public 'CODE' use32
.text:00003AB0                 assume cs:_text
.text:00003AB0                 ;org 3AB0h
.text:00003AB0 ; COMDAT (pick any)
.text:00003AB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003AB0
.text:00003AB0 ; =============== S U B R O U T I N E =======================================
.text:00003AB0
.text:00003AB0 ; Attributes: bp-based frame
.text:00003AB0
.text:00003AB0 ; int __stdcall CObjectVector<CMultiStream::CSubStreamInfo>::Add(struct CMultiStream::CSubStreamInfo *)
.text:00003AB0                 public ?Add@?$CObjectVector@UCSubStreamInfo@CMultiStream@@@@QAEIABUCSubStreamInfo@CMultiStream@@@Z
.text:00003AB0 ?Add@?$CObjectVector@UCSubStreamInfo@CMultiStream@@@@QAEIABUCSubStreamInfo@CMultiStream@@@Z proc near
.text:00003AB0                                         ; CODE XREF: NArchive::NSplit::CHandler::GetStream(uint,ISequentialInStream * *)+131p
.text:00003AB0
.text:00003AB0 var_C           = dword ptr -0Ch
.text:00003AB0 var_8           = dword ptr -8
.text:00003AB0 var_4           = dword ptr -4
.text:00003AB0 arg_0           = dword ptr  8
.text:00003AB0
.text:00003AB0                 push    ebp
.text:00003AB1                 mov     ebp, esp
.text:00003AB3                 sub     esp, 0Ch
.text:00003AB6                 mov     [ebp+var_C], 0CCCCCCCCh
.text:00003ABD                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00003AC4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003ACB                 mov     [ebp+var_4], ecx
.text:00003ACE                 push    20h ; ' '       ; unsigned int
.text:00003AD0                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00003AD5                 add     esp, 4
.text:00003AD8                 mov     [ebp+var_8], eax
.text:00003ADB                 cmp     [ebp+var_8], 0
.text:00003ADF                 jz      short loc_3AF2
.text:00003AE1                 mov     eax, [ebp+arg_0]
.text:00003AE4                 push    eax             ; struct CMultiStream::CSubStreamInfo *
.text:00003AE5                 mov     ecx, [ebp+var_8] ; this
.text:00003AE8                 call    ??0CSubStreamInfo@CMultiStream@@QAE@ABU01@@Z ; CMultiStream::CSubStreamInfo::CSubStreamInfo(CMultiStream::CSubStreamInfo const &)
.text:00003AED                 mov     [ebp+var_C], eax
.text:00003AF0                 jmp     short loc_3AF9
.text:00003AF2 ; ---------------------------------------------------------------------------
.text:00003AF2
.text:00003AF2 loc_3AF2:                               ; CODE XREF: CObjectVector<CMultiStream::CSubStreamInfo>::Add(CMultiStream::CSubStreamInfo const &)+2Fj
.text:00003AF2                 mov     [ebp+var_C], 0
.text:00003AF9
.text:00003AF9 loc_3AF9:                               ; CODE XREF: CObjectVector<CMultiStream::CSubStreamInfo>::Add(CMultiStream::CSubStreamInfo const &)+40j
.text:00003AF9                 mov     ecx, [ebp+var_C]
.text:00003AFC                 push    ecx
.text:00003AFD                 mov     ecx, [ebp+var_4]
.text:00003B00                 call    ?Add@?$CRecordVector@PAX@@QAEIQAX@Z ; CRecordVector<void *>::Add(void * const)
.text:00003B05                 add     esp, 0Ch
.text:00003B08                 cmp     ebp, esp
.text:00003B0A                 call    __RTC_CheckEsp
.text:00003B0F                 mov     esp, ebp
.text:00003B11                 pop     ebp
.text:00003B12                 retn    4
.text:00003B12 ?Add@?$CObjectVector@UCSubStreamInfo@CMultiStream@@@@QAEIABUCSubStreamInfo@CMultiStream@@@Z endp
.text:00003B12
.text:00003B12 ; ---------------------------------------------------------------------------
.text:00003B15                 align 4
.text:00003B15 _text           ends
.text:00003B15
.text:00003B18 ; ===========================================================================
.text:00003B18
.text:00003B18 ; Segment type: Pure code
.text:00003B18 ; Segment permissions: Read/Execute
.text:00003B18 _text           segment para public 'CODE' use32
.text:00003B18                 assume cs:_text
.text:00003B18                 ;org 3B18h
.text:00003B18 ; COMDAT (pick any)
.text:00003B18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003B18
.text:00003B18 ; =============== S U B R O U T I N E =======================================
.text:00003B18
.text:00003B18 ; Attributes: bp-based frame
.text:00003B18
.text:00003B18 ; public: __thiscall CObjectVector<struct CMultiStream::CSubStreamInfo>::~CObjectVector<struct CMultiStream::CSubStreamInfo>(void)
.text:00003B18                 public ??1?$CObjectVector@UCSubStreamInfo@CMultiStream@@@@QAE@XZ
.text:00003B18 ??1?$CObjectVector@UCSubStreamInfo@CMultiStream@@@@QAE@XZ proc near
.text:00003B18                                         ; CODE XREF: CMultiStream::~CMultiStream(void)+14p
.text:00003B18
.text:00003B18 var_20          = dword ptr -20h
.text:00003B18 var_1C          = dword ptr -1Ch
.text:00003B18 var_18          = dword ptr -18h
.text:00003B18 var_14          = dword ptr -14h
.text:00003B18 var_10          = dword ptr -10h
.text:00003B18 var_C           = dword ptr -0Ch
.text:00003B18 var_4           = dword ptr -4
.text:00003B18
.text:00003B18                 push    ebp
.text:00003B19                 mov     ebp, esp
.text:00003B1B                 push    0FFFFFFFFh
.text:00003B1D                 push    offset __ehhandler$??1?$CObjectVector@UCSubStreamInfo@CMultiStream@@@@QAE@XZ
.text:00003B22                 mov     eax, large fs:0
.text:00003B28                 push    eax
.text:00003B29                 sub     esp, 14h
.text:00003B2C                 mov     eax, 0CCCCCCCCh
.text:00003B31                 mov     [ebp+var_20], eax
.text:00003B34                 mov     [ebp+var_1C], eax
.text:00003B37                 mov     [ebp+var_18], eax
.text:00003B3A                 mov     [ebp+var_14], eax
.text:00003B3D                 mov     [ebp+var_10], eax
.text:00003B40                 mov     eax, dword ptr ds:___security_cookie
.text:00003B45                 xor     eax, ebp
.text:00003B47                 push    eax
.text:00003B48                 lea     eax, [ebp+var_C]
.text:00003B4B                 mov     large fs:0, eax
.text:00003B51                 mov     [ebp+var_10], ecx
.text:00003B54                 mov     [ebp+var_4], 0
.text:00003B5B                 mov     ecx, [ebp+var_10]
.text:00003B5E                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00003B63                 mov     [ebp+var_14], eax
.text:00003B66
.text:00003B66 loc_3B66:                               ; CODE XREF: CObjectVector<CMultiStream::CSubStreamInfo>::~CObjectVector<CMultiStream::CSubStreamInfo>(void):loc_3BA8j
.text:00003B66                 cmp     [ebp+var_14], 0
.text:00003B6A                 jz      short loc_3BAA
.text:00003B6C                 mov     eax, [ebp+var_14]
.text:00003B6F                 sub     eax, 1
.text:00003B72                 mov     [ebp+var_14], eax
.text:00003B75                 mov     ecx, [ebp+var_14]
.text:00003B78                 push    ecx
.text:00003B79                 mov     ecx, [ebp+var_10]
.text:00003B7C                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00003B81                 mov     edx, [eax]
.text:00003B83                 mov     [ebp+var_1C], edx
.text:00003B86                 mov     eax, [ebp+var_1C]
.text:00003B89                 mov     [ebp+var_18], eax
.text:00003B8C                 cmp     [ebp+var_18], 0
.text:00003B90                 jz      short loc_3BA1
.text:00003B92                 push    1
.text:00003B94                 mov     ecx, [ebp+var_18]
.text:00003B97                 call    ??_GCSubStreamInfo@CMultiStream@@QAEPAXI@Z ; CMultiStream::CSubStreamInfo::`scalar deleting destructor'(uint)
.text:00003B9C                 mov     [ebp+var_20], eax
.text:00003B9F                 jmp     short loc_3BA8
.text:00003BA1 ; ---------------------------------------------------------------------------
.text:00003BA1
.text:00003BA1 loc_3BA1:                               ; CODE XREF: CObjectVector<CMultiStream::CSubStreamInfo>::~CObjectVector<CMultiStream::CSubStreamInfo>(void)+78j
.text:00003BA1                 mov     [ebp+var_20], 0
.text:00003BA8
.text:00003BA8 loc_3BA8:                               ; CODE XREF: CObjectVector<CMultiStream::CSubStreamInfo>::~CObjectVector<CMultiStream::CSubStreamInfo>(void)+87j
.text:00003BA8                 jmp     short loc_3B66
.text:00003BAA ; ---------------------------------------------------------------------------
.text:00003BAA
.text:00003BAA loc_3BAA:                               ; CODE XREF: CObjectVector<CMultiStream::CSubStreamInfo>::~CObjectVector<CMultiStream::CSubStreamInfo>(void)+52j
.text:00003BAA                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00003BB1                 mov     ecx, [ebp+var_10]
.text:00003BB4                 call    ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text:00003BB9                 mov     ecx, [ebp+var_C]
.text:00003BBC                 mov     large fs:0, ecx
.text:00003BC3                 pop     ecx
.text:00003BC4                 add     esp, 20h
.text:00003BC7                 cmp     ebp, esp
.text:00003BC9                 call    __RTC_CheckEsp
.text:00003BCE                 mov     esp, ebp
.text:00003BD0                 pop     ebp
.text:00003BD1                 retn
.text:00003BD1 ??1?$CObjectVector@UCSubStreamInfo@CMultiStream@@@@QAE@XZ endp
.text:00003BD1
.text:00003BD1 ; ---------------------------------------------------------------------------
.text:00003BD2                 align 4
.text:00003BD2 _text           ends
.text:00003BD2
.text$x:00003BD4 ; ===========================================================================
.text$x:00003BD4
.text$x:00003BD4 ; Segment type: Pure code
.text$x:00003BD4 ; Segment permissions: Read/Execute
.text$x:00003BD4 _text$x         segment para public 'CODE' use32
.text$x:00003BD4                 assume cs:_text$x
.text$x:00003BD4                 ;org 3BD4h
.text$x:00003BD4 ; COMDAT (pick associative to section at 3B18)
.text$x:00003BD4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003BD4
.text$x:00003BD4 ; =============== S U B R O U T I N E =======================================
.text$x:00003BD4
.text$x:00003BD4
.text$x:00003BD4 __unwindfunclet$??1?$CObjectVector@UCSubStreamInfo@CMultiStream@@@@QAE@XZ$0 proc near
.text$x:00003BD4                                         ; DATA XREF: .xdata$x:00003BFCo
.text$x:00003BD4                 mov     ecx, [ebp-10h]
.text$x:00003BD7                 jmp     ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text$x:00003BD7 __unwindfunclet$??1?$CObjectVector@UCSubStreamInfo@CMultiStream@@@@QAE@XZ$0 endp
.text$x:00003BD7
.text$x:00003BDC
.text$x:00003BDC ; =============== S U B R O U T I N E =======================================
.text$x:00003BDC
.text$x:00003BDC
.text$x:00003BDC __ehhandler$??1?$CObjectVector@UCSubStreamInfo@CMultiStream@@@@QAE@XZ proc near
.text$x:00003BDC                                         ; DATA XREF: CObjectVector<CMultiStream::CSubStreamInfo>::~CObjectVector<CMultiStream::CSubStreamInfo>(void)+5o
.text$x:00003BDC
.text$x:00003BDC arg_4           = dword ptr  8
.text$x:00003BDC
.text$x:00003BDC                 mov     edx, [esp+arg_4]
.text$x:00003BE0                 lea     eax, [edx+0Ch]
.text$x:00003BE3                 mov     ecx, [edx-18h]
.text$x:00003BE6                 xor     ecx, eax
.text$x:00003BE8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003BED                 mov     eax, offset __ehfuncinfo$??1?$CObjectVector@UCSubStreamInfo@CMultiStream@@@@QAE@XZ
.text$x:00003BF2                 jmp     ___CxxFrameHandler3
.text$x:00003BF2 __ehhandler$??1?$CObjectVector@UCSubStreamInfo@CMultiStream@@@@QAE@XZ endp
.text$x:00003BF2
.text$x:00003BF2 ; ---------------------------------------------------------------------------
.text$x:00003BF7                 align 4
.text$x:00003BF7 _text$x         ends
.text$x:00003BF7
.xdata$x:00003BF8 ; ===========================================================================
.xdata$x:00003BF8
.xdata$x:00003BF8 ; Segment type: Pure data
.xdata$x:00003BF8 ; Segment permissions: Read
.xdata$x:00003BF8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003BF8                 assume cs:_xdata$x
.xdata$x:00003BF8                 ;org 3BF8h
.xdata$x:00003BF8 ; COMDAT (pick associative to section at 3B18)
.xdata$x:00003BF8 __unwindtable$??1?$CObjectVector@UCSubStreamInfo@CMultiStream@@@@QAE@XZ db 0FFh
.xdata$x:00003BF8                                         ; DATA XREF: .xdata$x:00003C08o
.xdata$x:00003BF9                 db 0FFh
.xdata$x:00003BFA                 db 0FFh
.xdata$x:00003BFB                 db 0FFh
.xdata$x:00003BFC                 dd offset __unwindfunclet$??1?$CObjectVector@UCSubStreamInfo@CMultiStream@@@@QAE@XZ$0
.xdata$x:00003C00 __ehfuncinfo$??1?$CObjectVector@UCSubStreamInfo@CMultiStream@@@@QAE@XZ db  22h ; "
.xdata$x:00003C00                                         ; DATA XREF: __ehhandler$??1?$CObjectVector@UCSubStreamInfo@CMultiStream@@@@QAE@XZ+11o
.xdata$x:00003C01                 db    5
.xdata$x:00003C02                 db  93h ; ô
.xdata$x:00003C03                 db  19h
.xdata$x:00003C04                 db    1
.xdata$x:00003C05                 db    0
.xdata$x:00003C06                 db    0
.xdata$x:00003C07                 db    0
.xdata$x:00003C08                 dd offset __unwindtable$??1?$CObjectVector@UCSubStreamInfo@CMultiStream@@@@QAE@XZ
.xdata$x:00003C0C                 align 20h
.xdata$x:00003C20                 db    1
.xdata$x:00003C21                 db    0
.xdata$x:00003C22                 db    0
.xdata$x:00003C23                 db    0
.xdata$x:00003C23 _xdata$x        ends
.xdata$x:00003C23
.text:00003C24 ; ===========================================================================
.text:00003C24
.text:00003C24 ; Segment type: Pure code
.text:00003C24 ; Segment permissions: Read/Execute
.text:00003C24 _text           segment para public 'CODE' use32
.text:00003C24                 assume cs:_text
.text:00003C24                 ;org 3C24h
.text:00003C24 ; COMDAT (pick any)
.text:00003C24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003C24
.text:00003C24 ; =============== S U B R O U T I N E =======================================
.text:00003C24
.text:00003C24 ; Attributes: bp-based frame
.text:00003C24
.text:00003C24 ; public: unsigned int __thiscall CObjectVector<class CMyComPtr<struct IInStream>>::Size(void)const
.text:00003C24                 public ?Size@?$CObjectVector@V?$CMyComPtr@UIInStream@@@@@@QBEIXZ
.text:00003C24 ?Size@?$CObjectVector@V?$CMyComPtr@UIInStream@@@@@@QBEIXZ proc near
.text:00003C24                                         ; CODE XREF: NArchive::NSplit::CHandler::GetArchiveProperty(ulong,tagPROPVARIANT *)+A8p
.text:00003C24                                         ; NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+6F9p ...
.text:00003C24
.text:00003C24 var_4           = dword ptr -4
.text:00003C24
.text:00003C24                 push    ebp
.text:00003C25                 mov     ebp, esp
.text:00003C27                 push    ecx
.text:00003C28                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003C2F                 mov     [ebp+var_4], ecx
.text:00003C32                 mov     ecx, [ebp+var_4]
.text:00003C35                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00003C3A                 add     esp, 4
.text:00003C3D                 cmp     ebp, esp
.text:00003C3F                 call    __RTC_CheckEsp
.text:00003C44                 mov     esp, ebp
.text:00003C46                 pop     ebp
.text:00003C47                 retn
.text:00003C47 ?Size@?$CObjectVector@V?$CMyComPtr@UIInStream@@@@@@QBEIXZ endp
.text:00003C47
.text:00003C47 _text           ends
.text:00003C47
.text:00003C48 ; ===========================================================================
.text:00003C48
.text:00003C48 ; Segment type: Pure code
.text:00003C48 ; Segment permissions: Read/Execute
.text:00003C48 _text           segment para public 'CODE' use32
.text:00003C48                 assume cs:_text
.text:00003C48                 ;org 3C48h
.text:00003C48 ; COMDAT (pick any)
.text:00003C48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003C48
.text:00003C48 ; =============== S U B R O U T I N E =======================================
.text:00003C48
.text:00003C48 ; Attributes: bp-based frame
.text:00003C48
.text:00003C48 ; public: bool __thiscall CObjectVector<class CMyComPtr<struct IInStream>>::IsEmpty(void)const
.text:00003C48                 public ?IsEmpty@?$CObjectVector@V?$CMyComPtr@UIInStream@@@@@@QBE_NXZ
.text:00003C48 ?IsEmpty@?$CObjectVector@V?$CMyComPtr@UIInStream@@@@@@QBE_NXZ proc near
.text:00003C48                                         ; CODE XREF: NArchive::NSplit::CHandler::GetNumberOfItems(uint *)+9p
.text:00003C48
.text:00003C48 var_4           = dword ptr -4
.text:00003C48
.text:00003C48                 push    ebp
.text:00003C49                 mov     ebp, esp
.text:00003C4B                 push    ecx
.text:00003C4C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003C53                 mov     [ebp+var_4], ecx
.text:00003C56                 mov     ecx, [ebp+var_4]
.text:00003C59                 call    ?IsEmpty@?$CRecordVector@PAX@@QBE_NXZ ; CRecordVector<void *>::IsEmpty(void)
.text:00003C5E                 add     esp, 4
.text:00003C61                 cmp     ebp, esp
.text:00003C63                 call    __RTC_CheckEsp
.text:00003C68                 mov     esp, ebp
.text:00003C6A                 pop     ebp
.text:00003C6B                 retn
.text:00003C6B ?IsEmpty@?$CObjectVector@V?$CMyComPtr@UIInStream@@@@@@QBE_NXZ endp
.text:00003C6B
.text:00003C6B _text           ends
.text:00003C6B
.text:00003C6C ; ===========================================================================
.text:00003C6C
.text:00003C6C ; Segment type: Pure code
.text:00003C6C ; Segment permissions: Read/Execute
.text:00003C6C _text           segment para public 'CODE' use32
.text:00003C6C                 assume cs:_text
.text:00003C6C                 ;org 3C6Ch
.text:00003C6C ; COMDAT (pick any)
.text:00003C6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003C6C
.text:00003C6C ; =============== S U B R O U T I N E =======================================
.text:00003C6C
.text:00003C6C ; Attributes: bp-based frame
.text:00003C6C
.text:00003C6C ; public: __thiscall CObjectVector<class CMyComPtr<struct IInStream>>::CObjectVector<class CMyComPtr<struct IInStream>>(void)
.text:00003C6C                 public ??0?$CObjectVector@V?$CMyComPtr@UIInStream@@@@@@QAE@XZ
.text:00003C6C ??0?$CObjectVector@V?$CMyComPtr@UIInStream@@@@@@QAE@XZ proc near
.text:00003C6C                                         ; CODE XREF: NArchive::NSplit::CHandler::CHandler(void)+64p
.text:00003C6C
.text:00003C6C var_4           = dword ptr -4
.text:00003C6C
.text:00003C6C                 push    ebp
.text:00003C6D                 mov     ebp, esp
.text:00003C6F                 push    ecx
.text:00003C70                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003C77                 mov     [ebp+var_4], ecx
.text:00003C7A                 mov     ecx, [ebp+var_4]
.text:00003C7D                 call    ??0?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::CRecordVector<void *>(void)
.text:00003C82                 mov     eax, [ebp+var_4]
.text:00003C85                 add     esp, 4
.text:00003C88                 cmp     ebp, esp
.text:00003C8A                 call    __RTC_CheckEsp
.text:00003C8F                 mov     esp, ebp
.text:00003C91                 pop     ebp
.text:00003C92                 retn
.text:00003C92 ??0?$CObjectVector@V?$CMyComPtr@UIInStream@@@@@@QAE@XZ endp
.text:00003C92
.text:00003C92 ; ---------------------------------------------------------------------------
.text:00003C93                 align 4
.text:00003C93 _text           ends
.text:00003C93
.text:00003C94 ; ===========================================================================
.text:00003C94
.text:00003C94 ; Segment type: Pure code
.text:00003C94 ; Segment permissions: Read/Execute
.text:00003C94 _text           segment para public 'CODE' use32
.text:00003C94                 assume cs:_text
.text:00003C94                 ;org 3C94h
.text:00003C94 ; COMDAT (pick any)
.text:00003C94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003C94
.text:00003C94 ; =============== S U B R O U T I N E =======================================
.text:00003C94
.text:00003C94 ; Attributes: bp-based frame
.text:00003C94
.text:00003C94 ; public: class CMyComPtr<struct IInStream> & __thiscall CObjectVector<class CMyComPtr<struct IInStream>>::operator[](unsigned int)
.text:00003C94                 public ??A?$CObjectVector@V?$CMyComPtr@UIInStream@@@@@@QAEAAV?$CMyComPtr@UIInStream@@@@I@Z
.text:00003C94 ??A?$CObjectVector@V?$CMyComPtr@UIInStream@@@@@@QAEAAV?$CMyComPtr@UIInStream@@@@I@Z proc near
.text:00003C94                                         ; CODE XREF: NArchive::NSplit::CHandler::Extract(uint const *,uint,int,IArchiveExtractCallback *)+361p
.text:00003C94                                         ; NArchive::NSplit::CHandler::GetStream(uint,ISequentialInStream * *)+F3p
.text:00003C94
.text:00003C94 var_4           = dword ptr -4
.text:00003C94 arg_0           = dword ptr  8
.text:00003C94
.text:00003C94                 push    ebp
.text:00003C95                 mov     ebp, esp
.text:00003C97                 push    ecx
.text:00003C98                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003C9F                 mov     [ebp+var_4], ecx
.text:00003CA2                 mov     eax, [ebp+arg_0]
.text:00003CA5                 push    eax
.text:00003CA6                 mov     ecx, [ebp+var_4]
.text:00003CA9                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00003CAE                 mov     eax, [eax]
.text:00003CB0                 add     esp, 4
.text:00003CB3                 cmp     ebp, esp
.text:00003CB5                 call    __RTC_CheckEsp
.text:00003CBA                 mov     esp, ebp
.text:00003CBC                 pop     ebp
.text:00003CBD                 retn    4
.text:00003CBD ??A?$CObjectVector@V?$CMyComPtr@UIInStream@@@@@@QAEAAV?$CMyComPtr@UIInStream@@@@I@Z endp
.text:00003CBD
.text:00003CBD _text           ends
.text:00003CBD
.text:00003CC0 ; ===========================================================================
.text:00003CC0
.text:00003CC0 ; Segment type: Pure code
.text:00003CC0 ; Segment permissions: Read/Execute
.text:00003CC0 _text           segment para public 'CODE' use32
.text:00003CC0                 assume cs:_text
.text:00003CC0                 ;org 3CC0h
.text:00003CC0 ; COMDAT (pick any)
.text:00003CC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003CC0
.text:00003CC0 ; =============== S U B R O U T I N E =======================================
.text:00003CC0
.text:00003CC0 ; Attributes: bp-based frame
.text:00003CC0
.text:00003CC0 ; public: unsigned int __thiscall CObjectVector<class CMyComPtr<struct IInStream>>::Add(class CMyComPtr<struct IInStream> const &)
.text:00003CC0                 public ?Add@?$CObjectVector@V?$CMyComPtr@UIInStream@@@@@@QAEIABV?$CMyComPtr@UIInStream@@@@@Z
.text:00003CC0 ?Add@?$CObjectVector@V?$CMyComPtr@UIInStream@@@@@@QAEIABV?$CMyComPtr@UIInStream@@@@@Z proc near
.text:00003CC0                                         ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+6DFp
.text:00003CC0                                         ; NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+B18p
.text:00003CC0
.text:00003CC0 var_C           = dword ptr -0Ch
.text:00003CC0 var_8           = dword ptr -8
.text:00003CC0 var_4           = dword ptr -4
.text:00003CC0 arg_0           = dword ptr  8
.text:00003CC0
.text:00003CC0                 push    ebp
.text:00003CC1                 mov     ebp, esp
.text:00003CC3                 sub     esp, 0Ch
.text:00003CC6                 mov     [ebp+var_C], 0CCCCCCCCh
.text:00003CCD                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00003CD4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003CDB                 mov     [ebp+var_4], ecx
.text:00003CDE                 push    4               ; unsigned int
.text:00003CE0                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00003CE5                 add     esp, 4
.text:00003CE8                 mov     [ebp+var_8], eax
.text:00003CEB                 cmp     [ebp+var_8], 0
.text:00003CEF                 jz      short loc_3D02
.text:00003CF1                 mov     eax, [ebp+arg_0]
.text:00003CF4                 push    eax
.text:00003CF5                 mov     ecx, [ebp+var_8]
.text:00003CF8                 call    ??0?$CMyComPtr@UIInStream@@@@QAE@ABV0@@Z ; CMyComPtr<IInStream>::CMyComPtr<IInStream>(CMyComPtr<IInStream> const &)
.text:00003CFD                 mov     [ebp+var_C], eax
.text:00003D00                 jmp     short loc_3D09
.text:00003D02 ; ---------------------------------------------------------------------------
.text:00003D02
.text:00003D02 loc_3D02:                               ; CODE XREF: CObjectVector<CMyComPtr<IInStream>>::Add(CMyComPtr<IInStream> const &)+2Fj
.text:00003D02                 mov     [ebp+var_C], 0
.text:00003D09
.text:00003D09 loc_3D09:                               ; CODE XREF: CObjectVector<CMyComPtr<IInStream>>::Add(CMyComPtr<IInStream> const &)+40j
.text:00003D09                 mov     ecx, [ebp+var_C]
.text:00003D0C                 push    ecx
.text:00003D0D                 mov     ecx, [ebp+var_4]
.text:00003D10                 call    ?Add@?$CRecordVector@PAX@@QAEIQAX@Z ; CRecordVector<void *>::Add(void * const)
.text:00003D15                 add     esp, 0Ch
.text:00003D18                 cmp     ebp, esp
.text:00003D1A                 call    __RTC_CheckEsp
.text:00003D1F                 mov     esp, ebp
.text:00003D21                 pop     ebp
.text:00003D22                 retn    4
.text:00003D22 ?Add@?$CObjectVector@V?$CMyComPtr@UIInStream@@@@@@QAEIABV?$CMyComPtr@UIInStream@@@@@Z endp
.text:00003D22
.text:00003D22 ; ---------------------------------------------------------------------------
.text:00003D25                 align 4
.text:00003D25 _text           ends
.text:00003D25
.text:00003D28 ; ===========================================================================
.text:00003D28
.text:00003D28 ; Segment type: Pure code
.text:00003D28 ; Segment permissions: Read/Execute
.text:00003D28 _text           segment para public 'CODE' use32
.text:00003D28                 assume cs:_text
.text:00003D28                 ;org 3D28h
.text:00003D28 ; COMDAT (pick any)
.text:00003D28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003D28
.text:00003D28 ; =============== S U B R O U T I N E =======================================
.text:00003D28
.text:00003D28 ; Attributes: bp-based frame
.text:00003D28
.text:00003D28 ; public: __thiscall CObjectVector<class CMyComPtr<struct IInStream>>::~CObjectVector<class CMyComPtr<struct IInStream>>(void)
.text:00003D28                 public ??1?$CObjectVector@V?$CMyComPtr@UIInStream@@@@@@QAE@XZ
.text:00003D28 ??1?$CObjectVector@V?$CMyComPtr@UIInStream@@@@@@QAE@XZ proc near
.text:00003D28                                         ; CODE XREF: __unwindfunclet$??0CHandler@NSplit@NArchive@@QAE@XZ$0+6j
.text:00003D28                                         ; NArchive::NSplit::CHandler::~CHandler(void)+5Bp ...
.text:00003D28
.text:00003D28 var_20          = dword ptr -20h
.text:00003D28 var_1C          = dword ptr -1Ch
.text:00003D28 var_18          = dword ptr -18h
.text:00003D28 var_14          = dword ptr -14h
.text:00003D28 var_10          = dword ptr -10h
.text:00003D28 var_C           = dword ptr -0Ch
.text:00003D28 var_4           = dword ptr -4
.text:00003D28
.text:00003D28                 push    ebp
.text:00003D29                 mov     ebp, esp
.text:00003D2B                 push    0FFFFFFFFh
.text:00003D2D                 push    offset __ehhandler$??1?$CObjectVector@V?$CMyComPtr@UIInStream@@@@@@QAE@XZ
.text:00003D32                 mov     eax, large fs:0
.text:00003D38                 push    eax
.text:00003D39                 sub     esp, 14h
.text:00003D3C                 mov     eax, 0CCCCCCCCh
.text:00003D41                 mov     [ebp+var_20], eax
.text:00003D44                 mov     [ebp+var_1C], eax
.text:00003D47                 mov     [ebp+var_18], eax
.text:00003D4A                 mov     [ebp+var_14], eax
.text:00003D4D                 mov     [ebp+var_10], eax
.text:00003D50                 mov     eax, dword ptr ds:___security_cookie
.text:00003D55                 xor     eax, ebp
.text:00003D57                 push    eax
.text:00003D58                 lea     eax, [ebp+var_C]
.text:00003D5B                 mov     large fs:0, eax
.text:00003D61                 mov     [ebp+var_10], ecx
.text:00003D64                 mov     [ebp+var_4], 0
.text:00003D6B                 mov     ecx, [ebp+var_10]
.text:00003D6E                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00003D73                 mov     [ebp+var_14], eax
.text:00003D76
.text:00003D76 loc_3D76:                               ; CODE XREF: CObjectVector<CMyComPtr<IInStream>>::~CObjectVector<CMyComPtr<IInStream>>(void):loc_3DB8j
.text:00003D76                 cmp     [ebp+var_14], 0
.text:00003D7A                 jz      short loc_3DBA
.text:00003D7C                 mov     eax, [ebp+var_14]
.text:00003D7F                 sub     eax, 1
.text:00003D82                 mov     [ebp+var_14], eax
.text:00003D85                 mov     ecx, [ebp+var_14]
.text:00003D88                 push    ecx
.text:00003D89                 mov     ecx, [ebp+var_10]
.text:00003D8C                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00003D91                 mov     edx, [eax]
.text:00003D93                 mov     [ebp+var_1C], edx
.text:00003D96                 mov     eax, [ebp+var_1C]
.text:00003D99                 mov     [ebp+var_18], eax
.text:00003D9C                 cmp     [ebp+var_18], 0
.text:00003DA0                 jz      short loc_3DB1
.text:00003DA2                 push    1
.text:00003DA4                 mov     ecx, [ebp+var_18]
.text:00003DA7                 call    ??_G?$CMyComPtr@UIInStream@@@@QAEPAXI@Z ; CMyComPtr<IInStream>::`scalar deleting destructor'(uint)
.text:00003DAC                 mov     [ebp+var_20], eax
.text:00003DAF                 jmp     short loc_3DB8
.text:00003DB1 ; ---------------------------------------------------------------------------
.text:00003DB1
.text:00003DB1 loc_3DB1:                               ; CODE XREF: CObjectVector<CMyComPtr<IInStream>>::~CObjectVector<CMyComPtr<IInStream>>(void)+78j
.text:00003DB1                 mov     [ebp+var_20], 0
.text:00003DB8
.text:00003DB8 loc_3DB8:                               ; CODE XREF: CObjectVector<CMyComPtr<IInStream>>::~CObjectVector<CMyComPtr<IInStream>>(void)+87j
.text:00003DB8                 jmp     short loc_3D76
.text:00003DBA ; ---------------------------------------------------------------------------
.text:00003DBA
.text:00003DBA loc_3DBA:                               ; CODE XREF: CObjectVector<CMyComPtr<IInStream>>::~CObjectVector<CMyComPtr<IInStream>>(void)+52j
.text:00003DBA                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00003DC1                 mov     ecx, [ebp+var_10]
.text:00003DC4                 call    ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text:00003DC9                 mov     ecx, [ebp+var_C]
.text:00003DCC                 mov     large fs:0, ecx
.text:00003DD3                 pop     ecx
.text:00003DD4                 add     esp, 20h
.text:00003DD7                 cmp     ebp, esp
.text:00003DD9                 call    __RTC_CheckEsp
.text:00003DDE                 mov     esp, ebp
.text:00003DE0                 pop     ebp
.text:00003DE1                 retn
.text:00003DE1 ??1?$CObjectVector@V?$CMyComPtr@UIInStream@@@@@@QAE@XZ endp
.text:00003DE1
.text:00003DE1 ; ---------------------------------------------------------------------------
.text:00003DE2                 align 4
.text:00003DE2 _text           ends
.text:00003DE2
.text$x:00003DE4 ; ===========================================================================
.text$x:00003DE4
.text$x:00003DE4 ; Segment type: Pure code
.text$x:00003DE4 ; Segment permissions: Read/Execute
.text$x:00003DE4 _text$x         segment para public 'CODE' use32
.text$x:00003DE4                 assume cs:_text$x
.text$x:00003DE4                 ;org 3DE4h
.text$x:00003DE4 ; COMDAT (pick associative to section at 3D28)
.text$x:00003DE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003DE4
.text$x:00003DE4 ; =============== S U B R O U T I N E =======================================
.text$x:00003DE4
.text$x:00003DE4
.text$x:00003DE4 __unwindfunclet$??1?$CObjectVector@V?$CMyComPtr@UIInStream@@@@@@QAE@XZ$0 proc near
.text$x:00003DE4                                         ; DATA XREF: .xdata$x:00003E0Co
.text$x:00003DE4                 mov     ecx, [ebp-10h]
.text$x:00003DE7                 jmp     ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text$x:00003DE7 __unwindfunclet$??1?$CObjectVector@V?$CMyComPtr@UIInStream@@@@@@QAE@XZ$0 endp
.text$x:00003DE7
.text$x:00003DEC
.text$x:00003DEC ; =============== S U B R O U T I N E =======================================
.text$x:00003DEC
.text$x:00003DEC
.text$x:00003DEC __ehhandler$??1?$CObjectVector@V?$CMyComPtr@UIInStream@@@@@@QAE@XZ proc near
.text$x:00003DEC                                         ; DATA XREF: CObjectVector<CMyComPtr<IInStream>>::~CObjectVector<CMyComPtr<IInStream>>(void)+5o
.text$x:00003DEC
.text$x:00003DEC arg_4           = dword ptr  8
.text$x:00003DEC
.text$x:00003DEC                 mov     edx, [esp+arg_4]
.text$x:00003DF0                 lea     eax, [edx+0Ch]
.text$x:00003DF3                 mov     ecx, [edx-18h]
.text$x:00003DF6                 xor     ecx, eax
.text$x:00003DF8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003DFD                 mov     eax, offset __ehfuncinfo$??1?$CObjectVector@V?$CMyComPtr@UIInStream@@@@@@QAE@XZ
.text$x:00003E02                 jmp     ___CxxFrameHandler3
.text$x:00003E02 __ehhandler$??1?$CObjectVector@V?$CMyComPtr@UIInStream@@@@@@QAE@XZ endp
.text$x:00003E02
.text$x:00003E02 ; ---------------------------------------------------------------------------
.text$x:00003E07                 align 4
.text$x:00003E07 _text$x         ends
.text$x:00003E07
.xdata$x:00003E08 ; ===========================================================================
.xdata$x:00003E08
.xdata$x:00003E08 ; Segment type: Pure data
.xdata$x:00003E08 ; Segment permissions: Read
.xdata$x:00003E08 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003E08                 assume cs:_xdata$x
.xdata$x:00003E08                 ;org 3E08h
.xdata$x:00003E08 ; COMDAT (pick associative to section at 3D28)
.xdata$x:00003E08 __unwindtable$??1?$CObjectVector@V?$CMyComPtr@UIInStream@@@@@@QAE@XZ db 0FFh
.xdata$x:00003E08                                         ; DATA XREF: .xdata$x:00003E18o
.xdata$x:00003E09                 db 0FFh
.xdata$x:00003E0A                 db 0FFh
.xdata$x:00003E0B                 db 0FFh
.xdata$x:00003E0C                 dd offset __unwindfunclet$??1?$CObjectVector@V?$CMyComPtr@UIInStream@@@@@@QAE@XZ$0
.xdata$x:00003E10 __ehfuncinfo$??1?$CObjectVector@V?$CMyComPtr@UIInStream@@@@@@QAE@XZ db  22h ; "
.xdata$x:00003E10                                         ; DATA XREF: __ehhandler$??1?$CObjectVector@V?$CMyComPtr@UIInStream@@@@@@QAE@XZ+11o
.xdata$x:00003E11                 db    5
.xdata$x:00003E12                 db  93h ; ô
.xdata$x:00003E13                 db  19h
.xdata$x:00003E14                 db    1
.xdata$x:00003E15                 db    0
.xdata$x:00003E16                 db    0
.xdata$x:00003E17                 db    0
.xdata$x:00003E18                 dd offset __unwindtable$??1?$CObjectVector@V?$CMyComPtr@UIInStream@@@@@@QAE@XZ
.xdata$x:00003E1C                 db    0
.xdata$x:00003E1D                 db    0
.xdata$x:00003E1E                 db    0
.xdata$x:00003E1F                 db    0
.xdata$x:00003E20                 db    0
.xdata$x:00003E21                 db    0
.xdata$x:00003E22                 db    0
.xdata$x:00003E23                 db    0
.xdata$x:00003E24                 db    0
.xdata$x:00003E25                 db    0
.xdata$x:00003E26                 db    0
.xdata$x:00003E27                 db    0
.xdata$x:00003E28                 db    0
.xdata$x:00003E29                 db    0
.xdata$x:00003E2A                 db    0
.xdata$x:00003E2B                 db    0
.xdata$x:00003E2C                 db    0
.xdata$x:00003E2D                 db    0
.xdata$x:00003E2E                 db    0
.xdata$x:00003E2F                 db    0
.xdata$x:00003E30                 db    1
.xdata$x:00003E31                 db    0
.xdata$x:00003E32                 db    0
.xdata$x:00003E33                 db    0
.xdata$x:00003E33 _xdata$x        ends
.xdata$x:00003E33
.text:00003E34 ; ===========================================================================
.text:00003E34
.text:00003E34 ; Segment type: Pure code
.text:00003E34 ; Segment permissions: Read/Execute
.text:00003E34 _text           segment para public 'CODE' use32
.text:00003E34                 assume cs:_text
.text:00003E34                 ;org 3E34h
.text:00003E34 ; COMDAT (pick any)
.text:00003E34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003E34
.text:00003E34 ; =============== S U B R O U T I N E =======================================
.text:00003E34
.text:00003E34 ; Attributes: bp-based frame
.text:00003E34
.text:00003E34 ; public: void __thiscall CObjectVector<class CMyComPtr<struct IInStream>>::Clear(void)
.text:00003E34                 public ?Clear@?$CObjectVector@V?$CMyComPtr@UIInStream@@@@@@QAEXXZ
.text:00003E34 ?Clear@?$CObjectVector@V?$CMyComPtr@UIInStream@@@@@@QAEXXZ proc near
.text:00003E34                                         ; CODE XREF: NArchive::NSplit::CHandler::Close(void)+25p
.text:00003E34
.text:00003E34 var_14          = dword ptr -14h
.text:00003E34 var_10          = dword ptr -10h
.text:00003E34 var_C           = dword ptr -0Ch
.text:00003E34 var_8           = dword ptr -8
.text:00003E34 var_4           = dword ptr -4
.text:00003E34
.text:00003E34                 push    ebp
.text:00003E35                 mov     ebp, esp
.text:00003E37                 sub     esp, 14h
.text:00003E3A                 mov     eax, 0CCCCCCCCh
.text:00003E3F                 mov     [ebp+var_14], eax
.text:00003E42                 mov     [ebp+var_10], eax
.text:00003E45                 mov     [ebp+var_C], eax
.text:00003E48                 mov     [ebp+var_8], eax
.text:00003E4B                 mov     [ebp+var_4], eax
.text:00003E4E                 mov     [ebp+var_4], ecx
.text:00003E51                 mov     ecx, [ebp+var_4]
.text:00003E54                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00003E59                 mov     [ebp+var_8], eax
.text:00003E5C
.text:00003E5C loc_3E5C:                               ; CODE XREF: CObjectVector<CMyComPtr<IInStream>>::Clear(void):loc_3E9Ej
.text:00003E5C                 cmp     [ebp+var_8], 0
.text:00003E60                 jz      short loc_3EA0
.text:00003E62                 mov     eax, [ebp+var_8]
.text:00003E65                 sub     eax, 1
.text:00003E68                 mov     [ebp+var_8], eax
.text:00003E6B                 mov     ecx, [ebp+var_8]
.text:00003E6E                 push    ecx
.text:00003E6F                 mov     ecx, [ebp+var_4]
.text:00003E72                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00003E77                 mov     edx, [eax]
.text:00003E79                 mov     [ebp+var_10], edx
.text:00003E7C                 mov     eax, [ebp+var_10]
.text:00003E7F                 mov     [ebp+var_C], eax
.text:00003E82                 cmp     [ebp+var_C], 0
.text:00003E86                 jz      short loc_3E97
.text:00003E88                 push    1
.text:00003E8A                 mov     ecx, [ebp+var_C]
.text:00003E8D                 call    ??_G?$CMyComPtr@UIInStream@@@@QAEPAXI@Z ; CMyComPtr<IInStream>::`scalar deleting destructor'(uint)
.text:00003E92                 mov     [ebp+var_14], eax
.text:00003E95                 jmp     short loc_3E9E
.text:00003E97 ; ---------------------------------------------------------------------------
.text:00003E97
.text:00003E97 loc_3E97:                               ; CODE XREF: CObjectVector<CMyComPtr<IInStream>>::Clear(void)+52j
.text:00003E97                 mov     [ebp+var_14], 0
.text:00003E9E
.text:00003E9E loc_3E9E:                               ; CODE XREF: CObjectVector<CMyComPtr<IInStream>>::Clear(void)+61j
.text:00003E9E                 jmp     short loc_3E5C
.text:00003EA0 ; ---------------------------------------------------------------------------
.text:00003EA0
.text:00003EA0 loc_3EA0:                               ; CODE XREF: CObjectVector<CMyComPtr<IInStream>>::Clear(void)+2Cj
.text:00003EA0                 mov     ecx, [ebp+var_4]
.text:00003EA3                 call    ?Clear@?$CRecordVector@PAX@@QAEXXZ ; CRecordVector<void *>::Clear(void)
.text:00003EA8                 add     esp, 14h
.text:00003EAB                 cmp     ebp, esp
.text:00003EAD                 call    __RTC_CheckEsp
.text:00003EB2                 mov     esp, ebp
.text:00003EB4                 pop     ebp
.text:00003EB5                 retn
.text:00003EB5 ?Clear@?$CObjectVector@V?$CMyComPtr@UIInStream@@@@@@QAEXXZ endp
.text:00003EB5
.text:00003EB5 ; ---------------------------------------------------------------------------
.text:00003EB6                 align 4
.text:00003EB6 _text           ends
.text:00003EB6
.text:00003EB8 ; ===========================================================================
.text:00003EB8
.text:00003EB8 ; Segment type: Pure code
.text:00003EB8 ; Segment permissions: Read/Execute
.text:00003EB8 _text           segment para public 'CODE' use32
.text:00003EB8                 assume cs:_text
.text:00003EB8                 ;org 3EB8h
.text:00003EB8 ; COMDAT (pick any)
.text:00003EB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003EB8
.text:00003EB8 ; =============== S U B R O U T I N E =======================================
.text:00003EB8
.text:00003EB8 ; Attributes: bp-based frame
.text:00003EB8
.text:00003EB8 ; public: __thiscall CRecordVector<unsigned __int64>::CRecordVector<unsigned __int64>(void)
.text:00003EB8                 public ??0?$CRecordVector@_K@@QAE@XZ
.text:00003EB8 ??0?$CRecordVector@_K@@QAE@XZ proc near ; CODE XREF: NArchive::NSplit::CHandler::CHandler(void)+76p
.text:00003EB8
.text:00003EB8 var_4           = dword ptr -4
.text:00003EB8
.text:00003EB8                 push    ebp
.text:00003EB9                 mov     ebp, esp
.text:00003EBB                 push    ecx
.text:00003EBC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003EC3                 mov     [ebp+var_4], ecx
.text:00003EC6                 mov     eax, [ebp+var_4]
.text:00003EC9                 mov     dword ptr [eax], 0
.text:00003ECF                 mov     ecx, [ebp+var_4]
.text:00003ED2                 mov     dword ptr [ecx+4], 0
.text:00003ED9                 mov     edx, [ebp+var_4]
.text:00003EDC                 mov     dword ptr [edx+8], 0
.text:00003EE3                 mov     eax, [ebp+var_4]
.text:00003EE6                 mov     esp, ebp
.text:00003EE8                 pop     ebp
.text:00003EE9                 retn
.text:00003EE9 ??0?$CRecordVector@_K@@QAE@XZ endp
.text:00003EE9
.text:00003EE9 ; ---------------------------------------------------------------------------
.text:00003EEA                 align 4
.text:00003EEA _text           ends
.text:00003EEA
.text:00003EEC ; ===========================================================================
.text:00003EEC
.text:00003EEC ; Segment type: Pure code
.text:00003EEC ; Segment permissions: Read/Execute
.text:00003EEC _text           segment para public 'CODE' use32
.text:00003EEC                 assume cs:_text
.text:00003EEC                 ;org 3EECh
.text:00003EEC ; COMDAT (pick any)
.text:00003EEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003EEC
.text:00003EEC ; =============== S U B R O U T I N E =======================================
.text:00003EEC
.text:00003EEC ; Attributes: bp-based frame
.text:00003EEC
.text:00003EEC ; public: bool __thiscall CRecordVector<unsigned __int64>::IsEmpty(void)const
.text:00003EEC                 public ?IsEmpty@?$CRecordVector@_K@@QBE_NXZ
.text:00003EEC ?IsEmpty@?$CRecordVector@_K@@QBE_NXZ proc near
.text:00003EEC                                         ; CODE XREF: NArchive::NSplit::CHandler::GetArchiveProperty(ulong,tagPROPVARIANT *)+63p
.text:00003EEC
.text:00003EEC var_4           = dword ptr -4
.text:00003EEC
.text:00003EEC                 push    ebp
.text:00003EED                 mov     ebp, esp
.text:00003EEF                 push    ecx
.text:00003EF0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003EF7                 mov     [ebp+var_4], ecx
.text:00003EFA                 mov     eax, [ebp+var_4]
.text:00003EFD                 xor     ecx, ecx
.text:00003EFF                 cmp     dword ptr [eax+4], 0
.text:00003F03                 setz    cl
.text:00003F06                 mov     al, cl
.text:00003F08                 mov     esp, ebp
.text:00003F0A                 pop     ebp
.text:00003F0B                 retn
.text:00003F0B ?IsEmpty@?$CRecordVector@_K@@QBE_NXZ endp
.text:00003F0B
.text:00003F0B _text           ends
.text:00003F0B
.text:00003F0C ; ===========================================================================
.text:00003F0C
.text:00003F0C ; Segment type: Pure code
.text:00003F0C ; Segment permissions: Read/Execute
.text:00003F0C _text           segment para public 'CODE' use32
.text:00003F0C                 assume cs:_text
.text:00003F0C                 ;org 3F0Ch
.text:00003F0C ; COMDAT (pick any)
.text:00003F0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003F0C
.text:00003F0C ; =============== S U B R O U T I N E =======================================
.text:00003F0C
.text:00003F0C ; Attributes: bp-based frame
.text:00003F0C
.text:00003F0C ; public: __thiscall CRecordVector<unsigned __int64>::~CRecordVector<unsigned __int64>(void)
.text:00003F0C                 public ??1?$CRecordVector@_K@@QAE@XZ
.text:00003F0C ??1?$CRecordVector@_K@@QAE@XZ proc near ; CODE XREF: __unwindfunclet$??0CHandler@NSplit@NArchive@@QAE@XZ$1+6j
.text:00003F0C                                         ; NArchive::NSplit::CHandler::~CHandler(void)+49p ...
.text:00003F0C
.text:00003F0C var_8           = dword ptr -8
.text:00003F0C var_4           = dword ptr -4
.text:00003F0C
.text:00003F0C                 push    ebp
.text:00003F0D                 mov     ebp, esp
.text:00003F0F                 sub     esp, 8
.text:00003F12                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00003F19                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003F20                 mov     [ebp+var_4], ecx
.text:00003F23                 mov     eax, [ebp+var_4]
.text:00003F26                 mov     ecx, [eax]
.text:00003F28                 mov     [ebp+var_8], ecx
.text:00003F2B                 mov     edx, [ebp+var_8]
.text:00003F2E                 push    edx             ; void *
.text:00003F2F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00003F34                 add     esp, 4
.text:00003F37                 add     esp, 8
.text:00003F3A                 cmp     ebp, esp
.text:00003F3C                 call    __RTC_CheckEsp
.text:00003F41                 mov     esp, ebp
.text:00003F43                 pop     ebp
.text:00003F44                 retn
.text:00003F44 ??1?$CRecordVector@_K@@QAE@XZ endp
.text:00003F44
.text:00003F44 ; ---------------------------------------------------------------------------
.text:00003F45                 align 4
.text:00003F45 _text           ends
.text:00003F45
.text:00003F48 ; ===========================================================================
.text:00003F48
.text:00003F48 ; Segment type: Pure code
.text:00003F48 ; Segment permissions: Read/Execute
.text:00003F48 _text           segment para public 'CODE' use32
.text:00003F48                 assume cs:_text
.text:00003F48                 ;org 3F48h
.text:00003F48 ; COMDAT (pick any)
.text:00003F48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003F48
.text:00003F48 ; =============== S U B R O U T I N E =======================================
.text:00003F48
.text:00003F48 ; Attributes: bp-based frame
.text:00003F48
.text:00003F48 ; public: void __thiscall CRecordVector<unsigned __int64>::Clear(void)
.text:00003F48                 public ?Clear@?$CRecordVector@_K@@QAEXXZ
.text:00003F48 ?Clear@?$CRecordVector@_K@@QAEXXZ proc near
.text:00003F48                                         ; CODE XREF: NArchive::NSplit::CHandler::Close(void)+30p
.text:00003F48
.text:00003F48 var_4           = dword ptr -4
.text:00003F48
.text:00003F48                 push    ebp
.text:00003F49                 mov     ebp, esp
.text:00003F4B                 push    ecx
.text:00003F4C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003F53                 mov     [ebp+var_4], ecx
.text:00003F56                 mov     eax, [ebp+var_4]
.text:00003F59                 mov     dword ptr [eax+4], 0
.text:00003F60                 mov     esp, ebp
.text:00003F62                 pop     ebp
.text:00003F63                 retn
.text:00003F63 ?Clear@?$CRecordVector@_K@@QAEXXZ endp
.text:00003F63
.text:00003F63 _text           ends
.text:00003F63
.text:00003F64 ; ===========================================================================
.text:00003F64
.text:00003F64 ; Segment type: Pure code
.text:00003F64 ; Segment permissions: Read/Execute
.text:00003F64 _text           segment para public 'CODE' use32
.text:00003F64                 assume cs:_text
.text:00003F64                 ;org 3F64h
.text:00003F64 ; COMDAT (pick any)
.text:00003F64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003F64
.text:00003F64 ; =============== S U B R O U T I N E =======================================
.text:00003F64
.text:00003F64 ; Attributes: bp-based frame
.text:00003F64
.text:00003F64 ; public: unsigned int __thiscall CRecordVector<unsigned __int64>::Add(unsigned __int64)
.text:00003F64                 public ?Add@?$CRecordVector@_K@@QAEI_K@Z
.text:00003F64 ?Add@?$CRecordVector@_K@@QAEI_K@Z proc near
.text:00003F64                                         ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+6BAp
.text:00003F64                                         ; NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+B06p
.text:00003F64
.text:00003F64 var_8           = dword ptr -8
.text:00003F64 var_4           = dword ptr -4
.text:00003F64 arg_0           = dword ptr  8
.text:00003F64 arg_4           = dword ptr  0Ch
.text:00003F64
.text:00003F64                 push    ebp
.text:00003F65                 mov     ebp, esp
.text:00003F67                 sub     esp, 8
.text:00003F6A                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00003F71                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003F78                 mov     [ebp+var_4], ecx
.text:00003F7B                 mov     ecx, [ebp+var_4]
.text:00003F7E                 call    ?ReserveOnePosition@?$CRecordVector@_K@@AAEXXZ ; CRecordVector<unsigned __int64>::ReserveOnePosition(void)
.text:00003F83                 mov     eax, [ebp+var_4]
.text:00003F86                 mov     ecx, [eax+4]
.text:00003F89                 mov     edx, [ebp+var_4]
.text:00003F8C                 mov     eax, [edx]
.text:00003F8E                 mov     edx, [ebp+arg_0]
.text:00003F91                 mov     [eax+ecx*8], edx
.text:00003F94                 mov     edx, [ebp+arg_4]
.text:00003F97                 mov     [eax+ecx*8+4], edx
.text:00003F9B                 mov     eax, [ebp+var_4]
.text:00003F9E                 mov     ecx, [eax+4]
.text:00003FA1                 mov     [ebp+var_8], ecx
.text:00003FA4                 mov     edx, [ebp+var_4]
.text:00003FA7                 mov     eax, [edx+4]
.text:00003FAA                 add     eax, 1
.text:00003FAD                 mov     ecx, [ebp+var_4]
.text:00003FB0                 mov     [ecx+4], eax
.text:00003FB3                 mov     eax, [ebp+var_8]
.text:00003FB6                 add     esp, 8
.text:00003FB9                 cmp     ebp, esp
.text:00003FBB                 call    __RTC_CheckEsp
.text:00003FC0                 mov     esp, ebp
.text:00003FC2                 pop     ebp
.text:00003FC3                 retn    8
.text:00003FC3 ?Add@?$CRecordVector@_K@@QAEI_K@Z endp
.text:00003FC3
.text:00003FC3 ; ---------------------------------------------------------------------------
.text:00003FC6                 align 4
.text:00003FC6 _text           ends
.text:00003FC6
.text:00003FC8 ; ===========================================================================
.text:00003FC8
.text:00003FC8 ; Segment type: Pure code
.text:00003FC8 ; Segment permissions: Read/Execute
.text:00003FC8 _text           segment para public 'CODE' use32
.text:00003FC8                 assume cs:_text
.text:00003FC8                 ;org 3FC8h
.text:00003FC8 ; COMDAT (pick any)
.text:00003FC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003FC8
.text:00003FC8 ; =============== S U B R O U T I N E =======================================
.text:00003FC8
.text:00003FC8 ; Attributes: bp-based frame
.text:00003FC8
.text:00003FC8 ; public: unsigned __int64 & __thiscall CRecordVector<unsigned __int64>::operator[](unsigned int)
.text:00003FC8                 public ??A?$CRecordVector@_K@@QAEAA_KI@Z
.text:00003FC8 ??A?$CRecordVector@_K@@QAEAA_KI@Z proc near
.text:00003FC8                                         ; CODE XREF: NArchive::NSplit::CHandler::GetArchiveProperty(ulong,tagPROPVARIANT *)+77p
.text:00003FC8                                         ; NArchive::NSplit::CHandler::GetStream(uint,ISequentialInStream * *)+111p
.text:00003FC8
.text:00003FC8 var_4           = dword ptr -4
.text:00003FC8 arg_0           = dword ptr  8
.text:00003FC8
.text:00003FC8                 push    ebp
.text:00003FC9                 mov     ebp, esp
.text:00003FCB                 push    ecx
.text:00003FCC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003FD3                 mov     [ebp+var_4], ecx
.text:00003FD6                 mov     eax, [ebp+var_4]
.text:00003FD9                 mov     ecx, [eax]
.text:00003FDB                 mov     edx, [ebp+arg_0]
.text:00003FDE                 lea     eax, [ecx+edx*8]
.text:00003FE1                 mov     esp, ebp
.text:00003FE3                 pop     ebp
.text:00003FE4                 retn    4
.text:00003FE4 ??A?$CRecordVector@_K@@QAEAA_KI@Z endp
.text:00003FE4
.text:00003FE4 ; ---------------------------------------------------------------------------
.text:00003FE7                 align 4
.text:00003FE7 _text           ends
.text:00003FE7
.text:00003FE8 ; ===========================================================================
.text:00003FE8
.text:00003FE8 ; Segment type: Pure code
.text:00003FE8 ; Segment permissions: Read/Execute
.text:00003FE8 _text           segment para public 'CODE' use32
.text:00003FE8                 assume cs:_text
.text:00003FE8                 ;org 3FE8h
.text:00003FE8 ; COMDAT (pick any)
.text:00003FE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003FE8
.text:00003FE8 ; =============== S U B R O U T I N E =======================================
.text:00003FE8
.text:00003FE8 ; Attributes: bp-based frame
.text:00003FE8
.text:00003FE8 ; public: __thiscall CMyComPtr<struct IArchiveOpenVolumeCallback>::CMyComPtr<struct IArchiveOpenVolumeCallback>(void)
.text:00003FE8                 public ??0?$CMyComPtr@UIArchiveOpenVolumeCallback@@@@QAE@XZ
.text:00003FE8 ??0?$CMyComPtr@UIArchiveOpenVolumeCallback@@@@QAE@XZ proc near
.text:00003FE8                                         ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+6Bp
.text:00003FE8
.text:00003FE8 var_4           = dword ptr -4
.text:00003FE8
.text:00003FE8                 push    ebp
.text:00003FE9                 mov     ebp, esp
.text:00003FEB                 push    ecx
.text:00003FEC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003FF3                 mov     [ebp+var_4], ecx
.text:00003FF6                 mov     eax, [ebp+var_4]
.text:00003FF9                 mov     dword ptr [eax], 0
.text:00003FFF                 mov     eax, [ebp+var_4]
.text:00004002                 mov     esp, ebp
.text:00004004                 pop     ebp
.text:00004005                 retn
.text:00004005 ??0?$CMyComPtr@UIArchiveOpenVolumeCallback@@@@QAE@XZ endp
.text:00004005
.text:00004005 ; ---------------------------------------------------------------------------
.text:00004006                 align 4
.text:00004006 _text           ends
.text:00004006
.text:00004008 ; ===========================================================================
.text:00004008
.text:00004008 ; Segment type: Pure code
.text:00004008 ; Segment permissions: Read/Execute
.text:00004008 _text           segment para public 'CODE' use32
.text:00004008                 assume cs:_text
.text:00004008                 ;org 4008h
.text:00004008 ; COMDAT (pick any)
.text:00004008                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004008
.text:00004008 ; =============== S U B R O U T I N E =======================================
.text:00004008
.text:00004008 ; Attributes: bp-based frame
.text:00004008
.text:00004008 ; public: __thiscall CMyComPtr<struct IArchiveOpenVolumeCallback>::~CMyComPtr<struct IArchiveOpenVolumeCallback>(void)
.text:00004008                 public ??1?$CMyComPtr@UIArchiveOpenVolumeCallback@@@@QAE@XZ
.text:00004008 ??1?$CMyComPtr@UIArchiveOpenVolumeCallback@@@@QAE@XZ proc near
.text:00004008                                         ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+BEp
.text:00004008                                         ; NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+14Bp ...
.text:00004008
.text:00004008 var_4           = dword ptr -4
.text:00004008
.text:00004008                 push    ebp
.text:00004009                 mov     ebp, esp
.text:0000400B                 push    ecx
.text:0000400C                 push    esi
.text:0000400D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00004014                 mov     [ebp+var_4], ecx
.text:00004017                 mov     eax, [ebp+var_4]
.text:0000401A                 cmp     dword ptr [eax], 0
.text:0000401D                 jz      short loc_403A
.text:0000401F                 mov     ecx, [ebp+var_4]
.text:00004022                 mov     edx, [ecx]
.text:00004024                 mov     eax, [ebp+var_4]
.text:00004027                 mov     ecx, [eax]
.text:00004029                 mov     edx, [edx]
.text:0000402B                 mov     esi, esp
.text:0000402D                 push    ecx
.text:0000402E                 mov     eax, [edx+8]
.text:00004031                 call    eax
.text:00004033                 cmp     esi, esp
.text:00004035                 call    __RTC_CheckEsp
.text:0000403A
.text:0000403A loc_403A:                               ; CODE XREF: CMyComPtr<IArchiveOpenVolumeCallback>::~CMyComPtr<IArchiveOpenVolumeCallback>(void)+15j
.text:0000403A                 pop     esi
.text:0000403B                 add     esp, 4
.text:0000403E                 cmp     ebp, esp
.text:00004040                 call    __RTC_CheckEsp
.text:00004045                 mov     esp, ebp
.text:00004047                 pop     ebp
.text:00004048                 retn
.text:00004048 ??1?$CMyComPtr@UIArchiveOpenVolumeCallback@@@@QAE@XZ endp
.text:00004048
.text:00004048 ; ---------------------------------------------------------------------------
.text:00004049                 align 4
.text:00004049 _text           ends
.text:00004049
.text:0000404C ; ===========================================================================
.text:0000404C
.text:0000404C ; Segment type: Pure code
.text:0000404C ; Segment permissions: Read/Execute
.text:0000404C _text           segment para public 'CODE' use32
.text:0000404C                 assume cs:_text
.text:0000404C                 ;org 404Ch
.text:0000404C ; COMDAT (pick any)
.text:0000404C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000404C
.text:0000404C ; =============== S U B R O U T I N E =======================================
.text:0000404C
.text:0000404C ; Attributes: bp-based frame
.text:0000404C
.text:0000404C ; public: struct IArchiveOpenVolumeCallback * * __thiscall CMyComPtr<struct IArchiveOpenVolumeCallback>::operator&(void)
.text:0000404C                 public ??I?$CMyComPtr@UIArchiveOpenVolumeCallback@@@@QAEPAPAUIArchiveOpenVolumeCallback@@XZ
.text:0000404C ??I?$CMyComPtr@UIArchiveOpenVolumeCallback@@@@QAEPAPAUIArchiveOpenVolumeCallback@@XZ proc near
.text:0000404C                                         ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+7Ap
.text:0000404C
.text:0000404C var_4           = dword ptr -4
.text:0000404C
.text:0000404C                 push    ebp
.text:0000404D                 mov     ebp, esp
.text:0000404F                 push    ecx
.text:00004050                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00004057                 mov     [ebp+var_4], ecx
.text:0000405A                 mov     eax, [ebp+var_4]
.text:0000405D                 mov     esp, ebp
.text:0000405F                 pop     ebp
.text:00004060                 retn
.text:00004060 ??I?$CMyComPtr@UIArchiveOpenVolumeCallback@@@@QAEPAPAUIArchiveOpenVolumeCallback@@XZ endp
.text:00004060
.text:00004060 ; ---------------------------------------------------------------------------
.text:00004061                 align 4
.text:00004061 _text           ends
.text:00004061
.text:00004064 ; ===========================================================================
.text:00004064
.text:00004064 ; Segment type: Pure code
.text:00004064 ; Segment permissions: Read/Execute
.text:00004064 _text           segment para public 'CODE' use32
.text:00004064                 assume cs:_text
.text:00004064                 ;org 4064h
.text:00004064 ; COMDAT (pick any)
.text:00004064                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004064
.text:00004064 ; =============== S U B R O U T I N E =======================================
.text:00004064
.text:00004064 ; Attributes: bp-based frame
.text:00004064
.text:00004064 ; public: struct IArchiveOpenVolumeCallback * __thiscall CMyComPtr<struct IArchiveOpenVolumeCallback>::operator->(void)const
.text:00004064                 public ??C?$CMyComPtr@UIArchiveOpenVolumeCallback@@@@QBEPAUIArchiveOpenVolumeCallback@@XZ
.text:00004064 ??C?$CMyComPtr@UIArchiveOpenVolumeCallback@@@@QBEPAUIArchiveOpenVolumeCallback@@XZ proc near
.text:00004064                                         ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+E9p
.text:00004064                                         ; NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+529p ...
.text:00004064
.text:00004064 var_4           = dword ptr -4
.text:00004064
.text:00004064                 push    ebp
.text:00004065                 mov     ebp, esp
.text:00004067                 push    ecx
.text:00004068                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000406F                 mov     [ebp+var_4], ecx
.text:00004072                 mov     eax, [ebp+var_4]
.text:00004075                 mov     eax, [eax]
.text:00004077                 mov     esp, ebp
.text:00004079                 pop     ebp
.text:0000407A                 retn
.text:0000407A ??C?$CMyComPtr@UIArchiveOpenVolumeCallback@@@@QBEPAUIArchiveOpenVolumeCallback@@XZ endp
.text:0000407A
.text:0000407A ; ---------------------------------------------------------------------------
.text:0000407B                 align 4
.text:0000407B _text           ends
.text:0000407B
.text:0000407C ; ===========================================================================
.text:0000407C
.text:0000407C ; Segment type: Pure code
.text:0000407C ; Segment permissions: Read/Execute
.text:0000407C _text           segment para public 'CODE' use32
.text:0000407C                 assume cs:_text
.text:0000407C                 ;org 407Ch
.text:0000407C ; COMDAT (pick any)
.text:0000407C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000407C
.text:0000407C ; =============== S U B R O U T I N E =======================================
.text:0000407C
.text:0000407C ; Attributes: bp-based frame
.text:0000407C
.text:0000407C ; public: bool __thiscall CMyComPtr<struct IArchiveOpenVolumeCallback>::operator!(void)const
.text:0000407C                 public ??7?$CMyComPtr@UIArchiveOpenVolumeCallback@@@@QBE_NXZ
.text:0000407C ??7?$CMyComPtr@UIArchiveOpenVolumeCallback@@@@QBE_NXZ proc near
.text:0000407C                                         ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+9Ep
.text:0000407C
.text:0000407C var_4           = dword ptr -4
.text:0000407C
.text:0000407C                 push    ebp
.text:0000407D                 mov     ebp, esp
.text:0000407F                 push    ecx
.text:00004080                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00004087                 mov     [ebp+var_4], ecx
.text:0000408A                 mov     eax, [ebp+var_4]
.text:0000408D                 xor     ecx, ecx
.text:0000408F                 cmp     dword ptr [eax], 0
.text:00004092                 setz    cl
.text:00004095                 mov     al, cl
.text:00004097                 mov     esp, ebp
.text:00004099                 pop     ebp
.text:0000409A                 retn
.text:0000409A ??7?$CMyComPtr@UIArchiveOpenVolumeCallback@@@@QBE_NXZ endp
.text:0000409A
.text:0000409A ; ---------------------------------------------------------------------------
.text:0000409B                 align 4
.text:0000409B _text           ends
.text:0000409B
.text:0000409C ; ===========================================================================
.text:0000409C
.text:0000409C ; Segment type: Pure code
.text:0000409C ; Segment permissions: Read/Execute
.text:0000409C _text           segment para public 'CODE' use32
.text:0000409C                 assume cs:_text
.text:0000409C                 ;org 409Ch
.text:0000409C ; COMDAT (pick any)
.text:0000409C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000409C
.text:0000409C ; =============== S U B R O U T I N E =======================================
.text:0000409C
.text:0000409C ; Attributes: bp-based frame
.text:0000409C
.text:0000409C ; public: __thiscall CMyComPtr<struct ISequentialOutStream>::CMyComPtr<struct ISequentialOutStream>(void)
.text:0000409C                 public ??0?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ
.text:0000409C ??0?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ proc near
.text:0000409C                                         ; CODE XREF: NArchive::NSplit::CHandler::Extract(uint const *,uint,int,IArchiveExtractCallback *)+C3p
.text:0000409C
.text:0000409C var_4           = dword ptr -4
.text:0000409C
.text:0000409C                 push    ebp
.text:0000409D                 mov     ebp, esp
.text:0000409F                 push    ecx
.text:000040A0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000040A7                 mov     [ebp+var_4], ecx
.text:000040AA                 mov     eax, [ebp+var_4]
.text:000040AD                 mov     dword ptr [eax], 0
.text:000040B3                 mov     eax, [ebp+var_4]
.text:000040B6                 mov     esp, ebp
.text:000040B8                 pop     ebp
.text:000040B9                 retn
.text:000040B9 ??0?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ endp
.text:000040B9
.text:000040B9 ; ---------------------------------------------------------------------------
.text:000040BA                 align 4
.text:000040BA _text           ends
.text:000040BA
.text:000040BC ; ===========================================================================
.text:000040BC
.text:000040BC ; Segment type: Pure code
.text:000040BC ; Segment permissions: Read/Execute
.text:000040BC _text           segment para public 'CODE' use32
.text:000040BC                 assume cs:_text
.text:000040BC                 ;org 40BCh
.text:000040BC ; COMDAT (pick any)
.text:000040BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000040BC
.text:000040BC ; =============== S U B R O U T I N E =======================================
.text:000040BC
.text:000040BC ; Attributes: bp-based frame
.text:000040BC
.text:000040BC ; public: __thiscall CMyComPtr<struct ISequentialOutStream>::~CMyComPtr<struct ISequentialOutStream>(void)
.text:000040BC                 public ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ
.text:000040BC ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ proc near
.text:000040BC                                         ; CODE XREF: NArchive::NSplit::CHandler::Extract(uint const *,uint,int,IArchiveExtractCallback *)+132p
.text:000040BC                                         ; NArchive::NSplit::CHandler::Extract(uint const *,uint,int,IArchiveExtractCallback *)+16Cp ...
.text:000040BC
.text:000040BC var_4           = dword ptr -4
.text:000040BC
.text:000040BC                 push    ebp
.text:000040BD                 mov     ebp, esp
.text:000040BF                 push    ecx
.text:000040C0                 push    esi
.text:000040C1                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000040C8                 mov     [ebp+var_4], ecx
.text:000040CB                 mov     eax, [ebp+var_4]
.text:000040CE                 cmp     dword ptr [eax], 0
.text:000040D1                 jz      short loc_40EE
.text:000040D3                 mov     ecx, [ebp+var_4]
.text:000040D6                 mov     edx, [ecx]
.text:000040D8                 mov     eax, [ebp+var_4]
.text:000040DB                 mov     ecx, [eax]
.text:000040DD                 mov     edx, [edx]
.text:000040DF                 mov     esi, esp
.text:000040E1                 push    ecx
.text:000040E2                 mov     eax, [edx+8]
.text:000040E5                 call    eax
.text:000040E7                 cmp     esi, esp
.text:000040E9                 call    __RTC_CheckEsp
.text:000040EE
.text:000040EE loc_40EE:                               ; CODE XREF: CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)+15j
.text:000040EE                 pop     esi
.text:000040EF                 add     esp, 4
.text:000040F2                 cmp     ebp, esp
.text:000040F4                 call    __RTC_CheckEsp
.text:000040F9                 mov     esp, ebp
.text:000040FB                 pop     ebp
.text:000040FC                 retn
.text:000040FC ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ endp
.text:000040FC
.text:000040FC ; ---------------------------------------------------------------------------
.text:000040FD                 align 10h
.text:000040FD _text           ends
.text:000040FD
.text:00004100 ; ===========================================================================
.text:00004100
.text:00004100 ; Segment type: Pure code
.text:00004100 ; Segment permissions: Read/Execute
.text:00004100 _text           segment para public 'CODE' use32
.text:00004100                 assume cs:_text
.text:00004100                 ;org 4100h
.text:00004100 ; COMDAT (pick any)
.text:00004100                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004100
.text:00004100 ; =============== S U B R O U T I N E =======================================
.text:00004100
.text:00004100 ; Attributes: bp-based frame
.text:00004100
.text:00004100 ; public: void __thiscall CMyComPtr<struct ISequentialOutStream>::Release(void)
.text:00004100                 public ?Release@?$CMyComPtr@UISequentialOutStream@@@@QAEXXZ
.text:00004100 ?Release@?$CMyComPtr@UISequentialOutStream@@@@QAEXXZ proc near
.text:00004100                                         ; CODE XREF: NArchive::NSplit::CHandler::Extract(uint const *,uint,int,IArchiveExtractCallback *)+4C5p
.text:00004100
.text:00004100 var_4           = dword ptr -4
.text:00004100
.text:00004100                 push    ebp
.text:00004101                 mov     ebp, esp
.text:00004103                 push    ecx
.text:00004104                 push    esi
.text:00004105                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000410C                 mov     [ebp+var_4], ecx
.text:0000410F                 mov     eax, [ebp+var_4]
.text:00004112                 cmp     dword ptr [eax], 0
.text:00004115                 jz      short loc_413B
.text:00004117                 mov     ecx, [ebp+var_4]
.text:0000411A                 mov     edx, [ecx]
.text:0000411C                 mov     eax, [ebp+var_4]
.text:0000411F                 mov     ecx, [eax]
.text:00004121                 mov     edx, [edx]
.text:00004123                 mov     esi, esp
.text:00004125                 push    ecx
.text:00004126                 mov     eax, [edx+8]
.text:00004129                 call    eax
.text:0000412B                 cmp     esi, esp
.text:0000412D                 call    __RTC_CheckEsp
.text:00004132                 mov     ecx, [ebp+var_4]
.text:00004135                 mov     dword ptr [ecx], 0
.text:0000413B
.text:0000413B loc_413B:                               ; CODE XREF: CMyComPtr<ISequentialOutStream>::Release(void)+15j
.text:0000413B                 pop     esi
.text:0000413C                 add     esp, 4
.text:0000413F                 cmp     ebp, esp
.text:00004141                 call    __RTC_CheckEsp
.text:00004146                 mov     esp, ebp
.text:00004148                 pop     ebp
.text:00004149                 retn
.text:00004149 ?Release@?$CMyComPtr@UISequentialOutStream@@@@QAEXXZ endp
.text:00004149
.text:00004149 ; ---------------------------------------------------------------------------
.text:0000414A                 align 4
.text:0000414A _text           ends
.text:0000414A
.text:0000414C ; ===========================================================================
.text:0000414C
.text:0000414C ; Segment type: Pure code
.text:0000414C ; Segment permissions: Read/Execute
.text:0000414C _text           segment para public 'CODE' use32
.text:0000414C                 assume cs:_text
.text:0000414C                 ;org 414Ch
.text:0000414C ; COMDAT (pick any)
.text:0000414C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000414C
.text:0000414C ; =============== S U B R O U T I N E =======================================
.text:0000414C
.text:0000414C ; Attributes: bp-based frame
.text:0000414C
.text:0000414C ; public: __thiscall CMyComPtr<struct ISequentialOutStream>::operator struct ISequentialOutStream *(void)const
.text:0000414C                 public ??B?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ
.text:0000414C ??B?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ proc near
.text:0000414C                                         ; CODE XREF: NArchive::NSplit::CHandler::Extract(uint const *,uint,int,IArchiveExtractCallback *)+41Dp
.text:0000414C
.text:0000414C var_4           = dword ptr -4
.text:0000414C
.text:0000414C                 push    ebp
.text:0000414D                 mov     ebp, esp
.text:0000414F                 push    ecx
.text:00004150                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00004157                 mov     [ebp+var_4], ecx
.text:0000415A                 mov     eax, [ebp+var_4]
.text:0000415D                 mov     eax, [eax]
.text:0000415F                 mov     esp, ebp
.text:00004161                 pop     ebp
.text:00004162                 retn
.text:00004162 ??B?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ endp
.text:00004162
.text:00004162 ; ---------------------------------------------------------------------------
.text:00004163                 align 4
.text:00004163 _text           ends
.text:00004163
.text:00004164 ; ===========================================================================
.text:00004164
.text:00004164 ; Segment type: Pure code
.text:00004164 ; Segment permissions: Read/Execute
.text:00004164 _text           segment para public 'CODE' use32
.text:00004164                 assume cs:_text
.text:00004164                 ;org 4164h
.text:00004164 ; COMDAT (pick any)
.text:00004164                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004164
.text:00004164 ; =============== S U B R O U T I N E =======================================
.text:00004164
.text:00004164 ; Attributes: bp-based frame
.text:00004164
.text:00004164 ; public: struct ISequentialOutStream * * __thiscall CMyComPtr<struct ISequentialOutStream>::operator&(void)
.text:00004164                 public ??I?$CMyComPtr@UISequentialOutStream@@@@QAEPAPAUISequentialOutStream@@XZ
.text:00004164 ??I?$CMyComPtr@UISequentialOutStream@@@@QAEPAPAUISequentialOutStream@@XZ proc near
.text:00004164                                         ; CODE XREF: NArchive::NSplit::CHandler::Extract(uint const *,uint,int,IArchiveExtractCallback *)+E1p
.text:00004164
.text:00004164 var_4           = dword ptr -4
.text:00004164
.text:00004164                 push    ebp
.text:00004165                 mov     ebp, esp
.text:00004167                 push    ecx
.text:00004168                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000416F                 mov     [ebp+var_4], ecx
.text:00004172                 mov     eax, [ebp+var_4]
.text:00004175                 mov     esp, ebp
.text:00004177                 pop     ebp
.text:00004178                 retn
.text:00004178 ??I?$CMyComPtr@UISequentialOutStream@@@@QAEPAPAUISequentialOutStream@@XZ endp
.text:00004178
.text:00004178 ; ---------------------------------------------------------------------------
.text:00004179                 align 4
.text:00004179 _text           ends
.text:00004179
.text:0000417C ; ===========================================================================
.text:0000417C
.text:0000417C ; Segment type: Pure code
.text:0000417C ; Segment permissions: Read/Execute
.text:0000417C _text           segment para public 'CODE' use32
.text:0000417C                 assume cs:_text
.text:0000417C                 ;org 417Ch
.text:0000417C ; COMDAT (pick any)
.text:0000417C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000417C
.text:0000417C ; =============== S U B R O U T I N E =======================================
.text:0000417C
.text:0000417C ; Attributes: bp-based frame
.text:0000417C
.text:0000417C ; public: bool __thiscall CMyComPtr<struct ISequentialOutStream>::operator!(void)const
.text:0000417C                 public ??7?$CMyComPtr@UISequentialOutStream@@@@QBE_NXZ
.text:0000417C ??7?$CMyComPtr@UISequentialOutStream@@@@QBE_NXZ proc near
.text:0000417C                                         ; CODE XREF: NArchive::NSplit::CHandler::Extract(uint const *,uint,int,IArchiveExtractCallback *)+148p
.text:0000417C
.text:0000417C var_4           = dword ptr -4
.text:0000417C
.text:0000417C                 push    ebp
.text:0000417D                 mov     ebp, esp
.text:0000417F                 push    ecx
.text:00004180                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00004187                 mov     [ebp+var_4], ecx
.text:0000418A                 mov     eax, [ebp+var_4]
.text:0000418D                 xor     ecx, ecx
.text:0000418F                 cmp     dword ptr [eax], 0
.text:00004192                 setz    cl
.text:00004195                 mov     al, cl
.text:00004197                 mov     esp, ebp
.text:00004199                 pop     ebp
.text:0000419A                 retn
.text:0000419A ??7?$CMyComPtr@UISequentialOutStream@@@@QBE_NXZ endp
.text:0000419A
.text:0000419A ; ---------------------------------------------------------------------------
.text:0000419B                 align 4
.text:0000419B _text           ends
.text:0000419B
.text:0000419C ; ===========================================================================
.text:0000419C
.text:0000419C ; Segment type: Pure code
.text:0000419C ; Segment permissions: Read/Execute
.text:0000419C _text           segment para public 'CODE' use32
.text:0000419C                 assume cs:_text
.text:0000419C                 ;org 419Ch
.text:0000419C ; COMDAT (pick any)
.text:0000419C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000419C
.text:0000419C ; =============== S U B R O U T I N E =======================================
.text:0000419C
.text:0000419C ; Attributes: bp-based frame
.text:0000419C
.text:0000419C ; public: __thiscall CMyComPtr<struct ICompressCoder>::CMyComPtr<struct ICompressCoder>(struct ICompressCoder *)
.text:0000419C                 public ??0?$CMyComPtr@UICompressCoder@@@@QAE@PAUICompressCoder@@@Z
.text:0000419C ??0?$CMyComPtr@UICompressCoder@@@@QAE@PAUICompressCoder@@@Z proc near
.text:0000419C                                         ; CODE XREF: NArchive::NSplit::CHandler::Extract(uint const *,uint,int,IArchiveExtractCallback *)+226p
.text:0000419C
.text:0000419C var_4           = dword ptr -4
.text:0000419C arg_0           = dword ptr  8
.text:0000419C
.text:0000419C                 push    ebp
.text:0000419D                 mov     ebp, esp
.text:0000419F                 push    ecx
.text:000041A0                 push    esi
.text:000041A1                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000041A8                 mov     [ebp+var_4], ecx
.text:000041AB                 mov     eax, [ebp+var_4]
.text:000041AE                 mov     ecx, [ebp+arg_0]
.text:000041B1                 mov     [eax], ecx
.text:000041B3                 cmp     [ebp+arg_0], 0
.text:000041B7                 jz      short loc_41D0
.text:000041B9                 mov     edx, [ebp+arg_0]
.text:000041BC                 mov     eax, [edx]
.text:000041BE                 mov     esi, esp
.text:000041C0                 mov     ecx, [ebp+arg_0]
.text:000041C3                 push    ecx
.text:000041C4                 mov     edx, [eax+4]
.text:000041C7                 call    edx
.text:000041C9                 cmp     esi, esp
.text:000041CB                 call    __RTC_CheckEsp
.text:000041D0
.text:000041D0 loc_41D0:                               ; CODE XREF: CMyComPtr<ICompressCoder>::CMyComPtr<ICompressCoder>(ICompressCoder *)+1Bj
.text:000041D0                 mov     eax, [ebp+var_4]
.text:000041D3                 pop     esi
.text:000041D4                 add     esp, 4
.text:000041D7                 cmp     ebp, esp
.text:000041D9                 call    __RTC_CheckEsp
.text:000041DE                 mov     esp, ebp
.text:000041E0                 pop     ebp
.text:000041E1                 retn    4
.text:000041E1 ??0?$CMyComPtr@UICompressCoder@@@@QAE@PAUICompressCoder@@@Z endp
.text:000041E1
.text:000041E1 _text           ends
.text:000041E1
.text:000041E4 ; ===========================================================================
.text:000041E4
.text:000041E4 ; Segment type: Pure code
.text:000041E4 ; Segment permissions: Read/Execute
.text:000041E4 _text           segment para public 'CODE' use32
.text:000041E4                 assume cs:_text
.text:000041E4                 ;org 41E4h
.text:000041E4 ; COMDAT (pick any)
.text:000041E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000041E4
.text:000041E4 ; =============== S U B R O U T I N E =======================================
.text:000041E4
.text:000041E4 ; Attributes: bp-based frame
.text:000041E4
.text:000041E4 ; public: __thiscall CMyComPtr<struct ICompressCoder>::~CMyComPtr<struct ICompressCoder>(void)
.text:000041E4                 public ??1?$CMyComPtr@UICompressCoder@@@@QAE@XZ
.text:000041E4 ??1?$CMyComPtr@UICompressCoder@@@@QAE@XZ proc near
.text:000041E4                                         ; CODE XREF: NArchive::NSplit::CHandler::Extract(uint const *,uint,int,IArchiveExtractCallback *)+33Bp
.text:000041E4                                         ; NArchive::NSplit::CHandler::Extract(uint const *,uint,int,IArchiveExtractCallback *)+3D6p ...
.text:000041E4
.text:000041E4 var_4           = dword ptr -4
.text:000041E4
.text:000041E4                 push    ebp
.text:000041E5                 mov     ebp, esp
.text:000041E7                 push    ecx
.text:000041E8                 push    esi
.text:000041E9                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000041F0                 mov     [ebp+var_4], ecx
.text:000041F3                 mov     eax, [ebp+var_4]
.text:000041F6                 cmp     dword ptr [eax], 0
.text:000041F9                 jz      short loc_4216
.text:000041FB                 mov     ecx, [ebp+var_4]
.text:000041FE                 mov     edx, [ecx]
.text:00004200                 mov     eax, [ebp+var_4]
.text:00004203                 mov     ecx, [eax]
.text:00004205                 mov     edx, [edx]
.text:00004207                 mov     esi, esp
.text:00004209                 push    ecx
.text:0000420A                 mov     eax, [edx+8]
.text:0000420D                 call    eax
.text:0000420F                 cmp     esi, esp
.text:00004211                 call    __RTC_CheckEsp
.text:00004216
.text:00004216 loc_4216:                               ; CODE XREF: CMyComPtr<ICompressCoder>::~CMyComPtr<ICompressCoder>(void)+15j
.text:00004216                 pop     esi
.text:00004217                 add     esp, 4
.text:0000421A                 cmp     ebp, esp
.text:0000421C                 call    __RTC_CheckEsp
.text:00004221                 mov     esp, ebp
.text:00004223                 pop     ebp
.text:00004224                 retn
.text:00004224 ??1?$CMyComPtr@UICompressCoder@@@@QAE@XZ endp
.text:00004224
.text:00004224 ; ---------------------------------------------------------------------------
.text:00004225                 align 4
.text:00004225 _text           ends
.text:00004225
.text:00004228 ; ===========================================================================
.text:00004228
.text:00004228 ; Segment type: Pure code
.text:00004228 ; Segment permissions: Read/Execute
.text:00004228 _text           segment para public 'CODE' use32
.text:00004228                 assume cs:_text
.text:00004228                 ;org 4228h
.text:00004228 ; COMDAT (pick any)
.text:00004228                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004228
.text:00004228 ; =============== S U B R O U T I N E =======================================
.text:00004228
.text:00004228 ; Attributes: bp-based frame
.text:00004228
.text:00004228 ; public: struct ICompressCoder * __thiscall CMyComPtr<struct ICompressCoder>::operator->(void)const
.text:00004228                 public ??C?$CMyComPtr@UICompressCoder@@@@QBEPAUICompressCoder@@XZ
.text:00004228 ??C?$CMyComPtr@UICompressCoder@@@@QBEPAUICompressCoder@@XZ proc near
.text:00004228                                         ; CODE XREF: NArchive::NSplit::CHandler::Extract(uint const *,uint,int,IArchiveExtractCallback *)+3F5p
.text:00004228
.text:00004228 var_4           = dword ptr -4
.text:00004228
.text:00004228                 push    ebp
.text:00004229                 mov     ebp, esp
.text:0000422B                 push    ecx
.text:0000422C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00004233                 mov     [ebp+var_4], ecx
.text:00004236                 mov     eax, [ebp+var_4]
.text:00004239                 mov     eax, [eax]
.text:0000423B                 mov     esp, ebp
.text:0000423D                 pop     ebp
.text:0000423E                 retn
.text:0000423E ??C?$CMyComPtr@UICompressCoder@@@@QBEPAUICompressCoder@@XZ endp
.text:0000423E
.text:0000423E ; ---------------------------------------------------------------------------
.text:0000423F                 align 10h
.text:0000423F _text           ends
.text:0000423F
.text:00004240 ; ===========================================================================
.text:00004240
.text:00004240 ; Segment type: Pure code
.text:00004240 ; Segment permissions: Read/Execute
.text:00004240 _text           segment para public 'CODE' use32
.text:00004240                 assume cs:_text
.text:00004240                 ;org 4240h
.text:00004240 ; COMDAT (pick any)
.text:00004240                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004240
.text:00004240 ; =============== S U B R O U T I N E =======================================
.text:00004240
.text:00004240 ; Attributes: bp-based frame
.text:00004240
.text:00004240 ; _DWORD __thiscall CMultiStream::CSubStreamInfo::CSubStreamInfo(CMultiStream::CSubStreamInfo *this, const struct CMultiStream::CSubStreamInfo *)
.text:00004240                 public ??0CSubStreamInfo@CMultiStream@@QAE@ABU01@@Z
.text:00004240 ??0CSubStreamInfo@CMultiStream@@QAE@ABU01@@Z proc near
.text:00004240                                         ; CODE XREF: CObjectVector<CMultiStream::CSubStreamInfo>::Add(CMultiStream::CSubStreamInfo const &)+38p
.text:00004240
.text:00004240 var_4           = dword ptr -4
.text:00004240 arg_0           = dword ptr  8
.text:00004240
.text:00004240                 push    ebp
.text:00004241                 mov     ebp, esp
.text:00004243                 push    ecx
.text:00004244                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000424B                 mov     [ebp+var_4], ecx
.text:0000424E                 mov     eax, [ebp+arg_0]
.text:00004251                 push    eax
.text:00004252                 mov     ecx, [ebp+var_4]
.text:00004255                 call    ??0?$CMyComPtr@UIInStream@@@@QAE@ABV0@@Z ; CMyComPtr<IInStream>::CMyComPtr<IInStream>(CMyComPtr<IInStream> const &)
.text:0000425A                 mov     ecx, [ebp+var_4]
.text:0000425D                 mov     edx, [ebp+arg_0]
.text:00004260                 mov     eax, [edx+8]
.text:00004263                 mov     [ecx+8], eax
.text:00004266                 mov     edx, [edx+0Ch]
.text:00004269                 mov     [ecx+0Ch], edx
.text:0000426C                 mov     eax, [ebp+var_4]
.text:0000426F                 mov     ecx, [ebp+arg_0]
.text:00004272                 mov     edx, [ecx+10h]
.text:00004275                 mov     [eax+10h], edx
.text:00004278                 mov     ecx, [ecx+14h]
.text:0000427B                 mov     [eax+14h], ecx
.text:0000427E                 mov     edx, [ebp+var_4]
.text:00004281                 mov     eax, [ebp+arg_0]
.text:00004284                 mov     ecx, [eax+18h]
.text:00004287                 mov     [edx+18h], ecx
.text:0000428A                 mov     eax, [eax+1Ch]
.text:0000428D                 mov     [edx+1Ch], eax
.text:00004290                 mov     eax, [ebp+var_4]
.text:00004293                 add     esp, 4
.text:00004296                 cmp     ebp, esp
.text:00004298                 call    __RTC_CheckEsp
.text:0000429D                 mov     esp, ebp
.text:0000429F                 pop     ebp
.text:000042A0                 retn    4
.text:000042A0 ??0CSubStreamInfo@CMultiStream@@QAE@ABU01@@Z endp
.text:000042A0
.text:000042A0 ; ---------------------------------------------------------------------------
.text:000042A3                 align 4
.text:000042A3 _text           ends
.text:000042A3
.text:000042A4 ; ===========================================================================
.text:000042A4
.text:000042A4 ; Segment type: Pure code
.text:000042A4 ; Segment permissions: Read/Execute
.text:000042A4 _text           segment para public 'CODE' use32
.text:000042A4                 assume cs:_text
.text:000042A4                 ;org 42A4h
.text:000042A4 ; COMDAT (pick any)
.text:000042A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000042A4
.text:000042A4 ; =============== S U B R O U T I N E =======================================
.text:000042A4
.text:000042A4 ; Attributes: bp-based frame
.text:000042A4
.text:000042A4 ; public: void * __thiscall CMultiStream::CSubStreamInfo::`scalar deleting destructor'(unsigned int)
.text:000042A4                 public ??_GCSubStreamInfo@CMultiStream@@QAEPAXI@Z
.text:000042A4 ??_GCSubStreamInfo@CMultiStream@@QAEPAXI@Z proc near
.text:000042A4                                         ; CODE XREF: CObjectVector<CMultiStream::CSubStreamInfo>::~CObjectVector<CMultiStream::CSubStreamInfo>(void)+7Fp
.text:000042A4
.text:000042A4 var_4           = dword ptr -4
.text:000042A4 arg_0           = dword ptr  8
.text:000042A4
.text:000042A4                 push    ebp
.text:000042A5                 mov     ebp, esp
.text:000042A7                 push    ecx
.text:000042A8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000042AF                 mov     [ebp+var_4], ecx
.text:000042B2                 mov     ecx, [ebp+var_4] ; this
.text:000042B5                 call    ??1CSubStreamInfo@CMultiStream@@QAE@XZ ; CMultiStream::CSubStreamInfo::~CSubStreamInfo(void)
.text:000042BA                 mov     eax, [ebp+arg_0]
.text:000042BD                 and     eax, 1
.text:000042C0                 jz      short loc_42CE
.text:000042C2                 mov     ecx, [ebp+var_4]
.text:000042C5                 push    ecx             ; void *
.text:000042C6                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:000042CB                 add     esp, 4
.text:000042CE
.text:000042CE loc_42CE:                               ; CODE XREF: CMultiStream::CSubStreamInfo::`scalar deleting destructor'(uint)+1Cj
.text:000042CE                 mov     eax, [ebp+var_4]
.text:000042D1                 add     esp, 4
.text:000042D4                 cmp     ebp, esp
.text:000042D6                 call    __RTC_CheckEsp
.text:000042DB                 mov     esp, ebp
.text:000042DD                 pop     ebp
.text:000042DE                 retn    4
.text:000042DE ??_GCSubStreamInfo@CMultiStream@@QAEPAXI@Z endp
.text:000042DE
.text:000042DE ; ---------------------------------------------------------------------------
.text:000042E1                 align 4
.text:000042E1 _text           ends
.text:000042E1
.text:000042E4 ; ===========================================================================
.text:000042E4
.text:000042E4 ; Segment type: Pure code
.text:000042E4 ; Segment permissions: Read/Execute
.text:000042E4 _text           segment para public 'CODE' use32
.text:000042E4                 assume cs:_text
.text:000042E4                 ;org 42E4h
.text:000042E4 ; COMDAT (pick any)
.text:000042E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000042E4
.text:000042E4 ; =============== S U B R O U T I N E =======================================
.text:000042E4
.text:000042E4 ; Attributes: bp-based frame
.text:000042E4
.text:000042E4 ; public: void * __thiscall CMyComPtr<struct IInStream>::`scalar deleting destructor'(unsigned int)
.text:000042E4                 public ??_G?$CMyComPtr@UIInStream@@@@QAEPAXI@Z
.text:000042E4 ??_G?$CMyComPtr@UIInStream@@@@QAEPAXI@Z proc near
.text:000042E4                                         ; CODE XREF: CObjectVector<CMyComPtr<IInStream>>::~CObjectVector<CMyComPtr<IInStream>>(void)+7Fp
.text:000042E4                                         ; CObjectVector<CMyComPtr<IInStream>>::Clear(void)+59p
.text:000042E4
.text:000042E4 var_4           = dword ptr -4
.text:000042E4 arg_0           = dword ptr  8
.text:000042E4
.text:000042E4                 push    ebp
.text:000042E5                 mov     ebp, esp
.text:000042E7                 push    ecx
.text:000042E8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000042EF                 mov     [ebp+var_4], ecx
.text:000042F2                 mov     ecx, [ebp+var_4]
.text:000042F5                 call    ??1?$CMyComPtr@UIInStream@@@@QAE@XZ ; CMyComPtr<IInStream>::~CMyComPtr<IInStream>(void)
.text:000042FA                 mov     eax, [ebp+arg_0]
.text:000042FD                 and     eax, 1
.text:00004300                 jz      short loc_430E
.text:00004302                 mov     ecx, [ebp+var_4]
.text:00004305                 push    ecx             ; void *
.text:00004306                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000430B                 add     esp, 4
.text:0000430E
.text:0000430E loc_430E:                               ; CODE XREF: CMyComPtr<IInStream>::`scalar deleting destructor'(uint)+1Cj
.text:0000430E                 mov     eax, [ebp+var_4]
.text:00004311                 add     esp, 4
.text:00004314                 cmp     ebp, esp
.text:00004316                 call    __RTC_CheckEsp
.text:0000431B                 mov     esp, ebp
.text:0000431D                 pop     ebp
.text:0000431E                 retn    4
.text:0000431E ??_G?$CMyComPtr@UIInStream@@@@QAEPAXI@Z endp
.text:0000431E
.text:0000431E ; ---------------------------------------------------------------------------
.text:00004321                 align 4
.text:00004321 _text           ends
.text:00004321
.text:00004324 ; ===========================================================================
.text:00004324
.text:00004324 ; Segment type: Pure code
.text:00004324 ; Segment permissions: Read/Execute
.text:00004324 _text           segment para public 'CODE' use32
.text:00004324                 assume cs:_text
.text:00004324                 ;org 4324h
.text:00004324 ; COMDAT (pick any)
.text:00004324                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004324
.text:00004324 ; =============== S U B R O U T I N E =======================================
.text:00004324
.text:00004324 ; Attributes: bp-based frame
.text:00004324
.text:00004324 ; public: __thiscall CRecordVector<void *>::CRecordVector<void *>(void)
.text:00004324                 public ??0?$CRecordVector@PAX@@QAE@XZ
.text:00004324 ??0?$CRecordVector@PAX@@QAE@XZ proc near
.text:00004324                                         ; CODE XREF: CObjectVector<CMultiStream::CSubStreamInfo>::CObjectVector<CMultiStream::CSubStreamInfo>(void)+11p
.text:00004324                                         ; CObjectVector<CMyComPtr<IInStream>>::CObjectVector<CMyComPtr<IInStream>>(void)+11p
.text:00004324
.text:00004324 var_4           = dword ptr -4
.text:00004324
.text:00004324                 push    ebp
.text:00004325                 mov     ebp, esp
.text:00004327                 push    ecx
.text:00004328                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000432F                 mov     [ebp+var_4], ecx
.text:00004332                 mov     eax, [ebp+var_4]
.text:00004335                 mov     dword ptr [eax], 0
.text:0000433B                 mov     ecx, [ebp+var_4]
.text:0000433E                 mov     dword ptr [ecx+4], 0
.text:00004345                 mov     edx, [ebp+var_4]
.text:00004348                 mov     dword ptr [edx+8], 0
.text:0000434F                 mov     eax, [ebp+var_4]
.text:00004352                 mov     esp, ebp
.text:00004354                 pop     ebp
.text:00004355                 retn
.text:00004355 ??0?$CRecordVector@PAX@@QAE@XZ endp
.text:00004355
.text:00004355 ; ---------------------------------------------------------------------------
.text:00004356                 align 4
.text:00004356 _text           ends
.text:00004356
.text:00004358 ; ===========================================================================
.text:00004358
.text:00004358 ; Segment type: Pure code
.text:00004358 ; Segment permissions: Read/Execute
.text:00004358 _text           segment para public 'CODE' use32
.text:00004358                 assume cs:_text
.text:00004358                 ;org 4358h
.text:00004358 ; COMDAT (pick any)
.text:00004358                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004358
.text:00004358 ; =============== S U B R O U T I N E =======================================
.text:00004358
.text:00004358 ; Attributes: bp-based frame
.text:00004358
.text:00004358 ; public: unsigned int __thiscall CRecordVector<void *>::Size(void)const
.text:00004358                 public ?Size@?$CRecordVector@PAX@@QBEIXZ
.text:00004358 ?Size@?$CRecordVector@PAX@@QBEIXZ proc near
.text:00004358                                         ; CODE XREF: CObjectVector<CMultiStream::CSubStreamInfo>::Size(void)+11p
.text:00004358                                         ; CObjectVector<CMultiStream::CSubStreamInfo>::~CObjectVector<CMultiStream::CSubStreamInfo>(void)+46p ...
.text:00004358
.text:00004358 var_4           = dword ptr -4
.text:00004358
.text:00004358                 push    ebp
.text:00004359                 mov     ebp, esp
.text:0000435B                 push    ecx
.text:0000435C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00004363                 mov     [ebp+var_4], ecx
.text:00004366                 mov     eax, [ebp+var_4]
.text:00004369                 mov     eax, [eax+4]
.text:0000436C                 mov     esp, ebp
.text:0000436E                 pop     ebp
.text:0000436F                 retn
.text:0000436F ?Size@?$CRecordVector@PAX@@QBEIXZ endp
.text:0000436F
.text:0000436F _text           ends
.text:0000436F
.text:00004370 ; ===========================================================================
.text:00004370
.text:00004370 ; Segment type: Pure code
.text:00004370 ; Segment permissions: Read/Execute
.text:00004370 _text           segment para public 'CODE' use32
.text:00004370                 assume cs:_text
.text:00004370                 ;org 4370h
.text:00004370 ; COMDAT (pick any)
.text:00004370                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004370
.text:00004370 ; =============== S U B R O U T I N E =======================================
.text:00004370
.text:00004370 ; Attributes: bp-based frame
.text:00004370
.text:00004370 ; public: bool __thiscall CRecordVector<void *>::IsEmpty(void)const
.text:00004370                 public ?IsEmpty@?$CRecordVector@PAX@@QBE_NXZ
.text:00004370 ?IsEmpty@?$CRecordVector@PAX@@QBE_NXZ proc near
.text:00004370                                         ; CODE XREF: CObjectVector<CMyComPtr<IInStream>>::IsEmpty(void)+11p
.text:00004370
.text:00004370 var_4           = dword ptr -4
.text:00004370
.text:00004370                 push    ebp
.text:00004371                 mov     ebp, esp
.text:00004373                 push    ecx
.text:00004374                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000437B                 mov     [ebp+var_4], ecx
.text:0000437E                 mov     eax, [ebp+var_4]
.text:00004381                 xor     ecx, ecx
.text:00004383                 cmp     dword ptr [eax+4], 0
.text:00004387                 setz    cl
.text:0000438A                 mov     al, cl
.text:0000438C                 mov     esp, ebp
.text:0000438E                 pop     ebp
.text:0000438F                 retn
.text:0000438F ?IsEmpty@?$CRecordVector@PAX@@QBE_NXZ endp
.text:0000438F
.text:0000438F _text           ends
.text:0000438F
.text:00004390 ; ===========================================================================
.text:00004390
.text:00004390 ; Segment type: Pure code
.text:00004390 ; Segment permissions: Read/Execute
.text:00004390 _text           segment para public 'CODE' use32
.text:00004390                 assume cs:_text
.text:00004390                 ;org 4390h
.text:00004390 ; COMDAT (pick any)
.text:00004390                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004390
.text:00004390 ; =============== S U B R O U T I N E =======================================
.text:00004390
.text:00004390 ; Attributes: bp-based frame
.text:00004390
.text:00004390 ; public: __thiscall CRecordVector<void *>::~CRecordVector<void *>(void)
.text:00004390                 public ??1?$CRecordVector@PAX@@QAE@XZ
.text:00004390 ??1?$CRecordVector@PAX@@QAE@XZ proc near
.text:00004390                                         ; CODE XREF: CObjectVector<CMultiStream::CSubStreamInfo>::~CObjectVector<CMultiStream::CSubStreamInfo>(void)+9Cp
.text:00004390                                         ; __unwindfunclet$??1?$CObjectVector@UCSubStreamInfo@CMultiStream@@@@QAE@XZ$0+3j ...
.text:00004390
.text:00004390 var_8           = dword ptr -8
.text:00004390 var_4           = dword ptr -4
.text:00004390
.text:00004390                 push    ebp
.text:00004391                 mov     ebp, esp
.text:00004393                 sub     esp, 8
.text:00004396                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000439D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000043A4                 mov     [ebp+var_4], ecx
.text:000043A7                 mov     eax, [ebp+var_4]
.text:000043AA                 mov     ecx, [eax]
.text:000043AC                 mov     [ebp+var_8], ecx
.text:000043AF                 mov     edx, [ebp+var_8]
.text:000043B2                 push    edx             ; void *
.text:000043B3                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:000043B8                 add     esp, 4
.text:000043BB                 add     esp, 8
.text:000043BE                 cmp     ebp, esp
.text:000043C0                 call    __RTC_CheckEsp
.text:000043C5                 mov     esp, ebp
.text:000043C7                 pop     ebp
.text:000043C8                 retn
.text:000043C8 ??1?$CRecordVector@PAX@@QAE@XZ endp
.text:000043C8
.text:000043C8 ; ---------------------------------------------------------------------------
.text:000043C9                 align 4
.text:000043C9 _text           ends
.text:000043C9
.text:000043CC ; ===========================================================================
.text:000043CC
.text:000043CC ; Segment type: Pure code
.text:000043CC ; Segment permissions: Read/Execute
.text:000043CC _text           segment para public 'CODE' use32
.text:000043CC                 assume cs:_text
.text:000043CC                 ;org 43CCh
.text:000043CC ; COMDAT (pick any)
.text:000043CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000043CC
.text:000043CC ; =============== S U B R O U T I N E =======================================
.text:000043CC
.text:000043CC ; Attributes: bp-based frame
.text:000043CC
.text:000043CC ; public: void __thiscall CRecordVector<void *>::Clear(void)
.text:000043CC                 public ?Clear@?$CRecordVector@PAX@@QAEXXZ
.text:000043CC ?Clear@?$CRecordVector@PAX@@QAEXXZ proc near
.text:000043CC                                         ; CODE XREF: CObjectVector<CMyComPtr<IInStream>>::Clear(void)+6Fp
.text:000043CC
.text:000043CC var_4           = dword ptr -4
.text:000043CC
.text:000043CC                 push    ebp
.text:000043CD                 mov     ebp, esp
.text:000043CF                 push    ecx
.text:000043D0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000043D7                 mov     [ebp+var_4], ecx
.text:000043DA                 mov     eax, [ebp+var_4]
.text:000043DD                 mov     dword ptr [eax+4], 0
.text:000043E4                 mov     esp, ebp
.text:000043E6                 pop     ebp
.text:000043E7                 retn
.text:000043E7 ?Clear@?$CRecordVector@PAX@@QAEXXZ endp
.text:000043E7
.text:000043E7 _text           ends
.text:000043E7
.text:000043E8 ; ===========================================================================
.text:000043E8
.text:000043E8 ; Segment type: Pure code
.text:000043E8 ; Segment permissions: Read/Execute
.text:000043E8 _text           segment para public 'CODE' use32
.text:000043E8                 assume cs:_text
.text:000043E8                 ;org 43E8h
.text:000043E8 ; COMDAT (pick any)
.text:000043E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000043E8
.text:000043E8 ; =============== S U B R O U T I N E =======================================
.text:000043E8
.text:000043E8 ; Attributes: bp-based frame
.text:000043E8
.text:000043E8 ; public: unsigned int __thiscall CRecordVector<void *>::Add(void * const)
.text:000043E8                 public ?Add@?$CRecordVector@PAX@@QAEIQAX@Z
.text:000043E8 ?Add@?$CRecordVector@PAX@@QAEIQAX@Z proc near
.text:000043E8                                         ; CODE XREF: CObjectVector<CMultiStream::CSubStreamInfo>::Add(CMultiStream::CSubStreamInfo const &)+50p
.text:000043E8                                         ; CObjectVector<CMyComPtr<IInStream>>::Add(CMyComPtr<IInStream> const &)+50p
.text:000043E8
.text:000043E8 var_8           = dword ptr -8
.text:000043E8 var_4           = dword ptr -4
.text:000043E8 arg_0           = dword ptr  8
.text:000043E8
.text:000043E8                 push    ebp
.text:000043E9                 mov     ebp, esp
.text:000043EB                 sub     esp, 8
.text:000043EE                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000043F5                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000043FC                 mov     [ebp+var_4], ecx
.text:000043FF                 mov     ecx, [ebp+var_4]
.text:00004402                 call    ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ ; CRecordVector<void *>::ReserveOnePosition(void)
.text:00004407                 mov     eax, [ebp+var_4]
.text:0000440A                 mov     ecx, [eax+4]
.text:0000440D                 mov     edx, [ebp+var_4]
.text:00004410                 mov     eax, [edx]
.text:00004412                 mov     edx, [ebp+arg_0]
.text:00004415                 mov     [eax+ecx*4], edx
.text:00004418                 mov     eax, [ebp+var_4]
.text:0000441B                 mov     ecx, [eax+4]
.text:0000441E                 mov     [ebp+var_8], ecx
.text:00004421                 mov     edx, [ebp+var_4]
.text:00004424                 mov     eax, [edx+4]
.text:00004427                 add     eax, 1
.text:0000442A                 mov     ecx, [ebp+var_4]
.text:0000442D                 mov     [ecx+4], eax
.text:00004430                 mov     eax, [ebp+var_8]
.text:00004433                 add     esp, 8
.text:00004436                 cmp     ebp, esp
.text:00004438                 call    __RTC_CheckEsp
.text:0000443D                 mov     esp, ebp
.text:0000443F                 pop     ebp
.text:00004440                 retn    4
.text:00004440 ?Add@?$CRecordVector@PAX@@QAEIQAX@Z endp
.text:00004440
.text:00004440 ; ---------------------------------------------------------------------------
.text:00004443                 align 4
.text:00004443 _text           ends
.text:00004443
.text:00004444 ; ===========================================================================
.text:00004444
.text:00004444 ; Segment type: Pure code
.text:00004444 ; Segment permissions: Read/Execute
.text:00004444 _text           segment para public 'CODE' use32
.text:00004444                 assume cs:_text
.text:00004444                 ;org 4444h
.text:00004444 ; COMDAT (pick any)
.text:00004444                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004444
.text:00004444 ; =============== S U B R O U T I N E =======================================
.text:00004444
.text:00004444 ; Attributes: bp-based frame
.text:00004444
.text:00004444 ; public: void * & __thiscall CRecordVector<void *>::operator[](unsigned int)
.text:00004444                 public ??A?$CRecordVector@PAX@@QAEAAPAXI@Z
.text:00004444 ??A?$CRecordVector@PAX@@QAEAAPAXI@Z proc near
.text:00004444                                         ; CODE XREF: CObjectVector<CMultiStream::CSubStreamInfo>::operator[](uint)+15p
.text:00004444                                         ; CObjectVector<CMultiStream::CSubStreamInfo>::~CObjectVector<CMultiStream::CSubStreamInfo>(void)+64p ...
.text:00004444
.text:00004444 var_4           = dword ptr -4
.text:00004444 arg_0           = dword ptr  8
.text:00004444
.text:00004444                 push    ebp
.text:00004445                 mov     ebp, esp
.text:00004447                 push    ecx
.text:00004448                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000444F                 mov     [ebp+var_4], ecx
.text:00004452                 mov     eax, [ebp+var_4]
.text:00004455                 mov     ecx, [eax]
.text:00004457                 mov     edx, [ebp+arg_0]
.text:0000445A                 lea     eax, [ecx+edx*4]
.text:0000445D                 mov     esp, ebp
.text:0000445F                 pop     ebp
.text:00004460                 retn    4
.text:00004460 ??A?$CRecordVector@PAX@@QAEAAPAXI@Z endp
.text:00004460
.text:00004460 ; ---------------------------------------------------------------------------
.text:00004463                 align 4
.text:00004463 _text           ends
.text:00004463
.text:00004464 ; ===========================================================================
.text:00004464
.text:00004464 ; Segment type: Pure code
.text:00004464 ; Segment permissions: Read/Execute
.text:00004464 _text           segment para public 'CODE' use32
.text:00004464                 assume cs:_text
.text:00004464                 ;org 4464h
.text:00004464 ; COMDAT (pick any)
.text:00004464                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004464
.text:00004464 ; =============== S U B R O U T I N E =======================================
.text:00004464
.text:00004464 ; Attributes: bp-based frame
.text:00004464
.text:00004464 ; public: __thiscall CMyComPtr<struct IInStream>::CMyComPtr<struct IInStream>(class CMyComPtr<struct IInStream> const &)
.text:00004464                 public ??0?$CMyComPtr@UIInStream@@@@QAE@ABV0@@Z
.text:00004464 ??0?$CMyComPtr@UIInStream@@@@QAE@ABV0@@Z proc near
.text:00004464                                         ; CODE XREF: CObjectVector<CMyComPtr<IInStream>>::Add(CMyComPtr<IInStream> const &)+38p
.text:00004464                                         ; CMultiStream::CSubStreamInfo::CSubStreamInfo(CMultiStream::CSubStreamInfo const &)+15p
.text:00004464
.text:00004464 var_4           = dword ptr -4
.text:00004464 arg_0           = dword ptr  8
.text:00004464
.text:00004464                 push    ebp
.text:00004465                 mov     ebp, esp
.text:00004467                 push    ecx
.text:00004468                 push    esi
.text:00004469                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00004470                 mov     [ebp+var_4], ecx
.text:00004473                 mov     eax, [ebp+var_4]
.text:00004476                 mov     ecx, [ebp+arg_0]
.text:00004479                 mov     edx, [ecx]
.text:0000447B                 mov     [eax], edx
.text:0000447D                 mov     eax, [ebp+var_4]
.text:00004480                 cmp     dword ptr [eax], 0
.text:00004483                 jz      short loc_44A0
.text:00004485                 mov     ecx, [ebp+var_4]
.text:00004488                 mov     edx, [ecx]
.text:0000448A                 mov     eax, [ebp+var_4]
.text:0000448D                 mov     ecx, [eax]
.text:0000448F                 mov     edx, [edx]
.text:00004491                 mov     esi, esp
.text:00004493                 push    ecx
.text:00004494                 mov     eax, [edx+4]
.text:00004497                 call    eax
.text:00004499                 cmp     esi, esp
.text:0000449B                 call    __RTC_CheckEsp
.text:000044A0
.text:000044A0 loc_44A0:                               ; CODE XREF: CMyComPtr<IInStream>::CMyComPtr<IInStream>(CMyComPtr<IInStream> const &)+1Fj
.text:000044A0                 mov     eax, [ebp+var_4]
.text:000044A3                 pop     esi
.text:000044A4                 add     esp, 4
.text:000044A7                 cmp     ebp, esp
.text:000044A9                 call    __RTC_CheckEsp
.text:000044AE                 mov     esp, ebp
.text:000044B0                 pop     ebp
.text:000044B1                 retn    4
.text:000044B1 ??0?$CMyComPtr@UIInStream@@@@QAE@ABV0@@Z endp
.text:000044B1
.text:000044B1 _text           ends
.text:000044B1
.text:000044B4 ; ===========================================================================
.text:000044B4
.text:000044B4 ; Segment type: Pure code
.text:000044B4 ; Segment permissions: Read/Execute
.text:000044B4 _text           segment para public 'CODE' use32
.text:000044B4                 assume cs:_text
.text:000044B4                 ;org 44B4h
.text:000044B4 ; COMDAT (pick any)
.text:000044B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000044B4
.text:000044B4 ; =============== S U B R O U T I N E =======================================
.text:000044B4
.text:000044B4 ; Attributes: bp-based frame
.text:000044B4
.text:000044B4 ; public: struct IInStream * __thiscall CMyComPtr<struct IInStream>::operator=(struct IInStream *)
.text:000044B4                 public ??4?$CMyComPtr@UIInStream@@@@QAEPAUIInStream@@PAU1@@Z
.text:000044B4 ??4?$CMyComPtr@UIInStream@@@@QAEPAUIInStream@@PAU1@@Z proc near
.text:000044B4                                         ; CODE XREF: CMyComPtr<IInStream>::operator=(CMyComPtr<IInStream> const &)+17p
.text:000044B4
.text:000044B4 var_4           = dword ptr -4
.text:000044B4 arg_0           = dword ptr  8
.text:000044B4
.text:000044B4                 push    ebp
.text:000044B5                 mov     ebp, esp
.text:000044B7                 push    ecx
.text:000044B8                 push    esi
.text:000044B9                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000044C0                 mov     [ebp+var_4], ecx
.text:000044C3                 cmp     [ebp+arg_0], 0
.text:000044C7                 jz      short loc_44E0
.text:000044C9                 mov     eax, [ebp+arg_0]
.text:000044CC                 mov     ecx, [eax]
.text:000044CE                 mov     esi, esp
.text:000044D0                 mov     edx, [ebp+arg_0]
.text:000044D3                 push    edx
.text:000044D4                 mov     eax, [ecx+4]
.text:000044D7                 call    eax
.text:000044D9                 cmp     esi, esp
.text:000044DB                 call    __RTC_CheckEsp
.text:000044E0
.text:000044E0 loc_44E0:                               ; CODE XREF: CMyComPtr<IInStream>::operator=(IInStream *)+13j
.text:000044E0                 mov     ecx, [ebp+var_4]
.text:000044E3                 cmp     dword ptr [ecx], 0
.text:000044E6                 jz      short loc_4503
.text:000044E8                 mov     edx, [ebp+var_4]
.text:000044EB                 mov     eax, [edx]
.text:000044ED                 mov     ecx, [ebp+var_4]
.text:000044F0                 mov     edx, [ecx]
.text:000044F2                 mov     eax, [eax]
.text:000044F4                 mov     esi, esp
.text:000044F6                 push    edx
.text:000044F7                 mov     ecx, [eax+8]
.text:000044FA                 call    ecx
.text:000044FC                 cmp     esi, esp
.text:000044FE                 call    __RTC_CheckEsp
.text:00004503
.text:00004503 loc_4503:                               ; CODE XREF: CMyComPtr<IInStream>::operator=(IInStream *)+32j
.text:00004503                 mov     edx, [ebp+var_4]
.text:00004506                 mov     eax, [ebp+arg_0]
.text:00004509                 mov     [edx], eax
.text:0000450B                 mov     eax, [ebp+arg_0]
.text:0000450E                 pop     esi
.text:0000450F                 add     esp, 4
.text:00004512                 cmp     ebp, esp
.text:00004514                 call    __RTC_CheckEsp
.text:00004519                 mov     esp, ebp
.text:0000451B                 pop     ebp
.text:0000451C                 retn    4
.text:0000451C ??4?$CMyComPtr@UIInStream@@@@QAEPAUIInStream@@PAU1@@Z endp
.text:0000451C
.text:0000451C ; ---------------------------------------------------------------------------
.text:0000451F                 align 10h
.text:0000451F _text           ends
.text:0000451F
.text:00004520 ; ===========================================================================
.text:00004520
.text:00004520 ; Segment type: Pure code
.text:00004520 ; Segment permissions: Read/Execute
.text:00004520 _text           segment para public 'CODE' use32
.text:00004520                 assume cs:_text
.text:00004520                 ;org 4520h
.text:00004520 ; COMDAT (pick any)
.text:00004520                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004520
.text:00004520 ; =============== S U B R O U T I N E =======================================
.text:00004520
.text:00004520 ; Attributes: bp-based frame
.text:00004520
.text:00004520 ; private: void __thiscall CRecordVector<unsigned __int64>::ReserveOnePosition(void)
.text:00004520                 public ?ReserveOnePosition@?$CRecordVector@_K@@AAEXXZ
.text:00004520 ?ReserveOnePosition@?$CRecordVector@_K@@AAEXXZ proc near
.text:00004520                                         ; CODE XREF: CRecordVector<unsigned __int64>::Add(unsigned __int64)+1Ap
.text:00004520
.text:00004520 var_14          = dword ptr -14h
.text:00004520 var_10          = dword ptr -10h
.text:00004520 Dst             = dword ptr -0Ch
.text:00004520 var_8           = dword ptr -8
.text:00004520 var_4           = dword ptr -4
.text:00004520
.text:00004520                 push    ebp
.text:00004521                 mov     ebp, esp
.text:00004523                 sub     esp, 14h
.text:00004526                 mov     eax, 0CCCCCCCCh
.text:0000452B                 mov     [ebp+var_14], eax
.text:0000452E                 mov     [ebp+var_10], eax
.text:00004531                 mov     [ebp+Dst], eax
.text:00004534                 mov     [ebp+var_8], eax
.text:00004537                 mov     [ebp+var_4], eax
.text:0000453A                 mov     [ebp+var_4], ecx
.text:0000453D                 mov     eax, [ebp+var_4]
.text:00004540                 mov     ecx, [ebp+var_4]
.text:00004543                 mov     edx, [eax+4]
.text:00004546                 cmp     edx, [ecx+8]
.text:00004549                 jnz     loc_45D4
.text:0000454F                 mov     eax, [ebp+var_4]
.text:00004552                 mov     ecx, [eax+8]
.text:00004555                 shr     ecx, 2
.text:00004558                 mov     edx, [ebp+var_4]
.text:0000455B                 mov     eax, [edx+8]
.text:0000455E                 lea     ecx, [eax+ecx+1]
.text:00004562                 mov     [ebp+var_8], ecx
.text:00004565                 xor     ecx, ecx
.text:00004567                 mov     eax, [ebp+var_8]
.text:0000456A                 mov     edx, 8
.text:0000456F                 mul     edx
.text:00004571                 seto    cl
.text:00004574                 neg     ecx
.text:00004576                 or      ecx, eax
.text:00004578                 push    ecx             ; unsigned int
.text:00004579                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0000457E                 add     esp, 4
.text:00004581                 mov     [ebp+var_10], eax
.text:00004584                 mov     eax, [ebp+var_10]
.text:00004587                 mov     [ebp+Dst], eax
.text:0000458A                 mov     ecx, [ebp+var_4]
.text:0000458D                 cmp     dword ptr [ecx+4], 0
.text:00004591                 jz      short loc_45AF
.text:00004593                 mov     edx, [ebp+var_4]
.text:00004596                 mov     eax, [edx+4]
.text:00004599                 shl     eax, 3
.text:0000459C                 push    eax             ; Size
.text:0000459D                 mov     ecx, [ebp+var_4]
.text:000045A0                 mov     edx, [ecx]
.text:000045A2                 push    edx             ; Src
.text:000045A3                 mov     eax, [ebp+Dst]
.text:000045A6                 push    eax             ; Dst
.text:000045A7                 call    _memcpy
.text:000045AC                 add     esp, 0Ch
.text:000045AF
.text:000045AF loc_45AF:                               ; CODE XREF: CRecordVector<unsigned __int64>::ReserveOnePosition(void)+71j
.text:000045AF                 mov     ecx, [ebp+var_4]
.text:000045B2                 mov     edx, [ecx]
.text:000045B4                 mov     [ebp+var_14], edx
.text:000045B7                 mov     eax, [ebp+var_14]
.text:000045BA                 push    eax             ; void *
.text:000045BB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:000045C0                 add     esp, 4
.text:000045C3                 mov     ecx, [ebp+var_4]
.text:000045C6                 mov     edx, [ebp+Dst]
.text:000045C9                 mov     [ecx], edx
.text:000045CB                 mov     eax, [ebp+var_4]
.text:000045CE                 mov     ecx, [ebp+var_8]
.text:000045D1                 mov     [eax+8], ecx
.text:000045D4
.text:000045D4 loc_45D4:                               ; CODE XREF: CRecordVector<unsigned __int64>::ReserveOnePosition(void)+29j
.text:000045D4                 add     esp, 14h
.text:000045D7                 cmp     ebp, esp
.text:000045D9                 call    __RTC_CheckEsp
.text:000045DE                 mov     esp, ebp
.text:000045E0                 pop     ebp
.text:000045E1                 retn
.text:000045E1 ?ReserveOnePosition@?$CRecordVector@_K@@AAEXXZ endp
.text:000045E1
.text:000045E1 ; ---------------------------------------------------------------------------
.text:000045E2                 align 4
.text:000045E2 _text           ends
.text:000045E2
.text:000045E4 ; ===========================================================================
.text:000045E4
.text:000045E4 ; Segment type: Pure code
.text:000045E4 ; Segment permissions: Read/Execute
.text:000045E4 _text           segment para public 'CODE' use32
.text:000045E4                 assume cs:_text
.text:000045E4                 ;org 45E4h
.text:000045E4 ; COMDAT (pick any)
.text:000045E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000045E4
.text:000045E4 ; =============== S U B R O U T I N E =======================================
.text:000045E4
.text:000045E4 ; Attributes: bp-based frame
.text:000045E4
.text:000045E4 ; private: void __thiscall CRecordVector<void *>::ReserveOnePosition(void)
.text:000045E4                 public ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ
.text:000045E4 ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ proc near
.text:000045E4                                         ; CODE XREF: CRecordVector<void *>::Add(void * const)+1Ap
.text:000045E4
.text:000045E4 var_14          = dword ptr -14h
.text:000045E4 var_10          = dword ptr -10h
.text:000045E4 Dst             = dword ptr -0Ch
.text:000045E4 var_8           = dword ptr -8
.text:000045E4 var_4           = dword ptr -4
.text:000045E4
.text:000045E4                 push    ebp
.text:000045E5                 mov     ebp, esp
.text:000045E7                 sub     esp, 14h
.text:000045EA                 mov     eax, 0CCCCCCCCh
.text:000045EF                 mov     [ebp+var_14], eax
.text:000045F2                 mov     [ebp+var_10], eax
.text:000045F5                 mov     [ebp+Dst], eax
.text:000045F8                 mov     [ebp+var_8], eax
.text:000045FB                 mov     [ebp+var_4], eax
.text:000045FE                 mov     [ebp+var_4], ecx
.text:00004601                 mov     eax, [ebp+var_4]
.text:00004604                 mov     ecx, [ebp+var_4]
.text:00004607                 mov     edx, [eax+4]
.text:0000460A                 cmp     edx, [ecx+8]
.text:0000460D                 jnz     loc_4698
.text:00004613                 mov     eax, [ebp+var_4]
.text:00004616                 mov     ecx, [eax+8]
.text:00004619                 shr     ecx, 2
.text:0000461C                 mov     edx, [ebp+var_4]
.text:0000461F                 mov     eax, [edx+8]
.text:00004622                 lea     ecx, [eax+ecx+1]
.text:00004626                 mov     [ebp+var_8], ecx
.text:00004629                 xor     ecx, ecx
.text:0000462B                 mov     eax, [ebp+var_8]
.text:0000462E                 mov     edx, 4
.text:00004633                 mul     edx
.text:00004635                 seto    cl
.text:00004638                 neg     ecx
.text:0000463A                 or      ecx, eax
.text:0000463C                 push    ecx             ; unsigned int
.text:0000463D                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00004642                 add     esp, 4
.text:00004645                 mov     [ebp+var_10], eax
.text:00004648                 mov     eax, [ebp+var_10]
.text:0000464B                 mov     [ebp+Dst], eax
.text:0000464E                 mov     ecx, [ebp+var_4]
.text:00004651                 cmp     dword ptr [ecx+4], 0
.text:00004655                 jz      short loc_4673
.text:00004657                 mov     edx, [ebp+var_4]
.text:0000465A                 mov     eax, [edx+4]
.text:0000465D                 shl     eax, 2
.text:00004660                 push    eax             ; Size
.text:00004661                 mov     ecx, [ebp+var_4]
.text:00004664                 mov     edx, [ecx]
.text:00004666                 push    edx             ; Src
.text:00004667                 mov     eax, [ebp+Dst]
.text:0000466A                 push    eax             ; Dst
.text:0000466B                 call    _memcpy
.text:00004670                 add     esp, 0Ch
.text:00004673
.text:00004673 loc_4673:                               ; CODE XREF: CRecordVector<void *>::ReserveOnePosition(void)+71j
.text:00004673                 mov     ecx, [ebp+var_4]
.text:00004676                 mov     edx, [ecx]
.text:00004678                 mov     [ebp+var_14], edx
.text:0000467B                 mov     eax, [ebp+var_14]
.text:0000467E                 push    eax             ; void *
.text:0000467F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00004684                 add     esp, 4
.text:00004687                 mov     ecx, [ebp+var_4]
.text:0000468A                 mov     edx, [ebp+Dst]
.text:0000468D                 mov     [ecx], edx
.text:0000468F                 mov     eax, [ebp+var_4]
.text:00004692                 mov     ecx, [ebp+var_8]
.text:00004695                 mov     [eax+8], ecx
.text:00004698
.text:00004698 loc_4698:                               ; CODE XREF: CRecordVector<void *>::ReserveOnePosition(void)+29j
.text:00004698                 add     esp, 14h
.text:0000469B                 cmp     ebp, esp
.text:0000469D                 call    __RTC_CheckEsp
.text:000046A2                 mov     esp, ebp
.text:000046A4                 pop     ebp
.text:000046A5                 retn
.text:000046A5 ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ endp
.text:000046A5
.text:000046A5 ; ---------------------------------------------------------------------------
.text:000046A6                 align 4
.text:000046A6 _text           ends
.text:000046A6
.text:000046A8 ; ===========================================================================
.text:000046A8
.text:000046A8 ; Segment type: Pure code
.text:000046A8 ; Segment permissions: Read/Execute
.text:000046A8 _text           segment para public 'CODE' use32
.text:000046A8                 assume cs:_text
.text:000046A8                 ;org 46A8h
.text:000046A8 ; COMDAT (pick any)
.text:000046A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000046A8
.text:000046A8 ; =============== S U B R O U T I N E =======================================
.text:000046A8
.text:000046A8
.text:000046A8 ; [thunk]:public: virtual unsigned long __stdcall NCompress::CCopyCoder::Release`adjustor{4}' (void)
.text:000046A8                 public ?Release@CCopyCoder@NCompress@@W3AGKXZ
.text:000046A8 ?Release@CCopyCoder@NCompress@@W3AGKXZ proc near
.text:000046A8                                         ; DATA XREF: .rdata:00002504o
.text:000046A8
.text:000046A8 arg_0           = dword ptr  4
.text:000046A8
.text:000046A8                 sub     [esp+arg_0], 4
.text:000046AD                 jmp     ?Release@CCopyCoder@NCompress@@UAGKXZ ; NCompress::CCopyCoder::Release(void)
.text:000046AD ?Release@CCopyCoder@NCompress@@W3AGKXZ endp
.text:000046AD
.text:000046AD ; ---------------------------------------------------------------------------
.text:000046B2                 align 4
.text:000046B2 _text           ends
.text:000046B2
.text:000046B4 ; ===========================================================================
.text:000046B4
.text:000046B4 ; Segment type: Pure code
.text:000046B4 ; Segment permissions: Read/Execute
.text:000046B4 _text           segment para public 'CODE' use32
.text:000046B4                 assume cs:_text
.text:000046B4                 ;org 46B4h
.text:000046B4 ; COMDAT (pick any)
.text:000046B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000046B4
.text:000046B4 ; =============== S U B R O U T I N E =======================================
.text:000046B4
.text:000046B4
.text:000046B4 ; [thunk]:public: virtual unsigned long __stdcall NArchive::NSplit::CHandler::AddRef`adjustor{4}' (void)
.text:000046B4                 public ?AddRef@CHandler@NSplit@NArchive@@W3AGKXZ
.text:000046B4 ?AddRef@CHandler@NSplit@NArchive@@W3AGKXZ proc near
.text:000046B4                                         ; DATA XREF: .rdata:00003260o
.text:000046B4
.text:000046B4 arg_0           = dword ptr  4
.text:000046B4
.text:000046B4                 sub     [esp+arg_0], 4
.text:000046B9                 jmp     ?AddRef@CHandler@NSplit@NArchive@@UAGKXZ ; NArchive::NSplit::CHandler::AddRef(void)
.text:000046B9 ?AddRef@CHandler@NSplit@NArchive@@W3AGKXZ endp
.text:000046B9
.text:000046B9 ; ---------------------------------------------------------------------------
.text:000046BE                 align 10h
.text:000046BE _text           ends
.text:000046BE
.text:000046C0 ; ===========================================================================
.text:000046C0
.text:000046C0 ; Segment type: Pure code
.text:000046C0 ; Segment permissions: Read/Execute
.text:000046C0 _text           segment para public 'CODE' use32
.text:000046C0                 assume cs:_text
.text:000046C0                 ;org 46C0h
.text:000046C0 ; COMDAT (pick any)
.text:000046C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000046C0
.text:000046C0 ; =============== S U B R O U T I N E =======================================
.text:000046C0
.text:000046C0
.text:000046C0 ; [thunk]:public: virtual unsigned long __stdcall NCompress::CCopyCoder::Release`adjustor{8}' (void)
.text:000046C0                 public ?Release@CCopyCoder@NCompress@@W7AGKXZ
.text:000046C0 ?Release@CCopyCoder@NCompress@@W7AGKXZ proc near
.text:000046C0                                         ; DATA XREF: .rdata:000024F0o
.text:000046C0
.text:000046C0 arg_0           = dword ptr  4
.text:000046C0
.text:000046C0                 sub     [esp+arg_0], 8
.text:000046C5                 jmp     ?Release@CCopyCoder@NCompress@@UAGKXZ ; NCompress::CCopyCoder::Release(void)
.text:000046C5 ?Release@CCopyCoder@NCompress@@W7AGKXZ endp
.text:000046C5
.text:000046C5 ; ---------------------------------------------------------------------------
.text:000046CA                 align 4
.text:000046CA _text           ends
.text:000046CA
.text:000046CC ; ===========================================================================
.text:000046CC
.text:000046CC ; Segment type: Pure code
.text:000046CC ; Segment permissions: Read/Execute
.text:000046CC _text           segment para public 'CODE' use32
.text:000046CC                 assume cs:_text
.text:000046CC                 ;org 46CCh
.text:000046CC ; COMDAT (pick any)
.text:000046CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000046CC
.text:000046CC ; =============== S U B R O U T I N E =======================================
.text:000046CC
.text:000046CC
.text:000046CC ; [thunk]:public: virtual long __stdcall NArchive::NSplit::CHandler::QueryInterface`adjustor{4}' (struct _GUID const &, void * *)
.text:000046CC                 public ?QueryInterface@CHandler@NSplit@NArchive@@W3AGJABU_GUID@@PAPAX@Z
.text:000046CC ?QueryInterface@CHandler@NSplit@NArchive@@W3AGJABU_GUID@@PAPAX@Z proc near
.text:000046CC                                         ; DATA XREF: .rdata:const NArchive::NSplit::CHandler::`vftable'{for `IInArchiveGetStream'}o
.text:000046CC
.text:000046CC arg_0           = dword ptr  4
.text:000046CC
.text:000046CC                 sub     [esp+arg_0], 4
.text:000046D1                 jmp     ?QueryInterface@CHandler@NSplit@NArchive@@UAGJABU_GUID@@PAPAX@Z ; NArchive::NSplit::CHandler::QueryInterface(_GUID const &,void * *)
.text:000046D1 ?QueryInterface@CHandler@NSplit@NArchive@@W3AGJABU_GUID@@PAPAX@Z endp
.text:000046D1
.text:000046D1 ; ---------------------------------------------------------------------------
.text:000046D6                 align 4
.text:000046D6 _text           ends
.text:000046D6
.text:000046D8 ; ===========================================================================
.text:000046D8
.text:000046D8 ; Segment type: Pure code
.text:000046D8 ; Segment permissions: Read/Execute
.text:000046D8 _text           segment para public 'CODE' use32
.text:000046D8                 assume cs:_text
.text:000046D8                 ;org 46D8h
.text:000046D8 ; COMDAT (pick any)
.text:000046D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000046D8
.text:000046D8 ; =============== S U B R O U T I N E =======================================
.text:000046D8
.text:000046D8
.text:000046D8 ; [thunk]:public: virtual unsigned long __stdcall NCompress::CCopyCoder::Release`adjustor{12}' (void)
.text:000046D8                 public ?Release@CCopyCoder@NCompress@@WM@AGKXZ
.text:000046D8 ?Release@CCopyCoder@NCompress@@WM@AGKXZ proc near
.text:000046D8                                         ; DATA XREF: .rdata:000024DCo
.text:000046D8
.text:000046D8 arg_0           = dword ptr  4
.text:000046D8
.text:000046D8                 sub     [esp+arg_0], 0Ch
.text:000046DD                 jmp     ?Release@CCopyCoder@NCompress@@UAGKXZ ; NCompress::CCopyCoder::Release(void)
.text:000046DD ?Release@CCopyCoder@NCompress@@WM@AGKXZ endp
.text:000046DD
.text:000046DD ; ---------------------------------------------------------------------------
.text:000046E2                 align 4
.text:000046E2 _text           ends
.text:000046E2
.text:000046E4 ; ===========================================================================
.text:000046E4
.text:000046E4 ; Segment type: Pure code
.text:000046E4 ; Segment permissions: Read/Execute
.text:000046E4 _text           segment para public 'CODE' use32
.text:000046E4                 assume cs:_text
.text:000046E4                 ;org 46E4h
.text:000046E4 ; COMDAT (pick any)
.text:000046E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000046E4
.text:000046E4 ; =============== S U B R O U T I N E =======================================
.text:000046E4
.text:000046E4
.text:000046E4 ; [thunk]:public: virtual unsigned long __stdcall NCompress::CCopyCoder::AddRef`adjustor{4}' (void)
.text:000046E4                 public ?AddRef@CCopyCoder@NCompress@@W3AGKXZ
.text:000046E4 ?AddRef@CCopyCoder@NCompress@@W3AGKXZ proc near ; DATA XREF: .rdata:00002500o
.text:000046E4
.text:000046E4 arg_0           = dword ptr  4
.text:000046E4
.text:000046E4                 sub     [esp+arg_0], 4
.text:000046E9                 jmp     ?AddRef@CCopyCoder@NCompress@@UAGKXZ ; NCompress::CCopyCoder::AddRef(void)
.text:000046E9 ?AddRef@CCopyCoder@NCompress@@W3AGKXZ endp
.text:000046E9
.text:000046E9 ; ---------------------------------------------------------------------------
.text:000046EE                 align 10h
.text:000046EE _text           ends
.text:000046EE
.text:000046F0 ; ===========================================================================
.text:000046F0
.text:000046F0 ; Segment type: Pure code
.text:000046F0 ; Segment permissions: Read/Execute
.text:000046F0 _text           segment para public 'CODE' use32
.text:000046F0                 assume cs:_text
.text:000046F0                 ;org 46F0h
.text:000046F0 ; COMDAT (pick any)
.text:000046F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000046F0
.text:000046F0 ; =============== S U B R O U T I N E =======================================
.text:000046F0
.text:000046F0
.text:000046F0 ; [thunk]:public: virtual unsigned long __stdcall NCompress::CCopyCoder::AddRef`adjustor{8}' (void)
.text:000046F0                 public ?AddRef@CCopyCoder@NCompress@@W7AGKXZ
.text:000046F0 ?AddRef@CCopyCoder@NCompress@@W7AGKXZ proc near ; DATA XREF: .rdata:000024ECo
.text:000046F0
.text:000046F0 arg_0           = dword ptr  4
.text:000046F0
.text:000046F0                 sub     [esp+arg_0], 8
.text:000046F5                 jmp     ?AddRef@CCopyCoder@NCompress@@UAGKXZ ; NCompress::CCopyCoder::AddRef(void)
.text:000046F5 ?AddRef@CCopyCoder@NCompress@@W7AGKXZ endp
.text:000046F5
.text:000046F5 ; ---------------------------------------------------------------------------
.text:000046FA                 align 4
.text:000046FA _text           ends
.text:000046FA
.text:000046FC ; ===========================================================================
.text:000046FC
.text:000046FC ; Segment type: Pure code
.text:000046FC ; Segment permissions: Read/Execute
.text:000046FC _text           segment para public 'CODE' use32
.text:000046FC                 assume cs:_text
.text:000046FC                 ;org 46FCh
.text:000046FC ; COMDAT (pick any)
.text:000046FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000046FC
.text:000046FC ; =============== S U B R O U T I N E =======================================
.text:000046FC
.text:000046FC
.text:000046FC ; [thunk]:public: virtual long __stdcall NCompress::CCopyCoder::QueryInterface`adjustor{4}' (struct _GUID const &, void * *)
.text:000046FC                 public ?QueryInterface@CCopyCoder@NCompress@@W3AGJABU_GUID@@PAPAX@Z
.text:000046FC ?QueryInterface@CCopyCoder@NCompress@@W3AGJABU_GUID@@PAPAX@Z proc near
.text:000046FC                                         ; DATA XREF: .rdata:const NCompress::CCopyCoder::`vftable'{for `ICompressSetInStream'}o
.text:000046FC
.text:000046FC arg_0           = dword ptr  4
.text:000046FC
.text:000046FC                 sub     [esp+arg_0], 4
.text:00004701                 jmp     ?QueryInterface@CCopyCoder@NCompress@@UAGJABU_GUID@@PAPAX@Z ; NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *)
.text:00004701 ?QueryInterface@CCopyCoder@NCompress@@W3AGJABU_GUID@@PAPAX@Z endp
.text:00004701
.text:00004701 ; ---------------------------------------------------------------------------
.text:00004706                 align 4
.text:00004706 _text           ends
.text:00004706
.text:00004708 ; ===========================================================================
.text:00004708
.text:00004708 ; Segment type: Pure code
.text:00004708 ; Segment permissions: Read/Execute
.text:00004708 _text           segment para public 'CODE' use32
.text:00004708                 assume cs:_text
.text:00004708                 ;org 4708h
.text:00004708 ; COMDAT (pick any)
.text:00004708                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004708
.text:00004708 ; =============== S U B R O U T I N E =======================================
.text:00004708
.text:00004708
.text:00004708 ; [thunk]:public: virtual unsigned long __stdcall NCompress::CCopyCoder::AddRef`adjustor{12}' (void)
.text:00004708                 public ?AddRef@CCopyCoder@NCompress@@WM@AGKXZ
.text:00004708 ?AddRef@CCopyCoder@NCompress@@WM@AGKXZ proc near
.text:00004708                                         ; DATA XREF: .rdata:000024D8o
.text:00004708
.text:00004708 arg_0           = dword ptr  4
.text:00004708
.text:00004708                 sub     [esp+arg_0], 0Ch
.text:0000470D                 jmp     ?AddRef@CCopyCoder@NCompress@@UAGKXZ ; NCompress::CCopyCoder::AddRef(void)
.text:0000470D ?AddRef@CCopyCoder@NCompress@@WM@AGKXZ endp
.text:0000470D
.text:0000470D ; ---------------------------------------------------------------------------
.text:00004712                 align 4
.text:00004712 _text           ends
.text:00004712
.text:00004714 ; ===========================================================================
.text:00004714
.text:00004714 ; Segment type: Pure code
.text:00004714 ; Segment permissions: Read/Execute
.text:00004714 _text           segment para public 'CODE' use32
.text:00004714                 assume cs:_text
.text:00004714                 ;org 4714h
.text:00004714 ; COMDAT (pick any)
.text:00004714                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004714
.text:00004714 ; =============== S U B R O U T I N E =======================================
.text:00004714
.text:00004714
.text:00004714 ; [thunk]:public: virtual long __stdcall NCompress::CCopyCoder::QueryInterface`adjustor{8}' (struct _GUID const &, void * *)
.text:00004714                 public ?QueryInterface@CCopyCoder@NCompress@@W7AGJABU_GUID@@PAPAX@Z
.text:00004714 ?QueryInterface@CCopyCoder@NCompress@@W7AGJABU_GUID@@PAPAX@Z proc near
.text:00004714                                         ; DATA XREF: .rdata:const NCompress::CCopyCoder::`vftable'{for `ISequentialInStream'}o
.text:00004714
.text:00004714 arg_0           = dword ptr  4
.text:00004714
.text:00004714                 sub     [esp+arg_0], 8
.text:00004719                 jmp     ?QueryInterface@CCopyCoder@NCompress@@UAGJABU_GUID@@PAPAX@Z ; NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *)
.text:00004719 ?QueryInterface@CCopyCoder@NCompress@@W7AGJABU_GUID@@PAPAX@Z endp
.text:00004719
.text:00004719 ; ---------------------------------------------------------------------------
.text:0000471E                 align 10h
.text:0000471E _text           ends
.text:0000471E
.text:00004720 ; ===========================================================================
.text:00004720
.text:00004720 ; Segment type: Pure code
.text:00004720 ; Segment permissions: Read/Execute
.text:00004720 _text           segment para public 'CODE' use32
.text:00004720                 assume cs:_text
.text:00004720                 ;org 4720h
.text:00004720 ; COMDAT (pick any)
.text:00004720                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004720
.text:00004720 ; =============== S U B R O U T I N E =======================================
.text:00004720
.text:00004720
.text:00004720 ; [thunk]:public: virtual long __stdcall NCompress::CCopyCoder::QueryInterface`adjustor{12}' (struct _GUID const &, void * *)
.text:00004720                 public ?QueryInterface@CCopyCoder@NCompress@@WM@AGJABU_GUID@@PAPAX@Z
.text:00004720 ?QueryInterface@CCopyCoder@NCompress@@WM@AGJABU_GUID@@PAPAX@Z proc near
.text:00004720                                         ; DATA XREF: .rdata:const NCompress::CCopyCoder::`vftable'{for `ICompressGetInStreamProcessedSize'}o
.text:00004720
.text:00004720 arg_0           = dword ptr  4
.text:00004720
.text:00004720                 sub     [esp+arg_0], 0Ch
.text:00004725                 jmp     ?QueryInterface@CCopyCoder@NCompress@@UAGJABU_GUID@@PAPAX@Z ; NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *)
.text:00004725 ?QueryInterface@CCopyCoder@NCompress@@WM@AGJABU_GUID@@PAPAX@Z endp
.text:00004725
.text:00004725 ; ---------------------------------------------------------------------------
.text:0000472A                 align 4
.text:0000472A _text           ends
.text:0000472A
.text:0000472C ; ===========================================================================
.text:0000472C
.text:0000472C ; Segment type: Pure code
.text:0000472C ; Segment permissions: Read/Execute
.text:0000472C _text           segment para public 'CODE' use32
.text:0000472C                 assume cs:_text
.text:0000472C                 ;org 472Ch
.text:0000472C ; COMDAT (pick any)
.text:0000472C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000472C
.text:0000472C ; =============== S U B R O U T I N E =======================================
.text:0000472C
.text:0000472C
.text:0000472C ; [thunk]:public: virtual unsigned long __stdcall NArchive::NSplit::CHandler::Release`adjustor{4}' (void)
.text:0000472C                 public ?Release@CHandler@NSplit@NArchive@@W3AGKXZ
.text:0000472C ?Release@CHandler@NSplit@NArchive@@W3AGKXZ proc near
.text:0000472C                                         ; DATA XREF: .rdata:00003264o
.text:0000472C
.text:0000472C arg_0           = dword ptr  4
.text:0000472C
.text:0000472C                 sub     [esp+arg_0], 4
.text:00004731                 jmp     ?Release@CHandler@NSplit@NArchive@@UAGKXZ ; NArchive::NSplit::CHandler::Release(void)
.text:00004731 ?Release@CHandler@NSplit@NArchive@@W3AGKXZ endp
.text:00004731
.text:00004731 ; ---------------------------------------------------------------------------
.text:00004736                 align 4
.text:00004736 _text           ends
.text:00004736
.text$yc:00004738 ; ===========================================================================
.text$yc:00004738
.text$yc:00004738 ; Segment type: Pure code
.text$yc:00004738 ; Segment permissions: Read/Execute
.text$yc:00004738 _text$yc        segment para public 'CODE' use32
.text$yc:00004738                 assume cs:_text$yc
.text$yc:00004738                 ;org 4738h
.text$yc:00004738 ; COMDAT (pick any)
.text$yc:00004738                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yc:00004738
.text$yc:00004738 ; =============== S U B R O U T I N E =======================================
.text$yc:00004738
.text$yc:00004738 ; Attributes: bp-based frame
.text$yc:00004738
.text$yc:00004738 ; void __cdecl NArchive::NSplit::`dynamic initializer for 'g_RegisterArc''(void)
.text$yc:00004738 ??__Eg_RegisterArc@NSplit@NArchive@@YAXXZ proc near
.text$yc:00004738                                         ; DATA XREF: .CRT$XCU:_g_RegisterArc$initializer$o
.text$yc:00004738                 push    ebp
.text$yc:00004739                 mov     ebp, esp
.text$yc:0000473B                 mov     ecx, offset _g_RegisterArc ; this
.text$yc:00004740                 call    ??0CRegisterArc@NSplit@NArchive@@QAE@XZ ; NArchive::NSplit::CRegisterArc::CRegisterArc(void)
.text$yc:00004745                 cmp     ebp, esp
.text$yc:00004747                 call    __RTC_CheckEsp
.text$yc:0000474C                 pop     ebp
.text$yc:0000474D                 retn
.text$yc:0000474D ??__Eg_RegisterArc@NSplit@NArchive@@YAXXZ endp
.text$yc:0000474D
.text$yc:0000474D ; ---------------------------------------------------------------------------
.text$yc:0000474E                 align 10h
.text$yc:0000474E _text$yc        ends
.text$yc:0000474E
.text:00004750 ; ===========================================================================
.text:00004750
.text:00004750 ; Segment type: Pure code
.text:00004750 ; Segment permissions: Read/Execute
.text:00004750 _text           segment para public 'CODE' use32
.text:00004750                 assume cs:_text
.text:00004750                 ;org 4750h
.text:00004750 ; COMDAT (pick any)
.text:00004750                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004750
.text:00004750 ; =============== S U B R O U T I N E =======================================
.text:00004750
.text:00004750 ; Attributes: bp-based frame
.text:00004750
.text:00004750 ; _DWORD __thiscall NArchive::NSplit::CRegisterArc::CRegisterArc(NArchive::NSplit::CRegisterArc *__hidden this)
.text:00004750                 public ??0CRegisterArc@NSplit@NArchive@@QAE@XZ
.text:00004750 ??0CRegisterArc@NSplit@NArchive@@QAE@XZ proc near
.text:00004750                                         ; CODE XREF: NArchive::NSplit::`dynamic initializer for 'g_RegisterArc''(void)+8p
.text:00004750
.text:00004750 var_4           = dword ptr -4
.text:00004750
.text:00004750                 push    ebp
.text:00004751                 mov     ebp, esp
.text:00004753                 push    ecx
.text:00004754                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000475B                 mov     [ebp+var_4], ecx
.text:0000475E                 push    offset _g_ArcInfo ; struct CArcInfo *
.text:00004763                 call    ?RegisterArc@@YGXPBUCArcInfo@@@Z ; RegisterArc(CArcInfo const *)
.text:00004768                 mov     eax, [ebp+var_4]
.text:0000476B                 add     esp, 4
.text:0000476E                 cmp     ebp, esp
.text:00004770                 call    __RTC_CheckEsp
.text:00004775                 mov     esp, ebp
.text:00004777                 pop     ebp
.text:00004778                 retn
.text:00004778 ??0CRegisterArc@NSplit@NArchive@@QAE@XZ endp
.text:00004778
.text:00004778 ; ---------------------------------------------------------------------------
.text:00004779                 align 4
.text:00004779 _text           ends
.text:00004779
.bss:0000477C ; ===========================================================================
.bss:0000477C
.bss:0000477C ; Segment type: Uninitialized
.bss:0000477C ; Segment permissions: Read/Write
.bss:0000477C _bss            segment byte public 'BSS' use32
.bss:0000477C                 assume cs:_bss
.bss:0000477C                 ;org 477Ch
.bss:0000477C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:0000477C ; NArchive::NSplit::CRegisterArc g_RegisterArc
.bss:0000477C _g_RegisterArc  db    ? ;               ; DATA XREF: NArchive::NSplit::`dynamic initializer for 'g_RegisterArc''(void)+3o
.bss:0000477D                 align 10h
.bss:0000477D _bss            ends
.bss:0000477D
.CRT$XCU:00004780 ; ===========================================================================
.CRT$XCU:00004780
.CRT$XCU:00004780 ; Segment type: Pure data
.CRT$XCU:00004780 ; Segment permissions: Read
.CRT$XCU:00004780 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00004780                 assume cs:_CRT$XCU
.CRT$XCU:00004780                 ;org 4780h
.CRT$XCU:00004780 _g_RegisterArc$initializer$ dd offset ??__Eg_RegisterArc@NSplit@NArchive@@YAXXZ ; NArchive::NSplit::`dynamic initializer for 'g_RegisterArc''(void)
.CRT$XCU:00004780 _CRT$XCU        ends
.CRT$XCU:00004780
UNDEF:00004790 ; ===========================================================================
UNDEF:00004790
UNDEF:00004790 ; Segment type: Externs
UNDEF:00004790 ; UNDEF
UNDEF:00004790                 extrn __RTC_Shutdown:near
UNDEF:00004790                                         ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
UNDEF:00004794                 extrn __RTC_InitBase:near
UNDEF:00004794                                         ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
UNDEF:00004798 ; unsigned char const * const k7z_PROPID_To_VARTYPE
UNDEF:00004798                 extrn ?k7z_PROPID_To_VARTYPE@@3QBEB:near
UNDEF:00004798                                         ; DATA XREF: NArchive::NSplit::CHandler::GetPropertyInfo(uint,wchar_t * *,ulong *,ushort *)+24r
UNDEF:00004798                                         ; NArchive::NSplit::CHandler::GetArchivePropertyInfo(uint,wchar_t * *,ulong *,ushort *)+24r
UNDEF:0000479C ; __int32 __thiscall NWindows::NCOM::CPropVariant::Detach(NWindows::NCOM::CPropVariant *__hidden this, struct tagPROPVARIANT *)
UNDEF:0000479C                 extrn ?Detach@CPropVariant@NCOM@NWindows@@QAEJPAUtagPROPVARIANT@@@Z:near
UNDEF:0000479C                                         ; CODE XREF: NArchive::NSplit::CHandler::GetArchiveProperty(ulong,tagPROPVARIANT *)+BDp
UNDEF:0000479C                                         ; NArchive::NSplit::CHandler::GetProperty(uint,ulong,tagPROPVARIANT *)+70p
UNDEF:000047A0 ; public: class NWindows::NCOM::CPropVariant & __thiscall NWindows::NCOM::CPropVariant::operator=(unsigned __int64)
UNDEF:000047A0                 extrn ??4CPropVariant@NCOM@NWindows@@QAEAAV012@_K@Z:near
UNDEF:000047A0                                         ; CODE XREF: NArchive::NSplit::CHandler::GetArchiveProperty(ulong,tagPROPVARIANT *)+86p
UNDEF:000047A0                                         ; NArchive::NSplit::CHandler::GetArchiveProperty(ulong,tagPROPVARIANT *)+9Bp ...
UNDEF:000047A4 ; public: class NWindows::NCOM::CPropVariant & __thiscall NWindows::NCOM::CPropVariant::operator=(unsigned int)
UNDEF:000047A4                 extrn ??4CPropVariant@NCOM@NWindows@@QAEAAV012@I@Z:near
UNDEF:000047A4                                         ; CODE XREF: NArchive::NSplit::CHandler::GetArchiveProperty(ulong,tagPROPVARIANT *)+56p
UNDEF:000047A4                                         ; NArchive::NSplit::CHandler::GetArchiveProperty(ulong,tagPROPVARIANT *)+B1p
UNDEF:000047A8                 extrn __RTC_CheckEsp:near
UNDEF:000047A8                                         ; CODE XREF: NArchive::NSplit::CHandler::GetArchiveProperty(ulong,tagPROPVARIANT *)+EAp
UNDEF:000047A8                                         ; NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+53p ...
UNDEF:000047AC ; __fastcall _RTC_CheckStackVars(x, x)
UNDEF:000047AC                 extrn @_RTC_CheckStackVars@8:near
UNDEF:000047AC                                         ; CODE XREF: NArchive::NSplit::CHandler::GetArchiveProperty(ulong,tagPROPVARIANT *)+DEp
UNDEF:000047AC                                         ; NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+CFBp ...
UNDEF:000047B0 ; __int32 __thiscall NWindows::NCOM::CPropVariant::Clear(NWindows::NCOM::CPropVariant *__hidden this)
UNDEF:000047B0                 extrn ?Clear@CPropVariant@NCOM@NWindows@@QAEJXZ:near
UNDEF:000047B0                                         ; CODE XREF: NWindows::NCOM::CPropVariant::~CPropVariant(void)+11p
UNDEF:000047B4 ; void __thiscall UString::SetFrom(UString *__hidden this, const wchar_t *, unsigned int)
UNDEF:000047B4                 extrn ?SetFrom@UString@@QAEXPB_WI@Z:near
UNDEF:000047B4                                         ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+512p
UNDEF:000047B8 ; void __thiscall UString::SetFromAscii(UString *__hidden this, const char *)
UNDEF:000047B8                 extrn ?SetFromAscii@UString@@QAEXPBD@Z:near
UNDEF:000047B8                                         ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+4F0p
UNDEF:000047BC ; public: class UString & __thiscall UString::operator=(class UString const &)
UNDEF:000047BC                 extrn ??4UString@@QAEAAV0@ABV0@@Z:near
UNDEF:000047BC                                         ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+48Ep
UNDEF:000047BC                                         ; NArchive::NSplit::CSeqName::GetNextName(UString &)+159p
UNDEF:000047C0 ; class UString __stdcall operator+(class UString const &, class UString const &)
UNDEF:000047C0                 extrn ??H@YG?AVUString@@ABV0@0@Z:near
UNDEF:000047C0                                         ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+466p
UNDEF:000047C0                                         ; NArchive::NSplit::CSeqName::GetNextName(UString &)+13Dp
UNDEF:000047C4 ; bool __stdcall StringsAreEqual_Ascii(const wchar_t *, const char *)
UNDEF:000047C4                 extrn ?StringsAreEqual_Ascii@@YG_NPB_WPBD@Z:near
UNDEF:000047C4                                         ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+257p
UNDEF:000047C4                                         ; NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+2E1p
UNDEF:000047C8 ; public: __thiscall UString::UString(class UString const &)
UNDEF:000047C8                 extrn ??0UString@@QAE@ABV0@@Z:near
UNDEF:000047C8                                         ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+200p
UNDEF:000047CC ; public: __thiscall UString::UString(wchar_t const *)
UNDEF:000047CC                 extrn ??0UString@@QAE@PB_W@Z:near
UNDEF:000047CC                                         ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+1EDp
UNDEF:000047D0 ; public: class UString & __thiscall UString::operator=(wchar_t const *)
UNDEF:000047D0                 extrn ??4UString@@QAEAAV0@PB_W@Z:near
UNDEF:000047D0                                         ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+1A7p
UNDEF:000047D0                                         ; NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+4C7p
UNDEF:000047D4 ; public: __thiscall UString::UString(void)
UNDEF:000047D4                 extrn ??0UString@@QAE@XZ:near
UNDEF:000047D4                                         ; CODE XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+D1p
UNDEF:000047D4                                         ; NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+7A9p ...
UNDEF:000047D8                 extrn _IID_IArchiveOpenVolumeCallback:near
UNDEF:000047D8                                         ; DATA XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+82o
UNDEF:000047DC                 extrn ___security_cookie:near
UNDEF:000047DC                                         ; DATA XREF: NArchive::NSplit::CHandler::Open2(IInStream *,IArchiveOpenCallback *)+2Dr
UNDEF:000047DC                                         ; NArchive::NSplit::CHandler::Open(IInStream *,unsigned __int64 const *,IArchiveOpenCallback *)+2Dr ...
UNDEF:000047E0                 extrn ___CxxFrameHandler3:near
UNDEF:000047E0                                         ; CODE XREF: __ehhandler$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z+19j
UNDEF:000047E0                                         ; __ehhandler$?Open@CHandler@NSplit@NArchive@@UAGJPAUIInStream@@PB_KPAUIArchiveOpenCallback@@@Z+16j ...
UNDEF:000047E4 ; __fastcall __security_check_cookie(x)
UNDEF:000047E4                 extrn @__security_check_cookie@4:near
UNDEF:000047E4                                         ; CODE XREF: __ehhandler$?Open2@CHandler@NSplit@NArchive@@AAEJPAUIInStream@@PAUIArchiveOpenCallback@@@Z+Fp
UNDEF:000047E4                                         ; __ehhandler$?Open@CHandler@NSplit@NArchive@@UAGJPAUIInStream@@PB_KPAUIArchiveOpenCallback@@@Z+Cp ...
UNDEF:000047E8 ; void __cdecl operator delete(void *)
UNDEF:000047E8                 extrn ??3@YAXPAX@Z:near ; CODE XREF: __unwindfunclet$?Extract@CHandler@NSplit@NArchive@@UAGJPBIIHPAUIArchiveExtractCallback@@@Z$3+4p
UNDEF:000047E8                                         ; __unwindfunclet$?Extract@CHandler@NSplit@NArchive@@UAGJPBIIHPAUIArchiveExtractCallback@@@Z$5+7p ...
UNDEF:000047EC ; private: __thiscall UString::UString(unsigned int, class UString const &)
UNDEF:000047EC                 extrn ??0UString@@AAE@IABV0@@Z:near
UNDEF:000047EC                                         ; CODE XREF: UString::Left(uint)+29p
UNDEF:000047F0 ; void __stdcall MyStringLower_Ascii(wchar_t *)
UNDEF:000047F0                 extrn ?MyStringLower_Ascii@@YGXPA_W@Z:near
UNDEF:000047F0                                         ; CODE XREF: UString::MakeLower_Ascii(void)+14p
UNDEF:000047F4 ; int __thiscall UString::ReverseFind(UString *__hidden this, wchar_t)
UNDEF:000047F4                 extrn ?ReverseFind@UString@@QBEH_W@Z:near
UNDEF:000047F4                                         ; CODE XREF: UString::ReverseFind_Dot(void)+13p
UNDEF:000047F8 ; void __thiscall UString::InsertAtFront(UString *__hidden this, wchar_t)
UNDEF:000047F8                 extrn ?InsertAtFront@UString@@QAEX_W@Z:near
UNDEF:000047F8                                         ; CODE XREF: NArchive::NSplit::CSeqName::GetNextName(UString &)+FBp
UNDEF:000047FC ; public: class NWindows::NCOM::CPropVariant & __thiscall NWindows::NCOM::CPropVariant::operator=(class UString const &)
UNDEF:000047FC                 extrn ??4CPropVariant@NCOM@NWindows@@QAEAAV012@ABVUString@@@Z:near
UNDEF:000047FC                                         ; CODE XREF: NArchive::NSplit::CHandler::GetProperty(uint,ulong,tagPROPVARIANT *)+4Fp
UNDEF:00004800 ; __int32 __thiscall CLocalProgress::SetCur(CLocalProgress *__hidden this)
UNDEF:00004800                 extrn ?SetCur@CLocalProgress@@QAEJXZ:near
UNDEF:00004800                                         ; CODE XREF: NArchive::NSplit::CHandler::Extract(uint const *,uint,int,IArchiveExtractCallback *)+305p
UNDEF:00004804 ; void __thiscall CLocalProgress::Init(CLocalProgress *__hidden this, struct IProgress *, bool)
UNDEF:00004804                 extrn ?Init@CLocalProgress@@QAEXPAUIProgress@@_N@Z:near
UNDEF:00004804                                         ; CODE XREF: NArchive::NSplit::CHandler::Extract(uint const *,uint,int,IArchiveExtractCallback *)+2ADp
UNDEF:00004808 ; public: __thiscall CLocalProgress::CLocalProgress(void)
UNDEF:00004808                 extrn ??0CLocalProgress@@QAE@XZ:near
UNDEF:00004808                                         ; CODE XREF: NArchive::NSplit::CHandler::Extract(uint const *,uint,int,IArchiveExtractCallback *)+25Ep
UNDEF:0000480C ; void *__cdecl operator new(unsigned int)
UNDEF:0000480C                 extrn ??2@YAPAXI@Z:near ; CODE XREF: NArchive::NSplit::CHandler::Extract(uint const *,uint,int,IArchiveExtractCallback *)+1C5p
UNDEF:0000480C                                         ; NArchive::NSplit::CHandler::Extract(uint const *,uint,int,IArchiveExtractCallback *)+231p ...
UNDEF:00004810 ; const type_info::`vftable'
UNDEF:00004810                 extrn ??_7type_info@@6B@:near
UNDEF:00004810                                         ; DATA XREF: .data:NCompress::CCopyCoder `RTTI Type Descriptor'o
UNDEF:00004810                                         ; .data:ICompressCoder `RTTI Type Descriptor'o ...
UNDEF:00004814 ; public: virtual long __stdcall NCompress::CCopyCoder::Code(struct ISequentialInStream *, struct ISequentialOutStream *, unsigned __int64 const *, unsigned __int64 const *, struct ICompressProgressInfo *)
UNDEF:00004814                 extrn ?Code@CCopyCoder@NCompress@@UAGJPAUISequentialInStream@@PAUISequentialOutStream@@PB_K2PAUICompressProgressInfo@@@Z:near
UNDEF:00004814                                         ; DATA XREF: .rdata:00002520o
UNDEF:00004818 ; public: virtual long __stdcall NCompress::CCopyCoder::SetInStream(struct ISequentialInStream *)
UNDEF:00004818                 extrn ?SetInStream@CCopyCoder@NCompress@@UAGJPAUISequentialInStream@@@Z:near
UNDEF:00004818                                         ; DATA XREF: .rdata:00002508o
UNDEF:0000481C ; public: virtual long __stdcall NCompress::CCopyCoder::ReleaseInStream(void)
UNDEF:0000481C                 extrn ?ReleaseInStream@CCopyCoder@NCompress@@UAGJXZ:near
UNDEF:0000481C                                         ; DATA XREF: .rdata:0000250Co
UNDEF:00004820 ; public: virtual long __stdcall NCompress::CCopyCoder::Read(void *, unsigned int, unsigned int *)
UNDEF:00004820                 extrn ?Read@CCopyCoder@NCompress@@UAGJPAXIPAI@Z:near
UNDEF:00004820                                         ; DATA XREF: .rdata:000024F4o
UNDEF:00004824 ; public: virtual long __stdcall NCompress::CCopyCoder::GetInStreamProcessedSize(unsigned __int64 *)
UNDEF:00004824                 extrn ?GetInStreamProcessedSize@CCopyCoder@NCompress@@UAGJPA_K@Z:near
UNDEF:00004824                                         ; DATA XREF: .rdata:000024E0o
UNDEF:00004828                 extrn _IID_ICompressGetInStreamProcessedSize:near
UNDEF:00004828                                         ; DATA XREF: NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *):loc_29CEo
UNDEF:0000482C                 extrn _IID_ISequentialInStream:near
UNDEF:0000482C                                         ; DATA XREF: NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *):loc_299Ao
UNDEF:00004830                 extrn _IID_ICompressSetInStream:near
UNDEF:00004830                                         ; DATA XREF: NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *):loc_2966o
UNDEF:00004834                 extrn _IID_ICompressCoder:near
UNDEF:00004834                                         ; DATA XREF: NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *):loc_2947o
UNDEF:00004838 ; const IID IID_IUnknown
UNDEF:00004838                 extrn _IID_IUnknown:near
UNDEF:00004838                                         ; DATA XREF: NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *)+24o
UNDEF:00004838                                         ; CMultiStream::QueryInterface(_GUID const &,void * *)+Co ...
UNDEF:0000483C ; int __cdecl memcmp(const void *Buf1, const void *Buf2, size_t Size)
UNDEF:0000483C                 extrn _memcmp:near      ; CODE XREF: IsEqualGUID(x,x)+Dp
UNDEF:00004840                 extrn __purecall:near   ; DATA XREF: .rdata:const ICompressCoder::`vftable'o
UNDEF:00004840                                         ; .rdata:00002B48o ...
UNDEF:00004844 ; _DWORD __thiscall NCompress::CCopyCoder::~CCopyCoder(NCompress::CCopyCoder *__hidden this)
UNDEF:00004844                 extrn ??1CCopyCoder@NCompress@@QAE@XZ:near
UNDEF:00004844                                         ; CODE XREF: NCompress::CCopyCoder::`scalar deleting destructor'(uint)+11p
UNDEF:00004848 ; public: virtual long __stdcall CMultiStream::Read(void *, unsigned int, unsigned int *)
UNDEF:00004848                 extrn ?Read@CMultiStream@@UAGJPAXIPAI@Z:near
UNDEF:00004848                                         ; DATA XREF: .rdata:00002E98o
UNDEF:0000484C ; public: virtual long __stdcall CMultiStream::Seek(__int64, unsigned int, unsigned __int64 *)
UNDEF:0000484C                 extrn ?Seek@CMultiStream@@UAGJ_JIPA_K@Z:near
UNDEF:0000484C                                         ; DATA XREF: .rdata:00002E9Co
UNDEF:00004850                 extrn _IID_IInStream:near
UNDEF:00004850                                         ; DATA XREF: CMultiStream::QueryInterface(_GUID const &,void * *):loc_2FACo
UNDEF:00004854                 extrn _IID_IInArchiveGetStream:near
UNDEF:00004854                                         ; DATA XREF: NArchive::NSplit::CHandler::QueryInterface(_GUID const &,void * *):loc_34A4o
UNDEF:00004858                 extrn _IID_IInArchive:near
UNDEF:00004858                                         ; DATA XREF: NArchive::NSplit::CHandler::QueryInterface(_GUID const &,void * *):loc_3488o
UNDEF:0000485C ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:0000485C                 extrn _memcpy:near      ; CODE XREF: CRecordVector<unsigned __int64>::ReserveOnePosition(void)+87p
UNDEF:0000485C                                         ; CRecordVector<void *>::ReserveOnePosition(void)+87p
UNDEF:00004860 ; void __stdcall RegisterArc(const struct CArcInfo *)
UNDEF:00004860                 extrn ?RegisterArc@@YGXPBUCArcInfo@@@Z:near
UNDEF:00004860                                         ; CODE XREF: NArchive::NSplit::CRegisterArc::CRegisterArc(void)+13p
UNDEF:00004860
UNDEF:00004860
UNDEF:00004860                 end