.bss:00000000 ;
.bss:00000000 ; +-------------------------------------------------------------------------+
.bss:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.bss:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.bss:00000000 ; |                      License info: 48-3677-7074-51                      |
.bss:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.bss:00000000 ; +-------------------------------------------------------------------------+
.bss:00000000 ;
.bss:00000000 ; Input MD5   : 1C4EE00F821EF47FAEF4D1B4C8BCA895
.bss:00000000 ; Input CRC32 : 27D06BDE
.bss:00000000
.bss:00000000 ; File Name   : C:\workspace\7z1505-src\CPP\7zip\Bundles\Alone\Debug\Wildcard.obj
.bss:00000000 ; Format      : COFF (X386MAGIC)
.bss:00000000 ; includelib "uuid.lib"
.bss:00000000 ; includelib "MSVCRTD"
.bss:00000000 ; includelib "OLDNAMES"
.bss:00000000
.bss:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.bss:00000000
.bss:00000000                 .686p
.bss:00000000                 .mmx
.bss:00000000                 .model flat
.bss:00000000
.bss:00000000 ; ===========================================================================
.bss:00000000
.bss:00000000 ; Segment type: Uninitialized
.bss:00000000 ; Segment permissions: Read/Write
.bss:00000000 _bss            segment byte public 'BSS' use32
.bss:00000000                 assume cs:_bss
.bss:00000000                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00000000                 public ?g_CaseSensitive@@3_NA
.bss:00000000 ; bool g_CaseSensitive
.bss:00000000 ?g_CaseSensitive@@3_NA db ?             ; DATA XREF: IsPath1PrefixedByPath2(wchar_t const *,wchar_t const *):loc_3Fr
.bss:00000000                                         ; CompareFileNames(wchar_t const *,wchar_t const *)+4r ...
.bss:00000001                 align 4
.bss:00000001 _bss            ends
.bss:00000001
.rdata:00000004 ; ===========================================================================
.rdata:00000004
.rdata:00000004 ; Segment type: Pure data
.rdata:00000004 ; Segment permissions: Read
.rdata:00000004 _rdata          segment dword public 'DATA' use32
.rdata:00000004                 assume cs:_rdata
.rdata:00000004                 ;org 4
.rdata:00000004 ; wchar_t _SG67687
.rdata:00000004 $SG67687        dd offset $SG67928+2    ; DATA XREF: NWildcard::CItem::AreAllAllowed(void)+45o
.rdata:00000008 ; wchar_t _SG67871
.rdata:00000008 $SG67871        dd offset loc_3F        ; DATA XREF: NWildcard::GetNumPrefixParts_if_DrivePath(CObjectVector<UString> &)+65o
.rdata:0000000C ; wchar_t _SG67889
.rdata:0000000C $SG67889        dd offset $SG67943+2    ; DATA XREF: NWildcard::GetNumPrefixParts(CObjectVector<UString>):loc_19A3o
.rdata:0000000C                                         ; "."
.rdata:00000010 ; wchar_t _SG67893
.rdata:00000010 $SG67893        dd offset loc_3F        ; DATA XREF: NWildcard::GetNumPrefixParts(CObjectVector<UString>)+1A8o
.rdata:00000014 ; char _SG67899[4]
.rdata:00000014 $SG67899        db 'UNC',0              ; DATA XREF: NWildcard::GetNumPrefixParts(CObjectVector<UString>):loc_1A6Bo
.rdata:00000018 $SG67921        db 'Empty file path',0  ; DATA XREF: NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+4Fo
.rdata:00000028 ; wchar_t _SG67928
.rdata:00000028 $SG67928        dd offset loc_3F        ; DATA XREF: NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+F6o
.rdata:00000028                                         ; .rdata:$SG67687o ...
.rdata:0000002C ; wchar_t _SG67943
.rdata:0000002C $SG67943:                               ; DATA XREF: NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+1B6o
.rdata:0000002C                                         ; .rdata:$SG67889o ...
.rdata:0000002C                 unicode 0, <..>,0
.rdata:00000032                 align 4
.rdata:00000034 ; wchar_t _SG67944
.rdata:00000034 $SG67944        dd offset $SG67943+2    ; DATA XREF: NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+1CBo
.rdata:00000034                                         ; "."
.rdata:00000038 $SG67963        dd offset $SG67928+2    ; DATA XREF: NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+31Do
.rdata:00000038 _rdata          ends
.rdata:00000038
.text:0000003C ; ===========================================================================
.text:0000003C
.text:0000003C ; Segment type: Pure code
.text:0000003C ; Segment permissions: Read/Execute
.text:0000003C _text           segment para public 'CODE' use32
.text:0000003C                 assume cs:_text
.text:0000003C                 ;org 3Ch
.text:0000003C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000003C
.text:0000003C ; =============== S U B R O U T I N E =======================================
.text:0000003C
.text:0000003C ; Attributes: bp-based frame
.text:0000003C
.text:0000003C ; bool __stdcall IsPath1PrefixedByPath2(const wchar_t *, const wchar_t *)
.text:0000003C                 public ?IsPath1PrefixedByPath2@@YG_NPB_W0@Z
.text:0000003C ?IsPath1PrefixedByPath2@@YG_NPB_W0@Z proc near
.text:0000003C
.text:0000003C arg_0           = dword ptr  8
.text:0000003C arg_4           = dword ptr  0Ch
.text:0000003C
.text:0000003C                 push    ebp
.text:0000003D                 mov     ebp, esp
.text:0000003F
.text:0000003F loc_3F:                                 ; DATA XREF: .rdata:$SG67871o
.text:0000003F                                         ; .rdata:$SG67893o ...
.text:0000003F                 movzx   eax, ds:?g_CaseSensitive@@3_NA ; bool g_CaseSensitive
.text:00000046                 test    eax, eax
.text:00000048                 jz      short loc_59
.text:0000004A                 mov     ecx, [ebp+arg_4]
.text:0000004D                 push    ecx             ; wchar_t *
.text:0000004E                 mov     edx, [ebp+arg_0]
.text:00000051                 push    edx             ; wchar_t *
.text:00000052                 call    ?IsString1PrefixedByString2@@YG_NPB_W0@Z ; IsString1PrefixedByString2(wchar_t const *,wchar_t const *)
.text:00000057                 jmp     short loc_66
.text:00000059 ; ---------------------------------------------------------------------------
.text:00000059
.text:00000059 loc_59:                                 ; CODE XREF: IsPath1PrefixedByPath2(wchar_t const *,wchar_t const *)+Cj
.text:00000059                 mov     eax, [ebp+arg_4]
.text:0000005C                 push    eax             ; wchar_t *
.text:0000005D                 mov     ecx, [ebp+arg_0]
.text:00000060                 push    ecx             ; wchar_t *
.text:00000061                 call    ?IsString1PrefixedByString2_NoCase@@YG_NPB_W0@Z ; IsString1PrefixedByString2_NoCase(wchar_t const *,wchar_t const *)
.text:00000066
.text:00000066 loc_66:                                 ; CODE XREF: IsPath1PrefixedByPath2(wchar_t const *,wchar_t const *)+1Bj
.text:00000066                 cmp     ebp, esp
.text:00000068                 call    __RTC_CheckEsp
.text:0000006D                 pop     ebp
.text:0000006E                 retn    8
.text:0000006E ?IsPath1PrefixedByPath2@@YG_NPB_W0@Z endp
.text:0000006E
.text:0000006E ; ---------------------------------------------------------------------------
.text:00000071                 db 0Bh dup(0CCh)
.text:0000007C
.text:0000007C ; =============== S U B R O U T I N E =======================================
.text:0000007C
.text:0000007C ; Attributes: bp-based frame
.text:0000007C
.text:0000007C ; int __stdcall CompareFileNames(const wchar_t *Str1, const wchar_t *Str2)
.text:0000007C                 public ?CompareFileNames@@YGHPB_W0@Z
.text:0000007C ?CompareFileNames@@YGHPB_W0@Z proc near ; CODE XREF: NWildcard::CItem::CheckPath(CObjectVector<UString> const &,bool)+180p
.text:0000007C                                         ; NWildcard::CCensorNode::FindSubNode(UString const &)+5Cp ...
.text:0000007C
.text:0000007C Str1            = dword ptr  8
.text:0000007C Str2            = dword ptr  0Ch
.text:0000007C
.text:0000007C                 push    ebp
.text:0000007D                 mov     ebp, esp
.text:0000007F                 push    esi
.text:00000080                 movzx   eax, ds:?g_CaseSensitive@@3_NA ; bool g_CaseSensitive
.text:00000087                 test    eax, eax
.text:00000089                 jz      short loc_A7
.text:0000008B                 mov     esi, esp
.text:0000008D                 mov     ecx, [ebp+Str2]
.text:00000090                 push    ecx             ; Str2
.text:00000091                 mov     edx, [ebp+Str1]
.text:00000094                 push    edx             ; Str1
.text:00000095                 call    dword ptr ds:__imp__wcscmp
.text:0000009B                 add     esp, 8
.text:0000009E                 cmp     esi, esp
.text:000000A0                 call    __RTC_CheckEsp
.text:000000A5                 jmp     short loc_B4
.text:000000A7 ; ---------------------------------------------------------------------------
.text:000000A7
.text:000000A7 loc_A7:                                 ; CODE XREF: CompareFileNames(wchar_t const *,wchar_t const *)+Dj
.text:000000A7                 mov     eax, [ebp+Str2]
.text:000000AA                 push    eax             ; wchar_t *
.text:000000AB                 mov     ecx, [ebp+Str1]
.text:000000AE                 push    ecx             ; wchar_t *
.text:000000AF                 call    ?MyStringCompareNoCase@@YGHPB_W0@Z ; MyStringCompareNoCase(wchar_t const *,wchar_t const *)
.text:000000B4
.text:000000B4 loc_B4:                                 ; CODE XREF: CompareFileNames(wchar_t const *,wchar_t const *)+29j
.text:000000B4                 pop     esi
.text:000000B5                 cmp     ebp, esp
.text:000000B7                 call    __RTC_CheckEsp
.text:000000BC                 pop     ebp
.text:000000BD                 retn    8
.text:000000BD ?CompareFileNames@@YGHPB_W0@Z endp
.text:000000BD
.text:000000BD ; ---------------------------------------------------------------------------
.text:000000C0                 db 0Ch dup(0CCh)
.text:000000CC
.text:000000CC ; =============== S U B R O U T I N E =======================================
.text:000000CC
.text:000000CC ; Attributes: bp-based frame
.text:000000CC
.text:000000CC ; int __stdcall SplitPathToParts(UString *, int)
.text:000000CC                 public ?SplitPathToParts@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z
.text:000000CC ?SplitPathToParts@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z proc near
.text:000000CC                                         ; CODE XREF: NWildcard::CCensorNode::AddItem(bool,UString const &,bool,bool,bool,bool)+59p
.text:000000CC                                         ; NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+7Bp
.text:000000CC
.text:000000CC var_2C          = dword ptr -2Ch
.text:000000CC var_28          = dword ptr -28h
.text:000000CC var_24          = dword ptr -24h
.text:000000CC var_20          = dword ptr -20h
.text:000000CC var_1C          = dword ptr -1Ch
.text:000000CC var_18          = dword ptr -18h
.text:000000CC var_14          = dword ptr -14h
.text:000000CC var_10          = dword ptr -10h
.text:000000CC var_C           = dword ptr -0Ch
.text:000000CC var_4           = dword ptr -4
.text:000000CC arg_0           = dword ptr  8
.text:000000CC arg_4           = dword ptr  0Ch
.text:000000CC
.text:000000CC                 push    ebp
.text:000000CD                 mov     ebp, esp
.text:000000CF                 push    0FFFFFFFFh
.text:000000D1                 push    offset __ehhandler$?SplitPathToParts@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z
.text:000000D6                 mov     eax, large fs:0
.text:000000DC                 push    eax
.text:000000DD                 sub     esp, 20h
.text:000000E0                 mov     eax, 0CCCCCCCCh
.text:000000E5                 mov     [ebp+var_2C], eax
.text:000000E8                 mov     [ebp+var_28], eax
.text:000000EB                 mov     [ebp+var_24], eax
.text:000000EE                 mov     [ebp+var_20], eax
.text:000000F1                 mov     [ebp+var_1C], eax
.text:000000F4                 mov     [ebp+var_18], eax
.text:000000F7                 mov     [ebp+var_14], eax
.text:000000FA                 mov     [ebp+var_10], eax
.text:000000FD                 mov     eax, dword ptr ds:___security_cookie
.text:00000102                 xor     eax, ebp
.text:00000104                 push    eax
.text:00000105                 lea     eax, [ebp+var_C]
.text:00000108                 mov     large fs:0, eax
.text:0000010E                 mov     ecx, [ebp+arg_4]
.text:00000111                 call    ?Clear@?$CObjectVector@VUString@@@@QAEXXZ ; CObjectVector<UString>::Clear(void)
.text:00000116                 mov     ecx, [ebp+arg_0] ; this
.text:00000119                 call    ?Len@UString@@QBEIXZ ; UString::Len(void)
.text:0000011E                 mov     [ebp+var_10], eax
.text:00000121                 cmp     [ebp+var_10], 0
.text:00000125                 jnz     short loc_12C
.text:00000127                 jmp     loc_1E2
.text:0000012C ; ---------------------------------------------------------------------------
.text:0000012C
.text:0000012C loc_12C:                                ; CODE XREF: SplitPathToParts(UString const &,CObjectVector<UString> &)+59j
.text:0000012C                 lea     ecx, [ebp+var_20]
.text:0000012F                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00000134                 mov     [ebp+var_4], 0
.text:0000013B                 mov     [ebp+var_28], 0
.text:00000142                 mov     [ebp+var_2C], 0
.text:00000149                 jmp     short loc_154
.text:0000014B ; ---------------------------------------------------------------------------
.text:0000014B
.text:0000014B loc_14B:                                ; CODE XREF: SplitPathToParts(UString const &,CObjectVector<UString> &):loc_1A9j
.text:0000014B                 mov     eax, [ebp+var_2C]
.text:0000014E                 add     eax, 1
.text:00000151                 mov     [ebp+var_2C], eax
.text:00000154
.text:00000154 loc_154:                                ; CODE XREF: SplitPathToParts(UString const &,CObjectVector<UString> &)+7Dj
.text:00000154                 mov     ecx, [ebp+var_2C]
.text:00000157                 cmp     ecx, [ebp+var_10]
.text:0000015A                 jnb     short loc_1AB
.text:0000015C                 mov     ecx, [ebp+arg_0]
.text:0000015F                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00000164                 mov     edx, [ebp+var_2C]
.text:00000167                 movzx   eax, word ptr [eax+edx*2]
.text:0000016B                 push    eax             ; wchar_t
.text:0000016C                 call    ?IsPathSepar@@YG_N_W@Z ; IsPathSepar(wchar_t)
.text:00000171                 movzx   ecx, al
.text:00000174                 test    ecx, ecx
.text:00000176                 jz      short loc_1A9
.text:00000178                 mov     edx, [ebp+var_2C]
.text:0000017B                 sub     edx, [ebp+var_28]
.text:0000017E                 push    edx             ; unsigned int
.text:0000017F                 mov     eax, [ebp+var_28]
.text:00000182                 push    eax             ; unsigned int
.text:00000183                 mov     ecx, [ebp+arg_0] ; this
.text:00000186                 call    ?Ptr@UString@@QBEPB_WI@Z ; UString::Ptr(uint)
.text:0000018B                 push    eax             ; wchar_t *
.text:0000018C                 lea     ecx, [ebp+var_20] ; this
.text:0000018F                 call    ?SetFrom@UString@@QAEXPB_WI@Z ; UString::SetFrom(wchar_t const *,uint)
.text:00000194                 lea     ecx, [ebp+var_20]
.text:00000197                 push    ecx
.text:00000198                 mov     ecx, [ebp+arg_4]
.text:0000019B                 call    ?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z ; CObjectVector<UString>::Add(UString const &)
.text:000001A0                 mov     edx, [ebp+var_2C]
.text:000001A3                 add     edx, 1
.text:000001A6                 mov     [ebp+var_28], edx
.text:000001A9
.text:000001A9 loc_1A9:                                ; CODE XREF: SplitPathToParts(UString const &,CObjectVector<UString> &)+AAj
.text:000001A9                 jmp     short loc_14B
.text:000001AB ; ---------------------------------------------------------------------------
.text:000001AB
.text:000001AB loc_1AB:                                ; CODE XREF: SplitPathToParts(UString const &,CObjectVector<UString> &)+8Ej
.text:000001AB                 mov     eax, [ebp+var_10]
.text:000001AE                 sub     eax, [ebp+var_28]
.text:000001B1                 push    eax             ; unsigned int
.text:000001B2                 mov     ecx, [ebp+var_28]
.text:000001B5                 push    ecx             ; unsigned int
.text:000001B6                 mov     ecx, [ebp+arg_0] ; this
.text:000001B9                 call    ?Ptr@UString@@QBEPB_WI@Z ; UString::Ptr(uint)
.text:000001BE                 push    eax             ; wchar_t *
.text:000001BF                 lea     ecx, [ebp+var_20] ; this
.text:000001C2                 call    ?SetFrom@UString@@QAEXPB_WI@Z ; UString::SetFrom(wchar_t const *,uint)
.text:000001C7                 lea     edx, [ebp+var_20]
.text:000001CA                 push    edx
.text:000001CB                 mov     ecx, [ebp+arg_4]
.text:000001CE                 call    ?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z ; CObjectVector<UString>::Add(UString const &)
.text:000001D3                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000001DA                 lea     ecx, [ebp+var_20] ; this
.text:000001DD                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000001E2
.text:000001E2 loc_1E2:                                ; CODE XREF: SplitPathToParts(UString const &,CObjectVector<UString> &)+5Bj
.text:000001E2                 push    edx
.text:000001E3                 mov     ecx, ebp
.text:000001E5                 push    eax
.text:000001E6                 lea     edx, $LN12
.text:000001EC                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:000001F1                 pop     eax
.text:000001F2                 pop     edx
.text:000001F3                 mov     ecx, [ebp+var_C]
.text:000001F6                 mov     large fs:0, ecx
.text:000001FD                 pop     ecx
.text:000001FE                 add     esp, 2Ch
.text:00000201                 cmp     ebp, esp
.text:00000203                 call    __RTC_CheckEsp
.text:00000208                 mov     esp, ebp
.text:0000020A                 pop     ebp
.text:0000020B                 retn    8
.text:0000020B ?SplitPathToParts@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z endp
.text:0000020B
.text:0000020B ; ---------------------------------------------------------------------------
.text:0000020E                 align 10h
.text:00000210 $LN12           dd 1                    ; DATA XREF: SplitPathToParts(UString const &,CObjectVector<UString> &)+11Ao
.text:00000214                 dd offset $LN11
.text:00000218 $LN11           dd 0FFFFFFE0h, 0Ch      ; DATA XREF: .text:00000214o
.text:00000220                 dd offset $LN9          ; "name"
.text:00000224 $LN9            db 'name',0             ; DATA XREF: .text:00000220o
.text:00000229                 align 4
.text:0000022C
.text:0000022C ; =============== S U B R O U T I N E =======================================
.text:0000022C
.text:0000022C ; Attributes: bp-based frame
.text:0000022C
.text:0000022C ; void __stdcall SplitPathToParts_2(const struct UString *, struct UString *, struct UString *)
.text:0000022C                 public ?SplitPathToParts_2@@YGXABVUString@@AAV1@1@Z
.text:0000022C ?SplitPathToParts_2@@YGXABVUString@@AAV1@1@Z proc near
.text:0000022C
.text:0000022C var_8           = dword ptr -8
.text:0000022C var_4           = dword ptr -4
.text:0000022C arg_0           = dword ptr  8
.text:0000022C arg_4           = dword ptr  0Ch
.text:0000022C arg_8           = dword ptr  10h
.text:0000022C
.text:0000022C                 push    ebp
.text:0000022D                 mov     ebp, esp
.text:0000022F                 sub     esp, 8
.text:00000232                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00000239                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000240                 mov     ecx, [ebp+arg_0]
.text:00000243                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00000248                 mov     [ebp+var_4], eax
.text:0000024B                 mov     ecx, [ebp+arg_0] ; this
.text:0000024E                 call    ?Len@UString@@QBEIXZ ; UString::Len(void)
.text:00000253                 mov     ecx, [ebp+var_4]
.text:00000256                 lea     edx, [ecx+eax*2]
.text:00000259                 mov     [ebp+var_8], edx
.text:0000025C                 jmp     short loc_267
.text:0000025E ; ---------------------------------------------------------------------------
.text:0000025E
.text:0000025E loc_25E:                                ; CODE XREF: SplitPathToParts_2(UString const &,UString &,UString &):loc_285j
.text:0000025E                 mov     eax, [ebp+var_8]
.text:00000261                 sub     eax, 2
.text:00000264                 mov     [ebp+var_8], eax
.text:00000267
.text:00000267 loc_267:                                ; CODE XREF: SplitPathToParts_2(UString const &,UString &,UString &)+30j
.text:00000267                 mov     ecx, [ebp+var_8]
.text:0000026A                 cmp     ecx, [ebp+var_4]
.text:0000026D                 jz      short loc_287
.text:0000026F                 mov     edx, [ebp+var_8]
.text:00000272                 movzx   eax, word ptr [edx-2]
.text:00000276                 push    eax             ; wchar_t
.text:00000277                 call    ?IsPathSepar@@YG_N_W@Z ; IsPathSepar(wchar_t)
.text:0000027C                 movzx   ecx, al
.text:0000027F                 test    ecx, ecx
.text:00000281                 jz      short loc_285
.text:00000283                 jmp     short loc_287
.text:00000285 ; ---------------------------------------------------------------------------
.text:00000285
.text:00000285 loc_285:                                ; CODE XREF: SplitPathToParts_2(UString const &,UString &,UString &)+55j
.text:00000285                 jmp     short loc_25E
.text:00000287 ; ---------------------------------------------------------------------------
.text:00000287
.text:00000287 loc_287:                                ; CODE XREF: SplitPathToParts_2(UString const &,UString &,UString &)+41j
.text:00000287                                         ; SplitPathToParts_2(UString const &,UString &,UString &)+57j
.text:00000287                 mov     edx, [ebp+var_8]
.text:0000028A                 sub     edx, [ebp+var_4]
.text:0000028D                 sar     edx, 1
.text:0000028F                 push    edx             ; unsigned int
.text:00000290                 mov     ecx, [ebp+arg_0]
.text:00000293                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00000298                 push    eax             ; wchar_t *
.text:00000299                 mov     ecx, [ebp+arg_4] ; this
.text:0000029C                 call    ?SetFrom@UString@@QAEXPB_WI@Z ; UString::SetFrom(wchar_t const *,uint)
.text:000002A1                 mov     eax, [ebp+var_8]
.text:000002A4                 push    eax
.text:000002A5                 mov     ecx, [ebp+arg_8]
.text:000002A8                 call    ??4UString@@QAEAAV0@PB_W@Z ; UString::operator=(wchar_t const *)
.text:000002AD                 add     esp, 8
.text:000002B0                 cmp     ebp, esp
.text:000002B2                 call    __RTC_CheckEsp
.text:000002B7                 mov     esp, ebp
.text:000002B9                 pop     ebp
.text:000002BA                 retn    0Ch
.text:000002BA ?SplitPathToParts_2@@YGXABVUString@@AAV1@1@Z endp
.text:000002BA
.text:000002BA ; ---------------------------------------------------------------------------
.text:000002BD                 db 0Fh dup(0CCh)
.text:000002CC
.text:000002CC ; =============== S U B R O U T I N E =======================================
.text:000002CC
.text:000002CC ; Attributes: bp-based frame
.text:000002CC
.text:000002CC ; void __stdcall SplitPathToParts_Smart(const struct UString *, struct UString *, struct UString *)
.text:000002CC                 public ?SplitPathToParts_Smart@@YGXABVUString@@AAV1@1@Z
.text:000002CC ?SplitPathToParts_Smart@@YGXABVUString@@AAV1@1@Z proc near
.text:000002CC
.text:000002CC var_8           = dword ptr -8
.text:000002CC var_4           = dword ptr -4
.text:000002CC arg_0           = dword ptr  8
.text:000002CC arg_4           = dword ptr  0Ch
.text:000002CC arg_8           = dword ptr  10h
.text:000002CC
.text:000002CC                 push    ebp
.text:000002CD                 mov     ebp, esp
.text:000002CF                 sub     esp, 8
.text:000002D2                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000002D9                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000002E0                 mov     ecx, [ebp+arg_0]
.text:000002E3                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000002E8                 mov     [ebp+var_4], eax
.text:000002EB                 mov     ecx, [ebp+arg_0] ; this
.text:000002EE                 call    ?Len@UString@@QBEIXZ ; UString::Len(void)
.text:000002F3                 mov     ecx, [ebp+var_4]
.text:000002F6                 lea     edx, [ecx+eax*2]
.text:000002F9                 mov     [ebp+var_8], edx
.text:000002FC                 mov     eax, [ebp+var_8]
.text:000002FF                 cmp     eax, [ebp+var_4]
.text:00000302                 jz      short loc_34C
.text:00000304                 mov     ecx, [ebp+var_8]
.text:00000307                 movzx   edx, word ptr [ecx-2]
.text:0000030B                 push    edx             ; wchar_t
.text:0000030C                 call    ?IsPathSepar@@YG_N_W@Z ; IsPathSepar(wchar_t)
.text:00000311                 movzx   eax, al
.text:00000314                 test    eax, eax
.text:00000316                 jz      short loc_321
.text:00000318                 mov     ecx, [ebp+var_8]
.text:0000031B                 sub     ecx, 2
.text:0000031E                 mov     [ebp+var_8], ecx
.text:00000321
.text:00000321 loc_321:                                ; CODE XREF: SplitPathToParts_Smart(UString const &,UString &,UString &)+4Aj
.text:00000321                 jmp     short loc_32C
.text:00000323 ; ---------------------------------------------------------------------------
.text:00000323
.text:00000323 loc_323:                                ; CODE XREF: SplitPathToParts_Smart(UString const &,UString &,UString &):loc_34Aj
.text:00000323                 mov     edx, [ebp+var_8]
.text:00000326                 sub     edx, 2
.text:00000329                 mov     [ebp+var_8], edx
.text:0000032C
.text:0000032C loc_32C:                                ; CODE XREF: SplitPathToParts_Smart(UString const &,UString &,UString &):loc_321j
.text:0000032C                 mov     eax, [ebp+var_8]
.text:0000032F                 cmp     eax, [ebp+var_4]
.text:00000332                 jz      short loc_34C
.text:00000334                 mov     ecx, [ebp+var_8]
.text:00000337                 movzx   edx, word ptr [ecx-2]
.text:0000033B                 push    edx             ; wchar_t
.text:0000033C                 call    ?IsPathSepar@@YG_N_W@Z ; IsPathSepar(wchar_t)
.text:00000341                 movzx   eax, al
.text:00000344                 test    eax, eax
.text:00000346                 jz      short loc_34A
.text:00000348                 jmp     short loc_34C
.text:0000034A ; ---------------------------------------------------------------------------
.text:0000034A
.text:0000034A loc_34A:                                ; CODE XREF: SplitPathToParts_Smart(UString const &,UString &,UString &)+7Aj
.text:0000034A                 jmp     short loc_323
.text:0000034C ; ---------------------------------------------------------------------------
.text:0000034C
.text:0000034C loc_34C:                                ; CODE XREF: SplitPathToParts_Smart(UString const &,UString &,UString &)+36j
.text:0000034C                                         ; SplitPathToParts_Smart(UString const &,UString &,UString &)+66j ...
.text:0000034C                 mov     ecx, [ebp+var_8]
.text:0000034F                 sub     ecx, [ebp+var_4]
.text:00000352                 sar     ecx, 1
.text:00000354                 push    ecx             ; unsigned int
.text:00000355                 mov     ecx, [ebp+arg_0]
.text:00000358                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:0000035D                 push    eax             ; wchar_t *
.text:0000035E                 mov     ecx, [ebp+arg_4] ; this
.text:00000361                 call    ?SetFrom@UString@@QAEXPB_WI@Z ; UString::SetFrom(wchar_t const *,uint)
.text:00000366                 mov     edx, [ebp+var_8]
.text:00000369                 push    edx
.text:0000036A                 mov     ecx, [ebp+arg_8]
.text:0000036D                 call    ??4UString@@QAEAAV0@PB_W@Z ; UString::operator=(wchar_t const *)
.text:00000372                 add     esp, 8
.text:00000375                 cmp     ebp, esp
.text:00000377                 call    __RTC_CheckEsp
.text:0000037C                 mov     esp, ebp
.text:0000037E                 pop     ebp
.text:0000037F                 retn    0Ch
.text:0000037F ?SplitPathToParts_Smart@@YGXABVUString@@AAV1@1@Z endp
.text:0000037F
.text:0000037F ; ---------------------------------------------------------------------------
.text:00000382                 db 0Ah dup(0CCh)
.text:0000038C
.text:0000038C ; =============== S U B R O U T I N E =======================================
.text:0000038C
.text:0000038C ; Attributes: bp-based frame
.text:0000038C
.text:0000038C ; class UString __stdcall ExtractDirPrefixFromPath(class UString const &)
.text:0000038C                 public ?ExtractDirPrefixFromPath@@YG?AVUString@@ABV1@@Z
.text:0000038C ?ExtractDirPrefixFromPath@@YG?AVUString@@ABV1@@Z proc near
.text:0000038C
.text:0000038C var_C           = dword ptr -0Ch
.text:0000038C var_8           = dword ptr -8
.text:0000038C var_4           = dword ptr -4
.text:0000038C arg_0           = dword ptr  8
.text:0000038C arg_4           = dword ptr  0Ch
.text:0000038C
.text:0000038C                 push    ebp
.text:0000038D                 mov     ebp, esp
.text:0000038F                 sub     esp, 0Ch
.text:00000392                 mov     [ebp+var_C], 0CCCCCCCCh
.text:00000399                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000003A0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000003A7                 mov     [ebp+var_C], 0
.text:000003AE                 mov     ecx, [ebp+arg_4]
.text:000003B1                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000003B6                 mov     [ebp+var_4], eax
.text:000003B9                 mov     ecx, [ebp+arg_4] ; this
.text:000003BC                 call    ?Len@UString@@QBEIXZ ; UString::Len(void)
.text:000003C1                 mov     ecx, [ebp+var_4]
.text:000003C4                 lea     edx, [ecx+eax*2]
.text:000003C7                 mov     [ebp+var_8], edx
.text:000003CA                 jmp     short loc_3D5
.text:000003CC ; ---------------------------------------------------------------------------
.text:000003CC
.text:000003CC loc_3CC:                                ; CODE XREF: ExtractDirPrefixFromPath(UString const &):loc_3F3j
.text:000003CC                 mov     eax, [ebp+var_8]
.text:000003CF                 sub     eax, 2
.text:000003D2                 mov     [ebp+var_8], eax
.text:000003D5
.text:000003D5 loc_3D5:                                ; CODE XREF: ExtractDirPrefixFromPath(UString const &)+3Ej
.text:000003D5                 mov     ecx, [ebp+var_8]
.text:000003D8                 cmp     ecx, [ebp+var_4]
.text:000003DB                 jz      short loc_3F5
.text:000003DD                 mov     edx, [ebp+var_8]
.text:000003E0                 movzx   eax, word ptr [edx-2]
.text:000003E4                 push    eax             ; wchar_t
.text:000003E5                 call    ?IsPathSepar@@YG_N_W@Z ; IsPathSepar(wchar_t)
.text:000003EA                 movzx   ecx, al
.text:000003ED                 test    ecx, ecx
.text:000003EF                 jz      short loc_3F3
.text:000003F1                 jmp     short loc_3F5
.text:000003F3 ; ---------------------------------------------------------------------------
.text:000003F3
.text:000003F3 loc_3F3:                                ; CODE XREF: ExtractDirPrefixFromPath(UString const &)+63j
.text:000003F3                 jmp     short loc_3CC
.text:000003F5 ; ---------------------------------------------------------------------------
.text:000003F5
.text:000003F5 loc_3F5:                                ; CODE XREF: ExtractDirPrefixFromPath(UString const &)+4Fj
.text:000003F5                                         ; ExtractDirPrefixFromPath(UString const &)+65j
.text:000003F5                 mov     edx, [ebp+var_8]
.text:000003F8                 sub     edx, [ebp+var_4]
.text:000003FB                 sar     edx, 1
.text:000003FD                 push    edx
.text:000003FE                 mov     eax, [ebp+arg_0]
.text:00000401                 push    eax
.text:00000402                 mov     ecx, [ebp+arg_4]
.text:00000405                 call    ?Left@UString@@QBE?AV1@I@Z ; UString::Left(uint)
.text:0000040A                 mov     ecx, [ebp+var_C]
.text:0000040D                 or      ecx, 1
.text:00000410                 mov     [ebp+var_C], ecx
.text:00000413                 mov     eax, [ebp+arg_0]
.text:00000416                 add     esp, 0Ch
.text:00000419                 cmp     ebp, esp
.text:0000041B                 call    __RTC_CheckEsp
.text:00000420                 mov     esp, ebp
.text:00000422                 pop     ebp
.text:00000423                 retn    8
.text:00000423 ?ExtractDirPrefixFromPath@@YG?AVUString@@ABV1@@Z endp
.text:00000423
.text:00000423 ; ---------------------------------------------------------------------------
.text:00000426                 db 6 dup(0CCh)
.text:0000042C
.text:0000042C ; =============== S U B R O U T I N E =======================================
.text:0000042C
.text:0000042C ; Attributes: bp-based frame
.text:0000042C
.text:0000042C ; class UString __stdcall ExtractFileNameFromPath(class UString const &)
.text:0000042C                 public ?ExtractFileNameFromPath@@YG?AVUString@@ABV1@@Z
.text:0000042C ?ExtractFileNameFromPath@@YG?AVUString@@ABV1@@Z proc near
.text:0000042C
.text:0000042C var_C           = dword ptr -0Ch
.text:0000042C var_8           = dword ptr -8
.text:0000042C var_4           = dword ptr -4
.text:0000042C arg_0           = dword ptr  8
.text:0000042C arg_4           = dword ptr  0Ch
.text:0000042C
.text:0000042C                 push    ebp
.text:0000042D                 mov     ebp, esp
.text:0000042F                 sub     esp, 0Ch
.text:00000432                 mov     [ebp+var_C], 0CCCCCCCCh
.text:00000439                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00000440                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000447                 mov     [ebp+var_C], 0
.text:0000044E                 mov     ecx, [ebp+arg_4]
.text:00000451                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00000456                 mov     [ebp+var_4], eax
.text:00000459                 mov     ecx, [ebp+arg_4] ; this
.text:0000045C                 call    ?Len@UString@@QBEIXZ ; UString::Len(void)
.text:00000461                 mov     ecx, [ebp+var_4]
.text:00000464                 lea     edx, [ecx+eax*2]
.text:00000467                 mov     [ebp+var_8], edx
.text:0000046A                 jmp     short loc_475
.text:0000046C ; ---------------------------------------------------------------------------
.text:0000046C
.text:0000046C loc_46C:                                ; CODE XREF: ExtractFileNameFromPath(UString const &):loc_493j
.text:0000046C                 mov     eax, [ebp+var_8]
.text:0000046F                 sub     eax, 2
.text:00000472                 mov     [ebp+var_8], eax
.text:00000475
.text:00000475 loc_475:                                ; CODE XREF: ExtractFileNameFromPath(UString const &)+3Ej
.text:00000475                 mov     ecx, [ebp+var_8]
.text:00000478                 cmp     ecx, [ebp+var_4]
.text:0000047B                 jz      short loc_495
.text:0000047D                 mov     edx, [ebp+var_8]
.text:00000480                 movzx   eax, word ptr [edx-2]
.text:00000484                 push    eax             ; wchar_t
.text:00000485                 call    ?IsPathSepar@@YG_N_W@Z ; IsPathSepar(wchar_t)
.text:0000048A                 movzx   ecx, al
.text:0000048D                 test    ecx, ecx
.text:0000048F                 jz      short loc_493
.text:00000491                 jmp     short loc_495
.text:00000493 ; ---------------------------------------------------------------------------
.text:00000493
.text:00000493 loc_493:                                ; CODE XREF: ExtractFileNameFromPath(UString const &)+63j
.text:00000493                 jmp     short loc_46C
.text:00000495 ; ---------------------------------------------------------------------------
.text:00000495
.text:00000495 loc_495:                                ; CODE XREF: ExtractFileNameFromPath(UString const &)+4Fj
.text:00000495                                         ; ExtractFileNameFromPath(UString const &)+65j
.text:00000495                 mov     edx, [ebp+var_8]
.text:00000498                 push    edx
.text:00000499                 mov     ecx, [ebp+arg_0]
.text:0000049C                 call    ??0UString@@QAE@PB_W@Z ; UString::UString(wchar_t const *)
.text:000004A1                 mov     eax, [ebp+var_C]
.text:000004A4                 or      eax, 1
.text:000004A7                 mov     [ebp+var_C], eax
.text:000004AA                 mov     eax, [ebp+arg_0]
.text:000004AD                 add     esp, 0Ch
.text:000004B0                 cmp     ebp, esp
.text:000004B2                 call    __RTC_CheckEsp
.text:000004B7                 mov     esp, ebp
.text:000004B9                 pop     ebp
.text:000004BA                 retn    8
.text:000004BA ?ExtractFileNameFromPath@@YG?AVUString@@ABV1@@Z endp
.text:000004BA
.text:000004BA ; ---------------------------------------------------------------------------
.text:000004BD                 db 0Fh dup(0CCh)
.text:000004CC
.text:000004CC ; =============== S U B R O U T I N E =======================================
.text:000004CC
.text:000004CC ; Attributes: bp-based frame
.text:000004CC
.text:000004CC ; bool __stdcall DoesWildcardMatchName(const struct UString *, const struct UString *)
.text:000004CC                 public ?DoesWildcardMatchName@@YG_NABVUString@@0@Z
.text:000004CC ?DoesWildcardMatchName@@YG_NABVUString@@0@Z proc near
.text:000004CC                                         ; CODE XREF: NWildcard::CItem::CheckPath(CObjectVector<UString> const &,bool)+145p
.text:000004CC
.text:000004CC arg_0           = dword ptr  8
.text:000004CC arg_4           = dword ptr  0Ch
.text:000004CC
.text:000004CC                 push    ebp
.text:000004CD                 mov     ebp, esp
.text:000004CF                 mov     ecx, [ebp+arg_4]
.text:000004D2                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000004D7                 push    eax
.text:000004D8                 mov     ecx, [ebp+arg_0]
.text:000004DB                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000004E0                 push    eax
.text:000004E1                 call    ?EnhancedMaskTest@@YG_NPB_W0@Z ; EnhancedMaskTest(wchar_t const *,wchar_t const *)
.text:000004E6                 cmp     ebp, esp
.text:000004E8                 call    __RTC_CheckEsp
.text:000004ED                 pop     ebp
.text:000004EE                 retn    8
.text:000004EE ?DoesWildcardMatchName@@YG_NABVUString@@0@Z endp
.text:000004EE
.text:000004EE ; ---------------------------------------------------------------------------
.text:000004F1                 db 0Bh dup(0CCh)
.text:000004FC
.text:000004FC ; =============== S U B R O U T I N E =======================================
.text:000004FC
.text:000004FC ; Attributes: bp-based frame
.text:000004FC
.text:000004FC ; bool __stdcall EnhancedMaskTest(wchar_t const *, wchar_t const *)
.text:000004FC ?EnhancedMaskTest@@YG_NPB_W0@Z proc near
.text:000004FC                                         ; CODE XREF: DoesWildcardMatchName(UString const &,UString const &)+15p
.text:000004FC                                         ; EnhancedMaskTest(wchar_t const *,wchar_t const *)+55p
.text:000004FC
.text:000004FC var_8           = dword ptr -8
.text:000004FC var_4           = dword ptr -4
.text:000004FC arg_0           = dword ptr  8
.text:000004FC arg_4           = dword ptr  0Ch
.text:000004FC
.text:000004FC                 push    ebp
.text:000004FD                 mov     ebp, esp
.text:000004FF                 sub     esp, 8
.text:00000502                 push    esi
.text:00000503                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000050A                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000511
.text:00000511 loc_511:                                ; CODE XREF: EnhancedMaskTest(wchar_t const *,wchar_t const *)+D5j
.text:00000511                 mov     eax, [ebp+arg_0]
.text:00000514                 mov     cx, [eax]
.text:00000517                 mov     word ptr [ebp+var_4], cx
.text:0000051B                 mov     edx, [ebp+arg_4]
.text:0000051E                 mov     ax, [edx]
.text:00000521                 mov     word ptr [ebp+var_8], ax
.text:00000525                 movzx   ecx, word ptr [ebp+var_4]
.text:00000529                 test    ecx, ecx
.text:0000052B                 jnz     short loc_53D
.text:0000052D                 movzx   eax, word ptr [ebp+var_8]
.text:00000531                 neg     eax
.text:00000533                 sbb     eax, eax
.text:00000535                 add     eax, 1
.text:00000538                 jmp     loc_5D6
.text:0000053D ; ---------------------------------------------------------------------------
.text:0000053D
.text:0000053D loc_53D:                                ; CODE XREF: EnhancedMaskTest(wchar_t const *,wchar_t const *)+2Fj
.text:0000053D                 movzx   edx, word ptr [ebp+var_4]
.text:00000541                 cmp     edx, 2Ah ; '*'
.text:00000544                 jnz     short loc_56F
.text:00000546                 mov     eax, [ebp+arg_4]
.text:00000549                 push    eax
.text:0000054A                 mov     ecx, [ebp+arg_0]
.text:0000054D                 add     ecx, 2
.text:00000550                 push    ecx
.text:00000551                 call    ?EnhancedMaskTest@@YG_NPB_W0@Z ; EnhancedMaskTest(wchar_t const *,wchar_t const *)
.text:00000556                 movzx   edx, al
.text:00000559                 test    edx, edx
.text:0000055B                 jz      short loc_561
.text:0000055D                 mov     al, 1
.text:0000055F                 jmp     short loc_5D6
.text:00000561 ; ---------------------------------------------------------------------------
.text:00000561
.text:00000561 loc_561:                                ; CODE XREF: EnhancedMaskTest(wchar_t const *,wchar_t const *)+5Fj
.text:00000561                 movzx   eax, word ptr [ebp+var_8]
.text:00000565                 test    eax, eax
.text:00000567                 jnz     short loc_56D
.text:00000569                 xor     al, al
.text:0000056B                 jmp     short loc_5D6
.text:0000056D ; ---------------------------------------------------------------------------
.text:0000056D
.text:0000056D loc_56D:                                ; CODE XREF: EnhancedMaskTest(wchar_t const *,wchar_t const *)+6Bj
.text:0000056D                 jmp     short loc_5C8
.text:0000056F ; ---------------------------------------------------------------------------
.text:0000056F
.text:0000056F loc_56F:                                ; CODE XREF: EnhancedMaskTest(wchar_t const *,wchar_t const *)+48j
.text:0000056F                 movzx   ecx, word ptr [ebp+var_4]
.text:00000573                 cmp     ecx, 3Fh ; '?'
.text:00000576                 jnz     short loc_586
.text:00000578                 movzx   edx, word ptr [ebp+var_8]
.text:0000057C                 test    edx, edx
.text:0000057E                 jnz     short loc_584
.text:00000580                 xor     al, al
.text:00000582                 jmp     short loc_5D6
.text:00000584 ; ---------------------------------------------------------------------------
.text:00000584
.text:00000584 loc_584:                                ; CODE XREF: EnhancedMaskTest(wchar_t const *,wchar_t const *)+82j
.text:00000584                 jmp     short loc_5BF
.text:00000586 ; ---------------------------------------------------------------------------
.text:00000586
.text:00000586 loc_586:                                ; CODE XREF: EnhancedMaskTest(wchar_t const *,wchar_t const *)+7Aj
.text:00000586                 movzx   eax, word ptr [ebp+var_4]
.text:0000058A                 movzx   ecx, word ptr [ebp+var_8]
.text:0000058E                 cmp     eax, ecx
.text:00000590                 jz      short loc_5BF
.text:00000592                 movzx   edx, ds:?g_CaseSensitive@@3_NA ; bool g_CaseSensitive
.text:00000599                 test    edx, edx
.text:0000059B                 jnz     short loc_5BB
.text:0000059D                 movzx   eax, word ptr [ebp+var_4]
.text:000005A1                 push    eax             ; wchar_t
.text:000005A2                 call    ?MyCharUpper@@YG_W_W@Z ; MyCharUpper(wchar_t)
.text:000005A7                 movzx   esi, ax
.text:000005AA                 movzx   ecx, word ptr [ebp+var_8]
.text:000005AE                 push    ecx             ; wchar_t
.text:000005AF                 call    ?MyCharUpper@@YG_W_W@Z ; MyCharUpper(wchar_t)
.text:000005B4                 movzx   edx, ax
.text:000005B7                 cmp     esi, edx
.text:000005B9                 jz      short loc_5BF
.text:000005BB
.text:000005BB loc_5BB:                                ; CODE XREF: EnhancedMaskTest(wchar_t const *,wchar_t const *)+9Fj
.text:000005BB                 xor     al, al
.text:000005BD                 jmp     short loc_5D6
.text:000005BF ; ---------------------------------------------------------------------------
.text:000005BF
.text:000005BF loc_5BF:                                ; CODE XREF: EnhancedMaskTest(wchar_t const *,wchar_t const *):loc_584j
.text:000005BF                                         ; EnhancedMaskTest(wchar_t const *,wchar_t const *)+94j ...
.text:000005BF                 mov     eax, [ebp+arg_0]
.text:000005C2                 add     eax, 2
.text:000005C5                 mov     [ebp+arg_0], eax
.text:000005C8
.text:000005C8 loc_5C8:                                ; CODE XREF: EnhancedMaskTest(wchar_t const *,wchar_t const *):loc_56Dj
.text:000005C8                 mov     ecx, [ebp+arg_4]
.text:000005CB                 add     ecx, 2
.text:000005CE                 mov     [ebp+arg_4], ecx
.text:000005D1                 jmp     loc_511
.text:000005D6 ; ---------------------------------------------------------------------------
.text:000005D6
.text:000005D6 loc_5D6:                                ; CODE XREF: EnhancedMaskTest(wchar_t const *,wchar_t const *)+3Cj
.text:000005D6                                         ; EnhancedMaskTest(wchar_t const *,wchar_t const *)+63j ...
.text:000005D6                 pop     esi
.text:000005D7                 add     esp, 8
.text:000005DA                 cmp     ebp, esp
.text:000005DC                 call    __RTC_CheckEsp
.text:000005E1                 mov     esp, ebp
.text:000005E3                 pop     ebp
.text:000005E4                 retn    8
.text:000005E4 ?EnhancedMaskTest@@YG_NPB_W0@Z endp
.text:000005E4
.text:000005E4 ; ---------------------------------------------------------------------------
.text:000005E7                 db 5 dup(0CCh)
.text:000005EC
.text:000005EC ; =============== S U B R O U T I N E =======================================
.text:000005EC
.text:000005EC ; Attributes: bp-based frame
.text:000005EC
.text:000005EC ; bool __stdcall DoesNameContainWildcard(const struct UString *)
.text:000005EC                 public ?DoesNameContainWildcard@@YG_NABVUString@@@Z
.text:000005EC ?DoesNameContainWildcard@@YG_NABVUString@@@Z proc near
.text:000005EC                                         ; CODE XREF: NWildcard::CCensorNode::AddItem(bool,NWildcard::CItem &,int)+67p
.text:000005EC                                         ; NWildcard::CCensorNode::AddItem(bool,NWildcard::CItem &,int)+B0p ...
.text:000005EC
.text:000005EC var_8           = dword ptr -8
.text:000005EC var_4           = dword ptr -4
.text:000005EC arg_0           = dword ptr  8
.text:000005EC
.text:000005EC                 push    ebp
.text:000005ED                 mov     ebp, esp
.text:000005EF                 sub     esp, 8
.text:000005F2                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000005F9                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000600                 mov     [ebp+var_4], 0
.text:00000607                 jmp     short loc_612
.text:00000609 ; ---------------------------------------------------------------------------
.text:00000609
.text:00000609 loc_609:                                ; CODE XREF: DoesNameContainWildcard(UString const &):loc_648j
.text:00000609                 mov     eax, [ebp+var_4]
.text:0000060C                 add     eax, 1
.text:0000060F                 mov     [ebp+var_4], eax
.text:00000612
.text:00000612 loc_612:                                ; CODE XREF: DoesNameContainWildcard(UString const &)+1Bj
.text:00000612                 mov     ecx, [ebp+arg_0] ; this
.text:00000615                 call    ?Len@UString@@QBEIXZ ; UString::Len(void)
.text:0000061A                 cmp     [ebp+var_4], eax
.text:0000061D                 jnb     short loc_64A
.text:0000061F                 mov     ecx, [ebp+arg_0]
.text:00000622                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00000627                 mov     ecx, [ebp+var_4]
.text:0000062A                 mov     dx, [eax+ecx*2]
.text:0000062E                 mov     word ptr [ebp+var_8], dx
.text:00000632                 movzx   eax, word ptr [ebp+var_8]
.text:00000636                 cmp     eax, 2Ah ; '*'
.text:00000639                 jz      short loc_644
.text:0000063B                 movzx   ecx, word ptr [ebp+var_8]
.text:0000063F                 cmp     ecx, 3Fh ; '?'
.text:00000642                 jnz     short loc_648
.text:00000644
.text:00000644 loc_644:                                ; CODE XREF: DoesNameContainWildcard(UString const &)+4Dj
.text:00000644                 mov     al, 1
.text:00000646                 jmp     short loc_64C
.text:00000648 ; ---------------------------------------------------------------------------
.text:00000648
.text:00000648 loc_648:                                ; CODE XREF: DoesNameContainWildcard(UString const &)+56j
.text:00000648                 jmp     short loc_609
.text:0000064A ; ---------------------------------------------------------------------------
.text:0000064A
.text:0000064A loc_64A:                                ; CODE XREF: DoesNameContainWildcard(UString const &)+31j
.text:0000064A                 xor     al, al
.text:0000064C
.text:0000064C loc_64C:                                ; CODE XREF: DoesNameContainWildcard(UString const &)+5Aj
.text:0000064C                 add     esp, 8
.text:0000064F                 cmp     ebp, esp
.text:00000651                 call    __RTC_CheckEsp
.text:00000656                 mov     esp, ebp
.text:00000658                 pop     ebp
.text:00000659                 retn    4
.text:00000659 ?DoesNameContainWildcard@@YG_NABVUString@@@Z endp
.text:00000659
.text:0000065C
.text:0000065C ; =============== S U B R O U T I N E =======================================
.text:0000065C
.text:0000065C ; Attributes: bp-based frame
.text:0000065C
.text:0000065C ; bool __thiscall NWildcard::CItem::AreAllAllowed(NWildcard::CItem *__hidden this)
.text:0000065C                 public ?AreAllAllowed@CItem@NWildcard@@QBE_NXZ
.text:0000065C ?AreAllAllowed@CItem@NWildcard@@QBE_NXZ proc near
.text:0000065C                                         ; CODE XREF: NWildcard::CCensorNode::AreAllAllowed(void)+65p
.text:0000065C
.text:0000065C var_8           = dword ptr -8
.text:0000065C var_4           = dword ptr -4
.text:0000065C
.text:0000065C                 push    ebp
.text:0000065D                 mov     ebp, esp
.text:0000065F                 sub     esp, 8
.text:00000662                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00000669                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000670                 mov     [ebp+var_4], ecx
.text:00000673                 mov     eax, [ebp+var_4]
.text:00000676                 movzx   ecx, byte ptr [eax+0Dh]
.text:0000067A                 test    ecx, ecx
.text:0000067C                 jz      short loc_6C4
.text:0000067E                 mov     edx, [ebp+var_4]
.text:00000681                 movzx   eax, byte ptr [edx+0Eh]
.text:00000685                 test    eax, eax
.text:00000687                 jz      short loc_6C4
.text:00000689                 mov     ecx, [ebp+var_4]
.text:0000068C                 movzx   edx, byte ptr [ecx+0Fh]
.text:00000690                 test    edx, edx
.text:00000692                 jz      short loc_6C4
.text:00000694                 mov     ecx, [ebp+var_4]
.text:00000697                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:0000069C                 cmp     eax, 1
.text:0000069F                 jnz     short loc_6C4
.text:000006A1                 push    offset $SG67687 ; Str2
.text:000006A6                 mov     ecx, [ebp+var_4]
.text:000006A9                 call    ?Front@?$CObjectVector@VUString@@@@QBEABVUString@@XZ ; CObjectVector<UString>::Front(void)
.text:000006AE                 push    eax             ; int
.text:000006AF                 call    ??8@YG_NABVUString@@PB_W@Z ; operator==(UString const &,wchar_t const *)
.text:000006B4                 movzx   eax, al
.text:000006B7                 test    eax, eax
.text:000006B9                 jz      short loc_6C4
.text:000006BB                 mov     [ebp+var_8], 1
.text:000006C2                 jmp     short loc_6CB
.text:000006C4 ; ---------------------------------------------------------------------------
.text:000006C4
.text:000006C4 loc_6C4:                                ; CODE XREF: NWildcard::CItem::AreAllAllowed(void)+20j
.text:000006C4                                         ; NWildcard::CItem::AreAllAllowed(void)+2Bj ...
.text:000006C4                 mov     [ebp+var_8], 0
.text:000006CB
.text:000006CB loc_6CB:                                ; CODE XREF: NWildcard::CItem::AreAllAllowed(void)+66j
.text:000006CB                 mov     al, byte ptr [ebp+var_8]
.text:000006CE                 add     esp, 8
.text:000006D1                 cmp     ebp, esp
.text:000006D3                 call    __RTC_CheckEsp
.text:000006D8                 mov     esp, ebp
.text:000006DA                 pop     ebp
.text:000006DB                 retn
.text:000006DB ?AreAllAllowed@CItem@NWildcard@@QBE_NXZ endp
.text:000006DB
.text:000006DC
.text:000006DC ; =============== S U B R O U T I N E =======================================
.text:000006DC
.text:000006DC ; Attributes: bp-based frame
.text:000006DC
.text:000006DC ; public: bool __thiscall NWildcard::CItem::CheckPath(class CObjectVector<class UString> const &, bool)const
.text:000006DC                 public ?CheckPath@CItem@NWildcard@@QBE_NABV?$CObjectVector@VUString@@@@_N@Z
.text:000006DC ?CheckPath@CItem@NWildcard@@QBE_NABV?$CObjectVector@VUString@@@@_N@Z proc near
.text:000006DC                                         ; CODE XREF: NWildcard::CCensorNode::CheckPathCurrent(bool,CObjectVector<UString> const &,bool)+7Bp
.text:000006DC
.text:000006DC var_18          = dword ptr -18h
.text:000006DC var_14          = dword ptr -14h
.text:000006DC var_10          = dword ptr -10h
.text:000006DC var_C           = dword ptr -0Ch
.text:000006DC var_8           = dword ptr -8
.text:000006DC var_4           = dword ptr -4
.text:000006DC arg_0           = dword ptr  8
.text:000006DC arg_4           = byte ptr  0Ch
.text:000006DC
.text:000006DC                 push    ebp
.text:000006DD                 mov     ebp, esp
.text:000006DF                 sub     esp, 18h
.text:000006E2                 push    esi
.text:000006E3                 mov     eax, 0CCCCCCCCh
.text:000006E8                 mov     [ebp+var_18], eax
.text:000006EB                 mov     [ebp+var_14], eax
.text:000006EE                 mov     [ebp+var_10], eax
.text:000006F1                 mov     [ebp+var_C], eax
.text:000006F4                 mov     [ebp+var_8], eax
.text:000006F7                 mov     [ebp+var_4], eax
.text:000006FA                 mov     [ebp+var_4], ecx
.text:000006FD                 movzx   eax, [ebp+arg_4]
.text:00000701                 test    eax, eax
.text:00000703                 jnz     short loc_717
.text:00000705                 mov     ecx, [ebp+var_4]
.text:00000708                 movzx   edx, byte ptr [ecx+0Eh]
.text:0000070C                 test    edx, edx
.text:0000070E                 jnz     short loc_717
.text:00000710                 xor     al, al
.text:00000712                 jmp     loc_884
.text:00000717 ; ---------------------------------------------------------------------------
.text:00000717
.text:00000717 loc_717:                                ; CODE XREF: NWildcard::CItem::CheckPath(CObjectVector<UString> const &,bool)+27j
.text:00000717                                         ; NWildcard::CItem::CheckPath(CObjectVector<UString> const &,bool)+32j
.text:00000717                 mov     ecx, [ebp+arg_0]
.text:0000071A                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:0000071F                 mov     esi, eax
.text:00000721                 mov     ecx, [ebp+var_4]
.text:00000724                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:00000729                 sub     esi, eax
.text:0000072B                 mov     [ebp+var_8], esi
.text:0000072E                 jns     short loc_737
.text:00000730                 xor     al, al
.text:00000732                 jmp     loc_884
.text:00000737 ; ---------------------------------------------------------------------------
.text:00000737
.text:00000737 loc_737:                                ; CODE XREF: NWildcard::CItem::CheckPath(CObjectVector<UString> const &,bool)+52j
.text:00000737                 mov     [ebp+var_C], 0
.text:0000073E                 mov     [ebp+var_10], 0
.text:00000745                 movzx   eax, [ebp+arg_4]
.text:00000749                 test    eax, eax
.text:0000074B                 jz      short loc_790
.text:0000074D                 mov     ecx, [ebp+var_4]
.text:00000750                 movzx   edx, byte ptr [ecx+0Eh]
.text:00000754                 test    edx, edx
.text:00000756                 jnz     short loc_778
.text:00000758                 mov     eax, [ebp+var_4]
.text:0000075B                 movzx   ecx, byte ptr [eax+0Ch]
.text:0000075F                 test    ecx, ecx
.text:00000761                 jz      short loc_76B
.text:00000763                 mov     edx, [ebp+var_8]
.text:00000766                 mov     [ebp+var_C], edx
.text:00000769                 jmp     short loc_778
.text:0000076B ; ---------------------------------------------------------------------------
.text:0000076B
.text:0000076B loc_76B:                                ; CODE XREF: NWildcard::CItem::CheckPath(CObjectVector<UString> const &,bool)+85j
.text:0000076B                 cmp     [ebp+var_8], 0
.text:0000076F                 jz      short loc_778
.text:00000771                 xor     al, al
.text:00000773                 jmp     loc_884
.text:00000778 ; ---------------------------------------------------------------------------
.text:00000778
.text:00000778 loc_778:                                ; CODE XREF: NWildcard::CItem::CheckPath(CObjectVector<UString> const &,bool)+7Aj
.text:00000778                                         ; NWildcard::CItem::CheckPath(CObjectVector<UString> const &,bool)+8Dj ...
.text:00000778                 mov     eax, [ebp+var_4]
.text:0000077B                 movzx   ecx, byte ptr [eax+0Dh]
.text:0000077F                 test    ecx, ecx
.text:00000781                 jnz     short loc_790
.text:00000783                 cmp     [ebp+var_8], 0
.text:00000787                 jnz     short loc_790
.text:00000789                 xor     al, al
.text:0000078B                 jmp     loc_884
.text:00000790 ; ---------------------------------------------------------------------------
.text:00000790
.text:00000790 loc_790:                                ; CODE XREF: NWildcard::CItem::CheckPath(CObjectVector<UString> const &,bool)+6Fj
.text:00000790                                         ; NWildcard::CItem::CheckPath(CObjectVector<UString> const &,bool)+A5j ...
.text:00000790                 mov     edx, [ebp+var_4]
.text:00000793                 movzx   eax, byte ptr [edx+0Ch]
.text:00000797                 test    eax, eax
.text:00000799                 jz      short loc_7BD
.text:0000079B                 mov     ecx, [ebp+var_8]
.text:0000079E                 mov     [ebp+var_10], ecx
.text:000007A1                 movzx   edx, [ebp+arg_4]
.text:000007A5                 test    edx, edx
.text:000007A7                 jz      short loc_7BD
.text:000007A9                 mov     eax, [ebp+var_4]
.text:000007AC                 movzx   ecx, byte ptr [eax+0Dh]
.text:000007B0                 test    ecx, ecx
.text:000007B2                 jnz     short loc_7BD
.text:000007B4                 mov     edx, [ebp+var_8]
.text:000007B7                 sub     edx, 1
.text:000007BA                 mov     [ebp+var_10], edx
.text:000007BD
.text:000007BD loc_7BD:                                ; CODE XREF: NWildcard::CItem::CheckPath(CObjectVector<UString> const &,bool)+BDj
.text:000007BD                                         ; NWildcard::CItem::CheckPath(CObjectVector<UString> const &,bool)+CBj ...
.text:000007BD                 mov     eax, [ebp+var_C]
.text:000007C0                 mov     [ebp+var_14], eax
.text:000007C3                 jmp     short loc_7CE
.text:000007C5 ; ---------------------------------------------------------------------------
.text:000007C5
.text:000007C5 loc_7C5:                                ; CODE XREF: NWildcard::CItem::CheckPath(CObjectVector<UString> const &,bool):loc_87Dj
.text:000007C5                 mov     ecx, [ebp+var_14]
.text:000007C8                 add     ecx, 1
.text:000007CB                 mov     [ebp+var_14], ecx
.text:000007CE
.text:000007CE loc_7CE:                                ; CODE XREF: NWildcard::CItem::CheckPath(CObjectVector<UString> const &,bool)+E7j
.text:000007CE                 mov     edx, [ebp+var_14]
.text:000007D1                 cmp     edx, [ebp+var_10]
.text:000007D4                 jg      loc_882
.text:000007DA                 mov     [ebp+var_18], 0
.text:000007E1                 jmp     short loc_7EC
.text:000007E3 ; ---------------------------------------------------------------------------
.text:000007E3
.text:000007E3 loc_7E3:                                ; CODE XREF: NWildcard::CItem::CheckPath(CObjectVector<UString> const &,bool):loc_867j
.text:000007E3                 mov     eax, [ebp+var_18]
.text:000007E6                 add     eax, 1
.text:000007E9                 mov     [ebp+var_18], eax
.text:000007EC
.text:000007EC loc_7EC:                                ; CODE XREF: NWildcard::CItem::CheckPath(CObjectVector<UString> const &,bool)+105j
.text:000007EC                 mov     ecx, [ebp+var_4]
.text:000007EF                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:000007F4                 cmp     [ebp+var_18], eax
.text:000007F7                 jnb     short loc_86C
.text:000007F9                 mov     ecx, [ebp+var_4]
.text:000007FC                 movzx   edx, byte ptr [ecx+0Fh]
.text:00000800                 test    edx, edx
.text:00000802                 jz      short loc_831
.text:00000804                 mov     eax, [ebp+var_18]
.text:00000807                 add     eax, [ebp+var_14]
.text:0000080A                 push    eax
.text:0000080B                 mov     ecx, [ebp+arg_0]
.text:0000080E                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00000813                 push    eax             ; struct UString *
.text:00000814                 mov     ecx, [ebp+var_18]
.text:00000817                 push    ecx
.text:00000818                 mov     ecx, [ebp+var_4]
.text:0000081B                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00000820                 push    eax             ; struct UString *
.text:00000821                 call    ?DoesWildcardMatchName@@YG_NABVUString@@0@Z ; DoesWildcardMatchName(UString const &,UString const &)
.text:00000826                 movzx   edx, al
.text:00000829                 test    edx, edx
.text:0000082B                 jnz     short loc_82F
.text:0000082D                 jmp     short loc_86C
.text:0000082F ; ---------------------------------------------------------------------------
.text:0000082F
.text:0000082F loc_82F:                                ; CODE XREF: NWildcard::CItem::CheckPath(CObjectVector<UString> const &,bool)+14Fj
.text:0000082F                 jmp     short loc_867
.text:00000831 ; ---------------------------------------------------------------------------
.text:00000831
.text:00000831 loc_831:                                ; CODE XREF: NWildcard::CItem::CheckPath(CObjectVector<UString> const &,bool)+126j
.text:00000831                 mov     eax, [ebp+var_18]
.text:00000834                 add     eax, [ebp+var_14]
.text:00000837                 push    eax
.text:00000838                 mov     ecx, [ebp+arg_0]
.text:0000083B                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00000840                 mov     ecx, eax
.text:00000842                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00000847                 push    eax             ; Str2
.text:00000848                 mov     ecx, [ebp+var_18]
.text:0000084B                 push    ecx
.text:0000084C                 mov     ecx, [ebp+var_4]
.text:0000084F                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00000854                 mov     ecx, eax
.text:00000856                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:0000085B                 push    eax             ; Str1
.text:0000085C                 call    ?CompareFileNames@@YGHPB_W0@Z ; CompareFileNames(wchar_t const *,wchar_t const *)
.text:00000861                 test    eax, eax
.text:00000863                 jz      short loc_867
.text:00000865                 jmp     short loc_86C
.text:00000867 ; ---------------------------------------------------------------------------
.text:00000867
.text:00000867 loc_867:                                ; CODE XREF: NWildcard::CItem::CheckPath(CObjectVector<UString> const &,bool):loc_82Fj
.text:00000867                                         ; NWildcard::CItem::CheckPath(CObjectVector<UString> const &,bool)+187j
.text:00000867                 jmp     loc_7E3
.text:0000086C ; ---------------------------------------------------------------------------
.text:0000086C
.text:0000086C loc_86C:                                ; CODE XREF: NWildcard::CItem::CheckPath(CObjectVector<UString> const &,bool)+11Bj
.text:0000086C                                         ; NWildcard::CItem::CheckPath(CObjectVector<UString> const &,bool)+151j ...
.text:0000086C                 mov     ecx, [ebp+var_4]
.text:0000086F                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:00000874                 cmp     [ebp+var_18], eax
.text:00000877                 jnz     short loc_87D
.text:00000879                 mov     al, 1
.text:0000087B                 jmp     short loc_884
.text:0000087D ; ---------------------------------------------------------------------------
.text:0000087D
.text:0000087D loc_87D:                                ; CODE XREF: NWildcard::CItem::CheckPath(CObjectVector<UString> const &,bool)+19Bj
.text:0000087D                 jmp     loc_7C5
.text:00000882 ; ---------------------------------------------------------------------------
.text:00000882
.text:00000882 loc_882:                                ; CODE XREF: NWildcard::CItem::CheckPath(CObjectVector<UString> const &,bool)+F8j
.text:00000882                 xor     al, al
.text:00000884
.text:00000884 loc_884:                                ; CODE XREF: NWildcard::CItem::CheckPath(CObjectVector<UString> const &,bool)+36j
.text:00000884                                         ; NWildcard::CItem::CheckPath(CObjectVector<UString> const &,bool)+56j ...
.text:00000884                 pop     esi
.text:00000885                 add     esp, 18h
.text:00000888                 cmp     ebp, esp
.text:0000088A                 call    __RTC_CheckEsp
.text:0000088F                 mov     esp, ebp
.text:00000891                 pop     ebp
.text:00000892                 retn    8
.text:00000892 ?CheckPath@CItem@NWildcard@@QBE_NABV?$CObjectVector@VUString@@@@_N@Z endp
.text:00000892
.text:00000892 ; ---------------------------------------------------------------------------
.text:00000895                 db 7 dup(0CCh)
.text:0000089C
.text:0000089C ; =============== S U B R O U T I N E =======================================
.text:0000089C
.text:0000089C ; Attributes: bp-based frame
.text:0000089C
.text:0000089C ; bool __thiscall NWildcard::CCensorNode::AreAllAllowed(NWildcard::CCensorNode *__hidden this)
.text:0000089C                 public ?AreAllAllowed@CCensorNode@NWildcard@@QBE_NXZ
.text:0000089C ?AreAllAllowed@CCensorNode@NWildcard@@QBE_NXZ proc near
.text:0000089C
.text:0000089C var_4           = dword ptr -4
.text:0000089C
.text:0000089C                 push    ebp
.text:0000089D                 mov     ebp, esp
.text:0000089F                 push    ecx
.text:000008A0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000008A7                 mov     [ebp+var_4], ecx
.text:000008AA                 mov     ecx, [ebp+var_4]
.text:000008AD                 add     ecx, 4          ; this
.text:000008B0                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:000008B5                 movzx   eax, al
.text:000008B8                 test    eax, eax
.text:000008BA                 jz      short loc_8F0
.text:000008BC                 mov     ecx, [ebp+var_4]
.text:000008BF                 add     ecx, 10h
.text:000008C2                 call    ?IsEmpty@?$CObjectVector@VCCensorNode@NWildcard@@@@QBE_NXZ ; CObjectVector<NWildcard::CCensorNode>::IsEmpty(void)
.text:000008C7                 movzx   ecx, al
.text:000008CA                 test    ecx, ecx
.text:000008CC                 jz      short loc_8F0
.text:000008CE                 mov     ecx, [ebp+var_4]
.text:000008D1                 add     ecx, 28h ; '('
.text:000008D4                 call    ?IsEmpty@?$CObjectVector@UCItem@NWildcard@@@@QBE_NXZ ; CObjectVector<NWildcard::CItem>::IsEmpty(void)
.text:000008D9                 movzx   edx, al
.text:000008DC                 test    edx, edx
.text:000008DE                 jz      short loc_8F0
.text:000008E0                 mov     ecx, [ebp+var_4]
.text:000008E3                 add     ecx, 1Ch
.text:000008E6                 call    ?Size@?$CObjectVector@UCItem@NWildcard@@@@QBEIXZ ; CObjectVector<NWildcard::CItem>::Size(void)
.text:000008EB                 cmp     eax, 1
.text:000008EE                 jz      short loc_8F4
.text:000008F0
.text:000008F0 loc_8F0:                                ; CODE XREF: NWildcard::CCensorNode::AreAllAllowed(void)+1Ej
.text:000008F0                                         ; NWildcard::CCensorNode::AreAllAllowed(void)+30j ...
.text:000008F0                 xor     al, al
.text:000008F2                 jmp     short loc_906
.text:000008F4 ; ---------------------------------------------------------------------------
.text:000008F4
.text:000008F4 loc_8F4:                                ; CODE XREF: NWildcard::CCensorNode::AreAllAllowed(void)+52j
.text:000008F4                 mov     ecx, [ebp+var_4]
.text:000008F7                 add     ecx, 1Ch
.text:000008FA                 call    ?Front@?$CObjectVector@UCItem@NWildcard@@@@QBEABUCItem@NWildcard@@XZ ; CObjectVector<NWildcard::CItem>::Front(void)
.text:000008FF                 mov     ecx, eax        ; this
.text:00000901                 call    ?AreAllAllowed@CItem@NWildcard@@QBE_NXZ ; NWildcard::CItem::AreAllAllowed(void)
.text:00000906
.text:00000906 loc_906:                                ; CODE XREF: NWildcard::CCensorNode::AreAllAllowed(void)+56j
.text:00000906                 add     esp, 4
.text:00000909                 cmp     ebp, esp
.text:0000090B                 call    __RTC_CheckEsp
.text:00000910                 mov     esp, ebp
.text:00000912                 pop     ebp
.text:00000913                 retn
.text:00000913 ?AreAllAllowed@CCensorNode@NWildcard@@QBE_NXZ endp
.text:00000913
.text:00000913 ; ---------------------------------------------------------------------------
.text:00000914                 db 8 dup(0CCh)
.text:0000091C
.text:0000091C ; =============== S U B R O U T I N E =======================================
.text:0000091C
.text:0000091C ; Attributes: bp-based frame
.text:0000091C
.text:0000091C ; int __thiscall NWildcard::CCensorNode::FindSubNode(NWildcard::CCensorNode *this, const struct UString *)
.text:0000091C                 public ?FindSubNode@CCensorNode@NWildcard@@QBEHABVUString@@@Z
.text:0000091C ?FindSubNode@CCensorNode@NWildcard@@QBEHABVUString@@@Z proc near
.text:0000091C                                         ; CODE XREF: NWildcard::CCensorNode::AddItem(bool,NWildcard::CItem &,int)+D9p
.text:0000091C                                         ; NWildcard::CCensorNode::CheckPathVect(CObjectVector<UString> const &,bool,bool &)+ACp ...
.text:0000091C
.text:0000091C var_8           = dword ptr -8
.text:0000091C var_4           = dword ptr -4
.text:0000091C arg_0           = dword ptr  8
.text:0000091C
.text:0000091C                 push    ebp
.text:0000091D                 mov     ebp, esp
.text:0000091F                 sub     esp, 8
.text:00000922                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00000929                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000930                 mov     [ebp+var_4], ecx
.text:00000933                 mov     [ebp+var_8], 0
.text:0000093A                 jmp     short loc_945
.text:0000093C ; ---------------------------------------------------------------------------
.text:0000093C
.text:0000093C loc_93C:                                ; CODE XREF: NWildcard::CCensorNode::FindSubNode(UString const &):loc_986j
.text:0000093C                 mov     eax, [ebp+var_8]
.text:0000093F                 add     eax, 1
.text:00000942                 mov     [ebp+var_8], eax
.text:00000945
.text:00000945 loc_945:                                ; CODE XREF: NWildcard::CCensorNode::FindSubNode(UString const &)+1Ej
.text:00000945                 mov     ecx, [ebp+var_4]
.text:00000948                 add     ecx, 10h
.text:0000094B                 call    ?Size@?$CObjectVector@VCCensorNode@NWildcard@@@@QBEIXZ ; CObjectVector<NWildcard::CCensorNode>::Size(void)
.text:00000950                 cmp     [ebp+var_8], eax
.text:00000953                 jnb     short loc_988
.text:00000955                 mov     ecx, [ebp+arg_0]
.text:00000958                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:0000095D                 push    eax             ; Str2
.text:0000095E                 mov     ecx, [ebp+var_8]
.text:00000961                 push    ecx
.text:00000962                 mov     ecx, [ebp+var_4]
.text:00000965                 add     ecx, 10h
.text:00000968                 call    ??A?$CObjectVector@VCCensorNode@NWildcard@@@@QBEABVCCensorNode@NWildcard@@I@Z ; CObjectVector<NWildcard::CCensorNode>::operator[](uint)
.text:0000096D                 add     eax, 4
.text:00000970                 mov     ecx, eax
.text:00000972                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00000977                 push    eax             ; Str1
.text:00000978                 call    ?CompareFileNames@@YGHPB_W0@Z ; CompareFileNames(wchar_t const *,wchar_t const *)
.text:0000097D                 test    eax, eax
.text:0000097F                 jnz     short loc_986
.text:00000981                 mov     eax, [ebp+var_8]
.text:00000984                 jmp     short loc_98B
.text:00000986 ; ---------------------------------------------------------------------------
.text:00000986
.text:00000986 loc_986:                                ; CODE XREF: NWildcard::CCensorNode::FindSubNode(UString const &)+63j
.text:00000986                 jmp     short loc_93C
.text:00000988 ; ---------------------------------------------------------------------------
.text:00000988
.text:00000988 loc_988:                                ; CODE XREF: NWildcard::CCensorNode::FindSubNode(UString const &)+37j
.text:00000988                 or      eax, 0FFFFFFFFh
.text:0000098B
.text:0000098B loc_98B:                                ; CODE XREF: NWildcard::CCensorNode::FindSubNode(UString const &)+68j
.text:0000098B                 add     esp, 8
.text:0000098E                 cmp     ebp, esp
.text:00000990                 call    __RTC_CheckEsp
.text:00000995                 mov     esp, ebp
.text:00000997                 pop     ebp
.text:00000998                 retn    4
.text:00000998 ?FindSubNode@CCensorNode@NWildcard@@QBEHABVUString@@@Z endp
.text:00000998
.text:00000998 ; ---------------------------------------------------------------------------
.text:0000099B                 align 4
.text:0000099C
.text:0000099C ; =============== S U B R O U T I N E =======================================
.text:0000099C
.text:0000099C ; Attributes: bp-based frame
.text:0000099C
.text:0000099C ; void __thiscall NWildcard::CCensorNode::AddItemSimple(NWildcard::CCensorNode *this, bool, struct NWildcard::CItem *)
.text:0000099C                 public ?AddItemSimple@CCensorNode@NWildcard@@AAEX_NAAUCItem@2@@Z
.text:0000099C ?AddItemSimple@CCensorNode@NWildcard@@AAEX_NAAUCItem@2@@Z proc near
.text:0000099C                                         ; CODE XREF: NWildcard::CCensorNode::AddItem(bool,NWildcard::CItem &,int)+86p
.text:0000099C                                         ; NWildcard::CCensorNode::AddItem(bool,NWildcard::CItem &,int)+C8p
.text:0000099C
.text:0000099C var_4           = dword ptr -4
.text:0000099C arg_0           = byte ptr  8
.text:0000099C arg_4           = dword ptr  0Ch
.text:0000099C
.text:0000099C                 push    ebp
.text:0000099D                 mov     ebp, esp
.text:0000099F                 push    ecx
.text:000009A0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000009A7                 mov     [ebp+var_4], ecx
.text:000009AA                 movzx   eax, [ebp+arg_0]
.text:000009AE                 test    eax, eax
.text:000009B0                 jz      short loc_9C3
.text:000009B2                 mov     ecx, [ebp+arg_4]
.text:000009B5                 push    ecx             ; struct NWildcard::CItem *
.text:000009B6                 mov     ecx, [ebp+var_4]
.text:000009B9                 add     ecx, 1Ch
.text:000009BC                 call    ?Add@?$CObjectVector@UCItem@NWildcard@@@@QAEIABUCItem@NWildcard@@@Z ; CObjectVector<NWildcard::CItem>::Add(NWildcard::CItem const &)
.text:000009C1                 jmp     short loc_9D2
.text:000009C3 ; ---------------------------------------------------------------------------
.text:000009C3
.text:000009C3 loc_9C3:                                ; CODE XREF: NWildcard::CCensorNode::AddItemSimple(bool,NWildcard::CItem &)+14j
.text:000009C3                 mov     edx, [ebp+arg_4]
.text:000009C6                 push    edx             ; struct NWildcard::CItem *
.text:000009C7                 mov     ecx, [ebp+var_4]
.text:000009CA                 add     ecx, 28h ; '('
.text:000009CD                 call    ?Add@?$CObjectVector@UCItem@NWildcard@@@@QAEIABUCItem@NWildcard@@@Z ; CObjectVector<NWildcard::CItem>::Add(NWildcard::CItem const &)
.text:000009D2
.text:000009D2 loc_9D2:                                ; CODE XREF: NWildcard::CCensorNode::AddItemSimple(bool,NWildcard::CItem &)+25j
.text:000009D2                 add     esp, 4
.text:000009D5                 cmp     ebp, esp
.text:000009D7                 call    __RTC_CheckEsp
.text:000009DC                 mov     esp, ebp
.text:000009DE                 pop     ebp
.text:000009DF                 retn    8
.text:000009DF ?AddItemSimple@CCensorNode@NWildcard@@AAEX_NAAUCItem@2@@Z endp
.text:000009DF
.text:000009DF ; ---------------------------------------------------------------------------
.text:000009E2                 db 0Ah dup(0CCh)
.text:000009EC
.text:000009EC ; =============== S U B R O U T I N E =======================================
.text:000009EC
.text:000009EC ; Attributes: bp-based frame
.text:000009EC
.text:000009EC ; void __thiscall NWildcard::CCensorNode::AddItem(NWildcard::CCensorNode *this, bool, struct NWildcard::CItem *, int)
.text:000009EC                 public ?AddItem@CCensorNode@NWildcard@@QAEX_NAAUCItem@2@H@Z
.text:000009EC ?AddItem@CCensorNode@NWildcard@@QAEX_NAAUCItem@2@H@Z proc near
.text:000009EC                                         ; CODE XREF: NWildcard::CCensorNode::AddItem(bool,NWildcard::CItem &,int)+153p
.text:000009EC                                         ; NWildcard::CCensorNode::AddItem(bool,UString const &,bool,bool,bool,bool)+84p ...
.text:000009EC
.text:000009EC var_54          = dword ptr -54h
.text:000009EC var_50          = dword ptr -50h
.text:000009EC var_4C          = byte ptr -4Ch
.text:000009EC var_18          = dword ptr -18h
.text:000009EC var_14          = dword ptr -14h
.text:000009EC var_10          = dword ptr -10h
.text:000009EC var_C           = dword ptr -0Ch
.text:000009EC var_4           = dword ptr -4
.text:000009EC arg_0           = byte ptr  8
.text:000009EC arg_4           = dword ptr  0Ch
.text:000009EC arg_8           = dword ptr  10h
.text:000009EC
.text:000009EC                 push    ebp
.text:000009ED                 mov     ebp, esp
.text:000009EF                 push    0FFFFFFFFh
.text:000009F1                 push    offset __ehhandler$?AddItem@CCensorNode@NWildcard@@QAEX_NAAUCItem@2@H@Z
.text:000009F6                 mov     eax, large fs:0
.text:000009FC                 push    eax
.text:000009FD                 sub     esp, 48h
.text:00000A00                 push    edi
.text:00000A01                 push    ecx
.text:00000A02                 lea     edi, [ebp+var_54]
.text:00000A05                 mov     ecx, 12h
.text:00000A0A                 mov     eax, 0CCCCCCCCh
.text:00000A0F                 rep stosd
.text:00000A11                 pop     ecx
.text:00000A12                 mov     eax, dword ptr ds:___security_cookie
.text:00000A17                 xor     eax, ebp
.text:00000A19                 push    eax
.text:00000A1A                 lea     eax, [ebp+var_C]
.text:00000A1D                 mov     large fs:0, eax
.text:00000A23                 mov     [ebp+var_10], ecx
.text:00000A26                 mov     ecx, [ebp+arg_4]
.text:00000A29                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:00000A2E                 cmp     eax, 1
.text:00000A31                 ja      short loc_A7C
.text:00000A33                 mov     ecx, [ebp+arg_4]
.text:00000A36                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:00000A3B                 test    eax, eax
.text:00000A3D                 jz      short loc_A66
.text:00000A3F                 mov     eax, [ebp+arg_4]
.text:00000A42                 movzx   ecx, byte ptr [eax+0Fh]
.text:00000A46                 test    ecx, ecx
.text:00000A48                 jz      short loc_A66
.text:00000A4A                 mov     ecx, [ebp+arg_4]
.text:00000A4D                 call    ?Front@?$CObjectVector@VUString@@@@QAEAAVUString@@XZ ; CObjectVector<UString>::Front(void)
.text:00000A52                 push    eax             ; struct UString *
.text:00000A53                 call    ?DoesNameContainWildcard@@YG_NABVUString@@@Z ; DoesNameContainWildcard(UString const &)
.text:00000A58                 movzx   edx, al
.text:00000A5B                 test    edx, edx
.text:00000A5D                 jnz     short loc_A66
.text:00000A5F                 mov     eax, [ebp+arg_4]
.text:00000A62                 mov     byte ptr [eax+0Fh], 0
.text:00000A66
.text:00000A66 loc_A66:                                ; CODE XREF: NWildcard::CCensorNode::AddItem(bool,NWildcard::CItem &,int)+51j
.text:00000A66                                         ; NWildcard::CCensorNode::AddItem(bool,NWildcard::CItem &,int)+5Cj ...
.text:00000A66                 mov     ecx, [ebp+arg_4]
.text:00000A69                 push    ecx             ; struct NWildcard::CItem *
.text:00000A6A                 movzx   edx, [ebp+arg_0]
.text:00000A6E                 push    edx             ; bool
.text:00000A6F                 mov     ecx, [ebp+var_10] ; this
.text:00000A72                 call    ?AddItemSimple@CCensorNode@NWildcard@@AAEX_NAAUCItem@2@@Z ; NWildcard::CCensorNode::AddItemSimple(bool,NWildcard::CItem &)
.text:00000A77                 jmp     loc_B44
.text:00000A7C ; ---------------------------------------------------------------------------
.text:00000A7C
.text:00000A7C loc_A7C:                                ; CODE XREF: NWildcard::CCensorNode::AddItem(bool,NWildcard::CItem &,int)+45j
.text:00000A7C                 mov     ecx, [ebp+arg_4]
.text:00000A7F                 call    ?Front@?$CObjectVector@VUString@@@@QAEAAVUString@@XZ ; CObjectVector<UString>::Front(void)
.text:00000A84                 mov     [ebp+var_14], eax
.text:00000A87                 mov     eax, [ebp+arg_4]
.text:00000A8A                 movzx   ecx, byte ptr [eax+0Fh]
.text:00000A8E                 test    ecx, ecx
.text:00000A90                 jz      short loc_ABE
.text:00000A92                 cmp     [ebp+arg_8], 0
.text:00000A96                 jz      short loc_ABE
.text:00000A98                 mov     edx, [ebp+var_14]
.text:00000A9B                 push    edx             ; struct UString *
.text:00000A9C                 call    ?DoesNameContainWildcard@@YG_NABVUString@@@Z ; DoesNameContainWildcard(UString const &)
.text:00000AA1                 movzx   eax, al
.text:00000AA4                 test    eax, eax
.text:00000AA6                 jz      short loc_ABE
.text:00000AA8                 mov     ecx, [ebp+arg_4]
.text:00000AAB                 push    ecx             ; struct NWildcard::CItem *
.text:00000AAC                 movzx   edx, [ebp+arg_0]
.text:00000AB0                 push    edx             ; bool
.text:00000AB1                 mov     ecx, [ebp+var_10] ; this
.text:00000AB4                 call    ?AddItemSimple@CCensorNode@NWildcard@@AAEX_NAAUCItem@2@@Z ; NWildcard::CCensorNode::AddItemSimple(bool,NWildcard::CItem &)
.text:00000AB9                 jmp     loc_B44
.text:00000ABE ; ---------------------------------------------------------------------------
.text:00000ABE
.text:00000ABE loc_ABE:                                ; CODE XREF: NWildcard::CCensorNode::AddItem(bool,NWildcard::CItem &,int)+A4j
.text:00000ABE                                         ; NWildcard::CCensorNode::AddItem(bool,NWildcard::CItem &,int)+AAj ...
.text:00000ABE                 mov     eax, [ebp+var_14]
.text:00000AC1                 push    eax             ; struct UString *
.text:00000AC2                 mov     ecx, [ebp+var_10] ; this
.text:00000AC5                 call    ?FindSubNode@CCensorNode@NWildcard@@QBEHABVUString@@@Z ; NWildcard::CCensorNode::FindSubNode(UString const &)
.text:00000ACA                 mov     [ebp+var_18], eax
.text:00000ACD                 cmp     [ebp+var_18], 0
.text:00000AD1                 jge     short loc_B14
.text:00000AD3                 mov     ecx, [ebp+var_10]
.text:00000AD6                 push    ecx             ; struct NWildcard::CCensorNode *
.text:00000AD7                 mov     edx, [ebp+var_14]
.text:00000ADA                 push    edx             ; struct UString *
.text:00000ADB                 lea     ecx, [ebp+var_4C] ; this
.text:00000ADE                 call    ??0CCensorNode@NWildcard@@QAE@ABVUString@@PAV01@@Z ; NWildcard::CCensorNode::CCensorNode(UString const &,NWildcard::CCensorNode *)
.text:00000AE3                 mov     [ebp+var_50], eax
.text:00000AE6                 mov     eax, [ebp+var_50]
.text:00000AE9                 mov     [ebp+var_54], eax
.text:00000AEC                 mov     [ebp+var_4], 0
.text:00000AF3                 mov     ecx, [ebp+var_54]
.text:00000AF6                 push    ecx
.text:00000AF7                 mov     ecx, [ebp+var_10]
.text:00000AFA                 add     ecx, 10h
.text:00000AFD                 call    ?Add@?$CObjectVector@VCCensorNode@NWildcard@@@@QAEIABVCCensorNode@NWildcard@@@Z ; CObjectVector<NWildcard::CCensorNode>::Add(NWildcard::CCensorNode const &)
.text:00000B02                 mov     [ebp+var_18], eax
.text:00000B05                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000B0C                 lea     ecx, [ebp+var_4C] ; this
.text:00000B0F                 call    ??1CCensorNode@NWildcard@@QAE@XZ ; NWildcard::CCensorNode::~CCensorNode(void)
.text:00000B14
.text:00000B14 loc_B14:                                ; CODE XREF: NWildcard::CCensorNode::AddItem(bool,NWildcard::CItem &,int)+E5j
.text:00000B14                 push    0
.text:00000B16                 mov     ecx, [ebp+arg_4]
.text:00000B19                 call    ?Delete@?$CObjectVector@VUString@@@@QAEXI@Z ; CObjectVector<UString>::Delete(uint)
.text:00000B1E                 mov     edx, [ebp+arg_8]
.text:00000B21                 sub     edx, 1
.text:00000B24                 push    edx             ; int
.text:00000B25                 mov     eax, [ebp+arg_4]
.text:00000B28                 push    eax             ; struct NWildcard::CItem *
.text:00000B29                 movzx   ecx, [ebp+arg_0]
.text:00000B2D                 push    ecx             ; bool
.text:00000B2E                 mov     edx, [ebp+var_18]
.text:00000B31                 push    edx
.text:00000B32                 mov     ecx, [ebp+var_10]
.text:00000B35                 add     ecx, 10h
.text:00000B38                 call    ??A?$CObjectVector@VCCensorNode@NWildcard@@@@QAEAAVCCensorNode@NWildcard@@I@Z ; CObjectVector<NWildcard::CCensorNode>::operator[](uint)
.text:00000B3D                 mov     ecx, eax        ; this
.text:00000B3F                 call    ?AddItem@CCensorNode@NWildcard@@QAEX_NAAUCItem@2@H@Z ; NWildcard::CCensorNode::AddItem(bool,NWildcard::CItem &,int)
.text:00000B44
.text:00000B44 loc_B44:                                ; CODE XREF: NWildcard::CCensorNode::AddItem(bool,NWildcard::CItem &,int)+8Bj
.text:00000B44                                         ; NWildcard::CCensorNode::AddItem(bool,NWildcard::CItem &,int)+CDj
.text:00000B44                 mov     ecx, [ebp+var_C]
.text:00000B47                 mov     large fs:0, ecx
.text:00000B4E                 pop     ecx
.text:00000B4F                 pop     edi
.text:00000B50                 add     esp, 54h
.text:00000B53                 cmp     ebp, esp
.text:00000B55                 call    __RTC_CheckEsp
.text:00000B5A                 mov     esp, ebp
.text:00000B5C                 pop     ebp
.text:00000B5D                 retn    0Ch
.text:00000B5D ?AddItem@CCensorNode@NWildcard@@QAEX_NAAUCItem@2@H@Z endp
.text:00000B5D
.text:00000B5D ; ---------------------------------------------------------------------------
.text:00000B60                 db 0Ch dup(0CCh)
.text:00000B6C
.text:00000B6C ; =============== S U B R O U T I N E =======================================
.text:00000B6C
.text:00000B6C ; Attributes: bp-based frame
.text:00000B6C
.text:00000B6C ; void __thiscall NWildcard::CCensorNode::AddItem(NWildcard::CCensorNode *this, bool, const struct UString *, bool, bool, bool, bool)
.text:00000B6C                 public ?AddItem@CCensorNode@NWildcard@@QAEX_NABVUString@@0000@Z
.text:00000B6C ?AddItem@CCensorNode@NWildcard@@QAEX_NABVUString@@0000@Z proc near
.text:00000B6C                                         ; CODE XREF: NWildcard::CCensorNode::AddItem2(bool,UString const &,bool,bool)+B2p
.text:00000B6C
.text:00000B6C var_28          = dword ptr -28h
.text:00000B6C var_24          = dword ptr -24h
.text:00000B6C var_20          = dword ptr -20h
.text:00000B6C var_1C          = dword ptr -1Ch
.text:00000B6C var_18          = dword ptr -18h
.text:00000B6C var_14          = dword ptr -14h
.text:00000B6C var_10          = dword ptr -10h
.text:00000B6C var_C           = dword ptr -0Ch
.text:00000B6C var_4           = dword ptr -4
.text:00000B6C arg_0           = byte ptr  8
.text:00000B6C arg_4           = dword ptr  0Ch
.text:00000B6C arg_8           = byte ptr  10h
.text:00000B6C arg_C           = byte ptr  14h
.text:00000B6C arg_10          = byte ptr  18h
.text:00000B6C arg_14          = byte ptr  1Ch
.text:00000B6C
.text:00000B6C                 push    ebp
.text:00000B6D                 mov     ebp, esp
.text:00000B6F                 push    0FFFFFFFFh
.text:00000B71                 push    offset __ehhandler$?AddItem@CCensorNode@NWildcard@@QAEX_NABVUString@@0000@Z
.text:00000B76                 mov     eax, large fs:0
.text:00000B7C                 push    eax
.text:00000B7D                 sub     esp, 1Ch
.text:00000B80                 mov     eax, 0CCCCCCCCh
.text:00000B85                 mov     [ebp+var_28], eax
.text:00000B88                 mov     [ebp+var_24], eax
.text:00000B8B                 mov     [ebp+var_20], eax
.text:00000B8E                 mov     [ebp+var_1C], eax
.text:00000B91                 mov     [ebp+var_18], eax
.text:00000B94                 mov     [ebp+var_14], eax
.text:00000B97                 mov     [ebp+var_10], eax
.text:00000B9A                 mov     eax, dword ptr ds:___security_cookie
.text:00000B9F                 xor     eax, ebp
.text:00000BA1                 push    eax
.text:00000BA2                 lea     eax, [ebp+var_C]
.text:00000BA5                 mov     large fs:0, eax
.text:00000BAB                 mov     [ebp+var_10], ecx
.text:00000BAE                 lea     ecx, [ebp+var_24] ; this
.text:00000BB1                 call    ??0CItem@NWildcard@@QAE@XZ ; NWildcard::CItem::CItem(void)
.text:00000BB6                 mov     [ebp+var_4], 0
.text:00000BBD                 lea     eax, [ebp+var_24]
.text:00000BC0                 push    eax             ; int
.text:00000BC1                 mov     ecx, [ebp+arg_4]
.text:00000BC4                 push    ecx             ; UString *
.text:00000BC5                 call    ?SplitPathToParts@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z ; SplitPathToParts(UString const &,CObjectVector<UString> &)
.text:00000BCA                 mov     dl, [ebp+arg_8]
.text:00000BCD                 mov     byte ptr [ebp+var_18], dl
.text:00000BD0                 mov     al, [ebp+arg_C]
.text:00000BD3                 mov     byte ptr [ebp+var_18+1], al
.text:00000BD6                 mov     cl, [ebp+arg_10]
.text:00000BD9                 mov     byte ptr [ebp+var_18+2], cl
.text:00000BDC                 mov     dl, [ebp+arg_14]
.text:00000BDF                 mov     byte ptr [ebp+var_18+3], dl
.text:00000BE2                 push    0FFFFFFFFh      ; int
.text:00000BE4                 lea     eax, [ebp+var_24]
.text:00000BE7                 push    eax             ; struct NWildcard::CItem *
.text:00000BE8                 movzx   ecx, [ebp+arg_0]
.text:00000BEC                 push    ecx             ; bool
.text:00000BED                 mov     ecx, [ebp+var_10] ; this
.text:00000BF0                 call    ?AddItem@CCensorNode@NWildcard@@QAEX_NAAUCItem@2@H@Z ; NWildcard::CCensorNode::AddItem(bool,NWildcard::CItem &,int)
.text:00000BF5                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000BFC                 lea     ecx, [ebp+var_24] ; this
.text:00000BFF                 call    ??1CItem@NWildcard@@QAE@XZ ; NWildcard::CItem::~CItem(void)
.text:00000C04                 push    edx
.text:00000C05                 mov     ecx, ebp
.text:00000C07                 push    eax
.text:00000C08                 lea     edx, $LN7
.text:00000C0E                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00000C13                 pop     eax
.text:00000C14                 pop     edx
.text:00000C15                 mov     ecx, [ebp+var_C]
.text:00000C18                 mov     large fs:0, ecx
.text:00000C1F                 pop     ecx
.text:00000C20                 add     esp, 28h
.text:00000C23                 cmp     ebp, esp
.text:00000C25                 call    __RTC_CheckEsp
.text:00000C2A                 mov     esp, ebp
.text:00000C2C                 pop     ebp
.text:00000C2D                 retn    18h
.text:00000C2D ?AddItem@CCensorNode@NWildcard@@QAEX_NABVUString@@0000@Z endp
.text:00000C2D
.text:00000C2D ; ---------------------------------------------------------------------------
.text:00000C30 $LN7            dd 1                    ; DATA XREF: NWildcard::CCensorNode::AddItem(bool,UString const &,bool,bool,bool,bool)+9Co
.text:00000C34                 dd offset $LN6
.text:00000C38 $LN6            dd 0FFFFFFDCh, 10h      ; DATA XREF: .text:00000C34o
.text:00000C40                 dd offset $LN4          ; "item"
.text:00000C44 $LN4            db 'item',0             ; DATA XREF: .text:00000C40o
.text:00000C49                 align 4
.text:00000C4C
.text:00000C4C ; =============== S U B R O U T I N E =======================================
.text:00000C4C
.text:00000C4C ; Attributes: bp-based frame
.text:00000C4C
.text:00000C4C ; bool __thiscall NWildcard::CCensorNode::NeedCheckSubDirs(NWildcard::CCensorNode *__hidden this)
.text:00000C4C                 public ?NeedCheckSubDirs@CCensorNode@NWildcard@@QBE_NXZ
.text:00000C4C ?NeedCheckSubDirs@CCensorNode@NWildcard@@QBE_NXZ proc near
.text:00000C4C
.text:00000C4C var_C           = dword ptr -0Ch
.text:00000C4C var_8           = dword ptr -8
.text:00000C4C var_4           = dword ptr -4
.text:00000C4C
.text:00000C4C                 push    ebp
.text:00000C4D                 mov     ebp, esp
.text:00000C4F                 sub     esp, 0Ch
.text:00000C52                 mov     [ebp+var_C], 0CCCCCCCCh
.text:00000C59                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00000C60                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000C67                 mov     [ebp+var_4], ecx
.text:00000C6A                 mov     [ebp+var_8], 0
.text:00000C71                 jmp     short loc_C7C
.text:00000C73 ; ---------------------------------------------------------------------------
.text:00000C73
.text:00000C73 loc_C73:                                ; CODE XREF: NWildcard::CCensorNode::NeedCheckSubDirs(void):loc_CBAj
.text:00000C73                 mov     eax, [ebp+var_8]
.text:00000C76                 add     eax, 1
.text:00000C79                 mov     [ebp+var_8], eax
.text:00000C7C
.text:00000C7C loc_C7C:                                ; CODE XREF: NWildcard::CCensorNode::NeedCheckSubDirs(void)+25j
.text:00000C7C                 mov     ecx, [ebp+var_4]
.text:00000C7F                 add     ecx, 1Ch
.text:00000C82                 call    ?Size@?$CObjectVector@UCItem@NWildcard@@@@QBEIXZ ; CObjectVector<NWildcard::CItem>::Size(void)
.text:00000C87                 cmp     [ebp+var_8], eax
.text:00000C8A                 jnb     short loc_CBC
.text:00000C8C                 mov     ecx, [ebp+var_8]
.text:00000C8F                 push    ecx
.text:00000C90                 mov     ecx, [ebp+var_4]
.text:00000C93                 add     ecx, 1Ch
.text:00000C96                 call    ??A?$CObjectVector@UCItem@NWildcard@@@@QBEABUCItem@NWildcard@@I@Z ; CObjectVector<NWildcard::CItem>::operator[](uint)
.text:00000C9B                 mov     [ebp+var_C], eax
.text:00000C9E                 mov     edx, [ebp+var_C]
.text:00000CA1                 movzx   eax, byte ptr [edx+0Ch]
.text:00000CA5                 test    eax, eax
.text:00000CA7                 jnz     short loc_CB6
.text:00000CA9                 mov     ecx, [ebp+var_C]
.text:00000CAC                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:00000CB1                 cmp     eax, 1
.text:00000CB4                 jbe     short loc_CBA
.text:00000CB6
.text:00000CB6 loc_CB6:                                ; CODE XREF: NWildcard::CCensorNode::NeedCheckSubDirs(void)+5Bj
.text:00000CB6                 mov     al, 1
.text:00000CB8                 jmp     short loc_CBE
.text:00000CBA ; ---------------------------------------------------------------------------
.text:00000CBA
.text:00000CBA loc_CBA:                                ; CODE XREF: NWildcard::CCensorNode::NeedCheckSubDirs(void)+68j
.text:00000CBA                 jmp     short loc_C73
.text:00000CBC ; ---------------------------------------------------------------------------
.text:00000CBC
.text:00000CBC loc_CBC:                                ; CODE XREF: NWildcard::CCensorNode::NeedCheckSubDirs(void)+3Ej
.text:00000CBC                 xor     al, al
.text:00000CBE
.text:00000CBE loc_CBE:                                ; CODE XREF: NWildcard::CCensorNode::NeedCheckSubDirs(void)+6Cj
.text:00000CBE                 add     esp, 0Ch
.text:00000CC1                 cmp     ebp, esp
.text:00000CC3                 call    __RTC_CheckEsp
.text:00000CC8                 mov     esp, ebp
.text:00000CCA                 pop     ebp
.text:00000CCB                 retn
.text:00000CCB ?NeedCheckSubDirs@CCensorNode@NWildcard@@QBE_NXZ endp
.text:00000CCB
.text:00000CCC
.text:00000CCC ; =============== S U B R O U T I N E =======================================
.text:00000CCC
.text:00000CCC ; Attributes: bp-based frame
.text:00000CCC
.text:00000CCC ; bool __thiscall NWildcard::CCensorNode::AreThereIncludeItems(NWildcard::CCensorNode *__hidden this)
.text:00000CCC                 public ?AreThereIncludeItems@CCensorNode@NWildcard@@QBE_NXZ
.text:00000CCC ?AreThereIncludeItems@CCensorNode@NWildcard@@QBE_NXZ proc near
.text:00000CCC                                         ; CODE XREF: NWildcard::CCensorNode::AreThereIncludeItems(void)+5Dp
.text:00000CCC
.text:00000CCC var_8           = dword ptr -8
.text:00000CCC var_4           = dword ptr -4
.text:00000CCC
.text:00000CCC                 push    ebp
.text:00000CCD                 mov     ebp, esp
.text:00000CCF                 sub     esp, 8
.text:00000CD2                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00000CD9                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000CE0                 mov     [ebp+var_4], ecx
.text:00000CE3                 mov     ecx, [ebp+var_4]
.text:00000CE6                 add     ecx, 1Ch
.text:00000CE9                 call    ?Size@?$CObjectVector@UCItem@NWildcard@@@@QBEIXZ ; CObjectVector<NWildcard::CItem>::Size(void)
.text:00000CEE                 test    eax, eax
.text:00000CF0                 jbe     short loc_CF6
.text:00000CF2                 mov     al, 1
.text:00000CF4                 jmp     short loc_D3D
.text:00000CF6 ; ---------------------------------------------------------------------------
.text:00000CF6
.text:00000CF6 loc_CF6:                                ; CODE XREF: NWildcard::CCensorNode::AreThereIncludeItems(void)+24j
.text:00000CF6                 mov     [ebp+var_8], 0
.text:00000CFD                 jmp     short loc_D08
.text:00000CFF ; ---------------------------------------------------------------------------
.text:00000CFF
.text:00000CFF loc_CFF:                                ; CODE XREF: NWildcard::CCensorNode::AreThereIncludeItems(void):loc_D39j
.text:00000CFF                 mov     eax, [ebp+var_8]
.text:00000D02                 add     eax, 1
.text:00000D05                 mov     [ebp+var_8], eax
.text:00000D08
.text:00000D08 loc_D08:                                ; CODE XREF: NWildcard::CCensorNode::AreThereIncludeItems(void)+31j
.text:00000D08                 mov     ecx, [ebp+var_4]
.text:00000D0B                 add     ecx, 10h
.text:00000D0E                 call    ?Size@?$CObjectVector@VCCensorNode@NWildcard@@@@QBEIXZ ; CObjectVector<NWildcard::CCensorNode>::Size(void)
.text:00000D13                 cmp     [ebp+var_8], eax
.text:00000D16                 jnb     short loc_D3B
.text:00000D18                 mov     ecx, [ebp+var_8]
.text:00000D1B                 push    ecx
.text:00000D1C                 mov     ecx, [ebp+var_4]
.text:00000D1F                 add     ecx, 10h
.text:00000D22                 call    ??A?$CObjectVector@VCCensorNode@NWildcard@@@@QBEABVCCensorNode@NWildcard@@I@Z ; CObjectVector<NWildcard::CCensorNode>::operator[](uint)
.text:00000D27                 mov     ecx, eax        ; this
.text:00000D29                 call    ?AreThereIncludeItems@CCensorNode@NWildcard@@QBE_NXZ ; NWildcard::CCensorNode::AreThereIncludeItems(void)
.text:00000D2E                 movzx   edx, al
.text:00000D31                 test    edx, edx
.text:00000D33                 jz      short loc_D39
.text:00000D35                 mov     al, 1
.text:00000D37                 jmp     short loc_D3D
.text:00000D39 ; ---------------------------------------------------------------------------
.text:00000D39
.text:00000D39 loc_D39:                                ; CODE XREF: NWildcard::CCensorNode::AreThereIncludeItems(void)+67j
.text:00000D39                 jmp     short loc_CFF
.text:00000D3B ; ---------------------------------------------------------------------------
.text:00000D3B
.text:00000D3B loc_D3B:                                ; CODE XREF: NWildcard::CCensorNode::AreThereIncludeItems(void)+4Aj
.text:00000D3B                 xor     al, al
.text:00000D3D
.text:00000D3D loc_D3D:                                ; CODE XREF: NWildcard::CCensorNode::AreThereIncludeItems(void)+28j
.text:00000D3D                                         ; NWildcard::CCensorNode::AreThereIncludeItems(void)+6Bj
.text:00000D3D                 add     esp, 8
.text:00000D40                 cmp     ebp, esp
.text:00000D42                 call    __RTC_CheckEsp
.text:00000D47                 mov     esp, ebp
.text:00000D49                 pop     ebp
.text:00000D4A                 retn
.text:00000D4A ?AreThereIncludeItems@CCensorNode@NWildcard@@QBE_NXZ endp
.text:00000D4A
.text:00000D4A ; ---------------------------------------------------------------------------
.text:00000D4B                 align 4
.text:00000D4C
.text:00000D4C ; =============== S U B R O U T I N E =======================================
.text:00000D4C
.text:00000D4C ; Attributes: bp-based frame
.text:00000D4C
.text:00000D4C ; private: bool __thiscall NWildcard::CCensorNode::CheckPathCurrent(bool, class CObjectVector<class UString> const &, bool)const
.text:00000D4C                 public ?CheckPathCurrent@CCensorNode@NWildcard@@ABE_N_NABV?$CObjectVector@VUString@@@@0@Z
.text:00000D4C ?CheckPathCurrent@CCensorNode@NWildcard@@ABE_N_NABV?$CObjectVector@VUString@@@@0@Z proc near
.text:00000D4C                                         ; CODE XREF: NWildcard::CCensorNode::CheckPathVect(CObjectVector<UString> const &,bool,bool &)+56p
.text:00000D4C                                         ; NWildcard::CCensorNode::CheckPathVect(CObjectVector<UString> const &,bool,bool &)+83p ...
.text:00000D4C
.text:00000D4C var_14          = dword ptr -14h
.text:00000D4C var_10          = dword ptr -10h
.text:00000D4C var_C           = dword ptr -0Ch
.text:00000D4C var_8           = dword ptr -8
.text:00000D4C var_4           = dword ptr -4
.text:00000D4C arg_0           = byte ptr  8
.text:00000D4C arg_4           = dword ptr  0Ch
.text:00000D4C arg_8           = byte ptr  10h
.text:00000D4C
.text:00000D4C                 push    ebp
.text:00000D4D                 mov     ebp, esp
.text:00000D4F                 sub     esp, 14h
.text:00000D52                 mov     eax, 0CCCCCCCCh
.text:00000D57                 mov     [ebp+var_14], eax
.text:00000D5A                 mov     [ebp+var_10], eax
.text:00000D5D                 mov     [ebp+var_C], eax
.text:00000D60                 mov     [ebp+var_8], eax
.text:00000D63                 mov     [ebp+var_4], eax
.text:00000D66                 mov     [ebp+var_4], ecx
.text:00000D69                 movzx   eax, [ebp+arg_0]
.text:00000D6D                 test    eax, eax
.text:00000D6F                 jz      short loc_D7C
.text:00000D71                 mov     ecx, [ebp+var_4]
.text:00000D74                 add     ecx, 1Ch
.text:00000D77                 mov     [ebp+var_14], ecx
.text:00000D7A                 jmp     short loc_D85
.text:00000D7C ; ---------------------------------------------------------------------------
.text:00000D7C
.text:00000D7C loc_D7C:                                ; CODE XREF: NWildcard::CCensorNode::CheckPathCurrent(bool,CObjectVector<UString> const &,bool)+23j
.text:00000D7C                 mov     edx, [ebp+var_4]
.text:00000D7F                 add     edx, 28h ; '('
.text:00000D82                 mov     [ebp+var_14], edx
.text:00000D85
.text:00000D85 loc_D85:                                ; CODE XREF: NWildcard::CCensorNode::CheckPathCurrent(bool,CObjectVector<UString> const &,bool)+2Ej
.text:00000D85                 mov     eax, [ebp+var_14]
.text:00000D88                 mov     [ebp+var_10], eax
.text:00000D8B                 mov     ecx, [ebp+var_10]
.text:00000D8E                 mov     [ebp+var_8], ecx
.text:00000D91                 mov     [ebp+var_C], 0
.text:00000D98                 jmp     short loc_DA3
.text:00000D9A ; ---------------------------------------------------------------------------
.text:00000D9A
.text:00000D9A loc_D9A:                                ; CODE XREF: NWildcard::CCensorNode::CheckPathCurrent(bool,CObjectVector<UString> const &,bool):loc_DD7j
.text:00000D9A                 mov     edx, [ebp+var_C]
.text:00000D9D                 add     edx, 1
.text:00000DA0                 mov     [ebp+var_C], edx
.text:00000DA3
.text:00000DA3 loc_DA3:                                ; CODE XREF: NWildcard::CCensorNode::CheckPathCurrent(bool,CObjectVector<UString> const &,bool)+4Cj
.text:00000DA3                 mov     ecx, [ebp+var_8]
.text:00000DA6                 call    ?Size@?$CObjectVector@UCItem@NWildcard@@@@QBEIXZ ; CObjectVector<NWildcard::CItem>::Size(void)
.text:00000DAB                 cmp     [ebp+var_C], eax
.text:00000DAE                 jnb     short loc_DD9
.text:00000DB0                 movzx   eax, [ebp+arg_8]
.text:00000DB4                 push    eax
.text:00000DB5                 mov     ecx, [ebp+arg_4]
.text:00000DB8                 push    ecx
.text:00000DB9                 mov     edx, [ebp+var_C]
.text:00000DBC                 push    edx
.text:00000DBD                 mov     ecx, [ebp+var_8]
.text:00000DC0                 call    ??A?$CObjectVector@UCItem@NWildcard@@@@QBEABUCItem@NWildcard@@I@Z ; CObjectVector<NWildcard::CItem>::operator[](uint)
.text:00000DC5                 mov     ecx, eax
.text:00000DC7                 call    ?CheckPath@CItem@NWildcard@@QBE_NABV?$CObjectVector@VUString@@@@_N@Z ; NWildcard::CItem::CheckPath(CObjectVector<UString> const &,bool)
.text:00000DCC                 movzx   eax, al
.text:00000DCF                 test    eax, eax
.text:00000DD1                 jz      short loc_DD7
.text:00000DD3                 mov     al, 1
.text:00000DD5                 jmp     short loc_DDB
.text:00000DD7 ; ---------------------------------------------------------------------------
.text:00000DD7
.text:00000DD7 loc_DD7:                                ; CODE XREF: NWildcard::CCensorNode::CheckPathCurrent(bool,CObjectVector<UString> const &,bool)+85j
.text:00000DD7                 jmp     short loc_D9A
.text:00000DD9 ; ---------------------------------------------------------------------------
.text:00000DD9
.text:00000DD9 loc_DD9:                                ; CODE XREF: NWildcard::CCensorNode::CheckPathCurrent(bool,CObjectVector<UString> const &,bool)+62j
.text:00000DD9                 xor     al, al
.text:00000DDB
.text:00000DDB loc_DDB:                                ; CODE XREF: NWildcard::CCensorNode::CheckPathCurrent(bool,CObjectVector<UString> const &,bool)+89j
.text:00000DDB                 add     esp, 14h
.text:00000DDE                 cmp     ebp, esp
.text:00000DE0                 call    __RTC_CheckEsp
.text:00000DE5                 mov     esp, ebp
.text:00000DE7                 pop     ebp
.text:00000DE8                 retn    0Ch
.text:00000DE8 ?CheckPathCurrent@CCensorNode@NWildcard@@ABE_N_NABV?$CObjectVector@VUString@@@@0@Z endp
.text:00000DE8
.text:00000DE8 ; ---------------------------------------------------------------------------
.text:00000DEB                 align 4
.text:00000DEC
.text:00000DEC ; =============== S U B R O U T I N E =======================================
.text:00000DEC
.text:00000DEC ; Attributes: bp-based frame
.text:00000DEC
.text:00000DEC ; public: bool __thiscall NWildcard::CCensorNode::CheckPathVect(class CObjectVector<class UString> const &, bool, bool &)const
.text:00000DEC                 public ?CheckPathVect@CCensorNode@NWildcard@@QBE_NABV?$CObjectVector@VUString@@@@_NAA_N@Z
.text:00000DEC ?CheckPathVect@CCensorNode@NWildcard@@QBE_NABV?$CObjectVector@VUString@@@@_NAA_N@Z proc near
.text:00000DEC                                         ; CODE XREF: NWildcard::CCensorNode::CheckPathVect(CObjectVector<UString> const &,bool,bool &)+F5p
.text:00000DEC
.text:00000DEC var_30          = dword ptr -30h
.text:00000DEC var_2C          = dword ptr -2Ch
.text:00000DEC var_28          = dword ptr -28h
.text:00000DEC var_24          = dword ptr -24h
.text:00000DEC var_20          = dword ptr -20h
.text:00000DEC var_1C          = dword ptr -1Ch
.text:00000DEC var_18          = dword ptr -18h
.text:00000DEC var_14          = dword ptr -14h
.text:00000DEC var_10          = dword ptr -10h
.text:00000DEC var_C           = dword ptr -0Ch
.text:00000DEC var_4           = dword ptr -4
.text:00000DEC arg_0           = dword ptr  8
.text:00000DEC arg_4           = byte ptr  0Ch
.text:00000DEC arg_8           = dword ptr  10h
.text:00000DEC
.text:00000DEC                 push    ebp
.text:00000DED                 mov     ebp, esp
.text:00000DEF                 push    0FFFFFFFFh
.text:00000DF1                 push    offset __ehhandler$?CheckPathVect@CCensorNode@NWildcard@@QBE_NABV?$CObjectVector@VUString@@@@_NAA_N@Z
.text:00000DF6                 mov     eax, large fs:0
.text:00000DFC                 push    eax
.text:00000DFD                 sub     esp, 24h
.text:00000E00                 mov     eax, 0CCCCCCCCh
.text:00000E05                 mov     [ebp+var_30], eax
.text:00000E08                 mov     [ebp+var_2C], eax
.text:00000E0B                 mov     [ebp+var_28], eax
.text:00000E0E                 mov     [ebp+var_24], eax
.text:00000E11                 mov     [ebp+var_20], eax
.text:00000E14                 mov     [ebp+var_1C], eax
.text:00000E17                 mov     [ebp+var_18], eax
.text:00000E1A                 mov     [ebp+var_14], eax
.text:00000E1D                 mov     [ebp+var_10], eax
.text:00000E20                 mov     eax, dword ptr ds:___security_cookie
.text:00000E25                 xor     eax, ebp
.text:00000E27                 push    eax
.text:00000E28                 lea     eax, [ebp+var_C]
.text:00000E2B                 mov     large fs:0, eax
.text:00000E31                 mov     [ebp+var_10], ecx
.text:00000E34                 movzx   eax, [ebp+arg_4]
.text:00000E38                 push    eax
.text:00000E39                 mov     ecx, [ebp+arg_0]
.text:00000E3C                 push    ecx
.text:00000E3D                 push    0
.text:00000E3F                 mov     ecx, [ebp+var_10]
.text:00000E42                 call    ?CheckPathCurrent@CCensorNode@NWildcard@@ABE_N_NABV?$CObjectVector@VUString@@@@0@Z ; NWildcard::CCensorNode::CheckPathCurrent(bool,CObjectVector<UString> const &,bool)
.text:00000E47                 movzx   edx, al
.text:00000E4A                 test    edx, edx
.text:00000E4C                 jz      short loc_E5B
.text:00000E4E                 mov     eax, [ebp+arg_8]
.text:00000E51                 mov     byte ptr [eax], 0
.text:00000E54                 mov     al, 1
.text:00000E56                 jmp     loc_F17
.text:00000E5B ; ---------------------------------------------------------------------------
.text:00000E5B
.text:00000E5B loc_E5B:                                ; CODE XREF: NWildcard::CCensorNode::CheckPathVect(CObjectVector<UString> const &,bool,bool &)+60j
.text:00000E5B                 mov     ecx, [ebp+arg_8]
.text:00000E5E                 mov     byte ptr [ecx], 1
.text:00000E61                 movzx   edx, [ebp+arg_4]
.text:00000E65                 push    edx
.text:00000E66                 mov     eax, [ebp+arg_0]
.text:00000E69                 push    eax
.text:00000E6A                 push    1
.text:00000E6C                 mov     ecx, [ebp+var_10]
.text:00000E6F                 call    ?CheckPathCurrent@CCensorNode@NWildcard@@ABE_N_NABV?$CObjectVector@VUString@@@@0@Z ; NWildcard::CCensorNode::CheckPathCurrent(bool,CObjectVector<UString> const &,bool)
.text:00000E74                 mov     byte ptr [ebp+var_14+3], al
.text:00000E77                 mov     ecx, [ebp+arg_0]
.text:00000E7A                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:00000E7F                 cmp     eax, 1
.text:00000E82                 ja      short loc_E8C
.text:00000E84                 mov     al, byte ptr [ebp+var_14+3]
.text:00000E87                 jmp     loc_F17
.text:00000E8C ; ---------------------------------------------------------------------------
.text:00000E8C
.text:00000E8C loc_E8C:                                ; CODE XREF: NWildcard::CCensorNode::CheckPathVect(CObjectVector<UString> const &,bool,bool &)+96j
.text:00000E8C                 mov     ecx, [ebp+arg_0]
.text:00000E8F                 call    ?Front@?$CObjectVector@VUString@@@@QBEABVUString@@XZ ; CObjectVector<UString>::Front(void)
.text:00000E94                 push    eax             ; struct UString *
.text:00000E95                 mov     ecx, [ebp+var_10] ; this
.text:00000E98                 call    ?FindSubNode@CCensorNode@NWildcard@@QBEHABVUString@@@Z ; NWildcard::CCensorNode::FindSubNode(UString const &)
.text:00000E9D                 mov     [ebp+var_18], eax
.text:00000EA0                 cmp     [ebp+var_18], 0
.text:00000EA4                 jl      short loc_F14
.text:00000EA6                 mov     ecx, [ebp+arg_0]
.text:00000EA9                 push    ecx
.text:00000EAA                 lea     ecx, [ebp+var_28]
.text:00000EAD                 call    ??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z ; CObjectVector<UString>::CObjectVector<UString>(CObjectVector<UString> const &)
.text:00000EB2                 mov     [ebp+var_4], 0
.text:00000EB9                 push    0
.text:00000EBB                 lea     ecx, [ebp+var_28]
.text:00000EBE                 call    ?Delete@?$CObjectVector@VUString@@@@QAEXI@Z ; CObjectVector<UString>::Delete(uint)
.text:00000EC3                 mov     edx, [ebp+arg_8]
.text:00000EC6                 push    edx
.text:00000EC7                 movzx   eax, [ebp+arg_4]
.text:00000ECB                 push    eax
.text:00000ECC                 lea     ecx, [ebp+var_28]
.text:00000ECF                 push    ecx
.text:00000ED0                 mov     edx, [ebp+var_18]
.text:00000ED3                 push    edx
.text:00000ED4                 mov     ecx, [ebp+var_10]
.text:00000ED7                 add     ecx, 10h
.text:00000EDA                 call    ??A?$CObjectVector@VCCensorNode@NWildcard@@@@QBEABVCCensorNode@NWildcard@@I@Z ; CObjectVector<NWildcard::CCensorNode>::operator[](uint)
.text:00000EDF                 mov     ecx, eax
.text:00000EE1                 call    ?CheckPathVect@CCensorNode@NWildcard@@QBE_NABV?$CObjectVector@VUString@@@@_NAA_N@Z ; NWildcard::CCensorNode::CheckPathVect(CObjectVector<UString> const &,bool,bool &)
.text:00000EE6                 movzx   eax, al
.text:00000EE9                 test    eax, eax
.text:00000EEB                 jz      short loc_F05
.text:00000EED                 mov     byte ptr [ebp+var_30+3], 1
.text:00000EF1                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000EF8                 lea     ecx, [ebp+var_28]
.text:00000EFB                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:00000F00                 mov     al, byte ptr [ebp+var_30+3]
.text:00000F03                 jmp     short loc_F17
.text:00000F05 ; ---------------------------------------------------------------------------
.text:00000F05
.text:00000F05 loc_F05:                                ; CODE XREF: NWildcard::CCensorNode::CheckPathVect(CObjectVector<UString> const &,bool,bool &)+FFj
.text:00000F05                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000F0C                 lea     ecx, [ebp+var_28]
.text:00000F0F                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:00000F14
.text:00000F14 loc_F14:                                ; CODE XREF: NWildcard::CCensorNode::CheckPathVect(CObjectVector<UString> const &,bool,bool &)+B8j
.text:00000F14                 mov     al, byte ptr [ebp+var_14+3]
.text:00000F17
.text:00000F17 loc_F17:                                ; CODE XREF: NWildcard::CCensorNode::CheckPathVect(CObjectVector<UString> const &,bool,bool &)+6Aj
.text:00000F17                                         ; NWildcard::CCensorNode::CheckPathVect(CObjectVector<UString> const &,bool,bool &)+9Bj ...
.text:00000F17                 push    edx
.text:00000F18                 mov     ecx, ebp
.text:00000F1A                 push    eax
.text:00000F1B                 lea     edx, $LN11_0
.text:00000F21                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00000F26                 pop     eax
.text:00000F27                 pop     edx
.text:00000F28                 mov     ecx, [ebp+var_C]
.text:00000F2B                 mov     large fs:0, ecx
.text:00000F32                 pop     ecx
.text:00000F33                 add     esp, 30h
.text:00000F36                 cmp     ebp, esp
.text:00000F38                 call    __RTC_CheckEsp
.text:00000F3D                 mov     esp, ebp
.text:00000F3F                 pop     ebp
.text:00000F40                 retn    0Ch
.text:00000F40 ?CheckPathVect@CCensorNode@NWildcard@@QBE_NABV?$CObjectVector@VUString@@@@_NAA_N@Z endp
.text:00000F40
.text:00000F40 ; ---------------------------------------------------------------------------
.text:00000F43                 align 4
.text:00000F44 $LN11_0         dd 1                    ; DATA XREF: NWildcard::CCensorNode::CheckPathVect(CObjectVector<UString> const &,bool,bool &)+12Fo
.text:00000F48                 dd offset $LN10
.text:00000F4C $LN10           dd 0FFFFFFD8h, 0Ch      ; DATA XREF: .text:00000F48o
.text:00000F54                 dd offset $LN8          ; "pathParts2"
.text:00000F58 $LN8            db 'pathParts2',0       ; DATA XREF: .text:00000F54o
.text:00000F63                 db 9 dup(0CCh)
.text:00000F6C
.text:00000F6C ; =============== S U B R O U T I N E =======================================
.text:00000F6C
.text:00000F6C ; Attributes: bp-based frame
.text:00000F6C
.text:00000F6C ; public: bool __thiscall NWildcard::CCensorNode::CheckPathToRoot(bool, class CObjectVector<class UString> &, bool)const
.text:00000F6C                 public ?CheckPathToRoot@CCensorNode@NWildcard@@QBE_N_NAAV?$CObjectVector@VUString@@@@0@Z
.text:00000F6C ?CheckPathToRoot@CCensorNode@NWildcard@@QBE_N_NAAV?$CObjectVector@VUString@@@@0@Z proc near
.text:00000F6C                                         ; CODE XREF: NWildcard::CCensorNode::CheckPathToRoot(bool,CObjectVector<UString> &,bool)+5Fp
.text:00000F6C
.text:00000F6C var_4           = dword ptr -4
.text:00000F6C arg_0           = byte ptr  8
.text:00000F6C arg_4           = dword ptr  0Ch
.text:00000F6C arg_8           = byte ptr  10h
.text:00000F6C
.text:00000F6C                 push    ebp
.text:00000F6D                 mov     ebp, esp
.text:00000F6F                 push    ecx
.text:00000F70                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000F77                 mov     [ebp+var_4], ecx
.text:00000F7A                 movzx   eax, [ebp+arg_8]
.text:00000F7E                 push    eax
.text:00000F7F                 mov     ecx, [ebp+arg_4]
.text:00000F82                 push    ecx
.text:00000F83                 movzx   edx, [ebp+arg_0]
.text:00000F87                 push    edx
.text:00000F88                 mov     ecx, [ebp+var_4]
.text:00000F8B                 call    ?CheckPathCurrent@CCensorNode@NWildcard@@ABE_N_NABV?$CObjectVector@VUString@@@@0@Z ; NWildcard::CCensorNode::CheckPathCurrent(bool,CObjectVector<UString> const &,bool)
.text:00000F90                 movzx   eax, al
.text:00000F93                 test    eax, eax
.text:00000F95                 jz      short loc_F9B
.text:00000F97                 mov     al, 1
.text:00000F99                 jmp     short loc_FD0
.text:00000F9B ; ---------------------------------------------------------------------------
.text:00000F9B
.text:00000F9B loc_F9B:                                ; CODE XREF: NWildcard::CCensorNode::CheckPathToRoot(bool,CObjectVector<UString> &,bool)+29j
.text:00000F9B                 mov     ecx, [ebp+var_4]
.text:00000F9E                 cmp     dword ptr [ecx], 0
.text:00000FA1                 jnz     short loc_FA7
.text:00000FA3                 xor     al, al
.text:00000FA5                 jmp     short loc_FD0
.text:00000FA7 ; ---------------------------------------------------------------------------
.text:00000FA7
.text:00000FA7 loc_FA7:                                ; CODE XREF: NWildcard::CCensorNode::CheckPathToRoot(bool,CObjectVector<UString> &,bool)+35j
.text:00000FA7                 mov     edx, [ebp+var_4]
.text:00000FAA                 add     edx, 4
.text:00000FAD                 push    edx
.text:00000FAE                 push    0
.text:00000FB0                 mov     ecx, [ebp+arg_4]
.text:00000FB3                 call    ?Insert@?$CObjectVector@VUString@@@@QAEXIABVUString@@@Z ; CObjectVector<UString>::Insert(uint,UString const &)
.text:00000FB8                 movzx   eax, [ebp+arg_8]
.text:00000FBC                 push    eax
.text:00000FBD                 mov     ecx, [ebp+arg_4]
.text:00000FC0                 push    ecx
.text:00000FC1                 movzx   edx, [ebp+arg_0]
.text:00000FC5                 push    edx
.text:00000FC6                 mov     eax, [ebp+var_4]
.text:00000FC9                 mov     ecx, [eax]
.text:00000FCB                 call    ?CheckPathToRoot@CCensorNode@NWildcard@@QBE_N_NAAV?$CObjectVector@VUString@@@@0@Z ; NWildcard::CCensorNode::CheckPathToRoot(bool,CObjectVector<UString> &,bool)
.text:00000FD0
.text:00000FD0 loc_FD0:                                ; CODE XREF: NWildcard::CCensorNode::CheckPathToRoot(bool,CObjectVector<UString> &,bool)+2Dj
.text:00000FD0                                         ; NWildcard::CCensorNode::CheckPathToRoot(bool,CObjectVector<UString> &,bool)+39j
.text:00000FD0                 add     esp, 4
.text:00000FD3                 cmp     ebp, esp
.text:00000FD5                 call    __RTC_CheckEsp
.text:00000FDA                 mov     esp, ebp
.text:00000FDC                 pop     ebp
.text:00000FDD                 retn    0Ch
.text:00000FDD ?CheckPathToRoot@CCensorNode@NWildcard@@QBE_N_NAAV?$CObjectVector@VUString@@@@0@Z endp
.text:00000FDD
.text:00000FDD ; ---------------------------------------------------------------------------
.text:00000FE0                 db 0Ch dup(0CCh)
.text:00000FEC
.text:00000FEC ; =============== S U B R O U T I N E =======================================
.text:00000FEC
.text:00000FEC ; Attributes: bp-based frame
.text:00000FEC
.text:00000FEC ; void __thiscall NWildcard::CCensorNode::AddItem2(NWildcard::CCensorNode *this, bool, const struct UString *, bool, bool)
.text:00000FEC                 public ?AddItem2@CCensorNode@NWildcard@@QAEX_NABVUString@@00@Z
.text:00000FEC ?AddItem2@CCensorNode@NWildcard@@QAEX_NABVUString@@00@Z proc near
.text:00000FEC
.text:00000FEC var_28          = dword ptr -28h
.text:00000FEC var_24          = dword ptr -24h
.text:00000FEC var_20          = dword ptr -20h
.text:00000FEC var_1C          = dword ptr -1Ch
.text:00000FEC var_18          = dword ptr -18h
.text:00000FEC var_14          = dword ptr -14h
.text:00000FEC var_10          = dword ptr -10h
.text:00000FEC var_C           = dword ptr -0Ch
.text:00000FEC var_4           = dword ptr -4
.text:00000FEC arg_0           = byte ptr  8
.text:00000FEC arg_4           = dword ptr  0Ch
.text:00000FEC arg_8           = byte ptr  10h
.text:00000FEC arg_C           = byte ptr  14h
.text:00000FEC
.text:00000FEC                 push    ebp
.text:00000FED                 mov     ebp, esp
.text:00000FEF                 push    0FFFFFFFFh
.text:00000FF1                 push    offset __ehhandler$?AddItem2@CCensorNode@NWildcard@@QAEX_NABVUString@@00@Z
.text:00000FF6                 mov     eax, large fs:0
.text:00000FFC                 push    eax
.text:00000FFD                 sub     esp, 1Ch
.text:00001000                 mov     eax, 0CCCCCCCCh
.text:00001005                 mov     [ebp+var_28], eax
.text:00001008                 mov     [ebp+var_24], eax
.text:0000100B                 mov     [ebp+var_20], eax
.text:0000100E                 mov     [ebp+var_1C], eax
.text:00001011                 mov     [ebp+var_18], eax
.text:00001014                 mov     [ebp+var_14], eax
.text:00001017                 mov     [ebp+var_10], eax
.text:0000101A                 mov     eax, dword ptr ds:___security_cookie
.text:0000101F                 xor     eax, ebp
.text:00001021                 push    eax
.text:00001022                 lea     eax, [ebp+var_C]
.text:00001025                 mov     large fs:0, eax
.text:0000102B                 mov     [ebp+var_10], ecx
.text:0000102E                 mov     ecx, [ebp+arg_4] ; this
.text:00001031                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:00001036                 movzx   eax, al
.text:00001039                 test    eax, eax
.text:0000103B                 jz      short loc_103F
.text:0000103D                 jmp     short loc_10B2
.text:0000103F ; ---------------------------------------------------------------------------
.text:0000103F
.text:0000103F loc_103F:                               ; CODE XREF: NWildcard::CCensorNode::AddItem2(bool,UString const &,bool,bool)+4Fj
.text:0000103F                 mov     byte ptr [ebp+var_14+3], 1
.text:00001043                 mov     byte ptr [ebp+var_14+2], 1
.text:00001047                 mov     ecx, [ebp+arg_4]
.text:0000104A                 push    ecx
.text:0000104B                 lea     ecx, [ebp+var_24]
.text:0000104E                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00001053                 mov     [ebp+var_4], 0
.text:0000105A                 mov     ecx, [ebp+arg_4] ; this
.text:0000105D                 call    ?Back@UString@@QBE_WXZ ; UString::Back(void)
.text:00001062                 movzx   edx, ax
.text:00001065                 push    edx             ; wchar_t
.text:00001066                 call    ?IsPathSepar@@YG_N_W@Z ; IsPathSepar(wchar_t)
.text:0000106B                 movzx   eax, al
.text:0000106E                 test    eax, eax
.text:00001070                 jz      short loc_107E
.text:00001072                 lea     ecx, [ebp+var_24] ; this
.text:00001075                 call    ?DeleteBack@UString@@QAEXXZ ; UString::DeleteBack(void)
.text:0000107A                 mov     byte ptr [ebp+var_14+3], 0
.text:0000107E
.text:0000107E loc_107E:                               ; CODE XREF: NWildcard::CCensorNode::AddItem2(bool,UString const &,bool,bool)+84j
.text:0000107E                 movzx   ecx, [ebp+arg_C]
.text:00001082                 push    ecx             ; bool
.text:00001083                 movzx   edx, byte ptr [ebp+var_14+2]
.text:00001087                 push    edx             ; bool
.text:00001088                 movzx   eax, byte ptr [ebp+var_14+3]
.text:0000108C                 push    eax             ; bool
.text:0000108D                 movzx   ecx, [ebp+arg_8]
.text:00001091                 push    ecx             ; bool
.text:00001092                 lea     edx, [ebp+var_24]
.text:00001095                 push    edx             ; struct UString *
.text:00001096                 movzx   eax, [ebp+arg_0]
.text:0000109A                 push    eax             ; bool
.text:0000109B                 mov     ecx, [ebp+var_10] ; this
.text:0000109E                 call    ?AddItem@CCensorNode@NWildcard@@QAEX_NABVUString@@0000@Z ; NWildcard::CCensorNode::AddItem(bool,UString const &,bool,bool,bool,bool)
.text:000010A3                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000010AA                 lea     ecx, [ebp+var_24] ; this
.text:000010AD                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000010B2
.text:000010B2 loc_10B2:                               ; CODE XREF: NWildcard::CCensorNode::AddItem2(bool,UString const &,bool,bool)+51j
.text:000010B2                 push    edx
.text:000010B3                 mov     ecx, ebp
.text:000010B5                 push    eax
.text:000010B6                 lea     edx, $LN9_0
.text:000010BC                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:000010C1                 pop     eax
.text:000010C2                 pop     edx
.text:000010C3                 mov     ecx, [ebp+var_C]
.text:000010C6                 mov     large fs:0, ecx
.text:000010CD                 pop     ecx
.text:000010CE                 add     esp, 28h
.text:000010D1                 cmp     ebp, esp
.text:000010D3                 call    __RTC_CheckEsp
.text:000010D8                 mov     esp, ebp
.text:000010DA                 pop     ebp
.text:000010DB                 retn    10h
.text:000010DB ?AddItem2@CCensorNode@NWildcard@@QAEX_NABVUString@@00@Z endp
.text:000010DB
.text:000010DB ; ---------------------------------------------------------------------------
.text:000010DE                 align 10h
.text:000010E0 $LN9_0          dd 1                    ; DATA XREF: NWildcard::CCensorNode::AddItem2(bool,UString const &,bool,bool)+CAo
.text:000010E4                 dd offset $LN8_0
.text:000010E8 $LN8_0          dd 0FFFFFFDCh, 0Ch      ; DATA XREF: .text:000010E4o
.text:000010F0                 dd offset $LN6_0        ; "path2"
.text:000010F4 $LN6_0          db 'path2',0            ; DATA XREF: .text:000010F0o
.text:000010FA                 align 4
.text:000010FC
.text:000010FC ; =============== S U B R O U T I N E =======================================
.text:000010FC
.text:000010FC ; Attributes: bp-based frame
.text:000010FC
.text:000010FC ; void __thiscall NWildcard::CCensorNode::ExtendExclude(NWildcard::CCensorNode *this, const struct NWildcard::CCensorNode *)
.text:000010FC                 public ?ExtendExclude@CCensorNode@NWildcard@@QAEXABV12@@Z
.text:000010FC ?ExtendExclude@CCensorNode@NWildcard@@QAEXABV12@@Z proc near
.text:000010FC                                         ; CODE XREF: NWildcard::CCensorNode::ExtendExclude(NWildcard::CCensorNode const &)+F5p
.text:000010FC                                         ; NWildcard::CCensor::ExtendExclude(void)+B8p
.text:000010FC
.text:000010FC var_58          = dword ptr -58h
.text:000010FC var_54          = dword ptr -54h
.text:000010FC var_50          = byte ptr -50h
.text:000010FC var_1C          = dword ptr -1Ch
.text:000010FC var_18          = dword ptr -18h
.text:000010FC var_14          = dword ptr -14h
.text:000010FC var_10          = dword ptr -10h
.text:000010FC var_C           = dword ptr -0Ch
.text:000010FC var_4           = dword ptr -4
.text:000010FC arg_0           = dword ptr  8
.text:000010FC
.text:000010FC                 push    ebp
.text:000010FD                 mov     ebp, esp
.text:000010FF                 push    0FFFFFFFFh
.text:00001101                 push    offset __ehhandler$?ExtendExclude@CCensorNode@NWildcard@@QAEXABV12@@Z
.text:00001106                 mov     eax, large fs:0
.text:0000110C                 push    eax
.text:0000110D                 sub     esp, 4Ch
.text:00001110                 push    edi
.text:00001111                 push    ecx
.text:00001112                 lea     edi, [ebp+var_58]
.text:00001115                 mov     ecx, 13h
.text:0000111A                 mov     eax, 0CCCCCCCCh
.text:0000111F                 rep stosd
.text:00001121                 pop     ecx
.text:00001122                 mov     eax, dword ptr ds:___security_cookie
.text:00001127                 xor     eax, ebp
.text:00001129                 push    eax
.text:0000112A                 lea     eax, [ebp+var_C]
.text:0000112D                 mov     large fs:0, eax
.text:00001133                 mov     [ebp+var_10], ecx
.text:00001136                 mov     eax, [ebp+arg_0]
.text:00001139                 add     eax, 28h ; '('
.text:0000113C                 push    eax
.text:0000113D                 mov     ecx, [ebp+var_10]
.text:00001140                 add     ecx, 28h ; '('
.text:00001143                 call    ??Y?$CObjectVector@UCItem@NWildcard@@@@QAEAAV0@ABV0@@Z ; CObjectVector<NWildcard::CItem>::operator+=(CObjectVector<NWildcard::CItem> const &)
.text:00001148                 mov     [ebp+var_14], 0
.text:0000114F                 jmp     short loc_115A
.text:00001151 ; ---------------------------------------------------------------------------
.text:00001151
.text:00001151 loc_1151:                               ; CODE XREF: NWildcard::CCensorNode::ExtendExclude(NWildcard::CCensorNode const &)+FAj
.text:00001151                 mov     ecx, [ebp+var_14]
.text:00001154                 add     ecx, 1
.text:00001157                 mov     [ebp+var_14], ecx
.text:0000115A
.text:0000115A loc_115A:                               ; CODE XREF: NWildcard::CCensorNode::ExtendExclude(NWildcard::CCensorNode const &)+53j
.text:0000115A                 mov     ecx, [ebp+arg_0]
.text:0000115D                 add     ecx, 10h
.text:00001160                 call    ?Size@?$CObjectVector@VCCensorNode@NWildcard@@@@QBEIXZ ; CObjectVector<NWildcard::CCensorNode>::Size(void)
.text:00001165                 cmp     [ebp+var_14], eax
.text:00001168                 jnb     loc_11FB
.text:0000116E                 mov     edx, [ebp+var_14]
.text:00001171                 push    edx
.text:00001172                 mov     ecx, [ebp+arg_0]
.text:00001175                 add     ecx, 10h
.text:00001178                 call    ??A?$CObjectVector@VCCensorNode@NWildcard@@@@QBEABVCCensorNode@NWildcard@@I@Z ; CObjectVector<NWildcard::CCensorNode>::operator[](uint)
.text:0000117D                 mov     [ebp+var_18], eax
.text:00001180                 mov     eax, [ebp+var_18]
.text:00001183                 add     eax, 4
.text:00001186                 push    eax             ; struct UString *
.text:00001187                 mov     ecx, [ebp+var_10] ; this
.text:0000118A                 call    ?FindSubNode@CCensorNode@NWildcard@@QBEHABVUString@@@Z ; NWildcard::CCensorNode::FindSubNode(UString const &)
.text:0000118F                 mov     [ebp+var_1C], eax
.text:00001192                 cmp     [ebp+var_1C], 0
.text:00001196                 jge     short loc_11DC
.text:00001198                 mov     ecx, [ebp+var_10]
.text:0000119B                 push    ecx             ; struct NWildcard::CCensorNode *
.text:0000119C                 mov     edx, [ebp+var_18]
.text:0000119F                 add     edx, 4
.text:000011A2                 push    edx             ; struct UString *
.text:000011A3                 lea     ecx, [ebp+var_50] ; this
.text:000011A6                 call    ??0CCensorNode@NWildcard@@QAE@ABVUString@@PAV01@@Z ; NWildcard::CCensorNode::CCensorNode(UString const &,NWildcard::CCensorNode *)
.text:000011AB                 mov     [ebp+var_54], eax
.text:000011AE                 mov     eax, [ebp+var_54]
.text:000011B1                 mov     [ebp+var_58], eax
.text:000011B4                 mov     [ebp+var_4], 0
.text:000011BB                 mov     ecx, [ebp+var_58]
.text:000011BE                 push    ecx
.text:000011BF                 mov     ecx, [ebp+var_10]
.text:000011C2                 add     ecx, 10h
.text:000011C5                 call    ?Add@?$CObjectVector@VCCensorNode@NWildcard@@@@QAEIABVCCensorNode@NWildcard@@@Z ; CObjectVector<NWildcard::CCensorNode>::Add(NWildcard::CCensorNode const &)
.text:000011CA                 mov     [ebp+var_1C], eax
.text:000011CD                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000011D4                 lea     ecx, [ebp+var_50] ; this
.text:000011D7                 call    ??1CCensorNode@NWildcard@@QAE@XZ ; NWildcard::CCensorNode::~CCensorNode(void)
.text:000011DC
.text:000011DC loc_11DC:                               ; CODE XREF: NWildcard::CCensorNode::ExtendExclude(NWildcard::CCensorNode const &)+9Aj
.text:000011DC                 mov     edx, [ebp+var_18]
.text:000011DF                 push    edx             ; struct NWildcard::CCensorNode *
.text:000011E0                 mov     eax, [ebp+var_1C]
.text:000011E3                 push    eax
.text:000011E4                 mov     ecx, [ebp+var_10]
.text:000011E7                 add     ecx, 10h
.text:000011EA                 call    ??A?$CObjectVector@VCCensorNode@NWildcard@@@@QAEAAVCCensorNode@NWildcard@@I@Z ; CObjectVector<NWildcard::CCensorNode>::operator[](uint)
.text:000011EF                 mov     ecx, eax        ; this
.text:000011F1                 call    ?ExtendExclude@CCensorNode@NWildcard@@QAEXABV12@@Z ; NWildcard::CCensorNode::ExtendExclude(NWildcard::CCensorNode const &)
.text:000011F6                 jmp     loc_1151
.text:000011FB ; ---------------------------------------------------------------------------
.text:000011FB
.text:000011FB loc_11FB:                               ; CODE XREF: NWildcard::CCensorNode::ExtendExclude(NWildcard::CCensorNode const &)+6Cj
.text:000011FB                 mov     ecx, [ebp+var_C]
.text:000011FE                 mov     large fs:0, ecx
.text:00001205                 pop     ecx
.text:00001206                 pop     edi
.text:00001207                 add     esp, 58h
.text:0000120A                 cmp     ebp, esp
.text:0000120C                 call    __RTC_CheckEsp
.text:00001211                 mov     esp, ebp
.text:00001213                 pop     ebp
.text:00001214                 retn    4
.text:00001214 ?ExtendExclude@CCensorNode@NWildcard@@QAEXABV12@@Z endp
.text:00001214
.text:00001214 ; ---------------------------------------------------------------------------
.text:00001217                 db 5 dup(0CCh)
.text:0000121C
.text:0000121C ; =============== S U B R O U T I N E =======================================
.text:0000121C
.text:0000121C ; Attributes: bp-based frame
.text:0000121C
.text:0000121C ; int __thiscall NWildcard::CCensor::FindPrefix(NWildcard::CCensor *this, const struct UString *)
.text:0000121C                 public ?FindPrefix@CCensor@NWildcard@@ABEHABVUString@@@Z
.text:0000121C ?FindPrefix@CCensor@NWildcard@@ABEHABVUString@@@Z proc near
.text:0000121C                                         ; CODE XREF: NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+287p
.text:0000121C
.text:0000121C var_8           = dword ptr -8
.text:0000121C var_4           = dword ptr -4
.text:0000121C arg_0           = dword ptr  8
.text:0000121C
.text:0000121C                 push    ebp
.text:0000121D                 mov     ebp, esp
.text:0000121F                 sub     esp, 8
.text:00001222                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00001229                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001230                 mov     [ebp+var_4], ecx
.text:00001233                 mov     [ebp+var_8], 0
.text:0000123A                 jmp     short loc_1245
.text:0000123C ; ---------------------------------------------------------------------------
.text:0000123C
.text:0000123C loc_123C:                               ; CODE XREF: NWildcard::CCensor::FindPrefix(UString const &):loc_127Dj
.text:0000123C                 mov     eax, [ebp+var_8]
.text:0000123F                 add     eax, 1
.text:00001242                 mov     [ebp+var_8], eax
.text:00001245
.text:00001245 loc_1245:                               ; CODE XREF: NWildcard::CCensor::FindPrefix(UString const &)+1Ej
.text:00001245                 mov     ecx, [ebp+var_4]
.text:00001248                 call    ?Size@?$CObjectVector@UCPair@NWildcard@@@@QBEIXZ ; CObjectVector<NWildcard::CPair>::Size(void)
.text:0000124D                 cmp     [ebp+var_8], eax
.text:00001250                 jnb     short loc_127F
.text:00001252                 mov     ecx, [ebp+arg_0]
.text:00001255                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:0000125A                 push    eax             ; Str2
.text:0000125B                 mov     ecx, [ebp+var_8]
.text:0000125E                 push    ecx
.text:0000125F                 mov     ecx, [ebp+var_4]
.text:00001262                 call    ??A?$CObjectVector@UCPair@NWildcard@@@@QBEABUCPair@NWildcard@@I@Z ; CObjectVector<NWildcard::CPair>::operator[](uint)
.text:00001267                 mov     ecx, eax
.text:00001269                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:0000126E                 push    eax             ; Str1
.text:0000126F                 call    ?CompareFileNames@@YGHPB_W0@Z ; CompareFileNames(wchar_t const *,wchar_t const *)
.text:00001274                 test    eax, eax
.text:00001276                 jnz     short loc_127D
.text:00001278                 mov     eax, [ebp+var_8]
.text:0000127B                 jmp     short loc_1282
.text:0000127D ; ---------------------------------------------------------------------------
.text:0000127D
.text:0000127D loc_127D:                               ; CODE XREF: NWildcard::CCensor::FindPrefix(UString const &)+5Aj
.text:0000127D                 jmp     short loc_123C
.text:0000127F ; ---------------------------------------------------------------------------
.text:0000127F
.text:0000127F loc_127F:                               ; CODE XREF: NWildcard::CCensor::FindPrefix(UString const &)+34j
.text:0000127F                 or      eax, 0FFFFFFFFh
.text:00001282
.text:00001282 loc_1282:                               ; CODE XREF: NWildcard::CCensor::FindPrefix(UString const &)+5Fj
.text:00001282                 add     esp, 8
.text:00001285                 cmp     ebp, esp
.text:00001287                 call    __RTC_CheckEsp
.text:0000128C                 mov     esp, ebp
.text:0000128E                 pop     ebp
.text:0000128F                 retn    4
.text:0000128F ?FindPrefix@CCensor@NWildcard@@ABEHABVUString@@@Z endp
.text:0000128F
.text:0000128F ; ---------------------------------------------------------------------------
.text:00001292                 db 0Ah dup(0CCh)
.text:0000129C
.text:0000129C ; =============== S U B R O U T I N E =======================================
.text:0000129C
.text:0000129C ; Attributes: bp-based frame
.text:0000129C
.text:0000129C ; bool __stdcall NWildcard::IsDriveColonName(NWildcard *this, const wchar_t *)
.text:0000129C                 public ?IsDriveColonName@NWildcard@@YG_NPB_W@Z
.text:0000129C ?IsDriveColonName@NWildcard@@YG_NPB_W@Z proc near
.text:0000129C                                         ; CODE XREF: NWildcard::GetNumPrefixParts_if_DrivePath(CObjectVector<UString> &)+A0p
.text:0000129C                                         ; NWildcard::GetNumPrefixParts(CObjectVector<UString>)+7Bp ...
.text:0000129C
.text:0000129C var_8           = dword ptr -8
.text:0000129C var_4           = dword ptr -4
.text:0000129C this            = dword ptr  8
.text:0000129C
.text:0000129C                 push    ebp
.text:0000129D                 mov     ebp, esp
.text:0000129F                 sub     esp, 8
.text:000012A2                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000012A9                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000012B0                 mov     eax, [ebp+this]
.text:000012B3                 mov     cx, [eax]
.text:000012B6                 mov     word ptr [ebp+var_4], cx
.text:000012BA                 movzx   edx, word ptr [ebp+var_4]
.text:000012BE                 test    edx, edx
.text:000012C0                 jz      short loc_1306
.text:000012C2                 mov     eax, [ebp+this]
.text:000012C5                 movzx   ecx, word ptr [eax+2]
.text:000012C9                 cmp     ecx, 3Ah ; ':'
.text:000012CC                 jnz     short loc_1306
.text:000012CE                 mov     edx, [ebp+this]
.text:000012D1                 movzx   eax, word ptr [edx+4]
.text:000012D5                 test    eax, eax
.text:000012D7                 jnz     short loc_1306
.text:000012D9                 movzx   ecx, word ptr [ebp+var_4]
.text:000012DD                 cmp     ecx, 61h ; 'a'
.text:000012E0                 jl      short loc_12EB
.text:000012E2                 movzx   edx, word ptr [ebp+var_4]
.text:000012E6                 cmp     edx, 7Ah ; 'z'
.text:000012E9                 jle     short loc_12FD
.text:000012EB
.text:000012EB loc_12EB:                               ; CODE XREF: NWildcard::IsDriveColonName(wchar_t const *)+44j
.text:000012EB                 movzx   eax, word ptr [ebp+var_4]
.text:000012EF                 cmp     eax, 41h ; 'A'
.text:000012F2                 jl      short loc_1306
.text:000012F4                 movzx   ecx, word ptr [ebp+var_4]
.text:000012F8                 cmp     ecx, 5Ah ; 'Z'
.text:000012FB                 jg      short loc_1306
.text:000012FD
.text:000012FD loc_12FD:                               ; CODE XREF: NWildcard::IsDriveColonName(wchar_t const *)+4Dj
.text:000012FD                 mov     [ebp+var_8], 1
.text:00001304                 jmp     short loc_130D
.text:00001306 ; ---------------------------------------------------------------------------
.text:00001306
.text:00001306 loc_1306:                               ; CODE XREF: NWildcard::IsDriveColonName(wchar_t const *)+24j
.text:00001306                                         ; NWildcard::IsDriveColonName(wchar_t const *)+30j ...
.text:00001306                 mov     [ebp+var_8], 0
.text:0000130D
.text:0000130D loc_130D:                               ; CODE XREF: NWildcard::IsDriveColonName(wchar_t const *)+68j
.text:0000130D                 mov     al, byte ptr [ebp+var_8]
.text:00001310                 mov     esp, ebp
.text:00001312                 pop     ebp
.text:00001313                 retn    4
.text:00001313 ?IsDriveColonName@NWildcard@@YG_NPB_W@Z endp
.text:00001313
.text:00001313 ; ---------------------------------------------------------------------------
.text:00001316                 db 6 dup(0CCh)
.text:0000131C
.text:0000131C ; =============== S U B R O U T I N E =======================================
.text:0000131C
.text:0000131C ; Attributes: bp-based frame
.text:0000131C
.text:0000131C ; int __thiscall NWildcard::GetNumPrefixParts_if_DrivePath(wchar_t *, int)
.text:0000131C                 public ?GetNumPrefixParts_if_DrivePath@NWildcard@@YGIAAV?$CObjectVector@VUString@@@@@Z
.text:0000131C ?GetNumPrefixParts_if_DrivePath@NWildcard@@YGIAAV?$CObjectVector@VUString@@@@@Z proc near
.text:0000131C
.text:0000131C var_4           = dword ptr -4
.text:0000131C arg_0           = dword ptr  8
.text:0000131C
.text:0000131C                 push    ebp
.text:0000131D                 mov     ebp, esp
.text:0000131F                 push    ecx             ; wchar_t *
.text:00001320                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001327                 mov     ecx, [ebp+arg_0]
.text:0000132A                 call    ?IsEmpty@?$CObjectVector@VUString@@@@QBE_NXZ ; CObjectVector<UString>::IsEmpty(void)
.text:0000132F                 movzx   eax, al
.text:00001332                 test    eax, eax
.text:00001334                 jz      short loc_133D
.text:00001336                 xor     eax, eax
.text:00001338                 jmp     loc_13D2
.text:0000133D ; ---------------------------------------------------------------------------
.text:0000133D
.text:0000133D loc_133D:                               ; CODE XREF: NWildcard::GetNumPrefixParts_if_DrivePath(CObjectVector<UString> &)+18j
.text:0000133D                 mov     [ebp+var_4], 0
.text:00001344                 push    0
.text:00001346                 mov     ecx, [ebp+arg_0]
.text:00001349                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:0000134E                 mov     ecx, eax        ; this
.text:00001350                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:00001355                 movzx   ecx, al
.text:00001358                 test    ecx, ecx
.text:0000135A                 jz      short loc_13A8
.text:0000135C                 mov     ecx, [ebp+arg_0]
.text:0000135F                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:00001364                 cmp     eax, 4
.text:00001367                 jb      short loc_139D
.text:00001369                 push    1
.text:0000136B                 mov     ecx, [ebp+arg_0]
.text:0000136E                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00001373                 mov     ecx, eax        ; this
.text:00001375                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:0000137A                 movzx   edx, al
.text:0000137D                 test    edx, edx
.text:0000137F                 jz      short loc_139D
.text:00001381                 push    offset $SG67871 ; Str2
.text:00001386                 push    2
.text:00001388                 mov     ecx, [ebp+arg_0]
.text:0000138B                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00001390                 push    eax             ; int
.text:00001391                 call    ??9@YG_NABVUString@@PB_W@Z ; operator!=(UString const &,wchar_t const *)
.text:00001396                 movzx   eax, al
.text:00001399                 test    eax, eax
.text:0000139B                 jz      short loc_13A1
.text:0000139D
.text:0000139D loc_139D:                               ; CODE XREF: NWildcard::GetNumPrefixParts_if_DrivePath(CObjectVector<UString> &)+4Bj
.text:0000139D                                         ; NWildcard::GetNumPrefixParts_if_DrivePath(CObjectVector<UString> &)+63j
.text:0000139D                 xor     eax, eax
.text:0000139F                 jmp     short loc_13D2
.text:000013A1 ; ---------------------------------------------------------------------------
.text:000013A1
.text:000013A1 loc_13A1:                               ; CODE XREF: NWildcard::GetNumPrefixParts_if_DrivePath(CObjectVector<UString> &)+7Fj
.text:000013A1                 mov     [ebp+var_4], 3
.text:000013A8
.text:000013A8 loc_13A8:                               ; CODE XREF: NWildcard::GetNumPrefixParts_if_DrivePath(CObjectVector<UString> &)+3Ej
.text:000013A8                 mov     ecx, [ebp+var_4]
.text:000013AB                 push    ecx
.text:000013AC                 mov     ecx, [ebp+arg_0]
.text:000013AF                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:000013B4                 mov     ecx, eax
.text:000013B6                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000013BB                 push    eax             ; this
.text:000013BC                 call    ?IsDriveColonName@NWildcard@@YG_NPB_W@Z ; NWildcard::IsDriveColonName(wchar_t const *)
.text:000013C1                 movzx   edx, al
.text:000013C4                 test    edx, edx
.text:000013C6                 jz      short loc_13D0
.text:000013C8                 mov     eax, [ebp+var_4]
.text:000013CB                 add     eax, 1
.text:000013CE                 jmp     short loc_13D2
.text:000013D0 ; ---------------------------------------------------------------------------
.text:000013D0
.text:000013D0 loc_13D0:                               ; CODE XREF: NWildcard::GetNumPrefixParts_if_DrivePath(CObjectVector<UString> &)+AAj
.text:000013D0                 xor     eax, eax
.text:000013D2
.text:000013D2 loc_13D2:                               ; CODE XREF: NWildcard::GetNumPrefixParts_if_DrivePath(CObjectVector<UString> &)+1Cj
.text:000013D2                                         ; NWildcard::GetNumPrefixParts_if_DrivePath(CObjectVector<UString> &)+83j ...
.text:000013D2                 add     esp, 4
.text:000013D5                 cmp     ebp, esp
.text:000013D7                 call    __RTC_CheckEsp
.text:000013DC                 mov     esp, ebp
.text:000013DE                 pop     ebp
.text:000013DF                 retn    4
.text:000013DF ?GetNumPrefixParts_if_DrivePath@NWildcard@@YGIAAV?$CObjectVector@VUString@@@@@Z endp
.text:000013DF
.text:000013DF ; ---------------------------------------------------------------------------
.text:000013E2                 db 0Ah dup(0CCh)
.text:000013EC
.text:000013EC ; =============== S U B R O U T I N E =======================================
.text:000013EC
.text:000013EC ; Attributes: bp-based frame
.text:000013EC
.text:000013EC ; public: void __thiscall NWildcard::CCensor::AddItem(enum  NWildcard::ECensorPathMode, bool, class UString const &, bool, bool)
.text:000013EC                 public ?AddItem@CCensor@NWildcard@@QAEXW4ECensorPathMode@2@_NABVUString@@11@Z
.text:000013EC ?AddItem@CCensor@NWildcard@@QAEXW4ECensorPathMode@2@_NABVUString@@11@Z proc near
.text:000013EC                                         ; CODE XREF: NWildcard::CCensor::AddPathsToCensor(NWildcard::ECensorPathMode)+75p
.text:000013EC
.text:000013EC var_DC          = dword ptr -0DCh
.text:000013EC var_D8          = dword ptr -0D8h
.text:000013EC var_D4          = dword ptr -0D4h
.text:000013EC var_D0          = dword ptr -0D0h
.text:000013EC var_CC          = byte ptr -0CCh
.text:000013EC var_C0          = byte ptr -0C0h
.text:000013EC var_80          = dword ptr -80h
.text:000013EC var_7C          = dword ptr -7Ch
.text:000013EC var_74          = byte ptr -74h
.text:000013EC var_68          = byte ptr -68h
.text:000013EC var_67          = byte ptr -67h
.text:000013EC var_66          = byte ptr -66h
.text:000013EC var_65          = byte ptr -65h
.text:000013EC var_60          = dword ptr -60h
.text:000013EC var_5C          = dword ptr -5Ch
.text:000013EC var_58          = dword ptr -58h
.text:000013EC var_54          = dword ptr -54h
.text:000013EC var_50          = dword ptr -50h
.text:000013EC var_4C          = dword ptr -4Ch
.text:000013EC var_48          = dword ptr -48h
.text:000013EC var_44          = dword ptr -44h
.text:000013EC var_40          = dword ptr -40h
.text:000013EC var_38          = byte ptr -38h
.text:000013EC var_25          = byte ptr -25h
.text:000013EC var_20          = dword ptr -20h
.text:000013EC var_10          = dword ptr -10h
.text:000013EC var_C           = dword ptr -0Ch
.text:000013EC var_4           = dword ptr -4
.text:000013EC arg_0           = dword ptr  8
.text:000013EC arg_4           = byte ptr  0Ch
.text:000013EC arg_8           = dword ptr  10h
.text:000013EC arg_C           = byte ptr  14h
.text:000013EC arg_10          = byte ptr  18h
.text:000013EC
.text:000013EC                 push    ebp
.text:000013ED                 mov     ebp, esp
.text:000013EF                 push    0FFFFFFFFh
.text:000013F1                 push    offset __ehhandler$?AddItem@CCensor@NWildcard@@QAEXW4ECensorPathMode@2@_NABVUString@@11@Z
.text:000013F6                 mov     eax, large fs:0
.text:000013FC                 push    eax
.text:000013FD                 sub     esp, 0D0h
.text:00001403                 push    edi
.text:00001404                 push    ecx
.text:00001405                 lea     edi, [ebp+var_DC]
.text:0000140B                 mov     ecx, 34h ; '4'
.text:00001410                 mov     eax, 0CCCCCCCCh
.text:00001415                 rep stosd
.text:00001417                 pop     ecx
.text:00001418                 mov     eax, dword ptr ds:___security_cookie
.text:0000141D                 xor     eax, ebp
.text:0000141F                 push    eax
.text:00001420                 lea     eax, [ebp+var_C]
.text:00001423                 mov     large fs:0, eax
.text:00001429                 mov     [ebp+var_10], ecx
.text:0000142C                 mov     ecx, [ebp+arg_8] ; this
.text:0000142F                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:00001434                 movzx   eax, al
.text:00001437                 test    eax, eax
.text:00001439                 jz      short loc_1450
.text:0000143B                 mov     [ebp+var_7C], offset $SG67921 ; "Empty file path"
.text:00001442                 push    offset __TI2PAD
.text:00001447                 lea     ecx, [ebp+var_7C]
.text:0000144A                 push    ecx
.text:0000144B                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:00001450 ; ---------------------------------------------------------------------------
.text:00001450
.text:00001450 loc_1450:                               ; CODE XREF: NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+4Dj
.text:00001450                 lea     ecx, [ebp+var_20]
.text:00001453                 call    ??0?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::CObjectVector<UString>(void)
.text:00001458                 mov     [ebp+var_4], 0
.text:0000145F                 lea     edx, [ebp+var_20]
.text:00001462                 push    edx             ; int
.text:00001463                 mov     eax, [ebp+arg_8]
.text:00001466                 push    eax             ; UString *
.text:00001467                 call    ?SplitPathToParts@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z ; SplitPathToParts(UString const &,CObjectVector<UString> &)
.text:0000146C                 mov     [ebp+var_25], 1
.text:00001470                 lea     ecx, [ebp+var_20]
.text:00001473                 call    ?Back@?$CObjectVector@VUString@@@@QAEAAVUString@@XZ ; CObjectVector<UString>::Back(void)
.text:00001478                 mov     ecx, eax        ; this
.text:0000147A                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:0000147F                 movzx   ecx, al
.text:00001482                 test    ecx, ecx
.text:00001484                 jz      short loc_1492
.text:00001486                 mov     [ebp+var_25], 0
.text:0000148A                 lea     ecx, [ebp+var_20]
.text:0000148D                 call    ?DeleteBack@?$CObjectVector@VUString@@@@QAEXXZ ; CObjectVector<UString>::DeleteBack(void)
.text:00001492
.text:00001492 loc_1492:                               ; CODE XREF: NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+98j
.text:00001492                 lea     ecx, [ebp+var_38]
.text:00001495                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:0000149A                 mov     byte ptr [ebp+var_4], 1
.text:0000149E                 mov     [ebp+var_40], 0FFFFFFFFh
.text:000014A5                 lea     ecx, [ebp+var_20]
.text:000014A8                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:000014AD                 cmp     eax, 3
.text:000014B0                 jb      short loc_1505
.text:000014B2                 push    0
.text:000014B4                 lea     ecx, [ebp+var_20]
.text:000014B7                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:000014BC                 mov     ecx, eax        ; this
.text:000014BE                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:000014C3                 movzx   edx, al
.text:000014C6                 test    edx, edx
.text:000014C8                 jz      short loc_1505
.text:000014CA                 push    1
.text:000014CC                 lea     ecx, [ebp+var_20]
.text:000014CF                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:000014D4                 mov     ecx, eax        ; this
.text:000014D6                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:000014DB                 movzx   eax, al
.text:000014DE                 test    eax, eax
.text:000014E0                 jz      short loc_1505
.text:000014E2                 push    offset $SG67928 ; Str2
.text:000014E7                 push    2
.text:000014E9                 lea     ecx, [ebp+var_20]
.text:000014EC                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:000014F1                 push    eax             ; int
.text:000014F2                 call    ??8@YG_NABVUString@@PB_W@Z ; operator==(UString const &,wchar_t const *)
.text:000014F7                 movzx   ecx, al
.text:000014FA                 test    ecx, ecx
.text:000014FC                 jz      short loc_1505
.text:000014FE                 mov     [ebp+var_40], 2
.text:00001505
.text:00001505 loc_1505:                               ; CODE XREF: NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+C4j
.text:00001505                                         ; NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+DCj ...
.text:00001505                 cmp     [ebp+arg_0], 2
.text:00001509                 jz      loc_166C
.text:0000150F                 mov     [ebp+var_40], 0FFFFFFFFh
.text:00001516                 sub     esp, 0Ch
.text:00001519                 mov     ecx, esp
.text:0000151B                 mov     [ebp+var_80], esp
.text:0000151E                 lea     edx, [ebp+var_20]
.text:00001521                 push    edx
.text:00001522                 call    ??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z ; CObjectVector<UString>::CObjectVector<UString>(CObjectVector<UString> const &)
.text:00001527                 mov     [ebp+var_D0], eax
.text:0000152D                 call    ?GetNumPrefixParts@NWildcard@@YGIV?$CObjectVector@VUString@@@@@Z ; NWildcard::GetNumPrefixParts(CObjectVector<UString>)
.text:00001532                 mov     [ebp+var_D4], eax
.text:00001538                 mov     eax, [ebp+var_D4]
.text:0000153E                 mov     [ebp+var_44], eax
.text:00001541                 mov     ecx, [ebp+var_44]
.text:00001544                 mov     [ebp+var_48], ecx
.text:00001547                 cmp     [ebp+arg_0], 1
.text:0000154B                 jz      short loc_156E
.text:0000154D                 cmp     [ebp+var_44], 0
.text:00001551                 jz      short loc_156E
.text:00001553                 lea     ecx, [ebp+var_20]
.text:00001556                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:0000155B                 cmp     eax, [ebp+var_44]
.text:0000155E                 jbe     short loc_156E
.text:00001560                 lea     ecx, [ebp+var_20]
.text:00001563                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:00001568                 sub     eax, 1
.text:0000156B                 mov     [ebp+var_48], eax
.text:0000156E
.text:0000156E loc_156E:                               ; CODE XREF: NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+15Fj
.text:0000156E                                         ; NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+165j ...
.text:0000156E                 mov     [ebp+var_4C], 0FFFFFFFFh
.text:00001575                 mov     edx, [ebp+var_44]
.text:00001578                 mov     [ebp+var_50], edx
.text:0000157B                 jmp     short loc_1586
.text:0000157D ; ---------------------------------------------------------------------------
.text:0000157D
.text:0000157D loc_157D:                               ; CODE XREF: NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool):loc_15D2j
.text:0000157D                 mov     eax, [ebp+var_50]
.text:00001580                 add     eax, 1
.text:00001583                 mov     [ebp+var_50], eax
.text:00001586
.text:00001586 loc_1586:                               ; CODE XREF: NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+18Fj
.text:00001586                 lea     ecx, [ebp+var_20]
.text:00001589                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:0000158E                 cmp     [ebp+var_50], eax
.text:00001591                 jnb     short loc_15D4
.text:00001593                 mov     ecx, [ebp+var_50]
.text:00001596                 push    ecx
.text:00001597                 lea     ecx, [ebp+var_20]
.text:0000159A                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:0000159F                 mov     [ebp+var_54], eax
.text:000015A2                 push    offset $SG67943 ; ".."
.text:000015A7                 mov     edx, [ebp+var_54]
.text:000015AA                 push    edx             ; int
.text:000015AB                 call    ??8@YG_NABVUString@@PB_W@Z ; operator==(UString const &,wchar_t const *)
.text:000015B0                 movzx   eax, al
.text:000015B3                 test    eax, eax
.text:000015B5                 jnz     short loc_15CC
.text:000015B7                 push    offset $SG67944 ; Str2
.text:000015BC                 mov     ecx, [ebp+var_54]
.text:000015BF                 push    ecx             ; int
.text:000015C0                 call    ??8@YG_NABVUString@@PB_W@Z ; operator==(UString const &,wchar_t const *)
.text:000015C5                 movzx   edx, al
.text:000015C8                 test    edx, edx
.text:000015CA                 jz      short loc_15D2
.text:000015CC
.text:000015CC loc_15CC:                               ; CODE XREF: NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+1C9j
.text:000015CC                 mov     eax, [ebp+var_50]
.text:000015CF                 mov     [ebp+var_4C], eax
.text:000015D2
.text:000015D2 loc_15D2:                               ; CODE XREF: NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+1DEj
.text:000015D2                 jmp     short loc_157D
.text:000015D4 ; ---------------------------------------------------------------------------
.text:000015D4
.text:000015D4 loc_15D4:                               ; CODE XREF: NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+1A5j
.text:000015D4                 cmp     [ebp+var_4C], 0
.text:000015D8                 jl      short loc_1605
.text:000015DA                 lea     ecx, [ebp+var_20]
.text:000015DD                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:000015E2                 sub     eax, 1
.text:000015E5                 cmp     [ebp+var_4C], eax
.text:000015E8                 jnz     short loc_15F7
.text:000015EA                 lea     ecx, [ebp+var_20]
.text:000015ED                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:000015F2                 mov     [ebp+var_48], eax
.text:000015F5                 jmp     short loc_1605
.text:000015F7 ; ---------------------------------------------------------------------------
.text:000015F7
.text:000015F7 loc_15F7:                               ; CODE XREF: NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+1FCj
.text:000015F7                 lea     ecx, [ebp+var_20]
.text:000015FA                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:000015FF                 sub     eax, 1
.text:00001602                 mov     [ebp+var_48], eax
.text:00001605
.text:00001605 loc_1605:                               ; CODE XREF: NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+1ECj
.text:00001605                                         ; NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+209j
.text:00001605                 mov     [ebp+var_58], 0
.text:0000160C                 jmp     short loc_1617
.text:0000160E ; ---------------------------------------------------------------------------
.text:0000160E
.text:0000160E loc_160E:                               ; CODE XREF: NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+27Ej
.text:0000160E                 mov     ecx, [ebp+var_58]
.text:00001611                 add     ecx, 1
.text:00001614                 mov     [ebp+var_58], ecx
.text:00001617
.text:00001617 loc_1617:                               ; CODE XREF: NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+220j
.text:00001617                 mov     edx, [ebp+var_58]
.text:0000161A                 cmp     edx, [ebp+var_48]
.text:0000161D                 jnb     short loc_166C
.text:0000161F                 lea     ecx, [ebp+var_20]
.text:00001622                 call    ?Front@?$CObjectVector@VUString@@@@QAEAAVUString@@XZ ; CObjectVector<UString>::Front(void)
.text:00001627                 mov     [ebp+var_5C], eax
.text:0000162A                 movzx   eax, [ebp+arg_10]
.text:0000162E                 test    eax, eax
.text:00001630                 jz      short loc_164C
.text:00001632                 mov     ecx, [ebp+var_58]
.text:00001635                 cmp     ecx, [ebp+var_44]
.text:00001638                 jb      short loc_164C
.text:0000163A                 mov     edx, [ebp+var_5C]
.text:0000163D                 push    edx             ; struct UString *
.text:0000163E                 call    ?DoesNameContainWildcard@@YG_NABVUString@@@Z ; DoesNameContainWildcard(UString const &)
.text:00001643                 movzx   eax, al
.text:00001646                 test    eax, eax
.text:00001648                 jz      short loc_164C
.text:0000164A                 jmp     short loc_166C
.text:0000164C ; ---------------------------------------------------------------------------
.text:0000164C
.text:0000164C loc_164C:                               ; CODE XREF: NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+244j
.text:0000164C                                         ; NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+24Cj ...
.text:0000164C                 mov     ecx, [ebp+var_5C]
.text:0000164F                 push    ecx
.text:00001650                 lea     ecx, [ebp+var_38]
.text:00001653                 call    ??YUString@@QAEAAV0@ABV0@@Z ; UString::operator+=(UString const &)
.text:00001658                 lea     ecx, [ebp+var_38] ; this
.text:0000165B                 call    ?Add_PathSepar@UString@@QAEXXZ ; UString::Add_PathSepar(void)
.text:00001660                 push    0
.text:00001662                 lea     ecx, [ebp+var_20]
.text:00001665                 call    ?Delete@?$CObjectVector@VUString@@@@QAEXI@Z ; CObjectVector<UString>::Delete(uint)
.text:0000166A                 jmp     short loc_160E
.text:0000166C ; ---------------------------------------------------------------------------
.text:0000166C
.text:0000166C loc_166C:                               ; CODE XREF: NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+11Dj
.text:0000166C                                         ; NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+231j ...
.text:0000166C                 lea     edx, [ebp+var_38]
.text:0000166F                 push    edx             ; struct UString *
.text:00001670                 mov     ecx, [ebp+var_10] ; this
.text:00001673                 call    ?FindPrefix@CCensor@NWildcard@@ABEHABVUString@@@Z ; NWildcard::CCensor::FindPrefix(UString const &)
.text:00001678                 mov     [ebp+var_60], eax
.text:0000167B                 cmp     [ebp+var_60], 0
.text:0000167F                 jge     short loc_16C7
.text:00001681                 lea     eax, [ebp+var_38]
.text:00001684                 push    eax             ; struct UString *
.text:00001685                 lea     ecx, [ebp+var_C0] ; this
.text:0000168B                 call    ??0CPair@NWildcard@@QAE@ABVUString@@@Z ; NWildcard::CPair::CPair(UString const &)
.text:00001690                 mov     [ebp+var_D8], eax
.text:00001696                 mov     ecx, [ebp+var_D8]
.text:0000169C                 mov     [ebp+var_DC], ecx
.text:000016A2                 mov     byte ptr [ebp+var_4], 2
.text:000016A6                 mov     edx, [ebp+var_DC]
.text:000016AC                 push    edx
.text:000016AD                 mov     ecx, [ebp+var_10]
.text:000016B0                 call    ?Add@?$CObjectVector@UCPair@NWildcard@@@@QAEIABUCPair@NWildcard@@@Z ; CObjectVector<NWildcard::CPair>::Add(NWildcard::CPair const &)
.text:000016B5                 mov     [ebp+var_60], eax
.text:000016B8                 mov     byte ptr [ebp+var_4], 1
.text:000016BC                 lea     ecx, [ebp+var_C0] ; this
.text:000016C2                 call    ??1CPair@NWildcard@@QAE@XZ ; NWildcard::CPair::~CPair(void)
.text:000016C7
.text:000016C7 loc_16C7:                               ; CODE XREF: NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+293j
.text:000016C7                 cmp     [ebp+arg_0], 2
.text:000016CB                 jz      short loc_1747
.text:000016CD                 lea     ecx, [ebp+var_20]
.text:000016D0                 call    ?IsEmpty@?$CObjectVector@VUString@@@@QBE_NXZ ; CObjectVector<UString>::IsEmpty(void)
.text:000016D5                 movzx   eax, al
.text:000016D8                 test    eax, eax
.text:000016DA                 jnz     short loc_1701
.text:000016DC                 lea     ecx, [ebp+var_20]
.text:000016DF                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:000016E4                 cmp     eax, 1
.text:000016E7                 jnz     short loc_1747
.text:000016E9                 push    0
.text:000016EB                 lea     ecx, [ebp+var_20]
.text:000016EE                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:000016F3                 mov     ecx, eax        ; this
.text:000016F5                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:000016FA                 movzx   ecx, al
.text:000016FD                 test    ecx, ecx
.text:000016FF                 jz      short loc_1747
.text:00001701
.text:00001701 loc_1701:                               ; CODE XREF: NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+2EEj
.text:00001701                 lea     ecx, [ebp+var_20]
.text:00001704                 call    ?Clear@?$CObjectVector@VUString@@@@QAEXXZ ; CObjectVector<UString>::Clear(void)
.text:00001709                 push    offset $SG67963
.text:0000170E                 lea     ecx, [ebp+var_CC]
.text:00001714                 call    ??0UString@@QAE@PB_W@Z ; UString::UString(wchar_t const *)
.text:00001719                 mov     byte ptr [ebp+var_4], 3
.text:0000171D                 lea     edx, [ebp+var_CC]
.text:00001723                 push    edx
.text:00001724                 lea     ecx, [ebp+var_20]
.text:00001727                 call    ?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z ; CObjectVector<UString>::Add(UString const &)
.text:0000172C                 mov     byte ptr [ebp+var_4], 1
.text:00001730                 lea     ecx, [ebp+var_CC] ; this
.text:00001736                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000173B                 mov     [ebp+var_25], 1
.text:0000173F                 mov     [ebp+arg_10], 1
.text:00001743                 mov     [ebp+arg_C], 0
.text:00001747
.text:00001747 loc_1747:                               ; CODE XREF: NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+2DFj
.text:00001747                                         ; NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+2FBj ...
.text:00001747                 lea     ecx, [ebp+var_74] ; this
.text:0000174A                 call    ??0CItem@NWildcard@@QAE@XZ ; NWildcard::CItem::CItem(void)
.text:0000174F                 mov     byte ptr [ebp+var_4], 4
.text:00001753                 lea     eax, [ebp+var_20]
.text:00001756                 push    eax
.text:00001757                 lea     ecx, [ebp+var_74]
.text:0000175A                 call    ??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z ; CObjectVector<UString>::operator=(CObjectVector<UString> const &)
.text:0000175F                 mov     [ebp+var_66], 1
.text:00001763                 mov     cl, [ebp+var_25]
.text:00001766                 mov     [ebp+var_67], cl
.text:00001769                 mov     dl, [ebp+arg_C]
.text:0000176C                 mov     [ebp+var_68], dl
.text:0000176F                 mov     al, [ebp+arg_10]
.text:00001772                 mov     [ebp+var_65], al
.text:00001775                 mov     ecx, [ebp+var_40]
.text:00001778                 push    ecx             ; int
.text:00001779                 lea     edx, [ebp+var_74]
.text:0000177C                 push    edx             ; struct NWildcard::CItem *
.text:0000177D                 movzx   eax, [ebp+arg_4]
.text:00001781                 push    eax             ; bool
.text:00001782                 mov     ecx, [ebp+var_60]
.text:00001785                 push    ecx
.text:00001786                 mov     ecx, [ebp+var_10]
.text:00001789                 call    ??A?$CObjectVector@UCPair@NWildcard@@@@QAEAAUCPair@NWildcard@@I@Z ; CObjectVector<NWildcard::CPair>::operator[](uint)
.text:0000178E                 add     eax, 0Ch
.text:00001791                 mov     ecx, eax        ; this
.text:00001793                 call    ?AddItem@CCensorNode@NWildcard@@QAEX_NAAUCItem@2@H@Z ; NWildcard::CCensorNode::AddItem(bool,NWildcard::CItem &,int)
.text:00001798                 mov     byte ptr [ebp+var_4], 1
.text:0000179C                 lea     ecx, [ebp+var_74] ; this
.text:0000179F                 call    ??1CItem@NWildcard@@QAE@XZ ; NWildcard::CItem::~CItem(void)
.text:000017A4                 mov     byte ptr [ebp+var_4], 0
.text:000017A8                 lea     ecx, [ebp+var_38] ; this
.text:000017AB                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000017B0                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000017B7                 lea     ecx, [ebp+var_20]
.text:000017BA                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:000017BF                 push    edx
.text:000017C0                 mov     ecx, ebp
.text:000017C2                 push    eax
.text:000017C3                 lea     edx, $LN37
.text:000017C9                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:000017CE                 pop     eax
.text:000017CF                 pop     edx
.text:000017D0                 mov     ecx, [ebp+var_C]
.text:000017D3                 mov     large fs:0, ecx
.text:000017DA                 pop     ecx
.text:000017DB                 pop     edi
.text:000017DC                 add     esp, 0DCh
.text:000017E2                 cmp     ebp, esp
.text:000017E4                 call    __RTC_CheckEsp
.text:000017E9                 mov     esp, ebp
.text:000017EB                 pop     ebp
.text:000017EC                 retn    14h
.text:000017EC ?AddItem@CCensor@NWildcard@@QAEXW4ECensorPathMode@2@_NABVUString@@11@Z endp
.text:000017EC
.text:000017EC ; ---------------------------------------------------------------------------
.text:000017EF                 align 10h
.text:000017F0 $LN37           dd 3                    ; DATA XREF: NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+3D7o
.text:000017F4                 dd offset $LN36
.text:000017F8 $LN36           dd 0FFFFFFE0h, 0Ch      ; DATA XREF: .text:000017F4o
.text:00001800                 dd offset $LN32         ; "pathParts"
.text:00001804                 dd 0FFFFFFC8h, 0Ch
.text:0000180C                 dd offset $LN33         ; "prefix"
.text:00001810                 dd 0FFFFFF8Ch, 10h
.text:00001818                 dd offset $LN34         ; "item"
.text:0000181C $LN34           db 'item',0             ; DATA XREF: .text:00001818o
.text:00001821 $LN33           db 'prefix',0           ; DATA XREF: .text:0000180Co
.text:00001828 $LN32           db 'pathParts',0        ; DATA XREF: .text:00001800o
.text:00001832                 db 0Ah dup(0CCh)
.text:0000183C
.text:0000183C ; =============== S U B R O U T I N E =======================================
.text:0000183C
.text:0000183C ; Attributes: bp-based frame
.text:0000183C
.text:0000183C ; unsigned int __stdcall NWildcard::GetNumPrefixParts(class CObjectVector<class UString>)
.text:0000183C ?GetNumPrefixParts@NWildcard@@YGIV?$CObjectVector@VUString@@@@@Z proc near
.text:0000183C                                         ; CODE XREF: NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+141p
.text:0000183C
.text:0000183C var_40          = dword ptr -40h
.text:0000183C var_3C          = dword ptr -3Ch
.text:0000183C var_38          = dword ptr -38h
.text:0000183C var_34          = dword ptr -34h
.text:0000183C var_30          = dword ptr -30h
.text:0000183C var_2C          = dword ptr -2Ch
.text:0000183C var_28          = dword ptr -28h
.text:0000183C var_24          = dword ptr -24h
.text:0000183C var_20          = dword ptr -20h
.text:0000183C var_1C          = dword ptr -1Ch
.text:0000183C var_18          = dword ptr -18h
.text:0000183C var_14          = dword ptr -14h
.text:0000183C var_10          = dword ptr -10h
.text:0000183C var_C           = dword ptr -0Ch
.text:0000183C var_4           = dword ptr -4
.text:0000183C arg_0           = byte ptr  8
.text:0000183C
.text:0000183C                 push    ebp
.text:0000183D                 mov     ebp, esp
.text:0000183F                 push    0FFFFFFFFh
.text:00001841                 push    offset __ehhandler$?GetNumPrefixParts@NWildcard@@YGIV?$CObjectVector@VUString@@@@@Z
.text:00001846                 mov     eax, large fs:0
.text:0000184C                 push    eax
.text:0000184D                 sub     esp, 34h
.text:00001850                 push    edi
.text:00001851                 lea     edi, [ebp+var_40]
.text:00001854                 mov     ecx, 0Dh
.text:00001859                 mov     eax, 0CCCCCCCCh
.text:0000185E                 rep stosd
.text:00001860                 mov     eax, dword ptr ds:___security_cookie
.text:00001865                 xor     eax, ebp
.text:00001867                 push    eax             ; wchar_t *
.text:00001868                 lea     eax, [ebp+var_C]
.text:0000186B                 mov     large fs:0, eax
.text:00001871                 mov     [ebp+var_4], 0
.text:00001878                 lea     ecx, [ebp+arg_0]
.text:0000187B                 call    ?IsEmpty@?$CObjectVector@VUString@@@@QBE_NXZ ; CObjectVector<UString>::IsEmpty(void)
.text:00001880                 movzx   eax, al
.text:00001883                 test    eax, eax
.text:00001885                 jz      short loc_18A5
.text:00001887                 mov     [ebp+var_14], 0
.text:0000188E                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001895                 lea     ecx, [ebp+arg_0]
.text:00001898                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:0000189D                 mov     eax, [ebp+var_14]
.text:000018A0                 jmp     loc_1AF7
.text:000018A5 ; ---------------------------------------------------------------------------
.text:000018A5
.text:000018A5 loc_18A5:                               ; CODE XREF: NWildcard::GetNumPrefixParts(CObjectVector<UString>)+49j
.text:000018A5                 push    0
.text:000018A7                 lea     ecx, [ebp+arg_0]
.text:000018AA                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:000018AF                 mov     ecx, eax
.text:000018B1                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000018B6                 push    eax             ; this
.text:000018B7                 call    ?IsDriveColonName@NWildcard@@YG_NPB_W@Z ; NWildcard::IsDriveColonName(wchar_t const *)
.text:000018BC                 movzx   ecx, al
.text:000018BF                 test    ecx, ecx
.text:000018C1                 jz      short loc_18E1
.text:000018C3                 mov     [ebp+var_18], 1
.text:000018CA                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000018D1                 lea     ecx, [ebp+arg_0]
.text:000018D4                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:000018D9                 mov     eax, [ebp+var_18]
.text:000018DC                 jmp     loc_1AF7
.text:000018E1 ; ---------------------------------------------------------------------------
.text:000018E1
.text:000018E1 loc_18E1:                               ; CODE XREF: NWildcard::GetNumPrefixParts(CObjectVector<UString>)+85j
.text:000018E1                 push    0
.text:000018E3                 lea     ecx, [ebp+arg_0]
.text:000018E6                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:000018EB                 mov     ecx, eax        ; this
.text:000018ED                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:000018F2                 movzx   edx, al
.text:000018F5                 test    edx, edx
.text:000018F7                 jnz     short loc_1917
.text:000018F9                 mov     [ebp+var_1C], 0
.text:00001900                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001907                 lea     ecx, [ebp+arg_0]
.text:0000190A                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:0000190F                 mov     eax, [ebp+var_1C]
.text:00001912                 jmp     loc_1AF7
.text:00001917 ; ---------------------------------------------------------------------------
.text:00001917
.text:00001917 loc_1917:                               ; CODE XREF: NWildcard::GetNumPrefixParts(CObjectVector<UString>)+BBj
.text:00001917                 lea     ecx, [ebp+arg_0]
.text:0000191A                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:0000191F                 cmp     eax, 1
.text:00001922                 jnz     short loc_1942
.text:00001924                 mov     [ebp+var_20], 1
.text:0000192B                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001932                 lea     ecx, [ebp+arg_0]
.text:00001935                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:0000193A                 mov     eax, [ebp+var_20]
.text:0000193D                 jmp     loc_1AF7
.text:00001942 ; ---------------------------------------------------------------------------
.text:00001942
.text:00001942 loc_1942:                               ; CODE XREF: NWildcard::GetNumPrefixParts(CObjectVector<UString>)+E6j
.text:00001942                 push    1
.text:00001944                 lea     ecx, [ebp+arg_0]
.text:00001947                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:0000194C                 mov     ecx, eax        ; this
.text:0000194E                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:00001953                 movzx   eax, al
.text:00001956                 test    eax, eax
.text:00001958                 jnz     short loc_1978
.text:0000195A                 mov     [ebp+var_24], 1
.text:00001961                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001968                 lea     ecx, [ebp+arg_0]
.text:0000196B                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:00001970                 mov     eax, [ebp+var_24]
.text:00001973                 jmp     loc_1AF7
.text:00001978 ; ---------------------------------------------------------------------------
.text:00001978
.text:00001978 loc_1978:                               ; CODE XREF: NWildcard::GetNumPrefixParts(CObjectVector<UString>)+11Cj
.text:00001978                 lea     ecx, [ebp+arg_0]
.text:0000197B                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:00001980                 cmp     eax, 2
.text:00001983                 jnz     short loc_19A3
.text:00001985                 mov     [ebp+var_28], 2
.text:0000198C                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001993                 lea     ecx, [ebp+arg_0]
.text:00001996                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:0000199B                 mov     eax, [ebp+var_28]
.text:0000199E                 jmp     loc_1AF7
.text:000019A3 ; ---------------------------------------------------------------------------
.text:000019A3
.text:000019A3 loc_19A3:                               ; CODE XREF: NWildcard::GetNumPrefixParts(CObjectVector<UString>)+147j
.text:000019A3                 push    offset $SG67889 ; Str2
.text:000019A8                 push    2
.text:000019AA                 lea     ecx, [ebp+arg_0]
.text:000019AD                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:000019B2                 push    eax             ; int
.text:000019B3                 call    ??8@YG_NABVUString@@PB_W@Z ; operator==(UString const &,wchar_t const *)
.text:000019B8                 movzx   ecx, al
.text:000019BB                 test    ecx, ecx
.text:000019BD                 jz      short loc_19DD
.text:000019BF                 mov     [ebp+var_2C], 3
.text:000019C6                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000019CD                 lea     ecx, [ebp+arg_0]
.text:000019D0                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:000019D5                 mov     eax, [ebp+var_2C]
.text:000019D8                 jmp     loc_1AF7
.text:000019DD ; ---------------------------------------------------------------------------
.text:000019DD
.text:000019DD loc_19DD:                               ; CODE XREF: NWildcard::GetNumPrefixParts(CObjectVector<UString>)+181j
.text:000019DD                 mov     [ebp+var_10], 2
.text:000019E4                 push    offset $SG67893 ; Str2
.text:000019E9                 push    2
.text:000019EB                 lea     ecx, [ebp+arg_0]
.text:000019EE                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:000019F3                 push    eax             ; int
.text:000019F4                 call    ??8@YG_NABVUString@@PB_W@Z ; operator==(UString const &,wchar_t const *)
.text:000019F9                 movzx   edx, al
.text:000019FC                 test    edx, edx
.text:000019FE                 jz      loc_1AAA
.text:00001A04                 lea     ecx, [ebp+arg_0]
.text:00001A07                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:00001A0C                 cmp     eax, 3
.text:00001A0F                 jnz     short loc_1A2F
.text:00001A11                 mov     [ebp+var_30], 3
.text:00001A18                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001A1F                 lea     ecx, [ebp+arg_0]
.text:00001A22                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:00001A27                 mov     eax, [ebp+var_30]
.text:00001A2A                 jmp     loc_1AF7
.text:00001A2F ; ---------------------------------------------------------------------------
.text:00001A2F
.text:00001A2F loc_1A2F:                               ; CODE XREF: NWildcard::GetNumPrefixParts(CObjectVector<UString>)+1D3j
.text:00001A2F                 push    3
.text:00001A31                 lea     ecx, [ebp+arg_0]
.text:00001A34                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00001A39                 mov     ecx, eax
.text:00001A3B                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00001A40                 push    eax             ; this
.text:00001A41                 call    ?IsDriveColonName@NWildcard@@YG_NPB_W@Z ; NWildcard::IsDriveColonName(wchar_t const *)
.text:00001A46                 movzx   eax, al
.text:00001A49                 test    eax, eax
.text:00001A4B                 jz      short loc_1A6B
.text:00001A4D                 mov     [ebp+var_34], 4
.text:00001A54                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001A5B                 lea     ecx, [ebp+arg_0]
.text:00001A5E                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:00001A63                 mov     eax, [ebp+var_34]
.text:00001A66                 jmp     loc_1AF7
.text:00001A6B ; ---------------------------------------------------------------------------
.text:00001A6B
.text:00001A6B loc_1A6B:                               ; CODE XREF: NWildcard::GetNumPrefixParts(CObjectVector<UString>)+20Fj
.text:00001A6B                 push    offset $SG67899 ; "UNC"
.text:00001A70                 push    3
.text:00001A72                 lea     ecx, [ebp+arg_0]
.text:00001A75                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00001A7A                 mov     ecx, eax        ; this
.text:00001A7C                 call    ?IsEqualTo_Ascii_NoCase@UString@@QBE_NPBD@Z ; UString::IsEqualTo_Ascii_NoCase(char const *)
.text:00001A81                 movzx   ecx, al
.text:00001A84                 test    ecx, ecx
.text:00001A86                 jnz     short loc_1AA3
.text:00001A88                 mov     [ebp+var_38], 3
.text:00001A8F                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001A96                 lea     ecx, [ebp+arg_0]
.text:00001A99                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:00001A9E                 mov     eax, [ebp+var_38]
.text:00001AA1                 jmp     short loc_1AF7
.text:00001AA3 ; ---------------------------------------------------------------------------
.text:00001AA3
.text:00001AA3 loc_1AA3:                               ; CODE XREF: NWildcard::GetNumPrefixParts(CObjectVector<UString>)+24Aj
.text:00001AA3                 mov     [ebp+var_10], 4
.text:00001AAA
.text:00001AAA loc_1AAA:                               ; CODE XREF: NWildcard::GetNumPrefixParts(CObjectVector<UString>)+1C2j
.text:00001AAA                 mov     edx, [ebp+var_10]
.text:00001AAD                 add     edx, 1
.text:00001AB0                 mov     [ebp+var_10], edx
.text:00001AB3                 lea     ecx, [ebp+arg_0]
.text:00001AB6                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:00001ABB                 cmp     eax, [ebp+var_10]
.text:00001ABE                 ja      short loc_1ADF
.text:00001AC0                 lea     ecx, [ebp+arg_0]
.text:00001AC3                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:00001AC8                 mov     [ebp+var_3C], eax
.text:00001ACB                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001AD2                 lea     ecx, [ebp+arg_0]
.text:00001AD5                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:00001ADA                 mov     eax, [ebp+var_3C]
.text:00001ADD                 jmp     short loc_1AF7
.text:00001ADF ; ---------------------------------------------------------------------------
.text:00001ADF
.text:00001ADF loc_1ADF:                               ; CODE XREF: NWildcard::GetNumPrefixParts(CObjectVector<UString>)+282j
.text:00001ADF                 mov     eax, [ebp+var_10]
.text:00001AE2                 mov     [ebp+var_40], eax
.text:00001AE5                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001AEC                 lea     ecx, [ebp+arg_0]
.text:00001AEF                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:00001AF4                 mov     eax, [ebp+var_40]
.text:00001AF7
.text:00001AF7 loc_1AF7:                               ; CODE XREF: NWildcard::GetNumPrefixParts(CObjectVector<UString>)+64j
.text:00001AF7                                         ; NWildcard::GetNumPrefixParts(CObjectVector<UString>)+A0j ...
.text:00001AF7                 mov     ecx, [ebp+var_C]
.text:00001AFA                 mov     large fs:0, ecx
.text:00001B01                 pop     ecx
.text:00001B02                 pop     edi
.text:00001B03                 add     esp, 40h
.text:00001B06                 cmp     ebp, esp
.text:00001B08                 call    __RTC_CheckEsp
.text:00001B0D                 mov     esp, ebp
.text:00001B0F                 pop     ebp
.text:00001B10                 retn    0Ch
.text:00001B10 ?GetNumPrefixParts@NWildcard@@YGIV?$CObjectVector@VUString@@@@@Z endp
.text:00001B10
.text:00001B10 ; ---------------------------------------------------------------------------
.text:00001B13                 db 9 dup(0CCh)
.text:00001B1C
.text:00001B1C ; =============== S U B R O U T I N E =======================================
.text:00001B1C
.text:00001B1C ; Attributes: bp-based frame
.text:00001B1C
.text:00001B1C ; void __thiscall NWildcard::CCensor::ExtendExclude(NWildcard::CCensor *__hidden this)
.text:00001B1C                 public ?ExtendExclude@CCensor@NWildcard@@QAEXXZ
.text:00001B1C ?ExtendExclude@CCensor@NWildcard@@QAEXXZ proc near
.text:00001B1C
.text:00001B1C var_C           = dword ptr -0Ch
.text:00001B1C var_8           = dword ptr -8
.text:00001B1C var_4           = dword ptr -4
.text:00001B1C
.text:00001B1C                 push    ebp
.text:00001B1D                 mov     ebp, esp
.text:00001B1F                 sub     esp, 0Ch
.text:00001B22                 mov     [ebp+var_C], 0CCCCCCCCh
.text:00001B29                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00001B30                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001B37                 mov     [ebp+var_4], ecx
.text:00001B3A                 mov     [ebp+var_8], 0
.text:00001B41                 jmp     short loc_1B4C
.text:00001B43 ; ---------------------------------------------------------------------------
.text:00001B43
.text:00001B43 loc_1B43:                               ; CODE XREF: NWildcard::CCensor::ExtendExclude(void):loc_1B75j
.text:00001B43                 mov     eax, [ebp+var_8]
.text:00001B46                 add     eax, 1
.text:00001B49                 mov     [ebp+var_8], eax
.text:00001B4C
.text:00001B4C loc_1B4C:                               ; CODE XREF: NWildcard::CCensor::ExtendExclude(void)+25j
.text:00001B4C                 mov     ecx, [ebp+var_4]
.text:00001B4F                 call    ?Size@?$CObjectVector@UCPair@NWildcard@@@@QBEIXZ ; CObjectVector<NWildcard::CPair>::Size(void)
.text:00001B54                 cmp     [ebp+var_8], eax
.text:00001B57                 jnb     short loc_1B77
.text:00001B59                 mov     ecx, [ebp+var_8]
.text:00001B5C                 push    ecx
.text:00001B5D                 mov     ecx, [ebp+var_4]
.text:00001B60                 call    ??A?$CObjectVector@UCPair@NWildcard@@@@QAEAAUCPair@NWildcard@@I@Z ; CObjectVector<NWildcard::CPair>::operator[](uint)
.text:00001B65                 mov     ecx, eax        ; this
.text:00001B67                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:00001B6C                 movzx   edx, al
.text:00001B6F                 test    edx, edx
.text:00001B71                 jz      short loc_1B75
.text:00001B73                 jmp     short loc_1B77
.text:00001B75 ; ---------------------------------------------------------------------------
.text:00001B75
.text:00001B75 loc_1B75:                               ; CODE XREF: NWildcard::CCensor::ExtendExclude(void)+55j
.text:00001B75                 jmp     short loc_1B43
.text:00001B77 ; ---------------------------------------------------------------------------
.text:00001B77
.text:00001B77 loc_1B77:                               ; CODE XREF: NWildcard::CCensor::ExtendExclude(void)+3Bj
.text:00001B77                                         ; NWildcard::CCensor::ExtendExclude(void)+57j
.text:00001B77                 mov     ecx, [ebp+var_4]
.text:00001B7A                 call    ?Size@?$CObjectVector@UCPair@NWildcard@@@@QBEIXZ ; CObjectVector<NWildcard::CPair>::Size(void)
.text:00001B7F                 cmp     [ebp+var_8], eax
.text:00001B82                 jnz     short loc_1B86
.text:00001B84                 jmp     short loc_1BDB
.text:00001B86 ; ---------------------------------------------------------------------------
.text:00001B86
.text:00001B86 loc_1B86:                               ; CODE XREF: NWildcard::CCensor::ExtendExclude(void)+66j
.text:00001B86                 mov     eax, [ebp+var_8]
.text:00001B89                 mov     [ebp+var_C], eax
.text:00001B8C                 mov     [ebp+var_8], 0
.text:00001B93                 jmp     short loc_1B9E
.text:00001B95 ; ---------------------------------------------------------------------------
.text:00001B95
.text:00001B95 loc_1B95:                               ; CODE XREF: NWildcard::CCensor::ExtendExclude(void):loc_1BD9j
.text:00001B95                 mov     ecx, [ebp+var_8]
.text:00001B98                 add     ecx, 1
.text:00001B9B                 mov     [ebp+var_8], ecx
.text:00001B9E
.text:00001B9E loc_1B9E:                               ; CODE XREF: NWildcard::CCensor::ExtendExclude(void)+77j
.text:00001B9E                 mov     ecx, [ebp+var_4]
.text:00001BA1                 call    ?Size@?$CObjectVector@UCPair@NWildcard@@@@QBEIXZ ; CObjectVector<NWildcard::CPair>::Size(void)
.text:00001BA6                 cmp     [ebp+var_8], eax
.text:00001BA9                 jnb     short loc_1BDB
.text:00001BAB                 mov     edx, [ebp+var_C]
.text:00001BAE                 cmp     edx, [ebp+var_8]
.text:00001BB1                 jz      short loc_1BD9
.text:00001BB3                 mov     eax, [ebp+var_C]
.text:00001BB6                 push    eax
.text:00001BB7                 mov     ecx, [ebp+var_4]
.text:00001BBA                 call    ??A?$CObjectVector@UCPair@NWildcard@@@@QAEAAUCPair@NWildcard@@I@Z ; CObjectVector<NWildcard::CPair>::operator[](uint)
.text:00001BBF                 add     eax, 0Ch
.text:00001BC2                 push    eax             ; struct NWildcard::CCensorNode *
.text:00001BC3                 mov     ecx, [ebp+var_8]
.text:00001BC6                 push    ecx
.text:00001BC7                 mov     ecx, [ebp+var_4]
.text:00001BCA                 call    ??A?$CObjectVector@UCPair@NWildcard@@@@QAEAAUCPair@NWildcard@@I@Z ; CObjectVector<NWildcard::CPair>::operator[](uint)
.text:00001BCF                 add     eax, 0Ch
.text:00001BD2                 mov     ecx, eax        ; this
.text:00001BD4                 call    ?ExtendExclude@CCensorNode@NWildcard@@QAEXABV12@@Z ; NWildcard::CCensorNode::ExtendExclude(NWildcard::CCensorNode const &)
.text:00001BD9
.text:00001BD9 loc_1BD9:                               ; CODE XREF: NWildcard::CCensor::ExtendExclude(void)+95j
.text:00001BD9                 jmp     short loc_1B95
.text:00001BDB ; ---------------------------------------------------------------------------
.text:00001BDB
.text:00001BDB loc_1BDB:                               ; CODE XREF: NWildcard::CCensor::ExtendExclude(void)+68j
.text:00001BDB                                         ; NWildcard::CCensor::ExtendExclude(void)+8Dj
.text:00001BDB                 add     esp, 0Ch
.text:00001BDE                 cmp     ebp, esp
.text:00001BE0                 call    __RTC_CheckEsp
.text:00001BE5                 mov     esp, ebp
.text:00001BE7                 pop     ebp
.text:00001BE8                 retn
.text:00001BE8 ?ExtendExclude@CCensor@NWildcard@@QAEXXZ endp
.text:00001BE8
.text:00001BE8 ; ---------------------------------------------------------------------------
.text:00001BE9                 align 4
.text:00001BEC
.text:00001BEC ; =============== S U B R O U T I N E =======================================
.text:00001BEC
.text:00001BEC ; Attributes: bp-based frame
.text:00001BEC
.text:00001BEC ; public: void __thiscall NWildcard::CCensor::AddPathsToCensor(enum  NWildcard::ECensorPathMode)
.text:00001BEC                 public ?AddPathsToCensor@CCensor@NWildcard@@QAEXW4ECensorPathMode@2@@Z
.text:00001BEC ?AddPathsToCensor@CCensor@NWildcard@@QAEXW4ECensorPathMode@2@@Z proc near
.text:00001BEC
.text:00001BEC var_C           = dword ptr -0Ch
.text:00001BEC var_8           = dword ptr -8
.text:00001BEC var_4           = dword ptr -4
.text:00001BEC arg_0           = dword ptr  8
.text:00001BEC
.text:00001BEC                 push    ebp
.text:00001BED                 mov     ebp, esp
.text:00001BEF                 sub     esp, 0Ch
.text:00001BF2                 mov     [ebp+var_C], 0CCCCCCCCh
.text:00001BF9                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00001C00                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001C07                 mov     [ebp+var_4], ecx
.text:00001C0A                 mov     [ebp+var_8], 0
.text:00001C11                 jmp     short loc_1C1C
.text:00001C13 ; ---------------------------------------------------------------------------
.text:00001C13
.text:00001C13 loc_1C13:                               ; CODE XREF: NWildcard::CCensor::AddPathsToCensor(NWildcard::ECensorPathMode)+7Aj
.text:00001C13                 mov     eax, [ebp+var_8]
.text:00001C16                 add     eax, 1
.text:00001C19                 mov     [ebp+var_8], eax
.text:00001C1C
.text:00001C1C loc_1C1C:                               ; CODE XREF: NWildcard::CCensor::AddPathsToCensor(NWildcard::ECensorPathMode)+25j
.text:00001C1C                 mov     ecx, [ebp+var_4]
.text:00001C1F                 add     ecx, 0Ch
.text:00001C22                 call    ?Size@?$CObjectVector@UCCensorPath@NWildcard@@@@QBEIXZ ; CObjectVector<NWildcard::CCensorPath>::Size(void)
.text:00001C27                 cmp     [ebp+var_8], eax
.text:00001C2A                 jnb     short loc_1C68
.text:00001C2C                 mov     ecx, [ebp+var_8]
.text:00001C2F                 push    ecx
.text:00001C30                 mov     ecx, [ebp+var_4]
.text:00001C33                 add     ecx, 0Ch
.text:00001C36                 call    ??A?$CObjectVector@UCCensorPath@NWildcard@@@@QAEAAUCCensorPath@NWildcard@@I@Z ; CObjectVector<NWildcard::CCensorPath>::operator[](uint)
.text:00001C3B                 mov     [ebp+var_C], eax
.text:00001C3E                 mov     edx, [ebp+var_C]
.text:00001C41                 movzx   eax, byte ptr [edx+0Eh]
.text:00001C45                 push    eax
.text:00001C46                 mov     ecx, [ebp+var_C]
.text:00001C49                 movzx   edx, byte ptr [ecx+0Dh]
.text:00001C4D                 push    edx
.text:00001C4E                 mov     eax, [ebp+var_C]
.text:00001C51                 push    eax
.text:00001C52                 mov     ecx, [ebp+var_C]
.text:00001C55                 movzx   edx, byte ptr [ecx+0Ch]
.text:00001C59                 push    edx
.text:00001C5A                 mov     eax, [ebp+arg_0]
.text:00001C5D                 push    eax
.text:00001C5E                 mov     ecx, [ebp+var_4]
.text:00001C61                 call    ?AddItem@CCensor@NWildcard@@QAEXW4ECensorPathMode@2@_NABVUString@@11@Z ; NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)
.text:00001C66                 jmp     short loc_1C13
.text:00001C68 ; ---------------------------------------------------------------------------
.text:00001C68
.text:00001C68 loc_1C68:                               ; CODE XREF: NWildcard::CCensor::AddPathsToCensor(NWildcard::ECensorPathMode)+3Ej
.text:00001C68                 mov     ecx, [ebp+var_4]
.text:00001C6B                 add     ecx, 0Ch
.text:00001C6E                 call    ?Clear@?$CObjectVector@UCCensorPath@NWildcard@@@@QAEXXZ ; CObjectVector<NWildcard::CCensorPath>::Clear(void)
.text:00001C73                 add     esp, 0Ch
.text:00001C76                 cmp     ebp, esp
.text:00001C78                 call    __RTC_CheckEsp
.text:00001C7D                 mov     esp, ebp
.text:00001C7F                 pop     ebp
.text:00001C80                 retn    4
.text:00001C80 ?AddPathsToCensor@CCensor@NWildcard@@QAEXW4ECensorPathMode@2@@Z endp
.text:00001C80
.text:00001C80 ; ---------------------------------------------------------------------------
.text:00001C83                 db 9 dup(0CCh)
.text:00001C8C
.text:00001C8C ; =============== S U B R O U T I N E =======================================
.text:00001C8C
.text:00001C8C ; Attributes: bp-based frame
.text:00001C8C
.text:00001C8C ; void __thiscall NWildcard::CCensor::AddPreItem(NWildcard::CCensor *this, bool, const struct UString *, bool, bool)
.text:00001C8C                 public ?AddPreItem@CCensor@NWildcard@@QAEX_NABVUString@@00@Z
.text:00001C8C ?AddPreItem@CCensor@NWildcard@@QAEX_NABVUString@@00@Z proc near
.text:00001C8C
.text:00001C8C var_8           = dword ptr -8
.text:00001C8C var_4           = dword ptr -4
.text:00001C8C arg_0           = byte ptr  8
.text:00001C8C arg_4           = dword ptr  0Ch
.text:00001C8C arg_8           = byte ptr  10h
.text:00001C8C arg_C           = byte ptr  14h
.text:00001C8C
.text:00001C8C                 push    ebp
.text:00001C8D                 mov     ebp, esp
.text:00001C8F                 sub     esp, 8
.text:00001C92                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00001C99                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001CA0                 mov     [ebp+var_4], ecx
.text:00001CA3                 mov     ecx, [ebp+var_4]
.text:00001CA6                 add     ecx, 0Ch
.text:00001CA9                 call    ?AddNew@?$CObjectVector@UCCensorPath@NWildcard@@@@QAEAAUCCensorPath@NWildcard@@XZ ; CObjectVector<NWildcard::CCensorPath>::AddNew(void)
.text:00001CAE                 mov     [ebp+var_8], eax
.text:00001CB1                 mov     eax, [ebp+arg_4]
.text:00001CB4                 push    eax
.text:00001CB5                 mov     ecx, [ebp+var_8]
.text:00001CB8                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:00001CBD                 mov     ecx, [ebp+var_8]
.text:00001CC0                 mov     dl, [ebp+arg_0]
.text:00001CC3                 mov     [ecx+0Ch], dl
.text:00001CC6                 mov     eax, [ebp+var_8]
.text:00001CC9                 mov     cl, [ebp+arg_8]
.text:00001CCC                 mov     [eax+0Dh], cl
.text:00001CCF                 mov     edx, [ebp+var_8]
.text:00001CD2                 mov     al, [ebp+arg_C]
.text:00001CD5                 mov     [edx+0Eh], al
.text:00001CD8                 add     esp, 8
.text:00001CDB                 cmp     ebp, esp
.text:00001CDD                 call    __RTC_CheckEsp
.text:00001CE2                 mov     esp, ebp
.text:00001CE4                 pop     ebp
.text:00001CE5                 retn    10h
.text:00001CE5 ?AddPreItem@CCensor@NWildcard@@QAEX_NABVUString@@00@Z endp
.text:00001CE5
.text:00001CE5 _text           ends
.text:00001CE5
.rtc$TMZ:00001CE8 ; ===========================================================================
.rtc$TMZ:00001CE8
.rtc$TMZ:00001CE8 ; Segment type: Pure data
.rtc$TMZ:00001CE8 ; Segment permissions: Read
.rtc$TMZ:00001CE8 _rtc$TMZ        segment dword public 'DATA' use32
.rtc$TMZ:00001CE8                 assume cs:_rtc$TMZ
.rtc$TMZ:00001CE8                 ;org 1CE8h
.rtc$TMZ:00001CE8 ; COMDAT (pick any)
.rtc$TMZ:00001CE8 __RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
.rtc$TMZ:00001CE8 _rtc$TMZ        ends
.rtc$TMZ:00001CE8
.rtc$IMZ:00001CEC ; ===========================================================================
.rtc$IMZ:00001CEC
.rtc$IMZ:00001CEC ; Segment type: Pure data
.rtc$IMZ:00001CEC ; Segment permissions: Read
.rtc$IMZ:00001CEC _rtc$IMZ        segment dword public 'DATA' use32
.rtc$IMZ:00001CEC                 assume cs:_rtc$IMZ
.rtc$IMZ:00001CEC                 ;org 1CECh
.rtc$IMZ:00001CEC ; COMDAT (pick any)
.rtc$IMZ:00001CEC __RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
.rtc$IMZ:00001CEC _rtc$IMZ        ends
.rtc$IMZ:00001CEC
.text$x:00001CF0 ; ===========================================================================
.text$x:00001CF0
.text$x:00001CF0 ; Segment type: Pure code
.text$x:00001CF0 ; Segment permissions: Read/Execute
.text$x:00001CF0 _text$x         segment para public 'CODE' use32
.text$x:00001CF0                 assume cs:_text$x
.text$x:00001CF0                 ;org 1CF0h
.text$x:00001CF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001CF0
.text$x:00001CF0 ; =============== S U B R O U T I N E =======================================
.text$x:00001CF0
.text$x:00001CF0
.text$x:00001CF0 __unwindfunclet$?SplitPathToParts@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z$0 proc near
.text$x:00001CF0                                         ; DATA XREF: .xdata$x:00001E38o
.text$x:00001CF0                 lea     ecx, [ebp-20h]  ; this
.text$x:00001CF3                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00001CF3 __unwindfunclet$?SplitPathToParts@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z$0 endp
.text$x:00001CF3
.text$x:00001CF8
.text$x:00001CF8 ; =============== S U B R O U T I N E =======================================
.text$x:00001CF8
.text$x:00001CF8
.text$x:00001CF8 __ehhandler$?SplitPathToParts@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z proc near
.text$x:00001CF8                                         ; DATA XREF: SplitPathToParts(UString const &,CObjectVector<UString> &)+5o
.text$x:00001CF8
.text$x:00001CF8 arg_4           = dword ptr  8
.text$x:00001CF8
.text$x:00001CF8                 mov     edx, [esp+arg_4]
.text$x:00001CFC                 lea     eax, [edx+0Ch]
.text$x:00001CFF                 mov     ecx, [edx-24h]
.text$x:00001D02                 xor     ecx, eax
.text$x:00001D04                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001D09                 mov     eax, offset __ehfuncinfo$?SplitPathToParts@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z
.text$x:00001D0E                 jmp     ___CxxFrameHandler3
.text$x:00001D0E __ehhandler$?SplitPathToParts@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z endp
.text$x:00001D0E
.text$x:00001D13
.text$x:00001D13 ; =============== S U B R O U T I N E =======================================
.text$x:00001D13
.text$x:00001D13
.text$x:00001D13 __unwindfunclet$?AddItem@CCensorNode@NWildcard@@QAEX_NAAUCItem@2@H@Z$0 proc near
.text$x:00001D13                                         ; DATA XREF: .xdata$x:00001E64o
.text$x:00001D13                 lea     ecx, [ebp-4Ch]  ; this
.text$x:00001D16                 jmp     ??1CCensorNode@NWildcard@@QAE@XZ ; NWildcard::CCensorNode::~CCensorNode(void)
.text$x:00001D16 __unwindfunclet$?AddItem@CCensorNode@NWildcard@@QAEX_NAAUCItem@2@H@Z$0 endp
.text$x:00001D16
.text$x:00001D1B
.text$x:00001D1B ; =============== S U B R O U T I N E =======================================
.text$x:00001D1B
.text$x:00001D1B
.text$x:00001D1B __ehhandler$?AddItem@CCensorNode@NWildcard@@QAEX_NAAUCItem@2@H@Z proc near
.text$x:00001D1B                                         ; DATA XREF: NWildcard::CCensorNode::AddItem(bool,NWildcard::CItem &,int)+5o
.text$x:00001D1B
.text$x:00001D1B arg_4           = dword ptr  8
.text$x:00001D1B
.text$x:00001D1B                 mov     edx, [esp+arg_4]
.text$x:00001D1F                 lea     eax, [edx+0Ch]
.text$x:00001D22                 mov     ecx, [edx-50h]
.text$x:00001D25                 xor     ecx, eax
.text$x:00001D27                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001D2C                 mov     eax, offset __ehfuncinfo$?AddItem@CCensorNode@NWildcard@@QAEX_NAAUCItem@2@H@Z
.text$x:00001D31                 jmp     ___CxxFrameHandler3
.text$x:00001D31 __ehhandler$?AddItem@CCensorNode@NWildcard@@QAEX_NAAUCItem@2@H@Z endp
.text$x:00001D31
.text$x:00001D36
.text$x:00001D36 ; =============== S U B R O U T I N E =======================================
.text$x:00001D36
.text$x:00001D36
.text$x:00001D36 __unwindfunclet$?AddItem@CCensorNode@NWildcard@@QAEX_NABVUString@@0000@Z$0 proc near
.text$x:00001D36                                         ; DATA XREF: .xdata$x:00001E90o
.text$x:00001D36                 lea     ecx, [ebp-24h]  ; this
.text$x:00001D39                 jmp     ??1CItem@NWildcard@@QAE@XZ ; NWildcard::CItem::~CItem(void)
.text$x:00001D39 __unwindfunclet$?AddItem@CCensorNode@NWildcard@@QAEX_NABVUString@@0000@Z$0 endp
.text$x:00001D39
.text$x:00001D3E
.text$x:00001D3E ; =============== S U B R O U T I N E =======================================
.text$x:00001D3E
.text$x:00001D3E
.text$x:00001D3E __ehhandler$?AddItem@CCensorNode@NWildcard@@QAEX_NABVUString@@0000@Z proc near
.text$x:00001D3E                                         ; DATA XREF: NWildcard::CCensorNode::AddItem(bool,UString const &,bool,bool,bool,bool)+5o
.text$x:00001D3E
.text$x:00001D3E arg_4           = dword ptr  8
.text$x:00001D3E
.text$x:00001D3E                 mov     edx, [esp+arg_4]
.text$x:00001D42                 lea     eax, [edx+0Ch]
.text$x:00001D45                 mov     ecx, [edx-20h]
.text$x:00001D48                 xor     ecx, eax
.text$x:00001D4A                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001D4F                 mov     eax, offset __ehfuncinfo$?AddItem@CCensorNode@NWildcard@@QAEX_NABVUString@@0000@Z
.text$x:00001D54                 jmp     ___CxxFrameHandler3
.text$x:00001D54 __ehhandler$?AddItem@CCensorNode@NWildcard@@QAEX_NABVUString@@0000@Z endp
.text$x:00001D54
.text$x:00001D59
.text$x:00001D59 ; =============== S U B R O U T I N E =======================================
.text$x:00001D59
.text$x:00001D59
.text$x:00001D59 __unwindfunclet$?CheckPathVect@CCensorNode@NWildcard@@QBE_NABV?$CObjectVector@VUString@@@@_NAA_N@Z$0 proc near
.text$x:00001D59                                         ; DATA XREF: .xdata$x:00001EBCo
.text$x:00001D59                 lea     ecx, [ebp-28h]
.text$x:00001D5C                 jmp     ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text$x:00001D5C __unwindfunclet$?CheckPathVect@CCensorNode@NWildcard@@QBE_NABV?$CObjectVector@VUString@@@@_NAA_N@Z$0 endp
.text$x:00001D5C
.text$x:00001D61
.text$x:00001D61 ; =============== S U B R O U T I N E =======================================
.text$x:00001D61
.text$x:00001D61
.text$x:00001D61 __ehhandler$?CheckPathVect@CCensorNode@NWildcard@@QBE_NABV?$CObjectVector@VUString@@@@_NAA_N@Z proc near
.text$x:00001D61                                         ; DATA XREF: NWildcard::CCensorNode::CheckPathVect(CObjectVector<UString> const &,bool,bool &)+5o
.text$x:00001D61
.text$x:00001D61 arg_4           = dword ptr  8
.text$x:00001D61
.text$x:00001D61                 mov     edx, [esp+arg_4]
.text$x:00001D65                 lea     eax, [edx+0Ch]
.text$x:00001D68                 mov     ecx, [edx-28h]
.text$x:00001D6B                 xor     ecx, eax
.text$x:00001D6D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001D72                 mov     eax, offset __ehfuncinfo$?CheckPathVect@CCensorNode@NWildcard@@QBE_NABV?$CObjectVector@VUString@@@@_NAA_N@Z
.text$x:00001D77                 jmp     ___CxxFrameHandler3
.text$x:00001D77 __ehhandler$?CheckPathVect@CCensorNode@NWildcard@@QBE_NABV?$CObjectVector@VUString@@@@_NAA_N@Z endp
.text$x:00001D77
.text$x:00001D7C
.text$x:00001D7C ; =============== S U B R O U T I N E =======================================
.text$x:00001D7C
.text$x:00001D7C
.text$x:00001D7C __unwindfunclet$?AddItem2@CCensorNode@NWildcard@@QAEX_NABVUString@@00@Z$0 proc near
.text$x:00001D7C                                         ; DATA XREF: .xdata$x:00001EE8o
.text$x:00001D7C                 lea     ecx, [ebp-24h]  ; this
.text$x:00001D7F                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00001D7F __unwindfunclet$?AddItem2@CCensorNode@NWildcard@@QAEX_NABVUString@@00@Z$0 endp
.text$x:00001D7F
.text$x:00001D84
.text$x:00001D84 ; =============== S U B R O U T I N E =======================================
.text$x:00001D84
.text$x:00001D84
.text$x:00001D84 __ehhandler$?AddItem2@CCensorNode@NWildcard@@QAEX_NABVUString@@00@Z proc near
.text$x:00001D84                                         ; DATA XREF: NWildcard::CCensorNode::AddItem2(bool,UString const &,bool,bool)+5o
.text$x:00001D84
.text$x:00001D84 arg_4           = dword ptr  8
.text$x:00001D84
.text$x:00001D84                 mov     edx, [esp+arg_4]
.text$x:00001D88                 lea     eax, [edx+0Ch]
.text$x:00001D8B                 mov     ecx, [edx-20h]
.text$x:00001D8E                 xor     ecx, eax
.text$x:00001D90                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001D95                 mov     eax, offset __ehfuncinfo$?AddItem2@CCensorNode@NWildcard@@QAEX_NABVUString@@00@Z
.text$x:00001D9A                 jmp     ___CxxFrameHandler3
.text$x:00001D9A __ehhandler$?AddItem2@CCensorNode@NWildcard@@QAEX_NABVUString@@00@Z endp
.text$x:00001D9A
.text$x:00001D9F
.text$x:00001D9F ; =============== S U B R O U T I N E =======================================
.text$x:00001D9F
.text$x:00001D9F
.text$x:00001D9F __unwindfunclet$?ExtendExclude@CCensorNode@NWildcard@@QAEXABV12@@Z$0 proc near
.text$x:00001D9F                                         ; DATA XREF: .xdata$x:00001F14o
.text$x:00001D9F                 lea     ecx, [ebp-50h]  ; this
.text$x:00001DA2                 jmp     ??1CCensorNode@NWildcard@@QAE@XZ ; NWildcard::CCensorNode::~CCensorNode(void)
.text$x:00001DA2 __unwindfunclet$?ExtendExclude@CCensorNode@NWildcard@@QAEXABV12@@Z$0 endp
.text$x:00001DA2
.text$x:00001DA7
.text$x:00001DA7 ; =============== S U B R O U T I N E =======================================
.text$x:00001DA7
.text$x:00001DA7
.text$x:00001DA7 __ehhandler$?ExtendExclude@CCensorNode@NWildcard@@QAEXABV12@@Z proc near
.text$x:00001DA7                                         ; DATA XREF: NWildcard::CCensorNode::ExtendExclude(NWildcard::CCensorNode const &)+5o
.text$x:00001DA7
.text$x:00001DA7 arg_4           = dword ptr  8
.text$x:00001DA7
.text$x:00001DA7                 mov     edx, [esp+arg_4]
.text$x:00001DAB                 lea     eax, [edx+0Ch]
.text$x:00001DAE                 mov     ecx, [edx-54h]
.text$x:00001DB1                 xor     ecx, eax
.text$x:00001DB3                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001DB8                 mov     eax, offset __ehfuncinfo$?ExtendExclude@CCensorNode@NWildcard@@QAEXABV12@@Z
.text$x:00001DBD                 jmp     ___CxxFrameHandler3
.text$x:00001DBD __ehhandler$?ExtendExclude@CCensorNode@NWildcard@@QAEXABV12@@Z endp
.text$x:00001DBD
.text$x:00001DC2
.text$x:00001DC2 ; =============== S U B R O U T I N E =======================================
.text$x:00001DC2
.text$x:00001DC2
.text$x:00001DC2 __unwindfunclet$?AddItem@CCensor@NWildcard@@QAEXW4ECensorPathMode@2@_NABVUString@@11@Z$0 proc near
.text$x:00001DC2                                         ; DATA XREF: .xdata$x:00001F64o
.text$x:00001DC2                 lea     ecx, [ebp-20h]
.text$x:00001DC5                 jmp     ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text$x:00001DC5 __unwindfunclet$?AddItem@CCensor@NWildcard@@QAEXW4ECensorPathMode@2@_NABVUString@@11@Z$0 endp
.text$x:00001DC5
.text$x:00001DCA
.text$x:00001DCA ; =============== S U B R O U T I N E =======================================
.text$x:00001DCA
.text$x:00001DCA
.text$x:00001DCA __unwindfunclet$?AddItem@CCensor@NWildcard@@QAEXW4ECensorPathMode@2@_NABVUString@@11@Z$1 proc near
.text$x:00001DCA                                         ; DATA XREF: .xdata$x:00001F6Co
.text$x:00001DCA                 lea     ecx, [ebp-38h]  ; this
.text$x:00001DCD                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00001DCD __unwindfunclet$?AddItem@CCensor@NWildcard@@QAEXW4ECensorPathMode@2@_NABVUString@@11@Z$1 endp
.text$x:00001DCD
.text$x:00001DD2
.text$x:00001DD2 ; =============== S U B R O U T I N E =======================================
.text$x:00001DD2
.text$x:00001DD2
.text$x:00001DD2 __unwindfunclet$?AddItem@CCensor@NWildcard@@QAEXW4ECensorPathMode@2@_NABVUString@@11@Z$3 proc near
.text$x:00001DD2                                         ; DATA XREF: .xdata$x:00001F74o
.text$x:00001DD2                 lea     ecx, [ebp-0C0h] ; this
.text$x:00001DD8                 jmp     ??1CPair@NWildcard@@QAE@XZ ; NWildcard::CPair::~CPair(void)
.text$x:00001DD8 __unwindfunclet$?AddItem@CCensor@NWildcard@@QAEXW4ECensorPathMode@2@_NABVUString@@11@Z$3 endp
.text$x:00001DD8
.text$x:00001DDD
.text$x:00001DDD ; =============== S U B R O U T I N E =======================================
.text$x:00001DDD
.text$x:00001DDD
.text$x:00001DDD __unwindfunclet$?AddItem@CCensor@NWildcard@@QAEXW4ECensorPathMode@2@_NABVUString@@11@Z$4 proc near
.text$x:00001DDD                                         ; DATA XREF: .xdata$x:00001F7Co
.text$x:00001DDD                 lea     ecx, [ebp-0CCh] ; this
.text$x:00001DE3                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00001DE3 __unwindfunclet$?AddItem@CCensor@NWildcard@@QAEXW4ECensorPathMode@2@_NABVUString@@11@Z$4 endp
.text$x:00001DE3
.text$x:00001DE8
.text$x:00001DE8 ; =============== S U B R O U T I N E =======================================
.text$x:00001DE8
.text$x:00001DE8
.text$x:00001DE8 __unwindfunclet$?AddItem@CCensor@NWildcard@@QAEXW4ECensorPathMode@2@_NABVUString@@11@Z$5 proc near
.text$x:00001DE8                                         ; DATA XREF: .xdata$x:00001F84o
.text$x:00001DE8                 lea     ecx, [ebp-74h]  ; this
.text$x:00001DEB                 jmp     ??1CItem@NWildcard@@QAE@XZ ; NWildcard::CItem::~CItem(void)
.text$x:00001DEB __unwindfunclet$?AddItem@CCensor@NWildcard@@QAEXW4ECensorPathMode@2@_NABVUString@@11@Z$5 endp
.text$x:00001DEB
.text$x:00001DF0
.text$x:00001DF0 ; =============== S U B R O U T I N E =======================================
.text$x:00001DF0
.text$x:00001DF0
.text$x:00001DF0 __ehhandler$?AddItem@CCensor@NWildcard@@QAEXW4ECensorPathMode@2@_NABVUString@@11@Z proc near
.text$x:00001DF0                                         ; DATA XREF: NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+5o
.text$x:00001DF0
.text$x:00001DF0 arg_4           = dword ptr  8
.text$x:00001DF0
.text$x:00001DF0                 mov     edx, [esp+arg_4]
.text$x:00001DF4                 lea     eax, [edx+0Ch]
.text$x:00001DF7                 mov     ecx, [edx-0D8h]
.text$x:00001DFD                 xor     ecx, eax
.text$x:00001DFF                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001E04                 mov     eax, offset __ehfuncinfo$?AddItem@CCensor@NWildcard@@QAEXW4ECensorPathMode@2@_NABVUString@@11@Z
.text$x:00001E09                 jmp     ___CxxFrameHandler3
.text$x:00001E09 __ehhandler$?AddItem@CCensor@NWildcard@@QAEXW4ECensorPathMode@2@_NABVUString@@11@Z endp
.text$x:00001E09
.text$x:00001E0E
.text$x:00001E0E ; =============== S U B R O U T I N E =======================================
.text$x:00001E0E
.text$x:00001E0E
.text$x:00001E0E __unwindfunclet$?GetNumPrefixParts@NWildcard@@YGIV?$CObjectVector@VUString@@@@@Z$0 proc near
.text$x:00001E0E                                         ; DATA XREF: .xdata$x:00001F8Co
.text$x:00001E0E                 lea     ecx, [ebp+8]
.text$x:00001E11                 jmp     ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text$x:00001E11 __unwindfunclet$?GetNumPrefixParts@NWildcard@@YGIV?$CObjectVector@VUString@@@@@Z$0 endp
.text$x:00001E11
.text$x:00001E16
.text$x:00001E16 ; =============== S U B R O U T I N E =======================================
.text$x:00001E16
.text$x:00001E16
.text$x:00001E16 __ehhandler$?GetNumPrefixParts@NWildcard@@YGIV?$CObjectVector@VUString@@@@@Z proc near
.text$x:00001E16                                         ; DATA XREF: NWildcard::GetNumPrefixParts(CObjectVector<UString>)+5o
.text$x:00001E16
.text$x:00001E16 arg_4           = dword ptr  8
.text$x:00001E16
.text$x:00001E16                 mov     edx, [esp+arg_4]
.text$x:00001E1A                 lea     eax, [edx+0Ch]
.text$x:00001E1D                 mov     ecx, [edx-3Ch]
.text$x:00001E20                 xor     ecx, eax
.text$x:00001E22                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001E27                 mov     eax, offset __ehfuncinfo$?GetNumPrefixParts@NWildcard@@YGIV?$CObjectVector@VUString@@@@@Z
.text$x:00001E2C                 jmp     ___CxxFrameHandler3
.text$x:00001E2C __ehhandler$?GetNumPrefixParts@NWildcard@@YGIV?$CObjectVector@VUString@@@@@Z endp
.text$x:00001E2C
.text$x:00001E2C ; ---------------------------------------------------------------------------
.text$x:00001E31                 align 4
.text$x:00001E31 _text$x         ends
.text$x:00001E31
.xdata$x:00001E34 ; ===========================================================================
.xdata$x:00001E34
.xdata$x:00001E34 ; Segment type: Pure data
.xdata$x:00001E34 ; Segment permissions: Read
.xdata$x:00001E34 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001E34                 assume cs:_xdata$x
.xdata$x:00001E34                 ;org 1E34h
.xdata$x:00001E34 __unwindtable$?SplitPathToParts@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z db 0FFh
.xdata$x:00001E34                                         ; DATA XREF: .xdata$x:00001E44o
.xdata$x:00001E35                 db 0FFh
.xdata$x:00001E36                 db 0FFh
.xdata$x:00001E37                 db 0FFh
.xdata$x:00001E38                 dd offset __unwindfunclet$?SplitPathToParts@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z$0
.xdata$x:00001E3C __ehfuncinfo$?SplitPathToParts@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z db  22h ; "
.xdata$x:00001E3C                                         ; DATA XREF: __ehhandler$?SplitPathToParts@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z+11o
.xdata$x:00001E3D                 db    5
.xdata$x:00001E3E                 db  93h ; ô
.xdata$x:00001E3F                 db  19h
.xdata$x:00001E40                 db    1
.xdata$x:00001E41                 db    0
.xdata$x:00001E42                 db    0
.xdata$x:00001E43                 db    0
.xdata$x:00001E44                 dd offset __unwindtable$?SplitPathToParts@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z
.xdata$x:00001E48                 db    0
.xdata$x:00001E49                 db    0
.xdata$x:00001E4A                 db    0
.xdata$x:00001E4B                 db    0
.xdata$x:00001E4C                 db    0
.xdata$x:00001E4D                 db    0
.xdata$x:00001E4E                 db    0
.xdata$x:00001E4F                 db    0
.xdata$x:00001E50                 db    0
.xdata$x:00001E51                 db    0
.xdata$x:00001E52                 db    0
.xdata$x:00001E53                 db    0
.xdata$x:00001E54                 db    0
.xdata$x:00001E55                 db    0
.xdata$x:00001E56                 db    0
.xdata$x:00001E57                 db    0
.xdata$x:00001E58                 db    0
.xdata$x:00001E59                 db    0
.xdata$x:00001E5A                 db    0
.xdata$x:00001E5B                 db    0
.xdata$x:00001E5C                 db    1
.xdata$x:00001E5D                 db    0
.xdata$x:00001E5E                 db    0
.xdata$x:00001E5F                 db    0
.xdata$x:00001E60 __unwindtable$?AddItem@CCensorNode@NWildcard@@QAEX_NAAUCItem@2@H@Z db 0FFh
.xdata$x:00001E60                                         ; DATA XREF: .xdata$x:00001E70o
.xdata$x:00001E61                 db 0FFh
.xdata$x:00001E62                 db 0FFh
.xdata$x:00001E63                 db 0FFh
.xdata$x:00001E64                 dd offset __unwindfunclet$?AddItem@CCensorNode@NWildcard@@QAEX_NAAUCItem@2@H@Z$0
.xdata$x:00001E68 __ehfuncinfo$?AddItem@CCensorNode@NWildcard@@QAEX_NAAUCItem@2@H@Z db  22h ; "
.xdata$x:00001E68                                         ; DATA XREF: __ehhandler$?AddItem@CCensorNode@NWildcard@@QAEX_NAAUCItem@2@H@Z+11o
.xdata$x:00001E69                 db    5
.xdata$x:00001E6A                 db  93h ; ô
.xdata$x:00001E6B                 db  19h
.xdata$x:00001E6C                 db    1
.xdata$x:00001E6D                 db    0
.xdata$x:00001E6E                 db    0
.xdata$x:00001E6F                 db    0
.xdata$x:00001E70                 dd offset __unwindtable$?AddItem@CCensorNode@NWildcard@@QAEX_NAAUCItem@2@H@Z
.xdata$x:00001E74                 db    0
.xdata$x:00001E75                 db    0
.xdata$x:00001E76                 db    0
.xdata$x:00001E77                 db    0
.xdata$x:00001E78                 db    0
.xdata$x:00001E79                 db    0
.xdata$x:00001E7A                 db    0
.xdata$x:00001E7B                 db    0
.xdata$x:00001E7C                 db    0
.xdata$x:00001E7D                 db    0
.xdata$x:00001E7E                 db    0
.xdata$x:00001E7F                 db    0
.xdata$x:00001E80                 db    0
.xdata$x:00001E81                 db    0
.xdata$x:00001E82                 db    0
.xdata$x:00001E83                 db    0
.xdata$x:00001E84                 db    0
.xdata$x:00001E85                 db    0
.xdata$x:00001E86                 db    0
.xdata$x:00001E87                 db    0
.xdata$x:00001E88                 db    1
.xdata$x:00001E89                 db    0
.xdata$x:00001E8A                 db    0
.xdata$x:00001E8B                 db    0
.xdata$x:00001E8C __unwindtable$?AddItem@CCensorNode@NWildcard@@QAEX_NABVUString@@0000@Z db 0FFh
.xdata$x:00001E8C                                         ; DATA XREF: .xdata$x:00001E9Co
.xdata$x:00001E8D                 db 0FFh
.xdata$x:00001E8E                 db 0FFh
.xdata$x:00001E8F                 db 0FFh
.xdata$x:00001E90                 dd offset __unwindfunclet$?AddItem@CCensorNode@NWildcard@@QAEX_NABVUString@@0000@Z$0
.xdata$x:00001E94 __ehfuncinfo$?AddItem@CCensorNode@NWildcard@@QAEX_NABVUString@@0000@Z db  22h ; "
.xdata$x:00001E94                                         ; DATA XREF: __ehhandler$?AddItem@CCensorNode@NWildcard@@QAEX_NABVUString@@0000@Z+11o
.xdata$x:00001E95                 db    5
.xdata$x:00001E96                 db  93h ; ô
.xdata$x:00001E97                 db  19h
.xdata$x:00001E98                 db    1
.xdata$x:00001E99                 db    0
.xdata$x:00001E9A                 db    0
.xdata$x:00001E9B                 db    0
.xdata$x:00001E9C                 dd offset __unwindtable$?AddItem@CCensorNode@NWildcard@@QAEX_NABVUString@@0000@Z
.xdata$x:00001EA0                 db    0
.xdata$x:00001EA1                 db    0
.xdata$x:00001EA2                 db    0
.xdata$x:00001EA3                 db    0
.xdata$x:00001EA4                 db    0
.xdata$x:00001EA5                 db    0
.xdata$x:00001EA6                 db    0
.xdata$x:00001EA7                 db    0
.xdata$x:00001EA8                 db    0
.xdata$x:00001EA9                 db    0
.xdata$x:00001EAA                 db    0
.xdata$x:00001EAB                 db    0
.xdata$x:00001EAC                 db    0
.xdata$x:00001EAD                 db    0
.xdata$x:00001EAE                 db    0
.xdata$x:00001EAF                 db    0
.xdata$x:00001EB0                 db    0
.xdata$x:00001EB1                 db    0
.xdata$x:00001EB2                 db    0
.xdata$x:00001EB3                 db    0
.xdata$x:00001EB4                 db    1
.xdata$x:00001EB5                 db    0
.xdata$x:00001EB6                 db    0
.xdata$x:00001EB7                 db    0
.xdata$x:00001EB8 __unwindtable$?CheckPathVect@CCensorNode@NWildcard@@QBE_NABV?$CObjectVector@VUString@@@@_NAA_N@Z db 0FFh
.xdata$x:00001EB8                                         ; DATA XREF: .xdata$x:00001EC8o
.xdata$x:00001EB9                 db 0FFh
.xdata$x:00001EBA                 db 0FFh
.xdata$x:00001EBB                 db 0FFh
.xdata$x:00001EBC                 dd offset __unwindfunclet$?CheckPathVect@CCensorNode@NWildcard@@QBE_NABV?$CObjectVector@VUString@@@@_NAA_N@Z$0
.xdata$x:00001EC0 __ehfuncinfo$?CheckPathVect@CCensorNode@NWildcard@@QBE_NABV?$CObjectVector@VUString@@@@_NAA_N@Z db  22h ; "
.xdata$x:00001EC0                                         ; DATA XREF: __ehhandler$?CheckPathVect@CCensorNode@NWildcard@@QBE_NABV?$CObjectVector@VUString@@@@_NAA_N@Z+11o
.xdata$x:00001EC1                 db    5
.xdata$x:00001EC2                 db  93h ; ô
.xdata$x:00001EC3                 db  19h
.xdata$x:00001EC4                 db    1
.xdata$x:00001EC5                 db    0
.xdata$x:00001EC6                 db    0
.xdata$x:00001EC7                 db    0
.xdata$x:00001EC8                 dd offset __unwindtable$?CheckPathVect@CCensorNode@NWildcard@@QBE_NABV?$CObjectVector@VUString@@@@_NAA_N@Z
.xdata$x:00001ECC                 align 20h
.xdata$x:00001EE0                 db    1
.xdata$x:00001EE1                 db    0
.xdata$x:00001EE2                 db    0
.xdata$x:00001EE3                 db    0
.xdata$x:00001EE4 __unwindtable$?AddItem2@CCensorNode@NWildcard@@QAEX_NABVUString@@00@Z db 0FFh
.xdata$x:00001EE4                                         ; DATA XREF: .xdata$x:00001EF4o
.xdata$x:00001EE5                 db 0FFh
.xdata$x:00001EE6                 db 0FFh
.xdata$x:00001EE7                 db 0FFh
.xdata$x:00001EE8                 dd offset __unwindfunclet$?AddItem2@CCensorNode@NWildcard@@QAEX_NABVUString@@00@Z$0
.xdata$x:00001EEC __ehfuncinfo$?AddItem2@CCensorNode@NWildcard@@QAEX_NABVUString@@00@Z db  22h ; "
.xdata$x:00001EEC                                         ; DATA XREF: __ehhandler$?AddItem2@CCensorNode@NWildcard@@QAEX_NABVUString@@00@Z+11o
.xdata$x:00001EED                 db    5
.xdata$x:00001EEE                 db  93h ; ô
.xdata$x:00001EEF                 db  19h
.xdata$x:00001EF0                 db    1
.xdata$x:00001EF1                 db    0
.xdata$x:00001EF2                 db    0
.xdata$x:00001EF3                 db    0
.xdata$x:00001EF4                 dd offset __unwindtable$?AddItem2@CCensorNode@NWildcard@@QAEX_NABVUString@@00@Z
.xdata$x:00001EF8                 db    0
.xdata$x:00001EF9                 db    0
.xdata$x:00001EFA                 db    0
.xdata$x:00001EFB                 db    0
.xdata$x:00001EFC                 db    0
.xdata$x:00001EFD                 db    0
.xdata$x:00001EFE                 db    0
.xdata$x:00001EFF                 db    0
.xdata$x:00001F00                 db    0
.xdata$x:00001F01                 db    0
.xdata$x:00001F02                 db    0
.xdata$x:00001F03                 db    0
.xdata$x:00001F04                 db    0
.xdata$x:00001F05                 db    0
.xdata$x:00001F06                 db    0
.xdata$x:00001F07                 db    0
.xdata$x:00001F08                 db    0
.xdata$x:00001F09                 db    0
.xdata$x:00001F0A                 db    0
.xdata$x:00001F0B                 db    0
.xdata$x:00001F0C                 db    1
.xdata$x:00001F0D                 db    0
.xdata$x:00001F0E                 db    0
.xdata$x:00001F0F                 db    0
.xdata$x:00001F10 __unwindtable$?ExtendExclude@CCensorNode@NWildcard@@QAEXABV12@@Z db 0FFh
.xdata$x:00001F10                                         ; DATA XREF: .xdata$x:00001F20o
.xdata$x:00001F11                 db 0FFh
.xdata$x:00001F12                 db 0FFh
.xdata$x:00001F13                 db 0FFh
.xdata$x:00001F14                 dd offset __unwindfunclet$?ExtendExclude@CCensorNode@NWildcard@@QAEXABV12@@Z$0
.xdata$x:00001F18 __ehfuncinfo$?ExtendExclude@CCensorNode@NWildcard@@QAEXABV12@@Z db  22h ; "
.xdata$x:00001F18                                         ; DATA XREF: __ehhandler$?ExtendExclude@CCensorNode@NWildcard@@QAEXABV12@@Z+11o
.xdata$x:00001F19                 db    5
.xdata$x:00001F1A                 db  93h ; ô
.xdata$x:00001F1B                 db  19h
.xdata$x:00001F1C                 db    1
.xdata$x:00001F1D                 db    0
.xdata$x:00001F1E                 db    0
.xdata$x:00001F1F                 db    0
.xdata$x:00001F20                 dd offset __unwindtable$?ExtendExclude@CCensorNode@NWildcard@@QAEXABV12@@Z
.xdata$x:00001F24                 db    0
.xdata$x:00001F25                 db    0
.xdata$x:00001F26                 db    0
.xdata$x:00001F27                 db    0
.xdata$x:00001F28                 db    0
.xdata$x:00001F29                 db    0
.xdata$x:00001F2A                 db    0
.xdata$x:00001F2B                 db    0
.xdata$x:00001F2C                 db    0
.xdata$x:00001F2D                 db    0
.xdata$x:00001F2E                 db    0
.xdata$x:00001F2F                 db    0
.xdata$x:00001F30                 db    0
.xdata$x:00001F31                 db    0
.xdata$x:00001F32                 db    0
.xdata$x:00001F33                 db    0
.xdata$x:00001F34                 db    0
.xdata$x:00001F35                 db    0
.xdata$x:00001F36                 db    0
.xdata$x:00001F37                 db    0
.xdata$x:00001F38                 db    1
.xdata$x:00001F39                 db    0
.xdata$x:00001F3A                 db    0
.xdata$x:00001F3B                 db    0
.xdata$x:00001F3C __ehfuncinfo$?AddItem@CCensor@NWildcard@@QAEXW4ECensorPathMode@2@_NABVUString@@11@Z db  22h ; "
.xdata$x:00001F3C                                         ; DATA XREF: __ehhandler$?AddItem@CCensor@NWildcard@@QAEXW4ECensorPathMode@2@_NABVUString@@11@Z+14o
.xdata$x:00001F3D                 db    5
.xdata$x:00001F3E                 db  93h ; ô
.xdata$x:00001F3F                 db  19h
.xdata$x:00001F40                 db    5
.xdata$x:00001F41                 db    0
.xdata$x:00001F42                 db    0
.xdata$x:00001F43                 db    0
.xdata$x:00001F44                 dd offset __unwindtable$?AddItem@CCensor@NWildcard@@QAEXW4ECensorPathMode@2@_NABVUString@@11@Z
.xdata$x:00001F48                 db    0
.xdata$x:00001F49                 db    0
.xdata$x:00001F4A                 db    0
.xdata$x:00001F4B                 db    0
.xdata$x:00001F4C                 db    0
.xdata$x:00001F4D                 db    0
.xdata$x:00001F4E                 db    0
.xdata$x:00001F4F                 db    0
.xdata$x:00001F50                 db    0
.xdata$x:00001F51                 db    0
.xdata$x:00001F52                 db    0
.xdata$x:00001F53                 db    0
.xdata$x:00001F54                 db    0
.xdata$x:00001F55                 db    0
.xdata$x:00001F56                 db    0
.xdata$x:00001F57                 db    0
.xdata$x:00001F58                 db    0
.xdata$x:00001F59                 db    0
.xdata$x:00001F5A                 db    0
.xdata$x:00001F5B                 db    0
.xdata$x:00001F5C                 db    1
.xdata$x:00001F5D                 db    0
.xdata$x:00001F5E                 db    0
.xdata$x:00001F5F                 db    0
.xdata$x:00001F60 __unwindtable$?AddItem@CCensor@NWildcard@@QAEXW4ECensorPathMode@2@_NABVUString@@11@Z db 0FFh
.xdata$x:00001F60                                         ; DATA XREF: .xdata$x:00001F44o
.xdata$x:00001F61                 db 0FFh
.xdata$x:00001F62                 db 0FFh
.xdata$x:00001F63                 db 0FFh
.xdata$x:00001F64                 dd offset __unwindfunclet$?AddItem@CCensor@NWildcard@@QAEXW4ECensorPathMode@2@_NABVUString@@11@Z$0
.xdata$x:00001F68                 db    0
.xdata$x:00001F69                 db    0
.xdata$x:00001F6A                 db    0
.xdata$x:00001F6B                 db    0
.xdata$x:00001F6C                 dd offset __unwindfunclet$?AddItem@CCensor@NWildcard@@QAEXW4ECensorPathMode@2@_NABVUString@@11@Z$1
.xdata$x:00001F70                 db    1
.xdata$x:00001F71                 db    0
.xdata$x:00001F72                 db    0
.xdata$x:00001F73                 db    0
.xdata$x:00001F74                 dd offset __unwindfunclet$?AddItem@CCensor@NWildcard@@QAEXW4ECensorPathMode@2@_NABVUString@@11@Z$3
.xdata$x:00001F78                 db    1
.xdata$x:00001F79                 db    0
.xdata$x:00001F7A                 db    0
.xdata$x:00001F7B                 db    0
.xdata$x:00001F7C                 dd offset __unwindfunclet$?AddItem@CCensor@NWildcard@@QAEXW4ECensorPathMode@2@_NABVUString@@11@Z$4
.xdata$x:00001F80                 db    1
.xdata$x:00001F81                 db    0
.xdata$x:00001F82                 db    0
.xdata$x:00001F83                 db    0
.xdata$x:00001F84                 dd offset __unwindfunclet$?AddItem@CCensor@NWildcard@@QAEXW4ECensorPathMode@2@_NABVUString@@11@Z$5
.xdata$x:00001F88 __unwindtable$?GetNumPrefixParts@NWildcard@@YGIV?$CObjectVector@VUString@@@@@Z db 0FFh
.xdata$x:00001F88                                         ; DATA XREF: .xdata$x:00001F98o
.xdata$x:00001F89                 db 0FFh
.xdata$x:00001F8A                 db 0FFh
.xdata$x:00001F8B                 db 0FFh
.xdata$x:00001F8C                 dd offset __unwindfunclet$?GetNumPrefixParts@NWildcard@@YGIV?$CObjectVector@VUString@@@@@Z$0
.xdata$x:00001F90 __ehfuncinfo$?GetNumPrefixParts@NWildcard@@YGIV?$CObjectVector@VUString@@@@@Z db  22h ; "
.xdata$x:00001F90                                         ; DATA XREF: __ehhandler$?GetNumPrefixParts@NWildcard@@YGIV?$CObjectVector@VUString@@@@@Z+11o
.xdata$x:00001F91                 db    5
.xdata$x:00001F92                 db  93h ; ô
.xdata$x:00001F93                 db  19h
.xdata$x:00001F94                 db    1
.xdata$x:00001F95                 db    0
.xdata$x:00001F96                 db    0
.xdata$x:00001F97                 db    0
.xdata$x:00001F98                 dd offset __unwindtable$?GetNumPrefixParts@NWildcard@@YGIV?$CObjectVector@VUString@@@@@Z
.xdata$x:00001F9C                 db    0
.xdata$x:00001F9D                 db    0
.xdata$x:00001F9E                 db    0
.xdata$x:00001F9F                 db    0
.xdata$x:00001FA0                 db    0
.xdata$x:00001FA1                 db    0
.xdata$x:00001FA2                 db    0
.xdata$x:00001FA3                 db    0
.xdata$x:00001FA4                 db    0
.xdata$x:00001FA5                 db    0
.xdata$x:00001FA6                 db    0
.xdata$x:00001FA7                 db    0
.xdata$x:00001FA8                 db    0
.xdata$x:00001FA9                 db    0
.xdata$x:00001FAA                 db    0
.xdata$x:00001FAB                 db    0
.xdata$x:00001FAC                 db    0
.xdata$x:00001FAD                 db    0
.xdata$x:00001FAE                 db    0
.xdata$x:00001FAF                 db    0
.xdata$x:00001FB0                 db    1
.xdata$x:00001FB1                 db    0
.xdata$x:00001FB2                 db    0
.xdata$x:00001FB3                 db    0
.xdata$x:00001FB3 _xdata$x        ends
.xdata$x:00001FB3
.text:00001FB4 ; ===========================================================================
.text:00001FB4
.text:00001FB4 ; Segment type: Pure code
.text:00001FB4 ; Segment permissions: Read/Execute
.text:00001FB4 _text           segment para public 'CODE' use32
.text:00001FB4                 assume cs:_text
.text:00001FB4                 ;org 1FB4h
.text:00001FB4 ; COMDAT (pick any)
.text:00001FB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001FB4
.text:00001FB4 ; =============== S U B R O U T I N E =======================================
.text:00001FB4
.text:00001FB4 ; Attributes: bp-based frame
.text:00001FB4
.text:00001FB4 ; bool __stdcall IsPathSepar(wchar_t)
.text:00001FB4                 public ?IsPathSepar@@YG_N_W@Z
.text:00001FB4 ?IsPathSepar@@YG_N_W@Z proc near        ; CODE XREF: SplitPathToParts(UString const &,CObjectVector<UString> &)+A0p
.text:00001FB4                                         ; SplitPathToParts_2(UString const &,UString &,UString &)+4Bp ...
.text:00001FB4
.text:00001FB4 var_4           = dword ptr -4
.text:00001FB4 arg_0           = word ptr  8
.text:00001FB4
.text:00001FB4                 push    ebp
.text:00001FB5                 mov     ebp, esp
.text:00001FB7                 push    ecx
.text:00001FB8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001FBF                 movzx   eax, [ebp+arg_0]
.text:00001FC3                 cmp     eax, 5Ch ; '\'
.text:00001FC6                 jz      short loc_1FDA
.text:00001FC8                 movzx   ecx, [ebp+arg_0]
.text:00001FCC                 cmp     ecx, 2Fh ; '/'
.text:00001FCF                 jz      short loc_1FDA
.text:00001FD1                 mov     [ebp+var_4], 0
.text:00001FD8                 jmp     short loc_1FE1
.text:00001FDA ; ---------------------------------------------------------------------------
.text:00001FDA
.text:00001FDA loc_1FDA:                               ; CODE XREF: IsPathSepar(wchar_t)+12j
.text:00001FDA                                         ; IsPathSepar(wchar_t)+1Bj
.text:00001FDA                 mov     [ebp+var_4], 1
.text:00001FE1
.text:00001FE1 loc_1FE1:                               ; CODE XREF: IsPathSepar(wchar_t)+24j
.text:00001FE1                 mov     al, byte ptr [ebp+var_4]
.text:00001FE4                 mov     esp, ebp
.text:00001FE6                 pop     ebp
.text:00001FE7                 retn    4
.text:00001FE7 ?IsPathSepar@@YG_N_W@Z endp
.text:00001FE7
.text:00001FE7 ; ---------------------------------------------------------------------------
.text:00001FEA                 align 4
.text:00001FEA _text           ends
.text:00001FEA
.text:00001FEC ; ===========================================================================
.text:00001FEC
.text:00001FEC ; Segment type: Pure code
.text:00001FEC ; Segment permissions: Read/Execute
.text:00001FEC _text           segment para public 'CODE' use32
.text:00001FEC                 assume cs:_text
.text:00001FEC                 ;org 1FECh
.text:00001FEC ; COMDAT (pick any)
.text:00001FEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001FEC
.text:00001FEC ; =============== S U B R O U T I N E =======================================
.text:00001FEC
.text:00001FEC ; Attributes: bp-based frame
.text:00001FEC
.text:00001FEC ; _DWORD __thiscall UString::~UString(UString *__hidden this)
.text:00001FEC                 public ??1UString@@QAE@XZ
.text:00001FEC ??1UString@@QAE@XZ proc near            ; CODE XREF: SplitPathToParts(UString const &,CObjectVector<UString> &)+111p
.text:00001FEC                                         ; NWildcard::CCensorNode::AddItem2(bool,UString const &,bool,bool)+C1p ...
.text:00001FEC
.text:00001FEC var_8           = dword ptr -8
.text:00001FEC var_4           = dword ptr -4
.text:00001FEC
.text:00001FEC                 push    ebp
.text:00001FED                 mov     ebp, esp
.text:00001FEF                 sub     esp, 8
.text:00001FF2                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00001FF9                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002000                 mov     [ebp+var_4], ecx
.text:00002003                 mov     eax, [ebp+var_4]
.text:00002006                 mov     ecx, [eax]
.text:00002008                 mov     [ebp+var_8], ecx
.text:0000200B                 mov     edx, [ebp+var_8]
.text:0000200E                 push    edx             ; void *
.text:0000200F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00002014                 add     esp, 4
.text:00002017                 add     esp, 8
.text:0000201A                 cmp     ebp, esp
.text:0000201C                 call    __RTC_CheckEsp
.text:00002021                 mov     esp, ebp
.text:00002023                 pop     ebp
.text:00002024                 retn
.text:00002024 ??1UString@@QAE@XZ endp
.text:00002024
.text:00002024 ; ---------------------------------------------------------------------------
.text:00002025                 align 4
.text:00002025 _text           ends
.text:00002025
.text:00002028 ; ===========================================================================
.text:00002028
.text:00002028 ; Segment type: Pure code
.text:00002028 ; Segment permissions: Read/Execute
.text:00002028 _text           segment para public 'CODE' use32
.text:00002028                 assume cs:_text
.text:00002028                 ;org 2028h
.text:00002028 ; COMDAT (pick any)
.text:00002028                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002028
.text:00002028 ; =============== S U B R O U T I N E =======================================
.text:00002028
.text:00002028 ; Attributes: bp-based frame
.text:00002028
.text:00002028 ; unsigned int __thiscall UString::Len(UString *__hidden this)
.text:00002028                 public ?Len@UString@@QBEIXZ
.text:00002028 ?Len@UString@@QBEIXZ proc near          ; CODE XREF: SplitPathToParts(UString const &,CObjectVector<UString> &)+4Dp
.text:00002028                                         ; SplitPathToParts_2(UString const &,UString &,UString &)+22p ...
.text:00002028
.text:00002028 var_4           = dword ptr -4
.text:00002028
.text:00002028                 push    ebp
.text:00002029                 mov     ebp, esp
.text:0000202B                 push    ecx
.text:0000202C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002033                 mov     [ebp+var_4], ecx
.text:00002036                 mov     eax, [ebp+var_4]
.text:00002039                 mov     eax, [eax+4]
.text:0000203C                 mov     esp, ebp
.text:0000203E                 pop     ebp
.text:0000203F                 retn
.text:0000203F ?Len@UString@@QBEIXZ endp
.text:0000203F
.text:0000203F _text           ends
.text:0000203F
.text:00002040 ; ===========================================================================
.text:00002040
.text:00002040 ; Segment type: Pure code
.text:00002040 ; Segment permissions: Read/Execute
.text:00002040 _text           segment para public 'CODE' use32
.text:00002040                 assume cs:_text
.text:00002040                 ;org 2040h
.text:00002040 ; COMDAT (pick any)
.text:00002040                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002040
.text:00002040 ; =============== S U B R O U T I N E =======================================
.text:00002040
.text:00002040 ; Attributes: bp-based frame
.text:00002040
.text:00002040 ; public: __thiscall UString::operator wchar_t const *(void)const
.text:00002040                 public ??BUString@@QBEPB_WXZ
.text:00002040 ??BUString@@QBEPB_WXZ proc near         ; CODE XREF: SplitPathToParts(UString const &,CObjectVector<UString> &)+93p
.text:00002040                                         ; SplitPathToParts_2(UString const &,UString &,UString &)+17p ...
.text:00002040
.text:00002040 var_4           = dword ptr -4
.text:00002040
.text:00002040                 push    ebp
.text:00002041                 mov     ebp, esp
.text:00002043                 push    ecx
.text:00002044                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000204B                 mov     [ebp+var_4], ecx
.text:0000204E                 mov     eax, [ebp+var_4]
.text:00002051                 mov     eax, [eax]
.text:00002053                 mov     esp, ebp
.text:00002055                 pop     ebp
.text:00002056                 retn
.text:00002056 ??BUString@@QBEPB_WXZ endp
.text:00002056
.text:00002056 ; ---------------------------------------------------------------------------
.text:00002057                 align 4
.text:00002057 _text           ends
.text:00002057
.text:00002058 ; ===========================================================================
.text:00002058
.text:00002058 ; Segment type: Pure code
.text:00002058 ; Segment permissions: Read/Execute
.text:00002058 _text           segment para public 'CODE' use32
.text:00002058                 assume cs:_text
.text:00002058                 ;org 2058h
.text:00002058 ; COMDAT (pick any)
.text:00002058                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002058
.text:00002058 ; =============== S U B R O U T I N E =======================================
.text:00002058
.text:00002058 ; Attributes: bp-based frame
.text:00002058
.text:00002058 ; const wchar_t *__thiscall UString::Ptr(UString *this, unsigned int)
.text:00002058                 public ?Ptr@UString@@QBEPB_WI@Z
.text:00002058 ?Ptr@UString@@QBEPB_WI@Z proc near      ; CODE XREF: SplitPathToParts(UString const &,CObjectVector<UString> &)+BAp
.text:00002058                                         ; SplitPathToParts(UString const &,CObjectVector<UString> &)+EDp
.text:00002058
.text:00002058 var_4           = dword ptr -4
.text:00002058 arg_0           = dword ptr  8
.text:00002058
.text:00002058                 push    ebp
.text:00002059                 mov     ebp, esp
.text:0000205B                 push    ecx
.text:0000205C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002063                 mov     [ebp+var_4], ecx
.text:00002066                 mov     eax, [ebp+var_4]
.text:00002069                 mov     ecx, [eax]
.text:0000206B                 mov     edx, [ebp+arg_0]
.text:0000206E                 lea     eax, [ecx+edx*2]
.text:00002071                 mov     esp, ebp
.text:00002073                 pop     ebp
.text:00002074                 retn    4
.text:00002074 ?Ptr@UString@@QBEPB_WI@Z endp
.text:00002074
.text:00002074 ; ---------------------------------------------------------------------------
.text:00002077                 align 4
.text:00002077 _text           ends
.text:00002077
.text:00002078 ; ===========================================================================
.text:00002078
.text:00002078 ; Segment type: Pure code
.text:00002078 ; Segment permissions: Read/Execute
.text:00002078 _text           segment para public 'CODE' use32
.text:00002078                 assume cs:_text
.text:00002078                 ;org 2078h
.text:00002078 ; COMDAT (pick any)
.text:00002078                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002078
.text:00002078 ; =============== S U B R O U T I N E =======================================
.text:00002078
.text:00002078 ; Attributes: bp-based frame
.text:00002078
.text:00002078 ; public: class UString __thiscall UString::Left(unsigned int)const
.text:00002078                 public ?Left@UString@@QBE?AV1@I@Z
.text:00002078 ?Left@UString@@QBE?AV1@I@Z proc near    ; CODE XREF: ExtractDirPrefixFromPath(UString const &)+79p
.text:00002078
.text:00002078 var_8           = dword ptr -8
.text:00002078 var_4           = dword ptr -4
.text:00002078 arg_0           = dword ptr  8
.text:00002078 arg_4           = dword ptr  0Ch
.text:00002078
.text:00002078                 push    ebp
.text:00002079                 mov     ebp, esp
.text:0000207B                 sub     esp, 8
.text:0000207E                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00002085                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000208C                 mov     [ebp+var_4], ecx
.text:0000208F                 mov     [ebp+var_8], 0
.text:00002096                 mov     eax, [ebp+var_4]
.text:00002099                 push    eax
.text:0000209A                 mov     ecx, [ebp+arg_4]
.text:0000209D                 push    ecx
.text:0000209E                 mov     ecx, [ebp+arg_0]
.text:000020A1                 call    ??0UString@@AAE@IABV0@@Z ; UString::UString(uint,UString const &)
.text:000020A6                 mov     edx, [ebp+var_8]
.text:000020A9                 or      edx, 1
.text:000020AC                 mov     [ebp+var_8], edx
.text:000020AF                 mov     eax, [ebp+arg_0]
.text:000020B2                 add     esp, 8
.text:000020B5                 cmp     ebp, esp
.text:000020B7                 call    __RTC_CheckEsp
.text:000020BC                 mov     esp, ebp
.text:000020BE                 pop     ebp
.text:000020BF                 retn    8
.text:000020BF ?Left@UString@@QBE?AV1@I@Z endp
.text:000020BF
.text:000020BF ; ---------------------------------------------------------------------------
.text:000020C2                 align 4
.text:000020C2 _text           ends
.text:000020C2
.text:000020C4 ; ===========================================================================
.text:000020C4
.text:000020C4 ; Segment type: Pure code
.text:000020C4 ; Segment permissions: Read/Execute
.text:000020C4 _text           segment para public 'CODE' use32
.text:000020C4                 assume cs:_text
.text:000020C4                 ;org 20C4h
.text:000020C4 ; COMDAT (pick any)
.text:000020C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000020C4
.text:000020C4 ; =============== S U B R O U T I N E =======================================
.text:000020C4
.text:000020C4 ; Attributes: bp-based frame
.text:000020C4
.text:000020C4 ; wchar_t __stdcall MyCharUpper(wchar_t)
.text:000020C4                 public ?MyCharUpper@@YG_W_W@Z
.text:000020C4 ?MyCharUpper@@YG_W_W@Z proc near        ; CODE XREF: EnhancedMaskTest(wchar_t const *,wchar_t const *)+A6p
.text:000020C4                                         ; EnhancedMaskTest(wchar_t const *,wchar_t const *)+B3p
.text:000020C4
.text:000020C4 arg_0           = word ptr  8
.text:000020C4
.text:000020C4                 push    ebp
.text:000020C5                 mov     ebp, esp
.text:000020C7                 movzx   eax, [ebp+arg_0]
.text:000020CB                 cmp     eax, 61h ; 'a'
.text:000020CE                 jge     short loc_20D6
.text:000020D0                 mov     ax, [ebp+arg_0]
.text:000020D4                 jmp     short loc_2101
.text:000020D6 ; ---------------------------------------------------------------------------
.text:000020D6
.text:000020D6 loc_20D6:                               ; CODE XREF: MyCharUpper(wchar_t)+Aj
.text:000020D6                 movzx   ecx, [ebp+arg_0]
.text:000020DA                 cmp     ecx, 7Ah ; 'z'
.text:000020DD                 jg      short loc_20E8
.text:000020DF                 movzx   eax, [ebp+arg_0]
.text:000020E3                 sub     eax, 20h ; ' '
.text:000020E6                 jmp     short loc_2101
.text:000020E8 ; ---------------------------------------------------------------------------
.text:000020E8
.text:000020E8 loc_20E8:                               ; CODE XREF: MyCharUpper(wchar_t)+19j
.text:000020E8                 movzx   edx, [ebp+arg_0]
.text:000020EC                 cmp     edx, 7Fh ; ''
.text:000020EF                 jg      short loc_20F7
.text:000020F1                 mov     ax, [ebp+arg_0]
.text:000020F5                 jmp     short loc_2101
.text:000020F7 ; ---------------------------------------------------------------------------
.text:000020F7
.text:000020F7 loc_20F7:                               ; CODE XREF: MyCharUpper(wchar_t)+2Bj
.text:000020F7                 movzx   eax, [ebp+arg_0]
.text:000020FB                 push    eax             ; wchar_t
.text:000020FC                 call    ?MyCharUpper_WIN@@YG_W_W@Z ; MyCharUpper_WIN(wchar_t)
.text:00002101
.text:00002101 loc_2101:                               ; CODE XREF: MyCharUpper(wchar_t)+10j
.text:00002101                                         ; MyCharUpper(wchar_t)+22j ...
.text:00002101                 cmp     ebp, esp
.text:00002103                 call    __RTC_CheckEsp
.text:00002108                 pop     ebp
.text:00002109                 retn    4
.text:00002109 ?MyCharUpper@@YG_W_W@Z endp
.text:00002109
.text:00002109 _text           ends
.text:00002109
.text:0000210C ; ===========================================================================
.text:0000210C
.text:0000210C ; Segment type: Pure code
.text:0000210C ; Segment permissions: Read/Execute
.text:0000210C _text           segment para public 'CODE' use32
.text:0000210C                 assume cs:_text
.text:0000210C                 ;org 210Ch
.text:0000210C ; COMDAT (pick any)
.text:0000210C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000210C
.text:0000210C ; =============== S U B R O U T I N E =======================================
.text:0000210C
.text:0000210C ; Attributes: bp-based frame
.text:0000210C
.text:0000210C ; int __stdcall operator==(int, wchar_t *Str2)
.text:0000210C                 public ??8@YG_NABVUString@@PB_W@Z
.text:0000210C ??8@YG_NABVUString@@PB_W@Z proc near    ; CODE XREF: NWildcard::CItem::AreAllAllowed(void)+53p
.text:0000210C                                         ; NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+106p ...
.text:0000210C
.text:0000210C arg_0           = dword ptr  8
.text:0000210C Str2            = dword ptr  0Ch
.text:0000210C
.text:0000210C                 push    ebp
.text:0000210D                 mov     ebp, esp
.text:0000210F                 push    esi
.text:00002110                 mov     esi, esp
.text:00002112                 mov     eax, [ebp+Str2]
.text:00002115                 push    eax             ; Str2
.text:00002116                 mov     ecx, [ebp+arg_0]
.text:00002119                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:0000211E                 push    eax             ; Str1
.text:0000211F                 call    dword ptr ds:__imp__wcscmp
.text:00002125                 add     esp, 8
.text:00002128                 cmp     esi, esp
.text:0000212A                 call    __RTC_CheckEsp
.text:0000212F                 neg     eax
.text:00002131                 sbb     eax, eax
.text:00002133                 add     eax, 1
.text:00002136                 pop     esi
.text:00002137                 cmp     ebp, esp
.text:00002139                 call    __RTC_CheckEsp
.text:0000213E                 pop     ebp
.text:0000213F                 retn    8
.text:0000213F ??8@YG_NABVUString@@PB_W@Z endp
.text:0000213F
.text:0000213F ; ---------------------------------------------------------------------------
.text:00002142                 align 4
.text:00002142 _text           ends
.text:00002142
.text:00002144 ; ===========================================================================
.text:00002144
.text:00002144 ; Segment type: Pure code
.text:00002144 ; Segment permissions: Read/Execute
.text:00002144 _text           segment para public 'CODE' use32
.text:00002144                 assume cs:_text
.text:00002144                 ;org 2144h
.text:00002144 ; COMDAT (pick any)
.text:00002144                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002144
.text:00002144 ; =============== S U B R O U T I N E =======================================
.text:00002144
.text:00002144 ; Attributes: bp-based frame
.text:00002144
.text:00002144 ; bool __thiscall UString::IsEmpty(UString *__hidden this)
.text:00002144                 public ?IsEmpty@UString@@QBE_NXZ
.text:00002144 ?IsEmpty@UString@@QBE_NXZ proc near     ; CODE XREF: NWildcard::CCensorNode::AreAllAllowed(void)+14p
.text:00002144                                         ; NWildcard::CCensorNode::AddItem2(bool,UString const &,bool,bool)+45p ...
.text:00002144
.text:00002144 var_4           = dword ptr -4
.text:00002144
.text:00002144                 push    ebp
.text:00002145                 mov     ebp, esp
.text:00002147                 push    ecx
.text:00002148                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000214F                 mov     [ebp+var_4], ecx
.text:00002152                 mov     eax, [ebp+var_4]
.text:00002155                 xor     ecx, ecx
.text:00002157                 cmp     dword ptr [eax+4], 0
.text:0000215B                 setz    cl
.text:0000215E                 mov     al, cl
.text:00002160                 mov     esp, ebp
.text:00002162                 pop     ebp
.text:00002163                 retn
.text:00002163 ?IsEmpty@UString@@QBE_NXZ endp
.text:00002163
.text:00002163 _text           ends
.text:00002163
.text:00002164 ; ===========================================================================
.text:00002164
.text:00002164 ; Segment type: Pure code
.text:00002164 ; Segment permissions: Read/Execute
.text:00002164 _text           segment para public 'CODE' use32
.text:00002164                 assume cs:_text
.text:00002164                 ;org 2164h
.text:00002164 ; COMDAT (pick any)
.text:00002164                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002164
.text:00002164 ; =============== S U B R O U T I N E =======================================
.text:00002164
.text:00002164 ; Attributes: bp-based frame
.text:00002164
.text:00002164 ; _DWORD __thiscall NWildcard::CCensorNode::CCensorNode(NWildcard::CCensorNode *this, const struct UString *, struct NWildcard::CCensorNode *)
.text:00002164                 public ??0CCensorNode@NWildcard@@QAE@ABVUString@@PAV01@@Z
.text:00002164 ??0CCensorNode@NWildcard@@QAE@ABVUString@@PAV01@@Z proc near
.text:00002164                                         ; CODE XREF: NWildcard::CCensorNode::AddItem(bool,NWildcard::CItem &,int)+F2p
.text:00002164                                         ; NWildcard::CCensorNode::ExtendExclude(NWildcard::CCensorNode const &)+AAp
.text:00002164
.text:00002164 var_10          = dword ptr -10h
.text:00002164 var_C           = dword ptr -0Ch
.text:00002164 var_4           = dword ptr -4
.text:00002164 arg_0           = dword ptr  8
.text:00002164 arg_4           = dword ptr  0Ch
.text:00002164
.text:00002164                 push    ebp
.text:00002165                 mov     ebp, esp
.text:00002167                 push    0FFFFFFFFh
.text:00002169                 push    offset __ehhandler$??0CCensorNode@NWildcard@@QAE@ABVUString@@PAV01@@Z
.text:0000216E                 mov     eax, large fs:0
.text:00002174                 push    eax
.text:00002175                 push    ecx
.text:00002176                 mov     [ebp+var_10], 0CCCCCCCCh
.text:0000217D                 mov     eax, dword ptr ds:___security_cookie
.text:00002182                 xor     eax, ebp
.text:00002184                 push    eax
.text:00002185                 lea     eax, [ebp+var_C]
.text:00002188                 mov     large fs:0, eax
.text:0000218E                 mov     [ebp+var_10], ecx
.text:00002191                 mov     eax, [ebp+var_10]
.text:00002194                 mov     ecx, [ebp+arg_4]
.text:00002197                 mov     [eax], ecx
.text:00002199                 mov     edx, [ebp+arg_0]
.text:0000219C                 push    edx
.text:0000219D                 mov     ecx, [ebp+var_10]
.text:000021A0                 add     ecx, 4
.text:000021A3                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:000021A8                 mov     [ebp+var_4], 0
.text:000021AF                 mov     ecx, [ebp+var_10]
.text:000021B2                 add     ecx, 10h
.text:000021B5                 call    ??0?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@XZ ; CObjectVector<NWildcard::CCensorNode>::CObjectVector<NWildcard::CCensorNode>(void)
.text:000021BA                 mov     byte ptr [ebp+var_4], 1
.text:000021BE                 mov     ecx, [ebp+var_10]
.text:000021C1                 add     ecx, 1Ch
.text:000021C4                 call    ??0?$CObjectVector@UCItem@NWildcard@@@@QAE@XZ ; CObjectVector<NWildcard::CItem>::CObjectVector<NWildcard::CItem>(void)
.text:000021C9                 mov     byte ptr [ebp+var_4], 2
.text:000021CD                 mov     ecx, [ebp+var_10]
.text:000021D0                 add     ecx, 28h ; '('
.text:000021D3                 call    ??0?$CObjectVector@UCItem@NWildcard@@@@QAE@XZ ; CObjectVector<NWildcard::CItem>::CObjectVector<NWildcard::CItem>(void)
.text:000021D8                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000021DF                 mov     eax, [ebp+var_10]
.text:000021E2                 mov     ecx, [ebp+var_C]
.text:000021E5                 mov     large fs:0, ecx
.text:000021EC                 pop     ecx
.text:000021ED                 add     esp, 10h
.text:000021F0                 cmp     ebp, esp
.text:000021F2                 call    __RTC_CheckEsp
.text:000021F7                 mov     esp, ebp
.text:000021F9                 pop     ebp
.text:000021FA                 retn    8
.text:000021FA ??0CCensorNode@NWildcard@@QAE@ABVUString@@PAV01@@Z endp
.text:000021FA
.text:000021FA ; ---------------------------------------------------------------------------
.text:000021FD                 align 10h
.text:000021FD _text           ends
.text:000021FD
.text$x:00002200 ; ===========================================================================
.text$x:00002200
.text$x:00002200 ; Segment type: Pure code
.text$x:00002200 ; Segment permissions: Read/Execute
.text$x:00002200 _text$x         segment para public 'CODE' use32
.text$x:00002200                 assume cs:_text$x
.text$x:00002200                 ;org 2200h
.text$x:00002200 ; COMDAT (pick associative to section at 2164)
.text$x:00002200                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002200
.text$x:00002200 ; =============== S U B R O U T I N E =======================================
.text$x:00002200
.text$x:00002200
.text$x:00002200 __unwindfunclet$??0CCensorNode@NWildcard@@QAE@ABVUString@@PAV01@@Z$0 proc near
.text$x:00002200                                         ; DATA XREF: .xdata$x:00002240o
.text$x:00002200                 mov     ecx, [ebp-10h]
.text$x:00002203                 add     ecx, 4          ; this
.text$x:00002206                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00002206 __unwindfunclet$??0CCensorNode@NWildcard@@QAE@ABVUString@@PAV01@@Z$0 endp
.text$x:00002206
.text$x:0000220B
.text$x:0000220B ; =============== S U B R O U T I N E =======================================
.text$x:0000220B
.text$x:0000220B
.text$x:0000220B __unwindfunclet$??0CCensorNode@NWildcard@@QAE@ABVUString@@PAV01@@Z$1 proc near
.text$x:0000220B                                         ; DATA XREF: .xdata$x:00002248o
.text$x:0000220B                 mov     ecx, [ebp-10h]
.text$x:0000220E                 add     ecx, 10h
.text$x:00002211                 jmp     ??1?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@XZ ; CObjectVector<NWildcard::CCensorNode>::~CObjectVector<NWildcard::CCensorNode>(void)
.text$x:00002211 __unwindfunclet$??0CCensorNode@NWildcard@@QAE@ABVUString@@PAV01@@Z$1 endp
.text$x:00002211
.text$x:00002216
.text$x:00002216 ; =============== S U B R O U T I N E =======================================
.text$x:00002216
.text$x:00002216
.text$x:00002216 __unwindfunclet$??0CCensorNode@NWildcard@@QAE@ABVUString@@PAV01@@Z$2 proc near
.text$x:00002216                                         ; DATA XREF: .xdata$x:00002250o
.text$x:00002216                 mov     ecx, [ebp-10h]
.text$x:00002219                 add     ecx, 1Ch
.text$x:0000221C                 jmp     ??1?$CObjectVector@UCItem@NWildcard@@@@QAE@XZ ; CObjectVector<NWildcard::CItem>::~CObjectVector<NWildcard::CItem>(void)
.text$x:0000221C __unwindfunclet$??0CCensorNode@NWildcard@@QAE@ABVUString@@PAV01@@Z$2 endp
.text$x:0000221C
.text$x:00002221
.text$x:00002221 ; =============== S U B R O U T I N E =======================================
.text$x:00002221
.text$x:00002221
.text$x:00002221 __ehhandler$??0CCensorNode@NWildcard@@QAE@ABVUString@@PAV01@@Z proc near
.text$x:00002221                                         ; DATA XREF: NWildcard::CCensorNode::CCensorNode(UString const &,NWildcard::CCensorNode *)+5o
.text$x:00002221
.text$x:00002221 arg_4           = dword ptr  8
.text$x:00002221
.text$x:00002221                 mov     edx, [esp+arg_4]
.text$x:00002225                 lea     eax, [edx+0Ch]
.text$x:00002228                 mov     ecx, [edx-8]
.text$x:0000222B                 xor     ecx, eax
.text$x:0000222D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002232                 mov     eax, offset __ehfuncinfo$??0CCensorNode@NWildcard@@QAE@ABVUString@@PAV01@@Z
.text$x:00002237                 jmp     ___CxxFrameHandler3
.text$x:00002237 __ehhandler$??0CCensorNode@NWildcard@@QAE@ABVUString@@PAV01@@Z endp
.text$x:00002237
.text$x:00002237 _text$x         ends
.text$x:00002237
.xdata$x:0000223C ; ===========================================================================
.xdata$x:0000223C
.xdata$x:0000223C ; Segment type: Pure data
.xdata$x:0000223C ; Segment permissions: Read
.xdata$x:0000223C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000223C                 assume cs:_xdata$x
.xdata$x:0000223C                 ;org 223Ch
.xdata$x:0000223C ; COMDAT (pick associative to section at 2164)
.xdata$x:0000223C __unwindtable$??0CCensorNode@NWildcard@@QAE@ABVUString@@PAV01@@Z db 0FFh
.xdata$x:0000223C                                         ; DATA XREF: .xdata$x:0000225Co
.xdata$x:0000223D                 db 0FFh
.xdata$x:0000223E                 db 0FFh
.xdata$x:0000223F                 db 0FFh
.xdata$x:00002240                 dd offset __unwindfunclet$??0CCensorNode@NWildcard@@QAE@ABVUString@@PAV01@@Z$0
.xdata$x:00002244                 align 8
.xdata$x:00002248                 dd offset __unwindfunclet$??0CCensorNode@NWildcard@@QAE@ABVUString@@PAV01@@Z$1
.xdata$x:0000224C                 db    1
.xdata$x:0000224D                 db    0
.xdata$x:0000224E                 db    0
.xdata$x:0000224F                 db    0
.xdata$x:00002250                 dd offset __unwindfunclet$??0CCensorNode@NWildcard@@QAE@ABVUString@@PAV01@@Z$2
.xdata$x:00002254 __ehfuncinfo$??0CCensorNode@NWildcard@@QAE@ABVUString@@PAV01@@Z db  22h ; "
.xdata$x:00002254                                         ; DATA XREF: __ehhandler$??0CCensorNode@NWildcard@@QAE@ABVUString@@PAV01@@Z+11o
.xdata$x:00002255                 db    5
.xdata$x:00002256                 db  93h ; ô
.xdata$x:00002257                 db  19h
.xdata$x:00002258                 db    3
.xdata$x:00002259                 db    0
.xdata$x:0000225A                 db    0
.xdata$x:0000225B                 db    0
.xdata$x:0000225C                 dd offset __unwindtable$??0CCensorNode@NWildcard@@QAE@ABVUString@@PAV01@@Z
.xdata$x:00002260                 db    0
.xdata$x:00002261                 db    0
.xdata$x:00002262                 db    0
.xdata$x:00002263                 db    0
.xdata$x:00002264                 db    0
.xdata$x:00002265                 db    0
.xdata$x:00002266                 db    0
.xdata$x:00002267                 db    0
.xdata$x:00002268                 db    0
.xdata$x:00002269                 db    0
.xdata$x:0000226A                 db    0
.xdata$x:0000226B                 db    0
.xdata$x:0000226C                 db    0
.xdata$x:0000226D                 db    0
.xdata$x:0000226E                 db    0
.xdata$x:0000226F                 db    0
.xdata$x:00002270                 db    0
.xdata$x:00002271                 db    0
.xdata$x:00002272                 db    0
.xdata$x:00002273                 db    0
.xdata$x:00002274                 db    1
.xdata$x:00002275                 db    0
.xdata$x:00002276                 db    0
.xdata$x:00002277                 db    0
.xdata$x:00002277 _xdata$x        ends
.xdata$x:00002277
.text:00002278 ; ===========================================================================
.text:00002278
.text:00002278 ; Segment type: Pure code
.text:00002278 ; Segment permissions: Read/Execute
.text:00002278 _text           segment para public 'CODE' use32
.text:00002278                 assume cs:_text
.text:00002278                 ;org 2278h
.text:00002278 ; COMDAT (pick any)
.text:00002278                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002278
.text:00002278 ; =============== S U B R O U T I N E =======================================
.text:00002278
.text:00002278 ; Attributes: bp-based frame
.text:00002278
.text:00002278 ; _DWORD __thiscall NWildcard::CCensorNode::~CCensorNode(NWildcard::CCensorNode *__hidden this)
.text:00002278                 public ??1CCensorNode@NWildcard@@QAE@XZ
.text:00002278 ??1CCensorNode@NWildcard@@QAE@XZ proc near
.text:00002278                                         ; CODE XREF: NWildcard::CCensorNode::AddItem(bool,NWildcard::CItem &,int)+123p
.text:00002278                                         ; NWildcard::CCensorNode::ExtendExclude(NWildcard::CCensorNode const &)+DBp ...
.text:00002278
.text:00002278 var_10          = dword ptr -10h
.text:00002278 var_C           = dword ptr -0Ch
.text:00002278 var_4           = dword ptr -4
.text:00002278
.text:00002278                 push    ebp
.text:00002279                 mov     ebp, esp
.text:0000227B                 push    0FFFFFFFFh
.text:0000227D                 push    offset __ehhandler$??1CCensorNode@NWildcard@@QAE@XZ
.text:00002282                 mov     eax, large fs:0
.text:00002288                 push    eax
.text:00002289                 push    ecx
.text:0000228A                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00002291                 mov     eax, dword ptr ds:___security_cookie
.text:00002296                 xor     eax, ebp
.text:00002298                 push    eax
.text:00002299                 lea     eax, [ebp+var_C]
.text:0000229C                 mov     large fs:0, eax
.text:000022A2                 mov     [ebp+var_10], ecx
.text:000022A5                 mov     [ebp+var_4], 2
.text:000022AC                 mov     ecx, [ebp+var_10]
.text:000022AF                 add     ecx, 28h ; '('
.text:000022B2                 call    ??1?$CObjectVector@UCItem@NWildcard@@@@QAE@XZ ; CObjectVector<NWildcard::CItem>::~CObjectVector<NWildcard::CItem>(void)
.text:000022B7                 mov     byte ptr [ebp+var_4], 1
.text:000022BB                 mov     ecx, [ebp+var_10]
.text:000022BE                 add     ecx, 1Ch
.text:000022C1                 call    ??1?$CObjectVector@UCItem@NWildcard@@@@QAE@XZ ; CObjectVector<NWildcard::CItem>::~CObjectVector<NWildcard::CItem>(void)
.text:000022C6                 mov     byte ptr [ebp+var_4], 0
.text:000022CA                 mov     ecx, [ebp+var_10]
.text:000022CD                 add     ecx, 10h
.text:000022D0                 call    ??1?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@XZ ; CObjectVector<NWildcard::CCensorNode>::~CObjectVector<NWildcard::CCensorNode>(void)
.text:000022D5                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000022DC                 mov     ecx, [ebp+var_10]
.text:000022DF                 add     ecx, 4          ; this
.text:000022E2                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000022E7                 mov     ecx, [ebp+var_C]
.text:000022EA                 mov     large fs:0, ecx
.text:000022F1                 pop     ecx
.text:000022F2                 add     esp, 10h
.text:000022F5                 cmp     ebp, esp
.text:000022F7                 call    __RTC_CheckEsp
.text:000022FC                 mov     esp, ebp
.text:000022FE                 pop     ebp
.text:000022FF                 retn
.text:000022FF ??1CCensorNode@NWildcard@@QAE@XZ endp
.text:000022FF
.text:000022FF _text           ends
.text:000022FF
.text$x:00002300 ; ===========================================================================
.text$x:00002300
.text$x:00002300 ; Segment type: Pure code
.text$x:00002300 ; Segment permissions: Read/Execute
.text$x:00002300 _text$x         segment para public 'CODE' use32
.text$x:00002300                 assume cs:_text$x
.text$x:00002300                 ;org 2300h
.text$x:00002300 ; COMDAT (pick associative to section at 2278)
.text$x:00002300                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002300
.text$x:00002300 ; =============== S U B R O U T I N E =======================================
.text$x:00002300
.text$x:00002300
.text$x:00002300 __unwindfunclet$??1CCensorNode@NWildcard@@QAE@XZ$0 proc near
.text$x:00002300                                         ; DATA XREF: .xdata$x:00002340o
.text$x:00002300                 mov     ecx, [ebp-10h]
.text$x:00002303                 add     ecx, 4          ; this
.text$x:00002306                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00002306 __unwindfunclet$??1CCensorNode@NWildcard@@QAE@XZ$0 endp
.text$x:00002306
.text$x:0000230B
.text$x:0000230B ; =============== S U B R O U T I N E =======================================
.text$x:0000230B
.text$x:0000230B
.text$x:0000230B __unwindfunclet$??1CCensorNode@NWildcard@@QAE@XZ$1 proc near
.text$x:0000230B                                         ; DATA XREF: .xdata$x:00002348o
.text$x:0000230B                 mov     ecx, [ebp-10h]
.text$x:0000230E                 add     ecx, 10h
.text$x:00002311                 jmp     ??1?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@XZ ; CObjectVector<NWildcard::CCensorNode>::~CObjectVector<NWildcard::CCensorNode>(void)
.text$x:00002311 __unwindfunclet$??1CCensorNode@NWildcard@@QAE@XZ$1 endp
.text$x:00002311
.text$x:00002316
.text$x:00002316 ; =============== S U B R O U T I N E =======================================
.text$x:00002316
.text$x:00002316
.text$x:00002316 __unwindfunclet$??1CCensorNode@NWildcard@@QAE@XZ$2 proc near
.text$x:00002316                                         ; DATA XREF: .xdata$x:00002350o
.text$x:00002316                 mov     ecx, [ebp-10h]
.text$x:00002319                 add     ecx, 1Ch
.text$x:0000231C                 jmp     ??1?$CObjectVector@UCItem@NWildcard@@@@QAE@XZ ; CObjectVector<NWildcard::CItem>::~CObjectVector<NWildcard::CItem>(void)
.text$x:0000231C __unwindfunclet$??1CCensorNode@NWildcard@@QAE@XZ$2 endp
.text$x:0000231C
.text$x:00002321
.text$x:00002321 ; =============== S U B R O U T I N E =======================================
.text$x:00002321
.text$x:00002321
.text$x:00002321 __ehhandler$??1CCensorNode@NWildcard@@QAE@XZ proc near
.text$x:00002321                                         ; DATA XREF: NWildcard::CCensorNode::~CCensorNode(void)+5o
.text$x:00002321
.text$x:00002321 arg_4           = dword ptr  8
.text$x:00002321
.text$x:00002321                 mov     edx, [esp+arg_4]
.text$x:00002325                 lea     eax, [edx+0Ch]
.text$x:00002328                 mov     ecx, [edx-8]
.text$x:0000232B                 xor     ecx, eax
.text$x:0000232D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002332                 mov     eax, offset __ehfuncinfo$??1CCensorNode@NWildcard@@QAE@XZ
.text$x:00002337                 jmp     ___CxxFrameHandler3
.text$x:00002337 __ehhandler$??1CCensorNode@NWildcard@@QAE@XZ endp
.text$x:00002337
.text$x:00002337 _text$x         ends
.text$x:00002337
.xdata$x:0000233C ; ===========================================================================
.xdata$x:0000233C
.xdata$x:0000233C ; Segment type: Pure data
.xdata$x:0000233C ; Segment permissions: Read
.xdata$x:0000233C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000233C                 assume cs:_xdata$x
.xdata$x:0000233C                 ;org 233Ch
.xdata$x:0000233C ; COMDAT (pick associative to section at 2278)
.xdata$x:0000233C __unwindtable$??1CCensorNode@NWildcard@@QAE@XZ db 0FFh
.xdata$x:0000233C                                         ; DATA XREF: .xdata$x:0000235Co
.xdata$x:0000233D                 db 0FFh
.xdata$x:0000233E                 db 0FFh
.xdata$x:0000233F                 db 0FFh
.xdata$x:00002340                 dd offset __unwindfunclet$??1CCensorNode@NWildcard@@QAE@XZ$0
.xdata$x:00002344                 align 8
.xdata$x:00002348                 dd offset __unwindfunclet$??1CCensorNode@NWildcard@@QAE@XZ$1
.xdata$x:0000234C                 db    1
.xdata$x:0000234D                 db    0
.xdata$x:0000234E                 db    0
.xdata$x:0000234F                 db    0
.xdata$x:00002350                 dd offset __unwindfunclet$??1CCensorNode@NWildcard@@QAE@XZ$2
.xdata$x:00002354 __ehfuncinfo$??1CCensorNode@NWildcard@@QAE@XZ db  22h ; "
.xdata$x:00002354                                         ; DATA XREF: __ehhandler$??1CCensorNode@NWildcard@@QAE@XZ+11o
.xdata$x:00002355                 db    5
.xdata$x:00002356                 db  93h ; ô
.xdata$x:00002357                 db  19h
.xdata$x:00002358                 db    3
.xdata$x:00002359                 db    0
.xdata$x:0000235A                 db    0
.xdata$x:0000235B                 db    0
.xdata$x:0000235C                 dd offset __unwindtable$??1CCensorNode@NWildcard@@QAE@XZ
.xdata$x:00002360                 db    0
.xdata$x:00002361                 db    0
.xdata$x:00002362                 db    0
.xdata$x:00002363                 db    0
.xdata$x:00002364                 db    0
.xdata$x:00002365                 db    0
.xdata$x:00002366                 db    0
.xdata$x:00002367                 db    0
.xdata$x:00002368                 db    0
.xdata$x:00002369                 db    0
.xdata$x:0000236A                 db    0
.xdata$x:0000236B                 db    0
.xdata$x:0000236C                 db    0
.xdata$x:0000236D                 db    0
.xdata$x:0000236E                 db    0
.xdata$x:0000236F                 db    0
.xdata$x:00002370                 db    0
.xdata$x:00002371                 db    0
.xdata$x:00002372                 db    0
.xdata$x:00002373                 db    0
.xdata$x:00002374                 db    1
.xdata$x:00002375                 db    0
.xdata$x:00002376                 db    0
.xdata$x:00002377                 db    0
.xdata$x:00002377 _xdata$x        ends
.xdata$x:00002377
.text:00002378 ; ===========================================================================
.text:00002378
.text:00002378 ; Segment type: Pure code
.text:00002378 ; Segment permissions: Read/Execute
.text:00002378 _text           segment para public 'CODE' use32
.text:00002378                 assume cs:_text
.text:00002378                 ;org 2378h
.text:00002378 ; COMDAT (pick any)
.text:00002378                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002378
.text:00002378 ; =============== S U B R O U T I N E =======================================
.text:00002378
.text:00002378 ; Attributes: bp-based frame
.text:00002378
.text:00002378 ; _DWORD __thiscall NWildcard::CItem::CItem(NWildcard::CItem *__hidden this)
.text:00002378                 public ??0CItem@NWildcard@@QAE@XZ
.text:00002378 ??0CItem@NWildcard@@QAE@XZ proc near    ; CODE XREF: NWildcard::CCensorNode::AddItem(bool,UString const &,bool,bool,bool,bool)+45p
.text:00002378                                         ; NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+35Ep
.text:00002378
.text:00002378 var_4           = dword ptr -4
.text:00002378
.text:00002378                 push    ebp
.text:00002379                 mov     ebp, esp
.text:0000237B                 push    ecx
.text:0000237C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002383                 mov     [ebp+var_4], ecx
.text:00002386                 mov     ecx, [ebp+var_4]
.text:00002389                 call    ??0?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::CObjectVector<UString>(void)
.text:0000238E                 mov     eax, [ebp+var_4]
.text:00002391                 add     esp, 4
.text:00002394                 cmp     ebp, esp
.text:00002396                 call    __RTC_CheckEsp
.text:0000239B                 mov     esp, ebp
.text:0000239D                 pop     ebp
.text:0000239E                 retn
.text:0000239E ??0CItem@NWildcard@@QAE@XZ endp
.text:0000239E
.text:0000239E ; ---------------------------------------------------------------------------
.text:0000239F                 align 10h
.text:0000239F _text           ends
.text:0000239F
.text:000023A0 ; ===========================================================================
.text:000023A0
.text:000023A0 ; Segment type: Pure code
.text:000023A0 ; Segment permissions: Read/Execute
.text:000023A0 _text           segment para public 'CODE' use32
.text:000023A0                 assume cs:_text
.text:000023A0                 ;org 23A0h
.text:000023A0 ; COMDAT (pick any)
.text:000023A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000023A0
.text:000023A0 ; =============== S U B R O U T I N E =======================================
.text:000023A0
.text:000023A0 ; Attributes: bp-based frame
.text:000023A0
.text:000023A0 ; _DWORD __thiscall NWildcard::CItem::~CItem(NWildcard::CItem *__hidden this)
.text:000023A0                 public ??1CItem@NWildcard@@QAE@XZ
.text:000023A0 ??1CItem@NWildcard@@QAE@XZ proc near    ; CODE XREF: NWildcard::CCensorNode::AddItem(bool,UString const &,bool,bool,bool,bool)+93p
.text:000023A0                                         ; NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+3B3p ...
.text:000023A0
.text:000023A0 var_4           = dword ptr -4
.text:000023A0
.text:000023A0                 push    ebp
.text:000023A1                 mov     ebp, esp
.text:000023A3                 push    ecx
.text:000023A4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000023AB                 mov     [ebp+var_4], ecx
.text:000023AE                 mov     ecx, [ebp+var_4]
.text:000023B1                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:000023B6                 add     esp, 4
.text:000023B9                 cmp     ebp, esp
.text:000023BB                 call    __RTC_CheckEsp
.text:000023C0                 mov     esp, ebp
.text:000023C2                 pop     ebp
.text:000023C3                 retn
.text:000023C3 ??1CItem@NWildcard@@QAE@XZ endp
.text:000023C3
.text:000023C3 _text           ends
.text:000023C3
.text:000023C4 ; ===========================================================================
.text:000023C4
.text:000023C4 ; Segment type: Pure code
.text:000023C4 ; Segment permissions: Read/Execute
.text:000023C4 _text           segment para public 'CODE' use32
.text:000023C4                 assume cs:_text
.text:000023C4                 ;org 23C4h
.text:000023C4 ; COMDAT (pick any)
.text:000023C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000023C4
.text:000023C4 ; =============== S U B R O U T I N E =======================================
.text:000023C4
.text:000023C4 ; Attributes: bp-based frame
.text:000023C4
.text:000023C4 ; wchar_t __thiscall UString::Back(UString *__hidden this)
.text:000023C4                 public ?Back@UString@@QBE_WXZ
.text:000023C4 ?Back@UString@@QBE_WXZ proc near        ; CODE XREF: NWildcard::CCensorNode::AddItem2(bool,UString const &,bool,bool)+71p
.text:000023C4
.text:000023C4 var_4           = dword ptr -4
.text:000023C4
.text:000023C4                 push    ebp
.text:000023C5                 mov     ebp, esp
.text:000023C7                 push    ecx
.text:000023C8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000023CF                 mov     [ebp+var_4], ecx
.text:000023D2                 mov     eax, [ebp+var_4]
.text:000023D5                 mov     ecx, [eax+4]
.text:000023D8                 mov     edx, [ebp+var_4]
.text:000023DB                 mov     eax, [edx]
.text:000023DD                 mov     ax, [eax+ecx*2-2]
.text:000023E2                 mov     esp, ebp
.text:000023E4                 pop     ebp
.text:000023E5                 retn
.text:000023E5 ?Back@UString@@QBE_WXZ endp
.text:000023E5
.text:000023E5 ; ---------------------------------------------------------------------------
.text:000023E6                 align 4
.text:000023E6 _text           ends
.text:000023E6
.text:000023E8 ; ===========================================================================
.text:000023E8
.text:000023E8 ; Segment type: Pure code
.text:000023E8 ; Segment permissions: Read/Execute
.text:000023E8 _text           segment para public 'CODE' use32
.text:000023E8                 assume cs:_text
.text:000023E8                 ;org 23E8h
.text:000023E8 ; COMDAT (pick any)
.text:000023E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000023E8
.text:000023E8 ; =============== S U B R O U T I N E =======================================
.text:000023E8
.text:000023E8 ; Attributes: bp-based frame
.text:000023E8
.text:000023E8 ; void __thiscall UString::DeleteBack(UString *__hidden this)
.text:000023E8                 public ?DeleteBack@UString@@QAEXXZ
.text:000023E8 ?DeleteBack@UString@@QAEXXZ proc near   ; CODE XREF: NWildcard::CCensorNode::AddItem2(bool,UString const &,bool,bool)+89p
.text:000023E8
.text:000023E8 var_8           = dword ptr -8
.text:000023E8 var_4           = dword ptr -4
.text:000023E8
.text:000023E8                 push    ebp
.text:000023E9                 mov     ebp, esp
.text:000023EB                 sub     esp, 8
.text:000023EE                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000023F5                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000023FC                 mov     [ebp+var_4], ecx
.text:000023FF                 mov     eax, [ebp+var_4]
.text:00002402                 mov     ecx, [eax+4]
.text:00002405                 sub     ecx, 1
.text:00002408                 mov     [ebp+var_8], ecx
.text:0000240B                 mov     edx, [ebp+var_4]
.text:0000240E                 mov     eax, [ebp+var_8]
.text:00002411                 mov     [edx+4], eax
.text:00002414                 mov     ecx, [ebp+var_4]
.text:00002417                 mov     edx, [ecx]
.text:00002419                 xor     eax, eax
.text:0000241B                 mov     ecx, [ebp+var_8]
.text:0000241E                 mov     [edx+ecx*2], ax
.text:00002422                 mov     esp, ebp
.text:00002424                 pop     ebp
.text:00002425                 retn
.text:00002425 ?DeleteBack@UString@@QAEXXZ endp
.text:00002425
.text:00002425 ; ---------------------------------------------------------------------------
.text:00002426                 align 4
.text:00002426 _text           ends
.text:00002426
.text:00002428 ; ===========================================================================
.text:00002428
.text:00002428 ; Segment type: Pure code
.text:00002428 ; Segment permissions: Read/Execute
.text:00002428 _text           segment para public 'CODE' use32
.text:00002428                 assume cs:_text
.text:00002428                 ;org 2428h
.text:00002428 ; COMDAT (pick any)
.text:00002428                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002428
.text:00002428 ; =============== S U B R O U T I N E =======================================
.text:00002428
.text:00002428 ; Attributes: bp-based frame
.text:00002428
.text:00002428 ; int __stdcall operator!=(int, wchar_t *Str2)
.text:00002428                 public ??9@YG_NABVUString@@PB_W@Z
.text:00002428 ??9@YG_NABVUString@@PB_W@Z proc near    ; CODE XREF: NWildcard::GetNumPrefixParts_if_DrivePath(CObjectVector<UString> &)+75p
.text:00002428
.text:00002428 arg_0           = dword ptr  8
.text:00002428 Str2            = dword ptr  0Ch
.text:00002428
.text:00002428                 push    ebp
.text:00002429                 mov     ebp, esp
.text:0000242B                 push    esi
.text:0000242C                 mov     esi, esp
.text:0000242E                 mov     eax, [ebp+Str2]
.text:00002431                 push    eax             ; Str2
.text:00002432                 mov     ecx, [ebp+arg_0]
.text:00002435                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:0000243A                 push    eax             ; Str1
.text:0000243B                 call    dword ptr ds:__imp__wcscmp
.text:00002441                 add     esp, 8
.text:00002444                 cmp     esi, esp
.text:00002446                 call    __RTC_CheckEsp
.text:0000244B                 neg     eax
.text:0000244D                 sbb     eax, eax
.text:0000244F                 neg     eax
.text:00002451                 pop     esi
.text:00002452                 cmp     ebp, esp
.text:00002454                 call    __RTC_CheckEsp
.text:00002459                 pop     ebp
.text:0000245A                 retn    8
.text:0000245A ??9@YG_NABVUString@@PB_W@Z endp
.text:0000245A
.text:0000245A ; ---------------------------------------------------------------------------
.text:0000245D                 align 10h
.text:0000245D _text           ends
.text:0000245D
.xdata$x:00002460 ; ===========================================================================
.xdata$x:00002460
.xdata$x:00002460 ; Segment type: Pure data
.xdata$x:00002460 ; Segment permissions: Read
.xdata$x:00002460 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002460                 assume cs:_xdata$x
.xdata$x:00002460                 ;org 2460h
.xdata$x:00002460 ; COMDAT (pick any)
.xdata$x:00002460                 public __TI2PAD
.xdata$x:00002460 __TI2PAD        db    0                 ; DATA XREF: NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+56o
.xdata$x:00002461                 db    0
.xdata$x:00002462                 db    0
.xdata$x:00002463                 db    0
.xdata$x:00002464                 db    0
.xdata$x:00002465                 db    0
.xdata$x:00002466                 db    0
.xdata$x:00002467                 db    0
.xdata$x:00002468                 db    0
.xdata$x:00002469                 db    0
.xdata$x:0000246A                 db    0
.xdata$x:0000246B                 db    0
.xdata$x:0000246C                 dd offset __CTA2PAD
.xdata$x:0000246C _xdata$x        ends
.xdata$x:0000246C
.xdata$x:00002470 ; ===========================================================================
.xdata$x:00002470
.xdata$x:00002470 ; Segment type: Pure data
.xdata$x:00002470 ; Segment permissions: Read
.xdata$x:00002470 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002470                 assume cs:_xdata$x
.xdata$x:00002470                 ;org 2470h
.xdata$x:00002470 ; COMDAT (pick any)
.xdata$x:00002470                 public __CTA2PAD
.xdata$x:00002470 __CTA2PAD       db    2                 ; DATA XREF: .xdata$x:0000246Co
.xdata$x:00002471                 db    0
.xdata$x:00002472                 db    0
.xdata$x:00002473                 db    0
.xdata$x:00002474                 dd offset __CT??_R0PAD@84
.xdata$x:00002478                 dd offset __CT??_R0PAX@84
.xdata$x:00002478 _xdata$x        ends
.xdata$x:00002478
.xdata$x:0000247C ; ===========================================================================
.xdata$x:0000247C
.xdata$x:0000247C ; Segment type: Pure data
.xdata$x:0000247C ; Segment permissions: Read
.xdata$x:0000247C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000247C                 assume cs:_xdata$x
.xdata$x:0000247C                 ;org 247Ch
.xdata$x:0000247C ; COMDAT (pick any)
.xdata$x:0000247C                 public __CT??_R0PAD@84
.xdata$x:0000247C __CT??_R0PAD@84 db    1                 ; DATA XREF: .xdata$x:00002474o
.xdata$x:0000247D                 db    0
.xdata$x:0000247E                 db    0
.xdata$x:0000247F                 db    0
.xdata$x:00002480                 dd offset ??_R0PAD@8    ; char * `RTTI Type Descriptor'
.xdata$x:00002484                 align 8
.xdata$x:00002488                 db 0FFh
.xdata$x:00002489                 db 0FFh
.xdata$x:0000248A                 db 0FFh
.xdata$x:0000248B                 db 0FFh
.xdata$x:0000248C                 db    0
.xdata$x:0000248D                 db    0
.xdata$x:0000248E                 db    0
.xdata$x:0000248F                 db    0
.xdata$x:00002490                 db    4
.xdata$x:00002491                 db    0
.xdata$x:00002492                 db    0
.xdata$x:00002493                 db    0
.xdata$x:00002494                 db    0
.xdata$x:00002495                 db    0
.xdata$x:00002496                 db    0
.xdata$x:00002497                 db    0
.xdata$x:00002497 _xdata$x        ends
.xdata$x:00002497
.data:00002498 ; ===========================================================================
.data:00002498
.data:00002498 ; Segment type: Pure data
.data:00002498 ; Segment permissions: Read/Write
.data:00002498 _data           segment dword public 'DATA' use32
.data:00002498                 assume cs:_data
.data:00002498                 ;org 2498h
.data:00002498 ; COMDAT (pick any)
.data:00002498                 public ??_R0PAD@8
.data:00002498 ; char * `RTTI Type Descriptor'
.data:00002498 ??_R0PAD@8      dd offset ??_7type_info@@6B@ ; DATA XREF: .xdata$x:00002480o
.data:00002498                                         ; const type_info::`vftable'
.data:0000249C                 align 10h
.data:000024A0 a_pad           db '.PAD',0
.data:000024A5                 align 4
.data:000024A5 _data           ends
.data:000024A5
.xdata$x:000024A8 ; ===========================================================================
.xdata$x:000024A8
.xdata$x:000024A8 ; Segment type: Pure data
.xdata$x:000024A8 ; Segment permissions: Read
.xdata$x:000024A8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000024A8                 assume cs:_xdata$x
.xdata$x:000024A8                 ;org 24A8h
.xdata$x:000024A8 ; COMDAT (pick any)
.xdata$x:000024A8                 public __CT??_R0PAX@84
.xdata$x:000024A8 __CT??_R0PAX@84 db    1                 ; DATA XREF: .xdata$x:00002478o
.xdata$x:000024A9                 db    0
.xdata$x:000024AA                 db    0
.xdata$x:000024AB                 db    0
.xdata$x:000024AC                 dd offset ??_R0PAX@8    ; void * `RTTI Type Descriptor'
.xdata$x:000024B0                 db    0
.xdata$x:000024B1                 db    0
.xdata$x:000024B2                 db    0
.xdata$x:000024B3                 db    0
.xdata$x:000024B4                 db 0FFh
.xdata$x:000024B5                 db 0FFh
.xdata$x:000024B6                 db 0FFh
.xdata$x:000024B7                 db 0FFh
.xdata$x:000024B8                 db    0
.xdata$x:000024B9                 db    0
.xdata$x:000024BA                 db    0
.xdata$x:000024BB                 db    0
.xdata$x:000024BC                 db    4
.xdata$x:000024BD                 db    0
.xdata$x:000024BE                 db    0
.xdata$x:000024BF                 db    0
.xdata$x:000024C0                 db    0
.xdata$x:000024C1                 db    0
.xdata$x:000024C2                 db    0
.xdata$x:000024C3                 db    0
.xdata$x:000024C3 _xdata$x        ends
.xdata$x:000024C3
.data:000024C4 ; ===========================================================================
.data:000024C4
.data:000024C4 ; Segment type: Pure data
.data:000024C4 ; Segment permissions: Read/Write
.data:000024C4 _data           segment dword public 'DATA' use32
.data:000024C4                 assume cs:_data
.data:000024C4                 ;org 24C4h
.data:000024C4 ; COMDAT (pick any)
.data:000024C4                 public ??_R0PAX@8
.data:000024C4 ; void * `RTTI Type Descriptor'
.data:000024C4 ??_R0PAX@8      dd offset ??_7type_info@@6B@ ; DATA XREF: .xdata$x:000024ACo
.data:000024C4                                         ; const type_info::`vftable'
.data:000024C8                 db    0
.data:000024C9                 db    0
.data:000024CA                 db    0
.data:000024CB                 db    0
.data:000024CC                 db  2Eh ; .
.data:000024CD                 db  50h ; P
.data:000024CE                 db  41h ; A
.data:000024CF                 db  58h ; X
.data:000024D0                 db    0
.data:000024D1                 align 4
.data:000024D1 _data           ends
.data:000024D1
.text:000024D4 ; ===========================================================================
.text:000024D4
.text:000024D4 ; Segment type: Pure code
.text:000024D4 ; Segment permissions: Read/Execute
.text:000024D4 _text           segment para public 'CODE' use32
.text:000024D4                 assume cs:_text
.text:000024D4                 ;org 24D4h
.text:000024D4 ; COMDAT (pick any)
.text:000024D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000024D4
.text:000024D4 ; =============== S U B R O U T I N E =======================================
.text:000024D4
.text:000024D4 ; Attributes: bp-based frame
.text:000024D4
.text:000024D4 ; void __thiscall UString::Add_PathSepar(UString *__hidden this)
.text:000024D4                 public ?Add_PathSepar@UString@@QAEXXZ
.text:000024D4 ?Add_PathSepar@UString@@QAEXXZ proc near
.text:000024D4                                         ; CODE XREF: NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+26Fp
.text:000024D4
.text:000024D4 var_4           = dword ptr -4
.text:000024D4
.text:000024D4                 push    ebp
.text:000024D5                 mov     ebp, esp
.text:000024D7                 push    ecx
.text:000024D8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000024DF                 mov     [ebp+var_4], ecx
.text:000024E2                 push    5Ch ; '\'
.text:000024E4                 mov     ecx, [ebp+var_4]
.text:000024E7                 call    ??YUString@@QAEAAV0@_W@Z ; UString::operator+=(wchar_t)
.text:000024EC                 add     esp, 4
.text:000024EF                 cmp     ebp, esp
.text:000024F1                 call    __RTC_CheckEsp
.text:000024F6                 mov     esp, ebp
.text:000024F8                 pop     ebp
.text:000024F9                 retn
.text:000024F9 ?Add_PathSepar@UString@@QAEXXZ endp
.text:000024F9
.text:000024F9 ; ---------------------------------------------------------------------------
.text:000024FA                 align 4
.text:000024FA _text           ends
.text:000024FA
.text:000024FC ; ===========================================================================
.text:000024FC
.text:000024FC ; Segment type: Pure code
.text:000024FC ; Segment permissions: Read/Execute
.text:000024FC _text           segment para public 'CODE' use32
.text:000024FC                 assume cs:_text
.text:000024FC                 ;org 24FCh
.text:000024FC ; COMDAT (pick any)
.text:000024FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000024FC
.text:000024FC ; =============== S U B R O U T I N E =======================================
.text:000024FC
.text:000024FC ; Attributes: bp-based frame
.text:000024FC
.text:000024FC ; public: class UString & __thiscall UString::operator+=(wchar_t)
.text:000024FC                 public ??YUString@@QAEAAV0@_W@Z
.text:000024FC ??YUString@@QAEAAV0@_W@Z proc near      ; CODE XREF: UString::Add_PathSepar(void)+13p
.text:000024FC
.text:000024FC var_C           = dword ptr -0Ch
.text:000024FC var_8           = dword ptr -8
.text:000024FC var_4           = dword ptr -4
.text:000024FC arg_0           = word ptr  8
.text:000024FC
.text:000024FC                 push    ebp
.text:000024FD                 mov     ebp, esp
.text:000024FF                 sub     esp, 0Ch
.text:00002502                 mov     [ebp+var_C], 0CCCCCCCCh
.text:00002509                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00002510                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002517                 mov     [ebp+var_4], ecx
.text:0000251A                 mov     eax, [ebp+var_4]
.text:0000251D                 mov     ecx, [ebp+var_4]
.text:00002520                 mov     edx, [eax+8]
.text:00002523                 cmp     edx, [ecx+4]
.text:00002526                 jnz     short loc_2530
.text:00002528                 mov     ecx, [ebp+var_4] ; this
.text:0000252B                 call    ?Grow_1@UString@@AAEXXZ ; UString::Grow_1(void)
.text:00002530
.text:00002530 loc_2530:                               ; CODE XREF: UString::operator+=(wchar_t)+2Aj
.text:00002530                 mov     eax, [ebp+var_4]
.text:00002533                 mov     ecx, [eax+4]
.text:00002536                 mov     [ebp+var_8], ecx
.text:00002539                 mov     edx, [ebp+var_4]
.text:0000253C                 mov     eax, [edx]
.text:0000253E                 mov     [ebp+var_C], eax
.text:00002541                 mov     ecx, [ebp+var_8]
.text:00002544                 mov     edx, [ebp+var_C]
.text:00002547                 mov     ax, [ebp+arg_0]
.text:0000254B                 mov     [edx+ecx*2], ax
.text:0000254F                 mov     ecx, [ebp+var_8]
.text:00002552                 add     ecx, 1
.text:00002555                 mov     [ebp+var_8], ecx
.text:00002558                 xor     edx, edx
.text:0000255A                 mov     eax, [ebp+var_8]
.text:0000255D                 mov     ecx, [ebp+var_C]
.text:00002560                 mov     [ecx+eax*2], dx
.text:00002564                 mov     edx, [ebp+var_4]
.text:00002567                 mov     eax, [ebp+var_8]
.text:0000256A                 mov     [edx+4], eax
.text:0000256D                 mov     eax, [ebp+var_4]
.text:00002570                 add     esp, 0Ch
.text:00002573                 cmp     ebp, esp
.text:00002575                 call    __RTC_CheckEsp
.text:0000257A                 mov     esp, ebp
.text:0000257C                 pop     ebp
.text:0000257D                 retn    4
.text:0000257D ??YUString@@QAEAAV0@_W@Z endp
.text:0000257D
.text:0000257D _text           ends
.text:0000257D
.text:00002580 ; ===========================================================================
.text:00002580
.text:00002580 ; Segment type: Pure code
.text:00002580 ; Segment permissions: Read/Execute
.text:00002580 _text           segment para public 'CODE' use32
.text:00002580                 assume cs:_text
.text:00002580                 ;org 2580h
.text:00002580 ; COMDAT (pick any)
.text:00002580                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002580
.text:00002580 ; =============== S U B R O U T I N E =======================================
.text:00002580
.text:00002580 ; Attributes: bp-based frame
.text:00002580
.text:00002580 ; _DWORD __thiscall NWildcard::CPair::CPair(NWildcard::CPair *this, const struct UString *)
.text:00002580                 public ??0CPair@NWildcard@@QAE@ABVUString@@@Z
.text:00002580 ??0CPair@NWildcard@@QAE@ABVUString@@@Z proc near
.text:00002580                                         ; CODE XREF: NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+29Fp
.text:00002580
.text:00002580 var_10          = dword ptr -10h
.text:00002580 var_C           = dword ptr -0Ch
.text:00002580 var_4           = dword ptr -4
.text:00002580 arg_0           = dword ptr  8
.text:00002580
.text:00002580                 push    ebp
.text:00002581                 mov     ebp, esp
.text:00002583                 push    0FFFFFFFFh
.text:00002585                 push    offset __ehhandler$??0CPair@NWildcard@@QAE@ABVUString@@@Z
.text:0000258A                 mov     eax, large fs:0
.text:00002590                 push    eax
.text:00002591                 push    ecx
.text:00002592                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00002599                 mov     eax, dword ptr ds:___security_cookie
.text:0000259E                 xor     eax, ebp
.text:000025A0                 push    eax
.text:000025A1                 lea     eax, [ebp+var_C]
.text:000025A4                 mov     large fs:0, eax
.text:000025AA                 mov     [ebp+var_10], ecx
.text:000025AD                 mov     eax, [ebp+arg_0]
.text:000025B0                 push    eax
.text:000025B1                 mov     ecx, [ebp+var_10]
.text:000025B4                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:000025B9                 mov     [ebp+var_4], 0
.text:000025C0                 mov     ecx, [ebp+var_10]
.text:000025C3                 add     ecx, 0Ch        ; this
.text:000025C6                 call    ??0CCensorNode@NWildcard@@QAE@XZ ; NWildcard::CCensorNode::CCensorNode(void)
.text:000025CB                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000025D2                 mov     eax, [ebp+var_10]
.text:000025D5                 mov     ecx, [ebp+var_C]
.text:000025D8                 mov     large fs:0, ecx
.text:000025DF                 pop     ecx
.text:000025E0                 add     esp, 10h
.text:000025E3                 cmp     ebp, esp
.text:000025E5                 call    __RTC_CheckEsp
.text:000025EA                 mov     esp, ebp
.text:000025EC                 pop     ebp
.text:000025ED                 retn    4
.text:000025ED ??0CPair@NWildcard@@QAE@ABVUString@@@Z endp
.text:000025ED
.text:000025ED _text           ends
.text:000025ED
.text$x:000025F0 ; ===========================================================================
.text$x:000025F0
.text$x:000025F0 ; Segment type: Pure code
.text$x:000025F0 ; Segment permissions: Read/Execute
.text$x:000025F0 _text$x         segment para public 'CODE' use32
.text$x:000025F0                 assume cs:_text$x
.text$x:000025F0                 ;org 25F0h
.text$x:000025F0 ; COMDAT (pick associative to section at 2580)
.text$x:000025F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000025F0
.text$x:000025F0 ; =============== S U B R O U T I N E =======================================
.text$x:000025F0
.text$x:000025F0
.text$x:000025F0 __unwindfunclet$??0CPair@NWildcard@@QAE@ABVUString@@@Z$0 proc near
.text$x:000025F0                                         ; DATA XREF: .xdata$x:00002618o
.text$x:000025F0                 mov     ecx, [ebp-10h]  ; this
.text$x:000025F3                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000025F3 __unwindfunclet$??0CPair@NWildcard@@QAE@ABVUString@@@Z$0 endp
.text$x:000025F3
.text$x:000025F8
.text$x:000025F8 ; =============== S U B R O U T I N E =======================================
.text$x:000025F8
.text$x:000025F8
.text$x:000025F8 __ehhandler$??0CPair@NWildcard@@QAE@ABVUString@@@Z proc near
.text$x:000025F8                                         ; DATA XREF: NWildcard::CPair::CPair(UString const &)+5o
.text$x:000025F8
.text$x:000025F8 arg_4           = dword ptr  8
.text$x:000025F8
.text$x:000025F8                 mov     edx, [esp+arg_4]
.text$x:000025FC                 lea     eax, [edx+0Ch]
.text$x:000025FF                 mov     ecx, [edx-8]
.text$x:00002602                 xor     ecx, eax
.text$x:00002604                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002609                 mov     eax, offset __ehfuncinfo$??0CPair@NWildcard@@QAE@ABVUString@@@Z
.text$x:0000260E                 jmp     ___CxxFrameHandler3
.text$x:0000260E __ehhandler$??0CPair@NWildcard@@QAE@ABVUString@@@Z endp
.text$x:0000260E
.text$x:0000260E ; ---------------------------------------------------------------------------
.text$x:00002613                 align 4
.text$x:00002613 _text$x         ends
.text$x:00002613
.xdata$x:00002614 ; ===========================================================================
.xdata$x:00002614
.xdata$x:00002614 ; Segment type: Pure data
.xdata$x:00002614 ; Segment permissions: Read
.xdata$x:00002614 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002614                 assume cs:_xdata$x
.xdata$x:00002614                 ;org 2614h
.xdata$x:00002614 ; COMDAT (pick associative to section at 2580)
.xdata$x:00002614 __unwindtable$??0CPair@NWildcard@@QAE@ABVUString@@@Z db 0FFh
.xdata$x:00002614                                         ; DATA XREF: .xdata$x:00002624o
.xdata$x:00002615                 db 0FFh
.xdata$x:00002616                 db 0FFh
.xdata$x:00002617                 db 0FFh
.xdata$x:00002618                 dd offset __unwindfunclet$??0CPair@NWildcard@@QAE@ABVUString@@@Z$0
.xdata$x:0000261C __ehfuncinfo$??0CPair@NWildcard@@QAE@ABVUString@@@Z db  22h ; "
.xdata$x:0000261C                                         ; DATA XREF: __ehhandler$??0CPair@NWildcard@@QAE@ABVUString@@@Z+11o
.xdata$x:0000261D                 db    5
.xdata$x:0000261E                 db  93h ; ô
.xdata$x:0000261F                 db  19h
.xdata$x:00002620                 db    1
.xdata$x:00002621                 db    0
.xdata$x:00002622                 db    0
.xdata$x:00002623                 db    0
.xdata$x:00002624                 dd offset __unwindtable$??0CPair@NWildcard@@QAE@ABVUString@@@Z
.xdata$x:00002628                 db    0
.xdata$x:00002629                 db    0
.xdata$x:0000262A                 db    0
.xdata$x:0000262B                 db    0
.xdata$x:0000262C                 db    0
.xdata$x:0000262D                 db    0
.xdata$x:0000262E                 db    0
.xdata$x:0000262F                 db    0
.xdata$x:00002630                 db    0
.xdata$x:00002631                 db    0
.xdata$x:00002632                 db    0
.xdata$x:00002633                 db    0
.xdata$x:00002634                 db    0
.xdata$x:00002635                 db    0
.xdata$x:00002636                 db    0
.xdata$x:00002637                 db    0
.xdata$x:00002638                 db    0
.xdata$x:00002639                 db    0
.xdata$x:0000263A                 db    0
.xdata$x:0000263B                 db    0
.xdata$x:0000263C                 db    1
.xdata$x:0000263D                 db    0
.xdata$x:0000263E                 db    0
.xdata$x:0000263F                 db    0
.xdata$x:0000263F _xdata$x        ends
.xdata$x:0000263F
.text:00002640 ; ===========================================================================
.text:00002640
.text:00002640 ; Segment type: Pure code
.text:00002640 ; Segment permissions: Read/Execute
.text:00002640 _text           segment para public 'CODE' use32
.text:00002640                 assume cs:_text
.text:00002640                 ;org 2640h
.text:00002640 ; COMDAT (pick any)
.text:00002640                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002640
.text:00002640 ; =============== S U B R O U T I N E =======================================
.text:00002640
.text:00002640 ; Attributes: bp-based frame
.text:00002640
.text:00002640 ; _DWORD __thiscall NWildcard::CCensorNode::CCensorNode(NWildcard::CCensorNode *__hidden this)
.text:00002640                 public ??0CCensorNode@NWildcard@@QAE@XZ
.text:00002640 ??0CCensorNode@NWildcard@@QAE@XZ proc near
.text:00002640                                         ; CODE XREF: NWildcard::CPair::CPair(UString const &)+46p
.text:00002640
.text:00002640 var_10          = dword ptr -10h
.text:00002640 var_C           = dword ptr -0Ch
.text:00002640 var_4           = dword ptr -4
.text:00002640
.text:00002640                 push    ebp
.text:00002641                 mov     ebp, esp
.text:00002643                 push    0FFFFFFFFh
.text:00002645                 push    offset __ehhandler$??0CCensorNode@NWildcard@@QAE@XZ
.text:0000264A                 mov     eax, large fs:0
.text:00002650                 push    eax
.text:00002651                 push    ecx
.text:00002652                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00002659                 mov     eax, dword ptr ds:___security_cookie
.text:0000265E                 xor     eax, ebp
.text:00002660                 push    eax
.text:00002661                 lea     eax, [ebp+var_C]
.text:00002664                 mov     large fs:0, eax
.text:0000266A                 mov     [ebp+var_10], ecx
.text:0000266D                 mov     eax, [ebp+var_10]
.text:00002670                 mov     dword ptr [eax], 0
.text:00002676                 mov     ecx, [ebp+var_10]
.text:00002679                 add     ecx, 4
.text:0000267C                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00002681                 mov     [ebp+var_4], 0
.text:00002688                 mov     ecx, [ebp+var_10]
.text:0000268B                 add     ecx, 10h
.text:0000268E                 call    ??0?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@XZ ; CObjectVector<NWildcard::CCensorNode>::CObjectVector<NWildcard::CCensorNode>(void)
.text:00002693                 mov     byte ptr [ebp+var_4], 1
.text:00002697                 mov     ecx, [ebp+var_10]
.text:0000269A                 add     ecx, 1Ch
.text:0000269D                 call    ??0?$CObjectVector@UCItem@NWildcard@@@@QAE@XZ ; CObjectVector<NWildcard::CItem>::CObjectVector<NWildcard::CItem>(void)
.text:000026A2                 mov     byte ptr [ebp+var_4], 2
.text:000026A6                 mov     ecx, [ebp+var_10]
.text:000026A9                 add     ecx, 28h ; '('
.text:000026AC                 call    ??0?$CObjectVector@UCItem@NWildcard@@@@QAE@XZ ; CObjectVector<NWildcard::CItem>::CObjectVector<NWildcard::CItem>(void)
.text:000026B1                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000026B8                 mov     eax, [ebp+var_10]
.text:000026BB                 mov     ecx, [ebp+var_C]
.text:000026BE                 mov     large fs:0, ecx
.text:000026C5                 pop     ecx
.text:000026C6                 add     esp, 10h
.text:000026C9                 cmp     ebp, esp
.text:000026CB                 call    __RTC_CheckEsp
.text:000026D0                 mov     esp, ebp
.text:000026D2                 pop     ebp
.text:000026D3                 retn
.text:000026D3 ??0CCensorNode@NWildcard@@QAE@XZ endp
.text:000026D3
.text:000026D3 _text           ends
.text:000026D3
.text$x:000026D4 ; ===========================================================================
.text$x:000026D4
.text$x:000026D4 ; Segment type: Pure code
.text$x:000026D4 ; Segment permissions: Read/Execute
.text$x:000026D4 _text$x         segment para public 'CODE' use32
.text$x:000026D4                 assume cs:_text$x
.text$x:000026D4                 ;org 26D4h
.text$x:000026D4 ; COMDAT (pick associative to section at 2640)
.text$x:000026D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000026D4
.text$x:000026D4 ; =============== S U B R O U T I N E =======================================
.text$x:000026D4
.text$x:000026D4
.text$x:000026D4 __unwindfunclet$??0CCensorNode@NWildcard@@QAE@XZ$0 proc near
.text$x:000026D4                                         ; DATA XREF: .xdata$x:00002714o
.text$x:000026D4                 mov     ecx, [ebp-10h]
.text$x:000026D7                 add     ecx, 4          ; this
.text$x:000026DA                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000026DA __unwindfunclet$??0CCensorNode@NWildcard@@QAE@XZ$0 endp
.text$x:000026DA
.text$x:000026DF
.text$x:000026DF ; =============== S U B R O U T I N E =======================================
.text$x:000026DF
.text$x:000026DF
.text$x:000026DF __unwindfunclet$??0CCensorNode@NWildcard@@QAE@XZ$1 proc near
.text$x:000026DF                                         ; DATA XREF: .xdata$x:0000271Co
.text$x:000026DF                 mov     ecx, [ebp-10h]
.text$x:000026E2                 add     ecx, 10h
.text$x:000026E5                 jmp     ??1?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@XZ ; CObjectVector<NWildcard::CCensorNode>::~CObjectVector<NWildcard::CCensorNode>(void)
.text$x:000026E5 __unwindfunclet$??0CCensorNode@NWildcard@@QAE@XZ$1 endp
.text$x:000026E5
.text$x:000026EA
.text$x:000026EA ; =============== S U B R O U T I N E =======================================
.text$x:000026EA
.text$x:000026EA
.text$x:000026EA __unwindfunclet$??0CCensorNode@NWildcard@@QAE@XZ$2 proc near
.text$x:000026EA                                         ; DATA XREF: .xdata$x:00002724o
.text$x:000026EA                 mov     ecx, [ebp-10h]
.text$x:000026ED                 add     ecx, 1Ch
.text$x:000026F0                 jmp     ??1?$CObjectVector@UCItem@NWildcard@@@@QAE@XZ ; CObjectVector<NWildcard::CItem>::~CObjectVector<NWildcard::CItem>(void)
.text$x:000026F0 __unwindfunclet$??0CCensorNode@NWildcard@@QAE@XZ$2 endp
.text$x:000026F0
.text$x:000026F5
.text$x:000026F5 ; =============== S U B R O U T I N E =======================================
.text$x:000026F5
.text$x:000026F5
.text$x:000026F5 __ehhandler$??0CCensorNode@NWildcard@@QAE@XZ proc near
.text$x:000026F5                                         ; DATA XREF: NWildcard::CCensorNode::CCensorNode(void)+5o
.text$x:000026F5
.text$x:000026F5 arg_4           = dword ptr  8
.text$x:000026F5
.text$x:000026F5                 mov     edx, [esp+arg_4]
.text$x:000026F9                 lea     eax, [edx+0Ch]
.text$x:000026FC                 mov     ecx, [edx-8]
.text$x:000026FF                 xor     ecx, eax
.text$x:00002701                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002706                 mov     eax, offset __ehfuncinfo$??0CCensorNode@NWildcard@@QAE@XZ
.text$x:0000270B                 jmp     ___CxxFrameHandler3
.text$x:0000270B __ehhandler$??0CCensorNode@NWildcard@@QAE@XZ endp
.text$x:0000270B
.text$x:0000270B _text$x         ends
.text$x:0000270B
.xdata$x:00002710 ; ===========================================================================
.xdata$x:00002710
.xdata$x:00002710 ; Segment type: Pure data
.xdata$x:00002710 ; Segment permissions: Read
.xdata$x:00002710 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002710                 assume cs:_xdata$x
.xdata$x:00002710                 ;org 2710h
.xdata$x:00002710 ; COMDAT (pick associative to section at 2640)
.xdata$x:00002710 __unwindtable$??0CCensorNode@NWildcard@@QAE@XZ db 0FFh
.xdata$x:00002710                                         ; DATA XREF: .xdata$x:00002730o
.xdata$x:00002711                 db 0FFh
.xdata$x:00002712                 db 0FFh
.xdata$x:00002713                 db 0FFh
.xdata$x:00002714                 dd offset __unwindfunclet$??0CCensorNode@NWildcard@@QAE@XZ$0
.xdata$x:00002718                 db    0
.xdata$x:00002719                 db    0
.xdata$x:0000271A                 db    0
.xdata$x:0000271B                 db    0
.xdata$x:0000271C                 dd offset __unwindfunclet$??0CCensorNode@NWildcard@@QAE@XZ$1
.xdata$x:00002720                 db    1
.xdata$x:00002721                 db    0
.xdata$x:00002722                 db    0
.xdata$x:00002723                 db    0
.xdata$x:00002724                 dd offset __unwindfunclet$??0CCensorNode@NWildcard@@QAE@XZ$2
.xdata$x:00002728 __ehfuncinfo$??0CCensorNode@NWildcard@@QAE@XZ db  22h ; "
.xdata$x:00002728                                         ; DATA XREF: __ehhandler$??0CCensorNode@NWildcard@@QAE@XZ+11o
.xdata$x:00002729                 db    5
.xdata$x:0000272A                 db  93h ; ô
.xdata$x:0000272B                 db  19h
.xdata$x:0000272C                 db    3
.xdata$x:0000272D                 db    0
.xdata$x:0000272E                 db    0
.xdata$x:0000272F                 db    0
.xdata$x:00002730                 dd offset __unwindtable$??0CCensorNode@NWildcard@@QAE@XZ
.xdata$x:00002734                 db    0
.xdata$x:00002735                 db    0
.xdata$x:00002736                 db    0
.xdata$x:00002737                 db    0
.xdata$x:00002738                 db    0
.xdata$x:00002739                 db    0
.xdata$x:0000273A                 db    0
.xdata$x:0000273B                 db    0
.xdata$x:0000273C                 db    0
.xdata$x:0000273D                 db    0
.xdata$x:0000273E                 db    0
.xdata$x:0000273F                 db    0
.xdata$x:00002740                 db    0
.xdata$x:00002741                 db    0
.xdata$x:00002742                 db    0
.xdata$x:00002743                 db    0
.xdata$x:00002744                 db    0
.xdata$x:00002745                 db    0
.xdata$x:00002746                 db    0
.xdata$x:00002747                 db    0
.xdata$x:00002748                 db    1
.xdata$x:00002749                 db    0
.xdata$x:0000274A                 db    0
.xdata$x:0000274B                 db    0
.xdata$x:0000274B _xdata$x        ends
.xdata$x:0000274B
.text:0000274C ; ===========================================================================
.text:0000274C
.text:0000274C ; Segment type: Pure code
.text:0000274C ; Segment permissions: Read/Execute
.text:0000274C _text           segment para public 'CODE' use32
.text:0000274C                 assume cs:_text
.text:0000274C                 ;org 274Ch
.text:0000274C ; COMDAT (pick any)
.text:0000274C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000274C
.text:0000274C ; =============== S U B R O U T I N E =======================================
.text:0000274C
.text:0000274C ; Attributes: bp-based frame
.text:0000274C
.text:0000274C ; bool __thiscall UString::IsEqualTo_Ascii_NoCase(UString *this, const char *)
.text:0000274C                 public ?IsEqualTo_Ascii_NoCase@UString@@QBE_NPBD@Z
.text:0000274C ?IsEqualTo_Ascii_NoCase@UString@@QBE_NPBD@Z proc near
.text:0000274C                                         ; CODE XREF: NWildcard::GetNumPrefixParts(CObjectVector<UString>)+240p
.text:0000274C
.text:0000274C var_4           = dword ptr -4
.text:0000274C arg_0           = dword ptr  8
.text:0000274C
.text:0000274C                 push    ebp
.text:0000274D                 mov     ebp, esp
.text:0000274F                 push    ecx
.text:00002750                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002757                 mov     [ebp+var_4], ecx
.text:0000275A                 mov     eax, [ebp+arg_0]
.text:0000275D                 push    eax             ; char *
.text:0000275E                 mov     ecx, [ebp+var_4]
.text:00002761                 mov     edx, [ecx]
.text:00002763                 push    edx             ; wchar_t *
.text:00002764                 call    ?StringsAreEqualNoCase_Ascii@@YG_NPB_WPBD@Z ; StringsAreEqualNoCase_Ascii(wchar_t const *,char const *)
.text:00002769                 add     esp, 4
.text:0000276C                 cmp     ebp, esp
.text:0000276E                 call    __RTC_CheckEsp
.text:00002773                 mov     esp, ebp
.text:00002775                 pop     ebp
.text:00002776                 retn    4
.text:00002776 ?IsEqualTo_Ascii_NoCase@UString@@QBE_NPBD@Z endp
.text:00002776
.text:00002776 ; ---------------------------------------------------------------------------
.text:00002779                 align 4
.text:00002779 _text           ends
.text:00002779
.text:0000277C ; ===========================================================================
.text:0000277C
.text:0000277C ; Segment type: Pure code
.text:0000277C ; Segment permissions: Read/Execute
.text:0000277C _text           segment para public 'CODE' use32
.text:0000277C                 assume cs:_text
.text:0000277C                 ;org 277Ch
.text:0000277C ; COMDAT (pick any)
.text:0000277C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000277C
.text:0000277C ; =============== S U B R O U T I N E =======================================
.text:0000277C
.text:0000277C ; Attributes: bp-based frame
.text:0000277C
.text:0000277C ; _DWORD __thiscall NWildcard::CPair::~CPair(NWildcard::CPair *__hidden this)
.text:0000277C                 public ??1CPair@NWildcard@@QAE@XZ
.text:0000277C ??1CPair@NWildcard@@QAE@XZ proc near    ; CODE XREF: NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+2D6p
.text:0000277C                                         ; __unwindfunclet$?AddItem@CCensor@NWildcard@@QAEXW4ECensorPathMode@2@_NABVUString@@11@Z$3+6j
.text:0000277C
.text:0000277C var_10          = dword ptr -10h
.text:0000277C var_C           = dword ptr -0Ch
.text:0000277C var_4           = dword ptr -4
.text:0000277C
.text:0000277C                 push    ebp
.text:0000277D                 mov     ebp, esp
.text:0000277F                 push    0FFFFFFFFh
.text:00002781                 push    offset __ehhandler$??1CPair@NWildcard@@QAE@XZ
.text:00002786                 mov     eax, large fs:0
.text:0000278C                 push    eax
.text:0000278D                 push    ecx
.text:0000278E                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00002795                 mov     eax, dword ptr ds:___security_cookie
.text:0000279A                 xor     eax, ebp
.text:0000279C                 push    eax
.text:0000279D                 lea     eax, [ebp+var_C]
.text:000027A0                 mov     large fs:0, eax
.text:000027A6                 mov     [ebp+var_10], ecx
.text:000027A9                 mov     [ebp+var_4], 0
.text:000027B0                 mov     ecx, [ebp+var_10]
.text:000027B3                 add     ecx, 0Ch        ; this
.text:000027B6                 call    ??1CCensorNode@NWildcard@@QAE@XZ ; NWildcard::CCensorNode::~CCensorNode(void)
.text:000027BB                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000027C2                 mov     ecx, [ebp+var_10] ; this
.text:000027C5                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000027CA                 mov     ecx, [ebp+var_C]
.text:000027CD                 mov     large fs:0, ecx
.text:000027D4                 pop     ecx
.text:000027D5                 add     esp, 10h
.text:000027D8                 cmp     ebp, esp
.text:000027DA                 call    __RTC_CheckEsp
.text:000027DF                 mov     esp, ebp
.text:000027E1                 pop     ebp
.text:000027E2                 retn
.text:000027E2 ??1CPair@NWildcard@@QAE@XZ endp
.text:000027E2
.text:000027E2 ; ---------------------------------------------------------------------------
.text:000027E3                 align 4
.text:000027E3 _text           ends
.text:000027E3
.text$x:000027E4 ; ===========================================================================
.text$x:000027E4
.text$x:000027E4 ; Segment type: Pure code
.text$x:000027E4 ; Segment permissions: Read/Execute
.text$x:000027E4 _text$x         segment para public 'CODE' use32
.text$x:000027E4                 assume cs:_text$x
.text$x:000027E4                 ;org 27E4h
.text$x:000027E4 ; COMDAT (pick associative to section at 277C)
.text$x:000027E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000027E4
.text$x:000027E4 ; =============== S U B R O U T I N E =======================================
.text$x:000027E4
.text$x:000027E4
.text$x:000027E4 __unwindfunclet$??1CPair@NWildcard@@QAE@XZ$0 proc near
.text$x:000027E4                                         ; DATA XREF: .xdata$x:0000280Co
.text$x:000027E4                 mov     ecx, [ebp-10h]  ; this
.text$x:000027E7                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000027E7 __unwindfunclet$??1CPair@NWildcard@@QAE@XZ$0 endp
.text$x:000027E7
.text$x:000027EC
.text$x:000027EC ; =============== S U B R O U T I N E =======================================
.text$x:000027EC
.text$x:000027EC
.text$x:000027EC __ehhandler$??1CPair@NWildcard@@QAE@XZ proc near
.text$x:000027EC                                         ; DATA XREF: NWildcard::CPair::~CPair(void)+5o
.text$x:000027EC
.text$x:000027EC arg_4           = dword ptr  8
.text$x:000027EC
.text$x:000027EC                 mov     edx, [esp+arg_4]
.text$x:000027F0                 lea     eax, [edx+0Ch]
.text$x:000027F3                 mov     ecx, [edx-8]
.text$x:000027F6                 xor     ecx, eax
.text$x:000027F8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000027FD                 mov     eax, offset __ehfuncinfo$??1CPair@NWildcard@@QAE@XZ
.text$x:00002802                 jmp     ___CxxFrameHandler3
.text$x:00002802 __ehhandler$??1CPair@NWildcard@@QAE@XZ endp
.text$x:00002802
.text$x:00002802 ; ---------------------------------------------------------------------------
.text$x:00002807                 align 4
.text$x:00002807 _text$x         ends
.text$x:00002807
.xdata$x:00002808 ; ===========================================================================
.xdata$x:00002808
.xdata$x:00002808 ; Segment type: Pure data
.xdata$x:00002808 ; Segment permissions: Read
.xdata$x:00002808 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002808                 assume cs:_xdata$x
.xdata$x:00002808                 ;org 2808h
.xdata$x:00002808 ; COMDAT (pick associative to section at 277C)
.xdata$x:00002808 __unwindtable$??1CPair@NWildcard@@QAE@XZ db 0FFh
.xdata$x:00002808                                         ; DATA XREF: .xdata$x:00002818o
.xdata$x:00002809                 db 0FFh
.xdata$x:0000280A                 db 0FFh
.xdata$x:0000280B                 db 0FFh
.xdata$x:0000280C                 dd offset __unwindfunclet$??1CPair@NWildcard@@QAE@XZ$0
.xdata$x:00002810 __ehfuncinfo$??1CPair@NWildcard@@QAE@XZ db  22h ; "
.xdata$x:00002810                                         ; DATA XREF: __ehhandler$??1CPair@NWildcard@@QAE@XZ+11o
.xdata$x:00002811                 db    5
.xdata$x:00002812                 db  93h ; ô
.xdata$x:00002813                 db  19h
.xdata$x:00002814                 db    1
.xdata$x:00002815                 db    0
.xdata$x:00002816                 db    0
.xdata$x:00002817                 db    0
.xdata$x:00002818                 dd offset __unwindtable$??1CPair@NWildcard@@QAE@XZ
.xdata$x:0000281C                 db    0
.xdata$x:0000281D                 db    0
.xdata$x:0000281E                 db    0
.xdata$x:0000281F                 db    0
.xdata$x:00002820                 db    0
.xdata$x:00002821                 db    0
.xdata$x:00002822                 db    0
.xdata$x:00002823                 db    0
.xdata$x:00002824                 db    0
.xdata$x:00002825                 db    0
.xdata$x:00002826                 db    0
.xdata$x:00002827                 db    0
.xdata$x:00002828                 db    0
.xdata$x:00002829                 db    0
.xdata$x:0000282A                 db    0
.xdata$x:0000282B                 db    0
.xdata$x:0000282C                 db    0
.xdata$x:0000282D                 db    0
.xdata$x:0000282E                 db    0
.xdata$x:0000282F                 db    0
.xdata$x:00002830                 db    1
.xdata$x:00002831                 db    0
.xdata$x:00002832                 db    0
.xdata$x:00002833                 db    0
.xdata$x:00002833 _xdata$x        ends
.xdata$x:00002833
.text:00002834 ; ===========================================================================
.text:00002834
.text:00002834 ; Segment type: Pure code
.text:00002834 ; Segment permissions: Read/Execute
.text:00002834 _text           segment para public 'CODE' use32
.text:00002834                 assume cs:_text
.text:00002834                 ;org 2834h
.text:00002834 ; COMDAT (pick any)
.text:00002834                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002834
.text:00002834 ; =============== S U B R O U T I N E =======================================
.text:00002834
.text:00002834 ; Attributes: bp-based frame
.text:00002834
.text:00002834 ; public: unsigned int __thiscall CObjectVector<class UString>::Size(void)const
.text:00002834                 public ?Size@?$CObjectVector@VUString@@@@QBEIXZ
.text:00002834 ?Size@?$CObjectVector@VUString@@@@QBEIXZ proc near
.text:00002834                                         ; CODE XREF: NWildcard::CItem::AreAllAllowed(void)+3Bp
.text:00002834                                         ; NWildcard::CItem::CheckPath(CObjectVector<UString> const &,bool)+3Ep ...
.text:00002834
.text:00002834 var_4           = dword ptr -4
.text:00002834
.text:00002834                 push    ebp
.text:00002835                 mov     ebp, esp
.text:00002837                 push    ecx
.text:00002838                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000283F                 mov     [ebp+var_4], ecx
.text:00002842                 mov     ecx, [ebp+var_4]
.text:00002845                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:0000284A                 add     esp, 4
.text:0000284D                 cmp     ebp, esp
.text:0000284F                 call    __RTC_CheckEsp
.text:00002854                 mov     esp, ebp
.text:00002856                 pop     ebp
.text:00002857                 retn
.text:00002857 ?Size@?$CObjectVector@VUString@@@@QBEIXZ endp
.text:00002857
.text:00002857 _text           ends
.text:00002857
.text:00002858 ; ===========================================================================
.text:00002858
.text:00002858 ; Segment type: Pure code
.text:00002858 ; Segment permissions: Read/Execute
.text:00002858 _text           segment para public 'CODE' use32
.text:00002858                 assume cs:_text
.text:00002858                 ;org 2858h
.text:00002858 ; COMDAT (pick any)
.text:00002858                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002858
.text:00002858 ; =============== S U B R O U T I N E =======================================
.text:00002858
.text:00002858 ; Attributes: bp-based frame
.text:00002858
.text:00002858 ; public: bool __thiscall CObjectVector<class UString>::IsEmpty(void)const
.text:00002858                 public ?IsEmpty@?$CObjectVector@VUString@@@@QBE_NXZ
.text:00002858 ?IsEmpty@?$CObjectVector@VUString@@@@QBE_NXZ proc near
.text:00002858                                         ; CODE XREF: NWildcard::GetNumPrefixParts_if_DrivePath(CObjectVector<UString> &)+Ep
.text:00002858                                         ; NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+2E4p ...
.text:00002858
.text:00002858 var_4           = dword ptr -4
.text:00002858
.text:00002858                 push    ebp
.text:00002859                 mov     ebp, esp
.text:0000285B                 push    ecx
.text:0000285C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002863                 mov     [ebp+var_4], ecx
.text:00002866                 mov     ecx, [ebp+var_4]
.text:00002869                 call    ?IsEmpty@?$CRecordVector@PAX@@QBE_NXZ ; CRecordVector<void *>::IsEmpty(void)
.text:0000286E                 add     esp, 4
.text:00002871                 cmp     ebp, esp
.text:00002873                 call    __RTC_CheckEsp
.text:00002878                 mov     esp, ebp
.text:0000287A                 pop     ebp
.text:0000287B                 retn
.text:0000287B ?IsEmpty@?$CObjectVector@VUString@@@@QBE_NXZ endp
.text:0000287B
.text:0000287B _text           ends
.text:0000287B
.text:0000287C ; ===========================================================================
.text:0000287C
.text:0000287C ; Segment type: Pure code
.text:0000287C ; Segment permissions: Read/Execute
.text:0000287C _text           segment para public 'CODE' use32
.text:0000287C                 assume cs:_text
.text:0000287C                 ;org 287Ch
.text:0000287C ; COMDAT (pick any)
.text:0000287C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000287C
.text:0000287C ; =============== S U B R O U T I N E =======================================
.text:0000287C
.text:0000287C ; Attributes: bp-based frame
.text:0000287C
.text:0000287C ; public: __thiscall CObjectVector<class UString>::CObjectVector<class UString>(void)
.text:0000287C                 public ??0?$CObjectVector@VUString@@@@QAE@XZ
.text:0000287C ??0?$CObjectVector@VUString@@@@QAE@XZ proc near
.text:0000287C                                         ; CODE XREF: NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+67p
.text:0000287C                                         ; NWildcard::CItem::CItem(void)+11p
.text:0000287C
.text:0000287C var_4           = dword ptr -4
.text:0000287C
.text:0000287C                 push    ebp
.text:0000287D                 mov     ebp, esp
.text:0000287F                 push    ecx
.text:00002880                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002887                 mov     [ebp+var_4], ecx
.text:0000288A                 mov     ecx, [ebp+var_4]
.text:0000288D                 call    ??0?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::CRecordVector<void *>(void)
.text:00002892                 mov     eax, [ebp+var_4]
.text:00002895                 add     esp, 4
.text:00002898                 cmp     ebp, esp
.text:0000289A                 call    __RTC_CheckEsp
.text:0000289F                 mov     esp, ebp
.text:000028A1                 pop     ebp
.text:000028A2                 retn
.text:000028A2 ??0?$CObjectVector@VUString@@@@QAE@XZ endp
.text:000028A2
.text:000028A2 ; ---------------------------------------------------------------------------
.text:000028A3                 align 4
.text:000028A3 _text           ends
.text:000028A3
.text:000028A4 ; ===========================================================================
.text:000028A4
.text:000028A4 ; Segment type: Pure code
.text:000028A4 ; Segment permissions: Read/Execute
.text:000028A4 _text           segment para public 'CODE' use32
.text:000028A4                 assume cs:_text
.text:000028A4                 ;org 28A4h
.text:000028A4 ; COMDAT (pick any)
.text:000028A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000028A4
.text:000028A4 ; =============== S U B R O U T I N E =======================================
.text:000028A4
.text:000028A4 ; Attributes: bp-based frame
.text:000028A4
.text:000028A4 ; public: __thiscall CObjectVector<class UString>::CObjectVector<class UString>(class CObjectVector<class UString> const &)
.text:000028A4                 public ??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z
.text:000028A4 ??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z proc near
.text:000028A4                                         ; CODE XREF: NWildcard::CCensorNode::CheckPathVect(CObjectVector<UString> const &,bool,bool &)+C1p
.text:000028A4                                         ; NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+136p ...
.text:000028A4
.text:000028A4 var_24          = dword ptr -24h
.text:000028A4 var_20          = dword ptr -20h
.text:000028A4 var_1C          = dword ptr -1Ch
.text:000028A4 var_18          = dword ptr -18h
.text:000028A4 var_14          = dword ptr -14h
.text:000028A4 var_10          = dword ptr -10h
.text:000028A4 var_C           = dword ptr -0Ch
.text:000028A4 var_4           = dword ptr -4
.text:000028A4 arg_0           = dword ptr  8
.text:000028A4
.text:000028A4                 push    ebp
.text:000028A5                 mov     ebp, esp
.text:000028A7                 push    0FFFFFFFFh
.text:000028A9                 push    offset __ehhandler$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z
.text:000028AE                 mov     eax, large fs:0
.text:000028B4                 push    eax
.text:000028B5                 sub     esp, 18h
.text:000028B8                 mov     eax, 0CCCCCCCCh
.text:000028BD                 mov     [ebp+var_24], eax
.text:000028C0                 mov     [ebp+var_20], eax
.text:000028C3                 mov     [ebp+var_1C], eax
.text:000028C6                 mov     [ebp+var_18], eax
.text:000028C9                 mov     [ebp+var_14], eax
.text:000028CC                 mov     [ebp+var_10], eax
.text:000028CF                 mov     eax, dword ptr ds:___security_cookie
.text:000028D4                 xor     eax, ebp
.text:000028D6                 push    eax
.text:000028D7                 lea     eax, [ebp+var_C]
.text:000028DA                 mov     large fs:0, eax
.text:000028E0                 mov     [ebp+var_10], ecx
.text:000028E3                 mov     ecx, [ebp+var_10]
.text:000028E6                 call    ??0?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::CRecordVector<void *>(void)
.text:000028EB                 mov     [ebp+var_4], 0
.text:000028F2                 mov     ecx, [ebp+arg_0]
.text:000028F5                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:000028FA                 mov     [ebp+var_14], eax
.text:000028FD                 mov     eax, [ebp+var_14]
.text:00002900                 push    eax
.text:00002901                 mov     ecx, [ebp+var_10]
.text:00002904                 call    ?ConstructReserve@?$CRecordVector@PAX@@QAEXI@Z ; CRecordVector<void *>::ConstructReserve(uint)
.text:00002909                 mov     [ebp+var_18], 0
.text:00002910                 jmp     short loc_291B
.text:00002912 ; ---------------------------------------------------------------------------
.text:00002912
.text:00002912 loc_2912:                               ; CODE XREF: CObjectVector<UString>::CObjectVector<UString>(CObjectVector<UString> const &)+CDj
.text:00002912                 mov     ecx, [ebp+var_18]
.text:00002915                 add     ecx, 1
.text:00002918                 mov     [ebp+var_18], ecx
.text:0000291B
.text:0000291B loc_291B:                               ; CODE XREF: CObjectVector<UString>::CObjectVector<UString>(CObjectVector<UString> const &)+6Cj
.text:0000291B                 mov     edx, [ebp+var_18]
.text:0000291E                 cmp     edx, [ebp+var_14]
.text:00002921                 jnb     short loc_2973
.text:00002923                 push    0Ch             ; unsigned int
.text:00002925                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0000292A                 add     esp, 4
.text:0000292D                 mov     [ebp+var_20], eax
.text:00002930                 mov     byte ptr [ebp+var_4], 1
.text:00002934                 cmp     [ebp+var_20], 0
.text:00002938                 jz      short loc_2954
.text:0000293A                 mov     eax, [ebp+var_18]
.text:0000293D                 push    eax
.text:0000293E                 mov     ecx, [ebp+arg_0]
.text:00002941                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00002946                 push    eax
.text:00002947                 mov     ecx, [ebp+var_20]
.text:0000294A                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:0000294F                 mov     [ebp+var_24], eax
.text:00002952                 jmp     short loc_295B
.text:00002954 ; ---------------------------------------------------------------------------
.text:00002954
.text:00002954 loc_2954:                               ; CODE XREF: CObjectVector<UString>::CObjectVector<UString>(CObjectVector<UString> const &)+94j
.text:00002954                 mov     [ebp+var_24], 0
.text:0000295B
.text:0000295B loc_295B:                               ; CODE XREF: CObjectVector<UString>::CObjectVector<UString>(CObjectVector<UString> const &)+AEj
.text:0000295B                 mov     ecx, [ebp+var_24]
.text:0000295E                 mov     [ebp+var_1C], ecx
.text:00002961                 mov     byte ptr [ebp+var_4], 0
.text:00002965                 mov     edx, [ebp+var_1C]
.text:00002968                 push    edx
.text:00002969                 mov     ecx, [ebp+var_10]
.text:0000296C                 call    ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z ; CRecordVector<void *>::AddInReserved(void * const)
.text:00002971                 jmp     short loc_2912
.text:00002973 ; ---------------------------------------------------------------------------
.text:00002973
.text:00002973 loc_2973:                               ; CODE XREF: CObjectVector<UString>::CObjectVector<UString>(CObjectVector<UString> const &)+7Dj
.text:00002973                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000297A                 mov     eax, [ebp+var_10]
.text:0000297D                 mov     ecx, [ebp+var_C]
.text:00002980                 mov     large fs:0, ecx
.text:00002987                 pop     ecx
.text:00002988                 add     esp, 24h
.text:0000298B                 cmp     ebp, esp
.text:0000298D                 call    __RTC_CheckEsp
.text:00002992                 mov     esp, ebp
.text:00002994                 pop     ebp
.text:00002995                 retn    4
.text:00002995 ??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z endp
.text:00002995
.text:00002995 _text           ends
.text:00002995
.text$x:00002998 ; ===========================================================================
.text$x:00002998
.text$x:00002998 ; Segment type: Pure code
.text$x:00002998 ; Segment permissions: Read/Execute
.text$x:00002998 _text$x         segment para public 'CODE' use32
.text$x:00002998                 assume cs:_text$x
.text$x:00002998                 ;org 2998h
.text$x:00002998 ; COMDAT (pick associative to section at 28A4)
.text$x:00002998                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002998
.text$x:00002998 ; =============== S U B R O U T I N E =======================================
.text$x:00002998
.text$x:00002998
.text$x:00002998 __unwindfunclet$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z$0 proc near
.text$x:00002998                                         ; DATA XREF: .xdata$x:000029CCo
.text$x:00002998                 mov     ecx, [ebp-10h]
.text$x:0000299B                 jmp     ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text$x:0000299B __unwindfunclet$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z$0 endp
.text$x:0000299B
.text$x:000029A0
.text$x:000029A0 ; =============== S U B R O U T I N E =======================================
.text$x:000029A0
.text$x:000029A0
.text$x:000029A0 __unwindfunclet$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z$1 proc near
.text$x:000029A0                                         ; DATA XREF: .xdata$x:000029D4o
.text$x:000029A0                 mov     eax, [ebp-20h]
.text$x:000029A3                 push    eax             ; void *
.text$x:000029A4                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:000029A9                 pop     ecx
.text$x:000029AA                 retn
.text$x:000029AA __unwindfunclet$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z$1 endp
.text$x:000029AA
.text$x:000029AB
.text$x:000029AB ; =============== S U B R O U T I N E =======================================
.text$x:000029AB
.text$x:000029AB
.text$x:000029AB __ehhandler$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z proc near
.text$x:000029AB                                         ; DATA XREF: CObjectVector<UString>::CObjectVector<UString>(CObjectVector<UString> const &)+5o
.text$x:000029AB
.text$x:000029AB arg_4           = dword ptr  8
.text$x:000029AB
.text$x:000029AB                 mov     edx, [esp+arg_4]
.text$x:000029AF                 lea     eax, [edx+0Ch]
.text$x:000029B2                 mov     ecx, [edx-1Ch]
.text$x:000029B5                 xor     ecx, eax
.text$x:000029B7                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000029BC                 mov     eax, offset __ehfuncinfo$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z
.text$x:000029C1                 jmp     ___CxxFrameHandler3
.text$x:000029C1 __ehhandler$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z endp
.text$x:000029C1
.text$x:000029C1 ; ---------------------------------------------------------------------------
.text$x:000029C6                 align 4
.text$x:000029C6 _text$x         ends
.text$x:000029C6
.xdata$x:000029C8 ; ===========================================================================
.xdata$x:000029C8
.xdata$x:000029C8 ; Segment type: Pure data
.xdata$x:000029C8 ; Segment permissions: Read
.xdata$x:000029C8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000029C8                 assume cs:_xdata$x
.xdata$x:000029C8                 ;org 29C8h
.xdata$x:000029C8 ; COMDAT (pick associative to section at 28A4)
.xdata$x:000029C8 __unwindtable$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z db 0FFh
.xdata$x:000029C8                                         ; DATA XREF: .xdata$x:000029E0o
.xdata$x:000029C9                 db 0FFh
.xdata$x:000029CA                 db 0FFh
.xdata$x:000029CB                 db 0FFh
.xdata$x:000029CC                 dd offset __unwindfunclet$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z$0
.xdata$x:000029D0                 db    0
.xdata$x:000029D1                 db    0
.xdata$x:000029D2                 db    0
.xdata$x:000029D3                 db    0
.xdata$x:000029D4                 dd offset __unwindfunclet$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z$1
.xdata$x:000029D8 __ehfuncinfo$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z db  22h ; "
.xdata$x:000029D8                                         ; DATA XREF: __ehhandler$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z+11o
.xdata$x:000029D9                 db    5
.xdata$x:000029DA                 db  93h ; ô
.xdata$x:000029DB                 db  19h
.xdata$x:000029DC                 db    2
.xdata$x:000029DD                 db    0
.xdata$x:000029DE                 db    0
.xdata$x:000029DF                 db    0
.xdata$x:000029E0                 dd offset __unwindtable$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z
.xdata$x:000029E4                 db    0
.xdata$x:000029E5                 db    0
.xdata$x:000029E6                 db    0
.xdata$x:000029E7                 db    0
.xdata$x:000029E8                 db    0
.xdata$x:000029E9                 db    0
.xdata$x:000029EA                 db    0
.xdata$x:000029EB                 db    0
.xdata$x:000029EC                 db    0
.xdata$x:000029ED                 db    0
.xdata$x:000029EE                 db    0
.xdata$x:000029EF                 db    0
.xdata$x:000029F0                 db    0
.xdata$x:000029F1                 db    0
.xdata$x:000029F2                 db    0
.xdata$x:000029F3                 db    0
.xdata$x:000029F4                 db    0
.xdata$x:000029F5                 db    0
.xdata$x:000029F6                 db    0
.xdata$x:000029F7                 db    0
.xdata$x:000029F8                 db    1
.xdata$x:000029F9                 db    0
.xdata$x:000029FA                 db    0
.xdata$x:000029FB                 db    0
.xdata$x:000029FB _xdata$x        ends
.xdata$x:000029FB
.text:000029FC ; ===========================================================================
.text:000029FC
.text:000029FC ; Segment type: Pure code
.text:000029FC ; Segment permissions: Read/Execute
.text:000029FC _text           segment para public 'CODE' use32
.text:000029FC                 assume cs:_text
.text:000029FC                 ;org 29FCh
.text:000029FC ; COMDAT (pick any)
.text:000029FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000029FC
.text:000029FC ; =============== S U B R O U T I N E =======================================
.text:000029FC
.text:000029FC ; Attributes: bp-based frame
.text:000029FC
.text:000029FC ; public: class CObjectVector<class UString> & __thiscall CObjectVector<class UString>::operator=(class CObjectVector<class UString> const &)
.text:000029FC                 public ??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z
.text:000029FC ??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z proc near
.text:000029FC                                         ; CODE XREF: NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+36Ep
.text:000029FC
.text:000029FC var_24          = dword ptr -24h
.text:000029FC var_20          = dword ptr -20h
.text:000029FC var_1C          = dword ptr -1Ch
.text:000029FC var_18          = dword ptr -18h
.text:000029FC var_14          = dword ptr -14h
.text:000029FC var_10          = dword ptr -10h
.text:000029FC var_C           = dword ptr -0Ch
.text:000029FC var_4           = dword ptr -4
.text:000029FC arg_0           = dword ptr  8
.text:000029FC
.text:000029FC                 push    ebp
.text:000029FD                 mov     ebp, esp
.text:000029FF                 push    0FFFFFFFFh
.text:00002A01                 push    offset __ehhandler$??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z
.text:00002A06                 mov     eax, large fs:0
.text:00002A0C                 push    eax
.text:00002A0D                 sub     esp, 18h
.text:00002A10                 mov     eax, 0CCCCCCCCh
.text:00002A15                 mov     [ebp+var_24], eax
.text:00002A18                 mov     [ebp+var_20], eax
.text:00002A1B                 mov     [ebp+var_1C], eax
.text:00002A1E                 mov     [ebp+var_18], eax
.text:00002A21                 mov     [ebp+var_14], eax
.text:00002A24                 mov     [ebp+var_10], eax
.text:00002A27                 mov     eax, dword ptr ds:___security_cookie
.text:00002A2C                 xor     eax, ebp
.text:00002A2E                 push    eax
.text:00002A2F                 lea     eax, [ebp+var_C]
.text:00002A32                 mov     large fs:0, eax
.text:00002A38                 mov     [ebp+var_10], ecx
.text:00002A3B                 mov     eax, [ebp+arg_0]
.text:00002A3E                 cmp     eax, [ebp+var_10]
.text:00002A41                 jnz     short loc_2A4B
.text:00002A43                 mov     eax, [ebp+var_10]
.text:00002A46                 jmp     loc_2ADD
.text:00002A4B ; ---------------------------------------------------------------------------
.text:00002A4B
.text:00002A4B loc_2A4B:                               ; CODE XREF: CObjectVector<UString>::operator=(CObjectVector<UString> const &)+45j
.text:00002A4B                 mov     ecx, [ebp+var_10]
.text:00002A4E                 call    ?Clear@?$CObjectVector@VUString@@@@QAEXXZ ; CObjectVector<UString>::Clear(void)
.text:00002A53                 mov     ecx, [ebp+arg_0]
.text:00002A56                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:00002A5B                 mov     [ebp+var_14], eax
.text:00002A5E                 mov     ecx, [ebp+var_14]
.text:00002A61                 push    ecx
.text:00002A62                 mov     ecx, [ebp+var_10]
.text:00002A65                 call    ?Reserve@?$CRecordVector@PAX@@QAEXI@Z ; CRecordVector<void *>::Reserve(uint)
.text:00002A6A                 mov     [ebp+var_18], 0
.text:00002A71                 jmp     short loc_2A7C
.text:00002A73 ; ---------------------------------------------------------------------------
.text:00002A73
.text:00002A73 loc_2A73:                               ; CODE XREF: CObjectVector<UString>::operator=(CObjectVector<UString> const &)+DCj
.text:00002A73                 mov     edx, [ebp+var_18]
.text:00002A76                 add     edx, 1
.text:00002A79                 mov     [ebp+var_18], edx
.text:00002A7C
.text:00002A7C loc_2A7C:                               ; CODE XREF: CObjectVector<UString>::operator=(CObjectVector<UString> const &)+75j
.text:00002A7C                 mov     eax, [ebp+var_18]
.text:00002A7F                 cmp     eax, [ebp+var_14]
.text:00002A82                 jnb     short loc_2ADA
.text:00002A84                 push    0Ch             ; unsigned int
.text:00002A86                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00002A8B                 add     esp, 4
.text:00002A8E                 mov     [ebp+var_20], eax
.text:00002A91                 mov     [ebp+var_4], 0
.text:00002A98                 cmp     [ebp+var_20], 0
.text:00002A9C                 jz      short loc_2AB8
.text:00002A9E                 mov     ecx, [ebp+var_18]
.text:00002AA1                 push    ecx
.text:00002AA2                 mov     ecx, [ebp+arg_0]
.text:00002AA5                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00002AAA                 push    eax
.text:00002AAB                 mov     ecx, [ebp+var_20]
.text:00002AAE                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00002AB3                 mov     [ebp+var_24], eax
.text:00002AB6                 jmp     short loc_2ABF
.text:00002AB8 ; ---------------------------------------------------------------------------
.text:00002AB8
.text:00002AB8 loc_2AB8:                               ; CODE XREF: CObjectVector<UString>::operator=(CObjectVector<UString> const &)+A0j
.text:00002AB8                 mov     [ebp+var_24], 0
.text:00002ABF
.text:00002ABF loc_2ABF:                               ; CODE XREF: CObjectVector<UString>::operator=(CObjectVector<UString> const &)+BAj
.text:00002ABF                 mov     edx, [ebp+var_24]
.text:00002AC2                 mov     [ebp+var_1C], edx
.text:00002AC5                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00002ACC                 mov     eax, [ebp+var_1C]
.text:00002ACF                 push    eax
.text:00002AD0                 mov     ecx, [ebp+var_10]
.text:00002AD3                 call    ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z ; CRecordVector<void *>::AddInReserved(void * const)
.text:00002AD8                 jmp     short loc_2A73
.text:00002ADA ; ---------------------------------------------------------------------------
.text:00002ADA
.text:00002ADA loc_2ADA:                               ; CODE XREF: CObjectVector<UString>::operator=(CObjectVector<UString> const &)+86j
.text:00002ADA                 mov     eax, [ebp+var_10]
.text:00002ADD
.text:00002ADD loc_2ADD:                               ; CODE XREF: CObjectVector<UString>::operator=(CObjectVector<UString> const &)+4Aj
.text:00002ADD                 mov     ecx, [ebp+var_C]
.text:00002AE0                 mov     large fs:0, ecx
.text:00002AE7                 pop     ecx
.text:00002AE8                 add     esp, 24h
.text:00002AEB                 cmp     ebp, esp
.text:00002AED                 call    __RTC_CheckEsp
.text:00002AF2                 mov     esp, ebp
.text:00002AF4                 pop     ebp
.text:00002AF5                 retn    4
.text:00002AF5 ??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z endp
.text:00002AF5
.text:00002AF5 _text           ends
.text:00002AF5
.text$x:00002AF8 ; ===========================================================================
.text$x:00002AF8
.text$x:00002AF8 ; Segment type: Pure code
.text$x:00002AF8 ; Segment permissions: Read/Execute
.text$x:00002AF8 _text$x         segment para public 'CODE' use32
.text$x:00002AF8                 assume cs:_text$x
.text$x:00002AF8                 ;org 2AF8h
.text$x:00002AF8 ; COMDAT (pick associative to section at 29FC)
.text$x:00002AF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002AF8
.text$x:00002AF8 ; =============== S U B R O U T I N E =======================================
.text$x:00002AF8
.text$x:00002AF8
.text$x:00002AF8 __unwindfunclet$??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z$0 proc near
.text$x:00002AF8                                         ; DATA XREF: .xdata$x:00002B24o
.text$x:00002AF8                 mov     eax, [ebp-20h]
.text$x:00002AFB                 push    eax             ; void *
.text$x:00002AFC                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00002B01                 pop     ecx
.text$x:00002B02                 retn
.text$x:00002B02 __unwindfunclet$??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z$0 endp
.text$x:00002B02
.text$x:00002B03
.text$x:00002B03 ; =============== S U B R O U T I N E =======================================
.text$x:00002B03
.text$x:00002B03
.text$x:00002B03 __ehhandler$??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z proc near
.text$x:00002B03                                         ; DATA XREF: CObjectVector<UString>::operator=(CObjectVector<UString> const &)+5o
.text$x:00002B03
.text$x:00002B03 arg_4           = dword ptr  8
.text$x:00002B03
.text$x:00002B03                 mov     edx, [esp+arg_4]
.text$x:00002B07                 lea     eax, [edx+0Ch]
.text$x:00002B0A                 mov     ecx, [edx-1Ch]
.text$x:00002B0D                 xor     ecx, eax
.text$x:00002B0F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002B14                 mov     eax, offset __ehfuncinfo$??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z
.text$x:00002B19                 jmp     ___CxxFrameHandler3
.text$x:00002B19 __ehhandler$??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z endp
.text$x:00002B19
.text$x:00002B19 ; ---------------------------------------------------------------------------
.text$x:00002B1E                 align 10h
.text$x:00002B1E _text$x         ends
.text$x:00002B1E
.xdata$x:00002B20 ; ===========================================================================
.xdata$x:00002B20
.xdata$x:00002B20 ; Segment type: Pure data
.xdata$x:00002B20 ; Segment permissions: Read
.xdata$x:00002B20 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002B20                 assume cs:_xdata$x
.xdata$x:00002B20                 ;org 2B20h
.xdata$x:00002B20 ; COMDAT (pick associative to section at 29FC)
.xdata$x:00002B20 __unwindtable$??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z db 0FFh
.xdata$x:00002B20                                         ; DATA XREF: .xdata$x:00002B30o
.xdata$x:00002B21                 db 0FFh
.xdata$x:00002B22                 db 0FFh
.xdata$x:00002B23                 db 0FFh
.xdata$x:00002B24                 dd offset __unwindfunclet$??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z$0
.xdata$x:00002B28 __ehfuncinfo$??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z db  22h ; "
.xdata$x:00002B28                                         ; DATA XREF: __ehhandler$??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z+11o
.xdata$x:00002B29                 db    5
.xdata$x:00002B2A                 db  93h ; ô
.xdata$x:00002B2B                 db  19h
.xdata$x:00002B2C                 db    1
.xdata$x:00002B2D                 db    0
.xdata$x:00002B2E                 db    0
.xdata$x:00002B2F                 db    0
.xdata$x:00002B30                 dd offset __unwindtable$??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z
.xdata$x:00002B34                 db    0
.xdata$x:00002B35                 db    0
.xdata$x:00002B36                 db    0
.xdata$x:00002B37                 db    0
.xdata$x:00002B38                 db    0
.xdata$x:00002B39                 db    0
.xdata$x:00002B3A                 db    0
.xdata$x:00002B3B                 db    0
.xdata$x:00002B3C                 db    0
.xdata$x:00002B3D                 db    0
.xdata$x:00002B3E                 db    0
.xdata$x:00002B3F                 db    0
.xdata$x:00002B40                 db    0
.xdata$x:00002B41                 db    0
.xdata$x:00002B42                 db    0
.xdata$x:00002B43                 db    0
.xdata$x:00002B44                 db    0
.xdata$x:00002B45                 db    0
.xdata$x:00002B46                 db    0
.xdata$x:00002B47                 db    0
.xdata$x:00002B48                 db    1
.xdata$x:00002B49                 db    0
.xdata$x:00002B4A                 db    0
.xdata$x:00002B4B                 db    0
.xdata$x:00002B4B _xdata$x        ends
.xdata$x:00002B4B
.text:00002B4C ; ===========================================================================
.text:00002B4C
.text:00002B4C ; Segment type: Pure code
.text:00002B4C ; Segment permissions: Read/Execute
.text:00002B4C _text           segment para public 'CODE' use32
.text:00002B4C                 assume cs:_text
.text:00002B4C                 ;org 2B4Ch
.text:00002B4C ; COMDAT (pick any)
.text:00002B4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002B4C
.text:00002B4C ; =============== S U B R O U T I N E =======================================
.text:00002B4C
.text:00002B4C ; Attributes: bp-based frame
.text:00002B4C
.text:00002B4C ; public: class UString const & __thiscall CObjectVector<class UString>::operator[](unsigned int)const
.text:00002B4C                 public ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z
.text:00002B4C ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z proc near
.text:00002B4C                                         ; CODE XREF: NWildcard::CItem::CheckPath(CObjectVector<UString> const &,bool)+132p
.text:00002B4C                                         ; NWildcard::CItem::CheckPath(CObjectVector<UString> const &,bool)+13Fp ...
.text:00002B4C
.text:00002B4C var_4           = dword ptr -4
.text:00002B4C arg_0           = dword ptr  8
.text:00002B4C
.text:00002B4C                 push    ebp
.text:00002B4D                 mov     ebp, esp
.text:00002B4F                 push    ecx
.text:00002B50                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002B57                 mov     [ebp+var_4], ecx
.text:00002B5A                 mov     eax, [ebp+arg_0]
.text:00002B5D                 push    eax
.text:00002B5E                 mov     ecx, [ebp+var_4]
.text:00002B61                 call    ??A?$CRecordVector@PAX@@QBEABQAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00002B66                 mov     eax, [eax]
.text:00002B68                 add     esp, 4
.text:00002B6B                 cmp     ebp, esp
.text:00002B6D                 call    __RTC_CheckEsp
.text:00002B72                 mov     esp, ebp
.text:00002B74                 pop     ebp
.text:00002B75                 retn    4
.text:00002B75 ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z endp
.text:00002B75
.text:00002B75 _text           ends
.text:00002B75
.text:00002B78 ; ===========================================================================
.text:00002B78
.text:00002B78 ; Segment type: Pure code
.text:00002B78 ; Segment permissions: Read/Execute
.text:00002B78 _text           segment para public 'CODE' use32
.text:00002B78                 assume cs:_text
.text:00002B78                 ;org 2B78h
.text:00002B78 ; COMDAT (pick any)
.text:00002B78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002B78
.text:00002B78 ; =============== S U B R O U T I N E =======================================
.text:00002B78
.text:00002B78 ; Attributes: bp-based frame
.text:00002B78
.text:00002B78 ; public: class UString & __thiscall CObjectVector<class UString>::operator[](unsigned int)
.text:00002B78                 public ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z
.text:00002B78 ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z proc near
.text:00002B78                                         ; CODE XREF: NWildcard::GetNumPrefixParts_if_DrivePath(CObjectVector<UString> &)+2Dp
.text:00002B78                                         ; NWildcard::GetNumPrefixParts_if_DrivePath(CObjectVector<UString> &)+52p ...
.text:00002B78
.text:00002B78 var_4           = dword ptr -4
.text:00002B78 arg_0           = dword ptr  8
.text:00002B78
.text:00002B78                 push    ebp
.text:00002B79                 mov     ebp, esp
.text:00002B7B                 push    ecx
.text:00002B7C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002B83                 mov     [ebp+var_4], ecx
.text:00002B86                 mov     eax, [ebp+arg_0]
.text:00002B89                 push    eax
.text:00002B8A                 mov     ecx, [ebp+var_4]
.text:00002B8D                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00002B92                 mov     eax, [eax]
.text:00002B94                 add     esp, 4
.text:00002B97                 cmp     ebp, esp
.text:00002B99                 call    __RTC_CheckEsp
.text:00002B9E                 mov     esp, ebp
.text:00002BA0                 pop     ebp
.text:00002BA1                 retn    4
.text:00002BA1 ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z endp
.text:00002BA1
.text:00002BA1 _text           ends
.text:00002BA1
.text:00002BA4 ; ===========================================================================
.text:00002BA4
.text:00002BA4 ; Segment type: Pure code
.text:00002BA4 ; Segment permissions: Read/Execute
.text:00002BA4 _text           segment para public 'CODE' use32
.text:00002BA4                 assume cs:_text
.text:00002BA4                 ;org 2BA4h
.text:00002BA4 ; COMDAT (pick any)
.text:00002BA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002BA4
.text:00002BA4 ; =============== S U B R O U T I N E =======================================
.text:00002BA4
.text:00002BA4 ; Attributes: bp-based frame
.text:00002BA4
.text:00002BA4 ; public: class UString const & __thiscall CObjectVector<class UString>::Front(void)const
.text:00002BA4                 public ?Front@?$CObjectVector@VUString@@@@QBEABVUString@@XZ
.text:00002BA4 ?Front@?$CObjectVector@VUString@@@@QBEABVUString@@XZ proc near
.text:00002BA4                                         ; CODE XREF: NWildcard::CItem::AreAllAllowed(void)+4Dp
.text:00002BA4                                         ; NWildcard::CCensorNode::CheckPathVect(CObjectVector<UString> const &,bool,bool &)+A3p
.text:00002BA4
.text:00002BA4 var_4           = dword ptr -4
.text:00002BA4
.text:00002BA4                 push    ebp
.text:00002BA5                 mov     ebp, esp
.text:00002BA7                 push    ecx
.text:00002BA8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002BAF                 mov     [ebp+var_4], ecx
.text:00002BB2                 push    0
.text:00002BB4                 mov     ecx, [ebp+var_4]
.text:00002BB7                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00002BBC                 add     esp, 4
.text:00002BBF                 cmp     ebp, esp
.text:00002BC1                 call    __RTC_CheckEsp
.text:00002BC6                 mov     esp, ebp
.text:00002BC8                 pop     ebp
.text:00002BC9                 retn
.text:00002BC9 ?Front@?$CObjectVector@VUString@@@@QBEABVUString@@XZ endp
.text:00002BC9
.text:00002BC9 ; ---------------------------------------------------------------------------
.text:00002BCA                 align 4
.text:00002BCA _text           ends
.text:00002BCA
.text:00002BCC ; ===========================================================================
.text:00002BCC
.text:00002BCC ; Segment type: Pure code
.text:00002BCC ; Segment permissions: Read/Execute
.text:00002BCC _text           segment para public 'CODE' use32
.text:00002BCC                 assume cs:_text
.text:00002BCC                 ;org 2BCCh
.text:00002BCC ; COMDAT (pick any)
.text:00002BCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002BCC
.text:00002BCC ; =============== S U B R O U T I N E =======================================
.text:00002BCC
.text:00002BCC ; Attributes: bp-based frame
.text:00002BCC
.text:00002BCC ; public: class UString & __thiscall CObjectVector<class UString>::Front(void)
.text:00002BCC                 public ?Front@?$CObjectVector@VUString@@@@QAEAAVUString@@XZ
.text:00002BCC ?Front@?$CObjectVector@VUString@@@@QAEAAVUString@@XZ proc near
.text:00002BCC                                         ; CODE XREF: NWildcard::CCensorNode::AddItem(bool,NWildcard::CItem &,int)+61p
.text:00002BCC                                         ; NWildcard::CCensorNode::AddItem(bool,NWildcard::CItem &,int)+93p ...
.text:00002BCC
.text:00002BCC var_4           = dword ptr -4
.text:00002BCC
.text:00002BCC                 push    ebp
.text:00002BCD                 mov     ebp, esp
.text:00002BCF                 push    ecx
.text:00002BD0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002BD7                 mov     [ebp+var_4], ecx
.text:00002BDA                 push    0
.text:00002BDC                 mov     ecx, [ebp+var_4]
.text:00002BDF                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00002BE4                 add     esp, 4
.text:00002BE7                 cmp     ebp, esp
.text:00002BE9                 call    __RTC_CheckEsp
.text:00002BEE                 mov     esp, ebp
.text:00002BF0                 pop     ebp
.text:00002BF1                 retn
.text:00002BF1 ?Front@?$CObjectVector@VUString@@@@QAEAAVUString@@XZ endp
.text:00002BF1
.text:00002BF1 ; ---------------------------------------------------------------------------
.text:00002BF2                 align 4
.text:00002BF2 _text           ends
.text:00002BF2
.text:00002BF4 ; ===========================================================================
.text:00002BF4
.text:00002BF4 ; Segment type: Pure code
.text:00002BF4 ; Segment permissions: Read/Execute
.text:00002BF4 _text           segment para public 'CODE' use32
.text:00002BF4                 assume cs:_text
.text:00002BF4                 ;org 2BF4h
.text:00002BF4 ; COMDAT (pick any)
.text:00002BF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002BF4
.text:00002BF4 ; =============== S U B R O U T I N E =======================================
.text:00002BF4
.text:00002BF4 ; Attributes: bp-based frame
.text:00002BF4
.text:00002BF4 ; public: class UString & __thiscall CObjectVector<class UString>::Back(void)
.text:00002BF4                 public ?Back@?$CObjectVector@VUString@@@@QAEAAVUString@@XZ
.text:00002BF4 ?Back@?$CObjectVector@VUString@@@@QAEAAVUString@@XZ proc near
.text:00002BF4                                         ; CODE XREF: NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+87p
.text:00002BF4
.text:00002BF4 var_4           = dword ptr -4
.text:00002BF4
.text:00002BF4                 push    ebp
.text:00002BF5                 mov     ebp, esp
.text:00002BF7                 push    ecx
.text:00002BF8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002BFF                 mov     [ebp+var_4], ecx
.text:00002C02                 mov     ecx, [ebp+var_4]
.text:00002C05                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00002C0A                 sub     eax, 1
.text:00002C0D                 push    eax
.text:00002C0E                 mov     ecx, [ebp+var_4]
.text:00002C11                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00002C16                 add     esp, 4
.text:00002C19                 cmp     ebp, esp
.text:00002C1B                 call    __RTC_CheckEsp
.text:00002C20                 mov     esp, ebp
.text:00002C22                 pop     ebp
.text:00002C23                 retn
.text:00002C23 ?Back@?$CObjectVector@VUString@@@@QAEAAVUString@@XZ endp
.text:00002C23
.text:00002C23 _text           ends
.text:00002C23
.text:00002C24 ; ===========================================================================
.text:00002C24
.text:00002C24 ; Segment type: Pure code
.text:00002C24 ; Segment permissions: Read/Execute
.text:00002C24 _text           segment para public 'CODE' use32
.text:00002C24                 assume cs:_text
.text:00002C24                 ;org 2C24h
.text:00002C24 ; COMDAT (pick any)
.text:00002C24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002C24
.text:00002C24 ; =============== S U B R O U T I N E =======================================
.text:00002C24
.text:00002C24 ; Attributes: bp-based frame
.text:00002C24
.text:00002C24 ; public: unsigned int __thiscall CObjectVector<class UString>::Add(class UString const &)
.text:00002C24                 public ?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z
.text:00002C24 ?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z proc near
.text:00002C24                                         ; CODE XREF: SplitPathToParts(UString const &,CObjectVector<UString> &)+CFp
.text:00002C24                                         ; SplitPathToParts(UString const &,CObjectVector<UString> &)+102p ...
.text:00002C24
.text:00002C24 var_1C          = dword ptr -1Ch
.text:00002C24 var_18          = dword ptr -18h
.text:00002C24 var_14          = dword ptr -14h
.text:00002C24 var_10          = dword ptr -10h
.text:00002C24 var_C           = dword ptr -0Ch
.text:00002C24 var_4           = dword ptr -4
.text:00002C24 arg_0           = dword ptr  8
.text:00002C24
.text:00002C24                 push    ebp
.text:00002C25                 mov     ebp, esp
.text:00002C27                 push    0FFFFFFFFh
.text:00002C29                 push    offset __ehhandler$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z
.text:00002C2E                 mov     eax, large fs:0
.text:00002C34                 push    eax
.text:00002C35                 sub     esp, 10h
.text:00002C38                 mov     eax, 0CCCCCCCCh
.text:00002C3D                 mov     [ebp+var_1C], eax
.text:00002C40                 mov     [ebp+var_18], eax
.text:00002C43                 mov     [ebp+var_14], eax
.text:00002C46                 mov     [ebp+var_10], eax
.text:00002C49                 mov     eax, dword ptr ds:___security_cookie
.text:00002C4E                 xor     eax, ebp
.text:00002C50                 push    eax
.text:00002C51                 lea     eax, [ebp+var_C]
.text:00002C54                 mov     large fs:0, eax
.text:00002C5A                 mov     [ebp+var_10], ecx
.text:00002C5D                 push    0Ch             ; unsigned int
.text:00002C5F                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00002C64                 add     esp, 4
.text:00002C67                 mov     [ebp+var_18], eax
.text:00002C6A                 mov     [ebp+var_4], 0
.text:00002C71                 cmp     [ebp+var_18], 0
.text:00002C75                 jz      short loc_2C88
.text:00002C77                 mov     eax, [ebp+arg_0]
.text:00002C7A                 push    eax
.text:00002C7B                 mov     ecx, [ebp+var_18]
.text:00002C7E                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00002C83                 mov     [ebp+var_1C], eax
.text:00002C86                 jmp     short loc_2C8F
.text:00002C88 ; ---------------------------------------------------------------------------
.text:00002C88
.text:00002C88 loc_2C88:                               ; CODE XREF: CObjectVector<UString>::Add(UString const &)+51j
.text:00002C88                 mov     [ebp+var_1C], 0
.text:00002C8F
.text:00002C8F loc_2C8F:                               ; CODE XREF: CObjectVector<UString>::Add(UString const &)+62j
.text:00002C8F                 mov     ecx, [ebp+var_1C]
.text:00002C92                 mov     [ebp+var_14], ecx
.text:00002C95                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00002C9C                 mov     edx, [ebp+var_14]
.text:00002C9F                 push    edx
.text:00002CA0                 mov     ecx, [ebp+var_10]
.text:00002CA3                 call    ?Add@?$CRecordVector@PAX@@QAEIQAX@Z ; CRecordVector<void *>::Add(void * const)
.text:00002CA8                 mov     ecx, [ebp+var_C]
.text:00002CAB                 mov     large fs:0, ecx
.text:00002CB2                 pop     ecx
.text:00002CB3                 add     esp, 1Ch
.text:00002CB6                 cmp     ebp, esp
.text:00002CB8                 call    __RTC_CheckEsp
.text:00002CBD                 mov     esp, ebp
.text:00002CBF                 pop     ebp
.text:00002CC0                 retn    4
.text:00002CC0 ?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z endp
.text:00002CC0
.text:00002CC0 ; ---------------------------------------------------------------------------
.text:00002CC3                 align 4
.text:00002CC3 _text           ends
.text:00002CC3
.text$x:00002CC4 ; ===========================================================================
.text$x:00002CC4
.text$x:00002CC4 ; Segment type: Pure code
.text$x:00002CC4 ; Segment permissions: Read/Execute
.text$x:00002CC4 _text$x         segment para public 'CODE' use32
.text$x:00002CC4                 assume cs:_text$x
.text$x:00002CC4                 ;org 2CC4h
.text$x:00002CC4 ; COMDAT (pick associative to section at 2C24)
.text$x:00002CC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002CC4
.text$x:00002CC4 ; =============== S U B R O U T I N E =======================================
.text$x:00002CC4
.text$x:00002CC4
.text$x:00002CC4 __unwindfunclet$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z$0 proc near
.text$x:00002CC4                                         ; DATA XREF: .xdata$x:00002CF0o
.text$x:00002CC4                 mov     eax, [ebp-18h]
.text$x:00002CC7                 push    eax             ; void *
.text$x:00002CC8                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00002CCD                 pop     ecx
.text$x:00002CCE                 retn
.text$x:00002CCE __unwindfunclet$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z$0 endp
.text$x:00002CCE
.text$x:00002CCF
.text$x:00002CCF ; =============== S U B R O U T I N E =======================================
.text$x:00002CCF
.text$x:00002CCF
.text$x:00002CCF __ehhandler$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z proc near
.text$x:00002CCF                                         ; DATA XREF: CObjectVector<UString>::Add(UString const &)+5o
.text$x:00002CCF
.text$x:00002CCF arg_4           = dword ptr  8
.text$x:00002CCF
.text$x:00002CCF                 mov     edx, [esp+arg_4]
.text$x:00002CD3                 lea     eax, [edx+0Ch]
.text$x:00002CD6                 mov     ecx, [edx-14h]
.text$x:00002CD9                 xor     ecx, eax
.text$x:00002CDB                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002CE0                 mov     eax, offset __ehfuncinfo$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z
.text$x:00002CE5                 jmp     ___CxxFrameHandler3
.text$x:00002CE5 __ehhandler$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z endp
.text$x:00002CE5
.text$x:00002CE5 ; ---------------------------------------------------------------------------
.text$x:00002CEA                 align 4
.text$x:00002CEA _text$x         ends
.text$x:00002CEA
.xdata$x:00002CEC ; ===========================================================================
.xdata$x:00002CEC
.xdata$x:00002CEC ; Segment type: Pure data
.xdata$x:00002CEC ; Segment permissions: Read
.xdata$x:00002CEC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002CEC                 assume cs:_xdata$x
.xdata$x:00002CEC                 ;org 2CECh
.xdata$x:00002CEC ; COMDAT (pick associative to section at 2C24)
.xdata$x:00002CEC __unwindtable$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z db 0FFh
.xdata$x:00002CEC                                         ; DATA XREF: .xdata$x:00002CFCo
.xdata$x:00002CED                 db 0FFh
.xdata$x:00002CEE                 db 0FFh
.xdata$x:00002CEF                 db 0FFh
.xdata$x:00002CF0                 dd offset __unwindfunclet$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z$0
.xdata$x:00002CF4 __ehfuncinfo$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z db  22h ; "
.xdata$x:00002CF4                                         ; DATA XREF: __ehhandler$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z+11o
.xdata$x:00002CF5                 db    5
.xdata$x:00002CF6                 db  93h ; ô
.xdata$x:00002CF7                 db  19h
.xdata$x:00002CF8                 db    1
.xdata$x:00002CF9                 db    0
.xdata$x:00002CFA                 db    0
.xdata$x:00002CFB                 db    0
.xdata$x:00002CFC                 dd offset __unwindtable$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z
.xdata$x:00002D00                 db    0
.xdata$x:00002D01                 db    0
.xdata$x:00002D02                 db    0
.xdata$x:00002D03                 db    0
.xdata$x:00002D04                 db    0
.xdata$x:00002D05                 db    0
.xdata$x:00002D06                 db    0
.xdata$x:00002D07                 db    0
.xdata$x:00002D08                 db    0
.xdata$x:00002D09                 db    0
.xdata$x:00002D0A                 db    0
.xdata$x:00002D0B                 db    0
.xdata$x:00002D0C                 db    0
.xdata$x:00002D0D                 db    0
.xdata$x:00002D0E                 db    0
.xdata$x:00002D0F                 db    0
.xdata$x:00002D10                 db    0
.xdata$x:00002D11                 db    0
.xdata$x:00002D12                 db    0
.xdata$x:00002D13                 db    0
.xdata$x:00002D14                 db    1
.xdata$x:00002D15                 db    0
.xdata$x:00002D16                 db    0
.xdata$x:00002D17                 db    0
.xdata$x:00002D17 _xdata$x        ends
.xdata$x:00002D17
.text:00002D18 ; ===========================================================================
.text:00002D18
.text:00002D18 ; Segment type: Pure code
.text:00002D18 ; Segment permissions: Read/Execute
.text:00002D18 _text           segment para public 'CODE' use32
.text:00002D18                 assume cs:_text
.text:00002D18                 ;org 2D18h
.text:00002D18 ; COMDAT (pick any)
.text:00002D18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002D18
.text:00002D18 ; =============== S U B R O U T I N E =======================================
.text:00002D18
.text:00002D18 ; Attributes: bp-based frame
.text:00002D18
.text:00002D18 ; public: void __thiscall CObjectVector<class UString>::Insert(unsigned int, class UString const &)
.text:00002D18                 public ?Insert@?$CObjectVector@VUString@@@@QAEXIABVUString@@@Z
.text:00002D18 ?Insert@?$CObjectVector@VUString@@@@QAEXIABVUString@@@Z proc near
.text:00002D18                                         ; CODE XREF: NWildcard::CCensorNode::CheckPathToRoot(bool,CObjectVector<UString> &,bool)+47p
.text:00002D18
.text:00002D18 var_1C          = dword ptr -1Ch
.text:00002D18 var_18          = dword ptr -18h
.text:00002D18 var_14          = dword ptr -14h
.text:00002D18 var_10          = dword ptr -10h
.text:00002D18 var_C           = dword ptr -0Ch
.text:00002D18 var_4           = dword ptr -4
.text:00002D18 arg_0           = dword ptr  8
.text:00002D18 arg_4           = dword ptr  0Ch
.text:00002D18
.text:00002D18                 push    ebp
.text:00002D19                 mov     ebp, esp
.text:00002D1B                 push    0FFFFFFFFh
.text:00002D1D                 push    offset __ehhandler$?Insert@?$CObjectVector@VUString@@@@QAEXIABVUString@@@Z
.text:00002D22                 mov     eax, large fs:0
.text:00002D28                 push    eax
.text:00002D29                 sub     esp, 10h
.text:00002D2C                 mov     eax, 0CCCCCCCCh
.text:00002D31                 mov     [ebp+var_1C], eax
.text:00002D34                 mov     [ebp+var_18], eax
.text:00002D37                 mov     [ebp+var_14], eax
.text:00002D3A                 mov     [ebp+var_10], eax
.text:00002D3D                 mov     eax, dword ptr ds:___security_cookie
.text:00002D42                 xor     eax, ebp
.text:00002D44                 push    eax
.text:00002D45                 lea     eax, [ebp+var_C]
.text:00002D48                 mov     large fs:0, eax
.text:00002D4E                 mov     [ebp+var_10], ecx
.text:00002D51                 push    0Ch             ; unsigned int
.text:00002D53                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00002D58                 add     esp, 4
.text:00002D5B                 mov     [ebp+var_18], eax
.text:00002D5E                 mov     [ebp+var_4], 0
.text:00002D65                 cmp     [ebp+var_18], 0
.text:00002D69                 jz      short loc_2D7C
.text:00002D6B                 mov     eax, [ebp+arg_4]
.text:00002D6E                 push    eax
.text:00002D6F                 mov     ecx, [ebp+var_18]
.text:00002D72                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00002D77                 mov     [ebp+var_1C], eax
.text:00002D7A                 jmp     short loc_2D83
.text:00002D7C ; ---------------------------------------------------------------------------
.text:00002D7C
.text:00002D7C loc_2D7C:                               ; CODE XREF: CObjectVector<UString>::Insert(uint,UString const &)+51j
.text:00002D7C                 mov     [ebp+var_1C], 0
.text:00002D83
.text:00002D83 loc_2D83:                               ; CODE XREF: CObjectVector<UString>::Insert(uint,UString const &)+62j
.text:00002D83                 mov     ecx, [ebp+var_1C]
.text:00002D86                 mov     [ebp+var_14], ecx
.text:00002D89                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00002D90                 mov     edx, [ebp+var_14]
.text:00002D93                 push    edx
.text:00002D94                 mov     eax, [ebp+arg_0]
.text:00002D97                 push    eax
.text:00002D98                 mov     ecx, [ebp+var_10]
.text:00002D9B                 call    ?Insert@?$CRecordVector@PAX@@QAEXIQAX@Z ; CRecordVector<void *>::Insert(uint,void * const)
.text:00002DA0                 mov     ecx, [ebp+var_C]
.text:00002DA3                 mov     large fs:0, ecx
.text:00002DAA                 pop     ecx
.text:00002DAB                 add     esp, 1Ch
.text:00002DAE                 cmp     ebp, esp
.text:00002DB0                 call    __RTC_CheckEsp
.text:00002DB5                 mov     esp, ebp
.text:00002DB7                 pop     ebp
.text:00002DB8                 retn    8
.text:00002DB8 ?Insert@?$CObjectVector@VUString@@@@QAEXIABVUString@@@Z endp
.text:00002DB8
.text:00002DB8 ; ---------------------------------------------------------------------------
.text:00002DBB                 align 4
.text:00002DBB _text           ends
.text:00002DBB
.text$x:00002DBC ; ===========================================================================
.text$x:00002DBC
.text$x:00002DBC ; Segment type: Pure code
.text$x:00002DBC ; Segment permissions: Read/Execute
.text$x:00002DBC _text$x         segment para public 'CODE' use32
.text$x:00002DBC                 assume cs:_text$x
.text$x:00002DBC                 ;org 2DBCh
.text$x:00002DBC ; COMDAT (pick associative to section at 2D18)
.text$x:00002DBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002DBC
.text$x:00002DBC ; =============== S U B R O U T I N E =======================================
.text$x:00002DBC
.text$x:00002DBC
.text$x:00002DBC __unwindfunclet$?Insert@?$CObjectVector@VUString@@@@QAEXIABVUString@@@Z$0 proc near
.text$x:00002DBC                                         ; DATA XREF: .xdata$x:00002DE8o
.text$x:00002DBC                 mov     eax, [ebp-18h]
.text$x:00002DBF                 push    eax             ; void *
.text$x:00002DC0                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00002DC5                 pop     ecx
.text$x:00002DC6                 retn
.text$x:00002DC6 __unwindfunclet$?Insert@?$CObjectVector@VUString@@@@QAEXIABVUString@@@Z$0 endp
.text$x:00002DC6
.text$x:00002DC7
.text$x:00002DC7 ; =============== S U B R O U T I N E =======================================
.text$x:00002DC7
.text$x:00002DC7
.text$x:00002DC7 __ehhandler$?Insert@?$CObjectVector@VUString@@@@QAEXIABVUString@@@Z proc near
.text$x:00002DC7                                         ; DATA XREF: CObjectVector<UString>::Insert(uint,UString const &)+5o
.text$x:00002DC7
.text$x:00002DC7 arg_4           = dword ptr  8
.text$x:00002DC7
.text$x:00002DC7                 mov     edx, [esp+arg_4]
.text$x:00002DCB                 lea     eax, [edx+0Ch]
.text$x:00002DCE                 mov     ecx, [edx-14h]
.text$x:00002DD1                 xor     ecx, eax
.text$x:00002DD3                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002DD8                 mov     eax, offset __ehfuncinfo$?Insert@?$CObjectVector@VUString@@@@QAEXIABVUString@@@Z
.text$x:00002DDD                 jmp     ___CxxFrameHandler3
.text$x:00002DDD __ehhandler$?Insert@?$CObjectVector@VUString@@@@QAEXIABVUString@@@Z endp
.text$x:00002DDD
.text$x:00002DDD ; ---------------------------------------------------------------------------
.text$x:00002DE2                 align 4
.text$x:00002DE2 _text$x         ends
.text$x:00002DE2
.xdata$x:00002DE4 ; ===========================================================================
.xdata$x:00002DE4
.xdata$x:00002DE4 ; Segment type: Pure data
.xdata$x:00002DE4 ; Segment permissions: Read
.xdata$x:00002DE4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002DE4                 assume cs:_xdata$x
.xdata$x:00002DE4                 ;org 2DE4h
.xdata$x:00002DE4 ; COMDAT (pick associative to section at 2D18)
.xdata$x:00002DE4 __unwindtable$?Insert@?$CObjectVector@VUString@@@@QAEXIABVUString@@@Z db 0FFh
.xdata$x:00002DE4                                         ; DATA XREF: .xdata$x:00002DF4o
.xdata$x:00002DE5                 db 0FFh
.xdata$x:00002DE6                 db 0FFh
.xdata$x:00002DE7                 db 0FFh
.xdata$x:00002DE8                 dd offset __unwindfunclet$?Insert@?$CObjectVector@VUString@@@@QAEXIABVUString@@@Z$0
.xdata$x:00002DEC __ehfuncinfo$?Insert@?$CObjectVector@VUString@@@@QAEXIABVUString@@@Z db  22h ; "
.xdata$x:00002DEC                                         ; DATA XREF: __ehhandler$?Insert@?$CObjectVector@VUString@@@@QAEXIABVUString@@@Z+11o
.xdata$x:00002DED                 db    5
.xdata$x:00002DEE                 db  93h ; ô
.xdata$x:00002DEF                 db  19h
.xdata$x:00002DF0                 db    1
.xdata$x:00002DF1                 db    0
.xdata$x:00002DF2                 db    0
.xdata$x:00002DF3                 db    0
.xdata$x:00002DF4                 dd offset __unwindtable$?Insert@?$CObjectVector@VUString@@@@QAEXIABVUString@@@Z
.xdata$x:00002DF8                 db    0
.xdata$x:00002DF9                 db    0
.xdata$x:00002DFA                 db    0
.xdata$x:00002DFB                 db    0
.xdata$x:00002DFC                 db    0
.xdata$x:00002DFD                 db    0
.xdata$x:00002DFE                 db    0
.xdata$x:00002DFF                 db    0
.xdata$x:00002E00                 db    0
.xdata$x:00002E01                 db    0
.xdata$x:00002E02                 db    0
.xdata$x:00002E03                 db    0
.xdata$x:00002E04                 db    0
.xdata$x:00002E05                 db    0
.xdata$x:00002E06                 db    0
.xdata$x:00002E07                 db    0
.xdata$x:00002E08                 db    0
.xdata$x:00002E09                 db    0
.xdata$x:00002E0A                 db    0
.xdata$x:00002E0B                 db    0
.xdata$x:00002E0C                 db    1
.xdata$x:00002E0D                 db    0
.xdata$x:00002E0E                 db    0
.xdata$x:00002E0F                 db    0
.xdata$x:00002E0F _xdata$x        ends
.xdata$x:00002E0F
.text:00002E10 ; ===========================================================================
.text:00002E10
.text:00002E10 ; Segment type: Pure code
.text:00002E10 ; Segment permissions: Read/Execute
.text:00002E10 _text           segment para public 'CODE' use32
.text:00002E10                 assume cs:_text
.text:00002E10                 ;org 2E10h
.text:00002E10 ; COMDAT (pick any)
.text:00002E10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002E10
.text:00002E10 ; =============== S U B R O U T I N E =======================================
.text:00002E10
.text:00002E10 ; Attributes: bp-based frame
.text:00002E10
.text:00002E10 ; public: __thiscall CObjectVector<class UString>::~CObjectVector<class UString>(void)
.text:00002E10                 public ??1?$CObjectVector@VUString@@@@QAE@XZ
.text:00002E10 ??1?$CObjectVector@VUString@@@@QAE@XZ proc near
.text:00002E10                                         ; CODE XREF: NWildcard::CCensorNode::CheckPathVect(CObjectVector<UString> const &,bool,bool &)+10Fp
.text:00002E10                                         ; NWildcard::CCensorNode::CheckPathVect(CObjectVector<UString> const &,bool,bool &)+123p ...
.text:00002E10
.text:00002E10 var_20          = dword ptr -20h
.text:00002E10 var_1C          = dword ptr -1Ch
.text:00002E10 var_18          = dword ptr -18h
.text:00002E10 var_14          = dword ptr -14h
.text:00002E10 var_10          = dword ptr -10h
.text:00002E10 var_C           = dword ptr -0Ch
.text:00002E10 var_4           = dword ptr -4
.text:00002E10
.text:00002E10                 push    ebp
.text:00002E11                 mov     ebp, esp
.text:00002E13                 push    0FFFFFFFFh
.text:00002E15                 push    offset __ehhandler$??1?$CObjectVector@VUString@@@@QAE@XZ
.text:00002E1A                 mov     eax, large fs:0
.text:00002E20                 push    eax
.text:00002E21                 sub     esp, 14h
.text:00002E24                 mov     eax, 0CCCCCCCCh
.text:00002E29                 mov     [ebp+var_20], eax
.text:00002E2C                 mov     [ebp+var_1C], eax
.text:00002E2F                 mov     [ebp+var_18], eax
.text:00002E32                 mov     [ebp+var_14], eax
.text:00002E35                 mov     [ebp+var_10], eax
.text:00002E38                 mov     eax, dword ptr ds:___security_cookie
.text:00002E3D                 xor     eax, ebp
.text:00002E3F                 push    eax
.text:00002E40                 lea     eax, [ebp+var_C]
.text:00002E43                 mov     large fs:0, eax
.text:00002E49                 mov     [ebp+var_10], ecx
.text:00002E4C                 mov     [ebp+var_4], 0
.text:00002E53                 mov     ecx, [ebp+var_10]
.text:00002E56                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00002E5B                 mov     [ebp+var_14], eax
.text:00002E5E
.text:00002E5E loc_2E5E:                               ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void):loc_2EA0j
.text:00002E5E                 cmp     [ebp+var_14], 0
.text:00002E62                 jz      short loc_2EA2
.text:00002E64                 mov     eax, [ebp+var_14]
.text:00002E67                 sub     eax, 1
.text:00002E6A                 mov     [ebp+var_14], eax
.text:00002E6D                 mov     ecx, [ebp+var_14]
.text:00002E70                 push    ecx
.text:00002E71                 mov     ecx, [ebp+var_10]
.text:00002E74                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00002E79                 mov     edx, [eax]
.text:00002E7B                 mov     [ebp+var_1C], edx
.text:00002E7E                 mov     eax, [ebp+var_1C]
.text:00002E81                 mov     [ebp+var_18], eax
.text:00002E84                 cmp     [ebp+var_18], 0
.text:00002E88                 jz      short loc_2E99
.text:00002E8A                 push    1
.text:00002E8C                 mov     ecx, [ebp+var_18]
.text:00002E8F                 call    ??_GUString@@QAEPAXI@Z ; UString::`scalar deleting destructor'(uint)
.text:00002E94                 mov     [ebp+var_20], eax
.text:00002E97                 jmp     short loc_2EA0
.text:00002E99 ; ---------------------------------------------------------------------------
.text:00002E99
.text:00002E99 loc_2E99:                               ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+78j
.text:00002E99                 mov     [ebp+var_20], 0
.text:00002EA0
.text:00002EA0 loc_2EA0:                               ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+87j
.text:00002EA0                 jmp     short loc_2E5E
.text:00002EA2 ; ---------------------------------------------------------------------------
.text:00002EA2
.text:00002EA2 loc_2EA2:                               ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+52j
.text:00002EA2                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00002EA9                 mov     ecx, [ebp+var_10]
.text:00002EAC                 call    ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text:00002EB1                 mov     ecx, [ebp+var_C]
.text:00002EB4                 mov     large fs:0, ecx
.text:00002EBB                 pop     ecx
.text:00002EBC                 add     esp, 20h
.text:00002EBF                 cmp     ebp, esp
.text:00002EC1                 call    __RTC_CheckEsp
.text:00002EC6                 mov     esp, ebp
.text:00002EC8                 pop     ebp
.text:00002EC9                 retn
.text:00002EC9 ??1?$CObjectVector@VUString@@@@QAE@XZ endp
.text:00002EC9
.text:00002EC9 ; ---------------------------------------------------------------------------
.text:00002ECA                 align 4
.text:00002ECA _text           ends
.text:00002ECA
.text$x:00002ECC ; ===========================================================================
.text$x:00002ECC
.text$x:00002ECC ; Segment type: Pure code
.text$x:00002ECC ; Segment permissions: Read/Execute
.text$x:00002ECC _text$x         segment para public 'CODE' use32
.text$x:00002ECC                 assume cs:_text$x
.text$x:00002ECC                 ;org 2ECCh
.text$x:00002ECC ; COMDAT (pick associative to section at 2E10)
.text$x:00002ECC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002ECC
.text$x:00002ECC ; =============== S U B R O U T I N E =======================================
.text$x:00002ECC
.text$x:00002ECC
.text$x:00002ECC __unwindfunclet$??1?$CObjectVector@VUString@@@@QAE@XZ$0 proc near
.text$x:00002ECC                                         ; DATA XREF: .xdata$x:00002EF4o
.text$x:00002ECC                 mov     ecx, [ebp-10h]
.text$x:00002ECF                 jmp     ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text$x:00002ECF __unwindfunclet$??1?$CObjectVector@VUString@@@@QAE@XZ$0 endp
.text$x:00002ECF
.text$x:00002ED4
.text$x:00002ED4 ; =============== S U B R O U T I N E =======================================
.text$x:00002ED4
.text$x:00002ED4
.text$x:00002ED4 __ehhandler$??1?$CObjectVector@VUString@@@@QAE@XZ proc near
.text$x:00002ED4                                         ; DATA XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+5o
.text$x:00002ED4
.text$x:00002ED4 arg_4           = dword ptr  8
.text$x:00002ED4
.text$x:00002ED4                 mov     edx, [esp+arg_4]
.text$x:00002ED8                 lea     eax, [edx+0Ch]
.text$x:00002EDB                 mov     ecx, [edx-18h]
.text$x:00002EDE                 xor     ecx, eax
.text$x:00002EE0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002EE5                 mov     eax, offset __ehfuncinfo$??1?$CObjectVector@VUString@@@@QAE@XZ
.text$x:00002EEA                 jmp     ___CxxFrameHandler3
.text$x:00002EEA __ehhandler$??1?$CObjectVector@VUString@@@@QAE@XZ endp
.text$x:00002EEA
.text$x:00002EEA ; ---------------------------------------------------------------------------
.text$x:00002EEF                 align 10h
.text$x:00002EEF _text$x         ends
.text$x:00002EEF
.xdata$x:00002EF0 ; ===========================================================================
.xdata$x:00002EF0
.xdata$x:00002EF0 ; Segment type: Pure data
.xdata$x:00002EF0 ; Segment permissions: Read
.xdata$x:00002EF0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002EF0                 assume cs:_xdata$x
.xdata$x:00002EF0                 ;org 2EF0h
.xdata$x:00002EF0 ; COMDAT (pick associative to section at 2E10)
.xdata$x:00002EF0 __unwindtable$??1?$CObjectVector@VUString@@@@QAE@XZ db 0FFh
.xdata$x:00002EF0                                         ; DATA XREF: .xdata$x:00002F00o
.xdata$x:00002EF1                 db 0FFh
.xdata$x:00002EF2                 db 0FFh
.xdata$x:00002EF3                 db 0FFh
.xdata$x:00002EF4                 dd offset __unwindfunclet$??1?$CObjectVector@VUString@@@@QAE@XZ$0
.xdata$x:00002EF8 __ehfuncinfo$??1?$CObjectVector@VUString@@@@QAE@XZ db  22h ; "
.xdata$x:00002EF8                                         ; DATA XREF: __ehhandler$??1?$CObjectVector@VUString@@@@QAE@XZ+11o
.xdata$x:00002EF9                 db    5
.xdata$x:00002EFA                 db  93h ; ô
.xdata$x:00002EFB                 db  19h
.xdata$x:00002EFC                 db    1
.xdata$x:00002EFD                 db    0
.xdata$x:00002EFE                 db    0
.xdata$x:00002EFF                 db    0
.xdata$x:00002F00                 dd offset __unwindtable$??1?$CObjectVector@VUString@@@@QAE@XZ
.xdata$x:00002F04                 db    0
.xdata$x:00002F05                 db    0
.xdata$x:00002F06                 db    0
.xdata$x:00002F07                 db    0
.xdata$x:00002F08                 db    0
.xdata$x:00002F09                 db    0
.xdata$x:00002F0A                 db    0
.xdata$x:00002F0B                 db    0
.xdata$x:00002F0C                 db    0
.xdata$x:00002F0D                 db    0
.xdata$x:00002F0E                 db    0
.xdata$x:00002F0F                 db    0
.xdata$x:00002F10                 db    0
.xdata$x:00002F11                 db    0
.xdata$x:00002F12                 db    0
.xdata$x:00002F13                 db    0
.xdata$x:00002F14                 db    0
.xdata$x:00002F15                 db    0
.xdata$x:00002F16                 db    0
.xdata$x:00002F17                 db    0
.xdata$x:00002F18                 db    1
.xdata$x:00002F19                 db    0
.xdata$x:00002F1A                 db    0
.xdata$x:00002F1B                 db    0
.xdata$x:00002F1B _xdata$x        ends
.xdata$x:00002F1B
.text:00002F1C ; ===========================================================================
.text:00002F1C
.text:00002F1C ; Segment type: Pure code
.text:00002F1C ; Segment permissions: Read/Execute
.text:00002F1C _text           segment para public 'CODE' use32
.text:00002F1C                 assume cs:_text
.text:00002F1C                 ;org 2F1Ch
.text:00002F1C ; COMDAT (pick any)
.text:00002F1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002F1C
.text:00002F1C ; =============== S U B R O U T I N E =======================================
.text:00002F1C
.text:00002F1C ; Attributes: bp-based frame
.text:00002F1C
.text:00002F1C ; public: void __thiscall CObjectVector<class UString>::Clear(void)
.text:00002F1C                 public ?Clear@?$CObjectVector@VUString@@@@QAEXXZ
.text:00002F1C ?Clear@?$CObjectVector@VUString@@@@QAEXXZ proc near
.text:00002F1C                                         ; CODE XREF: SplitPathToParts(UString const &,CObjectVector<UString> &)+45p
.text:00002F1C                                         ; NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+318p ...
.text:00002F1C
.text:00002F1C var_14          = dword ptr -14h
.text:00002F1C var_10          = dword ptr -10h
.text:00002F1C var_C           = dword ptr -0Ch
.text:00002F1C var_8           = dword ptr -8
.text:00002F1C var_4           = dword ptr -4
.text:00002F1C
.text:00002F1C                 push    ebp
.text:00002F1D                 mov     ebp, esp
.text:00002F1F                 sub     esp, 14h
.text:00002F22                 mov     eax, 0CCCCCCCCh
.text:00002F27                 mov     [ebp+var_14], eax
.text:00002F2A                 mov     [ebp+var_10], eax
.text:00002F2D                 mov     [ebp+var_C], eax
.text:00002F30                 mov     [ebp+var_8], eax
.text:00002F33                 mov     [ebp+var_4], eax
.text:00002F36                 mov     [ebp+var_4], ecx
.text:00002F39                 mov     ecx, [ebp+var_4]
.text:00002F3C                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00002F41                 mov     [ebp+var_8], eax
.text:00002F44
.text:00002F44 loc_2F44:                               ; CODE XREF: CObjectVector<UString>::Clear(void):loc_2F86j
.text:00002F44                 cmp     [ebp+var_8], 0
.text:00002F48                 jz      short loc_2F88
.text:00002F4A                 mov     eax, [ebp+var_8]
.text:00002F4D                 sub     eax, 1
.text:00002F50                 mov     [ebp+var_8], eax
.text:00002F53                 mov     ecx, [ebp+var_8]
.text:00002F56                 push    ecx
.text:00002F57                 mov     ecx, [ebp+var_4]
.text:00002F5A                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00002F5F                 mov     edx, [eax]
.text:00002F61                 mov     [ebp+var_10], edx
.text:00002F64                 mov     eax, [ebp+var_10]
.text:00002F67                 mov     [ebp+var_C], eax
.text:00002F6A                 cmp     [ebp+var_C], 0
.text:00002F6E                 jz      short loc_2F7F
.text:00002F70                 push    1
.text:00002F72                 mov     ecx, [ebp+var_C]
.text:00002F75                 call    ??_GUString@@QAEPAXI@Z ; UString::`scalar deleting destructor'(uint)
.text:00002F7A                 mov     [ebp+var_14], eax
.text:00002F7D                 jmp     short loc_2F86
.text:00002F7F ; ---------------------------------------------------------------------------
.text:00002F7F
.text:00002F7F loc_2F7F:                               ; CODE XREF: CObjectVector<UString>::Clear(void)+52j
.text:00002F7F                 mov     [ebp+var_14], 0
.text:00002F86
.text:00002F86 loc_2F86:                               ; CODE XREF: CObjectVector<UString>::Clear(void)+61j
.text:00002F86                 jmp     short loc_2F44
.text:00002F88 ; ---------------------------------------------------------------------------
.text:00002F88
.text:00002F88 loc_2F88:                               ; CODE XREF: CObjectVector<UString>::Clear(void)+2Cj
.text:00002F88                 mov     ecx, [ebp+var_4]
.text:00002F8B                 call    ?Clear@?$CRecordVector@PAX@@QAEXXZ ; CRecordVector<void *>::Clear(void)
.text:00002F90                 add     esp, 14h
.text:00002F93                 cmp     ebp, esp
.text:00002F95                 call    __RTC_CheckEsp
.text:00002F9A                 mov     esp, ebp
.text:00002F9C                 pop     ebp
.text:00002F9D                 retn
.text:00002F9D ?Clear@?$CObjectVector@VUString@@@@QAEXXZ endp
.text:00002F9D
.text:00002F9D ; ---------------------------------------------------------------------------
.text:00002F9E                 align 10h
.text:00002F9E _text           ends
.text:00002F9E
.text:00002FA0 ; ===========================================================================
.text:00002FA0
.text:00002FA0 ; Segment type: Pure code
.text:00002FA0 ; Segment permissions: Read/Execute
.text:00002FA0 _text           segment para public 'CODE' use32
.text:00002FA0                 assume cs:_text
.text:00002FA0                 ;org 2FA0h
.text:00002FA0 ; COMDAT (pick any)
.text:00002FA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002FA0
.text:00002FA0 ; =============== S U B R O U T I N E =======================================
.text:00002FA0
.text:00002FA0 ; Attributes: bp-based frame
.text:00002FA0
.text:00002FA0 ; public: void __thiscall CObjectVector<class UString>::DeleteBack(void)
.text:00002FA0                 public ?DeleteBack@?$CObjectVector@VUString@@@@QAEXXZ
.text:00002FA0 ?DeleteBack@?$CObjectVector@VUString@@@@QAEXXZ proc near
.text:00002FA0                                         ; CODE XREF: NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+A1p
.text:00002FA0
.text:00002FA0 var_10          = dword ptr -10h
.text:00002FA0 var_C           = dword ptr -0Ch
.text:00002FA0 var_8           = dword ptr -8
.text:00002FA0 var_4           = dword ptr -4
.text:00002FA0
.text:00002FA0                 push    ebp
.text:00002FA1                 mov     ebp, esp
.text:00002FA3                 sub     esp, 10h
.text:00002FA6                 mov     eax, 0CCCCCCCCh
.text:00002FAB                 mov     [ebp+var_10], eax
.text:00002FAE                 mov     [ebp+var_C], eax
.text:00002FB1                 mov     [ebp+var_8], eax
.text:00002FB4                 mov     [ebp+var_4], eax
.text:00002FB7                 mov     [ebp+var_4], ecx
.text:00002FBA                 mov     ecx, [ebp+var_4]
.text:00002FBD                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00002FC2                 sub     eax, 1
.text:00002FC5                 push    eax
.text:00002FC6                 mov     ecx, [ebp+var_4]
.text:00002FC9                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00002FCE                 mov     eax, [eax]
.text:00002FD0                 mov     [ebp+var_C], eax
.text:00002FD3                 mov     ecx, [ebp+var_C]
.text:00002FD6                 mov     [ebp+var_8], ecx
.text:00002FD9                 cmp     [ebp+var_8], 0
.text:00002FDD                 jz      short loc_2FEE
.text:00002FDF                 push    1
.text:00002FE1                 mov     ecx, [ebp+var_8]
.text:00002FE4                 call    ??_GUString@@QAEPAXI@Z ; UString::`scalar deleting destructor'(uint)
.text:00002FE9                 mov     [ebp+var_10], eax
.text:00002FEC                 jmp     short loc_2FF5
.text:00002FEE ; ---------------------------------------------------------------------------
.text:00002FEE
.text:00002FEE loc_2FEE:                               ; CODE XREF: CObjectVector<UString>::DeleteBack(void)+3Dj
.text:00002FEE                 mov     [ebp+var_10], 0
.text:00002FF5
.text:00002FF5 loc_2FF5:                               ; CODE XREF: CObjectVector<UString>::DeleteBack(void)+4Cj
.text:00002FF5                 mov     ecx, [ebp+var_4]
.text:00002FF8                 call    ?DeleteBack@?$CRecordVector@PAX@@QAEXXZ ; CRecordVector<void *>::DeleteBack(void)
.text:00002FFD                 add     esp, 10h
.text:00003000                 cmp     ebp, esp
.text:00003002                 call    __RTC_CheckEsp
.text:00003007                 mov     esp, ebp
.text:00003009                 pop     ebp
.text:0000300A                 retn
.text:0000300A ?DeleteBack@?$CObjectVector@VUString@@@@QAEXXZ endp
.text:0000300A
.text:0000300A ; ---------------------------------------------------------------------------
.text:0000300B                 align 4
.text:0000300B _text           ends
.text:0000300B
.text:0000300C ; ===========================================================================
.text:0000300C
.text:0000300C ; Segment type: Pure code
.text:0000300C ; Segment permissions: Read/Execute
.text:0000300C _text           segment para public 'CODE' use32
.text:0000300C                 assume cs:_text
.text:0000300C                 ;org 300Ch
.text:0000300C ; COMDAT (pick any)
.text:0000300C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000300C
.text:0000300C ; =============== S U B R O U T I N E =======================================
.text:0000300C
.text:0000300C ; Attributes: bp-based frame
.text:0000300C
.text:0000300C ; public: void __thiscall CObjectVector<class UString>::Delete(unsigned int)
.text:0000300C                 public ?Delete@?$CObjectVector@VUString@@@@QAEXI@Z
.text:0000300C ?Delete@?$CObjectVector@VUString@@@@QAEXI@Z proc near
.text:0000300C                                         ; CODE XREF: NWildcard::CCensorNode::AddItem(bool,NWildcard::CItem &,int)+12Dp
.text:0000300C                                         ; NWildcard::CCensorNode::CheckPathVect(CObjectVector<UString> const &,bool,bool &)+D2p ...
.text:0000300C
.text:0000300C var_10          = dword ptr -10h
.text:0000300C var_C           = dword ptr -0Ch
.text:0000300C var_8           = dword ptr -8
.text:0000300C var_4           = dword ptr -4
.text:0000300C arg_0           = dword ptr  8
.text:0000300C
.text:0000300C                 push    ebp
.text:0000300D                 mov     ebp, esp
.text:0000300F                 sub     esp, 10h
.text:00003012                 mov     eax, 0CCCCCCCCh
.text:00003017                 mov     [ebp+var_10], eax
.text:0000301A                 mov     [ebp+var_C], eax
.text:0000301D                 mov     [ebp+var_8], eax
.text:00003020                 mov     [ebp+var_4], eax
.text:00003023                 mov     [ebp+var_4], ecx
.text:00003026                 mov     eax, [ebp+arg_0]
.text:00003029                 push    eax
.text:0000302A                 mov     ecx, [ebp+var_4]
.text:0000302D                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00003032                 mov     ecx, [eax]
.text:00003034                 mov     [ebp+var_C], ecx
.text:00003037                 mov     edx, [ebp+var_C]
.text:0000303A                 mov     [ebp+var_8], edx
.text:0000303D                 cmp     [ebp+var_8], 0
.text:00003041                 jz      short loc_3052
.text:00003043                 push    1
.text:00003045                 mov     ecx, [ebp+var_8]
.text:00003048                 call    ??_GUString@@QAEPAXI@Z ; UString::`scalar deleting destructor'(uint)
.text:0000304D                 mov     [ebp+var_10], eax
.text:00003050                 jmp     short loc_3059
.text:00003052 ; ---------------------------------------------------------------------------
.text:00003052
.text:00003052 loc_3052:                               ; CODE XREF: CObjectVector<UString>::Delete(uint)+35j
.text:00003052                 mov     [ebp+var_10], 0
.text:00003059
.text:00003059 loc_3059:                               ; CODE XREF: CObjectVector<UString>::Delete(uint)+44j
.text:00003059                 mov     eax, [ebp+arg_0]
.text:0000305C                 push    eax
.text:0000305D                 mov     ecx, [ebp+var_4]
.text:00003060                 call    ?Delete@?$CRecordVector@PAX@@QAEXI@Z ; CRecordVector<void *>::Delete(uint)
.text:00003065                 add     esp, 10h
.text:00003068                 cmp     ebp, esp
.text:0000306A                 call    __RTC_CheckEsp
.text:0000306F                 mov     esp, ebp
.text:00003071                 pop     ebp
.text:00003072                 retn    4
.text:00003072 ?Delete@?$CObjectVector@VUString@@@@QAEXI@Z endp
.text:00003072
.text:00003072 ; ---------------------------------------------------------------------------
.text:00003075                 align 4
.text:00003075 _text           ends
.text:00003075
.text:00003078 ; ===========================================================================
.text:00003078
.text:00003078 ; Segment type: Pure code
.text:00003078 ; Segment permissions: Read/Execute
.text:00003078 _text           segment para public 'CODE' use32
.text:00003078                 assume cs:_text
.text:00003078                 ;org 3078h
.text:00003078 ; COMDAT (pick any)
.text:00003078                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003078
.text:00003078 ; =============== S U B R O U T I N E =======================================
.text:00003078
.text:00003078 ; Attributes: bp-based frame
.text:00003078
.text:00003078 ; public: unsigned int __thiscall CObjectVector<class NWildcard::CCensorNode>::Size(void)const
.text:00003078                 public ?Size@?$CObjectVector@VCCensorNode@NWildcard@@@@QBEIXZ
.text:00003078 ?Size@?$CObjectVector@VCCensorNode@NWildcard@@@@QBEIXZ proc near
.text:00003078                                         ; CODE XREF: NWildcard::CCensorNode::FindSubNode(UString const &)+2Fp
.text:00003078                                         ; NWildcard::CCensorNode::AreThereIncludeItems(void)+42p ...
.text:00003078
.text:00003078 var_4           = dword ptr -4
.text:00003078
.text:00003078                 push    ebp
.text:00003079                 mov     ebp, esp
.text:0000307B                 push    ecx
.text:0000307C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003083                 mov     [ebp+var_4], ecx
.text:00003086                 mov     ecx, [ebp+var_4]
.text:00003089                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:0000308E                 add     esp, 4
.text:00003091                 cmp     ebp, esp
.text:00003093                 call    __RTC_CheckEsp
.text:00003098                 mov     esp, ebp
.text:0000309A                 pop     ebp
.text:0000309B                 retn
.text:0000309B ?Size@?$CObjectVector@VCCensorNode@NWildcard@@@@QBEIXZ endp
.text:0000309B
.text:0000309B _text           ends
.text:0000309B
.text:0000309C ; ===========================================================================
.text:0000309C
.text:0000309C ; Segment type: Pure code
.text:0000309C ; Segment permissions: Read/Execute
.text:0000309C _text           segment para public 'CODE' use32
.text:0000309C                 assume cs:_text
.text:0000309C                 ;org 309Ch
.text:0000309C ; COMDAT (pick any)
.text:0000309C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000309C
.text:0000309C ; =============== S U B R O U T I N E =======================================
.text:0000309C
.text:0000309C ; Attributes: bp-based frame
.text:0000309C
.text:0000309C ; public: bool __thiscall CObjectVector<class NWildcard::CCensorNode>::IsEmpty(void)const
.text:0000309C                 public ?IsEmpty@?$CObjectVector@VCCensorNode@NWildcard@@@@QBE_NXZ
.text:0000309C ?IsEmpty@?$CObjectVector@VCCensorNode@NWildcard@@@@QBE_NXZ proc near
.text:0000309C                                         ; CODE XREF: NWildcard::CCensorNode::AreAllAllowed(void)+26p
.text:0000309C
.text:0000309C var_4           = dword ptr -4
.text:0000309C
.text:0000309C                 push    ebp
.text:0000309D                 mov     ebp, esp
.text:0000309F                 push    ecx
.text:000030A0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000030A7                 mov     [ebp+var_4], ecx
.text:000030AA                 mov     ecx, [ebp+var_4]
.text:000030AD                 call    ?IsEmpty@?$CRecordVector@PAX@@QBE_NXZ ; CRecordVector<void *>::IsEmpty(void)
.text:000030B2                 add     esp, 4
.text:000030B5                 cmp     ebp, esp
.text:000030B7                 call    __RTC_CheckEsp
.text:000030BC                 mov     esp, ebp
.text:000030BE                 pop     ebp
.text:000030BF                 retn
.text:000030BF ?IsEmpty@?$CObjectVector@VCCensorNode@NWildcard@@@@QBE_NXZ endp
.text:000030BF
.text:000030BF _text           ends
.text:000030BF
.text:000030C0 ; ===========================================================================
.text:000030C0
.text:000030C0 ; Segment type: Pure code
.text:000030C0 ; Segment permissions: Read/Execute
.text:000030C0 _text           segment para public 'CODE' use32
.text:000030C0                 assume cs:_text
.text:000030C0                 ;org 30C0h
.text:000030C0 ; COMDAT (pick any)
.text:000030C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000030C0
.text:000030C0 ; =============== S U B R O U T I N E =======================================
.text:000030C0
.text:000030C0 ; Attributes: bp-based frame
.text:000030C0
.text:000030C0 ; public: __thiscall CObjectVector<class NWildcard::CCensorNode>::CObjectVector<class NWildcard::CCensorNode>(void)
.text:000030C0                 public ??0?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@XZ
.text:000030C0 ??0?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@XZ proc near
.text:000030C0                                         ; CODE XREF: NWildcard::CCensorNode::CCensorNode(UString const &,NWildcard::CCensorNode *)+51p
.text:000030C0                                         ; NWildcard::CCensorNode::CCensorNode(void)+4Ep
.text:000030C0
.text:000030C0 var_4           = dword ptr -4
.text:000030C0
.text:000030C0                 push    ebp
.text:000030C1                 mov     ebp, esp
.text:000030C3                 push    ecx
.text:000030C4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000030CB                 mov     [ebp+var_4], ecx
.text:000030CE                 mov     ecx, [ebp+var_4]
.text:000030D1                 call    ??0?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::CRecordVector<void *>(void)
.text:000030D6                 mov     eax, [ebp+var_4]
.text:000030D9                 add     esp, 4
.text:000030DC                 cmp     ebp, esp
.text:000030DE                 call    __RTC_CheckEsp
.text:000030E3                 mov     esp, ebp
.text:000030E5                 pop     ebp
.text:000030E6                 retn
.text:000030E6 ??0?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@XZ endp
.text:000030E6
.text:000030E6 ; ---------------------------------------------------------------------------
.text:000030E7                 align 4
.text:000030E7 _text           ends
.text:000030E7
.text:000030E8 ; ===========================================================================
.text:000030E8
.text:000030E8 ; Segment type: Pure code
.text:000030E8 ; Segment permissions: Read/Execute
.text:000030E8 _text           segment para public 'CODE' use32
.text:000030E8                 assume cs:_text
.text:000030E8                 ;org 30E8h
.text:000030E8 ; COMDAT (pick any)
.text:000030E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000030E8
.text:000030E8 ; =============== S U B R O U T I N E =======================================
.text:000030E8
.text:000030E8 ; Attributes: bp-based frame
.text:000030E8
.text:000030E8 ; public: class NWildcard::CCensorNode const & __thiscall CObjectVector<class NWildcard::CCensorNode>::operator[](unsigned int)const
.text:000030E8                 public ??A?$CObjectVector@VCCensorNode@NWildcard@@@@QBEABVCCensorNode@NWildcard@@I@Z
.text:000030E8 ??A?$CObjectVector@VCCensorNode@NWildcard@@@@QBEABVCCensorNode@NWildcard@@I@Z proc near
.text:000030E8                                         ; CODE XREF: NWildcard::CCensorNode::FindSubNode(UString const &)+4Cp
.text:000030E8                                         ; NWildcard::CCensorNode::AreThereIncludeItems(void)+56p ...
.text:000030E8
.text:000030E8 var_4           = dword ptr -4
.text:000030E8 arg_0           = dword ptr  8
.text:000030E8
.text:000030E8                 push    ebp
.text:000030E9                 mov     ebp, esp
.text:000030EB                 push    ecx
.text:000030EC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000030F3                 mov     [ebp+var_4], ecx
.text:000030F6                 mov     eax, [ebp+arg_0]
.text:000030F9                 push    eax
.text:000030FA                 mov     ecx, [ebp+var_4]
.text:000030FD                 call    ??A?$CRecordVector@PAX@@QBEABQAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00003102                 mov     eax, [eax]
.text:00003104                 add     esp, 4
.text:00003107                 cmp     ebp, esp
.text:00003109                 call    __RTC_CheckEsp
.text:0000310E                 mov     esp, ebp
.text:00003110                 pop     ebp
.text:00003111                 retn    4
.text:00003111 ??A?$CObjectVector@VCCensorNode@NWildcard@@@@QBEABVCCensorNode@NWildcard@@I@Z endp
.text:00003111
.text:00003111 _text           ends
.text:00003111
.text:00003114 ; ===========================================================================
.text:00003114
.text:00003114 ; Segment type: Pure code
.text:00003114 ; Segment permissions: Read/Execute
.text:00003114 _text           segment para public 'CODE' use32
.text:00003114                 assume cs:_text
.text:00003114                 ;org 3114h
.text:00003114 ; COMDAT (pick any)
.text:00003114                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003114
.text:00003114 ; =============== S U B R O U T I N E =======================================
.text:00003114
.text:00003114 ; Attributes: bp-based frame
.text:00003114
.text:00003114 ; public: class NWildcard::CCensorNode & __thiscall CObjectVector<class NWildcard::CCensorNode>::operator[](unsigned int)
.text:00003114                 public ??A?$CObjectVector@VCCensorNode@NWildcard@@@@QAEAAVCCensorNode@NWildcard@@I@Z
.text:00003114 ??A?$CObjectVector@VCCensorNode@NWildcard@@@@QAEAAVCCensorNode@NWildcard@@I@Z proc near
.text:00003114                                         ; CODE XREF: NWildcard::CCensorNode::AddItem(bool,NWildcard::CItem &,int)+14Cp
.text:00003114                                         ; NWildcard::CCensorNode::ExtendExclude(NWildcard::CCensorNode const &)+EEp
.text:00003114
.text:00003114 var_4           = dword ptr -4
.text:00003114 arg_0           = dword ptr  8
.text:00003114
.text:00003114                 push    ebp
.text:00003115                 mov     ebp, esp
.text:00003117                 push    ecx
.text:00003118                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000311F                 mov     [ebp+var_4], ecx
.text:00003122                 mov     eax, [ebp+arg_0]
.text:00003125                 push    eax
.text:00003126                 mov     ecx, [ebp+var_4]
.text:00003129                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:0000312E                 mov     eax, [eax]
.text:00003130                 add     esp, 4
.text:00003133                 cmp     ebp, esp
.text:00003135                 call    __RTC_CheckEsp
.text:0000313A                 mov     esp, ebp
.text:0000313C                 pop     ebp
.text:0000313D                 retn    4
.text:0000313D ??A?$CObjectVector@VCCensorNode@NWildcard@@@@QAEAAVCCensorNode@NWildcard@@I@Z endp
.text:0000313D
.text:0000313D _text           ends
.text:0000313D
.text:00003140 ; ===========================================================================
.text:00003140
.text:00003140 ; Segment type: Pure code
.text:00003140 ; Segment permissions: Read/Execute
.text:00003140 _text           segment para public 'CODE' use32
.text:00003140                 assume cs:_text
.text:00003140                 ;org 3140h
.text:00003140 ; COMDAT (pick any)
.text:00003140                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003140
.text:00003140 ; =============== S U B R O U T I N E =======================================
.text:00003140
.text:00003140 ; Attributes: bp-based frame
.text:00003140
.text:00003140 ; public: unsigned int __thiscall CObjectVector<class NWildcard::CCensorNode>::Add(class NWildcard::CCensorNode const &)
.text:00003140                 public ?Add@?$CObjectVector@VCCensorNode@NWildcard@@@@QAEIABVCCensorNode@NWildcard@@@Z
.text:00003140 ?Add@?$CObjectVector@VCCensorNode@NWildcard@@@@QAEIABVCCensorNode@NWildcard@@@Z proc near
.text:00003140                                         ; CODE XREF: NWildcard::CCensorNode::AddItem(bool,NWildcard::CItem &,int)+111p
.text:00003140                                         ; NWildcard::CCensorNode::ExtendExclude(NWildcard::CCensorNode const &)+C9p
.text:00003140
.text:00003140 var_1C          = dword ptr -1Ch
.text:00003140 var_18          = dword ptr -18h
.text:00003140 var_14          = dword ptr -14h
.text:00003140 var_10          = dword ptr -10h
.text:00003140 var_C           = dword ptr -0Ch
.text:00003140 var_4           = dword ptr -4
.text:00003140 arg_0           = dword ptr  8
.text:00003140
.text:00003140                 push    ebp
.text:00003141                 mov     ebp, esp
.text:00003143                 push    0FFFFFFFFh
.text:00003145                 push    offset __ehhandler$?Add@?$CObjectVector@VCCensorNode@NWildcard@@@@QAEIABVCCensorNode@NWildcard@@@Z
.text:0000314A                 mov     eax, large fs:0
.text:00003150                 push    eax
.text:00003151                 sub     esp, 10h
.text:00003154                 mov     eax, 0CCCCCCCCh
.text:00003159                 mov     [ebp+var_1C], eax
.text:0000315C                 mov     [ebp+var_18], eax
.text:0000315F                 mov     [ebp+var_14], eax
.text:00003162                 mov     [ebp+var_10], eax
.text:00003165                 mov     eax, dword ptr ds:___security_cookie
.text:0000316A                 xor     eax, ebp
.text:0000316C                 push    eax
.text:0000316D                 lea     eax, [ebp+var_C]
.text:00003170                 mov     large fs:0, eax
.text:00003176                 mov     [ebp+var_10], ecx
.text:00003179                 push    34h ; '4'       ; unsigned int
.text:0000317B                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00003180                 add     esp, 4
.text:00003183                 mov     [ebp+var_18], eax
.text:00003186                 mov     [ebp+var_4], 0
.text:0000318D                 cmp     [ebp+var_18], 0
.text:00003191                 jz      short loc_31A4
.text:00003193                 mov     eax, [ebp+arg_0]
.text:00003196                 push    eax             ; struct NWildcard::CCensorNode *
.text:00003197                 mov     ecx, [ebp+var_18] ; this
.text:0000319A                 call    ??0CCensorNode@NWildcard@@QAE@ABV01@@Z ; NWildcard::CCensorNode::CCensorNode(NWildcard::CCensorNode const &)
.text:0000319F                 mov     [ebp+var_1C], eax
.text:000031A2                 jmp     short loc_31AB
.text:000031A4 ; ---------------------------------------------------------------------------
.text:000031A4
.text:000031A4 loc_31A4:                               ; CODE XREF: CObjectVector<NWildcard::CCensorNode>::Add(NWildcard::CCensorNode const &)+51j
.text:000031A4                 mov     [ebp+var_1C], 0
.text:000031AB
.text:000031AB loc_31AB:                               ; CODE XREF: CObjectVector<NWildcard::CCensorNode>::Add(NWildcard::CCensorNode const &)+62j
.text:000031AB                 mov     ecx, [ebp+var_1C]
.text:000031AE                 mov     [ebp+var_14], ecx
.text:000031B1                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000031B8                 mov     edx, [ebp+var_14]
.text:000031BB                 push    edx
.text:000031BC                 mov     ecx, [ebp+var_10]
.text:000031BF                 call    ?Add@?$CRecordVector@PAX@@QAEIQAX@Z ; CRecordVector<void *>::Add(void * const)
.text:000031C4                 mov     ecx, [ebp+var_C]
.text:000031C7                 mov     large fs:0, ecx
.text:000031CE                 pop     ecx
.text:000031CF                 add     esp, 1Ch
.text:000031D2                 cmp     ebp, esp
.text:000031D4                 call    __RTC_CheckEsp
.text:000031D9                 mov     esp, ebp
.text:000031DB                 pop     ebp
.text:000031DC                 retn    4
.text:000031DC ?Add@?$CObjectVector@VCCensorNode@NWildcard@@@@QAEIABVCCensorNode@NWildcard@@@Z endp
.text:000031DC
.text:000031DC ; ---------------------------------------------------------------------------
.text:000031DF                 align 10h
.text:000031DF _text           ends
.text:000031DF
.text$x:000031E0 ; ===========================================================================
.text$x:000031E0
.text$x:000031E0 ; Segment type: Pure code
.text$x:000031E0 ; Segment permissions: Read/Execute
.text$x:000031E0 _text$x         segment para public 'CODE' use32
.text$x:000031E0                 assume cs:_text$x
.text$x:000031E0                 ;org 31E0h
.text$x:000031E0 ; COMDAT (pick associative to section at 3140)
.text$x:000031E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000031E0
.text$x:000031E0 ; =============== S U B R O U T I N E =======================================
.text$x:000031E0
.text$x:000031E0
.text$x:000031E0 __unwindfunclet$?Add@?$CObjectVector@VCCensorNode@NWildcard@@@@QAEIABVCCensorNode@NWildcard@@@Z$0 proc near
.text$x:000031E0                                         ; DATA XREF: .xdata$x:0000320Co
.text$x:000031E0                 mov     eax, [ebp-18h]
.text$x:000031E3                 push    eax             ; void *
.text$x:000031E4                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:000031E9                 pop     ecx
.text$x:000031EA                 retn
.text$x:000031EA __unwindfunclet$?Add@?$CObjectVector@VCCensorNode@NWildcard@@@@QAEIABVCCensorNode@NWildcard@@@Z$0 endp
.text$x:000031EA
.text$x:000031EB
.text$x:000031EB ; =============== S U B R O U T I N E =======================================
.text$x:000031EB
.text$x:000031EB
.text$x:000031EB __ehhandler$?Add@?$CObjectVector@VCCensorNode@NWildcard@@@@QAEIABVCCensorNode@NWildcard@@@Z proc near
.text$x:000031EB                                         ; DATA XREF: CObjectVector<NWildcard::CCensorNode>::Add(NWildcard::CCensorNode const &)+5o
.text$x:000031EB
.text$x:000031EB arg_4           = dword ptr  8
.text$x:000031EB
.text$x:000031EB                 mov     edx, [esp+arg_4]
.text$x:000031EF                 lea     eax, [edx+0Ch]
.text$x:000031F2                 mov     ecx, [edx-14h]
.text$x:000031F5                 xor     ecx, eax
.text$x:000031F7                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000031FC                 mov     eax, offset __ehfuncinfo$?Add@?$CObjectVector@VCCensorNode@NWildcard@@@@QAEIABVCCensorNode@NWildcard@@@Z
.text$x:00003201                 jmp     ___CxxFrameHandler3
.text$x:00003201 __ehhandler$?Add@?$CObjectVector@VCCensorNode@NWildcard@@@@QAEIABVCCensorNode@NWildcard@@@Z endp
.text$x:00003201
.text$x:00003201 ; ---------------------------------------------------------------------------
.text$x:00003206                 align 4
.text$x:00003206 _text$x         ends
.text$x:00003206
.xdata$x:00003208 ; ===========================================================================
.xdata$x:00003208
.xdata$x:00003208 ; Segment type: Pure data
.xdata$x:00003208 ; Segment permissions: Read
.xdata$x:00003208 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003208                 assume cs:_xdata$x
.xdata$x:00003208                 ;org 3208h
.xdata$x:00003208 ; COMDAT (pick associative to section at 3140)
.xdata$x:00003208 __unwindtable$?Add@?$CObjectVector@VCCensorNode@NWildcard@@@@QAEIABVCCensorNode@NWildcard@@@Z db 0FFh
.xdata$x:00003208                                         ; DATA XREF: .xdata$x:00003218o
.xdata$x:00003209                 db 0FFh
.xdata$x:0000320A                 db 0FFh
.xdata$x:0000320B                 db 0FFh
.xdata$x:0000320C                 dd offset __unwindfunclet$?Add@?$CObjectVector@VCCensorNode@NWildcard@@@@QAEIABVCCensorNode@NWildcard@@@Z$0
.xdata$x:00003210 __ehfuncinfo$?Add@?$CObjectVector@VCCensorNode@NWildcard@@@@QAEIABVCCensorNode@NWildcard@@@Z db  22h ; "
.xdata$x:00003210                                         ; DATA XREF: __ehhandler$?Add@?$CObjectVector@VCCensorNode@NWildcard@@@@QAEIABVCCensorNode@NWildcard@@@Z+11o
.xdata$x:00003211                 db    5
.xdata$x:00003212                 db  93h ; ô
.xdata$x:00003213                 db  19h
.xdata$x:00003214                 db    1
.xdata$x:00003215                 db    0
.xdata$x:00003216                 db    0
.xdata$x:00003217                 db    0
.xdata$x:00003218                 dd offset __unwindtable$?Add@?$CObjectVector@VCCensorNode@NWildcard@@@@QAEIABVCCensorNode@NWildcard@@@Z
.xdata$x:0000321C                 db    0
.xdata$x:0000321D                 db    0
.xdata$x:0000321E                 db    0
.xdata$x:0000321F                 db    0
.xdata$x:00003220                 db    0
.xdata$x:00003221                 db    0
.xdata$x:00003222                 db    0
.xdata$x:00003223                 db    0
.xdata$x:00003224                 db    0
.xdata$x:00003225                 db    0
.xdata$x:00003226                 db    0
.xdata$x:00003227                 db    0
.xdata$x:00003228                 db    0
.xdata$x:00003229                 db    0
.xdata$x:0000322A                 db    0
.xdata$x:0000322B                 db    0
.xdata$x:0000322C                 db    0
.xdata$x:0000322D                 db    0
.xdata$x:0000322E                 db    0
.xdata$x:0000322F                 db    0
.xdata$x:00003230                 db    1
.xdata$x:00003231                 db    0
.xdata$x:00003232                 db    0
.xdata$x:00003233                 db    0
.xdata$x:00003233 _xdata$x        ends
.xdata$x:00003233
.text:00003234 ; ===========================================================================
.text:00003234
.text:00003234 ; Segment type: Pure code
.text:00003234 ; Segment permissions: Read/Execute
.text:00003234 _text           segment para public 'CODE' use32
.text:00003234                 assume cs:_text
.text:00003234                 ;org 3234h
.text:00003234 ; COMDAT (pick any)
.text:00003234                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003234
.text:00003234 ; =============== S U B R O U T I N E =======================================
.text:00003234
.text:00003234 ; Attributes: bp-based frame
.text:00003234
.text:00003234 ; public: __thiscall CObjectVector<class NWildcard::CCensorNode>::~CObjectVector<class NWildcard::CCensorNode>(void)
.text:00003234                 public ??1?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@XZ
.text:00003234 ??1?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@XZ proc near
.text:00003234                                         ; CODE XREF: __unwindfunclet$??0CCensorNode@NWildcard@@QAE@ABVUString@@PAV01@@Z$1+6j
.text:00003234                                         ; NWildcard::CCensorNode::~CCensorNode(void)+58p ...
.text:00003234
.text:00003234 var_20          = dword ptr -20h
.text:00003234 var_1C          = dword ptr -1Ch
.text:00003234 var_18          = dword ptr -18h
.text:00003234 var_14          = dword ptr -14h
.text:00003234 var_10          = dword ptr -10h
.text:00003234 var_C           = dword ptr -0Ch
.text:00003234 var_4           = dword ptr -4
.text:00003234
.text:00003234                 push    ebp
.text:00003235                 mov     ebp, esp
.text:00003237                 push    0FFFFFFFFh
.text:00003239                 push    offset __ehhandler$??1?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@XZ
.text:0000323E                 mov     eax, large fs:0
.text:00003244                 push    eax
.text:00003245                 sub     esp, 14h
.text:00003248                 mov     eax, 0CCCCCCCCh
.text:0000324D                 mov     [ebp+var_20], eax
.text:00003250                 mov     [ebp+var_1C], eax
.text:00003253                 mov     [ebp+var_18], eax
.text:00003256                 mov     [ebp+var_14], eax
.text:00003259                 mov     [ebp+var_10], eax
.text:0000325C                 mov     eax, dword ptr ds:___security_cookie
.text:00003261                 xor     eax, ebp
.text:00003263                 push    eax
.text:00003264                 lea     eax, [ebp+var_C]
.text:00003267                 mov     large fs:0, eax
.text:0000326D                 mov     [ebp+var_10], ecx
.text:00003270                 mov     [ebp+var_4], 0
.text:00003277                 mov     ecx, [ebp+var_10]
.text:0000327A                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:0000327F                 mov     [ebp+var_14], eax
.text:00003282
.text:00003282 loc_3282:                               ; CODE XREF: CObjectVector<NWildcard::CCensorNode>::~CObjectVector<NWildcard::CCensorNode>(void):loc_32C4j
.text:00003282                 cmp     [ebp+var_14], 0
.text:00003286                 jz      short loc_32C6
.text:00003288                 mov     eax, [ebp+var_14]
.text:0000328B                 sub     eax, 1
.text:0000328E                 mov     [ebp+var_14], eax
.text:00003291                 mov     ecx, [ebp+var_14]
.text:00003294                 push    ecx
.text:00003295                 mov     ecx, [ebp+var_10]
.text:00003298                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:0000329D                 mov     edx, [eax]
.text:0000329F                 mov     [ebp+var_1C], edx
.text:000032A2                 mov     eax, [ebp+var_1C]
.text:000032A5                 mov     [ebp+var_18], eax
.text:000032A8                 cmp     [ebp+var_18], 0
.text:000032AC                 jz      short loc_32BD
.text:000032AE                 push    1
.text:000032B0                 mov     ecx, [ebp+var_18]
.text:000032B3                 call    ??_GCCensorNode@NWildcard@@QAEPAXI@Z ; NWildcard::CCensorNode::`scalar deleting destructor'(uint)
.text:000032B8                 mov     [ebp+var_20], eax
.text:000032BB                 jmp     short loc_32C4
.text:000032BD ; ---------------------------------------------------------------------------
.text:000032BD
.text:000032BD loc_32BD:                               ; CODE XREF: CObjectVector<NWildcard::CCensorNode>::~CObjectVector<NWildcard::CCensorNode>(void)+78j
.text:000032BD                 mov     [ebp+var_20], 0
.text:000032C4
.text:000032C4 loc_32C4:                               ; CODE XREF: CObjectVector<NWildcard::CCensorNode>::~CObjectVector<NWildcard::CCensorNode>(void)+87j
.text:000032C4                 jmp     short loc_3282
.text:000032C6 ; ---------------------------------------------------------------------------
.text:000032C6
.text:000032C6 loc_32C6:                               ; CODE XREF: CObjectVector<NWildcard::CCensorNode>::~CObjectVector<NWildcard::CCensorNode>(void)+52j
.text:000032C6                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000032CD                 mov     ecx, [ebp+var_10]
.text:000032D0                 call    ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text:000032D5                 mov     ecx, [ebp+var_C]
.text:000032D8                 mov     large fs:0, ecx
.text:000032DF                 pop     ecx
.text:000032E0                 add     esp, 20h
.text:000032E3                 cmp     ebp, esp
.text:000032E5                 call    __RTC_CheckEsp
.text:000032EA                 mov     esp, ebp
.text:000032EC                 pop     ebp
.text:000032ED                 retn
.text:000032ED ??1?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@XZ endp
.text:000032ED
.text:000032ED ; ---------------------------------------------------------------------------
.text:000032EE                 align 10h
.text:000032EE _text           ends
.text:000032EE
.text$x:000032F0 ; ===========================================================================
.text$x:000032F0
.text$x:000032F0 ; Segment type: Pure code
.text$x:000032F0 ; Segment permissions: Read/Execute
.text$x:000032F0 _text$x         segment para public 'CODE' use32
.text$x:000032F0                 assume cs:_text$x
.text$x:000032F0                 ;org 32F0h
.text$x:000032F0 ; COMDAT (pick associative to section at 3234)
.text$x:000032F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000032F0
.text$x:000032F0 ; =============== S U B R O U T I N E =======================================
.text$x:000032F0
.text$x:000032F0
.text$x:000032F0 __unwindfunclet$??1?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@XZ$0 proc near
.text$x:000032F0                                         ; DATA XREF: .xdata$x:00003318o
.text$x:000032F0                 mov     ecx, [ebp-10h]
.text$x:000032F3                 jmp     ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text$x:000032F3 __unwindfunclet$??1?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@XZ$0 endp
.text$x:000032F3
.text$x:000032F8
.text$x:000032F8 ; =============== S U B R O U T I N E =======================================
.text$x:000032F8
.text$x:000032F8
.text$x:000032F8 __ehhandler$??1?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@XZ proc near
.text$x:000032F8                                         ; DATA XREF: CObjectVector<NWildcard::CCensorNode>::~CObjectVector<NWildcard::CCensorNode>(void)+5o
.text$x:000032F8
.text$x:000032F8 arg_4           = dword ptr  8
.text$x:000032F8
.text$x:000032F8                 mov     edx, [esp+arg_4]
.text$x:000032FC                 lea     eax, [edx+0Ch]
.text$x:000032FF                 mov     ecx, [edx-18h]
.text$x:00003302                 xor     ecx, eax
.text$x:00003304                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003309                 mov     eax, offset __ehfuncinfo$??1?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@XZ
.text$x:0000330E                 jmp     ___CxxFrameHandler3
.text$x:0000330E __ehhandler$??1?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@XZ endp
.text$x:0000330E
.text$x:0000330E ; ---------------------------------------------------------------------------
.text$x:00003313                 align 4
.text$x:00003313 _text$x         ends
.text$x:00003313
.xdata$x:00003314 ; ===========================================================================
.xdata$x:00003314
.xdata$x:00003314 ; Segment type: Pure data
.xdata$x:00003314 ; Segment permissions: Read
.xdata$x:00003314 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003314                 assume cs:_xdata$x
.xdata$x:00003314                 ;org 3314h
.xdata$x:00003314 ; COMDAT (pick associative to section at 3234)
.xdata$x:00003314 __unwindtable$??1?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@XZ db 0FFh
.xdata$x:00003314                                         ; DATA XREF: .xdata$x:00003324o
.xdata$x:00003315                 db 0FFh
.xdata$x:00003316                 db 0FFh
.xdata$x:00003317                 db 0FFh
.xdata$x:00003318                 dd offset __unwindfunclet$??1?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@XZ$0
.xdata$x:0000331C __ehfuncinfo$??1?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@XZ db  22h ; "
.xdata$x:0000331C                                         ; DATA XREF: __ehhandler$??1?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@XZ+11o
.xdata$x:0000331D                 db    5
.xdata$x:0000331E                 db  93h ; ô
.xdata$x:0000331F                 db  19h
.xdata$x:00003320                 db    1
.xdata$x:00003321                 db    0
.xdata$x:00003322                 db    0
.xdata$x:00003323                 db    0
.xdata$x:00003324                 dd offset __unwindtable$??1?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@XZ
.xdata$x:00003328                 db    0
.xdata$x:00003329                 db    0
.xdata$x:0000332A                 db    0
.xdata$x:0000332B                 db    0
.xdata$x:0000332C                 db    0
.xdata$x:0000332D                 db    0
.xdata$x:0000332E                 db    0
.xdata$x:0000332F                 db    0
.xdata$x:00003330                 db    0
.xdata$x:00003331                 db    0
.xdata$x:00003332                 db    0
.xdata$x:00003333                 db    0
.xdata$x:00003334                 db    0
.xdata$x:00003335                 db    0
.xdata$x:00003336                 db    0
.xdata$x:00003337                 db    0
.xdata$x:00003338                 db    0
.xdata$x:00003339                 db    0
.xdata$x:0000333A                 db    0
.xdata$x:0000333B                 db    0
.xdata$x:0000333C                 db    1
.xdata$x:0000333D                 db    0
.xdata$x:0000333E                 db    0
.xdata$x:0000333F                 db    0
.xdata$x:0000333F _xdata$x        ends
.xdata$x:0000333F
.text:00003340 ; ===========================================================================
.text:00003340
.text:00003340 ; Segment type: Pure code
.text:00003340 ; Segment permissions: Read/Execute
.text:00003340 _text           segment para public 'CODE' use32
.text:00003340                 assume cs:_text
.text:00003340                 ;org 3340h
.text:00003340 ; COMDAT (pick any)
.text:00003340                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003340
.text:00003340 ; =============== S U B R O U T I N E =======================================
.text:00003340
.text:00003340 ; Attributes: bp-based frame
.text:00003340
.text:00003340 ; public: unsigned int __thiscall CObjectVector<struct NWildcard::CItem>::Size(void)const
.text:00003340                 public ?Size@?$CObjectVector@UCItem@NWildcard@@@@QBEIXZ
.text:00003340 ?Size@?$CObjectVector@UCItem@NWildcard@@@@QBEIXZ proc near
.text:00003340                                         ; CODE XREF: NWildcard::CCensorNode::AreAllAllowed(void)+4Ap
.text:00003340                                         ; NWildcard::CCensorNode::NeedCheckSubDirs(void)+36p ...
.text:00003340
.text:00003340 var_4           = dword ptr -4
.text:00003340
.text:00003340                 push    ebp
.text:00003341                 mov     ebp, esp
.text:00003343                 push    ecx
.text:00003344                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000334B                 mov     [ebp+var_4], ecx
.text:0000334E                 mov     ecx, [ebp+var_4]
.text:00003351                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00003356                 add     esp, 4
.text:00003359                 cmp     ebp, esp
.text:0000335B                 call    __RTC_CheckEsp
.text:00003360                 mov     esp, ebp
.text:00003362                 pop     ebp
.text:00003363                 retn
.text:00003363 ?Size@?$CObjectVector@UCItem@NWildcard@@@@QBEIXZ endp
.text:00003363
.text:00003363 _text           ends
.text:00003363
.text:00003364 ; ===========================================================================
.text:00003364
.text:00003364 ; Segment type: Pure code
.text:00003364 ; Segment permissions: Read/Execute
.text:00003364 _text           segment para public 'CODE' use32
.text:00003364                 assume cs:_text
.text:00003364                 ;org 3364h
.text:00003364 ; COMDAT (pick any)
.text:00003364                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003364
.text:00003364 ; =============== S U B R O U T I N E =======================================
.text:00003364
.text:00003364 ; Attributes: bp-based frame
.text:00003364
.text:00003364 ; public: bool __thiscall CObjectVector<struct NWildcard::CItem>::IsEmpty(void)const
.text:00003364                 public ?IsEmpty@?$CObjectVector@UCItem@NWildcard@@@@QBE_NXZ
.text:00003364 ?IsEmpty@?$CObjectVector@UCItem@NWildcard@@@@QBE_NXZ proc near
.text:00003364                                         ; CODE XREF: NWildcard::CCensorNode::AreAllAllowed(void)+38p
.text:00003364
.text:00003364 var_4           = dword ptr -4
.text:00003364
.text:00003364                 push    ebp
.text:00003365                 mov     ebp, esp
.text:00003367                 push    ecx
.text:00003368                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000336F                 mov     [ebp+var_4], ecx
.text:00003372                 mov     ecx, [ebp+var_4]
.text:00003375                 call    ?IsEmpty@?$CRecordVector@PAX@@QBE_NXZ ; CRecordVector<void *>::IsEmpty(void)
.text:0000337A                 add     esp, 4
.text:0000337D                 cmp     ebp, esp
.text:0000337F                 call    __RTC_CheckEsp
.text:00003384                 mov     esp, ebp
.text:00003386                 pop     ebp
.text:00003387                 retn
.text:00003387 ?IsEmpty@?$CObjectVector@UCItem@NWildcard@@@@QBE_NXZ endp
.text:00003387
.text:00003387 _text           ends
.text:00003387
.text:00003388 ; ===========================================================================
.text:00003388
.text:00003388 ; Segment type: Pure code
.text:00003388 ; Segment permissions: Read/Execute
.text:00003388 _text           segment para public 'CODE' use32
.text:00003388                 assume cs:_text
.text:00003388                 ;org 3388h
.text:00003388 ; COMDAT (pick any)
.text:00003388                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003388
.text:00003388 ; =============== S U B R O U T I N E =======================================
.text:00003388
.text:00003388 ; Attributes: bp-based frame
.text:00003388
.text:00003388 ; public: __thiscall CObjectVector<struct NWildcard::CItem>::CObjectVector<struct NWildcard::CItem>(void)
.text:00003388                 public ??0?$CObjectVector@UCItem@NWildcard@@@@QAE@XZ
.text:00003388 ??0?$CObjectVector@UCItem@NWildcard@@@@QAE@XZ proc near
.text:00003388                                         ; CODE XREF: NWildcard::CCensorNode::CCensorNode(UString const &,NWildcard::CCensorNode *)+60p
.text:00003388                                         ; NWildcard::CCensorNode::CCensorNode(UString const &,NWildcard::CCensorNode *)+6Fp ...
.text:00003388
.text:00003388 var_4           = dword ptr -4
.text:00003388
.text:00003388                 push    ebp
.text:00003389                 mov     ebp, esp
.text:0000338B                 push    ecx
.text:0000338C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003393                 mov     [ebp+var_4], ecx
.text:00003396                 mov     ecx, [ebp+var_4]
.text:00003399                 call    ??0?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::CRecordVector<void *>(void)
.text:0000339E                 mov     eax, [ebp+var_4]
.text:000033A1                 add     esp, 4
.text:000033A4                 cmp     ebp, esp
.text:000033A6                 call    __RTC_CheckEsp
.text:000033AB                 mov     esp, ebp
.text:000033AD                 pop     ebp
.text:000033AE                 retn
.text:000033AE ??0?$CObjectVector@UCItem@NWildcard@@@@QAE@XZ endp
.text:000033AE
.text:000033AE ; ---------------------------------------------------------------------------
.text:000033AF                 align 10h
.text:000033AF _text           ends
.text:000033AF
.text:000033B0 ; ===========================================================================
.text:000033B0
.text:000033B0 ; Segment type: Pure code
.text:000033B0 ; Segment permissions: Read/Execute
.text:000033B0 _text           segment para public 'CODE' use32
.text:000033B0                 assume cs:_text
.text:000033B0                 ;org 33B0h
.text:000033B0 ; COMDAT (pick any)
.text:000033B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000033B0
.text:000033B0 ; =============== S U B R O U T I N E =======================================
.text:000033B0
.text:000033B0 ; Attributes: bp-based frame
.text:000033B0
.text:000033B0 ; public: class CObjectVector<struct NWildcard::CItem> & __thiscall CObjectVector<struct NWildcard::CItem>::operator+=(class CObjectVector<struct NWildcard::CItem> const &)
.text:000033B0                 public ??Y?$CObjectVector@UCItem@NWildcard@@@@QAEAAV0@ABV0@@Z
.text:000033B0 ??Y?$CObjectVector@UCItem@NWildcard@@@@QAEAAV0@ABV0@@Z proc near
.text:000033B0                                         ; CODE XREF: NWildcard::CCensorNode::ExtendExclude(NWildcard::CCensorNode const &)+47p
.text:000033B0
.text:000033B0 var_24          = dword ptr -24h
.text:000033B0 var_20          = dword ptr -20h
.text:000033B0 var_1C          = dword ptr -1Ch
.text:000033B0 var_18          = dword ptr -18h
.text:000033B0 var_14          = dword ptr -14h
.text:000033B0 var_10          = dword ptr -10h
.text:000033B0 var_C           = dword ptr -0Ch
.text:000033B0 var_4           = dword ptr -4
.text:000033B0 arg_0           = dword ptr  8
.text:000033B0
.text:000033B0                 push    ebp
.text:000033B1                 mov     ebp, esp
.text:000033B3                 push    0FFFFFFFFh
.text:000033B5                 push    offset __ehhandler$??Y?$CObjectVector@UCItem@NWildcard@@@@QAEAAV0@ABV0@@Z
.text:000033BA                 mov     eax, large fs:0
.text:000033C0                 push    eax
.text:000033C1                 sub     esp, 18h
.text:000033C4                 mov     eax, 0CCCCCCCCh
.text:000033C9                 mov     [ebp+var_24], eax
.text:000033CC                 mov     [ebp+var_20], eax
.text:000033CF                 mov     [ebp+var_1C], eax
.text:000033D2                 mov     [ebp+var_18], eax
.text:000033D5                 mov     [ebp+var_14], eax
.text:000033D8                 mov     [ebp+var_10], eax
.text:000033DB                 mov     eax, dword ptr ds:___security_cookie
.text:000033E0                 xor     eax, ebp
.text:000033E2                 push    eax
.text:000033E3                 lea     eax, [ebp+var_C]
.text:000033E6                 mov     large fs:0, eax
.text:000033EC                 mov     [ebp+var_10], ecx
.text:000033EF                 mov     ecx, [ebp+arg_0]
.text:000033F2                 call    ?Size@?$CObjectVector@UCItem@NWildcard@@@@QBEIXZ ; CObjectVector<NWildcard::CItem>::Size(void)
.text:000033F7                 mov     [ebp+var_14], eax
.text:000033FA                 mov     ecx, [ebp+var_10]
.text:000033FD                 call    ?Size@?$CObjectVector@UCItem@NWildcard@@@@QBEIXZ ; CObjectVector<NWildcard::CItem>::Size(void)
.text:00003402                 add     eax, [ebp+var_14]
.text:00003405                 push    eax
.text:00003406                 mov     ecx, [ebp+var_10]
.text:00003409                 call    ?Reserve@?$CRecordVector@PAX@@QAEXI@Z ; CRecordVector<void *>::Reserve(uint)
.text:0000340E                 mov     [ebp+var_18], 0
.text:00003415                 jmp     short loc_3420
.text:00003417 ; ---------------------------------------------------------------------------
.text:00003417
.text:00003417 loc_3417:                               ; CODE XREF: CObjectVector<NWildcard::CItem>::operator+=(CObjectVector<NWildcard::CItem> const &)+CCj
.text:00003417                 mov     eax, [ebp+var_18]
.text:0000341A                 add     eax, 1
.text:0000341D                 mov     [ebp+var_18], eax
.text:00003420
.text:00003420 loc_3420:                               ; CODE XREF: CObjectVector<NWildcard::CItem>::operator+=(CObjectVector<NWildcard::CItem> const &)+65j
.text:00003420                 mov     ecx, [ebp+var_18]
.text:00003423                 cmp     ecx, [ebp+var_14]
.text:00003426                 jnb     short loc_347E
.text:00003428                 push    10h             ; unsigned int
.text:0000342A                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0000342F                 add     esp, 4
.text:00003432                 mov     [ebp+var_20], eax
.text:00003435                 mov     [ebp+var_4], 0
.text:0000343C                 cmp     [ebp+var_20], 0
.text:00003440                 jz      short loc_345C
.text:00003442                 mov     edx, [ebp+var_18]
.text:00003445                 push    edx
.text:00003446                 mov     ecx, [ebp+arg_0]
.text:00003449                 call    ??A?$CObjectVector@UCItem@NWildcard@@@@QBEABUCItem@NWildcard@@I@Z ; CObjectVector<NWildcard::CItem>::operator[](uint)
.text:0000344E                 push    eax             ; struct NWildcard::CItem *
.text:0000344F                 mov     ecx, [ebp+var_20] ; this
.text:00003452                 call    ??0CItem@NWildcard@@QAE@ABU01@@Z ; NWildcard::CItem::CItem(NWildcard::CItem const &)
.text:00003457                 mov     [ebp+var_24], eax
.text:0000345A                 jmp     short loc_3463
.text:0000345C ; ---------------------------------------------------------------------------
.text:0000345C
.text:0000345C loc_345C:                               ; CODE XREF: CObjectVector<NWildcard::CItem>::operator+=(CObjectVector<NWildcard::CItem> const &)+90j
.text:0000345C                 mov     [ebp+var_24], 0
.text:00003463
.text:00003463 loc_3463:                               ; CODE XREF: CObjectVector<NWildcard::CItem>::operator+=(CObjectVector<NWildcard::CItem> const &)+AAj
.text:00003463                 mov     eax, [ebp+var_24]
.text:00003466                 mov     [ebp+var_1C], eax
.text:00003469                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00003470                 mov     ecx, [ebp+var_1C]
.text:00003473                 push    ecx
.text:00003474                 mov     ecx, [ebp+var_10]
.text:00003477                 call    ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z ; CRecordVector<void *>::AddInReserved(void * const)
.text:0000347C                 jmp     short loc_3417
.text:0000347E ; ---------------------------------------------------------------------------
.text:0000347E
.text:0000347E loc_347E:                               ; CODE XREF: CObjectVector<NWildcard::CItem>::operator+=(CObjectVector<NWildcard::CItem> const &)+76j
.text:0000347E                 mov     eax, [ebp+var_10]
.text:00003481                 mov     ecx, [ebp+var_C]
.text:00003484                 mov     large fs:0, ecx
.text:0000348B                 pop     ecx
.text:0000348C                 add     esp, 24h
.text:0000348F                 cmp     ebp, esp
.text:00003491                 call    __RTC_CheckEsp
.text:00003496                 mov     esp, ebp
.text:00003498                 pop     ebp
.text:00003499                 retn    4
.text:00003499 ??Y?$CObjectVector@UCItem@NWildcard@@@@QAEAAV0@ABV0@@Z endp
.text:00003499
.text:00003499 _text           ends
.text:00003499
.text$x:0000349C ; ===========================================================================
.text$x:0000349C
.text$x:0000349C ; Segment type: Pure code
.text$x:0000349C ; Segment permissions: Read/Execute
.text$x:0000349C _text$x         segment para public 'CODE' use32
.text$x:0000349C                 assume cs:_text$x
.text$x:0000349C                 ;org 349Ch
.text$x:0000349C ; COMDAT (pick associative to section at 33B0)
.text$x:0000349C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000349C
.text$x:0000349C ; =============== S U B R O U T I N E =======================================
.text$x:0000349C
.text$x:0000349C
.text$x:0000349C __unwindfunclet$??Y?$CObjectVector@UCItem@NWildcard@@@@QAEAAV0@ABV0@@Z$0 proc near
.text$x:0000349C                                         ; DATA XREF: .xdata$x:000034C8o
.text$x:0000349C                 mov     eax, [ebp-20h]
.text$x:0000349F                 push    eax             ; void *
.text$x:000034A0                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:000034A5                 pop     ecx
.text$x:000034A6                 retn
.text$x:000034A6 __unwindfunclet$??Y?$CObjectVector@UCItem@NWildcard@@@@QAEAAV0@ABV0@@Z$0 endp
.text$x:000034A6
.text$x:000034A7
.text$x:000034A7 ; =============== S U B R O U T I N E =======================================
.text$x:000034A7
.text$x:000034A7
.text$x:000034A7 __ehhandler$??Y?$CObjectVector@UCItem@NWildcard@@@@QAEAAV0@ABV0@@Z proc near
.text$x:000034A7                                         ; DATA XREF: CObjectVector<NWildcard::CItem>::operator+=(CObjectVector<NWildcard::CItem> const &)+5o
.text$x:000034A7
.text$x:000034A7 arg_4           = dword ptr  8
.text$x:000034A7
.text$x:000034A7                 mov     edx, [esp+arg_4]
.text$x:000034AB                 lea     eax, [edx+0Ch]
.text$x:000034AE                 mov     ecx, [edx-1Ch]
.text$x:000034B1                 xor     ecx, eax
.text$x:000034B3                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000034B8                 mov     eax, offset __ehfuncinfo$??Y?$CObjectVector@UCItem@NWildcard@@@@QAEAAV0@ABV0@@Z
.text$x:000034BD                 jmp     ___CxxFrameHandler3
.text$x:000034BD __ehhandler$??Y?$CObjectVector@UCItem@NWildcard@@@@QAEAAV0@ABV0@@Z endp
.text$x:000034BD
.text$x:000034BD ; ---------------------------------------------------------------------------
.text$x:000034C2                 align 4
.text$x:000034C2 _text$x         ends
.text$x:000034C2
.xdata$x:000034C4 ; ===========================================================================
.xdata$x:000034C4
.xdata$x:000034C4 ; Segment type: Pure data
.xdata$x:000034C4 ; Segment permissions: Read
.xdata$x:000034C4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000034C4                 assume cs:_xdata$x
.xdata$x:000034C4                 ;org 34C4h
.xdata$x:000034C4 ; COMDAT (pick associative to section at 33B0)
.xdata$x:000034C4 __unwindtable$??Y?$CObjectVector@UCItem@NWildcard@@@@QAEAAV0@ABV0@@Z db 0FFh
.xdata$x:000034C4                                         ; DATA XREF: .xdata$x:000034D4o
.xdata$x:000034C5                 db 0FFh
.xdata$x:000034C6                 db 0FFh
.xdata$x:000034C7                 db 0FFh
.xdata$x:000034C8                 dd offset __unwindfunclet$??Y?$CObjectVector@UCItem@NWildcard@@@@QAEAAV0@ABV0@@Z$0
.xdata$x:000034CC __ehfuncinfo$??Y?$CObjectVector@UCItem@NWildcard@@@@QAEAAV0@ABV0@@Z db  22h ; "
.xdata$x:000034CC                                         ; DATA XREF: __ehhandler$??Y?$CObjectVector@UCItem@NWildcard@@@@QAEAAV0@ABV0@@Z+11o
.xdata$x:000034CD                 db    5
.xdata$x:000034CE                 db  93h ; ô
.xdata$x:000034CF                 db  19h
.xdata$x:000034D0                 db    1
.xdata$x:000034D1                 db    0
.xdata$x:000034D2                 db    0
.xdata$x:000034D3                 db    0
.xdata$x:000034D4                 dd offset __unwindtable$??Y?$CObjectVector@UCItem@NWildcard@@@@QAEAAV0@ABV0@@Z
.xdata$x:000034D8                 db    0
.xdata$x:000034D9                 db    0
.xdata$x:000034DA                 db    0
.xdata$x:000034DB                 db    0
.xdata$x:000034DC                 db    0
.xdata$x:000034DD                 db    0
.xdata$x:000034DE                 db    0
.xdata$x:000034DF                 db    0
.xdata$x:000034E0                 db    0
.xdata$x:000034E1                 db    0
.xdata$x:000034E2                 db    0
.xdata$x:000034E3                 db    0
.xdata$x:000034E4                 db    0
.xdata$x:000034E5                 db    0
.xdata$x:000034E6                 db    0
.xdata$x:000034E7                 db    0
.xdata$x:000034E8                 db    0
.xdata$x:000034E9                 db    0
.xdata$x:000034EA                 db    0
.xdata$x:000034EB                 db    0
.xdata$x:000034EC                 db    1
.xdata$x:000034ED                 db    0
.xdata$x:000034EE                 db    0
.xdata$x:000034EF                 db    0
.xdata$x:000034EF _xdata$x        ends
.xdata$x:000034EF
.text:000034F0 ; ===========================================================================
.text:000034F0
.text:000034F0 ; Segment type: Pure code
.text:000034F0 ; Segment permissions: Read/Execute
.text:000034F0 _text           segment para public 'CODE' use32
.text:000034F0                 assume cs:_text
.text:000034F0                 ;org 34F0h
.text:000034F0 ; COMDAT (pick any)
.text:000034F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000034F0
.text:000034F0 ; =============== S U B R O U T I N E =======================================
.text:000034F0
.text:000034F0 ; Attributes: bp-based frame
.text:000034F0
.text:000034F0 ; public: struct NWildcard::CItem const & __thiscall CObjectVector<struct NWildcard::CItem>::operator[](unsigned int)const
.text:000034F0                 public ??A?$CObjectVector@UCItem@NWildcard@@@@QBEABUCItem@NWildcard@@I@Z
.text:000034F0 ??A?$CObjectVector@UCItem@NWildcard@@@@QBEABUCItem@NWildcard@@I@Z proc near
.text:000034F0                                         ; CODE XREF: NWildcard::CCensorNode::NeedCheckSubDirs(void)+4Ap
.text:000034F0                                         ; NWildcard::CCensorNode::CheckPathCurrent(bool,CObjectVector<UString> const &,bool)+74p ...
.text:000034F0
.text:000034F0 var_4           = dword ptr -4
.text:000034F0 arg_0           = dword ptr  8
.text:000034F0
.text:000034F0                 push    ebp
.text:000034F1                 mov     ebp, esp
.text:000034F3                 push    ecx
.text:000034F4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000034FB                 mov     [ebp+var_4], ecx
.text:000034FE                 mov     eax, [ebp+arg_0]
.text:00003501                 push    eax
.text:00003502                 mov     ecx, [ebp+var_4]
.text:00003505                 call    ??A?$CRecordVector@PAX@@QBEABQAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:0000350A                 mov     eax, [eax]
.text:0000350C                 add     esp, 4
.text:0000350F                 cmp     ebp, esp
.text:00003511                 call    __RTC_CheckEsp
.text:00003516                 mov     esp, ebp
.text:00003518                 pop     ebp
.text:00003519                 retn    4
.text:00003519 ??A?$CObjectVector@UCItem@NWildcard@@@@QBEABUCItem@NWildcard@@I@Z endp
.text:00003519
.text:00003519 _text           ends
.text:00003519
.text:0000351C ; ===========================================================================
.text:0000351C
.text:0000351C ; Segment type: Pure code
.text:0000351C ; Segment permissions: Read/Execute
.text:0000351C _text           segment para public 'CODE' use32
.text:0000351C                 assume cs:_text
.text:0000351C                 ;org 351Ch
.text:0000351C ; COMDAT (pick any)
.text:0000351C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000351C
.text:0000351C ; =============== S U B R O U T I N E =======================================
.text:0000351C
.text:0000351C ; Attributes: bp-based frame
.text:0000351C
.text:0000351C ; public: struct NWildcard::CItem const & __thiscall CObjectVector<struct NWildcard::CItem>::Front(void)const
.text:0000351C                 public ?Front@?$CObjectVector@UCItem@NWildcard@@@@QBEABUCItem@NWildcard@@XZ
.text:0000351C ?Front@?$CObjectVector@UCItem@NWildcard@@@@QBEABUCItem@NWildcard@@XZ proc near
.text:0000351C                                         ; CODE XREF: NWildcard::CCensorNode::AreAllAllowed(void)+5Ep
.text:0000351C
.text:0000351C var_4           = dword ptr -4
.text:0000351C
.text:0000351C                 push    ebp
.text:0000351D                 mov     ebp, esp
.text:0000351F                 push    ecx
.text:00003520                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003527                 mov     [ebp+var_4], ecx
.text:0000352A                 push    0
.text:0000352C                 mov     ecx, [ebp+var_4]
.text:0000352F                 call    ??A?$CObjectVector@UCItem@NWildcard@@@@QBEABUCItem@NWildcard@@I@Z ; CObjectVector<NWildcard::CItem>::operator[](uint)
.text:00003534                 add     esp, 4
.text:00003537                 cmp     ebp, esp
.text:00003539                 call    __RTC_CheckEsp
.text:0000353E                 mov     esp, ebp
.text:00003540                 pop     ebp
.text:00003541                 retn
.text:00003541 ?Front@?$CObjectVector@UCItem@NWildcard@@@@QBEABUCItem@NWildcard@@XZ endp
.text:00003541
.text:00003541 ; ---------------------------------------------------------------------------
.text:00003542                 align 4
.text:00003542 _text           ends
.text:00003542
.text:00003544 ; ===========================================================================
.text:00003544
.text:00003544 ; Segment type: Pure code
.text:00003544 ; Segment permissions: Read/Execute
.text:00003544 _text           segment para public 'CODE' use32
.text:00003544                 assume cs:_text
.text:00003544                 ;org 3544h
.text:00003544 ; COMDAT (pick any)
.text:00003544                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003544
.text:00003544 ; =============== S U B R O U T I N E =======================================
.text:00003544
.text:00003544 ; Attributes: bp-based frame
.text:00003544
.text:00003544 ; int __stdcall CObjectVector<NWildcard::CItem>::Add(struct NWildcard::CItem *)
.text:00003544                 public ?Add@?$CObjectVector@UCItem@NWildcard@@@@QAEIABUCItem@NWildcard@@@Z
.text:00003544 ?Add@?$CObjectVector@UCItem@NWildcard@@@@QAEIABUCItem@NWildcard@@@Z proc near
.text:00003544                                         ; CODE XREF: NWildcard::CCensorNode::AddItemSimple(bool,NWildcard::CItem &)+20p
.text:00003544                                         ; NWildcard::CCensorNode::AddItemSimple(bool,NWildcard::CItem &)+31p
.text:00003544
.text:00003544 var_1C          = dword ptr -1Ch
.text:00003544 var_18          = dword ptr -18h
.text:00003544 var_14          = dword ptr -14h
.text:00003544 var_10          = dword ptr -10h
.text:00003544 var_C           = dword ptr -0Ch
.text:00003544 var_4           = dword ptr -4
.text:00003544 arg_0           = dword ptr  8
.text:00003544
.text:00003544                 push    ebp
.text:00003545                 mov     ebp, esp
.text:00003547                 push    0FFFFFFFFh
.text:00003549                 push    offset __ehhandler$?Add@?$CObjectVector@UCItem@NWildcard@@@@QAEIABUCItem@NWildcard@@@Z
.text:0000354E                 mov     eax, large fs:0
.text:00003554                 push    eax
.text:00003555                 sub     esp, 10h
.text:00003558                 mov     eax, 0CCCCCCCCh
.text:0000355D                 mov     [ebp+var_1C], eax
.text:00003560                 mov     [ebp+var_18], eax
.text:00003563                 mov     [ebp+var_14], eax
.text:00003566                 mov     [ebp+var_10], eax
.text:00003569                 mov     eax, dword ptr ds:___security_cookie
.text:0000356E                 xor     eax, ebp
.text:00003570                 push    eax
.text:00003571                 lea     eax, [ebp+var_C]
.text:00003574                 mov     large fs:0, eax
.text:0000357A                 mov     [ebp+var_10], ecx
.text:0000357D                 push    10h             ; unsigned int
.text:0000357F                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00003584                 add     esp, 4
.text:00003587                 mov     [ebp+var_18], eax
.text:0000358A                 mov     [ebp+var_4], 0
.text:00003591                 cmp     [ebp+var_18], 0
.text:00003595                 jz      short loc_35A8
.text:00003597                 mov     eax, [ebp+arg_0]
.text:0000359A                 push    eax             ; struct NWildcard::CItem *
.text:0000359B                 mov     ecx, [ebp+var_18] ; this
.text:0000359E                 call    ??0CItem@NWildcard@@QAE@ABU01@@Z ; NWildcard::CItem::CItem(NWildcard::CItem const &)
.text:000035A3                 mov     [ebp+var_1C], eax
.text:000035A6                 jmp     short loc_35AF
.text:000035A8 ; ---------------------------------------------------------------------------
.text:000035A8
.text:000035A8 loc_35A8:                               ; CODE XREF: CObjectVector<NWildcard::CItem>::Add(NWildcard::CItem const &)+51j
.text:000035A8                 mov     [ebp+var_1C], 0
.text:000035AF
.text:000035AF loc_35AF:                               ; CODE XREF: CObjectVector<NWildcard::CItem>::Add(NWildcard::CItem const &)+62j
.text:000035AF                 mov     ecx, [ebp+var_1C]
.text:000035B2                 mov     [ebp+var_14], ecx
.text:000035B5                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000035BC                 mov     edx, [ebp+var_14]
.text:000035BF                 push    edx
.text:000035C0                 mov     ecx, [ebp+var_10]
.text:000035C3                 call    ?Add@?$CRecordVector@PAX@@QAEIQAX@Z ; CRecordVector<void *>::Add(void * const)
.text:000035C8                 mov     ecx, [ebp+var_C]
.text:000035CB                 mov     large fs:0, ecx
.text:000035D2                 pop     ecx
.text:000035D3                 add     esp, 1Ch
.text:000035D6                 cmp     ebp, esp
.text:000035D8                 call    __RTC_CheckEsp
.text:000035DD                 mov     esp, ebp
.text:000035DF                 pop     ebp
.text:000035E0                 retn    4
.text:000035E0 ?Add@?$CObjectVector@UCItem@NWildcard@@@@QAEIABUCItem@NWildcard@@@Z endp
.text:000035E0
.text:000035E0 ; ---------------------------------------------------------------------------
.text:000035E3                 align 4
.text:000035E3 _text           ends
.text:000035E3
.text$x:000035E4 ; ===========================================================================
.text$x:000035E4
.text$x:000035E4 ; Segment type: Pure code
.text$x:000035E4 ; Segment permissions: Read/Execute
.text$x:000035E4 _text$x         segment para public 'CODE' use32
.text$x:000035E4                 assume cs:_text$x
.text$x:000035E4                 ;org 35E4h
.text$x:000035E4 ; COMDAT (pick associative to section at 3544)
.text$x:000035E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000035E4
.text$x:000035E4 ; =============== S U B R O U T I N E =======================================
.text$x:000035E4
.text$x:000035E4
.text$x:000035E4 __unwindfunclet$?Add@?$CObjectVector@UCItem@NWildcard@@@@QAEIABUCItem@NWildcard@@@Z$0 proc near
.text$x:000035E4                                         ; DATA XREF: .xdata$x:00003610o
.text$x:000035E4                 mov     eax, [ebp-18h]
.text$x:000035E7                 push    eax             ; void *
.text$x:000035E8                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:000035ED                 pop     ecx
.text$x:000035EE                 retn
.text$x:000035EE __unwindfunclet$?Add@?$CObjectVector@UCItem@NWildcard@@@@QAEIABUCItem@NWildcard@@@Z$0 endp
.text$x:000035EE
.text$x:000035EF
.text$x:000035EF ; =============== S U B R O U T I N E =======================================
.text$x:000035EF
.text$x:000035EF
.text$x:000035EF __ehhandler$?Add@?$CObjectVector@UCItem@NWildcard@@@@QAEIABUCItem@NWildcard@@@Z proc near
.text$x:000035EF                                         ; DATA XREF: CObjectVector<NWildcard::CItem>::Add(NWildcard::CItem const &)+5o
.text$x:000035EF
.text$x:000035EF arg_4           = dword ptr  8
.text$x:000035EF
.text$x:000035EF                 mov     edx, [esp+arg_4]
.text$x:000035F3                 lea     eax, [edx+0Ch]
.text$x:000035F6                 mov     ecx, [edx-14h]
.text$x:000035F9                 xor     ecx, eax
.text$x:000035FB                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003600                 mov     eax, offset __ehfuncinfo$?Add@?$CObjectVector@UCItem@NWildcard@@@@QAEIABUCItem@NWildcard@@@Z
.text$x:00003605                 jmp     ___CxxFrameHandler3
.text$x:00003605 __ehhandler$?Add@?$CObjectVector@UCItem@NWildcard@@@@QAEIABUCItem@NWildcard@@@Z endp
.text$x:00003605
.text$x:00003605 ; ---------------------------------------------------------------------------
.text$x:0000360A                 align 4
.text$x:0000360A _text$x         ends
.text$x:0000360A
.xdata$x:0000360C ; ===========================================================================
.xdata$x:0000360C
.xdata$x:0000360C ; Segment type: Pure data
.xdata$x:0000360C ; Segment permissions: Read
.xdata$x:0000360C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000360C                 assume cs:_xdata$x
.xdata$x:0000360C                 ;org 360Ch
.xdata$x:0000360C ; COMDAT (pick associative to section at 3544)
.xdata$x:0000360C __unwindtable$?Add@?$CObjectVector@UCItem@NWildcard@@@@QAEIABUCItem@NWildcard@@@Z db 0FFh
.xdata$x:0000360C                                         ; DATA XREF: .xdata$x:0000361Co
.xdata$x:0000360D                 db 0FFh
.xdata$x:0000360E                 db 0FFh
.xdata$x:0000360F                 db 0FFh
.xdata$x:00003610                 dd offset __unwindfunclet$?Add@?$CObjectVector@UCItem@NWildcard@@@@QAEIABUCItem@NWildcard@@@Z$0
.xdata$x:00003614 __ehfuncinfo$?Add@?$CObjectVector@UCItem@NWildcard@@@@QAEIABUCItem@NWildcard@@@Z db  22h ; "
.xdata$x:00003614                                         ; DATA XREF: __ehhandler$?Add@?$CObjectVector@UCItem@NWildcard@@@@QAEIABUCItem@NWildcard@@@Z+11o
.xdata$x:00003615                 db    5
.xdata$x:00003616                 db  93h ; ô
.xdata$x:00003617                 db  19h
.xdata$x:00003618                 db    1
.xdata$x:00003619                 db    0
.xdata$x:0000361A                 db    0
.xdata$x:0000361B                 db    0
.xdata$x:0000361C                 dd offset __unwindtable$?Add@?$CObjectVector@UCItem@NWildcard@@@@QAEIABUCItem@NWildcard@@@Z
.xdata$x:00003620                 db    0
.xdata$x:00003621                 db    0
.xdata$x:00003622                 db    0
.xdata$x:00003623                 db    0
.xdata$x:00003624                 db    0
.xdata$x:00003625                 db    0
.xdata$x:00003626                 db    0
.xdata$x:00003627                 db    0
.xdata$x:00003628                 db    0
.xdata$x:00003629                 db    0
.xdata$x:0000362A                 db    0
.xdata$x:0000362B                 db    0
.xdata$x:0000362C                 db    0
.xdata$x:0000362D                 db    0
.xdata$x:0000362E                 db    0
.xdata$x:0000362F                 db    0
.xdata$x:00003630                 db    0
.xdata$x:00003631                 db    0
.xdata$x:00003632                 db    0
.xdata$x:00003633                 db    0
.xdata$x:00003634                 db    1
.xdata$x:00003635                 db    0
.xdata$x:00003636                 db    0
.xdata$x:00003637                 db    0
.xdata$x:00003637 _xdata$x        ends
.xdata$x:00003637
.text:00003638 ; ===========================================================================
.text:00003638
.text:00003638 ; Segment type: Pure code
.text:00003638 ; Segment permissions: Read/Execute
.text:00003638 _text           segment para public 'CODE' use32
.text:00003638                 assume cs:_text
.text:00003638                 ;org 3638h
.text:00003638 ; COMDAT (pick any)
.text:00003638                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003638
.text:00003638 ; =============== S U B R O U T I N E =======================================
.text:00003638
.text:00003638 ; Attributes: bp-based frame
.text:00003638
.text:00003638 ; public: __thiscall CObjectVector<struct NWildcard::CItem>::~CObjectVector<struct NWildcard::CItem>(void)
.text:00003638                 public ??1?$CObjectVector@UCItem@NWildcard@@@@QAE@XZ
.text:00003638 ??1?$CObjectVector@UCItem@NWildcard@@@@QAE@XZ proc near
.text:00003638                                         ; CODE XREF: __unwindfunclet$??0CCensorNode@NWildcard@@QAE@ABVUString@@PAV01@@Z$2+6j
.text:00003638                                         ; NWildcard::CCensorNode::~CCensorNode(void)+3Ap ...
.text:00003638
.text:00003638 var_20          = dword ptr -20h
.text:00003638 var_1C          = dword ptr -1Ch
.text:00003638 var_18          = dword ptr -18h
.text:00003638 var_14          = dword ptr -14h
.text:00003638 var_10          = dword ptr -10h
.text:00003638 var_C           = dword ptr -0Ch
.text:00003638 var_4           = dword ptr -4
.text:00003638
.text:00003638                 push    ebp
.text:00003639                 mov     ebp, esp
.text:0000363B                 push    0FFFFFFFFh
.text:0000363D                 push    offset __ehhandler$??1?$CObjectVector@UCItem@NWildcard@@@@QAE@XZ
.text:00003642                 mov     eax, large fs:0
.text:00003648                 push    eax
.text:00003649                 sub     esp, 14h
.text:0000364C                 mov     eax, 0CCCCCCCCh
.text:00003651                 mov     [ebp+var_20], eax
.text:00003654                 mov     [ebp+var_1C], eax
.text:00003657                 mov     [ebp+var_18], eax
.text:0000365A                 mov     [ebp+var_14], eax
.text:0000365D                 mov     [ebp+var_10], eax
.text:00003660                 mov     eax, dword ptr ds:___security_cookie
.text:00003665                 xor     eax, ebp
.text:00003667                 push    eax
.text:00003668                 lea     eax, [ebp+var_C]
.text:0000366B                 mov     large fs:0, eax
.text:00003671                 mov     [ebp+var_10], ecx
.text:00003674                 mov     [ebp+var_4], 0
.text:0000367B                 mov     ecx, [ebp+var_10]
.text:0000367E                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00003683                 mov     [ebp+var_14], eax
.text:00003686
.text:00003686 loc_3686:                               ; CODE XREF: CObjectVector<NWildcard::CItem>::~CObjectVector<NWildcard::CItem>(void):loc_36C8j
.text:00003686                 cmp     [ebp+var_14], 0
.text:0000368A                 jz      short loc_36CA
.text:0000368C                 mov     eax, [ebp+var_14]
.text:0000368F                 sub     eax, 1
.text:00003692                 mov     [ebp+var_14], eax
.text:00003695                 mov     ecx, [ebp+var_14]
.text:00003698                 push    ecx
.text:00003699                 mov     ecx, [ebp+var_10]
.text:0000369C                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:000036A1                 mov     edx, [eax]
.text:000036A3                 mov     [ebp+var_1C], edx
.text:000036A6                 mov     eax, [ebp+var_1C]
.text:000036A9                 mov     [ebp+var_18], eax
.text:000036AC                 cmp     [ebp+var_18], 0
.text:000036B0                 jz      short loc_36C1
.text:000036B2                 push    1
.text:000036B4                 mov     ecx, [ebp+var_18]
.text:000036B7                 call    ??_GCItem@NWildcard@@QAEPAXI@Z ; NWildcard::CItem::`scalar deleting destructor'(uint)
.text:000036BC                 mov     [ebp+var_20], eax
.text:000036BF                 jmp     short loc_36C8
.text:000036C1 ; ---------------------------------------------------------------------------
.text:000036C1
.text:000036C1 loc_36C1:                               ; CODE XREF: CObjectVector<NWildcard::CItem>::~CObjectVector<NWildcard::CItem>(void)+78j
.text:000036C1                 mov     [ebp+var_20], 0
.text:000036C8
.text:000036C8 loc_36C8:                               ; CODE XREF: CObjectVector<NWildcard::CItem>::~CObjectVector<NWildcard::CItem>(void)+87j
.text:000036C8                 jmp     short loc_3686
.text:000036CA ; ---------------------------------------------------------------------------
.text:000036CA
.text:000036CA loc_36CA:                               ; CODE XREF: CObjectVector<NWildcard::CItem>::~CObjectVector<NWildcard::CItem>(void)+52j
.text:000036CA                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000036D1                 mov     ecx, [ebp+var_10]
.text:000036D4                 call    ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text:000036D9                 mov     ecx, [ebp+var_C]
.text:000036DC                 mov     large fs:0, ecx
.text:000036E3                 pop     ecx
.text:000036E4                 add     esp, 20h
.text:000036E7                 cmp     ebp, esp
.text:000036E9                 call    __RTC_CheckEsp
.text:000036EE                 mov     esp, ebp
.text:000036F0                 pop     ebp
.text:000036F1                 retn
.text:000036F1 ??1?$CObjectVector@UCItem@NWildcard@@@@QAE@XZ endp
.text:000036F1
.text:000036F1 ; ---------------------------------------------------------------------------
.text:000036F2                 align 4
.text:000036F2 _text           ends
.text:000036F2
.text$x:000036F4 ; ===========================================================================
.text$x:000036F4
.text$x:000036F4 ; Segment type: Pure code
.text$x:000036F4 ; Segment permissions: Read/Execute
.text$x:000036F4 _text$x         segment para public 'CODE' use32
.text$x:000036F4                 assume cs:_text$x
.text$x:000036F4                 ;org 36F4h
.text$x:000036F4 ; COMDAT (pick associative to section at 3638)
.text$x:000036F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000036F4
.text$x:000036F4 ; =============== S U B R O U T I N E =======================================
.text$x:000036F4
.text$x:000036F4
.text$x:000036F4 __unwindfunclet$??1?$CObjectVector@UCItem@NWildcard@@@@QAE@XZ$0 proc near
.text$x:000036F4                                         ; DATA XREF: .xdata$x:0000371Co
.text$x:000036F4                 mov     ecx, [ebp-10h]
.text$x:000036F7                 jmp     ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text$x:000036F7 __unwindfunclet$??1?$CObjectVector@UCItem@NWildcard@@@@QAE@XZ$0 endp
.text$x:000036F7
.text$x:000036FC
.text$x:000036FC ; =============== S U B R O U T I N E =======================================
.text$x:000036FC
.text$x:000036FC
.text$x:000036FC __ehhandler$??1?$CObjectVector@UCItem@NWildcard@@@@QAE@XZ proc near
.text$x:000036FC                                         ; DATA XREF: CObjectVector<NWildcard::CItem>::~CObjectVector<NWildcard::CItem>(void)+5o
.text$x:000036FC
.text$x:000036FC arg_4           = dword ptr  8
.text$x:000036FC
.text$x:000036FC                 mov     edx, [esp+arg_4]
.text$x:00003700                 lea     eax, [edx+0Ch]
.text$x:00003703                 mov     ecx, [edx-18h]
.text$x:00003706                 xor     ecx, eax
.text$x:00003708                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000370D                 mov     eax, offset __ehfuncinfo$??1?$CObjectVector@UCItem@NWildcard@@@@QAE@XZ
.text$x:00003712                 jmp     ___CxxFrameHandler3
.text$x:00003712 __ehhandler$??1?$CObjectVector@UCItem@NWildcard@@@@QAE@XZ endp
.text$x:00003712
.text$x:00003712 ; ---------------------------------------------------------------------------
.text$x:00003717                 align 4
.text$x:00003717 _text$x         ends
.text$x:00003717
.xdata$x:00003718 ; ===========================================================================
.xdata$x:00003718
.xdata$x:00003718 ; Segment type: Pure data
.xdata$x:00003718 ; Segment permissions: Read
.xdata$x:00003718 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003718                 assume cs:_xdata$x
.xdata$x:00003718                 ;org 3718h
.xdata$x:00003718 ; COMDAT (pick associative to section at 3638)
.xdata$x:00003718 __unwindtable$??1?$CObjectVector@UCItem@NWildcard@@@@QAE@XZ db 0FFh
.xdata$x:00003718                                         ; DATA XREF: .xdata$x:00003728o
.xdata$x:00003719                 db 0FFh
.xdata$x:0000371A                 db 0FFh
.xdata$x:0000371B                 db 0FFh
.xdata$x:0000371C                 dd offset __unwindfunclet$??1?$CObjectVector@UCItem@NWildcard@@@@QAE@XZ$0
.xdata$x:00003720 __ehfuncinfo$??1?$CObjectVector@UCItem@NWildcard@@@@QAE@XZ db  22h ; "
.xdata$x:00003720                                         ; DATA XREF: __ehhandler$??1?$CObjectVector@UCItem@NWildcard@@@@QAE@XZ+11o
.xdata$x:00003721                 db    5
.xdata$x:00003722                 db  93h ; ô
.xdata$x:00003723                 db  19h
.xdata$x:00003724                 db    1
.xdata$x:00003725                 db    0
.xdata$x:00003726                 db    0
.xdata$x:00003727                 db    0
.xdata$x:00003728                 dd offset __unwindtable$??1?$CObjectVector@UCItem@NWildcard@@@@QAE@XZ
.xdata$x:0000372C                 align 20h
.xdata$x:00003740                 db    1
.xdata$x:00003741                 db    0
.xdata$x:00003742                 db    0
.xdata$x:00003743                 db    0
.xdata$x:00003743 _xdata$x        ends
.xdata$x:00003743
.text:00003744 ; ===========================================================================
.text:00003744
.text:00003744 ; Segment type: Pure code
.text:00003744 ; Segment permissions: Read/Execute
.text:00003744 _text           segment para public 'CODE' use32
.text:00003744                 assume cs:_text
.text:00003744                 ;org 3744h
.text:00003744 ; COMDAT (pick any)
.text:00003744                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003744
.text:00003744 ; =============== S U B R O U T I N E =======================================
.text:00003744
.text:00003744 ; Attributes: bp-based frame
.text:00003744
.text:00003744 ; public: unsigned int __thiscall CObjectVector<struct NWildcard::CPair>::Size(void)const
.text:00003744                 public ?Size@?$CObjectVector@UCPair@NWildcard@@@@QBEIXZ
.text:00003744 ?Size@?$CObjectVector@UCPair@NWildcard@@@@QBEIXZ proc near
.text:00003744                                         ; CODE XREF: NWildcard::CCensor::FindPrefix(UString const &)+2Cp
.text:00003744                                         ; NWildcard::CCensor::ExtendExclude(void)+33p ...
.text:00003744
.text:00003744 var_4           = dword ptr -4
.text:00003744
.text:00003744                 push    ebp
.text:00003745                 mov     ebp, esp
.text:00003747                 push    ecx
.text:00003748                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000374F                 mov     [ebp+var_4], ecx
.text:00003752                 mov     ecx, [ebp+var_4]
.text:00003755                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:0000375A                 add     esp, 4
.text:0000375D                 cmp     ebp, esp
.text:0000375F                 call    __RTC_CheckEsp
.text:00003764                 mov     esp, ebp
.text:00003766                 pop     ebp
.text:00003767                 retn
.text:00003767 ?Size@?$CObjectVector@UCPair@NWildcard@@@@QBEIXZ endp
.text:00003767
.text:00003767 _text           ends
.text:00003767
.text:00003768 ; ===========================================================================
.text:00003768
.text:00003768 ; Segment type: Pure code
.text:00003768 ; Segment permissions: Read/Execute
.text:00003768 _text           segment para public 'CODE' use32
.text:00003768                 assume cs:_text
.text:00003768                 ;org 3768h
.text:00003768 ; COMDAT (pick any)
.text:00003768                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003768
.text:00003768 ; =============== S U B R O U T I N E =======================================
.text:00003768
.text:00003768 ; Attributes: bp-based frame
.text:00003768
.text:00003768 ; public: struct NWildcard::CPair const & __thiscall CObjectVector<struct NWildcard::CPair>::operator[](unsigned int)const
.text:00003768                 public ??A?$CObjectVector@UCPair@NWildcard@@@@QBEABUCPair@NWildcard@@I@Z
.text:00003768 ??A?$CObjectVector@UCPair@NWildcard@@@@QBEABUCPair@NWildcard@@I@Z proc near
.text:00003768                                         ; CODE XREF: NWildcard::CCensor::FindPrefix(UString const &)+46p
.text:00003768
.text:00003768 var_4           = dword ptr -4
.text:00003768 arg_0           = dword ptr  8
.text:00003768
.text:00003768                 push    ebp
.text:00003769                 mov     ebp, esp
.text:0000376B                 push    ecx
.text:0000376C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003773                 mov     [ebp+var_4], ecx
.text:00003776                 mov     eax, [ebp+arg_0]
.text:00003779                 push    eax
.text:0000377A                 mov     ecx, [ebp+var_4]
.text:0000377D                 call    ??A?$CRecordVector@PAX@@QBEABQAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00003782                 mov     eax, [eax]
.text:00003784                 add     esp, 4
.text:00003787                 cmp     ebp, esp
.text:00003789                 call    __RTC_CheckEsp
.text:0000378E                 mov     esp, ebp
.text:00003790                 pop     ebp
.text:00003791                 retn    4
.text:00003791 ??A?$CObjectVector@UCPair@NWildcard@@@@QBEABUCPair@NWildcard@@I@Z endp
.text:00003791
.text:00003791 _text           ends
.text:00003791
.text:00003794 ; ===========================================================================
.text:00003794
.text:00003794 ; Segment type: Pure code
.text:00003794 ; Segment permissions: Read/Execute
.text:00003794 _text           segment para public 'CODE' use32
.text:00003794                 assume cs:_text
.text:00003794                 ;org 3794h
.text:00003794 ; COMDAT (pick any)
.text:00003794                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003794
.text:00003794 ; =============== S U B R O U T I N E =======================================
.text:00003794
.text:00003794 ; Attributes: bp-based frame
.text:00003794
.text:00003794 ; public: struct NWildcard::CPair & __thiscall CObjectVector<struct NWildcard::CPair>::operator[](unsigned int)
.text:00003794                 public ??A?$CObjectVector@UCPair@NWildcard@@@@QAEAAUCPair@NWildcard@@I@Z
.text:00003794 ??A?$CObjectVector@UCPair@NWildcard@@@@QAEAAUCPair@NWildcard@@I@Z proc near
.text:00003794                                         ; CODE XREF: NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+39Dp
.text:00003794                                         ; NWildcard::CCensor::ExtendExclude(void)+44p ...
.text:00003794
.text:00003794 var_4           = dword ptr -4
.text:00003794 arg_0           = dword ptr  8
.text:00003794
.text:00003794                 push    ebp
.text:00003795                 mov     ebp, esp
.text:00003797                 push    ecx
.text:00003798                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000379F                 mov     [ebp+var_4], ecx
.text:000037A2                 mov     eax, [ebp+arg_0]
.text:000037A5                 push    eax
.text:000037A6                 mov     ecx, [ebp+var_4]
.text:000037A9                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:000037AE                 mov     eax, [eax]
.text:000037B0                 add     esp, 4
.text:000037B3                 cmp     ebp, esp
.text:000037B5                 call    __RTC_CheckEsp
.text:000037BA                 mov     esp, ebp
.text:000037BC                 pop     ebp
.text:000037BD                 retn    4
.text:000037BD ??A?$CObjectVector@UCPair@NWildcard@@@@QAEAAUCPair@NWildcard@@I@Z endp
.text:000037BD
.text:000037BD _text           ends
.text:000037BD
.text:000037C0 ; ===========================================================================
.text:000037C0
.text:000037C0 ; Segment type: Pure code
.text:000037C0 ; Segment permissions: Read/Execute
.text:000037C0 _text           segment para public 'CODE' use32
.text:000037C0                 assume cs:_text
.text:000037C0                 ;org 37C0h
.text:000037C0 ; COMDAT (pick any)
.text:000037C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000037C0
.text:000037C0 ; =============== S U B R O U T I N E =======================================
.text:000037C0
.text:000037C0 ; Attributes: bp-based frame
.text:000037C0
.text:000037C0 ; public: unsigned int __thiscall CObjectVector<struct NWildcard::CPair>::Add(struct NWildcard::CPair const &)
.text:000037C0                 public ?Add@?$CObjectVector@UCPair@NWildcard@@@@QAEIABUCPair@NWildcard@@@Z
.text:000037C0 ?Add@?$CObjectVector@UCPair@NWildcard@@@@QAEIABUCPair@NWildcard@@@Z proc near
.text:000037C0                                         ; CODE XREF: NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+2C4p
.text:000037C0
.text:000037C0 var_1C          = dword ptr -1Ch
.text:000037C0 var_18          = dword ptr -18h
.text:000037C0 var_14          = dword ptr -14h
.text:000037C0 var_10          = dword ptr -10h
.text:000037C0 var_C           = dword ptr -0Ch
.text:000037C0 var_4           = dword ptr -4
.text:000037C0 arg_0           = dword ptr  8
.text:000037C0
.text:000037C0                 push    ebp
.text:000037C1                 mov     ebp, esp
.text:000037C3                 push    0FFFFFFFFh
.text:000037C5                 push    offset __ehhandler$?Add@?$CObjectVector@UCPair@NWildcard@@@@QAEIABUCPair@NWildcard@@@Z
.text:000037CA                 mov     eax, large fs:0
.text:000037D0                 push    eax
.text:000037D1                 sub     esp, 10h
.text:000037D4                 mov     eax, 0CCCCCCCCh
.text:000037D9                 mov     [ebp+var_1C], eax
.text:000037DC                 mov     [ebp+var_18], eax
.text:000037DF                 mov     [ebp+var_14], eax
.text:000037E2                 mov     [ebp+var_10], eax
.text:000037E5                 mov     eax, dword ptr ds:___security_cookie
.text:000037EA                 xor     eax, ebp
.text:000037EC                 push    eax
.text:000037ED                 lea     eax, [ebp+var_C]
.text:000037F0                 mov     large fs:0, eax
.text:000037F6                 mov     [ebp+var_10], ecx
.text:000037F9                 push    40h ; '@'       ; unsigned int
.text:000037FB                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00003800                 add     esp, 4
.text:00003803                 mov     [ebp+var_18], eax
.text:00003806                 mov     [ebp+var_4], 0
.text:0000380D                 cmp     [ebp+var_18], 0
.text:00003811                 jz      short loc_3824
.text:00003813                 mov     eax, [ebp+arg_0]
.text:00003816                 push    eax             ; struct NWildcard::CPair *
.text:00003817                 mov     ecx, [ebp+var_18] ; this
.text:0000381A                 call    ??0CPair@NWildcard@@QAE@ABU01@@Z ; NWildcard::CPair::CPair(NWildcard::CPair const &)
.text:0000381F                 mov     [ebp+var_1C], eax
.text:00003822                 jmp     short loc_382B
.text:00003824 ; ---------------------------------------------------------------------------
.text:00003824
.text:00003824 loc_3824:                               ; CODE XREF: CObjectVector<NWildcard::CPair>::Add(NWildcard::CPair const &)+51j
.text:00003824                 mov     [ebp+var_1C], 0
.text:0000382B
.text:0000382B loc_382B:                               ; CODE XREF: CObjectVector<NWildcard::CPair>::Add(NWildcard::CPair const &)+62j
.text:0000382B                 mov     ecx, [ebp+var_1C]
.text:0000382E                 mov     [ebp+var_14], ecx
.text:00003831                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00003838                 mov     edx, [ebp+var_14]
.text:0000383B                 push    edx
.text:0000383C                 mov     ecx, [ebp+var_10]
.text:0000383F                 call    ?Add@?$CRecordVector@PAX@@QAEIQAX@Z ; CRecordVector<void *>::Add(void * const)
.text:00003844                 mov     ecx, [ebp+var_C]
.text:00003847                 mov     large fs:0, ecx
.text:0000384E                 pop     ecx
.text:0000384F                 add     esp, 1Ch
.text:00003852                 cmp     ebp, esp
.text:00003854                 call    __RTC_CheckEsp
.text:00003859                 mov     esp, ebp
.text:0000385B                 pop     ebp
.text:0000385C                 retn    4
.text:0000385C ?Add@?$CObjectVector@UCPair@NWildcard@@@@QAEIABUCPair@NWildcard@@@Z endp
.text:0000385C
.text:0000385C ; ---------------------------------------------------------------------------
.text:0000385F                 align 10h
.text:0000385F _text           ends
.text:0000385F
.text$x:00003860 ; ===========================================================================
.text$x:00003860
.text$x:00003860 ; Segment type: Pure code
.text$x:00003860 ; Segment permissions: Read/Execute
.text$x:00003860 _text$x         segment para public 'CODE' use32
.text$x:00003860                 assume cs:_text$x
.text$x:00003860                 ;org 3860h
.text$x:00003860 ; COMDAT (pick associative to section at 37C0)
.text$x:00003860                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003860
.text$x:00003860 ; =============== S U B R O U T I N E =======================================
.text$x:00003860
.text$x:00003860
.text$x:00003860 __unwindfunclet$?Add@?$CObjectVector@UCPair@NWildcard@@@@QAEIABUCPair@NWildcard@@@Z$0 proc near
.text$x:00003860                                         ; DATA XREF: .xdata$x:0000388Co
.text$x:00003860                 mov     eax, [ebp-18h]
.text$x:00003863                 push    eax             ; void *
.text$x:00003864                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00003869                 pop     ecx
.text$x:0000386A                 retn
.text$x:0000386A __unwindfunclet$?Add@?$CObjectVector@UCPair@NWildcard@@@@QAEIABUCPair@NWildcard@@@Z$0 endp
.text$x:0000386A
.text$x:0000386B
.text$x:0000386B ; =============== S U B R O U T I N E =======================================
.text$x:0000386B
.text$x:0000386B
.text$x:0000386B __ehhandler$?Add@?$CObjectVector@UCPair@NWildcard@@@@QAEIABUCPair@NWildcard@@@Z proc near
.text$x:0000386B                                         ; DATA XREF: CObjectVector<NWildcard::CPair>::Add(NWildcard::CPair const &)+5o
.text$x:0000386B
.text$x:0000386B arg_4           = dword ptr  8
.text$x:0000386B
.text$x:0000386B                 mov     edx, [esp+arg_4]
.text$x:0000386F                 lea     eax, [edx+0Ch]
.text$x:00003872                 mov     ecx, [edx-14h]
.text$x:00003875                 xor     ecx, eax
.text$x:00003877                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000387C                 mov     eax, offset __ehfuncinfo$?Add@?$CObjectVector@UCPair@NWildcard@@@@QAEIABUCPair@NWildcard@@@Z
.text$x:00003881                 jmp     ___CxxFrameHandler3
.text$x:00003881 __ehhandler$?Add@?$CObjectVector@UCPair@NWildcard@@@@QAEIABUCPair@NWildcard@@@Z endp
.text$x:00003881
.text$x:00003881 ; ---------------------------------------------------------------------------
.text$x:00003886                 align 4
.text$x:00003886 _text$x         ends
.text$x:00003886
.xdata$x:00003888 ; ===========================================================================
.xdata$x:00003888
.xdata$x:00003888 ; Segment type: Pure data
.xdata$x:00003888 ; Segment permissions: Read
.xdata$x:00003888 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003888                 assume cs:_xdata$x
.xdata$x:00003888                 ;org 3888h
.xdata$x:00003888 ; COMDAT (pick associative to section at 37C0)
.xdata$x:00003888 __unwindtable$?Add@?$CObjectVector@UCPair@NWildcard@@@@QAEIABUCPair@NWildcard@@@Z db 0FFh
.xdata$x:00003888                                         ; DATA XREF: .xdata$x:00003898o
.xdata$x:00003889                 db 0FFh
.xdata$x:0000388A                 db 0FFh
.xdata$x:0000388B                 db 0FFh
.xdata$x:0000388C                 dd offset __unwindfunclet$?Add@?$CObjectVector@UCPair@NWildcard@@@@QAEIABUCPair@NWildcard@@@Z$0
.xdata$x:00003890 __ehfuncinfo$?Add@?$CObjectVector@UCPair@NWildcard@@@@QAEIABUCPair@NWildcard@@@Z db  22h ; "
.xdata$x:00003890                                         ; DATA XREF: __ehhandler$?Add@?$CObjectVector@UCPair@NWildcard@@@@QAEIABUCPair@NWildcard@@@Z+11o
.xdata$x:00003891                 db    5
.xdata$x:00003892                 db  93h ; ô
.xdata$x:00003893                 db  19h
.xdata$x:00003894                 db    1
.xdata$x:00003895                 db    0
.xdata$x:00003896                 db    0
.xdata$x:00003897                 db    0
.xdata$x:00003898                 dd offset __unwindtable$?Add@?$CObjectVector@UCPair@NWildcard@@@@QAEIABUCPair@NWildcard@@@Z
.xdata$x:0000389C                 db    0
.xdata$x:0000389D                 db    0
.xdata$x:0000389E                 db    0
.xdata$x:0000389F                 db    0
.xdata$x:000038A0                 db    0
.xdata$x:000038A1                 db    0
.xdata$x:000038A2                 db    0
.xdata$x:000038A3                 db    0
.xdata$x:000038A4                 db    0
.xdata$x:000038A5                 db    0
.xdata$x:000038A6                 db    0
.xdata$x:000038A7                 db    0
.xdata$x:000038A8                 db    0
.xdata$x:000038A9                 db    0
.xdata$x:000038AA                 db    0
.xdata$x:000038AB                 db    0
.xdata$x:000038AC                 db    0
.xdata$x:000038AD                 db    0
.xdata$x:000038AE                 db    0
.xdata$x:000038AF                 db    0
.xdata$x:000038B0                 db    1
.xdata$x:000038B1                 db    0
.xdata$x:000038B2                 db    0
.xdata$x:000038B3                 db    0
.xdata$x:000038B3 _xdata$x        ends
.xdata$x:000038B3
.text:000038B4 ; ===========================================================================
.text:000038B4
.text:000038B4 ; Segment type: Pure code
.text:000038B4 ; Segment permissions: Read/Execute
.text:000038B4 _text           segment para public 'CODE' use32
.text:000038B4                 assume cs:_text
.text:000038B4                 ;org 38B4h
.text:000038B4 ; COMDAT (pick any)
.text:000038B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000038B4
.text:000038B4 ; =============== S U B R O U T I N E =======================================
.text:000038B4
.text:000038B4 ; Attributes: bp-based frame
.text:000038B4
.text:000038B4 ; public: unsigned int __thiscall CObjectVector<struct NWildcard::CCensorPath>::Size(void)const
.text:000038B4                 public ?Size@?$CObjectVector@UCCensorPath@NWildcard@@@@QBEIXZ
.text:000038B4 ?Size@?$CObjectVector@UCCensorPath@NWildcard@@@@QBEIXZ proc near
.text:000038B4                                         ; CODE XREF: NWildcard::CCensor::AddPathsToCensor(NWildcard::ECensorPathMode)+36p
.text:000038B4
.text:000038B4 var_4           = dword ptr -4
.text:000038B4
.text:000038B4                 push    ebp
.text:000038B5                 mov     ebp, esp
.text:000038B7                 push    ecx
.text:000038B8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000038BF                 mov     [ebp+var_4], ecx
.text:000038C2                 mov     ecx, [ebp+var_4]
.text:000038C5                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:000038CA                 add     esp, 4
.text:000038CD                 cmp     ebp, esp
.text:000038CF                 call    __RTC_CheckEsp
.text:000038D4                 mov     esp, ebp
.text:000038D6                 pop     ebp
.text:000038D7                 retn
.text:000038D7 ?Size@?$CObjectVector@UCCensorPath@NWildcard@@@@QBEIXZ endp
.text:000038D7
.text:000038D7 _text           ends
.text:000038D7
.text:000038D8 ; ===========================================================================
.text:000038D8
.text:000038D8 ; Segment type: Pure code
.text:000038D8 ; Segment permissions: Read/Execute
.text:000038D8 _text           segment para public 'CODE' use32
.text:000038D8                 assume cs:_text
.text:000038D8                 ;org 38D8h
.text:000038D8 ; COMDAT (pick any)
.text:000038D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000038D8
.text:000038D8 ; =============== S U B R O U T I N E =======================================
.text:000038D8
.text:000038D8 ; Attributes: bp-based frame
.text:000038D8
.text:000038D8 ; public: struct NWildcard::CCensorPath & __thiscall CObjectVector<struct NWildcard::CCensorPath>::operator[](unsigned int)
.text:000038D8                 public ??A?$CObjectVector@UCCensorPath@NWildcard@@@@QAEAAUCCensorPath@NWildcard@@I@Z
.text:000038D8 ??A?$CObjectVector@UCCensorPath@NWildcard@@@@QAEAAUCCensorPath@NWildcard@@I@Z proc near
.text:000038D8                                         ; CODE XREF: NWildcard::CCensor::AddPathsToCensor(NWildcard::ECensorPathMode)+4Ap
.text:000038D8
.text:000038D8 var_4           = dword ptr -4
.text:000038D8 arg_0           = dword ptr  8
.text:000038D8
.text:000038D8                 push    ebp
.text:000038D9                 mov     ebp, esp
.text:000038DB                 push    ecx
.text:000038DC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000038E3                 mov     [ebp+var_4], ecx
.text:000038E6                 mov     eax, [ebp+arg_0]
.text:000038E9                 push    eax
.text:000038EA                 mov     ecx, [ebp+var_4]
.text:000038ED                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:000038F2                 mov     eax, [eax]
.text:000038F4                 add     esp, 4
.text:000038F7                 cmp     ebp, esp
.text:000038F9                 call    __RTC_CheckEsp
.text:000038FE                 mov     esp, ebp
.text:00003900                 pop     ebp
.text:00003901                 retn    4
.text:00003901 ??A?$CObjectVector@UCCensorPath@NWildcard@@@@QAEAAUCCensorPath@NWildcard@@I@Z endp
.text:00003901
.text:00003901 _text           ends
.text:00003901
.text:00003904 ; ===========================================================================
.text:00003904
.text:00003904 ; Segment type: Pure code
.text:00003904 ; Segment permissions: Read/Execute
.text:00003904 _text           segment para public 'CODE' use32
.text:00003904                 assume cs:_text
.text:00003904                 ;org 3904h
.text:00003904 ; COMDAT (pick any)
.text:00003904                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003904
.text:00003904 ; =============== S U B R O U T I N E =======================================
.text:00003904
.text:00003904 ; Attributes: bp-based frame
.text:00003904
.text:00003904 ; public: struct NWildcard::CCensorPath & __thiscall CObjectVector<struct NWildcard::CCensorPath>::AddNew(void)
.text:00003904                 public ?AddNew@?$CObjectVector@UCCensorPath@NWildcard@@@@QAEAAUCCensorPath@NWildcard@@XZ
.text:00003904 ?AddNew@?$CObjectVector@UCCensorPath@NWildcard@@@@QAEAAUCCensorPath@NWildcard@@XZ proc near
.text:00003904                                         ; CODE XREF: NWildcard::CCensor::AddPreItem(bool,UString const &,bool,bool)+1Dp
.text:00003904
.text:00003904 var_20          = dword ptr -20h
.text:00003904 var_1C          = dword ptr -1Ch
.text:00003904 var_18          = dword ptr -18h
.text:00003904 var_14          = dword ptr -14h
.text:00003904 var_10          = dword ptr -10h
.text:00003904 var_C           = dword ptr -0Ch
.text:00003904 var_4           = dword ptr -4
.text:00003904
.text:00003904                 push    ebp
.text:00003905                 mov     ebp, esp
.text:00003907                 push    0FFFFFFFFh
.text:00003909                 push    offset __ehhandler$?AddNew@?$CObjectVector@UCCensorPath@NWildcard@@@@QAEAAUCCensorPath@NWildcard@@XZ
.text:0000390E                 mov     eax, large fs:0
.text:00003914                 push    eax
.text:00003915                 sub     esp, 14h
.text:00003918                 mov     eax, 0CCCCCCCCh
.text:0000391D                 mov     [ebp+var_20], eax
.text:00003920                 mov     [ebp+var_1C], eax
.text:00003923                 mov     [ebp+var_18], eax
.text:00003926                 mov     [ebp+var_14], eax
.text:00003929                 mov     [ebp+var_10], eax
.text:0000392C                 mov     eax, dword ptr ds:___security_cookie
.text:00003931                 xor     eax, ebp
.text:00003933                 push    eax
.text:00003934                 lea     eax, [ebp+var_C]
.text:00003937                 mov     large fs:0, eax
.text:0000393D                 mov     [ebp+var_10], ecx
.text:00003940                 push    10h             ; unsigned int
.text:00003942                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00003947                 add     esp, 4
.text:0000394A                 mov     [ebp+var_1C], eax
.text:0000394D                 mov     [ebp+var_4], 0
.text:00003954                 cmp     [ebp+var_1C], 0
.text:00003958                 jz      short loc_3967
.text:0000395A                 mov     ecx, [ebp+var_1C] ; this
.text:0000395D                 call    ??0CCensorPath@NWildcard@@QAE@XZ ; NWildcard::CCensorPath::CCensorPath(void)
.text:00003962                 mov     [ebp+var_20], eax
.text:00003965                 jmp     short loc_396E
.text:00003967 ; ---------------------------------------------------------------------------
.text:00003967
.text:00003967 loc_3967:                               ; CODE XREF: CObjectVector<NWildcard::CCensorPath>::AddNew(void)+54j
.text:00003967                 mov     [ebp+var_20], 0
.text:0000396E
.text:0000396E loc_396E:                               ; CODE XREF: CObjectVector<NWildcard::CCensorPath>::AddNew(void)+61j
.text:0000396E                 mov     eax, [ebp+var_20]
.text:00003971                 mov     [ebp+var_18], eax
.text:00003974                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000397B                 mov     ecx, [ebp+var_18]
.text:0000397E                 mov     [ebp+var_14], ecx
.text:00003981                 mov     edx, [ebp+var_14]
.text:00003984                 push    edx
.text:00003985                 mov     ecx, [ebp+var_10]
.text:00003988                 call    ?Add@?$CRecordVector@PAX@@QAEIQAX@Z ; CRecordVector<void *>::Add(void * const)
.text:0000398D                 mov     eax, [ebp+var_14]
.text:00003990                 mov     ecx, [ebp+var_C]
.text:00003993                 mov     large fs:0, ecx
.text:0000399A                 pop     ecx
.text:0000399B                 add     esp, 20h
.text:0000399E                 cmp     ebp, esp
.text:000039A0                 call    __RTC_CheckEsp
.text:000039A5                 mov     esp, ebp
.text:000039A7                 pop     ebp
.text:000039A8                 retn
.text:000039A8 ?AddNew@?$CObjectVector@UCCensorPath@NWildcard@@@@QAEAAUCCensorPath@NWildcard@@XZ endp
.text:000039A8
.text:000039A8 ; ---------------------------------------------------------------------------
.text:000039A9                 align 4
.text:000039A9 _text           ends
.text:000039A9
.text$x:000039AC ; ===========================================================================
.text$x:000039AC
.text$x:000039AC ; Segment type: Pure code
.text$x:000039AC ; Segment permissions: Read/Execute
.text$x:000039AC _text$x         segment para public 'CODE' use32
.text$x:000039AC                 assume cs:_text$x
.text$x:000039AC                 ;org 39ACh
.text$x:000039AC ; COMDAT (pick associative to section at 3904)
.text$x:000039AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000039AC
.text$x:000039AC ; =============== S U B R O U T I N E =======================================
.text$x:000039AC
.text$x:000039AC
.text$x:000039AC __unwindfunclet$?AddNew@?$CObjectVector@UCCensorPath@NWildcard@@@@QAEAAUCCensorPath@NWildcard@@XZ$0 proc near
.text$x:000039AC                                         ; DATA XREF: .xdata$x:000039D8o
.text$x:000039AC                 mov     eax, [ebp-1Ch]
.text$x:000039AF                 push    eax             ; void *
.text$x:000039B0                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:000039B5                 pop     ecx
.text$x:000039B6                 retn
.text$x:000039B6 __unwindfunclet$?AddNew@?$CObjectVector@UCCensorPath@NWildcard@@@@QAEAAUCCensorPath@NWildcard@@XZ$0 endp
.text$x:000039B6
.text$x:000039B7
.text$x:000039B7 ; =============== S U B R O U T I N E =======================================
.text$x:000039B7
.text$x:000039B7
.text$x:000039B7 __ehhandler$?AddNew@?$CObjectVector@UCCensorPath@NWildcard@@@@QAEAAUCCensorPath@NWildcard@@XZ proc near
.text$x:000039B7                                         ; DATA XREF: CObjectVector<NWildcard::CCensorPath>::AddNew(void)+5o
.text$x:000039B7
.text$x:000039B7 arg_4           = dword ptr  8
.text$x:000039B7
.text$x:000039B7                 mov     edx, [esp+arg_4]
.text$x:000039BB                 lea     eax, [edx+0Ch]
.text$x:000039BE                 mov     ecx, [edx-18h]
.text$x:000039C1                 xor     ecx, eax
.text$x:000039C3                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000039C8                 mov     eax, offset __ehfuncinfo$?AddNew@?$CObjectVector@UCCensorPath@NWildcard@@@@QAEAAUCCensorPath@NWildcard@@XZ
.text$x:000039CD                 jmp     ___CxxFrameHandler3
.text$x:000039CD __ehhandler$?AddNew@?$CObjectVector@UCCensorPath@NWildcard@@@@QAEAAUCCensorPath@NWildcard@@XZ endp
.text$x:000039CD
.text$x:000039CD ; ---------------------------------------------------------------------------
.text$x:000039D2                 align 4
.text$x:000039D2 _text$x         ends
.text$x:000039D2
.xdata$x:000039D4 ; ===========================================================================
.xdata$x:000039D4
.xdata$x:000039D4 ; Segment type: Pure data
.xdata$x:000039D4 ; Segment permissions: Read
.xdata$x:000039D4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000039D4                 assume cs:_xdata$x
.xdata$x:000039D4                 ;org 39D4h
.xdata$x:000039D4 ; COMDAT (pick associative to section at 3904)
.xdata$x:000039D4 __unwindtable$?AddNew@?$CObjectVector@UCCensorPath@NWildcard@@@@QAEAAUCCensorPath@NWildcard@@XZ db 0FFh
.xdata$x:000039D4                                         ; DATA XREF: .xdata$x:000039E4o
.xdata$x:000039D5                 db 0FFh
.xdata$x:000039D6                 db 0FFh
.xdata$x:000039D7                 db 0FFh
.xdata$x:000039D8                 dd offset __unwindfunclet$?AddNew@?$CObjectVector@UCCensorPath@NWildcard@@@@QAEAAUCCensorPath@NWildcard@@XZ$0
.xdata$x:000039DC __ehfuncinfo$?AddNew@?$CObjectVector@UCCensorPath@NWildcard@@@@QAEAAUCCensorPath@NWildcard@@XZ db  22h ; "
.xdata$x:000039DC                                         ; DATA XREF: __ehhandler$?AddNew@?$CObjectVector@UCCensorPath@NWildcard@@@@QAEAAUCCensorPath@NWildcard@@XZ+11o
.xdata$x:000039DD                 db    5
.xdata$x:000039DE                 db  93h ; ô
.xdata$x:000039DF                 db  19h
.xdata$x:000039E0                 db    1
.xdata$x:000039E1                 db    0
.xdata$x:000039E2                 db    0
.xdata$x:000039E3                 db    0
.xdata$x:000039E4                 dd offset __unwindtable$?AddNew@?$CObjectVector@UCCensorPath@NWildcard@@@@QAEAAUCCensorPath@NWildcard@@XZ
.xdata$x:000039E8                 db    0
.xdata$x:000039E9                 db    0
.xdata$x:000039EA                 db    0
.xdata$x:000039EB                 db    0
.xdata$x:000039EC                 db    0
.xdata$x:000039ED                 db    0
.xdata$x:000039EE                 db    0
.xdata$x:000039EF                 db    0
.xdata$x:000039F0                 db    0
.xdata$x:000039F1                 db    0
.xdata$x:000039F2                 db    0
.xdata$x:000039F3                 db    0
.xdata$x:000039F4                 db    0
.xdata$x:000039F5                 db    0
.xdata$x:000039F6                 db    0
.xdata$x:000039F7                 db    0
.xdata$x:000039F8                 db    0
.xdata$x:000039F9                 db    0
.xdata$x:000039FA                 db    0
.xdata$x:000039FB                 db    0
.xdata$x:000039FC                 db    1
.xdata$x:000039FD                 db    0
.xdata$x:000039FE                 db    0
.xdata$x:000039FF                 db    0
.xdata$x:000039FF _xdata$x        ends
.xdata$x:000039FF
.text:00003A00 ; ===========================================================================
.text:00003A00
.text:00003A00 ; Segment type: Pure code
.text:00003A00 ; Segment permissions: Read/Execute
.text:00003A00 _text           segment para public 'CODE' use32
.text:00003A00                 assume cs:_text
.text:00003A00                 ;org 3A00h
.text:00003A00 ; COMDAT (pick any)
.text:00003A00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003A00
.text:00003A00 ; =============== S U B R O U T I N E =======================================
.text:00003A00
.text:00003A00 ; Attributes: bp-based frame
.text:00003A00
.text:00003A00 ; _DWORD __thiscall NWildcard::CCensorPath::CCensorPath(NWildcard::CCensorPath *__hidden this)
.text:00003A00                 public ??0CCensorPath@NWildcard@@QAE@XZ
.text:00003A00 ??0CCensorPath@NWildcard@@QAE@XZ proc near
.text:00003A00                                         ; CODE XREF: CObjectVector<NWildcard::CCensorPath>::AddNew(void)+59p
.text:00003A00
.text:00003A00 var_4           = dword ptr -4
.text:00003A00
.text:00003A00                 push    ebp
.text:00003A01                 mov     ebp, esp
.text:00003A03                 push    ecx
.text:00003A04                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003A0B                 mov     [ebp+var_4], ecx
.text:00003A0E                 mov     ecx, [ebp+var_4]
.text:00003A11                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00003A16                 mov     eax, [ebp+var_4]
.text:00003A19                 mov     byte ptr [eax+0Ch], 1
.text:00003A1D                 mov     ecx, [ebp+var_4]
.text:00003A20                 mov     byte ptr [ecx+0Dh], 0
.text:00003A24                 mov     edx, [ebp+var_4]
.text:00003A27                 mov     byte ptr [edx+0Eh], 1
.text:00003A2B                 mov     eax, [ebp+var_4]
.text:00003A2E                 add     esp, 4
.text:00003A31                 cmp     ebp, esp
.text:00003A33                 call    __RTC_CheckEsp
.text:00003A38                 mov     esp, ebp
.text:00003A3A                 pop     ebp
.text:00003A3B                 retn
.text:00003A3B ??0CCensorPath@NWildcard@@QAE@XZ endp
.text:00003A3B
.text:00003A3B _text           ends
.text:00003A3B
.text:00003A3C ; ===========================================================================
.text:00003A3C
.text:00003A3C ; Segment type: Pure code
.text:00003A3C ; Segment permissions: Read/Execute
.text:00003A3C _text           segment para public 'CODE' use32
.text:00003A3C                 assume cs:_text
.text:00003A3C                 ;org 3A3Ch
.text:00003A3C ; COMDAT (pick any)
.text:00003A3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003A3C
.text:00003A3C ; =============== S U B R O U T I N E =======================================
.text:00003A3C
.text:00003A3C ; Attributes: bp-based frame
.text:00003A3C
.text:00003A3C ; public: void __thiscall CObjectVector<struct NWildcard::CCensorPath>::Clear(void)
.text:00003A3C                 public ?Clear@?$CObjectVector@UCCensorPath@NWildcard@@@@QAEXXZ
.text:00003A3C ?Clear@?$CObjectVector@UCCensorPath@NWildcard@@@@QAEXXZ proc near
.text:00003A3C                                         ; CODE XREF: NWildcard::CCensor::AddPathsToCensor(NWildcard::ECensorPathMode)+82p
.text:00003A3C
.text:00003A3C var_14          = dword ptr -14h
.text:00003A3C var_10          = dword ptr -10h
.text:00003A3C var_C           = dword ptr -0Ch
.text:00003A3C var_8           = dword ptr -8
.text:00003A3C var_4           = dword ptr -4
.text:00003A3C
.text:00003A3C                 push    ebp
.text:00003A3D                 mov     ebp, esp
.text:00003A3F                 sub     esp, 14h
.text:00003A42                 mov     eax, 0CCCCCCCCh
.text:00003A47                 mov     [ebp+var_14], eax
.text:00003A4A                 mov     [ebp+var_10], eax
.text:00003A4D                 mov     [ebp+var_C], eax
.text:00003A50                 mov     [ebp+var_8], eax
.text:00003A53                 mov     [ebp+var_4], eax
.text:00003A56                 mov     [ebp+var_4], ecx
.text:00003A59                 mov     ecx, [ebp+var_4]
.text:00003A5C                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00003A61                 mov     [ebp+var_8], eax
.text:00003A64
.text:00003A64 loc_3A64:                               ; CODE XREF: CObjectVector<NWildcard::CCensorPath>::Clear(void):loc_3AA6j
.text:00003A64                 cmp     [ebp+var_8], 0
.text:00003A68                 jz      short loc_3AA8
.text:00003A6A                 mov     eax, [ebp+var_8]
.text:00003A6D                 sub     eax, 1
.text:00003A70                 mov     [ebp+var_8], eax
.text:00003A73                 mov     ecx, [ebp+var_8]
.text:00003A76                 push    ecx
.text:00003A77                 mov     ecx, [ebp+var_4]
.text:00003A7A                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00003A7F                 mov     edx, [eax]
.text:00003A81                 mov     [ebp+var_10], edx
.text:00003A84                 mov     eax, [ebp+var_10]
.text:00003A87                 mov     [ebp+var_C], eax
.text:00003A8A                 cmp     [ebp+var_C], 0
.text:00003A8E                 jz      short loc_3A9F
.text:00003A90                 push    1
.text:00003A92                 mov     ecx, [ebp+var_C]
.text:00003A95                 call    ??_GCCensorPath@NWildcard@@QAEPAXI@Z ; NWildcard::CCensorPath::`scalar deleting destructor'(uint)
.text:00003A9A                 mov     [ebp+var_14], eax
.text:00003A9D                 jmp     short loc_3AA6
.text:00003A9F ; ---------------------------------------------------------------------------
.text:00003A9F
.text:00003A9F loc_3A9F:                               ; CODE XREF: CObjectVector<NWildcard::CCensorPath>::Clear(void)+52j
.text:00003A9F                 mov     [ebp+var_14], 0
.text:00003AA6
.text:00003AA6 loc_3AA6:                               ; CODE XREF: CObjectVector<NWildcard::CCensorPath>::Clear(void)+61j
.text:00003AA6                 jmp     short loc_3A64
.text:00003AA8 ; ---------------------------------------------------------------------------
.text:00003AA8
.text:00003AA8 loc_3AA8:                               ; CODE XREF: CObjectVector<NWildcard::CCensorPath>::Clear(void)+2Cj
.text:00003AA8                 mov     ecx, [ebp+var_4]
.text:00003AAB                 call    ?Clear@?$CRecordVector@PAX@@QAEXXZ ; CRecordVector<void *>::Clear(void)
.text:00003AB0                 add     esp, 14h
.text:00003AB3                 cmp     ebp, esp
.text:00003AB5                 call    __RTC_CheckEsp
.text:00003ABA                 mov     esp, ebp
.text:00003ABC                 pop     ebp
.text:00003ABD                 retn
.text:00003ABD ?Clear@?$CObjectVector@UCCensorPath@NWildcard@@@@QAEXXZ endp
.text:00003ABD
.text:00003ABD ; ---------------------------------------------------------------------------
.text:00003ABE                 align 10h
.text:00003ABE _text           ends
.text:00003ABE
.text:00003AC0 ; ===========================================================================
.text:00003AC0
.text:00003AC0 ; Segment type: Pure code
.text:00003AC0 ; Segment permissions: Read/Execute
.text:00003AC0 _text           segment para public 'CODE' use32
.text:00003AC0                 assume cs:_text
.text:00003AC0                 ;org 3AC0h
.text:00003AC0 ; COMDAT (pick any)
.text:00003AC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003AC0
.text:00003AC0 ; =============== S U B R O U T I N E =======================================
.text:00003AC0
.text:00003AC0 ; Attributes: bp-based frame
.text:00003AC0
.text:00003AC0 ; public: void * __thiscall UString::`scalar deleting destructor'(unsigned int)
.text:00003AC0                 public ??_GUString@@QAEPAXI@Z
.text:00003AC0 ??_GUString@@QAEPAXI@Z proc near        ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+7Fp
.text:00003AC0                                         ; CObjectVector<UString>::Clear(void)+59p ...
.text:00003AC0
.text:00003AC0 var_4           = dword ptr -4
.text:00003AC0 arg_0           = dword ptr  8
.text:00003AC0
.text:00003AC0                 push    ebp
.text:00003AC1                 mov     ebp, esp
.text:00003AC3                 push    ecx
.text:00003AC4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003ACB                 mov     [ebp+var_4], ecx
.text:00003ACE                 mov     ecx, [ebp+var_4] ; this
.text:00003AD1                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003AD6                 mov     eax, [ebp+arg_0]
.text:00003AD9                 and     eax, 1
.text:00003ADC                 jz      short loc_3AEA
.text:00003ADE                 mov     ecx, [ebp+var_4]
.text:00003AE1                 push    ecx             ; void *
.text:00003AE2                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00003AE7                 add     esp, 4
.text:00003AEA
.text:00003AEA loc_3AEA:                               ; CODE XREF: UString::`scalar deleting destructor'(uint)+1Cj
.text:00003AEA                 mov     eax, [ebp+var_4]
.text:00003AED                 add     esp, 4
.text:00003AF0                 cmp     ebp, esp
.text:00003AF2                 call    __RTC_CheckEsp
.text:00003AF7                 mov     esp, ebp
.text:00003AF9                 pop     ebp
.text:00003AFA                 retn    4
.text:00003AFA ??_GUString@@QAEPAXI@Z endp
.text:00003AFA
.text:00003AFA ; ---------------------------------------------------------------------------
.text:00003AFD                 align 10h
.text:00003AFD _text           ends
.text:00003AFD
.text:00003B00 ; ===========================================================================
.text:00003B00
.text:00003B00 ; Segment type: Pure code
.text:00003B00 ; Segment permissions: Read/Execute
.text:00003B00 _text           segment para public 'CODE' use32
.text:00003B00                 assume cs:_text
.text:00003B00                 ;org 3B00h
.text:00003B00 ; COMDAT (pick any)
.text:00003B00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003B00
.text:00003B00 ; =============== S U B R O U T I N E =======================================
.text:00003B00
.text:00003B00 ; Attributes: bp-based frame
.text:00003B00
.text:00003B00 ; _DWORD __thiscall NWildcard::CCensorNode::CCensorNode(NWildcard::CCensorNode *this, const struct NWildcard::CCensorNode *)
.text:00003B00                 public ??0CCensorNode@NWildcard@@QAE@ABV01@@Z
.text:00003B00 ??0CCensorNode@NWildcard@@QAE@ABV01@@Z proc near
.text:00003B00                                         ; CODE XREF: CObjectVector<NWildcard::CCensorNode>::Add(NWildcard::CCensorNode const &)+5Ap
.text:00003B00                                         ; NWildcard::CPair::CPair(NWildcard::CPair const &)+4Dp ...
.text:00003B00
.text:00003B00 var_10          = dword ptr -10h
.text:00003B00 var_C           = dword ptr -0Ch
.text:00003B00 var_4           = dword ptr -4
.text:00003B00 arg_0           = dword ptr  8
.text:00003B00
.text:00003B00                 push    ebp
.text:00003B01                 mov     ebp, esp
.text:00003B03                 push    0FFFFFFFFh
.text:00003B05                 push    offset __ehhandler$??0CCensorNode@NWildcard@@QAE@ABV01@@Z
.text:00003B0A                 mov     eax, large fs:0
.text:00003B10                 push    eax
.text:00003B11                 push    ecx
.text:00003B12                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00003B19                 mov     eax, dword ptr ds:___security_cookie
.text:00003B1E                 xor     eax, ebp
.text:00003B20                 push    eax
.text:00003B21                 lea     eax, [ebp+var_C]
.text:00003B24                 mov     large fs:0, eax
.text:00003B2A                 mov     [ebp+var_10], ecx
.text:00003B2D                 mov     eax, [ebp+var_10]
.text:00003B30                 mov     ecx, [ebp+arg_0]
.text:00003B33                 mov     edx, [ecx]
.text:00003B35                 mov     [eax], edx
.text:00003B37                 mov     eax, [ebp+arg_0]
.text:00003B3A                 add     eax, 4
.text:00003B3D                 push    eax
.text:00003B3E                 mov     ecx, [ebp+var_10]
.text:00003B41                 add     ecx, 4
.text:00003B44                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00003B49                 mov     [ebp+var_4], 0
.text:00003B50                 mov     ecx, [ebp+arg_0]
.text:00003B53                 add     ecx, 10h
.text:00003B56                 push    ecx
.text:00003B57                 mov     ecx, [ebp+var_10]
.text:00003B5A                 add     ecx, 10h
.text:00003B5D                 call    ??0?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@ABV0@@Z ; CObjectVector<NWildcard::CCensorNode>::CObjectVector<NWildcard::CCensorNode>(CObjectVector<NWildcard::CCensorNode> const &)
.text:00003B62                 mov     byte ptr [ebp+var_4], 1
.text:00003B66                 mov     edx, [ebp+arg_0]
.text:00003B69                 add     edx, 1Ch
.text:00003B6C                 push    edx
.text:00003B6D                 mov     ecx, [ebp+var_10]
.text:00003B70                 add     ecx, 1Ch
.text:00003B73                 call    ??0?$CObjectVector@UCItem@NWildcard@@@@QAE@ABV0@@Z ; CObjectVector<NWildcard::CItem>::CObjectVector<NWildcard::CItem>(CObjectVector<NWildcard::CItem> const &)
.text:00003B78                 mov     byte ptr [ebp+var_4], 2
.text:00003B7C                 mov     eax, [ebp+arg_0]
.text:00003B7F                 add     eax, 28h ; '('
.text:00003B82                 push    eax
.text:00003B83                 mov     ecx, [ebp+var_10]
.text:00003B86                 add     ecx, 28h ; '('
.text:00003B89                 call    ??0?$CObjectVector@UCItem@NWildcard@@@@QAE@ABV0@@Z ; CObjectVector<NWildcard::CItem>::CObjectVector<NWildcard::CItem>(CObjectVector<NWildcard::CItem> const &)
.text:00003B8E                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00003B95                 mov     eax, [ebp+var_10]
.text:00003B98                 mov     ecx, [ebp+var_C]
.text:00003B9B                 mov     large fs:0, ecx
.text:00003BA2                 pop     ecx
.text:00003BA3                 add     esp, 10h
.text:00003BA6                 cmp     ebp, esp
.text:00003BA8                 call    __RTC_CheckEsp
.text:00003BAD                 mov     esp, ebp
.text:00003BAF                 pop     ebp
.text:00003BB0                 retn    4
.text:00003BB0 ??0CCensorNode@NWildcard@@QAE@ABV01@@Z endp
.text:00003BB0
.text:00003BB0 ; ---------------------------------------------------------------------------
.text:00003BB3                 align 4
.text:00003BB3 _text           ends
.text:00003BB3
.text$x:00003BB4 ; ===========================================================================
.text$x:00003BB4
.text$x:00003BB4 ; Segment type: Pure code
.text$x:00003BB4 ; Segment permissions: Read/Execute
.text$x:00003BB4 _text$x         segment para public 'CODE' use32
.text$x:00003BB4                 assume cs:_text$x
.text$x:00003BB4                 ;org 3BB4h
.text$x:00003BB4 ; COMDAT (pick associative to section at 3B00)
.text$x:00003BB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003BB4
.text$x:00003BB4 ; =============== S U B R O U T I N E =======================================
.text$x:00003BB4
.text$x:00003BB4
.text$x:00003BB4 __unwindfunclet$??0CCensorNode@NWildcard@@QAE@ABV01@@Z$0 proc near
.text$x:00003BB4                                         ; DATA XREF: .xdata$x:00003BF4o
.text$x:00003BB4                 mov     ecx, [ebp-10h]
.text$x:00003BB7                 add     ecx, 4          ; this
.text$x:00003BBA                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00003BBA __unwindfunclet$??0CCensorNode@NWildcard@@QAE@ABV01@@Z$0 endp
.text$x:00003BBA
.text$x:00003BBF
.text$x:00003BBF ; =============== S U B R O U T I N E =======================================
.text$x:00003BBF
.text$x:00003BBF
.text$x:00003BBF __unwindfunclet$??0CCensorNode@NWildcard@@QAE@ABV01@@Z$1 proc near
.text$x:00003BBF                                         ; DATA XREF: .xdata$x:00003BFCo
.text$x:00003BBF                 mov     ecx, [ebp-10h]
.text$x:00003BC2                 add     ecx, 10h
.text$x:00003BC5                 jmp     ??1?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@XZ ; CObjectVector<NWildcard::CCensorNode>::~CObjectVector<NWildcard::CCensorNode>(void)
.text$x:00003BC5 __unwindfunclet$??0CCensorNode@NWildcard@@QAE@ABV01@@Z$1 endp
.text$x:00003BC5
.text$x:00003BCA
.text$x:00003BCA ; =============== S U B R O U T I N E =======================================
.text$x:00003BCA
.text$x:00003BCA
.text$x:00003BCA __unwindfunclet$??0CCensorNode@NWildcard@@QAE@ABV01@@Z$2 proc near
.text$x:00003BCA                                         ; DATA XREF: .xdata$x:00003C04o
.text$x:00003BCA                 mov     ecx, [ebp-10h]
.text$x:00003BCD                 add     ecx, 1Ch
.text$x:00003BD0                 jmp     ??1?$CObjectVector@UCItem@NWildcard@@@@QAE@XZ ; CObjectVector<NWildcard::CItem>::~CObjectVector<NWildcard::CItem>(void)
.text$x:00003BD0 __unwindfunclet$??0CCensorNode@NWildcard@@QAE@ABV01@@Z$2 endp
.text$x:00003BD0
.text$x:00003BD5
.text$x:00003BD5 ; =============== S U B R O U T I N E =======================================
.text$x:00003BD5
.text$x:00003BD5
.text$x:00003BD5 __ehhandler$??0CCensorNode@NWildcard@@QAE@ABV01@@Z proc near
.text$x:00003BD5                                         ; DATA XREF: NWildcard::CCensorNode::CCensorNode(NWildcard::CCensorNode const &)+5o
.text$x:00003BD5
.text$x:00003BD5 arg_4           = dword ptr  8
.text$x:00003BD5
.text$x:00003BD5                 mov     edx, [esp+arg_4]
.text$x:00003BD9                 lea     eax, [edx+0Ch]
.text$x:00003BDC                 mov     ecx, [edx-8]
.text$x:00003BDF                 xor     ecx, eax
.text$x:00003BE1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003BE6                 mov     eax, offset __ehfuncinfo$??0CCensorNode@NWildcard@@QAE@ABV01@@Z
.text$x:00003BEB                 jmp     ___CxxFrameHandler3
.text$x:00003BEB __ehhandler$??0CCensorNode@NWildcard@@QAE@ABV01@@Z endp
.text$x:00003BEB
.text$x:00003BEB _text$x         ends
.text$x:00003BEB
.xdata$x:00003BF0 ; ===========================================================================
.xdata$x:00003BF0
.xdata$x:00003BF0 ; Segment type: Pure data
.xdata$x:00003BF0 ; Segment permissions: Read
.xdata$x:00003BF0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003BF0                 assume cs:_xdata$x
.xdata$x:00003BF0                 ;org 3BF0h
.xdata$x:00003BF0 ; COMDAT (pick associative to section at 3B00)
.xdata$x:00003BF0 __unwindtable$??0CCensorNode@NWildcard@@QAE@ABV01@@Z db 0FFh
.xdata$x:00003BF0                                         ; DATA XREF: .xdata$x:00003C10o
.xdata$x:00003BF1                 db 0FFh
.xdata$x:00003BF2                 db 0FFh
.xdata$x:00003BF3                 db 0FFh
.xdata$x:00003BF4                 dd offset __unwindfunclet$??0CCensorNode@NWildcard@@QAE@ABV01@@Z$0
.xdata$x:00003BF8                 db    0
.xdata$x:00003BF9                 db    0
.xdata$x:00003BFA                 db    0
.xdata$x:00003BFB                 db    0
.xdata$x:00003BFC                 dd offset __unwindfunclet$??0CCensorNode@NWildcard@@QAE@ABV01@@Z$1
.xdata$x:00003C00                 db    1
.xdata$x:00003C01                 db    0
.xdata$x:00003C02                 db    0
.xdata$x:00003C03                 db    0
.xdata$x:00003C04                 dd offset __unwindfunclet$??0CCensorNode@NWildcard@@QAE@ABV01@@Z$2
.xdata$x:00003C08 __ehfuncinfo$??0CCensorNode@NWildcard@@QAE@ABV01@@Z db  22h ; "
.xdata$x:00003C08                                         ; DATA XREF: __ehhandler$??0CCensorNode@NWildcard@@QAE@ABV01@@Z+11o
.xdata$x:00003C09                 db    5
.xdata$x:00003C0A                 db  93h ; ô
.xdata$x:00003C0B                 db  19h
.xdata$x:00003C0C                 db    3
.xdata$x:00003C0D                 db    0
.xdata$x:00003C0E                 db    0
.xdata$x:00003C0F                 db    0
.xdata$x:00003C10                 dd offset __unwindtable$??0CCensorNode@NWildcard@@QAE@ABV01@@Z
.xdata$x:00003C14                 db    0
.xdata$x:00003C15                 db    0
.xdata$x:00003C16                 db    0
.xdata$x:00003C17                 db    0
.xdata$x:00003C18                 db    0
.xdata$x:00003C19                 db    0
.xdata$x:00003C1A                 db    0
.xdata$x:00003C1B                 db    0
.xdata$x:00003C1C                 db    0
.xdata$x:00003C1D                 db    0
.xdata$x:00003C1E                 db    0
.xdata$x:00003C1F                 db    0
.xdata$x:00003C20                 db    0
.xdata$x:00003C21                 db    0
.xdata$x:00003C22                 db    0
.xdata$x:00003C23                 db    0
.xdata$x:00003C24                 db    0
.xdata$x:00003C25                 db    0
.xdata$x:00003C26                 db    0
.xdata$x:00003C27                 db    0
.xdata$x:00003C28                 db    1
.xdata$x:00003C29                 db    0
.xdata$x:00003C2A                 db    0
.xdata$x:00003C2B                 db    0
.xdata$x:00003C2B _xdata$x        ends
.xdata$x:00003C2B
.text:00003C2C ; ===========================================================================
.text:00003C2C
.text:00003C2C ; Segment type: Pure code
.text:00003C2C ; Segment permissions: Read/Execute
.text:00003C2C _text           segment para public 'CODE' use32
.text:00003C2C                 assume cs:_text
.text:00003C2C                 ;org 3C2Ch
.text:00003C2C ; COMDAT (pick any)
.text:00003C2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003C2C
.text:00003C2C ; =============== S U B R O U T I N E =======================================
.text:00003C2C
.text:00003C2C ; Attributes: bp-based frame
.text:00003C2C
.text:00003C2C ; public: void * __thiscall NWildcard::CCensorNode::`scalar deleting destructor'(unsigned int)
.text:00003C2C                 public ??_GCCensorNode@NWildcard@@QAEPAXI@Z
.text:00003C2C ??_GCCensorNode@NWildcard@@QAEPAXI@Z proc near
.text:00003C2C                                         ; CODE XREF: CObjectVector<NWildcard::CCensorNode>::~CObjectVector<NWildcard::CCensorNode>(void)+7Fp
.text:00003C2C
.text:00003C2C var_4           = dword ptr -4
.text:00003C2C arg_0           = dword ptr  8
.text:00003C2C
.text:00003C2C                 push    ebp
.text:00003C2D                 mov     ebp, esp
.text:00003C2F                 push    ecx
.text:00003C30                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003C37                 mov     [ebp+var_4], ecx
.text:00003C3A                 mov     ecx, [ebp+var_4] ; this
.text:00003C3D                 call    ??1CCensorNode@NWildcard@@QAE@XZ ; NWildcard::CCensorNode::~CCensorNode(void)
.text:00003C42                 mov     eax, [ebp+arg_0]
.text:00003C45                 and     eax, 1
.text:00003C48                 jz      short loc_3C56
.text:00003C4A                 mov     ecx, [ebp+var_4]
.text:00003C4D                 push    ecx             ; void *
.text:00003C4E                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00003C53                 add     esp, 4
.text:00003C56
.text:00003C56 loc_3C56:                               ; CODE XREF: NWildcard::CCensorNode::`scalar deleting destructor'(uint)+1Cj
.text:00003C56                 mov     eax, [ebp+var_4]
.text:00003C59                 add     esp, 4
.text:00003C5C                 cmp     ebp, esp
.text:00003C5E                 call    __RTC_CheckEsp
.text:00003C63                 mov     esp, ebp
.text:00003C65                 pop     ebp
.text:00003C66                 retn    4
.text:00003C66 ??_GCCensorNode@NWildcard@@QAEPAXI@Z endp
.text:00003C66
.text:00003C66 ; ---------------------------------------------------------------------------
.text:00003C69                 align 4
.text:00003C69 _text           ends
.text:00003C69
.text:00003C6C ; ===========================================================================
.text:00003C6C
.text:00003C6C ; Segment type: Pure code
.text:00003C6C ; Segment permissions: Read/Execute
.text:00003C6C _text           segment para public 'CODE' use32
.text:00003C6C                 assume cs:_text
.text:00003C6C                 ;org 3C6Ch
.text:00003C6C ; COMDAT (pick any)
.text:00003C6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003C6C
.text:00003C6C ; =============== S U B R O U T I N E =======================================
.text:00003C6C
.text:00003C6C ; Attributes: bp-based frame
.text:00003C6C
.text:00003C6C ; _DWORD __thiscall NWildcard::CItem::CItem(NWildcard::CItem *this, const struct NWildcard::CItem *)
.text:00003C6C                 public ??0CItem@NWildcard@@QAE@ABU01@@Z
.text:00003C6C ??0CItem@NWildcard@@QAE@ABU01@@Z proc near
.text:00003C6C                                         ; CODE XREF: CObjectVector<NWildcard::CItem>::operator+=(CObjectVector<NWildcard::CItem> const &)+A2p
.text:00003C6C                                         ; CObjectVector<NWildcard::CItem>::Add(NWildcard::CItem const &)+5Ap ...
.text:00003C6C
.text:00003C6C var_4           = dword ptr -4
.text:00003C6C arg_0           = dword ptr  8
.text:00003C6C
.text:00003C6C                 push    ebp
.text:00003C6D                 mov     ebp, esp
.text:00003C6F                 push    ecx
.text:00003C70                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003C77                 mov     [ebp+var_4], ecx
.text:00003C7A                 mov     eax, [ebp+arg_0]
.text:00003C7D                 push    eax
.text:00003C7E                 mov     ecx, [ebp+var_4]
.text:00003C81                 call    ??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z ; CObjectVector<UString>::CObjectVector<UString>(CObjectVector<UString> const &)
.text:00003C86                 mov     ecx, [ebp+var_4]
.text:00003C89                 mov     edx, [ebp+arg_0]
.text:00003C8C                 mov     al, [edx+0Ch]
.text:00003C8F                 mov     [ecx+0Ch], al
.text:00003C92                 mov     ecx, [ebp+var_4]
.text:00003C95                 mov     edx, [ebp+arg_0]
.text:00003C98                 mov     al, [edx+0Dh]
.text:00003C9B                 mov     [ecx+0Dh], al
.text:00003C9E                 mov     ecx, [ebp+var_4]
.text:00003CA1                 mov     edx, [ebp+arg_0]
.text:00003CA4                 mov     al, [edx+0Eh]
.text:00003CA7                 mov     [ecx+0Eh], al
.text:00003CAA                 mov     ecx, [ebp+var_4]
.text:00003CAD                 mov     edx, [ebp+arg_0]
.text:00003CB0                 mov     al, [edx+0Fh]
.text:00003CB3                 mov     [ecx+0Fh], al
.text:00003CB6                 mov     eax, [ebp+var_4]
.text:00003CB9                 add     esp, 4
.text:00003CBC                 cmp     ebp, esp
.text:00003CBE                 call    __RTC_CheckEsp
.text:00003CC3                 mov     esp, ebp
.text:00003CC5                 pop     ebp
.text:00003CC6                 retn    4
.text:00003CC6 ??0CItem@NWildcard@@QAE@ABU01@@Z endp
.text:00003CC6
.text:00003CC6 ; ---------------------------------------------------------------------------
.text:00003CC9                 align 4
.text:00003CC9 _text           ends
.text:00003CC9
.text:00003CCC ; ===========================================================================
.text:00003CCC
.text:00003CCC ; Segment type: Pure code
.text:00003CCC ; Segment permissions: Read/Execute
.text:00003CCC _text           segment para public 'CODE' use32
.text:00003CCC                 assume cs:_text
.text:00003CCC                 ;org 3CCCh
.text:00003CCC ; COMDAT (pick any)
.text:00003CCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003CCC
.text:00003CCC ; =============== S U B R O U T I N E =======================================
.text:00003CCC
.text:00003CCC ; Attributes: bp-based frame
.text:00003CCC
.text:00003CCC ; public: void * __thiscall NWildcard::CItem::`scalar deleting destructor'(unsigned int)
.text:00003CCC                 public ??_GCItem@NWildcard@@QAEPAXI@Z
.text:00003CCC ??_GCItem@NWildcard@@QAEPAXI@Z proc near
.text:00003CCC                                         ; CODE XREF: CObjectVector<NWildcard::CItem>::~CObjectVector<NWildcard::CItem>(void)+7Fp
.text:00003CCC
.text:00003CCC var_4           = dword ptr -4
.text:00003CCC arg_0           = dword ptr  8
.text:00003CCC
.text:00003CCC                 push    ebp
.text:00003CCD                 mov     ebp, esp
.text:00003CCF                 push    ecx
.text:00003CD0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003CD7                 mov     [ebp+var_4], ecx
.text:00003CDA                 mov     ecx, [ebp+var_4] ; this
.text:00003CDD                 call    ??1CItem@NWildcard@@QAE@XZ ; NWildcard::CItem::~CItem(void)
.text:00003CE2                 mov     eax, [ebp+arg_0]
.text:00003CE5                 and     eax, 1
.text:00003CE8                 jz      short loc_3CF6
.text:00003CEA                 mov     ecx, [ebp+var_4]
.text:00003CED                 push    ecx             ; void *
.text:00003CEE                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00003CF3                 add     esp, 4
.text:00003CF6
.text:00003CF6 loc_3CF6:                               ; CODE XREF: NWildcard::CItem::`scalar deleting destructor'(uint)+1Cj
.text:00003CF6                 mov     eax, [ebp+var_4]
.text:00003CF9                 add     esp, 4
.text:00003CFC                 cmp     ebp, esp
.text:00003CFE                 call    __RTC_CheckEsp
.text:00003D03                 mov     esp, ebp
.text:00003D05                 pop     ebp
.text:00003D06                 retn    4
.text:00003D06 ??_GCItem@NWildcard@@QAEPAXI@Z endp
.text:00003D06
.text:00003D06 ; ---------------------------------------------------------------------------
.text:00003D09                 align 4
.text:00003D09 _text           ends
.text:00003D09
.text:00003D0C ; ===========================================================================
.text:00003D0C
.text:00003D0C ; Segment type: Pure code
.text:00003D0C ; Segment permissions: Read/Execute
.text:00003D0C _text           segment para public 'CODE' use32
.text:00003D0C                 assume cs:_text
.text:00003D0C                 ;org 3D0Ch
.text:00003D0C ; COMDAT (pick any)
.text:00003D0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003D0C
.text:00003D0C ; =============== S U B R O U T I N E =======================================
.text:00003D0C
.text:00003D0C ; Attributes: bp-based frame
.text:00003D0C
.text:00003D0C ; _DWORD __thiscall NWildcard::CPair::CPair(NWildcard::CPair *this, const struct NWildcard::CPair *)
.text:00003D0C                 public ??0CPair@NWildcard@@QAE@ABU01@@Z
.text:00003D0C ??0CPair@NWildcard@@QAE@ABU01@@Z proc near
.text:00003D0C                                         ; CODE XREF: CObjectVector<NWildcard::CPair>::Add(NWildcard::CPair const &)+5Ap
.text:00003D0C
.text:00003D0C var_10          = dword ptr -10h
.text:00003D0C var_C           = dword ptr -0Ch
.text:00003D0C var_4           = dword ptr -4
.text:00003D0C arg_0           = dword ptr  8
.text:00003D0C
.text:00003D0C                 push    ebp
.text:00003D0D                 mov     ebp, esp
.text:00003D0F                 push    0FFFFFFFFh
.text:00003D11                 push    offset __ehhandler$??0CPair@NWildcard@@QAE@ABU01@@Z
.text:00003D16                 mov     eax, large fs:0
.text:00003D1C                 push    eax
.text:00003D1D                 push    ecx
.text:00003D1E                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00003D25                 mov     eax, dword ptr ds:___security_cookie
.text:00003D2A                 xor     eax, ebp
.text:00003D2C                 push    eax
.text:00003D2D                 lea     eax, [ebp+var_C]
.text:00003D30                 mov     large fs:0, eax
.text:00003D36                 mov     [ebp+var_10], ecx
.text:00003D39                 mov     eax, [ebp+arg_0]
.text:00003D3C                 push    eax
.text:00003D3D                 mov     ecx, [ebp+var_10]
.text:00003D40                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00003D45                 mov     [ebp+var_4], 0
.text:00003D4C                 mov     ecx, [ebp+arg_0]
.text:00003D4F                 add     ecx, 0Ch
.text:00003D52                 push    ecx             ; struct NWildcard::CCensorNode *
.text:00003D53                 mov     ecx, [ebp+var_10]
.text:00003D56                 add     ecx, 0Ch        ; this
.text:00003D59                 call    ??0CCensorNode@NWildcard@@QAE@ABV01@@Z ; NWildcard::CCensorNode::CCensorNode(NWildcard::CCensorNode const &)
.text:00003D5E                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00003D65                 mov     eax, [ebp+var_10]
.text:00003D68                 mov     ecx, [ebp+var_C]
.text:00003D6B                 mov     large fs:0, ecx
.text:00003D72                 pop     ecx
.text:00003D73                 add     esp, 10h
.text:00003D76                 cmp     ebp, esp
.text:00003D78                 call    __RTC_CheckEsp
.text:00003D7D                 mov     esp, ebp
.text:00003D7F                 pop     ebp
.text:00003D80                 retn    4
.text:00003D80 ??0CPair@NWildcard@@QAE@ABU01@@Z endp
.text:00003D80
.text:00003D80 ; ---------------------------------------------------------------------------
.text:00003D83                 align 4
.text:00003D83 _text           ends
.text:00003D83
.text$x:00003D84 ; ===========================================================================
.text$x:00003D84
.text$x:00003D84 ; Segment type: Pure code
.text$x:00003D84 ; Segment permissions: Read/Execute
.text$x:00003D84 _text$x         segment para public 'CODE' use32
.text$x:00003D84                 assume cs:_text$x
.text$x:00003D84                 ;org 3D84h
.text$x:00003D84 ; COMDAT (pick associative to section at 3D0C)
.text$x:00003D84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003D84
.text$x:00003D84 ; =============== S U B R O U T I N E =======================================
.text$x:00003D84
.text$x:00003D84
.text$x:00003D84 __unwindfunclet$??0CPair@NWildcard@@QAE@ABU01@@Z$0 proc near
.text$x:00003D84                                         ; DATA XREF: .xdata$x:00003DACo
.text$x:00003D84                 mov     ecx, [ebp-10h]  ; this
.text$x:00003D87                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00003D87 __unwindfunclet$??0CPair@NWildcard@@QAE@ABU01@@Z$0 endp
.text$x:00003D87
.text$x:00003D8C
.text$x:00003D8C ; =============== S U B R O U T I N E =======================================
.text$x:00003D8C
.text$x:00003D8C
.text$x:00003D8C __ehhandler$??0CPair@NWildcard@@QAE@ABU01@@Z proc near
.text$x:00003D8C                                         ; DATA XREF: NWildcard::CPair::CPair(NWildcard::CPair const &)+5o
.text$x:00003D8C
.text$x:00003D8C arg_4           = dword ptr  8
.text$x:00003D8C
.text$x:00003D8C                 mov     edx, [esp+arg_4]
.text$x:00003D90                 lea     eax, [edx+0Ch]
.text$x:00003D93                 mov     ecx, [edx-8]
.text$x:00003D96                 xor     ecx, eax
.text$x:00003D98                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003D9D                 mov     eax, offset __ehfuncinfo$??0CPair@NWildcard@@QAE@ABU01@@Z
.text$x:00003DA2                 jmp     ___CxxFrameHandler3
.text$x:00003DA2 __ehhandler$??0CPair@NWildcard@@QAE@ABU01@@Z endp
.text$x:00003DA2
.text$x:00003DA2 ; ---------------------------------------------------------------------------
.text$x:00003DA7                 align 4
.text$x:00003DA7 _text$x         ends
.text$x:00003DA7
.xdata$x:00003DA8 ; ===========================================================================
.xdata$x:00003DA8
.xdata$x:00003DA8 ; Segment type: Pure data
.xdata$x:00003DA8 ; Segment permissions: Read
.xdata$x:00003DA8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003DA8                 assume cs:_xdata$x
.xdata$x:00003DA8                 ;org 3DA8h
.xdata$x:00003DA8 ; COMDAT (pick associative to section at 3D0C)
.xdata$x:00003DA8 __unwindtable$??0CPair@NWildcard@@QAE@ABU01@@Z db 0FFh
.xdata$x:00003DA8                                         ; DATA XREF: .xdata$x:00003DB8o
.xdata$x:00003DA9                 db 0FFh
.xdata$x:00003DAA                 db 0FFh
.xdata$x:00003DAB                 db 0FFh
.xdata$x:00003DAC                 dd offset __unwindfunclet$??0CPair@NWildcard@@QAE@ABU01@@Z$0
.xdata$x:00003DB0 __ehfuncinfo$??0CPair@NWildcard@@QAE@ABU01@@Z db  22h ; "
.xdata$x:00003DB0                                         ; DATA XREF: __ehhandler$??0CPair@NWildcard@@QAE@ABU01@@Z+11o
.xdata$x:00003DB1                 db    5
.xdata$x:00003DB2                 db  93h ; ô
.xdata$x:00003DB3                 db  19h
.xdata$x:00003DB4                 db    1
.xdata$x:00003DB5                 db    0
.xdata$x:00003DB6                 db    0
.xdata$x:00003DB7                 db    0
.xdata$x:00003DB8                 dd offset __unwindtable$??0CPair@NWildcard@@QAE@ABU01@@Z
.xdata$x:00003DBC                 db    0
.xdata$x:00003DBD                 db    0
.xdata$x:00003DBE                 db    0
.xdata$x:00003DBF                 db    0
.xdata$x:00003DC0                 db    0
.xdata$x:00003DC1                 db    0
.xdata$x:00003DC2                 db    0
.xdata$x:00003DC3                 db    0
.xdata$x:00003DC4                 db    0
.xdata$x:00003DC5                 db    0
.xdata$x:00003DC6                 db    0
.xdata$x:00003DC7                 db    0
.xdata$x:00003DC8                 db    0
.xdata$x:00003DC9                 db    0
.xdata$x:00003DCA                 db    0
.xdata$x:00003DCB                 db    0
.xdata$x:00003DCC                 db    0
.xdata$x:00003DCD                 db    0
.xdata$x:00003DCE                 db    0
.xdata$x:00003DCF                 db    0
.xdata$x:00003DD0                 db    1
.xdata$x:00003DD1                 db    0
.xdata$x:00003DD2                 db    0
.xdata$x:00003DD3                 db    0
.xdata$x:00003DD3 _xdata$x        ends
.xdata$x:00003DD3
.text:00003DD4 ; ===========================================================================
.text:00003DD4
.text:00003DD4 ; Segment type: Pure code
.text:00003DD4 ; Segment permissions: Read/Execute
.text:00003DD4 _text           segment para public 'CODE' use32
.text:00003DD4                 assume cs:_text
.text:00003DD4                 ;org 3DD4h
.text:00003DD4 ; COMDAT (pick any)
.text:00003DD4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003DD4
.text:00003DD4 ; =============== S U B R O U T I N E =======================================
.text:00003DD4
.text:00003DD4 ; Attributes: bp-based frame
.text:00003DD4
.text:00003DD4 ; public: void * __thiscall NWildcard::CCensorPath::`scalar deleting destructor'(unsigned int)
.text:00003DD4                 public ??_GCCensorPath@NWildcard@@QAEPAXI@Z
.text:00003DD4 ??_GCCensorPath@NWildcard@@QAEPAXI@Z proc near
.text:00003DD4                                         ; CODE XREF: CObjectVector<NWildcard::CCensorPath>::Clear(void)+59p
.text:00003DD4
.text:00003DD4 var_4           = dword ptr -4
.text:00003DD4 arg_0           = dword ptr  8
.text:00003DD4
.text:00003DD4                 push    ebp
.text:00003DD5                 mov     ebp, esp
.text:00003DD7                 push    ecx
.text:00003DD8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003DDF                 mov     [ebp+var_4], ecx
.text:00003DE2                 mov     ecx, [ebp+var_4] ; this
.text:00003DE5                 call    ??1CCensorPath@NWildcard@@QAE@XZ ; NWildcard::CCensorPath::~CCensorPath(void)
.text:00003DEA                 mov     eax, [ebp+arg_0]
.text:00003DED                 and     eax, 1
.text:00003DF0                 jz      short loc_3DFE
.text:00003DF2                 mov     ecx, [ebp+var_4]
.text:00003DF5                 push    ecx             ; void *
.text:00003DF6                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00003DFB                 add     esp, 4
.text:00003DFE
.text:00003DFE loc_3DFE:                               ; CODE XREF: NWildcard::CCensorPath::`scalar deleting destructor'(uint)+1Cj
.text:00003DFE                 mov     eax, [ebp+var_4]
.text:00003E01                 add     esp, 4
.text:00003E04                 cmp     ebp, esp
.text:00003E06                 call    __RTC_CheckEsp
.text:00003E0B                 mov     esp, ebp
.text:00003E0D                 pop     ebp
.text:00003E0E                 retn    4
.text:00003E0E ??_GCCensorPath@NWildcard@@QAEPAXI@Z endp
.text:00003E0E
.text:00003E0E ; ---------------------------------------------------------------------------
.text:00003E11                 align 4
.text:00003E11 _text           ends
.text:00003E11
.text:00003E14 ; ===========================================================================
.text:00003E14
.text:00003E14 ; Segment type: Pure code
.text:00003E14 ; Segment permissions: Read/Execute
.text:00003E14 _text           segment para public 'CODE' use32
.text:00003E14                 assume cs:_text
.text:00003E14                 ;org 3E14h
.text:00003E14 ; COMDAT (pick any)
.text:00003E14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003E14
.text:00003E14 ; =============== S U B R O U T I N E =======================================
.text:00003E14
.text:00003E14 ; Attributes: bp-based frame
.text:00003E14
.text:00003E14 ; _DWORD __thiscall NWildcard::CCensorPath::~CCensorPath(NWildcard::CCensorPath *__hidden this)
.text:00003E14                 public ??1CCensorPath@NWildcard@@QAE@XZ
.text:00003E14 ??1CCensorPath@NWildcard@@QAE@XZ proc near
.text:00003E14                                         ; CODE XREF: NWildcard::CCensorPath::`scalar deleting destructor'(uint)+11p
.text:00003E14
.text:00003E14 var_4           = dword ptr -4
.text:00003E14
.text:00003E14                 push    ebp
.text:00003E15                 mov     ebp, esp
.text:00003E17                 push    ecx
.text:00003E18                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003E1F                 mov     [ebp+var_4], ecx
.text:00003E22                 mov     ecx, [ebp+var_4] ; this
.text:00003E25                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003E2A                 add     esp, 4
.text:00003E2D                 cmp     ebp, esp
.text:00003E2F                 call    __RTC_CheckEsp
.text:00003E34                 mov     esp, ebp
.text:00003E36                 pop     ebp
.text:00003E37                 retn
.text:00003E37 ??1CCensorPath@NWildcard@@QAE@XZ endp
.text:00003E37
.text:00003E37 _text           ends
.text:00003E37
.text:00003E38 ; ===========================================================================
.text:00003E38
.text:00003E38 ; Segment type: Pure code
.text:00003E38 ; Segment permissions: Read/Execute
.text:00003E38 _text           segment para public 'CODE' use32
.text:00003E38                 assume cs:_text
.text:00003E38                 ;org 3E38h
.text:00003E38 ; COMDAT (pick any)
.text:00003E38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003E38
.text:00003E38 ; =============== S U B R O U T I N E =======================================
.text:00003E38
.text:00003E38 ; Attributes: bp-based frame
.text:00003E38
.text:00003E38 ; public: __thiscall CRecordVector<void *>::CRecordVector<void *>(void)
.text:00003E38                 public ??0?$CRecordVector@PAX@@QAE@XZ
.text:00003E38 ??0?$CRecordVector@PAX@@QAE@XZ proc near
.text:00003E38                                         ; CODE XREF: CObjectVector<UString>::CObjectVector<UString>(void)+11p
.text:00003E38                                         ; CObjectVector<UString>::CObjectVector<UString>(CObjectVector<UString> const &)+42p ...
.text:00003E38
.text:00003E38 var_4           = dword ptr -4
.text:00003E38
.text:00003E38                 push    ebp
.text:00003E39                 mov     ebp, esp
.text:00003E3B                 push    ecx
.text:00003E3C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003E43                 mov     [ebp+var_4], ecx
.text:00003E46                 mov     eax, [ebp+var_4]
.text:00003E49                 mov     dword ptr [eax], 0
.text:00003E4F                 mov     ecx, [ebp+var_4]
.text:00003E52                 mov     dword ptr [ecx+4], 0
.text:00003E59                 mov     edx, [ebp+var_4]
.text:00003E5C                 mov     dword ptr [edx+8], 0
.text:00003E63                 mov     eax, [ebp+var_4]
.text:00003E66                 mov     esp, ebp
.text:00003E68                 pop     ebp
.text:00003E69                 retn
.text:00003E69 ??0?$CRecordVector@PAX@@QAE@XZ endp
.text:00003E69
.text:00003E69 ; ---------------------------------------------------------------------------
.text:00003E6A                 align 4
.text:00003E6A _text           ends
.text:00003E6A
.text:00003E6C ; ===========================================================================
.text:00003E6C
.text:00003E6C ; Segment type: Pure code
.text:00003E6C ; Segment permissions: Read/Execute
.text:00003E6C _text           segment para public 'CODE' use32
.text:00003E6C                 assume cs:_text
.text:00003E6C                 ;org 3E6Ch
.text:00003E6C ; COMDAT (pick any)
.text:00003E6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003E6C
.text:00003E6C ; =============== S U B R O U T I N E =======================================
.text:00003E6C
.text:00003E6C ; Attributes: bp-based frame
.text:00003E6C
.text:00003E6C ; public: unsigned int __thiscall CRecordVector<void *>::Size(void)const
.text:00003E6C                 public ?Size@?$CRecordVector@PAX@@QBEIXZ
.text:00003E6C ?Size@?$CRecordVector@PAX@@QBEIXZ proc near
.text:00003E6C                                         ; CODE XREF: CObjectVector<UString>::Size(void)+11p
.text:00003E6C                                         ; CObjectVector<UString>::Back(void)+11p ...
.text:00003E6C
.text:00003E6C var_4           = dword ptr -4
.text:00003E6C
.text:00003E6C                 push    ebp
.text:00003E6D                 mov     ebp, esp
.text:00003E6F                 push    ecx
.text:00003E70                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003E77                 mov     [ebp+var_4], ecx
.text:00003E7A                 mov     eax, [ebp+var_4]
.text:00003E7D                 mov     eax, [eax+4]
.text:00003E80                 mov     esp, ebp
.text:00003E82                 pop     ebp
.text:00003E83                 retn
.text:00003E83 ?Size@?$CRecordVector@PAX@@QBEIXZ endp
.text:00003E83
.text:00003E83 _text           ends
.text:00003E83
.text:00003E84 ; ===========================================================================
.text:00003E84
.text:00003E84 ; Segment type: Pure code
.text:00003E84 ; Segment permissions: Read/Execute
.text:00003E84 _text           segment para public 'CODE' use32
.text:00003E84                 assume cs:_text
.text:00003E84                 ;org 3E84h
.text:00003E84 ; COMDAT (pick any)
.text:00003E84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003E84
.text:00003E84 ; =============== S U B R O U T I N E =======================================
.text:00003E84
.text:00003E84 ; Attributes: bp-based frame
.text:00003E84
.text:00003E84 ; public: bool __thiscall CRecordVector<void *>::IsEmpty(void)const
.text:00003E84                 public ?IsEmpty@?$CRecordVector@PAX@@QBE_NXZ
.text:00003E84 ?IsEmpty@?$CRecordVector@PAX@@QBE_NXZ proc near
.text:00003E84                                         ; CODE XREF: CObjectVector<UString>::IsEmpty(void)+11p
.text:00003E84                                         ; CObjectVector<NWildcard::CCensorNode>::IsEmpty(void)+11p ...
.text:00003E84
.text:00003E84 var_4           = dword ptr -4
.text:00003E84
.text:00003E84                 push    ebp
.text:00003E85                 mov     ebp, esp
.text:00003E87                 push    ecx
.text:00003E88                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003E8F                 mov     [ebp+var_4], ecx
.text:00003E92                 mov     eax, [ebp+var_4]
.text:00003E95                 xor     ecx, ecx
.text:00003E97                 cmp     dword ptr [eax+4], 0
.text:00003E9B                 setz    cl
.text:00003E9E                 mov     al, cl
.text:00003EA0                 mov     esp, ebp
.text:00003EA2                 pop     ebp
.text:00003EA3                 retn
.text:00003EA3 ?IsEmpty@?$CRecordVector@PAX@@QBE_NXZ endp
.text:00003EA3
.text:00003EA3 _text           ends
.text:00003EA3
.text:00003EA4 ; ===========================================================================
.text:00003EA4
.text:00003EA4 ; Segment type: Pure code
.text:00003EA4 ; Segment permissions: Read/Execute
.text:00003EA4 _text           segment para public 'CODE' use32
.text:00003EA4                 assume cs:_text
.text:00003EA4                 ;org 3EA4h
.text:00003EA4 ; COMDAT (pick any)
.text:00003EA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003EA4
.text:00003EA4 ; =============== S U B R O U T I N E =======================================
.text:00003EA4
.text:00003EA4 ; Attributes: bp-based frame
.text:00003EA4
.text:00003EA4 ; public: void __thiscall CRecordVector<void *>::ConstructReserve(unsigned int)
.text:00003EA4                 public ?ConstructReserve@?$CRecordVector@PAX@@QAEXI@Z
.text:00003EA4 ?ConstructReserve@?$CRecordVector@PAX@@QAEXI@Z proc near
.text:00003EA4                                         ; CODE XREF: CObjectVector<UString>::CObjectVector<UString>(CObjectVector<UString> const &)+60p
.text:00003EA4                                         ; CObjectVector<NWildcard::CCensorNode>::CObjectVector<NWildcard::CCensorNode>(CObjectVector<NWildcard::CCensorNode> const &)+60p ...
.text:00003EA4
.text:00003EA4 var_8           = dword ptr -8
.text:00003EA4 var_4           = dword ptr -4
.text:00003EA4 arg_0           = dword ptr  8
.text:00003EA4
.text:00003EA4                 push    ebp
.text:00003EA5                 mov     ebp, esp
.text:00003EA7                 sub     esp, 8
.text:00003EAA                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00003EB1                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003EB8                 mov     [ebp+var_4], ecx
.text:00003EBB                 cmp     [ebp+arg_0], 0
.text:00003EBF                 jz      short loc_3EF1
.text:00003EC1                 xor     ecx, ecx
.text:00003EC3                 mov     eax, [ebp+arg_0]
.text:00003EC6                 mov     edx, 4
.text:00003ECB                 mul     edx
.text:00003ECD                 seto    cl
.text:00003ED0                 neg     ecx
.text:00003ED2                 or      ecx, eax
.text:00003ED4                 push    ecx             ; unsigned int
.text:00003ED5                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00003EDA                 add     esp, 4
.text:00003EDD                 mov     [ebp+var_8], eax
.text:00003EE0                 mov     eax, [ebp+var_4]
.text:00003EE3                 mov     ecx, [ebp+var_8]
.text:00003EE6                 mov     [eax], ecx
.text:00003EE8                 mov     edx, [ebp+var_4]
.text:00003EEB                 mov     eax, [ebp+arg_0]
.text:00003EEE                 mov     [edx+8], eax
.text:00003EF1
.text:00003EF1 loc_3EF1:                               ; CODE XREF: CRecordVector<void *>::ConstructReserve(uint)+1Bj
.text:00003EF1                 add     esp, 8
.text:00003EF4                 cmp     ebp, esp
.text:00003EF6                 call    __RTC_CheckEsp
.text:00003EFB                 mov     esp, ebp
.text:00003EFD                 pop     ebp
.text:00003EFE                 retn    4
.text:00003EFE ?ConstructReserve@?$CRecordVector@PAX@@QAEXI@Z endp
.text:00003EFE
.text:00003EFE ; ---------------------------------------------------------------------------
.text:00003F01                 align 4
.text:00003F01 _text           ends
.text:00003F01
.text:00003F04 ; ===========================================================================
.text:00003F04
.text:00003F04 ; Segment type: Pure code
.text:00003F04 ; Segment permissions: Read/Execute
.text:00003F04 _text           segment para public 'CODE' use32
.text:00003F04                 assume cs:_text
.text:00003F04                 ;org 3F04h
.text:00003F04 ; COMDAT (pick any)
.text:00003F04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003F04
.text:00003F04 ; =============== S U B R O U T I N E =======================================
.text:00003F04
.text:00003F04 ; Attributes: bp-based frame
.text:00003F04
.text:00003F04 ; public: void __thiscall CRecordVector<void *>::Reserve(unsigned int)
.text:00003F04                 public ?Reserve@?$CRecordVector@PAX@@QAEXI@Z
.text:00003F04 ?Reserve@?$CRecordVector@PAX@@QAEXI@Z proc near
.text:00003F04                                         ; CODE XREF: CObjectVector<UString>::operator=(CObjectVector<UString> const &)+69p
.text:00003F04                                         ; CObjectVector<NWildcard::CItem>::operator+=(CObjectVector<NWildcard::CItem> const &)+59p
.text:00003F04
.text:00003F04 var_10          = dword ptr -10h
.text:00003F04 var_C           = dword ptr -0Ch
.text:00003F04 Dst             = dword ptr -8
.text:00003F04 var_4           = dword ptr -4
.text:00003F04 arg_0           = dword ptr  8
.text:00003F04
.text:00003F04                 push    ebp
.text:00003F05                 mov     ebp, esp
.text:00003F07                 sub     esp, 10h
.text:00003F0A                 mov     eax, 0CCCCCCCCh
.text:00003F0F                 mov     [ebp+var_10], eax
.text:00003F12                 mov     [ebp+var_C], eax
.text:00003F15                 mov     [ebp+Dst], eax
.text:00003F18                 mov     [ebp+var_4], eax
.text:00003F1B                 mov     [ebp+var_4], ecx
.text:00003F1E                 mov     eax, [ebp+var_4]
.text:00003F21                 mov     ecx, [ebp+arg_0]
.text:00003F24                 cmp     ecx, [eax+8]
.text:00003F27                 jbe     short loc_3F98
.text:00003F29                 xor     ecx, ecx
.text:00003F2B                 mov     eax, [ebp+arg_0]
.text:00003F2E                 mov     edx, 4
.text:00003F33                 mul     edx
.text:00003F35                 seto    cl
.text:00003F38                 neg     ecx
.text:00003F3A                 or      ecx, eax
.text:00003F3C                 push    ecx             ; unsigned int
.text:00003F3D                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00003F42                 add     esp, 4
.text:00003F45                 mov     [ebp+var_C], eax
.text:00003F48                 mov     eax, [ebp+var_C]
.text:00003F4B                 mov     [ebp+Dst], eax
.text:00003F4E                 mov     ecx, [ebp+var_4]
.text:00003F51                 cmp     dword ptr [ecx+4], 0
.text:00003F55                 jz      short loc_3F73
.text:00003F57                 mov     edx, [ebp+var_4]
.text:00003F5A                 mov     eax, [edx+4]
.text:00003F5D                 shl     eax, 2
.text:00003F60                 push    eax             ; Size
.text:00003F61                 mov     ecx, [ebp+var_4]
.text:00003F64                 mov     edx, [ecx]
.text:00003F66                 push    edx             ; Src
.text:00003F67                 mov     eax, [ebp+Dst]
.text:00003F6A                 push    eax             ; Dst
.text:00003F6B                 call    _memcpy
.text:00003F70                 add     esp, 0Ch
.text:00003F73
.text:00003F73 loc_3F73:                               ; CODE XREF: CRecordVector<void *>::Reserve(uint)+51j
.text:00003F73                 mov     ecx, [ebp+var_4]
.text:00003F76                 mov     edx, [ecx]
.text:00003F78                 mov     [ebp+var_10], edx
.text:00003F7B                 mov     eax, [ebp+var_10]
.text:00003F7E                 push    eax             ; void *
.text:00003F7F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00003F84                 add     esp, 4
.text:00003F87                 mov     ecx, [ebp+var_4]
.text:00003F8A                 mov     edx, [ebp+Dst]
.text:00003F8D                 mov     [ecx], edx
.text:00003F8F                 mov     eax, [ebp+var_4]
.text:00003F92                 mov     ecx, [ebp+arg_0]
.text:00003F95                 mov     [eax+8], ecx
.text:00003F98
.text:00003F98 loc_3F98:                               ; CODE XREF: CRecordVector<void *>::Reserve(uint)+23j
.text:00003F98                 add     esp, 10h
.text:00003F9B                 cmp     ebp, esp
.text:00003F9D                 call    __RTC_CheckEsp
.text:00003FA2                 mov     esp, ebp
.text:00003FA4                 pop     ebp
.text:00003FA5                 retn    4
.text:00003FA5 ?Reserve@?$CRecordVector@PAX@@QAEXI@Z endp
.text:00003FA5
.text:00003FA5 _text           ends
.text:00003FA5
.text:00003FA8 ; ===========================================================================
.text:00003FA8
.text:00003FA8 ; Segment type: Pure code
.text:00003FA8 ; Segment permissions: Read/Execute
.text:00003FA8 _text           segment para public 'CODE' use32
.text:00003FA8                 assume cs:_text
.text:00003FA8                 ;org 3FA8h
.text:00003FA8 ; COMDAT (pick any)
.text:00003FA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003FA8
.text:00003FA8 ; =============== S U B R O U T I N E =======================================
.text:00003FA8
.text:00003FA8 ; Attributes: bp-based frame
.text:00003FA8
.text:00003FA8 ; public: __thiscall CRecordVector<void *>::~CRecordVector<void *>(void)
.text:00003FA8                 public ??1?$CRecordVector@PAX@@QAE@XZ
.text:00003FA8 ??1?$CRecordVector@PAX@@QAE@XZ proc near
.text:00003FA8                                         ; CODE XREF: __unwindfunclet$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z$0+3j
.text:00003FA8                                         ; CObjectVector<UString>::~CObjectVector<UString>(void)+9Cp ...
.text:00003FA8
.text:00003FA8 var_8           = dword ptr -8
.text:00003FA8 var_4           = dword ptr -4
.text:00003FA8
.text:00003FA8                 push    ebp
.text:00003FA9                 mov     ebp, esp
.text:00003FAB                 sub     esp, 8
.text:00003FAE                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00003FB5                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003FBC                 mov     [ebp+var_4], ecx
.text:00003FBF                 mov     eax, [ebp+var_4]
.text:00003FC2                 mov     ecx, [eax]
.text:00003FC4                 mov     [ebp+var_8], ecx
.text:00003FC7                 mov     edx, [ebp+var_8]
.text:00003FCA                 push    edx             ; void *
.text:00003FCB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00003FD0                 add     esp, 4
.text:00003FD3                 add     esp, 8
.text:00003FD6                 cmp     ebp, esp
.text:00003FD8                 call    __RTC_CheckEsp
.text:00003FDD                 mov     esp, ebp
.text:00003FDF                 pop     ebp
.text:00003FE0                 retn
.text:00003FE0 ??1?$CRecordVector@PAX@@QAE@XZ endp
.text:00003FE0
.text:00003FE0 ; ---------------------------------------------------------------------------
.text:00003FE1                 align 4
.text:00003FE1 _text           ends
.text:00003FE1
.text:00003FE4 ; ===========================================================================
.text:00003FE4
.text:00003FE4 ; Segment type: Pure code
.text:00003FE4 ; Segment permissions: Read/Execute
.text:00003FE4 _text           segment para public 'CODE' use32
.text:00003FE4                 assume cs:_text
.text:00003FE4                 ;org 3FE4h
.text:00003FE4 ; COMDAT (pick any)
.text:00003FE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003FE4
.text:00003FE4 ; =============== S U B R O U T I N E =======================================
.text:00003FE4
.text:00003FE4 ; Attributes: bp-based frame
.text:00003FE4
.text:00003FE4 ; public: void __thiscall CRecordVector<void *>::Clear(void)
.text:00003FE4                 public ?Clear@?$CRecordVector@PAX@@QAEXXZ
.text:00003FE4 ?Clear@?$CRecordVector@PAX@@QAEXXZ proc near
.text:00003FE4                                         ; CODE XREF: CObjectVector<UString>::Clear(void)+6Fp
.text:00003FE4                                         ; CObjectVector<NWildcard::CCensorPath>::Clear(void)+6Fp
.text:00003FE4
.text:00003FE4 var_4           = dword ptr -4
.text:00003FE4
.text:00003FE4                 push    ebp
.text:00003FE5                 mov     ebp, esp
.text:00003FE7                 push    ecx
.text:00003FE8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003FEF                 mov     [ebp+var_4], ecx
.text:00003FF2                 mov     eax, [ebp+var_4]
.text:00003FF5                 mov     dword ptr [eax+4], 0
.text:00003FFC                 mov     esp, ebp
.text:00003FFE                 pop     ebp
.text:00003FFF                 retn
.text:00003FFF ?Clear@?$CRecordVector@PAX@@QAEXXZ endp
.text:00003FFF
.text:00003FFF _text           ends
.text:00003FFF
.text:00004000 ; ===========================================================================
.text:00004000
.text:00004000 ; Segment type: Pure code
.text:00004000 ; Segment permissions: Read/Execute
.text:00004000 _text           segment para public 'CODE' use32
.text:00004000                 assume cs:_text
.text:00004000                 ;org 4000h
.text:00004000 ; COMDAT (pick any)
.text:00004000                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004000
.text:00004000 ; =============== S U B R O U T I N E =======================================
.text:00004000
.text:00004000 ; Attributes: bp-based frame
.text:00004000
.text:00004000 ; public: void __thiscall CRecordVector<void *>::DeleteBack(void)
.text:00004000                 public ?DeleteBack@?$CRecordVector@PAX@@QAEXXZ
.text:00004000 ?DeleteBack@?$CRecordVector@PAX@@QAEXXZ proc near
.text:00004000                                         ; CODE XREF: CObjectVector<UString>::DeleteBack(void)+58p
.text:00004000
.text:00004000 var_4           = dword ptr -4
.text:00004000
.text:00004000                 push    ebp
.text:00004001                 mov     ebp, esp
.text:00004003                 push    ecx
.text:00004004                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000400B                 mov     [ebp+var_4], ecx
.text:0000400E                 mov     eax, [ebp+var_4]
.text:00004011                 mov     ecx, [eax+4]
.text:00004014                 sub     ecx, 1
.text:00004017                 mov     edx, [ebp+var_4]
.text:0000401A                 mov     [edx+4], ecx
.text:0000401D                 mov     esp, ebp
.text:0000401F                 pop     ebp
.text:00004020                 retn
.text:00004020 ?DeleteBack@?$CRecordVector@PAX@@QAEXXZ endp
.text:00004020
.text:00004020 ; ---------------------------------------------------------------------------
.text:00004021                 align 4
.text:00004021 _text           ends
.text:00004021
.text:00004024 ; ===========================================================================
.text:00004024
.text:00004024 ; Segment type: Pure code
.text:00004024 ; Segment permissions: Read/Execute
.text:00004024 _text           segment para public 'CODE' use32
.text:00004024                 assume cs:_text
.text:00004024                 ;org 4024h
.text:00004024 ; COMDAT (pick any)
.text:00004024                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004024
.text:00004024 ; =============== S U B R O U T I N E =======================================
.text:00004024
.text:00004024 ; Attributes: bp-based frame
.text:00004024
.text:00004024 ; public: void __thiscall CRecordVector<void *>::Delete(unsigned int)
.text:00004024                 public ?Delete@?$CRecordVector@PAX@@QAEXI@Z
.text:00004024 ?Delete@?$CRecordVector@PAX@@QAEXI@Z proc near
.text:00004024                                         ; CODE XREF: CObjectVector<UString>::Delete(uint)+54p
.text:00004024
.text:00004024 var_4           = dword ptr -4
.text:00004024 arg_0           = dword ptr  8
.text:00004024
.text:00004024                 push    ebp
.text:00004025                 mov     ebp, esp
.text:00004027                 push    ecx
.text:00004028                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000402F                 mov     [ebp+var_4], ecx
.text:00004032                 mov     eax, [ebp+arg_0]
.text:00004035                 add     eax, 1
.text:00004038                 push    eax
.text:00004039                 mov     ecx, [ebp+arg_0]
.text:0000403C                 push    ecx
.text:0000403D                 mov     ecx, [ebp+var_4]
.text:00004040                 call    ?MoveItems@?$CRecordVector@PAX@@AAEXII@Z ; CRecordVector<void *>::MoveItems(uint,uint)
.text:00004045                 mov     edx, [ebp+var_4]
.text:00004048                 mov     eax, [edx+4]
.text:0000404B                 sub     eax, 1
.text:0000404E                 mov     ecx, [ebp+var_4]
.text:00004051                 mov     [ecx+4], eax
.text:00004054                 add     esp, 4
.text:00004057                 cmp     ebp, esp
.text:00004059                 call    __RTC_CheckEsp
.text:0000405E                 mov     esp, ebp
.text:00004060                 pop     ebp
.text:00004061                 retn    4
.text:00004061 ?Delete@?$CRecordVector@PAX@@QAEXI@Z endp
.text:00004061
.text:00004061 _text           ends
.text:00004061
.text:00004064 ; ===========================================================================
.text:00004064
.text:00004064 ; Segment type: Pure code
.text:00004064 ; Segment permissions: Read/Execute
.text:00004064 _text           segment para public 'CODE' use32
.text:00004064                 assume cs:_text
.text:00004064                 ;org 4064h
.text:00004064 ; COMDAT (pick any)
.text:00004064                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004064
.text:00004064 ; =============== S U B R O U T I N E =======================================
.text:00004064
.text:00004064 ; Attributes: bp-based frame
.text:00004064
.text:00004064 ; public: unsigned int __thiscall CRecordVector<void *>::Add(void * const)
.text:00004064                 public ?Add@?$CRecordVector@PAX@@QAEIQAX@Z
.text:00004064 ?Add@?$CRecordVector@PAX@@QAEIQAX@Z proc near
.text:00004064                                         ; CODE XREF: CObjectVector<UString>::Add(UString const &)+7Fp
.text:00004064                                         ; CObjectVector<NWildcard::CCensorNode>::Add(NWildcard::CCensorNode const &)+7Fp ...
.text:00004064
.text:00004064 var_8           = dword ptr -8
.text:00004064 var_4           = dword ptr -4
.text:00004064 arg_0           = dword ptr  8
.text:00004064
.text:00004064                 push    ebp
.text:00004065                 mov     ebp, esp
.text:00004067                 sub     esp, 8
.text:0000406A                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00004071                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00004078                 mov     [ebp+var_4], ecx
.text:0000407B                 mov     ecx, [ebp+var_4]
.text:0000407E                 call    ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ ; CRecordVector<void *>::ReserveOnePosition(void)
.text:00004083                 mov     eax, [ebp+var_4]
.text:00004086                 mov     ecx, [eax+4]
.text:00004089                 mov     edx, [ebp+var_4]
.text:0000408C                 mov     eax, [edx]
.text:0000408E                 mov     edx, [ebp+arg_0]
.text:00004091                 mov     [eax+ecx*4], edx
.text:00004094                 mov     eax, [ebp+var_4]
.text:00004097                 mov     ecx, [eax+4]
.text:0000409A                 mov     [ebp+var_8], ecx
.text:0000409D                 mov     edx, [ebp+var_4]
.text:000040A0                 mov     eax, [edx+4]
.text:000040A3                 add     eax, 1
.text:000040A6                 mov     ecx, [ebp+var_4]
.text:000040A9                 mov     [ecx+4], eax
.text:000040AC                 mov     eax, [ebp+var_8]
.text:000040AF                 add     esp, 8
.text:000040B2                 cmp     ebp, esp
.text:000040B4                 call    __RTC_CheckEsp
.text:000040B9                 mov     esp, ebp
.text:000040BB                 pop     ebp
.text:000040BC                 retn    4
.text:000040BC ?Add@?$CRecordVector@PAX@@QAEIQAX@Z endp
.text:000040BC
.text:000040BC ; ---------------------------------------------------------------------------
.text:000040BF                 align 10h
.text:000040BF _text           ends
.text:000040BF
.text:000040C0 ; ===========================================================================
.text:000040C0
.text:000040C0 ; Segment type: Pure code
.text:000040C0 ; Segment permissions: Read/Execute
.text:000040C0 _text           segment para public 'CODE' use32
.text:000040C0                 assume cs:_text
.text:000040C0                 ;org 40C0h
.text:000040C0 ; COMDAT (pick any)
.text:000040C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000040C0
.text:000040C0 ; =============== S U B R O U T I N E =======================================
.text:000040C0
.text:000040C0 ; Attributes: bp-based frame
.text:000040C0
.text:000040C0 ; public: void __thiscall CRecordVector<void *>::AddInReserved(void * const)
.text:000040C0                 public ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z
.text:000040C0 ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z proc near
.text:000040C0                                         ; CODE XREF: CObjectVector<UString>::CObjectVector<UString>(CObjectVector<UString> const &)+C8p
.text:000040C0                                         ; CObjectVector<UString>::operator=(CObjectVector<UString> const &)+D7p ...
.text:000040C0
.text:000040C0 var_4           = dword ptr -4
.text:000040C0 arg_0           = dword ptr  8
.text:000040C0
.text:000040C0                 push    ebp
.text:000040C1                 mov     ebp, esp
.text:000040C3                 push    ecx
.text:000040C4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000040CB                 mov     [ebp+var_4], ecx
.text:000040CE                 mov     eax, [ebp+var_4]
.text:000040D1                 mov     ecx, [eax+4]
.text:000040D4                 mov     edx, [ebp+var_4]
.text:000040D7                 mov     eax, [edx]
.text:000040D9                 mov     edx, [ebp+arg_0]
.text:000040DC                 mov     [eax+ecx*4], edx
.text:000040DF                 mov     eax, [ebp+var_4]
.text:000040E2                 mov     ecx, [eax+4]
.text:000040E5                 add     ecx, 1
.text:000040E8                 mov     edx, [ebp+var_4]
.text:000040EB                 mov     [edx+4], ecx
.text:000040EE                 mov     esp, ebp
.text:000040F0                 pop     ebp
.text:000040F1                 retn    4
.text:000040F1 ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z endp
.text:000040F1
.text:000040F1 _text           ends
.text:000040F1
.text:000040F4 ; ===========================================================================
.text:000040F4
.text:000040F4 ; Segment type: Pure code
.text:000040F4 ; Segment permissions: Read/Execute
.text:000040F4 _text           segment para public 'CODE' use32
.text:000040F4                 assume cs:_text
.text:000040F4                 ;org 40F4h
.text:000040F4 ; COMDAT (pick any)
.text:000040F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000040F4
.text:000040F4 ; =============== S U B R O U T I N E =======================================
.text:000040F4
.text:000040F4 ; Attributes: bp-based frame
.text:000040F4
.text:000040F4 ; public: void __thiscall CRecordVector<void *>::Insert(unsigned int, void * const)
.text:000040F4                 public ?Insert@?$CRecordVector@PAX@@QAEXIQAX@Z
.text:000040F4 ?Insert@?$CRecordVector@PAX@@QAEXIQAX@Z proc near
.text:000040F4                                         ; CODE XREF: CObjectVector<UString>::Insert(uint,UString const &)+83p
.text:000040F4
.text:000040F4 var_4           = dword ptr -4
.text:000040F4 arg_0           = dword ptr  8
.text:000040F4 arg_4           = dword ptr  0Ch
.text:000040F4
.text:000040F4                 push    ebp
.text:000040F5                 mov     ebp, esp
.text:000040F7                 push    ecx
.text:000040F8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000040FF                 mov     [ebp+var_4], ecx
.text:00004102                 mov     ecx, [ebp+var_4]
.text:00004105                 call    ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ ; CRecordVector<void *>::ReserveOnePosition(void)
.text:0000410A                 mov     eax, [ebp+arg_0]
.text:0000410D                 push    eax
.text:0000410E                 mov     ecx, [ebp+arg_0]
.text:00004111                 add     ecx, 1
.text:00004114                 push    ecx
.text:00004115                 mov     ecx, [ebp+var_4]
.text:00004118                 call    ?MoveItems@?$CRecordVector@PAX@@AAEXII@Z ; CRecordVector<void *>::MoveItems(uint,uint)
.text:0000411D                 mov     edx, [ebp+var_4]
.text:00004120                 mov     eax, [edx]
.text:00004122                 mov     ecx, [ebp+arg_0]
.text:00004125                 mov     edx, [ebp+arg_4]
.text:00004128                 mov     [eax+ecx*4], edx
.text:0000412B                 mov     eax, [ebp+var_4]
.text:0000412E                 mov     ecx, [eax+4]
.text:00004131                 add     ecx, 1
.text:00004134                 mov     edx, [ebp+var_4]
.text:00004137                 mov     [edx+4], ecx
.text:0000413A                 add     esp, 4
.text:0000413D                 cmp     ebp, esp
.text:0000413F                 call    __RTC_CheckEsp
.text:00004144                 mov     esp, ebp
.text:00004146                 pop     ebp
.text:00004147                 retn    8
.text:00004147 ?Insert@?$CRecordVector@PAX@@QAEXIQAX@Z endp
.text:00004147
.text:00004147 ; ---------------------------------------------------------------------------
.text:0000414A                 align 4
.text:0000414A _text           ends
.text:0000414A
.text:0000414C ; ===========================================================================
.text:0000414C
.text:0000414C ; Segment type: Pure code
.text:0000414C ; Segment permissions: Read/Execute
.text:0000414C _text           segment para public 'CODE' use32
.text:0000414C                 assume cs:_text
.text:0000414C                 ;org 414Ch
.text:0000414C ; COMDAT (pick any)
.text:0000414C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000414C
.text:0000414C ; =============== S U B R O U T I N E =======================================
.text:0000414C
.text:0000414C ; Attributes: bp-based frame
.text:0000414C
.text:0000414C ; public: void * const & __thiscall CRecordVector<void *>::operator[](unsigned int)const
.text:0000414C                 public ??A?$CRecordVector@PAX@@QBEABQAXI@Z
.text:0000414C ??A?$CRecordVector@PAX@@QBEABQAXI@Z proc near
.text:0000414C                                         ; CODE XREF: CObjectVector<UString>::operator[](uint)+15p
.text:0000414C                                         ; CObjectVector<NWildcard::CCensorNode>::operator[](uint)+15p ...
.text:0000414C
.text:0000414C var_4           = dword ptr -4
.text:0000414C arg_0           = dword ptr  8
.text:0000414C
.text:0000414C                 push    ebp
.text:0000414D                 mov     ebp, esp
.text:0000414F                 push    ecx
.text:00004150                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00004157                 mov     [ebp+var_4], ecx
.text:0000415A                 mov     eax, [ebp+var_4]
.text:0000415D                 mov     ecx, [eax]
.text:0000415F                 mov     edx, [ebp+arg_0]
.text:00004162                 lea     eax, [ecx+edx*4]
.text:00004165                 mov     esp, ebp
.text:00004167                 pop     ebp
.text:00004168                 retn    4
.text:00004168 ??A?$CRecordVector@PAX@@QBEABQAXI@Z endp
.text:00004168
.text:00004168 ; ---------------------------------------------------------------------------
.text:0000416B                 align 4
.text:0000416B _text           ends
.text:0000416B
.text:0000416C ; ===========================================================================
.text:0000416C
.text:0000416C ; Segment type: Pure code
.text:0000416C ; Segment permissions: Read/Execute
.text:0000416C _text           segment para public 'CODE' use32
.text:0000416C                 assume cs:_text
.text:0000416C                 ;org 416Ch
.text:0000416C ; COMDAT (pick any)
.text:0000416C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000416C
.text:0000416C ; =============== S U B R O U T I N E =======================================
.text:0000416C
.text:0000416C ; Attributes: bp-based frame
.text:0000416C
.text:0000416C ; public: void * & __thiscall CRecordVector<void *>::operator[](unsigned int)
.text:0000416C                 public ??A?$CRecordVector@PAX@@QAEAAPAXI@Z
.text:0000416C ??A?$CRecordVector@PAX@@QAEAAPAXI@Z proc near
.text:0000416C                                         ; CODE XREF: CObjectVector<UString>::operator[](uint)+15p
.text:0000416C                                         ; CObjectVector<UString>::~CObjectVector<UString>(void)+64p ...
.text:0000416C
.text:0000416C var_4           = dword ptr -4
.text:0000416C arg_0           = dword ptr  8
.text:0000416C
.text:0000416C                 push    ebp
.text:0000416D                 mov     ebp, esp
.text:0000416F                 push    ecx
.text:00004170                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00004177                 mov     [ebp+var_4], ecx
.text:0000417A                 mov     eax, [ebp+var_4]
.text:0000417D                 mov     ecx, [eax]
.text:0000417F                 mov     edx, [ebp+arg_0]
.text:00004182                 lea     eax, [ecx+edx*4]
.text:00004185                 mov     esp, ebp
.text:00004187                 pop     ebp
.text:00004188                 retn    4
.text:00004188 ??A?$CRecordVector@PAX@@QAEAAPAXI@Z endp
.text:00004188
.text:00004188 ; ---------------------------------------------------------------------------
.text:0000418B                 align 4
.text:0000418B _text           ends
.text:0000418B
.text:0000418C ; ===========================================================================
.text:0000418C
.text:0000418C ; Segment type: Pure code
.text:0000418C ; Segment permissions: Read/Execute
.text:0000418C _text           segment para public 'CODE' use32
.text:0000418C                 assume cs:_text
.text:0000418C                 ;org 418Ch
.text:0000418C ; COMDAT (pick any)
.text:0000418C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000418C
.text:0000418C ; =============== S U B R O U T I N E =======================================
.text:0000418C
.text:0000418C ; Attributes: bp-based frame
.text:0000418C
.text:0000418C ; public: __thiscall CObjectVector<class NWildcard::CCensorNode>::CObjectVector<class NWildcard::CCensorNode>(class CObjectVector<class NWildcard::CCensorNode> const &)
.text:0000418C                 public ??0?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@ABV0@@Z
.text:0000418C ??0?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@ABV0@@Z proc near
.text:0000418C                                         ; CODE XREF: NWildcard::CCensorNode::CCensorNode(NWildcard::CCensorNode const &)+5Dp
.text:0000418C
.text:0000418C var_24          = dword ptr -24h
.text:0000418C var_20          = dword ptr -20h
.text:0000418C var_1C          = dword ptr -1Ch
.text:0000418C var_18          = dword ptr -18h
.text:0000418C var_14          = dword ptr -14h
.text:0000418C var_10          = dword ptr -10h
.text:0000418C var_C           = dword ptr -0Ch
.text:0000418C var_4           = dword ptr -4
.text:0000418C arg_0           = dword ptr  8
.text:0000418C
.text:0000418C                 push    ebp
.text:0000418D                 mov     ebp, esp
.text:0000418F                 push    0FFFFFFFFh
.text:00004191                 push    offset __ehhandler$??0?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@ABV0@@Z
.text:00004196                 mov     eax, large fs:0
.text:0000419C                 push    eax
.text:0000419D                 sub     esp, 18h
.text:000041A0                 mov     eax, 0CCCCCCCCh
.text:000041A5                 mov     [ebp+var_24], eax
.text:000041A8                 mov     [ebp+var_20], eax
.text:000041AB                 mov     [ebp+var_1C], eax
.text:000041AE                 mov     [ebp+var_18], eax
.text:000041B1                 mov     [ebp+var_14], eax
.text:000041B4                 mov     [ebp+var_10], eax
.text:000041B7                 mov     eax, dword ptr ds:___security_cookie
.text:000041BC                 xor     eax, ebp
.text:000041BE                 push    eax
.text:000041BF                 lea     eax, [ebp+var_C]
.text:000041C2                 mov     large fs:0, eax
.text:000041C8                 mov     [ebp+var_10], ecx
.text:000041CB                 mov     ecx, [ebp+var_10]
.text:000041CE                 call    ??0?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::CRecordVector<void *>(void)
.text:000041D3                 mov     [ebp+var_4], 0
.text:000041DA                 mov     ecx, [ebp+arg_0]
.text:000041DD                 call    ?Size@?$CObjectVector@VCCensorNode@NWildcard@@@@QBEIXZ ; CObjectVector<NWildcard::CCensorNode>::Size(void)
.text:000041E2                 mov     [ebp+var_14], eax
.text:000041E5                 mov     eax, [ebp+var_14]
.text:000041E8                 push    eax
.text:000041E9                 mov     ecx, [ebp+var_10]
.text:000041EC                 call    ?ConstructReserve@?$CRecordVector@PAX@@QAEXI@Z ; CRecordVector<void *>::ConstructReserve(uint)
.text:000041F1                 mov     [ebp+var_18], 0
.text:000041F8                 jmp     short loc_4203
.text:000041FA ; ---------------------------------------------------------------------------
.text:000041FA
.text:000041FA loc_41FA:                               ; CODE XREF: CObjectVector<NWildcard::CCensorNode>::CObjectVector<NWildcard::CCensorNode>(CObjectVector<NWildcard::CCensorNode> const &)+CDj
.text:000041FA                 mov     ecx, [ebp+var_18]
.text:000041FD                 add     ecx, 1
.text:00004200                 mov     [ebp+var_18], ecx
.text:00004203
.text:00004203 loc_4203:                               ; CODE XREF: CObjectVector<NWildcard::CCensorNode>::CObjectVector<NWildcard::CCensorNode>(CObjectVector<NWildcard::CCensorNode> const &)+6Cj
.text:00004203                 mov     edx, [ebp+var_18]
.text:00004206                 cmp     edx, [ebp+var_14]
.text:00004209                 jnb     short loc_425B
.text:0000420B                 push    34h ; '4'       ; unsigned int
.text:0000420D                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00004212                 add     esp, 4
.text:00004215                 mov     [ebp+var_20], eax
.text:00004218                 mov     byte ptr [ebp+var_4], 1
.text:0000421C                 cmp     [ebp+var_20], 0
.text:00004220                 jz      short loc_423C
.text:00004222                 mov     eax, [ebp+var_18]
.text:00004225                 push    eax
.text:00004226                 mov     ecx, [ebp+arg_0]
.text:00004229                 call    ??A?$CObjectVector@VCCensorNode@NWildcard@@@@QBEABVCCensorNode@NWildcard@@I@Z ; CObjectVector<NWildcard::CCensorNode>::operator[](uint)
.text:0000422E                 push    eax             ; struct NWildcard::CCensorNode *
.text:0000422F                 mov     ecx, [ebp+var_20] ; this
.text:00004232                 call    ??0CCensorNode@NWildcard@@QAE@ABV01@@Z ; NWildcard::CCensorNode::CCensorNode(NWildcard::CCensorNode const &)
.text:00004237                 mov     [ebp+var_24], eax
.text:0000423A                 jmp     short loc_4243
.text:0000423C ; ---------------------------------------------------------------------------
.text:0000423C
.text:0000423C loc_423C:                               ; CODE XREF: CObjectVector<NWildcard::CCensorNode>::CObjectVector<NWildcard::CCensorNode>(CObjectVector<NWildcard::CCensorNode> const &)+94j
.text:0000423C                 mov     [ebp+var_24], 0
.text:00004243
.text:00004243 loc_4243:                               ; CODE XREF: CObjectVector<NWildcard::CCensorNode>::CObjectVector<NWildcard::CCensorNode>(CObjectVector<NWildcard::CCensorNode> const &)+AEj
.text:00004243                 mov     ecx, [ebp+var_24]
.text:00004246                 mov     [ebp+var_1C], ecx
.text:00004249                 mov     byte ptr [ebp+var_4], 0
.text:0000424D                 mov     edx, [ebp+var_1C]
.text:00004250                 push    edx
.text:00004251                 mov     ecx, [ebp+var_10]
.text:00004254                 call    ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z ; CRecordVector<void *>::AddInReserved(void * const)
.text:00004259                 jmp     short loc_41FA
.text:0000425B ; ---------------------------------------------------------------------------
.text:0000425B
.text:0000425B loc_425B:                               ; CODE XREF: CObjectVector<NWildcard::CCensorNode>::CObjectVector<NWildcard::CCensorNode>(CObjectVector<NWildcard::CCensorNode> const &)+7Dj
.text:0000425B                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00004262                 mov     eax, [ebp+var_10]
.text:00004265                 mov     ecx, [ebp+var_C]
.text:00004268                 mov     large fs:0, ecx
.text:0000426F                 pop     ecx
.text:00004270                 add     esp, 24h
.text:00004273                 cmp     ebp, esp
.text:00004275                 call    __RTC_CheckEsp
.text:0000427A                 mov     esp, ebp
.text:0000427C                 pop     ebp
.text:0000427D                 retn    4
.text:0000427D ??0?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@ABV0@@Z endp
.text:0000427D
.text:0000427D _text           ends
.text:0000427D
.text$x:00004280 ; ===========================================================================
.text$x:00004280
.text$x:00004280 ; Segment type: Pure code
.text$x:00004280 ; Segment permissions: Read/Execute
.text$x:00004280 _text$x         segment para public 'CODE' use32
.text$x:00004280                 assume cs:_text$x
.text$x:00004280                 ;org 4280h
.text$x:00004280 ; COMDAT (pick associative to section at 418C)
.text$x:00004280                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004280
.text$x:00004280 ; =============== S U B R O U T I N E =======================================
.text$x:00004280
.text$x:00004280
.text$x:00004280 __unwindfunclet$??0?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@ABV0@@Z$0 proc near
.text$x:00004280                                         ; DATA XREF: .xdata$x:000042B4o
.text$x:00004280                 mov     ecx, [ebp-10h]
.text$x:00004283                 jmp     ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text$x:00004283 __unwindfunclet$??0?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@ABV0@@Z$0 endp
.text$x:00004283
.text$x:00004288
.text$x:00004288 ; =============== S U B R O U T I N E =======================================
.text$x:00004288
.text$x:00004288
.text$x:00004288 __unwindfunclet$??0?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@ABV0@@Z$1 proc near
.text$x:00004288                                         ; DATA XREF: .xdata$x:000042BCo
.text$x:00004288                 mov     eax, [ebp-20h]
.text$x:0000428B                 push    eax             ; void *
.text$x:0000428C                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00004291                 pop     ecx
.text$x:00004292                 retn
.text$x:00004292 __unwindfunclet$??0?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@ABV0@@Z$1 endp
.text$x:00004292
.text$x:00004293
.text$x:00004293 ; =============== S U B R O U T I N E =======================================
.text$x:00004293
.text$x:00004293
.text$x:00004293 __ehhandler$??0?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@ABV0@@Z proc near
.text$x:00004293                                         ; DATA XREF: CObjectVector<NWildcard::CCensorNode>::CObjectVector<NWildcard::CCensorNode>(CObjectVector<NWildcard::CCensorNode> const &)+5o
.text$x:00004293
.text$x:00004293 arg_4           = dword ptr  8
.text$x:00004293
.text$x:00004293                 mov     edx, [esp+arg_4]
.text$x:00004297                 lea     eax, [edx+0Ch]
.text$x:0000429A                 mov     ecx, [edx-1Ch]
.text$x:0000429D                 xor     ecx, eax
.text$x:0000429F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000042A4                 mov     eax, offset __ehfuncinfo$??0?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@ABV0@@Z
.text$x:000042A9                 jmp     ___CxxFrameHandler3
.text$x:000042A9 __ehhandler$??0?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@ABV0@@Z endp
.text$x:000042A9
.text$x:000042A9 ; ---------------------------------------------------------------------------
.text$x:000042AE                 align 10h
.text$x:000042AE _text$x         ends
.text$x:000042AE
.xdata$x:000042B0 ; ===========================================================================
.xdata$x:000042B0
.xdata$x:000042B0 ; Segment type: Pure data
.xdata$x:000042B0 ; Segment permissions: Read
.xdata$x:000042B0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000042B0                 assume cs:_xdata$x
.xdata$x:000042B0                 ;org 42B0h
.xdata$x:000042B0 ; COMDAT (pick associative to section at 418C)
.xdata$x:000042B0 __unwindtable$??0?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@ABV0@@Z db 0FFh
.xdata$x:000042B0                                         ; DATA XREF: .xdata$x:000042C8o
.xdata$x:000042B1                 db 0FFh
.xdata$x:000042B2                 db 0FFh
.xdata$x:000042B3                 db 0FFh
.xdata$x:000042B4                 dd offset __unwindfunclet$??0?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@ABV0@@Z$0
.xdata$x:000042B8                 db    0
.xdata$x:000042B9                 db    0
.xdata$x:000042BA                 db    0
.xdata$x:000042BB                 db    0
.xdata$x:000042BC                 dd offset __unwindfunclet$??0?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@ABV0@@Z$1
.xdata$x:000042C0 __ehfuncinfo$??0?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@ABV0@@Z db  22h ; "
.xdata$x:000042C0                                         ; DATA XREF: __ehhandler$??0?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@ABV0@@Z+11o
.xdata$x:000042C1                 db    5
.xdata$x:000042C2                 db  93h ; ô
.xdata$x:000042C3                 db  19h
.xdata$x:000042C4                 db    2
.xdata$x:000042C5                 db    0
.xdata$x:000042C6                 db    0
.xdata$x:000042C7                 db    0
.xdata$x:000042C8                 dd offset __unwindtable$??0?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@ABV0@@Z
.xdata$x:000042CC                 align 20h
.xdata$x:000042E0                 db    1
.xdata$x:000042E1                 db    0
.xdata$x:000042E2                 db    0
.xdata$x:000042E3                 db    0
.xdata$x:000042E3 _xdata$x        ends
.xdata$x:000042E3
.text:000042E4 ; ===========================================================================
.text:000042E4
.text:000042E4 ; Segment type: Pure code
.text:000042E4 ; Segment permissions: Read/Execute
.text:000042E4 _text           segment para public 'CODE' use32
.text:000042E4                 assume cs:_text
.text:000042E4                 ;org 42E4h
.text:000042E4 ; COMDAT (pick any)
.text:000042E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000042E4
.text:000042E4 ; =============== S U B R O U T I N E =======================================
.text:000042E4
.text:000042E4 ; Attributes: bp-based frame
.text:000042E4
.text:000042E4 ; public: __thiscall CObjectVector<struct NWildcard::CItem>::CObjectVector<struct NWildcard::CItem>(class CObjectVector<struct NWildcard::CItem> const &)
.text:000042E4                 public ??0?$CObjectVector@UCItem@NWildcard@@@@QAE@ABV0@@Z
.text:000042E4 ??0?$CObjectVector@UCItem@NWildcard@@@@QAE@ABV0@@Z proc near
.text:000042E4                                         ; CODE XREF: NWildcard::CCensorNode::CCensorNode(NWildcard::CCensorNode const &)+73p
.text:000042E4                                         ; NWildcard::CCensorNode::CCensorNode(NWildcard::CCensorNode const &)+89p
.text:000042E4
.text:000042E4 var_24          = dword ptr -24h
.text:000042E4 var_20          = dword ptr -20h
.text:000042E4 var_1C          = dword ptr -1Ch
.text:000042E4 var_18          = dword ptr -18h
.text:000042E4 var_14          = dword ptr -14h
.text:000042E4 var_10          = dword ptr -10h
.text:000042E4 var_C           = dword ptr -0Ch
.text:000042E4 var_4           = dword ptr -4
.text:000042E4 arg_0           = dword ptr  8
.text:000042E4
.text:000042E4                 push    ebp
.text:000042E5                 mov     ebp, esp
.text:000042E7                 push    0FFFFFFFFh
.text:000042E9                 push    offset __ehhandler$??0?$CObjectVector@UCItem@NWildcard@@@@QAE@ABV0@@Z
.text:000042EE                 mov     eax, large fs:0
.text:000042F4                 push    eax
.text:000042F5                 sub     esp, 18h
.text:000042F8                 mov     eax, 0CCCCCCCCh
.text:000042FD                 mov     [ebp+var_24], eax
.text:00004300                 mov     [ebp+var_20], eax
.text:00004303                 mov     [ebp+var_1C], eax
.text:00004306                 mov     [ebp+var_18], eax
.text:00004309                 mov     [ebp+var_14], eax
.text:0000430C                 mov     [ebp+var_10], eax
.text:0000430F                 mov     eax, dword ptr ds:___security_cookie
.text:00004314                 xor     eax, ebp
.text:00004316                 push    eax
.text:00004317                 lea     eax, [ebp+var_C]
.text:0000431A                 mov     large fs:0, eax
.text:00004320                 mov     [ebp+var_10], ecx
.text:00004323                 mov     ecx, [ebp+var_10]
.text:00004326                 call    ??0?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::CRecordVector<void *>(void)
.text:0000432B                 mov     [ebp+var_4], 0
.text:00004332                 mov     ecx, [ebp+arg_0]
.text:00004335                 call    ?Size@?$CObjectVector@UCItem@NWildcard@@@@QBEIXZ ; CObjectVector<NWildcard::CItem>::Size(void)
.text:0000433A                 mov     [ebp+var_14], eax
.text:0000433D                 mov     eax, [ebp+var_14]
.text:00004340                 push    eax
.text:00004341                 mov     ecx, [ebp+var_10]
.text:00004344                 call    ?ConstructReserve@?$CRecordVector@PAX@@QAEXI@Z ; CRecordVector<void *>::ConstructReserve(uint)
.text:00004349                 mov     [ebp+var_18], 0
.text:00004350                 jmp     short loc_435B
.text:00004352 ; ---------------------------------------------------------------------------
.text:00004352
.text:00004352 loc_4352:                               ; CODE XREF: CObjectVector<NWildcard::CItem>::CObjectVector<NWildcard::CItem>(CObjectVector<NWildcard::CItem> const &)+CDj
.text:00004352                 mov     ecx, [ebp+var_18]
.text:00004355                 add     ecx, 1
.text:00004358                 mov     [ebp+var_18], ecx
.text:0000435B
.text:0000435B loc_435B:                               ; CODE XREF: CObjectVector<NWildcard::CItem>::CObjectVector<NWildcard::CItem>(CObjectVector<NWildcard::CItem> const &)+6Cj
.text:0000435B                 mov     edx, [ebp+var_18]
.text:0000435E                 cmp     edx, [ebp+var_14]
.text:00004361                 jnb     short loc_43B3
.text:00004363                 push    10h             ; unsigned int
.text:00004365                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0000436A                 add     esp, 4
.text:0000436D                 mov     [ebp+var_20], eax
.text:00004370                 mov     byte ptr [ebp+var_4], 1
.text:00004374                 cmp     [ebp+var_20], 0
.text:00004378                 jz      short loc_4394
.text:0000437A                 mov     eax, [ebp+var_18]
.text:0000437D                 push    eax
.text:0000437E                 mov     ecx, [ebp+arg_0]
.text:00004381                 call    ??A?$CObjectVector@UCItem@NWildcard@@@@QBEABUCItem@NWildcard@@I@Z ; CObjectVector<NWildcard::CItem>::operator[](uint)
.text:00004386                 push    eax             ; struct NWildcard::CItem *
.text:00004387                 mov     ecx, [ebp+var_20] ; this
.text:0000438A                 call    ??0CItem@NWildcard@@QAE@ABU01@@Z ; NWildcard::CItem::CItem(NWildcard::CItem const &)
.text:0000438F                 mov     [ebp+var_24], eax
.text:00004392                 jmp     short loc_439B
.text:00004394 ; ---------------------------------------------------------------------------
.text:00004394
.text:00004394 loc_4394:                               ; CODE XREF: CObjectVector<NWildcard::CItem>::CObjectVector<NWildcard::CItem>(CObjectVector<NWildcard::CItem> const &)+94j
.text:00004394                 mov     [ebp+var_24], 0
.text:0000439B
.text:0000439B loc_439B:                               ; CODE XREF: CObjectVector<NWildcard::CItem>::CObjectVector<NWildcard::CItem>(CObjectVector<NWildcard::CItem> const &)+AEj
.text:0000439B                 mov     ecx, [ebp+var_24]
.text:0000439E                 mov     [ebp+var_1C], ecx
.text:000043A1                 mov     byte ptr [ebp+var_4], 0
.text:000043A5                 mov     edx, [ebp+var_1C]
.text:000043A8                 push    edx
.text:000043A9                 mov     ecx, [ebp+var_10]
.text:000043AC                 call    ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z ; CRecordVector<void *>::AddInReserved(void * const)
.text:000043B1                 jmp     short loc_4352
.text:000043B3 ; ---------------------------------------------------------------------------
.text:000043B3
.text:000043B3 loc_43B3:                               ; CODE XREF: CObjectVector<NWildcard::CItem>::CObjectVector<NWildcard::CItem>(CObjectVector<NWildcard::CItem> const &)+7Dj
.text:000043B3                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000043BA                 mov     eax, [ebp+var_10]
.text:000043BD                 mov     ecx, [ebp+var_C]
.text:000043C0                 mov     large fs:0, ecx
.text:000043C7                 pop     ecx
.text:000043C8                 add     esp, 24h
.text:000043CB                 cmp     ebp, esp
.text:000043CD                 call    __RTC_CheckEsp
.text:000043D2                 mov     esp, ebp
.text:000043D4                 pop     ebp
.text:000043D5                 retn    4
.text:000043D5 ??0?$CObjectVector@UCItem@NWildcard@@@@QAE@ABV0@@Z endp
.text:000043D5
.text:000043D5 _text           ends
.text:000043D5
.text$x:000043D8 ; ===========================================================================
.text$x:000043D8
.text$x:000043D8 ; Segment type: Pure code
.text$x:000043D8 ; Segment permissions: Read/Execute
.text$x:000043D8 _text$x         segment para public 'CODE' use32
.text$x:000043D8                 assume cs:_text$x
.text$x:000043D8                 ;org 43D8h
.text$x:000043D8 ; COMDAT (pick associative to section at 42E4)
.text$x:000043D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000043D8
.text$x:000043D8 ; =============== S U B R O U T I N E =======================================
.text$x:000043D8
.text$x:000043D8
.text$x:000043D8 __unwindfunclet$??0?$CObjectVector@UCItem@NWildcard@@@@QAE@ABV0@@Z$0 proc near
.text$x:000043D8                                         ; DATA XREF: .xdata$x:0000440Co
.text$x:000043D8                 mov     ecx, [ebp-10h]
.text$x:000043DB                 jmp     ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text$x:000043DB __unwindfunclet$??0?$CObjectVector@UCItem@NWildcard@@@@QAE@ABV0@@Z$0 endp
.text$x:000043DB
.text$x:000043E0
.text$x:000043E0 ; =============== S U B R O U T I N E =======================================
.text$x:000043E0
.text$x:000043E0
.text$x:000043E0 __unwindfunclet$??0?$CObjectVector@UCItem@NWildcard@@@@QAE@ABV0@@Z$1 proc near
.text$x:000043E0                                         ; DATA XREF: .xdata$x:00004414o
.text$x:000043E0                 mov     eax, [ebp-20h]
.text$x:000043E3                 push    eax             ; void *
.text$x:000043E4                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:000043E9                 pop     ecx
.text$x:000043EA                 retn
.text$x:000043EA __unwindfunclet$??0?$CObjectVector@UCItem@NWildcard@@@@QAE@ABV0@@Z$1 endp
.text$x:000043EA
.text$x:000043EB
.text$x:000043EB ; =============== S U B R O U T I N E =======================================
.text$x:000043EB
.text$x:000043EB
.text$x:000043EB __ehhandler$??0?$CObjectVector@UCItem@NWildcard@@@@QAE@ABV0@@Z proc near
.text$x:000043EB                                         ; DATA XREF: CObjectVector<NWildcard::CItem>::CObjectVector<NWildcard::CItem>(CObjectVector<NWildcard::CItem> const &)+5o
.text$x:000043EB
.text$x:000043EB arg_4           = dword ptr  8
.text$x:000043EB
.text$x:000043EB                 mov     edx, [esp+arg_4]
.text$x:000043EF                 lea     eax, [edx+0Ch]
.text$x:000043F2                 mov     ecx, [edx-1Ch]
.text$x:000043F5                 xor     ecx, eax
.text$x:000043F7                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000043FC                 mov     eax, offset __ehfuncinfo$??0?$CObjectVector@UCItem@NWildcard@@@@QAE@ABV0@@Z
.text$x:00004401                 jmp     ___CxxFrameHandler3
.text$x:00004401 __ehhandler$??0?$CObjectVector@UCItem@NWildcard@@@@QAE@ABV0@@Z endp
.text$x:00004401
.text$x:00004401 ; ---------------------------------------------------------------------------
.text$x:00004406                 align 4
.text$x:00004406 _text$x         ends
.text$x:00004406
.xdata$x:00004408 ; ===========================================================================
.xdata$x:00004408
.xdata$x:00004408 ; Segment type: Pure data
.xdata$x:00004408 ; Segment permissions: Read
.xdata$x:00004408 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004408                 assume cs:_xdata$x
.xdata$x:00004408                 ;org 4408h
.xdata$x:00004408 ; COMDAT (pick associative to section at 42E4)
.xdata$x:00004408 __unwindtable$??0?$CObjectVector@UCItem@NWildcard@@@@QAE@ABV0@@Z db 0FFh
.xdata$x:00004408                                         ; DATA XREF: .xdata$x:00004420o
.xdata$x:00004409                 db 0FFh
.xdata$x:0000440A                 db 0FFh
.xdata$x:0000440B                 db 0FFh
.xdata$x:0000440C                 dd offset __unwindfunclet$??0?$CObjectVector@UCItem@NWildcard@@@@QAE@ABV0@@Z$0
.xdata$x:00004410                 db    0
.xdata$x:00004411                 db    0
.xdata$x:00004412                 db    0
.xdata$x:00004413                 db    0
.xdata$x:00004414                 dd offset __unwindfunclet$??0?$CObjectVector@UCItem@NWildcard@@@@QAE@ABV0@@Z$1
.xdata$x:00004418 __ehfuncinfo$??0?$CObjectVector@UCItem@NWildcard@@@@QAE@ABV0@@Z db  22h ; "
.xdata$x:00004418                                         ; DATA XREF: __ehhandler$??0?$CObjectVector@UCItem@NWildcard@@@@QAE@ABV0@@Z+11o
.xdata$x:00004419                 db    5
.xdata$x:0000441A                 db  93h ; ô
.xdata$x:0000441B                 db  19h
.xdata$x:0000441C                 db    2
.xdata$x:0000441D                 db    0
.xdata$x:0000441E                 db    0
.xdata$x:0000441F                 db    0
.xdata$x:00004420                 dd offset __unwindtable$??0?$CObjectVector@UCItem@NWildcard@@@@QAE@ABV0@@Z
.xdata$x:00004424                 db    0
.xdata$x:00004425                 db    0
.xdata$x:00004426                 db    0
.xdata$x:00004427                 db    0
.xdata$x:00004428                 db    0
.xdata$x:00004429                 db    0
.xdata$x:0000442A                 db    0
.xdata$x:0000442B                 db    0
.xdata$x:0000442C                 db    0
.xdata$x:0000442D                 db    0
.xdata$x:0000442E                 db    0
.xdata$x:0000442F                 db    0
.xdata$x:00004430                 db    0
.xdata$x:00004431                 db    0
.xdata$x:00004432                 db    0
.xdata$x:00004433                 db    0
.xdata$x:00004434                 db    0
.xdata$x:00004435                 db    0
.xdata$x:00004436                 db    0
.xdata$x:00004437                 db    0
.xdata$x:00004438                 db    1
.xdata$x:00004439                 db    0
.xdata$x:0000443A                 db    0
.xdata$x:0000443B                 db    0
.xdata$x:0000443B _xdata$x        ends
.xdata$x:0000443B
.text:0000443C ; ===========================================================================
.text:0000443C
.text:0000443C ; Segment type: Pure code
.text:0000443C ; Segment permissions: Read/Execute
.text:0000443C _text           segment para public 'CODE' use32
.text:0000443C                 assume cs:_text
.text:0000443C                 ;org 443Ch
.text:0000443C ; COMDAT (pick any)
.text:0000443C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000443C
.text:0000443C ; =============== S U B R O U T I N E =======================================
.text:0000443C
.text:0000443C ; Attributes: bp-based frame
.text:0000443C
.text:0000443C ; private: void __thiscall CRecordVector<void *>::MoveItems(unsigned int, unsigned int)
.text:0000443C                 public ?MoveItems@?$CRecordVector@PAX@@AAEXII@Z
.text:0000443C ?MoveItems@?$CRecordVector@PAX@@AAEXII@Z proc near
.text:0000443C                                         ; CODE XREF: CRecordVector<void *>::Delete(uint)+1Cp
.text:0000443C                                         ; CRecordVector<void *>::Insert(uint,void * const)+24p
.text:0000443C
.text:0000443C var_4           = dword ptr -4
.text:0000443C arg_0           = dword ptr  8
.text:0000443C arg_4           = dword ptr  0Ch
.text:0000443C
.text:0000443C                 push    ebp
.text:0000443D                 mov     ebp, esp
.text:0000443F                 push    ecx
.text:00004440                 push    esi
.text:00004441                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00004448                 mov     [ebp+var_4], ecx
.text:0000444B                 mov     eax, [ebp+var_4]
.text:0000444E                 mov     ecx, [eax+4]
.text:00004451                 sub     ecx, [ebp+arg_4]
.text:00004454                 shl     ecx, 2
.text:00004457                 mov     esi, esp
.text:00004459                 push    ecx             ; Size
.text:0000445A                 mov     edx, [ebp+var_4]
.text:0000445D                 mov     eax, [edx]
.text:0000445F                 mov     ecx, [ebp+arg_4]
.text:00004462                 lea     edx, [eax+ecx*4]
.text:00004465                 push    edx             ; Src
.text:00004466                 mov     eax, [ebp+var_4]
.text:00004469                 mov     ecx, [eax]
.text:0000446B                 mov     edx, [ebp+arg_0]
.text:0000446E                 lea     eax, [ecx+edx*4]
.text:00004471                 push    eax             ; Dst
.text:00004472                 call    dword ptr ds:__imp__memmove
.text:00004478                 add     esp, 0Ch
.text:0000447B                 cmp     esi, esp
.text:0000447D                 call    __RTC_CheckEsp
.text:00004482                 pop     esi
.text:00004483                 add     esp, 4
.text:00004486                 cmp     ebp, esp
.text:00004488                 call    __RTC_CheckEsp
.text:0000448D                 mov     esp, ebp
.text:0000448F                 pop     ebp
.text:00004490                 retn    8
.text:00004490 ?MoveItems@?$CRecordVector@PAX@@AAEXII@Z endp
.text:00004490
.text:00004490 ; ---------------------------------------------------------------------------
.text:00004493                 align 4
.text:00004493 _text           ends
.text:00004493
.text:00004494 ; ===========================================================================
.text:00004494
.text:00004494 ; Segment type: Pure code
.text:00004494 ; Segment permissions: Read/Execute
.text:00004494 _text           segment para public 'CODE' use32
.text:00004494                 assume cs:_text
.text:00004494                 ;org 4494h
.text:00004494 ; COMDAT (pick any)
.text:00004494                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004494
.text:00004494 ; =============== S U B R O U T I N E =======================================
.text:00004494
.text:00004494 ; Attributes: bp-based frame
.text:00004494
.text:00004494 ; private: void __thiscall CRecordVector<void *>::ReserveOnePosition(void)
.text:00004494                 public ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ
.text:00004494 ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ proc near
.text:00004494                                         ; CODE XREF: CRecordVector<void *>::Add(void * const)+1Ap
.text:00004494                                         ; CRecordVector<void *>::Insert(uint,void * const)+11p
.text:00004494
.text:00004494 var_14          = dword ptr -14h
.text:00004494 var_10          = dword ptr -10h
.text:00004494 Dst             = dword ptr -0Ch
.text:00004494 var_8           = dword ptr -8
.text:00004494 var_4           = dword ptr -4
.text:00004494
.text:00004494                 push    ebp
.text:00004495                 mov     ebp, esp
.text:00004497                 sub     esp, 14h
.text:0000449A                 mov     eax, 0CCCCCCCCh
.text:0000449F                 mov     [ebp+var_14], eax
.text:000044A2                 mov     [ebp+var_10], eax
.text:000044A5                 mov     [ebp+Dst], eax
.text:000044A8                 mov     [ebp+var_8], eax
.text:000044AB                 mov     [ebp+var_4], eax
.text:000044AE                 mov     [ebp+var_4], ecx
.text:000044B1                 mov     eax, [ebp+var_4]
.text:000044B4                 mov     ecx, [ebp+var_4]
.text:000044B7                 mov     edx, [eax+4]
.text:000044BA                 cmp     edx, [ecx+8]
.text:000044BD                 jnz     loc_4548
.text:000044C3                 mov     eax, [ebp+var_4]
.text:000044C6                 mov     ecx, [eax+8]
.text:000044C9                 shr     ecx, 2
.text:000044CC                 mov     edx, [ebp+var_4]
.text:000044CF                 mov     eax, [edx+8]
.text:000044D2                 lea     ecx, [eax+ecx+1]
.text:000044D6                 mov     [ebp+var_8], ecx
.text:000044D9                 xor     ecx, ecx
.text:000044DB                 mov     eax, [ebp+var_8]
.text:000044DE                 mov     edx, 4
.text:000044E3                 mul     edx
.text:000044E5                 seto    cl
.text:000044E8                 neg     ecx
.text:000044EA                 or      ecx, eax
.text:000044EC                 push    ecx             ; unsigned int
.text:000044ED                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:000044F2                 add     esp, 4
.text:000044F5                 mov     [ebp+var_10], eax
.text:000044F8                 mov     eax, [ebp+var_10]
.text:000044FB                 mov     [ebp+Dst], eax
.text:000044FE                 mov     ecx, [ebp+var_4]
.text:00004501                 cmp     dword ptr [ecx+4], 0
.text:00004505                 jz      short loc_4523
.text:00004507                 mov     edx, [ebp+var_4]
.text:0000450A                 mov     eax, [edx+4]
.text:0000450D                 shl     eax, 2
.text:00004510                 push    eax             ; Size
.text:00004511                 mov     ecx, [ebp+var_4]
.text:00004514                 mov     edx, [ecx]
.text:00004516                 push    edx             ; Src
.text:00004517                 mov     eax, [ebp+Dst]
.text:0000451A                 push    eax             ; Dst
.text:0000451B                 call    _memcpy
.text:00004520                 add     esp, 0Ch
.text:00004523
.text:00004523 loc_4523:                               ; CODE XREF: CRecordVector<void *>::ReserveOnePosition(void)+71j
.text:00004523                 mov     ecx, [ebp+var_4]
.text:00004526                 mov     edx, [ecx]
.text:00004528                 mov     [ebp+var_14], edx
.text:0000452B                 mov     eax, [ebp+var_14]
.text:0000452E                 push    eax             ; void *
.text:0000452F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00004534                 add     esp, 4
.text:00004537                 mov     ecx, [ebp+var_4]
.text:0000453A                 mov     edx, [ebp+Dst]
.text:0000453D                 mov     [ecx], edx
.text:0000453F                 mov     eax, [ebp+var_4]
.text:00004542                 mov     ecx, [ebp+var_8]
.text:00004545                 mov     [eax+8], ecx
.text:00004548
.text:00004548 loc_4548:                               ; CODE XREF: CRecordVector<void *>::ReserveOnePosition(void)+29j
.text:00004548                 add     esp, 14h
.text:0000454B                 cmp     ebp, esp
.text:0000454D                 call    __RTC_CheckEsp
.text:00004552                 mov     esp, ebp
.text:00004554                 pop     ebp
.text:00004555                 retn
.text:00004555 ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ endp
.text:00004555
.text:00004555 _text           ends
.text:00004555
UNDEF:00004560 ; ===========================================================================
UNDEF:00004560
UNDEF:00004560 ; Segment type: Externs
UNDEF:00004560 ; UNDEF
UNDEF:00004560 ; bool __stdcall IsString1PrefixedByString2_NoCase(const wchar_t *, const wchar_t *)
UNDEF:00004560                 extrn ?IsString1PrefixedByString2_NoCase@@YG_NPB_W0@Z:near
UNDEF:00004560                                         ; CODE XREF: IsPath1PrefixedByPath2(wchar_t const *,wchar_t const *)+25p
UNDEF:00004564 ; bool __stdcall IsString1PrefixedByString2(const wchar_t *, const wchar_t *)
UNDEF:00004564                 extrn ?IsString1PrefixedByString2@@YG_NPB_W0@Z:near
UNDEF:00004564                                         ; CODE XREF: IsPath1PrefixedByPath2(wchar_t const *,wchar_t const *)+16p
UNDEF:00004568                 extrn __RTC_CheckEsp:near
UNDEF:00004568                                         ; CODE XREF: IsPath1PrefixedByPath2(wchar_t const *,wchar_t const *)+2Cp
UNDEF:00004568                                         ; CompareFileNames(wchar_t const *,wchar_t const *)+24p ...
UNDEF:0000456C                 extrn __RTC_Shutdown:near
UNDEF:0000456C                                         ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
UNDEF:00004570                 extrn __RTC_InitBase:near
UNDEF:00004570                                         ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
UNDEF:00004574 ; int __stdcall MyStringCompareNoCase(const wchar_t *, const wchar_t *)
UNDEF:00004574                 extrn ?MyStringCompareNoCase@@YGHPB_W0@Z:near
UNDEF:00004574                                         ; CODE XREF: CompareFileNames(wchar_t const *,wchar_t const *)+33p
UNDEF:00004578 ; int __cdecl _wcscmp(const wchar_t *Str1, const wchar_t *Str2)
UNDEF:00004578                 extrn __imp__wcscmp:near
UNDEF:00004578                                         ; CODE XREF: CompareFileNames(wchar_t const *,wchar_t const *)+19p
UNDEF:00004578                                         ; operator==(UString const &,wchar_t const *)+13p ...
UNDEF:0000457C ; void __thiscall UString::SetFrom(UString *__hidden this, const wchar_t *, unsigned int)
UNDEF:0000457C                 extrn ?SetFrom@UString@@QAEXPB_WI@Z:near
UNDEF:0000457C                                         ; CODE XREF: SplitPathToParts(UString const &,CObjectVector<UString> &)+C3p
UNDEF:0000457C                                         ; SplitPathToParts(UString const &,CObjectVector<UString> &)+F6p ...
UNDEF:00004580 ; public: __thiscall UString::UString(void)
UNDEF:00004580                 extrn ??0UString@@QAE@XZ:near
UNDEF:00004580                                         ; CODE XREF: SplitPathToParts(UString const &,CObjectVector<UString> &)+63p
UNDEF:00004580                                         ; NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+A9p ...
UNDEF:00004584                 extrn ___security_cookie:near
UNDEF:00004584                                         ; DATA XREF: SplitPathToParts(UString const &,CObjectVector<UString> &)+31r
UNDEF:00004584                                         ; NWildcard::CCensorNode::AddItem(bool,NWildcard::CItem &,int)+26r ...
UNDEF:00004588                 extrn ___CxxFrameHandler3:near
UNDEF:00004588                                         ; CODE XREF: __ehhandler$?SplitPathToParts@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z+16j
UNDEF:00004588                                         ; __ehhandler$?AddItem@CCensorNode@NWildcard@@QAEX_NAAUCItem@2@H@Z+16j ...
UNDEF:0000458C ; __fastcall __security_check_cookie(x)
UNDEF:0000458C                 extrn @__security_check_cookie@4:near
UNDEF:0000458C                                         ; CODE XREF: __ehhandler$?SplitPathToParts@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z+Cp
UNDEF:0000458C                                         ; __ehhandler$?AddItem@CCensorNode@NWildcard@@QAEX_NAAUCItem@2@H@Z+Cp ...
UNDEF:00004590 ; __fastcall _RTC_CheckStackVars(x, x)
UNDEF:00004590                 extrn @_RTC_CheckStackVars@8:near
UNDEF:00004590                                         ; CODE XREF: SplitPathToParts(UString const &,CObjectVector<UString> &)+120p
UNDEF:00004590                                         ; NWildcard::CCensorNode::AddItem(bool,UString const &,bool,bool,bool,bool)+A2p ...
UNDEF:00004594 ; void __cdecl operator delete(void *)
UNDEF:00004594                 extrn ??3@YAXPAX@Z:near ; CODE XREF: UString::~UString(void)+23p
UNDEF:00004594                                         ; __unwindfunclet$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z$1+4p ...
UNDEF:00004598 ; public: class UString & __thiscall UString::operator=(wchar_t const *)
UNDEF:00004598                 extrn ??4UString@@QAEAAV0@PB_W@Z:near
UNDEF:00004598                                         ; CODE XREF: SplitPathToParts_2(UString const &,UString &,UString &)+7Cp
UNDEF:00004598                                         ; SplitPathToParts_Smart(UString const &,UString &,UString &)+A1p
UNDEF:0000459C ; private: __thiscall UString::UString(unsigned int, class UString const &)
UNDEF:0000459C                 extrn ??0UString@@AAE@IABV0@@Z:near
UNDEF:0000459C                                         ; CODE XREF: UString::Left(uint)+29p
UNDEF:000045A0 ; public: __thiscall UString::UString(wchar_t const *)
UNDEF:000045A0                 extrn ??0UString@@QAE@PB_W@Z:near
UNDEF:000045A0                                         ; CODE XREF: ExtractFileNameFromPath(UString const &)+70p
UNDEF:000045A0                                         ; NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+328p
UNDEF:000045A4 ; wchar_t __stdcall MyCharUpper_WIN(wchar_t)
UNDEF:000045A4                 extrn ?MyCharUpper_WIN@@YG_W_W@Z:near
UNDEF:000045A4                                         ; CODE XREF: MyCharUpper(wchar_t)+38p
UNDEF:000045A8 ; public: __thiscall UString::UString(class UString const &)
UNDEF:000045A8                 extrn ??0UString@@QAE@ABV0@@Z:near
UNDEF:000045A8                                         ; CODE XREF: NWildcard::CCensorNode::AddItem2(bool,UString const &,bool,bool)+62p
UNDEF:000045A8                                         ; NWildcard::CCensorNode::CCensorNode(UString const &,NWildcard::CCensorNode *)+3Fp ...
UNDEF:000045AC ; public: class UString & __thiscall UString::operator+=(class UString const &)
UNDEF:000045AC                 extrn ??YUString@@QAEAAV0@ABV0@@Z:near
UNDEF:000045AC                                         ; CODE XREF: NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+267p
UNDEF:000045B0 ; __stdcall _CxxThrowException(x, x)
UNDEF:000045B0                 extrn __CxxThrowException@8:near
UNDEF:000045B0                                         ; CODE XREF: NWildcard::CCensor::AddItem(NWildcard::ECensorPathMode,bool,UString const &,bool,bool)+5Fp
UNDEF:000045B4 ; const type_info::`vftable'
UNDEF:000045B4                 extrn ??_7type_info@@6B@:near
UNDEF:000045B4                                         ; DATA XREF: .data:char * `RTTI Type Descriptor'o
UNDEF:000045B4                                         ; .data:void * `RTTI Type Descriptor'o
UNDEF:000045B8 ; void __thiscall UString::Grow_1(UString *__hidden this)
UNDEF:000045B8                 extrn ?Grow_1@UString@@AAEXXZ:near
UNDEF:000045B8                                         ; CODE XREF: UString::operator+=(wchar_t)+2Fp
UNDEF:000045BC ; bool __stdcall StringsAreEqualNoCase_Ascii(const wchar_t *, const char *)
UNDEF:000045BC                 extrn ?StringsAreEqualNoCase_Ascii@@YG_NPB_WPBD@Z:near
UNDEF:000045BC                                         ; CODE XREF: UString::IsEqualTo_Ascii_NoCase(char const *)+18p
UNDEF:000045C0 ; public: class UString & __thiscall UString::operator=(class UString const &)
UNDEF:000045C0                 extrn ??4UString@@QAEAAV0@ABV0@@Z:near
UNDEF:000045C0                                         ; CODE XREF: NWildcard::CCensor::AddPreItem(bool,UString const &,bool,bool)+2Cp
UNDEF:000045C4 ; void *__cdecl operator new(unsigned int)
UNDEF:000045C4                 extrn ??2@YAPAXI@Z:near ; CODE XREF: CObjectVector<UString>::CObjectVector<UString>(CObjectVector<UString> const &)+81p
UNDEF:000045C4                                         ; CObjectVector<UString>::operator=(CObjectVector<UString> const &)+8Ap ...
UNDEF:000045C8 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:000045C8                 extrn _memcpy:near      ; CODE XREF: CRecordVector<void *>::Reserve(uint)+67p
UNDEF:000045C8                                         ; CRecordVector<void *>::ReserveOnePosition(void)+87p
UNDEF:000045CC ; void *__cdecl _memmove(void *Dst, const void *Src, size_t Size)
UNDEF:000045CC                 extrn __imp__memmove:near
UNDEF:000045CC                                         ; CODE XREF: CRecordVector<void *>::MoveItems(uint,uint)+36p
UNDEF:000045CC                                         ; DATA XREF: CRecordVector<void *>::MoveItems(uint,uint)+36r
UNDEF:000045CC
UNDEF:000045CC
UNDEF:000045CC                 end