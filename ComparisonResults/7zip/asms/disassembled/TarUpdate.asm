.text:00000000 ;
.text:00000000 ; +-------------------------------------------------------------------------+
.text:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.text:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.text:00000000 ; |                      License info: 48-3677-7074-51                      |
.text:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.text:00000000 ; +-------------------------------------------------------------------------+
.text:00000000 ;
.text:00000000 ; Input MD5   : AD36623C64C1671D054AD466EAC5C32A
.text:00000000 ; Input CRC32 : D2732B31
.text:00000000
.text:00000000 ; File Name   : C:\workspace\7z1505-src\CPP\7zip\Bundles\Alone\Debug\TarUpdate.obj
.text:00000000 ; Format      : COFF (X386MAGIC)
.text:00000000 ; includelib "uuid.lib"
.text:00000000 ; includelib "MSVCRTD"
.text:00000000 ; includelib "OLDNAMES"
.text:00000000
.text:00000000                 .686p
.text:00000000                 .mmx
.text:00000000                 .model flat
.text:00000000
.text:00000000 ; ===========================================================================
.text:00000000
.text:00000000 ; Segment type: Pure code
.text:00000000 ; Segment permissions: Read/Execute
.text:00000000 _text           segment para public 'CODE' use32
.text:00000000                 assume cs:_text
.text:00000000                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00000000
.text:00000000 ; =============== S U B R O U T I N E =======================================
.text:00000000
.text:00000000 ; Attributes: bp-based frame
.text:00000000
.text:00000000 ; int __stdcall NArchive::NTar::UpdateArchive(struct ISequentialInStream *, struct ISequentialOutStream *, int, int, struct AString *, NArchive::NTar *)
.text:00000000                 public ?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z
.text:00000000 ?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z proc near
.text:00000000
.text:00000000 var_27C         = dword ptr -27Ch
.text:00000000 var_278         = dword ptr -278h
.text:00000000 var_274         = dword ptr -274h
.text:00000000 var_270         = dword ptr -270h
.text:00000000 var_26C         = dword ptr -26Ch
.text:00000000 var_268         = dword ptr -268h
.text:00000000 var_264         = dword ptr -264h
.text:00000000 var_260         = dword ptr -260h
.text:00000000 var_25C         = dword ptr -25Ch
.text:00000000 var_258         = dword ptr -258h
.text:00000000 var_254         = dword ptr -254h
.text:00000000 var_250         = dword ptr -250h
.text:00000000 var_24C         = dword ptr -24Ch
.text:00000000 var_248         = dword ptr -248h
.text:00000000 var_244         = dword ptr -244h
.text:00000000 var_240         = dword ptr -240h
.text:00000000 var_23C         = dword ptr -23Ch
.text:00000000 var_238         = dword ptr -238h
.text:00000000 var_234         = dword ptr -234h
.text:00000000 var_230         = dword ptr -230h
.text:00000000 var_22C         = dword ptr -22Ch
.text:00000000 var_228         = dword ptr -228h
.text:00000000 var_224         = dword ptr -224h
.text:00000000 var_220         = dword ptr -220h
.text:00000000 var_21C         = dword ptr -21Ch
.text:00000000 var_218         = dword ptr -218h
.text:00000000 var_214         = dword ptr -214h
.text:00000000 var_210         = dword ptr -210h
.text:00000000 var_20C         = dword ptr -20Ch
.text:00000000 var_208         = dword ptr -208h
.text:00000000 var_204         = dword ptr -204h
.text:00000000 var_200         = dword ptr -200h
.text:00000000 var_1FC         = dword ptr -1FCh
.text:00000000 var_1F8         = dword ptr -1F8h
.text:00000000 var_1F4         = dword ptr -1F4h
.text:00000000 var_1F0         = dword ptr -1F0h
.text:00000000 var_1EC         = dword ptr -1ECh
.text:00000000 var_1E8         = dword ptr -1E8h
.text:00000000 var_1E4         = dword ptr -1E4h
.text:00000000 var_1E0         = dword ptr -1E0h
.text:00000000 var_1DC         = dword ptr -1DCh
.text:00000000 var_1D8         = dword ptr -1D8h
.text:00000000 var_1D4         = dword ptr -1D4h
.text:00000000 var_1D0         = dword ptr -1D0h
.text:00000000 var_1CC         = dword ptr -1CCh
.text:00000000 var_1C8         = dword ptr -1C8h
.text:00000000 var_1C4         = dword ptr -1C4h
.text:00000000 var_1C0         = dword ptr -1C0h
.text:00000000 var_1BC         = dword ptr -1BCh
.text:00000000 var_1B8         = qword ptr -1B8h
.text:00000000 var_1B0         = dword ptr -1B0h
.text:00000000 var_1AC         = dword ptr -1ACh
.text:00000000 var_1A8         = dword ptr -1A8h
.text:00000000 var_1A4         = dword ptr -1A4h
.text:00000000 var_1A0         = dword ptr -1A0h
.text:00000000 var_19C         = dword ptr -19Ch
.text:00000000 var_198         = dword ptr -198h
.text:00000000 var_194         = dword ptr -194h
.text:00000000 var_190         = dword ptr -190h
.text:00000000 var_18C         = dword ptr -18Ch
.text:00000000 var_188         = dword ptr -188h
.text:00000000 var_184         = dword ptr -184h
.text:00000000 var_180         = dword ptr -180h
.text:00000000 var_178         = dword ptr -178h
.text:00000000 var_164         = dword ptr -164h
.text:00000000 var_160         = dword ptr -160h
.text:00000000 var_154         = byte ptr -154h
.text:00000000 var_144         = byte ptr -144h
.text:00000000 var_13C         = dword ptr -13Ch
.text:00000000 var_138         = dword ptr -138h
.text:00000000 var_131         = byte ptr -131h
.text:00000000 var_12C         = byte ptr -12Ch
.text:00000000 var_124         = dword ptr -124h
.text:00000000 var_11C         = dword ptr -11Ch
.text:00000000 var_108         = byte ptr -108h
.text:00000000 var_F8          = qword ptr -0F8h
.text:00000000 var_F0          = dword ptr -0F0h
.text:00000000 var_EC          = dword ptr -0ECh
.text:00000000 var_E8          = dword ptr -0E8h
.text:00000000 var_E4          = dword ptr -0E4h
.text:00000000 var_E0          = dword ptr -0E0h
.text:00000000 var_DC          = dword ptr -0DCh
.text:00000000 var_D8          = dword ptr -0D8h
.text:00000000 var_D4          = dword ptr -0D4h
.text:00000000 var_D0          = dword ptr -0D0h
.text:00000000 var_CC          = byte ptr -0CCh
.text:00000000 var_C0          = byte ptr -0C0h
.text:00000000 var_B4          = byte ptr -0B4h
.text:00000000 Dst             = byte ptr -0A8h
.text:00000000 var_A0          = byte ptr -0A0h
.text:00000000 var_9F          = byte ptr -9Fh
.text:00000000 var_9E          = byte ptr -9Eh
.text:00000000 var_9C          = byte ptr -9Ch
.text:00000000 var_8C          = dword ptr -8Ch
.text:00000000 var_88          = dword ptr -88h
.text:00000000 var_80          = byte ptr -80h
.text:00000000 var_78          = dword ptr -78h
.text:00000000 var_70          = byte ptr -70h
.text:00000000 var_68          = dword ptr -68h
.text:00000000 var_60          = byte ptr -60h
.text:00000000 var_58          = dword ptr -58h
.text:00000000 var_54          = dword ptr -54h
.text:00000000 var_50          = dword ptr -50h
.text:00000000 var_4C          = dword ptr -4Ch
.text:00000000 var_48          = dword ptr -48h
.text:00000000 var_44          = byte ptr -44h
.text:00000000 var_3C          = byte ptr -3Ch
.text:00000000 var_30          = byte ptr -30h
.text:00000000 var_24          = byte ptr -24h
.text:00000000 var_1C          = dword ptr -1Ch
.text:00000000 var_18          = dword ptr -18h
.text:00000000 var_10          = dword ptr -10h
.text:00000000 var_C           = dword ptr -0Ch
.text:00000000 var_4           = dword ptr -4
.text:00000000 arg_0           = dword ptr  8
.text:00000000 arg_4           = dword ptr  0Ch
.text:00000000 arg_8           = dword ptr  10h
.text:00000000 arg_C           = dword ptr  14h
.text:00000000 arg_10          = dword ptr  18h
.text:00000000 arg_14          = dword ptr  1Ch
.text:00000000
.text:00000000                 push    ebp
.text:00000001
.text:00000001 ; struct _FILETIME loc_1
.text:00000001 loc_1:                                  ; DATA XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+272o
.text:00000001                                         ; NArchive::NTar::CItem::IsDir(void):$LN1o
.text:00000001                 mov     ebp, esp
.text:00000003                 push    0FFFFFFFFh
.text:00000005                 push    offset __ehhandler$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z
.text:0000000A                 mov     eax, large fs:0
.text:00000010                 push    eax
.text:00000011                 sub     esp, 270h
.text:00000017                 push    esi
.text:00000018                 push    edi
.text:00000019                 lea     edi, [ebp+var_27C]
.text:0000001F                 mov     ecx, 9Ch ; 'Â£'
.text:00000024                 mov     eax, 0CCCCCCCCh
.text:00000029                 rep stosd
.text:0000002B                 mov     eax, dword ptr ds:___security_cookie
.text:00000030                 xor     eax, ebp
.text:00000032                 mov     [ebp+var_10], eax
.text:00000035                 push    eax
.text:00000036                 lea     eax, [ebp+var_C]
.text:00000039                 mov     large fs:0, eax
.text:0000003F                 lea     ecx, [ebp+var_24] ; this
.text:00000042                 call    ??0COutArchive@NTar@NArchive@@QAE@XZ ; NArchive::NTar::COutArchive::COutArchive(void)
.text:00000047                 mov     [ebp+var_4], 0
.text:0000004E                 mov     eax, [ebp+arg_4]
.text:00000051                 push    eax             ; struct ISequentialOutStream *
.text:00000052                 lea     ecx, [ebp+var_24] ; this
.text:00000055                 call    ?Create@COutArchive@NTar@NArchive@@QAEXPAUISequentialOutStream@@@Z ; NArchive::NTar::COutArchive::Create(ISequentialOutStream *)
.text:0000005A                 mov     [ebp+var_1C], 0
.text:00000061                 mov     [ebp+var_18], 0
.text:00000068                 lea     ecx, [ebp+var_30]
.text:0000006B                 call    ??0?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::CMyComPtr<IOutStream>(void)
.text:00000070                 mov     byte ptr [ebp+var_4], 1
.text:00000074                 lea     ecx, [ebp+var_30]
.text:00000077                 call    ??I?$CMyComPtr@UIOutStream@@@@QAEPAPAUIOutStream@@XZ ; CMyComPtr<IOutStream>::operator&(void)
.text:0000007C                 mov     esi, esp
.text:0000007E                 push    eax
.text:0000007F                 push    offset _IID_IOutStream
.text:00000084                 mov     ecx, [ebp+arg_4]
.text:00000087                 mov     edx, [ecx]
.text:00000089                 mov     eax, [ebp+arg_4]
.text:0000008C                 push    eax
.text:0000008D                 mov     ecx, [edx]
.text:0000008F                 call    ecx
.text:00000091                 cmp     esi, esp
.text:00000093                 call    __RTC_CheckEsp
.text:00000098                 lea     ecx, [ebp+var_3C]
.text:0000009B                 call    ??0?$CMyComPtr@UIArchiveUpdateCallbackFile@@@@QAE@XZ ; CMyComPtr<IArchiveUpdateCallbackFile>::CMyComPtr<IArchiveUpdateCallbackFile>(void)
.text:000000A0                 mov     byte ptr [ebp+var_4], 2
.text:000000A4                 lea     ecx, [ebp+var_3C]
.text:000000A7                 call    ??I?$CMyComPtr@UIArchiveUpdateCallbackFile@@@@QAEPAPAUIArchiveUpdateCallbackFile@@XZ ; CMyComPtr<IArchiveUpdateCallbackFile>::operator&(void)
.text:000000AC                 mov     esi, esp
.text:000000AE                 push    eax
.text:000000AF                 push    offset _IID_IArchiveUpdateCallbackFile
.text:000000B4                 mov     edx, [ebp+arg_14]
.text:000000B7                 mov     eax, [edx]
.text:000000B9                 mov     ecx, [ebp+arg_14]
.text:000000BC                 push    ecx
.text:000000BD                 mov     edx, [eax]
.text:000000BF                 call    edx
.text:000000C1                 cmp     esi, esp
.text:000000C3                 call    __RTC_CheckEsp
.text:000000C8                 mov     [ebp+var_48], 0
.text:000000CF                 mov     dword ptr [ebp+var_44], 0
.text:000000D6                 mov     [ebp+var_4C], 0
.text:000000DD                 jmp     short loc_E8
.text:000000DF ; ---------------------------------------------------------------------------
.text:000000DF
.text:000000DF loc_DF:                                 ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *):loc_147j
.text:000000DF                 mov     eax, [ebp+var_4C]
.text:000000E2                 add     eax, 1
.text:000000E5                 mov     [ebp+var_4C], eax
.text:000000E8
.text:000000E8 loc_E8:                                 ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+DDj
.text:000000E8                 mov     ecx, [ebp+arg_C]
.text:000000EB                 call    ?Size@?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QBEIXZ ; CObjectVector<NArchive::NTar::CUpdateItem>::Size(void)
.text:000000F0                 cmp     [ebp+var_4C], eax
.text:000000F3                 jnb     short loc_149
.text:000000F5                 mov     ecx, [ebp+var_4C]
.text:000000F8                 push    ecx
.text:000000F9                 mov     ecx, [ebp+arg_C]
.text:000000FC                 call    ??A?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QBEABUCUpdateItem@NTar@NArchive@@I@Z ; CObjectVector<NArchive::NTar::CUpdateItem>::operator[](uint)
.text:00000101                 mov     [ebp+var_50], eax
.text:00000104                 mov     edx, [ebp+var_50]
.text:00000107                 movzx   eax, byte ptr [edx+1Ch]
.text:0000010B                 test    eax, eax
.text:0000010D                 jz      short loc_126
.text:0000010F                 mov     ecx, [ebp+var_50]
.text:00000112                 mov     edx, [ebp+var_48]
.text:00000115                 add     edx, [ecx+10h]
.text:00000118                 mov     eax, dword ptr [ebp+var_44]
.text:0000011B                 adc     eax, [ecx+14h]
.text:0000011E                 mov     [ebp+var_48], edx
.text:00000121                 mov     dword ptr [ebp+var_44], eax
.text:00000124                 jmp     short loc_147
.text:00000126 ; ---------------------------------------------------------------------------
.text:00000126
.text:00000126 loc_126:                                ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+10Dj
.text:00000126                 mov     ecx, [ebp+var_50]
.text:00000129                 mov     edx, [ecx]
.text:0000012B                 push    edx
.text:0000012C                 mov     ecx, [ebp+arg_8]
.text:0000012F                 call    ??A?$CObjectVector@UCItemEx@NTar@NArchive@@@@QBEABUCItemEx@NTar@NArchive@@I@Z ; CObjectVector<NArchive::NTar::CItemEx>::operator[](uint)
.text:00000134                 mov     ecx, eax        ; this
.text:00000136                 call    ?GetFullSize@CItemEx@NTar@NArchive@@QBE_KXZ ; NArchive::NTar::CItemEx::GetFullSize(void)
.text:0000013B                 add     eax, [ebp+var_48]
.text:0000013E                 adc     edx, dword ptr [ebp+var_44]
.text:00000141                 mov     [ebp+var_48], eax
.text:00000144                 mov     dword ptr [ebp+var_44], edx
.text:00000147
.text:00000147 loc_147:                                ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+124j
.text:00000147                 jmp     short loc_DF
.text:00000149 ; ---------------------------------------------------------------------------
.text:00000149
.text:00000149 loc_149:                                ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+F3j
.text:00000149                 mov     esi, esp
.text:0000014B                 mov     eax, dword ptr [ebp+var_44]
.text:0000014E                 push    eax             ; bool
.text:0000014F                 mov     ecx, [ebp+var_48]
.text:00000152                 push    ecx
.text:00000153                 mov     edx, [ebp+arg_14]
.text:00000156                 mov     eax, [edx]
.text:00000158                 mov     ecx, [ebp+arg_14]
.text:0000015B                 push    ecx
.text:0000015C                 mov     edx, [eax+0Ch]
.text:0000015F                 call    edx
.text:00000161                 cmp     esi, esp
.text:00000163                 call    __RTC_CheckEsp
.text:00000168                 mov     [ebp+var_54], eax
.text:0000016B                 cmp     [ebp+var_54], 0
.text:0000016F                 jz      short loc_1AC
.text:00000171                 mov     eax, [ebp+var_54]
.text:00000174                 mov     [ebp+var_1D8], eax
.text:0000017A                 mov     byte ptr [ebp+var_4], 1
.text:0000017E                 lea     ecx, [ebp+var_3C]
.text:00000181                 call    ??1?$CMyComPtr@UIArchiveUpdateCallbackFile@@@@QAE@XZ ; CMyComPtr<IArchiveUpdateCallbackFile>::~CMyComPtr<IArchiveUpdateCallbackFile>(void)
.text:00000186                 mov     byte ptr [ebp+var_4], 0
.text:0000018A                 lea     ecx, [ebp+var_30]
.text:0000018D                 call    ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::~CMyComPtr<IOutStream>(void)
.text:00000192                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000199                 lea     ecx, [ebp+var_24] ; this
.text:0000019C                 call    ??1COutArchive@NTar@NArchive@@QAE@XZ ; NArchive::NTar::COutArchive::~COutArchive(void)
.text:000001A1                 mov     eax, [ebp+var_1D8]
.text:000001A7                 jmp     loc_1978
.text:000001AC ; ---------------------------------------------------------------------------
.text:000001AC
.text:000001AC loc_1AC:                                ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+16Fj
.text:000001AC                 push    28h ; '('       ; unsigned int
.text:000001AE                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:000001B3                 add     esp, 4
.text:000001B6                 mov     [ebp+var_1E0], eax
.text:000001BC                 mov     byte ptr [ebp+var_4], 3
.text:000001C0                 cmp     [ebp+var_1E0], 0
.text:000001C7                 jz      short loc_1DC
.text:000001C9                 mov     ecx, [ebp+var_1E0] ; this
.text:000001CF                 call    ??0CCopyCoder@NCompress@@QAE@XZ ; NCompress::CCopyCoder::CCopyCoder(void)
.text:000001D4                 mov     [ebp+var_24C], eax
.text:000001DA                 jmp     short loc_1E6
.text:000001DC ; ---------------------------------------------------------------------------
.text:000001DC
.text:000001DC loc_1DC:                                ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+1C7j
.text:000001DC                 mov     [ebp+var_24C], 0
.text:000001E6
.text:000001E6 loc_1E6:                                ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+1DAj
.text:000001E6                 mov     ecx, [ebp+var_24C]
.text:000001EC                 mov     [ebp+var_1DC], ecx
.text:000001F2                 mov     byte ptr [ebp+var_4], 2
.text:000001F6                 mov     edx, [ebp+var_1DC]
.text:000001FC                 mov     [ebp+var_58], edx
.text:000001FF                 mov     eax, [ebp+var_58]
.text:00000202                 push    eax
.text:00000203                 lea     ecx, [ebp+var_60]
.text:00000206                 call    ??0?$CMyComPtr@UICompressCoder@@@@QAE@PAUICompressCoder@@@Z ; CMyComPtr<ICompressCoder>::CMyComPtr<ICompressCoder>(ICompressCoder *)
.text:0000020B                 mov     byte ptr [ebp+var_4], 4
.text:0000020F                 push    38h ; '8'       ; unsigned int
.text:00000211                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00000216                 add     esp, 4
.text:00000219                 mov     [ebp+var_1E8], eax
.text:0000021F                 mov     byte ptr [ebp+var_4], 5
.text:00000223                 cmp     [ebp+var_1E8], 0
.text:0000022A                 jz      short loc_23F
.text:0000022C                 mov     ecx, [ebp+var_1E8]
.text:00000232                 call    ??0CLocalProgress@@QAE@XZ ; CLocalProgress::CLocalProgress(void)
.text:00000237                 mov     [ebp+var_250], eax
.text:0000023D                 jmp     short loc_249
.text:0000023F ; ---------------------------------------------------------------------------
.text:0000023F
.text:0000023F loc_23F:                                ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+22Aj
.text:0000023F                 mov     [ebp+var_250], 0
.text:00000249
.text:00000249 loc_249:                                ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+23Dj
.text:00000249                 mov     ecx, [ebp+var_250]
.text:0000024F                 mov     [ebp+var_1E4], ecx
.text:00000255                 mov     byte ptr [ebp+var_4], 4
.text:00000259                 mov     edx, [ebp+var_1E4]
.text:0000025F                 mov     [ebp+var_68], edx
.text:00000262                 mov     eax, [ebp+var_68]
.text:00000265                 push    eax
.text:00000266                 lea     ecx, [ebp+var_70]
.text:00000269                 call    ??0?$CMyComPtr@UICompressProgressInfo@@@@QAE@PAUICompressProgressInfo@@@Z ; CMyComPtr<ICompressProgressInfo>::CMyComPtr<ICompressProgressInfo>(ICompressProgressInfo *)
.text:0000026E                 mov     byte ptr [ebp+var_4], 6
.text:00000272                 push    offset loc_1    ; bool
.text:00000274                 mov     ecx, [ebp+arg_14]
.text:00000277                 push    ecx             ; struct IProgress *
.text:00000278                 mov     ecx, [ebp+var_68] ; this
.text:0000027B                 call    ?Init@CLocalProgress@@QAEXPAUIProgress@@_N@Z ; CLocalProgress::Init(IProgress *,bool)
.text:00000280                 push    28h ; '('       ; unsigned int
.text:00000282                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00000287                 add     esp, 4
.text:0000028A                 mov     [ebp+var_1F0], eax
.text:00000290                 mov     byte ptr [ebp+var_4], 7
.text:00000294                 cmp     [ebp+var_1F0], 0
.text:0000029B                 jz      short loc_2B0
.text:0000029D                 mov     ecx, [ebp+var_1F0]
.text:000002A3                 call    ??0CLimitedSequentialInStream@@QAE@XZ ; CLimitedSequentialInStream::CLimitedSequentialInStream(void)
.text:000002A8                 mov     [ebp+var_254], eax
.text:000002AE                 jmp     short loc_2BA
.text:000002B0 ; ---------------------------------------------------------------------------
.text:000002B0
.text:000002B0 loc_2B0:                                ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+29Bj
.text:000002B0                 mov     [ebp+var_254], 0
.text:000002BA
.text:000002BA loc_2BA:                                ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+2AEj
.text:000002BA                 mov     edx, [ebp+var_254]
.text:000002C0                 mov     [ebp+var_1EC], edx
.text:000002C6                 mov     byte ptr [ebp+var_4], 6
.text:000002CA                 mov     eax, [ebp+var_1EC]
.text:000002D0                 mov     [ebp+var_78], eax
.text:000002D3                 mov     ecx, [ebp+var_78]
.text:000002D6                 push    ecx
.text:000002D7                 lea     ecx, [ebp+var_80]
.text:000002DA                 call    ??0?$CMyComPtr@VCLimitedSequentialInStream@@@@QAE@PAVCLimitedSequentialInStream@@@Z ; CMyComPtr<CLimitedSequentialInStream>::CMyComPtr<CLimitedSequentialInStream>(CLimitedSequentialInStream *)
.text:000002DF                 mov     byte ptr [ebp+var_4], 8
.text:000002E3                 mov     edx, [ebp+arg_0]
.text:000002E6                 push    edx             ; struct ISequentialInStream *
.text:000002E7                 mov     ecx, [ebp+var_78] ; this
.text:000002EA                 call    ?SetStream@CLimitedSequentialInStream@@QAEXPAUISequentialInStream@@@Z ; CLimitedSequentialInStream::SetStream(ISequentialInStream *)
.text:000002EF                 mov     [ebp+var_48], 0
.text:000002F6                 mov     dword ptr [ebp+var_44], 0
.text:000002FD                 mov     [ebp+var_4C], 0
.text:00000304                 jmp     short loc_30F
.text:00000306 ; ---------------------------------------------------------------------------
.text:00000306
.text:00000306 loc_306:                                ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+1880j
.text:00000306                 mov     eax, [ebp+var_4C]
.text:00000309                 add     eax, 1
.text:0000030C                 mov     [ebp+var_4C], eax
.text:0000030F
.text:0000030F loc_30F:                                ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+304j
.text:0000030F                 mov     ecx, [ebp+arg_C]
.text:00000312                 call    ?Size@?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QBEIXZ ; CObjectVector<NArchive::NTar::CUpdateItem>::Size(void)
.text:00000317                 cmp     [ebp+var_4C], eax
.text:0000031A                 jnb     loc_1885
.text:00000320                 mov     ecx, [ebp+var_68]
.text:00000323                 mov     edx, [ebp+var_48]
.text:00000326                 mov     [ecx+28h], edx
.text:00000329                 mov     eax, dword ptr [ebp+var_44]
.text:0000032C                 mov     [ecx+2Ch], eax
.text:0000032F                 mov     ecx, [ebp+var_68]
.text:00000332                 mov     edx, [ebp+var_48]
.text:00000335                 mov     [ecx+20h], edx
.text:00000338                 mov     eax, dword ptr [ebp+var_44]
.text:0000033B                 mov     [ecx+24h], eax
.text:0000033E                 mov     ecx, [ebp+var_68] ; this
.text:00000341                 call    ?SetCur@CLocalProgress@@QAEJXZ ; CLocalProgress::SetCur(void)
.text:00000346                 mov     [ebp+var_88], eax
.text:0000034C                 cmp     [ebp+var_88], 0
.text:00000353                 jz      short loc_3B7
.text:00000355                 mov     ecx, [ebp+var_88]
.text:0000035B                 mov     [ebp+var_1F4], ecx
.text:00000361                 mov     byte ptr [ebp+var_4], 6
.text:00000365                 lea     ecx, [ebp+var_80]
.text:00000368                 call    ??1?$CMyComPtr@VCLimitedSequentialInStream@@@@QAE@XZ ; CMyComPtr<CLimitedSequentialInStream>::~CMyComPtr<CLimitedSequentialInStream>(void)
.text:0000036D                 mov     byte ptr [ebp+var_4], 4
.text:00000371                 lea     ecx, [ebp+var_70]
.text:00000374                 call    ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ ; CMyComPtr<ICompressProgressInfo>::~CMyComPtr<ICompressProgressInfo>(void)
.text:00000379                 mov     byte ptr [ebp+var_4], 2
.text:0000037D                 lea     ecx, [ebp+var_60]
.text:00000380                 call    ??1?$CMyComPtr@UICompressCoder@@@@QAE@XZ ; CMyComPtr<ICompressCoder>::~CMyComPtr<ICompressCoder>(void)
.text:00000385                 mov     byte ptr [ebp+var_4], 1
.text:00000389                 lea     ecx, [ebp+var_3C]
.text:0000038C                 call    ??1?$CMyComPtr@UIArchiveUpdateCallbackFile@@@@QAE@XZ ; CMyComPtr<IArchiveUpdateCallbackFile>::~CMyComPtr<IArchiveUpdateCallbackFile>(void)
.text:00000391                 mov     byte ptr [ebp+var_4], 0
.text:00000395                 lea     ecx, [ebp+var_30]
.text:00000398                 call    ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::~CMyComPtr<IOutStream>(void)
.text:0000039D                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000003A4                 lea     ecx, [ebp+var_24] ; this
.text:000003A7                 call    ??1COutArchive@NTar@NArchive@@QAE@XZ ; NArchive::NTar::COutArchive::~COutArchive(void)
.text:000003AC                 mov     eax, [ebp+var_1F4]
.text:000003B2                 jmp     loc_1978
.text:000003B7 ; ---------------------------------------------------------------------------
.text:000003B7
.text:000003B7 loc_3B7:                                ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+353j
.text:000003B7                 mov     edx, [ebp+var_4C]
.text:000003BA                 push    edx
.text:000003BB                 mov     ecx, [ebp+arg_C]
.text:000003BE                 call    ??A?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QBEABUCUpdateItem@NTar@NArchive@@I@Z ; CObjectVector<NArchive::NTar::CUpdateItem>::operator[](uint)
.text:000003C3                 mov     [ebp+var_8C], eax
.text:000003C9                 lea     ecx, [ebp+var_108] ; this
.text:000003CF                 call    ??0CItem@NTar@NArchive@@QAE@XZ ; NArchive::NTar::CItem::CItem(void)
.text:000003D4                 mov     byte ptr [ebp+var_4], 9
.text:000003D8                 mov     eax, [ebp+var_8C]
.text:000003DE                 movzx   ecx, byte ptr [eax+1Dh]
.text:000003E2                 test    ecx, ecx
.text:000003E4                 jz      loc_4D4
.text:000003EA                 mov     edx, [ebp+var_8C]
.text:000003F0                 mov     eax, [edx+18h]
.text:000003F3                 mov     [ebp+var_E0], eax
.text:000003F9                 mov     ecx, [ebp+var_8C]
.text:000003FF                 add     ecx, 20h ; ' '
.text:00000402                 push    ecx
.text:00000403                 lea     ecx, [ebp+var_108]
.text:00000409                 call    ??4AString@@QAEAAV0@ABV0@@Z ; AString::operator=(AString const &)
.text:0000040E                 mov     edx, [ebp+var_8C]
.text:00000414                 add     edx, 2Ch ; ','
.text:00000417                 push    edx
.text:00000418                 lea     ecx, [ebp+var_C0]
.text:0000041E                 call    ??4AString@@QAEAAV0@ABV0@@Z ; AString::operator=(AString const &)
.text:00000423                 mov     eax, [ebp+var_8C]
.text:00000429                 add     eax, 38h ; '8'
.text:0000042C                 push    eax
.text:0000042D                 lea     ecx, [ebp+var_B4]
.text:00000433                 call    ??4AString@@QAEAAV0@ABV0@@Z ; AString::operator=(AString const &)
.text:00000438                 mov     ecx, [ebp+var_8C]
.text:0000043E                 movzx   edx, byte ptr [ecx+1Eh]
.text:00000442                 test    edx, edx
.text:00000444                 jz      short loc_463
.text:00000446                 mov     [ebp+var_A0], 35h ; '5'
.text:0000044D                 mov     dword ptr [ebp+var_F8], 0
.text:00000457                 mov     dword ptr [ebp+var_F8+4], 0
.text:00000461                 jmp     short loc_482
.text:00000463 ; ---------------------------------------------------------------------------
.text:00000463
.text:00000463 loc_463:                                ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+444j
.text:00000463                 mov     [ebp+var_A0], 30h ; '0'
.text:0000046A                 mov     eax, [ebp+var_8C]
.text:00000470                 mov     ecx, [eax+10h]
.text:00000473                 mov     dword ptr [ebp+var_F8], ecx
.text:00000479                 mov     edx, [eax+14h]
.text:0000047C                 mov     dword ptr [ebp+var_F8+4], edx
.text:00000482
.text:00000482 loc_482:                                ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+461j
.text:00000482                 mov     eax, [ebp+var_8C]
.text:00000488                 mov     ecx, [eax+8]
.text:0000048B                 mov     [ebp+var_E8], ecx
.text:00000491                 mov     edx, [eax+0Ch]
.text:00000494                 mov     [ebp+var_E4], edx
.text:0000049A                 mov     [ebp+var_9F], 0
.text:000004A1                 mov     [ebp+var_9E], 0
.text:000004A8                 mov     [ebp+var_DC], 0
.text:000004B2                 mov     [ebp+var_D8], 0
.text:000004BC                 push    8               ; Size
.text:000004BE                 push    offset ?kUsTar_00@NMagic@NFileHeader@NTar@NArchive@@3QBDB ; Src
.text:000004C3                 lea     eax, [ebp+Dst]
.text:000004C9                 push    eax             ; Dst
.text:000004CA                 call    _memcpy
.text:000004CF                 add     esp, 0Ch
.text:000004D2                 jmp     short loc_4F1
.text:000004D4 ; ---------------------------------------------------------------------------
.text:000004D4
.text:000004D4 loc_4D4:                                ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+3E4j
.text:000004D4                 mov     ecx, [ebp+var_8C]
.text:000004DA                 mov     edx, [ecx]
.text:000004DC                 push    edx
.text:000004DD                 mov     ecx, [ebp+arg_8]
.text:000004E0                 call    ??A?$CObjectVector@UCItemEx@NTar@NArchive@@@@QBEABUCItemEx@NTar@NArchive@@I@Z ; CObjectVector<NArchive::NTar::CItemEx>::operator[](uint)
.text:000004E5                 push    eax
.text:000004E6                 lea     ecx, [ebp+var_108]
.text:000004EC                 call    ??4CItem@NTar@NArchive@@QAEAAU012@ABU012@@Z ; NArchive::NTar::CItem::operator=(NArchive::NTar::CItem const &)
.text:000004F1
.text:000004F1 loc_4F1:                                ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+4D2j
.text:000004F1                 lea     ecx, [ebp+var_11C]
.text:000004F7                 call    ??0AString@@QAE@XZ ; AString::AString(void)
.text:000004FC                 mov     byte ptr [ebp+var_4], 0Ah
.text:00000500                 mov     eax, [ebp+var_8C]
.text:00000506                 movzx   ecx, byte ptr [eax+1Ch]
.text:0000050A                 test    ecx, ecx
.text:0000050C                 jnz     short loc_520
.text:0000050E                 mov     edx, [ebp+var_8C]
.text:00000514                 movzx   eax, byte ptr [edx+1Dh]
.text:00000518                 test    eax, eax
.text:0000051A                 jz      loc_600
.text:00000520
.text:00000520 loc_520:                                ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+50Cj
.text:00000520                 push    1               ; unsigned int
.text:00000522                 mov     ecx, [ebp+arg_10]
.text:00000525                 push    ecx             ; struct AString *
.text:00000526                 lea     edx, [ebp+var_11C]
.text:0000052C                 push    edx             ; unsigned __int32
.text:0000052D                 push    36h ; '6'       ; unsigned int
.text:0000052F                 mov     eax, [ebp+var_8C]
.text:00000535                 mov     ecx, [eax+4]
.text:00000538                 push    ecx             ; struct IArchiveUpdateCallback *
.text:00000539                 mov     edx, [ebp+arg_14]
.text:0000053C                 push    edx             ; struct _FILETIME *
.text:0000053D                 call    ?GetPropString@NTar@NArchive@@YGJPAUIArchiveUpdateCallback@@IKAAVAString@@I_N@Z ; NArchive::NTar::GetPropString(IArchiveUpdateCallback *,uint,ulong,AString &,uint,bool)
.text:00000542                 mov     [ebp+var_124], eax
.text:00000548                 cmp     [ebp+var_124], 0
.text:0000054F                 jz      loc_5D5
.text:00000555                 mov     eax, [ebp+var_124]
.text:0000055B                 mov     [ebp+var_1F8], eax
.text:00000561                 mov     byte ptr [ebp+var_4], 9
.text:00000565                 lea     ecx, [ebp+var_11C] ; this
.text:0000056B                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00000570                 mov     byte ptr [ebp+var_4], 8
.text:00000574                 lea     ecx, [ebp+var_108] ; this
.text:0000057A                 call    ??1CItem@NTar@NArchive@@QAE@XZ ; NArchive::NTar::CItem::~CItem(void)
.text:0000057F                 mov     byte ptr [ebp+var_4], 6
.text:00000583                 lea     ecx, [ebp+var_80]
.text:00000586                 call    ??1?$CMyComPtr@VCLimitedSequentialInStream@@@@QAE@XZ ; CMyComPtr<CLimitedSequentialInStream>::~CMyComPtr<CLimitedSequentialInStream>(void)
.text:0000058B                 mov     byte ptr [ebp+var_4], 4
.text:0000058F                 lea     ecx, [ebp+var_70]
.text:00000592                 call    ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ ; CMyComPtr<ICompressProgressInfo>::~CMyComPtr<ICompressProgressInfo>(void)
.text:00000597                 mov     byte ptr [ebp+var_4], 2
.text:0000059B                 lea     ecx, [ebp+var_60]
.text:0000059E                 call    ??1?$CMyComPtr@UICompressCoder@@@@QAE@XZ ; CMyComPtr<ICompressCoder>::~CMyComPtr<ICompressCoder>(void)
.text:000005A3                 mov     byte ptr [ebp+var_4], 1
.text:000005A7                 lea     ecx, [ebp+var_3C]
.text:000005AA                 call    ??1?$CMyComPtr@UIArchiveUpdateCallbackFile@@@@QAE@XZ ; CMyComPtr<IArchiveUpdateCallbackFile>::~CMyComPtr<IArchiveUpdateCallbackFile>(void)
.text:000005AF                 mov     byte ptr [ebp+var_4], 0
.text:000005B3                 lea     ecx, [ebp+var_30]
.text:000005B6                 call    ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::~CMyComPtr<IOutStream>(void)
.text:000005BB                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000005C2                 lea     ecx, [ebp+var_24] ; this
.text:000005C5                 call    ??1COutArchive@NTar@NArchive@@QAE@XZ ; NArchive::NTar::COutArchive::~COutArchive(void)
.text:000005CA                 mov     eax, [ebp+var_1F8]
.text:000005D0                 jmp     loc_1978
.text:000005D5 ; ---------------------------------------------------------------------------
.text:000005D5
.text:000005D5 loc_5D5:                                ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+54Fj
.text:000005D5                 lea     ecx, [ebp+var_11C] ; this
.text:000005DB                 call    ?IsEmpty@AString@@QBE_NXZ ; AString::IsEmpty(void)
.text:000005E0                 movzx   ecx, al
.text:000005E3                 test    ecx, ecx
.text:000005E5                 jnz     short loc_600
.text:000005E7                 mov     [ebp+var_A0], 32h ; '2'
.text:000005EE                 lea     edx, [ebp+var_11C]
.text:000005F4                 push    edx
.text:000005F5                 lea     ecx, [ebp+var_CC]
.text:000005FB                 call    ??4AString@@QAEAAV0@ABV0@@Z ; AString::operator=(AString const &)
.text:00000600
.text:00000600 loc_600:                                ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+51Aj
.text:00000600                                         ; NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+5E5j
.text:00000600                 mov     eax, [ebp+var_8C]
.text:00000606                 movzx   ecx, byte ptr [eax+1Ch]
.text:0000060A                 test    ecx, ecx
.text:0000060C                 jz      loc_119B
.text:00000612                 lea     ecx, [ebp+var_9C]
.text:00000618                 call    ?Clear@?$CRecordVector@UCSparseBlock@NTar@NArchive@@@@QAEXXZ ; CRecordVector<NArchive::NTar::CSparseBlock>::Clear(void)
.text:0000061D                 mov     edx, [ebp+var_8C]
.text:00000623                 mov     eax, [edx+10h]
.text:00000626                 mov     dword ptr [ebp+var_F8], eax
.text:0000062C                 mov     ecx, [edx+14h]
.text:0000062F                 mov     dword ptr [ebp+var_F8+4], ecx
.text:00000635                 mov     edx, [ebp+var_8C]
.text:0000063B                 mov     eax, [edx+10h]
.text:0000063E                 mov     [ebp+var_F0], eax
.text:00000644                 mov     ecx, [edx+14h]
.text:00000647                 mov     [ebp+var_EC], ecx
.text:0000064D                 mov     edx, [ebp+var_8C]
.text:00000653                 mov     [ebp+var_258], edx
.text:00000659                 mov     eax, [ebp+var_258]
.text:0000065F                 mov     ecx, [ebp+var_258]
.text:00000665                 mov     edx, [eax+10h]
.text:00000668                 and     edx, [ecx+14h]
.text:0000066B                 cmp     edx, 0FFFFFFFFh
.text:0000066E                 jnz     short loc_6EE
.text:00000670                 mov     [ebp+var_1FC], 80070057h
.text:0000067A                 mov     byte ptr [ebp+var_4], 9
.text:0000067E                 lea     ecx, [ebp+var_11C] ; this
.text:00000684                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00000689                 mov     byte ptr [ebp+var_4], 8
.text:0000068D                 lea     ecx, [ebp+var_108] ; this
.text:00000693                 call    ??1CItem@NTar@NArchive@@QAE@XZ ; NArchive::NTar::CItem::~CItem(void)
.text:00000698                 mov     byte ptr [ebp+var_4], 6
.text:0000069C                 lea     ecx, [ebp+var_80]
.text:0000069F                 call    ??1?$CMyComPtr@VCLimitedSequentialInStream@@@@QAE@XZ ; CMyComPtr<CLimitedSequentialInStream>::~CMyComPtr<CLimitedSequentialInStream>(void)
.text:000006A4                 mov     byte ptr [ebp+var_4], 4
.text:000006A8                 lea     ecx, [ebp+var_70]
.text:000006AB                 call    ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ ; CMyComPtr<ICompressProgressInfo>::~CMyComPtr<ICompressProgressInfo>(void)
.text:000006B0                 mov     byte ptr [ebp+var_4], 2
.text:000006B4                 lea     ecx, [ebp+var_60]
.text:000006B7                 call    ??1?$CMyComPtr@UICompressCoder@@@@QAE@XZ ; CMyComPtr<ICompressCoder>::~CMyComPtr<ICompressCoder>(void)
.text:000006BC                 mov     byte ptr [ebp+var_4], 1
.text:000006C0                 lea     ecx, [ebp+var_3C]
.text:000006C3                 call    ??1?$CMyComPtr@UIArchiveUpdateCallbackFile@@@@QAE@XZ ; CMyComPtr<IArchiveUpdateCallbackFile>::~CMyComPtr<IArchiveUpdateCallbackFile>(void)
.text:000006C8                 mov     byte ptr [ebp+var_4], 0
.text:000006CC                 lea     ecx, [ebp+var_30]
.text:000006CF                 call    ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::~CMyComPtr<IOutStream>(void)
.text:000006D4                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000006DB                 lea     ecx, [ebp+var_24] ; this
.text:000006DE                 call    ??1COutArchive@NTar@NArchive@@QAE@XZ ; NArchive::NTar::COutArchive::~COutArchive(void)
.text:000006E3                 mov     eax, [ebp+var_1FC]
.text:000006E9                 jmp     loc_1978
.text:000006EE ; ---------------------------------------------------------------------------
.text:000006EE
.text:000006EE loc_6EE:                                ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+66Ej
.text:000006EE                 lea     ecx, [ebp+var_12C]
.text:000006F4                 call    ??0?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::CMyComPtr<ISequentialInStream>(void)
.text:000006F9                 mov     byte ptr [ebp+var_4], 0Bh
.text:000006FD                 mov     [ebp+var_131], 1
.text:00000704                 lea     ecx, [ebp+var_11C] ; this
.text:0000070A                 call    ?IsEmpty@AString@@QBE_NXZ ; AString::IsEmpty(void)
.text:0000070F                 movzx   eax, al
.text:00000712                 test    eax, eax
.text:00000714                 jnz     short loc_743
.text:00000716                 mov     dword ptr [ebp+var_F8], 0
.text:00000720                 mov     dword ptr [ebp+var_F8+4], 0
.text:0000072A                 mov     [ebp+var_F0], 0
.text:00000734                 mov     [ebp+var_EC], 0
.text:0000073E                 jmp     loc_A76
.text:00000743 ; ---------------------------------------------------------------------------
.text:00000743
.text:00000743 loc_743:                                ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+714j
.text:00000743                 lea     ecx, [ebp+var_12C]
.text:00000749                 call    ??I?$CMyComPtr@UISequentialInStream@@@@QAEPAPAUISequentialInStream@@XZ ; CMyComPtr<ISequentialInStream>::operator&(void)
.text:0000074E                 mov     esi, esp
.text:00000750                 push    eax
.text:00000751                 mov     ecx, [ebp+var_8C]
.text:00000757                 mov     edx, [ecx+4]
.text:0000075A                 push    edx
.text:0000075B                 mov     eax, [ebp+arg_14]
.text:0000075E                 mov     ecx, [eax]
.text:00000760                 mov     edx, [ebp+arg_14]
.text:00000763                 push    edx
.text:00000764                 mov     eax, [ecx+1Ch]
.text:00000767                 call    eax
.text:00000769                 cmp     esi, esp
.text:0000076B                 call    __RTC_CheckEsp
.text:00000770                 mov     [ebp+var_138], eax
.text:00000776                 cmp     [ebp+var_138], 1
.text:0000077D                 jnz     short loc_78B
.text:0000077F                 mov     [ebp+var_131], 0
.text:00000786                 jmp     loc_A76
.text:0000078B ; ---------------------------------------------------------------------------
.text:0000078B
.text:0000078B loc_78B:                                ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+77Dj
.text:0000078B                 mov     ecx, [ebp+var_138]
.text:00000791                 mov     [ebp+var_13C], ecx
.text:00000797                 cmp     [ebp+var_13C], 0
.text:0000079E                 jz      loc_833
.text:000007A4                 mov     edx, [ebp+var_13C]
.text:000007AA                 mov     [ebp+var_200], edx
.text:000007B0                 mov     byte ptr [ebp+var_4], 0Ah
.text:000007B4                 lea     ecx, [ebp+var_12C]
.text:000007BA                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:000007BF                 mov     byte ptr [ebp+var_4], 9
.text:000007C3                 lea     ecx, [ebp+var_11C] ; this
.text:000007C9                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:000007CE                 mov     byte ptr [ebp+var_4], 8
.text:000007D2                 lea     ecx, [ebp+var_108] ; this
.text:000007D8                 call    ??1CItem@NTar@NArchive@@QAE@XZ ; NArchive::NTar::CItem::~CItem(void)
.text:000007DD                 mov     byte ptr [ebp+var_4], 6
.text:000007E1                 lea     ecx, [ebp+var_80]
.text:000007E4                 call    ??1?$CMyComPtr@VCLimitedSequentialInStream@@@@QAE@XZ ; CMyComPtr<CLimitedSequentialInStream>::~CMyComPtr<CLimitedSequentialInStream>(void)
.text:000007E9                 mov     byte ptr [ebp+var_4], 4
.text:000007ED                 lea     ecx, [ebp+var_70]
.text:000007F0                 call    ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ ; CMyComPtr<ICompressProgressInfo>::~CMyComPtr<ICompressProgressInfo>(void)
.text:000007F5                 mov     byte ptr [ebp+var_4], 2
.text:000007F9                 lea     ecx, [ebp+var_60]
.text:000007FC                 call    ??1?$CMyComPtr@UICompressCoder@@@@QAE@XZ ; CMyComPtr<ICompressCoder>::~CMyComPtr<ICompressCoder>(void)
.text:00000801                 mov     byte ptr [ebp+var_4], 1
.text:00000805                 lea     ecx, [ebp+var_3C]
.text:00000808                 call    ??1?$CMyComPtr@UIArchiveUpdateCallbackFile@@@@QAE@XZ ; CMyComPtr<IArchiveUpdateCallbackFile>::~CMyComPtr<IArchiveUpdateCallbackFile>(void)
.text:0000080D                 mov     byte ptr [ebp+var_4], 0
.text:00000811                 lea     ecx, [ebp+var_30]
.text:00000814                 call    ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::~CMyComPtr<IOutStream>(void)
.text:00000819                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000820                 lea     ecx, [ebp+var_24] ; this
.text:00000823                 call    ??1COutArchive@NTar@NArchive@@QAE@XZ ; NArchive::NTar::COutArchive::~COutArchive(void)
.text:00000828                 mov     eax, [ebp+var_200]
.text:0000082E                 jmp     loc_1978
.text:00000833 ; ---------------------------------------------------------------------------
.text:00000833
.text:00000833 loc_833:                                ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+79Ej
.text:00000833                 lea     ecx, [ebp+var_12C]
.text:00000839                 call    ??B?$CMyComPtr@UISequentialInStream@@@@QBEPAUISequentialInStream@@XZ ; CMyComPtr<ISequentialInStream>::operator ISequentialInStream *(void)
.text:0000083E                 test    eax, eax
.text:00000840                 jz      loc_927
.text:00000846                 lea     ecx, [ebp+var_144]
.text:0000084C                 call    ??0?$CMyComPtr@UIStreamGetProps@@@@QAE@XZ ; CMyComPtr<IStreamGetProps>::CMyComPtr<IStreamGetProps>(void)
.text:00000851                 mov     byte ptr [ebp+var_4], 0Ch
.text:00000855                 lea     ecx, [ebp+var_12C]
.text:0000085B                 call    ??C?$CMyComPtr@UISequentialInStream@@@@QBEPAUISequentialInStream@@XZ ; CMyComPtr<ISequentialInStream>::operator->(void)
.text:00000860                 mov     [ebp+var_25C], eax
.text:00000866                 lea     ecx, [ebp+var_144]
.text:0000086C                 call    ??I?$CMyComPtr@UIStreamGetProps@@@@QAEPAPAUIStreamGetProps@@XZ ; CMyComPtr<IStreamGetProps>::operator&(void)
.text:00000871                 mov     esi, esp
.text:00000873                 push    eax
.text:00000874                 push    offset _IID_IStreamGetProps
.text:00000879                 mov     eax, [ebp+var_25C]
.text:0000087F                 push    eax
.text:00000880                 mov     ecx, [ebp+var_25C]
.text:00000886                 mov     edx, [ecx]
.text:00000888                 mov     eax, [edx]
.text:0000088A                 call    eax
.text:0000088C                 cmp     esi, esp
.text:0000088E                 call    __RTC_CheckEsp
.text:00000893                 lea     ecx, [ebp+var_144]
.text:00000899                 call    ??B?$CMyComPtr@UIStreamGetProps@@@@QBEPAUIStreamGetProps@@XZ ; CMyComPtr<IStreamGetProps>::operator IStreamGetProps *(void)
.text:0000089E                 test    eax, eax
.text:000008A0                 jz      short loc_918
.text:000008A2                 lea     ecx, [ebp+var_144]
.text:000008A8                 call    ??C?$CMyComPtr@UIStreamGetProps@@@@QBEPAUIStreamGetProps@@XZ ; CMyComPtr<IStreamGetProps>::operator->(void)
.text:000008AD                 mov     [ebp+var_260], eax
.text:000008B3                 mov     esi, esp
.text:000008B5                 push    0
.text:000008B7                 lea     ecx, [ebp+var_154]
.text:000008BD                 push    ecx
.text:000008BE                 push    0
.text:000008C0                 push    0
.text:000008C2                 lea     edx, [ebp+var_164]
.text:000008C8                 push    edx
.text:000008C9                 mov     eax, [ebp+var_260]
.text:000008CF                 push    eax
.text:000008D0                 mov     ecx, [ebp+var_260]
.text:000008D6                 mov     edx, [ecx]
.text:000008D8                 mov     eax, [edx+0Ch]
.text:000008DB                 call    eax
.text:000008DD                 cmp     esi, esp
.text:000008DF                 call    __RTC_CheckEsp
.text:000008E4                 test    eax, eax
.text:000008E6                 jnz     short loc_918
.text:000008E8                 mov     ecx, [ebp+var_164]
.text:000008EE                 mov     dword ptr [ebp+var_F8], ecx
.text:000008F4                 mov     edx, [ebp+var_160]
.text:000008FA                 mov     dword ptr [ebp+var_F8+4], edx
.text:00000900                 lea     eax, [ebp+var_154]
.text:00000906                 push    eax             ; bool
.text:00000907                 call    ?FileTimeToUnixTime64@NTime@NWindows@@YG_JABU_FILETIME@@@Z ; NWindows::NTime::FileTimeToUnixTime64(_FILETIME const &)
.text:0000090C                 mov     [ebp+var_E8], eax
.text:00000912                 mov     [ebp+var_E4], edx
.text:00000918
.text:00000918 loc_918:                                ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+8A0j
.text:00000918                                         ; NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+8E6j
.text:00000918                 mov     byte ptr [ebp+var_4], 0Bh
.text:0000091C                 lea     ecx, [ebp+var_144]
.text:00000922                 call    ??1?$CMyComPtr@UIStreamGetProps@@@@QAE@XZ ; CMyComPtr<IStreamGetProps>::~CMyComPtr<IStreamGetProps>(void)
.text:00000927
.text:00000927 loc_927:                                ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+840j
.text:00000927                 lea     ecx, [ebp+var_178]
.text:0000092D                 call    ??0AString@@QAE@XZ ; AString::AString(void)
.text:00000932                 mov     byte ptr [ebp+var_4], 0Dh
.text:00000936                 push    1               ; unsigned int
.text:00000938                 mov     ecx, [ebp+arg_10]
.text:0000093B                 push    ecx             ; struct AString *
.text:0000093C                 lea     edx, [ebp+var_178]
.text:00000942                 push    edx             ; unsigned __int32
.text:00000943                 push    5Ah ; 'Z'       ; unsigned int
.text:00000945                 mov     eax, [ebp+var_8C]
.text:0000094B                 mov     ecx, [eax+4]
.text:0000094E                 push    ecx             ; struct IArchiveUpdateCallback *
.text:0000094F                 mov     edx, [ebp+arg_14]
.text:00000952                 push    edx             ; this
.text:00000953                 call    ?GetPropString@NTar@NArchive@@YGJPAUIArchiveUpdateCallback@@IKAAVAString@@I_N@Z ; NArchive::NTar::GetPropString(IArchiveUpdateCallback *,uint,ulong,AString &,uint,bool)
.text:00000958                 mov     [ebp+var_180], eax
.text:0000095E                 cmp     [ebp+var_180], 0
.text:00000965                 jz      loc_A09
.text:0000096B                 mov     eax, [ebp+var_180]
.text:00000971                 mov     [ebp+var_204], eax
.text:00000977                 mov     byte ptr [ebp+var_4], 0Bh
.text:0000097B                 lea     ecx, [ebp+var_178] ; this
.text:00000981                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00000986                 mov     byte ptr [ebp+var_4], 0Ah
.text:0000098A                 lea     ecx, [ebp+var_12C]
.text:00000990                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:00000995                 mov     byte ptr [ebp+var_4], 9
.text:00000999                 lea     ecx, [ebp+var_11C] ; this
.text:0000099F                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:000009A4                 mov     byte ptr [ebp+var_4], 8
.text:000009A8                 lea     ecx, [ebp+var_108] ; this
.text:000009AE                 call    ??1CItem@NTar@NArchive@@QAE@XZ ; NArchive::NTar::CItem::~CItem(void)
.text:000009B3                 mov     byte ptr [ebp+var_4], 6
.text:000009B7                 lea     ecx, [ebp+var_80]
.text:000009BA                 call    ??1?$CMyComPtr@VCLimitedSequentialInStream@@@@QAE@XZ ; CMyComPtr<CLimitedSequentialInStream>::~CMyComPtr<CLimitedSequentialInStream>(void)
.text:000009BF                 mov     byte ptr [ebp+var_4], 4
.text:000009C3                 lea     ecx, [ebp+var_70]
.text:000009C6                 call    ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ ; CMyComPtr<ICompressProgressInfo>::~CMyComPtr<ICompressProgressInfo>(void)
.text:000009CB                 mov     byte ptr [ebp+var_4], 2
.text:000009CF                 lea     ecx, [ebp+var_60]
.text:000009D2                 call    ??1?$CMyComPtr@UICompressCoder@@@@QAE@XZ ; CMyComPtr<ICompressCoder>::~CMyComPtr<ICompressCoder>(void)
.text:000009D7                 mov     byte ptr [ebp+var_4], 1
.text:000009DB                 lea     ecx, [ebp+var_3C]
.text:000009DE                 call    ??1?$CMyComPtr@UIArchiveUpdateCallbackFile@@@@QAE@XZ ; CMyComPtr<IArchiveUpdateCallbackFile>::~CMyComPtr<IArchiveUpdateCallbackFile>(void)
.text:000009E3                 mov     byte ptr [ebp+var_4], 0
.text:000009E7                 lea     ecx, [ebp+var_30]
.text:000009EA                 call    ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::~CMyComPtr<IOutStream>(void)
.text:000009EF                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000009F6                 lea     ecx, [ebp+var_24] ; this
.text:000009F9                 call    ??1COutArchive@NTar@NArchive@@QAE@XZ ; NArchive::NTar::COutArchive::~COutArchive(void)
.text:000009FE                 mov     eax, [ebp+var_204]
.text:00000A04                 jmp     loc_1978
.text:00000A09 ; ---------------------------------------------------------------------------
.text:00000A09
.text:00000A09 loc_A09:                                ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+965j
.text:00000A09                 lea     ecx, [ebp+var_178] ; this
.text:00000A0F                 call    ?IsEmpty@AString@@QBE_NXZ ; AString::IsEmpty(void)
.text:00000A14                 movzx   ecx, al
.text:00000A17                 test    ecx, ecx
.text:00000A19                 jnz     short loc_A67
.text:00000A1B                 mov     [ebp+var_A0], 31h ; '1'
.text:00000A22                 lea     edx, [ebp+var_178]
.text:00000A28                 push    edx
.text:00000A29                 lea     ecx, [ebp+var_CC]
.text:00000A2F                 call    ??4AString@@QAEAAV0@ABV0@@Z ; AString::operator=(AString const &)
.text:00000A34                 mov     dword ptr [ebp+var_F8], 0
.text:00000A3E                 mov     dword ptr [ebp+var_F8+4], 0
.text:00000A48                 mov     [ebp+var_F0], 0
.text:00000A52                 mov     [ebp+var_EC], 0
.text:00000A5C                 lea     ecx, [ebp+var_12C]
.text:00000A62                 call    ?Release@?$CMyComPtr@UISequentialInStream@@@@QAEXXZ ; CMyComPtr<ISequentialInStream>::Release(void)
.text:00000A67
.text:00000A67 loc_A67:                                ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+A19j
.text:00000A67                 mov     byte ptr [ebp+var_4], 0Bh
.text:00000A6B                 lea     ecx, [ebp+var_178] ; this
.text:00000A71                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00000A76
.text:00000A76 loc_A76:                                ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+73Ej
.text:00000A76                                         ; NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+786j
.text:00000A76                 movzx   eax, [ebp+var_131]
.text:00000A7D                 test    eax, eax
.text:00000A7F                 jz      loc_10B4
.text:00000A85                 mov     ecx, [ebp+var_1C]
.text:00000A88                 mov     [ebp+var_188], ecx
.text:00000A8E                 mov     edx, [ebp+var_18]
.text:00000A91                 mov     [ebp+var_184], edx
.text:00000A97                 lea     eax, [ebp+var_108]
.text:00000A9D                 push    eax             ; struct NArchive::NTar::CItem *
.text:00000A9E                 lea     ecx, [ebp+var_24] ; this
.text:00000AA1                 call    ?WriteHeader@COutArchive@NTar@NArchive@@QAEJABUCItem@23@@Z ; NArchive::NTar::COutArchive::WriteHeader(NArchive::NTar::CItem const &)
.text:00000AA6                 mov     [ebp+var_18C], eax
.text:00000AAC                 cmp     [ebp+var_18C], 0
.text:00000AB3                 jz      loc_B48
.text:00000AB9                 mov     ecx, [ebp+var_18C]
.text:00000ABF                 mov     [ebp+var_208], ecx
.text:00000AC5                 mov     byte ptr [ebp+var_4], 0Ah
.text:00000AC9                 lea     ecx, [ebp+var_12C]
.text:00000ACF                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:00000AD4                 mov     byte ptr [ebp+var_4], 9
.text:00000AD8                 lea     ecx, [ebp+var_11C] ; this
.text:00000ADE                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00000AE3                 mov     byte ptr [ebp+var_4], 8
.text:00000AE7                 lea     ecx, [ebp+var_108] ; this
.text:00000AED                 call    ??1CItem@NTar@NArchive@@QAE@XZ ; NArchive::NTar::CItem::~CItem(void)
.text:00000AF2                 mov     byte ptr [ebp+var_4], 6
.text:00000AF6                 lea     ecx, [ebp+var_80]
.text:00000AF9                 call    ??1?$CMyComPtr@VCLimitedSequentialInStream@@@@QAE@XZ ; CMyComPtr<CLimitedSequentialInStream>::~CMyComPtr<CLimitedSequentialInStream>(void)
.text:00000AFE                 mov     byte ptr [ebp+var_4], 4
.text:00000B02                 lea     ecx, [ebp+var_70]
.text:00000B05                 call    ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ ; CMyComPtr<ICompressProgressInfo>::~CMyComPtr<ICompressProgressInfo>(void)
.text:00000B0A                 mov     byte ptr [ebp+var_4], 2
.text:00000B0E                 lea     ecx, [ebp+var_60]
.text:00000B11                 call    ??1?$CMyComPtr@UICompressCoder@@@@QAE@XZ ; CMyComPtr<ICompressCoder>::~CMyComPtr<ICompressCoder>(void)
.text:00000B16                 mov     byte ptr [ebp+var_4], 1
.text:00000B1A                 lea     ecx, [ebp+var_3C]
.text:00000B1D                 call    ??1?$CMyComPtr@UIArchiveUpdateCallbackFile@@@@QAE@XZ ; CMyComPtr<IArchiveUpdateCallbackFile>::~CMyComPtr<IArchiveUpdateCallbackFile>(void)
.text:00000B22                 mov     byte ptr [ebp+var_4], 0
.text:00000B26                 lea     ecx, [ebp+var_30]
.text:00000B29                 call    ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::~CMyComPtr<IOutStream>(void)
.text:00000B2E                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000B35                 lea     ecx, [ebp+var_24] ; this
.text:00000B38                 call    ??1COutArchive@NTar@NArchive@@QAE@XZ ; NArchive::NTar::COutArchive::~COutArchive(void)
.text:00000B3D                 mov     eax, [ebp+var_208]
.text:00000B43                 jmp     loc_1978
.text:00000B48 ; ---------------------------------------------------------------------------
.text:00000B48
.text:00000B48 loc_B48:                                ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+AB3j
.text:00000B48                 lea     ecx, [ebp+var_12C]
.text:00000B4E                 call    ??B?$CMyComPtr@UISequentialInStream@@@@QBEPAUISequentialInStream@@XZ ; CMyComPtr<ISequentialInStream>::operator ISequentialInStream *(void)
.text:00000B53                 test    eax, eax
.text:00000B55                 jz      loc_10B4
.text:00000B5B                 lea     ecx, [ebp+var_60]
.text:00000B5E                 call    ??C?$CMyComPtr@UICompressCoder@@@@QBEPAUICompressCoder@@XZ ; CMyComPtr<ICompressCoder>::operator->(void)
.text:00000B63                 mov     [ebp+var_264], eax
.text:00000B69                 lea     ecx, [ebp+var_70]
.text:00000B6C                 call    ??B?$CMyComPtr@UICompressProgressInfo@@@@QBEPAUICompressProgressInfo@@XZ ; CMyComPtr<ICompressProgressInfo>::operator ICompressProgressInfo *(void)
.text:00000B71                 mov     esi, esp
.text:00000B73                 push    eax
.text:00000B74                 push    0
.text:00000B76                 push    0
.text:00000B78                 mov     edx, [ebp+arg_4]
.text:00000B7B                 push    edx
.text:00000B7C                 lea     ecx, [ebp+var_12C]
.text:00000B82                 call    ??B?$CMyComPtr@UISequentialInStream@@@@QBEPAUISequentialInStream@@XZ ; CMyComPtr<ISequentialInStream>::operator ISequentialInStream *(void)
.text:00000B87                 push    eax
.text:00000B88                 mov     eax, [ebp+var_264]
.text:00000B8E                 push    eax
.text:00000B8F                 mov     ecx, [ebp+var_264]
.text:00000B95                 mov     edx, [ecx]
.text:00000B97                 mov     eax, [edx+0Ch]
.text:00000B9A                 call    eax
.text:00000B9C                 cmp     esi, esp
.text:00000B9E                 call    __RTC_CheckEsp
.text:00000BA3                 mov     [ebp+var_190], eax
.text:00000BA9                 cmp     [ebp+var_190], 0
.text:00000BB0                 jz      loc_C45
.text:00000BB6                 mov     ecx, [ebp+var_190]
.text:00000BBC                 mov     [ebp+var_20C], ecx
.text:00000BC2                 mov     byte ptr [ebp+var_4], 0Ah
.text:00000BC6                 lea     ecx, [ebp+var_12C]
.text:00000BCC                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:00000BD1                 mov     byte ptr [ebp+var_4], 9
.text:00000BD5                 lea     ecx, [ebp+var_11C] ; this
.text:00000BDB                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00000BE0                 mov     byte ptr [ebp+var_4], 8
.text:00000BE4                 lea     ecx, [ebp+var_108] ; this
.text:00000BEA                 call    ??1CItem@NTar@NArchive@@QAE@XZ ; NArchive::NTar::CItem::~CItem(void)
.text:00000BEF                 mov     byte ptr [ebp+var_4], 6
.text:00000BF3                 lea     ecx, [ebp+var_80]
.text:00000BF6                 call    ??1?$CMyComPtr@VCLimitedSequentialInStream@@@@QAE@XZ ; CMyComPtr<CLimitedSequentialInStream>::~CMyComPtr<CLimitedSequentialInStream>(void)
.text:00000BFB                 mov     byte ptr [ebp+var_4], 4
.text:00000BFF                 lea     ecx, [ebp+var_70]
.text:00000C02                 call    ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ ; CMyComPtr<ICompressProgressInfo>::~CMyComPtr<ICompressProgressInfo>(void)
.text:00000C07                 mov     byte ptr [ebp+var_4], 2
.text:00000C0B                 lea     ecx, [ebp+var_60]
.text:00000C0E                 call    ??1?$CMyComPtr@UICompressCoder@@@@QAE@XZ ; CMyComPtr<ICompressCoder>::~CMyComPtr<ICompressCoder>(void)
.text:00000C13                 mov     byte ptr [ebp+var_4], 1
.text:00000C17                 lea     ecx, [ebp+var_3C]
.text:00000C1A                 call    ??1?$CMyComPtr@UIArchiveUpdateCallbackFile@@@@QAE@XZ ; CMyComPtr<IArchiveUpdateCallbackFile>::~CMyComPtr<IArchiveUpdateCallbackFile>(void)
.text:00000C1F                 mov     byte ptr [ebp+var_4], 0
.text:00000C23                 lea     ecx, [ebp+var_30]
.text:00000C26                 call    ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::~CMyComPtr<IOutStream>(void)
.text:00000C2B                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000C32                 lea     ecx, [ebp+var_24] ; this
.text:00000C35                 call    ??1COutArchive@NTar@NArchive@@QAE@XZ ; NArchive::NTar::COutArchive::~COutArchive(void)
.text:00000C3A                 mov     eax, [ebp+var_20C]
.text:00000C40                 jmp     loc_1978
.text:00000C45 ; ---------------------------------------------------------------------------
.text:00000C45
.text:00000C45 loc_C45:                                ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+BB0j
.text:00000C45                 mov     edx, [ebp+var_58]
.text:00000C48                 mov     eax, [ebp+var_1C]
.text:00000C4B                 add     eax, [edx+20h]
.text:00000C4E                 mov     ecx, [ebp+var_18]
.text:00000C51                 adc     ecx, [edx+24h]
.text:00000C54                 mov     [ebp+var_1C], eax
.text:00000C57                 mov     [ebp+var_18], ecx
.text:00000C5A                 mov     edx, [ebp+var_58]
.text:00000C5D                 mov     [ebp+var_268], edx
.text:00000C63                 mov     eax, [ebp+var_268]
.text:00000C69                 mov     ecx, [eax+20h]
.text:00000C6C                 cmp     ecx, dword ptr [ebp+var_F8]
.text:00000C72                 jnz     short loc_C89
.text:00000C74                 mov     edx, [ebp+var_268]
.text:00000C7A                 mov     eax, [edx+24h]
.text:00000C7D                 cmp     eax, dword ptr [ebp+var_F8+4]
.text:00000C83                 jz      loc_FFC
.text:00000C89
.text:00000C89 loc_C89:                                ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+C72j
.text:00000C89                 lea     ecx, [ebp+var_30]
.text:00000C8C                 call    ??7?$CMyComPtr@UIOutStream@@@@QBE_NXZ ; CMyComPtr<IOutStream>::operator!(void)
.text:00000C91                 movzx   ecx, al
.text:00000C94                 test    ecx, ecx
.text:00000C96                 jz      loc_D29
.text:00000C9C                 mov     [ebp+var_210], 80004005h
.text:00000CA6                 mov     byte ptr [ebp+var_4], 0Ah
.text:00000CAA                 lea     ecx, [ebp+var_12C]
.text:00000CB0                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:00000CB5                 mov     byte ptr [ebp+var_4], 9
.text:00000CB9                 lea     ecx, [ebp+var_11C] ; this
.text:00000CBF                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00000CC4                 mov     byte ptr [ebp+var_4], 8
.text:00000CC8                 lea     ecx, [ebp+var_108] ; this
.text:00000CCE                 call    ??1CItem@NTar@NArchive@@QAE@XZ ; NArchive::NTar::CItem::~CItem(void)
.text:00000CD3                 mov     byte ptr [ebp+var_4], 6
.text:00000CD7                 lea     ecx, [ebp+var_80]
.text:00000CDA                 call    ??1?$CMyComPtr@VCLimitedSequentialInStream@@@@QAE@XZ ; CMyComPtr<CLimitedSequentialInStream>::~CMyComPtr<CLimitedSequentialInStream>(void)
.text:00000CDF                 mov     byte ptr [ebp+var_4], 4
.text:00000CE3                 lea     ecx, [ebp+var_70]
.text:00000CE6                 call    ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ ; CMyComPtr<ICompressProgressInfo>::~CMyComPtr<ICompressProgressInfo>(void)
.text:00000CEB                 mov     byte ptr [ebp+var_4], 2
.text:00000CEF                 lea     ecx, [ebp+var_60]
.text:00000CF2                 call    ??1?$CMyComPtr@UICompressCoder@@@@QAE@XZ ; CMyComPtr<ICompressCoder>::~CMyComPtr<ICompressCoder>(void)
.text:00000CF7                 mov     byte ptr [ebp+var_4], 1
.text:00000CFB                 lea     ecx, [ebp+var_3C]
.text:00000CFE                 call    ??1?$CMyComPtr@UIArchiveUpdateCallbackFile@@@@QAE@XZ ; CMyComPtr<IArchiveUpdateCallbackFile>::~CMyComPtr<IArchiveUpdateCallbackFile>(void)
.text:00000D03                 mov     byte ptr [ebp+var_4], 0
.text:00000D07                 lea     ecx, [ebp+var_30]
.text:00000D0A                 call    ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::~CMyComPtr<IOutStream>(void)
.text:00000D0F                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000D16                 lea     ecx, [ebp+var_24] ; this
.text:00000D19                 call    ??1COutArchive@NTar@NArchive@@QAE@XZ ; NArchive::NTar::COutArchive::~COutArchive(void)
.text:00000D1E                 mov     eax, [ebp+var_210]
.text:00000D24                 jmp     loc_1978
.text:00000D29 ; ---------------------------------------------------------------------------
.text:00000D29
.text:00000D29 loc_D29:                                ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+C96j
.text:00000D29                 mov     edx, [ebp+var_1C]
.text:00000D2C                 sub     edx, [ebp+var_188]
.text:00000D32                 mov     eax, [ebp+var_18]
.text:00000D35                 sbb     eax, [ebp+var_184]
.text:00000D3B                 mov     [ebp+var_198], edx
.text:00000D41                 mov     [ebp+var_194], eax
.text:00000D47                 lea     ecx, [ebp+var_30]
.text:00000D4A                 call    ??C?$CMyComPtr@UIOutStream@@@@QBEPAUIOutStream@@XZ ; CMyComPtr<IOutStream>::operator->(void)
.text:00000D4F                 mov     [ebp+var_26C], eax
.text:00000D55                 mov     esi, esp
.text:00000D57                 push    0
.text:00000D59                 push    1
.text:00000D5B                 mov     ecx, [ebp+var_198]
.text:00000D61                 neg     ecx
.text:00000D63                 mov     edx, [ebp+var_194]
.text:00000D69                 adc     edx, 0
.text:00000D6C                 neg     edx
.text:00000D6E                 push    edx
.text:00000D6F                 push    ecx
.text:00000D70                 mov     eax, [ebp+var_26C]
.text:00000D76                 push    eax
.text:00000D77                 mov     ecx, [ebp+var_26C]
.text:00000D7D                 mov     edx, [ecx]
.text:00000D7F                 mov     eax, [edx+10h]
.text:00000D82                 call    eax
.text:00000D84                 cmp     esi, esp
.text:00000D86                 call    __RTC_CheckEsp
.text:00000D8B                 mov     [ebp+var_19C], eax
.text:00000D91                 cmp     [ebp+var_19C], 0
.text:00000D98                 jz      loc_E2D
.text:00000D9E                 mov     ecx, [ebp+var_19C]
.text:00000DA4                 mov     [ebp+var_214], ecx
.text:00000DAA                 mov     byte ptr [ebp+var_4], 0Ah
.text:00000DAE                 lea     ecx, [ebp+var_12C]
.text:00000DB4                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:00000DB9                 mov     byte ptr [ebp+var_4], 9
.text:00000DBD                 lea     ecx, [ebp+var_11C] ; this
.text:00000DC3                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00000DC8                 mov     byte ptr [ebp+var_4], 8
.text:00000DCC                 lea     ecx, [ebp+var_108] ; this
.text:00000DD2                 call    ??1CItem@NTar@NArchive@@QAE@XZ ; NArchive::NTar::CItem::~CItem(void)
.text:00000DD7                 mov     byte ptr [ebp+var_4], 6
.text:00000DDB                 lea     ecx, [ebp+var_80]
.text:00000DDE                 call    ??1?$CMyComPtr@VCLimitedSequentialInStream@@@@QAE@XZ ; CMyComPtr<CLimitedSequentialInStream>::~CMyComPtr<CLimitedSequentialInStream>(void)
.text:00000DE3                 mov     byte ptr [ebp+var_4], 4
.text:00000DE7                 lea     ecx, [ebp+var_70]
.text:00000DEA                 call    ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ ; CMyComPtr<ICompressProgressInfo>::~CMyComPtr<ICompressProgressInfo>(void)
.text:00000DEF                 mov     byte ptr [ebp+var_4], 2
.text:00000DF3                 lea     ecx, [ebp+var_60]
.text:00000DF6                 call    ??1?$CMyComPtr@UICompressCoder@@@@QAE@XZ ; CMyComPtr<ICompressCoder>::~CMyComPtr<ICompressCoder>(void)
.text:00000DFB                 mov     byte ptr [ebp+var_4], 1
.text:00000DFF                 lea     ecx, [ebp+var_3C]
.text:00000E02                 call    ??1?$CMyComPtr@UIArchiveUpdateCallbackFile@@@@QAE@XZ ; CMyComPtr<IArchiveUpdateCallbackFile>::~CMyComPtr<IArchiveUpdateCallbackFile>(void)
.text:00000E07                 mov     byte ptr [ebp+var_4], 0
.text:00000E0B                 lea     ecx, [ebp+var_30]
.text:00000E0E                 call    ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::~CMyComPtr<IOutStream>(void)
.text:00000E13                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000E1A                 lea     ecx, [ebp+var_24] ; this
.text:00000E1D                 call    ??1COutArchive@NTar@NArchive@@QAE@XZ ; NArchive::NTar::COutArchive::~COutArchive(void)
.text:00000E22                 mov     eax, [ebp+var_214]
.text:00000E28                 jmp     loc_1978
.text:00000E2D ; ---------------------------------------------------------------------------
.text:00000E2D
.text:00000E2D loc_E2D:                                ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+D98j
.text:00000E2D                 mov     edx, [ebp+var_188]
.text:00000E33                 mov     [ebp+var_1C], edx
.text:00000E36                 mov     eax, [ebp+var_184]
.text:00000E3C                 mov     [ebp+var_18], eax
.text:00000E3F                 mov     ecx, [ebp+var_58]
.text:00000E42                 mov     edx, [ecx+20h]
.text:00000E45                 mov     dword ptr [ebp+var_F8], edx
.text:00000E4B                 mov     eax, [ecx+24h]
.text:00000E4E                 mov     dword ptr [ebp+var_F8+4], eax
.text:00000E54                 lea     ecx, [ebp+var_108]
.text:00000E5A                 push    ecx             ; struct NArchive::NTar::CItem *
.text:00000E5B                 lea     ecx, [ebp+var_24] ; this
.text:00000E5E                 call    ?WriteHeader@COutArchive@NTar@NArchive@@QAEJABUCItem@23@@Z ; NArchive::NTar::COutArchive::WriteHeader(NArchive::NTar::CItem const &)
.text:00000E63                 mov     [ebp+var_1A0], eax
.text:00000E69                 cmp     [ebp+var_1A0], 0
.text:00000E70                 jz      loc_F05
.text:00000E76                 mov     edx, [ebp+var_1A0]
.text:00000E7C                 mov     [ebp+var_218], edx
.text:00000E82                 mov     byte ptr [ebp+var_4], 0Ah
.text:00000E86                 lea     ecx, [ebp+var_12C]
.text:00000E8C                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:00000E91                 mov     byte ptr [ebp+var_4], 9
.text:00000E95                 lea     ecx, [ebp+var_11C] ; this
.text:00000E9B                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00000EA0                 mov     byte ptr [ebp+var_4], 8
.text:00000EA4                 lea     ecx, [ebp+var_108] ; this
.text:00000EAA                 call    ??1CItem@NTar@NArchive@@QAE@XZ ; NArchive::NTar::CItem::~CItem(void)
.text:00000EAF                 mov     byte ptr [ebp+var_4], 6
.text:00000EB3                 lea     ecx, [ebp+var_80]
.text:00000EB6                 call    ??1?$CMyComPtr@VCLimitedSequentialInStream@@@@QAE@XZ ; CMyComPtr<CLimitedSequentialInStream>::~CMyComPtr<CLimitedSequentialInStream>(void)
.text:00000EBB                 mov     byte ptr [ebp+var_4], 4
.text:00000EBF                 lea     ecx, [ebp+var_70]
.text:00000EC2                 call    ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ ; CMyComPtr<ICompressProgressInfo>::~CMyComPtr<ICompressProgressInfo>(void)
.text:00000EC7                 mov     byte ptr [ebp+var_4], 2
.text:00000ECB                 lea     ecx, [ebp+var_60]
.text:00000ECE                 call    ??1?$CMyComPtr@UICompressCoder@@@@QAE@XZ ; CMyComPtr<ICompressCoder>::~CMyComPtr<ICompressCoder>(void)
.text:00000ED3                 mov     byte ptr [ebp+var_4], 1
.text:00000ED7                 lea     ecx, [ebp+var_3C]
.text:00000EDA                 call    ??1?$CMyComPtr@UIArchiveUpdateCallbackFile@@@@QAE@XZ ; CMyComPtr<IArchiveUpdateCallbackFile>::~CMyComPtr<IArchiveUpdateCallbackFile>(void)
.text:00000EDF                 mov     byte ptr [ebp+var_4], 0
.text:00000EE3                 lea     ecx, [ebp+var_30]
.text:00000EE6                 call    ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::~CMyComPtr<IOutStream>(void)
.text:00000EEB                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000EF2                 lea     ecx, [ebp+var_24] ; this
.text:00000EF5                 call    ??1COutArchive@NTar@NArchive@@QAE@XZ ; NArchive::NTar::COutArchive::~COutArchive(void)
.text:00000EFA                 mov     eax, [ebp+var_218]
.text:00000F00                 jmp     loc_1978
.text:00000F05 ; ---------------------------------------------------------------------------
.text:00000F05
.text:00000F05 loc_F05:                                ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+E70j
.text:00000F05                 lea     ecx, [ebp+var_30]
.text:00000F08                 call    ??C?$CMyComPtr@UIOutStream@@@@QBEPAUIOutStream@@XZ ; CMyComPtr<IOutStream>::operator->(void)
.text:00000F0D                 mov     [ebp+var_270], eax
.text:00000F13                 mov     esi, esp
.text:00000F15                 push    0
.text:00000F17                 push    1
.text:00000F19                 mov     eax, dword ptr [ebp+var_F8+4]
.text:00000F1F                 push    eax
.text:00000F20                 mov     ecx, dword ptr [ebp+var_F8]
.text:00000F26                 push    ecx
.text:00000F27                 mov     edx, [ebp+var_270]
.text:00000F2D                 push    edx
.text:00000F2E                 mov     eax, [ebp+var_270]
.text:00000F34                 mov     ecx, [eax]
.text:00000F36                 mov     edx, [ecx+10h]
.text:00000F39                 call    edx
.text:00000F3B                 cmp     esi, esp
.text:00000F3D                 call    __RTC_CheckEsp
.text:00000F42                 mov     [ebp+var_1A4], eax
.text:00000F48                 cmp     [ebp+var_1A4], 0
.text:00000F4F                 jz      loc_FE4
.text:00000F55                 mov     eax, [ebp+var_1A4]
.text:00000F5B                 mov     [ebp+var_21C], eax
.text:00000F61                 mov     byte ptr [ebp+var_4], 0Ah
.text:00000F65                 lea     ecx, [ebp+var_12C]
.text:00000F6B                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:00000F70                 mov     byte ptr [ebp+var_4], 9
.text:00000F74                 lea     ecx, [ebp+var_11C] ; this
.text:00000F7A                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00000F7F                 mov     byte ptr [ebp+var_4], 8
.text:00000F83                 lea     ecx, [ebp+var_108] ; this
.text:00000F89                 call    ??1CItem@NTar@NArchive@@QAE@XZ ; NArchive::NTar::CItem::~CItem(void)
.text:00000F8E                 mov     byte ptr [ebp+var_4], 6
.text:00000F92                 lea     ecx, [ebp+var_80]
.text:00000F95                 call    ??1?$CMyComPtr@VCLimitedSequentialInStream@@@@QAE@XZ ; CMyComPtr<CLimitedSequentialInStream>::~CMyComPtr<CLimitedSequentialInStream>(void)
.text:00000F9A                 mov     byte ptr [ebp+var_4], 4
.text:00000F9E                 lea     ecx, [ebp+var_70]
.text:00000FA1                 call    ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ ; CMyComPtr<ICompressProgressInfo>::~CMyComPtr<ICompressProgressInfo>(void)
.text:00000FA6                 mov     byte ptr [ebp+var_4], 2
.text:00000FAA                 lea     ecx, [ebp+var_60]
.text:00000FAD                 call    ??1?$CMyComPtr@UICompressCoder@@@@QAE@XZ ; CMyComPtr<ICompressCoder>::~CMyComPtr<ICompressCoder>(void)
.text:00000FB2                 mov     byte ptr [ebp+var_4], 1
.text:00000FB6                 lea     ecx, [ebp+var_3C]
.text:00000FB9                 call    ??1?$CMyComPtr@UIArchiveUpdateCallbackFile@@@@QAE@XZ ; CMyComPtr<IArchiveUpdateCallbackFile>::~CMyComPtr<IArchiveUpdateCallbackFile>(void)
.text:00000FBE                 mov     byte ptr [ebp+var_4], 0
.text:00000FC2                 lea     ecx, [ebp+var_30]
.text:00000FC5                 call    ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::~CMyComPtr<IOutStream>(void)
.text:00000FCA                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000FD1                 lea     ecx, [ebp+var_24] ; this
.text:00000FD4                 call    ??1COutArchive@NTar@NArchive@@QAE@XZ ; NArchive::NTar::COutArchive::~COutArchive(void)
.text:00000FD9                 mov     eax, [ebp+var_21C]
.text:00000FDF                 jmp     loc_1978
.text:00000FE4 ; ---------------------------------------------------------------------------
.text:00000FE4
.text:00000FE4 loc_FE4:                                ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+F4Fj
.text:00000FE4                 mov     ecx, [ebp+var_1C]
.text:00000FE7                 add     ecx, dword ptr [ebp+var_F8]
.text:00000FED                 mov     edx, [ebp+var_18]
.text:00000FF0                 adc     edx, dword ptr [ebp+var_F8+4]
.text:00000FF6                 mov     [ebp+var_1C], ecx
.text:00000FF9                 mov     [ebp+var_18], edx
.text:00000FFC
.text:00000FFC loc_FFC:                                ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+C83j
.text:00000FFC                 mov     eax, dword ptr [ebp+var_F8+4]
.text:00001002                 push    eax
.text:00001003                 mov     ecx, dword ptr [ebp+var_F8]
.text:00001009                 push    ecx             ; unsigned __int64
.text:0000100A                 lea     ecx, [ebp+var_24] ; this
.text:0000100D                 call    ?FillDataResidual@COutArchive@NTar@NArchive@@QAEJ_K@Z ; NArchive::NTar::COutArchive::FillDataResidual(unsigned __int64)
.text:00001012                 mov     [ebp+var_1A8], eax
.text:00001018                 cmp     [ebp+var_1A8], 0
.text:0000101F                 jz      loc_10B4
.text:00001025                 mov     edx, [ebp+var_1A8]
.text:0000102B                 mov     [ebp+var_220], edx
.text:00001031                 mov     byte ptr [ebp+var_4], 0Ah
.text:00001035                 lea     ecx, [ebp+var_12C]
.text:0000103B                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:00001040                 mov     byte ptr [ebp+var_4], 9
.text:00001044                 lea     ecx, [ebp+var_11C] ; this
.text:0000104A                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:0000104F                 mov     byte ptr [ebp+var_4], 8
.text:00001053                 lea     ecx, [ebp+var_108] ; this
.text:00001059                 call    ??1CItem@NTar@NArchive@@QAE@XZ ; NArchive::NTar::CItem::~CItem(void)
.text:0000105E                 mov     byte ptr [ebp+var_4], 6
.text:00001062                 lea     ecx, [ebp+var_80]
.text:00001065                 call    ??1?$CMyComPtr@VCLimitedSequentialInStream@@@@QAE@XZ ; CMyComPtr<CLimitedSequentialInStream>::~CMyComPtr<CLimitedSequentialInStream>(void)
.text:0000106A                 mov     byte ptr [ebp+var_4], 4
.text:0000106E                 lea     ecx, [ebp+var_70]
.text:00001071                 call    ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ ; CMyComPtr<ICompressProgressInfo>::~CMyComPtr<ICompressProgressInfo>(void)
.text:00001076                 mov     byte ptr [ebp+var_4], 2
.text:0000107A                 lea     ecx, [ebp+var_60]
.text:0000107D                 call    ??1?$CMyComPtr@UICompressCoder@@@@QAE@XZ ; CMyComPtr<ICompressCoder>::~CMyComPtr<ICompressCoder>(void)
.text:00001082                 mov     byte ptr [ebp+var_4], 1
.text:00001086                 lea     ecx, [ebp+var_3C]
.text:00001089                 call    ??1?$CMyComPtr@UIArchiveUpdateCallbackFile@@@@QAE@XZ ; CMyComPtr<IArchiveUpdateCallbackFile>::~CMyComPtr<IArchiveUpdateCallbackFile>(void)
.text:0000108E                 mov     byte ptr [ebp+var_4], 0
.text:00001092                 lea     ecx, [ebp+var_30]
.text:00001095                 call    ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::~CMyComPtr<IOutStream>(void)
.text:0000109A                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000010A1                 lea     ecx, [ebp+var_24] ; this
.text:000010A4                 call    ??1COutArchive@NTar@NArchive@@QAE@XZ ; NArchive::NTar::COutArchive::~COutArchive(void)
.text:000010A9                 mov     eax, [ebp+var_220]
.text:000010AF                 jmp     loc_1978
.text:000010B4 ; ---------------------------------------------------------------------------
.text:000010B4
.text:000010B4 loc_10B4:                               ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+A7Fj
.text:000010B4                                         ; NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+B55j ...
.text:000010B4                 mov     eax, [ebp+var_48]
.text:000010B7                 add     eax, dword ptr [ebp+var_F8]
.text:000010BD                 mov     ecx, dword ptr [ebp+var_44]
.text:000010C0                 adc     ecx, dword ptr [ebp+var_F8+4]
.text:000010C6                 mov     [ebp+var_48], eax
.text:000010C9                 mov     dword ptr [ebp+var_44], ecx
.text:000010CC                 mov     esi, esp
.text:000010CE                 push    0
.text:000010D0                 mov     edx, [ebp+arg_14]
.text:000010D3                 mov     eax, [edx]
.text:000010D5                 mov     ecx, [ebp+arg_14]
.text:000010D8                 push    ecx
.text:000010D9                 mov     edx, [eax+20h]
.text:000010DC                 call    edx
.text:000010DE                 cmp     esi, esp
.text:000010E0                 call    __RTC_CheckEsp
.text:000010E5                 mov     [ebp+var_1AC], eax
.text:000010EB                 cmp     [ebp+var_1AC], 0
.text:000010F2                 jz      loc_1187
.text:000010F8                 mov     eax, [ebp+var_1AC]
.text:000010FE                 mov     [ebp+var_224], eax
.text:00001104                 mov     byte ptr [ebp+var_4], 0Ah
.text:00001108                 lea     ecx, [ebp+var_12C]
.text:0000110E                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:00001113                 mov     byte ptr [ebp+var_4], 9
.text:00001117                 lea     ecx, [ebp+var_11C] ; this
.text:0000111D                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00001122                 mov     byte ptr [ebp+var_4], 8
.text:00001126                 lea     ecx, [ebp+var_108] ; this
.text:0000112C                 call    ??1CItem@NTar@NArchive@@QAE@XZ ; NArchive::NTar::CItem::~CItem(void)
.text:00001131                 mov     byte ptr [ebp+var_4], 6
.text:00001135                 lea     ecx, [ebp+var_80]
.text:00001138                 call    ??1?$CMyComPtr@VCLimitedSequentialInStream@@@@QAE@XZ ; CMyComPtr<CLimitedSequentialInStream>::~CMyComPtr<CLimitedSequentialInStream>(void)
.text:0000113D                 mov     byte ptr [ebp+var_4], 4
.text:00001141                 lea     ecx, [ebp+var_70]
.text:00001144                 call    ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ ; CMyComPtr<ICompressProgressInfo>::~CMyComPtr<ICompressProgressInfo>(void)
.text:00001149                 mov     byte ptr [ebp+var_4], 2
.text:0000114D                 lea     ecx, [ebp+var_60]
.text:00001150                 call    ??1?$CMyComPtr@UICompressCoder@@@@QAE@XZ ; CMyComPtr<ICompressCoder>::~CMyComPtr<ICompressCoder>(void)
.text:00001155                 mov     byte ptr [ebp+var_4], 1
.text:00001159                 lea     ecx, [ebp+var_3C]
.text:0000115C                 call    ??1?$CMyComPtr@UIArchiveUpdateCallbackFile@@@@QAE@XZ ; CMyComPtr<IArchiveUpdateCallbackFile>::~CMyComPtr<IArchiveUpdateCallbackFile>(void)
.text:00001161                 mov     byte ptr [ebp+var_4], 0
.text:00001165                 lea     ecx, [ebp+var_30]
.text:00001168                 call    ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::~CMyComPtr<IOutStream>(void)
.text:0000116D                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001174                 lea     ecx, [ebp+var_24] ; this
.text:00001177                 call    ??1COutArchive@NTar@NArchive@@QAE@XZ ; NArchive::NTar::COutArchive::~COutArchive(void)
.text:0000117C                 mov     eax, [ebp+var_224]
.text:00001182                 jmp     loc_1978
.text:00001187 ; ---------------------------------------------------------------------------
.text:00001187
.text:00001187 loc_1187:                               ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+10F2j
.text:00001187                 mov     byte ptr [ebp+var_4], 0Ah
.text:0000118B                 lea     ecx, [ebp+var_12C]
.text:00001191                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:00001196                 jmp     loc_1862
.text:0000119B ; ---------------------------------------------------------------------------
.text:0000119B
.text:0000119B loc_119B:                               ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+60Cj
.text:0000119B                 mov     ecx, [ebp+var_8C]
.text:000011A1                 mov     edx, [ecx]
.text:000011A3                 push    edx
.text:000011A4                 mov     ecx, [ebp+arg_8]
.text:000011A7                 call    ??A?$CObjectVector@UCItemEx@NTar@NArchive@@@@QBEABUCItemEx@NTar@NArchive@@I@Z ; CObjectVector<NArchive::NTar::CItemEx>::operator[](uint)
.text:000011AC                 mov     [ebp+var_1B0], eax
.text:000011B2                 mov     eax, [ebp+var_8C]
.text:000011B8                 movzx   ecx, byte ptr [eax+1Dh]
.text:000011BC                 test    ecx, ecx
.text:000011BE                 jz      loc_1444
.text:000011C4                 lea     ecx, [ebp+var_11C] ; this
.text:000011CA                 call    ?IsEmpty@AString@@QBE_NXZ ; AString::IsEmpty(void)
.text:000011CF                 movzx   edx, al
.text:000011D2                 test    edx, edx
.text:000011D4                 jnz     short loc_1200
.text:000011D6                 mov     dword ptr [ebp+var_F8], 0
.text:000011E0                 mov     dword ptr [ebp+var_F8+4], 0
.text:000011EA                 mov     [ebp+var_F0], 0
.text:000011F4                 mov     [ebp+var_EC], 0
.text:000011FE                 jmp     short loc_1270
.text:00001200 ; ---------------------------------------------------------------------------
.text:00001200
.text:00001200 loc_1200:                               ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+11D4j
.text:00001200                 mov     eax, [ebp+var_8C]
.text:00001206                 movzx   esi, byte ptr [eax+1Eh]
.text:0000120A                 mov     ecx, [ebp+var_1B0] ; this
.text:00001210                 call    ?IsDir@CItem@NTar@NArchive@@QBE_NXZ ; NArchive::NTar::CItem::IsDir(void)
.text:00001215                 movzx   ecx, al
.text:00001218                 cmp     esi, ecx
.text:0000121A                 jnz     short loc_122B
.text:0000121C                 mov     edx, [ebp+var_1B0]
.text:00001222                 mov     al, [edx+68h]
.text:00001225                 mov     [ebp+var_A0], al
.text:0000122B
.text:0000122B loc_122B:                               ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+121Aj
.text:0000122B                 mov     ecx, [ebp+var_1B0]
.text:00001231                 add     ecx, 6Ch ; 'l'
.text:00001234                 push    ecx
.text:00001235                 lea     ecx, [ebp+var_9C]
.text:0000123B                 call    ??4?$CRecordVector@UCSparseBlock@NTar@NArchive@@@@QAEAAV0@ABV0@@Z ; CRecordVector<NArchive::NTar::CSparseBlock>::operator=(CRecordVector<NArchive::NTar::CSparseBlock> const &)
.text:00001240                 mov     edx, [ebp+var_1B0]
.text:00001246                 mov     eax, [edx+18h]
.text:00001249                 mov     [ebp+var_F0], eax
.text:0000124F                 mov     ecx, [edx+1Ch]
.text:00001252                 mov     [ebp+var_EC], ecx
.text:00001258                 mov     edx, [ebp+var_1B0]
.text:0000125E                 mov     eax, [edx+10h]
.text:00001261                 mov     dword ptr [ebp+var_F8], eax
.text:00001267                 mov     ecx, [edx+14h]
.text:0000126A                 mov     dword ptr [ebp+var_F8+4], ecx
.text:00001270
.text:00001270 loc_1270:                               ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+11FEj
.text:00001270                 mov     edx, [ebp+var_1B0]
.text:00001276                 mov     al, [edx+69h]
.text:00001279                 mov     [ebp+var_9F], al
.text:0000127F                 mov     ecx, [ebp+var_1B0]
.text:00001285                 mov     dl, [ecx+6Ah]
.text:00001288                 mov     [ebp+var_9E], dl
.text:0000128E                 mov     eax, [ebp+var_1B0]
.text:00001294                 mov     ecx, [eax+34h]
.text:00001297                 mov     [ebp+var_D4], ecx
.text:0000129D                 mov     edx, [ebp+var_1B0]
.text:000012A3                 mov     eax, [edx+38h]
.text:000012A6                 mov     [ebp+var_D0], eax
.text:000012AC                 mov     ecx, [ebp+var_1B0]
.text:000012B2                 mov     edx, [ecx+2Ch]
.text:000012B5                 mov     [ebp+var_DC], edx
.text:000012BB                 mov     eax, [ebp+var_1B0]
.text:000012C1                 mov     ecx, [eax+30h]
.text:000012C4                 mov     [ebp+var_D8], ecx
.text:000012CA                 lea     edx, [ebp+var_108]
.text:000012D0                 push    edx             ; struct NArchive::NTar::CItem *
.text:000012D1                 lea     ecx, [ebp+var_24] ; this
.text:000012D4                 call    ?WriteHeader@COutArchive@NTar@NArchive@@QAEJABUCItem@23@@Z ; NArchive::NTar::COutArchive::WriteHeader(NArchive::NTar::CItem const &)
.text:000012D9                 mov     [ebp+var_1BC], eax
.text:000012DF                 cmp     [ebp+var_1BC], 0
.text:000012E6                 jz      loc_136C
.text:000012EC                 mov     eax, [ebp+var_1BC]
.text:000012F2                 mov     [ebp+var_228], eax
.text:000012F8                 mov     byte ptr [ebp+var_4], 9
.text:000012FC                 lea     ecx, [ebp+var_11C] ; this
.text:00001302                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00001307                 mov     byte ptr [ebp+var_4], 8
.text:0000130B                 lea     ecx, [ebp+var_108] ; this
.text:00001311                 call    ??1CItem@NTar@NArchive@@QAE@XZ ; NArchive::NTar::CItem::~CItem(void)
.text:00001316                 mov     byte ptr [ebp+var_4], 6
.text:0000131A                 lea     ecx, [ebp+var_80]
.text:0000131D                 call    ??1?$CMyComPtr@VCLimitedSequentialInStream@@@@QAE@XZ ; CMyComPtr<CLimitedSequentialInStream>::~CMyComPtr<CLimitedSequentialInStream>(void)
.text:00001322                 mov     byte ptr [ebp+var_4], 4
.text:00001326                 lea     ecx, [ebp+var_70]
.text:00001329                 call    ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ ; CMyComPtr<ICompressProgressInfo>::~CMyComPtr<ICompressProgressInfo>(void)
.text:0000132E                 mov     byte ptr [ebp+var_4], 2
.text:00001332                 lea     ecx, [ebp+var_60]
.text:00001335                 call    ??1?$CMyComPtr@UICompressCoder@@@@QAE@XZ ; CMyComPtr<ICompressCoder>::~CMyComPtr<ICompressCoder>(void)
.text:0000133A                 mov     byte ptr [ebp+var_4], 1
.text:0000133E                 lea     ecx, [ebp+var_3C]
.text:00001341                 call    ??1?$CMyComPtr@UIArchiveUpdateCallbackFile@@@@QAE@XZ ; CMyComPtr<IArchiveUpdateCallbackFile>::~CMyComPtr<IArchiveUpdateCallbackFile>(void)
.text:00001346                 mov     byte ptr [ebp+var_4], 0
.text:0000134A                 lea     ecx, [ebp+var_30]
.text:0000134D                 call    ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::~CMyComPtr<IOutStream>(void)
.text:00001352                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001359                 lea     ecx, [ebp+var_24] ; this
.text:0000135C                 call    ??1COutArchive@NTar@NArchive@@QAE@XZ ; NArchive::NTar::COutArchive::~COutArchive(void)
.text:00001361                 mov     eax, [ebp+var_228]
.text:00001367                 jmp     loc_1978
.text:0000136C ; ---------------------------------------------------------------------------
.text:0000136C
.text:0000136C loc_136C:                               ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+12E6j
.text:0000136C                 mov     esi, esp
.text:0000136E                 push    0
.text:00001370                 push    0
.text:00001372                 mov     ecx, [ebp+var_1B0] ; this
.text:00001378                 call    ?GetDataPosition@CItemEx@NTar@NArchive@@QBE_KXZ ; NArchive::NTar::CItemEx::GetDataPosition(void)
.text:0000137D                 push    edx
.text:0000137E                 push    eax
.text:0000137F                 mov     ecx, [ebp+arg_0]
.text:00001382                 mov     edx, [ecx]
.text:00001384                 mov     eax, [ebp+arg_0]
.text:00001387                 push    eax
.text:00001388                 mov     ecx, [edx+10h]
.text:0000138B                 call    ecx
.text:0000138D                 cmp     esi, esp
.text:0000138F                 call    __RTC_CheckEsp
.text:00001394                 mov     [ebp+var_1C0], eax
.text:0000139A                 cmp     [ebp+var_1C0], 0
.text:000013A1                 jz      loc_1427
.text:000013A7                 mov     edx, [ebp+var_1C0]
.text:000013AD                 mov     [ebp+var_22C], edx
.text:000013B3                 mov     byte ptr [ebp+var_4], 9
.text:000013B7                 lea     ecx, [ebp+var_11C] ; this
.text:000013BD                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:000013C2                 mov     byte ptr [ebp+var_4], 8
.text:000013C6                 lea     ecx, [ebp+var_108] ; this
.text:000013CC                 call    ??1CItem@NTar@NArchive@@QAE@XZ ; NArchive::NTar::CItem::~CItem(void)
.text:000013D1                 mov     byte ptr [ebp+var_4], 6
.text:000013D5                 lea     ecx, [ebp+var_80]
.text:000013D8                 call    ??1?$CMyComPtr@VCLimitedSequentialInStream@@@@QAE@XZ ; CMyComPtr<CLimitedSequentialInStream>::~CMyComPtr<CLimitedSequentialInStream>(void)
.text:000013DD                 mov     byte ptr [ebp+var_4], 4
.text:000013E1                 lea     ecx, [ebp+var_70]
.text:000013E4                 call    ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ ; CMyComPtr<ICompressProgressInfo>::~CMyComPtr<ICompressProgressInfo>(void)
.text:000013E9                 mov     byte ptr [ebp+var_4], 2
.text:000013ED                 lea     ecx, [ebp+var_60]
.text:000013F0                 call    ??1?$CMyComPtr@UICompressCoder@@@@QAE@XZ ; CMyComPtr<ICompressCoder>::~CMyComPtr<ICompressCoder>(void)
.text:000013F5                 mov     byte ptr [ebp+var_4], 1
.text:000013F9                 lea     ecx, [ebp+var_3C]
.text:000013FC                 call    ??1?$CMyComPtr@UIArchiveUpdateCallbackFile@@@@QAE@XZ ; CMyComPtr<IArchiveUpdateCallbackFile>::~CMyComPtr<IArchiveUpdateCallbackFile>(void)
.text:00001401                 mov     byte ptr [ebp+var_4], 0
.text:00001405                 lea     ecx, [ebp+var_30]
.text:00001408                 call    ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::~CMyComPtr<IOutStream>(void)
.text:0000140D                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001414                 lea     ecx, [ebp+var_24] ; this
.text:00001417                 call    ??1COutArchive@NTar@NArchive@@QAE@XZ ; NArchive::NTar::COutArchive::~COutArchive(void)
.text:0000141C                 mov     eax, [ebp+var_22C]
.text:00001422                 jmp     loc_1978
.text:00001427 ; ---------------------------------------------------------------------------
.text:00001427
.text:00001427 loc_1427:                               ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+13A1j
.text:00001427                 mov     eax, [ebp+var_1B0]
.text:0000142D                 mov     ecx, [eax+10h]
.text:00001430                 mov     dword ptr [ebp+var_1B8], ecx
.text:00001436                 mov     edx, [eax+14h]
.text:00001439                 mov     dword ptr [ebp+var_1B8+4], edx
.text:0000143F                 jmp     loc_1517
.text:00001444 ; ---------------------------------------------------------------------------
.text:00001444
.text:00001444 loc_1444:                               ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+11BEj
.text:00001444                 mov     esi, esp
.text:00001446                 push    0
.text:00001448                 push    0
.text:0000144A                 mov     eax, [ebp+var_1B0]
.text:00001450                 mov     ecx, [eax+7Ch]
.text:00001453                 push    ecx
.text:00001454                 mov     edx, [eax+78h]
.text:00001457                 push    edx
.text:00001458                 mov     eax, [ebp+arg_0]
.text:0000145B                 mov     ecx, [eax]
.text:0000145D                 mov     edx, [ebp+arg_0]
.text:00001460                 push    edx
.text:00001461                 mov     eax, [ecx+10h]
.text:00001464                 call    eax
.text:00001466                 cmp     esi, esp
.text:00001468                 call    __RTC_CheckEsp
.text:0000146D                 mov     [ebp+var_1C4], eax
.text:00001473                 cmp     [ebp+var_1C4], 0
.text:0000147A                 jz      loc_1500
.text:00001480                 mov     ecx, [ebp+var_1C4]
.text:00001486                 mov     [ebp+var_230], ecx
.text:0000148C                 mov     byte ptr [ebp+var_4], 9
.text:00001490                 lea     ecx, [ebp+var_11C] ; this
.text:00001496                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:0000149B                 mov     byte ptr [ebp+var_4], 8
.text:0000149F                 lea     ecx, [ebp+var_108] ; this
.text:000014A5                 call    ??1CItem@NTar@NArchive@@QAE@XZ ; NArchive::NTar::CItem::~CItem(void)
.text:000014AA                 mov     byte ptr [ebp+var_4], 6
.text:000014AE                 lea     ecx, [ebp+var_80]
.text:000014B1                 call    ??1?$CMyComPtr@VCLimitedSequentialInStream@@@@QAE@XZ ; CMyComPtr<CLimitedSequentialInStream>::~CMyComPtr<CLimitedSequentialInStream>(void)
.text:000014B6                 mov     byte ptr [ebp+var_4], 4
.text:000014BA                 lea     ecx, [ebp+var_70]
.text:000014BD                 call    ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ ; CMyComPtr<ICompressProgressInfo>::~CMyComPtr<ICompressProgressInfo>(void)
.text:000014C2                 mov     byte ptr [ebp+var_4], 2
.text:000014C6                 lea     ecx, [ebp+var_60]
.text:000014C9                 call    ??1?$CMyComPtr@UICompressCoder@@@@QAE@XZ ; CMyComPtr<ICompressCoder>::~CMyComPtr<ICompressCoder>(void)
.text:000014CE                 mov     byte ptr [ebp+var_4], 1
.text:000014D2                 lea     ecx, [ebp+var_3C]
.text:000014D5                 call    ??1?$CMyComPtr@UIArchiveUpdateCallbackFile@@@@QAE@XZ ; CMyComPtr<IArchiveUpdateCallbackFile>::~CMyComPtr<IArchiveUpdateCallbackFile>(void)
.text:000014DA                 mov     byte ptr [ebp+var_4], 0
.text:000014DE                 lea     ecx, [ebp+var_30]
.text:000014E1                 call    ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::~CMyComPtr<IOutStream>(void)
.text:000014E6                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000014ED                 lea     ecx, [ebp+var_24] ; this
.text:000014F0                 call    ??1COutArchive@NTar@NArchive@@QAE@XZ ; NArchive::NTar::COutArchive::~COutArchive(void)
.text:000014F5                 mov     eax, [ebp+var_230]
.text:000014FB                 jmp     loc_1978
.text:00001500 ; ---------------------------------------------------------------------------
.text:00001500
.text:00001500 loc_1500:                               ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+147Aj
.text:00001500                 mov     ecx, [ebp+var_1B0] ; this
.text:00001506                 call    ?GetFullSize@CItemEx@NTar@NArchive@@QBE_KXZ ; NArchive::NTar::CItemEx::GetFullSize(void)
.text:0000150B                 mov     dword ptr [ebp+var_1B8], eax
.text:00001511                 mov     dword ptr [ebp+var_1B8+4], edx
.text:00001517
.text:00001517 loc_1517:                               ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+143Fj
.text:00001517                 mov     edx, dword ptr [ebp+var_1B8+4]
.text:0000151D                 push    edx
.text:0000151E                 mov     eax, dword ptr [ebp+var_1B8]
.text:00001524                 push    eax             ; unsigned __int64
.text:00001525                 mov     ecx, [ebp+var_78] ; this
.text:00001528                 call    ?Init@CLimitedSequentialInStream@@QAEX_K@Z ; CLimitedSequentialInStream::Init(unsigned __int64)
.text:0000152D                 lea     ecx, [ebp+var_3C]
.text:00001530                 call    ??B?$CMyComPtr@UIArchiveUpdateCallbackFile@@@@QBEPAUIArchiveUpdateCallbackFile@@XZ ; CMyComPtr<IArchiveUpdateCallbackFile>::operator IArchiveUpdateCallbackFile *(void)
.text:00001535                 test    eax, eax
.text:00001537                 jz      loc_1608
.text:0000153D                 lea     ecx, [ebp+var_3C]
.text:00001540                 call    ??C?$CMyComPtr@UIArchiveUpdateCallbackFile@@@@QBEPAUIArchiveUpdateCallbackFile@@XZ ; CMyComPtr<IArchiveUpdateCallbackFile>::operator->(void)
.text:00001545                 mov     [ebp+var_274], eax
.text:0000154B                 mov     esi, esp
.text:0000154D                 push    3
.text:0000154F                 mov     ecx, [ebp+var_8C]
.text:00001555                 mov     edx, [ecx]
.text:00001557                 push    edx
.text:00001558                 push    1
.text:0000155A                 mov     eax, [ebp+var_274]
.text:00001560                 push    eax
.text:00001561                 mov     ecx, [ebp+var_274]
.text:00001567                 mov     edx, [ecx]
.text:00001569                 mov     eax, [edx+10h]
.text:0000156C                 call    eax
.text:0000156E                 cmp     esi, esp
.text:00001570                 call    __RTC_CheckEsp
.text:00001575                 mov     [ebp+var_1C8], eax
.text:0000157B                 cmp     [ebp+var_1C8], 0
.text:00001582                 jz      loc_1608
.text:00001588                 mov     ecx, [ebp+var_1C8]
.text:0000158E                 mov     [ebp+var_234], ecx
.text:00001594                 mov     byte ptr [ebp+var_4], 9
.text:00001598                 lea     ecx, [ebp+var_11C] ; this
.text:0000159E                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:000015A3                 mov     byte ptr [ebp+var_4], 8
.text:000015A7                 lea     ecx, [ebp+var_108] ; this
.text:000015AD                 call    ??1CItem@NTar@NArchive@@QAE@XZ ; NArchive::NTar::CItem::~CItem(void)
.text:000015B2                 mov     byte ptr [ebp+var_4], 6
.text:000015B6                 lea     ecx, [ebp+var_80]
.text:000015B9                 call    ??1?$CMyComPtr@VCLimitedSequentialInStream@@@@QAE@XZ ; CMyComPtr<CLimitedSequentialInStream>::~CMyComPtr<CLimitedSequentialInStream>(void)
.text:000015BE                 mov     byte ptr [ebp+var_4], 4
.text:000015C2                 lea     ecx, [ebp+var_70]
.text:000015C5                 call    ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ ; CMyComPtr<ICompressProgressInfo>::~CMyComPtr<ICompressProgressInfo>(void)
.text:000015CA                 mov     byte ptr [ebp+var_4], 2
.text:000015CE                 lea     ecx, [ebp+var_60]
.text:000015D1                 call    ??1?$CMyComPtr@UICompressCoder@@@@QAE@XZ ; CMyComPtr<ICompressCoder>::~CMyComPtr<ICompressCoder>(void)
.text:000015D6                 mov     byte ptr [ebp+var_4], 1
.text:000015DA                 lea     ecx, [ebp+var_3C]
.text:000015DD                 call    ??1?$CMyComPtr@UIArchiveUpdateCallbackFile@@@@QAE@XZ ; CMyComPtr<IArchiveUpdateCallbackFile>::~CMyComPtr<IArchiveUpdateCallbackFile>(void)
.text:000015E2                 mov     byte ptr [ebp+var_4], 0
.text:000015E6                 lea     ecx, [ebp+var_30]
.text:000015E9                 call    ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::~CMyComPtr<IOutStream>(void)
.text:000015EE                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000015F5                 lea     ecx, [ebp+var_24] ; this
.text:000015F8                 call    ??1COutArchive@NTar@NArchive@@QAE@XZ ; NArchive::NTar::COutArchive::~COutArchive(void)
.text:000015FD                 mov     eax, [ebp+var_234]
.text:00001603                 jmp     loc_1978
.text:00001608 ; ---------------------------------------------------------------------------
.text:00001608
.text:00001608 loc_1608:                               ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+1537j
.text:00001608                                         ; NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+1582j
.text:00001608                 lea     ecx, [ebp+var_60]
.text:0000160B                 call    ??C?$CMyComPtr@UICompressCoder@@@@QBEPAUICompressCoder@@XZ ; CMyComPtr<ICompressCoder>::operator->(void)
.text:00001610                 mov     [ebp+var_278], eax
.text:00001616                 lea     ecx, [ebp+var_70]
.text:00001619                 call    ??B?$CMyComPtr@UICompressProgressInfo@@@@QBEPAUICompressProgressInfo@@XZ ; CMyComPtr<ICompressProgressInfo>::operator ICompressProgressInfo *(void)
.text:0000161E                 mov     esi, esp
.text:00001620                 push    eax
.text:00001621                 push    0
.text:00001623                 push    0
.text:00001625                 mov     edx, [ebp+arg_4]
.text:00001628                 push    edx
.text:00001629                 lea     ecx, [ebp+var_80]
.text:0000162C                 call    ??B?$CMyComPtr@VCLimitedSequentialInStream@@@@QBEPAVCLimitedSequentialInStream@@XZ ; CMyComPtr<CLimitedSequentialInStream>::operator CLimitedSequentialInStream *(void)
.text:00001631                 push    eax
.text:00001632                 mov     eax, [ebp+var_278]
.text:00001638                 push    eax
.text:00001639                 mov     ecx, [ebp+var_278]
.text:0000163F                 mov     edx, [ecx]
.text:00001641                 mov     eax, [edx+0Ch]
.text:00001644                 call    eax
.text:00001646                 cmp     esi, esp
.text:00001648                 call    __RTC_CheckEsp
.text:0000164D                 mov     [ebp+var_1CC], eax
.text:00001653                 cmp     [ebp+var_1CC], 0
.text:0000165A                 jz      loc_16E0
.text:00001660                 mov     ecx, [ebp+var_1CC]
.text:00001666                 mov     [ebp+var_238], ecx
.text:0000166C                 mov     byte ptr [ebp+var_4], 9
.text:00001670                 lea     ecx, [ebp+var_11C] ; this
.text:00001676                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:0000167B                 mov     byte ptr [ebp+var_4], 8
.text:0000167F                 lea     ecx, [ebp+var_108] ; this
.text:00001685                 call    ??1CItem@NTar@NArchive@@QAE@XZ ; NArchive::NTar::CItem::~CItem(void)
.text:0000168A                 mov     byte ptr [ebp+var_4], 6
.text:0000168E                 lea     ecx, [ebp+var_80]
.text:00001691                 call    ??1?$CMyComPtr@VCLimitedSequentialInStream@@@@QAE@XZ ; CMyComPtr<CLimitedSequentialInStream>::~CMyComPtr<CLimitedSequentialInStream>(void)
.text:00001696                 mov     byte ptr [ebp+var_4], 4
.text:0000169A                 lea     ecx, [ebp+var_70]
.text:0000169D                 call    ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ ; CMyComPtr<ICompressProgressInfo>::~CMyComPtr<ICompressProgressInfo>(void)
.text:000016A2                 mov     byte ptr [ebp+var_4], 2
.text:000016A6                 lea     ecx, [ebp+var_60]
.text:000016A9                 call    ??1?$CMyComPtr@UICompressCoder@@@@QAE@XZ ; CMyComPtr<ICompressCoder>::~CMyComPtr<ICompressCoder>(void)
.text:000016AE                 mov     byte ptr [ebp+var_4], 1
.text:000016B2                 lea     ecx, [ebp+var_3C]
.text:000016B5                 call    ??1?$CMyComPtr@UIArchiveUpdateCallbackFile@@@@QAE@XZ ; CMyComPtr<IArchiveUpdateCallbackFile>::~CMyComPtr<IArchiveUpdateCallbackFile>(void)
.text:000016BA                 mov     byte ptr [ebp+var_4], 0
.text:000016BE                 lea     ecx, [ebp+var_30]
.text:000016C1                 call    ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::~CMyComPtr<IOutStream>(void)
.text:000016C6                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000016CD                 lea     ecx, [ebp+var_24] ; this
.text:000016D0                 call    ??1COutArchive@NTar@NArchive@@QAE@XZ ; NArchive::NTar::COutArchive::~COutArchive(void)
.text:000016D5                 mov     eax, [ebp+var_238]
.text:000016DB                 jmp     loc_1978
.text:000016E0 ; ---------------------------------------------------------------------------
.text:000016E0
.text:000016E0 loc_16E0:                               ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+165Aj
.text:000016E0                 mov     edx, [ebp+var_58]
.text:000016E3                 mov     [ebp+var_27C], edx
.text:000016E9                 mov     eax, [ebp+var_27C]
.text:000016EF                 mov     ecx, [eax+20h]
.text:000016F2                 cmp     ecx, dword ptr [ebp+var_1B8]
.text:000016F8                 jnz     short loc_170B
.text:000016FA                 mov     edx, [ebp+var_27C]
.text:00001700                 mov     eax, [edx+24h]
.text:00001703                 cmp     eax, dword ptr [ebp+var_1B8+4]
.text:00001709                 jz      short loc_1789
.text:0000170B
.text:0000170B loc_170B:                               ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+16F8j
.text:0000170B                 mov     [ebp+var_23C], 80004005h
.text:00001715                 mov     byte ptr [ebp+var_4], 9
.text:00001719                 lea     ecx, [ebp+var_11C] ; this
.text:0000171F                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00001724                 mov     byte ptr [ebp+var_4], 8
.text:00001728                 lea     ecx, [ebp+var_108] ; this
.text:0000172E                 call    ??1CItem@NTar@NArchive@@QAE@XZ ; NArchive::NTar::CItem::~CItem(void)
.text:00001733                 mov     byte ptr [ebp+var_4], 6
.text:00001737                 lea     ecx, [ebp+var_80]
.text:0000173A                 call    ??1?$CMyComPtr@VCLimitedSequentialInStream@@@@QAE@XZ ; CMyComPtr<CLimitedSequentialInStream>::~CMyComPtr<CLimitedSequentialInStream>(void)
.text:0000173F                 mov     byte ptr [ebp+var_4], 4
.text:00001743                 lea     ecx, [ebp+var_70]
.text:00001746                 call    ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ ; CMyComPtr<ICompressProgressInfo>::~CMyComPtr<ICompressProgressInfo>(void)
.text:0000174B                 mov     byte ptr [ebp+var_4], 2
.text:0000174F                 lea     ecx, [ebp+var_60]
.text:00001752                 call    ??1?$CMyComPtr@UICompressCoder@@@@QAE@XZ ; CMyComPtr<ICompressCoder>::~CMyComPtr<ICompressCoder>(void)
.text:00001757                 mov     byte ptr [ebp+var_4], 1
.text:0000175B                 lea     ecx, [ebp+var_3C]
.text:0000175E                 call    ??1?$CMyComPtr@UIArchiveUpdateCallbackFile@@@@QAE@XZ ; CMyComPtr<IArchiveUpdateCallbackFile>::~CMyComPtr<IArchiveUpdateCallbackFile>(void)
.text:00001763                 mov     byte ptr [ebp+var_4], 0
.text:00001767                 lea     ecx, [ebp+var_30]
.text:0000176A                 call    ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::~CMyComPtr<IOutStream>(void)
.text:0000176F                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001776                 lea     ecx, [ebp+var_24] ; this
.text:00001779                 call    ??1COutArchive@NTar@NArchive@@QAE@XZ ; NArchive::NTar::COutArchive::~COutArchive(void)
.text:0000177E                 mov     eax, [ebp+var_23C]
.text:00001784                 jmp     loc_1978
.text:00001789 ; ---------------------------------------------------------------------------
.text:00001789
.text:00001789 loc_1789:                               ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+1709j
.text:00001789                 mov     ecx, [ebp+var_1C]
.text:0000178C                 add     ecx, dword ptr [ebp+var_1B8]
.text:00001792                 mov     edx, [ebp+var_18]
.text:00001795                 adc     edx, dword ptr [ebp+var_1B8+4]
.text:0000179B                 mov     [ebp+var_1C], ecx
.text:0000179E                 mov     [ebp+var_18], edx
.text:000017A1                 mov     eax, [ebp+var_1B0]
.text:000017A7                 mov     ecx, [eax+14h]
.text:000017AA                 push    ecx
.text:000017AB                 mov     edx, [eax+10h]
.text:000017AE                 push    edx             ; unsigned __int64
.text:000017AF                 lea     ecx, [ebp+var_24] ; this
.text:000017B2                 call    ?FillDataResidual@COutArchive@NTar@NArchive@@QAEJ_K@Z ; NArchive::NTar::COutArchive::FillDataResidual(unsigned __int64)
.text:000017B7                 mov     [ebp+var_1D0], eax
.text:000017BD                 cmp     [ebp+var_1D0], 0
.text:000017C4                 jz      loc_184A
.text:000017CA                 mov     eax, [ebp+var_1D0]
.text:000017D0                 mov     [ebp+var_240], eax
.text:000017D6                 mov     byte ptr [ebp+var_4], 9
.text:000017DA                 lea     ecx, [ebp+var_11C] ; this
.text:000017E0                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:000017E5                 mov     byte ptr [ebp+var_4], 8
.text:000017E9                 lea     ecx, [ebp+var_108] ; this
.text:000017EF                 call    ??1CItem@NTar@NArchive@@QAE@XZ ; NArchive::NTar::CItem::~CItem(void)
.text:000017F4                 mov     byte ptr [ebp+var_4], 6
.text:000017F8                 lea     ecx, [ebp+var_80]
.text:000017FB                 call    ??1?$CMyComPtr@VCLimitedSequentialInStream@@@@QAE@XZ ; CMyComPtr<CLimitedSequentialInStream>::~CMyComPtr<CLimitedSequentialInStream>(void)
.text:00001800                 mov     byte ptr [ebp+var_4], 4
.text:00001804                 lea     ecx, [ebp+var_70]
.text:00001807                 call    ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ ; CMyComPtr<ICompressProgressInfo>::~CMyComPtr<ICompressProgressInfo>(void)
.text:0000180C                 mov     byte ptr [ebp+var_4], 2
.text:00001810                 lea     ecx, [ebp+var_60]
.text:00001813                 call    ??1?$CMyComPtr@UICompressCoder@@@@QAE@XZ ; CMyComPtr<ICompressCoder>::~CMyComPtr<ICompressCoder>(void)
.text:00001818                 mov     byte ptr [ebp+var_4], 1
.text:0000181C                 lea     ecx, [ebp+var_3C]
.text:0000181F                 call    ??1?$CMyComPtr@UIArchiveUpdateCallbackFile@@@@QAE@XZ ; CMyComPtr<IArchiveUpdateCallbackFile>::~CMyComPtr<IArchiveUpdateCallbackFile>(void)
.text:00001824                 mov     byte ptr [ebp+var_4], 0
.text:00001828                 lea     ecx, [ebp+var_30]
.text:0000182B                 call    ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::~CMyComPtr<IOutStream>(void)
.text:00001830                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001837                 lea     ecx, [ebp+var_24] ; this
.text:0000183A                 call    ??1COutArchive@NTar@NArchive@@QAE@XZ ; NArchive::NTar::COutArchive::~COutArchive(void)
.text:0000183F                 mov     eax, [ebp+var_240]
.text:00001845                 jmp     loc_1978
.text:0000184A ; ---------------------------------------------------------------------------
.text:0000184A
.text:0000184A loc_184A:                               ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+17C4j
.text:0000184A                 mov     ecx, [ebp+var_48]
.text:0000184D                 add     ecx, dword ptr [ebp+var_1B8]
.text:00001853                 mov     edx, dword ptr [ebp+var_44]
.text:00001856                 adc     edx, dword ptr [ebp+var_1B8+4]
.text:0000185C                 mov     [ebp+var_48], ecx
.text:0000185F                 mov     dword ptr [ebp+var_44], edx
.text:00001862
.text:00001862 loc_1862:                               ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+1196j
.text:00001862                 mov     byte ptr [ebp+var_4], 9
.text:00001866                 lea     ecx, [ebp+var_11C] ; this
.text:0000186C                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00001871                 mov     byte ptr [ebp+var_4], 8
.text:00001875                 lea     ecx, [ebp+var_108] ; this
.text:0000187B                 call    ??1CItem@NTar@NArchive@@QAE@XZ ; NArchive::NTar::CItem::~CItem(void)
.text:00001880                 jmp     loc_306
.text:00001885 ; ---------------------------------------------------------------------------
.text:00001885
.text:00001885 loc_1885:                               ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+31Aj
.text:00001885                 mov     eax, [ebp+var_68]
.text:00001888                 mov     ecx, [ebp+var_48]
.text:0000188B                 mov     [eax+28h], ecx
.text:0000188E                 mov     edx, dword ptr [ebp+var_44]
.text:00001891                 mov     [eax+2Ch], edx
.text:00001894                 mov     eax, [ebp+var_68]
.text:00001897                 mov     ecx, [ebp+var_48]
.text:0000189A                 mov     [eax+20h], ecx
.text:0000189D                 mov     edx, dword ptr [ebp+var_44]
.text:000018A0                 mov     [eax+24h], edx
.text:000018A3                 mov     ecx, [ebp+var_68] ; this
.text:000018A6                 call    ?SetCur@CLocalProgress@@QAEJXZ ; CLocalProgress::SetCur(void)
.text:000018AB                 mov     [ebp+var_1D4], eax
.text:000018B1                 cmp     [ebp+var_1D4], 0
.text:000018B8                 jz      short loc_1919
.text:000018BA                 mov     eax, [ebp+var_1D4]
.text:000018C0                 mov     [ebp+var_244], eax
.text:000018C6                 mov     byte ptr [ebp+var_4], 6
.text:000018CA                 lea     ecx, [ebp+var_80]
.text:000018CD                 call    ??1?$CMyComPtr@VCLimitedSequentialInStream@@@@QAE@XZ ; CMyComPtr<CLimitedSequentialInStream>::~CMyComPtr<CLimitedSequentialInStream>(void)
.text:000018D2                 mov     byte ptr [ebp+var_4], 4
.text:000018D6                 lea     ecx, [ebp+var_70]
.text:000018D9                 call    ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ ; CMyComPtr<ICompressProgressInfo>::~CMyComPtr<ICompressProgressInfo>(void)
.text:000018DE                 mov     byte ptr [ebp+var_4], 2
.text:000018E2                 lea     ecx, [ebp+var_60]
.text:000018E5                 call    ??1?$CMyComPtr@UICompressCoder@@@@QAE@XZ ; CMyComPtr<ICompressCoder>::~CMyComPtr<ICompressCoder>(void)
.text:000018EA                 mov     byte ptr [ebp+var_4], 1
.text:000018EE                 lea     ecx, [ebp+var_3C]
.text:000018F1                 call    ??1?$CMyComPtr@UIArchiveUpdateCallbackFile@@@@QAE@XZ ; CMyComPtr<IArchiveUpdateCallbackFile>::~CMyComPtr<IArchiveUpdateCallbackFile>(void)
.text:000018F6                 mov     byte ptr [ebp+var_4], 0
.text:000018FA                 lea     ecx, [ebp+var_30]
.text:000018FD                 call    ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::~CMyComPtr<IOutStream>(void)
.text:00001902                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001909                 lea     ecx, [ebp+var_24] ; this
.text:0000190C                 call    ??1COutArchive@NTar@NArchive@@QAE@XZ ; NArchive::NTar::COutArchive::~COutArchive(void)
.text:00001911                 mov     eax, [ebp+var_244]
.text:00001917                 jmp     short loc_1978
.text:00001919 ; ---------------------------------------------------------------------------
.text:00001919
.text:00001919 loc_1919:                               ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+18B8j
.text:00001919                 lea     ecx, [ebp+var_24] ; this
.text:0000191C                 call    ?WriteFinishHeader@COutArchive@NTar@NArchive@@QAEJXZ ; NArchive::NTar::COutArchive::WriteFinishHeader(void)
.text:00001921                 mov     [ebp+var_248], eax
.text:00001927                 mov     byte ptr [ebp+var_4], 6
.text:0000192B                 lea     ecx, [ebp+var_80]
.text:0000192E                 call    ??1?$CMyComPtr@VCLimitedSequentialInStream@@@@QAE@XZ ; CMyComPtr<CLimitedSequentialInStream>::~CMyComPtr<CLimitedSequentialInStream>(void)
.text:00001933                 mov     byte ptr [ebp+var_4], 4
.text:00001937                 lea     ecx, [ebp+var_70]
.text:0000193A                 call    ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ ; CMyComPtr<ICompressProgressInfo>::~CMyComPtr<ICompressProgressInfo>(void)
.text:0000193F                 mov     byte ptr [ebp+var_4], 2
.text:00001943                 lea     ecx, [ebp+var_60]
.text:00001946                 call    ??1?$CMyComPtr@UICompressCoder@@@@QAE@XZ ; CMyComPtr<ICompressCoder>::~CMyComPtr<ICompressCoder>(void)
.text:0000194B                 mov     byte ptr [ebp+var_4], 1
.text:0000194F                 lea     ecx, [ebp+var_3C]
.text:00001952                 call    ??1?$CMyComPtr@UIArchiveUpdateCallbackFile@@@@QAE@XZ ; CMyComPtr<IArchiveUpdateCallbackFile>::~CMyComPtr<IArchiveUpdateCallbackFile>(void)
.text:00001957                 mov     byte ptr [ebp+var_4], 0
.text:0000195B                 lea     ecx, [ebp+var_30]
.text:0000195E                 call    ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::~CMyComPtr<IOutStream>(void)
.text:00001963                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000196A                 lea     ecx, [ebp+var_24] ; this
.text:0000196D                 call    ??1COutArchive@NTar@NArchive@@QAE@XZ ; NArchive::NTar::COutArchive::~COutArchive(void)
.text:00001972                 mov     eax, [ebp+var_248]
.text:00001978
.text:00001978 loc_1978:                               ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+1A7j
.text:00001978                                         ; NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+3B2j ...
.text:00001978                 push    edx
.text:00001979                 mov     ecx, ebp
.text:0000197B                 push    eax
.text:0000197C                 lea     edx, $LN96
.text:00001982                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00001987                 pop     eax
.text:00001988                 pop     edx
.text:00001989                 mov     ecx, [ebp+var_C]
.text:0000198C                 mov     large fs:0, ecx
.text:00001993                 pop     ecx
.text:00001994                 pop     edi
.text:00001995                 pop     esi
.text:00001996                 mov     ecx, [ebp+var_10]
.text:00001999                 xor     ecx, ebp
.text:0000199B                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text:000019A0                 add     esp, 27Ch
.text:000019A6                 cmp     ebp, esp
.text:000019A8                 call    __RTC_CheckEsp
.text:000019AD                 mov     esp, ebp
.text:000019AF                 pop     ebp
.text:000019B0                 retn    18h
.text:000019B0 ?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z endp ; sp-analysis failed
.text:000019B0
.text:000019B0 ; ---------------------------------------------------------------------------
.text:000019B3                 align 4
.text:000019B4 $LN96           dd 0Dh                  ; DATA XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+197Co
.text:000019B8                 dd offset $LN95
.text:000019BC $LN95           dd 0FFFFFFDCh, 10h      ; DATA XREF: .text:000019B8o
.text:000019C4                 dd offset $LN81         ; "outArchive"
.text:000019C8                 dd 0FFFFFFD0h, 4
.text:000019D0                 dd offset $LN82         ; "outSeekStream"
.text:000019D4                 dd 0FFFFFFC4h, 4
.text:000019DC                 dd offset $LN83         ; "opCallback"
.text:000019E0                 dd 0FFFFFFA0h, 4
.text:000019E8                 dd offset $LN84         ; "copyCoder"
.text:000019EC                 db 90h
.text:000019ED                 db 3 dup(0FFh)
.text:000019F0                 dd 4
.text:000019F4                 dd offset $LN85         ; "progress"
.text:000019F8                 dd 0FFFFFF80h, 4
.text:00001A00                 dd offset $LN86         ; "inStreamLimited"
.text:00001A04                 dd 0FFFFFEF8h, 78h
.text:00001A0C                 dd offset $LN87         ; "item"
.text:00001A10                 dd 0FFFFFEE4h, 0Ch
.text:00001A18                 dd offset $LN88         ; "symLink"
.text:00001A1C                 dd 0FFFFFED4h, 4
.text:00001A24                 dd offset $LN89         ; "fileInStream"
.text:00001A28                 dd 0FFFFFEBCh, 4
.text:00001A30                 dd offset $LN90         ; "getProps"
.text:00001A34                 dd 0FFFFFEACh, 8
.text:00001A3C                 dd offset $LN91         ; "mTime"
.text:00001A40                 dd 0FFFFFE9Ch, 8
.text:00001A48                 dd offset $LN92         ; "size2"
.text:00001A4C                 dd 0FFFFFE88h, 0Ch
.text:00001A54                 dd offset $LN93         ; "hardLink"
.text:00001A58 $LN93           db 'hardLink',0         ; DATA XREF: .text:00001A54o
.text:00001A61 $LN92           db 'size2',0            ; DATA XREF: .text:00001A48o
.text:00001A67 $LN91           db 'mTime',0            ; DATA XREF: .text:00001A3Co
.text:00001A6D $LN90           db 'getProps',0         ; DATA XREF: .text:00001A30o
.text:00001A76 $LN89           db 'fileInStream',0     ; DATA XREF: .text:00001A24o
.text:00001A83 $LN88           db 'symLink',0          ; DATA XREF: .text:00001A18o
.text:00001A8B $LN87           db 'item',0             ; DATA XREF: .text:00001A0Co
.text:00001A90 $LN86           db 'inStreamLimited',0  ; DATA XREF: .text:00001A00o
.text:00001AA0 $LN85           db 'progress',0         ; DATA XREF: .text:000019F4o
.text:00001AA9 $LN84           db 'copyCoder',0        ; DATA XREF: .text:000019E8o
.text:00001AB3 $LN83           db 'opCallback',0       ; DATA XREF: .text:000019DCo
.text:00001ABE $LN82           db 'outSeekStream',0    ; DATA XREF: .text:000019D0o
.text:00001ACC $LN81           db 'outArchive',0       ; DATA XREF: .text:000019C4o
.text:00001AD7                 align 4
.text:00001AD7 _text           ends
.text:00001AD7
.text$x:00001AD8 ; ===========================================================================
.text$x:00001AD8
.text$x:00001AD8 ; Segment type: Pure code
.text$x:00001AD8 ; Segment permissions: Read/Execute
.text$x:00001AD8 _text$x         segment para public 'CODE' use32
.text$x:00001AD8                 assume cs:_text$x
.text$x:00001AD8                 ;org 1AD8h
.text$x:00001AD8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00001AD8
.text$x:00001AD8 ; =============== S U B R O U T I N E =======================================
.text$x:00001AD8
.text$x:00001AD8
.text$x:00001AD8 __unwindfunclet$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z$0 proc near
.text$x:00001AD8                                         ; DATA XREF: .xdata$x:00001BBCo
.text$x:00001AD8                 lea     ecx, [ebp-24h]  ; this
.text$x:00001ADB                 jmp     ??1COutArchive@NTar@NArchive@@QAE@XZ ; NArchive::NTar::COutArchive::~COutArchive(void)
.text$x:00001ADB __unwindfunclet$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z$0 endp
.text$x:00001ADB
.text$x:00001AE0
.text$x:00001AE0 ; =============== S U B R O U T I N E =======================================
.text$x:00001AE0
.text$x:00001AE0
.text$x:00001AE0 __unwindfunclet$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z$1 proc near
.text$x:00001AE0                                         ; DATA XREF: .xdata$x:00001BC4o
.text$x:00001AE0                 lea     ecx, [ebp-30h]
.text$x:00001AE3                 jmp     ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::~CMyComPtr<IOutStream>(void)
.text$x:00001AE3 __unwindfunclet$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z$1 endp
.text$x:00001AE3
.text$x:00001AE8
.text$x:00001AE8 ; =============== S U B R O U T I N E =======================================
.text$x:00001AE8
.text$x:00001AE8
.text$x:00001AE8 __unwindfunclet$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z$2 proc near
.text$x:00001AE8                                         ; DATA XREF: .xdata$x:00001BCCo
.text$x:00001AE8                 lea     ecx, [ebp-3Ch]
.text$x:00001AEB                 jmp     ??1?$CMyComPtr@UIArchiveUpdateCallbackFile@@@@QAE@XZ ; CMyComPtr<IArchiveUpdateCallbackFile>::~CMyComPtr<IArchiveUpdateCallbackFile>(void)
.text$x:00001AEB __unwindfunclet$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z$2 endp
.text$x:00001AEB
.text$x:00001AF0
.text$x:00001AF0 ; =============== S U B R O U T I N E =======================================
.text$x:00001AF0
.text$x:00001AF0
.text$x:00001AF0 __unwindfunclet$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z$3 proc near
.text$x:00001AF0                                         ; DATA XREF: .xdata$x:00001BD4o
.text$x:00001AF0                 mov     eax, [ebp-1E0h]
.text$x:00001AF6                 push    eax             ; void *
.text$x:00001AF7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00001AFC                 pop     ecx
.text$x:00001AFD                 retn
.text$x:00001AFD __unwindfunclet$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z$3 endp
.text$x:00001AFD
.text$x:00001AFE
.text$x:00001AFE ; =============== S U B R O U T I N E =======================================
.text$x:00001AFE
.text$x:00001AFE
.text$x:00001AFE __unwindfunclet$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z$4 proc near
.text$x:00001AFE                                         ; DATA XREF: .xdata$x:00001BDCo
.text$x:00001AFE                 lea     ecx, [ebp-60h]
.text$x:00001B01                 jmp     ??1?$CMyComPtr@UICompressCoder@@@@QAE@XZ ; CMyComPtr<ICompressCoder>::~CMyComPtr<ICompressCoder>(void)
.text$x:00001B01 __unwindfunclet$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z$4 endp
.text$x:00001B01
.text$x:00001B06
.text$x:00001B06 ; =============== S U B R O U T I N E =======================================
.text$x:00001B06
.text$x:00001B06
.text$x:00001B06 __unwindfunclet$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z$5 proc near
.text$x:00001B06                                         ; DATA XREF: .xdata$x:00001BE4o
.text$x:00001B06                 mov     eax, [ebp-1E8h]
.text$x:00001B0C                 push    eax             ; void *
.text$x:00001B0D                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00001B12                 pop     ecx
.text$x:00001B13                 retn
.text$x:00001B13 __unwindfunclet$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z$5 endp
.text$x:00001B13
.text$x:00001B14
.text$x:00001B14 ; =============== S U B R O U T I N E =======================================
.text$x:00001B14
.text$x:00001B14
.text$x:00001B14 __unwindfunclet$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z$6 proc near
.text$x:00001B14                                         ; DATA XREF: .xdata$x:00001BECo
.text$x:00001B14                 lea     ecx, [ebp-70h]
.text$x:00001B17                 jmp     ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ ; CMyComPtr<ICompressProgressInfo>::~CMyComPtr<ICompressProgressInfo>(void)
.text$x:00001B17 __unwindfunclet$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z$6 endp
.text$x:00001B17
.text$x:00001B1C
.text$x:00001B1C ; =============== S U B R O U T I N E =======================================
.text$x:00001B1C
.text$x:00001B1C
.text$x:00001B1C __unwindfunclet$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z$7 proc near
.text$x:00001B1C                                         ; DATA XREF: .xdata$x:00001BF4o
.text$x:00001B1C                 mov     eax, [ebp-1F0h]
.text$x:00001B22                 push    eax             ; void *
.text$x:00001B23                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00001B28                 pop     ecx
.text$x:00001B29                 retn
.text$x:00001B29 __unwindfunclet$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z$7 endp
.text$x:00001B29
.text$x:00001B2A
.text$x:00001B2A ; =============== S U B R O U T I N E =======================================
.text$x:00001B2A
.text$x:00001B2A
.text$x:00001B2A __unwindfunclet$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z$8 proc near
.text$x:00001B2A                                         ; DATA XREF: .xdata$x:00001BFCo
.text$x:00001B2A                 lea     ecx, [ebp-80h]
.text$x:00001B2D                 jmp     ??1?$CMyComPtr@VCLimitedSequentialInStream@@@@QAE@XZ ; CMyComPtr<CLimitedSequentialInStream>::~CMyComPtr<CLimitedSequentialInStream>(void)
.text$x:00001B2D __unwindfunclet$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z$8 endp
.text$x:00001B2D
.text$x:00001B32
.text$x:00001B32 ; =============== S U B R O U T I N E =======================================
.text$x:00001B32
.text$x:00001B32
.text$x:00001B32 __unwindfunclet$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z$9 proc near
.text$x:00001B32                                         ; DATA XREF: .xdata$x:00001C04o
.text$x:00001B32                 lea     ecx, [ebp-108h] ; this
.text$x:00001B38                 jmp     ??1CItem@NTar@NArchive@@QAE@XZ ; NArchive::NTar::CItem::~CItem(void)
.text$x:00001B38 __unwindfunclet$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z$9 endp
.text$x:00001B38
.text$x:00001B3D
.text$x:00001B3D ; =============== S U B R O U T I N E =======================================
.text$x:00001B3D
.text$x:00001B3D
.text$x:00001B3D __unwindfunclet$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z$10 proc near
.text$x:00001B3D                                         ; DATA XREF: .xdata$x:00001C0Co
.text$x:00001B3D                 lea     ecx, [ebp-11Ch] ; this
.text$x:00001B43                 jmp     ??1AString@@QAE@XZ ; AString::~AString(void)
.text$x:00001B43 __unwindfunclet$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z$10 endp
.text$x:00001B43
.text$x:00001B48
.text$x:00001B48 ; =============== S U B R O U T I N E =======================================
.text$x:00001B48
.text$x:00001B48
.text$x:00001B48 __unwindfunclet$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z$11 proc near
.text$x:00001B48                                         ; DATA XREF: .xdata$x:00001C14o
.text$x:00001B48                 lea     ecx, [ebp-12Ch]
.text$x:00001B4E                 jmp     ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text$x:00001B4E __unwindfunclet$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z$11 endp
.text$x:00001B4E
.text$x:00001B53
.text$x:00001B53 ; =============== S U B R O U T I N E =======================================
.text$x:00001B53
.text$x:00001B53
.text$x:00001B53 __unwindfunclet$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z$12 proc near
.text$x:00001B53                                         ; DATA XREF: .xdata$x:00001C1Co
.text$x:00001B53                 lea     ecx, [ebp-144h]
.text$x:00001B59                 jmp     ??1?$CMyComPtr@UIStreamGetProps@@@@QAE@XZ ; CMyComPtr<IStreamGetProps>::~CMyComPtr<IStreamGetProps>(void)
.text$x:00001B59 __unwindfunclet$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z$12 endp
.text$x:00001B59
.text$x:00001B5E
.text$x:00001B5E ; =============== S U B R O U T I N E =======================================
.text$x:00001B5E
.text$x:00001B5E
.text$x:00001B5E __unwindfunclet$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z$13 proc near
.text$x:00001B5E                                         ; DATA XREF: .xdata$x:00001C24o
.text$x:00001B5E                 lea     ecx, [ebp-178h] ; this
.text$x:00001B64                 jmp     ??1AString@@QAE@XZ ; AString::~AString(void)
.text$x:00001B64 __unwindfunclet$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z$13 endp
.text$x:00001B64
.text$x:00001B69
.text$x:00001B69 ; =============== S U B R O U T I N E =======================================
.text$x:00001B69
.text$x:00001B69
.text$x:00001B69 __ehhandler$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z proc near
.text$x:00001B69                                         ; DATA XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+5o
.text$x:00001B69
.text$x:00001B69 arg_4           = dword ptr  8
.text$x:00001B69
.text$x:00001B69                 mov     edx, [esp+arg_4]
.text$x:00001B6D                 lea     eax, [edx+0Ch]
.text$x:00001B70                 mov     ecx, [edx-27Ch]
.text$x:00001B76                 xor     ecx, eax
.text$x:00001B78                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001B7D                 mov     ecx, [edx-4]
.text$x:00001B80                 xor     ecx, eax
.text$x:00001B82                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001B87                 mov     eax, offset __ehfuncinfo$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z
.text$x:00001B8C                 jmp     ___CxxFrameHandler3
.text$x:00001B8C __ehhandler$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z endp
.text$x:00001B8C
.text$x:00001B8C ; ---------------------------------------------------------------------------
.text$x:00001B91                 align 4
.text$x:00001B91 _text$x         ends
.text$x:00001B91
.xdata$x:00001B94 ; ===========================================================================
.xdata$x:00001B94
.xdata$x:00001B94 ; Segment type: Pure data
.xdata$x:00001B94 ; Segment permissions: Read
.xdata$x:00001B94 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001B94                 assume cs:_xdata$x
.xdata$x:00001B94                 ;org 1B94h
.xdata$x:00001B94 __ehfuncinfo$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z db  22h ; "
.xdata$x:00001B94                                         ; DATA XREF: __ehhandler$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z+1Eo
.xdata$x:00001B95                 db    5
.xdata$x:00001B96                 db  93h ; Ã´
.xdata$x:00001B97                 db  19h
.xdata$x:00001B98                 db  0Eh
.xdata$x:00001B99                 db    0
.xdata$x:00001B9A                 db    0
.xdata$x:00001B9B                 db    0
.xdata$x:00001B9C                 dd offset __unwindtable$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z
.xdata$x:00001BA0                 db    0
.xdata$x:00001BA1                 db    0
.xdata$x:00001BA2                 db    0
.xdata$x:00001BA3                 db    0
.xdata$x:00001BA4                 db    0
.xdata$x:00001BA5                 db    0
.xdata$x:00001BA6                 db    0
.xdata$x:00001BA7                 db    0
.xdata$x:00001BA8                 db    0
.xdata$x:00001BA9                 db    0
.xdata$x:00001BAA                 db    0
.xdata$x:00001BAB                 db    0
.xdata$x:00001BAC                 db    0
.xdata$x:00001BAD                 db    0
.xdata$x:00001BAE                 db    0
.xdata$x:00001BAF                 db    0
.xdata$x:00001BB0                 db    0
.xdata$x:00001BB1                 db    0
.xdata$x:00001BB2                 db    0
.xdata$x:00001BB3                 db    0
.xdata$x:00001BB4                 db    1
.xdata$x:00001BB5                 db    0
.xdata$x:00001BB6                 db    0
.xdata$x:00001BB7                 db    0
.xdata$x:00001BB8 __unwindtable$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z db 0FFh
.xdata$x:00001BB8                                         ; DATA XREF: .xdata$x:00001B9Co
.xdata$x:00001BB9                 db 0FFh
.xdata$x:00001BBA                 db 0FFh
.xdata$x:00001BBB                 db 0FFh
.xdata$x:00001BBC                 dd offset __unwindfunclet$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z$0
.xdata$x:00001BC0                 db    0
.xdata$x:00001BC1                 db    0
.xdata$x:00001BC2                 db    0
.xdata$x:00001BC3                 db    0
.xdata$x:00001BC4                 dd offset __unwindfunclet$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z$1
.xdata$x:00001BC8                 db    1
.xdata$x:00001BC9                 db    0
.xdata$x:00001BCA                 db    0
.xdata$x:00001BCB                 db    0
.xdata$x:00001BCC                 dd offset __unwindfunclet$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z$2
.xdata$x:00001BD0                 db    2
.xdata$x:00001BD1                 db    0
.xdata$x:00001BD2                 db    0
.xdata$x:00001BD3                 db    0
.xdata$x:00001BD4                 dd offset __unwindfunclet$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z$3
.xdata$x:00001BD8                 db    2
.xdata$x:00001BD9                 db    0
.xdata$x:00001BDA                 db    0
.xdata$x:00001BDB                 db    0
.xdata$x:00001BDC                 dd offset __unwindfunclet$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z$4
.xdata$x:00001BE0                 db    4
.xdata$x:00001BE1                 db    0
.xdata$x:00001BE2                 db    0
.xdata$x:00001BE3                 db    0
.xdata$x:00001BE4                 dd offset __unwindfunclet$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z$5
.xdata$x:00001BE8                 db    4
.xdata$x:00001BE9                 db    0
.xdata$x:00001BEA                 db    0
.xdata$x:00001BEB                 db    0
.xdata$x:00001BEC                 dd offset __unwindfunclet$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z$6
.xdata$x:00001BF0                 db    6
.xdata$x:00001BF1                 db    0
.xdata$x:00001BF2                 db    0
.xdata$x:00001BF3                 db    0
.xdata$x:00001BF4                 dd offset __unwindfunclet$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z$7
.xdata$x:00001BF8                 db    6
.xdata$x:00001BF9                 db    0
.xdata$x:00001BFA                 db    0
.xdata$x:00001BFB                 db    0
.xdata$x:00001BFC                 dd offset __unwindfunclet$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z$8
.xdata$x:00001C00                 db    8
.xdata$x:00001C01                 db    0
.xdata$x:00001C02                 db    0
.xdata$x:00001C03                 db    0
.xdata$x:00001C04                 dd offset __unwindfunclet$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z$9
.xdata$x:00001C08                 db    9
.xdata$x:00001C09                 db    0
.xdata$x:00001C0A                 db    0
.xdata$x:00001C0B                 db    0
.xdata$x:00001C0C                 dd offset __unwindfunclet$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z$10
.xdata$x:00001C10                 db  0Ah
.xdata$x:00001C11                 db    0
.xdata$x:00001C12                 db    0
.xdata$x:00001C13                 db    0
.xdata$x:00001C14                 dd offset __unwindfunclet$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z$11
.xdata$x:00001C18                 db  0Bh
.xdata$x:00001C19                 db    0
.xdata$x:00001C1A                 db    0
.xdata$x:00001C1B                 db    0
.xdata$x:00001C1C                 dd offset __unwindfunclet$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z$12
.xdata$x:00001C20                 db  0Bh
.xdata$x:00001C21                 db    0
.xdata$x:00001C22                 db    0
.xdata$x:00001C23                 db    0
.xdata$x:00001C24                 dd offset __unwindfunclet$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z$13
.xdata$x:00001C24 _xdata$x        ends
.xdata$x:00001C24
.rtc$TMZ:00001C28 ; ===========================================================================
.rtc$TMZ:00001C28
.rtc$TMZ:00001C28 ; Segment type: Pure data
.rtc$TMZ:00001C28 ; Segment permissions: Read
.rtc$TMZ:00001C28 _rtc$TMZ        segment dword public 'DATA' use32
.rtc$TMZ:00001C28                 assume cs:_rtc$TMZ
.rtc$TMZ:00001C28                 ;org 1C28h
.rtc$TMZ:00001C28 ; COMDAT (pick any)
.rtc$TMZ:00001C28 __RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
.rtc$TMZ:00001C28 _rtc$TMZ        ends
.rtc$TMZ:00001C28
.rtc$IMZ:00001C2C ; ===========================================================================
.rtc$IMZ:00001C2C
.rtc$IMZ:00001C2C ; Segment type: Pure data
.rtc$IMZ:00001C2C ; Segment permissions: Read
.rtc$IMZ:00001C2C _rtc$IMZ        segment dword public 'DATA' use32
.rtc$IMZ:00001C2C                 assume cs:_rtc$IMZ
.rtc$IMZ:00001C2C                 ;org 1C2Ch
.rtc$IMZ:00001C2C ; COMDAT (pick any)
.rtc$IMZ:00001C2C __RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
.rtc$IMZ:00001C2C _rtc$IMZ        ends
.rtc$IMZ:00001C2C
.text:00001C30 ; ===========================================================================
.text:00001C30
.text:00001C30 ; Segment type: Pure code
.text:00001C30 ; Segment permissions: Read/Execute
.text:00001C30 _text           segment para public 'CODE' use32
.text:00001C30                 assume cs:_text
.text:00001C30                 ;org 1C30h
.text:00001C30 ; COMDAT (pick any)
.text:00001C30                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00001C30
.text:00001C30 ; =============== S U B R O U T I N E =======================================
.text:00001C30
.text:00001C30 ; Attributes: bp-based frame
.text:00001C30
.text:00001C30 ; void __thiscall CLimitedSequentialInStream::SetStream(CLimitedSequentialInStream *this, struct ISequentialInStream *)
.text:00001C30                 public ?SetStream@CLimitedSequentialInStream@@QAEXPAUISequentialInStream@@@Z
.text:00001C30 ?SetStream@CLimitedSequentialInStream@@QAEXPAUISequentialInStream@@@Z proc near
.text:00001C30                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+2EAp
.text:00001C30
.text:00001C30 var_4           = dword ptr -4
.text:00001C30 arg_0           = dword ptr  8
.text:00001C30
.text:00001C30                 push    ebp
.text:00001C31                 mov     ebp, esp
.text:00001C33                 push    ecx
.text:00001C34                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001C3B                 mov     [ebp+var_4], ecx
.text:00001C3E                 mov     eax, [ebp+arg_0]
.text:00001C41                 push    eax
.text:00001C42                 mov     ecx, [ebp+var_4]
.text:00001C45                 add     ecx, 8
.text:00001C48                 call    ??4?$CMyComPtr@UISequentialInStream@@@@QAEPAUISequentialInStream@@PAU1@@Z ; CMyComPtr<ISequentialInStream>::operator=(ISequentialInStream *)
.text:00001C4D                 add     esp, 4
.text:00001C50                 cmp     ebp, esp
.text:00001C52                 call    __RTC_CheckEsp
.text:00001C57                 mov     esp, ebp
.text:00001C59                 pop     ebp
.text:00001C5A                 retn    4
.text:00001C5A ?SetStream@CLimitedSequentialInStream@@QAEXPAUISequentialInStream@@@Z endp
.text:00001C5A
.text:00001C5A ; ---------------------------------------------------------------------------
.text:00001C5D                 align 10h
.text:00001C5D _text           ends
.text:00001C5D
.text:00001C60 ; ===========================================================================
.text:00001C60
.text:00001C60 ; Segment type: Pure code
.text:00001C60 ; Segment permissions: Read/Execute
.text:00001C60 _text           segment para public 'CODE' use32
.text:00001C60                 assume cs:_text
.text:00001C60                 ;org 1C60h
.text:00001C60 ; COMDAT (pick any)
.text:00001C60                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00001C60
.text:00001C60 ; =============== S U B R O U T I N E =======================================
.text:00001C60
.text:00001C60 ; Attributes: bp-based frame
.text:00001C60
.text:00001C60 ; void __thiscall CLimitedSequentialInStream::Init(CLimitedSequentialInStream *this, unsigned __int64)
.text:00001C60                 public ?Init@CLimitedSequentialInStream@@QAEX_K@Z
.text:00001C60 ?Init@CLimitedSequentialInStream@@QAEX_K@Z proc near
.text:00001C60                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+1528p
.text:00001C60
.text:00001C60 var_4           = dword ptr -4
.text:00001C60 arg_0           = qword ptr  8
.text:00001C60
.text:00001C60                 push    ebp
.text:00001C61                 mov     ebp, esp
.text:00001C63                 push    ecx
.text:00001C64                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001C6B                 mov     [ebp+var_4], ecx
.text:00001C6E                 mov     eax, [ebp+var_4]
.text:00001C71                 mov     ecx, dword ptr [ebp+arg_0]
.text:00001C74                 mov     [eax+10h], ecx
.text:00001C77                 mov     edx, dword ptr [ebp+arg_0+4]
.text:00001C7A                 mov     [eax+14h], edx
.text:00001C7D                 mov     eax, [ebp+var_4]
.text:00001C80                 mov     dword ptr [eax+18h], 0
.text:00001C87                 mov     dword ptr [eax+1Ch], 0
.text:00001C8E                 mov     ecx, [ebp+var_4]
.text:00001C91                 mov     byte ptr [ecx+20h], 0
.text:00001C95                 mov     esp, ebp
.text:00001C97                 pop     ebp
.text:00001C98                 retn    8
.text:00001C98 ?Init@CLimitedSequentialInStream@@QAEX_K@Z endp
.text:00001C98
.text:00001C98 ; ---------------------------------------------------------------------------
.text:00001C9B                 align 4
.text:00001C9B _text           ends
.text:00001C9B
.text:00001C9C ; ===========================================================================
.text:00001C9C
.text:00001C9C ; Segment type: Pure code
.text:00001C9C ; Segment permissions: Read/Execute
.text:00001C9C _text           segment para public 'CODE' use32
.text:00001C9C                 assume cs:_text
.text:00001C9C                 ;org 1C9Ch
.text:00001C9C ; COMDAT (pick any)
.text:00001C9C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00001C9C
.text:00001C9C ; =============== S U B R O U T I N E =======================================
.text:00001C9C
.text:00001C9C ; Attributes: bp-based frame
.text:00001C9C
.text:00001C9C ; _DWORD __thiscall NCompress::CCopyCoder::CCopyCoder(NCompress::CCopyCoder *__hidden this)
.text:00001C9C                 public ??0CCopyCoder@NCompress@@QAE@XZ
.text:00001C9C ??0CCopyCoder@NCompress@@QAE@XZ proc near
.text:00001C9C                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+1CFp
.text:00001C9C
.text:00001C9C var_4           = dword ptr -4
.text:00001C9C
.text:00001C9C                 push    ebp
.text:00001C9D                 mov     ebp, esp
.text:00001C9F                 push    ecx
.text:00001CA0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001CA7                 mov     [ebp+var_4], ecx
.text:00001CAA                 mov     ecx, [ebp+var_4] ; this
.text:00001CAD                 call    ??0ICompressCoder@@QAE@XZ ; ICompressCoder::ICompressCoder(void)
.text:00001CB2                 mov     ecx, [ebp+var_4]
.text:00001CB5                 add     ecx, 4          ; this
.text:00001CB8                 call    ??0ICompressSetInStream@@QAE@XZ ; ICompressSetInStream::ICompressSetInStream(void)
.text:00001CBD                 mov     ecx, [ebp+var_4]
.text:00001CC0                 add     ecx, 8          ; this
.text:00001CC3                 call    ??0ISequentialInStream@@QAE@XZ ; ISequentialInStream::ISequentialInStream(void)
.text:00001CC8                 mov     ecx, [ebp+var_4]
.text:00001CCB                 add     ecx, 0Ch        ; this
.text:00001CCE                 call    ??0ICompressGetInStreamProcessedSize@@QAE@XZ ; ICompressGetInStreamProcessedSize::ICompressGetInStreamProcessedSize(void)
.text:00001CD3                 mov     ecx, [ebp+var_4]
.text:00001CD6                 add     ecx, 10h        ; this
.text:00001CD9                 call    ??0CMyUnknownImp@@QAE@XZ ; CMyUnknownImp::CMyUnknownImp(void)
.text:00001CDE                 mov     eax, [ebp+var_4]
.text:00001CE1                 mov     dword ptr [eax], offset ??_7CCopyCoder@NCompress@@6BICompressCoder@@@ ; const NCompress::CCopyCoder::`vftable'{for `ICompressCoder'}
.text:00001CE7                 mov     ecx, [ebp+var_4]
.text:00001CEA                 mov     dword ptr [ecx+4], offset ??_7CCopyCoder@NCompress@@6BICompressSetInStream@@@ ; const NCompress::CCopyCoder::`vftable'{for `ICompressSetInStream'}
.text:00001CF1                 mov     edx, [ebp+var_4]
.text:00001CF4                 mov     dword ptr [edx+8], offset ??_7CCopyCoder@NCompress@@6BISequentialInStream@@@ ; const NCompress::CCopyCoder::`vftable'{for `ISequentialInStream'}
.text:00001CFB                 mov     eax, [ebp+var_4]
.text:00001CFE                 mov     dword ptr [eax+0Ch], offset ??_7CCopyCoder@NCompress@@6BICompressGetInStreamProcessedSize@@@ ; const NCompress::CCopyCoder::`vftable'{for `ICompressGetInStreamProcessedSize'}
.text:00001D05                 mov     ecx, [ebp+var_4]
.text:00001D08                 mov     dword ptr [ecx+14h], 0
.text:00001D0F                 mov     ecx, [ebp+var_4]
.text:00001D12                 add     ecx, 18h
.text:00001D15                 call    ??0?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::CMyComPtr<ISequentialInStream>(void)
.text:00001D1A                 mov     edx, [ebp+var_4]
.text:00001D1D                 mov     dword ptr [edx+20h], 0
.text:00001D24                 mov     dword ptr [edx+24h], 0
.text:00001D2B                 mov     eax, [ebp+var_4]
.text:00001D2E                 add     esp, 4
.text:00001D31                 cmp     ebp, esp
.text:00001D33                 call    __RTC_CheckEsp
.text:00001D38                 mov     esp, ebp
.text:00001D3A                 pop     ebp
.text:00001D3B                 retn
.text:00001D3B ??0CCopyCoder@NCompress@@QAE@XZ endp
.text:00001D3B
.text:00001D3B _text           ends
.text:00001D3B
.rdata:00001D3C ; ===========================================================================
.rdata:00001D3C
.rdata:00001D3C ; Segment type: Pure data
.rdata:00001D3C ; Segment permissions: Read
.rdata:00001D3C _rdata          segment dword public 'DATA' use32
.rdata:00001D3C                 assume cs:_rdata
.rdata:00001D3C                 ;org 1D3Ch
.rdata:00001D3C ; COMDAT (pick largest)
.rdata:00001D3C                 dd offset ??_R4CCopyCoder@NCompress@@6BICompressGetInStreamProcessedSize@@@ ; const NCompress::CCopyCoder::`RTTI Complete Object Locator'{for `ICompressGetInStreamProcessedSize'}
.rdata:00001D40                 public ??_7CCopyCoder@NCompress@@6BICompressGetInStreamProcessedSize@@@
.rdata:00001D40 ; const NCompress::CCopyCoder::`vftable'{for `ICompressGetInStreamProcessedSize'}
.rdata:00001D40 ??_7CCopyCoder@NCompress@@6BICompressGetInStreamProcessedSize@@@ dd offset ?QueryInterface@CCopyCoder@NCompress@@WM@AGJABU_GUID@@PAPAX@Z
.rdata:00001D40                                         ; DATA XREF: NCompress::CCopyCoder::CCopyCoder(void)+62o
.rdata:00001D40                                         ; [thunk]:NCompress::CCopyCoder::QueryInterface`adjustor{12}' (_GUID const &,void * *)
.rdata:00001D44                 dd offset ?AddRef@CCopyCoder@NCompress@@WM@AGKXZ ; [thunk]:NCompress::CCopyCoder::AddRef`adjustor{12}' (void)
.rdata:00001D48                 dd offset ?Release@CCopyCoder@NCompress@@WM@AGKXZ ; [thunk]:NCompress::CCopyCoder::Release`adjustor{12}' (void)
.rdata:00001D4C                 dd offset ?GetInStreamProcessedSize@CCopyCoder@NCompress@@UAGJPA_K@Z ; NCompress::CCopyCoder::GetInStreamProcessedSize(unsigned __int64 *)
.rdata:00001D4C _rdata          ends
.rdata:00001D4C
.rdata:00001D50 ; ===========================================================================
.rdata:00001D50
.rdata:00001D50 ; Segment type: Pure data
.rdata:00001D50 ; Segment permissions: Read
.rdata:00001D50 _rdata          segment dword public 'DATA' use32
.rdata:00001D50                 assume cs:_rdata
.rdata:00001D50                 ;org 1D50h
.rdata:00001D50 ; COMDAT (pick largest)
.rdata:00001D50                 dd offset ??_R4CCopyCoder@NCompress@@6BISequentialInStream@@@ ; const NCompress::CCopyCoder::`RTTI Complete Object Locator'{for `ISequentialInStream'}
.rdata:00001D54                 public ??_7CCopyCoder@NCompress@@6BISequentialInStream@@@
.rdata:00001D54 ; const NCompress::CCopyCoder::`vftable'{for `ISequentialInStream'}
.rdata:00001D54 ??_7CCopyCoder@NCompress@@6BISequentialInStream@@@ dd offset ?QueryInterface@CCopyCoder@NCompress@@W7AGJABU_GUID@@PAPAX@Z
.rdata:00001D54                                         ; DATA XREF: NCompress::CCopyCoder::CCopyCoder(void)+58o
.rdata:00001D54                                         ; [thunk]:NCompress::CCopyCoder::QueryInterface`adjustor{8}' (_GUID const &,void * *)
.rdata:00001D58                 dd offset ?AddRef@CCopyCoder@NCompress@@W7AGKXZ ; [thunk]:NCompress::CCopyCoder::AddRef`adjustor{8}' (void)
.rdata:00001D5C                 dd offset ?Release@CCopyCoder@NCompress@@W7AGKXZ ; [thunk]:NCompress::CCopyCoder::Release`adjustor{8}' (void)
.rdata:00001D60                 dd offset ?Read@CCopyCoder@NCompress@@UAGJPAXIPAI@Z ; NCompress::CCopyCoder::Read(void *,uint,uint *)
.rdata:00001D60 _rdata          ends
.rdata:00001D60
.rdata:00001D64 ; ===========================================================================
.rdata:00001D64
.rdata:00001D64 ; Segment type: Pure data
.rdata:00001D64 ; Segment permissions: Read
.rdata:00001D64 _rdata          segment dword public 'DATA' use32
.rdata:00001D64                 assume cs:_rdata
.rdata:00001D64                 ;org 1D64h
.rdata:00001D64 ; COMDAT (pick largest)
.rdata:00001D64                 dd offset ??_R4CCopyCoder@NCompress@@6BICompressSetInStream@@@ ; const NCompress::CCopyCoder::`RTTI Complete Object Locator'{for `ICompressSetInStream'}
.rdata:00001D68                 public ??_7CCopyCoder@NCompress@@6BICompressSetInStream@@@
.rdata:00001D68 ; const NCompress::CCopyCoder::`vftable'{for `ICompressSetInStream'}
.rdata:00001D68 ??_7CCopyCoder@NCompress@@6BICompressSetInStream@@@ dd offset ?QueryInterface@CCopyCoder@NCompress@@W3AGJABU_GUID@@PAPAX@Z
.rdata:00001D68                                         ; DATA XREF: NCompress::CCopyCoder::CCopyCoder(void)+4Eo
.rdata:00001D68                                         ; [thunk]:NCompress::CCopyCoder::QueryInterface`adjustor{4}' (_GUID const &,void * *)
.rdata:00001D6C                 dd offset ?AddRef@CCopyCoder@NCompress@@W3AGKXZ ; [thunk]:NCompress::CCopyCoder::AddRef`adjustor{4}' (void)
.rdata:00001D70                 dd offset ?Release@CCopyCoder@NCompress@@W3AGKXZ ; [thunk]:NCompress::CCopyCoder::Release`adjustor{4}' (void)
.rdata:00001D74                 dd offset ?SetInStream@CCopyCoder@NCompress@@UAGJPAUISequentialInStream@@@Z ; NCompress::CCopyCoder::SetInStream(ISequentialInStream *)
.rdata:00001D78                 dd offset ?ReleaseInStream@CCopyCoder@NCompress@@UAGJXZ ; NCompress::CCopyCoder::ReleaseInStream(void)
.rdata:00001D78 _rdata          ends
.rdata:00001D78
.rdata:00001D7C ; ===========================================================================
.rdata:00001D7C
.rdata:00001D7C ; Segment type: Pure data
.rdata:00001D7C ; Segment permissions: Read
.rdata:00001D7C _rdata          segment dword public 'DATA' use32
.rdata:00001D7C                 assume cs:_rdata
.rdata:00001D7C                 ;org 1D7Ch
.rdata:00001D7C ; COMDAT (pick largest)
.rdata:00001D7C                 dd offset ??_R4CCopyCoder@NCompress@@6BICompressCoder@@@ ; const NCompress::CCopyCoder::`RTTI Complete Object Locator'{for `ICompressCoder'}
.rdata:00001D80                 public ??_7CCopyCoder@NCompress@@6BICompressCoder@@@
.rdata:00001D80 ; const NCompress::CCopyCoder::`vftable'{for `ICompressCoder'}
.rdata:00001D80 ??_7CCopyCoder@NCompress@@6BICompressCoder@@@ dd offset ?QueryInterface@CCopyCoder@NCompress@@UAGJABU_GUID@@PAPAX@Z
.rdata:00001D80                                         ; DATA XREF: NCompress::CCopyCoder::CCopyCoder(void)+45o
.rdata:00001D80                                         ; NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *)
.rdata:00001D84                 dd offset ?AddRef@CCopyCoder@NCompress@@UAGKXZ ; NCompress::CCopyCoder::AddRef(void)
.rdata:00001D88                 dd offset ?Release@CCopyCoder@NCompress@@UAGKXZ ; NCompress::CCopyCoder::Release(void)
.rdata:00001D8C                 dd offset ?Code@CCopyCoder@NCompress@@UAGJPAUISequentialInStream@@PAUISequentialOutStream@@PB_K2PAUICompressProgressInfo@@@Z ; NCompress::CCopyCoder::Code(ISequentialInStream *,ISequentialOutStream *,unsigned __int64 const *,unsigned __int64 const *,ICompressProgressInfo *)
.rdata:00001D8C _rdata          ends
.rdata:00001D8C
.rdata$r:00001D90 ; ===========================================================================
.rdata$r:00001D90
.rdata$r:00001D90 ; Segment type: Pure data
.rdata$r:00001D90 ; Segment permissions: Read
.rdata$r:00001D90 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001D90                 assume cs:_rdata$r
.rdata$r:00001D90                 ;org 1D90h
.rdata$r:00001D90 ; COMDAT (pick any)
.rdata$r:00001D90                 public ??_R4CCopyCoder@NCompress@@6BICompressCoder@@@
.rdata$r:00001D90 ; const NCompress::CCopyCoder::`RTTI Complete Object Locator'{for `ICompressCoder'}
.rdata$r:00001D90 ??_R4CCopyCoder@NCompress@@6BICompressCoder@@@ db    0
.rdata$r:00001D90                                         ; DATA XREF: .rdata:00001D7Co
.rdata$r:00001D91                 db    0
.rdata$r:00001D92                 db    0
.rdata$r:00001D93                 db    0
.rdata$r:00001D94                 db    0
.rdata$r:00001D95                 db    0
.rdata$r:00001D96                 db    0
.rdata$r:00001D97                 db    0
.rdata$r:00001D98                 db    0
.rdata$r:00001D99                 db    0
.rdata$r:00001D9A                 db    0
.rdata$r:00001D9B                 db    0
.rdata$r:00001D9C                 dd offset ??_R0?AVCCopyCoder@NCompress@@@8 ; NCompress::CCopyCoder `RTTI Type Descriptor'
.rdata$r:00001DA0                 dd offset ??_R3CCopyCoder@NCompress@@8 ; NCompress::CCopyCoder::`RTTI Class Hierarchy Descriptor'
.rdata$r:00001DA0 _rdata$r        ends
.rdata$r:00001DA0
.data:00001DA4 ; ===========================================================================
.data:00001DA4
.data:00001DA4 ; Segment type: Pure data
.data:00001DA4 ; Segment permissions: Read/Write
.data:00001DA4 _data           segment dword public 'DATA' use32
.data:00001DA4                 assume cs:_data
.data:00001DA4                 ;org 1DA4h
.data:00001DA4 ; COMDAT (pick any)
.data:00001DA4                 public ??_R0?AVCCopyCoder@NCompress@@@8
.data:00001DA4 ; class NCompress::CCopyCoder `RTTI Type Descriptor'
.data:00001DA4 ??_R0?AVCCopyCoder@NCompress@@@8 dd offset ??_7type_info@@6B@
.data:00001DA4                                         ; DATA XREF: .rdata$r:00001D9Co
.data:00001DA4                                         ; .rdata$r:NCompress::CCopyCoder::`RTTI Base Class Descriptor at (0,-1,0,64)'o ...
.data:00001DA4                                         ; const type_info::`vftable'
.data:00001DA8                 db    0
.data:00001DA9                 db    0
.data:00001DAA                 db    0
.data:00001DAB                 db    0
.data:00001DAC                 db  2Eh ; .
.data:00001DAD                 db  3Fh ; ?
.data:00001DAE                 db  41h ; A
.data:00001DAF                 db  56h ; V
.data:00001DB0                 db  43h ; C
.data:00001DB1                 db  43h ; C
.data:00001DB2                 db  6Fh ; o
.data:00001DB3                 db  70h ; p
.data:00001DB4                 db  79h ; y
.data:00001DB5                 db  43h ; C
.data:00001DB6                 db  6Fh ; o
.data:00001DB7                 db  64h ; d
.data:00001DB8                 db  65h ; e
.data:00001DB9                 db  72h ; r
.data:00001DBA                 db  40h ; @
.data:00001DBB                 db  4Eh ; N
.data:00001DBC                 db  43h ; C
.data:00001DBD                 db  6Fh ; o
.data:00001DBE                 db  6Dh ; m
.data:00001DBF                 db  70h ; p
.data:00001DC0                 db  72h ; r
.data:00001DC1                 db  65h ; e
.data:00001DC2                 db  73h ; s
.data:00001DC3                 db  73h ; s
.data:00001DC4                 db  40h ; @
.data:00001DC5                 db  40h ; @
.data:00001DC6                 db    0
.data:00001DC7                 align 4
.data:00001DC7 _data           ends
.data:00001DC7
.rdata$r:00001DC8 ; ===========================================================================
.rdata$r:00001DC8
.rdata$r:00001DC8 ; Segment type: Pure data
.rdata$r:00001DC8 ; Segment permissions: Read
.rdata$r:00001DC8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001DC8                 assume cs:_rdata$r
.rdata$r:00001DC8                 ;org 1DC8h
.rdata$r:00001DC8 ; COMDAT (pick any)
.rdata$r:00001DC8                 public ??_R3CCopyCoder@NCompress@@8
.rdata$r:00001DC8 ; NCompress::CCopyCoder::`RTTI Class Hierarchy Descriptor'
.rdata$r:00001DC8 ??_R3CCopyCoder@NCompress@@8 db    0    ; DATA XREF: .rdata$r:00001DA0o
.rdata$r:00001DC8                                         ; .rdata$r:00001E1Co ...
.rdata$r:00001DC9                 db    0
.rdata$r:00001DCA                 db    0
.rdata$r:00001DCB                 db    0
.rdata$r:00001DCC                 db    5
.rdata$r:00001DCD                 db    0
.rdata$r:00001DCE                 db    0
.rdata$r:00001DCF                 db    0
.rdata$r:00001DD0                 db  0Ah
.rdata$r:00001DD1                 db    0
.rdata$r:00001DD2                 db    0
.rdata$r:00001DD3                 db    0
.rdata$r:00001DD4                 dd offset ??_R2CCopyCoder@NCompress@@8 ; NCompress::CCopyCoder::`RTTI Base Class Array'
.rdata$r:00001DD4 _rdata$r        ends
.rdata$r:00001DD4
.rdata$r:00001DD8 ; ===========================================================================
.rdata$r:00001DD8
.rdata$r:00001DD8 ; Segment type: Pure data
.rdata$r:00001DD8 ; Segment permissions: Read
.rdata$r:00001DD8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001DD8                 assume cs:_rdata$r
.rdata$r:00001DD8                 ;org 1DD8h
.rdata$r:00001DD8 ; COMDAT (pick any)
.rdata$r:00001DD8                 public ??_R2CCopyCoder@NCompress@@8
.rdata$r:00001DD8 ; NCompress::CCopyCoder::`RTTI Base Class Array'
.rdata$r:00001DD8 ??_R2CCopyCoder@NCompress@@8 dd offset ??_R1A@?0A@EA@CCopyCoder@NCompress@@8
.rdata$r:00001DD8                                         ; DATA XREF: .rdata$r:00001DD4o
.rdata$r:00001DD8                                         ; NCompress::CCopyCoder::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00001DDC                 dd offset ??_R1A@?0A@EA@ICompressCoder@@8 ; ICompressCoder::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00001DE0                 dd offset ??_R1A@?0A@EC@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,66)'
.rdata$r:00001DE4                 dd offset ??_R13?0A@EA@ICompressSetInStream@@8 ; ICompressSetInStream::`RTTI Base Class Descriptor at (4,-1,0,64)'
.rdata$r:00001DE8                 dd offset ??_R13?0A@EC@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (4,-1,0,66)'
.rdata$r:00001DEC                 dd offset ??_R17?0A@EA@ISequentialInStream@@8 ; ISequentialInStream::`RTTI Base Class Descriptor at (8,-1,0,64)'
.rdata$r:00001DF0                 dd offset ??_R17?0A@EC@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (8,-1,0,66)'
.rdata$r:00001DF4                 dd offset ??_R1M@?0A@EA@ICompressGetInStreamProcessedSize@@8 ; ICompressGetInStreamProcessedSize::`RTTI Base Class Descriptor at (12,-1,0,64)'
.rdata$r:00001DF8                 dd offset ??_R1M@?0A@EC@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (12,-1,0,66)'
.rdata$r:00001DFC                 dd offset ??_R1BA@?0A@EA@CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Base Class Descriptor at (16,-1,0,64)'
.rdata$r:00001E00                 db    0
.rdata$r:00001E01                 align 4
.rdata$r:00001E01 _rdata$r        ends
.rdata$r:00001E01
.rdata$r:00001E04 ; ===========================================================================
.rdata$r:00001E04
.rdata$r:00001E04 ; Segment type: Pure data
.rdata$r:00001E04 ; Segment permissions: Read
.rdata$r:00001E04 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001E04                 assume cs:_rdata$r
.rdata$r:00001E04                 ;org 1E04h
.rdata$r:00001E04 ; COMDAT (pick any)
.rdata$r:00001E04                 public ??_R1A@?0A@EA@CCopyCoder@NCompress@@8
.rdata$r:00001E04 ; NCompress::CCopyCoder::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00001E04 ??_R1A@?0A@EA@CCopyCoder@NCompress@@8 dd offset ??_R0?AVCCopyCoder@NCompress@@@8
.rdata$r:00001E04                                         ; DATA XREF: .rdata$r:NCompress::CCopyCoder::`RTTI Base Class Array'o
.rdata$r:00001E04                                         ; NCompress::CCopyCoder `RTTI Type Descriptor'
.rdata$r:00001E08                 db    9
.rdata$r:00001E09                 db    0
.rdata$r:00001E0A                 db    0
.rdata$r:00001E0B                 db    0
.rdata$r:00001E0C                 db    0
.rdata$r:00001E0D                 db    0
.rdata$r:00001E0E                 db    0
.rdata$r:00001E0F                 db    0
.rdata$r:00001E10                 db 0FFh
.rdata$r:00001E11                 db 0FFh
.rdata$r:00001E12                 db 0FFh
.rdata$r:00001E13                 db 0FFh
.rdata$r:00001E14                 db    0
.rdata$r:00001E15                 db    0
.rdata$r:00001E16                 db    0
.rdata$r:00001E17                 db    0
.rdata$r:00001E18                 db  40h ; @
.rdata$r:00001E19                 db    0
.rdata$r:00001E1A                 db    0
.rdata$r:00001E1B                 db    0
.rdata$r:00001E1C                 dd offset ??_R3CCopyCoder@NCompress@@8 ; NCompress::CCopyCoder::`RTTI Class Hierarchy Descriptor'
.rdata$r:00001E1C _rdata$r        ends
.rdata$r:00001E1C
.rdata$r:00001E20 ; ===========================================================================
.rdata$r:00001E20
.rdata$r:00001E20 ; Segment type: Pure data
.rdata$r:00001E20 ; Segment permissions: Read
.rdata$r:00001E20 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001E20                 assume cs:_rdata$r
.rdata$r:00001E20                 ;org 1E20h
.rdata$r:00001E20 ; COMDAT (pick any)
.rdata$r:00001E20                 public ??_R1A@?0A@EA@ICompressCoder@@8
.rdata$r:00001E20 ; ICompressCoder::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00001E20 ??_R1A@?0A@EA@ICompressCoder@@8 dd offset ??_R0?AUICompressCoder@@@8
.rdata$r:00001E20                                         ; DATA XREF: .rdata$r:00001DDCo
.rdata$r:00001E20                                         ; .rdata$r:ICompressCoder::`RTTI Base Class Array'o
.rdata$r:00001E20                                         ; ICompressCoder `RTTI Type Descriptor'
.rdata$r:00001E24                 db    1
.rdata$r:00001E25                 db    0
.rdata$r:00001E26                 db    0
.rdata$r:00001E27                 db    0
.rdata$r:00001E28                 db    0
.rdata$r:00001E29                 db    0
.rdata$r:00001E2A                 db    0
.rdata$r:00001E2B                 db    0
.rdata$r:00001E2C                 db 0FFh
.rdata$r:00001E2D                 db 0FFh
.rdata$r:00001E2E                 db 0FFh
.rdata$r:00001E2F                 db 0FFh
.rdata$r:00001E30                 db    0
.rdata$r:00001E31                 db    0
.rdata$r:00001E32                 db    0
.rdata$r:00001E33                 db    0
.rdata$r:00001E34                 db  40h ; @
.rdata$r:00001E35                 db    0
.rdata$r:00001E36                 db    0
.rdata$r:00001E37                 db    0
.rdata$r:00001E38                 dd offset ??_R3ICompressCoder@@8 ; ICompressCoder::`RTTI Class Hierarchy Descriptor'
.rdata$r:00001E38 _rdata$r        ends
.rdata$r:00001E38
.data:00001E3C ; ===========================================================================
.data:00001E3C
.data:00001E3C ; Segment type: Pure data
.data:00001E3C ; Segment permissions: Read/Write
.data:00001E3C _data           segment dword public 'DATA' use32
.data:00001E3C                 assume cs:_data
.data:00001E3C                 ;org 1E3Ch
.data:00001E3C ; COMDAT (pick any)
.data:00001E3C                 public ??_R0?AUICompressCoder@@@8
.data:00001E3C ; struct ICompressCoder `RTTI Type Descriptor'
.data:00001E3C ??_R0?AUICompressCoder@@@8 dd offset ??_7type_info@@6B@
.data:00001E3C                                         ; DATA XREF: .rdata$r:ICompressCoder::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:00001E3C                                         ; .rdata$r:000023CCo
.data:00001E3C                                         ; const type_info::`vftable'
.data:00001E40                 db    0
.data:00001E41                 db    0
.data:00001E42                 db    0
.data:00001E43                 db    0
.data:00001E44                 db  2Eh ; .
.data:00001E45                 db  3Fh ; ?
.data:00001E46                 db  41h ; A
.data:00001E47                 db  55h ; U
.data:00001E48                 db  49h ; I
.data:00001E49                 db  43h ; C
.data:00001E4A                 db  6Fh ; o
.data:00001E4B                 db  6Dh ; m
.data:00001E4C                 db  70h ; p
.data:00001E4D                 db  72h ; r
.data:00001E4E                 db  65h ; e
.data:00001E4F                 db  73h ; s
.data:00001E50                 db  73h ; s
.data:00001E51                 db  43h ; C
.data:00001E52                 db  6Fh ; o
.data:00001E53                 db  64h ; d
.data:00001E54                 db  65h ; e
.data:00001E55                 db  72h ; r
.data:00001E56                 db  40h ; @
.data:00001E57                 db  40h ; @
.data:00001E58                 db    0
.data:00001E59                 align 4
.data:00001E59 _data           ends
.data:00001E59
.rdata$r:00001E5C ; ===========================================================================
.rdata$r:00001E5C
.rdata$r:00001E5C ; Segment type: Pure data
.rdata$r:00001E5C ; Segment permissions: Read
.rdata$r:00001E5C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001E5C                 assume cs:_rdata$r
.rdata$r:00001E5C                 ;org 1E5Ch
.rdata$r:00001E5C ; COMDAT (pick any)
.rdata$r:00001E5C                 public ??_R3ICompressCoder@@8
.rdata$r:00001E5C ; ICompressCoder::`RTTI Class Hierarchy Descriptor'
.rdata$r:00001E5C ??_R3ICompressCoder@@8 db    0          ; DATA XREF: .rdata$r:00001E38o
.rdata$r:00001E5C                                         ; .rdata$r:000023D0o
.rdata$r:00001E5D                 db    0
.rdata$r:00001E5E                 db    0
.rdata$r:00001E5F                 db    0
.rdata$r:00001E60                 db    0
.rdata$r:00001E61                 db    0
.rdata$r:00001E62                 db    0
.rdata$r:00001E63                 db    0
.rdata$r:00001E64                 db    2
.rdata$r:00001E65                 db    0
.rdata$r:00001E66                 db    0
.rdata$r:00001E67                 db    0
.rdata$r:00001E68                 dd offset ??_R2ICompressCoder@@8 ; ICompressCoder::`RTTI Base Class Array'
.rdata$r:00001E68 _rdata$r        ends
.rdata$r:00001E68
.rdata$r:00001E6C ; ===========================================================================
.rdata$r:00001E6C
.rdata$r:00001E6C ; Segment type: Pure data
.rdata$r:00001E6C ; Segment permissions: Read
.rdata$r:00001E6C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001E6C                 assume cs:_rdata$r
.rdata$r:00001E6C                 ;org 1E6Ch
.rdata$r:00001E6C ; COMDAT (pick any)
.rdata$r:00001E6C                 public ??_R2ICompressCoder@@8
.rdata$r:00001E6C ; ICompressCoder::`RTTI Base Class Array'
.rdata$r:00001E6C ??_R2ICompressCoder@@8 dd offset ??_R1A@?0A@EA@ICompressCoder@@8
.rdata$r:00001E6C                                         ; DATA XREF: .rdata$r:00001E68o
.rdata$r:00001E6C                                         ; ICompressCoder::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00001E70                 dd offset ??_R1A@?0A@EA@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00001E74                 db    0
.rdata$r:00001E75                 align 4
.rdata$r:00001E75 _rdata$r        ends
.rdata$r:00001E75
.rdata$r:00001E78 ; ===========================================================================
.rdata$r:00001E78
.rdata$r:00001E78 ; Segment type: Pure data
.rdata$r:00001E78 ; Segment permissions: Read
.rdata$r:00001E78 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001E78                 assume cs:_rdata$r
.rdata$r:00001E78                 ;org 1E78h
.rdata$r:00001E78 ; COMDAT (pick any)
.rdata$r:00001E78                 public ??_R1A@?0A@EA@IUnknown@@8
.rdata$r:00001E78 ; IUnknown::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00001E78 ??_R1A@?0A@EA@IUnknown@@8 dd offset ??_R0?AUIUnknown@@@8
.rdata$r:00001E78                                         ; DATA XREF: .rdata$r:00001E70o
.rdata$r:00001E78                                         ; .rdata$r:IUnknown::`RTTI Base Class Array'o ...
.rdata$r:00001E78                                         ; IUnknown `RTTI Type Descriptor'
.rdata$r:00001E7C                 db    0
.rdata$r:00001E7D                 db    0
.rdata$r:00001E7E                 db    0
.rdata$r:00001E7F                 db    0
.rdata$r:00001E80                 db    0
.rdata$r:00001E81                 db    0
.rdata$r:00001E82                 db    0
.rdata$r:00001E83                 db    0
.rdata$r:00001E84                 db 0FFh
.rdata$r:00001E85                 db 0FFh
.rdata$r:00001E86                 db 0FFh
.rdata$r:00001E87                 db 0FFh
.rdata$r:00001E88                 db    0
.rdata$r:00001E89                 db    0
.rdata$r:00001E8A                 db    0
.rdata$r:00001E8B                 db    0
.rdata$r:00001E8C                 db  40h ; @
.rdata$r:00001E8D                 db    0
.rdata$r:00001E8E                 db    0
.rdata$r:00001E8F                 db    0
.rdata$r:00001E90                 dd offset ??_R3IUnknown@@8 ; IUnknown::`RTTI Class Hierarchy Descriptor'
.rdata$r:00001E90 _rdata$r        ends
.rdata$r:00001E90
.data:00001E94 ; ===========================================================================
.data:00001E94
.data:00001E94 ; Segment type: Pure data
.data:00001E94 ; Segment permissions: Read/Write
.data:00001E94 _data           segment dword public 'DATA' use32
.data:00001E94                 assume cs:_data
.data:00001E94                 ;org 1E94h
.data:00001E94 ; COMDAT (pick any)
.data:00001E94                 public ??_R0?AUIUnknown@@@8
.data:00001E94 ; struct IUnknown `RTTI Type Descriptor'
.data:00001E94 ??_R0?AUIUnknown@@@8 dd offset ??_7type_info@@6B@
.data:00001E94                                         ; DATA XREF: .rdata$r:IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:00001E94                                         ; .rdata$r:IUnknown::`RTTI Base Class Descriptor at (0,-1,0,66)'o ...
.data:00001E94                                         ; const type_info::`vftable'
.data:00001E98                 db    0
.data:00001E99                 db    0
.data:00001E9A                 db    0
.data:00001E9B                 db    0
.data:00001E9C                 db  2Eh ; .
.data:00001E9D                 db  3Fh ; ?
.data:00001E9E                 db  41h ; A
.data:00001E9F                 db  55h ; U
.data:00001EA0                 db  49h ; I
.data:00001EA1                 db  55h ; U
.data:00001EA2                 db  6Eh ; n
.data:00001EA3                 db  6Bh ; k
.data:00001EA4                 db  6Eh ; n
.data:00001EA5                 db  6Fh ; o
.data:00001EA6                 db  77h ; w
.data:00001EA7                 db  6Eh ; n
.data:00001EA8                 db  40h ; @
.data:00001EA9                 db  40h ; @
.data:00001EAA                 db    0
.data:00001EAB                 align 4
.data:00001EAB _data           ends
.data:00001EAB
.rdata$r:00001EAC ; ===========================================================================
.rdata$r:00001EAC
.rdata$r:00001EAC ; Segment type: Pure data
.rdata$r:00001EAC ; Segment permissions: Read
.rdata$r:00001EAC _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001EAC                 assume cs:_rdata$r
.rdata$r:00001EAC                 ;org 1EACh
.rdata$r:00001EAC ; COMDAT (pick any)
.rdata$r:00001EAC                 public ??_R3IUnknown@@8
.rdata$r:00001EAC ; IUnknown::`RTTI Class Hierarchy Descriptor'
.rdata$r:00001EAC ??_R3IUnknown@@8 db    0                ; DATA XREF: .rdata$r:00001E90o
.rdata$r:00001EAC                                         ; .rdata$r:00001EDCo ...
.rdata$r:00001EAD                 db    0
.rdata$r:00001EAE                 db    0
.rdata$r:00001EAF                 db    0
.rdata$r:00001EB0                 db    0
.rdata$r:00001EB1                 db    0
.rdata$r:00001EB2                 db    0
.rdata$r:00001EB3                 db    0
.rdata$r:00001EB4                 db    1
.rdata$r:00001EB5                 db    0
.rdata$r:00001EB6                 db    0
.rdata$r:00001EB7                 db    0
.rdata$r:00001EB8                 dd offset ??_R2IUnknown@@8 ; IUnknown::`RTTI Base Class Array'
.rdata$r:00001EB8 _rdata$r        ends
.rdata$r:00001EB8
.rdata$r:00001EBC ; ===========================================================================
.rdata$r:00001EBC
.rdata$r:00001EBC ; Segment type: Pure data
.rdata$r:00001EBC ; Segment permissions: Read
.rdata$r:00001EBC _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001EBC                 assume cs:_rdata$r
.rdata$r:00001EBC                 ;org 1EBCh
.rdata$r:00001EBC ; COMDAT (pick any)
.rdata$r:00001EBC                 public ??_R2IUnknown@@8
.rdata$r:00001EBC ; IUnknown::`RTTI Base Class Array'
.rdata$r:00001EBC ??_R2IUnknown@@8 dd offset ??_R1A@?0A@EA@IUnknown@@8
.rdata$r:00001EBC                                         ; DATA XREF: .rdata$r:00001EB8o
.rdata$r:00001EBC                                         ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00001EC0                 db    0
.rdata$r:00001EC1                 align 4
.rdata$r:00001EC1 _rdata$r        ends
.rdata$r:00001EC1
.rdata$r:00001EC4 ; ===========================================================================
.rdata$r:00001EC4
.rdata$r:00001EC4 ; Segment type: Pure data
.rdata$r:00001EC4 ; Segment permissions: Read
.rdata$r:00001EC4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001EC4                 assume cs:_rdata$r
.rdata$r:00001EC4                 ;org 1EC4h
.rdata$r:00001EC4 ; COMDAT (pick any)
.rdata$r:00001EC4                 public ??_R1A@?0A@EC@IUnknown@@8
.rdata$r:00001EC4 ; IUnknown::`RTTI Base Class Descriptor at (0, -1, 0, 66)'
.rdata$r:00001EC4 ??_R1A@?0A@EC@IUnknown@@8 dd offset ??_R0?AUIUnknown@@@8
.rdata$r:00001EC4                                         ; DATA XREF: .rdata$r:00001DE0o
.rdata$r:00001EC4                                         ; IUnknown `RTTI Type Descriptor'
.rdata$r:00001EC8                 align 10h
.rdata$r:00001ED0                 db 0FFh
.rdata$r:00001ED1                 db 0FFh
.rdata$r:00001ED2                 db 0FFh
.rdata$r:00001ED3                 db 0FFh
.rdata$r:00001ED4                 db    0
.rdata$r:00001ED5                 db    0
.rdata$r:00001ED6                 db    0
.rdata$r:00001ED7                 db    0
.rdata$r:00001ED8                 db  42h ; B
.rdata$r:00001ED9                 db    0
.rdata$r:00001EDA                 db    0
.rdata$r:00001EDB                 db    0
.rdata$r:00001EDC                 dd offset ??_R3IUnknown@@8 ; IUnknown::`RTTI Class Hierarchy Descriptor'
.rdata$r:00001EDC _rdata$r        ends
.rdata$r:00001EDC
.rdata$r:00001EE0 ; ===========================================================================
.rdata$r:00001EE0
.rdata$r:00001EE0 ; Segment type: Pure data
.rdata$r:00001EE0 ; Segment permissions: Read
.rdata$r:00001EE0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001EE0                 assume cs:_rdata$r
.rdata$r:00001EE0                 ;org 1EE0h
.rdata$r:00001EE0 ; COMDAT (pick any)
.rdata$r:00001EE0                 public ??_R13?0A@EA@ICompressSetInStream@@8
.rdata$r:00001EE0 ; ICompressSetInStream::`RTTI Base Class Descriptor at (4, -1, 0, 64)'
.rdata$r:00001EE0 ??_R13?0A@EA@ICompressSetInStream@@8 dd offset ??_R0?AUICompressSetInStream@@@8
.rdata$r:00001EE0                                         ; DATA XREF: .rdata$r:00001DE4o
.rdata$r:00001EE0                                         ; ICompressSetInStream `RTTI Type Descriptor'
.rdata$r:00001EE4                 db    1
.rdata$r:00001EE5                 db    0
.rdata$r:00001EE6                 db    0
.rdata$r:00001EE7                 db    0
.rdata$r:00001EE8                 db    4
.rdata$r:00001EE9                 db    0
.rdata$r:00001EEA                 db    0
.rdata$r:00001EEB                 db    0
.rdata$r:00001EEC                 db 0FFh
.rdata$r:00001EED                 db 0FFh
.rdata$r:00001EEE                 db 0FFh
.rdata$r:00001EEF                 db 0FFh
.rdata$r:00001EF0                 db    0
.rdata$r:00001EF1                 db    0
.rdata$r:00001EF2                 db    0
.rdata$r:00001EF3                 db    0
.rdata$r:00001EF4                 db  40h ; @
.rdata$r:00001EF5                 db    0
.rdata$r:00001EF6                 db    0
.rdata$r:00001EF7                 db    0
.rdata$r:00001EF8                 dd offset ??_R3ICompressSetInStream@@8 ; ICompressSetInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00001EF8 _rdata$r        ends
.rdata$r:00001EF8
.data:00001EFC ; ===========================================================================
.data:00001EFC
.data:00001EFC ; Segment type: Pure data
.data:00001EFC ; Segment permissions: Read/Write
.data:00001EFC _data           segment dword public 'DATA' use32
.data:00001EFC                 assume cs:_data
.data:00001EFC                 ;org 1EFCh
.data:00001EFC ; COMDAT (pick any)
.data:00001EFC                 public ??_R0?AUICompressSetInStream@@@8
.data:00001EFC ; struct ICompressSetInStream `RTTI Type Descriptor'
.data:00001EFC ??_R0?AUICompressSetInStream@@@8 dd offset ??_7type_info@@6B@
.data:00001EFC                                         ; DATA XREF: .rdata$r:ICompressSetInStream::`RTTI Base Class Descriptor at (4,-1,0,64)'o
.data:00001EFC                                         ; .rdata$r:ICompressSetInStream::`RTTI Base Class Descriptor at (0,-1,0,64)'o ...
.data:00001EFC                                         ; const type_info::`vftable'
.data:00001F00                 db    0
.data:00001F01                 db    0
.data:00001F02                 db    0
.data:00001F03                 db    0
.data:00001F04                 db  2Eh ; .
.data:00001F05                 db  3Fh ; ?
.data:00001F06                 db  41h ; A
.data:00001F07                 db  55h ; U
.data:00001F08                 db  49h ; I
.data:00001F09                 db  43h ; C
.data:00001F0A                 db  6Fh ; o
.data:00001F0B                 db  6Dh ; m
.data:00001F0C                 db  70h ; p
.data:00001F0D                 db  72h ; r
.data:00001F0E                 db  65h ; e
.data:00001F0F                 db  73h ; s
.data:00001F10                 db  73h ; s
.data:00001F11                 db  53h ; S
.data:00001F12                 db  65h ; e
.data:00001F13                 db  74h ; t
.data:00001F14                 db  49h ; I
.data:00001F15                 db  6Eh ; n
.data:00001F16                 db  53h ; S
.data:00001F17                 db  74h ; t
.data:00001F18                 db  72h ; r
.data:00001F19                 db  65h ; e
.data:00001F1A                 db  61h ; a
.data:00001F1B                 db  6Dh ; m
.data:00001F1C                 db  40h ; @
.data:00001F1D                 db  40h ; @
.data:00001F1E                 db    0
.data:00001F1F                 align 10h
.data:00001F1F _data           ends
.data:00001F1F
.rdata$r:00001F20 ; ===========================================================================
.rdata$r:00001F20
.rdata$r:00001F20 ; Segment type: Pure data
.rdata$r:00001F20 ; Segment permissions: Read
.rdata$r:00001F20 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001F20                 assume cs:_rdata$r
.rdata$r:00001F20                 ;org 1F20h
.rdata$r:00001F20 ; COMDAT (pick any)
.rdata$r:00001F20                 public ??_R3ICompressSetInStream@@8
.rdata$r:00001F20 ; ICompressSetInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00001F20 ??_R3ICompressSetInStream@@8 db    0    ; DATA XREF: .rdata$r:00001EF8o
.rdata$r:00001F20                                         ; .rdata$r:00001F54o ...
.rdata$r:00001F21                 db    0
.rdata$r:00001F22                 db    0
.rdata$r:00001F23                 db    0
.rdata$r:00001F24                 db    0
.rdata$r:00001F25                 db    0
.rdata$r:00001F26                 db    0
.rdata$r:00001F27                 db    0
.rdata$r:00001F28                 db    2
.rdata$r:00001F29                 db    0
.rdata$r:00001F2A                 db    0
.rdata$r:00001F2B                 db    0
.rdata$r:00001F2C                 dd offset ??_R2ICompressSetInStream@@8 ; ICompressSetInStream::`RTTI Base Class Array'
.rdata$r:00001F2C _rdata$r        ends
.rdata$r:00001F2C
.rdata$r:00001F30 ; ===========================================================================
.rdata$r:00001F30
.rdata$r:00001F30 ; Segment type: Pure data
.rdata$r:00001F30 ; Segment permissions: Read
.rdata$r:00001F30 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001F30                 assume cs:_rdata$r
.rdata$r:00001F30                 ;org 1F30h
.rdata$r:00001F30 ; COMDAT (pick any)
.rdata$r:00001F30                 public ??_R2ICompressSetInStream@@8
.rdata$r:00001F30 ; ICompressSetInStream::`RTTI Base Class Array'
.rdata$r:00001F30 ??_R2ICompressSetInStream@@8 dd offset ??_R1A@?0A@EA@ICompressSetInStream@@8
.rdata$r:00001F30                                         ; DATA XREF: .rdata$r:00001F2Co
.rdata$r:00001F30                                         ; ICompressSetInStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00001F34                 dd offset ??_R1A@?0A@EA@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00001F38                 db    0
.rdata$r:00001F39                 align 4
.rdata$r:00001F39 _rdata$r        ends
.rdata$r:00001F39
.rdata$r:00001F3C ; ===========================================================================
.rdata$r:00001F3C
.rdata$r:00001F3C ; Segment type: Pure data
.rdata$r:00001F3C ; Segment permissions: Read
.rdata$r:00001F3C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001F3C                 assume cs:_rdata$r
.rdata$r:00001F3C                 ;org 1F3Ch
.rdata$r:00001F3C ; COMDAT (pick any)
.rdata$r:00001F3C                 public ??_R1A@?0A@EA@ICompressSetInStream@@8
.rdata$r:00001F3C ; ICompressSetInStream::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00001F3C ??_R1A@?0A@EA@ICompressSetInStream@@8 dd offset ??_R0?AUICompressSetInStream@@@8
.rdata$r:00001F3C                                         ; DATA XREF: .rdata$r:ICompressSetInStream::`RTTI Base Class Array'o
.rdata$r:00001F3C                                         ; ICompressSetInStream `RTTI Type Descriptor'
.rdata$r:00001F40                 db    1
.rdata$r:00001F41                 db    0
.rdata$r:00001F42                 db    0
.rdata$r:00001F43                 db    0
.rdata$r:00001F44                 db    0
.rdata$r:00001F45                 db    0
.rdata$r:00001F46                 db    0
.rdata$r:00001F47                 db    0
.rdata$r:00001F48                 db 0FFh
.rdata$r:00001F49                 db 0FFh
.rdata$r:00001F4A                 db 0FFh
.rdata$r:00001F4B                 db 0FFh
.rdata$r:00001F4C                 db    0
.rdata$r:00001F4D                 db    0
.rdata$r:00001F4E                 db    0
.rdata$r:00001F4F                 db    0
.rdata$r:00001F50                 db  40h ; @
.rdata$r:00001F51                 db    0
.rdata$r:00001F52                 db    0
.rdata$r:00001F53                 db    0
.rdata$r:00001F54                 dd offset ??_R3ICompressSetInStream@@8 ; ICompressSetInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00001F54 _rdata$r        ends
.rdata$r:00001F54
.rdata$r:00001F58 ; ===========================================================================
.rdata$r:00001F58
.rdata$r:00001F58 ; Segment type: Pure data
.rdata$r:00001F58 ; Segment permissions: Read
.rdata$r:00001F58 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001F58                 assume cs:_rdata$r
.rdata$r:00001F58                 ;org 1F58h
.rdata$r:00001F58 ; COMDAT (pick any)
.rdata$r:00001F58                 public ??_R13?0A@EC@IUnknown@@8
.rdata$r:00001F58 ; IUnknown::`RTTI Base Class Descriptor at (4, -1, 0, 66)'
.rdata$r:00001F58 ??_R13?0A@EC@IUnknown@@8 dd offset ??_R0?AUIUnknown@@@8
.rdata$r:00001F58                                         ; DATA XREF: .rdata$r:00001DE8o
.rdata$r:00001F58                                         ; IUnknown `RTTI Type Descriptor'
.rdata$r:00001F5C                 align 10h
.rdata$r:00001F60                 db    4
.rdata$r:00001F61                 db    0
.rdata$r:00001F62                 db    0
.rdata$r:00001F63                 db    0
.rdata$r:00001F64                 db 0FFh
.rdata$r:00001F65                 db 0FFh
.rdata$r:00001F66                 db 0FFh
.rdata$r:00001F67                 db 0FFh
.rdata$r:00001F68                 db    0
.rdata$r:00001F69                 db    0
.rdata$r:00001F6A                 db    0
.rdata$r:00001F6B                 db    0
.rdata$r:00001F6C                 db  42h ; B
.rdata$r:00001F6D                 db    0
.rdata$r:00001F6E                 db    0
.rdata$r:00001F6F                 db    0
.rdata$r:00001F70                 dd offset ??_R3IUnknown@@8 ; IUnknown::`RTTI Class Hierarchy Descriptor'
.rdata$r:00001F70 _rdata$r        ends
.rdata$r:00001F70
.rdata$r:00001F74 ; ===========================================================================
.rdata$r:00001F74
.rdata$r:00001F74 ; Segment type: Pure data
.rdata$r:00001F74 ; Segment permissions: Read
.rdata$r:00001F74 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001F74                 assume cs:_rdata$r
.rdata$r:00001F74                 ;org 1F74h
.rdata$r:00001F74 ; COMDAT (pick any)
.rdata$r:00001F74                 public ??_R17?0A@EA@ISequentialInStream@@8
.rdata$r:00001F74 ; ISequentialInStream::`RTTI Base Class Descriptor at (8, -1, 0, 64)'
.rdata$r:00001F74 ??_R17?0A@EA@ISequentialInStream@@8 dd offset ??_R0?AUISequentialInStream@@@8
.rdata$r:00001F74                                         ; DATA XREF: .rdata$r:00001DECo
.rdata$r:00001F74                                         ; ISequentialInStream `RTTI Type Descriptor'
.rdata$r:00001F78                 db    1
.rdata$r:00001F79                 db    0
.rdata$r:00001F7A                 db    0
.rdata$r:00001F7B                 db    0
.rdata$r:00001F7C                 db    8
.rdata$r:00001F7D                 db    0
.rdata$r:00001F7E                 db    0
.rdata$r:00001F7F                 db    0
.rdata$r:00001F80                 db 0FFh
.rdata$r:00001F81                 db 0FFh
.rdata$r:00001F82                 db 0FFh
.rdata$r:00001F83                 db 0FFh
.rdata$r:00001F84                 db    0
.rdata$r:00001F85                 db    0
.rdata$r:00001F86                 db    0
.rdata$r:00001F87                 db    0
.rdata$r:00001F88                 db  40h ; @
.rdata$r:00001F89                 db    0
.rdata$r:00001F8A                 db    0
.rdata$r:00001F8B                 db    0
.rdata$r:00001F8C                 dd offset ??_R3ISequentialInStream@@8 ; ISequentialInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00001F8C _rdata$r        ends
.rdata$r:00001F8C
.data:00001F90 ; ===========================================================================
.data:00001F90
.data:00001F90 ; Segment type: Pure data
.data:00001F90 ; Segment permissions: Read/Write
.data:00001F90 _data           segment dword public 'DATA' use32
.data:00001F90                 assume cs:_data
.data:00001F90                 ;org 1F90h
.data:00001F90 ; COMDAT (pick any)
.data:00001F90                 public ??_R0?AUISequentialInStream@@@8
.data:00001F90 ; struct ISequentialInStream `RTTI Type Descriptor'
.data:00001F90 ??_R0?AUISequentialInStream@@@8 dd offset ??_7type_info@@6B@
.data:00001F90                                         ; DATA XREF: .rdata$r:ISequentialInStream::`RTTI Base Class Descriptor at (8,-1,0,64)'o
.data:00001F90                                         ; .rdata$r:ISequentialInStream::`RTTI Base Class Descriptor at (0,-1,0,64)'o ...
.data:00001F90                                         ; const type_info::`vftable'
.data:00001F94                 align 8
.data:00001F98 a_?auisequentia db '.?AUISequentialInStream@@',0
.data:00001FB2                 align 4
.data:00001FB2 _data           ends
.data:00001FB2
.rdata$r:00001FB4 ; ===========================================================================
.rdata$r:00001FB4
.rdata$r:00001FB4 ; Segment type: Pure data
.rdata$r:00001FB4 ; Segment permissions: Read
.rdata$r:00001FB4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001FB4                 assume cs:_rdata$r
.rdata$r:00001FB4                 ;org 1FB4h
.rdata$r:00001FB4 ; COMDAT (pick any)
.rdata$r:00001FB4                 public ??_R3ISequentialInStream@@8
.rdata$r:00001FB4 ; ISequentialInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00001FB4 ??_R3ISequentialInStream@@8 db    0     ; DATA XREF: .rdata$r:00001F8Co
.rdata$r:00001FB4                                         ; .rdata$r:00001FE8o ...
.rdata$r:00001FB5                 db    0
.rdata$r:00001FB6                 db    0
.rdata$r:00001FB7                 db    0
.rdata$r:00001FB8                 db    0
.rdata$r:00001FB9                 db    0
.rdata$r:00001FBA                 db    0
.rdata$r:00001FBB                 db    0
.rdata$r:00001FBC                 db    2
.rdata$r:00001FBD                 db    0
.rdata$r:00001FBE                 db    0
.rdata$r:00001FBF                 db    0
.rdata$r:00001FC0                 dd offset ??_R2ISequentialInStream@@8 ; ISequentialInStream::`RTTI Base Class Array'
.rdata$r:00001FC0 _rdata$r        ends
.rdata$r:00001FC0
.rdata$r:00001FC4 ; ===========================================================================
.rdata$r:00001FC4
.rdata$r:00001FC4 ; Segment type: Pure data
.rdata$r:00001FC4 ; Segment permissions: Read
.rdata$r:00001FC4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001FC4                 assume cs:_rdata$r
.rdata$r:00001FC4                 ;org 1FC4h
.rdata$r:00001FC4 ; COMDAT (pick any)
.rdata$r:00001FC4                 public ??_R2ISequentialInStream@@8
.rdata$r:00001FC4 ; ISequentialInStream::`RTTI Base Class Array'
.rdata$r:00001FC4 ??_R2ISequentialInStream@@8 dd offset ??_R1A@?0A@EA@ISequentialInStream@@8
.rdata$r:00001FC4                                         ; DATA XREF: .rdata$r:00001FC0o
.rdata$r:00001FC4                                         ; ISequentialInStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00001FC8                 dd offset ??_R1A@?0A@EA@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00001FCC                 db    0
.rdata$r:00001FCD                 align 10h
.rdata$r:00001FCD _rdata$r        ends
.rdata$r:00001FCD
.rdata$r:00001FD0 ; ===========================================================================
.rdata$r:00001FD0
.rdata$r:00001FD0 ; Segment type: Pure data
.rdata$r:00001FD0 ; Segment permissions: Read
.rdata$r:00001FD0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001FD0                 assume cs:_rdata$r
.rdata$r:00001FD0                 ;org 1FD0h
.rdata$r:00001FD0 ; COMDAT (pick any)
.rdata$r:00001FD0                 public ??_R1A@?0A@EA@ISequentialInStream@@8
.rdata$r:00001FD0 ; ISequentialInStream::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00001FD0 ??_R1A@?0A@EA@ISequentialInStream@@8 dd offset ??_R0?AUISequentialInStream@@@8
.rdata$r:00001FD0                                         ; DATA XREF: .rdata$r:ISequentialInStream::`RTTI Base Class Array'o
.rdata$r:00001FD0                                         ; .rdata$r:000027BCo
.rdata$r:00001FD0                                         ; ISequentialInStream `RTTI Type Descriptor'
.rdata$r:00001FD4                 db    1
.rdata$r:00001FD5                 db    0
.rdata$r:00001FD6                 db    0
.rdata$r:00001FD7                 db    0
.rdata$r:00001FD8                 db    0
.rdata$r:00001FD9                 db    0
.rdata$r:00001FDA                 db    0
.rdata$r:00001FDB                 db    0
.rdata$r:00001FDC                 db 0FFh
.rdata$r:00001FDD                 db 0FFh
.rdata$r:00001FDE                 db 0FFh
.rdata$r:00001FDF                 db 0FFh
.rdata$r:00001FE0                 db    0
.rdata$r:00001FE1                 db    0
.rdata$r:00001FE2                 db    0
.rdata$r:00001FE3                 db    0
.rdata$r:00001FE4                 db  40h ; @
.rdata$r:00001FE5                 db    0
.rdata$r:00001FE6                 db    0
.rdata$r:00001FE7                 db    0
.rdata$r:00001FE8                 dd offset ??_R3ISequentialInStream@@8 ; ISequentialInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00001FE8 _rdata$r        ends
.rdata$r:00001FE8
.rdata$r:00001FEC ; ===========================================================================
.rdata$r:00001FEC
.rdata$r:00001FEC ; Segment type: Pure data
.rdata$r:00001FEC ; Segment permissions: Read
.rdata$r:00001FEC _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001FEC                 assume cs:_rdata$r
.rdata$r:00001FEC                 ;org 1FECh
.rdata$r:00001FEC ; COMDAT (pick any)
.rdata$r:00001FEC                 public ??_R17?0A@EC@IUnknown@@8
.rdata$r:00001FEC ; IUnknown::`RTTI Base Class Descriptor at (8, -1, 0, 66)'
.rdata$r:00001FEC ??_R17?0A@EC@IUnknown@@8 dd offset ??_R0?AUIUnknown@@@8
.rdata$r:00001FEC                                         ; DATA XREF: .rdata$r:00001DF0o
.rdata$r:00001FEC                                         ; IUnknown `RTTI Type Descriptor'
.rdata$r:00001FF0                 db    0
.rdata$r:00001FF1                 db    0
.rdata$r:00001FF2                 db    0
.rdata$r:00001FF3                 db    0
.rdata$r:00001FF4                 db    8
.rdata$r:00001FF5                 db    0
.rdata$r:00001FF6                 db    0
.rdata$r:00001FF7                 db    0
.rdata$r:00001FF8                 db 0FFh
.rdata$r:00001FF9                 db 0FFh
.rdata$r:00001FFA                 db 0FFh
.rdata$r:00001FFB                 db 0FFh
.rdata$r:00001FFC                 db    0
.rdata$r:00001FFD                 db    0
.rdata$r:00001FFE                 db    0
.rdata$r:00001FFF                 db    0
.rdata$r:00002000                 db  42h ; B
.rdata$r:00002001                 db    0
.rdata$r:00002002                 db    0
.rdata$r:00002003                 db    0
.rdata$r:00002004                 dd offset ??_R3IUnknown@@8 ; IUnknown::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002004 _rdata$r        ends
.rdata$r:00002004
.rdata$r:00002008 ; ===========================================================================
.rdata$r:00002008
.rdata$r:00002008 ; Segment type: Pure data
.rdata$r:00002008 ; Segment permissions: Read
.rdata$r:00002008 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002008                 assume cs:_rdata$r
.rdata$r:00002008                 ;org 2008h
.rdata$r:00002008 ; COMDAT (pick any)
.rdata$r:00002008                 public ??_R1M@?0A@EA@ICompressGetInStreamProcessedSize@@8
.rdata$r:00002008 ; ICompressGetInStreamProcessedSize::`RTTI Base Class Descriptor at (12, -1, 0, 64)'
.rdata$r:00002008 ??_R1M@?0A@EA@ICompressGetInStreamProcessedSize@@8 dd offset ??_R0?AUICompressGetInStreamProcessedSize@@@8
.rdata$r:00002008                                         ; DATA XREF: .rdata$r:00001DF4o
.rdata$r:00002008                                         ; ICompressGetInStreamProcessedSize `RTTI Type Descriptor'
.rdata$r:0000200C                 db    1
.rdata$r:0000200D                 db    0
.rdata$r:0000200E                 db    0
.rdata$r:0000200F                 db    0
.rdata$r:00002010                 db  0Ch
.rdata$r:00002011                 db    0
.rdata$r:00002012                 db    0
.rdata$r:00002013                 db    0
.rdata$r:00002014                 db 0FFh
.rdata$r:00002015                 db 0FFh
.rdata$r:00002016                 db 0FFh
.rdata$r:00002017                 db 0FFh
.rdata$r:00002018                 db    0
.rdata$r:00002019                 db    0
.rdata$r:0000201A                 db    0
.rdata$r:0000201B                 db    0
.rdata$r:0000201C                 db  40h ; @
.rdata$r:0000201D                 db    0
.rdata$r:0000201E                 db    0
.rdata$r:0000201F                 db    0
.rdata$r:00002020                 dd offset ??_R3ICompressGetInStreamProcessedSize@@8 ; ICompressGetInStreamProcessedSize::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002020 _rdata$r        ends
.rdata$r:00002020
.data:00002024 ; ===========================================================================
.data:00002024
.data:00002024 ; Segment type: Pure data
.data:00002024 ; Segment permissions: Read/Write
.data:00002024 _data           segment dword public 'DATA' use32
.data:00002024                 assume cs:_data
.data:00002024                 ;org 2024h
.data:00002024 ; COMDAT (pick any)
.data:00002024                 public ??_R0?AUICompressGetInStreamProcessedSize@@@8
.data:00002024 ; struct ICompressGetInStreamProcessedSize `RTTI Type Descriptor'
.data:00002024 ??_R0?AUICompressGetInStreamProcessedSize@@@8 dd offset ??_7type_info@@6B@
.data:00002024                                         ; DATA XREF: .rdata$r:ICompressGetInStreamProcessedSize::`RTTI Base Class Descriptor at (12,-1,0,64)'o
.data:00002024                                         ; .rdata$r:ICompressGetInStreamProcessedSize::`RTTI Base Class Descriptor at (0,-1,0,64)'o ...
.data:00002024                                         ; const type_info::`vftable'
.data:00002028                 db    0
.data:00002029                 db    0
.data:0000202A                 db    0
.data:0000202B                 db    0
.data:0000202C                 db  2Eh ; .
.data:0000202D                 db  3Fh ; ?
.data:0000202E                 db  41h ; A
.data:0000202F                 db  55h ; U
.data:00002030                 db  49h ; I
.data:00002031                 db  43h ; C
.data:00002032                 db  6Fh ; o
.data:00002033                 db  6Dh ; m
.data:00002034                 db  70h ; p
.data:00002035                 db  72h ; r
.data:00002036                 db  65h ; e
.data:00002037                 db  73h ; s
.data:00002038                 db  73h ; s
.data:00002039                 db  47h ; G
.data:0000203A                 db  65h ; e
.data:0000203B                 db  74h ; t
.data:0000203C                 db  49h ; I
.data:0000203D                 db  6Eh ; n
.data:0000203E                 db  53h ; S
.data:0000203F                 db  74h ; t
.data:00002040                 db  72h ; r
.data:00002041                 db  65h ; e
.data:00002042                 db  61h ; a
.data:00002043                 db  6Dh ; m
.data:00002044                 db  50h ; P
.data:00002045                 db  72h ; r
.data:00002046                 db  6Fh ; o
.data:00002047                 db  63h ; c
.data:00002048                 db  65h ; e
.data:00002049                 db  73h ; s
.data:0000204A                 db  73h ; s
.data:0000204B                 db  65h ; e
.data:0000204C                 db  64h ; d
.data:0000204D                 db  53h ; S
.data:0000204E                 db  69h ; i
.data:0000204F                 db  7Ah ; z
.data:00002050                 db  65h ; e
.data:00002051                 db  40h ; @
.data:00002052                 db  40h ; @
.data:00002053                 db    0
.data:00002053 _data           ends
.data:00002053
.rdata$r:00002054 ; ===========================================================================
.rdata$r:00002054
.rdata$r:00002054 ; Segment type: Pure data
.rdata$r:00002054 ; Segment permissions: Read
.rdata$r:00002054 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002054                 assume cs:_rdata$r
.rdata$r:00002054                 ;org 2054h
.rdata$r:00002054 ; COMDAT (pick any)
.rdata$r:00002054                 public ??_R3ICompressGetInStreamProcessedSize@@8
.rdata$r:00002054 ; ICompressGetInStreamProcessedSize::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002054 ??_R3ICompressGetInStreamProcessedSize@@8 db    0
.rdata$r:00002054                                         ; DATA XREF: .rdata$r:00002020o
.rdata$r:00002054                                         ; .rdata$r:00002088o ...
.rdata$r:00002055                 db    0
.rdata$r:00002056                 db    0
.rdata$r:00002057                 db    0
.rdata$r:00002058                 db    0
.rdata$r:00002059                 db    0
.rdata$r:0000205A                 db    0
.rdata$r:0000205B                 db    0
.rdata$r:0000205C                 db    2
.rdata$r:0000205D                 db    0
.rdata$r:0000205E                 db    0
.rdata$r:0000205F                 db    0
.rdata$r:00002060                 dd offset ??_R2ICompressGetInStreamProcessedSize@@8 ; ICompressGetInStreamProcessedSize::`RTTI Base Class Array'
.rdata$r:00002060 _rdata$r        ends
.rdata$r:00002060
.rdata$r:00002064 ; ===========================================================================
.rdata$r:00002064
.rdata$r:00002064 ; Segment type: Pure data
.rdata$r:00002064 ; Segment permissions: Read
.rdata$r:00002064 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002064                 assume cs:_rdata$r
.rdata$r:00002064                 ;org 2064h
.rdata$r:00002064 ; COMDAT (pick any)
.rdata$r:00002064                 public ??_R2ICompressGetInStreamProcessedSize@@8
.rdata$r:00002064 ; ICompressGetInStreamProcessedSize::`RTTI Base Class Array'
.rdata$r:00002064 ??_R2ICompressGetInStreamProcessedSize@@8 dd offset ??_R1A@?0A@EA@ICompressGetInStreamProcessedSize@@8
.rdata$r:00002064                                         ; DATA XREF: .rdata$r:00002060o
.rdata$r:00002064                                         ; ICompressGetInStreamProcessedSize::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002068                 dd offset ??_R1A@?0A@EA@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000206C                 db    0
.rdata$r:0000206D                 align 10h
.rdata$r:0000206D _rdata$r        ends
.rdata$r:0000206D
.rdata$r:00002070 ; ===========================================================================
.rdata$r:00002070
.rdata$r:00002070 ; Segment type: Pure data
.rdata$r:00002070 ; Segment permissions: Read
.rdata$r:00002070 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002070                 assume cs:_rdata$r
.rdata$r:00002070                 ;org 2070h
.rdata$r:00002070 ; COMDAT (pick any)
.rdata$r:00002070                 public ??_R1A@?0A@EA@ICompressGetInStreamProcessedSize@@8
.rdata$r:00002070 ; ICompressGetInStreamProcessedSize::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002070 ??_R1A@?0A@EA@ICompressGetInStreamProcessedSize@@8 dd offset ??_R0?AUICompressGetInStreamProcessedSize@@@8
.rdata$r:00002070                                         ; DATA XREF: .rdata$r:ICompressGetInStreamProcessedSize::`RTTI Base Class Array'o
.rdata$r:00002070                                         ; ICompressGetInStreamProcessedSize `RTTI Type Descriptor'
.rdata$r:00002074                 db    1
.rdata$r:00002075                 db    0
.rdata$r:00002076                 db    0
.rdata$r:00002077                 db    0
.rdata$r:00002078                 db    0
.rdata$r:00002079                 db    0
.rdata$r:0000207A                 db    0
.rdata$r:0000207B                 db    0
.rdata$r:0000207C                 db 0FFh
.rdata$r:0000207D                 db 0FFh
.rdata$r:0000207E                 db 0FFh
.rdata$r:0000207F                 db 0FFh
.rdata$r:00002080                 db    0
.rdata$r:00002081                 db    0
.rdata$r:00002082                 db    0
.rdata$r:00002083                 db    0
.rdata$r:00002084                 db  40h ; @
.rdata$r:00002085                 db    0
.rdata$r:00002086                 db    0
.rdata$r:00002087                 db    0
.rdata$r:00002088                 dd offset ??_R3ICompressGetInStreamProcessedSize@@8 ; ICompressGetInStreamProcessedSize::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002088 _rdata$r        ends
.rdata$r:00002088
.rdata$r:0000208C ; ===========================================================================
.rdata$r:0000208C
.rdata$r:0000208C ; Segment type: Pure data
.rdata$r:0000208C ; Segment permissions: Read
.rdata$r:0000208C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000208C                 assume cs:_rdata$r
.rdata$r:0000208C                 ;org 208Ch
.rdata$r:0000208C ; COMDAT (pick any)
.rdata$r:0000208C                 public ??_R1M@?0A@EC@IUnknown@@8
.rdata$r:0000208C ; IUnknown::`RTTI Base Class Descriptor at (12, -1, 0, 66)'
.rdata$r:0000208C ??_R1M@?0A@EC@IUnknown@@8 dd offset ??_R0?AUIUnknown@@@8
.rdata$r:0000208C                                         ; DATA XREF: .rdata$r:00001DF8o
.rdata$r:0000208C                                         ; IUnknown `RTTI Type Descriptor'
.rdata$r:00002090                 db    0
.rdata$r:00002091                 db    0
.rdata$r:00002092                 db    0
.rdata$r:00002093                 db    0
.rdata$r:00002094                 db  0Ch
.rdata$r:00002095                 db    0
.rdata$r:00002096                 db    0
.rdata$r:00002097                 db    0
.rdata$r:00002098                 db 0FFh
.rdata$r:00002099                 db 0FFh
.rdata$r:0000209A                 db 0FFh
.rdata$r:0000209B                 db 0FFh
.rdata$r:0000209C                 db    0
.rdata$r:0000209D                 db    0
.rdata$r:0000209E                 db    0
.rdata$r:0000209F                 db    0
.rdata$r:000020A0                 db  42h ; B
.rdata$r:000020A1                 db    0
.rdata$r:000020A2                 db    0
.rdata$r:000020A3                 db    0
.rdata$r:000020A4                 dd offset ??_R3IUnknown@@8 ; IUnknown::`RTTI Class Hierarchy Descriptor'
.rdata$r:000020A4 _rdata$r        ends
.rdata$r:000020A4
.rdata$r:000020A8 ; ===========================================================================
.rdata$r:000020A8
.rdata$r:000020A8 ; Segment type: Pure data
.rdata$r:000020A8 ; Segment permissions: Read
.rdata$r:000020A8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000020A8                 assume cs:_rdata$r
.rdata$r:000020A8                 ;org 20A8h
.rdata$r:000020A8 ; COMDAT (pick any)
.rdata$r:000020A8                 public ??_R1BA@?0A@EA@CMyUnknownImp@@8
.rdata$r:000020A8 ; CMyUnknownImp::`RTTI Base Class Descriptor at (16, -1, 0, 64)'
.rdata$r:000020A8 ??_R1BA@?0A@EA@CMyUnknownImp@@8 dd offset ??_R0?AVCMyUnknownImp@@@8
.rdata$r:000020A8                                         ; DATA XREF: .rdata$r:00001DFCo
.rdata$r:000020A8                                         ; CMyUnknownImp `RTTI Type Descriptor'
.rdata$r:000020AC                 align 10h
.rdata$r:000020B0                 db  10h
.rdata$r:000020B1                 db    0
.rdata$r:000020B2                 db    0
.rdata$r:000020B3                 db    0
.rdata$r:000020B4                 db 0FFh
.rdata$r:000020B5                 db 0FFh
.rdata$r:000020B6                 db 0FFh
.rdata$r:000020B7                 db 0FFh
.rdata$r:000020B8                 db    0
.rdata$r:000020B9                 db    0
.rdata$r:000020BA                 db    0
.rdata$r:000020BB                 db    0
.rdata$r:000020BC                 db  40h ; @
.rdata$r:000020BD                 db    0
.rdata$r:000020BE                 db    0
.rdata$r:000020BF                 db    0
.rdata$r:000020C0                 dd offset ??_R3CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Class Hierarchy Descriptor'
.rdata$r:000020C0 _rdata$r        ends
.rdata$r:000020C0
.data:000020C4 ; ===========================================================================
.data:000020C4
.data:000020C4 ; Segment type: Pure data
.data:000020C4 ; Segment permissions: Read/Write
.data:000020C4 _data           segment dword public 'DATA' use32
.data:000020C4                 assume cs:_data
.data:000020C4                 ;org 20C4h
.data:000020C4 ; COMDAT (pick any)
.data:000020C4                 public ??_R0?AVCMyUnknownImp@@@8
.data:000020C4 ; class CMyUnknownImp `RTTI Type Descriptor'
.data:000020C4 ??_R0?AVCMyUnknownImp@@@8 dd offset ??_7type_info@@6B@
.data:000020C4                                         ; DATA XREF: .rdata$r:CMyUnknownImp::`RTTI Base Class Descriptor at (16,-1,0,64)'o
.data:000020C4                                         ; .rdata$r:CMyUnknownImp::`RTTI Base Class Descriptor at (0,-1,0,64)'o ...
.data:000020C4                                         ; const type_info::`vftable'
.data:000020C8                 db    0
.data:000020C9                 db    0
.data:000020CA                 db    0
.data:000020CB                 db    0
.data:000020CC                 db  2Eh ; .
.data:000020CD                 db  3Fh ; ?
.data:000020CE                 db  41h ; A
.data:000020CF                 db  56h ; V
.data:000020D0                 db  43h ; C
.data:000020D1                 db  4Dh ; M
.data:000020D2                 db  79h ; y
.data:000020D3                 db  55h ; U
.data:000020D4                 db  6Eh ; n
.data:000020D5                 db  6Bh ; k
.data:000020D6                 db  6Eh ; n
.data:000020D7                 db  6Fh ; o
.data:000020D8                 db  77h ; w
.data:000020D9                 db  6Eh ; n
.data:000020DA                 db  49h ; I
.data:000020DB                 db  6Dh ; m
.data:000020DC                 db  70h ; p
.data:000020DD                 db  40h ; @
.data:000020DE                 db  40h ; @
.data:000020DF                 db    0
.data:000020DF _data           ends
.data:000020DF
.rdata$r:000020E0 ; ===========================================================================
.rdata$r:000020E0
.rdata$r:000020E0 ; Segment type: Pure data
.rdata$r:000020E0 ; Segment permissions: Read
.rdata$r:000020E0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000020E0                 assume cs:_rdata$r
.rdata$r:000020E0                 ;org 20E0h
.rdata$r:000020E0 ; COMDAT (pick any)
.rdata$r:000020E0                 public ??_R3CMyUnknownImp@@8
.rdata$r:000020E0 ; CMyUnknownImp::`RTTI Class Hierarchy Descriptor'
.rdata$r:000020E0 ??_R3CMyUnknownImp@@8 db    0           ; DATA XREF: .rdata$r:000020C0o
.rdata$r:000020E0                                         ; .rdata$r:00002110o ...
.rdata$r:000020E1                 db    0
.rdata$r:000020E2                 db    0
.rdata$r:000020E3                 db    0
.rdata$r:000020E4                 db    0
.rdata$r:000020E5                 db    0
.rdata$r:000020E6                 db    0
.rdata$r:000020E7                 db    0
.rdata$r:000020E8                 db    1
.rdata$r:000020E9                 db    0
.rdata$r:000020EA                 db    0
.rdata$r:000020EB                 db    0
.rdata$r:000020EC                 dd offset ??_R2CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Base Class Array'
.rdata$r:000020EC _rdata$r        ends
.rdata$r:000020EC
.rdata$r:000020F0 ; ===========================================================================
.rdata$r:000020F0
.rdata$r:000020F0 ; Segment type: Pure data
.rdata$r:000020F0 ; Segment permissions: Read
.rdata$r:000020F0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000020F0                 assume cs:_rdata$r
.rdata$r:000020F0                 ;org 20F0h
.rdata$r:000020F0 ; COMDAT (pick any)
.rdata$r:000020F0                 public ??_R2CMyUnknownImp@@8
.rdata$r:000020F0 ; CMyUnknownImp::`RTTI Base Class Array'
.rdata$r:000020F0 ??_R2CMyUnknownImp@@8 dd offset ??_R1A@?0A@EA@CMyUnknownImp@@8
.rdata$r:000020F0                                         ; DATA XREF: .rdata$r:000020ECo
.rdata$r:000020F0                                         ; CMyUnknownImp::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000020F4                 db    0
.rdata$r:000020F5                 align 4
.rdata$r:000020F5 _rdata$r        ends
.rdata$r:000020F5
.rdata$r:000020F8 ; ===========================================================================
.rdata$r:000020F8
.rdata$r:000020F8 ; Segment type: Pure data
.rdata$r:000020F8 ; Segment permissions: Read
.rdata$r:000020F8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000020F8                 assume cs:_rdata$r
.rdata$r:000020F8                 ;org 20F8h
.rdata$r:000020F8 ; COMDAT (pick any)
.rdata$r:000020F8                 public ??_R1A@?0A@EA@CMyUnknownImp@@8
.rdata$r:000020F8 ; CMyUnknownImp::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000020F8 ??_R1A@?0A@EA@CMyUnknownImp@@8 dd offset ??_R0?AVCMyUnknownImp@@@8
.rdata$r:000020F8                                         ; DATA XREF: .rdata$r:CMyUnknownImp::`RTTI Base Class Array'o
.rdata$r:000020F8                                         ; CMyUnknownImp `RTTI Type Descriptor'
.rdata$r:000020FC                 db    0
.rdata$r:000020FD                 db    0
.rdata$r:000020FE                 db    0
.rdata$r:000020FF                 db    0
.rdata$r:00002100                 db    0
.rdata$r:00002101                 db    0
.rdata$r:00002102                 db    0
.rdata$r:00002103                 db    0
.rdata$r:00002104                 db 0FFh
.rdata$r:00002105                 db 0FFh
.rdata$r:00002106                 db 0FFh
.rdata$r:00002107                 db 0FFh
.rdata$r:00002108                 db    0
.rdata$r:00002109                 db    0
.rdata$r:0000210A                 db    0
.rdata$r:0000210B                 db    0
.rdata$r:0000210C                 db  40h ; @
.rdata$r:0000210D                 db    0
.rdata$r:0000210E                 db    0
.rdata$r:0000210F                 db    0
.rdata$r:00002110                 dd offset ??_R3CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002110 _rdata$r        ends
.rdata$r:00002110
.rdata$r:00002114 ; ===========================================================================
.rdata$r:00002114
.rdata$r:00002114 ; Segment type: Pure data
.rdata$r:00002114 ; Segment permissions: Read
.rdata$r:00002114 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002114                 assume cs:_rdata$r
.rdata$r:00002114                 ;org 2114h
.rdata$r:00002114 ; COMDAT (pick any)
.rdata$r:00002114                 public ??_R4CCopyCoder@NCompress@@6BICompressSetInStream@@@
.rdata$r:00002114 ; const NCompress::CCopyCoder::`RTTI Complete Object Locator'{for `ICompressSetInStream'}
.rdata$r:00002114 ??_R4CCopyCoder@NCompress@@6BICompressSetInStream@@@ db    0
.rdata$r:00002114                                         ; DATA XREF: .rdata:00001D64o
.rdata$r:00002115                 db    0
.rdata$r:00002116                 db    0
.rdata$r:00002117                 db    0
.rdata$r:00002118                 db    4
.rdata$r:00002119                 db    0
.rdata$r:0000211A                 db    0
.rdata$r:0000211B                 db    0
.rdata$r:0000211C                 db    0
.rdata$r:0000211D                 db    0
.rdata$r:0000211E                 db    0
.rdata$r:0000211F                 db    0
.rdata$r:00002120                 dd offset ??_R0?AVCCopyCoder@NCompress@@@8 ; NCompress::CCopyCoder `RTTI Type Descriptor'
.rdata$r:00002124                 dd offset ??_R3CCopyCoder@NCompress@@8 ; NCompress::CCopyCoder::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002124 _rdata$r        ends
.rdata$r:00002124
.rdata$r:00002128 ; ===========================================================================
.rdata$r:00002128
.rdata$r:00002128 ; Segment type: Pure data
.rdata$r:00002128 ; Segment permissions: Read
.rdata$r:00002128 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002128                 assume cs:_rdata$r
.rdata$r:00002128                 ;org 2128h
.rdata$r:00002128 ; COMDAT (pick any)
.rdata$r:00002128                 public ??_R4CCopyCoder@NCompress@@6BISequentialInStream@@@
.rdata$r:00002128 ; const NCompress::CCopyCoder::`RTTI Complete Object Locator'{for `ISequentialInStream'}
.rdata$r:00002128 ??_R4CCopyCoder@NCompress@@6BISequentialInStream@@@ db    0
.rdata$r:00002128                                         ; DATA XREF: .rdata:00001D50o
.rdata$r:00002129                 db    0
.rdata$r:0000212A                 db    0
.rdata$r:0000212B                 db    0
.rdata$r:0000212C                 db    8
.rdata$r:0000212D                 db    0
.rdata$r:0000212E                 db    0
.rdata$r:0000212F                 db    0
.rdata$r:00002130                 db    0
.rdata$r:00002131                 db    0
.rdata$r:00002132                 db    0
.rdata$r:00002133                 db    0
.rdata$r:00002134                 dd offset ??_R0?AVCCopyCoder@NCompress@@@8 ; NCompress::CCopyCoder `RTTI Type Descriptor'
.rdata$r:00002138                 dd offset ??_R3CCopyCoder@NCompress@@8 ; NCompress::CCopyCoder::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002138 _rdata$r        ends
.rdata$r:00002138
.rdata$r:0000213C ; ===========================================================================
.rdata$r:0000213C
.rdata$r:0000213C ; Segment type: Pure data
.rdata$r:0000213C ; Segment permissions: Read
.rdata$r:0000213C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000213C                 assume cs:_rdata$r
.rdata$r:0000213C                 ;org 213Ch
.rdata$r:0000213C ; COMDAT (pick any)
.rdata$r:0000213C                 public ??_R4CCopyCoder@NCompress@@6BICompressGetInStreamProcessedSize@@@
.rdata$r:0000213C ; const NCompress::CCopyCoder::`RTTI Complete Object Locator'{for `ICompressGetInStreamProcessedSize'}
.rdata$r:0000213C ??_R4CCopyCoder@NCompress@@6BICompressGetInStreamProcessedSize@@@ db    0
.rdata$r:0000213C                                         ; DATA XREF: .rdata:00001D3Co
.rdata$r:0000213D                 db    0
.rdata$r:0000213E                 db    0
.rdata$r:0000213F                 db    0
.rdata$r:00002140                 db  0Ch
.rdata$r:00002141                 db    0
.rdata$r:00002142                 db    0
.rdata$r:00002143                 db    0
.rdata$r:00002144                 db    0
.rdata$r:00002145                 db    0
.rdata$r:00002146                 db    0
.rdata$r:00002147                 db    0
.rdata$r:00002148                 dd offset ??_R0?AVCCopyCoder@NCompress@@@8 ; NCompress::CCopyCoder `RTTI Type Descriptor'
.rdata$r:0000214C                 dd offset ??_R3CCopyCoder@NCompress@@8 ; NCompress::CCopyCoder::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000214C _rdata$r        ends
.rdata$r:0000214C
.text:00002150 ; ===========================================================================
.text:00002150
.text:00002150 ; Segment type: Pure code
.text:00002150 ; Segment permissions: Read/Execute
.text:00002150 _text           segment para public 'CODE' use32
.text:00002150                 assume cs:_text
.text:00002150                 ;org 2150h
.text:00002150 ; COMDAT (pick any)
.text:00002150                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00002150
.text:00002150 ; =============== S U B R O U T I N E =======================================
.text:00002150
.text:00002150 ; Attributes: bp-based frame
.text:00002150
.text:00002150 ; _DWORD __thiscall CMyUnknownImp::CMyUnknownImp(CMyUnknownImp *__hidden this)
.text:00002150                 public ??0CMyUnknownImp@@QAE@XZ
.text:00002150 ??0CMyUnknownImp@@QAE@XZ proc near      ; CODE XREF: NCompress::CCopyCoder::CCopyCoder(void)+3Dp
.text:00002150                                         ; CLimitedSequentialInStream::CLimitedSequentialInStream(void)+1Cp
.text:00002150
.text:00002150 var_4           = dword ptr -4
.text:00002150
.text:00002150                 push    ebp
.text:00002151                 mov     ebp, esp
.text:00002153                 push    ecx
.text:00002154                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000215B                 mov     [ebp+var_4], ecx
.text:0000215E                 mov     eax, [ebp+var_4]
.text:00002161                 mov     dword ptr [eax], 0
.text:00002167                 mov     eax, [ebp+var_4]
.text:0000216A                 mov     esp, ebp
.text:0000216C                 pop     ebp
.text:0000216D                 retn
.text:0000216D ??0CMyUnknownImp@@QAE@XZ endp
.text:0000216D
.text:0000216D ; ---------------------------------------------------------------------------
.text:0000216E                 align 10h
.text:0000216E _text           ends
.text:0000216E
.text:00002170 ; ===========================================================================
.text:00002170
.text:00002170 ; Segment type: Pure code
.text:00002170 ; Segment permissions: Read/Execute
.text:00002170 _text           segment para public 'CODE' use32
.text:00002170                 assume cs:_text
.text:00002170                 ;org 2170h
.text:00002170 ; COMDAT (pick any)
.text:00002170                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00002170
.text:00002170 ; =============== S U B R O U T I N E =======================================
.text:00002170
.text:00002170 ; Attributes: bp-based frame
.text:00002170
.text:00002170 ; __int32 __stdcall NCompress::CCopyCoder::QueryInterface(NCompress::CCopyCoder *this, const struct _GUID *Buf1, void **)
.text:00002170                 public ?QueryInterface@CCopyCoder@NCompress@@UAGJABU_GUID@@PAPAX@Z
.text:00002170 ?QueryInterface@CCopyCoder@NCompress@@UAGJABU_GUID@@PAPAX@Z proc near
.text:00002170                                         ; CODE XREF: [thunk]:NCompress::CCopyCoder::QueryInterface`adjustor{4}' (_GUID const &,void * *)+5j
.text:00002170                                         ; [thunk]:NCompress::CCopyCoder::QueryInterface`adjustor{8}' (_GUID const &,void * *)+5j ...
.text:00002170
.text:00002170 var_C           = dword ptr -0Ch
.text:00002170 var_8           = dword ptr -8
.text:00002170 var_4           = dword ptr -4
.text:00002170 this            = dword ptr  8
.text:00002170 Buf1            = dword ptr  0Ch
.text:00002170 arg_8           = dword ptr  10h
.text:00002170
.text:00002170                 push    ebp
.text:00002171                 mov     ebp, esp
.text:00002173                 sub     esp, 0Ch
.text:00002176                 mov     [ebp+var_C], 0CCCCCCCCh
.text:0000217D                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00002184                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000218B                 mov     eax, [ebp+arg_8]
.text:0000218E                 mov     dword ptr [eax], 0
.text:00002194                 push    offset _IID_IUnknown ; Buf2
.text:00002199                 mov     ecx, [ebp+Buf1]
.text:0000219C                 push    ecx             ; Buf1
.text:0000219D                 call    ___@8           ; __(x,x)
.text:000021A2                 test    eax, eax
.text:000021A4                 jz      short loc_21B3
.text:000021A6                 mov     edx, [ebp+arg_8]
.text:000021A9                 mov     eax, [ebp+this]
.text:000021AC                 mov     [edx], eax
.text:000021AE                 jmp     loc_2275
.text:000021B3 ; ---------------------------------------------------------------------------
.text:000021B3
.text:000021B3 loc_21B3:                               ; CODE XREF: NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *)+34j
.text:000021B3                 push    offset _IID_ICompressCoder ; Buf2
.text:000021B8                 mov     ecx, [ebp+Buf1]
.text:000021BB                 push    ecx             ; Buf1
.text:000021BC                 call    ___@8           ; __(x,x)
.text:000021C1                 test    eax, eax
.text:000021C3                 jz      short loc_21D2
.text:000021C5                 mov     edx, [ebp+arg_8]
.text:000021C8                 mov     eax, [ebp+this]
.text:000021CB                 mov     [edx], eax
.text:000021CD                 jmp     loc_2275
.text:000021D2 ; ---------------------------------------------------------------------------
.text:000021D2
.text:000021D2 loc_21D2:                               ; CODE XREF: NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *)+53j
.text:000021D2                 push    offset _IID_ICompressSetInStream ; Buf2
.text:000021D7                 mov     ecx, [ebp+Buf1]
.text:000021DA                 push    ecx             ; Buf1
.text:000021DB                 call    ___@8           ; __(x,x)
.text:000021E0                 test    eax, eax
.text:000021E2                 jz      short loc_2206
.text:000021E4                 cmp     [ebp+this], 0
.text:000021E8                 jz      short loc_21F5
.text:000021EA                 mov     edx, [ebp+this]
.text:000021ED                 add     edx, 4
.text:000021F0                 mov     [ebp+var_4], edx
.text:000021F3                 jmp     short loc_21FC
.text:000021F5 ; ---------------------------------------------------------------------------
.text:000021F5
.text:000021F5 loc_21F5:                               ; CODE XREF: NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *)+78j
.text:000021F5                 mov     [ebp+var_4], 0
.text:000021FC
.text:000021FC loc_21FC:                               ; CODE XREF: NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *)+83j
.text:000021FC                 mov     eax, [ebp+arg_8]
.text:000021FF                 mov     ecx, [ebp+var_4]
.text:00002202                 mov     [eax], ecx
.text:00002204                 jmp     short loc_2275
.text:00002206 ; ---------------------------------------------------------------------------
.text:00002206
.text:00002206 loc_2206:                               ; CODE XREF: NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *)+72j
.text:00002206                 push    offset _IID_ISequentialInStream ; Buf2
.text:0000220B                 mov     edx, [ebp+Buf1]
.text:0000220E                 push    edx             ; Buf1
.text:0000220F                 call    ___@8           ; __(x,x)
.text:00002214                 test    eax, eax
.text:00002216                 jz      short loc_223A
.text:00002218                 cmp     [ebp+this], 0
.text:0000221C                 jz      short loc_2229
.text:0000221E                 mov     eax, [ebp+this]
.text:00002221                 add     eax, 8
.text:00002224                 mov     [ebp+var_8], eax
.text:00002227                 jmp     short loc_2230
.text:00002229 ; ---------------------------------------------------------------------------
.text:00002229
.text:00002229 loc_2229:                               ; CODE XREF: NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *)+ACj
.text:00002229                 mov     [ebp+var_8], 0
.text:00002230
.text:00002230 loc_2230:                               ; CODE XREF: NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *)+B7j
.text:00002230                 mov     ecx, [ebp+arg_8]
.text:00002233                 mov     edx, [ebp+var_8]
.text:00002236                 mov     [ecx], edx
.text:00002238                 jmp     short loc_2275
.text:0000223A ; ---------------------------------------------------------------------------
.text:0000223A
.text:0000223A loc_223A:                               ; CODE XREF: NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *)+A6j
.text:0000223A                 push    offset _IID_ICompressGetInStreamProcessedSize ; Buf2
.text:0000223F                 mov     eax, [ebp+Buf1]
.text:00002242                 push    eax             ; Buf1
.text:00002243                 call    ___@8           ; __(x,x)
.text:00002248                 test    eax, eax
.text:0000224A                 jz      short loc_226E
.text:0000224C                 cmp     [ebp+this], 0
.text:00002250                 jz      short loc_225D
.text:00002252                 mov     ecx, [ebp+this]
.text:00002255                 add     ecx, 0Ch
.text:00002258                 mov     [ebp+var_C], ecx
.text:0000225B                 jmp     short loc_2264
.text:0000225D ; ---------------------------------------------------------------------------
.text:0000225D
.text:0000225D loc_225D:                               ; CODE XREF: NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *)+E0j
.text:0000225D                 mov     [ebp+var_C], 0
.text:00002264
.text:00002264 loc_2264:                               ; CODE XREF: NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *)+EBj
.text:00002264                 mov     edx, [ebp+arg_8]
.text:00002267                 mov     eax, [ebp+var_C]
.text:0000226A                 mov     [edx], eax
.text:0000226C                 jmp     short loc_2275
.text:0000226E ; ---------------------------------------------------------------------------
.text:0000226E
.text:0000226E loc_226E:                               ; CODE XREF: NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *)+DAj
.text:0000226E                 mov     eax, 80004002h
.text:00002273                 jmp     short loc_2286
.text:00002275 ; ---------------------------------------------------------------------------
.text:00002275
.text:00002275 loc_2275:                               ; CODE XREF: NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *)+3Ej
.text:00002275                                         ; NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *)+5Dj ...
.text:00002275                 mov     ecx, [ebp+this]
.text:00002278                 mov     edx, [ecx+10h]
.text:0000227B                 add     edx, 1
.text:0000227E                 mov     eax, [ebp+this]
.text:00002281                 mov     [eax+10h], edx
.text:00002284                 xor     eax, eax
.text:00002286
.text:00002286 loc_2286:                               ; CODE XREF: NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *)+103j
.text:00002286                 add     esp, 0Ch
.text:00002289                 cmp     ebp, esp
.text:0000228B                 call    __RTC_CheckEsp
.text:00002290                 mov     esp, ebp
.text:00002292                 pop     ebp
.text:00002293                 retn    0Ch
.text:00002293 ?QueryInterface@CCopyCoder@NCompress@@UAGJABU_GUID@@PAPAX@Z endp
.text:00002293
.text:00002293 ; ---------------------------------------------------------------------------
.text:00002296                 align 4
.text:00002296 _text           ends
.text:00002296
.text:00002298 ; ===========================================================================
.text:00002298
.text:00002298 ; Segment type: Pure code
.text:00002298 ; Segment permissions: Read/Execute
.text:00002298 _text           segment para public 'CODE' use32
.text:00002298                 assume cs:_text
.text:00002298                 ;org 2298h
.text:00002298 ; COMDAT (pick any)
.text:00002298                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00002298
.text:00002298 ; =============== S U B R O U T I N E =======================================
.text:00002298
.text:00002298 ; Attributes: bp-based frame
.text:00002298
.text:00002298 ; int __stdcall __(void *Buf1, void *Buf2)
.text:00002298                 public ___@8
.text:00002298 ___@8           proc near               ; CODE XREF: NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *)+2Dp
.text:00002298                                         ; NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *)+4Cp ...
.text:00002298
.text:00002298 Buf1            = dword ptr  8
.text:00002298 Buf2            = dword ptr  0Ch
.text:00002298
.text:00002298                 push    ebp
.text:00002299                 mov     ebp, esp
.text:0000229B                 mov     eax, [ebp+Buf2]
.text:0000229E                 push    eax             ; Buf2
.text:0000229F                 mov     ecx, [ebp+Buf1]
.text:000022A2                 push    ecx             ; Buf1
.text:000022A3                 call    _IsEqualGUID@8  ; IsEqualGUID(x,x)
.text:000022A8                 cmp     ebp, esp
.text:000022AA                 call    __RTC_CheckEsp
.text:000022AF                 pop     ebp
.text:000022B0                 retn    8
.text:000022B0 ___@8           endp
.text:000022B0
.text:000022B0 ; ---------------------------------------------------------------------------
.text:000022B3                 align 4
.text:000022B3 _text           ends
.text:000022B3
.text:000022B4 ; ===========================================================================
.text:000022B4
.text:000022B4 ; Segment type: Pure code
.text:000022B4 ; Segment permissions: Read/Execute
.text:000022B4 _text           segment para public 'CODE' use32
.text:000022B4                 assume cs:_text
.text:000022B4                 ;org 22B4h
.text:000022B4 ; COMDAT (pick any)
.text:000022B4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:000022B4
.text:000022B4 ; =============== S U B R O U T I N E =======================================
.text:000022B4
.text:000022B4 ; Attributes: bp-based frame
.text:000022B4
.text:000022B4 ; int __stdcall IsEqualGUID(void *Buf1, void *Buf2)
.text:000022B4                 public _IsEqualGUID@8
.text:000022B4 _IsEqualGUID@8  proc near               ; CODE XREF: __(x,x)+Bp
.text:000022B4
.text:000022B4 Buf1            = dword ptr  8
.text:000022B4 Buf2            = dword ptr  0Ch
.text:000022B4
.text:000022B4                 push    ebp
.text:000022B5                 mov     ebp, esp
.text:000022B7                 push    10h             ; Size
.text:000022B9                 mov     eax, [ebp+Buf2]
.text:000022BC                 push    eax             ; Buf2
.text:000022BD                 mov     ecx, [ebp+Buf1]
.text:000022C0                 push    ecx             ; Buf1
.text:000022C1                 call    _memcmp
.text:000022C6                 add     esp, 0Ch
.text:000022C9                 neg     eax
.text:000022CB                 sbb     eax, eax
.text:000022CD                 add     eax, 1
.text:000022D0                 cmp     ebp, esp
.text:000022D2                 call    __RTC_CheckEsp
.text:000022D7                 pop     ebp
.text:000022D8                 retn    8
.text:000022D8 _IsEqualGUID@8  endp
.text:000022D8
.text:000022D8 ; ---------------------------------------------------------------------------
.text:000022DB                 align 4
.text:000022DB _text           ends
.text:000022DB
.text:000022DC ; ===========================================================================
.text:000022DC
.text:000022DC ; Segment type: Pure code
.text:000022DC ; Segment permissions: Read/Execute
.text:000022DC _text           segment para public 'CODE' use32
.text:000022DC                 assume cs:_text
.text:000022DC                 ;org 22DCh
.text:000022DC ; COMDAT (pick any)
.text:000022DC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:000022DC
.text:000022DC ; =============== S U B R O U T I N E =======================================
.text:000022DC
.text:000022DC ; Attributes: bp-based frame
.text:000022DC
.text:000022DC ; unsigned __int32 __stdcall NCompress::CCopyCoder::AddRef(NCompress::CCopyCoder *this)
.text:000022DC                 public ?AddRef@CCopyCoder@NCompress@@UAGKXZ
.text:000022DC ?AddRef@CCopyCoder@NCompress@@UAGKXZ proc near
.text:000022DC                                         ; CODE XREF: [thunk]:NCompress::CCopyCoder::AddRef`adjustor{4}' (void)+5j
.text:000022DC                                         ; [thunk]:NCompress::CCopyCoder::AddRef`adjustor{8}' (void)+5j ...
.text:000022DC
.text:000022DC var_4           = dword ptr -4
.text:000022DC this            = dword ptr  8
.text:000022DC
.text:000022DC                 push    ebp
.text:000022DD                 mov     ebp, esp
.text:000022DF                 push    ecx
.text:000022E0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000022E7                 mov     eax, [ebp+this]
.text:000022EA                 mov     ecx, [eax+10h]
.text:000022ED                 add     ecx, 1
.text:000022F0                 mov     [ebp+var_4], ecx
.text:000022F3                 mov     edx, [ebp+this]
.text:000022F6                 mov     eax, [ebp+var_4]
.text:000022F9                 mov     [edx+10h], eax
.text:000022FC                 mov     eax, [ebp+var_4]
.text:000022FF                 mov     esp, ebp
.text:00002301                 pop     ebp
.text:00002302                 retn    4
.text:00002302 ?AddRef@CCopyCoder@NCompress@@UAGKXZ endp
.text:00002302
.text:00002302 ; ---------------------------------------------------------------------------
.text:00002305                 align 4
.text:00002305 _text           ends
.text:00002305
.text:00002308 ; ===========================================================================
.text:00002308
.text:00002308 ; Segment type: Pure code
.text:00002308 ; Segment permissions: Read/Execute
.text:00002308 _text           segment para public 'CODE' use32
.text:00002308                 assume cs:_text
.text:00002308                 ;org 2308h
.text:00002308 ; COMDAT (pick any)
.text:00002308                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00002308
.text:00002308 ; =============== S U B R O U T I N E =======================================
.text:00002308
.text:00002308 ; Attributes: bp-based frame
.text:00002308
.text:00002308 ; unsigned __int32 __stdcall NCompress::CCopyCoder::Release(NCompress::CCopyCoder *this)
.text:00002308                 public ?Release@CCopyCoder@NCompress@@UAGKXZ
.text:00002308 ?Release@CCopyCoder@NCompress@@UAGKXZ proc near
.text:00002308                                         ; CODE XREF: [thunk]:NCompress::CCopyCoder::Release`adjustor{4}' (void)+5j
.text:00002308                                         ; [thunk]:NCompress::CCopyCoder::Release`adjustor{8}' (void)+5j ...
.text:00002308
.text:00002308 var_10          = dword ptr -10h
.text:00002308 var_C           = dword ptr -0Ch
.text:00002308 var_8           = dword ptr -8
.text:00002308 var_4           = dword ptr -4
.text:00002308 this            = dword ptr  8
.text:00002308
.text:00002308                 push    ebp
.text:00002309                 mov     ebp, esp
.text:0000230B                 sub     esp, 10h
.text:0000230E                 mov     eax, 0CCCCCCCCh
.text:00002313                 mov     [ebp+var_10], eax
.text:00002316                 mov     [ebp+var_C], eax
.text:00002319                 mov     [ebp+var_8], eax
.text:0000231C                 mov     [ebp+var_4], eax
.text:0000231F                 mov     eax, [ebp+this]
.text:00002322                 mov     ecx, [eax+10h]
.text:00002325                 sub     ecx, 1
.text:00002328                 mov     [ebp+var_C], ecx
.text:0000232B                 mov     edx, [ebp+this]
.text:0000232E                 mov     eax, [ebp+var_C]
.text:00002331                 mov     [edx+10h], eax
.text:00002334                 cmp     [ebp+var_C], 0
.text:00002338                 jz      short loc_2342
.text:0000233A                 mov     ecx, [ebp+this]
.text:0000233D                 mov     eax, [ecx+10h]
.text:00002340                 jmp     short loc_236C
.text:00002342 ; ---------------------------------------------------------------------------
.text:00002342
.text:00002342 loc_2342:                               ; CODE XREF: NCompress::CCopyCoder::Release(void)+30j
.text:00002342                 mov     edx, [ebp+this]
.text:00002345                 mov     [ebp+var_8], edx
.text:00002348                 mov     eax, [ebp+var_8]
.text:0000234B                 mov     [ebp+var_4], eax
.text:0000234E                 cmp     [ebp+var_4], 0
.text:00002352                 jz      short loc_2363
.text:00002354                 push    1
.text:00002356                 mov     ecx, [ebp+var_4]
.text:00002359                 call    ??_GCCopyCoder@NCompress@@QAEPAXI@Z ; NCompress::CCopyCoder::`scalar deleting destructor'(uint)
.text:0000235E                 mov     [ebp+var_10], eax
.text:00002361                 jmp     short loc_236A
.text:00002363 ; ---------------------------------------------------------------------------
.text:00002363
.text:00002363 loc_2363:                               ; CODE XREF: NCompress::CCopyCoder::Release(void)+4Aj
.text:00002363                 mov     [ebp+var_10], 0
.text:0000236A
.text:0000236A loc_236A:                               ; CODE XREF: NCompress::CCopyCoder::Release(void)+59j
.text:0000236A                 xor     eax, eax
.text:0000236C
.text:0000236C loc_236C:                               ; CODE XREF: NCompress::CCopyCoder::Release(void)+38j
.text:0000236C                 add     esp, 10h
.text:0000236F                 cmp     ebp, esp
.text:00002371                 call    __RTC_CheckEsp
.text:00002376                 mov     esp, ebp
.text:00002378                 pop     ebp
.text:00002379                 retn    4
.text:00002379 ?Release@CCopyCoder@NCompress@@UAGKXZ endp
.text:00002379
.text:00002379 _text           ends
.text:00002379
.text:0000237C ; ===========================================================================
.text:0000237C
.text:0000237C ; Segment type: Pure code
.text:0000237C ; Segment permissions: Read/Execute
.text:0000237C _text           segment para public 'CODE' use32
.text:0000237C                 assume cs:_text
.text:0000237C                 ;org 237Ch
.text:0000237C ; COMDAT (pick any)
.text:0000237C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:0000237C
.text:0000237C ; =============== S U B R O U T I N E =======================================
.text:0000237C
.text:0000237C ; Attributes: bp-based frame
.text:0000237C
.text:0000237C ; _DWORD __thiscall ICompressCoder::ICompressCoder(ICompressCoder *__hidden this)
.text:0000237C                 public ??0ICompressCoder@@QAE@XZ
.text:0000237C ??0ICompressCoder@@QAE@XZ proc near     ; CODE XREF: NCompress::CCopyCoder::CCopyCoder(void)+11p
.text:0000237C
.text:0000237C var_4           = dword ptr -4
.text:0000237C
.text:0000237C                 push    ebp
.text:0000237D                 mov     ebp, esp
.text:0000237F                 push    ecx
.text:00002380                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002387                 mov     [ebp+var_4], ecx
.text:0000238A                 mov     ecx, [ebp+var_4]
.text:0000238D                 call    ??0IUnknown@@QAE@XZ ; IUnknown::IUnknown(void)
.text:00002392                 mov     eax, [ebp+var_4]
.text:00002395                 mov     dword ptr [eax], offset ??_7ICompressCoder@@6B@ ; const ICompressCoder::`vftable'
.text:0000239B                 mov     eax, [ebp+var_4]
.text:0000239E                 add     esp, 4
.text:000023A1                 cmp     ebp, esp
.text:000023A3                 call    __RTC_CheckEsp
.text:000023A8                 mov     esp, ebp
.text:000023AA                 pop     ebp
.text:000023AB                 retn
.text:000023AB ??0ICompressCoder@@QAE@XZ endp
.text:000023AB
.text:000023AB _text           ends
.text:000023AB
.rdata:000023AC ; ===========================================================================
.rdata:000023AC
.rdata:000023AC ; Segment type: Pure data
.rdata:000023AC ; Segment permissions: Read
.rdata:000023AC _rdata          segment dword public 'DATA' use32
.rdata:000023AC                 assume cs:_rdata
.rdata:000023AC                 ;org 23ACh
.rdata:000023AC ; COMDAT (pick largest)
.rdata:000023AC                 dd offset ??_R4ICompressCoder@@6B@ ; const ICompressCoder::`RTTI Complete Object Locator'
.rdata:000023B0                 public ??_7ICompressCoder@@6B@
.rdata:000023B0 ; const ICompressCoder::`vftable'
.rdata:000023B0 ??_7ICompressCoder@@6B@ dd offset __purecall
.rdata:000023B0                                         ; DATA XREF: ICompressCoder::ICompressCoder(void)+19o
.rdata:000023B4                 dd offset __purecall
.rdata:000023B8                 dd offset __purecall
.rdata:000023BC                 dd offset __purecall
.rdata:000023BC _rdata          ends
.rdata:000023BC
.rdata$r:000023C0 ; ===========================================================================
.rdata$r:000023C0
.rdata$r:000023C0 ; Segment type: Pure data
.rdata$r:000023C0 ; Segment permissions: Read
.rdata$r:000023C0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000023C0                 assume cs:_rdata$r
.rdata$r:000023C0                 ;org 23C0h
.rdata$r:000023C0 ; COMDAT (pick any)
.rdata$r:000023C0                 public ??_R4ICompressCoder@@6B@
.rdata$r:000023C0 ; const ICompressCoder::`RTTI Complete Object Locator'
.rdata$r:000023C0 ??_R4ICompressCoder@@6B@ db    0        ; DATA XREF: .rdata:000023ACo
.rdata$r:000023C1                 db    0
.rdata$r:000023C2                 db    0
.rdata$r:000023C3                 db    0
.rdata$r:000023C4                 db    0
.rdata$r:000023C5                 db    0
.rdata$r:000023C6                 db    0
.rdata$r:000023C7                 db    0
.rdata$r:000023C8                 db    0
.rdata$r:000023C9                 db    0
.rdata$r:000023CA                 db    0
.rdata$r:000023CB                 db    0
.rdata$r:000023CC                 dd offset ??_R0?AUICompressCoder@@@8 ; ICompressCoder `RTTI Type Descriptor'
.rdata$r:000023D0                 dd offset ??_R3ICompressCoder@@8 ; ICompressCoder::`RTTI Class Hierarchy Descriptor'
.rdata$r:000023D0 _rdata$r        ends
.rdata$r:000023D0
.text:000023D4 ; ===========================================================================
.text:000023D4
.text:000023D4 ; Segment type: Pure code
.text:000023D4 ; Segment permissions: Read/Execute
.text:000023D4 _text           segment para public 'CODE' use32
.text:000023D4                 assume cs:_text
.text:000023D4                 ;org 23D4h
.text:000023D4 ; COMDAT (pick any)
.text:000023D4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:000023D4
.text:000023D4 ; =============== S U B R O U T I N E =======================================
.text:000023D4
.text:000023D4 ; Attributes: bp-based frame
.text:000023D4
.text:000023D4 ; _DWORD __thiscall ICompressSetInStream::ICompressSetInStream(ICompressSetInStream *__hidden this)
.text:000023D4                 public ??0ICompressSetInStream@@QAE@XZ
.text:000023D4 ??0ICompressSetInStream@@QAE@XZ proc near
.text:000023D4                                         ; CODE XREF: NCompress::CCopyCoder::CCopyCoder(void)+1Cp
.text:000023D4
.text:000023D4 var_4           = dword ptr -4
.text:000023D4
.text:000023D4                 push    ebp
.text:000023D5                 mov     ebp, esp
.text:000023D7                 push    ecx
.text:000023D8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000023DF                 mov     [ebp+var_4], ecx
.text:000023E2                 mov     ecx, [ebp+var_4]
.text:000023E5                 call    ??0IUnknown@@QAE@XZ ; IUnknown::IUnknown(void)
.text:000023EA                 mov     eax, [ebp+var_4]
.text:000023ED                 mov     dword ptr [eax], offset ??_7ICompressSetInStream@@6B@ ; const ICompressSetInStream::`vftable'
.text:000023F3                 mov     eax, [ebp+var_4]
.text:000023F6                 add     esp, 4
.text:000023F9                 cmp     ebp, esp
.text:000023FB                 call    __RTC_CheckEsp
.text:00002400                 mov     esp, ebp
.text:00002402                 pop     ebp
.text:00002403                 retn
.text:00002403 ??0ICompressSetInStream@@QAE@XZ endp
.text:00002403
.text:00002403 _text           ends
.text:00002403
.rdata:00002404 ; ===========================================================================
.rdata:00002404
.rdata:00002404 ; Segment type: Pure data
.rdata:00002404 ; Segment permissions: Read
.rdata:00002404 _rdata          segment dword public 'DATA' use32
.rdata:00002404                 assume cs:_rdata
.rdata:00002404                 ;org 2404h
.rdata:00002404 ; COMDAT (pick largest)
.rdata:00002404                 dd offset ??_R4ICompressSetInStream@@6B@ ; const ICompressSetInStream::`RTTI Complete Object Locator'
.rdata:00002408                 public ??_7ICompressSetInStream@@6B@
.rdata:00002408 ; const ICompressSetInStream::`vftable'
.rdata:00002408 ??_7ICompressSetInStream@@6B@ dd offset __purecall
.rdata:00002408                                         ; DATA XREF: ICompressSetInStream::ICompressSetInStream(void)+19o
.rdata:0000240C                 dd offset __purecall
.rdata:00002410                 dd offset __purecall
.rdata:00002414                 dd offset __purecall
.rdata:00002418                 dd offset __purecall
.rdata:00002418 _rdata          ends
.rdata:00002418
.rdata$r:0000241C ; ===========================================================================
.rdata$r:0000241C
.rdata$r:0000241C ; Segment type: Pure data
.rdata$r:0000241C ; Segment permissions: Read
.rdata$r:0000241C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000241C                 assume cs:_rdata$r
.rdata$r:0000241C                 ;org 241Ch
.rdata$r:0000241C ; COMDAT (pick any)
.rdata$r:0000241C                 public ??_R4ICompressSetInStream@@6B@
.rdata$r:0000241C ; const ICompressSetInStream::`RTTI Complete Object Locator'
.rdata$r:0000241C ??_R4ICompressSetInStream@@6B@ db    0  ; DATA XREF: .rdata:00002404o
.rdata$r:0000241D                 db    0
.rdata$r:0000241E                 db    0
.rdata$r:0000241F                 db    0
.rdata$r:00002420                 db    0
.rdata$r:00002421                 db    0
.rdata$r:00002422                 db    0
.rdata$r:00002423                 db    0
.rdata$r:00002424                 db    0
.rdata$r:00002425                 db    0
.rdata$r:00002426                 db    0
.rdata$r:00002427                 db    0
.rdata$r:00002428                 dd offset ??_R0?AUICompressSetInStream@@@8 ; ICompressSetInStream `RTTI Type Descriptor'
.rdata$r:0000242C                 dd offset ??_R3ICompressSetInStream@@8 ; ICompressSetInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000242C _rdata$r        ends
.rdata$r:0000242C
.text:00002430 ; ===========================================================================
.text:00002430
.text:00002430 ; Segment type: Pure code
.text:00002430 ; Segment permissions: Read/Execute
.text:00002430 _text           segment para public 'CODE' use32
.text:00002430                 assume cs:_text
.text:00002430                 ;org 2430h
.text:00002430 ; COMDAT (pick any)
.text:00002430                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00002430
.text:00002430 ; =============== S U B R O U T I N E =======================================
.text:00002430
.text:00002430 ; Attributes: bp-based frame
.text:00002430
.text:00002430 ; _DWORD __thiscall ISequentialInStream::ISequentialInStream(ISequentialInStream *__hidden this)
.text:00002430                 public ??0ISequentialInStream@@QAE@XZ
.text:00002430 ??0ISequentialInStream@@QAE@XZ proc near
.text:00002430                                         ; CODE XREF: NCompress::CCopyCoder::CCopyCoder(void)+27p
.text:00002430                                         ; CLimitedSequentialInStream::CLimitedSequentialInStream(void)+11p
.text:00002430
.text:00002430 var_4           = dword ptr -4
.text:00002430
.text:00002430                 push    ebp
.text:00002431                 mov     ebp, esp
.text:00002433                 push    ecx
.text:00002434                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000243B                 mov     [ebp+var_4], ecx
.text:0000243E                 mov     ecx, [ebp+var_4]
.text:00002441                 call    ??0IUnknown@@QAE@XZ ; IUnknown::IUnknown(void)
.text:00002446                 mov     eax, [ebp+var_4]
.text:00002449                 mov     dword ptr [eax], offset ??_7ISequentialInStream@@6B@ ; const ISequentialInStream::`vftable'
.text:0000244F                 mov     eax, [ebp+var_4]
.text:00002452                 add     esp, 4
.text:00002455                 cmp     ebp, esp
.text:00002457                 call    __RTC_CheckEsp
.text:0000245C                 mov     esp, ebp
.text:0000245E                 pop     ebp
.text:0000245F                 retn
.text:0000245F ??0ISequentialInStream@@QAE@XZ endp
.text:0000245F
.text:0000245F _text           ends
.text:0000245F
.rdata:00002460 ; ===========================================================================
.rdata:00002460
.rdata:00002460 ; Segment type: Pure data
.rdata:00002460 ; Segment permissions: Read
.rdata:00002460 _rdata          segment dword public 'DATA' use32
.rdata:00002460                 assume cs:_rdata
.rdata:00002460                 ;org 2460h
.rdata:00002460 ; COMDAT (pick largest)
.rdata:00002460                 dd offset ??_R4ISequentialInStream@@6B@ ; const ISequentialInStream::`RTTI Complete Object Locator'
.rdata:00002464                 public ??_7ISequentialInStream@@6B@
.rdata:00002464 ; const ISequentialInStream::`vftable'
.rdata:00002464 ??_7ISequentialInStream@@6B@ dd offset __purecall
.rdata:00002464                                         ; DATA XREF: ISequentialInStream::ISequentialInStream(void)+19o
.rdata:00002468                 dd offset __purecall
.rdata:0000246C                 dd offset __purecall
.rdata:00002470                 dd offset __purecall
.rdata:00002470 _rdata          ends
.rdata:00002470
.rdata$r:00002474 ; ===========================================================================
.rdata$r:00002474
.rdata$r:00002474 ; Segment type: Pure data
.rdata$r:00002474 ; Segment permissions: Read
.rdata$r:00002474 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002474                 assume cs:_rdata$r
.rdata$r:00002474                 ;org 2474h
.rdata$r:00002474 ; COMDAT (pick any)
.rdata$r:00002474                 public ??_R4ISequentialInStream@@6B@
.rdata$r:00002474 ; const ISequentialInStream::`RTTI Complete Object Locator'
.rdata$r:00002474 ??_R4ISequentialInStream@@6B@ db    0   ; DATA XREF: .rdata:00002460o
.rdata$r:00002475                 db    0
.rdata$r:00002476                 db    0
.rdata$r:00002477                 db    0
.rdata$r:00002478                 db    0
.rdata$r:00002479                 db    0
.rdata$r:0000247A                 db    0
.rdata$r:0000247B                 db    0
.rdata$r:0000247C                 db    0
.rdata$r:0000247D                 db    0
.rdata$r:0000247E                 db    0
.rdata$r:0000247F                 db    0
.rdata$r:00002480                 dd offset ??_R0?AUISequentialInStream@@@8 ; ISequentialInStream `RTTI Type Descriptor'
.rdata$r:00002484                 dd offset ??_R3ISequentialInStream@@8 ; ISequentialInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002484 _rdata$r        ends
.rdata$r:00002484
.text:00002488 ; ===========================================================================
.text:00002488
.text:00002488 ; Segment type: Pure code
.text:00002488 ; Segment permissions: Read/Execute
.text:00002488 _text           segment para public 'CODE' use32
.text:00002488                 assume cs:_text
.text:00002488                 ;org 2488h
.text:00002488 ; COMDAT (pick any)
.text:00002488                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00002488
.text:00002488 ; =============== S U B R O U T I N E =======================================
.text:00002488
.text:00002488 ; Attributes: bp-based frame
.text:00002488
.text:00002488 ; _DWORD __thiscall ICompressGetInStreamProcessedSize::ICompressGetInStreamProcessedSize(ICompressGetInStreamProcessedSize *__hidden this)
.text:00002488                 public ??0ICompressGetInStreamProcessedSize@@QAE@XZ
.text:00002488 ??0ICompressGetInStreamProcessedSize@@QAE@XZ proc near
.text:00002488                                         ; CODE XREF: NCompress::CCopyCoder::CCopyCoder(void)+32p
.text:00002488
.text:00002488 var_4           = dword ptr -4
.text:00002488
.text:00002488                 push    ebp
.text:00002489                 mov     ebp, esp
.text:0000248B                 push    ecx
.text:0000248C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002493                 mov     [ebp+var_4], ecx
.text:00002496                 mov     ecx, [ebp+var_4]
.text:00002499                 call    ??0IUnknown@@QAE@XZ ; IUnknown::IUnknown(void)
.text:0000249E                 mov     eax, [ebp+var_4]
.text:000024A1                 mov     dword ptr [eax], offset ??_7ICompressGetInStreamProcessedSize@@6B@ ; const ICompressGetInStreamProcessedSize::`vftable'
.text:000024A7                 mov     eax, [ebp+var_4]
.text:000024AA                 add     esp, 4
.text:000024AD                 cmp     ebp, esp
.text:000024AF                 call    __RTC_CheckEsp
.text:000024B4                 mov     esp, ebp
.text:000024B6                 pop     ebp
.text:000024B7                 retn
.text:000024B7 ??0ICompressGetInStreamProcessedSize@@QAE@XZ endp
.text:000024B7
.text:000024B7 _text           ends
.text:000024B7
.rdata:000024B8 ; ===========================================================================
.rdata:000024B8
.rdata:000024B8 ; Segment type: Pure data
.rdata:000024B8 ; Segment permissions: Read
.rdata:000024B8 _rdata          segment dword public 'DATA' use32
.rdata:000024B8                 assume cs:_rdata
.rdata:000024B8                 ;org 24B8h
.rdata:000024B8 ; COMDAT (pick largest)
.rdata:000024B8                 dd offset ??_R4ICompressGetInStreamProcessedSize@@6B@ ; const ICompressGetInStreamProcessedSize::`RTTI Complete Object Locator'
.rdata:000024BC                 public ??_7ICompressGetInStreamProcessedSize@@6B@
.rdata:000024BC ; const ICompressGetInStreamProcessedSize::`vftable'
.rdata:000024BC ??_7ICompressGetInStreamProcessedSize@@6B@ dd offset __purecall
.rdata:000024BC                                         ; DATA XREF: ICompressGetInStreamProcessedSize::ICompressGetInStreamProcessedSize(void)+19o
.rdata:000024C0                 dd offset __purecall
.rdata:000024C4                 dd offset __purecall
.rdata:000024C8                 dd offset __purecall
.rdata:000024C8 _rdata          ends
.rdata:000024C8
.rdata$r:000024CC ; ===========================================================================
.rdata$r:000024CC
.rdata$r:000024CC ; Segment type: Pure data
.rdata$r:000024CC ; Segment permissions: Read
.rdata$r:000024CC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000024CC                 assume cs:_rdata$r
.rdata$r:000024CC                 ;org 24CCh
.rdata$r:000024CC ; COMDAT (pick any)
.rdata$r:000024CC                 public ??_R4ICompressGetInStreamProcessedSize@@6B@
.rdata$r:000024CC ; const ICompressGetInStreamProcessedSize::`RTTI Complete Object Locator'
.rdata$r:000024CC ??_R4ICompressGetInStreamProcessedSize@@6B@ db    0
.rdata$r:000024CC                                         ; DATA XREF: .rdata:000024B8o
.rdata$r:000024CD                 db    0
.rdata$r:000024CE                 db    0
.rdata$r:000024CF                 db    0
.rdata$r:000024D0                 db    0
.rdata$r:000024D1                 db    0
.rdata$r:000024D2                 db    0
.rdata$r:000024D3                 db    0
.rdata$r:000024D4                 db    0
.rdata$r:000024D5                 db    0
.rdata$r:000024D6                 db    0
.rdata$r:000024D7                 db    0
.rdata$r:000024D8                 dd offset ??_R0?AUICompressGetInStreamProcessedSize@@@8 ; ICompressGetInStreamProcessedSize `RTTI Type Descriptor'
.rdata$r:000024DC                 dd offset ??_R3ICompressGetInStreamProcessedSize@@8 ; ICompressGetInStreamProcessedSize::`RTTI Class Hierarchy Descriptor'
.rdata$r:000024DC _rdata$r        ends
.rdata$r:000024DC
.text:000024E0 ; ===========================================================================
.text:000024E0
.text:000024E0 ; Segment type: Pure code
.text:000024E0 ; Segment permissions: Read/Execute
.text:000024E0 _text           segment para public 'CODE' use32
.text:000024E0                 assume cs:_text
.text:000024E0                 ;org 24E0h
.text:000024E0 ; COMDAT (pick any)
.text:000024E0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:000024E0
.text:000024E0 ; =============== S U B R O U T I N E =======================================
.text:000024E0
.text:000024E0 ; Attributes: bp-based frame
.text:000024E0
.text:000024E0 ; public: void * __thiscall NCompress::CCopyCoder::`scalar deleting destructor'(unsigned int)
.text:000024E0                 public ??_GCCopyCoder@NCompress@@QAEPAXI@Z
.text:000024E0 ??_GCCopyCoder@NCompress@@QAEPAXI@Z proc near
.text:000024E0                                         ; CODE XREF: NCompress::CCopyCoder::Release(void)+51p
.text:000024E0
.text:000024E0 var_4           = dword ptr -4
.text:000024E0 arg_0           = dword ptr  8
.text:000024E0
.text:000024E0                 push    ebp
.text:000024E1                 mov     ebp, esp
.text:000024E3                 push    ecx
.text:000024E4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000024EB                 mov     [ebp+var_4], ecx
.text:000024EE                 mov     ecx, [ebp+var_4] ; this
.text:000024F1                 call    ??1CCopyCoder@NCompress@@QAE@XZ ; NCompress::CCopyCoder::~CCopyCoder(void)
.text:000024F6                 mov     eax, [ebp+arg_0]
.text:000024F9                 and     eax, 1
.text:000024FC                 jz      short loc_250A
.text:000024FE                 mov     ecx, [ebp+var_4]
.text:00002501                 push    ecx             ; void *
.text:00002502                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00002507                 add     esp, 4
.text:0000250A
.text:0000250A loc_250A:                               ; CODE XREF: NCompress::CCopyCoder::`scalar deleting destructor'(uint)+1Cj
.text:0000250A                 mov     eax, [ebp+var_4]
.text:0000250D                 add     esp, 4
.text:00002510                 cmp     ebp, esp
.text:00002512                 call    __RTC_CheckEsp
.text:00002517                 mov     esp, ebp
.text:00002519                 pop     ebp
.text:0000251A                 retn    4
.text:0000251A ??_GCCopyCoder@NCompress@@QAEPAXI@Z endp
.text:0000251A
.text:0000251A ; ---------------------------------------------------------------------------
.text:0000251D                 align 10h
.text:0000251D _text           ends
.text:0000251D
.text:00002520 ; ===========================================================================
.text:00002520
.text:00002520 ; Segment type: Pure code
.text:00002520 ; Segment permissions: Read/Execute
.text:00002520 _text           segment para public 'CODE' use32
.text:00002520                 assume cs:_text
.text:00002520                 ;org 2520h
.text:00002520 ; COMDAT (pick any)
.text:00002520                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00002520
.text:00002520 ; =============== S U B R O U T I N E =======================================
.text:00002520
.text:00002520 ; Attributes: bp-based frame
.text:00002520
.text:00002520 ; public: __thiscall IUnknown::IUnknown(void)
.text:00002520                 public ??0IUnknown@@QAE@XZ
.text:00002520 ??0IUnknown@@QAE@XZ proc near           ; CODE XREF: ICompressCoder::ICompressCoder(void)+11p
.text:00002520                                         ; ICompressSetInStream::ICompressSetInStream(void)+11p ...
.text:00002520
.text:00002520 var_4           = dword ptr -4
.text:00002520
.text:00002520                 push    ebp
.text:00002521                 mov     ebp, esp
.text:00002523                 push    ecx
.text:00002524                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000252B                 mov     [ebp+var_4], ecx
.text:0000252E                 mov     eax, [ebp+var_4]
.text:00002531                 mov     esp, ebp
.text:00002533                 pop     ebp
.text:00002534                 retn
.text:00002534 ??0IUnknown@@QAE@XZ endp
.text:00002534
.text:00002534 ; ---------------------------------------------------------------------------
.text:00002535                 align 4
.text:00002535 _text           ends
.text:00002535
.text:00002538 ; ===========================================================================
.text:00002538
.text:00002538 ; Segment type: Pure code
.text:00002538 ; Segment permissions: Read/Execute
.text:00002538 _text           segment para public 'CODE' use32
.text:00002538                 assume cs:_text
.text:00002538                 ;org 2538h
.text:00002538 ; COMDAT (pick any)
.text:00002538                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00002538
.text:00002538 ; =============== S U B R O U T I N E =======================================
.text:00002538
.text:00002538 ; Attributes: bp-based frame
.text:00002538
.text:00002538 ; _DWORD __thiscall AString::~AString(AString *__hidden this)
.text:00002538                 public ??1AString@@QAE@XZ
.text:00002538 ??1AString@@QAE@XZ proc near            ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+56Bp
.text:00002538                                         ; NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+684p ...
.text:00002538
.text:00002538 var_8           = dword ptr -8
.text:00002538 var_4           = dword ptr -4
.text:00002538
.text:00002538                 push    ebp
.text:00002539                 mov     ebp, esp
.text:0000253B                 sub     esp, 8
.text:0000253E                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00002545                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000254C                 mov     [ebp+var_4], ecx
.text:0000254F                 mov     eax, [ebp+var_4]
.text:00002552                 mov     ecx, [eax]
.text:00002554                 mov     [ebp+var_8], ecx
.text:00002557                 mov     edx, [ebp+var_8]
.text:0000255A                 push    edx             ; void *
.text:0000255B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00002560                 add     esp, 4
.text:00002563                 add     esp, 8
.text:00002566                 cmp     ebp, esp
.text:00002568                 call    __RTC_CheckEsp
.text:0000256D                 mov     esp, ebp
.text:0000256F                 pop     ebp
.text:00002570                 retn
.text:00002570 ??1AString@@QAE@XZ endp
.text:00002570
.text:00002570 ; ---------------------------------------------------------------------------
.text:00002571                 align 4
.text:00002571 _text           ends
.text:00002571
.text:00002574 ; ===========================================================================
.text:00002574
.text:00002574 ; Segment type: Pure code
.text:00002574 ; Segment permissions: Read/Execute
.text:00002574 _text           segment para public 'CODE' use32
.text:00002574                 assume cs:_text
.text:00002574                 ;org 2574h
.text:00002574 ; COMDAT (pick any)
.text:00002574                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00002574
.text:00002574 ; =============== S U B R O U T I N E =======================================
.text:00002574
.text:00002574 ; Attributes: bp-based frame
.text:00002574
.text:00002574 ; bool __thiscall AString::IsEmpty(AString *__hidden this)
.text:00002574                 public ?IsEmpty@AString@@QBE_NXZ
.text:00002574 ?IsEmpty@AString@@QBE_NXZ proc near     ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+5DBp
.text:00002574                                         ; NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+70Ap ...
.text:00002574
.text:00002574 var_4           = dword ptr -4
.text:00002574
.text:00002574                 push    ebp
.text:00002575                 mov     ebp, esp
.text:00002577                 push    ecx
.text:00002578                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000257F                 mov     [ebp+var_4], ecx
.text:00002582                 mov     eax, [ebp+var_4]
.text:00002585                 xor     ecx, ecx
.text:00002587                 cmp     dword ptr [eax+4], 0
.text:0000258B                 setz    cl
.text:0000258E                 mov     al, cl
.text:00002590                 mov     esp, ebp
.text:00002592                 pop     ebp
.text:00002593                 retn
.text:00002593 ?IsEmpty@AString@@QBE_NXZ endp
.text:00002593
.text:00002593 _text           ends
.text:00002593
.text:00002594 ; ===========================================================================
.text:00002594
.text:00002594 ; Segment type: Pure code
.text:00002594 ; Segment permissions: Read/Execute
.text:00002594 _text           segment para public 'CODE' use32
.text:00002594                 assume cs:_text
.text:00002594                 ;org 2594h
.text:00002594 ; COMDAT (pick any)
.text:00002594                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00002594
.text:00002594 ; =============== S U B R O U T I N E =======================================
.text:00002594
.text:00002594 ; Attributes: bp-based frame
.text:00002594
.text:00002594 ; bool __thiscall NArchive::NTar::CItem::IsDir(NArchive::NTar::CItem *__hidden this)
.text:00002594                 public ?IsDir@CItem@NTar@NArchive@@QBE_NXZ
.text:00002594 ?IsDir@CItem@NTar@NArchive@@QBE_NXZ proc near
.text:00002594                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+1210p
.text:00002594
.text:00002594 var_8           = dword ptr -8
.text:00002594 var_4           = dword ptr -4
.text:00002594
.text:00002594                 push    ebp
.text:00002595                 mov     ebp, esp
.text:00002597                 sub     esp, 8
.text:0000259A                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000025A1                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000025A8                 mov     [ebp+var_4], ecx
.text:000025AB                 mov     eax, [ebp+var_4]
.text:000025AE                 movsx   ecx, byte ptr [eax+68h]
.text:000025B2                 mov     [ebp+var_8], ecx
.text:000025B5                 cmp     [ebp+var_8], 44h ; 'D' ; switch 69 cases
.text:000025B9                 ja      short $LN3      ; jumptable 000025C5 default case
.text:000025BB                 mov     edx, [ebp+var_8]
.text:000025BE                 movzx   eax, ds:$LN7[edx]
.text:000025C5                 jmp     ds:$LN8[eax*4]  ; switch jump
.text:000025CC ; ---------------------------------------------------------------------------
.text:000025CC
.text:000025CC $LN2:                                   ; CODE XREF: NArchive::NTar::CItem::IsDir(void)+31j
.text:000025CC                                         ; DATA XREF: .text:$LN8o
.text:000025CC                 mov     al, 1           ; jumptable 000025C5 cases 53,68
.text:000025CE                 jmp     short loc_25DF
.text:000025D0 ; ---------------------------------------------------------------------------
.text:000025D0
.text:000025D0 $LN1:                                   ; CODE XREF: NArchive::NTar::CItem::IsDir(void)+31j
.text:000025D0                                         ; DATA XREF: .text:$LN8o
.text:000025D0                 push    offset loc_1    ; jumptable 000025C5 cases 0,48,50
.text:000025D2                 mov     ecx, [ebp+var_4]
.text:000025D5                 push    ecx             ; this
.text:000025D6                 call    ?HasTailSlash@NItemName@NArchive@@YG_NABVAString@@I@Z ; NArchive::NItemName::HasTailSlash(AString const &,uint)
.text:000025DB                 jmp     short loc_25DF
.text:000025DD ; ---------------------------------------------------------------------------
.text:000025DD
.text:000025DD $LN3:                                   ; CODE XREF: NArchive::NTar::CItem::IsDir(void)+25j
.text:000025DD                                         ; NArchive::NTar::CItem::IsDir(void)+31j
.text:000025DD                                         ; DATA XREF: ...
.text:000025DD                 xor     al, al          ; jumptable 000025C5 default case
.text:000025DF
.text:000025DF loc_25DF:                               ; CODE XREF: NArchive::NTar::CItem::IsDir(void)+3Aj
.text:000025DF                                         ; NArchive::NTar::CItem::IsDir(void)+47j
.text:000025DF                 add     esp, 8
.text:000025E2                 cmp     ebp, esp
.text:000025E4                 call    __RTC_CheckEsp
.text:000025E9                 mov     esp, ebp
.text:000025EB                 pop     ebp
.text:000025EC                 retn
.text:000025EC ?IsDir@CItem@NTar@NArchive@@QBE_NXZ endp ; sp-analysis failed
.text:000025EC
.text:000025EC ; ---------------------------------------------------------------------------
.text:000025ED                 align 10h
.text:000025F0 $LN8            dd offset $LN1, offset $LN2, offset $LN3
.text:000025F0                                         ; DATA XREF: NArchive::NTar::CItem::IsDir(void)+31r
.text:000025F0                                         ; jump table for switch statement
.text:000025FC $LN7            db      0,     2,     2,     2
.text:000025FC                                         ; DATA XREF: NArchive::NTar::CItem::IsDir(void)+2Ar
.text:000025FC                 db      2,     2,     2,     2 ; indirect table for switch statement
.text:000025FC                 db      2,     2,     2,     2
.text:000025FC                 db      2,     2,     2,     2
.text:000025FC                 db      2,     2,     2,     2
.text:000025FC                 db      2,     2,     2,     2
.text:000025FC                 db      2,     2,     2,     2
.text:000025FC                 db      2,     2,     2,     2
.text:000025FC                 db      2,     2,     2,     2
.text:000025FC                 db      2,     2,     2,     2
.text:000025FC                 db      2,     2,     2,     2
.text:000025FC                 db      2,     2,     2,     2
.text:000025FC                 db      0,     2,     0,     2
.text:000025FC                 db      2,     1,     2,     2
.text:000025FC                 db      2,     2,     2,     2
.text:000025FC                 db      2,     2,     2,     2
.text:000025FC                 db      2,     2,     2,     2
.text:000025FC                 db      1
.text:00002641                 align 4
.text:00002641 _text           ends
.text:00002641
.text:00002644 ; ===========================================================================
.text:00002644
.text:00002644 ; Segment type: Pure code
.text:00002644 ; Segment permissions: Read/Execute
.text:00002644 _text           segment para public 'CODE' use32
.text:00002644                 assume cs:_text
.text:00002644                 ;org 2644h
.text:00002644 ; COMDAT (pick any)
.text:00002644                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00002644
.text:00002644 ; =============== S U B R O U T I N E =======================================
.text:00002644
.text:00002644 ; Attributes: bp-based frame
.text:00002644
.text:00002644 ; unsigned __int64 __thiscall NArchive::NTar::CItemEx::GetDataPosition(NArchive::NTar::CItemEx *__hidden this)
.text:00002644                 public ?GetDataPosition@CItemEx@NTar@NArchive@@QBE_KXZ
.text:00002644 ?GetDataPosition@CItemEx@NTar@NArchive@@QBE_KXZ proc near
.text:00002644                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+1378p
.text:00002644
.text:00002644 var_4           = dword ptr -4
.text:00002644
.text:00002644                 push    ebp
.text:00002645                 mov     ebp, esp
.text:00002647                 push    ecx
.text:00002648                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000264F                 mov     [ebp+var_4], ecx
.text:00002652                 mov     eax, [ebp+var_4]
.text:00002655                 mov     eax, [eax+80h]
.text:0000265B                 xor     edx, edx
.text:0000265D                 mov     ecx, [ebp+var_4]
.text:00002660                 add     eax, [ecx+78h]
.text:00002663                 adc     edx, [ecx+7Ch]
.text:00002666                 mov     esp, ebp
.text:00002668                 pop     ebp
.text:00002669                 retn
.text:00002669 ?GetDataPosition@CItemEx@NTar@NArchive@@QBE_KXZ endp
.text:00002669
.text:00002669 ; ---------------------------------------------------------------------------
.text:0000266A                 align 4
.text:0000266A _text           ends
.text:0000266A
.text:0000266C ; ===========================================================================
.text:0000266C
.text:0000266C ; Segment type: Pure code
.text:0000266C ; Segment permissions: Read/Execute
.text:0000266C _text           segment para public 'CODE' use32
.text:0000266C                 assume cs:_text
.text:0000266C                 ;org 266Ch
.text:0000266C ; COMDAT (pick any)
.text:0000266C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:0000266C
.text:0000266C ; =============== S U B R O U T I N E =======================================
.text:0000266C
.text:0000266C ; Attributes: bp-based frame
.text:0000266C
.text:0000266C ; unsigned __int64 __thiscall NArchive::NTar::CItemEx::GetFullSize(NArchive::NTar::CItemEx *__hidden this)
.text:0000266C                 public ?GetFullSize@CItemEx@NTar@NArchive@@QBE_KXZ
.text:0000266C ?GetFullSize@CItemEx@NTar@NArchive@@QBE_KXZ proc near
.text:0000266C                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+136p
.text:0000266C                                         ; NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+1506p
.text:0000266C
.text:0000266C var_4           = dword ptr -4
.text:0000266C
.text:0000266C                 push    ebp
.text:0000266D                 mov     ebp, esp
.text:0000266F                 push    ecx
.text:00002670                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002677                 mov     [ebp+var_4], ecx
.text:0000267A                 mov     eax, [ebp+var_4]
.text:0000267D                 mov     eax, [eax+80h]
.text:00002683                 xor     edx, edx
.text:00002685                 mov     ecx, [ebp+var_4]
.text:00002688                 add     eax, [ecx+10h]
.text:0000268B                 adc     edx, [ecx+14h]
.text:0000268E                 mov     esp, ebp
.text:00002690                 pop     ebp
.text:00002691                 retn
.text:00002691 ?GetFullSize@CItemEx@NTar@NArchive@@QBE_KXZ endp
.text:00002691
.text:00002691 ; ---------------------------------------------------------------------------
.text:00002692                 align 4
.text:00002692 _text           ends
.text:00002692
.text:00002694 ; ===========================================================================
.text:00002694
.text:00002694 ; Segment type: Pure code
.text:00002694 ; Segment permissions: Read/Execute
.text:00002694 _text           segment para public 'CODE' use32
.text:00002694                 assume cs:_text
.text:00002694                 ;org 2694h
.text:00002694 ; COMDAT (pick any)
.text:00002694                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00002694
.text:00002694 ; =============== S U B R O U T I N E =======================================
.text:00002694
.text:00002694 ; Attributes: bp-based frame
.text:00002694
.text:00002694 ; void __thiscall NArchive::NTar::COutArchive::Create(NArchive::NTar::COutArchive *this, struct ISequentialOutStream *)
.text:00002694                 public ?Create@COutArchive@NTar@NArchive@@QAEXPAUISequentialOutStream@@@Z
.text:00002694 ?Create@COutArchive@NTar@NArchive@@QAEXPAUISequentialOutStream@@@Z proc near
.text:00002694                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+55p
.text:00002694
.text:00002694 var_4           = dword ptr -4
.text:00002694 arg_0           = dword ptr  8
.text:00002694
.text:00002694                 push    ebp
.text:00002695                 mov     ebp, esp
.text:00002697                 push    ecx
.text:00002698                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000269F                 mov     [ebp+var_4], ecx
.text:000026A2                 mov     eax, [ebp+arg_0]
.text:000026A5                 push    eax
.text:000026A6                 mov     ecx, [ebp+var_4]
.text:000026A9                 call    ??4?$CMyComPtr@UISequentialOutStream@@@@QAEPAUISequentialOutStream@@PAU1@@Z ; CMyComPtr<ISequentialOutStream>::operator=(ISequentialOutStream *)
.text:000026AE                 add     esp, 4
.text:000026B1                 cmp     ebp, esp
.text:000026B3                 call    __RTC_CheckEsp
.text:000026B8                 mov     esp, ebp
.text:000026BA                 pop     ebp
.text:000026BB                 retn    4
.text:000026BB ?Create@COutArchive@NTar@NArchive@@QAEXPAUISequentialOutStream@@@Z endp
.text:000026BB
.text:000026BB ; ---------------------------------------------------------------------------
.text:000026BE                 align 10h
.text:000026BE _text           ends
.text:000026BE
.text:000026C0 ; ===========================================================================
.text:000026C0
.text:000026C0 ; Segment type: Pure code
.text:000026C0 ; Segment permissions: Read/Execute
.text:000026C0 _text           segment para public 'CODE' use32
.text:000026C0                 assume cs:_text
.text:000026C0                 ;org 26C0h
.text:000026C0 ; COMDAT (pick any)
.text:000026C0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:000026C0
.text:000026C0 ; =============== S U B R O U T I N E =======================================
.text:000026C0
.text:000026C0 ; Attributes: bp-based frame
.text:000026C0
.text:000026C0 ; _DWORD __thiscall NArchive::NTar::COutArchive::COutArchive(NArchive::NTar::COutArchive *__hidden this)
.text:000026C0                 public ??0COutArchive@NTar@NArchive@@QAE@XZ
.text:000026C0 ??0COutArchive@NTar@NArchive@@QAE@XZ proc near
.text:000026C0                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+42p
.text:000026C0
.text:000026C0 var_4           = dword ptr -4
.text:000026C0
.text:000026C0                 push    ebp
.text:000026C1                 mov     ebp, esp
.text:000026C3                 push    ecx
.text:000026C4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000026CB                 mov     [ebp+var_4], ecx
.text:000026CE                 mov     ecx, [ebp+var_4]
.text:000026D1                 call    ??0?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::CMyComPtr<ISequentialOutStream>(void)
.text:000026D6                 mov     eax, [ebp+var_4]
.text:000026D9                 add     esp, 4
.text:000026DC                 cmp     ebp, esp
.text:000026DE                 call    __RTC_CheckEsp
.text:000026E3                 mov     esp, ebp
.text:000026E5                 pop     ebp
.text:000026E6                 retn
.text:000026E6 ??0COutArchive@NTar@NArchive@@QAE@XZ endp
.text:000026E6
.text:000026E6 ; ---------------------------------------------------------------------------
.text:000026E7                 align 4
.text:000026E7 _text           ends
.text:000026E7
.text:000026E8 ; ===========================================================================
.text:000026E8
.text:000026E8 ; Segment type: Pure code
.text:000026E8 ; Segment permissions: Read/Execute
.text:000026E8 _text           segment para public 'CODE' use32
.text:000026E8                 assume cs:_text
.text:000026E8                 ;org 26E8h
.text:000026E8 ; COMDAT (pick any)
.text:000026E8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:000026E8
.text:000026E8 ; =============== S U B R O U T I N E =======================================
.text:000026E8
.text:000026E8 ; Attributes: bp-based frame
.text:000026E8
.text:000026E8 ; _DWORD __thiscall NArchive::NTar::COutArchive::~COutArchive(NArchive::NTar::COutArchive *__hidden this)
.text:000026E8                 public ??1COutArchive@NTar@NArchive@@QAE@XZ
.text:000026E8 ??1COutArchive@NTar@NArchive@@QAE@XZ proc near
.text:000026E8                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+19Cp
.text:000026E8                                         ; NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+3A7p ...
.text:000026E8
.text:000026E8 var_4           = dword ptr -4
.text:000026E8
.text:000026E8                 push    ebp
.text:000026E9                 mov     ebp, esp
.text:000026EB                 push    ecx
.text:000026EC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000026F3                 mov     [ebp+var_4], ecx
.text:000026F6                 mov     ecx, [ebp+var_4]
.text:000026F9                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:000026FE                 add     esp, 4
.text:00002701                 cmp     ebp, esp
.text:00002703                 call    __RTC_CheckEsp
.text:00002708                 mov     esp, ebp
.text:0000270A                 pop     ebp
.text:0000270B                 retn
.text:0000270B ??1COutArchive@NTar@NArchive@@QAE@XZ endp
.text:0000270B
.text:0000270B _text           ends
.text:0000270B
.text:0000270C ; ===========================================================================
.text:0000270C
.text:0000270C ; Segment type: Pure code
.text:0000270C ; Segment permissions: Read/Execute
.text:0000270C _text           segment para public 'CODE' use32
.text:0000270C                 assume cs:_text
.text:0000270C                 ;org 270Ch
.text:0000270C ; COMDAT (pick any)
.text:0000270C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:0000270C
.text:0000270C ; =============== S U B R O U T I N E =======================================
.text:0000270C
.text:0000270C ; Attributes: bp-based frame
.text:0000270C
.text:0000270C ; public: __thiscall CLimitedSequentialInStream::CLimitedSequentialInStream(void)
.text:0000270C                 public ??0CLimitedSequentialInStream@@QAE@XZ
.text:0000270C ??0CLimitedSequentialInStream@@QAE@XZ proc near
.text:0000270C                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+2A3p
.text:0000270C
.text:0000270C var_4           = dword ptr -4
.text:0000270C
.text:0000270C                 push    ebp
.text:0000270D                 mov     ebp, esp
.text:0000270F                 push    ecx
.text:00002710                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002717                 mov     [ebp+var_4], ecx
.text:0000271A                 mov     ecx, [ebp+var_4] ; this
.text:0000271D                 call    ??0ISequentialInStream@@QAE@XZ ; ISequentialInStream::ISequentialInStream(void)
.text:00002722                 mov     ecx, [ebp+var_4]
.text:00002725                 add     ecx, 4          ; this
.text:00002728                 call    ??0CMyUnknownImp@@QAE@XZ ; CMyUnknownImp::CMyUnknownImp(void)
.text:0000272D                 mov     eax, [ebp+var_4]
.text:00002730                 mov     dword ptr [eax], offset ??_7CLimitedSequentialInStream@@6B@ ; const CLimitedSequentialInStream::`vftable'
.text:00002736                 mov     ecx, [ebp+var_4]
.text:00002739                 add     ecx, 8
.text:0000273C                 call    ??0?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::CMyComPtr<ISequentialInStream>(void)
.text:00002741                 mov     eax, [ebp+var_4]
.text:00002744                 add     esp, 4
.text:00002747                 cmp     ebp, esp
.text:00002749                 call    __RTC_CheckEsp
.text:0000274E                 mov     esp, ebp
.text:00002750                 pop     ebp
.text:00002751                 retn
.text:00002751 ??0CLimitedSequentialInStream@@QAE@XZ endp
.text:00002751
.text:00002751 ; ---------------------------------------------------------------------------
.text:00002752                 align 4
.text:00002752 _text           ends
.text:00002752
.rdata:00002754 ; ===========================================================================
.rdata:00002754
.rdata:00002754 ; Segment type: Pure data
.rdata:00002754 ; Segment permissions: Read
.rdata:00002754 _rdata          segment dword public 'DATA' use32
.rdata:00002754                 assume cs:_rdata
.rdata:00002754                 ;org 2754h
.rdata:00002754 ; COMDAT (pick largest)
.rdata:00002754                 dd offset ??_R4CLimitedSequentialInStream@@6B@ ; const CLimitedSequentialInStream::`RTTI Complete Object Locator'
.rdata:00002758                 public ??_7CLimitedSequentialInStream@@6B@
.rdata:00002758 ; const CLimitedSequentialInStream::`vftable'
.rdata:00002758 ??_7CLimitedSequentialInStream@@6B@ dd offset ?QueryInterface@CLimitedSequentialInStream@@UAGJABU_GUID@@PAPAX@Z
.rdata:00002758                                         ; DATA XREF: CLimitedSequentialInStream::CLimitedSequentialInStream(void)+24o
.rdata:00002758                                         ; CLimitedSequentialInStream::QueryInterface(_GUID const &,void * *)
.rdata:0000275C                 dd offset ?AddRef@CLimitedSequentialInStream@@UAGKXZ ; CLimitedSequentialInStream::AddRef(void)
.rdata:00002760                 dd offset ?Release@CLimitedSequentialInStream@@UAGKXZ ; CLimitedSequentialInStream::Release(void)
.rdata:00002764                 dd offset ?Read@CLimitedSequentialInStream@@UAGJPAXIPAI@Z ; CLimitedSequentialInStream::Read(void *,uint,uint *)
.rdata:00002764 _rdata          ends
.rdata:00002764
.rdata$r:00002768 ; ===========================================================================
.rdata$r:00002768
.rdata$r:00002768 ; Segment type: Pure data
.rdata$r:00002768 ; Segment permissions: Read
.rdata$r:00002768 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002768                 assume cs:_rdata$r
.rdata$r:00002768                 ;org 2768h
.rdata$r:00002768 ; COMDAT (pick any)
.rdata$r:00002768                 public ??_R4CLimitedSequentialInStream@@6B@
.rdata$r:00002768 ; const CLimitedSequentialInStream::`RTTI Complete Object Locator'
.rdata$r:00002768 ??_R4CLimitedSequentialInStream@@6B@ db    0 ; DATA XREF: .rdata:00002754o
.rdata$r:00002769                 db    0
.rdata$r:0000276A                 db    0
.rdata$r:0000276B                 db    0
.rdata$r:0000276C                 db    0
.rdata$r:0000276D                 db    0
.rdata$r:0000276E                 db    0
.rdata$r:0000276F                 db    0
.rdata$r:00002770                 db    0
.rdata$r:00002771                 db    0
.rdata$r:00002772                 db    0
.rdata$r:00002773                 db    0
.rdata$r:00002774                 dd offset ??_R0?AVCLimitedSequentialInStream@@@8 ; CLimitedSequentialInStream `RTTI Type Descriptor'
.rdata$r:00002778                 dd offset ??_R3CLimitedSequentialInStream@@8 ; CLimitedSequentialInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002778 _rdata$r        ends
.rdata$r:00002778
.data:0000277C ; ===========================================================================
.data:0000277C
.data:0000277C ; Segment type: Pure data
.data:0000277C ; Segment permissions: Read/Write
.data:0000277C _data           segment dword public 'DATA' use32
.data:0000277C                 assume cs:_data
.data:0000277C                 ;org 277Ch
.data:0000277C ; COMDAT (pick any)
.data:0000277C                 public ??_R0?AVCLimitedSequentialInStream@@@8
.data:0000277C ; class CLimitedSequentialInStream `RTTI Type Descriptor'
.data:0000277C ??_R0?AVCLimitedSequentialInStream@@@8 dd offset ??_7type_info@@6B@
.data:0000277C                                         ; DATA XREF: .rdata$r:00002774o
.data:0000277C                                         ; .rdata$r:CLimitedSequentialInStream::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:0000277C                                         ; const type_info::`vftable'
.data:00002780                 db    0
.data:00002781                 db    0
.data:00002782                 db    0
.data:00002783                 db    0
.data:00002784                 db  2Eh ; .
.data:00002785                 db  3Fh ; ?
.data:00002786                 db  41h ; A
.data:00002787                 db  56h ; V
.data:00002788                 db  43h ; C
.data:00002789                 db  4Ch ; L
.data:0000278A                 db  69h ; i
.data:0000278B                 db  6Dh ; m
.data:0000278C                 db  69h ; i
.data:0000278D                 db  74h ; t
.data:0000278E                 db  65h ; e
.data:0000278F                 db  64h ; d
.data:00002790                 db  53h ; S
.data:00002791                 db  65h ; e
.data:00002792                 db  71h ; q
.data:00002793                 db  75h ; u
.data:00002794                 db  65h ; e
.data:00002795                 db  6Eh ; n
.data:00002796                 db  74h ; t
.data:00002797                 db  69h ; i
.data:00002798                 db  61h ; a
.data:00002799                 db  6Ch ; l
.data:0000279A                 db  49h ; I
.data:0000279B                 db  6Eh ; n
.data:0000279C                 db  53h ; S
.data:0000279D                 db  74h ; t
.data:0000279E                 db  72h ; r
.data:0000279F                 db  65h ; e
.data:000027A0                 db  61h ; a
.data:000027A1                 db  6Dh ; m
.data:000027A2                 db  40h ; @
.data:000027A3                 db  40h ; @
.data:000027A4                 db    0
.data:000027A5                 align 4
.data:000027A5 _data           ends
.data:000027A5
.rdata$r:000027A8 ; ===========================================================================
.rdata$r:000027A8
.rdata$r:000027A8 ; Segment type: Pure data
.rdata$r:000027A8 ; Segment permissions: Read
.rdata$r:000027A8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000027A8                 assume cs:_rdata$r
.rdata$r:000027A8                 ;org 27A8h
.rdata$r:000027A8 ; COMDAT (pick any)
.rdata$r:000027A8                 public ??_R3CLimitedSequentialInStream@@8
.rdata$r:000027A8 ; CLimitedSequentialInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:000027A8 ??_R3CLimitedSequentialInStream@@8 db    0 ; DATA XREF: .rdata$r:00002778o
.rdata$r:000027A8                                         ; .rdata$r:000027E4o
.rdata$r:000027A9                 db    0
.rdata$r:000027AA                 db    0
.rdata$r:000027AB                 db    0
.rdata$r:000027AC                 db    1
.rdata$r:000027AD                 db    0
.rdata$r:000027AE                 db    0
.rdata$r:000027AF                 db    0
.rdata$r:000027B0                 db    4
.rdata$r:000027B1                 db    0
.rdata$r:000027B2                 db    0
.rdata$r:000027B3                 db    0
.rdata$r:000027B4                 dd offset ??_R2CLimitedSequentialInStream@@8 ; CLimitedSequentialInStream::`RTTI Base Class Array'
.rdata$r:000027B4 _rdata$r        ends
.rdata$r:000027B4
.rdata$r:000027B8 ; ===========================================================================
.rdata$r:000027B8
.rdata$r:000027B8 ; Segment type: Pure data
.rdata$r:000027B8 ; Segment permissions: Read
.rdata$r:000027B8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000027B8                 assume cs:_rdata$r
.rdata$r:000027B8                 ;org 27B8h
.rdata$r:000027B8 ; COMDAT (pick any)
.rdata$r:000027B8                 public ??_R2CLimitedSequentialInStream@@8
.rdata$r:000027B8 ; CLimitedSequentialInStream::`RTTI Base Class Array'
.rdata$r:000027B8 ??_R2CLimitedSequentialInStream@@8 dd offset ??_R1A@?0A@EA@CLimitedSequentialInStream@@8
.rdata$r:000027B8                                         ; DATA XREF: .rdata$r:000027B4o
.rdata$r:000027B8                                         ; CLimitedSequentialInStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000027BC                 dd offset ??_R1A@?0A@EA@ISequentialInStream@@8 ; ISequentialInStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000027C0                 dd offset ??_R1A@?0A@EA@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000027C4                 dd offset ??_R13?0A@EA@CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Base Class Descriptor at (4,-1,0,64)'
.rdata$r:000027C8                 db    0
.rdata$r:000027C9                 align 4
.rdata$r:000027C9 _rdata$r        ends
.rdata$r:000027C9
.rdata$r:000027CC ; ===========================================================================
.rdata$r:000027CC
.rdata$r:000027CC ; Segment type: Pure data
.rdata$r:000027CC ; Segment permissions: Read
.rdata$r:000027CC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000027CC                 assume cs:_rdata$r
.rdata$r:000027CC                 ;org 27CCh
.rdata$r:000027CC ; COMDAT (pick any)
.rdata$r:000027CC                 public ??_R1A@?0A@EA@CLimitedSequentialInStream@@8
.rdata$r:000027CC ; CLimitedSequentialInStream::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000027CC ??_R1A@?0A@EA@CLimitedSequentialInStream@@8 dd offset ??_R0?AVCLimitedSequentialInStream@@@8
.rdata$r:000027CC                                         ; DATA XREF: .rdata$r:CLimitedSequentialInStream::`RTTI Base Class Array'o
.rdata$r:000027CC                                         ; CLimitedSequentialInStream `RTTI Type Descriptor'
.rdata$r:000027D0                 db    3
.rdata$r:000027D1                 db    0
.rdata$r:000027D2                 db    0
.rdata$r:000027D3                 db    0
.rdata$r:000027D4                 db    0
.rdata$r:000027D5                 db    0
.rdata$r:000027D6                 db    0
.rdata$r:000027D7                 db    0
.rdata$r:000027D8                 db 0FFh
.rdata$r:000027D9                 db 0FFh
.rdata$r:000027DA                 db 0FFh
.rdata$r:000027DB                 db 0FFh
.rdata$r:000027DC                 db    0
.rdata$r:000027DD                 db    0
.rdata$r:000027DE                 db    0
.rdata$r:000027DF                 db    0
.rdata$r:000027E0                 db  40h ; @
.rdata$r:000027E1                 db    0
.rdata$r:000027E2                 db    0
.rdata$r:000027E3                 db    0
.rdata$r:000027E4                 dd offset ??_R3CLimitedSequentialInStream@@8 ; CLimitedSequentialInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:000027E4 _rdata$r        ends
.rdata$r:000027E4
.rdata$r:000027E8 ; ===========================================================================
.rdata$r:000027E8
.rdata$r:000027E8 ; Segment type: Pure data
.rdata$r:000027E8 ; Segment permissions: Read
.rdata$r:000027E8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000027E8                 assume cs:_rdata$r
.rdata$r:000027E8                 ;org 27E8h
.rdata$r:000027E8 ; COMDAT (pick any)
.rdata$r:000027E8                 public ??_R13?0A@EA@CMyUnknownImp@@8
.rdata$r:000027E8 ; CMyUnknownImp::`RTTI Base Class Descriptor at (4, -1, 0, 64)'
.rdata$r:000027E8 ??_R13?0A@EA@CMyUnknownImp@@8 dd offset ??_R0?AVCMyUnknownImp@@@8
.rdata$r:000027E8                                         ; DATA XREF: .rdata$r:000027C4o
.rdata$r:000027E8                                         ; CMyUnknownImp `RTTI Type Descriptor'
.rdata$r:000027EC                 align 10h
.rdata$r:000027F0                 db    4
.rdata$r:000027F1                 db    0
.rdata$r:000027F2                 db    0
.rdata$r:000027F3                 db    0
.rdata$r:000027F4                 db 0FFh
.rdata$r:000027F5                 db 0FFh
.rdata$r:000027F6                 db 0FFh
.rdata$r:000027F7                 db 0FFh
.rdata$r:000027F8                 db    0
.rdata$r:000027F9                 db    0
.rdata$r:000027FA                 db    0
.rdata$r:000027FB                 db    0
.rdata$r:000027FC                 db  40h ; @
.rdata$r:000027FD                 db    0
.rdata$r:000027FE                 db    0
.rdata$r:000027FF                 db    0
.rdata$r:00002800                 dd offset ??_R3CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002800 _rdata$r        ends
.rdata$r:00002800
.text:00002804 ; ===========================================================================
.text:00002804
.text:00002804 ; Segment type: Pure code
.text:00002804 ; Segment permissions: Read/Execute
.text:00002804 _text           segment para public 'CODE' use32
.text:00002804                 assume cs:_text
.text:00002804                 ;org 2804h
.text:00002804 ; COMDAT (pick any)
.text:00002804                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00002804
.text:00002804 ; =============== S U B R O U T I N E =======================================
.text:00002804
.text:00002804 ; Attributes: bp-based frame
.text:00002804
.text:00002804 ; __int32 __stdcall CLimitedSequentialInStream::QueryInterface(CLimitedSequentialInStream *this, const struct _GUID *Buf1, void **)
.text:00002804                 public ?QueryInterface@CLimitedSequentialInStream@@UAGJABU_GUID@@PAPAX@Z
.text:00002804 ?QueryInterface@CLimitedSequentialInStream@@UAGJABU_GUID@@PAPAX@Z proc near
.text:00002804                                         ; DATA XREF: .rdata:const CLimitedSequentialInStream::`vftable'o
.text:00002804
.text:00002804 this            = dword ptr  8
.text:00002804 Buf1            = dword ptr  0Ch
.text:00002804 arg_8           = dword ptr  10h
.text:00002804
.text:00002804                 push    ebp
.text:00002805                 mov     ebp, esp
.text:00002807                 mov     eax, [ebp+arg_8]
.text:0000280A                 mov     dword ptr [eax], 0
.text:00002810                 push    offset _IID_IUnknown ; Buf2
.text:00002815                 mov     ecx, [ebp+Buf1]
.text:00002818                 push    ecx             ; Buf1
.text:00002819                 call    ___@8           ; __(x,x)
.text:0000281E                 test    eax, eax
.text:00002820                 jz      short loc_282C
.text:00002822                 mov     edx, [ebp+arg_8]
.text:00002825                 mov     eax, [ebp+this]
.text:00002828                 mov     [edx], eax
.text:0000282A                 jmp     short loc_284F
.text:0000282C ; ---------------------------------------------------------------------------
.text:0000282C
.text:0000282C loc_282C:                               ; CODE XREF: CLimitedSequentialInStream::QueryInterface(_GUID const &,void * *)+1Cj
.text:0000282C                 push    offset _IID_ISequentialInStream ; Buf2
.text:00002831                 mov     ecx, [ebp+Buf1]
.text:00002834                 push    ecx             ; Buf1
.text:00002835                 call    ___@8           ; __(x,x)
.text:0000283A                 test    eax, eax
.text:0000283C                 jz      short loc_2848
.text:0000283E                 mov     edx, [ebp+arg_8]
.text:00002841                 mov     eax, [ebp+this]
.text:00002844                 mov     [edx], eax
.text:00002846                 jmp     short loc_284F
.text:00002848 ; ---------------------------------------------------------------------------
.text:00002848
.text:00002848 loc_2848:                               ; CODE XREF: CLimitedSequentialInStream::QueryInterface(_GUID const &,void * *)+38j
.text:00002848                 mov     eax, 80004002h
.text:0000284D                 jmp     short loc_2860
.text:0000284F ; ---------------------------------------------------------------------------
.text:0000284F
.text:0000284F loc_284F:                               ; CODE XREF: CLimitedSequentialInStream::QueryInterface(_GUID const &,void * *)+26j
.text:0000284F                                         ; CLimitedSequentialInStream::QueryInterface(_GUID const &,void * *)+42j
.text:0000284F                 mov     ecx, [ebp+this]
.text:00002852                 mov     edx, [ecx+4]
.text:00002855                 add     edx, 1
.text:00002858                 mov     eax, [ebp+this]
.text:0000285B                 mov     [eax+4], edx
.text:0000285E                 xor     eax, eax
.text:00002860
.text:00002860 loc_2860:                               ; CODE XREF: CLimitedSequentialInStream::QueryInterface(_GUID const &,void * *)+49j
.text:00002860                 cmp     ebp, esp
.text:00002862                 call    __RTC_CheckEsp
.text:00002867                 pop     ebp
.text:00002868                 retn    0Ch
.text:00002868 ?QueryInterface@CLimitedSequentialInStream@@UAGJABU_GUID@@PAPAX@Z endp
.text:00002868
.text:00002868 ; ---------------------------------------------------------------------------
.text:0000286B                 align 4
.text:0000286B _text           ends
.text:0000286B
.text:0000286C ; ===========================================================================
.text:0000286C
.text:0000286C ; Segment type: Pure code
.text:0000286C ; Segment permissions: Read/Execute
.text:0000286C _text           segment para public 'CODE' use32
.text:0000286C                 assume cs:_text
.text:0000286C                 ;org 286Ch
.text:0000286C ; COMDAT (pick any)
.text:0000286C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:0000286C
.text:0000286C ; =============== S U B R O U T I N E =======================================
.text:0000286C
.text:0000286C ; Attributes: bp-based frame
.text:0000286C
.text:0000286C ; unsigned __int32 __stdcall CLimitedSequentialInStream::AddRef(CLimitedSequentialInStream *this)
.text:0000286C                 public ?AddRef@CLimitedSequentialInStream@@UAGKXZ
.text:0000286C ?AddRef@CLimitedSequentialInStream@@UAGKXZ proc near
.text:0000286C                                         ; DATA XREF: .rdata:0000275Co
.text:0000286C
.text:0000286C var_4           = dword ptr -4
.text:0000286C this            = dword ptr  8
.text:0000286C
.text:0000286C                 push    ebp
.text:0000286D                 mov     ebp, esp
.text:0000286F                 push    ecx
.text:00002870                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002877                 mov     eax, [ebp+this]
.text:0000287A                 mov     ecx, [eax+4]
.text:0000287D                 add     ecx, 1
.text:00002880                 mov     [ebp+var_4], ecx
.text:00002883                 mov     edx, [ebp+this]
.text:00002886                 mov     eax, [ebp+var_4]
.text:00002889                 mov     [edx+4], eax
.text:0000288C                 mov     eax, [ebp+var_4]
.text:0000288F                 mov     esp, ebp
.text:00002891                 pop     ebp
.text:00002892                 retn    4
.text:00002892 ?AddRef@CLimitedSequentialInStream@@UAGKXZ endp
.text:00002892
.text:00002892 ; ---------------------------------------------------------------------------
.text:00002895                 align 4
.text:00002895 _text           ends
.text:00002895
.text:00002898 ; ===========================================================================
.text:00002898
.text:00002898 ; Segment type: Pure code
.text:00002898 ; Segment permissions: Read/Execute
.text:00002898 _text           segment para public 'CODE' use32
.text:00002898                 assume cs:_text
.text:00002898                 ;org 2898h
.text:00002898 ; COMDAT (pick any)
.text:00002898                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00002898
.text:00002898 ; =============== S U B R O U T I N E =======================================
.text:00002898
.text:00002898 ; Attributes: bp-based frame
.text:00002898
.text:00002898 ; unsigned __int32 __stdcall CLimitedSequentialInStream::Release(CLimitedSequentialInStream *this)
.text:00002898                 public ?Release@CLimitedSequentialInStream@@UAGKXZ
.text:00002898 ?Release@CLimitedSequentialInStream@@UAGKXZ proc near
.text:00002898                                         ; DATA XREF: .rdata:00002760o
.text:00002898
.text:00002898 var_10          = dword ptr -10h
.text:00002898 var_C           = dword ptr -0Ch
.text:00002898 var_8           = dword ptr -8
.text:00002898 var_4           = dword ptr -4
.text:00002898 this            = dword ptr  8
.text:00002898
.text:00002898                 push    ebp
.text:00002899                 mov     ebp, esp
.text:0000289B                 sub     esp, 10h
.text:0000289E                 mov     eax, 0CCCCCCCCh
.text:000028A3                 mov     [ebp+var_10], eax
.text:000028A6                 mov     [ebp+var_C], eax
.text:000028A9                 mov     [ebp+var_8], eax
.text:000028AC                 mov     [ebp+var_4], eax
.text:000028AF                 mov     eax, [ebp+this]
.text:000028B2                 mov     ecx, [eax+4]
.text:000028B5                 sub     ecx, 1
.text:000028B8                 mov     [ebp+var_C], ecx
.text:000028BB                 mov     edx, [ebp+this]
.text:000028BE                 mov     eax, [ebp+var_C]
.text:000028C1                 mov     [edx+4], eax
.text:000028C4                 cmp     [ebp+var_C], 0
.text:000028C8                 jz      short loc_28D2
.text:000028CA                 mov     ecx, [ebp+this]
.text:000028CD                 mov     eax, [ecx+4]
.text:000028D0                 jmp     short loc_28FC
.text:000028D2 ; ---------------------------------------------------------------------------
.text:000028D2
.text:000028D2 loc_28D2:                               ; CODE XREF: CLimitedSequentialInStream::Release(void)+30j
.text:000028D2                 mov     edx, [ebp+this]
.text:000028D5                 mov     [ebp+var_8], edx
.text:000028D8                 mov     eax, [ebp+var_8]
.text:000028DB                 mov     [ebp+var_4], eax
.text:000028DE                 cmp     [ebp+var_4], 0
.text:000028E2                 jz      short loc_28F3
.text:000028E4                 push    1
.text:000028E6                 mov     ecx, [ebp+var_4]
.text:000028E9                 call    ??_GCLimitedSequentialInStream@@QAEPAXI@Z ; CLimitedSequentialInStream::`scalar deleting destructor'(uint)
.text:000028EE                 mov     [ebp+var_10], eax
.text:000028F1                 jmp     short loc_28FA
.text:000028F3 ; ---------------------------------------------------------------------------
.text:000028F3
.text:000028F3 loc_28F3:                               ; CODE XREF: CLimitedSequentialInStream::Release(void)+4Aj
.text:000028F3                 mov     [ebp+var_10], 0
.text:000028FA
.text:000028FA loc_28FA:                               ; CODE XREF: CLimitedSequentialInStream::Release(void)+59j
.text:000028FA                 xor     eax, eax
.text:000028FC
.text:000028FC loc_28FC:                               ; CODE XREF: CLimitedSequentialInStream::Release(void)+38j
.text:000028FC                 add     esp, 10h
.text:000028FF                 cmp     ebp, esp
.text:00002901                 call    __RTC_CheckEsp
.text:00002906                 mov     esp, ebp
.text:00002908                 pop     ebp
.text:00002909                 retn    4
.text:00002909 ?Release@CLimitedSequentialInStream@@UAGKXZ endp
.text:00002909
.text:00002909 _text           ends
.text:00002909
.text:0000290C ; ===========================================================================
.text:0000290C
.text:0000290C ; Segment type: Pure code
.text:0000290C ; Segment permissions: Read/Execute
.text:0000290C _text           segment para public 'CODE' use32
.text:0000290C                 assume cs:_text
.text:0000290C                 ;org 290Ch
.text:0000290C ; COMDAT (pick any)
.text:0000290C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:0000290C
.text:0000290C ; =============== S U B R O U T I N E =======================================
.text:0000290C
.text:0000290C ; Attributes: bp-based frame
.text:0000290C
.text:0000290C ; public: void * __thiscall CLimitedSequentialInStream::`scalar deleting destructor'(unsigned int)
.text:0000290C                 public ??_GCLimitedSequentialInStream@@QAEPAXI@Z
.text:0000290C ??_GCLimitedSequentialInStream@@QAEPAXI@Z proc near
.text:0000290C                                         ; CODE XREF: CLimitedSequentialInStream::Release(void)+51p
.text:0000290C
.text:0000290C var_4           = dword ptr -4
.text:0000290C arg_0           = dword ptr  8
.text:0000290C
.text:0000290C                 push    ebp
.text:0000290D                 mov     ebp, esp
.text:0000290F                 push    ecx
.text:00002910                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002917                 mov     [ebp+var_4], ecx
.text:0000291A                 mov     ecx, [ebp+var_4] ; this
.text:0000291D                 call    ??1CLimitedSequentialInStream@@QAE@XZ ; CLimitedSequentialInStream::~CLimitedSequentialInStream(void)
.text:00002922                 mov     eax, [ebp+arg_0]
.text:00002925                 and     eax, 1
.text:00002928                 jz      short loc_2936
.text:0000292A                 mov     ecx, [ebp+var_4]
.text:0000292D                 push    ecx             ; void *
.text:0000292E                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00002933                 add     esp, 4
.text:00002936
.text:00002936 loc_2936:                               ; CODE XREF: CLimitedSequentialInStream::`scalar deleting destructor'(uint)+1Cj
.text:00002936                 mov     eax, [ebp+var_4]
.text:00002939                 add     esp, 4
.text:0000293C                 cmp     ebp, esp
.text:0000293E                 call    __RTC_CheckEsp
.text:00002943                 mov     esp, ebp
.text:00002945                 pop     ebp
.text:00002946                 retn    4
.text:00002946 ??_GCLimitedSequentialInStream@@QAEPAXI@Z endp
.text:00002946
.text:00002946 ; ---------------------------------------------------------------------------
.text:00002949                 align 4
.text:00002949 _text           ends
.text:00002949
.text:0000294C ; ===========================================================================
.text:0000294C
.text:0000294C ; Segment type: Pure code
.text:0000294C ; Segment permissions: Read/Execute
.text:0000294C _text           segment para public 'CODE' use32
.text:0000294C                 assume cs:_text
.text:0000294C                 ;org 294Ch
.text:0000294C ; COMDAT (pick any)
.text:0000294C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:0000294C
.text:0000294C ; =============== S U B R O U T I N E =======================================
.text:0000294C
.text:0000294C ; Attributes: bp-based frame
.text:0000294C
.text:0000294C ; _DWORD __thiscall CLimitedSequentialInStream::~CLimitedSequentialInStream(CLimitedSequentialInStream *__hidden this)
.text:0000294C                 public ??1CLimitedSequentialInStream@@QAE@XZ
.text:0000294C ??1CLimitedSequentialInStream@@QAE@XZ proc near
.text:0000294C                                         ; CODE XREF: CLimitedSequentialInStream::`scalar deleting destructor'(uint)+11p
.text:0000294C
.text:0000294C var_4           = dword ptr -4
.text:0000294C
.text:0000294C                 push    ebp
.text:0000294D                 mov     ebp, esp
.text:0000294F                 push    ecx
.text:00002950                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002957                 mov     [ebp+var_4], ecx
.text:0000295A                 mov     ecx, [ebp+var_4]
.text:0000295D                 add     ecx, 8
.text:00002960                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:00002965                 add     esp, 4
.text:00002968                 cmp     ebp, esp
.text:0000296A                 call    __RTC_CheckEsp
.text:0000296F                 mov     esp, ebp
.text:00002971                 pop     ebp
.text:00002972                 retn
.text:00002972 ??1CLimitedSequentialInStream@@QAE@XZ endp
.text:00002972
.text:00002972 ; ---------------------------------------------------------------------------
.text:00002973                 align 4
.text:00002973 _text           ends
.text:00002973
.text:00002974 ; ===========================================================================
.text:00002974
.text:00002974 ; Segment type: Pure code
.text:00002974 ; Segment permissions: Read/Execute
.text:00002974 _text           segment para public 'CODE' use32
.text:00002974                 assume cs:_text
.text:00002974                 ;org 2974h
.text:00002974 ; COMDAT (pick any)
.text:00002974                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00002974
.text:00002974 ; =============== S U B R O U T I N E =======================================
.text:00002974
.text:00002974 ; Attributes: bp-based frame
.text:00002974
.text:00002974 ; _DWORD __thiscall NArchive::NTar::CItem::CItem(NArchive::NTar::CItem *__hidden this)
.text:00002974                 public ??0CItem@NTar@NArchive@@QAE@XZ
.text:00002974 ??0CItem@NTar@NArchive@@QAE@XZ proc near
.text:00002974                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+3CFp
.text:00002974
.text:00002974 var_10          = dword ptr -10h
.text:00002974 var_C           = dword ptr -0Ch
.text:00002974 var_4           = dword ptr -4
.text:00002974
.text:00002974                 push    ebp
.text:00002975                 mov     ebp, esp
.text:00002977                 push    0FFFFFFFFh
.text:00002979                 push    offset __ehhandler$??0CItem@NTar@NArchive@@QAE@XZ
.text:0000297E                 mov     eax, large fs:0
.text:00002984                 push    eax
.text:00002985                 push    ecx
.text:00002986                 mov     [ebp+var_10], 0CCCCCCCCh
.text:0000298D                 mov     eax, dword ptr ds:___security_cookie
.text:00002992                 xor     eax, ebp
.text:00002994                 push    eax
.text:00002995                 lea     eax, [ebp+var_C]
.text:00002998                 mov     large fs:0, eax
.text:0000299E                 mov     [ebp+var_10], ecx
.text:000029A1                 mov     ecx, [ebp+var_10]
.text:000029A4                 call    ??0AString@@QAE@XZ ; AString::AString(void)
.text:000029A9                 mov     [ebp+var_4], 0
.text:000029B0                 mov     ecx, [ebp+var_10]
.text:000029B3                 add     ecx, 3Ch ; '<'
.text:000029B6                 call    ??0AString@@QAE@XZ ; AString::AString(void)
.text:000029BB                 mov     byte ptr [ebp+var_4], 1
.text:000029BF                 mov     ecx, [ebp+var_10]
.text:000029C2                 add     ecx, 48h ; 'H'
.text:000029C5                 call    ??0AString@@QAE@XZ ; AString::AString(void)
.text:000029CA                 mov     byte ptr [ebp+var_4], 2
.text:000029CE                 mov     ecx, [ebp+var_10]
.text:000029D1                 add     ecx, 54h ; 'T'
.text:000029D4                 call    ??0AString@@QAE@XZ ; AString::AString(void)
.text:000029D9                 mov     byte ptr [ebp+var_4], 3
.text:000029DD                 mov     ecx, [ebp+var_10]
.text:000029E0                 add     ecx, 6Ch ; 'l'
.text:000029E3                 call    ??0?$CRecordVector@UCSparseBlock@NTar@NArchive@@@@QAE@XZ ; CRecordVector<NArchive::NTar::CSparseBlock>::CRecordVector<NArchive::NTar::CSparseBlock>(void)
.text:000029E8                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000029EF                 mov     eax, [ebp+var_10]
.text:000029F2                 mov     ecx, [ebp+var_C]
.text:000029F5                 mov     large fs:0, ecx
.text:000029FC                 pop     ecx
.text:000029FD                 add     esp, 10h
.text:00002A00                 cmp     ebp, esp
.text:00002A02                 call    __RTC_CheckEsp
.text:00002A07                 mov     esp, ebp
.text:00002A09                 pop     ebp
.text:00002A0A                 retn
.text:00002A0A ??0CItem@NTar@NArchive@@QAE@XZ endp
.text:00002A0A
.text:00002A0A ; ---------------------------------------------------------------------------
.text:00002A0B                 align 4
.text:00002A0B _text           ends
.text:00002A0B
.text$x:00002A0C ; ===========================================================================
.text$x:00002A0C
.text$x:00002A0C ; Segment type: Pure code
.text$x:00002A0C ; Segment permissions: Read/Execute
.text$x:00002A0C _text$x         segment para public 'CODE' use32
.text$x:00002A0C                 assume cs:_text$x
.text$x:00002A0C                 ;org 2A0Ch
.text$x:00002A0C ; COMDAT (pick associative to section at 2974)
.text$x:00002A0C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00002A0C
.text$x:00002A0C ; =============== S U B R O U T I N E =======================================
.text$x:00002A0C
.text$x:00002A0C
.text$x:00002A0C __unwindfunclet$??0CItem@NTar@NArchive@@QAE@XZ$0 proc near
.text$x:00002A0C                                         ; DATA XREF: .xdata$x:00002A54o
.text$x:00002A0C                 mov     ecx, [ebp-10h]  ; this
.text$x:00002A0F                 jmp     ??1AString@@QAE@XZ ; AString::~AString(void)
.text$x:00002A0F __unwindfunclet$??0CItem@NTar@NArchive@@QAE@XZ$0 endp
.text$x:00002A0F
.text$x:00002A14
.text$x:00002A14 ; =============== S U B R O U T I N E =======================================
.text$x:00002A14
.text$x:00002A14
.text$x:00002A14 __unwindfunclet$??0CItem@NTar@NArchive@@QAE@XZ$1 proc near
.text$x:00002A14                                         ; DATA XREF: .xdata$x:00002A5Co
.text$x:00002A14                 mov     ecx, [ebp-10h]
.text$x:00002A17                 add     ecx, 3Ch ; '<'  ; this
.text$x:00002A1A                 jmp     ??1AString@@QAE@XZ ; AString::~AString(void)
.text$x:00002A1A __unwindfunclet$??0CItem@NTar@NArchive@@QAE@XZ$1 endp
.text$x:00002A1A
.text$x:00002A1F
.text$x:00002A1F ; =============== S U B R O U T I N E =======================================
.text$x:00002A1F
.text$x:00002A1F
.text$x:00002A1F __unwindfunclet$??0CItem@NTar@NArchive@@QAE@XZ$2 proc near
.text$x:00002A1F                                         ; DATA XREF: .xdata$x:00002A64o
.text$x:00002A1F                 mov     ecx, [ebp-10h]
.text$x:00002A22                 add     ecx, 48h ; 'H'  ; this
.text$x:00002A25                 jmp     ??1AString@@QAE@XZ ; AString::~AString(void)
.text$x:00002A25 __unwindfunclet$??0CItem@NTar@NArchive@@QAE@XZ$2 endp
.text$x:00002A25
.text$x:00002A2A
.text$x:00002A2A ; =============== S U B R O U T I N E =======================================
.text$x:00002A2A
.text$x:00002A2A
.text$x:00002A2A __unwindfunclet$??0CItem@NTar@NArchive@@QAE@XZ$3 proc near
.text$x:00002A2A                                         ; DATA XREF: .xdata$x:00002A6Co
.text$x:00002A2A                 mov     ecx, [ebp-10h]
.text$x:00002A2D                 add     ecx, 54h ; 'T'  ; this
.text$x:00002A30                 jmp     ??1AString@@QAE@XZ ; AString::~AString(void)
.text$x:00002A30 __unwindfunclet$??0CItem@NTar@NArchive@@QAE@XZ$3 endp
.text$x:00002A30
.text$x:00002A35
.text$x:00002A35 ; =============== S U B R O U T I N E =======================================
.text$x:00002A35
.text$x:00002A35
.text$x:00002A35 __ehhandler$??0CItem@NTar@NArchive@@QAE@XZ proc near
.text$x:00002A35                                         ; DATA XREF: NArchive::NTar::CItem::CItem(void)+5o
.text$x:00002A35
.text$x:00002A35 arg_4           = dword ptr  8
.text$x:00002A35
.text$x:00002A35                 mov     edx, [esp+arg_4]
.text$x:00002A39                 lea     eax, [edx+0Ch]
.text$x:00002A3C                 mov     ecx, [edx-8]
.text$x:00002A3F                 xor     ecx, eax
.text$x:00002A41                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002A46                 mov     eax, offset __ehfuncinfo$??0CItem@NTar@NArchive@@QAE@XZ
.text$x:00002A4B                 jmp     ___CxxFrameHandler3
.text$x:00002A4B __ehhandler$??0CItem@NTar@NArchive@@QAE@XZ endp
.text$x:00002A4B
.text$x:00002A4B _text$x         ends
.text$x:00002A4B
.xdata$x:00002A50 ; ===========================================================================
.xdata$x:00002A50
.xdata$x:00002A50 ; Segment type: Pure data
.xdata$x:00002A50 ; Segment permissions: Read
.xdata$x:00002A50 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002A50                 assume cs:_xdata$x
.xdata$x:00002A50                 ;org 2A50h
.xdata$x:00002A50 ; COMDAT (pick associative to section at 2974)
.xdata$x:00002A50 __unwindtable$??0CItem@NTar@NArchive@@QAE@XZ db 0FFh
.xdata$x:00002A50                                         ; DATA XREF: .xdata$x:00002A78o
.xdata$x:00002A51                 db 0FFh
.xdata$x:00002A52                 db 0FFh
.xdata$x:00002A53                 db 0FFh
.xdata$x:00002A54                 dd offset __unwindfunclet$??0CItem@NTar@NArchive@@QAE@XZ$0
.xdata$x:00002A58                 db    0
.xdata$x:00002A59                 db    0
.xdata$x:00002A5A                 db    0
.xdata$x:00002A5B                 db    0
.xdata$x:00002A5C                 dd offset __unwindfunclet$??0CItem@NTar@NArchive@@QAE@XZ$1
.xdata$x:00002A60                 db    1
.xdata$x:00002A61                 db    0
.xdata$x:00002A62                 db    0
.xdata$x:00002A63                 db    0
.xdata$x:00002A64                 dd offset __unwindfunclet$??0CItem@NTar@NArchive@@QAE@XZ$2
.xdata$x:00002A68                 db    2
.xdata$x:00002A69                 db    0
.xdata$x:00002A6A                 db    0
.xdata$x:00002A6B                 db    0
.xdata$x:00002A6C                 dd offset __unwindfunclet$??0CItem@NTar@NArchive@@QAE@XZ$3
.xdata$x:00002A70 __ehfuncinfo$??0CItem@NTar@NArchive@@QAE@XZ db  22h ; "
.xdata$x:00002A70                                         ; DATA XREF: __ehhandler$??0CItem@NTar@NArchive@@QAE@XZ+11o
.xdata$x:00002A71                 db    5
.xdata$x:00002A72                 db  93h ; Ã´
.xdata$x:00002A73                 db  19h
.xdata$x:00002A74                 db    4
.xdata$x:00002A75                 db    0
.xdata$x:00002A76                 db    0
.xdata$x:00002A77                 db    0
.xdata$x:00002A78                 dd offset __unwindtable$??0CItem@NTar@NArchive@@QAE@XZ
.xdata$x:00002A7C                 db    0
.xdata$x:00002A7D                 db    0
.xdata$x:00002A7E                 db    0
.xdata$x:00002A7F                 db    0
.xdata$x:00002A80                 db    0
.xdata$x:00002A81                 db    0
.xdata$x:00002A82                 db    0
.xdata$x:00002A83                 db    0
.xdata$x:00002A84                 db    0
.xdata$x:00002A85                 db    0
.xdata$x:00002A86                 db    0
.xdata$x:00002A87                 db    0
.xdata$x:00002A88                 db    0
.xdata$x:00002A89                 db    0
.xdata$x:00002A8A                 db    0
.xdata$x:00002A8B                 db    0
.xdata$x:00002A8C                 db    0
.xdata$x:00002A8D                 db    0
.xdata$x:00002A8E                 db    0
.xdata$x:00002A8F                 db    0
.xdata$x:00002A90                 db    1
.xdata$x:00002A91                 db    0
.xdata$x:00002A92                 db    0
.xdata$x:00002A93                 db    0
.xdata$x:00002A93 _xdata$x        ends
.xdata$x:00002A93
.text:00002A94 ; ===========================================================================
.text:00002A94
.text:00002A94 ; Segment type: Pure code
.text:00002A94 ; Segment permissions: Read/Execute
.text:00002A94 _text           segment para public 'CODE' use32
.text:00002A94                 assume cs:_text
.text:00002A94                 ;org 2A94h
.text:00002A94 ; COMDAT (pick any)
.text:00002A94                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00002A94
.text:00002A94 ; =============== S U B R O U T I N E =======================================
.text:00002A94
.text:00002A94 ; Attributes: bp-based frame
.text:00002A94
.text:00002A94 ; _DWORD __thiscall NArchive::NTar::CItem::~CItem(NArchive::NTar::CItem *__hidden this)
.text:00002A94                 public ??1CItem@NTar@NArchive@@QAE@XZ
.text:00002A94 ??1CItem@NTar@NArchive@@QAE@XZ proc near
.text:00002A94                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+57Ap
.text:00002A94                                         ; NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+693p ...
.text:00002A94
.text:00002A94 var_10          = dword ptr -10h
.text:00002A94 var_C           = dword ptr -0Ch
.text:00002A94 var_4           = dword ptr -4
.text:00002A94
.text:00002A94                 push    ebp
.text:00002A95                 mov     ebp, esp
.text:00002A97                 push    0FFFFFFFFh
.text:00002A99                 push    offset __ehhandler$??1CItem@NTar@NArchive@@QAE@XZ
.text:00002A9E                 mov     eax, large fs:0
.text:00002AA4                 push    eax
.text:00002AA5                 push    ecx
.text:00002AA6                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00002AAD                 mov     eax, dword ptr ds:___security_cookie
.text:00002AB2                 xor     eax, ebp
.text:00002AB4                 push    eax
.text:00002AB5                 lea     eax, [ebp+var_C]
.text:00002AB8                 mov     large fs:0, eax
.text:00002ABE                 mov     [ebp+var_10], ecx
.text:00002AC1                 mov     [ebp+var_4], 3
.text:00002AC8                 mov     ecx, [ebp+var_10]
.text:00002ACB                 add     ecx, 6Ch ; 'l'
.text:00002ACE                 call    ??1?$CRecordVector@UCSparseBlock@NTar@NArchive@@@@QAE@XZ ; CRecordVector<NArchive::NTar::CSparseBlock>::~CRecordVector<NArchive::NTar::CSparseBlock>(void)
.text:00002AD3                 mov     byte ptr [ebp+var_4], 2
.text:00002AD7                 mov     ecx, [ebp+var_10]
.text:00002ADA                 add     ecx, 54h ; 'T'  ; this
.text:00002ADD                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00002AE2                 mov     byte ptr [ebp+var_4], 1
.text:00002AE6                 mov     ecx, [ebp+var_10]
.text:00002AE9                 add     ecx, 48h ; 'H'  ; this
.text:00002AEC                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00002AF1                 mov     byte ptr [ebp+var_4], 0
.text:00002AF5                 mov     ecx, [ebp+var_10]
.text:00002AF8                 add     ecx, 3Ch ; '<'  ; this
.text:00002AFB                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00002B00                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00002B07                 mov     ecx, [ebp+var_10] ; this
.text:00002B0A                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00002B0F                 mov     ecx, [ebp+var_C]
.text:00002B12                 mov     large fs:0, ecx
.text:00002B19                 pop     ecx
.text:00002B1A                 add     esp, 10h
.text:00002B1D                 cmp     ebp, esp
.text:00002B1F                 call    __RTC_CheckEsp
.text:00002B24                 mov     esp, ebp
.text:00002B26                 pop     ebp
.text:00002B27                 retn
.text:00002B27 ??1CItem@NTar@NArchive@@QAE@XZ endp
.text:00002B27
.text:00002B27 _text           ends
.text:00002B27
.text$x:00002B28 ; ===========================================================================
.text$x:00002B28
.text$x:00002B28 ; Segment type: Pure code
.text$x:00002B28 ; Segment permissions: Read/Execute
.text$x:00002B28 _text$x         segment para public 'CODE' use32
.text$x:00002B28                 assume cs:_text$x
.text$x:00002B28                 ;org 2B28h
.text$x:00002B28 ; COMDAT (pick associative to section at 2A94)
.text$x:00002B28                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00002B28
.text$x:00002B28 ; =============== S U B R O U T I N E =======================================
.text$x:00002B28
.text$x:00002B28
.text$x:00002B28 __unwindfunclet$??1CItem@NTar@NArchive@@QAE@XZ$0 proc near
.text$x:00002B28                                         ; DATA XREF: .xdata$x:00002B70o
.text$x:00002B28                 mov     ecx, [ebp-10h]  ; this
.text$x:00002B2B                 jmp     ??1AString@@QAE@XZ ; AString::~AString(void)
.text$x:00002B2B __unwindfunclet$??1CItem@NTar@NArchive@@QAE@XZ$0 endp
.text$x:00002B2B
.text$x:00002B30
.text$x:00002B30 ; =============== S U B R O U T I N E =======================================
.text$x:00002B30
.text$x:00002B30
.text$x:00002B30 __unwindfunclet$??1CItem@NTar@NArchive@@QAE@XZ$1 proc near
.text$x:00002B30                                         ; DATA XREF: .xdata$x:00002B78o
.text$x:00002B30                 mov     ecx, [ebp-10h]
.text$x:00002B33                 add     ecx, 3Ch ; '<'  ; this
.text$x:00002B36                 jmp     ??1AString@@QAE@XZ ; AString::~AString(void)
.text$x:00002B36 __unwindfunclet$??1CItem@NTar@NArchive@@QAE@XZ$1 endp
.text$x:00002B36
.text$x:00002B3B
.text$x:00002B3B ; =============== S U B R O U T I N E =======================================
.text$x:00002B3B
.text$x:00002B3B
.text$x:00002B3B __unwindfunclet$??1CItem@NTar@NArchive@@QAE@XZ$2 proc near
.text$x:00002B3B                                         ; DATA XREF: .xdata$x:00002B80o
.text$x:00002B3B                 mov     ecx, [ebp-10h]
.text$x:00002B3E                 add     ecx, 48h ; 'H'  ; this
.text$x:00002B41                 jmp     ??1AString@@QAE@XZ ; AString::~AString(void)
.text$x:00002B41 __unwindfunclet$??1CItem@NTar@NArchive@@QAE@XZ$2 endp
.text$x:00002B41
.text$x:00002B46
.text$x:00002B46 ; =============== S U B R O U T I N E =======================================
.text$x:00002B46
.text$x:00002B46
.text$x:00002B46 __unwindfunclet$??1CItem@NTar@NArchive@@QAE@XZ$3 proc near
.text$x:00002B46                                         ; DATA XREF: .xdata$x:00002B88o
.text$x:00002B46                 mov     ecx, [ebp-10h]
.text$x:00002B49                 add     ecx, 54h ; 'T'  ; this
.text$x:00002B4C                 jmp     ??1AString@@QAE@XZ ; AString::~AString(void)
.text$x:00002B4C __unwindfunclet$??1CItem@NTar@NArchive@@QAE@XZ$3 endp
.text$x:00002B4C
.text$x:00002B51
.text$x:00002B51 ; =============== S U B R O U T I N E =======================================
.text$x:00002B51
.text$x:00002B51
.text$x:00002B51 __ehhandler$??1CItem@NTar@NArchive@@QAE@XZ proc near
.text$x:00002B51                                         ; DATA XREF: NArchive::NTar::CItem::~CItem(void)+5o
.text$x:00002B51
.text$x:00002B51 arg_4           = dword ptr  8
.text$x:00002B51
.text$x:00002B51                 mov     edx, [esp+arg_4]
.text$x:00002B55                 lea     eax, [edx+0Ch]
.text$x:00002B58                 mov     ecx, [edx-8]
.text$x:00002B5B                 xor     ecx, eax
.text$x:00002B5D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002B62                 mov     eax, offset __ehfuncinfo$??1CItem@NTar@NArchive@@QAE@XZ
.text$x:00002B67                 jmp     ___CxxFrameHandler3
.text$x:00002B67 __ehhandler$??1CItem@NTar@NArchive@@QAE@XZ endp
.text$x:00002B67
.text$x:00002B67 _text$x         ends
.text$x:00002B67
.xdata$x:00002B6C ; ===========================================================================
.xdata$x:00002B6C
.xdata$x:00002B6C ; Segment type: Pure data
.xdata$x:00002B6C ; Segment permissions: Read
.xdata$x:00002B6C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002B6C                 assume cs:_xdata$x
.xdata$x:00002B6C                 ;org 2B6Ch
.xdata$x:00002B6C ; COMDAT (pick associative to section at 2A94)
.xdata$x:00002B6C __unwindtable$??1CItem@NTar@NArchive@@QAE@XZ db 0FFh
.xdata$x:00002B6C                                         ; DATA XREF: .xdata$x:00002B94o
.xdata$x:00002B6D                 db 0FFh
.xdata$x:00002B6E                 db 0FFh
.xdata$x:00002B6F                 db 0FFh
.xdata$x:00002B70                 dd offset __unwindfunclet$??1CItem@NTar@NArchive@@QAE@XZ$0
.xdata$x:00002B74                 align 8
.xdata$x:00002B78                 dd offset __unwindfunclet$??1CItem@NTar@NArchive@@QAE@XZ$1
.xdata$x:00002B7C                 db    1
.xdata$x:00002B7D                 db    0
.xdata$x:00002B7E                 db    0
.xdata$x:00002B7F                 db    0
.xdata$x:00002B80                 dd offset __unwindfunclet$??1CItem@NTar@NArchive@@QAE@XZ$2
.xdata$x:00002B84                 db    2
.xdata$x:00002B85                 db    0
.xdata$x:00002B86                 db    0
.xdata$x:00002B87                 db    0
.xdata$x:00002B88                 dd offset __unwindfunclet$??1CItem@NTar@NArchive@@QAE@XZ$3
.xdata$x:00002B8C __ehfuncinfo$??1CItem@NTar@NArchive@@QAE@XZ db  22h ; "
.xdata$x:00002B8C                                         ; DATA XREF: __ehhandler$??1CItem@NTar@NArchive@@QAE@XZ+11o
.xdata$x:00002B8D                 db    5
.xdata$x:00002B8E                 db  93h ; Ã´
.xdata$x:00002B8F                 db  19h
.xdata$x:00002B90                 db    4
.xdata$x:00002B91                 db    0
.xdata$x:00002B92                 db    0
.xdata$x:00002B93                 db    0
.xdata$x:00002B94                 dd offset __unwindtable$??1CItem@NTar@NArchive@@QAE@XZ
.xdata$x:00002B98                 db    0
.xdata$x:00002B99                 db    0
.xdata$x:00002B9A                 db    0
.xdata$x:00002B9B                 db    0
.xdata$x:00002B9C                 db    0
.xdata$x:00002B9D                 db    0
.xdata$x:00002B9E                 db    0
.xdata$x:00002B9F                 db    0
.xdata$x:00002BA0                 db    0
.xdata$x:00002BA1                 db    0
.xdata$x:00002BA2                 db    0
.xdata$x:00002BA3                 db    0
.xdata$x:00002BA4                 db    0
.xdata$x:00002BA5                 db    0
.xdata$x:00002BA6                 db    0
.xdata$x:00002BA7                 db    0
.xdata$x:00002BA8                 db    0
.xdata$x:00002BA9                 db    0
.xdata$x:00002BAA                 db    0
.xdata$x:00002BAB                 db    0
.xdata$x:00002BAC                 db    1
.xdata$x:00002BAD                 db    0
.xdata$x:00002BAE                 db    0
.xdata$x:00002BAF                 db    0
.xdata$x:00002BAF _xdata$x        ends
.xdata$x:00002BAF
.text:00002BB0 ; ===========================================================================
.text:00002BB0
.text:00002BB0 ; Segment type: Pure code
.text:00002BB0 ; Segment permissions: Read/Execute
.text:00002BB0 _text           segment para public 'CODE' use32
.text:00002BB0                 assume cs:_text
.text:00002BB0                 ;org 2BB0h
.text:00002BB0 ; COMDAT (pick any)
.text:00002BB0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00002BB0
.text:00002BB0 ; =============== S U B R O U T I N E =======================================
.text:00002BB0
.text:00002BB0 ; Attributes: bp-based frame
.text:00002BB0
.text:00002BB0 ; public: struct NArchive::NTar::CItem & __thiscall NArchive::NTar::CItem::operator=(struct NArchive::NTar::CItem const &)
.text:00002BB0                 public ??4CItem@NTar@NArchive@@QAEAAU012@ABU012@@Z
.text:00002BB0 ??4CItem@NTar@NArchive@@QAEAAU012@ABU012@@Z proc near
.text:00002BB0                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+4ECp
.text:00002BB0
.text:00002BB0 var_8           = dword ptr -8
.text:00002BB0 var_4           = dword ptr -4
.text:00002BB0 arg_0           = dword ptr  8
.text:00002BB0
.text:00002BB0                 push    ebp
.text:00002BB1                 mov     ebp, esp
.text:00002BB3                 sub     esp, 8
.text:00002BB6                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00002BBD                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002BC4                 mov     [ebp+var_4], ecx
.text:00002BC7                 mov     eax, [ebp+arg_0]
.text:00002BCA                 push    eax
.text:00002BCB                 mov     ecx, [ebp+var_4]
.text:00002BCE                 call    ??4AString@@QAEAAV0@ABV0@@Z ; AString::operator=(AString const &)
.text:00002BD3                 mov     ecx, [ebp+var_4]
.text:00002BD6                 mov     edx, [ebp+arg_0]
.text:00002BD9                 mov     eax, [edx+10h]
.text:00002BDC                 mov     [ecx+10h], eax
.text:00002BDF                 mov     edx, [edx+14h]
.text:00002BE2                 mov     [ecx+14h], edx
.text:00002BE5                 mov     eax, [ebp+var_4]
.text:00002BE8                 mov     ecx, [ebp+arg_0]
.text:00002BEB                 mov     edx, [ecx+18h]
.text:00002BEE                 mov     [eax+18h], edx
.text:00002BF1                 mov     ecx, [ecx+1Ch]
.text:00002BF4                 mov     [eax+1Ch], ecx
.text:00002BF7                 mov     edx, [ebp+var_4]
.text:00002BFA                 mov     eax, [ebp+arg_0]
.text:00002BFD                 mov     ecx, [eax+20h]
.text:00002C00                 mov     [edx+20h], ecx
.text:00002C03                 mov     eax, [eax+24h]
.text:00002C06                 mov     [edx+24h], eax
.text:00002C09                 mov     ecx, [ebp+var_4]
.text:00002C0C                 mov     edx, [ebp+arg_0]
.text:00002C0F                 mov     eax, [edx+28h]
.text:00002C12                 mov     [ecx+28h], eax
.text:00002C15                 mov     ecx, [ebp+var_4]
.text:00002C18                 mov     edx, [ebp+arg_0]
.text:00002C1B                 mov     eax, [edx+2Ch]
.text:00002C1E                 mov     [ecx+2Ch], eax
.text:00002C21                 mov     ecx, [ebp+var_4]
.text:00002C24                 mov     edx, [ebp+arg_0]
.text:00002C27                 mov     eax, [edx+30h]
.text:00002C2A                 mov     [ecx+30h], eax
.text:00002C2D                 mov     ecx, [ebp+var_4]
.text:00002C30                 mov     edx, [ebp+arg_0]
.text:00002C33                 mov     eax, [edx+34h]
.text:00002C36                 mov     [ecx+34h], eax
.text:00002C39                 mov     ecx, [ebp+var_4]
.text:00002C3C                 mov     edx, [ebp+arg_0]
.text:00002C3F                 mov     eax, [edx+38h]
.text:00002C42                 mov     [ecx+38h], eax
.text:00002C45                 mov     ecx, [ebp+arg_0]
.text:00002C48                 add     ecx, 3Ch ; '<'
.text:00002C4B                 push    ecx
.text:00002C4C                 mov     ecx, [ebp+var_4]
.text:00002C4F                 add     ecx, 3Ch ; '<'
.text:00002C52                 call    ??4AString@@QAEAAV0@ABV0@@Z ; AString::operator=(AString const &)
.text:00002C57                 mov     edx, [ebp+arg_0]
.text:00002C5A                 add     edx, 48h ; 'H'
.text:00002C5D                 push    edx
.text:00002C5E                 mov     ecx, [ebp+var_4]
.text:00002C61                 add     ecx, 48h ; 'H'
.text:00002C64                 call    ??4AString@@QAEAAV0@ABV0@@Z ; AString::operator=(AString const &)
.text:00002C69                 mov     eax, [ebp+arg_0]
.text:00002C6C                 add     eax, 54h ; 'T'
.text:00002C6F                 push    eax
.text:00002C70                 mov     ecx, [ebp+var_4]
.text:00002C73                 add     ecx, 54h ; 'T'
.text:00002C76                 call    ??4AString@@QAEAAV0@ABV0@@Z ; AString::operator=(AString const &)
.text:00002C7B                 mov     [ebp+var_8], 0
.text:00002C82                 jmp     short loc_2C8D
.text:00002C84 ; ---------------------------------------------------------------------------
.text:00002C84
.text:00002C84 loc_2C84:                               ; CODE XREF: NArchive::NTar::CItem::operator=(NArchive::NTar::CItem const &)+F5j
.text:00002C84                 mov     ecx, [ebp+var_8]
.text:00002C87                 add     ecx, 1
.text:00002C8A                 mov     [ebp+var_8], ecx
.text:00002C8D
.text:00002C8D loc_2C8D:                               ; CODE XREF: NArchive::NTar::CItem::operator=(NArchive::NTar::CItem const &)+D2j
.text:00002C8D                 cmp     [ebp+var_8], 8
.text:00002C91                 jnb     short loc_2CA7
.text:00002C93                 mov     edx, [ebp+var_4]
.text:00002C96                 add     edx, [ebp+var_8]
.text:00002C99                 mov     eax, [ebp+arg_0]
.text:00002C9C                 add     eax, [ebp+var_8]
.text:00002C9F                 mov     cl, [eax+60h]
.text:00002CA2                 mov     [edx+60h], cl
.text:00002CA5                 jmp     short loc_2C84
.text:00002CA7 ; ---------------------------------------------------------------------------
.text:00002CA7
.text:00002CA7 loc_2CA7:                               ; CODE XREF: NArchive::NTar::CItem::operator=(NArchive::NTar::CItem const &)+E1j
.text:00002CA7                 mov     edx, [ebp+var_4]
.text:00002CAA                 mov     eax, [ebp+arg_0]
.text:00002CAD                 mov     cl, [eax+68h]
.text:00002CB0                 mov     [edx+68h], cl
.text:00002CB3                 mov     edx, [ebp+var_4]
.text:00002CB6                 mov     eax, [ebp+arg_0]
.text:00002CB9                 mov     cl, [eax+69h]
.text:00002CBC                 mov     [edx+69h], cl
.text:00002CBF                 mov     edx, [ebp+var_4]
.text:00002CC2                 mov     eax, [ebp+arg_0]
.text:00002CC5                 mov     cl, [eax+6Ah]
.text:00002CC8                 mov     [edx+6Ah], cl
.text:00002CCB                 mov     edx, [ebp+arg_0]
.text:00002CCE                 add     edx, 6Ch ; 'l'
.text:00002CD1                 push    edx
.text:00002CD2                 mov     ecx, [ebp+var_4]
.text:00002CD5                 add     ecx, 6Ch ; 'l'
.text:00002CD8                 call    ??4?$CRecordVector@UCSparseBlock@NTar@NArchive@@@@QAEAAV0@ABV0@@Z ; CRecordVector<NArchive::NTar::CSparseBlock>::operator=(CRecordVector<NArchive::NTar::CSparseBlock> const &)
.text:00002CDD                 mov     eax, [ebp+var_4]
.text:00002CE0                 add     esp, 8
.text:00002CE3                 cmp     ebp, esp
.text:00002CE5                 call    __RTC_CheckEsp
.text:00002CEA                 mov     esp, ebp
.text:00002CEC                 pop     ebp
.text:00002CED                 retn    4
.text:00002CED ??4CItem@NTar@NArchive@@QAEAAU012@ABU012@@Z endp
.text:00002CED
.text:00002CED _text           ends
.text:00002CED
.text:00002CF0 ; ===========================================================================
.text:00002CF0
.text:00002CF0 ; Segment type: Pure code
.text:00002CF0 ; Segment permissions: Read/Execute
.text:00002CF0 _text           segment para public 'CODE' use32
.text:00002CF0                 assume cs:_text
.text:00002CF0                 ;org 2CF0h
.text:00002CF0 ; COMDAT (pick any)
.text:00002CF0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00002CF0
.text:00002CF0 ; =============== S U B R O U T I N E =======================================
.text:00002CF0
.text:00002CF0 ; Attributes: bp-based frame
.text:00002CF0
.text:00002CF0 ; public: __thiscall CMyComPtr<struct ISequentialInStream>::CMyComPtr<struct ISequentialInStream>(void)
.text:00002CF0                 public ??0?$CMyComPtr@UISequentialInStream@@@@QAE@XZ
.text:00002CF0 ??0?$CMyComPtr@UISequentialInStream@@@@QAE@XZ proc near
.text:00002CF0                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+6F4p
.text:00002CF0                                         ; NCompress::CCopyCoder::CCopyCoder(void)+79p ...
.text:00002CF0
.text:00002CF0 var_4           = dword ptr -4
.text:00002CF0
.text:00002CF0                 push    ebp
.text:00002CF1                 mov     ebp, esp
.text:00002CF3                 push    ecx
.text:00002CF4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002CFB                 mov     [ebp+var_4], ecx
.text:00002CFE                 mov     eax, [ebp+var_4]
.text:00002D01                 mov     dword ptr [eax], 0
.text:00002D07                 mov     eax, [ebp+var_4]
.text:00002D0A                 mov     esp, ebp
.text:00002D0C                 pop     ebp
.text:00002D0D                 retn
.text:00002D0D ??0?$CMyComPtr@UISequentialInStream@@@@QAE@XZ endp
.text:00002D0D
.text:00002D0D ; ---------------------------------------------------------------------------
.text:00002D0E                 align 10h
.text:00002D0E _text           ends
.text:00002D0E
.text:00002D10 ; ===========================================================================
.text:00002D10
.text:00002D10 ; Segment type: Pure code
.text:00002D10 ; Segment permissions: Read/Execute
.text:00002D10 _text           segment para public 'CODE' use32
.text:00002D10                 assume cs:_text
.text:00002D10                 ;org 2D10h
.text:00002D10 ; COMDAT (pick any)
.text:00002D10                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00002D10
.text:00002D10 ; =============== S U B R O U T I N E =======================================
.text:00002D10
.text:00002D10 ; Attributes: bp-based frame
.text:00002D10
.text:00002D10 ; public: __thiscall CMyComPtr<struct ISequentialInStream>::~CMyComPtr<struct ISequentialInStream>(void)
.text:00002D10                 public ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ
.text:00002D10 ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ proc near
.text:00002D10                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+7BAp
.text:00002D10                                         ; NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+990p ...
.text:00002D10
.text:00002D10 var_4           = dword ptr -4
.text:00002D10
.text:00002D10                 push    ebp
.text:00002D11                 mov     ebp, esp
.text:00002D13                 push    ecx
.text:00002D14                 push    esi
.text:00002D15                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002D1C                 mov     [ebp+var_4], ecx
.text:00002D1F                 mov     eax, [ebp+var_4]
.text:00002D22                 cmp     dword ptr [eax], 0
.text:00002D25                 jz      short loc_2D42
.text:00002D27                 mov     ecx, [ebp+var_4]
.text:00002D2A                 mov     edx, [ecx]
.text:00002D2C                 mov     eax, [ebp+var_4]
.text:00002D2F                 mov     ecx, [eax]
.text:00002D31                 mov     edx, [edx]
.text:00002D33                 mov     esi, esp
.text:00002D35                 push    ecx
.text:00002D36                 mov     eax, [edx+8]
.text:00002D39                 call    eax
.text:00002D3B                 cmp     esi, esp
.text:00002D3D                 call    __RTC_CheckEsp
.text:00002D42
.text:00002D42 loc_2D42:                               ; CODE XREF: CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)+15j
.text:00002D42                 pop     esi
.text:00002D43                 add     esp, 4
.text:00002D46                 cmp     ebp, esp
.text:00002D48                 call    __RTC_CheckEsp
.text:00002D4D                 mov     esp, ebp
.text:00002D4F                 pop     ebp
.text:00002D50                 retn
.text:00002D50 ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ endp
.text:00002D50
.text:00002D50 ; ---------------------------------------------------------------------------
.text:00002D51                 align 4
.text:00002D51 _text           ends
.text:00002D51
.text:00002D54 ; ===========================================================================
.text:00002D54
.text:00002D54 ; Segment type: Pure code
.text:00002D54 ; Segment permissions: Read/Execute
.text:00002D54 _text           segment para public 'CODE' use32
.text:00002D54                 assume cs:_text
.text:00002D54                 ;org 2D54h
.text:00002D54 ; COMDAT (pick any)
.text:00002D54                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00002D54
.text:00002D54 ; =============== S U B R O U T I N E =======================================
.text:00002D54
.text:00002D54 ; Attributes: bp-based frame
.text:00002D54
.text:00002D54 ; public: void __thiscall CMyComPtr<struct ISequentialInStream>::Release(void)
.text:00002D54                 public ?Release@?$CMyComPtr@UISequentialInStream@@@@QAEXXZ
.text:00002D54 ?Release@?$CMyComPtr@UISequentialInStream@@@@QAEXXZ proc near
.text:00002D54                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+A62p
.text:00002D54
.text:00002D54 var_4           = dword ptr -4
.text:00002D54
.text:00002D54                 push    ebp
.text:00002D55                 mov     ebp, esp
.text:00002D57                 push    ecx
.text:00002D58                 push    esi
.text:00002D59                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002D60                 mov     [ebp+var_4], ecx
.text:00002D63                 mov     eax, [ebp+var_4]
.text:00002D66                 cmp     dword ptr [eax], 0
.text:00002D69                 jz      short loc_2D8F
.text:00002D6B                 mov     ecx, [ebp+var_4]
.text:00002D6E                 mov     edx, [ecx]
.text:00002D70                 mov     eax, [ebp+var_4]
.text:00002D73                 mov     ecx, [eax]
.text:00002D75                 mov     edx, [edx]
.text:00002D77                 mov     esi, esp
.text:00002D79                 push    ecx
.text:00002D7A                 mov     eax, [edx+8]
.text:00002D7D                 call    eax
.text:00002D7F                 cmp     esi, esp
.text:00002D81                 call    __RTC_CheckEsp
.text:00002D86                 mov     ecx, [ebp+var_4]
.text:00002D89                 mov     dword ptr [ecx], 0
.text:00002D8F
.text:00002D8F loc_2D8F:                               ; CODE XREF: CMyComPtr<ISequentialInStream>::Release(void)+15j
.text:00002D8F                 pop     esi
.text:00002D90                 add     esp, 4
.text:00002D93                 cmp     ebp, esp
.text:00002D95                 call    __RTC_CheckEsp
.text:00002D9A                 mov     esp, ebp
.text:00002D9C                 pop     ebp
.text:00002D9D                 retn
.text:00002D9D ?Release@?$CMyComPtr@UISequentialInStream@@@@QAEXXZ endp
.text:00002D9D
.text:00002D9D ; ---------------------------------------------------------------------------
.text:00002D9E                 align 10h
.text:00002D9E _text           ends
.text:00002D9E
.text:00002DA0 ; ===========================================================================
.text:00002DA0
.text:00002DA0 ; Segment type: Pure code
.text:00002DA0 ; Segment permissions: Read/Execute
.text:00002DA0 _text           segment para public 'CODE' use32
.text:00002DA0                 assume cs:_text
.text:00002DA0                 ;org 2DA0h
.text:00002DA0 ; COMDAT (pick any)
.text:00002DA0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00002DA0
.text:00002DA0 ; =============== S U B R O U T I N E =======================================
.text:00002DA0
.text:00002DA0 ; Attributes: bp-based frame
.text:00002DA0
.text:00002DA0 ; public: __thiscall CMyComPtr<struct ISequentialInStream>::operator struct ISequentialInStream *(void)const
.text:00002DA0                 public ??B?$CMyComPtr@UISequentialInStream@@@@QBEPAUISequentialInStream@@XZ
.text:00002DA0 ??B?$CMyComPtr@UISequentialInStream@@@@QBEPAUISequentialInStream@@XZ proc near
.text:00002DA0                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+839p
.text:00002DA0                                         ; NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+B4Ep ...
.text:00002DA0
.text:00002DA0 var_4           = dword ptr -4
.text:00002DA0
.text:00002DA0                 push    ebp
.text:00002DA1                 mov     ebp, esp
.text:00002DA3                 push    ecx
.text:00002DA4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002DAB                 mov     [ebp+var_4], ecx
.text:00002DAE                 mov     eax, [ebp+var_4]
.text:00002DB1                 mov     eax, [eax]
.text:00002DB3                 mov     esp, ebp
.text:00002DB5                 pop     ebp
.text:00002DB6                 retn
.text:00002DB6 ??B?$CMyComPtr@UISequentialInStream@@@@QBEPAUISequentialInStream@@XZ endp
.text:00002DB6
.text:00002DB6 ; ---------------------------------------------------------------------------
.text:00002DB7                 align 4
.text:00002DB7 _text           ends
.text:00002DB7
.text:00002DB8 ; ===========================================================================
.text:00002DB8
.text:00002DB8 ; Segment type: Pure code
.text:00002DB8 ; Segment permissions: Read/Execute
.text:00002DB8 _text           segment para public 'CODE' use32
.text:00002DB8                 assume cs:_text
.text:00002DB8                 ;org 2DB8h
.text:00002DB8 ; COMDAT (pick any)
.text:00002DB8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00002DB8
.text:00002DB8 ; =============== S U B R O U T I N E =======================================
.text:00002DB8
.text:00002DB8 ; Attributes: bp-based frame
.text:00002DB8
.text:00002DB8 ; public: struct ISequentialInStream * * __thiscall CMyComPtr<struct ISequentialInStream>::operator&(void)
.text:00002DB8                 public ??I?$CMyComPtr@UISequentialInStream@@@@QAEPAPAUISequentialInStream@@XZ
.text:00002DB8 ??I?$CMyComPtr@UISequentialInStream@@@@QAEPAPAUISequentialInStream@@XZ proc near
.text:00002DB8                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+749p
.text:00002DB8
.text:00002DB8 var_4           = dword ptr -4
.text:00002DB8
.text:00002DB8                 push    ebp
.text:00002DB9                 mov     ebp, esp
.text:00002DBB                 push    ecx
.text:00002DBC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002DC3                 mov     [ebp+var_4], ecx
.text:00002DC6                 mov     eax, [ebp+var_4]
.text:00002DC9                 mov     esp, ebp
.text:00002DCB                 pop     ebp
.text:00002DCC                 retn
.text:00002DCC ??I?$CMyComPtr@UISequentialInStream@@@@QAEPAPAUISequentialInStream@@XZ endp
.text:00002DCC
.text:00002DCC ; ---------------------------------------------------------------------------
.text:00002DCD                 align 10h
.text:00002DCD _text           ends
.text:00002DCD
.text:00002DD0 ; ===========================================================================
.text:00002DD0
.text:00002DD0 ; Segment type: Pure code
.text:00002DD0 ; Segment permissions: Read/Execute
.text:00002DD0 _text           segment para public 'CODE' use32
.text:00002DD0                 assume cs:_text
.text:00002DD0                 ;org 2DD0h
.text:00002DD0 ; COMDAT (pick any)
.text:00002DD0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00002DD0
.text:00002DD0 ; =============== S U B R O U T I N E =======================================
.text:00002DD0
.text:00002DD0 ; Attributes: bp-based frame
.text:00002DD0
.text:00002DD0 ; public: struct ISequentialInStream * __thiscall CMyComPtr<struct ISequentialInStream>::operator->(void)const
.text:00002DD0                 public ??C?$CMyComPtr@UISequentialInStream@@@@QBEPAUISequentialInStream@@XZ
.text:00002DD0 ??C?$CMyComPtr@UISequentialInStream@@@@QBEPAUISequentialInStream@@XZ proc near
.text:00002DD0                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+85Bp
.text:00002DD0
.text:00002DD0 var_4           = dword ptr -4
.text:00002DD0
.text:00002DD0                 push    ebp
.text:00002DD1                 mov     ebp, esp
.text:00002DD3                 push    ecx
.text:00002DD4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002DDB                 mov     [ebp+var_4], ecx
.text:00002DDE                 mov     eax, [ebp+var_4]
.text:00002DE1                 mov     eax, [eax]
.text:00002DE3                 mov     esp, ebp
.text:00002DE5                 pop     ebp
.text:00002DE6                 retn
.text:00002DE6 ??C?$CMyComPtr@UISequentialInStream@@@@QBEPAUISequentialInStream@@XZ endp
.text:00002DE6
.text:00002DE6 ; ---------------------------------------------------------------------------
.text:00002DE7                 align 4
.text:00002DE7 _text           ends
.text:00002DE7
.text:00002DE8 ; ===========================================================================
.text:00002DE8
.text:00002DE8 ; Segment type: Pure code
.text:00002DE8 ; Segment permissions: Read/Execute
.text:00002DE8 _text           segment para public 'CODE' use32
.text:00002DE8                 assume cs:_text
.text:00002DE8                 ;org 2DE8h
.text:00002DE8 ; COMDAT (pick any)
.text:00002DE8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00002DE8
.text:00002DE8 ; =============== S U B R O U T I N E =======================================
.text:00002DE8
.text:00002DE8 ; Attributes: bp-based frame
.text:00002DE8
.text:00002DE8 ; public: struct ISequentialInStream * __thiscall CMyComPtr<struct ISequentialInStream>::operator=(struct ISequentialInStream *)
.text:00002DE8                 public ??4?$CMyComPtr@UISequentialInStream@@@@QAEPAUISequentialInStream@@PAU1@@Z
.text:00002DE8 ??4?$CMyComPtr@UISequentialInStream@@@@QAEPAUISequentialInStream@@PAU1@@Z proc near
.text:00002DE8                                         ; CODE XREF: CLimitedSequentialInStream::SetStream(ISequentialInStream *)+18p
.text:00002DE8
.text:00002DE8 var_4           = dword ptr -4
.text:00002DE8 arg_0           = dword ptr  8
.text:00002DE8
.text:00002DE8                 push    ebp
.text:00002DE9                 mov     ebp, esp
.text:00002DEB                 push    ecx
.text:00002DEC                 push    esi
.text:00002DED                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002DF4                 mov     [ebp+var_4], ecx
.text:00002DF7                 cmp     [ebp+arg_0], 0
.text:00002DFB                 jz      short loc_2E14
.text:00002DFD                 mov     eax, [ebp+arg_0]
.text:00002E00                 mov     ecx, [eax]
.text:00002E02                 mov     esi, esp
.text:00002E04                 mov     edx, [ebp+arg_0]
.text:00002E07                 push    edx
.text:00002E08                 mov     eax, [ecx+4]
.text:00002E0B                 call    eax
.text:00002E0D                 cmp     esi, esp
.text:00002E0F                 call    __RTC_CheckEsp
.text:00002E14
.text:00002E14 loc_2E14:                               ; CODE XREF: CMyComPtr<ISequentialInStream>::operator=(ISequentialInStream *)+13j
.text:00002E14                 mov     ecx, [ebp+var_4]
.text:00002E17                 cmp     dword ptr [ecx], 0
.text:00002E1A                 jz      short loc_2E37
.text:00002E1C                 mov     edx, [ebp+var_4]
.text:00002E1F                 mov     eax, [edx]
.text:00002E21                 mov     ecx, [ebp+var_4]
.text:00002E24                 mov     edx, [ecx]
.text:00002E26                 mov     eax, [eax]
.text:00002E28                 mov     esi, esp
.text:00002E2A                 push    edx
.text:00002E2B                 mov     ecx, [eax+8]
.text:00002E2E                 call    ecx
.text:00002E30                 cmp     esi, esp
.text:00002E32                 call    __RTC_CheckEsp
.text:00002E37
.text:00002E37 loc_2E37:                               ; CODE XREF: CMyComPtr<ISequentialInStream>::operator=(ISequentialInStream *)+32j
.text:00002E37                 mov     edx, [ebp+var_4]
.text:00002E3A                 mov     eax, [ebp+arg_0]
.text:00002E3D                 mov     [edx], eax
.text:00002E3F                 mov     eax, [ebp+arg_0]
.text:00002E42                 pop     esi
.text:00002E43                 add     esp, 4
.text:00002E46                 cmp     ebp, esp
.text:00002E48                 call    __RTC_CheckEsp
.text:00002E4D                 mov     esp, ebp
.text:00002E4F                 pop     ebp
.text:00002E50                 retn    4
.text:00002E50 ??4?$CMyComPtr@UISequentialInStream@@@@QAEPAUISequentialInStream@@PAU1@@Z endp
.text:00002E50
.text:00002E50 ; ---------------------------------------------------------------------------
.text:00002E53                 align 4
.text:00002E53 _text           ends
.text:00002E53
.text:00002E54 ; ===========================================================================
.text:00002E54
.text:00002E54 ; Segment type: Pure code
.text:00002E54 ; Segment permissions: Read/Execute
.text:00002E54 _text           segment para public 'CODE' use32
.text:00002E54                 assume cs:_text
.text:00002E54                 ;org 2E54h
.text:00002E54 ; COMDAT (pick any)
.text:00002E54                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00002E54
.text:00002E54 ; =============== S U B R O U T I N E =======================================
.text:00002E54
.text:00002E54 ; Attributes: bp-based frame
.text:00002E54
.text:00002E54 ; public: __thiscall CMyComPtr<struct ISequentialOutStream>::CMyComPtr<struct ISequentialOutStream>(void)
.text:00002E54                 public ??0?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ
.text:00002E54 ??0?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ proc near
.text:00002E54                                         ; CODE XREF: NArchive::NTar::COutArchive::COutArchive(void)+11p
.text:00002E54
.text:00002E54 var_4           = dword ptr -4
.text:00002E54
.text:00002E54                 push    ebp
.text:00002E55                 mov     ebp, esp
.text:00002E57                 push    ecx
.text:00002E58                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002E5F                 mov     [ebp+var_4], ecx
.text:00002E62                 mov     eax, [ebp+var_4]
.text:00002E65                 mov     dword ptr [eax], 0
.text:00002E6B                 mov     eax, [ebp+var_4]
.text:00002E6E                 mov     esp, ebp
.text:00002E70                 pop     ebp
.text:00002E71                 retn
.text:00002E71 ??0?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ endp
.text:00002E71
.text:00002E71 ; ---------------------------------------------------------------------------
.text:00002E72                 align 4
.text:00002E72 _text           ends
.text:00002E72
.text:00002E74 ; ===========================================================================
.text:00002E74
.text:00002E74 ; Segment type: Pure code
.text:00002E74 ; Segment permissions: Read/Execute
.text:00002E74 _text           segment para public 'CODE' use32
.text:00002E74                 assume cs:_text
.text:00002E74                 ;org 2E74h
.text:00002E74 ; COMDAT (pick any)
.text:00002E74                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00002E74
.text:00002E74 ; =============== S U B R O U T I N E =======================================
.text:00002E74
.text:00002E74 ; Attributes: bp-based frame
.text:00002E74
.text:00002E74 ; public: __thiscall CMyComPtr<struct ISequentialOutStream>::~CMyComPtr<struct ISequentialOutStream>(void)
.text:00002E74                 public ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ
.text:00002E74 ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ proc near
.text:00002E74                                         ; CODE XREF: NArchive::NTar::COutArchive::~COutArchive(void)+11p
.text:00002E74
.text:00002E74 var_4           = dword ptr -4
.text:00002E74
.text:00002E74                 push    ebp
.text:00002E75                 mov     ebp, esp
.text:00002E77                 push    ecx
.text:00002E78                 push    esi
.text:00002E79                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002E80                 mov     [ebp+var_4], ecx
.text:00002E83                 mov     eax, [ebp+var_4]
.text:00002E86                 cmp     dword ptr [eax], 0
.text:00002E89                 jz      short loc_2EA6
.text:00002E8B                 mov     ecx, [ebp+var_4]
.text:00002E8E                 mov     edx, [ecx]
.text:00002E90                 mov     eax, [ebp+var_4]
.text:00002E93                 mov     ecx, [eax]
.text:00002E95                 mov     edx, [edx]
.text:00002E97                 mov     esi, esp
.text:00002E99                 push    ecx
.text:00002E9A                 mov     eax, [edx+8]
.text:00002E9D                 call    eax
.text:00002E9F                 cmp     esi, esp
.text:00002EA1                 call    __RTC_CheckEsp
.text:00002EA6
.text:00002EA6 loc_2EA6:                               ; CODE XREF: CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)+15j
.text:00002EA6                 pop     esi
.text:00002EA7                 add     esp, 4
.text:00002EAA                 cmp     ebp, esp
.text:00002EAC                 call    __RTC_CheckEsp
.text:00002EB1                 mov     esp, ebp
.text:00002EB3                 pop     ebp
.text:00002EB4                 retn
.text:00002EB4 ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ endp
.text:00002EB4
.text:00002EB4 ; ---------------------------------------------------------------------------
.text:00002EB5                 align 4
.text:00002EB5 _text           ends
.text:00002EB5
.text:00002EB8 ; ===========================================================================
.text:00002EB8
.text:00002EB8 ; Segment type: Pure code
.text:00002EB8 ; Segment permissions: Read/Execute
.text:00002EB8 _text           segment para public 'CODE' use32
.text:00002EB8                 assume cs:_text
.text:00002EB8                 ;org 2EB8h
.text:00002EB8 ; COMDAT (pick any)
.text:00002EB8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00002EB8
.text:00002EB8 ; =============== S U B R O U T I N E =======================================
.text:00002EB8
.text:00002EB8 ; Attributes: bp-based frame
.text:00002EB8
.text:00002EB8 ; public: struct ISequentialOutStream * __thiscall CMyComPtr<struct ISequentialOutStream>::operator=(struct ISequentialOutStream *)
.text:00002EB8                 public ??4?$CMyComPtr@UISequentialOutStream@@@@QAEPAUISequentialOutStream@@PAU1@@Z
.text:00002EB8 ??4?$CMyComPtr@UISequentialOutStream@@@@QAEPAUISequentialOutStream@@PAU1@@Z proc near
.text:00002EB8                                         ; CODE XREF: NArchive::NTar::COutArchive::Create(ISequentialOutStream *)+15p
.text:00002EB8
.text:00002EB8 var_4           = dword ptr -4
.text:00002EB8 arg_0           = dword ptr  8
.text:00002EB8
.text:00002EB8                 push    ebp
.text:00002EB9                 mov     ebp, esp
.text:00002EBB                 push    ecx
.text:00002EBC                 push    esi
.text:00002EBD                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002EC4                 mov     [ebp+var_4], ecx
.text:00002EC7                 cmp     [ebp+arg_0], 0
.text:00002ECB                 jz      short loc_2EE4
.text:00002ECD                 mov     eax, [ebp+arg_0]
.text:00002ED0                 mov     ecx, [eax]
.text:00002ED2                 mov     esi, esp
.text:00002ED4                 mov     edx, [ebp+arg_0]
.text:00002ED7                 push    edx
.text:00002ED8                 mov     eax, [ecx+4]
.text:00002EDB                 call    eax
.text:00002EDD                 cmp     esi, esp
.text:00002EDF                 call    __RTC_CheckEsp
.text:00002EE4
.text:00002EE4 loc_2EE4:                               ; CODE XREF: CMyComPtr<ISequentialOutStream>::operator=(ISequentialOutStream *)+13j
.text:00002EE4                 mov     ecx, [ebp+var_4]
.text:00002EE7                 cmp     dword ptr [ecx], 0
.text:00002EEA                 jz      short loc_2F07
.text:00002EEC                 mov     edx, [ebp+var_4]
.text:00002EEF                 mov     eax, [edx]
.text:00002EF1                 mov     ecx, [ebp+var_4]
.text:00002EF4                 mov     edx, [ecx]
.text:00002EF6                 mov     eax, [eax]
.text:00002EF8                 mov     esi, esp
.text:00002EFA                 push    edx
.text:00002EFB                 mov     ecx, [eax+8]
.text:00002EFE                 call    ecx
.text:00002F00                 cmp     esi, esp
.text:00002F02                 call    __RTC_CheckEsp
.text:00002F07
.text:00002F07 loc_2F07:                               ; CODE XREF: CMyComPtr<ISequentialOutStream>::operator=(ISequentialOutStream *)+32j
.text:00002F07                 mov     edx, [ebp+var_4]
.text:00002F0A                 mov     eax, [ebp+arg_0]
.text:00002F0D                 mov     [edx], eax
.text:00002F0F                 mov     eax, [ebp+arg_0]
.text:00002F12                 pop     esi
.text:00002F13                 add     esp, 4
.text:00002F16                 cmp     ebp, esp
.text:00002F18                 call    __RTC_CheckEsp
.text:00002F1D                 mov     esp, ebp
.text:00002F1F                 pop     ebp
.text:00002F20                 retn    4
.text:00002F20 ??4?$CMyComPtr@UISequentialOutStream@@@@QAEPAUISequentialOutStream@@PAU1@@Z endp
.text:00002F20
.text:00002F20 ; ---------------------------------------------------------------------------
.text:00002F23                 align 4
.text:00002F23 _text           ends
.text:00002F23
.text:00002F24 ; ===========================================================================
.text:00002F24
.text:00002F24 ; Segment type: Pure code
.text:00002F24 ; Segment permissions: Read/Execute
.text:00002F24 _text           segment para public 'CODE' use32
.text:00002F24                 assume cs:_text
.text:00002F24                 ;org 2F24h
.text:00002F24 ; COMDAT (pick any)
.text:00002F24                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00002F24
.text:00002F24 ; =============== S U B R O U T I N E =======================================
.text:00002F24
.text:00002F24 ; Attributes: bp-based frame
.text:00002F24
.text:00002F24 ; public: __thiscall CMyComPtr<struct IOutStream>::CMyComPtr<struct IOutStream>(void)
.text:00002F24                 public ??0?$CMyComPtr@UIOutStream@@@@QAE@XZ
.text:00002F24 ??0?$CMyComPtr@UIOutStream@@@@QAE@XZ proc near
.text:00002F24                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+6Bp
.text:00002F24
.text:00002F24 var_4           = dword ptr -4
.text:00002F24
.text:00002F24                 push    ebp
.text:00002F25                 mov     ebp, esp
.text:00002F27                 push    ecx
.text:00002F28                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002F2F                 mov     [ebp+var_4], ecx
.text:00002F32                 mov     eax, [ebp+var_4]
.text:00002F35                 mov     dword ptr [eax], 0
.text:00002F3B                 mov     eax, [ebp+var_4]
.text:00002F3E                 mov     esp, ebp
.text:00002F40                 pop     ebp
.text:00002F41                 retn
.text:00002F41 ??0?$CMyComPtr@UIOutStream@@@@QAE@XZ endp
.text:00002F41
.text:00002F41 ; ---------------------------------------------------------------------------
.text:00002F42                 align 4
.text:00002F42 _text           ends
.text:00002F42
.text:00002F44 ; ===========================================================================
.text:00002F44
.text:00002F44 ; Segment type: Pure code
.text:00002F44 ; Segment permissions: Read/Execute
.text:00002F44 _text           segment para public 'CODE' use32
.text:00002F44                 assume cs:_text
.text:00002F44                 ;org 2F44h
.text:00002F44 ; COMDAT (pick any)
.text:00002F44                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00002F44
.text:00002F44 ; =============== S U B R O U T I N E =======================================
.text:00002F44
.text:00002F44 ; Attributes: bp-based frame
.text:00002F44
.text:00002F44 ; public: __thiscall CMyComPtr<struct IOutStream>::~CMyComPtr<struct IOutStream>(void)
.text:00002F44                 public ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ
.text:00002F44 ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ proc near
.text:00002F44                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+18Dp
.text:00002F44                                         ; NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+398p ...
.text:00002F44
.text:00002F44 var_4           = dword ptr -4
.text:00002F44
.text:00002F44                 push    ebp
.text:00002F45                 mov     ebp, esp
.text:00002F47                 push    ecx
.text:00002F48                 push    esi
.text:00002F49                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002F50                 mov     [ebp+var_4], ecx
.text:00002F53                 mov     eax, [ebp+var_4]
.text:00002F56                 cmp     dword ptr [eax], 0
.text:00002F59                 jz      short loc_2F76
.text:00002F5B                 mov     ecx, [ebp+var_4]
.text:00002F5E                 mov     edx, [ecx]
.text:00002F60                 mov     eax, [ebp+var_4]
.text:00002F63                 mov     ecx, [eax]
.text:00002F65                 mov     edx, [edx]
.text:00002F67                 mov     esi, esp
.text:00002F69                 push    ecx
.text:00002F6A                 mov     eax, [edx+8]
.text:00002F6D                 call    eax
.text:00002F6F                 cmp     esi, esp
.text:00002F71                 call    __RTC_CheckEsp
.text:00002F76
.text:00002F76 loc_2F76:                               ; CODE XREF: CMyComPtr<IOutStream>::~CMyComPtr<IOutStream>(void)+15j
.text:00002F76                 pop     esi
.text:00002F77                 add     esp, 4
.text:00002F7A                 cmp     ebp, esp
.text:00002F7C                 call    __RTC_CheckEsp
.text:00002F81                 mov     esp, ebp
.text:00002F83                 pop     ebp
.text:00002F84                 retn
.text:00002F84 ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ endp
.text:00002F84
.text:00002F84 ; ---------------------------------------------------------------------------
.text:00002F85                 align 4
.text:00002F85 _text           ends
.text:00002F85
.text:00002F88 ; ===========================================================================
.text:00002F88
.text:00002F88 ; Segment type: Pure code
.text:00002F88 ; Segment permissions: Read/Execute
.text:00002F88 _text           segment para public 'CODE' use32
.text:00002F88                 assume cs:_text
.text:00002F88                 ;org 2F88h
.text:00002F88 ; COMDAT (pick any)
.text:00002F88                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00002F88
.text:00002F88 ; =============== S U B R O U T I N E =======================================
.text:00002F88
.text:00002F88 ; Attributes: bp-based frame
.text:00002F88
.text:00002F88 ; public: struct IOutStream * * __thiscall CMyComPtr<struct IOutStream>::operator&(void)
.text:00002F88                 public ??I?$CMyComPtr@UIOutStream@@@@QAEPAPAUIOutStream@@XZ
.text:00002F88 ??I?$CMyComPtr@UIOutStream@@@@QAEPAPAUIOutStream@@XZ proc near
.text:00002F88                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+77p
.text:00002F88
.text:00002F88 var_4           = dword ptr -4
.text:00002F88
.text:00002F88                 push    ebp
.text:00002F89                 mov     ebp, esp
.text:00002F8B                 push    ecx
.text:00002F8C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002F93                 mov     [ebp+var_4], ecx
.text:00002F96                 mov     eax, [ebp+var_4]
.text:00002F99                 mov     esp, ebp
.text:00002F9B                 pop     ebp
.text:00002F9C                 retn
.text:00002F9C ??I?$CMyComPtr@UIOutStream@@@@QAEPAPAUIOutStream@@XZ endp
.text:00002F9C
.text:00002F9C ; ---------------------------------------------------------------------------
.text:00002F9D                 align 10h
.text:00002F9D _text           ends
.text:00002F9D
.text:00002FA0 ; ===========================================================================
.text:00002FA0
.text:00002FA0 ; Segment type: Pure code
.text:00002FA0 ; Segment permissions: Read/Execute
.text:00002FA0 _text           segment para public 'CODE' use32
.text:00002FA0                 assume cs:_text
.text:00002FA0                 ;org 2FA0h
.text:00002FA0 ; COMDAT (pick any)
.text:00002FA0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00002FA0
.text:00002FA0 ; =============== S U B R O U T I N E =======================================
.text:00002FA0
.text:00002FA0 ; Attributes: bp-based frame
.text:00002FA0
.text:00002FA0 ; public: struct IOutStream * __thiscall CMyComPtr<struct IOutStream>::operator->(void)const
.text:00002FA0                 public ??C?$CMyComPtr@UIOutStream@@@@QBEPAUIOutStream@@XZ
.text:00002FA0 ??C?$CMyComPtr@UIOutStream@@@@QBEPAUIOutStream@@XZ proc near
.text:00002FA0                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+D4Ap
.text:00002FA0                                         ; NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+F08p
.text:00002FA0
.text:00002FA0 var_4           = dword ptr -4
.text:00002FA0
.text:00002FA0                 push    ebp
.text:00002FA1                 mov     ebp, esp
.text:00002FA3                 push    ecx
.text:00002FA4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002FAB                 mov     [ebp+var_4], ecx
.text:00002FAE                 mov     eax, [ebp+var_4]
.text:00002FB1                 mov     eax, [eax]
.text:00002FB3                 mov     esp, ebp
.text:00002FB5                 pop     ebp
.text:00002FB6                 retn
.text:00002FB6 ??C?$CMyComPtr@UIOutStream@@@@QBEPAUIOutStream@@XZ endp
.text:00002FB6
.text:00002FB6 ; ---------------------------------------------------------------------------
.text:00002FB7                 align 4
.text:00002FB7 _text           ends
.text:00002FB7
.text:00002FB8 ; ===========================================================================
.text:00002FB8
.text:00002FB8 ; Segment type: Pure code
.text:00002FB8 ; Segment permissions: Read/Execute
.text:00002FB8 _text           segment para public 'CODE' use32
.text:00002FB8                 assume cs:_text
.text:00002FB8                 ;org 2FB8h
.text:00002FB8 ; COMDAT (pick any)
.text:00002FB8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00002FB8
.text:00002FB8 ; =============== S U B R O U T I N E =======================================
.text:00002FB8
.text:00002FB8 ; Attributes: bp-based frame
.text:00002FB8
.text:00002FB8 ; public: bool __thiscall CMyComPtr<struct IOutStream>::operator!(void)const
.text:00002FB8                 public ??7?$CMyComPtr@UIOutStream@@@@QBE_NXZ
.text:00002FB8 ??7?$CMyComPtr@UIOutStream@@@@QBE_NXZ proc near
.text:00002FB8                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+C8Cp
.text:00002FB8
.text:00002FB8 var_4           = dword ptr -4
.text:00002FB8
.text:00002FB8                 push    ebp
.text:00002FB9                 mov     ebp, esp
.text:00002FBB                 push    ecx
.text:00002FBC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002FC3                 mov     [ebp+var_4], ecx
.text:00002FC6                 mov     eax, [ebp+var_4]
.text:00002FC9                 xor     ecx, ecx
.text:00002FCB                 cmp     dword ptr [eax], 0
.text:00002FCE                 setz    cl
.text:00002FD1                 mov     al, cl
.text:00002FD3                 mov     esp, ebp
.text:00002FD5                 pop     ebp
.text:00002FD6                 retn
.text:00002FD6 ??7?$CMyComPtr@UIOutStream@@@@QBE_NXZ endp
.text:00002FD6
.text:00002FD6 ; ---------------------------------------------------------------------------
.text:00002FD7                 align 4
.text:00002FD7 _text           ends
.text:00002FD7
.text:00002FD8 ; ===========================================================================
.text:00002FD8
.text:00002FD8 ; Segment type: Pure code
.text:00002FD8 ; Segment permissions: Read/Execute
.text:00002FD8 _text           segment para public 'CODE' use32
.text:00002FD8                 assume cs:_text
.text:00002FD8                 ;org 2FD8h
.text:00002FD8 ; COMDAT (pick any)
.text:00002FD8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00002FD8
.text:00002FD8 ; =============== S U B R O U T I N E =======================================
.text:00002FD8
.text:00002FD8 ; Attributes: bp-based frame
.text:00002FD8
.text:00002FD8 ; public: __thiscall CMyComPtr<struct ICompressProgressInfo>::CMyComPtr<struct ICompressProgressInfo>(struct ICompressProgressInfo *)
.text:00002FD8                 public ??0?$CMyComPtr@UICompressProgressInfo@@@@QAE@PAUICompressProgressInfo@@@Z
.text:00002FD8 ??0?$CMyComPtr@UICompressProgressInfo@@@@QAE@PAUICompressProgressInfo@@@Z proc near
.text:00002FD8                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+269p
.text:00002FD8
.text:00002FD8 var_4           = dword ptr -4
.text:00002FD8 arg_0           = dword ptr  8
.text:00002FD8
.text:00002FD8                 push    ebp
.text:00002FD9                 mov     ebp, esp
.text:00002FDB                 push    ecx
.text:00002FDC                 push    esi
.text:00002FDD                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002FE4                 mov     [ebp+var_4], ecx
.text:00002FE7                 mov     eax, [ebp+var_4]
.text:00002FEA                 mov     ecx, [ebp+arg_0]
.text:00002FED                 mov     [eax], ecx
.text:00002FEF                 cmp     [ebp+arg_0], 0
.text:00002FF3                 jz      short loc_300C
.text:00002FF5                 mov     edx, [ebp+arg_0]
.text:00002FF8                 mov     eax, [edx]
.text:00002FFA                 mov     esi, esp
.text:00002FFC                 mov     ecx, [ebp+arg_0]
.text:00002FFF                 push    ecx
.text:00003000                 mov     edx, [eax+4]
.text:00003003                 call    edx
.text:00003005                 cmp     esi, esp
.text:00003007                 call    __RTC_CheckEsp
.text:0000300C
.text:0000300C loc_300C:                               ; CODE XREF: CMyComPtr<ICompressProgressInfo>::CMyComPtr<ICompressProgressInfo>(ICompressProgressInfo *)+1Bj
.text:0000300C                 mov     eax, [ebp+var_4]
.text:0000300F                 pop     esi
.text:00003010                 add     esp, 4
.text:00003013                 cmp     ebp, esp
.text:00003015                 call    __RTC_CheckEsp
.text:0000301A                 mov     esp, ebp
.text:0000301C                 pop     ebp
.text:0000301D                 retn    4
.text:0000301D ??0?$CMyComPtr@UICompressProgressInfo@@@@QAE@PAUICompressProgressInfo@@@Z endp
.text:0000301D
.text:0000301D _text           ends
.text:0000301D
.text:00003020 ; ===========================================================================
.text:00003020
.text:00003020 ; Segment type: Pure code
.text:00003020 ; Segment permissions: Read/Execute
.text:00003020 _text           segment para public 'CODE' use32
.text:00003020                 assume cs:_text
.text:00003020                 ;org 3020h
.text:00003020 ; COMDAT (pick any)
.text:00003020                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00003020
.text:00003020 ; =============== S U B R O U T I N E =======================================
.text:00003020
.text:00003020 ; Attributes: bp-based frame
.text:00003020
.text:00003020 ; public: __thiscall CMyComPtr<struct ICompressProgressInfo>::~CMyComPtr<struct ICompressProgressInfo>(void)
.text:00003020                 public ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ
.text:00003020 ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ proc near
.text:00003020                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+374p
.text:00003020                                         ; NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+592p ...
.text:00003020
.text:00003020 var_4           = dword ptr -4
.text:00003020
.text:00003020                 push    ebp
.text:00003021                 mov     ebp, esp
.text:00003023                 push    ecx
.text:00003024                 push    esi
.text:00003025                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000302C                 mov     [ebp+var_4], ecx
.text:0000302F                 mov     eax, [ebp+var_4]
.text:00003032                 cmp     dword ptr [eax], 0
.text:00003035                 jz      short loc_3052
.text:00003037                 mov     ecx, [ebp+var_4]
.text:0000303A                 mov     edx, [ecx]
.text:0000303C                 mov     eax, [ebp+var_4]
.text:0000303F                 mov     ecx, [eax]
.text:00003041                 mov     edx, [edx]
.text:00003043                 mov     esi, esp
.text:00003045                 push    ecx
.text:00003046                 mov     eax, [edx+8]
.text:00003049                 call    eax
.text:0000304B                 cmp     esi, esp
.text:0000304D                 call    __RTC_CheckEsp
.text:00003052
.text:00003052 loc_3052:                               ; CODE XREF: CMyComPtr<ICompressProgressInfo>::~CMyComPtr<ICompressProgressInfo>(void)+15j
.text:00003052                 pop     esi
.text:00003053                 add     esp, 4
.text:00003056                 cmp     ebp, esp
.text:00003058                 call    __RTC_CheckEsp
.text:0000305D                 mov     esp, ebp
.text:0000305F                 pop     ebp
.text:00003060                 retn
.text:00003060 ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ endp
.text:00003060
.text:00003060 ; ---------------------------------------------------------------------------
.text:00003061                 align 4
.text:00003061 _text           ends
.text:00003061
.text:00003064 ; ===========================================================================
.text:00003064
.text:00003064 ; Segment type: Pure code
.text:00003064 ; Segment permissions: Read/Execute
.text:00003064 _text           segment para public 'CODE' use32
.text:00003064                 assume cs:_text
.text:00003064                 ;org 3064h
.text:00003064 ; COMDAT (pick any)
.text:00003064                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00003064
.text:00003064 ; =============== S U B R O U T I N E =======================================
.text:00003064
.text:00003064 ; Attributes: bp-based frame
.text:00003064
.text:00003064 ; public: __thiscall CMyComPtr<struct ICompressProgressInfo>::operator struct ICompressProgressInfo *(void)const
.text:00003064                 public ??B?$CMyComPtr@UICompressProgressInfo@@@@QBEPAUICompressProgressInfo@@XZ
.text:00003064 ??B?$CMyComPtr@UICompressProgressInfo@@@@QBEPAUICompressProgressInfo@@XZ proc near
.text:00003064                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+B6Cp
.text:00003064                                         ; NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+1619p
.text:00003064
.text:00003064 var_4           = dword ptr -4
.text:00003064
.text:00003064                 push    ebp
.text:00003065                 mov     ebp, esp
.text:00003067                 push    ecx
.text:00003068                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000306F                 mov     [ebp+var_4], ecx
.text:00003072                 mov     eax, [ebp+var_4]
.text:00003075                 mov     eax, [eax]
.text:00003077                 mov     esp, ebp
.text:00003079                 pop     ebp
.text:0000307A                 retn
.text:0000307A ??B?$CMyComPtr@UICompressProgressInfo@@@@QBEPAUICompressProgressInfo@@XZ endp
.text:0000307A
.text:0000307A ; ---------------------------------------------------------------------------
.text:0000307B                 align 4
.text:0000307B _text           ends
.text:0000307B
.text:0000307C ; ===========================================================================
.text:0000307C
.text:0000307C ; Segment type: Pure code
.text:0000307C ; Segment permissions: Read/Execute
.text:0000307C _text           segment para public 'CODE' use32
.text:0000307C                 assume cs:_text
.text:0000307C                 ;org 307Ch
.text:0000307C ; COMDAT (pick any)
.text:0000307C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:0000307C
.text:0000307C ; =============== S U B R O U T I N E =======================================
.text:0000307C
.text:0000307C ; Attributes: bp-based frame
.text:0000307C
.text:0000307C ; public: __thiscall CRecordVector<struct NArchive::NTar::CSparseBlock>::CRecordVector<struct NArchive::NTar::CSparseBlock>(void)
.text:0000307C                 public ??0?$CRecordVector@UCSparseBlock@NTar@NArchive@@@@QAE@XZ
.text:0000307C ??0?$CRecordVector@UCSparseBlock@NTar@NArchive@@@@QAE@XZ proc near
.text:0000307C                                         ; CODE XREF: NArchive::NTar::CItem::CItem(void)+6Fp
.text:0000307C
.text:0000307C var_4           = dword ptr -4
.text:0000307C
.text:0000307C                 push    ebp
.text:0000307D                 mov     ebp, esp
.text:0000307F                 push    ecx
.text:00003080                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003087                 mov     [ebp+var_4], ecx
.text:0000308A                 mov     eax, [ebp+var_4]
.text:0000308D                 mov     dword ptr [eax], 0
.text:00003093                 mov     ecx, [ebp+var_4]
.text:00003096                 mov     dword ptr [ecx+4], 0
.text:0000309D                 mov     edx, [ebp+var_4]
.text:000030A0                 mov     dword ptr [edx+8], 0
.text:000030A7                 mov     eax, [ebp+var_4]
.text:000030AA                 mov     esp, ebp
.text:000030AC                 pop     ebp
.text:000030AD                 retn
.text:000030AD ??0?$CRecordVector@UCSparseBlock@NTar@NArchive@@@@QAE@XZ endp
.text:000030AD
.text:000030AD ; ---------------------------------------------------------------------------
.text:000030AE                 align 10h
.text:000030AE _text           ends
.text:000030AE
.text:000030B0 ; ===========================================================================
.text:000030B0
.text:000030B0 ; Segment type: Pure code
.text:000030B0 ; Segment permissions: Read/Execute
.text:000030B0 _text           segment para public 'CODE' use32
.text:000030B0                 assume cs:_text
.text:000030B0                 ;org 30B0h
.text:000030B0 ; COMDAT (pick any)
.text:000030B0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:000030B0
.text:000030B0 ; =============== S U B R O U T I N E =======================================
.text:000030B0
.text:000030B0 ; Attributes: bp-based frame
.text:000030B0
.text:000030B0 ; public: __thiscall CRecordVector<struct NArchive::NTar::CSparseBlock>::~CRecordVector<struct NArchive::NTar::CSparseBlock>(void)
.text:000030B0                 public ??1?$CRecordVector@UCSparseBlock@NTar@NArchive@@@@QAE@XZ
.text:000030B0 ??1?$CRecordVector@UCSparseBlock@NTar@NArchive@@@@QAE@XZ proc near
.text:000030B0                                         ; CODE XREF: NArchive::NTar::CItem::~CItem(void)+3Ap
.text:000030B0
.text:000030B0 var_8           = dword ptr -8
.text:000030B0 var_4           = dword ptr -4
.text:000030B0
.text:000030B0                 push    ebp
.text:000030B1                 mov     ebp, esp
.text:000030B3                 sub     esp, 8
.text:000030B6                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000030BD                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000030C4                 mov     [ebp+var_4], ecx
.text:000030C7                 mov     eax, [ebp+var_4]
.text:000030CA                 mov     ecx, [eax]
.text:000030CC                 mov     [ebp+var_8], ecx
.text:000030CF                 mov     edx, [ebp+var_8]
.text:000030D2                 push    edx             ; void *
.text:000030D3                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:000030D8                 add     esp, 4
.text:000030DB                 add     esp, 8
.text:000030DE                 cmp     ebp, esp
.text:000030E0                 call    __RTC_CheckEsp
.text:000030E5                 mov     esp, ebp
.text:000030E7                 pop     ebp
.text:000030E8                 retn
.text:000030E8 ??1?$CRecordVector@UCSparseBlock@NTar@NArchive@@@@QAE@XZ endp
.text:000030E8
.text:000030E8 ; ---------------------------------------------------------------------------
.text:000030E9                 align 4
.text:000030E9 _text           ends
.text:000030E9
.text:000030EC ; ===========================================================================
.text:000030EC
.text:000030EC ; Segment type: Pure code
.text:000030EC ; Segment permissions: Read/Execute
.text:000030EC _text           segment para public 'CODE' use32
.text:000030EC                 assume cs:_text
.text:000030EC                 ;org 30ECh
.text:000030EC ; COMDAT (pick any)
.text:000030EC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:000030EC
.text:000030EC ; =============== S U B R O U T I N E =======================================
.text:000030EC
.text:000030EC ; Attributes: bp-based frame
.text:000030EC
.text:000030EC ; public: void __thiscall CRecordVector<struct NArchive::NTar::CSparseBlock>::Clear(void)
.text:000030EC                 public ?Clear@?$CRecordVector@UCSparseBlock@NTar@NArchive@@@@QAEXXZ
.text:000030EC ?Clear@?$CRecordVector@UCSparseBlock@NTar@NArchive@@@@QAEXXZ proc near
.text:000030EC                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+618p
.text:000030EC
.text:000030EC var_4           = dword ptr -4
.text:000030EC
.text:000030EC                 push    ebp
.text:000030ED                 mov     ebp, esp
.text:000030EF                 push    ecx
.text:000030F0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000030F7                 mov     [ebp+var_4], ecx
.text:000030FA                 mov     eax, [ebp+var_4]
.text:000030FD                 mov     dword ptr [eax+4], 0
.text:00003104                 mov     esp, ebp
.text:00003106                 pop     ebp
.text:00003107                 retn
.text:00003107 ?Clear@?$CRecordVector@UCSparseBlock@NTar@NArchive@@@@QAEXXZ endp
.text:00003107
.text:00003107 _text           ends
.text:00003107
.text:00003108 ; ===========================================================================
.text:00003108
.text:00003108 ; Segment type: Pure code
.text:00003108 ; Segment permissions: Read/Execute
.text:00003108 _text           segment para public 'CODE' use32
.text:00003108                 assume cs:_text
.text:00003108                 ;org 3108h
.text:00003108 ; COMDAT (pick any)
.text:00003108                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00003108
.text:00003108 ; =============== S U B R O U T I N E =======================================
.text:00003108
.text:00003108 ; Attributes: bp-based frame
.text:00003108
.text:00003108 ; public: class CRecordVector<struct NArchive::NTar::CSparseBlock> & __thiscall CRecordVector<struct NArchive::NTar::CSparseBlock>::operator=(class CRecordVector<struct NArchive::NTar::CSparseBlock> const &)
.text:00003108                 public ??4?$CRecordVector@UCSparseBlock@NTar@NArchive@@@@QAEAAV0@ABV0@@Z
.text:00003108 ??4?$CRecordVector@UCSparseBlock@NTar@NArchive@@@@QAEAAV0@ABV0@@Z proc near
.text:00003108                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+123Bp
.text:00003108                                         ; NArchive::NTar::CItem::operator=(NArchive::NTar::CItem const &)+128p
.text:00003108
.text:00003108 var_10          = dword ptr -10h
.text:00003108 var_C           = dword ptr -0Ch
.text:00003108 var_8           = dword ptr -8
.text:00003108 var_4           = dword ptr -4
.text:00003108 arg_0           = dword ptr  8
.text:00003108
.text:00003108                 push    ebp
.text:00003109                 mov     ebp, esp
.text:0000310B                 sub     esp, 10h
.text:0000310E                 mov     eax, 0CCCCCCCCh
.text:00003113                 mov     [ebp+var_10], eax
.text:00003116                 mov     [ebp+var_C], eax
.text:00003119                 mov     [ebp+var_8], eax
.text:0000311C                 mov     [ebp+var_4], eax
.text:0000311F                 mov     [ebp+var_4], ecx
.text:00003122                 mov     eax, [ebp+arg_0]
.text:00003125                 cmp     eax, [ebp+var_4]
.text:00003128                 jnz     short loc_3132
.text:0000312A                 mov     eax, [ebp+var_4]
.text:0000312D                 jmp     loc_31D6
.text:00003132 ; ---------------------------------------------------------------------------
.text:00003132
.text:00003132 loc_3132:                               ; CODE XREF: CRecordVector<NArchive::NTar::CSparseBlock>::operator=(CRecordVector<NArchive::NTar::CSparseBlock> const &)+20j
.text:00003132                 mov     ecx, [ebp+arg_0]
.text:00003135                 call    ?Size@?$CRecordVector@UCSparseBlock@NTar@NArchive@@@@QBEIXZ ; CRecordVector<NArchive::NTar::CSparseBlock>::Size(void)
.text:0000313A                 mov     [ebp+var_8], eax
.text:0000313D                 mov     ecx, [ebp+var_4]
.text:00003140                 mov     edx, [ebp+var_8]
.text:00003143                 cmp     edx, [ecx+8]
.text:00003146                 jbe     short loc_31A9
.text:00003148                 mov     eax, [ebp+var_4]
.text:0000314B                 mov     ecx, [eax]
.text:0000314D                 mov     [ebp+var_C], ecx
.text:00003150                 mov     edx, [ebp+var_C]
.text:00003153                 push    edx             ; void *
.text:00003154                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00003159                 add     esp, 4
.text:0000315C                 mov     eax, [ebp+var_4]
.text:0000315F                 mov     dword ptr [eax+8], 0
.text:00003166                 mov     ecx, [ebp+var_4]
.text:00003169                 mov     dword ptr [ecx+4], 0
.text:00003170                 mov     edx, [ebp+var_4]
.text:00003173                 mov     dword ptr [edx], 0
.text:00003179                 xor     ecx, ecx
.text:0000317B                 mov     eax, [ebp+var_8]
.text:0000317E                 mov     edx, 10h
.text:00003183                 mul     edx
.text:00003185                 seto    cl
.text:00003188                 neg     ecx
.text:0000318A                 or      ecx, eax
.text:0000318C                 push    ecx             ; unsigned int
.text:0000318D                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00003192                 add     esp, 4
.text:00003195                 mov     [ebp+var_10], eax
.text:00003198                 mov     eax, [ebp+var_4]
.text:0000319B                 mov     ecx, [ebp+var_10]
.text:0000319E                 mov     [eax], ecx
.text:000031A0                 mov     edx, [ebp+var_4]
.text:000031A3                 mov     eax, [ebp+var_8]
.text:000031A6                 mov     [edx+8], eax
.text:000031A9
.text:000031A9 loc_31A9:                               ; CODE XREF: CRecordVector<NArchive::NTar::CSparseBlock>::operator=(CRecordVector<NArchive::NTar::CSparseBlock> const &)+3Ej
.text:000031A9                 mov     ecx, [ebp+var_4]
.text:000031AC                 mov     edx, [ebp+var_8]
.text:000031AF                 mov     [ecx+4], edx
.text:000031B2                 cmp     [ebp+var_8], 0
.text:000031B6                 jz      short loc_31D3
.text:000031B8                 mov     eax, [ebp+var_8]
.text:000031BB                 shl     eax, 4
.text:000031BE                 push    eax             ; Size
.text:000031BF                 mov     ecx, [ebp+arg_0]
.text:000031C2                 mov     edx, [ecx]
.text:000031C4                 push    edx             ; Src
.text:000031C5                 mov     eax, [ebp+var_4]
.text:000031C8                 mov     ecx, [eax]
.text:000031CA                 push    ecx             ; Dst
.text:000031CB                 call    _memcpy
.text:000031D0                 add     esp, 0Ch
.text:000031D3
.text:000031D3 loc_31D3:                               ; CODE XREF: CRecordVector<NArchive::NTar::CSparseBlock>::operator=(CRecordVector<NArchive::NTar::CSparseBlock> const &)+AEj
.text:000031D3                 mov     eax, [ebp+var_4]
.text:000031D6
.text:000031D6 loc_31D6:                               ; CODE XREF: CRecordVector<NArchive::NTar::CSparseBlock>::operator=(CRecordVector<NArchive::NTar::CSparseBlock> const &)+25j
.text:000031D6                 add     esp, 10h
.text:000031D9                 cmp     ebp, esp
.text:000031DB                 call    __RTC_CheckEsp
.text:000031E0                 mov     esp, ebp
.text:000031E2                 pop     ebp
.text:000031E3                 retn    4
.text:000031E3 ??4?$CRecordVector@UCSparseBlock@NTar@NArchive@@@@QAEAAV0@ABV0@@Z endp
.text:000031E3
.text:000031E3 ; ---------------------------------------------------------------------------
.text:000031E6                 align 4
.text:000031E6 _text           ends
.text:000031E6
.text:000031E8 ; ===========================================================================
.text:000031E8
.text:000031E8 ; Segment type: Pure code
.text:000031E8 ; Segment permissions: Read/Execute
.text:000031E8 _text           segment para public 'CODE' use32
.text:000031E8                 assume cs:_text
.text:000031E8                 ;org 31E8h
.text:000031E8 ; COMDAT (pick any)
.text:000031E8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:000031E8
.text:000031E8 ; =============== S U B R O U T I N E =======================================
.text:000031E8
.text:000031E8 ; Attributes: bp-based frame
.text:000031E8
.text:000031E8 ; public: __thiscall CMyComPtr<struct IArchiveUpdateCallbackFile>::CMyComPtr<struct IArchiveUpdateCallbackFile>(void)
.text:000031E8                 public ??0?$CMyComPtr@UIArchiveUpdateCallbackFile@@@@QAE@XZ
.text:000031E8 ??0?$CMyComPtr@UIArchiveUpdateCallbackFile@@@@QAE@XZ proc near
.text:000031E8                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+9Bp
.text:000031E8
.text:000031E8 var_4           = dword ptr -4
.text:000031E8
.text:000031E8                 push    ebp
.text:000031E9                 mov     ebp, esp
.text:000031EB                 push    ecx
.text:000031EC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000031F3                 mov     [ebp+var_4], ecx
.text:000031F6                 mov     eax, [ebp+var_4]
.text:000031F9                 mov     dword ptr [eax], 0
.text:000031FF                 mov     eax, [ebp+var_4]
.text:00003202                 mov     esp, ebp
.text:00003204                 pop     ebp
.text:00003205                 retn
.text:00003205 ??0?$CMyComPtr@UIArchiveUpdateCallbackFile@@@@QAE@XZ endp
.text:00003205
.text:00003205 ; ---------------------------------------------------------------------------
.text:00003206                 align 4
.text:00003206 _text           ends
.text:00003206
.text:00003208 ; ===========================================================================
.text:00003208
.text:00003208 ; Segment type: Pure code
.text:00003208 ; Segment permissions: Read/Execute
.text:00003208 _text           segment para public 'CODE' use32
.text:00003208                 assume cs:_text
.text:00003208                 ;org 3208h
.text:00003208 ; COMDAT (pick any)
.text:00003208                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00003208
.text:00003208 ; =============== S U B R O U T I N E =======================================
.text:00003208
.text:00003208 ; Attributes: bp-based frame
.text:00003208
.text:00003208 ; public: __thiscall CMyComPtr<struct IArchiveUpdateCallbackFile>::~CMyComPtr<struct IArchiveUpdateCallbackFile>(void)
.text:00003208                 public ??1?$CMyComPtr@UIArchiveUpdateCallbackFile@@@@QAE@XZ
.text:00003208 ??1?$CMyComPtr@UIArchiveUpdateCallbackFile@@@@QAE@XZ proc near
.text:00003208                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+181p
.text:00003208                                         ; NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+38Cp ...
.text:00003208
.text:00003208 var_4           = dword ptr -4
.text:00003208
.text:00003208                 push    ebp
.text:00003209                 mov     ebp, esp
.text:0000320B                 push    ecx
.text:0000320C                 push    esi
.text:0000320D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003214                 mov     [ebp+var_4], ecx
.text:00003217                 mov     eax, [ebp+var_4]
.text:0000321A                 cmp     dword ptr [eax], 0
.text:0000321D                 jz      short loc_323A
.text:0000321F                 mov     ecx, [ebp+var_4]
.text:00003222                 mov     edx, [ecx]
.text:00003224                 mov     eax, [ebp+var_4]
.text:00003227                 mov     ecx, [eax]
.text:00003229                 mov     edx, [edx]
.text:0000322B                 mov     esi, esp
.text:0000322D                 push    ecx
.text:0000322E                 mov     eax, [edx+8]
.text:00003231                 call    eax
.text:00003233                 cmp     esi, esp
.text:00003235                 call    __RTC_CheckEsp
.text:0000323A
.text:0000323A loc_323A:                               ; CODE XREF: CMyComPtr<IArchiveUpdateCallbackFile>::~CMyComPtr<IArchiveUpdateCallbackFile>(void)+15j
.text:0000323A                 pop     esi
.text:0000323B                 add     esp, 4
.text:0000323E                 cmp     ebp, esp
.text:00003240                 call    __RTC_CheckEsp
.text:00003245                 mov     esp, ebp
.text:00003247                 pop     ebp
.text:00003248                 retn
.text:00003248 ??1?$CMyComPtr@UIArchiveUpdateCallbackFile@@@@QAE@XZ endp
.text:00003248
.text:00003248 ; ---------------------------------------------------------------------------
.text:00003249                 align 4
.text:00003249 _text           ends
.text:00003249
.text:0000324C ; ===========================================================================
.text:0000324C
.text:0000324C ; Segment type: Pure code
.text:0000324C ; Segment permissions: Read/Execute
.text:0000324C _text           segment para public 'CODE' use32
.text:0000324C                 assume cs:_text
.text:0000324C                 ;org 324Ch
.text:0000324C ; COMDAT (pick any)
.text:0000324C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:0000324C
.text:0000324C ; =============== S U B R O U T I N E =======================================
.text:0000324C
.text:0000324C ; Attributes: bp-based frame
.text:0000324C
.text:0000324C ; public: __thiscall CMyComPtr<struct IArchiveUpdateCallbackFile>::operator struct IArchiveUpdateCallbackFile *(void)const
.text:0000324C                 public ??B?$CMyComPtr@UIArchiveUpdateCallbackFile@@@@QBEPAUIArchiveUpdateCallbackFile@@XZ
.text:0000324C ??B?$CMyComPtr@UIArchiveUpdateCallbackFile@@@@QBEPAUIArchiveUpdateCallbackFile@@XZ proc near
.text:0000324C                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+1530p
.text:0000324C
.text:0000324C var_4           = dword ptr -4
.text:0000324C
.text:0000324C                 push    ebp
.text:0000324D                 mov     ebp, esp
.text:0000324F                 push    ecx
.text:00003250                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003257                 mov     [ebp+var_4], ecx
.text:0000325A                 mov     eax, [ebp+var_4]
.text:0000325D                 mov     eax, [eax]
.text:0000325F                 mov     esp, ebp
.text:00003261                 pop     ebp
.text:00003262                 retn
.text:00003262 ??B?$CMyComPtr@UIArchiveUpdateCallbackFile@@@@QBEPAUIArchiveUpdateCallbackFile@@XZ endp
.text:00003262
.text:00003262 ; ---------------------------------------------------------------------------
.text:00003263                 align 4
.text:00003263 _text           ends
.text:00003263
.text:00003264 ; ===========================================================================
.text:00003264
.text:00003264 ; Segment type: Pure code
.text:00003264 ; Segment permissions: Read/Execute
.text:00003264 _text           segment para public 'CODE' use32
.text:00003264                 assume cs:_text
.text:00003264                 ;org 3264h
.text:00003264 ; COMDAT (pick any)
.text:00003264                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00003264
.text:00003264 ; =============== S U B R O U T I N E =======================================
.text:00003264
.text:00003264 ; Attributes: bp-based frame
.text:00003264
.text:00003264 ; public: struct IArchiveUpdateCallbackFile * * __thiscall CMyComPtr<struct IArchiveUpdateCallbackFile>::operator&(void)
.text:00003264                 public ??I?$CMyComPtr@UIArchiveUpdateCallbackFile@@@@QAEPAPAUIArchiveUpdateCallbackFile@@XZ
.text:00003264 ??I?$CMyComPtr@UIArchiveUpdateCallbackFile@@@@QAEPAPAUIArchiveUpdateCallbackFile@@XZ proc near
.text:00003264                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+A7p
.text:00003264
.text:00003264 var_4           = dword ptr -4
.text:00003264
.text:00003264                 push    ebp
.text:00003265                 mov     ebp, esp
.text:00003267                 push    ecx
.text:00003268                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000326F                 mov     [ebp+var_4], ecx
.text:00003272                 mov     eax, [ebp+var_4]
.text:00003275                 mov     esp, ebp
.text:00003277                 pop     ebp
.text:00003278                 retn
.text:00003278 ??I?$CMyComPtr@UIArchiveUpdateCallbackFile@@@@QAEPAPAUIArchiveUpdateCallbackFile@@XZ endp
.text:00003278
.text:00003278 ; ---------------------------------------------------------------------------
.text:00003279                 align 4
.text:00003279 _text           ends
.text:00003279
.text:0000327C ; ===========================================================================
.text:0000327C
.text:0000327C ; Segment type: Pure code
.text:0000327C ; Segment permissions: Read/Execute
.text:0000327C _text           segment para public 'CODE' use32
.text:0000327C                 assume cs:_text
.text:0000327C                 ;org 327Ch
.text:0000327C ; COMDAT (pick any)
.text:0000327C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:0000327C
.text:0000327C ; =============== S U B R O U T I N E =======================================
.text:0000327C
.text:0000327C ; Attributes: bp-based frame
.text:0000327C
.text:0000327C ; public: struct IArchiveUpdateCallbackFile * __thiscall CMyComPtr<struct IArchiveUpdateCallbackFile>::operator->(void)const
.text:0000327C                 public ??C?$CMyComPtr@UIArchiveUpdateCallbackFile@@@@QBEPAUIArchiveUpdateCallbackFile@@XZ
.text:0000327C ??C?$CMyComPtr@UIArchiveUpdateCallbackFile@@@@QBEPAUIArchiveUpdateCallbackFile@@XZ proc near
.text:0000327C                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+1540p
.text:0000327C
.text:0000327C var_4           = dword ptr -4
.text:0000327C
.text:0000327C                 push    ebp
.text:0000327D                 mov     ebp, esp
.text:0000327F                 push    ecx
.text:00003280                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003287                 mov     [ebp+var_4], ecx
.text:0000328A                 mov     eax, [ebp+var_4]
.text:0000328D                 mov     eax, [eax]
.text:0000328F                 mov     esp, ebp
.text:00003291                 pop     ebp
.text:00003292                 retn
.text:00003292 ??C?$CMyComPtr@UIArchiveUpdateCallbackFile@@@@QBEPAUIArchiveUpdateCallbackFile@@XZ endp
.text:00003292
.text:00003292 ; ---------------------------------------------------------------------------
.text:00003293                 align 4
.text:00003293 _text           ends
.text:00003293
.text:00003294 ; ===========================================================================
.text:00003294
.text:00003294 ; Segment type: Pure code
.text:00003294 ; Segment permissions: Read/Execute
.text:00003294 _text           segment para public 'CODE' use32
.text:00003294                 assume cs:_text
.text:00003294                 ;org 3294h
.text:00003294 ; COMDAT (pick any)
.text:00003294                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00003294
.text:00003294 ; =============== S U B R O U T I N E =======================================
.text:00003294
.text:00003294 ; Attributes: bp-based frame
.text:00003294
.text:00003294 ; public: unsigned int __thiscall CObjectVector<struct NArchive::NTar::CUpdateItem>::Size(void)const
.text:00003294                 public ?Size@?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QBEIXZ
.text:00003294 ?Size@?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QBEIXZ proc near
.text:00003294                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+EBp
.text:00003294                                         ; NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+312p
.text:00003294
.text:00003294 var_4           = dword ptr -4
.text:00003294
.text:00003294                 push    ebp
.text:00003295                 mov     ebp, esp
.text:00003297                 push    ecx
.text:00003298                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000329F                 mov     [ebp+var_4], ecx
.text:000032A2                 mov     ecx, [ebp+var_4]
.text:000032A5                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:000032AA                 add     esp, 4
.text:000032AD                 cmp     ebp, esp
.text:000032AF                 call    __RTC_CheckEsp
.text:000032B4                 mov     esp, ebp
.text:000032B6                 pop     ebp
.text:000032B7                 retn
.text:000032B7 ?Size@?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QBEIXZ endp
.text:000032B7
.text:000032B7 _text           ends
.text:000032B7
.text:000032B8 ; ===========================================================================
.text:000032B8
.text:000032B8 ; Segment type: Pure code
.text:000032B8 ; Segment permissions: Read/Execute
.text:000032B8 _text           segment para public 'CODE' use32
.text:000032B8                 assume cs:_text
.text:000032B8                 ;org 32B8h
.text:000032B8 ; COMDAT (pick any)
.text:000032B8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:000032B8
.text:000032B8 ; =============== S U B R O U T I N E =======================================
.text:000032B8
.text:000032B8 ; Attributes: bp-based frame
.text:000032B8
.text:000032B8 ; public: struct NArchive::NTar::CUpdateItem const & __thiscall CObjectVector<struct NArchive::NTar::CUpdateItem>::operator[](unsigned int)const
.text:000032B8                 public ??A?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QBEABUCUpdateItem@NTar@NArchive@@I@Z
.text:000032B8 ??A?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QBEABUCUpdateItem@NTar@NArchive@@I@Z proc near
.text:000032B8                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+FCp
.text:000032B8                                         ; NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+3BEp
.text:000032B8
.text:000032B8 var_4           = dword ptr -4
.text:000032B8 arg_0           = dword ptr  8
.text:000032B8
.text:000032B8                 push    ebp
.text:000032B9                 mov     ebp, esp
.text:000032BB                 push    ecx
.text:000032BC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000032C3                 mov     [ebp+var_4], ecx
.text:000032C6                 mov     eax, [ebp+arg_0]
.text:000032C9                 push    eax
.text:000032CA                 mov     ecx, [ebp+var_4]
.text:000032CD                 call    ??A?$CRecordVector@PAX@@QBEABQAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:000032D2                 mov     eax, [eax]
.text:000032D4                 add     esp, 4
.text:000032D7                 cmp     ebp, esp
.text:000032D9                 call    __RTC_CheckEsp
.text:000032DE                 mov     esp, ebp
.text:000032E0                 pop     ebp
.text:000032E1                 retn    4
.text:000032E1 ??A?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QBEABUCUpdateItem@NTar@NArchive@@I@Z endp
.text:000032E1
.text:000032E1 _text           ends
.text:000032E1
.text:000032E4 ; ===========================================================================
.text:000032E4
.text:000032E4 ; Segment type: Pure code
.text:000032E4 ; Segment permissions: Read/Execute
.text:000032E4 _text           segment para public 'CODE' use32
.text:000032E4                 assume cs:_text
.text:000032E4                 ;org 32E4h
.text:000032E4 ; COMDAT (pick any)
.text:000032E4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:000032E4
.text:000032E4 ; =============== S U B R O U T I N E =======================================
.text:000032E4
.text:000032E4 ; Attributes: bp-based frame
.text:000032E4
.text:000032E4 ; public: struct NArchive::NTar::CItemEx const & __thiscall CObjectVector<struct NArchive::NTar::CItemEx>::operator[](unsigned int)const
.text:000032E4                 public ??A?$CObjectVector@UCItemEx@NTar@NArchive@@@@QBEABUCItemEx@NTar@NArchive@@I@Z
.text:000032E4 ??A?$CObjectVector@UCItemEx@NTar@NArchive@@@@QBEABUCItemEx@NTar@NArchive@@I@Z proc near
.text:000032E4                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+12Fp
.text:000032E4                                         ; NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+4E0p ...
.text:000032E4
.text:000032E4 var_4           = dword ptr -4
.text:000032E4 arg_0           = dword ptr  8
.text:000032E4
.text:000032E4                 push    ebp
.text:000032E5                 mov     ebp, esp
.text:000032E7                 push    ecx
.text:000032E8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000032EF                 mov     [ebp+var_4], ecx
.text:000032F2                 mov     eax, [ebp+arg_0]
.text:000032F5                 push    eax
.text:000032F6                 mov     ecx, [ebp+var_4]
.text:000032F9                 call    ??A?$CRecordVector@PAX@@QBEABQAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:000032FE                 mov     eax, [eax]
.text:00003300                 add     esp, 4
.text:00003303                 cmp     ebp, esp
.text:00003305                 call    __RTC_CheckEsp
.text:0000330A                 mov     esp, ebp
.text:0000330C                 pop     ebp
.text:0000330D                 retn    4
.text:0000330D ??A?$CObjectVector@UCItemEx@NTar@NArchive@@@@QBEABUCItemEx@NTar@NArchive@@I@Z endp
.text:0000330D
.text:0000330D _text           ends
.text:0000330D
.text:00003310 ; ===========================================================================
.text:00003310
.text:00003310 ; Segment type: Pure code
.text:00003310 ; Segment permissions: Read/Execute
.text:00003310 _text           segment para public 'CODE' use32
.text:00003310                 assume cs:_text
.text:00003310                 ;org 3310h
.text:00003310 ; COMDAT (pick any)
.text:00003310                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00003310
.text:00003310 ; =============== S U B R O U T I N E =======================================
.text:00003310
.text:00003310 ; Attributes: bp-based frame
.text:00003310
.text:00003310 ; public: __thiscall CMyComPtr<struct ICompressCoder>::CMyComPtr<struct ICompressCoder>(struct ICompressCoder *)
.text:00003310                 public ??0?$CMyComPtr@UICompressCoder@@@@QAE@PAUICompressCoder@@@Z
.text:00003310 ??0?$CMyComPtr@UICompressCoder@@@@QAE@PAUICompressCoder@@@Z proc near
.text:00003310                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+206p
.text:00003310
.text:00003310 var_4           = dword ptr -4
.text:00003310 arg_0           = dword ptr  8
.text:00003310
.text:00003310                 push    ebp
.text:00003311                 mov     ebp, esp
.text:00003313                 push    ecx
.text:00003314                 push    esi
.text:00003315                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000331C                 mov     [ebp+var_4], ecx
.text:0000331F                 mov     eax, [ebp+var_4]
.text:00003322                 mov     ecx, [ebp+arg_0]
.text:00003325                 mov     [eax], ecx
.text:00003327                 cmp     [ebp+arg_0], 0
.text:0000332B                 jz      short loc_3344
.text:0000332D                 mov     edx, [ebp+arg_0]
.text:00003330                 mov     eax, [edx]
.text:00003332                 mov     esi, esp
.text:00003334                 mov     ecx, [ebp+arg_0]
.text:00003337                 push    ecx
.text:00003338                 mov     edx, [eax+4]
.text:0000333B                 call    edx
.text:0000333D                 cmp     esi, esp
.text:0000333F                 call    __RTC_CheckEsp
.text:00003344
.text:00003344 loc_3344:                               ; CODE XREF: CMyComPtr<ICompressCoder>::CMyComPtr<ICompressCoder>(ICompressCoder *)+1Bj
.text:00003344                 mov     eax, [ebp+var_4]
.text:00003347                 pop     esi
.text:00003348                 add     esp, 4
.text:0000334B                 cmp     ebp, esp
.text:0000334D                 call    __RTC_CheckEsp
.text:00003352                 mov     esp, ebp
.text:00003354                 pop     ebp
.text:00003355                 retn    4
.text:00003355 ??0?$CMyComPtr@UICompressCoder@@@@QAE@PAUICompressCoder@@@Z endp
.text:00003355
.text:00003355 _text           ends
.text:00003355
.text:00003358 ; ===========================================================================
.text:00003358
.text:00003358 ; Segment type: Pure code
.text:00003358 ; Segment permissions: Read/Execute
.text:00003358 _text           segment para public 'CODE' use32
.text:00003358                 assume cs:_text
.text:00003358                 ;org 3358h
.text:00003358 ; COMDAT (pick any)
.text:00003358                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00003358
.text:00003358 ; =============== S U B R O U T I N E =======================================
.text:00003358
.text:00003358 ; Attributes: bp-based frame
.text:00003358
.text:00003358 ; public: __thiscall CMyComPtr<struct ICompressCoder>::~CMyComPtr<struct ICompressCoder>(void)
.text:00003358                 public ??1?$CMyComPtr@UICompressCoder@@@@QAE@XZ
.text:00003358 ??1?$CMyComPtr@UICompressCoder@@@@QAE@XZ proc near
.text:00003358                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+380p
.text:00003358                                         ; NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+59Ep ...
.text:00003358
.text:00003358 var_4           = dword ptr -4
.text:00003358
.text:00003358                 push    ebp
.text:00003359                 mov     ebp, esp
.text:0000335B                 push    ecx
.text:0000335C                 push    esi
.text:0000335D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003364                 mov     [ebp+var_4], ecx
.text:00003367                 mov     eax, [ebp+var_4]
.text:0000336A                 cmp     dword ptr [eax], 0
.text:0000336D                 jz      short loc_338A
.text:0000336F                 mov     ecx, [ebp+var_4]
.text:00003372                 mov     edx, [ecx]
.text:00003374                 mov     eax, [ebp+var_4]
.text:00003377                 mov     ecx, [eax]
.text:00003379                 mov     edx, [edx]
.text:0000337B                 mov     esi, esp
.text:0000337D                 push    ecx
.text:0000337E                 mov     eax, [edx+8]
.text:00003381                 call    eax
.text:00003383                 cmp     esi, esp
.text:00003385                 call    __RTC_CheckEsp
.text:0000338A
.text:0000338A loc_338A:                               ; CODE XREF: CMyComPtr<ICompressCoder>::~CMyComPtr<ICompressCoder>(void)+15j
.text:0000338A                 pop     esi
.text:0000338B                 add     esp, 4
.text:0000338E                 cmp     ebp, esp
.text:00003390                 call    __RTC_CheckEsp
.text:00003395                 mov     esp, ebp
.text:00003397                 pop     ebp
.text:00003398                 retn
.text:00003398 ??1?$CMyComPtr@UICompressCoder@@@@QAE@XZ endp
.text:00003398
.text:00003398 ; ---------------------------------------------------------------------------
.text:00003399                 align 4
.text:00003399 _text           ends
.text:00003399
.text:0000339C ; ===========================================================================
.text:0000339C
.text:0000339C ; Segment type: Pure code
.text:0000339C ; Segment permissions: Read/Execute
.text:0000339C _text           segment para public 'CODE' use32
.text:0000339C                 assume cs:_text
.text:0000339C                 ;org 339Ch
.text:0000339C ; COMDAT (pick any)
.text:0000339C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:0000339C
.text:0000339C ; =============== S U B R O U T I N E =======================================
.text:0000339C
.text:0000339C ; Attributes: bp-based frame
.text:0000339C
.text:0000339C ; public: struct ICompressCoder * __thiscall CMyComPtr<struct ICompressCoder>::operator->(void)const
.text:0000339C                 public ??C?$CMyComPtr@UICompressCoder@@@@QBEPAUICompressCoder@@XZ
.text:0000339C ??C?$CMyComPtr@UICompressCoder@@@@QBEPAUICompressCoder@@XZ proc near
.text:0000339C                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+B5Ep
.text:0000339C                                         ; NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+160Bp
.text:0000339C
.text:0000339C var_4           = dword ptr -4
.text:0000339C
.text:0000339C                 push    ebp
.text:0000339D                 mov     ebp, esp
.text:0000339F                 push    ecx
.text:000033A0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000033A7                 mov     [ebp+var_4], ecx
.text:000033AA                 mov     eax, [ebp+var_4]
.text:000033AD                 mov     eax, [eax]
.text:000033AF                 mov     esp, ebp
.text:000033B1                 pop     ebp
.text:000033B2                 retn
.text:000033B2 ??C?$CMyComPtr@UICompressCoder@@@@QBEPAUICompressCoder@@XZ endp
.text:000033B2
.text:000033B2 ; ---------------------------------------------------------------------------
.text:000033B3                 align 4
.text:000033B3 _text           ends
.text:000033B3
.text:000033B4 ; ===========================================================================
.text:000033B4
.text:000033B4 ; Segment type: Pure code
.text:000033B4 ; Segment permissions: Read/Execute
.text:000033B4 _text           segment para public 'CODE' use32
.text:000033B4                 assume cs:_text
.text:000033B4                 ;org 33B4h
.text:000033B4 ; COMDAT (pick any)
.text:000033B4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:000033B4
.text:000033B4 ; =============== S U B R O U T I N E =======================================
.text:000033B4
.text:000033B4 ; Attributes: bp-based frame
.text:000033B4
.text:000033B4 ; public: __thiscall CMyComPtr<class CLimitedSequentialInStream>::CMyComPtr<class CLimitedSequentialInStream>(class CLimitedSequentialInStream *)
.text:000033B4                 public ??0?$CMyComPtr@VCLimitedSequentialInStream@@@@QAE@PAVCLimitedSequentialInStream@@@Z
.text:000033B4 ??0?$CMyComPtr@VCLimitedSequentialInStream@@@@QAE@PAVCLimitedSequentialInStream@@@Z proc near
.text:000033B4                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+2DAp
.text:000033B4
.text:000033B4 var_4           = dword ptr -4
.text:000033B4 arg_0           = dword ptr  8
.text:000033B4
.text:000033B4                 push    ebp
.text:000033B5                 mov     ebp, esp
.text:000033B7                 push    ecx
.text:000033B8                 push    esi
.text:000033B9                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000033C0                 mov     [ebp+var_4], ecx
.text:000033C3                 mov     eax, [ebp+var_4]
.text:000033C6                 mov     ecx, [ebp+arg_0]
.text:000033C9                 mov     [eax], ecx
.text:000033CB                 cmp     [ebp+arg_0], 0
.text:000033CF                 jz      short loc_33E8
.text:000033D1                 mov     edx, [ebp+arg_0]
.text:000033D4                 mov     eax, [edx]
.text:000033D6                 mov     esi, esp
.text:000033D8                 mov     ecx, [ebp+arg_0]
.text:000033DB                 push    ecx
.text:000033DC                 mov     edx, [eax+4]
.text:000033DF                 call    edx
.text:000033E1                 cmp     esi, esp
.text:000033E3                 call    __RTC_CheckEsp
.text:000033E8
.text:000033E8 loc_33E8:                               ; CODE XREF: CMyComPtr<CLimitedSequentialInStream>::CMyComPtr<CLimitedSequentialInStream>(CLimitedSequentialInStream *)+1Bj
.text:000033E8                 mov     eax, [ebp+var_4]
.text:000033EB                 pop     esi
.text:000033EC                 add     esp, 4
.text:000033EF                 cmp     ebp, esp
.text:000033F1                 call    __RTC_CheckEsp
.text:000033F6                 mov     esp, ebp
.text:000033F8                 pop     ebp
.text:000033F9                 retn    4
.text:000033F9 ??0?$CMyComPtr@VCLimitedSequentialInStream@@@@QAE@PAVCLimitedSequentialInStream@@@Z endp
.text:000033F9
.text:000033F9 _text           ends
.text:000033F9
.text:000033FC ; ===========================================================================
.text:000033FC
.text:000033FC ; Segment type: Pure code
.text:000033FC ; Segment permissions: Read/Execute
.text:000033FC _text           segment para public 'CODE' use32
.text:000033FC                 assume cs:_text
.text:000033FC                 ;org 33FCh
.text:000033FC ; COMDAT (pick any)
.text:000033FC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:000033FC
.text:000033FC ; =============== S U B R O U T I N E =======================================
.text:000033FC
.text:000033FC ; Attributes: bp-based frame
.text:000033FC
.text:000033FC ; public: __thiscall CMyComPtr<class CLimitedSequentialInStream>::~CMyComPtr<class CLimitedSequentialInStream>(void)
.text:000033FC                 public ??1?$CMyComPtr@VCLimitedSequentialInStream@@@@QAE@XZ
.text:000033FC ??1?$CMyComPtr@VCLimitedSequentialInStream@@@@QAE@XZ proc near
.text:000033FC                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+368p
.text:000033FC                                         ; NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+586p ...
.text:000033FC
.text:000033FC var_4           = dword ptr -4
.text:000033FC
.text:000033FC                 push    ebp
.text:000033FD                 mov     ebp, esp
.text:000033FF                 push    ecx
.text:00003400                 push    esi
.text:00003401                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003408                 mov     [ebp+var_4], ecx
.text:0000340B                 mov     eax, [ebp+var_4]
.text:0000340E                 cmp     dword ptr [eax], 0
.text:00003411                 jz      short loc_342E
.text:00003413                 mov     ecx, [ebp+var_4]
.text:00003416                 mov     edx, [ecx]
.text:00003418                 mov     eax, [ebp+var_4]
.text:0000341B                 mov     ecx, [eax]
.text:0000341D                 mov     edx, [edx]
.text:0000341F                 mov     esi, esp
.text:00003421                 push    ecx
.text:00003422                 mov     eax, [edx+8]
.text:00003425                 call    eax
.text:00003427                 cmp     esi, esp
.text:00003429                 call    __RTC_CheckEsp
.text:0000342E
.text:0000342E loc_342E:                               ; CODE XREF: CMyComPtr<CLimitedSequentialInStream>::~CMyComPtr<CLimitedSequentialInStream>(void)+15j
.text:0000342E                 pop     esi
.text:0000342F                 add     esp, 4
.text:00003432                 cmp     ebp, esp
.text:00003434                 call    __RTC_CheckEsp
.text:00003439                 mov     esp, ebp
.text:0000343B                 pop     ebp
.text:0000343C                 retn
.text:0000343C ??1?$CMyComPtr@VCLimitedSequentialInStream@@@@QAE@XZ endp
.text:0000343C
.text:0000343C ; ---------------------------------------------------------------------------
.text:0000343D                 align 10h
.text:0000343D _text           ends
.text:0000343D
.text:00003440 ; ===========================================================================
.text:00003440
.text:00003440 ; Segment type: Pure code
.text:00003440 ; Segment permissions: Read/Execute
.text:00003440 _text           segment para public 'CODE' use32
.text:00003440                 assume cs:_text
.text:00003440                 ;org 3440h
.text:00003440 ; COMDAT (pick any)
.text:00003440                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00003440
.text:00003440 ; =============== S U B R O U T I N E =======================================
.text:00003440
.text:00003440 ; Attributes: bp-based frame
.text:00003440
.text:00003440 ; public: __thiscall CMyComPtr<class CLimitedSequentialInStream>::operator class CLimitedSequentialInStream *(void)const
.text:00003440                 public ??B?$CMyComPtr@VCLimitedSequentialInStream@@@@QBEPAVCLimitedSequentialInStream@@XZ
.text:00003440 ??B?$CMyComPtr@VCLimitedSequentialInStream@@@@QBEPAVCLimitedSequentialInStream@@XZ proc near
.text:00003440                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+162Cp
.text:00003440
.text:00003440 var_4           = dword ptr -4
.text:00003440
.text:00003440                 push    ebp
.text:00003441                 mov     ebp, esp
.text:00003443                 push    ecx
.text:00003444                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000344B                 mov     [ebp+var_4], ecx
.text:0000344E                 mov     eax, [ebp+var_4]
.text:00003451                 mov     eax, [eax]
.text:00003453                 mov     esp, ebp
.text:00003455                 pop     ebp
.text:00003456                 retn
.text:00003456 ??B?$CMyComPtr@VCLimitedSequentialInStream@@@@QBEPAVCLimitedSequentialInStream@@XZ endp
.text:00003456
.text:00003456 ; ---------------------------------------------------------------------------
.text:00003457                 align 4
.text:00003457 _text           ends
.text:00003457
.text:00003458 ; ===========================================================================
.text:00003458
.text:00003458 ; Segment type: Pure code
.text:00003458 ; Segment permissions: Read/Execute
.text:00003458 _text           segment para public 'CODE' use32
.text:00003458                 assume cs:_text
.text:00003458                 ;org 3458h
.text:00003458 ; COMDAT (pick any)
.text:00003458                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00003458
.text:00003458 ; =============== S U B R O U T I N E =======================================
.text:00003458
.text:00003458 ; Attributes: bp-based frame
.text:00003458
.text:00003458 ; public: __thiscall CMyComPtr<struct IStreamGetProps>::CMyComPtr<struct IStreamGetProps>(void)
.text:00003458                 public ??0?$CMyComPtr@UIStreamGetProps@@@@QAE@XZ
.text:00003458 ??0?$CMyComPtr@UIStreamGetProps@@@@QAE@XZ proc near
.text:00003458                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+84Cp
.text:00003458
.text:00003458 var_4           = dword ptr -4
.text:00003458
.text:00003458                 push    ebp
.text:00003459                 mov     ebp, esp
.text:0000345B                 push    ecx
.text:0000345C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003463                 mov     [ebp+var_4], ecx
.text:00003466                 mov     eax, [ebp+var_4]
.text:00003469                 mov     dword ptr [eax], 0
.text:0000346F                 mov     eax, [ebp+var_4]
.text:00003472                 mov     esp, ebp
.text:00003474                 pop     ebp
.text:00003475                 retn
.text:00003475 ??0?$CMyComPtr@UIStreamGetProps@@@@QAE@XZ endp
.text:00003475
.text:00003475 ; ---------------------------------------------------------------------------
.text:00003476                 align 4
.text:00003476 _text           ends
.text:00003476
.text:00003478 ; ===========================================================================
.text:00003478
.text:00003478 ; Segment type: Pure code
.text:00003478 ; Segment permissions: Read/Execute
.text:00003478 _text           segment para public 'CODE' use32
.text:00003478                 assume cs:_text
.text:00003478                 ;org 3478h
.text:00003478 ; COMDAT (pick any)
.text:00003478                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00003478
.text:00003478 ; =============== S U B R O U T I N E =======================================
.text:00003478
.text:00003478 ; Attributes: bp-based frame
.text:00003478
.text:00003478 ; public: __thiscall CMyComPtr<struct IStreamGetProps>::~CMyComPtr<struct IStreamGetProps>(void)
.text:00003478                 public ??1?$CMyComPtr@UIStreamGetProps@@@@QAE@XZ
.text:00003478 ??1?$CMyComPtr@UIStreamGetProps@@@@QAE@XZ proc near
.text:00003478                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+922p
.text:00003478                                         ; __unwindfunclet$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z$12+6j
.text:00003478
.text:00003478 var_4           = dword ptr -4
.text:00003478
.text:00003478                 push    ebp
.text:00003479                 mov     ebp, esp
.text:0000347B                 push    ecx
.text:0000347C                 push    esi
.text:0000347D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003484                 mov     [ebp+var_4], ecx
.text:00003487                 mov     eax, [ebp+var_4]
.text:0000348A                 cmp     dword ptr [eax], 0
.text:0000348D                 jz      short loc_34AA
.text:0000348F                 mov     ecx, [ebp+var_4]
.text:00003492                 mov     edx, [ecx]
.text:00003494                 mov     eax, [ebp+var_4]
.text:00003497                 mov     ecx, [eax]
.text:00003499                 mov     edx, [edx]
.text:0000349B                 mov     esi, esp
.text:0000349D                 push    ecx
.text:0000349E                 mov     eax, [edx+8]
.text:000034A1                 call    eax
.text:000034A3                 cmp     esi, esp
.text:000034A5                 call    __RTC_CheckEsp
.text:000034AA
.text:000034AA loc_34AA:                               ; CODE XREF: CMyComPtr<IStreamGetProps>::~CMyComPtr<IStreamGetProps>(void)+15j
.text:000034AA                 pop     esi
.text:000034AB                 add     esp, 4
.text:000034AE                 cmp     ebp, esp
.text:000034B0                 call    __RTC_CheckEsp
.text:000034B5                 mov     esp, ebp
.text:000034B7                 pop     ebp
.text:000034B8                 retn
.text:000034B8 ??1?$CMyComPtr@UIStreamGetProps@@@@QAE@XZ endp
.text:000034B8
.text:000034B8 ; ---------------------------------------------------------------------------
.text:000034B9                 align 4
.text:000034B9 _text           ends
.text:000034B9
.text:000034BC ; ===========================================================================
.text:000034BC
.text:000034BC ; Segment type: Pure code
.text:000034BC ; Segment permissions: Read/Execute
.text:000034BC _text           segment para public 'CODE' use32
.text:000034BC                 assume cs:_text
.text:000034BC                 ;org 34BCh
.text:000034BC ; COMDAT (pick any)
.text:000034BC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:000034BC
.text:000034BC ; =============== S U B R O U T I N E =======================================
.text:000034BC
.text:000034BC ; Attributes: bp-based frame
.text:000034BC
.text:000034BC ; public: __thiscall CMyComPtr<struct IStreamGetProps>::operator struct IStreamGetProps *(void)const
.text:000034BC                 public ??B?$CMyComPtr@UIStreamGetProps@@@@QBEPAUIStreamGetProps@@XZ
.text:000034BC ??B?$CMyComPtr@UIStreamGetProps@@@@QBEPAUIStreamGetProps@@XZ proc near
.text:000034BC                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+899p
.text:000034BC
.text:000034BC var_4           = dword ptr -4
.text:000034BC
.text:000034BC                 push    ebp
.text:000034BD                 mov     ebp, esp
.text:000034BF                 push    ecx
.text:000034C0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000034C7                 mov     [ebp+var_4], ecx
.text:000034CA                 mov     eax, [ebp+var_4]
.text:000034CD                 mov     eax, [eax]
.text:000034CF                 mov     esp, ebp
.text:000034D1                 pop     ebp
.text:000034D2                 retn
.text:000034D2 ??B?$CMyComPtr@UIStreamGetProps@@@@QBEPAUIStreamGetProps@@XZ endp
.text:000034D2
.text:000034D2 ; ---------------------------------------------------------------------------
.text:000034D3                 align 4
.text:000034D3 _text           ends
.text:000034D3
.text:000034D4 ; ===========================================================================
.text:000034D4
.text:000034D4 ; Segment type: Pure code
.text:000034D4 ; Segment permissions: Read/Execute
.text:000034D4 _text           segment para public 'CODE' use32
.text:000034D4                 assume cs:_text
.text:000034D4                 ;org 34D4h
.text:000034D4 ; COMDAT (pick any)
.text:000034D4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:000034D4
.text:000034D4 ; =============== S U B R O U T I N E =======================================
.text:000034D4
.text:000034D4 ; Attributes: bp-based frame
.text:000034D4
.text:000034D4 ; public: struct IStreamGetProps * * __thiscall CMyComPtr<struct IStreamGetProps>::operator&(void)
.text:000034D4                 public ??I?$CMyComPtr@UIStreamGetProps@@@@QAEPAPAUIStreamGetProps@@XZ
.text:000034D4 ??I?$CMyComPtr@UIStreamGetProps@@@@QAEPAPAUIStreamGetProps@@XZ proc near
.text:000034D4                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+86Cp
.text:000034D4
.text:000034D4 var_4           = dword ptr -4
.text:000034D4
.text:000034D4                 push    ebp
.text:000034D5                 mov     ebp, esp
.text:000034D7                 push    ecx
.text:000034D8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000034DF                 mov     [ebp+var_4], ecx
.text:000034E2                 mov     eax, [ebp+var_4]
.text:000034E5                 mov     esp, ebp
.text:000034E7                 pop     ebp
.text:000034E8                 retn
.text:000034E8 ??I?$CMyComPtr@UIStreamGetProps@@@@QAEPAPAUIStreamGetProps@@XZ endp
.text:000034E8
.text:000034E8 ; ---------------------------------------------------------------------------
.text:000034E9                 align 4
.text:000034E9 _text           ends
.text:000034E9
.text:000034EC ; ===========================================================================
.text:000034EC
.text:000034EC ; Segment type: Pure code
.text:000034EC ; Segment permissions: Read/Execute
.text:000034EC _text           segment para public 'CODE' use32
.text:000034EC                 assume cs:_text
.text:000034EC                 ;org 34ECh
.text:000034EC ; COMDAT (pick any)
.text:000034EC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:000034EC
.text:000034EC ; =============== S U B R O U T I N E =======================================
.text:000034EC
.text:000034EC ; Attributes: bp-based frame
.text:000034EC
.text:000034EC ; public: struct IStreamGetProps * __thiscall CMyComPtr<struct IStreamGetProps>::operator->(void)const
.text:000034EC                 public ??C?$CMyComPtr@UIStreamGetProps@@@@QBEPAUIStreamGetProps@@XZ
.text:000034EC ??C?$CMyComPtr@UIStreamGetProps@@@@QBEPAUIStreamGetProps@@XZ proc near
.text:000034EC                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+8A8p
.text:000034EC
.text:000034EC var_4           = dword ptr -4
.text:000034EC
.text:000034EC                 push    ebp
.text:000034ED                 mov     ebp, esp
.text:000034EF                 push    ecx
.text:000034F0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000034F7                 mov     [ebp+var_4], ecx
.text:000034FA                 mov     eax, [ebp+var_4]
.text:000034FD                 mov     eax, [eax]
.text:000034FF                 mov     esp, ebp
.text:00003501                 pop     ebp
.text:00003502                 retn
.text:00003502 ??C?$CMyComPtr@UIStreamGetProps@@@@QBEPAUIStreamGetProps@@XZ endp
.text:00003502
.text:00003502 ; ---------------------------------------------------------------------------
.text:00003503                 align 4
.text:00003503 _text           ends
.text:00003503
.text:00003504 ; ===========================================================================
.text:00003504
.text:00003504 ; Segment type: Pure code
.text:00003504 ; Segment permissions: Read/Execute
.text:00003504 _text           segment para public 'CODE' use32
.text:00003504                 assume cs:_text
.text:00003504                 ;org 3504h
.text:00003504 ; COMDAT (pick any)
.text:00003504                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00003504
.text:00003504 ; =============== S U B R O U T I N E =======================================
.text:00003504
.text:00003504 ; Attributes: bp-based frame
.text:00003504
.text:00003504 ; public: unsigned int __thiscall CRecordVector<void *>::Size(void)const
.text:00003504                 public ?Size@?$CRecordVector@PAX@@QBEIXZ
.text:00003504 ?Size@?$CRecordVector@PAX@@QBEIXZ proc near
.text:00003504                                         ; CODE XREF: CObjectVector<NArchive::NTar::CUpdateItem>::Size(void)+11p
.text:00003504
.text:00003504 var_4           = dword ptr -4
.text:00003504
.text:00003504                 push    ebp
.text:00003505                 mov     ebp, esp
.text:00003507                 push    ecx
.text:00003508                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000350F                 mov     [ebp+var_4], ecx
.text:00003512                 mov     eax, [ebp+var_4]
.text:00003515                 mov     eax, [eax+4]
.text:00003518                 mov     esp, ebp
.text:0000351A                 pop     ebp
.text:0000351B                 retn
.text:0000351B ?Size@?$CRecordVector@PAX@@QBEIXZ endp
.text:0000351B
.text:0000351B _text           ends
.text:0000351B
.text:0000351C ; ===========================================================================
.text:0000351C
.text:0000351C ; Segment type: Pure code
.text:0000351C ; Segment permissions: Read/Execute
.text:0000351C _text           segment para public 'CODE' use32
.text:0000351C                 assume cs:_text
.text:0000351C                 ;org 351Ch
.text:0000351C ; COMDAT (pick any)
.text:0000351C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:0000351C
.text:0000351C ; =============== S U B R O U T I N E =======================================
.text:0000351C
.text:0000351C ; Attributes: bp-based frame
.text:0000351C
.text:0000351C ; public: void * const & __thiscall CRecordVector<void *>::operator[](unsigned int)const
.text:0000351C                 public ??A?$CRecordVector@PAX@@QBEABQAXI@Z
.text:0000351C ??A?$CRecordVector@PAX@@QBEABQAXI@Z proc near
.text:0000351C                                         ; CODE XREF: CObjectVector<NArchive::NTar::CUpdateItem>::operator[](uint)+15p
.text:0000351C                                         ; CObjectVector<NArchive::NTar::CItemEx>::operator[](uint)+15p
.text:0000351C
.text:0000351C var_4           = dword ptr -4
.text:0000351C arg_0           = dword ptr  8
.text:0000351C
.text:0000351C                 push    ebp
.text:0000351D                 mov     ebp, esp
.text:0000351F                 push    ecx
.text:00003520                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003527                 mov     [ebp+var_4], ecx
.text:0000352A                 mov     eax, [ebp+var_4]
.text:0000352D                 mov     ecx, [eax]
.text:0000352F                 mov     edx, [ebp+arg_0]
.text:00003532                 lea     eax, [ecx+edx*4]
.text:00003535                 mov     esp, ebp
.text:00003537                 pop     ebp
.text:00003538                 retn    4
.text:00003538 ??A?$CRecordVector@PAX@@QBEABQAXI@Z endp
.text:00003538
.text:00003538 ; ---------------------------------------------------------------------------
.text:0000353B                 align 4
.text:0000353B _text           ends
.text:0000353B
.text:0000353C ; ===========================================================================
.text:0000353C
.text:0000353C ; Segment type: Pure code
.text:0000353C ; Segment permissions: Read/Execute
.text:0000353C _text           segment para public 'CODE' use32
.text:0000353C                 assume cs:_text
.text:0000353C                 ;org 353Ch
.text:0000353C ; COMDAT (pick any)
.text:0000353C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:0000353C
.text:0000353C ; =============== S U B R O U T I N E =======================================
.text:0000353C
.text:0000353C ; Attributes: bp-based frame
.text:0000353C
.text:0000353C ; public: unsigned int __thiscall CRecordVector<struct NArchive::NTar::CSparseBlock>::Size(void)const
.text:0000353C                 public ?Size@?$CRecordVector@UCSparseBlock@NTar@NArchive@@@@QBEIXZ
.text:0000353C ?Size@?$CRecordVector@UCSparseBlock@NTar@NArchive@@@@QBEIXZ proc near
.text:0000353C                                         ; CODE XREF: CRecordVector<NArchive::NTar::CSparseBlock>::operator=(CRecordVector<NArchive::NTar::CSparseBlock> const &)+2Dp
.text:0000353C
.text:0000353C var_4           = dword ptr -4
.text:0000353C
.text:0000353C                 push    ebp
.text:0000353D                 mov     ebp, esp
.text:0000353F                 push    ecx
.text:00003540                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003547                 mov     [ebp+var_4], ecx
.text:0000354A                 mov     eax, [ebp+var_4]
.text:0000354D                 mov     eax, [eax+4]
.text:00003550                 mov     esp, ebp
.text:00003552                 pop     ebp
.text:00003553                 retn
.text:00003553 ?Size@?$CRecordVector@UCSparseBlock@NTar@NArchive@@@@QBEIXZ endp
.text:00003553
.text:00003553 _text           ends
.text:00003553
.text:00003554 ; ===========================================================================
.text:00003554
.text:00003554 ; Segment type: Pure code
.text:00003554 ; Segment permissions: Read/Execute
.text:00003554 _text           segment para public 'CODE' use32
.text:00003554                 assume cs:_text
.text:00003554                 ;org 3554h
.text:00003554 ; COMDAT (pick any)
.text:00003554                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00003554
.text:00003554 ; =============== S U B R O U T I N E =======================================
.text:00003554
.text:00003554
.text:00003554 ; [thunk]:public: virtual unsigned long __stdcall NCompress::CCopyCoder::Release`adjustor{4}' (void)
.text:00003554                 public ?Release@CCopyCoder@NCompress@@W3AGKXZ
.text:00003554 ?Release@CCopyCoder@NCompress@@W3AGKXZ proc near
.text:00003554                                         ; DATA XREF: .rdata:00001D70o
.text:00003554
.text:00003554 arg_0           = dword ptr  4
.text:00003554
.text:00003554                 sub     [esp+arg_0], 4
.text:00003559                 jmp     ?Release@CCopyCoder@NCompress@@UAGKXZ ; NCompress::CCopyCoder::Release(void)
.text:00003559 ?Release@CCopyCoder@NCompress@@W3AGKXZ endp
.text:00003559
.text:00003559 ; ---------------------------------------------------------------------------
.text:0000355E                 align 10h
.text:0000355E _text           ends
.text:0000355E
.text:00003560 ; ===========================================================================
.text:00003560
.text:00003560 ; Segment type: Pure code
.text:00003560 ; Segment permissions: Read/Execute
.text:00003560 _text           segment para public 'CODE' use32
.text:00003560                 assume cs:_text
.text:00003560                 ;org 3560h
.text:00003560 ; COMDAT (pick any)
.text:00003560                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00003560
.text:00003560 ; =============== S U B R O U T I N E =======================================
.text:00003560
.text:00003560
.text:00003560 ; [thunk]:public: virtual unsigned long __stdcall NCompress::CCopyCoder::Release`adjustor{8}' (void)
.text:00003560                 public ?Release@CCopyCoder@NCompress@@W7AGKXZ
.text:00003560 ?Release@CCopyCoder@NCompress@@W7AGKXZ proc near
.text:00003560                                         ; DATA XREF: .rdata:00001D5Co
.text:00003560
.text:00003560 arg_0           = dword ptr  4
.text:00003560
.text:00003560                 sub     [esp+arg_0], 8
.text:00003565                 jmp     ?Release@CCopyCoder@NCompress@@UAGKXZ ; NCompress::CCopyCoder::Release(void)
.text:00003565 ?Release@CCopyCoder@NCompress@@W7AGKXZ endp
.text:00003565
.text:00003565 ; ---------------------------------------------------------------------------
.text:0000356A                 align 4
.text:0000356A _text           ends
.text:0000356A
.text:0000356C ; ===========================================================================
.text:0000356C
.text:0000356C ; Segment type: Pure code
.text:0000356C ; Segment permissions: Read/Execute
.text:0000356C _text           segment para public 'CODE' use32
.text:0000356C                 assume cs:_text
.text:0000356C                 ;org 356Ch
.text:0000356C ; COMDAT (pick any)
.text:0000356C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:0000356C
.text:0000356C ; =============== S U B R O U T I N E =======================================
.text:0000356C
.text:0000356C
.text:0000356C ; [thunk]:public: virtual unsigned long __stdcall NCompress::CCopyCoder::Release`adjustor{12}' (void)
.text:0000356C                 public ?Release@CCopyCoder@NCompress@@WM@AGKXZ
.text:0000356C ?Release@CCopyCoder@NCompress@@WM@AGKXZ proc near
.text:0000356C                                         ; DATA XREF: .rdata:00001D48o
.text:0000356C
.text:0000356C arg_0           = dword ptr  4
.text:0000356C
.text:0000356C                 sub     [esp+arg_0], 0Ch
.text:00003571                 jmp     ?Release@CCopyCoder@NCompress@@UAGKXZ ; NCompress::CCopyCoder::Release(void)
.text:00003571 ?Release@CCopyCoder@NCompress@@WM@AGKXZ endp
.text:00003571
.text:00003571 ; ---------------------------------------------------------------------------
.text:00003576                 align 4
.text:00003576 _text           ends
.text:00003576
.text:00003578 ; ===========================================================================
.text:00003578
.text:00003578 ; Segment type: Pure code
.text:00003578 ; Segment permissions: Read/Execute
.text:00003578 _text           segment para public 'CODE' use32
.text:00003578                 assume cs:_text
.text:00003578                 ;org 3578h
.text:00003578 ; COMDAT (pick any)
.text:00003578                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00003578
.text:00003578 ; =============== S U B R O U T I N E =======================================
.text:00003578
.text:00003578
.text:00003578 ; [thunk]:public: virtual unsigned long __stdcall NCompress::CCopyCoder::AddRef`adjustor{4}' (void)
.text:00003578                 public ?AddRef@CCopyCoder@NCompress@@W3AGKXZ
.text:00003578 ?AddRef@CCopyCoder@NCompress@@W3AGKXZ proc near ; DATA XREF: .rdata:00001D6Co
.text:00003578
.text:00003578 arg_0           = dword ptr  4
.text:00003578
.text:00003578                 sub     [esp+arg_0], 4
.text:0000357D                 jmp     ?AddRef@CCopyCoder@NCompress@@UAGKXZ ; NCompress::CCopyCoder::AddRef(void)
.text:0000357D ?AddRef@CCopyCoder@NCompress@@W3AGKXZ endp
.text:0000357D
.text:0000357D ; ---------------------------------------------------------------------------
.text:00003582                 align 4
.text:00003582 _text           ends
.text:00003582
.text:00003584 ; ===========================================================================
.text:00003584
.text:00003584 ; Segment type: Pure code
.text:00003584 ; Segment permissions: Read/Execute
.text:00003584 _text           segment para public 'CODE' use32
.text:00003584                 assume cs:_text
.text:00003584                 ;org 3584h
.text:00003584 ; COMDAT (pick any)
.text:00003584                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00003584
.text:00003584 ; =============== S U B R O U T I N E =======================================
.text:00003584
.text:00003584
.text:00003584 ; [thunk]:public: virtual unsigned long __stdcall NCompress::CCopyCoder::AddRef`adjustor{8}' (void)
.text:00003584                 public ?AddRef@CCopyCoder@NCompress@@W7AGKXZ
.text:00003584 ?AddRef@CCopyCoder@NCompress@@W7AGKXZ proc near ; DATA XREF: .rdata:00001D58o
.text:00003584
.text:00003584 arg_0           = dword ptr  4
.text:00003584
.text:00003584                 sub     [esp+arg_0], 8
.text:00003589                 jmp     ?AddRef@CCopyCoder@NCompress@@UAGKXZ ; NCompress::CCopyCoder::AddRef(void)
.text:00003589 ?AddRef@CCopyCoder@NCompress@@W7AGKXZ endp
.text:00003589
.text:00003589 ; ---------------------------------------------------------------------------
.text:0000358E                 align 10h
.text:0000358E _text           ends
.text:0000358E
.text:00003590 ; ===========================================================================
.text:00003590
.text:00003590 ; Segment type: Pure code
.text:00003590 ; Segment permissions: Read/Execute
.text:00003590 _text           segment para public 'CODE' use32
.text:00003590                 assume cs:_text
.text:00003590                 ;org 3590h
.text:00003590 ; COMDAT (pick any)
.text:00003590                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:00003590
.text:00003590 ; =============== S U B R O U T I N E =======================================
.text:00003590
.text:00003590
.text:00003590 ; [thunk]:public: virtual long __stdcall NCompress::CCopyCoder::QueryInterface`adjustor{4}' (struct _GUID const &, void * *)
.text:00003590                 public ?QueryInterface@CCopyCoder@NCompress@@W3AGJABU_GUID@@PAPAX@Z
.text:00003590 ?QueryInterface@CCopyCoder@NCompress@@W3AGJABU_GUID@@PAPAX@Z proc near
.text:00003590                                         ; DATA XREF: .rdata:const NCompress::CCopyCoder::`vftable'{for `ICompressSetInStream'}o
.text:00003590
.text:00003590 arg_0           = dword ptr  4
.text:00003590
.text:00003590                 sub     [esp+arg_0], 4
.text:00003595                 jmp     ?QueryInterface@CCopyCoder@NCompress@@UAGJABU_GUID@@PAPAX@Z ; NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *)
.text:00003595 ?QueryInterface@CCopyCoder@NCompress@@W3AGJABU_GUID@@PAPAX@Z endp
.text:00003595
.text:00003595 ; ---------------------------------------------------------------------------
.text:0000359A                 align 4
.text:0000359A _text           ends
.text:0000359A
.text:0000359C ; ===========================================================================
.text:0000359C
.text:0000359C ; Segment type: Pure code
.text:0000359C ; Segment permissions: Read/Execute
.text:0000359C _text           segment para public 'CODE' use32
.text:0000359C                 assume cs:_text
.text:0000359C                 ;org 359Ch
.text:0000359C ; COMDAT (pick any)
.text:0000359C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:0000359C
.text:0000359C ; =============== S U B R O U T I N E =======================================
.text:0000359C
.text:0000359C
.text:0000359C ; [thunk]:public: virtual unsigned long __stdcall NCompress::CCopyCoder::AddRef`adjustor{12}' (void)
.text:0000359C                 public ?AddRef@CCopyCoder@NCompress@@WM@AGKXZ
.text:0000359C ?AddRef@CCopyCoder@NCompress@@WM@AGKXZ proc near
.text:0000359C                                         ; DATA XREF: .rdata:00001D44o
.text:0000359C
.text:0000359C arg_0           = dword ptr  4
.text:0000359C
.text:0000359C                 sub     [esp+arg_0], 0Ch
.text:000035A1                 jmp     ?AddRef@CCopyCoder@NCompress@@UAGKXZ ; NCompress::CCopyCoder::AddRef(void)
.text:000035A1 ?AddRef@CCopyCoder@NCompress@@WM@AGKXZ endp
.text:000035A1
.text:000035A1 ; ---------------------------------------------------------------------------
.text:000035A6                 align 4
.text:000035A6 _text           ends
.text:000035A6
.text:000035A8 ; ===========================================================================
.text:000035A8
.text:000035A8 ; Segment type: Pure code
.text:000035A8 ; Segment permissions: Read/Execute
.text:000035A8 _text           segment para public 'CODE' use32
.text:000035A8                 assume cs:_text
.text:000035A8                 ;org 35A8h
.text:000035A8 ; COMDAT (pick any)
.text:000035A8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:000035A8
.text:000035A8 ; =============== S U B R O U T I N E =======================================
.text:000035A8
.text:000035A8
.text:000035A8 ; [thunk]:public: virtual long __stdcall NCompress::CCopyCoder::QueryInterface`adjustor{8}' (struct _GUID const &, void * *)
.text:000035A8                 public ?QueryInterface@CCopyCoder@NCompress@@W7AGJABU_GUID@@PAPAX@Z
.text:000035A8 ?QueryInterface@CCopyCoder@NCompress@@W7AGJABU_GUID@@PAPAX@Z proc near
.text:000035A8                                         ; DATA XREF: .rdata:const NCompress::CCopyCoder::`vftable'{for `ISequentialInStream'}o
.text:000035A8
.text:000035A8 arg_0           = dword ptr  4
.text:000035A8
.text:000035A8                 sub     [esp+arg_0], 8
.text:000035AD                 jmp     ?QueryInterface@CCopyCoder@NCompress@@UAGJABU_GUID@@PAPAX@Z ; NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *)
.text:000035AD ?QueryInterface@CCopyCoder@NCompress@@W7AGJABU_GUID@@PAPAX@Z endp
.text:000035AD
.text:000035AD ; ---------------------------------------------------------------------------
.text:000035B2                 align 4
.text:000035B2 _text           ends
.text:000035B2
.text:000035B4 ; ===========================================================================
.text:000035B4
.text:000035B4 ; Segment type: Pure code
.text:000035B4 ; Segment permissions: Read/Execute
.text:000035B4 _text           segment para public 'CODE' use32
.text:000035B4                 assume cs:_text
.text:000035B4                 ;org 35B4h
.text:000035B4 ; COMDAT (pick any)
.text:000035B4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text:000035B4
.text:000035B4 ; =============== S U B R O U T I N E =======================================
.text:000035B4
.text:000035B4
.text:000035B4 ; [thunk]:public: virtual long __stdcall NCompress::CCopyCoder::QueryInterface`adjustor{12}' (struct _GUID const &, void * *)
.text:000035B4                 public ?QueryInterface@CCopyCoder@NCompress@@WM@AGJABU_GUID@@PAPAX@Z
.text:000035B4 ?QueryInterface@CCopyCoder@NCompress@@WM@AGJABU_GUID@@PAPAX@Z proc near
.text:000035B4                                         ; DATA XREF: .rdata:const NCompress::CCopyCoder::`vftable'{for `ICompressGetInStreamProcessedSize'}o
.text:000035B4
.text:000035B4 arg_0           = dword ptr  4
.text:000035B4
.text:000035B4                 sub     [esp+arg_0], 0Ch
.text:000035B9                 jmp     ?QueryInterface@CCopyCoder@NCompress@@UAGJABU_GUID@@PAPAX@Z ; NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *)
.text:000035B9 ?QueryInterface@CCopyCoder@NCompress@@WM@AGJABU_GUID@@PAPAX@Z endp
.text:000035B9
.text:000035B9 _text           ends
.text:000035B9
UNDEF:000035C0 ; ===========================================================================
UNDEF:000035C0
UNDEF:000035C0 ; Segment type: Externs
UNDEF:000035C0 ; UNDEF
UNDEF:000035C0 ; void __cdecl operator delete(void *)
UNDEF:000035C0                 extrn ??3@YAXPAX@Z:near ; CODE XREF: __unwindfunclet$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z$3+7p
UNDEF:000035C0                                         ; __unwindfunclet$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z$5+7p ...
UNDEF:000035C4 ; __int32 __thiscall NArchive::NTar::COutArchive::WriteFinishHeader(NArchive::NTar::COutArchive *__hidden this)
UNDEF:000035C4                 extrn ?WriteFinishHeader@COutArchive@NTar@NArchive@@QAEJXZ:near
UNDEF:000035C4                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+191Cp
UNDEF:000035C8 ; __int32 __thiscall NArchive::NTar::COutArchive::FillDataResidual(NArchive::NTar::COutArchive *__hidden this, unsigned __int64)
UNDEF:000035C8                 extrn ?FillDataResidual@COutArchive@NTar@NArchive@@QAEJ_K@Z:near
UNDEF:000035C8                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+100Dp
UNDEF:000035C8                                         ; NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+17B2p
UNDEF:000035CC ; __int32 __thiscall NArchive::NTar::COutArchive::WriteHeader(NArchive::NTar::COutArchive *__hidden this, const struct NArchive::NTar::CItem *)
UNDEF:000035CC                 extrn ?WriteHeader@COutArchive@NTar@NArchive@@QAEJABUCItem@23@@Z:near
UNDEF:000035CC                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+AA1p
UNDEF:000035CC                                         ; NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+E5Ep ...
UNDEF:000035D0 ; __int64 NWindows::NTime::FileTimeToUnixTime64(NWindows::NTime *__hidden this, const struct _FILETIME *)
UNDEF:000035D0                 extrn ?FileTimeToUnixTime64@NTime@NWindows@@YG_JABU_FILETIME@@@Z:near
UNDEF:000035D0                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+907p
UNDEF:000035D4                 extrn _IID_IStreamGetProps:near
UNDEF:000035D4                                         ; DATA XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+874o
UNDEF:000035D8 ; __int32 NArchive::NTar::GetPropString(NArchive::NTar *__hidden this, struct IArchiveUpdateCallback *, unsigned int, unsigned __int32, struct AString *, unsigned int, bool)
UNDEF:000035D8                 extrn ?GetPropString@NTar@NArchive@@YGJPAUIArchiveUpdateCallback@@IKAAVAString@@I_N@Z:near
UNDEF:000035D8                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+53Dp
UNDEF:000035D8                                         ; NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+953p
UNDEF:000035DC ; public: __thiscall AString::AString(void)
UNDEF:000035DC                 extrn ??0AString@@QAE@XZ:near
UNDEF:000035DC                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+4F7p
UNDEF:000035DC                                         ; NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+92Dp ...
UNDEF:000035E0 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:000035E0                 extrn _memcpy:near      ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+4CAp
UNDEF:000035E0                                         ; CRecordVector<NArchive::NTar::CSparseBlock>::operator=(CRecordVector<NArchive::NTar::CSparseBlock> const &)+C3p
UNDEF:000035E4 ; char const * const NArchive::NTar::NFileHeader::NMagic::kUsTar_00
UNDEF:000035E4                 extrn ?kUsTar_00@NMagic@NFileHeader@NTar@NArchive@@3QBDB:near
UNDEF:000035E4                                         ; DATA XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+4BEo
UNDEF:000035E8 ; public: class AString & __thiscall AString::operator=(class AString const &)
UNDEF:000035E8                 extrn ??4AString@@QAEAAV0@ABV0@@Z:near
UNDEF:000035E8                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+409p
UNDEF:000035E8                                         ; NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+41Ep ...
UNDEF:000035EC ; __int32 __thiscall CLocalProgress::SetCur(CLocalProgress *__hidden this)
UNDEF:000035EC                 extrn ?SetCur@CLocalProgress@@QAEJXZ:near
UNDEF:000035EC                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+341p
UNDEF:000035EC                                         ; NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+18A6p
UNDEF:000035F0 ; void __thiscall CLocalProgress::Init(CLocalProgress *__hidden this, struct IProgress *, bool)
UNDEF:000035F0                 extrn ?Init@CLocalProgress@@QAEXPAUIProgress@@_N@Z:near
UNDEF:000035F0                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+27Bp
UNDEF:000035F4 ; public: __thiscall CLocalProgress::CLocalProgress(void)
UNDEF:000035F4                 extrn ??0CLocalProgress@@QAE@XZ:near
UNDEF:000035F4                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+232p
UNDEF:000035F8 ; void *__cdecl operator new(unsigned int)
UNDEF:000035F8                 extrn ??2@YAPAXI@Z:near ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+1AEp
UNDEF:000035F8                                         ; NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+211p ...
UNDEF:000035FC                 extrn _IID_IArchiveUpdateCallbackFile:near
UNDEF:000035FC                                         ; DATA XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+AFo
UNDEF:00003600                 extrn _IID_IOutStream:near
UNDEF:00003600                                         ; DATA XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+7Fo
UNDEF:00003604                 extrn ___security_cookie:near
UNDEF:00003604                                         ; DATA XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+2Br
UNDEF:00003604                                         ; NArchive::NTar::CItem::CItem(void)+19r ...
UNDEF:00003608                 extrn ___CxxFrameHandler3:near
UNDEF:00003608                                         ; CODE XREF: __ehhandler$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z+23j
UNDEF:00003608                                         ; __ehhandler$??0CItem@NTar@NArchive@@QAE@XZ+16j ...
UNDEF:0000360C ; __fastcall __security_check_cookie(x)
UNDEF:0000360C                 extrn @__security_check_cookie@4:near
UNDEF:0000360C                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+199Bp
UNDEF:0000360C                                         ; __ehhandler$?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z+Fp ...
UNDEF:00003610 ; __fastcall _RTC_CheckStackVars(x, x)
UNDEF:00003610                 extrn @_RTC_CheckStackVars@8:near
UNDEF:00003610                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+1982p
UNDEF:00003614                 extrn __RTC_CheckEsp:near
UNDEF:00003614                                         ; CODE XREF: NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+93p
UNDEF:00003614                                         ; NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)+C3p ...
UNDEF:00003618                 extrn __RTC_Shutdown:near
UNDEF:00003618                                         ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
UNDEF:0000361C                 extrn __RTC_InitBase:near
UNDEF:0000361C                                         ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
UNDEF:00003620 ; const type_info::`vftable'
UNDEF:00003620                 extrn ??_7type_info@@6B@:near
UNDEF:00003620                                         ; DATA XREF: .data:NCompress::CCopyCoder `RTTI Type Descriptor'o
UNDEF:00003620                                         ; .data:ICompressCoder `RTTI Type Descriptor'o ...
UNDEF:00003624 ; public: virtual long __stdcall NCompress::CCopyCoder::Code(struct ISequentialInStream *, struct ISequentialOutStream *, unsigned __int64 const *, unsigned __int64 const *, struct ICompressProgressInfo *)
UNDEF:00003624                 extrn ?Code@CCopyCoder@NCompress@@UAGJPAUISequentialInStream@@PAUISequentialOutStream@@PB_K2PAUICompressProgressInfo@@@Z:near
UNDEF:00003624                                         ; DATA XREF: .rdata:00001D8Co
UNDEF:00003628 ; public: virtual long __stdcall NCompress::CCopyCoder::SetInStream(struct ISequentialInStream *)
UNDEF:00003628                 extrn ?SetInStream@CCopyCoder@NCompress@@UAGJPAUISequentialInStream@@@Z:near
UNDEF:00003628                                         ; DATA XREF: .rdata:00001D74o
UNDEF:0000362C ; public: virtual long __stdcall NCompress::CCopyCoder::ReleaseInStream(void)
UNDEF:0000362C                 extrn ?ReleaseInStream@CCopyCoder@NCompress@@UAGJXZ:near
UNDEF:0000362C                                         ; DATA XREF: .rdata:00001D78o
UNDEF:00003630 ; public: virtual long __stdcall NCompress::CCopyCoder::Read(void *, unsigned int, unsigned int *)
UNDEF:00003630                 extrn ?Read@CCopyCoder@NCompress@@UAGJPAXIPAI@Z:near
UNDEF:00003630                                         ; DATA XREF: .rdata:00001D60o
UNDEF:00003634 ; public: virtual long __stdcall NCompress::CCopyCoder::GetInStreamProcessedSize(unsigned __int64 *)
UNDEF:00003634                 extrn ?GetInStreamProcessedSize@CCopyCoder@NCompress@@UAGJPA_K@Z:near
UNDEF:00003634                                         ; DATA XREF: .rdata:00001D4Co
UNDEF:00003638                 extrn _IID_ICompressGetInStreamProcessedSize:near
UNDEF:00003638                                         ; DATA XREF: NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *):loc_223Ao
UNDEF:0000363C                 extrn _IID_ISequentialInStream:near
UNDEF:0000363C                                         ; DATA XREF: NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *):loc_2206o
UNDEF:0000363C                                         ; CLimitedSequentialInStream::QueryInterface(_GUID const &,void * *):loc_282Co
UNDEF:00003640                 extrn _IID_ICompressSetInStream:near
UNDEF:00003640                                         ; DATA XREF: NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *):loc_21D2o
UNDEF:00003644                 extrn _IID_ICompressCoder:near
UNDEF:00003644                                         ; DATA XREF: NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *):loc_21B3o
UNDEF:00003648 ; const IID IID_IUnknown
UNDEF:00003648                 extrn _IID_IUnknown:near
UNDEF:00003648                                         ; DATA XREF: NCompress::CCopyCoder::QueryInterface(_GUID const &,void * *)+24o
UNDEF:00003648                                         ; CLimitedSequentialInStream::QueryInterface(_GUID const &,void * *)+Co
UNDEF:0000364C ; int __cdecl memcmp(const void *Buf1, const void *Buf2, size_t Size)
UNDEF:0000364C                 extrn _memcmp:near      ; CODE XREF: IsEqualGUID(x,x)+Dp
UNDEF:00003650                 extrn __purecall:near   ; DATA XREF: .rdata:const ICompressCoder::`vftable'o
UNDEF:00003650                                         ; .rdata:000023B4o ...
UNDEF:00003654 ; _DWORD __thiscall NCompress::CCopyCoder::~CCopyCoder(NCompress::CCopyCoder *__hidden this)
UNDEF:00003654                 extrn ??1CCopyCoder@NCompress@@QAE@XZ:near
UNDEF:00003654                                         ; CODE XREF: NCompress::CCopyCoder::`scalar deleting destructor'(uint)+11p
UNDEF:00003658 ; bool NArchive::NItemName::HasTailSlash(NArchive::NItemName *__hidden this, const struct AString *, unsigned int)
UNDEF:00003658                 extrn ?HasTailSlash@NItemName@NArchive@@YG_NABVAString@@I@Z:near
UNDEF:00003658                                         ; CODE XREF: NArchive::NTar::CItem::IsDir(void)+42p
UNDEF:0000365C ; public: virtual long __stdcall CLimitedSequentialInStream::Read(void *, unsigned int, unsigned int *)
UNDEF:0000365C                 extrn ?Read@CLimitedSequentialInStream@@UAGJPAXIPAI@Z:near
UNDEF:0000365C                                         ; DATA XREF: .rdata:00002764o
UNDEF:0000365C
UNDEF:0000365C
UNDEF:0000365C                 end