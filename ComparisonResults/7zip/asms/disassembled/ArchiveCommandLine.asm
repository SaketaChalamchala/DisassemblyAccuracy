.rdata:00000000 ;
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.rdata:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.rdata:00000000 ; |                      License info: 48-3677-7074-51                      |
.rdata:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ;
.rdata:00000000 ; Input MD5   : 8662EB79680885E700026C5B2EEDE0C9
.rdata:00000000 ; Input CRC32 : 968E0A76
.rdata:00000000
.rdata:00000000 ; File Name   : C:\workspace\7z1505-src\CPP\7zip\Bundles\Alone\Debug\ArchiveCommandLine.obj
.rdata:00000000 ; Format      : COFF (X386MAGIC)
.rdata:00000000 ; includelib "uuid.lib"
.rdata:00000000 ; includelib "MSVCRTD"
.rdata:00000000 ; includelib "OLDNAMES"
.rdata:00000000
.rdata:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.rdata:00000000
.rdata:00000000                 .686p
.rdata:00000000                 .mmx
.rdata:00000000                 .model flat
.rdata:00000000
.rdata:00000000 ; ===========================================================================
.rdata:00000000
.rdata:00000000 ; Segment type: Pure data
.rdata:00000000 ; Segment permissions: Read
.rdata:00000000 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00000000 _rdata          segment para public 'DATA' use32
.rdata:00000000                 assume cs:_rdata
.rdata:00000000 $SG76863        dd offset loc_2D30      ; DATA XREF: .data:_kRecursedPostCharSeto
.rdata:00000004 $SG76865        db  73h ; s             ; DATA XREF: .data:_k_ArcNameMode_PostCharSeto
.rdata:00000005                 db  65h ; e
.rdata:00000006                 db  61h ; a
.rdata:00000007                 db    0
.rdata:00000008 $SG76867        db  30h ; 0             ; DATA XREF: .data:_k_Stream_PostCharSeto
.rdata:00000009                 db  31h ; 1
.rdata:0000000A                 db  32h ; 2
.rdata:0000000B                 db    0
.rdata:0000000C $SG76887        db 'asut',0             ; DATA XREF: .data:_kOverwritePostCharSeto
.rdata:00000011                 align 4
.rdata:00000014 _k_OverwriteModes dd 1                  ; DATA XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+815r
.rdata:00000018                 db    2
.rdata:00000019                 db    0
.rdata:0000001A                 db    0
.rdata:0000001B                 db    0
.rdata:0000001C                 db    3
.rdata:0000001D                 db    0
.rdata:0000001E                 db    0
.rdata:0000001F                 db    0
.rdata:00000020                 db    4
.rdata:00000021                 db    0
.rdata:00000022                 db    0
.rdata:00000023                 db    0
.rdata:00000024 $SG76890        dd offset unk_3F        ; DATA XREF: .data:_kSwitchFormso
.rdata:00000028 $SG76891        db  68h ; h             ; DATA XREF: .data:0000060Co
.rdata:00000029                 db    0
.rdata:0000002A unk_2A          db    0                 ; DATA XREF: .rdata:$SG76969o
.rdata:0000002B                 db    0
.rdata:0000002C $SG76892        db  2Dh ; -             ; DATA XREF: .data:00000618o
.rdata:0000002D aHelp           db 'help',0             ; DATA XREF: .rdata:$SG77335o
.rdata:00000032 unk_32          db    0                 ; DATA XREF: .rdata:$SG77597o
.rdata:00000033                 db    0
.rdata:00000034 $SG76893        dd offset loc_6162      ; DATA XREF: .data:00000624o
.rdata:00000038 $SG76894        dd offset loc_6461+1    ; DATA XREF: .data:00000630o
.rdata:0000003C $SG76895        db  62h ; b             ; DATA XREF: .data:0000063Co
.rdata:0000003D                 db  74h ; t
.rdata:0000003E                 db    0
.rdata:0000003F unk_3F          db    0                 ; DATA XREF: .rdata:$SG76890o
.rdata:00000040 $SG76896        dd offset loc_6261+1    ; DATA XREF: .data:00000648o
.rdata:00000044 $SG76897        db  62h ; b             ; DATA XREF: .data:00000654o
.rdata:00000045                 db  73h ; s
.rdata:00000046                 db  6Fh ; o
.rdata:00000047                 db    0
.rdata:00000048 $SG76942        dd offset $SG76933      ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+5ABo
.rdata:00000048                                         ; "spf"
.rdata:0000004C $SG76941        db  73h ; s             ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+595o
.rdata:0000004D                 db  74h ; t
.rdata:0000004E                 db  6Ch ; l
.rdata:0000004F                 db    0
.rdata:00000050 $SG76940        db 'sdel',0             ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+57Do
.rdata:00000055                 align 4
.rdata:00000058 $SG76939        db 'snc',0              ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+565o
.rdata:0000005C $SG76938        db 'snr',0              ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+54Fo
.rdata:00000060 $SG76937        db 'sns',0              ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+529o
.rdata:00000064 $SG76936        db 'sni',0              ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+511o
.rdata:00000068 $SG76935        db 'snl',0              ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+4EEo
.rdata:00000068                                         ; .rdata:$SG76910o
.rdata:0000006C $SG76934        db 'snh',0              ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+4C8o
.rdata:0000006C                                         ; .rdata:$SG76907o ...
.rdata:00000070 $SG76933        db 'spf',0              ; DATA XREF: .rdata:$SG76942o
.rdata:00000070                                         ; `dynamic initializer for 'kSwitchForms''(void)+4A1o ...
.rdata:00000074 $SG76932        db 'spe',0              ; DATA XREF: .rdata:$SG76905o
.rdata:00000074                                         ; `dynamic initializer for 'kSwitchForms''(void)+47Eo ...
.rdata:00000078 $SG76931        db 'spd',0              ; DATA XREF: .rdata:$SG76911o
.rdata:00000078                                         ; `dynamic initializer for 'kSwitchForms''(void)+466o ...
.rdata:0000007C $SG76930        dd offset loc_6171+2    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+43Bo
.rdata:00000080 $SG76929        db  73h ; s             ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+418o
.rdata:00000081                 db  73h ; s
.rdata:00000082                 db  63h ; c
.rdata:00000083                 db    0
.rdata:00000084 $SG76928        db  73h ; s             ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+400o
.rdata:00000085                 db  73h ; s
.rdata:00000086                 db  77h ; w
.rdata:00000087                 db    0
.rdata:00000088 $SG76927        db  73h ; s             ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+3E8o
.rdata:00000089                 db  6Ch ; l
.rdata:0000008A                 db  74h ; t
.rdata:0000008B                 db    0
.rdata:0000008C $SG76926        db  73h ; s             ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+3C5o
.rdata:0000008D                 db  63h ; c
.rdata:0000008E                 db  63h ; c
.rdata:0000008F                 db    0
.rdata:00000090 $SG76925        db  73h ; s             ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+39Fo
.rdata:00000091                 db  63h ; c
.rdata:00000092                 db  73h ; s
.rdata:00000093                 db    0
.rdata:00000094 $SG76924        db  73h ; s             ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+379o
.rdata:00000095                 db  6Ch ; l
.rdata:00000096                 db  70h ; p
.rdata:00000097                 db    0
.rdata:00000098 $SG76923        dd offset loc_6F72+1    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+363o
.rdata:0000009C $SG76922        dd offset loc_6970+3    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+33Do
.rdata:000000A0 $SG76921        db 'scrc',0             ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+316o
.rdata:000000A5                 align 4
.rdata:000000A8 $SG76920        db 'seml',0             ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+2F0o
.rdata:000000AD                 align 10h
.rdata:000000B0 $SG76919        db 'sfx',0              ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+2CAo
.rdata:000000B4 $SG76918        db 'stm',0              ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+2A4o
.rdata:000000B8 $SG76917        dd offset $SG76933+2    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+27Bo
.rdata:000000B8                                         ; "f"
.rdata:000000BC $SG76916        dd offset $SG76932+2    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+254o
.rdata:000000BC                                         ; "e"
.rdata:000000C0 $SG76915        dd offset $SG76932+1    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+22Do
.rdata:000000C0                                         ; "pe"
.rdata:000000C4 $SG76914        dd offset loc_6E61      ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+217o
.rdata:000000C8 $SG76913        dd offset loc_785F+2    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+1F0o
.rdata:000000CC $SG76912        dd offset loc_695F+2    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+1C9o
.rdata:000000D0 $SG76911        dd offset $SG76931      ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+1A3o
.rdata:000000D0                                         ; "spd"
.rdata:000000D4 $SG76910        dd offset $SG76935+1    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+17Co
.rdata:000000D4                                         ; "nl"
.rdata:000000D8 $SG76909        dd offset $SG76932+3    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+156o
.rdata:000000D8                                         ; ""
.rdata:000000DC $SG76908        dd offset $SG76934+3    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+130o
.rdata:000000DC                                         ; ""
.rdata:000000E0 $SG76907        dd offset $SG76934+1    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+109o
.rdata:000000E0                                         ; "nh"
.rdata:000000E4 $SG76906        db  73h ; s             ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+E2o
.rdata:000000E5                 db  74h ; t
.rdata:000000E6                 db  78h ; x
.rdata:000000E7                 db    0
.rdata:000000E8 $SG76905        dd offset $SG76932      ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+BCo
.rdata:000000E8                                         ; "spe"
.rdata:000000EC $SG76904        dd offset loc_6F61      ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+91o
.rdata:000000F0 $SG76903        dd offset loc_6461      ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+79o
.rdata:000000F4 $SG76902        dd offset $SG76931+1    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+63o
.rdata:000000F4                                         ; "pd"
.rdata:000000F8 $SG76901        db  62h ; b             ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+38o
.rdata:000000F9                 db  73h ; s
.rdata:000000FA                 db  70h ; p
.rdata:000000FB                 db    0
.rdata:000000FC $SG76900        db  62h ; b             ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+Do
.rdata:000000FD                 db  73h ; s
.rdata:000000FE                 db  65h ; e
.rdata:000000FF                 db    0
.rdata:00000100 $SG76969        dd offset unk_2A        ; DATA XREF: .data:_kUniversalWildcardo
.rdata:00000104 $SG76973        db 'Cannot find listfile',0
.rdata:00000104                                         ; DATA XREF: .data:_kCannotFindListFileo
.rdata:00000119                 align 4
.rdata:0000011C $SG76977        db 'I won',27h,'t write compressed data to a terminal',0
.rdata:0000011C                                         ; DATA XREF: .data:_kTerminalOutErroro
.rdata:00000148 $SG76975        db 'Incorrect item in listfile.',0Ah
.rdata:00000148                                         ; DATA XREF: .data:_kIncorrectListFileo
.rdata:00000148                 db 'Check charset encoding and -scs switch.',0
.rdata:0000018C $SG76979        db 'I won',27h,'t write data and program',27h,'s messages to same terminal',0
.rdata:0000018C                                         ; DATA XREF: .data:_kSameTerminalErroro
.rdata:000001C7                 align 4
.rdata:000001C8 $SG76981        db 'Empty file path',0  ; DATA XREF: .data:_kEmptyFilePatho
.rdata:000001D8 $SG76983        db 'Cannot find archive',0
.rdata:000001D8                                         ; DATA XREF: .data:_kCannotFindArchiveo
.rdata:000001EC $SG77019        db 'audtexlbih',0       ; DATA XREF: .data:_g_Commandso
.rdata:000001F7                 align 4
.rdata:000001F8 ; char _SG77063[]
.rdata:000001F8 $SG77063        dd offset loc_722B+2    ; DATA XREF: AddRenamePair(CObjectVector<CRenamePair> *,UString const &,UString const &,NRecursedType::EEnum,bool)+D0o
.rdata:000001FC ; char _SG77066[4]
.rdata:000001FC $SG77066        db '-r0',0              ; DATA XREF: AddRenamePair(CObjectVector<CRenamePair> *,UString const &,UString const &,NRecursedType::EEnum,bool)+E5o
.rdata:00000200 $SG77075        db 'Unsupported rename command:',0
.rdata:00000200                                         ; DATA XREF: AddRenamePair(CObjectVector<CRenamePair> *,UString const &,UString const &,NRecursedType::EEnum,bool)+FBo
.rdata:0000021C $SG77143        db 'There is no second file name for rename pair:',0
.rdata:0000021C                                         ; DATA XREF: AddToCensorFromNonSwitchesStrings(CObjectVector<CRenamePair> *,uint,NWildcard::CCensor &,CObjectVector<UString> const &,NRecursedType::EEnum,bool,bool,int)+19Do
.rdata:0000024A                 align 4
.rdata:0000024C $SG77170        db 'Incorrect Map command',0
.rdata:0000024C                                         ; DATA XREF: .data:char const * const k_IncorrectMapCommando
.rdata:00000262                 align 4
.rdata:00000264 $SG77195        db 'Unsupported Map data size',0
.rdata:00000264                                         ; DATA XREF: ParseMapWithPaths(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool):loc_3161o
.rdata:0000027E                 align 10h
.rdata:00000280 $SG77201        db 'Can not open mapping',0
.rdata:00000280                                         ; DATA XREF: ParseMapWithPaths(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)+1D7o
.rdata:00000295                 align 4
.rdata:00000298 $SG77205        db 'MapViewOfFile error',0
.rdata:00000298                                         ; DATA XREF: ParseMapWithPaths(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)+22Eo
.rdata:000002AC $SG77212        db 'Unsupported Map data',0
.rdata:000002AC                                         ; DATA XREF: ParseMapWithPaths(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)+296o
.rdata:000002C1                 align 4
.rdata:000002C4 $SG77224        db 'Map data error',0   ; DATA XREF: ParseMapWithPaths(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)+37Do
.rdata:000002D3                 align 4
.rdata:000002D4 $SG77247        db 'Too short switch',0 ; DATA XREF: AddSwitchWildcardsToCensor(NWildcard::CCensor &,CObjectVector<UString> const &,bool,NRecursedType::EEnum,bool,int)+82o
.rdata:000002E5                 align 4
.rdata:000002E8 $SG77256        db 'Too short switch',0 ; DATA XREF: AddSwitchWildcardsToCensor(NWildcard::CCensor &,CObjectVector<UString> const &,bool,NRecursedType::EEnum,bool,int)+120o
.rdata:000002F9                 align 4
.rdata:000002FC $SG77265        db 'Incorrect wildcard type marker',0
.rdata:000002FC                                         ; DATA XREF: AddSwitchWildcardsToCensor(NWildcard::CCensor &,CObjectVector<UString> const &,bool,NRecursedType::EEnum,bool,int):loc_2F7Ao
.rdata:0000031B                 align 4
.rdata:0000031C $SG77331:                               ; DATA XREF: .data:_kUpdatePairStateIDSeto
.rdata:0000031C                 unicode 0, <pqrxyzw>,0
.rdata:0000032C _kUpdatePairStateNotSupportedActions dd 2
.rdata:0000032C                                         ; DATA XREF: ParseUpdateCommandString2(UString const &,NUpdateArchive::CActionSet &,UString &)+DAr
.rdata:00000330                 db    2
.rdata:00000331                 db    0
.rdata:00000332                 db    0
.rdata:00000333                 db    0
.rdata:00000334                 db    1
.rdata:00000335                 db    0
.rdata:00000336                 db    0
.rdata:00000337                 db    0
.rdata:00000338                 db 0FFh
.rdata:00000339                 db 0FFh
.rdata:0000033A                 db 0FFh
.rdata:0000033B                 db 0FFh
.rdata:0000033C                 db 0FFh
.rdata:0000033D                 db 0FFh
.rdata:0000033E                 db 0FFh
.rdata:0000033F                 db 0FFh
.rdata:00000340                 db 0FFh
.rdata:00000341                 db 0FFh
.rdata:00000342                 db 0FFh
.rdata:00000343                 db 0FFh
.rdata:00000344                 db 0FFh
.rdata:00000345                 db 0FFh
.rdata:00000346                 db 0FFh
.rdata:00000347                 db 0FFh
.rdata:00000348 $SG77335        dd offset aHelp         ; DATA XREF: .data:_kUpdateIgnoreItselfPostStringIDo
.rdata:00000348                                         ; "help"
.rdata:0000034C $SG77364        db 'incorrect update switch command',0
.rdata:0000034C                                         ; DATA XREF: ParseUpdateCommandString(CUpdateOptions &,CObjectVector<UString> const &,NUpdateArchive::CActionSet const &)+3Fo
.rdata:0000036C $SG77420        db 'Incorrect volume size:',0
.rdata:0000036C                                         ; DATA XREF: SetAddCommandOptions(NCommandType::EEnum,NCommandLineParser::CParser const &,CUpdateOptions &)+258o
.rdata:00000383                 align 4
.rdata:00000384 $SG77465        db 'Unsupported switch postfix -bb',0
.rdata:00000384                                         ; DATA XREF: CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+2FEo
.rdata:000003A3                 align 4
.rdata:000003A4 $SG77480        db 'Unsupported switch postfix -stm',0
.rdata:000003A4                                         ; DATA XREF: CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+44Bo
.rdata:000003C4 $SG77492        db 'utf-8',0            ; DATA XREF: .rdata:_g_CodePagePairso
.rdata:000003CA                 align 4
.rdata:000003CC $SG77493        db 'win',0              ; DATA XREF: .rdata:000003F4o
.rdata:000003D0 $SG77494        db 'dos',0              ; DATA XREF: .rdata:000003FCo
.rdata:000003D4 $SG77495        db 'utf-16le',0         ; DATA XREF: .rdata:00000404o
.rdata:000003DD                 align 10h
.rdata:000003E0 $SG77496        db 'utf-16be',0         ; DATA XREF: .rdata:0000040Co
.rdata:000003E9                 align 4
.rdata:000003EC _g_CodePagePairs dd offset $SG77492     ; DATA XREF: FindCharset(NCommandLineParser::CParser const &,uint,bool,int)+10Fo
.rdata:000003EC                                         ; "utf-8"
.rdata:000003F0                 db 0E9h ; T
.rdata:000003F1                 db 0FDh ; Â²
.rdata:000003F2                 db    0
.rdata:000003F3                 db    0
.rdata:000003F4                 dd offset $SG77493      ; "win"
.rdata:000003F8                 db    0
.rdata:000003F9                 db    0
.rdata:000003FA                 db    0
.rdata:000003FB                 db    0
.rdata:000003FC                 dd offset $SG77494      ; "dos"
.rdata:00000400                 db    1
.rdata:00000401                 db    0
.rdata:00000402                 db    0
.rdata:00000403                 db    0
.rdata:00000404                 dd offset $SG77495      ; "utf-16le"
.rdata:00000408                 dd offset $SG77627      ; "Archive name cannot by empty"
.rdata:0000040C                 dd offset $SG77496      ; "utf-16be"
.rdata:00000410                 dd offset $SG77627+1    ; "rchive name cannot by empty"
.rdata:00000414 $SG77519        db 'Unsupported charset:',0
.rdata:00000414                                         ; DATA XREF: FindCharset(NCommandLineParser::CParser const &,uint,bool,int)+F1o
.rdata:00000429                 align 4
.rdata:0000042C $SG77562        db 'Duplicate archive path:',0
.rdata:0000042C                                         ; DATA XREF: EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *)+374o
.rdata:00000444 $SG77584        db 'The command must be spcified',0
.rdata:00000444                                         ; DATA XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+3Do
.rdata:00000461                 align 4
.rdata:00000464 $SG77588        db 'Unsupported command:',0
.rdata:00000464                                         ; DATA XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+88o
.rdata:00000479                 align 4
.rdata:0000047C ; wchar_t _SG77597
.rdata:0000047C $SG77597        dd offset unk_32        ; DATA XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+153o
.rdata:00000480 $SG77601        db 'Unsupported -spf:',0
.rdata:00000480                                         ; DATA XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+17Ao
.rdata:00000492                 align 4
.rdata:00000494 $SG77623        db 'Cannot find archive name',0
.rdata:00000494                                         ; DATA XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+384o
.rdata:000004AD                 align 10h
.rdata:000004B0 $SG77627        db 'Archive name cannot by empty',0
.rdata:000004B0                                         ; DATA XREF: .rdata:00000408o
.rdata:000004B0                                         ; CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+3E0o ...
.rdata:000004CD                 align 10h
.rdata:000004D0 $SG77640        db 'Cannot use absolute pathnames for this command',0
.rdata:000004D0                                         ; DATA XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+65Eo
.rdata:000004FF                 align 10h
.rdata:00000500 $SG77663        db '-ai switch is not supported for this command',0
.rdata:00000500                                         ; DATA XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+8B3o
.rdata:0000052D                 align 10h
.rdata:00000530 $SG77672        db 'stdout mode and email mode cannot be combined',0
.rdata:00000530                                         ; DATA XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+A6Ao
.rdata:0000055E                 align 10h
.rdata:00000560 $SG77681        db 'Only one archive can be created with rename command',0
.rdata:00000560                                         ; DATA XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+B14o
.rdata:00000594 $SG77688        db 'Incorrect Number of benmchmark iterations',0
.rdata:00000594                                         ; DATA XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+B99o
.rdata:000005BE                 align 10h
.rdata:000005BE _rdata          ends
.rdata:000005BE
.data:000005C0 ; ===========================================================================
.data:000005C0
.data:000005C0 ; Segment type: Pure data
.data:000005C0 ; Segment permissions: Read/Write
.data:000005C0 ; Segment alignment 'qword' can not be represented in assembly
.data:000005C0 _data           segment para public 'DATA' use32
.data:000005C0                 assume cs:_data
.data:000005C0                 ;org 5C0h
.data:000005C0                 public ?g_CodePage@@3HA
.data:000005C0 ; int g_CodePage
.data:000005C0 ?g_CodePage@@3HA dd 0FFFFFFFFh          ; DATA XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+1EDw
.data:000005C4 ; char *kRecursedPostCharSet
.data:000005C4 _kRecursedPostCharSet dd offset $SG76863
.data:000005C4                                         ; DATA XREF: AddSwitchWildcardsToCensor(NWildcard::CCensor &,CObjectVector<UString> const &,bool,NRecursedType::EEnum,bool,int)+DCr
.data:000005C4                                         ; `dynamic initializer for 'kSwitchForms''(void)+29Ar
.data:000005C8 _k_ArcNameMode_PostCharSet dd offset $SG76865
.data:000005C8                                         ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+45Ar
.data:000005CC _k_Stream_PostCharSet dd offset $SG76867
.data:000005CC                                         ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+3r
.data:000005CC                                         ; `dynamic initializer for 'kSwitchForms''(void)+2Cr ...
.data:000005D0 _kOverwritePostCharSet dd offset $SG76887
.data:000005D0                                         ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+B0r
.data:000005D0                                         ; "asut"
.data:000005D4 _kUniversalWildcard dd offset $SG76969  ; DATA XREF: AddToCensorFromNonSwitchesStrings(CObjectVector<CRenamePair> *,uint,NWildcard::CCensor &,CObjectVector<UString> const &,NRecursedType::EEnum,bool,bool,int)+50r
.data:000005D8 _kCannotFindListFile dd offset $SG76973 ; DATA XREF: AddToCensorFromListFile(CObjectVector<CRenamePair> *,NWildcard::CCensor &,wchar_t const *,bool,NRecursedType::EEnum,bool,int)+58r
.data:000005D8                                         ; "Cannot find listfile"
.data:000005DC _kIncorrectListFile dd offset $SG76975  ; DATA XREF: AddToCensorFromListFile(CObjectVector<CRenamePair> *,NWildcard::CCensor &,wchar_t const *,bool,NRecursedType::EEnum,bool,int)+90r
.data:000005DC                                         ; AddToCensorFromListFile(CObjectVector<CRenamePair> *,NWildcard::CCensor &,wchar_t const *,bool,NRecursedType::EEnum,bool,int)+C8r
.data:000005DC                                         ; "Incorrect item in listfile.\nCheck char"...
.data:000005E0 _kTerminalOutError dd offset $SG76977   ; DATA XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+AA6r
.data:000005E0                                         ; "I won't write compressed data to a term"...
.data:000005E4 _kSameTerminalError dd offset $SG76979  ; DATA XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+788r
.data:000005E4                                         ; "I won't write data and program's messag"...
.data:000005E8 _kEmptyFilePath dd offset $SG76981      ; DATA XREF: AddToCensorFromNonSwitchesStrings(CObjectVector<CRenamePair> *,uint,NWildcard::CCensor &,CObjectVector<UString> const &,NRecursedType::EEnum,bool,bool,int)+D3r
.data:000005E8                                         ; "Empty file path"
.data:000005EC _kCannotFindArchive dd offset $SG76983  ; DATA XREF: EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *)+19Fr
.data:000005EC                                         ; "Cannot find archive"
.data:000005F0 ; char *g_Commands
.data:000005F0 _g_Commands     dd offset $SG77019      ; DATA XREF: ParseArchiveCommand(UString const &,CArcCommand &)+A5r
.data:000005F0                                         ; "audtexlbih"
.data:000005F4                 public ?k_IncorrectMapCommand@@3PBDB
.data:000005F4 ; char const * const k_IncorrectMapCommand
.data:000005F4 ?k_IncorrectMapCommand@@3PBDB dd offset $SG77170
.data:000005F4                                         ; DATA XREF: ParseMapWithPaths(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)+61r
.data:000005F4                                         ; ParseMapWithPaths(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)+A1r
.data:000005F4                                         ; "Incorrect Map command"
.data:000005F8 ; wchar_t *kUpdatePairStateIDSet
.data:000005F8 _kUpdatePairStateIDSet dd offset $SG77331
.data:000005F8                                         ; DATA XREF: ParseUpdateCommandString2(UString const &,NUpdateArchive::CActionSet &,UString &)+4Dr
.data:000005F8                                         ; "pqrxyzw"
.data:000005FC ; char *kUpdateIgnoreItselfPostStringID
.data:000005FC _kUpdateIgnoreItselfPostStringID dd offset $SG77335
.data:000005FC                                         ; DATA XREF: ParseUpdateCommandString(CUpdateOptions &,CObjectVector<UString> const &,NUpdateArchive::CActionSet const &)+78r
.data:00000600 _kSwitchForms   dd offset $SG76890      ; DATA XREF: CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+3Fo
.data:00000604                 db    0
.data:00000605                 db    0
.data:00000606                 db    0
.data:00000607                 db    0
.data:00000608                 db    0
.data:00000609                 db    0
.data:0000060A                 db    0
.data:0000060B                 db    0
.data:0000060C                 dd offset $SG76891
.data:00000610                 db    0
.data:00000611                 db    0
.data:00000612                 db    0
.data:00000613                 db    0
.data:00000614                 db    0
.data:00000615                 db    0
.data:00000616                 db    0
.data:00000617                 db    0
.data:00000618                 dd offset $SG76892
.data:0000061C                 db    0
.data:0000061D                 db    0
.data:0000061E                 db    0
.data:0000061F                 db    0
.data:00000620                 db    0
.data:00000621                 db    0
.data:00000622                 db    0
.data:00000623                 db    0
.data:00000624                 dd offset $SG76893
.data:00000628                 align 10h
.data:00000630                 dd offset $SG76894
.data:00000634                 db    0
.data:00000635                 db    0
.data:00000636                 db    0
.data:00000637                 db    0
.data:00000638                 db    0
.data:00000639                 db    0
.data:0000063A                 db    0
.data:0000063B                 db    0
.data:0000063C                 dd offset $SG76895
.data:00000640                 db    0
.data:00000641                 db    0
.data:00000642                 db    0
.data:00000643                 db    0
.data:00000644                 db    0
.data:00000645                 db    0
.data:00000646                 db    0
.data:00000647                 db    0
.data:00000648                 dd offset $SG76896
.data:0000064C                 db    2
.data:0000064D                 db    0
.data:0000064E                 db    0
.data:0000064F                 db    0
.data:00000650                 db    0
.data:00000651                 db    0
.data:00000652                 db    0
.data:00000653                 db    0
.data:00000654                 dd offset $SG76897
.data:00000658                 db    3
.data:00000659                 db    0
.data:0000065A                 db    1
.data:0000065B                 db    0
.data:0000065C dword_65C       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+8w
.data:00000660 dword_660       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+Dw
.data:00000664 byte_664        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+17w
.data:00000665 byte_665        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+1Ew
.data:00000666 byte_666        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+25w
.data:00000667                 align 4
.data:00000668 dword_668       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+32w
.data:0000066C dword_66C       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+38w
.data:00000670 byte_670        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+42w
.data:00000671 byte_671        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+49w
.data:00000672 byte_672        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+50w
.data:00000673                 align 4
.data:00000674 dword_674       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+5Dw
.data:00000678 dword_678       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+63w
.data:0000067C dword_67C       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+6Fw
.data:00000680 dword_680       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+74w
.data:00000684 dword_684       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+79w
.data:00000688 dword_688       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+85w
.data:0000068C dword_68C       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+8Bw
.data:00000690 dword_690       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+91w
.data:00000694 byte_694        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+9Bw
.data:00000695 byte_695        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+A2w
.data:00000696 byte_696        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+A9w
.data:00000697                 align 4
.data:00000698 dword_698       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+B6w
.data:0000069C dword_69C       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+BCw
.data:000006A0 byte_6A0        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+C6w
.data:000006A1 byte_6A1        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+CDw
.data:000006A2 byte_6A2        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+D4w
.data:000006A3                 align 4
.data:000006A4 dword_6A4       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+DDw
.data:000006A8 dword_6A8       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+E2w
.data:000006AC byte_6AC        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+ECw
.data:000006AD byte_6AD        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+F3w
.data:000006AE byte_6AE        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+FAw
.data:000006AF                 align 10h
.data:000006B0 dword_6B0       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+103w
.data:000006B4 dword_6B4       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+109w
.data:000006B8 byte_6B8        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+113w
.data:000006B9 byte_6B9        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+11Aw
.data:000006BA byte_6BA        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+121w
.data:000006BB                 align 4
.data:000006BC dword_6BC       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+12Aw
.data:000006C0 dword_6C0       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+130w
.data:000006C4 byte_6C4        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+13Aw
.data:000006C5 byte_6C5        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+141w
.data:000006C6 byte_6C6        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+148w
.data:000006C7                 align 4
.data:000006C8 dword_6C8       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+151w
.data:000006CC dword_6CC       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+156w
.data:000006D0 byte_6D0        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+160w
.data:000006D1 dword_6D1       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+169w
.data:000006D5 word_6D5        dw 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+16Fw
.data:000006D7 byte_6D7        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+176w
.data:000006D8 dword_6D8       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+17Cw
.data:000006DC byte_6DC        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+186w
.data:000006DD byte_6DD        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+18Dw
.data:000006DE byte_6DE        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+194w
.data:000006DF                 align 10h
.data:000006E0 dword_6E0       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+19Dw
.data:000006E4 dword_6E4       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+1A3w
.data:000006E8 byte_6E8        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+1ADw
.data:000006E9 byte_6E9        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+1B4w
.data:000006EA byte_6EA        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+1BBw
.data:000006EB                 align 4
.data:000006EC dword_6EC       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+1C4w
.data:000006F0 dword_6F0       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+1C9w
.data:000006F4 byte_6F4        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+1D3w
.data:000006F5 byte_6F5        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+1DAw
.data:000006F6 byte_6F6        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+1E1w
.data:000006F7                 align 4
.data:000006F8 dword_6F8       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+1EAw
.data:000006FC dword_6FC       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+1F0w
.data:00000700 byte_700        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+1FAw
.data:00000701 byte_701        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+201w
.data:00000702 byte_702        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+208w
.data:00000703                 align 4
.data:00000704 dword_704       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+211w
.data:00000708 dword_708       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+217w
.data:0000070C dword_70C       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+223w
.data:00000710 dword_710       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+228w
.data:00000714 dword_714       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+22Dw
.data:00000718 byte_718        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+237w
.data:00000719 byte_719        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+23Ew
.data:0000071A byte_71A        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+245w
.data:0000071B                 align 4
.data:0000071C dword_71C       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+24Ew
.data:00000720 dword_720       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+254w
.data:00000724 byte_724        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+25Ew
.data:00000725 byte_725        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+265w
.data:00000726 byte_726        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+26Cw
.data:00000727                 align 4
.data:00000728 dword_728       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+275w
.data:0000072C dword_72C       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+27Bw
.data:00000730 byte_730        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+285w
.data:00000731 byte_731        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+28Cw
.data:00000732 byte_732        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+293w
.data:00000733                 align 4
.data:00000734 dword_734       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+29Fw
.data:00000738 dword_738       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+2A4w
.data:0000073C byte_73C        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+2AEw
.data:0000073D dword_73D       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+2B7w
.data:00000741 word_741        dw 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+2BDw
.data:00000743 byte_743        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+2C4w
.data:00000744 dword_744       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+2CAw
.data:00000748 byte_748        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+2D4w
.data:00000749 dword_749       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+2DDw
.data:0000074D word_74D        dw 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+2E3w
.data:0000074F byte_74F        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+2EAw
.data:00000750 dword_750       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+2F0w
.data:00000754 byte_754        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+2FAw
.data:00000755 byte_755        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+301w
.data:00000756 byte_756        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+308w
.data:00000757                 align 4
.data:00000758 dword_758       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+311w
.data:0000075C dword_75C       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+316w
.data:00000760 byte_760        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+320w
.data:00000761 byte_761        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+327w
.data:00000762 byte_762        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+32Ew
.data:00000763                 align 4
.data:00000764 dword_764       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+337w
.data:00000768 dword_768       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+33Dw
.data:0000076C byte_76C        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+347w
.data:0000076D dword_76D       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+350w
.data:00000771 word_771        dw 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+356w
.data:00000773 byte_773        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+35Dw
.data:00000774 dword_774       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+363w
.data:00000778 dword_778       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+36Fw
.data:0000077C dword_77C       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+374w
.data:00000780 dword_780       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+379w
.data:00000784 byte_784        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+383w
.data:00000785 dword_785       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+38Cw
.data:00000789 word_789        dw 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+392w
.data:0000078B byte_78B        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+399w
.data:0000078C dword_78C       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+39Fw
.data:00000790 byte_790        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+3A9w
.data:00000791 dword_791       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+3B2w
.data:00000795 word_795        dw 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+3B8w
.data:00000797 byte_797        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+3BFw
.data:00000798 dword_798       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+3C5w
.data:0000079C byte_79C        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+3CFw
.data:0000079D dword_79D       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+3D8w
.data:000007A1 word_7A1        dw 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+3DDw
.data:000007A3 byte_7A3        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+3E3w
.data:000007A4 dword_7A4       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+3E8w
.data:000007A8 dword_7A8       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+3F4w
.data:000007AC dword_7AC       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+3FAw
.data:000007B0 dword_7B0       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+400w
.data:000007B4 dword_7B4       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+40Cw
.data:000007B8 dword_7B8       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+412w
.data:000007BC dword_7BC       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+418w
.data:000007C0 byte_7C0        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+422w
.data:000007C1 dword_7C1       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+42Bw
.data:000007C5 word_7C5        dw 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+430w
.data:000007C7 byte_7C7        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+436w
.data:000007C8 dword_7C8       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+43Bw
.data:000007CC byte_7CC        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+445w
.data:000007CD byte_7CD        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+44Cw
.data:000007CE byte_7CE        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+453w
.data:000007CF                 align 10h
.data:000007D0 dword_7D0       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+460w
.data:000007D4 dword_7D4       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+466w
.data:000007D8 dword_7D8       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+472w
.data:000007DC dword_7DC       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+478w
.data:000007E0 dword_7E0       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+47Ew
.data:000007E4 byte_7E4        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+488w
.data:000007E5 dword_7E5       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+491w
.data:000007E9 word_7E9        dw 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+496w
.data:000007EB byte_7EB        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+49Cw
.data:000007EC dword_7EC       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+4A1w
.data:000007F0 byte_7F0        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+4ABw
.data:000007F1 byte_7F1        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+4B2w
.data:000007F2 byte_7F2        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+4B9w
.data:000007F3                 align 4
.data:000007F4 dword_7F4       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+4C2w
.data:000007F8 dword_7F8       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+4C8w
.data:000007FC byte_7FC        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+4D2w
.data:000007FD dword_7FD       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+4DBw
.data:00000801 word_801        dw 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+4E1w
.data:00000803 byte_803        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+4E8w
.data:00000804 dword_804       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+4EEw
.data:00000808 byte_808        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+4F8w
.data:00000809 dword_809       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+501w
.data:0000080D word_80D        dw 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+506w
.data:0000080F byte_80F        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+50Cw
.data:00000810 dword_810       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+511w
.data:00000814 dword_814       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+51Dw
.data:00000818 dword_818       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+523w
.data:0000081C dword_81C       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+529w
.data:00000820 byte_820        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+533w
.data:00000821 dword_821       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+53Cw
.data:00000825 word_825        dw 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+542w
.data:00000827 byte_827        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+549w
.data:00000828 dword_828       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+54Fw
.data:0000082C dword_82C       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+55Bw
.data:00000830 dword_830       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+560w
.data:00000834 dword_834       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+565w
.data:00000838 dword_838       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+571w
.data:0000083C dword_83C       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+577w
.data:00000840 dword_840       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+57Dw
.data:00000844 dword_844       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+589w
.data:00000848 dword_848       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+58Fw
.data:0000084C dword_84C       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+595w
.data:00000850 dword_850       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+5A1w
.data:00000854 dword_854       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+5A6w
.data:00000858 dword_858       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+5ABw
.data:0000085C byte_85C        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+5B5w
.data:0000085D dword_85D       dd 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+5BEw
.data:00000861 word_861        dw 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+5C4w
.data:00000863 byte_863        db 0                    ; DATA XREF: `dynamic initializer for 'kSwitchForms''(void)+5CBw
.data:00000863 _data           ends
.data:00000863
.text:00000864 ; ===========================================================================
.text:00000864
.text:00000864 ; Segment type: Pure code
.text:00000864 ; Segment permissions: Read/Execute
.text:00000864 _text           segment para public 'CODE' use32
.text:00000864                 assume cs:_text
.text:00000864                 ;org 864h
.text:00000864                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000864
.text:00000864 ; =============== S U B R O U T I N E =======================================
.text:00000864
.text:00000864 ; Attributes: bp-based frame
.text:00000864
.text:00000864 ; public: __thiscall CArcCmdLineException::CArcCmdLineException(char const *, wchar_t const *)
.text:00000864                 public ??0CArcCmdLineException@@QAE@PBDPB_W@Z
.text:00000864 ??0CArcCmdLineException@@QAE@PBDPB_W@Z proc near
.text:00000864                                         ; CODE XREF: CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+6Ep
.text:00000864                                         ; CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+306p ...
.text:00000864
.text:00000864 var_30          = dword ptr -30h
.text:00000864 var_2C          = dword ptr -2Ch
.text:00000864 var_28          = dword ptr -28h
.text:00000864 var_24          = dword ptr -24h
.text:00000864 var_20          = dword ptr -20h
.text:00000864 var_1C          = dword ptr -1Ch
.text:00000864 var_18          = dword ptr -18h
.text:00000864 var_14          = dword ptr -14h
.text:00000864 var_10          = dword ptr -10h
.text:00000864 var_C           = dword ptr -0Ch
.text:00000864 var_4           = dword ptr -4
.text:00000864 arg_0           = dword ptr  8
.text:00000864 arg_4           = dword ptr  0Ch
.text:00000864
.text:00000864                 push    ebp
.text:00000865                 mov     ebp, esp
.text:00000867                 push    0FFFFFFFFh
.text:00000869                 push    offset __ehhandler$??0CArcCmdLineException@@QAE@PBDPB_W@Z
.text:0000086E                 mov     eax, large fs:0
.text:00000874                 push    eax
.text:00000875                 sub     esp, 24h
.text:00000878                 mov     eax, 0CCCCCCCCh
.text:0000087D                 mov     [ebp+var_30], eax
.text:00000880                 mov     [ebp+var_2C], eax
.text:00000883                 mov     [ebp+var_28], eax
.text:00000886                 mov     [ebp+var_24], eax
.text:00000889                 mov     [ebp+var_20], eax
.text:0000088C                 mov     [ebp+var_1C], eax
.text:0000088F                 mov     [ebp+var_18], eax
.text:00000892                 mov     [ebp+var_14], eax
.text:00000895                 mov     [ebp+var_10], eax
.text:00000898                 mov     eax, dword ptr ds:___security_cookie
.text:0000089D                 xor     eax, ebp
.text:0000089F                 push    eax
.text:000008A0                 lea     eax, [ebp+var_C]
.text:000008A3                 mov     large fs:0, eax
.text:000008A9                 mov     [ebp+var_10], ecx
.text:000008AC                 mov     ecx, [ebp+var_10]
.text:000008AF                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:000008B4                 mov     [ebp+var_4], 0
.text:000008BB                 mov     eax, [ebp+arg_0]
.text:000008BE                 push    eax
.text:000008BF                 lea     ecx, [ebp+var_1C]
.text:000008C2                 call    ??0AString@@QAE@PBD@Z ; AString::AString(char const *)
.text:000008C7                 mov     byte ptr [ebp+var_4], 1
.text:000008CB                 push    0
.text:000008CD                 lea     ecx, [ebp+var_1C]
.text:000008D0                 push    ecx
.text:000008D1                 lea     edx, [ebp+var_28]
.text:000008D4                 push    edx
.text:000008D5                 call    ?MultiByteToUnicodeString@@YG?AVUString@@ABVAString@@I@Z ; MultiByteToUnicodeString(AString const &,uint)
.text:000008DA                 mov     [ebp+var_2C], eax
.text:000008DD                 mov     eax, [ebp+var_2C]
.text:000008E0                 mov     [ebp+var_30], eax
.text:000008E3                 mov     byte ptr [ebp+var_4], 2
.text:000008E7                 mov     ecx, [ebp+var_30]
.text:000008EA                 push    ecx
.text:000008EB                 mov     ecx, [ebp+var_10]
.text:000008EE                 call    ??YUString@@QAEAAV0@ABV0@@Z ; UString::operator+=(UString const &)
.text:000008F3                 mov     byte ptr [ebp+var_4], 1
.text:000008F7                 lea     ecx, [ebp+var_28] ; this
.text:000008FA                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000008FF                 mov     byte ptr [ebp+var_4], 0
.text:00000903                 lea     ecx, [ebp+var_1C] ; this
.text:00000906                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:0000090B                 cmp     [ebp+arg_4], 0
.text:0000090F                 jz      short loc_925
.text:00000911                 mov     ecx, [ebp+var_10] ; this
.text:00000914                 call    ?Add_LF@UString@@QAEXXZ ; UString::Add_LF(void)
.text:00000919                 mov     edx, [ebp+arg_4]
.text:0000091C                 push    edx
.text:0000091D                 mov     ecx, [ebp+var_10]
.text:00000920                 call    ??YUString@@QAEAAV0@PB_W@Z ; UString::operator+=(wchar_t const *)
.text:00000925
.text:00000925 loc_925:                                ; CODE XREF: CArcCmdLineException::CArcCmdLineException(char const *,wchar_t const *)+ABj
.text:00000925                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000092C                 mov     eax, [ebp+var_10]
.text:0000092F                 mov     ecx, [ebp+var_C]
.text:00000932                 mov     large fs:0, ecx
.text:00000939                 pop     ecx
.text:0000093A                 add     esp, 30h
.text:0000093D                 cmp     ebp, esp
.text:0000093F                 call    __RTC_CheckEsp
.text:00000944                 mov     esp, ebp
.text:00000946                 pop     ebp
.text:00000947                 retn    8
.text:00000947 ??0CArcCmdLineException@@QAE@PBDPB_W@Z endp
.text:00000947
.text:00000947 ; ---------------------------------------------------------------------------
.text:0000094A                 db 0Ah dup(0CCh)
.text:00000954
.text:00000954 ; =============== S U B R O U T I N E =======================================
.text:00000954
.text:00000954 ; Attributes: bp-based frame
.text:00000954
.text:00000954 ; bool __thiscall CArcCommand::IsFromExtractGroup(CArcCommand *__hidden this)
.text:00000954                 public ?IsFromExtractGroup@CArcCommand@@QBE_NXZ
.text:00000954 ?IsFromExtractGroup@CArcCommand@@QBE_NXZ proc near
.text:00000954                                         ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+2DBp
.text:00000954
.text:00000954 var_8           = dword ptr -8
.text:00000954 var_4           = dword ptr -4
.text:00000954
.text:00000954                 push    ebp
.text:00000955                 mov     ebp, esp
.text:00000957                 sub     esp, 8
.text:0000095A                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00000961                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000968                 mov     [ebp+var_4], ecx
.text:0000096B                 mov     eax, [ebp+var_4]
.text:0000096E                 mov     ecx, [eax]
.text:00000970                 mov     [ebp+var_8], ecx
.text:00000973                 cmp     [ebp+var_8], 3
.text:00000977                 jl      short loc_985
.text:00000979                 cmp     [ebp+var_8], 5
.text:0000097D                 jle     short loc_981
.text:0000097F                 jmp     short loc_985
.text:00000981 ; ---------------------------------------------------------------------------
.text:00000981
.text:00000981 loc_981:                                ; CODE XREF: CArcCommand::IsFromExtractGroup(void)+29j
.text:00000981                 mov     al, 1
.text:00000983                 jmp     short loc_987
.text:00000985 ; ---------------------------------------------------------------------------
.text:00000985
.text:00000985 loc_985:                                ; CODE XREF: CArcCommand::IsFromExtractGroup(void)+23j
.text:00000985                                         ; CArcCommand::IsFromExtractGroup(void)+2Bj
.text:00000985                 xor     al, al
.text:00000987
.text:00000987 loc_987:                                ; CODE XREF: CArcCommand::IsFromExtractGroup(void)+2Fj
.text:00000987                 mov     esp, ebp
.text:00000989                 pop     ebp
.text:0000098A                 retn
.text:0000098A ?IsFromExtractGroup@CArcCommand@@QBE_NXZ endp
.text:0000098A
.text:0000098A ; ---------------------------------------------------------------------------
.text:0000098B                 db 9 dup(0CCh)
.text:00000994
.text:00000994 ; =============== S U B R O U T I N E =======================================
.text:00000994
.text:00000994 ; Attributes: bp-based frame
.text:00000994
.text:00000994 ; public: enum  NExtract::NPathMode::EEnum __thiscall CArcCommand::GetPathMode(void)const
.text:00000994                 public ?GetPathMode@CArcCommand@@QBE?AW4EEnum@NPathMode@NExtract@@XZ
.text:00000994 ?GetPathMode@CArcCommand@@QBE?AW4EEnum@NPathMode@NExtract@@XZ proc near
.text:00000994                                         ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+84Ap
.text:00000994
.text:00000994 var_8           = dword ptr -8
.text:00000994 var_4           = dword ptr -4
.text:00000994
.text:00000994                 push    ebp
.text:00000995                 mov     ebp, esp
.text:00000997                 sub     esp, 8
.text:0000099A                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000009A1                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000009A8                 mov     [ebp+var_4], ecx
.text:000009AB                 mov     eax, [ebp+var_4]
.text:000009AE                 mov     ecx, [eax]
.text:000009B0                 mov     [ebp+var_8], ecx
.text:000009B3                 cmp     [ebp+var_8], 3
.text:000009B7                 jz      short loc_9C1
.text:000009B9                 cmp     [ebp+var_8], 5
.text:000009BD                 jz      short loc_9C1
.text:000009BF                 jmp     short loc_9C5
.text:000009C1 ; ---------------------------------------------------------------------------
.text:000009C1
.text:000009C1 loc_9C1:                                ; CODE XREF: CArcCommand::GetPathMode(void)+23j
.text:000009C1                                         ; CArcCommand::GetPathMode(void)+29j
.text:000009C1                 xor     eax, eax
.text:000009C3                 jmp     short loc_9CA
.text:000009C5 ; ---------------------------------------------------------------------------
.text:000009C5
.text:000009C5 loc_9C5:                                ; CODE XREF: CArcCommand::GetPathMode(void)+2Bj
.text:000009C5                 mov     eax, 2
.text:000009CA
.text:000009CA loc_9CA:                                ; CODE XREF: CArcCommand::GetPathMode(void)+2Fj
.text:000009CA                 mov     esp, ebp
.text:000009CC                 pop     ebp
.text:000009CD                 retn
.text:000009CD ?GetPathMode@CArcCommand@@QBE?AW4EEnum@NPathMode@NExtract@@XZ endp
.text:000009CD
.text:000009CD ; ---------------------------------------------------------------------------
.text:000009CE                 db 6 dup(0CCh)
.text:000009D4
.text:000009D4 ; =============== S U B R O U T I N E =======================================
.text:000009D4
.text:000009D4 ; Attributes: bp-based frame
.text:000009D4
.text:000009D4 ; bool __thiscall CArcCommand::IsFromUpdateGroup(CArcCommand *__hidden this)
.text:000009D4                 public ?IsFromUpdateGroup@CArcCommand@@QBE_NXZ
.text:000009D4 ?IsFromUpdateGroup@CArcCommand@@QBE_NXZ proc near
.text:000009D4                                         ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+890p
.text:000009D4
.text:000009D4 var_8           = dword ptr -8
.text:000009D4 var_4           = dword ptr -4
.text:000009D4
.text:000009D4                 push    ebp
.text:000009D5                 mov     ebp, esp
.text:000009D7                 sub     esp, 8
.text:000009DA                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000009E1                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000009E8                 mov     [ebp+var_4], ecx
.text:000009EB                 mov     eax, [ebp+var_4]
.text:000009EE                 mov     ecx, [eax]
.text:000009F0                 mov     [ebp+var_8], ecx
.text:000009F3                 cmp     [ebp+var_8], 0
.text:000009F7                 jl      short loc_A0B
.text:000009F9                 cmp     [ebp+var_8], 2
.text:000009FD                 jle     short loc_A07
.text:000009FF                 cmp     [ebp+var_8], 0Ah
.text:00000A03                 jz      short loc_A07
.text:00000A05                 jmp     short loc_A0B
.text:00000A07 ; ---------------------------------------------------------------------------
.text:00000A07
.text:00000A07 loc_A07:                                ; CODE XREF: CArcCommand::IsFromUpdateGroup(void)+29j
.text:00000A07                                         ; CArcCommand::IsFromUpdateGroup(void)+2Fj
.text:00000A07                 mov     al, 1
.text:00000A09                 jmp     short loc_A0D
.text:00000A0B ; ---------------------------------------------------------------------------
.text:00000A0B
.text:00000A0B loc_A0B:                                ; CODE XREF: CArcCommand::IsFromUpdateGroup(void)+23j
.text:00000A0B                                         ; CArcCommand::IsFromUpdateGroup(void)+31j
.text:00000A0B                 xor     al, al
.text:00000A0D
.text:00000A0D loc_A0D:                                ; CODE XREF: CArcCommand::IsFromUpdateGroup(void)+35j
.text:00000A0D                 mov     esp, ebp
.text:00000A0F                 pop     ebp
.text:00000A10                 retn
.text:00000A10 ?IsFromUpdateGroup@CArcCommand@@QBE_NXZ endp
.text:00000A10
.text:00000A10 ; ---------------------------------------------------------------------------
.text:00000A11                 align 4
.text:00000A14
.text:00000A14 ; =============== S U B R O U T I N E =======================================
.text:00000A14
.text:00000A14 ; Attributes: bp-based frame
.text:00000A14
.text:00000A14 ; void __stdcall ConvertToLongNames(struct NWildcard::CCensor *)
.text:00000A14                 public ?ConvertToLongNames@@YGXAAVCCensor@NWildcard@@@Z
.text:00000A14 ?ConvertToLongNames@@YGXAAVCCensor@NWildcard@@@Z proc near
.text:00000A14                                         ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+721p
.text:00000A14
.text:00000A14 var_8           = dword ptr -8
.text:00000A14 var_4           = dword ptr -4
.text:00000A14 arg_0           = dword ptr  8
.text:00000A14
.text:00000A14                 push    ebp
.text:00000A15                 mov     ebp, esp
.text:00000A17                 sub     esp, 8
.text:00000A1A                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00000A21                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000A28                 mov     [ebp+var_4], 0
.text:00000A2F                 jmp     short loc_A3A
.text:00000A31 ; ---------------------------------------------------------------------------
.text:00000A31
.text:00000A31 loc_A31:                                ; CODE XREF: ConvertToLongNames(NWildcard::CCensor &)+52j
.text:00000A31                 mov     eax, [ebp+var_4]
.text:00000A34                 add     eax, 1
.text:00000A37                 mov     [ebp+var_4], eax
.text:00000A3A
.text:00000A3A loc_A3A:                                ; CODE XREF: ConvertToLongNames(NWildcard::CCensor &)+1Bj
.text:00000A3A                 mov     ecx, [ebp+arg_0]
.text:00000A3D                 call    ?Size@?$CObjectVector@UCPair@NWildcard@@@@QBEIXZ ; CObjectVector<NWildcard::CPair>::Size(void)
.text:00000A42                 cmp     [ebp+var_4], eax
.text:00000A45                 jnb     short loc_A68
.text:00000A47                 mov     ecx, [ebp+var_4]
.text:00000A4A                 push    ecx
.text:00000A4B                 mov     ecx, [ebp+arg_0]
.text:00000A4E                 call    ??A?$CObjectVector@UCPair@NWildcard@@@@QAEAAUCPair@NWildcard@@I@Z ; CObjectVector<NWildcard::CPair>::operator[](uint)
.text:00000A53                 mov     [ebp+var_8], eax
.text:00000A56                 mov     edx, [ebp+var_8]
.text:00000A59                 add     edx, 0Ch
.text:00000A5C                 push    edx             ; int
.text:00000A5D                 mov     eax, [ebp+var_8]
.text:00000A60                 push    eax             ; UString *
.text:00000A61                 call    ?ConvertToLongNames@@YGXABVUString@@AAVCCensorNode@NWildcard@@@Z ; ConvertToLongNames(UString const &,NWildcard::CCensorNode &)
.text:00000A66                 jmp     short loc_A31
.text:00000A68 ; ---------------------------------------------------------------------------
.text:00000A68
.text:00000A68 loc_A68:                                ; CODE XREF: ConvertToLongNames(NWildcard::CCensor &)+31j
.text:00000A68                 add     esp, 8
.text:00000A6B                 cmp     ebp, esp
.text:00000A6D                 call    __RTC_CheckEsp
.text:00000A72                 mov     esp, ebp
.text:00000A74                 pop     ebp
.text:00000A75                 retn    4
.text:00000A75 ?ConvertToLongNames@@YGXAAVCCensor@NWildcard@@@Z endp
.text:00000A75
.text:00000A75 ; ---------------------------------------------------------------------------
.text:00000A78                 db 0Ch dup(0CCh)
.text:00000A84
.text:00000A84 ; =============== S U B R O U T I N E =======================================
.text:00000A84
.text:00000A84 ; Attributes: bp-based frame
.text:00000A84
.text:00000A84 ; int __stdcall ConvertToLongNames(UString *, int)
.text:00000A84 ?ConvertToLongNames@@YGXABVUString@@AAVCCensorNode@NWildcard@@@Z proc near
.text:00000A84                                         ; CODE XREF: ConvertToLongNames(NWildcard::CCensor &)+4Dp
.text:00000A84                                         ; ConvertToLongNames(UString const &,NWildcard::CCensorNode &)+203p
.text:00000A84
.text:00000A84 var_4C          = dword ptr -4Ch
.text:00000A84 var_48          = dword ptr -48h
.text:00000A84 var_44          = dword ptr -44h
.text:00000A84 var_40          = dword ptr -40h
.text:00000A84 var_3C          = byte ptr -3Ch
.text:00000A84 var_30          = byte ptr -30h
.text:00000A84 var_24          = dword ptr -24h
.text:00000A84 var_20          = dword ptr -20h
.text:00000A84 var_1C          = dword ptr -1Ch
.text:00000A84 var_18          = dword ptr -18h
.text:00000A84 var_14          = dword ptr -14h
.text:00000A84 var_10          = dword ptr -10h
.text:00000A84 var_C           = dword ptr -0Ch
.text:00000A84 var_4           = dword ptr -4
.text:00000A84 arg_0           = dword ptr  8
.text:00000A84 arg_4           = dword ptr  0Ch
.text:00000A84
.text:00000A84                 push    ebp
.text:00000A85                 mov     ebp, esp
.text:00000A87                 push    0FFFFFFFFh
.text:00000A89                 push    offset __ehhandler$?ConvertToLongNames@@YGXABVUString@@AAVCCensorNode@NWildcard@@@Z
.text:00000A8E                 mov     eax, large fs:0
.text:00000A94                 push    eax
.text:00000A95                 sub     esp, 40h
.text:00000A98                 push    edi
.text:00000A99                 lea     edi, [ebp+var_4C]
.text:00000A9C                 mov     ecx, 10h
.text:00000AA1                 mov     eax, 0CCCCCCCCh
.text:00000AA6                 rep stosd
.text:00000AA8                 mov     eax, dword ptr ds:___security_cookie
.text:00000AAD                 xor     eax, ebp
.text:00000AAF                 push    eax             ; wchar_t *
.text:00000AB0                 lea     eax, [ebp+var_C]
.text:00000AB3                 mov     large fs:0, eax
.text:00000AB9                 mov     eax, [ebp+arg_4]
.text:00000ABC                 add     eax, 1Ch
.text:00000ABF                 push    eax             ; int
.text:00000AC0                 mov     ecx, [ebp+arg_0]
.text:00000AC3                 push    ecx             ; UString *
.text:00000AC4                 call    ?ConvertToLongNames@@YGXABVUString@@AAV?$CObjectVector@UCItem@NWildcard@@@@@Z ; ConvertToLongNames(UString const &,CObjectVector<NWildcard::CItem> &)
.text:00000AC9                 mov     edx, [ebp+arg_4]
.text:00000ACC                 add     edx, 28h ; '('
.text:00000ACF                 push    edx             ; int
.text:00000AD0                 mov     eax, [ebp+arg_0]
.text:00000AD3                 push    eax             ; UString *
.text:00000AD4                 call    ?ConvertToLongNames@@YGXABVUString@@AAV?$CObjectVector@UCItem@NWildcard@@@@@Z ; ConvertToLongNames(UString const &,CObjectVector<NWildcard::CItem> &)
.text:00000AD9                 mov     [ebp+var_10], 0
.text:00000AE0                 jmp     short loc_AEB
.text:00000AE2 ; ---------------------------------------------------------------------------
.text:00000AE2
.text:00000AE2 loc_AE2:                                ; CODE XREF: ConvertToLongNames(UString const &,NWildcard::CCensorNode &)+B0j
.text:00000AE2                                         ; ConvertToLongNames(UString const &,NWildcard::CCensorNode &)+BFj
.text:00000AE2                 mov     ecx, [ebp+var_10]
.text:00000AE5                 add     ecx, 1
.text:00000AE8                 mov     [ebp+var_10], ecx
.text:00000AEB
.text:00000AEB loc_AEB:                                ; CODE XREF: ConvertToLongNames(UString const &,NWildcard::CCensorNode &)+5Cj
.text:00000AEB                 mov     ecx, [ebp+arg_4]
.text:00000AEE                 add     ecx, 10h
.text:00000AF1                 call    ?Size@?$CObjectVector@VCCensorNode@NWildcard@@@@QBEIXZ ; CObjectVector<NWildcard::CCensorNode>::Size(void)
.text:00000AF6                 cmp     [ebp+var_10], eax
.text:00000AF9                 jnb     short loc_B45
.text:00000AFB                 mov     edx, [ebp+var_10]
.text:00000AFE                 push    edx
.text:00000AFF                 mov     ecx, [ebp+arg_4]
.text:00000B02                 add     ecx, 10h
.text:00000B05                 call    ??A?$CObjectVector@VCCensorNode@NWildcard@@@@QAEAAVCCensorNode@NWildcard@@I@Z ; CObjectVector<NWildcard::CCensorNode>::operator[](uint)
.text:00000B0A                 add     eax, 4
.text:00000B0D                 mov     [ebp+var_14], eax
.text:00000B10                 mov     ecx, [ebp+arg_0] ; this
.text:00000B13                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:00000B18                 movzx   eax, al
.text:00000B1B                 test    eax, eax
.text:00000B1D                 jz      short loc_B36
.text:00000B1F                 mov     ecx, [ebp+var_14]
.text:00000B22                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00000B27                 push    eax             ; this
.text:00000B28                 call    ?IsDriveColonName@NWildcard@@YG_NPB_W@Z ; NWildcard::IsDriveColonName(wchar_t const *)
.text:00000B2D                 movzx   ecx, al
.text:00000B30                 test    ecx, ecx
.text:00000B32                 jz      short loc_B36
.text:00000B34                 jmp     short loc_AE2
.text:00000B36 ; ---------------------------------------------------------------------------
.text:00000B36
.text:00000B36 loc_B36:                                ; CODE XREF: ConvertToLongNames(UString const &,NWildcard::CCensorNode &)+99j
.text:00000B36                                         ; ConvertToLongNames(UString const &,NWildcard::CCensorNode &)+AEj
.text:00000B36                 mov     edx, [ebp+var_14]
.text:00000B39                 push    edx             ; UString *
.text:00000B3A                 mov     eax, [ebp+arg_0]
.text:00000B3D                 push    eax             ; int
.text:00000B3E                 call    ?ConvertToLongName@@YGXABVUString@@AAV1@@Z ; ConvertToLongName(UString const &,UString &)
.text:00000B43                 jmp     short loc_AE2
.text:00000B45 ; ---------------------------------------------------------------------------
.text:00000B45
.text:00000B45 loc_B45:                                ; CODE XREF: ConvertToLongNames(UString const &,NWildcard::CCensorNode &)+75j
.text:00000B45                 mov     [ebp+var_10], 0
.text:00000B4C                 jmp     short loc_B57
.text:00000B4E ; ---------------------------------------------------------------------------
.text:00000B4E
.text:00000B4E loc_B4E:                                ; CODE XREF: ConvertToLongNames(UString const &,NWildcard::CCensorNode &):loc_C06j
.text:00000B4E                 mov     ecx, [ebp+var_10]
.text:00000B51                 add     ecx, 1
.text:00000B54                 mov     [ebp+var_10], ecx
.text:00000B57
.text:00000B57 loc_B57:                                ; CODE XREF: ConvertToLongNames(UString const &,NWildcard::CCensorNode &)+C8j
.text:00000B57                 mov     ecx, [ebp+arg_4]
.text:00000B5A                 add     ecx, 10h
.text:00000B5D                 call    ?Size@?$CObjectVector@VCCensorNode@NWildcard@@@@QBEIXZ ; CObjectVector<NWildcard::CCensorNode>::Size(void)
.text:00000B62                 cmp     [ebp+var_10], eax
.text:00000B65                 jnb     loc_C0B
.text:00000B6B                 mov     edx, [ebp+var_10]
.text:00000B6E                 push    edx
.text:00000B6F                 mov     ecx, [ebp+arg_4]
.text:00000B72                 add     ecx, 10h
.text:00000B75                 call    ??A?$CObjectVector@VCCensorNode@NWildcard@@@@QAEAAVCCensorNode@NWildcard@@I@Z ; CObjectVector<NWildcard::CCensorNode>::operator[](uint)
.text:00000B7A                 mov     [ebp+var_18], eax
.text:00000B7D                 mov     eax, [ebp+var_10]
.text:00000B80                 add     eax, 1
.text:00000B83                 mov     [ebp+var_1C], eax
.text:00000B86
.text:00000B86 loc_B86:                                ; CODE XREF: ConvertToLongNames(UString const &,NWildcard::CCensorNode &):loc_C04j
.text:00000B86                 mov     ecx, [ebp+arg_4]
.text:00000B89                 add     ecx, 10h
.text:00000B8C                 call    ?Size@?$CObjectVector@VCCensorNode@NWildcard@@@@QBEIXZ ; CObjectVector<NWildcard::CCensorNode>::Size(void)
.text:00000B91                 cmp     [ebp+var_1C], eax
.text:00000B94                 jnb     short loc_C06
.text:00000B96                 mov     ecx, [ebp+var_1C]
.text:00000B99                 push    ecx
.text:00000B9A                 mov     ecx, [ebp+arg_4]
.text:00000B9D                 add     ecx, 10h
.text:00000BA0                 call    ??A?$CObjectVector@VCCensorNode@NWildcard@@@@QAEAAVCCensorNode@NWildcard@@I@Z ; CObjectVector<NWildcard::CCensorNode>::operator[](uint)
.text:00000BA5                 mov     [ebp+var_20], eax
.text:00000BA8                 mov     ecx, [ebp+var_20]
.text:00000BAB                 add     ecx, 4
.text:00000BAE                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00000BB3                 push    eax             ; wchar_t *
.text:00000BB4                 mov     ecx, [ebp+var_18]
.text:00000BB7                 add     ecx, 4          ; this
.text:00000BBA                 call    ?IsEqualTo_NoCase@UString@@QBE_NPB_W@Z ; UString::IsEqualTo_NoCase(wchar_t const *)
.text:00000BBF                 movzx   edx, al
.text:00000BC2                 test    edx, edx
.text:00000BC4                 jz      short loc_BFB
.text:00000BC6                 mov     eax, [ebp+var_20]
.text:00000BC9                 add     eax, 1Ch
.text:00000BCC                 push    eax
.text:00000BCD                 mov     ecx, [ebp+var_18]
.text:00000BD0                 add     ecx, 1Ch
.text:00000BD3                 call    ??Y?$CObjectVector@UCItem@NWildcard@@@@QAEAAV0@ABV0@@Z ; CObjectVector<NWildcard::CItem>::operator+=(CObjectVector<NWildcard::CItem> const &)
.text:00000BD8                 mov     ecx, [ebp+var_20]
.text:00000BDB                 add     ecx, 28h ; '('
.text:00000BDE                 push    ecx
.text:00000BDF                 mov     ecx, [ebp+var_18]
.text:00000BE2                 add     ecx, 28h ; '('
.text:00000BE5                 call    ??Y?$CObjectVector@UCItem@NWildcard@@@@QAEAAV0@ABV0@@Z ; CObjectVector<NWildcard::CItem>::operator+=(CObjectVector<NWildcard::CItem> const &)
.text:00000BEA                 mov     edx, [ebp+var_1C]
.text:00000BED                 push    edx
.text:00000BEE                 mov     ecx, [ebp+arg_4]
.text:00000BF1                 add     ecx, 10h
.text:00000BF4                 call    ?Delete@?$CObjectVector@VCCensorNode@NWildcard@@@@QAEXI@Z ; CObjectVector<NWildcard::CCensorNode>::Delete(uint)
.text:00000BF9                 jmp     short loc_C04
.text:00000BFB ; ---------------------------------------------------------------------------
.text:00000BFB
.text:00000BFB loc_BFB:                                ; CODE XREF: ConvertToLongNames(UString const &,NWildcard::CCensorNode &)+140j
.text:00000BFB                 mov     eax, [ebp+var_1C]
.text:00000BFE                 add     eax, 1
.text:00000C01                 mov     [ebp+var_1C], eax
.text:00000C04
.text:00000C04 loc_C04:                                ; CODE XREF: ConvertToLongNames(UString const &,NWildcard::CCensorNode &)+175j
.text:00000C04                 jmp     short loc_B86
.text:00000C06 ; ---------------------------------------------------------------------------
.text:00000C06
.text:00000C06 loc_C06:                                ; CODE XREF: ConvertToLongNames(UString const &,NWildcard::CCensorNode &)+110j
.text:00000C06                 jmp     loc_B4E
.text:00000C0B ; ---------------------------------------------------------------------------
.text:00000C0B
.text:00000C0B loc_C0B:                                ; CODE XREF: ConvertToLongNames(UString const &,NWildcard::CCensorNode &)+E1j
.text:00000C0B                 mov     [ebp+var_10], 0
.text:00000C12                 jmp     short loc_C1D
.text:00000C14 ; ---------------------------------------------------------------------------
.text:00000C14
.text:00000C14 loc_C14:                                ; CODE XREF: ConvertToLongNames(UString const &,NWildcard::CCensorNode &)+223j
.text:00000C14                 mov     ecx, [ebp+var_10]
.text:00000C17                 add     ecx, 1
.text:00000C1A                 mov     [ebp+var_10], ecx
.text:00000C1D
.text:00000C1D loc_C1D:                                ; CODE XREF: ConvertToLongNames(UString const &,NWildcard::CCensorNode &)+18Ej
.text:00000C1D                 mov     ecx, [ebp+arg_4]
.text:00000C20                 add     ecx, 10h
.text:00000C23                 call    ?Size@?$CObjectVector@VCCensorNode@NWildcard@@@@QBEIXZ ; CObjectVector<NWildcard::CCensorNode>::Size(void)
.text:00000C28                 cmp     [ebp+var_10], eax
.text:00000C2B                 jnb     short loc_CAC
.text:00000C2D                 mov     edx, [ebp+var_10]
.text:00000C30                 push    edx
.text:00000C31                 mov     ecx, [ebp+arg_4]
.text:00000C34                 add     ecx, 10h
.text:00000C37                 call    ??A?$CObjectVector@VCCensorNode@NWildcard@@@@QAEAAVCCensorNode@NWildcard@@I@Z ; CObjectVector<NWildcard::CCensorNode>::operator[](uint)
.text:00000C3C                 mov     [ebp+var_24], eax
.text:00000C3F                 mov     eax, [ebp+var_24]
.text:00000C42                 push    eax             ; int
.text:00000C43                 push    5Ch ; '\'
.text:00000C45                 mov     ecx, [ebp+var_24]
.text:00000C48                 add     ecx, 4
.text:00000C4B                 push    ecx
.text:00000C4C                 mov     edx, [ebp+arg_0]
.text:00000C4F                 push    edx
.text:00000C50                 lea     eax, [ebp+var_30]
.text:00000C53                 push    eax
.text:00000C54                 call    ??H@YG?AVUString@@ABV0@0@Z ; operator+(UString const &,UString const &)
.text:00000C59                 mov     [ebp+var_40], eax
.text:00000C5C                 mov     ecx, [ebp+var_40]
.text:00000C5F                 mov     [ebp+var_44], ecx
.text:00000C62                 mov     [ebp+var_4], 0
.text:00000C69                 mov     edx, [ebp+var_44]
.text:00000C6C                 push    edx
.text:00000C6D                 lea     eax, [ebp+var_3C]
.text:00000C70                 push    eax
.text:00000C71                 call    ??H@YG?AVUString@@ABV0@_W@Z ; operator+(UString const &,wchar_t)
.text:00000C76                 mov     [ebp+var_48], eax
.text:00000C79                 mov     ecx, [ebp+var_48]
.text:00000C7C                 mov     [ebp+var_4C], ecx
.text:00000C7F                 mov     byte ptr [ebp+var_4], 1
.text:00000C83                 mov     edx, [ebp+var_4C]
.text:00000C86                 push    edx             ; UString *
.text:00000C87                 call    ?ConvertToLongNames@@YGXABVUString@@AAVCCensorNode@NWildcard@@@Z ; ConvertToLongNames(UString const &,NWildcard::CCensorNode &)
.text:00000C8C                 mov     byte ptr [ebp+var_4], 0
.text:00000C90                 lea     ecx, [ebp+var_3C] ; this
.text:00000C93                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000C98                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000C9F                 lea     ecx, [ebp+var_30] ; this
.text:00000CA2                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000CA7                 jmp     loc_C14
.text:00000CAC ; ---------------------------------------------------------------------------
.text:00000CAC
.text:00000CAC loc_CAC:                                ; CODE XREF: ConvertToLongNames(UString const &,NWildcard::CCensorNode &)+1A7j
.text:00000CAC                 mov     ecx, [ebp+var_C]
.text:00000CAF                 mov     large fs:0, ecx
.text:00000CB6                 pop     ecx
.text:00000CB7                 pop     edi
.text:00000CB8                 add     esp, 4Ch
.text:00000CBB                 cmp     ebp, esp
.text:00000CBD                 call    __RTC_CheckEsp
.text:00000CC2                 mov     esp, ebp
.text:00000CC4                 pop     ebp
.text:00000CC5                 retn    8
.text:00000CC5 ?ConvertToLongNames@@YGXABVUString@@AAVCCensorNode@NWildcard@@@Z endp ; sp-analysis failed
.text:00000CC5
.text:00000CC5 ; ---------------------------------------------------------------------------
.text:00000CC8                 db 0Ch dup(0CCh)
.text:00000CD4
.text:00000CD4 ; =============== S U B R O U T I N E =======================================
.text:00000CD4
.text:00000CD4 ; Attributes: bp-based frame
.text:00000CD4
.text:00000CD4 ; int __stdcall ConvertToLongName(int, UString *)
.text:00000CD4 ?ConvertToLongName@@YGXABVUString@@AAV1@@Z proc near
.text:00000CD4                                         ; CODE XREF: ConvertToLongNames(UString const &,NWildcard::CCensorNode &)+BAp
.text:00000CD4                                         ; ConvertToLongNames(UString const &,CObjectVector<NWildcard::CItem> &)+89p
.text:00000CD4
.text:00000CD4 var_60          = byte ptr -60h
.text:00000CD4 var_5C          = byte ptr -5Ch
.text:00000CD4 var_48          = byte ptr -48h
.text:00000CD4 var_20          = byte ptr -20h
.text:00000CD4 var_C           = dword ptr -0Ch
.text:00000CD4 var_4           = dword ptr -4
.text:00000CD4 arg_0           = dword ptr  8
.text:00000CD4 arg_4           = dword ptr  0Ch
.text:00000CD4
.text:00000CD4                 push    ebp
.text:00000CD5                 mov     ebp, esp
.text:00000CD7                 push    0FFFFFFFFh
.text:00000CD9                 push    offset __ehhandler$?ConvertToLongName@@YGXABVUString@@AAV1@@Z
.text:00000CDE                 mov     eax, large fs:0
.text:00000CE4                 push    eax
.text:00000CE5                 sub     esp, 54h
.text:00000CE8                 push    edi             ; wchar_t *
.text:00000CE9                 lea     edi, [ebp+var_60]
.text:00000CEC                 mov     ecx, 15h
.text:00000CF1                 mov     eax, 0CCCCCCCCh
.text:00000CF6                 rep stosd
.text:00000CF8                 mov     eax, dword ptr ds:___security_cookie
.text:00000CFD                 xor     eax, ebp
.text:00000CFF                 push    eax             ; wchar_t *
.text:00000D00                 lea     eax, [ebp+var_C]
.text:00000D03                 mov     large fs:0, eax
.text:00000D09                 mov     ecx, [ebp+arg_4] ; this
.text:00000D0C                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:00000D11                 movzx   eax, al
.text:00000D14                 test    eax, eax
.text:00000D16                 jnz     short loc_D28
.text:00000D18                 mov     ecx, [ebp+arg_4]
.text:00000D1B                 push    ecx             ; struct UString *
.text:00000D1C                 call    ?DoesNameContainWildcard@@YG_NABVUString@@@Z ; DoesNameContainWildcard(UString const &)
.text:00000D21                 movzx   edx, al
.text:00000D24                 test    edx, edx
.text:00000D26                 jz      short loc_D2D
.text:00000D28
.text:00000D28 loc_D28:                                ; CODE XREF: ConvertToLongName(UString const &,UString &)+42j
.text:00000D28                 jmp     loc_DC2
.text:00000D2D ; ---------------------------------------------------------------------------
.text:00000D2D
.text:00000D2D loc_D2D:                                ; CODE XREF: ConvertToLongName(UString const &,UString &)+52j
.text:00000D2D                 lea     ecx, [ebp+var_48] ; this
.text:00000D30                 call    ??0CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::CFileInfo(void)
.text:00000D35                 mov     [ebp+var_4], 0
.text:00000D3C                 mov     eax, [ebp+arg_4]
.text:00000D3F                 push    eax
.text:00000D40                 mov     ecx, [ebp+arg_0]
.text:00000D43                 push    ecx
.text:00000D44                 lea     edx, [ebp+var_5C]
.text:00000D47                 push    edx
.text:00000D48                 call    ??H@YG?AVUString@@ABV0@0@Z ; operator+(UString const &,UString const &)
.text:00000D4D                 mov     byte ptr [ebp+var_4], 1
.text:00000D51                 lea     ecx, [ebp+var_5C]
.text:00000D54                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00000D59                 push    eax             ; this
.text:00000D5A                 call    ?IsDevicePath@NName@NFile@NWindows@@YG_NPB_W@Z ; NWindows::NFile::NName::IsDevicePath(wchar_t const *)
.text:00000D5F                 movzx   eax, al
.text:00000D62                 test    eax, eax
.text:00000D64                 jz      short loc_D83
.text:00000D66                 mov     byte ptr [ebp+var_4], 0
.text:00000D6A                 lea     ecx, [ebp+var_5C] ; this
.text:00000D6D                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000D72                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000D79                 lea     ecx, [ebp+var_48] ; this
.text:00000D7C                 call    ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text:00000D81                 jmp     short loc_DC2
.text:00000D83 ; ---------------------------------------------------------------------------
.text:00000D83
.text:00000D83 loc_D83:                                ; CODE XREF: ConvertToLongName(UString const &,UString &)+90j
.text:00000D83                 lea     ecx, [ebp+var_5C]
.text:00000D86                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00000D8B                 push    eax             ; wchar_t *
.text:00000D8C                 lea     ecx, [ebp+var_48] ; this
.text:00000D8F                 call    ?Find@CFileInfo@NFind@NFile@NWindows@@QAE_NPB_W@Z ; NWindows::NFile::NFind::CFileInfo::Find(wchar_t const *)
.text:00000D94                 movzx   ecx, al
.text:00000D97                 test    ecx, ecx
.text:00000D99                 jz      short loc_DA7
.text:00000D9B                 lea     edx, [ebp+var_20]
.text:00000D9E                 push    edx
.text:00000D9F                 mov     ecx, [ebp+arg_4]
.text:00000DA2                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:00000DA7
.text:00000DA7 loc_DA7:                                ; CODE XREF: ConvertToLongName(UString const &,UString &)+C5j
.text:00000DA7                 mov     byte ptr [ebp+var_4], 0
.text:00000DAB                 lea     ecx, [ebp+var_5C] ; this
.text:00000DAE                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000DB3                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000DBA                 lea     ecx, [ebp+var_48] ; this
.text:00000DBD                 call    ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text:00000DC2
.text:00000DC2 loc_DC2:                                ; CODE XREF: ConvertToLongName(UString const &,UString &):loc_D28j
.text:00000DC2                                         ; ConvertToLongName(UString const &,UString &)+ADj
.text:00000DC2                 push    edx
.text:00000DC3                 mov     ecx, ebp
.text:00000DC5                 push    eax
.text:00000DC6                 lea     edx, $LN13
.text:00000DCC                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00000DD1                 pop     eax
.text:00000DD2                 pop     edx
.text:00000DD3                 mov     ecx, [ebp+var_C]
.text:00000DD6                 mov     large fs:0, ecx
.text:00000DDD                 pop     ecx
.text:00000DDE                 pop     edi
.text:00000DDF                 add     esp, 60h
.text:00000DE2                 cmp     ebp, esp
.text:00000DE4                 call    __RTC_CheckEsp
.text:00000DE9                 mov     esp, ebp
.text:00000DEB                 pop     ebp
.text:00000DEC                 retn    8
.text:00000DEC ?ConvertToLongName@@YGXABVUString@@AAV1@@Z endp
.text:00000DEC
.text:00000DEC ; ---------------------------------------------------------------------------
.text:00000DEF                 align 10h
.text:00000DF0 $LN13           dd 2                    ; DATA XREF: ConvertToLongName(UString const &,UString &)+F2o
.text:00000DF4                 dd offset $LN12
.text:00000DF8 $LN12           dd 0FFFFFFB8h, 38h      ; DATA XREF: .text:00000DF4o
.text:00000E00                 dd offset $LN9          ; "fi"
.text:00000E04                 dd 0FFFFFFA4h, 0Ch
.text:00000E0C                 dd offset $LN10         ; "path"
.text:00000E10 $LN10           db 'path',0             ; DATA XREF: .text:00000E0Co
.text:00000E15 $LN9            db 'fi',0               ; DATA XREF: .text:00000E00o
.text:00000E18                 db 0Ch dup(0CCh)
.text:00000E24
.text:00000E24 ; =============== S U B R O U T I N E =======================================
.text:00000E24
.text:00000E24 ; Attributes: bp-based frame
.text:00000E24
.text:00000E24 ; int __stdcall ConvertToLongNames(UString *, int)
.text:00000E24 ?ConvertToLongNames@@YGXABVUString@@AAV?$CObjectVector@UCItem@NWildcard@@@@@Z proc near
.text:00000E24                                         ; CODE XREF: ConvertToLongNames(UString const &,NWildcard::CCensorNode &)+40p
.text:00000E24                                         ; ConvertToLongNames(UString const &,NWildcard::CCensorNode &)+50p
.text:00000E24
.text:00000E24 var_8           = dword ptr -8
.text:00000E24 var_4           = dword ptr -4
.text:00000E24 arg_0           = dword ptr  8
.text:00000E24 arg_4           = dword ptr  0Ch
.text:00000E24
.text:00000E24                 push    ebp
.text:00000E25                 mov     ebp, esp
.text:00000E27                 sub     esp, 8
.text:00000E2A                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00000E31                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000E38                 mov     [ebp+var_4], 0
.text:00000E3F                 jmp     short loc_E4A
.text:00000E41 ; ---------------------------------------------------------------------------
.text:00000E41
.text:00000E41 loc_E41:                                ; CODE XREF: ConvertToLongNames(UString const &,CObjectVector<NWildcard::CItem> &):loc_E7Ej
.text:00000E41                                         ; ConvertToLongNames(UString const &,CObjectVector<NWildcard::CItem> &)+7Aj ...
.text:00000E41                 mov     eax, [ebp+var_4]
.text:00000E44                 add     eax, 1
.text:00000E47                 mov     [ebp+var_4], eax
.text:00000E4A
.text:00000E4A loc_E4A:                                ; CODE XREF: ConvertToLongNames(UString const &,CObjectVector<NWildcard::CItem> &)+1Bj
.text:00000E4A                 mov     ecx, [ebp+arg_4]
.text:00000E4D                 call    ?Size@?$CObjectVector@UCItem@NWildcard@@@@QBEIXZ ; CObjectVector<NWildcard::CItem>::Size(void)
.text:00000E52                 cmp     [ebp+var_4], eax
.text:00000E55                 jnb     short loc_EB4
.text:00000E57                 mov     ecx, [ebp+var_4]
.text:00000E5A                 push    ecx
.text:00000E5B                 mov     ecx, [ebp+arg_4]
.text:00000E5E                 call    ??A?$CObjectVector@UCItem@NWildcard@@@@QAEAAUCItem@NWildcard@@I@Z ; CObjectVector<NWildcard::CItem>::operator[](uint)
.text:00000E63                 mov     [ebp+var_8], eax
.text:00000E66                 mov     edx, [ebp+var_8]
.text:00000E69                 movzx   eax, byte ptr [edx+0Ch]
.text:00000E6D                 test    eax, eax
.text:00000E6F                 jnz     short loc_E7E
.text:00000E71                 mov     ecx, [ebp+var_8]
.text:00000E74                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:00000E79                 cmp     eax, 1
.text:00000E7C                 jz      short loc_E80
.text:00000E7E
.text:00000E7E loc_E7E:                                ; CODE XREF: ConvertToLongNames(UString const &,CObjectVector<NWildcard::CItem> &)+4Bj
.text:00000E7E                 jmp     short loc_E41
.text:00000E80 ; ---------------------------------------------------------------------------
.text:00000E80
.text:00000E80 loc_E80:                                ; CODE XREF: ConvertToLongNames(UString const &,CObjectVector<NWildcard::CItem> &)+58j
.text:00000E80                 mov     ecx, [ebp+arg_0] ; this
.text:00000E83                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:00000E88                 movzx   ecx, al
.text:00000E8B                 test    ecx, ecx
.text:00000E8D                 jz      short loc_EA0
.text:00000E8F                 mov     ecx, [ebp+var_8] ; this
.text:00000E92                 call    ?IsDriveItem@CItem@NWildcard@@QBE_NXZ ; NWildcard::CItem::IsDriveItem(void)
.text:00000E97                 movzx   edx, al
.text:00000E9A                 test    edx, edx
.text:00000E9C                 jz      short loc_EA0
.text:00000E9E                 jmp     short loc_E41
.text:00000EA0 ; ---------------------------------------------------------------------------
.text:00000EA0
.text:00000EA0 loc_EA0:                                ; CODE XREF: ConvertToLongNames(UString const &,CObjectVector<NWildcard::CItem> &)+69j
.text:00000EA0                                         ; ConvertToLongNames(UString const &,CObjectVector<NWildcard::CItem> &)+78j
.text:00000EA0                 mov     ecx, [ebp+var_8]
.text:00000EA3                 call    ?Front@?$CObjectVector@VUString@@@@QAEAAVUString@@XZ ; CObjectVector<UString>::Front(void)
.text:00000EA8                 push    eax             ; UString *
.text:00000EA9                 mov     eax, [ebp+arg_0]
.text:00000EAC                 push    eax             ; int
.text:00000EAD                 call    ?ConvertToLongName@@YGXABVUString@@AAV1@@Z ; ConvertToLongName(UString const &,UString &)
.text:00000EB2                 jmp     short loc_E41
.text:00000EB4 ; ---------------------------------------------------------------------------
.text:00000EB4
.text:00000EB4 loc_EB4:                                ; CODE XREF: ConvertToLongNames(UString const &,CObjectVector<NWildcard::CItem> &)+31j
.text:00000EB4                 add     esp, 8
.text:00000EB7                 cmp     ebp, esp
.text:00000EB9                 call    __RTC_CheckEsp
.text:00000EBE                 mov     esp, ebp
.text:00000EC0                 pop     ebp
.text:00000EC1                 retn    8
.text:00000EC1 ?ConvertToLongNames@@YGXABVUString@@AAV?$CObjectVector@UCItem@NWildcard@@@@@Z endp
.text:00000EC1
.text:00000EC4
.text:00000EC4 ; =============== S U B R O U T I N E =======================================
.text:00000EC4
.text:00000EC4 ; Attributes: bp-based frame
.text:00000EC4
.text:00000EC4 ; _DWORD __thiscall CArcCmdLineParser::CArcCmdLineParser(CArcCmdLineParser *__hidden this)
.text:00000EC4                 public ??0CArcCmdLineParser@@QAE@XZ
.text:00000EC4 ??0CArcCmdLineParser@@QAE@XZ proc near
.text:00000EC4
.text:00000EC4 var_4           = dword ptr -4
.text:00000EC4
.text:00000EC4                 push    ebp
.text:00000EC5                 mov     ebp, esp
.text:00000EC7                 push    ecx
.text:00000EC8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000ECF                 mov     [ebp+var_4], ecx
.text:00000ED2                 push    33h ; '3'       ; unsigned int
.text:00000ED4                 mov     ecx, [ebp+var_4] ; this
.text:00000ED7                 call    ??0CParser@NCommandLineParser@@QAE@I@Z ; NCommandLineParser::CParser::CParser(uint)
.text:00000EDC                 mov     eax, [ebp+var_4]
.text:00000EDF                 add     esp, 4
.text:00000EE2                 cmp     ebp, esp
.text:00000EE4                 call    __RTC_CheckEsp
.text:00000EE9                 mov     esp, ebp
.text:00000EEB                 pop     ebp
.text:00000EEC                 retn
.text:00000EEC ??0CArcCmdLineParser@@QAE@XZ endp
.text:00000EEC
.text:00000EEC ; ---------------------------------------------------------------------------
.text:00000EED                 db 7 dup(0CCh)
.text:00000EF4
.text:00000EF4 ; =============== S U B R O U T I N E =======================================
.text:00000EF4
.text:00000EF4 ; Attributes: bp-based frame
.text:00000EF4
.text:00000EF4 ; public: void __thiscall CArcCmdLineParser::Parse1(class CObjectVector<class UString> const &, struct CArcCmdLineOptions &)
.text:00000EF4                 public ?Parse1@CArcCmdLineParser@@QAEXABV?$CObjectVector@VUString@@@@AAUCArcCmdLineOptions@@@Z
.text:00000EF4 ?Parse1@CArcCmdLineParser@@QAEXABV?$CObjectVector@VUString@@@@AAUCArcCmdLineOptions@@@Z proc near
.text:00000EF4
.text:00000EF4 var_70          = dword ptr -70h
.text:00000EF4 var_6C          = byte ptr -6Ch
.text:00000EF4 var_60          = byte ptr -60h
.text:00000EF4 var_54          = byte ptr -54h
.text:00000EF4 var_44          = dword ptr -44h
.text:00000EF4 var_38          = byte ptr -38h
.text:00000EF4 dwProcessAffinityMask= dword ptr -28h
.text:00000EF4 var_24          = dword ptr -24h
.text:00000EF4 var_1C          = dword ptr -1Ch
.text:00000EF4 var_14          = dword ptr -14h
.text:00000EF4 var_10          = dword ptr -10h
.text:00000EF4 var_C           = dword ptr -0Ch
.text:00000EF4 var_4           = dword ptr -4
.text:00000EF4 arg_0           = dword ptr  8
.text:00000EF4 arg_4           = dword ptr  0Ch
.text:00000EF4
.text:00000EF4                 push    ebp
.text:00000EF5                 mov     ebp, esp
.text:00000EF7                 push    0FFFFFFFFh
.text:00000EF9                 push    offset __ehhandler$?Parse1@CArcCmdLineParser@@QAEXABV?$CObjectVector@VUString@@@@AAUCArcCmdLineOptions@@@Z
.text:00000EFE                 mov     eax, large fs:0
.text:00000F04                 push    eax
.text:00000F05                 sub     esp, 64h
.text:00000F08                 push    esi
.text:00000F09                 push    edi
.text:00000F0A                 push    ecx
.text:00000F0B                 lea     edi, [ebp+var_70]
.text:00000F0E                 mov     ecx, 19h
.text:00000F13                 mov     eax, 0CCCCCCCCh
.text:00000F18                 rep stosd
.text:00000F1A                 pop     ecx
.text:00000F1B                 mov     eax, dword ptr ds:___security_cookie
.text:00000F20                 xor     eax, ebp
.text:00000F22                 push    eax
.text:00000F23                 lea     eax, [ebp+var_C]
.text:00000F26                 mov     large fs:0, eax
.text:00000F2C                 mov     [ebp+var_10], ecx
.text:00000F2F                 mov     eax, [ebp+arg_0]
.text:00000F32                 push    eax
.text:00000F33                 push    offset _kSwitchForms
.text:00000F38                 mov     ecx, [ebp+var_10]
.text:00000F3B                 call    ?ParseStrings@CParser@NCommandLineParser@@QAE_NPBUCSwitchForm@2@ABV?$CObjectVector@VUString@@@@@Z ; NCommandLineParser::CParser::ParseStrings(NCommandLineParser::CSwitchForm const *,CObjectVector<UString> const &)
.text:00000F40                 movzx   ecx, al
.text:00000F43                 test    ecx, ecx
.text:00000F45                 jnz     short loc_F75
.text:00000F47                 mov     ecx, [ebp+var_10]
.text:00000F4A                 add     ecx, 20h ; ' '
.text:00000F4D                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00000F52                 push    eax
.text:00000F53                 mov     ecx, [ebp+var_10]
.text:00000F56                 add     ecx, 14h
.text:00000F59                 call    ??BAString@@QBEPBDXZ ; AString::operator char const *(void)
.text:00000F5E                 push    eax
.text:00000F5F                 lea     ecx, [ebp+var_54]
.text:00000F62                 call    ??0CArcCmdLineException@@QAE@PBDPB_W@Z ; CArcCmdLineException::CArcCmdLineException(char const *,wchar_t const *)
.text:00000F67                 push    offset __TI2?AUCArcCmdLineException@@
.text:00000F6C                 lea     edx, [ebp+var_54]
.text:00000F6F                 push    edx
.text:00000F70                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:00000F75 ; ---------------------------------------------------------------------------
.text:00000F75
.text:00000F75 loc_F75:                                ; CODE XREF: CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+51j
.text:00000F75                 mov     esi, esp
.text:00000F77                 call    dword ptr ds:__imp____iob_func
.text:00000F7D                 cmp     esi, esp
.text:00000F7F                 call    __RTC_CheckEsp
.text:00000F84                 mov     esi, esp
.text:00000F86                 push    eax             ; File
.text:00000F87                 call    dword ptr ds:__imp___fileno
.text:00000F8D                 add     esp, 4
.text:00000F90                 cmp     esi, esp
.text:00000F92                 call    __RTC_CheckEsp
.text:00000F97                 mov     esi, esp
.text:00000F99                 push    eax
.text:00000F9A                 call    dword ptr ds:__imp___isatty
.text:00000FA0                 add     esp, 4
.text:00000FA3                 cmp     esi, esp
.text:00000FA5                 call    __RTC_CheckEsp
.text:00000FAA                 neg     eax
.text:00000FAC                 sbb     eax, eax
.text:00000FAE                 neg     eax
.text:00000FB0                 mov     ecx, [ebp+arg_4]
.text:00000FB3                 mov     [ecx+4], al
.text:00000FB6                 mov     esi, esp
.text:00000FB8                 call    dword ptr ds:__imp____iob_func
.text:00000FBE                 cmp     esi, esp
.text:00000FC0                 call    __RTC_CheckEsp
.text:00000FC5                 add     eax, 20h ; ' '
.text:00000FC8                 mov     esi, esp
.text:00000FCA                 push    eax             ; File
.text:00000FCB                 call    dword ptr ds:__imp___fileno
.text:00000FD1                 add     esp, 4
.text:00000FD4                 cmp     esi, esp
.text:00000FD6                 call    __RTC_CheckEsp
.text:00000FDB                 mov     esi, esp
.text:00000FDD                 push    eax
.text:00000FDE                 call    dword ptr ds:__imp___isatty
.text:00000FE4                 add     esp, 4
.text:00000FE7                 cmp     esi, esp
.text:00000FE9                 call    __RTC_CheckEsp
.text:00000FEE                 neg     eax
.text:00000FF0                 sbb     eax, eax
.text:00000FF2                 neg     eax
.text:00000FF4                 mov     edx, [ebp+arg_4]
.text:00000FF7                 mov     [edx+5], al
.text:00000FFA                 mov     esi, esp
.text:00000FFC                 call    dword ptr ds:__imp____iob_func
.text:00001002                 cmp     esi, esp
.text:00001004                 call    __RTC_CheckEsp
.text:00001009                 add     eax, 40h ; '@'
.text:0000100C                 mov     esi, esp
.text:0000100E                 push    eax             ; File
.text:0000100F                 call    dword ptr ds:__imp___fileno
.text:00001015                 add     esp, 4
.text:00001018                 cmp     esi, esp
.text:0000101A                 call    __RTC_CheckEsp
.text:0000101F                 mov     esi, esp
.text:00001021                 push    eax
.text:00001022                 call    dword ptr ds:__imp___isatty
.text:00001028                 add     esp, 4
.text:0000102B                 cmp     esi, esp
.text:0000102D                 call    __RTC_CheckEsp
.text:00001032                 neg     eax
.text:00001034                 sbb     eax, eax
.text:00001036                 neg     eax
.text:00001038                 mov     ecx, [ebp+arg_4]
.text:0000103B                 mov     [ecx+6], al
.text:0000103E                 push    0
.text:00001040                 mov     ecx, [ebp+var_10]
.text:00001043                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00001048                 movzx   edx, byte ptr [eax]
.text:0000104B                 test    edx, edx
.text:0000104D                 jnz     short loc_107A
.text:0000104F                 push    1
.text:00001051                 mov     ecx, [ebp+var_10]
.text:00001054                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00001059                 movzx   eax, byte ptr [eax]
.text:0000105C                 test    eax, eax
.text:0000105E                 jnz     short loc_107A
.text:00001060                 push    2
.text:00001062                 mov     ecx, [ebp+var_10]
.text:00001065                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:0000106A                 movzx   ecx, byte ptr [eax]
.text:0000106D                 test    ecx, ecx
.text:0000106F                 jnz     short loc_107A
.text:00001071                 mov     [ebp+var_70], 0
.text:00001078                 jmp     short loc_1081
.text:0000107A ; ---------------------------------------------------------------------------
.text:0000107A
.text:0000107A loc_107A:                               ; CODE XREF: CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+159j
.text:0000107A                                         ; CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+16Aj ...
.text:0000107A                 mov     [ebp+var_70], 1
.text:00001081
.text:00001081 loc_1081:                               ; CODE XREF: CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+184j
.text:00001081                 mov     edx, [ebp+arg_4]
.text:00001084                 mov     al, byte ptr [ebp+var_70]
.text:00001087                 mov     [edx], al
.text:00001089                 push    1Eh
.text:0000108B                 mov     ecx, [ebp+var_10]
.text:0000108E                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00001093                 mov     ecx, [ebp+arg_4]
.text:00001096                 mov     dl, [eax]
.text:00001098                 mov     [ecx+7], dl
.text:0000109B                 push    1Fh
.text:0000109D                 mov     ecx, [ebp+var_10]
.text:000010A0                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:000010A5                 mov     ecx, [ebp+arg_4]
.text:000010A8                 mov     dl, [eax]
.text:000010AA                 mov     [ecx+8], dl
.text:000010AD                 push    3
.text:000010AF                 mov     ecx, [ebp+var_10]
.text:000010B2                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:000010B7                 movzx   eax, byte ptr [eax]
.text:000010BA                 neg     eax
.text:000010BC                 sbb     eax, eax
.text:000010BE                 add     eax, 1
.text:000010C1                 mov     ecx, [ebp+arg_4]
.text:000010C4                 mov     [ecx+9], al
.text:000010C7                 push    23h ; '#'
.text:000010C9                 mov     ecx, [ebp+var_10]
.text:000010CC                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:000010D1                 mov     edx, [ebp+arg_4]
.text:000010D4                 mov     al, [eax]
.text:000010D6                 mov     [edx+44h], al
.text:000010D9                 push    5
.text:000010DB                 mov     ecx, [ebp+var_10]
.text:000010DE                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:000010E3                 mov     ecx, [ebp+arg_4]
.text:000010E6                 mov     dl, [eax]
.text:000010E8                 mov     [ecx+45h], dl
.text:000010EB                 push    4
.text:000010ED                 mov     ecx, [ebp+var_10]
.text:000010F0                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:000010F5                 movzx   eax, byte ptr [eax]
.text:000010F8                 test    eax, eax
.text:000010FA                 jnz     short loc_1112
.text:000010FC                 mov     ecx, [ebp+arg_4]
.text:000010FF                 movzx   edx, byte ptr [ecx+8]
.text:00001103                 test    edx, edx
.text:00001105                 jnz     short loc_1112
.text:00001107                 mov     eax, [ebp+arg_4]
.text:0000110A                 movzx   ecx, byte ptr [eax+5]
.text:0000110E                 test    ecx, ecx
.text:00001110                 jnz     short loc_111F
.text:00001112
.text:00001112 loc_1112:                               ; CODE XREF: CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+206j
.text:00001112                                         ; CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+211j
.text:00001112                 mov     edx, [ebp+arg_4]
.text:00001115                 mov     dword ptr [edx+204h], 0
.text:0000111F
.text:0000111F loc_111F:                               ; CODE XREF: CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+21Cj
.text:0000111F                 mov     eax, [ebp+arg_4]
.text:00001122                 movzx   ecx, byte ptr [eax+8]
.text:00001126                 test    ecx, ecx
.text:00001128                 jz      short loc_1137
.text:0000112A                 mov     edx, [ebp+arg_4]
.text:0000112D                 mov     dword ptr [edx+1FCh], 0
.text:00001137
.text:00001137 loc_1137:                               ; CODE XREF: CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+234j
.text:00001137                 mov     eax, [ebp+arg_4]
.text:0000113A                 add     eax, 1FCh
.text:0000113F                 push    eax
.text:00001140                 push    7
.text:00001142                 mov     ecx, [ebp+var_10]
.text:00001145                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:0000114A                 push    eax
.text:0000114B                 call    ?SetStreamMode@@YGXABUCSwitchResult@NCommandLineParser@@AAI@Z ; SetStreamMode(NCommandLineParser::CSwitchResult const &,uint &)
.text:00001150                 mov     ecx, [ebp+arg_4]
.text:00001153                 add     ecx, 200h
.text:00001159                 push    ecx
.text:0000115A                 push    8
.text:0000115C                 mov     ecx, [ebp+var_10]
.text:0000115F                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00001164                 push    eax
.text:00001165                 call    ?SetStreamMode@@YGXABUCSwitchResult@NCommandLineParser@@AAI@Z ; SetStreamMode(NCommandLineParser::CSwitchResult const &,uint &)
.text:0000116A                 mov     edx, [ebp+arg_4]
.text:0000116D                 add     edx, 204h
.text:00001173                 push    edx
.text:00001174                 push    9
.text:00001176                 mov     ecx, [ebp+var_10]
.text:00001179                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:0000117E                 push    eax
.text:0000117F                 call    ?SetStreamMode@@YGXABUCSwitchResult@NCommandLineParser@@AAI@Z ; SetStreamMode(NCommandLineParser::CSwitchResult const &,uint &)
.text:00001184                 push    6
.text:00001186                 mov     ecx, [ebp+var_10]
.text:00001189                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:0000118E                 movzx   eax, byte ptr [eax]
.text:00001191                 test    eax, eax
.text:00001193                 jz      loc_1219
.text:00001199                 push    0
.text:0000119B                 push    6
.text:0000119D                 mov     ecx, [ebp+var_10]
.text:000011A0                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:000011A5                 add     eax, 8
.text:000011A8                 mov     ecx, eax
.text:000011AA                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:000011AF                 mov     [ebp+var_14], eax
.text:000011B2                 mov     ecx, [ebp+var_14] ; this
.text:000011B5                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:000011BA                 movzx   ecx, al
.text:000011BD                 test    ecx, ecx
.text:000011BF                 jz      short loc_11D0
.text:000011C1                 mov     edx, [ebp+arg_4]
.text:000011C4                 mov     dword ptr [edx+208h], 1
.text:000011CE                 jmp     short loc_1219
.text:000011D0 ; ---------------------------------------------------------------------------
.text:000011D0
.text:000011D0 loc_11D0:                               ; CODE XREF: CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+2CBj
.text:000011D0                 lea     eax, [ebp+var_1C]
.text:000011D3                 push    eax             ; int
.text:000011D4                 mov     ecx, [ebp+var_14]
.text:000011D7                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000011DC                 push    eax             ; wchar_t *
.text:000011DD                 call    ?StringToUInt32@@YG_NPB_WAAI@Z ; StringToUInt32(wchar_t const *,uint &)
.text:000011E2                 movzx   ecx, al
.text:000011E5                 test    ecx, ecx
.text:000011E7                 jnz     short loc_120D
.text:000011E9                 mov     ecx, [ebp+var_14]
.text:000011EC                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000011F1                 push    eax
.text:000011F2                 push    offset $SG77465 ; "Unsupported switch postfix -bb"
.text:000011F7                 lea     ecx, [ebp+var_60]
.text:000011FA                 call    ??0CArcCmdLineException@@QAE@PBDPB_W@Z ; CArcCmdLineException::CArcCmdLineException(char const *,wchar_t const *)
.text:000011FF                 push    offset __TI2?AUCArcCmdLineException@@
.text:00001204                 lea     edx, [ebp+var_60]
.text:00001207                 push    edx
.text:00001208                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:0000120D ; ---------------------------------------------------------------------------
.text:0000120D
.text:0000120D loc_120D:                               ; CODE XREF: CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+2F3j
.text:0000120D                 mov     eax, [ebp+arg_4]
.text:00001210                 mov     ecx, [ebp+var_1C]
.text:00001213                 mov     [eax+208h], ecx
.text:00001219
.text:00001219 loc_1219:                               ; CODE XREF: CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+29Fj
.text:00001219                                         ; CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+2DAj
.text:00001219                 push    25h ; '%'
.text:0000121B                 mov     ecx, [ebp+var_10]
.text:0000121E                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00001223                 movzx   edx, byte ptr [eax]
.text:00001226                 test    edx, edx
.text:00001228                 jz      short loc_1256
.text:0000122A                 push    25h ; '%'
.text:0000122C                 mov     ecx, [ebp+var_10]
.text:0000122F                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00001234                 movzx   eax, byte ptr [eax+1]
.text:00001238                 neg     eax
.text:0000123A                 sbb     eax, eax
.text:0000123C                 add     eax, 1
.text:0000123F                 mov     byte ptr ds:?g_CaseSensitive@@3_NA, al ; bool g_CaseSensitive
.text:00001244                 mov     ecx, [ebp+arg_4]
.text:00001247                 mov     byte ptr [ecx+2], 1
.text:0000124B                 mov     edx, [ebp+arg_4]
.text:0000124E                 mov     al, byte ptr ds:?g_CaseSensitive@@3_NA ; bool g_CaseSensitive
.text:00001253                 mov     [edx+3], al
.text:00001256
.text:00001256 loc_1256:                               ; CODE XREF: CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+334j
.text:00001256                 mov     ecx, [ebp+arg_4]
.text:00001259                 mov     byte ptr [ecx+1], 0
.text:0000125D                 push    20h ; ' '
.text:0000125F                 mov     ecx, [ebp+var_10]
.text:00001262                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00001267                 movzx   edx, byte ptr [eax]
.text:0000126A                 test    edx, edx
.text:0000126C                 jz      short loc_1289
.text:0000126E                 push    20h ; ' '
.text:00001270                 mov     ecx, [ebp+var_10]
.text:00001273                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00001278                 movzx   eax, byte ptr [eax+1]
.text:0000127C                 neg     eax
.text:0000127E                 sbb     eax, eax
.text:00001280                 add     eax, 1
.text:00001283                 mov     ecx, [ebp+arg_4]
.text:00001286                 mov     [ecx+1], al
.text:00001289
.text:00001289 loc_1289:                               ; CODE XREF: CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+378j
.text:00001289                 push    1Ah
.text:0000128B                 mov     ecx, [ebp+var_10]
.text:0000128E                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00001293                 movzx   edx, byte ptr [eax]
.text:00001296                 test    edx, edx
.text:00001298                 jz      loc_138C
.text:0000129E                 push    0
.text:000012A0                 push    1Ah
.text:000012A2                 mov     ecx, [ebp+var_10]
.text:000012A5                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:000012AA                 add     eax, 8
.text:000012AD                 mov     ecx, eax
.text:000012AF                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:000012B4                 mov     [ebp+var_24], eax
.text:000012B7                 mov     ecx, [ebp+var_24] ; this
.text:000012BA                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:000012BF                 movzx   eax, al
.text:000012C2                 test    eax, eax
.text:000012C4                 jnz     loc_138C
.text:000012CA                 mov     [ebp+dwProcessAffinityMask], 0
.text:000012D1                 lea     ecx, [ebp+var_38]
.text:000012D4                 call    ??0AString@@QAE@XZ ; AString::AString(void)
.text:000012D9                 mov     [ebp+var_4], 0
.text:000012E0                 mov     ecx, [ebp+var_24]
.text:000012E3                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000012E8                 push    eax             ; wchar_t *
.text:000012E9                 lea     ecx, [ebp+var_38] ; this
.text:000012EC                 call    ?SetFromWStr_if_Ascii@AString@@QAEXPB_W@Z ; AString::SetFromWStr_if_Ascii(wchar_t const *)
.text:000012F1                 lea     ecx, [ebp+var_38] ; this
.text:000012F4                 call    ?IsEmpty@AString@@QBE_NXZ ; AString::IsEmpty(void)
.text:000012F9                 movzx   ecx, al
.text:000012FC                 test    ecx, ecx
.text:000012FE                 jnz     short loc_1327
.text:00001300                 lea     edx, [ebp+var_44]
.text:00001303                 push    edx             ; char **
.text:00001304                 lea     ecx, [ebp+var_38]
.text:00001307                 call    ??BAString@@QBEPBDXZ ; AString::operator char const *(void)
.text:0000130C                 push    eax             ; char *
.text:0000130D                 call    ?ConvertHexStringToUInt32@@YGIPBDPAPBD@Z ; ConvertHexStringToUInt32(char const *,char const * *)
.text:00001312                 mov     [ebp+dwProcessAffinityMask], eax
.text:00001315                 mov     eax, [ebp+var_44]
.text:00001318                 movsx   ecx, byte ptr [eax]
.text:0000131B                 test    ecx, ecx
.text:0000131D                 jz      short loc_1327
.text:0000131F                 lea     ecx, [ebp+var_38] ; this
.text:00001322                 call    ?Empty@AString@@QAEXXZ ; AString::Empty(void)
.text:00001327
.text:00001327 loc_1327:                               ; CODE XREF: CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+40Aj
.text:00001327                                         ; CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+429j
.text:00001327                 lea     ecx, [ebp+var_38] ; this
.text:0000132A                 call    ?IsEmpty@AString@@QBE_NXZ ; AString::IsEmpty(void)
.text:0000132F                 movzx   edx, al
.text:00001332                 test    edx, edx
.text:00001334                 jz      short loc_135A
.text:00001336                 mov     ecx, [ebp+var_24]
.text:00001339                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:0000133E                 push    eax
.text:0000133F                 push    offset $SG77480 ; "Unsupported switch postfix -stm"
.text:00001344                 lea     ecx, [ebp+var_6C]
.text:00001347                 call    ??0CArcCmdLineException@@QAE@PBDPB_W@Z ; CArcCmdLineException::CArcCmdLineException(char const *,wchar_t const *)
.text:0000134C                 push    offset __TI2?AUCArcCmdLineException@@
.text:00001351                 lea     eax, [ebp+var_6C]
.text:00001354                 push    eax
.text:00001355                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:0000135A ; ---------------------------------------------------------------------------
.text:0000135A
.text:0000135A loc_135A:                               ; CODE XREF: CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+440j
.text:0000135A                 mov     esi, esp
.text:0000135C                 mov     ecx, [ebp+dwProcessAffinityMask]
.text:0000135F                 push    ecx             ; dwProcessAffinityMask
.text:00001360                 mov     edi, esp
.text:00001362                 call    dword ptr ds:__imp__GetCurrentProcess@0 ; GetCurrentProcess()
.text:00001368                 cmp     edi, esp
.text:0000136A                 call    __RTC_CheckEsp
.text:0000136F                 push    eax             ; hProcess
.text:00001370                 call    dword ptr ds:__imp__SetProcessAffinityMask@8 ; SetProcessAffinityMask(x,x)
.text:00001376                 cmp     esi, esp
.text:00001378                 call    __RTC_CheckEsp
.text:0000137D                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001384                 lea     ecx, [ebp+var_38] ; this
.text:00001387                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:0000138C
.text:0000138C loc_138C:                               ; CODE XREF: CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+3A4j
.text:0000138C                                         ; CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+3D0j
.text:0000138C                 push    edx
.text:0000138D                 mov     ecx, ebp
.text:0000138F                 push    eax
.text:00001390                 lea     edx, $LN26
.text:00001396                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:0000139B                 pop     eax
.text:0000139C                 pop     edx
.text:0000139D                 mov     ecx, [ebp+var_C]
.text:000013A0                 mov     large fs:0, ecx
.text:000013A7                 pop     ecx
.text:000013A8                 pop     edi
.text:000013A9                 pop     esi
.text:000013AA                 add     esp, 70h
.text:000013AD                 cmp     ebp, esp
.text:000013AF                 call    __RTC_CheckEsp
.text:000013B4                 mov     esp, ebp
.text:000013B6                 pop     ebp
.text:000013B7                 retn    8
.text:000013B7 ?Parse1@CArcCmdLineParser@@QAEXABV?$CObjectVector@VUString@@@@AAUCArcCmdLineOptions@@@Z endp
.text:000013B7
.text:000013B7 ; ---------------------------------------------------------------------------
.text:000013BA                 align 4
.text:000013BC $LN26           dd 3                    ; DATA XREF: CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+49Co
.text:000013C0                 dd offset $LN25
.text:000013C4 $LN25           dd 0FFFFFFE4h, 4        ; DATA XREF: .text:000013C0o
.text:000013CC                 dd offset $LN21
.text:000013D0                 dd 0FFFFFFC8h, 0Ch
.text:000013D8                 dd offset $LN22
.text:000013DC                 dd 0FFFFFFBCh, 4
.text:000013E4                 dd offset $LN23
.text:000013E8 $LN23           dd 646E65h              ; DATA XREF: .text:000013E4o
.text:000013EC $LN22           db 61h, 0               ; DATA XREF: .text:000013D8o
.text:000013EE $LN21           dw 76h                  ; DATA XREF: .text:000013CCo
.text:000013F0                 db 4 dup(0CCh)
.text:000013F4
.text:000013F4 ; =============== S U B R O U T I N E =======================================
.text:000013F4
.text:000013F4 ; Attributes: bp-based frame
.text:000013F4
.text:000013F4 ; int __stdcall StringToUInt32(wchar_t *, int)
.text:000013F4 ?StringToUInt32@@YG_NPB_WAAI@Z proc near
.text:000013F4                                         ; CODE XREF: CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+2E9p
.text:000013F4                                         ; CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+B79p ...
.text:000013F4
.text:000013F4 var_C           = dword ptr -0Ch
.text:000013F4 var_8           = dword ptr -8
.text:000013F4 var_4           = dword ptr -4
.text:000013F4 arg_0           = dword ptr  8
.text:000013F4 arg_4           = dword ptr  0Ch
.text:000013F4
.text:000013F4                 push    ebp
.text:000013F5                 mov     ebp, esp
.text:000013F7                 sub     esp, 0Ch
.text:000013FA                 mov     [ebp+var_C], 0CCCCCCCCh
.text:00001401                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00001408                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000140F                 mov     eax, [ebp+arg_0]
.text:00001412                 movzx   ecx, word ptr [eax]
.text:00001415                 test    ecx, ecx
.text:00001417                 jnz     short loc_141D
.text:00001419                 xor     al, al
.text:0000141B                 jmp     short loc_143C
.text:0000141D ; ---------------------------------------------------------------------------
.text:0000141D
.text:0000141D loc_141D:                               ; CODE XREF: StringToUInt32(wchar_t const *,uint &)+23j
.text:0000141D                 lea     edx, [ebp+var_8]
.text:00001420                 push    edx             ; wchar_t **
.text:00001421                 mov     eax, [ebp+arg_0]
.text:00001424                 push    eax             ; wchar_t *
.text:00001425                 call    ?ConvertStringToUInt32@@YGIPB_WPAPB_W@Z ; ConvertStringToUInt32(wchar_t const *,wchar_t const * *)
.text:0000142A                 mov     ecx, [ebp+arg_4]
.text:0000142D                 mov     [ecx], eax
.text:0000142F                 mov     edx, [ebp+var_8]
.text:00001432                 movzx   eax, word ptr [edx]
.text:00001435                 neg     eax
.text:00001437                 sbb     eax, eax
.text:00001439                 add     eax, 1
.text:0000143C
.text:0000143C loc_143C:                               ; CODE XREF: StringToUInt32(wchar_t const *,uint &)+27j
.text:0000143C                 push    edx
.text:0000143D                 mov     ecx, ebp
.text:0000143F                 push    eax
.text:00001440                 lea     edx, $LN6
.text:00001446                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:0000144B                 pop     eax
.text:0000144C                 pop     edx
.text:0000144D                 add     esp, 0Ch
.text:00001450                 cmp     ebp, esp
.text:00001452                 call    __RTC_CheckEsp
.text:00001457                 mov     esp, ebp
.text:00001459                 pop     ebp
.text:0000145A                 retn    8
.text:0000145A ?StringToUInt32@@YG_NPB_WAAI@Z endp
.text:0000145A
.text:0000145A ; ---------------------------------------------------------------------------
.text:0000145D                 align 10h
.text:00001460 $LN6            dd 1                    ; DATA XREF: StringToUInt32(wchar_t const *,uint &)+4Co
.text:00001464                 dd offset $LN5
.text:00001468 $LN5            dd 0FFFFFFF8h, 4        ; DATA XREF: .text:00001464o
.text:00001470                 dd offset $LN4
.text:00001474 $LN4            dd 646E65h, 3 dup(0CCCCCCCCh) ; DATA XREF: .text:00001470o
.text:00001484
.text:00001484 ; =============== S U B R O U T I N E =======================================
.text:00001484
.text:00001484 ; Attributes: bp-based frame
.text:00001484
.text:00001484 ; void __stdcall SetStreamMode(struct NCommandLineParser::CSwitchResult const &, unsigned int &)
.text:00001484 ?SetStreamMode@@YGXABUCSwitchResult@NCommandLineParser@@AAI@Z proc near
.text:00001484                                         ; CODE XREF: CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+257p
.text:00001484                                         ; CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+271p ...
.text:00001484
.text:00001484 arg_0           = dword ptr  8
.text:00001484 arg_4           = dword ptr  0Ch
.text:00001484
.text:00001484                 push    ebp
.text:00001485                 mov     ebp, esp
.text:00001487                 mov     eax, [ebp+arg_0]
.text:0000148A                 movzx   ecx, byte ptr [eax]
.text:0000148D                 test    ecx, ecx
.text:0000148F                 jz      short loc_149C
.text:00001491                 mov     edx, [ebp+arg_4]
.text:00001494                 mov     eax, [ebp+arg_0]
.text:00001497                 mov     ecx, [eax+4]
.text:0000149A                 mov     [edx], ecx
.text:0000149C
.text:0000149C loc_149C:                               ; CODE XREF: SetStreamMode(NCommandLineParser::CSwitchResult const &,uint &)+Bj
.text:0000149C                 pop     ebp
.text:0000149D                 retn    8
.text:0000149D ?SetStreamMode@@YGXABUCSwitchResult@NCommandLineParser@@AAI@Z endp
.text:0000149D
.text:0000149D ; ---------------------------------------------------------------------------
.text:000014A0                 db 4 dup(0CCh)
.text:000014A4
.text:000014A4 ; =============== S U B R O U T I N E =======================================
.text:000014A4
.text:000014A4 ; Attributes: bp-based frame
.text:000014A4
.text:000014A4 ; long __stdcall EnumerateDirItemsAndSort(class NWildcard::CCensor &, enum  NWildcard::ECensorPathMode, class UString const &, class CObjectVector<class UString> &, class CObjectVector<class UString> &, struct CDirItemsStat &, struct IDirItemsCallback *)
.text:000014A4                 public ?EnumerateDirItemsAndSort@@YGJAAVCCensor@NWildcard@@W4ECensorPathMode@2@ABVUString@@AAV?$CObjectVector@VUString@@@@3AAUCDirItemsStat@@PAUIDirItemsCallback@@@Z
.text:000014A4 ?EnumerateDirItemsAndSort@@YGJAAVCCensor@NWildcard@@W4ECensorPathMode@2@ABVUString@@AAV?$CObjectVector@VUString@@@@3AAUCDirItemsStat@@PAUIDirItemsCallback@@@Z proc near
.text:000014A4
.text:000014A4 var_150         = dword ptr -150h
.text:000014A4 var_14C         = dword ptr -14Ch
.text:000014A4 var_148         = dword ptr -148h
.text:000014A4 var_144         = byte ptr -144h
.text:000014A4 var_138         = byte ptr -138h
.text:000014A4 var_12C         = byte ptr -12Ch
.text:000014A4 var_120         = dword ptr -120h
.text:000014A4 var_11C         = dword ptr -11Ch
.text:000014A4 var_114         = byte ptr -114h
.text:000014A4 var_100         = word ptr -100h
.text:000014A4 var_F0          = dword ptr -0F0h
.text:000014A4 var_E8          = byte ptr -0E8h
.text:000014A4 var_D8          = dword ptr -0D8h
.text:000014A4 var_D4          = dword ptr -0D4h
.text:000014A4 var_D0          = dword ptr -0D0h
.text:000014A4 var_CC          = dword ptr -0CCh
.text:000014A4 var_C4          = byte ptr -0C4h
.text:000014A4 var_A0          = byte ptr -0A0h
.text:000014A4 var_8C          = byte ptr -8Ch
.text:000014A4 var_2C          = dword ptr -2Ch
.text:000014A4 var_1C          = byte ptr -1Ch
.text:000014A4 var_C           = dword ptr -0Ch
.text:000014A4 var_4           = dword ptr -4
.text:000014A4 arg_0           = dword ptr  8
.text:000014A4 arg_4           = dword ptr  0Ch
.text:000014A4 arg_8           = dword ptr  10h
.text:000014A4 arg_C           = dword ptr  14h
.text:000014A4 arg_10          = dword ptr  18h
.text:000014A4 arg_14          = dword ptr  1Ch
.text:000014A4 arg_18          = dword ptr  20h
.text:000014A4
.text:000014A4                 push    ebp
.text:000014A5                 mov     ebp, esp
.text:000014A7                 push    0FFFFFFFFh
.text:000014A9                 push    offset __ehhandler$?EnumerateDirItemsAndSort@@YGJAAVCCensor@NWildcard@@W4ECensorPathMode@2@ABVUString@@AAV?$CObjectVector@VUString@@@@3AAUCDirItemsStat@@PAUIDirItemsCallback@@@Z
.text:000014AE                 mov     eax, large fs:0
.text:000014B4                 push    eax
.text:000014B5                 sub     esp, 144h
.text:000014BB                 push    esi
.text:000014BC                 push    edi
.text:000014BD                 lea     edi, [ebp+var_150]
.text:000014C3                 mov     ecx, 51h ; 'Q'
.text:000014C8                 mov     eax, 0CCCCCCCCh
.text:000014CD                 rep stosd
.text:000014CF                 mov     eax, dword ptr ds:___security_cookie
.text:000014D4                 xor     eax, ebp
.text:000014D6                 push    eax             ; struct UString *
.text:000014D7                 lea     eax, [ebp+var_C]
.text:000014DA                 mov     large fs:0, eax
.text:000014E0                 lea     ecx, [ebp+var_1C]
.text:000014E3                 call    ??0?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::CObjectVector<UString>(void)
.text:000014E8                 mov     [ebp+var_4], 0
.text:000014EF                 lea     ecx, [ebp+var_C4] ; this
.text:000014F5                 call    ??0CDirItems@@QAE@XZ ; CDirItems::CDirItems(void)
.text:000014FA                 mov     byte ptr [ebp+var_4], 1
.text:000014FE                 mov     eax, [ebp+arg_18]
.text:00001501                 mov     [ebp+var_2C], eax
.text:00001504                 lea     ecx, [ebp+var_C4]
.text:0000150A                 push    ecx
.text:0000150B                 mov     edx, [ebp+arg_8]
.text:0000150E                 push    edx
.text:0000150F                 mov     eax, [ebp+arg_4]
.text:00001512                 push    eax
.text:00001513                 mov     ecx, [ebp+arg_0]
.text:00001516                 push    ecx             ; struct UString *
.text:00001517                 call    ?EnumerateItems@@YGJABVCCensor@NWildcard@@W4ECensorPathMode@2@ABVUString@@AAVCDirItems@@@Z ; EnumerateItems(NWildcard::CCensor const &,NWildcard::ECensorPathMode,UString const &,CDirItems &)
.text:0000151C                 mov     [ebp+var_CC], eax
.text:00001522                 mov     ecx, 0Ch
.text:00001527                 lea     esi, [ebp+var_8C]
.text:0000152D                 mov     edi, [ebp+arg_14]
.text:00001530                 rep movsd
.text:00001532                 mov     edx, [ebp+var_CC]
.text:00001538                 mov     [ebp+var_D0], edx
.text:0000153E                 cmp     [ebp+var_D0], 0
.text:00001545                 jz      short loc_157C
.text:00001547                 mov     eax, [ebp+var_D0]
.text:0000154D                 mov     [ebp+var_120], eax
.text:00001553                 mov     byte ptr [ebp+var_4], 0
.text:00001557                 lea     ecx, [ebp+var_C4] ; this
.text:0000155D                 call    ??1CDirItems@@QAE@XZ ; CDirItems::~CDirItems(void)
.text:00001562                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001569                 lea     ecx, [ebp+var_1C]
.text:0000156C                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:00001571                 mov     eax, [ebp+var_120]
.text:00001577                 jmp     loc_187B
.text:0000157C ; ---------------------------------------------------------------------------
.text:0000157C
.text:0000157C loc_157C:                               ; CODE XREF: EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *)+A1j
.text:0000157C                 mov     [ebp+var_D4], 0
.text:00001586                 jmp     short loc_1597
.text:00001588 ; ---------------------------------------------------------------------------
.text:00001588
.text:00001588 loc_1588:                               ; CODE XREF: EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *):loc_1621j
.text:00001588                 mov     ecx, [ebp+var_D4]
.text:0000158E                 add     ecx, 1
.text:00001591                 mov     [ebp+var_D4], ecx
.text:00001597
.text:00001597 loc_1597:                               ; CODE XREF: EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *)+E2j
.text:00001597                 lea     ecx, [ebp+var_A0]
.text:0000159D                 call    ?Size@?$CObjectVector@UCDirItem@@@@QBEIXZ ; CObjectVector<CDirItem>::Size(void)
.text:000015A2                 cmp     [ebp+var_D4], eax
.text:000015A8                 jnb     short loc_1626
.text:000015AA                 mov     edx, [ebp+var_D4]
.text:000015B0                 push    edx
.text:000015B1                 lea     ecx, [ebp+var_A0]
.text:000015B7                 call    ??A?$CObjectVector@UCDirItem@@@@QAEAAUCDirItem@@I@Z ; CObjectVector<CDirItem>::operator[](uint)
.text:000015BC                 mov     [ebp+var_D8], eax
.text:000015C2                 mov     ecx, [ebp+var_D8] ; this
.text:000015C8                 call    ?IsDir@CDirItem@@QBE_NXZ ; CDirItem::IsDir(void)
.text:000015CD                 movzx   eax, al
.text:000015D0                 test    eax, eax
.text:000015D2                 jnz     short loc_1621
.text:000015D4                 mov     ecx, [ebp+var_D4]
.text:000015DA                 push    ecx
.text:000015DB                 lea     edx, [ebp+var_12C]
.text:000015E1                 push    edx
.text:000015E2                 lea     ecx, [ebp+var_C4]
.text:000015E8                 call    ?GetPhyPath@CDirItems@@QBE?AVUString@@I@Z ; CDirItems::GetPhyPath(uint)
.text:000015ED                 mov     [ebp+var_14C], eax
.text:000015F3                 mov     eax, [ebp+var_14C]
.text:000015F9                 mov     [ebp+var_150], eax
.text:000015FF                 mov     byte ptr [ebp+var_4], 2
.text:00001603                 mov     ecx, [ebp+var_150]
.text:00001609                 push    ecx
.text:0000160A                 lea     ecx, [ebp+var_1C]
.text:0000160D                 call    ?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z ; CObjectVector<UString>::Add(UString const &)
.text:00001612                 mov     byte ptr [ebp+var_4], 1
.text:00001616                 lea     ecx, [ebp+var_12C] ; this
.text:0000161C                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00001621
.text:00001621 loc_1621:                               ; CODE XREF: EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *)+12Ej
.text:00001621                 jmp     loc_1588
.text:00001626 ; ---------------------------------------------------------------------------
.text:00001626
.text:00001626 loc_1626:                               ; CODE XREF: EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *)+104j
.text:00001626                 mov     byte ptr [ebp+var_4], 0
.text:0000162A                 lea     ecx, [ebp+var_C4] ; this
.text:00001630                 call    ??1CDirItems@@QAE@XZ ; CDirItems::~CDirItems(void)
.text:00001635                 lea     ecx, [ebp+var_1C]
.text:00001638                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:0000163D                 test    eax, eax
.text:0000163F                 jnz     short loc_1666
.text:00001641                 push    0
.text:00001643                 mov     edx, ds:_kCannotFindArchive
.text:00001649                 push    edx
.text:0000164A                 lea     ecx, [ebp+var_138]
.text:00001650                 call    ??0CArcCmdLineException@@QAE@PBDPB_W@Z ; CArcCmdLineException::CArcCmdLineException(char const *,wchar_t const *)
.text:00001655                 push    offset __TI2?AUCArcCmdLineException@@
.text:0000165A                 lea     eax, [ebp+var_138]
.text:00001660                 push    eax
.text:00001661                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:00001666 ; ---------------------------------------------------------------------------
.text:00001666
.text:00001666 loc_1666:                               ; CODE XREF: EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *)+19Bj
.text:00001666                 lea     ecx, [ebp+var_E8]
.text:0000166C                 call    ??0?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::CObjectVector<UString>(void)
.text:00001671                 mov     byte ptr [ebp+var_4], 3
.text:00001675                 mov     [ebp+var_F0], 0
.text:0000167F                 jmp     short loc_1690
.text:00001681 ; ---------------------------------------------------------------------------
.text:00001681
.text:00001681 loc_1681:                               ; CODE XREF: EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *)+24Fj
.text:00001681                 mov     ecx, [ebp+var_F0]
.text:00001687                 add     ecx, 1
.text:0000168A                 mov     [ebp+var_F0], ecx
.text:00001690
.text:00001690 loc_1690:                               ; CODE XREF: EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *)+1DBj
.text:00001690                 lea     ecx, [ebp+var_1C]
.text:00001693                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:00001698                 cmp     [ebp+var_F0], eax
.text:0000169E                 jnb     short loc_16F5
.text:000016A0                 lea     ecx, [ebp+var_100]
.text:000016A6                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:000016AB                 mov     byte ptr [ebp+var_4], 4
.text:000016AF                 lea     edx, [ebp+var_100]
.text:000016B5                 push    edx             ; wchar_t *
.text:000016B6                 mov     eax, [ebp+var_F0]
.text:000016BC                 push    eax
.text:000016BD                 lea     ecx, [ebp+var_1C]
.text:000016C0                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:000016C5                 mov     ecx, eax
.text:000016C7                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000016CC                 push    eax             ; this
.text:000016CD                 call    ?MyGetFullPathName@NDir@NFile@NWindows@@YG_NPB_WAAVUString@@@Z ; NWindows::NFile::NDir::MyGetFullPathName(wchar_t const *,UString &)
.text:000016D2                 lea     ecx, [ebp+var_100]
.text:000016D8                 push    ecx
.text:000016D9                 lea     ecx, [ebp+var_E8]
.text:000016DF                 call    ?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z ; CObjectVector<UString>::Add(UString const &)
.text:000016E4                 mov     byte ptr [ebp+var_4], 3
.text:000016E8                 lea     ecx, [ebp+var_100] ; this
.text:000016EE                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000016F3                 jmp     short loc_1681
.text:000016F5 ; ---------------------------------------------------------------------------
.text:000016F5
.text:000016F5 loc_16F5:                               ; CODE XREF: EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *)+1FAj
.text:000016F5                 lea     ecx, [ebp+var_114]
.text:000016FB                 call    ??0?$CRecordVector@I@@QAE@XZ ; CRecordVector<uint>::CRecordVector<uint>(void)
.text:00001700                 mov     byte ptr [ebp+var_4], 5
.text:00001704                 lea     edx, [ebp+var_114]
.text:0000170A                 push    edx
.text:0000170B                 lea     eax, [ebp+var_E8]
.text:00001711                 push    eax
.text:00001712                 call    ?SortFileNames@@YGXABV?$CObjectVector@VUString@@@@AAV?$CRecordVector@I@@@Z ; SortFileNames(CObjectVector<UString> const &,CRecordVector<uint> &)
.text:00001717                 lea     ecx, [ebp+var_114]
.text:0000171D                 call    ?Size@?$CRecordVector@I@@QBEIXZ ; CRecordVector<uint>::Size(void)
.text:00001722                 push    eax
.text:00001723                 mov     ecx, [ebp+arg_C]
.text:00001726                 call    ?ClearAndReserve@?$CObjectVector@VUString@@@@QAEXI@Z ; CObjectVector<UString>::ClearAndReserve(uint)
.text:0000172B                 lea     ecx, [ebp+var_114]
.text:00001731                 call    ?Size@?$CRecordVector@I@@QBEIXZ ; CRecordVector<uint>::Size(void)
.text:00001736                 push    eax
.text:00001737                 mov     ecx, [ebp+arg_10]
.text:0000173A                 call    ?ClearAndReserve@?$CObjectVector@VUString@@@@QAEXI@Z ; CObjectVector<UString>::ClearAndReserve(uint)
.text:0000173F                 mov     [ebp+var_F0], 0
.text:00001749                 jmp     short loc_175A
.text:0000174B ; ---------------------------------------------------------------------------
.text:0000174B
.text:0000174B loc_174B:                               ; CODE XREF: EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *):loc_1839j
.text:0000174B                 mov     ecx, [ebp+var_F0]
.text:00001751                 add     ecx, 1
.text:00001754                 mov     [ebp+var_F0], ecx
.text:0000175A
.text:0000175A loc_175A:                               ; CODE XREF: EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *)+2A5j
.text:0000175A                 lea     ecx, [ebp+var_114]
.text:00001760                 call    ?Size@?$CRecordVector@I@@QBEIXZ ; CRecordVector<uint>::Size(void)
.text:00001765                 cmp     [ebp+var_F0], eax
.text:0000176B                 jnb     loc_183E
.text:00001771                 mov     edx, [ebp+var_F0]
.text:00001777                 push    edx
.text:00001778                 lea     ecx, [ebp+var_114]
.text:0000177E                 call    ??A?$CRecordVector@I@@QAEAAII@Z ; CRecordVector<uint>::operator[](uint)
.text:00001783                 mov     eax, [eax]
.text:00001785                 mov     [ebp+var_11C], eax
.text:0000178B                 mov     ecx, [ebp+var_11C]
.text:00001791                 push    ecx
.text:00001792                 lea     ecx, [ebp+var_1C]
.text:00001795                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:0000179A                 push    eax
.text:0000179B                 mov     ecx, [ebp+arg_C]
.text:0000179E                 call    ?AddInReserved@?$CObjectVector@VUString@@@@QAEXABVUString@@@Z ; CObjectVector<UString>::AddInReserved(UString const &)
.text:000017A3                 mov     edx, [ebp+var_11C]
.text:000017A9                 push    edx
.text:000017AA                 lea     ecx, [ebp+var_E8]
.text:000017B0                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:000017B5                 push    eax
.text:000017B6                 mov     ecx, [ebp+arg_10]
.text:000017B9                 call    ?AddInReserved@?$CObjectVector@VUString@@@@QAEXABVUString@@@Z ; CObjectVector<UString>::AddInReserved(UString const &)
.text:000017BE                 cmp     [ebp+var_F0], 0
.text:000017C5                 jbe     short loc_1839
.text:000017C7                 mov     eax, [ebp+var_F0]
.text:000017CD                 sub     eax, 1
.text:000017D0                 push    eax
.text:000017D1                 mov     ecx, [ebp+arg_10]
.text:000017D4                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:000017D9                 mov     ecx, eax
.text:000017DB                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000017E0                 push    eax             ; wchar_t *
.text:000017E1                 mov     ecx, [ebp+var_F0]
.text:000017E7                 push    ecx
.text:000017E8                 mov     ecx, [ebp+arg_10]
.text:000017EB                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:000017F0                 mov     ecx, eax
.text:000017F2                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000017F7                 push    eax             ; wchar_t *
.text:000017F8                 call    ?CompareFileNames@@YGHPB_W0@Z ; CompareFileNames(wchar_t const *,wchar_t const *)
.text:000017FD                 test    eax, eax
.text:000017FF                 jnz     short loc_1839
.text:00001801                 mov     edx, [ebp+var_F0]
.text:00001807                 push    edx
.text:00001808                 mov     ecx, [ebp+arg_10]
.text:0000180B                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00001810                 mov     ecx, eax
.text:00001812                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00001817                 push    eax
.text:00001818                 push    offset $SG77562 ; "Duplicate archive path:"
.text:0000181D                 lea     ecx, [ebp+var_144]
.text:00001823                 call    ??0CArcCmdLineException@@QAE@PBDPB_W@Z ; CArcCmdLineException::CArcCmdLineException(char const *,wchar_t const *)
.text:00001828                 push    offset __TI2?AUCArcCmdLineException@@
.text:0000182D                 lea     eax, [ebp+var_144]
.text:00001833                 push    eax
.text:00001834                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:00001839 ; ---------------------------------------------------------------------------
.text:00001839
.text:00001839 loc_1839:                               ; CODE XREF: EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *)+321j
.text:00001839                                         ; EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *)+35Bj
.text:00001839                 jmp     loc_174B
.text:0000183E ; ---------------------------------------------------------------------------
.text:0000183E
.text:0000183E loc_183E:                               ; CODE XREF: EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *)+2C7j
.text:0000183E                 mov     [ebp+var_148], 0
.text:00001848                 mov     byte ptr [ebp+var_4], 3
.text:0000184C                 lea     ecx, [ebp+var_114]
.text:00001852                 call    ??1?$CRecordVector@I@@QAE@XZ ; CRecordVector<uint>::~CRecordVector<uint>(void)
.text:00001857                 mov     byte ptr [ebp+var_4], 0
.text:0000185B                 lea     ecx, [ebp+var_E8]
.text:00001861                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:00001866                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000186D                 lea     ecx, [ebp+var_1C]
.text:00001870                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:00001875                 mov     eax, [ebp+var_148]
.text:0000187B
.text:0000187B loc_187B:                               ; CODE XREF: EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *)+D3j
.text:0000187B                 push    edx
.text:0000187C                 mov     ecx, ebp
.text:0000187E                 push    eax
.text:0000187F                 lea     edx, $LN29
.text:00001885                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:0000188A                 pop     eax
.text:0000188B                 pop     edx
.text:0000188C                 mov     ecx, [ebp+var_C]
.text:0000188F                 mov     large fs:0, ecx
.text:00001896                 pop     ecx
.text:00001897                 pop     edi
.text:00001898                 pop     esi
.text:00001899                 add     esp, 150h
.text:0000189F                 cmp     ebp, esp
.text:000018A1                 call    __RTC_CheckEsp
.text:000018A6                 mov     esp, ebp
.text:000018A8                 pop     ebp
.text:000018A9                 retn    1Ch
.text:000018A9 ?EnumerateDirItemsAndSort@@YGJAAVCCensor@NWildcard@@W4ECensorPathMode@2@ABVUString@@AAV?$CObjectVector@VUString@@@@3AAUCDirItemsStat@@PAUIDirItemsCallback@@@Z endp ; sp-analysis failed
.text:000018A9
.text:000018A9 ; ---------------------------------------------------------------------------
.text:000018AC $LN29           dd 5                    ; DATA XREF: EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *)+3DBo
.text:000018B0                 dd offset $LN28
.text:000018B4 $LN28           dd 0FFFFFFE4h, 0Ch      ; DATA XREF: .text:000018B0o
.text:000018BC                 dd offset $LN22_0       ; "paths"
.text:000018C0                 dd 0FFFFFF3Ch, 0A0h
.text:000018C8                 dd offset $LN23_0       ; "dirItems"
.text:000018CC                 dd 0FFFFFF18h, 0Ch
.text:000018D4                 dd offset $LN24         ; "fullPaths"
.text:000018D8                 dd 0FFFFFF00h, 0Ch
.text:000018E0                 dd offset $LN25_0       ; "fullPath"
.text:000018E4                 dd 0FFFFFEECh, 0Ch
.text:000018EC                 dd offset $LN26_0       ; "indices"
.text:000018F0 $LN26_0         db 'indices',0          ; DATA XREF: .text:000018ECo
.text:000018F8 $LN25_0         db 'fullPath',0         ; DATA XREF: .text:000018E0o
.text:00001901 $LN24           db 'fullPaths',0        ; DATA XREF: .text:000018D4o
.text:0000190B $LN23_0         db 'dirItems',0         ; DATA XREF: .text:000018C8o
.text:00001914 $LN22_0         db 'paths',0            ; DATA XREF: .text:000018BCo
.text:0000191A                 db 0Ah dup(0CCh)
.text:00001924
.text:00001924 ; =============== S U B R O U T I N E =======================================
.text:00001924
.text:00001924 ; Attributes: bp-based frame
.text:00001924
.text:00001924 ; void __thiscall CArcCmdLineParser::Parse2(CArcCmdLineParser *__hidden this, struct CArcCmdLineOptions *)
.text:00001924                 public ?Parse2@CArcCmdLineParser@@QAEXAAUCArcCmdLineOptions@@@Z
.text:00001924 ?Parse2@CArcCmdLineParser@@QAEXAAUCArcCmdLineOptions@@@Z proc near
.text:00001924
.text:00001924 var_EC          = dword ptr -0ECh
.text:00001924 var_E8          = dword ptr -0E8h
.text:00001924 var_E4          = dword ptr -0E4h
.text:00001924 var_E0          = dword ptr -0E0h
.text:00001924 var_DC          = dword ptr -0DCh
.text:00001924 var_D8          = dword ptr -0D8h
.text:00001924 var_D4          = byte ptr -0D4h
.text:00001924 var_C8          = byte ptr -0C8h
.text:00001924 var_BC          = byte ptr -0BCh
.text:00001924 var_B0          = byte ptr -0B0h
.text:00001924 var_A4          = byte ptr -0A4h
.text:00001924 var_98          = byte ptr -98h
.text:00001924 var_8C          = byte ptr -8Ch
.text:00001924 var_80          = byte ptr -80h
.text:00001924 var_74          = byte ptr -74h
.text:00001924 var_68          = byte ptr -68h
.text:00001924 var_5C          = byte ptr -5Ch
.text:00001924 var_50          = byte ptr -50h
.text:00001924 var_44          = dword ptr -44h
.text:00001924 var_40          = dword ptr -40h
.text:00001924 var_3C          = dword ptr -3Ch
.text:00001924 var_38          = dword ptr -38h
.text:00001924 var_34          = dword ptr -34h
.text:00001924 var_30          = byte ptr -30h
.text:00001924 var_2F          = byte ptr -2Fh
.text:00001924 var_2E          = byte ptr -2Eh
.text:00001924 var_2D          = byte ptr -2Dh
.text:00001924 var_2C          = dword ptr -2Ch
.text:00001924 var_25          = byte ptr -25h
.text:00001924 var_24          = dword ptr -24h
.text:00001924 var_1D          = byte ptr -1Dh
.text:00001924 var_1C          = dword ptr -1Ch
.text:00001924 var_18          = dword ptr -18h
.text:00001924 var_11          = byte ptr -11h
.text:00001924 var_10          = dword ptr -10h
.text:00001924 var_C           = dword ptr -0Ch
.text:00001924 var_8           = dword ptr -8
.text:00001924 var_4           = dword ptr -4
.text:00001924 arg_0           = dword ptr  8
.text:00001924
.text:00001924                 push    ebp
.text:00001925                 mov     ebp, esp
.text:00001927                 sub     esp, 0ECh
.text:0000192D                 push    edi             ; struct UString *
.text:0000192E                 push    ecx
.text:0000192F                 lea     edi, [ebp+var_EC]
.text:00001935                 mov     ecx, 3Bh ; ';'
.text:0000193A                 mov     eax, 0CCCCCCCCh
.text:0000193F                 rep stosd
.text:00001941                 pop     ecx
.text:00001942                 mov     [ebp+var_4], ecx
.text:00001945                 mov     eax, [ebp+var_4]
.text:00001948                 add     eax, 8
.text:0000194B                 mov     [ebp+var_8], eax
.text:0000194E                 mov     ecx, [ebp+var_8]
.text:00001951                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:00001956                 mov     [ebp+var_C], eax
.text:00001959                 cmp     [ebp+var_C], 1
.text:0000195D                 jnb     short loc_197C
.text:0000195F                 push    0
.text:00001961                 push    offset $SG77584 ; "The command must be spcified"
.text:00001966                 lea     ecx, [ebp+var_50]
.text:00001969                 call    ??0CArcCmdLineException@@QAE@PBDPB_W@Z ; CArcCmdLineException::CArcCmdLineException(char const *,wchar_t const *)
.text:0000196E                 push    offset __TI2?AUCArcCmdLineException@@
.text:00001973                 lea     ecx, [ebp+var_50]
.text:00001976                 push    ecx
.text:00001977                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:0000197C ; ---------------------------------------------------------------------------
.text:0000197C
.text:0000197C loc_197C:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+39j
.text:0000197C                 mov     edx, [ebp+arg_0]
.text:0000197F                 add     edx, 24h ; '$'
.text:00001982                 push    edx
.text:00001983                 push    0
.text:00001985                 mov     ecx, [ebp+var_8]
.text:00001988                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:0000198D                 push    eax
.text:0000198E                 call    ?ParseArchiveCommand@@YG_NABVUString@@AAUCArcCommand@@@Z ; ParseArchiveCommand(UString const &,CArcCommand &)
.text:00001993                 movzx   eax, al
.text:00001996                 test    eax, eax
.text:00001998                 jnz     short loc_19C7
.text:0000199A                 push    0
.text:0000199C                 mov     ecx, [ebp+var_8]
.text:0000199F                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:000019A4                 mov     ecx, eax
.text:000019A6                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000019AB                 push    eax
.text:000019AC                 push    offset $SG77588 ; "Unsupported command:"
.text:000019B1                 lea     ecx, [ebp+var_5C]
.text:000019B4                 call    ??0CArcCmdLineException@@QAE@PBDPB_W@Z ; CArcCmdLineException::CArcCmdLineException(char const *,wchar_t const *)
.text:000019B9                 push    offset __TI2?AUCArcCmdLineException@@
.text:000019BE                 lea     ecx, [ebp+var_5C]
.text:000019C1                 push    ecx
.text:000019C2                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:000019C7 ; ---------------------------------------------------------------------------
.text:000019C7
.text:000019C7 loc_19C7:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+74j
.text:000019C7                 push    1Dh
.text:000019C9                 mov     ecx, [ebp+var_4]
.text:000019CC                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:000019D1                 movzx   edx, byte ptr [eax]
.text:000019D4                 test    edx, edx
.text:000019D6                 jz      short loc_19F1
.text:000019D8                 push    1Dh
.text:000019DA                 mov     ecx, [ebp+var_4]
.text:000019DD                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:000019E2                 add     eax, 8
.text:000019E5                 push    eax
.text:000019E6                 mov     ecx, [ebp+arg_0]
.text:000019E9                 add     ecx, 48h ; 'H'
.text:000019EC                 call    ??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z ; CObjectVector<UString>::operator=(CObjectVector<UString> const &)
.text:000019F1
.text:000019F1 loc_19F1:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+B2j
.text:000019F1                 push    28h ; '('
.text:000019F3                 mov     ecx, [ebp+var_4]
.text:000019F6                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:000019FB                 movzx   eax, byte ptr [eax]
.text:000019FE                 test    eax, eax
.text:00001A00                 jz      short loc_1A2A
.text:00001A02                 mov     ecx, [ebp+arg_0]
.text:00001A05                 mov     byte ptr [ecx+89h], 1
.text:00001A0C                 push    28h ; '('
.text:00001A0E                 mov     ecx, [ebp+var_4]
.text:00001A11                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00001A16                 movzx   edx, byte ptr [eax+1]
.text:00001A1A                 neg     edx
.text:00001A1C                 sbb     edx, edx
.text:00001A1E                 add     edx, 1
.text:00001A21                 mov     eax, [ebp+arg_0]
.text:00001A24                 mov     [eax+88h], dl
.text:00001A2A
.text:00001A2A loc_1A2A:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+DCj
.text:00001A2A                 mov     [ebp+var_10], 0
.text:00001A31                 push    29h ; ')'
.text:00001A33                 mov     ecx, [ebp+var_4]
.text:00001A36                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00001A3B                 mov     cl, [eax]
.text:00001A3D                 mov     [ebp+var_11], cl
.text:00001A40                 movzx   edx, [ebp+var_11]
.text:00001A44                 test    edx, edx
.text:00001A46                 jz      short loc_1AB9
.text:00001A48                 mov     [ebp+var_10], 2
.text:00001A4F                 push    0
.text:00001A51                 push    29h ; ')'
.text:00001A53                 mov     ecx, [ebp+var_4]
.text:00001A56                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00001A5B                 add     eax, 8
.text:00001A5E                 mov     ecx, eax
.text:00001A60                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00001A65                 mov     [ebp+var_18], eax
.text:00001A68                 mov     ecx, [ebp+var_18] ; this
.text:00001A6B                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:00001A70                 movzx   eax, al
.text:00001A73                 test    eax, eax
.text:00001A75                 jnz     short loc_1AB9
.text:00001A77                 push    offset $SG77597 ; Str2
.text:00001A7C                 mov     ecx, [ebp+var_18]
.text:00001A7F                 push    ecx             ; int
.text:00001A80                 call    ??8@YG_NABVUString@@PB_W@Z ; operator==(UString const &,wchar_t const *)
.text:00001A85                 movzx   edx, al
.text:00001A88                 test    edx, edx
.text:00001A8A                 jz      short loc_1A95
.text:00001A8C                 mov     [ebp+var_10], 1
.text:00001A93                 jmp     short loc_1AB9
.text:00001A95 ; ---------------------------------------------------------------------------
.text:00001A95
.text:00001A95 loc_1A95:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+166j
.text:00001A95                 mov     ecx, [ebp+var_18]
.text:00001A98                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00001A9D                 push    eax
.text:00001A9E                 push    offset $SG77601 ; "Unsupported -spf:"
.text:00001AA3                 lea     ecx, [ebp+var_68]
.text:00001AA6                 call    ??0CArcCmdLineException@@QAE@PBDPB_W@Z ; CArcCmdLineException::CArcCmdLineException(char const *,wchar_t const *)
.text:00001AAB                 push    offset __TI2?AUCArcCmdLineException@@
.text:00001AB0                 lea     eax, [ebp+var_68]
.text:00001AB3                 push    eax
.text:00001AB4                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:00001AB9 ; ---------------------------------------------------------------------------
.text:00001AB9
.text:00001AB9 loc_1AB9:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+122j
.text:00001AB9                                         ; CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+151j ...
.text:00001AB9                 push    19h
.text:00001ABB                 mov     ecx, [ebp+var_4]
.text:00001ABE                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00001AC3                 movzx   ecx, byte ptr [eax]
.text:00001AC6                 test    ecx, ecx
.text:00001AC8                 jz      short loc_1AE2
.text:00001ACA                 push    19h
.text:00001ACC                 mov     ecx, [ebp+var_4]
.text:00001ACF                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00001AD4                 mov     edx, [eax+4]
.text:00001AD7                 push    edx
.text:00001AD8                 call    ?GetRecursedTypeFromIndex@@YG?AW4EEnum@NRecursedType@@H@Z ; GetRecursedTypeFromIndex(int)
.text:00001ADD                 mov     [ebp+var_1C], eax
.text:00001AE0                 jmp     short loc_1AE9
.text:00001AE2 ; ---------------------------------------------------------------------------
.text:00001AE2
.text:00001AE2 loc_1AE2:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+1A4j
.text:00001AE2                 mov     [ebp+var_1C], 2
.text:00001AE9
.text:00001AE9 loc_1AE9:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+1BCj
.text:00001AE9                 mov     [ebp+var_1D], 1
.text:00001AED                 push    27h ; '''
.text:00001AEF                 mov     ecx, [ebp+var_4]
.text:00001AF2                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00001AF7                 movzx   eax, byte ptr [eax]
.text:00001AFA                 test    eax, eax
.text:00001AFC                 jz      short loc_1B02
.text:00001AFE                 mov     [ebp+var_1D], 0
.text:00001B02
.text:00001B02 loc_1B02:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+1D8j
.text:00001B02                 push    0FFFFFFFFh
.text:00001B04                 push    1
.text:00001B06                 push    22h ; '"'
.text:00001B08                 mov     ecx, [ebp+var_4]
.text:00001B0B                 push    ecx
.text:00001B0C                 call    ?FindCharset@@YGHABVCParser@NCommandLineParser@@I_NH@Z ; FindCharset(NCommandLineParser::CParser const &,uint,bool,int)
.text:00001B11                 mov     ds:?g_CodePage@@3HA, eax ; int g_CodePage
.text:00001B16                 push    0FDE9h
.text:00001B1B                 push    0
.text:00001B1D                 push    21h ; '!'
.text:00001B1F                 mov     edx, [ebp+var_4]
.text:00001B22                 push    edx
.text:00001B23                 call    ?FindCharset@@YGHABVCParser@NCommandLineParser@@I_NH@Z ; FindCharset(NCommandLineParser::CParser const &,uint,bool,int)
.text:00001B28                 mov     [ebp+var_24], eax
.text:00001B2B                 mov     [ebp+var_25], 0
.text:00001B2F                 push    12h
.text:00001B31                 mov     ecx, [ebp+var_4]
.text:00001B34                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00001B39                 movzx   eax, byte ptr [eax]
.text:00001B3C                 test    eax, eax
.text:00001B3E                 jz      short loc_1B6D
.text:00001B40                 mov     [ebp+var_25], 1
.text:00001B44                 mov     ecx, [ebp+var_24]
.text:00001B47                 push    ecx             ; int
.text:00001B48                 movzx   edx, [ebp+var_1D]
.text:00001B4C                 push    edx             ; char
.text:00001B4D                 mov     eax, [ebp+var_1C]
.text:00001B50                 push    eax             ; int
.text:00001B51                 push    1               ; char
.text:00001B53                 push    12h
.text:00001B55                 mov     ecx, [ebp+var_4]
.text:00001B58                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00001B5D                 add     eax, 8
.text:00001B60                 push    eax             ; int
.text:00001B61                 mov     ecx, [ebp+arg_0]
.text:00001B64                 add     ecx, 0Ch
.text:00001B67                 push    ecx             ; NWildcard::CCensor *
.text:00001B68                 call    ?AddSwitchWildcardsToCensor@@YGXAAVCCensor@NWildcard@@ABV?$CObjectVector@VUString@@@@_NW4EEnum@NRecursedType@@2H@Z ; AddSwitchWildcardsToCensor(NWildcard::CCensor &,CObjectVector<UString> const &,bool,NRecursedType::EEnum,bool,int)
.text:00001B6D
.text:00001B6D loc_1B6D:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+21Aj
.text:00001B6D                 push    13h
.text:00001B6F                 mov     ecx, [ebp+var_4]
.text:00001B72                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00001B77                 movzx   edx, byte ptr [eax]
.text:00001B7A                 test    edx, edx
.text:00001B7C                 jz      short loc_1BA7
.text:00001B7E                 mov     eax, [ebp+var_24]
.text:00001B81                 push    eax             ; int
.text:00001B82                 movzx   ecx, [ebp+var_1D]
.text:00001B86                 push    ecx             ; char
.text:00001B87                 mov     edx, [ebp+var_1C]
.text:00001B8A                 push    edx             ; int
.text:00001B8B                 push    0               ; char
.text:00001B8D                 push    13h
.text:00001B8F                 mov     ecx, [ebp+var_4]
.text:00001B92                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00001B97                 add     eax, 8
.text:00001B9A                 push    eax             ; int
.text:00001B9B                 mov     eax, [ebp+arg_0]
.text:00001B9E                 add     eax, 0Ch
.text:00001BA1                 push    eax             ; NWildcard::CCensor *
.text:00001BA2                 call    ?AddSwitchWildcardsToCensor@@YGXAAVCCensor@NWildcard@@ABV?$CObjectVector@VUString@@@@_NW4EEnum@NRecursedType@@2H@Z ; AddSwitchWildcardsToCensor(NWildcard::CCensor &,CObjectVector<UString> const &,bool,NRecursedType::EEnum,bool,int)
.text:00001BA7
.text:00001BA7 loc_1BA7:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+258j
.text:00001BA7                 mov     [ebp+var_2C], 1
.text:00001BAE                 push    16h
.text:00001BB0                 mov     ecx, [ebp+var_4]
.text:00001BB3                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00001BB8                 movzx   ecx, byte ptr [eax]
.text:00001BBB                 test    ecx, ecx
.text:00001BBD                 jnz     short loc_1BE6
.text:00001BBF                 mov     edx, [ebp+arg_0]
.text:00001BC2                 cmp     dword ptr [edx+24h], 7
.text:00001BC6                 jz      short loc_1BE6
.text:00001BC8                 mov     eax, [ebp+arg_0]
.text:00001BCB                 cmp     dword ptr [eax+24h], 8
.text:00001BCF                 jz      short loc_1BE6
.text:00001BD1                 mov     ecx, [ebp+arg_0]
.text:00001BD4                 cmp     dword ptr [ecx+24h], 9
.text:00001BD8                 jz      short loc_1BE6
.text:00001BDA                 mov     [ebp+var_E0], 1
.text:00001BE4                 jmp     short loc_1BF0
.text:00001BE6 ; ---------------------------------------------------------------------------
.text:00001BE6
.text:00001BE6 loc_1BE6:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+299j
.text:00001BE6                                         ; CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+2A2j ...
.text:00001BE6                 mov     [ebp+var_E0], 0
.text:00001BF0
.text:00001BF0 loc_1BF0:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+2C0j
.text:00001BF0                 mov     dl, byte ptr [ebp+var_E0]
.text:00001BF6                 mov     [ebp+var_2D], dl
.text:00001BF9                 mov     ecx, [ebp+arg_0]
.text:00001BFC                 add     ecx, 24h ; '$'  ; this
.text:00001BFF                 call    ?IsFromExtractGroup@CArcCommand@@QBE_NXZ ; CArcCommand::IsFromExtractGroup(void)
.text:00001C04                 mov     [ebp+var_2E], al
.text:00001C07                 movzx   eax, [ebp+var_2E]
.text:00001C0B                 test    eax, eax
.text:00001C0D                 jnz     short loc_1C24
.text:00001C0F                 mov     ecx, [ebp+arg_0]
.text:00001C12                 cmp     dword ptr [ecx+24h], 6
.text:00001C16                 jz      short loc_1C24
.text:00001C18                 mov     [ebp+var_E4], 0
.text:00001C22                 jmp     short loc_1C2E
.text:00001C24 ; ---------------------------------------------------------------------------
.text:00001C24
.text:00001C24 loc_1C24:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+2E9j
.text:00001C24                                         ; CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+2F2j
.text:00001C24                 mov     [ebp+var_E4], 1
.text:00001C2E
.text:00001C2E loc_1C2E:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+2FEj
.text:00001C2E                 mov     dl, byte ptr [ebp+var_E4]
.text:00001C34                 mov     [ebp+var_2F], dl
.text:00001C37                 mov     eax, [ebp+arg_0]
.text:00001C3A                 xor     ecx, ecx
.text:00001C3C                 cmp     dword ptr [eax+24h], 0Ah
.text:00001C40                 setz    cl
.text:00001C43                 mov     [ebp+var_30], cl
.text:00001C46                 movzx   edx, [ebp+var_2F]
.text:00001C4A                 test    edx, edx
.text:00001C4C                 jnz     short loc_1C56
.text:00001C4E                 movzx   eax, [ebp+var_30]
.text:00001C52                 test    eax, eax
.text:00001C54                 jz      short loc_1C65
.text:00001C56
.text:00001C56 loc_1C56:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+328j
.text:00001C56                 mov     ecx, [ebp+arg_0]
.text:00001C59                 movzx   edx, byte ptr [ecx+7]
.text:00001C5D                 test    edx, edx
.text:00001C5F                 jz      short loc_1C65
.text:00001C61                 mov     [ebp+var_2D], 0
.text:00001C65
.text:00001C65 loc_1C65:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+330j
.text:00001C65                                         ; CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+33Bj
.text:00001C65                 push    26h ; '&'
.text:00001C67                 mov     ecx, [ebp+var_4]
.text:00001C6A                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00001C6F                 movzx   eax, byte ptr [eax]
.text:00001C72                 test    eax, eax
.text:00001C74                 jz      short loc_1C92
.text:00001C76                 push    26h ; '&'
.text:00001C78                 mov     ecx, [ebp+var_4]
.text:00001C7B                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00001C80                 mov     ecx, [eax+4]
.text:00001C83                 push    ecx
.text:00001C84                 call    ?ParseArcNameMode@@YG?BW4EArcNameMode@@H@Z ; ParseArcNameMode(int)
.text:00001C89                 mov     edx, [ebp+arg_0]
.text:00001C8C                 mov     [edx+158h], eax
.text:00001C92
.text:00001C92 loc_1C92:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+350j
.text:00001C92                 movzx   eax, [ebp+var_2D]
.text:00001C96                 test    eax, eax
.text:00001C98                 jz      loc_1D1F
.text:00001C9E                 mov     ecx, [ebp+var_2C]
.text:00001CA1                 cmp     ecx, [ebp+var_C]
.text:00001CA4                 jb      short loc_1CC3
.text:00001CA6                 push    0
.text:00001CA8                 push    offset $SG77623 ; "Cannot find archive name"
.text:00001CAD                 lea     ecx, [ebp+var_74]
.text:00001CB0                 call    ??0CArcCmdLineException@@QAE@PBDPB_W@Z ; CArcCmdLineException::CArcCmdLineException(char const *,wchar_t const *)
.text:00001CB5                 push    offset __TI2?AUCArcCmdLineException@@
.text:00001CBA                 lea     edx, [ebp+var_74]
.text:00001CBD                 push    edx
.text:00001CBE                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:00001CC3 ; ---------------------------------------------------------------------------
.text:00001CC3
.text:00001CC3 loc_1CC3:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+380j
.text:00001CC3                 mov     eax, [ebp+var_2C]
.text:00001CC6                 mov     [ebp+var_E8], eax
.text:00001CCC                 mov     ecx, [ebp+var_2C]
.text:00001CCF                 add     ecx, 1
.text:00001CD2                 mov     [ebp+var_2C], ecx
.text:00001CD5                 mov     edx, [ebp+var_E8]
.text:00001CDB                 push    edx
.text:00001CDC                 mov     ecx, [ebp+var_8]
.text:00001CDF                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00001CE4                 push    eax
.text:00001CE5                 mov     ecx, [ebp+arg_0]
.text:00001CE8                 add     ecx, 28h ; '('
.text:00001CEB                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:00001CF0                 mov     ecx, [ebp+arg_0]
.text:00001CF3                 add     ecx, 28h ; '('  ; this
.text:00001CF6                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:00001CFB                 movzx   eax, al
.text:00001CFE                 test    eax, eax
.text:00001D00                 jz      short loc_1D1F
.text:00001D02                 push    0
.text:00001D04                 push    offset $SG77627 ; "Archive name cannot by empty"
.text:00001D09                 lea     ecx, [ebp+var_80]
.text:00001D0C                 call    ??0CArcCmdLineException@@QAE@PBDPB_W@Z ; CArcCmdLineException::CArcCmdLineException(char const *,wchar_t const *)
.text:00001D11                 push    offset __TI2?AUCArcCmdLineException@@
.text:00001D16                 lea     ecx, [ebp+var_80]
.text:00001D19                 push    ecx
.text:00001D1A                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:00001D1F ; ---------------------------------------------------------------------------
.text:00001D1F
.text:00001D1F loc_1D1F:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+374j
.text:00001D1F                                         ; CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+3DCj
.text:00001D1F                 movzx   edx, [ebp+var_30]
.text:00001D23                 test    edx, edx
.text:00001D25                 jz      short loc_1D37
.text:00001D27                 mov     eax, [ebp+arg_0]
.text:00001D2A                 add     eax, 1B4h
.text:00001D2F                 mov     [ebp+var_EC], eax
.text:00001D35                 jmp     short loc_1D41
.text:00001D37 ; ---------------------------------------------------------------------------
.text:00001D37
.text:00001D37 loc_1D37:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+401j
.text:00001D37                 mov     [ebp+var_EC], 0
.text:00001D41
.text:00001D41 loc_1D41:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+411j
.text:00001D41                 mov     ecx, [ebp+var_24]
.text:00001D44                 push    ecx             ; int
.text:00001D45                 movzx   edx, [ebp+var_25]
.text:00001D49                 push    edx             ; char
.text:00001D4A                 movzx   eax, [ebp+var_1D]
.text:00001D4E                 push    eax             ; char
.text:00001D4F                 mov     ecx, [ebp+var_1C]
.text:00001D52                 push    ecx             ; int
.text:00001D53                 mov     edx, [ebp+var_8]
.text:00001D56                 push    edx             ; int
.text:00001D57                 mov     eax, [ebp+arg_0]
.text:00001D5A                 add     eax, 0Ch
.text:00001D5D                 push    eax             ; NWildcard::CCensor *
.text:00001D5E                 mov     ecx, [ebp+var_2C]
.text:00001D61                 push    ecx             ; int
.text:00001D62                 mov     edx, [ebp+var_EC]
.text:00001D68                 push    edx             ; int
.text:00001D69                 call    ?AddToCensorFromNonSwitchesStrings@@YGXPAV?$CObjectVector@UCRenamePair@@@@IAAVCCensor@NWildcard@@ABV?$CObjectVector@VUString@@@@W4EEnum@NRecursedType@@_N4H@Z ; AddToCensorFromNonSwitchesStrings(CObjectVector<CRenamePair> *,uint,NWildcard::CCensor &,CObjectVector<UString> const &,NRecursedType::EEnum,bool,bool,int)
.text:00001D6E                 push    0Ah
.text:00001D70                 mov     ecx, [ebp+var_4]
.text:00001D73                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00001D78                 mov     ecx, [ebp+arg_0]
.text:00001D7B                 mov     dl, [eax]
.text:00001D7D                 mov     [ecx+0Ah], dl
.text:00001D80                 push    32h ; '2'
.text:00001D82                 mov     ecx, [ebp+var_4]
.text:00001D85                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00001D8A                 mov     ecx, [ebp+arg_0]
.text:00001D8D                 mov     dl, [eax]
.text:00001D8F                 mov     [ecx+34h], dl
.text:00001D92                 mov     eax, [ebp+arg_0]
.text:00001D95                 movzx   ecx, byte ptr [eax+34h]
.text:00001D99                 test    ecx, ecx
.text:00001D9B                 jz      short loc_1DBF
.text:00001D9D                 push    0
.text:00001D9F                 push    32h ; '2'
.text:00001DA1                 mov     ecx, [ebp+var_4]
.text:00001DA4                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00001DA9                 add     eax, 8
.text:00001DAC                 mov     ecx, eax
.text:00001DAE                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00001DB3                 push    eax
.text:00001DB4                 mov     ecx, [ebp+arg_0]
.text:00001DB7                 add     ecx, 38h ; '8'
.text:00001DBA                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:00001DBF
.text:00001DBF loc_1DBF:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+477j
.text:00001DBF                 push    0Bh
.text:00001DC1                 mov     ecx, [ebp+var_4]
.text:00001DC4                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00001DC9                 mov     edx, [ebp+arg_0]
.text:00001DCC                 mov     al, [eax]
.text:00001DCE                 mov     [edx+0Bh], al
.text:00001DD1                 push    0Dh
.text:00001DD3                 mov     ecx, [ebp+var_4]
.text:00001DD6                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00001DDB                 movzx   ecx, byte ptr [eax]
.text:00001DDE                 test    ecx, ecx
.text:00001DE0                 jz      short loc_1E07
.text:00001DE2                 push    0
.text:00001DE4                 push    0Dh
.text:00001DE6                 mov     ecx, [ebp+var_4]
.text:00001DE9                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00001DEE                 add     eax, 8
.text:00001DF1                 mov     ecx, eax
.text:00001DF3                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00001DF8                 push    eax
.text:00001DF9                 mov     ecx, [ebp+arg_0]
.text:00001DFC                 add     ecx, 1E4h
.text:00001E02                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:00001E07
.text:00001E07 loc_1E07:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+4BCj
.text:00001E07                 push    0Eh
.text:00001E09                 mov     ecx, [ebp+var_4]
.text:00001E0C                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00001E11                 add     eax, 8
.text:00001E14                 push    eax
.text:00001E15                 mov     ecx, [ebp+arg_0]
.text:00001E18                 add     ecx, 1F0h
.text:00001E1E                 call    ??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z ; CObjectVector<UString>::operator=(CObjectVector<UString> const &)
.text:00001E23                 mov     edx, [ebp+arg_0]
.text:00001E26                 add     edx, 7Ch ; '|'
.text:00001E29                 push    edx
.text:00001E2A                 mov     eax, [ebp+var_4]
.text:00001E2D                 push    eax
.text:00001E2E                 call    ?SetMethodOptions@@YGXABVCParser@NCommandLineParser@@AAV?$CObjectVector@UCProperty@@@@@Z ; SetMethodOptions(NCommandLineParser::CParser const &,CObjectVector<CProperty> &)
.text:00001E33                 push    2Ch ; ','
.text:00001E35                 mov     ecx, [ebp+var_4]
.text:00001E38                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00001E3D                 movzx   ecx, byte ptr [eax]
.text:00001E40                 test    ecx, ecx
.text:00001E42                 jz      short loc_1E52
.text:00001E44                 mov     ecx, [ebp+arg_0]
.text:00001E47                 add     ecx, 0ACh ; 'Â¼' ; this
.text:00001E4D                 call    ?SetTrueTrue@CBoolPair@@QAEXXZ ; CBoolPair::SetTrueTrue(void)
.text:00001E52
.text:00001E52 loc_1E52:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+51Ej
.text:00001E52                 mov     edx, [ebp+arg_0]
.text:00001E55                 add     edx, 0AEh ; 'Â«'
.text:00001E5B                 push    edx
.text:00001E5C                 push    2Dh ; '-'
.text:00001E5E                 mov     eax, [ebp+var_4]
.text:00001E61                 push    eax
.text:00001E62                 call    ?SetBoolPair@@YGXAAVCParser@NCommandLineParser@@IAAUCBoolPair@@@Z ; SetBoolPair(NCommandLineParser::CParser &,uint,CBoolPair &)
.text:00001E67                 mov     ecx, [ebp+arg_0]
.text:00001E6A                 add     ecx, 0B0h ; 'Â¦'
.text:00001E70                 push    ecx
.text:00001E71                 push    2Ah ; '*'
.text:00001E73                 mov     edx, [ebp+var_4]
.text:00001E76                 push    edx
.text:00001E77                 call    ?SetBoolPair@@YGXAAVCParser@NCommandLineParser@@IAAUCBoolPair@@@Z ; SetBoolPair(NCommandLineParser::CParser &,uint,CBoolPair &)
.text:00001E7C                 mov     eax, [ebp+arg_0]
.text:00001E7F                 add     eax, 0B2h ; 'Â¦'
.text:00001E84                 push    eax
.text:00001E85                 push    2Bh ; '+'
.text:00001E87                 mov     ecx, [ebp+var_4]
.text:00001E8A                 push    ecx
.text:00001E8B                 call    ?SetBoolPair@@YGXAAVCParser@NCommandLineParser@@IAAUCBoolPair@@@Z ; SetBoolPair(NCommandLineParser::CParser &,uint,CBoolPair &)
.text:00001E90                 movzx   edx, [ebp+var_2F]
.text:00001E94                 test    edx, edx
.text:00001E96                 jz      loc_21AE
.text:00001E9C                 mov     eax, [ebp+arg_0]
.text:00001E9F                 add     eax, 88h ; 'Ãª'
.text:00001EA4                 mov     [ebp+var_34], eax
.text:00001EA7                 mov     ecx, [ebp+var_34]
.text:00001EAA                 add     ecx, 18h
.text:00001EAD                 mov     [ebp+var_38], ecx
.text:00001EB0                 mov     edx, [ebp+arg_0]
.text:00001EB3                 mov     ax, [edx+0ACh]
.text:00001EBA                 mov     ecx, [ebp+var_38]
.text:00001EBD                 mov     [ecx], ax
.text:00001EC0                 mov     edx, [ebp+arg_0]
.text:00001EC3                 mov     ax, [edx+0AEh]
.text:00001ECA                 mov     ecx, [ebp+var_38]
.text:00001ECD                 mov     [ecx+6], ax
.text:00001ED1                 mov     edx, [ebp+arg_0]
.text:00001ED4                 movzx   eax, byte ptr [edx+0AFh]
.text:00001EDB                 test    eax, eax
.text:00001EDD                 jnz     short loc_1EE6
.text:00001EDF                 mov     ecx, [ebp+var_38]
.text:00001EE2                 mov     byte ptr [ecx+6], 1
.text:00001EE6
.text:00001EE6 loc_1EE6:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+5B9j
.text:00001EE6                 mov     edx, [ebp+arg_0]
.text:00001EE9                 mov     ax, [edx+0B0h]
.text:00001EF0                 mov     ecx, [ebp+var_38]
.text:00001EF3                 mov     [ecx+4], ax
.text:00001EF7                 mov     edx, [ebp+arg_0]
.text:00001EFA                 movzx   eax, byte ptr [edx+0B1h]
.text:00001F01                 test    eax, eax
.text:00001F03                 jnz     short loc_1F0C
.text:00001F05                 mov     ecx, [ebp+var_38]
.text:00001F08                 mov     byte ptr [ecx+4], 1
.text:00001F0C
.text:00001F0C loc_1F0C:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+5DFj
.text:00001F0C                 mov     edx, [ebp+arg_0]
.text:00001F0F                 mov     ax, [edx+0B2h]
.text:00001F16                 mov     ecx, [ebp+var_38]
.text:00001F19                 mov     [ecx+2], ax
.text:00001F1D                 mov     edx, [ebp+arg_0]
.text:00001F20                 movzx   eax, byte ptr [edx+0B3h]
.text:00001F27                 test    eax, eax
.text:00001F29                 jnz     short loc_1F32
.text:00001F2B                 mov     ecx, [ebp+var_38]
.text:00001F2E                 mov     byte ptr [ecx+2], 1
.text:00001F32
.text:00001F32 loc_1F32:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+605j
.text:00001F32                 push    2Eh ; '.'
.text:00001F34                 mov     ecx, [ebp+var_4]
.text:00001F37                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00001F3C                 mov     edx, [ebp+var_38]
.text:00001F3F                 mov     al, [eax]
.text:00001F41                 mov     [edx+8], al
.text:00001F44                 push    2Fh ; '/'
.text:00001F46                 mov     ecx, [ebp+var_4]
.text:00001F49                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00001F4E                 mov     ecx, [ebp+var_38]
.text:00001F51                 mov     dl, [eax]
.text:00001F53                 mov     [ecx+9], dl
.text:00001F56                 push    2
.text:00001F58                 mov     ecx, [ebp+arg_0]
.text:00001F5B                 add     ecx, 0Ch
.text:00001F5E                 call    ?AddPathsToCensor@CCensor@NWildcard@@QAEXW4ECensorPathMode@2@@Z ; NWildcard::CCensor::AddPathsToCensor(NWildcard::ECensorPathMode)
.text:00001F63                 mov     ecx, [ebp+arg_0]
.text:00001F66                 add     ecx, 0Ch        ; this
.text:00001F69                 call    ?ExtendExclude@CCensor@NWildcard@@QAEXXZ ; NWildcard::CCensor::ExtendExclude(void)
.text:00001F6E                 mov     ecx, [ebp+arg_0]
.text:00001F71                 add     ecx, 0Ch        ; this
.text:00001F74                 call    ?AllAreRelative@CCensor@NWildcard@@QBE_NXZ ; NWildcard::CCensor::AllAreRelative(void)
.text:00001F79                 movzx   eax, al
.text:00001F7C                 test    eax, eax
.text:00001F7E                 jnz     short loc_1FA3
.text:00001F80                 push    0
.text:00001F82                 push    offset $SG77640 ; "Cannot use absolute pathnames for this "...
.text:00001F87                 lea     ecx, [ebp+var_8C]
.text:00001F8D                 call    ??0CArcCmdLineException@@QAE@PBDPB_W@Z ; CArcCmdLineException::CArcCmdLineException(char const *,wchar_t const *)
.text:00001F92                 push    offset __TI2?AUCArcCmdLineException@@
.text:00001F97                 lea     ecx, [ebp+var_8C]
.text:00001F9D                 push    ecx
.text:00001F9E                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:00001FA3 ; ---------------------------------------------------------------------------
.text:00001FA3
.text:00001FA3 loc_1FA3:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+65Aj
.text:00001FA3                 mov     edx, [ebp+arg_0]
.text:00001FA6                 add     edx, 58h ; 'X'
.text:00001FA9                 mov     [ebp+var_3C], edx
.text:00001FAC                 push    14h
.text:00001FAE                 mov     ecx, [ebp+var_4]
.text:00001FB1                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00001FB6                 movzx   eax, byte ptr [eax]
.text:00001FB9                 test    eax, eax
.text:00001FBB                 jz      short loc_1FE1
.text:00001FBD                 mov     ecx, [ebp+var_24]
.text:00001FC0                 push    ecx             ; int
.text:00001FC1                 movzx   edx, [ebp+var_1D]
.text:00001FC5                 push    edx             ; char
.text:00001FC6                 push    2               ; int
.text:00001FC8                 push    1               ; char
.text:00001FCA                 push    14h
.text:00001FCC                 mov     ecx, [ebp+var_4]
.text:00001FCF                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00001FD4                 add     eax, 8
.text:00001FD7                 push    eax             ; int
.text:00001FD8                 mov     eax, [ebp+var_3C]
.text:00001FDB                 push    eax             ; NWildcard::CCensor *
.text:00001FDC                 call    ?AddSwitchWildcardsToCensor@@YGXAAVCCensor@NWildcard@@ABV?$CObjectVector@VUString@@@@_NW4EEnum@NRecursedType@@2H@Z ; AddSwitchWildcardsToCensor(NWildcard::CCensor &,CObjectVector<UString> const &,bool,NRecursedType::EEnum,bool,int)
.text:00001FE1
.text:00001FE1 loc_1FE1:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+697j
.text:00001FE1                 push    15h
.text:00001FE3                 mov     ecx, [ebp+var_4]
.text:00001FE6                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00001FEB                 movzx   ecx, byte ptr [eax]
.text:00001FEE                 test    ecx, ecx
.text:00001FF0                 jz      short loc_2016
.text:00001FF2                 mov     edx, [ebp+var_24]
.text:00001FF5                 push    edx             ; int
.text:00001FF6                 movzx   eax, [ebp+var_1D]
.text:00001FFA                 push    eax             ; char
.text:00001FFB                 push    2               ; int
.text:00001FFD                 push    0               ; char
.text:00001FFF                 push    15h
.text:00002001                 mov     ecx, [ebp+var_4]
.text:00002004                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00002009                 add     eax, 8
.text:0000200C                 push    eax             ; int
.text:0000200D                 mov     ecx, [ebp+var_3C]
.text:00002010                 push    ecx             ; NWildcard::CCensor *
.text:00002011                 call    ?AddSwitchWildcardsToCensor@@YGXAAVCCensor@NWildcard@@ABV?$CObjectVector@VUString@@@@_NW4EEnum@NRecursedType@@2H@Z ; AddSwitchWildcardsToCensor(NWildcard::CCensor &,CObjectVector<UString> const &,bool,NRecursedType::EEnum,bool,int)
.text:00002016
.text:00002016 loc_2016:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+6CCj
.text:00002016                 movzx   edx, [ebp+var_2D]
.text:0000201A                 test    edx, edx
.text:0000201C                 jz      short loc_2037
.text:0000201E                 movzx   eax, [ebp+var_1D]
.text:00002022                 push    eax             ; char
.text:00002023                 push    2               ; int
.text:00002025                 push    1               ; char
.text:00002027                 mov     ecx, [ebp+arg_0]
.text:0000202A                 add     ecx, 28h ; '('
.text:0000202D                 push    ecx             ; struct UString *
.text:0000202E                 mov     edx, [ebp+var_3C]
.text:00002031                 push    edx             ; NWildcard::CCensor *
.text:00002032                 call    ?AddNameToCensor@@YGXAAVCCensor@NWildcard@@ABVUString@@_NW4EEnum@NRecursedType@@2@Z ; AddNameToCensor(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)
.text:00002037
.text:00002037 loc_2037:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+6F8j
.text:00002037                 push    0               ; struct UString *
.text:00002039                 mov     ecx, [ebp+var_3C]
.text:0000203C                 call    ?AddPathsToCensor@CCensor@NWildcard@@QAEXW4ECensorPathMode@2@@Z ; NWildcard::CCensor::AddPathsToCensor(NWildcard::ECensorPathMode)
.text:00002041                 mov     eax, [ebp+var_3C]
.text:00002044                 push    eax             ; struct NWildcard::CCensor *
.text:00002045                 call    ?ConvertToLongNames@@YGXAAVCCensor@NWildcard@@@Z ; ConvertToLongNames(NWildcard::CCensor &)
.text:0000204A                 mov     ecx, [ebp+var_3C] ; this
.text:0000204D                 call    ?ExtendExclude@CCensor@NWildcard@@QAEXXZ ; NWildcard::CCensor::ExtendExclude(void)
.text:00002052                 mov     ecx, [ebp+arg_0]
.text:00002055                 movzx   edx, byte ptr [ecx+7]
.text:00002059                 test    edx, edx
.text:0000205B                 jz      short loc_207D
.text:0000205D                 push    1Eh
.text:0000205F                 mov     ecx, [ebp+var_4]
.text:00002062                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00002067                 add     eax, 8
.text:0000206A                 mov     ecx, eax
.text:0000206C                 call    ?Front@?$CObjectVector@VUString@@@@QBEABVUString@@XZ ; CObjectVector<UString>::Front(void)
.text:00002071                 push    eax
.text:00002072                 mov     ecx, [ebp+arg_0]
.text:00002075                 add     ecx, 70h ; 'p'
.text:00002078                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:0000207D
.text:0000207D loc_207D:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+737j
.text:0000207D                 movzx   eax, [ebp+var_2E]
.text:00002081                 test    eax, eax
.text:00002083                 jz      loc_2168
.text:00002089                 mov     ecx, [ebp+arg_0]
.text:0000208C                 movzx   edx, byte ptr [ecx+8]
.text:00002090                 test    edx, edx
.text:00002092                 jz      short loc_20CF
.text:00002094                 mov     eax, [ebp+arg_0]
.text:00002097                 movzx   ecx, byte ptr [eax+5]
.text:0000209B                 test    ecx, ecx
.text:0000209D                 jz      short loc_20CF
.text:0000209F                 mov     edx, [ebp+arg_0]
.text:000020A2                 movzx   eax, byte ptr [edx+6]
.text:000020A6                 test    eax, eax
.text:000020A8                 jz      short loc_20CF
.text:000020AA                 push    0
.text:000020AC                 mov     ecx, ds:_kSameTerminalError
.text:000020B2                 push    ecx
.text:000020B3                 lea     ecx, [ebp+var_98]
.text:000020B9                 call    ??0CArcCmdLineException@@QAE@PBDPB_W@Z ; CArcCmdLineException::CArcCmdLineException(char const *,wchar_t const *)
.text:000020BE                 push    offset __TI2?AUCArcCmdLineException@@
.text:000020C3                 lea     edx, [ebp+var_98]
.text:000020C9                 push    edx
.text:000020CA                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:000020CF ; ---------------------------------------------------------------------------
.text:000020CF
.text:000020CF loc_20CF:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+76Ej
.text:000020CF                                         ; CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+779j ...
.text:000020CF                 push    10h
.text:000020D1                 mov     ecx, [ebp+var_4]
.text:000020D4                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:000020D9                 movzx   eax, byte ptr [eax]
.text:000020DC                 test    eax, eax
.text:000020DE                 jz      short loc_210E
.text:000020E0                 push    0
.text:000020E2                 push    10h
.text:000020E4                 mov     ecx, [ebp+var_4]
.text:000020E7                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:000020EC                 add     eax, 8
.text:000020EF                 mov     ecx, eax
.text:000020F1                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:000020F6                 push    eax
.text:000020F7                 mov     ecx, [ebp+var_34]
.text:000020FA                 add     ecx, 0Ch
.text:000020FD                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:00002102                 mov     ecx, [ebp+var_34]
.text:00002105                 add     ecx, 0Ch
.text:00002108                 push    ecx             ; this
.text:00002109                 call    ?NormalizeDirPathPrefix@NName@NFile@NWindows@@YGXAAVUString@@@Z ; NWindows::NFile::NName::NormalizeDirPathPrefix(UString &)
.text:0000210E
.text:0000210E loc_210E:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+7BAj
.text:0000210E                 mov     edx, [ebp+var_34]
.text:00002111                 mov     dword ptr [edx+8], 0
.text:00002118                 push    0Ch
.text:0000211A                 mov     ecx, [ebp+var_4]
.text:0000211D                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00002122                 movzx   eax, byte ptr [eax]
.text:00002125                 test    eax, eax
.text:00002127                 jz      short loc_214C
.text:00002129                 push    0Ch
.text:0000212B                 mov     ecx, [ebp+var_4]
.text:0000212E                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00002133                 mov     ecx, [eax+4]
.text:00002136                 mov     edx, [ebp+var_34]
.text:00002139                 mov     eax, _k_OverwriteModes[ecx*4]
.text:00002140                 mov     [edx+8], eax
.text:00002143                 mov     ecx, [ebp+var_34]
.text:00002146                 mov     byte ptr [ecx+3], 1
.text:0000214A                 jmp     short loc_2168
.text:0000214C ; ---------------------------------------------------------------------------
.text:0000214C
.text:0000214C loc_214C:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+803j
.text:0000214C                 mov     edx, [ebp+arg_0]
.text:0000214F                 movzx   eax, byte ptr [edx+0Ah]
.text:00002153                 test    eax, eax
.text:00002155                 jz      short loc_2168
.text:00002157                 mov     ecx, [ebp+var_34]
.text:0000215A                 mov     dword ptr [ecx+8], 1
.text:00002161                 mov     edx, [ebp+var_34]
.text:00002164                 mov     byte ptr [edx+3], 1
.text:00002168
.text:00002168 loc_2168:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+75Fj
.text:00002168                                         ; CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+826j ...
.text:00002168                 mov     ecx, [ebp+arg_0]
.text:0000216B                 add     ecx, 24h ; '$'
.text:0000216E                 call    ?GetPathMode@CArcCommand@@QBE?AW4EEnum@NPathMode@NExtract@@XZ ; CArcCommand::GetPathMode(void)
.text:00002173                 mov     ecx, [ebp+var_34]
.text:00002176                 mov     [ecx+4], eax
.text:00002179                 cmp     [ebp+var_10], 2
.text:0000217D                 jnz     short loc_2192
.text:0000217F                 mov     edx, [ebp+var_34]
.text:00002182                 mov     dword ptr [edx+4], 3
.text:00002189                 mov     eax, [ebp+var_34]
.text:0000218C                 mov     byte ptr [eax+2], 1
.text:00002190                 jmp     short loc_21A9
.text:00002192 ; ---------------------------------------------------------------------------
.text:00002192
.text:00002192 loc_2192:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+859j
.text:00002192                 cmp     [ebp+var_10], 1
.text:00002196                 jnz     short loc_21A9
.text:00002198                 mov     ecx, [ebp+var_34]
.text:0000219B                 mov     dword ptr [ecx+4], 0
.text:000021A2                 mov     edx, [ebp+var_34]
.text:000021A5                 mov     byte ptr [edx+2], 1
.text:000021A9
.text:000021A9 loc_21A9:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+86Cj
.text:000021A9                                         ; CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+872j
.text:000021A9                 jmp     loc_2598
.text:000021AE ; ---------------------------------------------------------------------------
.text:000021AE
.text:000021AE loc_21AE:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+572j
.text:000021AE                 mov     ecx, [ebp+arg_0]
.text:000021B1                 add     ecx, 24h ; '$'  ; this
.text:000021B4                 call    ?IsFromUpdateGroup@CArcCommand@@QBE_NXZ ; CArcCommand::IsFromUpdateGroup(void)
.text:000021B9                 movzx   eax, al
.text:000021BC                 test    eax, eax
.text:000021BE                 jz      loc_245E
.text:000021C4                 push    14h
.text:000021C6                 mov     ecx, [ebp+var_4]
.text:000021C9                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:000021CE                 movzx   ecx, byte ptr [eax]
.text:000021D1                 test    ecx, ecx
.text:000021D3                 jz      short loc_21F8
.text:000021D5                 push    0
.text:000021D7                 push    offset $SG77663 ; "-ai switch is not supported for this co"...
.text:000021DC                 lea     ecx, [ebp+var_A4]
.text:000021E2                 call    ??0CArcCmdLineException@@QAE@PBDPB_W@Z ; CArcCmdLineException::CArcCmdLineException(char const *,wchar_t const *)
.text:000021E7                 push    offset __TI2?AUCArcCmdLineException@@
.text:000021EC                 lea     edx, [ebp+var_A4]
.text:000021F2                 push    edx
.text:000021F3                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:000021F8 ; ---------------------------------------------------------------------------
.text:000021F8
.text:000021F8 loc_21F8:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+8AFj
.text:000021F8                 mov     eax, [ebp+arg_0]
.text:000021FB                 add     eax, 0B8h ; '+'
.text:00002200                 mov     [ebp+var_40], eax
.text:00002203                 mov     ecx, [ebp+var_40]
.text:00002206                 push    ecx
.text:00002207                 mov     edx, [ebp+var_4]
.text:0000220A                 push    edx
.text:0000220B                 mov     eax, [ebp+arg_0]
.text:0000220E                 mov     ecx, [eax+24h]
.text:00002211                 push    ecx
.text:00002212                 call    ?SetAddCommandOptions@@YGXW4EEnum@NCommandType@@ABVCParser@NCommandLineParser@@AAUCUpdateOptions@@@Z ; SetAddCommandOptions(NCommandType::EEnum,NCommandLineParser::CParser const &,CUpdateOptions &)
.text:00002217                 mov     edx, [ebp+arg_0]
.text:0000221A                 add     edx, 7Ch ; '|'
.text:0000221D                 push    edx
.text:0000221E                 mov     ecx, [ebp+var_40]
.text:00002221                 add     ecx, 28h ; '('
.text:00002224                 call    ??4?$CObjectVector@UCProperty@@@@QAEAAV0@ABV0@@Z ; CObjectVector<CProperty>::operator=(CObjectVector<CProperty> const &)
.text:00002229                 push    24h ; '$'
.text:0000222B                 mov     ecx, [ebp+var_4]
.text:0000222E                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00002233                 movzx   eax, byte ptr [eax]
.text:00002236                 test    eax, eax
.text:00002238                 jz      short loc_2244
.text:0000223A                 mov     ecx, [ebp+var_40]
.text:0000223D                 mov     byte ptr [ecx+0B4h], 1
.text:00002244
.text:00002244 loc_2244:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+914j
.text:00002244                 mov     edx, [ebp+var_40]
.text:00002247                 mov     eax, [ebp+var_10]
.text:0000224A                 mov     [edx+0E0h], eax
.text:00002250                 mov     ecx, [ebp+arg_0]
.text:00002253                 mov     dx, [ecx+0AEh]
.text:0000225A                 mov     eax, [ebp+var_40]
.text:0000225D                 mov     [eax+0F2h], dx
.text:00002264                 mov     ecx, [ebp+arg_0]
.text:00002267                 mov     dx, [ecx+0ACh]
.text:0000226E                 mov     eax, [ebp+var_40]
.text:00002271                 mov     [eax+0F0h], dx
.text:00002278                 mov     ecx, [ebp+arg_0]
.text:0000227B                 mov     dx, [ecx+0B0h]
.text:00002282                 mov     eax, [ebp+var_40]
.text:00002285                 mov     [eax+0F4h], dx
.text:0000228C                 mov     ecx, [ebp+arg_0]
.text:0000228F                 mov     dx, [ecx+0B2h]
.text:00002296                 mov     eax, [ebp+var_40]
.text:00002299                 mov     [eax+0F6h], dx
.text:000022A0                 push    1Ch
.text:000022A2                 mov     ecx, [ebp+var_4]
.text:000022A5                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:000022AA                 mov     ecx, [ebp+var_40]
.text:000022AD                 mov     dl, [eax]
.text:000022AF                 mov     [ecx+0C5h], dl
.text:000022B5                 mov     eax, [ebp+var_40]
.text:000022B8                 movzx   ecx, byte ptr [eax+0C5h]
.text:000022BF                 test    ecx, ecx
.text:000022C1                 jz      short loc_2328
.text:000022C3                 push    1Ch
.text:000022C5                 mov     ecx, [ebp+var_4]
.text:000022C8                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:000022CD                 add     eax, 8
.text:000022D0                 mov     ecx, eax
.text:000022D2                 call    ?Front@?$CObjectVector@VUString@@@@QBEABVUString@@XZ ; CObjectVector<UString>::Front(void)
.text:000022D7                 push    eax
.text:000022D8                 mov     ecx, [ebp+var_40]
.text:000022DB                 add     ecx, 0C8h ; '+'
.text:000022E1                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:000022E6                 mov     ecx, [ebp+var_40]
.text:000022E9                 add     ecx, 0C8h ; '+' ; this
.text:000022EF                 call    ?Len@UString@@QBEIXZ ; UString::Len(void)
.text:000022F4                 test    eax, eax
.text:000022F6                 jbe     short loc_2328
.text:000022F8                 mov     ecx, [ebp+var_40]
.text:000022FB                 add     ecx, 0C8h ; '+'
.text:00002301                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00002306                 movzx   edx, word ptr [eax]
.text:00002309                 cmp     edx, 2Eh ; '.'
.text:0000230C                 jnz     short loc_2328
.text:0000230E                 mov     eax, [ebp+var_40]
.text:00002311                 mov     byte ptr [eax+0C6h], 1
.text:00002318                 push    0               ; unsigned int
.text:0000231A                 mov     ecx, [ebp+var_40]
.text:0000231D                 add     ecx, 0C8h ; '+' ; this
.text:00002323                 call    ?Delete@UString@@QAEXI@Z ; UString::Delete(uint)
.text:00002328
.text:00002328 loc_2328:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+99Dj
.text:00002328                                         ; CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+9D2j ...
.text:00002328                 mov     ecx, [ebp+var_40]
.text:0000232B                 mov     edx, [ebp+arg_0]
.text:0000232E                 mov     al, [edx+8]
.text:00002331                 mov     [ecx+0C4h], al
.text:00002337                 mov     ecx, [ebp+var_40]
.text:0000233A                 mov     edx, [ebp+arg_0]
.text:0000233D                 mov     al, [edx+7]
.text:00002340                 mov     [ecx+0B5h], al
.text:00002346                 push    30h ; '0'
.text:00002348                 mov     ecx, [ebp+var_4]
.text:0000234B                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00002350                 mov     ecx, [ebp+var_40]
.text:00002353                 mov     dl, [eax]
.text:00002355                 mov     [ecx+0F8h], dl
.text:0000235B                 push    31h ; '1'
.text:0000235D                 mov     ecx, [ebp+var_4]
.text:00002360                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00002365                 mov     ecx, [ebp+var_40]
.text:00002368                 mov     dl, [eax]
.text:0000236A                 mov     [ecx+0F9h], dl
.text:00002370                 mov     eax, [ebp+var_40]
.text:00002373                 movzx   ecx, byte ptr [eax+0C4h]
.text:0000237A                 test    ecx, ecx
.text:0000237C                 jz      short loc_23AF
.text:0000237E                 mov     edx, [ebp+var_40]
.text:00002381                 movzx   eax, byte ptr [edx+0C5h]
.text:00002388                 test    eax, eax
.text:0000238A                 jz      short loc_23AF
.text:0000238C                 push    0
.text:0000238E                 push    offset $SG77672 ; "stdout mode and email mode cannot be co"...
.text:00002393                 lea     ecx, [ebp+var_B0]
.text:00002399                 call    ??0CArcCmdLineException@@QAE@PBDPB_W@Z ; CArcCmdLineException::CArcCmdLineException(char const *,wchar_t const *)
.text:0000239E                 push    offset __TI2?AUCArcCmdLineException@@
.text:000023A3                 lea     ecx, [ebp+var_B0]
.text:000023A9                 push    ecx
.text:000023AA                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:000023AF ; ---------------------------------------------------------------------------
.text:000023AF
.text:000023AF loc_23AF:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+A58j
.text:000023AF                                         ; CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+A66j
.text:000023AF                 mov     edx, [ebp+var_40]
.text:000023B2                 movzx   eax, byte ptr [edx+0C4h]
.text:000023B9                 test    eax, eax
.text:000023BB                 jz      short loc_23EC
.text:000023BD                 mov     ecx, [ebp+arg_0]
.text:000023C0                 movzx   edx, byte ptr [ecx+5]
.text:000023C4                 test    edx, edx
.text:000023C6                 jz      short loc_23EC
.text:000023C8                 push    0
.text:000023CA                 mov     eax, ds:_kTerminalOutError
.text:000023CF                 push    eax
.text:000023D0                 lea     ecx, [ebp+var_BC]
.text:000023D6                 call    ??0CArcCmdLineException@@QAE@PBDPB_W@Z ; CArcCmdLineException::CArcCmdLineException(char const *,wchar_t const *)
.text:000023DB                 push    offset __TI2?AUCArcCmdLineException@@
.text:000023E0                 lea     ecx, [ebp+var_BC]
.text:000023E6                 push    ecx
.text:000023E7                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:000023EC ; ---------------------------------------------------------------------------
.text:000023EC
.text:000023EC loc_23EC:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+A97j
.text:000023EC                                         ; CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+AA2j
.text:000023EC                 mov     edx, [ebp+var_40]
.text:000023EF                 movzx   eax, byte ptr [edx+0B5h]
.text:000023F6                 test    eax, eax
.text:000023F8                 jz      short loc_241D
.text:000023FA                 push    1Eh
.text:000023FC                 mov     ecx, [ebp+var_4]
.text:000023FF                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00002404                 add     eax, 8
.text:00002407                 mov     ecx, eax
.text:00002409                 call    ?Front@?$CObjectVector@VUString@@@@QBEABVUString@@XZ ; CObjectVector<UString>::Front(void)
.text:0000240E                 push    eax
.text:0000240F                 mov     ecx, [ebp+var_40]
.text:00002412                 add     ecx, 0B8h ; '+'
.text:00002418                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:0000241D
.text:0000241D loc_241D:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+AD4j
.text:0000241D                 mov     ecx, [ebp+arg_0]
.text:00002420                 cmp     dword ptr [ecx+24h], 0Ah
.text:00002424                 jnz     short loc_2459
.text:00002426                 mov     ecx, [ebp+var_40]
.text:00002429                 add     ecx, 38h ; '8'
.text:0000242C                 call    ?Size@?$CObjectVector@UCUpdateArchiveCommand@@@@QBEIXZ ; CObjectVector<CUpdateArchiveCommand>::Size(void)
.text:00002431                 cmp     eax, 1
.text:00002434                 jz      short loc_2459
.text:00002436                 push    0
.text:00002438                 push    offset $SG77681 ; "Only one archive can be created with re"...
.text:0000243D                 lea     ecx, [ebp+var_C8]
.text:00002443                 call    ??0CArcCmdLineException@@QAE@PBDPB_W@Z ; CArcCmdLineException::CArcCmdLineException(char const *,wchar_t const *)
.text:00002448                 push    offset __TI2?AUCArcCmdLineException@@
.text:0000244D                 lea     edx, [ebp+var_C8]
.text:00002453                 push    edx
.text:00002454                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:00002459 ; ---------------------------------------------------------------------------
.text:00002459
.text:00002459 loc_2459:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+B00j
.text:00002459                                         ; CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+B10j
.text:00002459                 jmp     loc_2598
.text:0000245E ; ---------------------------------------------------------------------------
.text:0000245E
.text:0000245E loc_245E:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+89Aj
.text:0000245E                 mov     eax, [ebp+arg_0]
.text:00002461                 cmp     dword ptr [eax+24h], 7
.text:00002465                 jnz     loc_24EC
.text:0000246B                 mov     ecx, [ebp+arg_0]
.text:0000246E                 mov     dword ptr [ecx+20Ch], 1
.text:00002478                 mov     edx, [ebp+var_2C]
.text:0000247B                 cmp     edx, [ebp+var_C]
.text:0000247E                 jnb     short loc_24E7
.text:00002480                 mov     eax, [ebp+arg_0]
.text:00002483                 add     eax, 20Ch
.text:00002488                 push    eax             ; int
.text:00002489                 mov     ecx, [ebp+var_2C]
.text:0000248C                 push    ecx
.text:0000248D                 mov     ecx, [ebp+var_8]
.text:00002490                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00002495                 mov     ecx, eax
.text:00002497                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:0000249C                 push    eax             ; wchar_t *
.text:0000249D                 call    ?StringToUInt32@@YG_NPB_WAAI@Z ; StringToUInt32(wchar_t const *,uint &)
.text:000024A2                 movzx   edx, al
.text:000024A5                 test    edx, edx
.text:000024A7                 jnz     short loc_24DE
.text:000024A9                 mov     eax, [ebp+var_2C]
.text:000024AC                 push    eax
.text:000024AD                 mov     ecx, [ebp+var_8]
.text:000024B0                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:000024B5                 mov     ecx, eax
.text:000024B7                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000024BC                 push    eax
.text:000024BD                 push    offset $SG77688 ; "Incorrect Number of benmchmark iteratio"...
.text:000024C2                 lea     ecx, [ebp+var_D4]
.text:000024C8                 call    ??0CArcCmdLineException@@QAE@PBDPB_W@Z ; CArcCmdLineException::CArcCmdLineException(char const *,wchar_t const *)
.text:000024CD                 push    offset __TI2?AUCArcCmdLineException@@
.text:000024D2                 lea     ecx, [ebp+var_D4]
.text:000024D8                 push    ecx
.text:000024D9                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:000024DE ; ---------------------------------------------------------------------------
.text:000024DE
.text:000024DE loc_24DE:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+B83j
.text:000024DE                 mov     edx, [ebp+var_2C]
.text:000024E1                 add     edx, 1
.text:000024E4                 mov     [ebp+var_2C], edx
.text:000024E7
.text:000024E7 loc_24E7:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+B5Aj
.text:000024E7                 jmp     loc_2598
.text:000024EC ; ---------------------------------------------------------------------------
.text:000024EC
.text:000024EC loc_24EC:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+B41j
.text:000024EC                 mov     eax, [ebp+arg_0]
.text:000024EF                 cmp     dword ptr [eax+24h], 9
.text:000024F3                 jnz     short loc_2568
.text:000024F5                 mov     ecx, [ebp+var_10]
.text:000024F8                 push    ecx
.text:000024F9                 mov     ecx, [ebp+arg_0]
.text:000024FC                 add     ecx, 0Ch
.text:000024FF                 call    ?AddPathsToCensor@CCensor@NWildcard@@QAEXW4ECensorPathMode@2@@Z ; NWildcard::CCensor::AddPathsToCensor(NWildcard::ECensorPathMode)
.text:00002504                 mov     ecx, [ebp+arg_0]
.text:00002507                 add     ecx, 0Ch        ; this
.text:0000250A                 call    ?ExtendExclude@CCensor@NWildcard@@QAEXXZ ; NWildcard::CCensor::ExtendExclude(void)
.text:0000250F                 mov     edx, [ebp+arg_0]
.text:00002512                 add     edx, 1D0h
.text:00002518                 mov     [ebp+var_44], edx
.text:0000251B                 mov     eax, [ebp+var_44]
.text:0000251E                 mov     ecx, [ebp+var_10]
.text:00002521                 mov     [eax+10h], ecx
.text:00002524                 mov     edx, [ebp+arg_0]
.text:00002527                 add     edx, 48h ; 'H'
.text:0000252A                 push    edx
.text:0000252B                 mov     ecx, [ebp+var_44]
.text:0000252E                 call    ??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z ; CObjectVector<UString>::operator=(CObjectVector<UString> const &)
.text:00002533                 push    24h ; '$'
.text:00002535                 mov     ecx, [ebp+var_4]
.text:00002538                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:0000253D                 movzx   eax, byte ptr [eax]
.text:00002540                 test    eax, eax
.text:00002542                 jz      short loc_254B
.text:00002544                 mov     ecx, [ebp+var_44]
.text:00002547                 mov     byte ptr [ecx+0Ch], 1
.text:0000254B
.text:0000254B loc_254B:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+C1Ej
.text:0000254B                 mov     edx, [ebp+var_44]
.text:0000254E                 mov     eax, [ebp+arg_0]
.text:00002551                 mov     cl, [eax+7]
.text:00002554                 mov     [edx+0Dh], cl
.text:00002557                 mov     edx, [ebp+var_44]
.text:0000255A                 mov     eax, [ebp+arg_0]
.text:0000255D                 mov     cl, [eax+0AEh]
.text:00002563                 mov     [edx+0Eh], cl
.text:00002566                 jmp     short loc_2598
.text:00002568 ; ---------------------------------------------------------------------------
.text:00002568
.text:00002568 loc_2568:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+BCFj
.text:00002568                 mov     edx, [ebp+arg_0]
.text:0000256B                 cmp     dword ptr [edx+24h], 8
.text:0000256F                 jnz     short loc_2573
.text:00002571                 jmp     short loc_2598
.text:00002573 ; ---------------------------------------------------------------------------
.text:00002573
.text:00002573 loc_2573:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+C4Bj
.text:00002573                 mov     [ebp+var_DC], 490F5727h
.text:0000257D                 mov     [ebp+var_D8], 2
.text:00002587                 push    offset __TI1_J
.text:0000258C                 lea     eax, [ebp+var_DC]
.text:00002592                 push    eax
.text:00002593                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:00002598 ; ---------------------------------------------------------------------------
.text:00002598
.text:00002598 loc_2598:                               ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &):loc_21A9j
.text:00002598                                         ; CArcCmdLineParser::Parse2(CArcCmdLineOptions &):loc_2459j ...
.text:00002598                 pop     edi
.text:00002599                 add     esp, 0ECh
.text:0000259F                 cmp     ebp, esp
.text:000025A1                 call    __RTC_CheckEsp
.text:000025A6                 mov     esp, ebp
.text:000025A8                 pop     ebp
.text:000025A9                 retn    4
.text:000025A9 ?Parse2@CArcCmdLineParser@@QAEXAAUCArcCmdLineOptions@@@Z endp ; sp-analysis failed
.text:000025A9
.text:000025A9 ; ---------------------------------------------------------------------------
.text:000025AC                 db 8 dup(0CCh)
.text:000025B4
.text:000025B4 ; =============== S U B R O U T I N E =======================================
.text:000025B4
.text:000025B4 ; Attributes: bp-based frame
.text:000025B4
.text:000025B4 ; enum  EArcNameMode const __stdcall ParseArcNameMode(int)
.text:000025B4 ?ParseArcNameMode@@YG?BW4EArcNameMode@@H@Z proc near
.text:000025B4                                         ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+360p
.text:000025B4
.text:000025B4 var_4           = dword ptr -4
.text:000025B4 arg_0           = dword ptr  8
.text:000025B4
.text:000025B4                 push    ebp
.text:000025B5                 mov     ebp, esp
.text:000025B7                 push    ecx
.text:000025B8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000025BF                 mov     eax, [ebp+arg_0]
.text:000025C2                 mov     [ebp+var_4], eax
.text:000025C5                 cmp     [ebp+var_4], 1
.text:000025C9                 jz      short loc_25D3
.text:000025CB                 cmp     [ebp+var_4], 2
.text:000025CF                 jz      short loc_25DA
.text:000025D1                 jmp     short loc_25E1
.text:000025D3 ; ---------------------------------------------------------------------------
.text:000025D3
.text:000025D3 loc_25D3:                               ; CODE XREF: ParseArcNameMode(int)+15j
.text:000025D3                 mov     eax, 1
.text:000025D8                 jmp     short loc_25E3
.text:000025DA ; ---------------------------------------------------------------------------
.text:000025DA
.text:000025DA loc_25DA:                               ; CODE XREF: ParseArcNameMode(int)+1Bj
.text:000025DA                 mov     eax, 2
.text:000025DF                 jmp     short loc_25E3
.text:000025E1 ; ---------------------------------------------------------------------------
.text:000025E1
.text:000025E1 loc_25E1:                               ; CODE XREF: ParseArcNameMode(int)+1Dj
.text:000025E1                 xor     eax, eax
.text:000025E3
.text:000025E3 loc_25E3:                               ; CODE XREF: ParseArcNameMode(int)+24j
.text:000025E3                                         ; ParseArcNameMode(int)+2Bj
.text:000025E3                 mov     esp, ebp
.text:000025E5                 pop     ebp
.text:000025E6                 retn    4
.text:000025E6 ?ParseArcNameMode@@YG?BW4EArcNameMode@@H@Z endp
.text:000025E6
.text:000025E6 ; ---------------------------------------------------------------------------
.text:000025E9                 db 0Bh dup(0CCh)
.text:000025F4
.text:000025F4 ; =============== S U B R O U T I N E =======================================
.text:000025F4
.text:000025F4 ; Attributes: bp-based frame
.text:000025F4
.text:000025F4 ; enum  NRecursedType::EEnum __stdcall GetRecursedTypeFromIndex(int)
.text:000025F4 ?GetRecursedTypeFromIndex@@YG?AW4EEnum@NRecursedType@@H@Z proc near
.text:000025F4                                         ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+1B4p
.text:000025F4                                         ; AddSwitchWildcardsToCensor(NWildcard::CCensor &,CObjectVector<UString> const &,bool,NRecursedType::EEnum,bool,int)+EFp
.text:000025F4
.text:000025F4 var_4           = dword ptr -4
.text:000025F4 arg_0           = dword ptr  8
.text:000025F4
.text:000025F4                 push    ebp
.text:000025F5                 mov     ebp, esp
.text:000025F7                 push    ecx
.text:000025F8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000025FF                 mov     eax, [ebp+arg_0]
.text:00002602                 mov     [ebp+var_4], eax
.text:00002605                 cmp     [ebp+var_4], 0
.text:00002609                 jz      short loc_2613
.text:0000260B                 cmp     [ebp+var_4], 1
.text:0000260F                 jz      short loc_261A
.text:00002611                 jmp     short loc_2621
.text:00002613 ; ---------------------------------------------------------------------------
.text:00002613
.text:00002613 loc_2613:                               ; CODE XREF: GetRecursedTypeFromIndex(int)+15j
.text:00002613                 mov     eax, 1
.text:00002618                 jmp     short loc_2623
.text:0000261A ; ---------------------------------------------------------------------------
.text:0000261A
.text:0000261A loc_261A:                               ; CODE XREF: GetRecursedTypeFromIndex(int)+1Bj
.text:0000261A                 mov     eax, 2
.text:0000261F                 jmp     short loc_2623
.text:00002621 ; ---------------------------------------------------------------------------
.text:00002621
.text:00002621 loc_2621:                               ; CODE XREF: GetRecursedTypeFromIndex(int)+1Dj
.text:00002621                 xor     eax, eax
.text:00002623
.text:00002623 loc_2623:                               ; CODE XREF: GetRecursedTypeFromIndex(int)+24j
.text:00002623                                         ; GetRecursedTypeFromIndex(int)+2Bj
.text:00002623                 mov     esp, ebp
.text:00002625                 pop     ebp
.text:00002626                 retn    4
.text:00002626 ?GetRecursedTypeFromIndex@@YG?AW4EEnum@NRecursedType@@H@Z endp
.text:00002626
.text:00002626 ; ---------------------------------------------------------------------------
.text:00002629                 db 0Bh dup(0CCh)
.text:00002634
.text:00002634 ; =============== S U B R O U T I N E =======================================
.text:00002634
.text:00002634 ; Attributes: bp-based frame
.text:00002634
.text:00002634 ; bool __stdcall ParseArchiveCommand(class UString const &, struct CArcCommand &)
.text:00002634 ?ParseArchiveCommand@@YG_NABVUString@@AAUCArcCommand@@@Z proc near
.text:00002634                                         ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+6Ap
.text:00002634
.text:00002634 var_2C          = dword ptr -2Ch
.text:00002634 var_28          = dword ptr -28h
.text:00002634 var_24          = dword ptr -24h
.text:00002634 var_20          = dword ptr -20h
.text:00002634 var_1C          = dword ptr -1Ch
.text:00002634 var_18          = dword ptr -18h
.text:00002634 var_14          = dword ptr -14h
.text:00002634 var_10          = dword ptr -10h
.text:00002634 var_C           = dword ptr -0Ch
.text:00002634 var_4           = dword ptr -4
.text:00002634 arg_0           = dword ptr  8
.text:00002634 arg_4           = dword ptr  0Ch
.text:00002634
.text:00002634                 push    ebp
.text:00002635                 mov     ebp, esp
.text:00002637                 push    0FFFFFFFFh
.text:00002639                 push    offset __ehhandler$?ParseArchiveCommand@@YG_NABVUString@@AAUCArcCommand@@@Z
.text:0000263E                 mov     eax, large fs:0
.text:00002644                 push    eax
.text:00002645                 sub     esp, 20h
.text:00002648                 mov     eax, 0CCCCCCCCh
.text:0000264D                 mov     [ebp+var_2C], eax
.text:00002650                 mov     [ebp+var_28], eax
.text:00002653                 mov     [ebp+var_24], eax
.text:00002656                 mov     [ebp+var_20], eax
.text:00002659                 mov     [ebp+var_1C], eax
.text:0000265C                 mov     [ebp+var_18], eax
.text:0000265F                 mov     [ebp+var_14], eax
.text:00002662                 mov     [ebp+var_10], eax
.text:00002665                 mov     eax, dword ptr ds:___security_cookie
.text:0000266A                 xor     eax, ebp
.text:0000266C                 push    eax
.text:0000266D                 lea     eax, [ebp+var_C]
.text:00002670                 mov     large fs:0, eax
.text:00002676                 mov     eax, [ebp+arg_0]
.text:00002679                 push    eax
.text:0000267A                 lea     ecx, [ebp+var_1C]
.text:0000267D                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00002682                 mov     [ebp+var_4], 0
.text:00002689                 lea     ecx, [ebp+var_1C] ; this
.text:0000268C                 call    ?MakeLower_Ascii@UString@@QAEXXZ ; UString::MakeLower_Ascii(void)
.text:00002691                 lea     ecx, [ebp+var_1C] ; this
.text:00002694                 call    ?Len@UString@@QBEIXZ ; UString::Len(void)
.text:00002699                 cmp     eax, 1
.text:0000269C                 jnz     loc_2728
.text:000026A2                 lea     ecx, [ebp+var_1C]
.text:000026A5                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000026AA                 movzx   ecx, word ptr [eax]
.text:000026AD                 cmp     ecx, 7Fh ; ''
.text:000026B0                 jle     short loc_26CD
.text:000026B2                 mov     byte ptr [ebp+var_28+3], 0
.text:000026B6                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000026BD                 lea     ecx, [ebp+var_1C] ; this
.text:000026C0                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000026C5                 mov     al, byte ptr [ebp+var_28+3]
.text:000026C8                 jmp     loc_278D
.text:000026CD ; ---------------------------------------------------------------------------
.text:000026CD
.text:000026CD loc_26CD:                               ; CODE XREF: ParseArchiveCommand(UString const &,CArcCommand &)+7Cj
.text:000026CD                 lea     ecx, [ebp+var_1C]
.text:000026D0                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000026D5                 movzx   edx, byte ptr [eax]
.text:000026D8                 push    edx             ; char
.text:000026D9                 mov     eax, ds:_g_Commands
.text:000026DE                 push    eax             ; char *
.text:000026DF                 call    ?FindCharPosInString@@YGHPBDD@Z ; FindCharPosInString(char const *,char)
.text:000026E4                 mov     [ebp+var_24], eax
.text:000026E7                 cmp     [ebp+var_24], 0
.text:000026EB                 jge     short loc_2708
.text:000026ED                 mov     byte ptr [ebp+var_28+2], 0
.text:000026F1                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000026F8                 lea     ecx, [ebp+var_1C] ; this
.text:000026FB                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00002700                 mov     al, byte ptr [ebp+var_28+2]
.text:00002703                 jmp     loc_278D
.text:00002708 ; ---------------------------------------------------------------------------
.text:00002708
.text:00002708 loc_2708:                               ; CODE XREF: ParseArchiveCommand(UString const &,CArcCommand &)+B7j
.text:00002708                 mov     ecx, [ebp+arg_4]
.text:0000270B                 mov     edx, [ebp+var_24]
.text:0000270E                 mov     [ecx], edx
.text:00002710                 mov     byte ptr [ebp+var_28+1], 1
.text:00002714                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000271B                 lea     ecx, [ebp+var_1C] ; this
.text:0000271E                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00002723                 mov     al, byte ptr [ebp+var_28+1]
.text:00002726                 jmp     short loc_278D
.text:00002728 ; ---------------------------------------------------------------------------
.text:00002728
.text:00002728 loc_2728:                               ; CODE XREF: ParseArchiveCommand(UString const &,CArcCommand &)+68j
.text:00002728                 lea     ecx, [ebp+var_1C] ; this
.text:0000272B                 call    ?Len@UString@@QBEIXZ ; UString::Len(void)
.text:00002730                 cmp     eax, 2
.text:00002733                 jnz     short loc_2777
.text:00002735                 lea     ecx, [ebp+var_1C]
.text:00002738                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:0000273D                 movzx   eax, word ptr [eax]
.text:00002740                 cmp     eax, 72h ; 'r'
.text:00002743                 jnz     short loc_2777
.text:00002745                 lea     ecx, [ebp+var_1C]
.text:00002748                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:0000274D                 movzx   ecx, word ptr [eax+2]
.text:00002751                 cmp     ecx, 6Eh ; 'n'
.text:00002754                 jnz     short loc_2777
.text:00002756                 mov     edx, [ebp+arg_4]
.text:00002759                 mov     dword ptr [edx], 0Ah
.text:0000275F                 mov     byte ptr [ebp+var_28], 1
.text:00002763                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000276A                 lea     ecx, [ebp+var_1C] ; this
.text:0000276D                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00002772                 mov     al, byte ptr [ebp+var_28]
.text:00002775                 jmp     short loc_278D
.text:00002777 ; ---------------------------------------------------------------------------
.text:00002777
.text:00002777 loc_2777:                               ; CODE XREF: ParseArchiveCommand(UString const &,CArcCommand &)+FFj
.text:00002777                                         ; ParseArchiveCommand(UString const &,CArcCommand &)+10Fj ...
.text:00002777                 mov     byte ptr [ebp+var_2C+3], 0
.text:0000277B                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00002782                 lea     ecx, [ebp+var_1C] ; this
.text:00002785                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000278A                 mov     al, byte ptr [ebp+var_2C+3]
.text:0000278D
.text:0000278D loc_278D:                               ; CODE XREF: ParseArchiveCommand(UString const &,CArcCommand &)+94j
.text:0000278D                                         ; ParseArchiveCommand(UString const &,CArcCommand &)+CFj ...
.text:0000278D                 push    edx
.text:0000278E                 mov     ecx, ebp
.text:00002790                 push    eax
.text:00002791                 lea     edx, $LN11
.text:00002797                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:0000279C                 pop     eax
.text:0000279D                 pop     edx
.text:0000279E                 mov     ecx, [ebp+var_C]
.text:000027A1                 mov     large fs:0, ecx
.text:000027A8                 pop     ecx
.text:000027A9                 add     esp, 2Ch
.text:000027AC                 cmp     ebp, esp
.text:000027AE                 call    __RTC_CheckEsp
.text:000027B3                 mov     esp, ebp
.text:000027B5                 pop     ebp
.text:000027B6                 retn    8
.text:000027B6 ?ParseArchiveCommand@@YG_NABVUString@@AAUCArcCommand@@@Z endp
.text:000027B6
.text:000027B6 ; ---------------------------------------------------------------------------
.text:000027B9                 align 4
.text:000027BC $LN11           dd 1                    ; DATA XREF: ParseArchiveCommand(UString const &,CArcCommand &)+15Do
.text:000027C0                 dd offset $LN10_0
.text:000027C4 $LN10_0         dd 0FFFFFFE4h, 0Ch      ; DATA XREF: .text:000027C0o
.text:000027CC                 dd offset $LN8
.text:000027D0 $LN8            dd 0CCCC0073h           ; DATA XREF: .text:000027CCo
.text:000027D4
.text:000027D4 ; =============== S U B R O U T I N E =======================================
.text:000027D4
.text:000027D4 ; Attributes: bp-based frame
.text:000027D4
.text:000027D4 ; int __stdcall AddNameToCensor(NWildcard::CCensor *, struct UString *, char, int, char)
.text:000027D4 ?AddNameToCensor@@YGXAAVCCensor@NWildcard@@ABVUString@@_NW4EEnum@NRecursedType@@2@Z proc near
.text:000027D4                                         ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+70Ep
.text:000027D4                                         ; AddToCensorFromNonSwitchesStrings(CObjectVector<CRenamePair> *,uint,NWildcard::CCensor &,CObjectVector<UString> const &,NRecursedType::EEnum,bool,bool,int)+76p ...
.text:000027D4
.text:000027D4 var_8           = dword ptr -8
.text:000027D4 var_4           = dword ptr -4
.text:000027D4 arg_0           = dword ptr  8
.text:000027D4 arg_4           = dword ptr  0Ch
.text:000027D4 arg_8           = byte ptr  10h
.text:000027D4 arg_C           = dword ptr  14h
.text:000027D4 arg_10          = byte ptr  18h
.text:000027D4
.text:000027D4                 push    ebp
.text:000027D5                 mov     ebp, esp
.text:000027D7                 sub     esp, 8
.text:000027DA                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000027E1                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000027E8                 mov     byte ptr [ebp+var_4+3], 0
.text:000027EC                 mov     eax, [ebp+arg_C]
.text:000027EF                 mov     [ebp+var_8], eax
.text:000027F2                 cmp     [ebp+var_8], 0
.text:000027F6                 jz      short loc_280E
.text:000027F8                 cmp     [ebp+var_8], 1
.text:000027FC                 jz      short loc_2800
.text:000027FE                 jmp     short loc_2812
.text:00002800 ; ---------------------------------------------------------------------------
.text:00002800
.text:00002800 loc_2800:                               ; CODE XREF: AddNameToCensor(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)+28j
.text:00002800                 mov     ecx, [ebp+arg_4]
.text:00002803                 push    ecx             ; struct UString *
.text:00002804                 call    ?DoesNameContainWildcard@@YG_NABVUString@@@Z ; DoesNameContainWildcard(UString const &)
.text:00002809                 mov     byte ptr [ebp+var_4+3], al
.text:0000280C                 jmp     short loc_2812
.text:0000280E ; ---------------------------------------------------------------------------
.text:0000280E
.text:0000280E loc_280E:                               ; CODE XREF: AddNameToCensor(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)+22j
.text:0000280E                 mov     byte ptr [ebp+var_4+3], 1
.text:00002812
.text:00002812 loc_2812:                               ; CODE XREF: AddNameToCensor(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)+2Aj
.text:00002812                                         ; AddNameToCensor(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)+38j
.text:00002812                 movzx   edx, [ebp+arg_10]
.text:00002816                 push    edx             ; bool
.text:00002817                 movzx   eax, byte ptr [ebp+var_4+3]
.text:0000281B                 push    eax             ; bool
.text:0000281C                 mov     ecx, [ebp+arg_4]
.text:0000281F                 push    ecx             ; struct UString *
.text:00002820                 movzx   edx, [ebp+arg_8]
.text:00002824                 push    edx             ; bool
.text:00002825                 mov     ecx, [ebp+arg_0] ; this
.text:00002828                 call    ?AddPreItem@CCensor@NWildcard@@QAEX_NABVUString@@00@Z ; NWildcard::CCensor::AddPreItem(bool,UString const &,bool,bool)
.text:0000282D                 add     esp, 8
.text:00002830                 cmp     ebp, esp
.text:00002832                 call    __RTC_CheckEsp
.text:00002837                 mov     esp, ebp
.text:00002839                 pop     ebp
.text:0000283A                 retn    14h
.text:0000283A ?AddNameToCensor@@YGXAAVCCensor@NWildcard@@ABVUString@@_NW4EEnum@NRecursedType@@2@Z endp
.text:0000283A
.text:0000283A ; ---------------------------------------------------------------------------
.text:0000283D                 db 7 dup(0CCh)
.text:00002844
.text:00002844 ; =============== S U B R O U T I N E =======================================
.text:00002844
.text:00002844 ; Attributes: bp-based frame
.text:00002844
.text:00002844 ; int __stdcall AddToCensorFromNonSwitchesStrings(int, int, NWildcard::CCensor *, int, int, char, char, int)
.text:00002844 ?AddToCensorFromNonSwitchesStrings@@YGXPAV?$CObjectVector@UCRenamePair@@@@IAAVCCensor@NWildcard@@ABV?$CObjectVector@VUString@@@@W4EEnum@NRecursedType@@_N4H@Z proc near
.text:00002844                                         ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+445p
.text:00002844
.text:00002844 var_3C          = byte ptr -3Ch
.text:00002844 var_30          = byte ptr -30h
.text:00002844 var_24          = byte ptr -24h
.text:00002844 var_18          = dword ptr -18h
.text:00002844 var_14          = dword ptr -14h
.text:00002844 var_10          = dword ptr -10h
.text:00002844 var_C           = dword ptr -0Ch
.text:00002844 var_4           = dword ptr -4
.text:00002844 arg_0           = dword ptr  8
.text:00002844 arg_4           = dword ptr  0Ch
.text:00002844 arg_8           = dword ptr  10h
.text:00002844 arg_C           = dword ptr  14h
.text:00002844 arg_10          = dword ptr  18h
.text:00002844 arg_14          = byte ptr  1Ch
.text:00002844 arg_18          = byte ptr  20h
.text:00002844 arg_1C          = dword ptr  24h
.text:00002844
.text:00002844                 push    ebp
.text:00002845                 mov     ebp, esp
.text:00002847                 push    0FFFFFFFFh
.text:00002849                 push    offset __ehhandler$?AddToCensorFromNonSwitchesStrings@@YGXPAV?$CObjectVector@UCRenamePair@@@@IAAVCCensor@NWildcard@@ABV?$CObjectVector@VUString@@@@W4EEnum@NRecursedType@@_N4H@Z
.text:0000284E                 mov     eax, large fs:0
.text:00002854                 push    eax
.text:00002855                 sub     esp, 30h
.text:00002858                 push    edi
.text:00002859                 lea     edi, [ebp+var_3C]
.text:0000285C                 mov     ecx, 0Ch
.text:00002861                 mov     eax, 0CCCCCCCCh
.text:00002866                 rep stosd
.text:00002868                 mov     eax, dword ptr ds:___security_cookie
.text:0000286D                 xor     eax, ebp
.text:0000286F                 push    eax
.text:00002870                 lea     eax, [ebp+var_C]
.text:00002873                 mov     large fs:0, eax
.text:00002879                 cmp     [ebp+arg_0], 0
.text:0000287D                 jnz     short loc_288C
.text:0000287F                 mov     ecx, [ebp+arg_C]
.text:00002882                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:00002887                 cmp     eax, [ebp+arg_4]
.text:0000288A                 jnz     short loc_28CE
.text:0000288C
.text:0000288C loc_288C:                               ; CODE XREF: AddToCensorFromNonSwitchesStrings(CObjectVector<CRenamePair> *,uint,NWildcard::CCensor &,CObjectVector<UString> const &,NRecursedType::EEnum,bool,bool,int)+39j
.text:0000288C                 movzx   eax, [ebp+arg_18]
.text:00002890                 test    eax, eax
.text:00002892                 jnz     short loc_28CE
.text:00002894                 mov     ecx, ds:_kUniversalWildcard
.text:0000289A                 push    ecx
.text:0000289B                 lea     ecx, [ebp+var_24]
.text:0000289E                 call    ??0UString@@QAE@PB_W@Z ; UString::UString(wchar_t const *)
.text:000028A3                 mov     [ebp+var_4], 0
.text:000028AA                 push    1               ; char
.text:000028AC                 mov     edx, [ebp+arg_10]
.text:000028AF                 push    edx             ; int
.text:000028B0                 push    1               ; char
.text:000028B2                 lea     eax, [ebp+var_24]
.text:000028B5                 push    eax             ; struct UString *
.text:000028B6                 mov     ecx, [ebp+arg_8]
.text:000028B9                 push    ecx             ; NWildcard::CCensor *
.text:000028BA                 call    ?AddNameToCensor@@YGXAAVCCensor@NWildcard@@ABVUString@@_NW4EEnum@NRecursedType@@2@Z ; AddNameToCensor(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)
.text:000028BF                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000028C6                 lea     ecx, [ebp+var_24] ; this
.text:000028C9                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000028CE
.text:000028CE loc_28CE:                               ; CODE XREF: AddToCensorFromNonSwitchesStrings(CObjectVector<CRenamePair> *,uint,NWildcard::CCensor &,CObjectVector<UString> const &,NRecursedType::EEnum,bool,bool,int)+46j
.text:000028CE                                         ; AddToCensorFromNonSwitchesStrings(CObjectVector<CRenamePair> *,uint,NWildcard::CCensor &,CObjectVector<UString> const &,NRecursedType::EEnum,bool,bool,int)+4Ej
.text:000028CE                 mov     [ebp+var_10], 0FFFFFFFFh
.text:000028D5                 mov     edx, [ebp+arg_4]
.text:000028D8                 mov     [ebp+var_14], edx
.text:000028DB                 jmp     short loc_28E6
.text:000028DD ; ---------------------------------------------------------------------------
.text:000028DD
.text:000028DD loc_28DD:                               ; CODE XREF: AddToCensorFromNonSwitchesStrings(CObjectVector<CRenamePair> *,uint,NWildcard::CCensor &,CObjectVector<UString> const &,NRecursedType::EEnum,bool,bool,int):loc_29C2j
.text:000028DD                 mov     eax, [ebp+var_14]
.text:000028E0                 add     eax, 1
.text:000028E3                 mov     [ebp+var_14], eax
.text:000028E6
.text:000028E6 loc_28E6:                               ; CODE XREF: AddToCensorFromNonSwitchesStrings(CObjectVector<CRenamePair> *,uint,NWildcard::CCensor &,CObjectVector<UString> const &,NRecursedType::EEnum,bool,bool,int)+97j
.text:000028E6                 mov     ecx, [ebp+arg_C]
.text:000028E9                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:000028EE                 cmp     [ebp+var_14], eax
.text:000028F1                 jnb     loc_29C7
.text:000028F7                 mov     ecx, [ebp+var_14]
.text:000028FA                 push    ecx
.text:000028FB                 mov     ecx, [ebp+arg_C]
.text:000028FE                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00002903                 mov     [ebp+var_18], eax
.text:00002906                 mov     ecx, [ebp+var_18] ; this
.text:00002909                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:0000290E                 movzx   edx, al
.text:00002911                 test    edx, edx
.text:00002913                 jz      short loc_2933
.text:00002915                 push    0
.text:00002917                 mov     eax, ds:_kEmptyFilePath
.text:0000291C                 push    eax
.text:0000291D                 lea     ecx, [ebp+var_30]
.text:00002920                 call    ??0CArcCmdLineException@@QAE@PBDPB_W@Z ; CArcCmdLineException::CArcCmdLineException(char const *,wchar_t const *)
.text:00002925                 push    offset __TI2?AUCArcCmdLineException@@
.text:0000292A                 lea     ecx, [ebp+var_30]
.text:0000292D                 push    ecx
.text:0000292E                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:00002933 ; ---------------------------------------------------------------------------
.text:00002933
.text:00002933 loc_2933:                               ; CODE XREF: AddToCensorFromNonSwitchesStrings(CObjectVector<CRenamePair> *,uint,NWildcard::CCensor &,CObjectVector<UString> const &,NRecursedType::EEnum,bool,bool,int)+CFj
.text:00002933                 mov     ecx, [ebp+var_18]
.text:00002936                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:0000293B                 movzx   edx, word ptr [eax]
.text:0000293E                 cmp     edx, 40h ; '@'
.text:00002941                 jnz     short loc_296C
.text:00002943                 mov     eax, [ebp+arg_1C]
.text:00002946                 push    eax             ; int
.text:00002947                 movzx   ecx, [ebp+arg_14]
.text:0000294B                 push    ecx             ; char
.text:0000294C                 mov     edx, [ebp+arg_10]
.text:0000294F                 push    edx             ; int
.text:00002950                 push    1               ; char
.text:00002952                 push    1               ; unsigned int
.text:00002954                 mov     ecx, [ebp+var_18] ; this
.text:00002957                 call    ?Ptr@UString@@QBEPB_WI@Z ; UString::Ptr(uint)
.text:0000295C                 push    eax             ; NWindows::NFile::NFind *
.text:0000295D                 mov     eax, [ebp+arg_8]
.text:00002960                 push    eax             ; NWildcard::CCensor *
.text:00002961                 mov     ecx, [ebp+arg_0]
.text:00002964                 push    ecx             ; int
.text:00002965                 call    ?AddToCensorFromListFile@@YGXPAV?$CObjectVector@UCRenamePair@@@@AAVCCensor@NWildcard@@PB_W_NW4EEnum@NRecursedType@@3H@Z ; AddToCensorFromListFile(CObjectVector<CRenamePair> *,NWildcard::CCensor &,wchar_t const *,bool,NRecursedType::EEnum,bool,int)
.text:0000296A                 jmp     short loc_29C2
.text:0000296C ; ---------------------------------------------------------------------------
.text:0000296C
.text:0000296C loc_296C:                               ; CODE XREF: AddToCensorFromNonSwitchesStrings(CObjectVector<CRenamePair> *,uint,NWildcard::CCensor &,CObjectVector<UString> const &,NRecursedType::EEnum,bool,bool,int)+FDj
.text:0000296C                 cmp     [ebp+arg_0], 0
.text:00002970                 jz      short loc_29AA
.text:00002972                 cmp     [ebp+var_10], 0FFFFFFFFh
.text:00002976                 jnz     short loc_2980
.text:00002978                 mov     edx, [ebp+var_14]
.text:0000297B                 mov     [ebp+var_10], edx
.text:0000297E                 jmp     short loc_29A8
.text:00002980 ; ---------------------------------------------------------------------------
.text:00002980
.text:00002980 loc_2980:                               ; CODE XREF: AddToCensorFromNonSwitchesStrings(CObjectVector<CRenamePair> *,uint,NWildcard::CCensor &,CObjectVector<UString> const &,NRecursedType::EEnum,bool,bool,int)+132j
.text:00002980                 movzx   eax, [ebp+arg_14]
.text:00002984                 push    eax
.text:00002985                 push    2
.text:00002987                 mov     ecx, [ebp+var_18]
.text:0000298A                 push    ecx
.text:0000298B                 mov     edx, [ebp+var_10]
.text:0000298E                 push    edx
.text:0000298F                 mov     ecx, [ebp+arg_C]
.text:00002992                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00002997                 push    eax
.text:00002998                 mov     eax, [ebp+arg_0]
.text:0000299B                 push    eax
.text:0000299C                 call    ?AddRenamePair@@YGXPAV?$CObjectVector@UCRenamePair@@@@ABVUString@@1W4EEnum@NRecursedType@@_N@Z ; AddRenamePair(CObjectVector<CRenamePair> *,UString const &,UString const &,NRecursedType::EEnum,bool)
.text:000029A1                 mov     [ebp+var_10], 0FFFFFFFFh
.text:000029A8
.text:000029A8 loc_29A8:                               ; CODE XREF: AddToCensorFromNonSwitchesStrings(CObjectVector<CRenamePair> *,uint,NWildcard::CCensor &,CObjectVector<UString> const &,NRecursedType::EEnum,bool,bool,int)+13Aj
.text:000029A8                 jmp     short loc_29C2
.text:000029AA ; ---------------------------------------------------------------------------
.text:000029AA
.text:000029AA loc_29AA:                               ; CODE XREF: AddToCensorFromNonSwitchesStrings(CObjectVector<CRenamePair> *,uint,NWildcard::CCensor &,CObjectVector<UString> const &,NRecursedType::EEnum,bool,bool,int)+12Cj
.text:000029AA                 movzx   ecx, [ebp+arg_14]
.text:000029AE                 push    ecx             ; char
.text:000029AF                 mov     edx, [ebp+arg_10]
.text:000029B2                 push    edx             ; int
.text:000029B3                 push    1               ; char
.text:000029B5                 mov     eax, [ebp+var_18]
.text:000029B8                 push    eax             ; struct UString *
.text:000029B9                 mov     ecx, [ebp+arg_8]
.text:000029BC                 push    ecx             ; NWildcard::CCensor *
.text:000029BD                 call    ?AddNameToCensor@@YGXAAVCCensor@NWildcard@@ABVUString@@_NW4EEnum@NRecursedType@@2@Z ; AddNameToCensor(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)
.text:000029C2
.text:000029C2 loc_29C2:                               ; CODE XREF: AddToCensorFromNonSwitchesStrings(CObjectVector<CRenamePair> *,uint,NWildcard::CCensor &,CObjectVector<UString> const &,NRecursedType::EEnum,bool,bool,int)+126j
.text:000029C2                                         ; AddToCensorFromNonSwitchesStrings(CObjectVector<CRenamePair> *,uint,NWildcard::CCensor &,CObjectVector<UString> const &,NRecursedType::EEnum,bool,bool,int):loc_29A8j
.text:000029C2                 jmp     loc_28DD
.text:000029C7 ; ---------------------------------------------------------------------------
.text:000029C7
.text:000029C7 loc_29C7:                               ; CODE XREF: AddToCensorFromNonSwitchesStrings(CObjectVector<CRenamePair> *,uint,NWildcard::CCensor &,CObjectVector<UString> const &,NRecursedType::EEnum,bool,bool,int)+ADj
.text:000029C7                 cmp     [ebp+var_10], 0FFFFFFFFh
.text:000029CB                 jz      short loc_29FC
.text:000029CD                 mov     edx, [ebp+var_10]
.text:000029D0                 push    edx
.text:000029D1                 mov     ecx, [ebp+arg_C]
.text:000029D4                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:000029D9                 mov     ecx, eax
.text:000029DB                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000029E0                 push    eax
.text:000029E1                 push    offset $SG77143 ; "There is no second file name for rename"...
.text:000029E6                 lea     ecx, [ebp+var_3C]
.text:000029E9                 call    ??0CArcCmdLineException@@QAE@PBDPB_W@Z ; CArcCmdLineException::CArcCmdLineException(char const *,wchar_t const *)
.text:000029EE                 push    offset __TI2?AUCArcCmdLineException@@
.text:000029F3                 lea     eax, [ebp+var_3C]
.text:000029F6                 push    eax
.text:000029F7                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:000029FC ; ---------------------------------------------------------------------------
.text:000029FC
.text:000029FC loc_29FC:                               ; CODE XREF: AddToCensorFromNonSwitchesStrings(CObjectVector<CRenamePair> *,uint,NWildcard::CCensor &,CObjectVector<UString> const &,NRecursedType::EEnum,bool,bool,int)+187j
.text:000029FC                 mov     ecx, [ebp+var_C]
.text:000029FF                 mov     large fs:0, ecx
.text:00002A06                 pop     ecx
.text:00002A07                 pop     edi
.text:00002A08                 add     esp, 3Ch
.text:00002A0B                 cmp     ebp, esp
.text:00002A0D                 call    __RTC_CheckEsp
.text:00002A12                 mov     esp, ebp
.text:00002A14                 pop     ebp
.text:00002A15                 retn    20h
.text:00002A15 ?AddToCensorFromNonSwitchesStrings@@YGXPAV?$CObjectVector@UCRenamePair@@@@IAAVCCensor@NWildcard@@ABV?$CObjectVector@VUString@@@@W4EEnum@NRecursedType@@_N4H@Z endp
.text:00002A15
.text:00002A15 ; ---------------------------------------------------------------------------
.text:00002A18                 db 0Ch dup(0CCh)
.text:00002A24
.text:00002A24 ; =============== S U B R O U T I N E =======================================
.text:00002A24
.text:00002A24 ; Attributes: bp-based frame
.text:00002A24
.text:00002A24 ; void __stdcall AddRenamePair(class CObjectVector<struct CRenamePair> *, class UString const &, class UString const &, enum  NRecursedType::EEnum, bool)
.text:00002A24 ?AddRenamePair@@YGXPAV?$CObjectVector@UCRenamePair@@@@ABVUString@@1W4EEnum@NRecursedType@@_N@Z proc near
.text:00002A24                                         ; CODE XREF: AddToCensorFromNonSwitchesStrings(CObjectVector<CRenamePair> *,uint,NWildcard::CCensor &,CObjectVector<UString> const &,NRecursedType::EEnum,bool,bool,int)+158p
.text:00002A24                                         ; AddToCensorFromListFile(CObjectVector<CRenamePair> *,NWildcard::CCensor &,wchar_t const *,bool,NRecursedType::EEnum,bool,int)+12Ep
.text:00002A24
.text:00002A24 var_30          = dword ptr -30h
.text:00002A24 var_2C          = dword ptr -2Ch
.text:00002A24 var_28          = dword ptr -28h
.text:00002A24 var_24          = dword ptr -24h
.text:00002A24 var_20          = dword ptr -20h
.text:00002A24 var_1C          = dword ptr -1Ch
.text:00002A24 var_18          = dword ptr -18h
.text:00002A24 var_14          = dword ptr -14h
.text:00002A24 var_10          = dword ptr -10h
.text:00002A24 var_C           = dword ptr -0Ch
.text:00002A24 var_4           = dword ptr -4
.text:00002A24 arg_0           = dword ptr  8
.text:00002A24 arg_4           = dword ptr  0Ch
.text:00002A24 arg_8           = dword ptr  10h
.text:00002A24 arg_C           = dword ptr  14h
.text:00002A24 arg_10          = byte ptr  18h
.text:00002A24
.text:00002A24                 push    ebp
.text:00002A25                 mov     ebp, esp
.text:00002A27                 push    0FFFFFFFFh
.text:00002A29                 push    offset __ehhandler$?AddRenamePair@@YGXPAV?$CObjectVector@UCRenamePair@@@@ABVUString@@1W4EEnum@NRecursedType@@_N@Z
.text:00002A2E                 mov     eax, large fs:0
.text:00002A34                 push    eax
.text:00002A35                 sub     esp, 24h
.text:00002A38                 mov     eax, 0CCCCCCCCh
.text:00002A3D                 mov     [ebp+var_30], eax
.text:00002A40                 mov     [ebp+var_2C], eax
.text:00002A43                 mov     [ebp+var_28], eax
.text:00002A46                 mov     [ebp+var_24], eax
.text:00002A49                 mov     [ebp+var_20], eax
.text:00002A4C                 mov     [ebp+var_1C], eax
.text:00002A4F                 mov     [ebp+var_18], eax
.text:00002A52                 mov     [ebp+var_14], eax
.text:00002A55                 mov     [ebp+var_10], eax
.text:00002A58                 mov     eax, dword ptr ds:___security_cookie
.text:00002A5D                 xor     eax, ebp
.text:00002A5F                 push    eax
.text:00002A60                 lea     eax, [ebp+var_C]
.text:00002A63                 mov     large fs:0, eax
.text:00002A69                 mov     ecx, [ebp+arg_0]
.text:00002A6C                 call    ?AddNew@?$CObjectVector@UCRenamePair@@@@QAEAAUCRenamePair@@XZ ; CObjectVector<CRenamePair>::AddNew(void)
.text:00002A71                 mov     [ebp+var_10], eax
.text:00002A74                 mov     eax, [ebp+arg_4]
.text:00002A77                 push    eax
.text:00002A78                 mov     ecx, [ebp+var_10]
.text:00002A7B                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:00002A80                 mov     ecx, [ebp+arg_8]
.text:00002A83                 push    ecx
.text:00002A84                 mov     ecx, [ebp+var_10]
.text:00002A87                 add     ecx, 0Ch
.text:00002A8A                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:00002A8F                 mov     edx, [ebp+var_10]
.text:00002A92                 mov     eax, [ebp+arg_C]
.text:00002A95                 mov     [edx+1Ch], eax
.text:00002A98                 mov     ecx, [ebp+var_10]
.text:00002A9B                 mov     dl, [ebp+arg_10]
.text:00002A9E                 mov     [ecx+18h], dl
.text:00002AA1                 mov     ecx, [ebp+var_10] ; this
.text:00002AA4                 call    ?Prepare@CRenamePair@@QAE_NXZ ; CRenamePair::Prepare(void)
.text:00002AA9                 movzx   eax, al
.text:00002AAC                 test    eax, eax
.text:00002AAE                 jnz     loc_2B49
.text:00002AB4                 lea     ecx, [ebp+var_20]
.text:00002AB7                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00002ABC                 mov     [ebp+var_4], 0
.text:00002AC3                 mov     ecx, [ebp+var_10]
.text:00002AC6                 push    ecx
.text:00002AC7                 lea     ecx, [ebp+var_20]
.text:00002ACA                 call    ??YUString@@QAEAAV0@ABV0@@Z ; UString::operator+=(UString const &)
.text:00002ACF                 lea     ecx, [ebp+var_20] ; this
.text:00002AD2                 call    ?Add_LF@UString@@QAEXXZ ; UString::Add_LF(void)
.text:00002AD7                 mov     edx, [ebp+var_10]
.text:00002ADA                 add     edx, 0Ch
.text:00002ADD                 push    edx
.text:00002ADE                 lea     ecx, [ebp+var_20]
.text:00002AE1                 call    ??YUString@@QAEAAV0@ABV0@@Z ; UString::operator+=(UString const &)
.text:00002AE6                 lea     ecx, [ebp+var_20] ; this
.text:00002AE9                 call    ?Add_LF@UString@@QAEXXZ ; UString::Add_LF(void)
.text:00002AEE                 cmp     [ebp+arg_C], 0
.text:00002AF2                 jnz     short loc_2B03
.text:00002AF4                 push    offset $SG77063 ; char *
.text:00002AF9                 lea     ecx, [ebp+var_20] ; this
.text:00002AFC                 call    ?AddAscii@UString@@QAEXPBD@Z ; UString::AddAscii(char const *)
.text:00002B01                 jmp     short loc_2B16
.text:00002B03 ; ---------------------------------------------------------------------------
.text:00002B03
.text:00002B03 loc_2B03:                               ; CODE XREF: AddRenamePair(CObjectVector<CRenamePair> *,UString const &,UString const &,NRecursedType::EEnum,bool)+CEj
.text:00002B03                 cmp     [ebp+arg_C], 0
.text:00002B07                 jnz     short loc_2B16
.text:00002B09                 push    offset $SG77066 ; "-r0"
.text:00002B0E                 lea     ecx, [ebp+var_20] ; this
.text:00002B11                 call    ?AddAscii@UString@@QAEXPBD@Z ; UString::AddAscii(char const *)
.text:00002B16
.text:00002B16 loc_2B16:                               ; CODE XREF: AddRenamePair(CObjectVector<CRenamePair> *,UString const &,UString const &,NRecursedType::EEnum,bool)+DDj
.text:00002B16                                         ; AddRenamePair(CObjectVector<CRenamePair> *,UString const &,UString const &,NRecursedType::EEnum,bool)+E3j
.text:00002B16                 lea     ecx, [ebp+var_20]
.text:00002B19                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00002B1E                 push    eax
.text:00002B1F                 push    offset $SG77075 ; "Unsupported rename command:"
.text:00002B24                 lea     ecx, [ebp+var_30]
.text:00002B27                 call    ??0CArcCmdLineException@@QAE@PBDPB_W@Z ; CArcCmdLineException::CArcCmdLineException(char const *,wchar_t const *)
.text:00002B2C                 push    offset __TI2?AUCArcCmdLineException@@
.text:00002B31                 lea     eax, [ebp+var_30]
.text:00002B34                 push    eax
.text:00002B35                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:00002B3A ; ---------------------------------------------------------------------------
.text:00002B3A                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00002B41                 lea     ecx, [ebp+var_20] ; this
.text:00002B44                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00002B49
.text:00002B49 loc_2B49:                               ; CODE XREF: AddRenamePair(CObjectVector<CRenamePair> *,UString const &,UString const &,NRecursedType::EEnum,bool)+8Aj
.text:00002B49                 push    edx
.text:00002B4A                 mov     ecx, ebp
.text:00002B4C                 push    eax
.text:00002B4D                 lea     edx, $LN11_0
.text:00002B53                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00002B58                 pop     eax
.text:00002B59                 pop     edx
.text:00002B5A                 mov     ecx, [ebp+var_C]
.text:00002B5D                 mov     large fs:0, ecx
.text:00002B64                 pop     ecx
.text:00002B65                 add     esp, 30h
.text:00002B68                 cmp     ebp, esp
.text:00002B6A                 call    __RTC_CheckEsp
.text:00002B6F                 mov     esp, ebp
.text:00002B71                 pop     ebp
.text:00002B72                 retn    14h
.text:00002B72 ?AddRenamePair@@YGXPAV?$CObjectVector@UCRenamePair@@@@ABVUString@@1W4EEnum@NRecursedType@@_N@Z endp
.text:00002B72
.text:00002B72 ; ---------------------------------------------------------------------------
.text:00002B75                 align 4
.text:00002B78 $LN11_0         dd 1                    ; DATA XREF: AddRenamePair(CObjectVector<CRenamePair> *,UString const &,UString const &,NRecursedType::EEnum,bool)+129o
.text:00002B7C                 dd offset $LN10_1
.text:00002B80 $LN10_1         dd 0FFFFFFE0h, 0Ch      ; DATA XREF: .text:00002B7Co
.text:00002B88                 dd offset $LN8_0
.text:00002B8C $LN8_0          dd 6C6176h, 0CCCCCCCCh  ; DATA XREF: .text:00002B88o
.text:00002B94
.text:00002B94 ; =============== S U B R O U T I N E =======================================
.text:00002B94
.text:00002B94 ; Attributes: bp-based frame
.text:00002B94
.text:00002B94 ; int __stdcall AddToCensorFromListFile(int, NWildcard::CCensor *, NWindows::NFile::NFind *, char, int, char, int)
.text:00002B94 ?AddToCensorFromListFile@@YGXPAV?$CObjectVector@UCRenamePair@@@@AAVCCensor@NWildcard@@PB_W_NW4EEnum@NRecursedType@@3H@Z proc near
.text:00002B94                                         ; CODE XREF: AddToCensorFromNonSwitchesStrings(CObjectVector<CRenamePair> *,uint,NWildcard::CCensor &,CObjectVector<UString> const &,NRecursedType::EEnum,bool,bool,int)+121p
.text:00002B94                                         ; AddSwitchWildcardsToCensor(NWildcard::CCensor &,CObjectVector<UString> const &,bool,NRecursedType::EEnum,bool,int)+1B4p
.text:00002B94
.text:00002B94 var_4C          = byte ptr -4Ch
.text:00002B94 var_40          = byte ptr -40h
.text:00002B94 var_34          = byte ptr -34h
.text:00002B94 var_28          = dword ptr -28h
.text:00002B94 var_24          = dword ptr -24h
.text:00002B94 var_1C          = byte ptr -1Ch
.text:00002B94 var_C           = dword ptr -0Ch
.text:00002B94 var_4           = dword ptr -4
.text:00002B94 arg_0           = dword ptr  8
.text:00002B94 arg_4           = dword ptr  0Ch
.text:00002B94 arg_8           = dword ptr  10h
.text:00002B94 arg_C           = byte ptr  14h
.text:00002B94 arg_10          = dword ptr  18h
.text:00002B94 arg_14          = byte ptr  1Ch
.text:00002B94 arg_18          = dword ptr  20h
.text:00002B94
.text:00002B94                 push    ebp
.text:00002B95                 mov     ebp, esp
.text:00002B97                 push    0FFFFFFFFh
.text:00002B99                 push    offset __ehhandler$?AddToCensorFromListFile@@YGXPAV?$CObjectVector@UCRenamePair@@@@AAVCCensor@NWildcard@@PB_W_NW4EEnum@NRecursedType@@3H@Z
.text:00002B9E                 mov     eax, large fs:0
.text:00002BA4                 push    eax
.text:00002BA5                 sub     esp, 40h
.text:00002BA8                 push    edi
.text:00002BA9                 lea     edi, [ebp+var_4C]
.text:00002BAC                 mov     ecx, 10h
.text:00002BB1                 mov     eax, 0CCCCCCCCh
.text:00002BB6                 rep stosd
.text:00002BB8                 mov     eax, dword ptr ds:___security_cookie
.text:00002BBD                 xor     eax, ebp
.text:00002BBF                 push    eax             ; wchar_t *
.text:00002BC0                 lea     eax, [ebp+var_C]
.text:00002BC3                 mov     large fs:0, eax
.text:00002BC9                 lea     ecx, [ebp+var_1C]
.text:00002BCC                 call    ??0?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::CObjectVector<UString>(void)
.text:00002BD1                 mov     [ebp+var_4], 0
.text:00002BD8                 mov     eax, [ebp+arg_8]
.text:00002BDB                 push    eax             ; this
.text:00002BDC                 call    ?DoesFileExist@NFind@NFile@NWindows@@YG_NPB_W@Z ; NWindows::NFile::NFind::DoesFileExist(wchar_t const *)
.text:00002BE1                 movzx   ecx, al
.text:00002BE4                 test    ecx, ecx
.text:00002BE6                 jnz     short loc_2C08
.text:00002BE8                 mov     edx, [ebp+arg_8]
.text:00002BEB                 push    edx
.text:00002BEC                 mov     eax, ds:_kCannotFindListFile
.text:00002BF1                 push    eax
.text:00002BF2                 lea     ecx, [ebp+var_34]
.text:00002BF5                 call    ??0CArcCmdLineException@@QAE@PBDPB_W@Z ; CArcCmdLineException::CArcCmdLineException(char const *,wchar_t const *)
.text:00002BFA                 push    offset __TI2?AUCArcCmdLineException@@
.text:00002BFF                 lea     ecx, [ebp+var_34]
.text:00002C02                 push    ecx
.text:00002C03                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:00002C08 ; ---------------------------------------------------------------------------
.text:00002C08
.text:00002C08 loc_2C08:                               ; CODE XREF: AddToCensorFromListFile(CObjectVector<CRenamePair> *,NWildcard::CCensor &,wchar_t const *,bool,NRecursedType::EEnum,bool,int)+52j
.text:00002C08                 mov     edx, [ebp+arg_18]
.text:00002C0B                 push    edx
.text:00002C0C                 lea     eax, [ebp+var_1C]
.text:00002C0F                 push    eax
.text:00002C10                 mov     ecx, [ebp+arg_8]
.text:00002C13                 push    ecx
.text:00002C14                 call    ?ReadNamesFromListFile@@YG_NPB_WAAV?$CObjectVector@VUString@@@@I@Z ; ReadNamesFromListFile(wchar_t const *,CObjectVector<UString> &,uint)
.text:00002C19                 movzx   edx, al
.text:00002C1C                 test    edx, edx
.text:00002C1E                 jnz     short loc_2C41
.text:00002C20                 mov     eax, [ebp+arg_8]
.text:00002C23                 push    eax
.text:00002C24                 mov     ecx, ds:_kIncorrectListFile
.text:00002C2A                 push    ecx
.text:00002C2B                 lea     ecx, [ebp+var_40]
.text:00002C2E                 call    ??0CArcCmdLineException@@QAE@PBDPB_W@Z ; CArcCmdLineException::CArcCmdLineException(char const *,wchar_t const *)
.text:00002C33                 push    offset __TI2?AUCArcCmdLineException@@
.text:00002C38                 lea     edx, [ebp+var_40]
.text:00002C3B                 push    edx
.text:00002C3C                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:00002C41 ; ---------------------------------------------------------------------------
.text:00002C41
.text:00002C41 loc_2C41:                               ; CODE XREF: AddToCensorFromListFile(CObjectVector<CRenamePair> *,NWildcard::CCensor &,wchar_t const *,bool,NRecursedType::EEnum,bool,int)+8Aj
.text:00002C41                 cmp     [ebp+arg_0], 0
.text:00002C45                 jz      loc_2CCB
.text:00002C4B                 lea     ecx, [ebp+var_1C]
.text:00002C4E                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:00002C53                 and     eax, 1
.text:00002C56                 jz      short loc_2C79
.text:00002C58                 mov     eax, [ebp+arg_8]
.text:00002C5B                 push    eax
.text:00002C5C                 mov     ecx, ds:_kIncorrectListFile
.text:00002C62                 push    ecx
.text:00002C63                 lea     ecx, [ebp+var_4C]
.text:00002C66                 call    ??0CArcCmdLineException@@QAE@PBDPB_W@Z ; CArcCmdLineException::CArcCmdLineException(char const *,wchar_t const *)
.text:00002C6B                 push    offset __TI2?AUCArcCmdLineException@@
.text:00002C70                 lea     edx, [ebp+var_4C]
.text:00002C73                 push    edx
.text:00002C74                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:00002C79 ; ---------------------------------------------------------------------------
.text:00002C79
.text:00002C79 loc_2C79:                               ; CODE XREF: AddToCensorFromListFile(CObjectVector<CRenamePair> *,NWildcard::CCensor &,wchar_t const *,bool,NRecursedType::EEnum,bool,int)+C2j
.text:00002C79                 mov     [ebp+var_24], 0
.text:00002C80                 jmp     short loc_2C8B
.text:00002C82 ; ---------------------------------------------------------------------------
.text:00002C82
.text:00002C82 loc_2C82:                               ; CODE XREF: AddToCensorFromListFile(CObjectVector<CRenamePair> *,NWildcard::CCensor &,wchar_t const *,bool,NRecursedType::EEnum,bool,int)+133j
.text:00002C82                 mov     eax, [ebp+var_24]
.text:00002C85                 add     eax, 2
.text:00002C88                 mov     [ebp+var_24], eax
.text:00002C8B
.text:00002C8B loc_2C8B:                               ; CODE XREF: AddToCensorFromListFile(CObjectVector<CRenamePair> *,NWildcard::CCensor &,wchar_t const *,bool,NRecursedType::EEnum,bool,int)+ECj
.text:00002C8B                 lea     ecx, [ebp+var_1C]
.text:00002C8E                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:00002C93                 cmp     [ebp+var_24], eax
.text:00002C96                 jnb     short loc_2CC9
.text:00002C98                 movzx   ecx, [ebp+arg_14]
.text:00002C9C                 push    ecx
.text:00002C9D                 mov     edx, [ebp+arg_10]
.text:00002CA0                 push    edx
.text:00002CA1                 mov     eax, [ebp+var_24]
.text:00002CA4                 add     eax, 1
.text:00002CA7                 push    eax
.text:00002CA8                 lea     ecx, [ebp+var_1C]
.text:00002CAB                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00002CB0                 push    eax
.text:00002CB1                 mov     ecx, [ebp+var_24]
.text:00002CB4                 push    ecx
.text:00002CB5                 lea     ecx, [ebp+var_1C]
.text:00002CB8                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00002CBD                 push    eax
.text:00002CBE                 mov     edx, [ebp+arg_0]
.text:00002CC1                 push    edx
.text:00002CC2                 call    ?AddRenamePair@@YGXPAV?$CObjectVector@UCRenamePair@@@@ABVUString@@1W4EEnum@NRecursedType@@_N@Z ; AddRenamePair(CObjectVector<CRenamePair> *,UString const &,UString const &,NRecursedType::EEnum,bool)
.text:00002CC7                 jmp     short loc_2C82
.text:00002CC9 ; ---------------------------------------------------------------------------
.text:00002CC9
.text:00002CC9 loc_2CC9:                               ; CODE XREF: AddToCensorFromListFile(CObjectVector<CRenamePair> *,NWildcard::CCensor &,wchar_t const *,bool,NRecursedType::EEnum,bool,int)+102j
.text:00002CC9                 jmp     short loc_2D10
.text:00002CCB ; ---------------------------------------------------------------------------
.text:00002CCB
.text:00002CCB loc_2CCB:                               ; CODE XREF: AddToCensorFromListFile(CObjectVector<CRenamePair> *,NWildcard::CCensor &,wchar_t const *,bool,NRecursedType::EEnum,bool,int)+B1j
.text:00002CCB                 mov     [ebp+var_28], 0
.text:00002CD2                 jmp     short loc_2CDD
.text:00002CD4 ; ---------------------------------------------------------------------------
.text:00002CD4
.text:00002CD4 loc_2CD4:                               ; CODE XREF: AddToCensorFromListFile(CObjectVector<CRenamePair> *,NWildcard::CCensor &,wchar_t const *,bool,NRecursedType::EEnum,bool,int)+17Aj
.text:00002CD4                 mov     eax, [ebp+var_28]
.text:00002CD7                 add     eax, 1
.text:00002CDA                 mov     [ebp+var_28], eax
.text:00002CDD
.text:00002CDD loc_2CDD:                               ; CODE XREF: AddToCensorFromListFile(CObjectVector<CRenamePair> *,NWildcard::CCensor &,wchar_t const *,bool,NRecursedType::EEnum,bool,int)+13Ej
.text:00002CDD                 lea     ecx, [ebp+var_1C]
.text:00002CE0                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:00002CE5                 cmp     [ebp+var_28], eax
.text:00002CE8                 jnb     short loc_2D10
.text:00002CEA                 movzx   ecx, [ebp+arg_14]
.text:00002CEE                 push    ecx             ; char
.text:00002CEF                 mov     edx, [ebp+arg_10]
.text:00002CF2                 push    edx             ; int
.text:00002CF3                 movzx   eax, [ebp+arg_C]
.text:00002CF7                 push    eax             ; char
.text:00002CF8                 mov     ecx, [ebp+var_28]
.text:00002CFB                 push    ecx
.text:00002CFC                 lea     ecx, [ebp+var_1C]
.text:00002CFF                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00002D04                 push    eax             ; struct UString *
.text:00002D05                 mov     edx, [ebp+arg_4]
.text:00002D08                 push    edx             ; NWildcard::CCensor *
.text:00002D09                 call    ?AddNameToCensor@@YGXAAVCCensor@NWildcard@@ABVUString@@_NW4EEnum@NRecursedType@@2@Z ; AddNameToCensor(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)
.text:00002D0E                 jmp     short loc_2CD4
.text:00002D10 ; ---------------------------------------------------------------------------
.text:00002D10
.text:00002D10 loc_2D10:                               ; CODE XREF: AddToCensorFromListFile(CObjectVector<CRenamePair> *,NWildcard::CCensor &,wchar_t const *,bool,NRecursedType::EEnum,bool,int):loc_2CC9j
.text:00002D10                                         ; AddToCensorFromListFile(CObjectVector<CRenamePair> *,NWildcard::CCensor &,wchar_t const *,bool,NRecursedType::EEnum,bool,int)+154j
.text:00002D10                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00002D17                 lea     ecx, [ebp+var_1C]
.text:00002D1A                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:00002D1F                 push    edx
.text:00002D20                 mov     ecx, ebp
.text:00002D22                 push    eax
.text:00002D23                 lea     edx, $LN18
.text:00002D29                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00002D2E                 pop     eax
.text:00002D2F                 pop     edx
.text:00002D30
.text:00002D30 loc_2D30:                               ; DATA XREF: .rdata:$SG76863o
.text:00002D30                 mov     ecx, [ebp+var_C]
.text:00002D33                 mov     large fs:0, ecx
.text:00002D3A                 pop     ecx
.text:00002D3B                 pop     edi
.text:00002D3C                 add     esp, 4Ch
.text:00002D3F                 cmp     ebp, esp
.text:00002D41                 call    __RTC_CheckEsp
.text:00002D46                 mov     esp, ebp
.text:00002D48                 pop     ebp
.text:00002D49                 retn    1Ch
.text:00002D49 ?AddToCensorFromListFile@@YGXPAV?$CObjectVector@UCRenamePair@@@@AAVCCensor@NWildcard@@PB_W_NW4EEnum@NRecursedType@@3H@Z endp
.text:00002D49
.text:00002D49 ; ---------------------------------------------------------------------------
.text:00002D4C $LN18           dd 1                    ; DATA XREF: AddToCensorFromListFile(CObjectVector<CRenamePair> *,NWildcard::CCensor &,wchar_t const *,bool,NRecursedType::EEnum,bool,int)+18Fo
.text:00002D50                 dd offset $LN17
.text:00002D54 $LN17           dd 0FFFFFFE4h, 0Ch      ; DATA XREF: .text:00002D50o
.text:00002D5C                 dd offset $LN15         ; "names"
.text:00002D60 $LN15           db 'names',0            ; DATA XREF: .text:00002D5Co
.text:00002D66                 db 0Eh dup(0CCh)
.text:00002D74
.text:00002D74 ; =============== S U B R O U T I N E =======================================
.text:00002D74
.text:00002D74 ; Attributes: bp-based frame
.text:00002D74
.text:00002D74 ; int __stdcall AddSwitchWildcardsToCensor(NWildcard::CCensor *, int, char, int, char, int)
.text:00002D74 ?AddSwitchWildcardsToCensor@@YGXAAVCCensor@NWildcard@@ABV?$CObjectVector@VUString@@@@_NW4EEnum@NRecursedType@@2H@Z proc near
.text:00002D74                                         ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+244p
.text:00002D74                                         ; CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+27Ep ...
.text:00002D74
.text:00002D74 var_48          = byte ptr -48h
.text:00002D74 var_38          = dword ptr -38h
.text:00002D74 var_28          = dword ptr -28h
.text:00002D74 var_24          = word ptr -24h
.text:00002D74 var_20          = dword ptr -20h
.text:00002D74 var_1C          = dword ptr -1Ch
.text:00002D74 var_18          = dword ptr -18h
.text:00002D74 var_14          = dword ptr -14h
.text:00002D74 var_10          = dword ptr -10h
.text:00002D74 var_C           = dword ptr -0Ch
.text:00002D74 var_4           = dword ptr -4
.text:00002D74 arg_0           = dword ptr  8
.text:00002D74 arg_4           = dword ptr  0Ch
.text:00002D74 arg_8           = byte ptr  10h
.text:00002D74 arg_C           = dword ptr  14h
.text:00002D74 arg_10          = byte ptr  18h
.text:00002D74 arg_14          = dword ptr  1Ch
.text:00002D74
.text:00002D74                 push    ebp
.text:00002D75                 mov     ebp, esp
.text:00002D77                 push    0FFFFFFFFh
.text:00002D79                 push    offset __ehhandler$?AddSwitchWildcardsToCensor@@YGXAAVCCensor@NWildcard@@ABV?$CObjectVector@VUString@@@@_NW4EEnum@NRecursedType@@2H@Z
.text:00002D7E                 mov     eax, large fs:0
.text:00002D84                 push    eax
.text:00002D85                 sub     esp, 3Ch
.text:00002D88                 push    edi
.text:00002D89                 lea     edi, [ebp+var_48]
.text:00002D8C                 mov     ecx, 0Fh
.text:00002D91                 mov     eax, 0CCCCCCCCh
.text:00002D96                 rep stosd
.text:00002D98                 mov     eax, dword ptr ds:___security_cookie
.text:00002D9D                 xor     eax, ebp
.text:00002D9F                 push    eax
.text:00002DA0                 lea     eax, [ebp+var_C]
.text:00002DA3                 mov     large fs:0, eax
.text:00002DA9                 mov     [ebp+var_10], 0
.text:00002DB0                 mov     [ebp+var_14], 0
.text:00002DB7                 jmp     short loc_2DC2
.text:00002DB9 ; ---------------------------------------------------------------------------
.text:00002DB9
.text:00002DB9 loc_2DB9:                               ; CODE XREF: AddSwitchWildcardsToCensor(NWildcard::CCensor &,CObjectVector<UString> const &,bool,NRecursedType::EEnum,bool,int)+22Dj
.text:00002DB9                 mov     eax, [ebp+var_14]
.text:00002DBC                 add     eax, 1
.text:00002DBF                 mov     [ebp+var_14], eax
.text:00002DC2
.text:00002DC2 loc_2DC2:                               ; CODE XREF: AddSwitchWildcardsToCensor(NWildcard::CCensor &,CObjectVector<UString> const &,bool,NRecursedType::EEnum,bool,int)+43j
.text:00002DC2                 mov     ecx, [ebp+arg_4]
.text:00002DC5                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:00002DCA                 cmp     [ebp+var_14], eax
.text:00002DCD                 jnb     loc_2FA6
.text:00002DD3                 mov     ecx, [ebp+var_14]
.text:00002DD6                 push    ecx
.text:00002DD7                 mov     ecx, [ebp+arg_4]
.text:00002DDA                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00002DDF                 mov     [ebp+var_18], eax
.text:00002DE2                 mov     [ebp+var_20], 0
.text:00002DE9                 mov     ecx, [ebp+var_18] ; this
.text:00002DEC                 call    ?Len@UString@@QBEIXZ ; UString::Len(void)
.text:00002DF1                 cmp     eax, 2
.text:00002DF4                 jnb     short loc_2E02
.text:00002DF6                 mov     [ebp+var_10], offset $SG77247 ; "Too short switch"
.text:00002DFD                 jmp     loc_2FA6
.text:00002E02 ; ---------------------------------------------------------------------------
.text:00002E02
.text:00002E02 loc_2E02:                               ; CODE XREF: AddSwitchWildcardsToCensor(NWildcard::CCensor &,CObjectVector<UString> const &,bool,NRecursedType::EEnum,bool,int)+80j
.text:00002E02                 mov     ecx, [ebp+var_18]
.text:00002E05                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00002E0A                 mov     edx, [ebp+var_20]
.text:00002E0D                 movzx   eax, word ptr [eax+edx*2]
.text:00002E11                 push    eax             ; wchar_t
.text:00002E12                 call    ?MyCharLower_Ascii@@YG_W_W@Z ; MyCharLower_Ascii(wchar_t)
.text:00002E17                 movzx   ecx, ax
.text:00002E1A                 cmp     ecx, 72h ; 'r'
.text:00002E1D                 jnz     short loc_2E7C
.text:00002E1F                 mov     edx, [ebp+var_20]
.text:00002E22                 add     edx, 1
.text:00002E25                 mov     [ebp+var_20], edx
.text:00002E28                 mov     ecx, [ebp+var_18]
.text:00002E2B                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00002E30                 mov     ecx, [ebp+var_20]
.text:00002E33                 mov     dx, [eax+ecx*2]
.text:00002E37                 mov     [ebp+var_24], dx
.text:00002E3B                 mov     [ebp+var_28], 0FFFFFFFFh
.text:00002E42                 movzx   eax, [ebp+var_24]
.text:00002E46                 cmp     eax, 7Fh ; ''
.text:00002E49                 jg      short loc_2E5F
.text:00002E4B                 movzx   ecx, byte ptr [ebp+var_24]
.text:00002E4F                 push    ecx             ; char
.text:00002E50                 mov     edx, ds:_kRecursedPostCharSet
.text:00002E56                 push    edx             ; char *
.text:00002E57                 call    ?FindCharPosInString@@YGHPBDD@Z ; FindCharPosInString(char const *,char)
.text:00002E5C                 mov     [ebp+var_28], eax
.text:00002E5F
.text:00002E5F loc_2E5F:                               ; CODE XREF: AddSwitchWildcardsToCensor(NWildcard::CCensor &,CObjectVector<UString> const &,bool,NRecursedType::EEnum,bool,int)+D5j
.text:00002E5F                 mov     eax, [ebp+var_28]
.text:00002E62                 push    eax
.text:00002E63                 call    ?GetRecursedTypeFromIndex@@YG?AW4EEnum@NRecursedType@@H@Z ; GetRecursedTypeFromIndex(int)
.text:00002E68                 mov     [ebp+var_1C], eax
.text:00002E6B                 cmp     [ebp+var_28], 0
.text:00002E6F                 jl      short loc_2E7A
.text:00002E71                 mov     ecx, [ebp+var_20]
.text:00002E74                 add     ecx, 1
.text:00002E77                 mov     [ebp+var_20], ecx
.text:00002E7A
.text:00002E7A loc_2E7A:                               ; CODE XREF: AddSwitchWildcardsToCensor(NWildcard::CCensor &,CObjectVector<UString> const &,bool,NRecursedType::EEnum,bool,int)+FBj
.text:00002E7A                 jmp     short loc_2E82
.text:00002E7C ; ---------------------------------------------------------------------------
.text:00002E7C
.text:00002E7C loc_2E7C:                               ; CODE XREF: AddSwitchWildcardsToCensor(NWildcard::CCensor &,CObjectVector<UString> const &,bool,NRecursedType::EEnum,bool,int)+A9j
.text:00002E7C                 mov     edx, [ebp+arg_C]
.text:00002E7F                 mov     [ebp+var_1C], edx
.text:00002E82
.text:00002E82 loc_2E82:                               ; CODE XREF: AddSwitchWildcardsToCensor(NWildcard::CCensor &,CObjectVector<UString> const &,bool,NRecursedType::EEnum,bool,int):loc_2E7Aj
.text:00002E82                 mov     ecx, [ebp+var_18] ; this
.text:00002E85                 call    ?Len@UString@@QBEIXZ ; UString::Len(void)
.text:00002E8A                 mov     ecx, [ebp+var_20]
.text:00002E8D                 add     ecx, 2
.text:00002E90                 cmp     eax, ecx
.text:00002E92                 jnb     short loc_2EA0
.text:00002E94                 mov     [ebp+var_10], offset $SG77256 ; "Too short switch"
.text:00002E9B                 jmp     loc_2FA6
.text:00002EA0 ; ---------------------------------------------------------------------------
.text:00002EA0
.text:00002EA0 loc_2EA0:                               ; CODE XREF: AddSwitchWildcardsToCensor(NWildcard::CCensor &,CObjectVector<UString> const &,bool,NRecursedType::EEnum,bool,int)+11Ej
.text:00002EA0                 mov     edx, [ebp+var_20]
.text:00002EA3                 add     edx, 1
.text:00002EA6                 push    edx             ; unsigned int
.text:00002EA7                 mov     ecx, [ebp+var_18] ; this
.text:00002EAA                 call    ?Ptr@UString@@QBEPB_WI@Z ; UString::Ptr(uint)
.text:00002EAF                 push    eax
.text:00002EB0                 lea     ecx, [ebp+var_38]
.text:00002EB3                 call    ??0UString@@QAE@PB_W@Z ; UString::UString(wchar_t const *)
.text:00002EB8                 mov     [ebp+var_4], 0
.text:00002EBF                 mov     ecx, [ebp+var_18]
.text:00002EC2                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00002EC7                 mov     ecx, [ebp+var_20]
.text:00002ECA                 movzx   edx, word ptr [eax+ecx*2]
.text:00002ECE                 cmp     edx, 21h ; '!'
.text:00002ED1                 jnz     short loc_2EF3
.text:00002ED3                 movzx   eax, [ebp+arg_10]
.text:00002ED7                 push    eax             ; char
.text:00002ED8                 mov     ecx, [ebp+var_1C]
.text:00002EDB                 push    ecx             ; int
.text:00002EDC                 movzx   edx, [ebp+arg_8]
.text:00002EE0                 push    edx             ; char
.text:00002EE1                 lea     eax, [ebp+var_38]
.text:00002EE4                 push    eax             ; struct UString *
.text:00002EE5                 mov     ecx, [ebp+arg_0]
.text:00002EE8                 push    ecx             ; NWildcard::CCensor *
.text:00002EE9                 call    ?AddNameToCensor@@YGXAAVCCensor@NWildcard@@ABVUString@@_NW4EEnum@NRecursedType@@2@Z ; AddNameToCensor(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)
.text:00002EEE                 jmp     loc_2F92
.text:00002EF3 ; ---------------------------------------------------------------------------
.text:00002EF3
.text:00002EF3 loc_2EF3:                               ; CODE XREF: AddSwitchWildcardsToCensor(NWildcard::CCensor &,CObjectVector<UString> const &,bool,NRecursedType::EEnum,bool,int)+15Dj
.text:00002EF3                 mov     ecx, [ebp+var_18]
.text:00002EF6                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00002EFB                 mov     edx, [ebp+var_20]
.text:00002EFE                 movzx   eax, word ptr [eax+edx*2]
.text:00002F02                 cmp     eax, 40h ; '@'
.text:00002F05                 jnz     short loc_2F2F
.text:00002F07                 mov     ecx, [ebp+arg_14]
.text:00002F0A                 push    ecx             ; int
.text:00002F0B                 movzx   edx, [ebp+arg_10]
.text:00002F0F                 push    edx             ; char
.text:00002F10                 mov     eax, [ebp+var_1C]
.text:00002F13                 push    eax             ; int
.text:00002F14                 movzx   ecx, [ebp+arg_8]
.text:00002F18                 push    ecx             ; char
.text:00002F19                 lea     ecx, [ebp+var_38]
.text:00002F1C                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00002F21                 push    eax             ; NWindows::NFile::NFind *
.text:00002F22                 mov     edx, [ebp+arg_0]
.text:00002F25                 push    edx             ; NWildcard::CCensor *
.text:00002F26                 push    0               ; int
.text:00002F28                 call    ?AddToCensorFromListFile@@YGXPAV?$CObjectVector@UCRenamePair@@@@AAVCCensor@NWildcard@@PB_W_NW4EEnum@NRecursedType@@3H@Z ; AddToCensorFromListFile(CObjectVector<CRenamePair> *,NWildcard::CCensor &,wchar_t const *,bool,NRecursedType::EEnum,bool,int)
.text:00002F2D                 jmp     short loc_2F92
.text:00002F2F ; ---------------------------------------------------------------------------
.text:00002F2F
.text:00002F2F loc_2F2F:                               ; CODE XREF: AddSwitchWildcardsToCensor(NWildcard::CCensor &,CObjectVector<UString> const &,bool,NRecursedType::EEnum,bool,int)+191j
.text:00002F2F                 mov     ecx, [ebp+var_18]
.text:00002F32                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00002F37                 mov     ecx, [ebp+var_20]
.text:00002F3A                 movzx   edx, word ptr [eax+ecx*2]
.text:00002F3E                 cmp     edx, 23h ; '#'
.text:00002F41                 jnz     short loc_2F7A
.text:00002F43                 movzx   eax, [ebp+arg_10]
.text:00002F47                 push    eax             ; char
.text:00002F48                 mov     ecx, [ebp+var_1C]
.text:00002F4B                 push    ecx             ; int
.text:00002F4C                 movzx   edx, [ebp+arg_8]
.text:00002F50                 push    edx             ; char
.text:00002F51                 lea     eax, [ebp+var_38]
.text:00002F54                 push    eax             ; int
.text:00002F55                 mov     ecx, [ebp+arg_0]
.text:00002F58                 push    ecx             ; NWildcard::CCensor *
.text:00002F59                 call    ?ParseMapWithPaths@@YGPBDAAVCCensor@NWildcard@@ABVUString@@_NW4EEnum@NRecursedType@@2@Z ; ParseMapWithPaths(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)
.text:00002F5E                 mov     [ebp+var_10], eax
.text:00002F61                 cmp     [ebp+var_10], 0
.text:00002F65                 jz      short loc_2F78
.text:00002F67                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00002F6E                 lea     ecx, [ebp+var_38] ; this
.text:00002F71                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00002F76                 jmp     short loc_2FA6
.text:00002F78 ; ---------------------------------------------------------------------------
.text:00002F78
.text:00002F78 loc_2F78:                               ; CODE XREF: AddSwitchWildcardsToCensor(NWildcard::CCensor &,CObjectVector<UString> const &,bool,NRecursedType::EEnum,bool,int)+1F1j
.text:00002F78                 jmp     short loc_2F92
.text:00002F7A ; ---------------------------------------------------------------------------
.text:00002F7A
.text:00002F7A loc_2F7A:                               ; CODE XREF: AddSwitchWildcardsToCensor(NWildcard::CCensor &,CObjectVector<UString> const &,bool,NRecursedType::EEnum,bool,int)+1CDj
.text:00002F7A                 mov     [ebp+var_10], offset $SG77265 ; "Incorrect wildcard type marker"
.text:00002F81                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00002F88                 lea     ecx, [ebp+var_38] ; this
.text:00002F8B                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00002F90                 jmp     short loc_2FA6
.text:00002F92 ; ---------------------------------------------------------------------------
.text:00002F92
.text:00002F92 loc_2F92:                               ; CODE XREF: AddSwitchWildcardsToCensor(NWildcard::CCensor &,CObjectVector<UString> const &,bool,NRecursedType::EEnum,bool,int)+17Aj
.text:00002F92                                         ; AddSwitchWildcardsToCensor(NWildcard::CCensor &,CObjectVector<UString> const &,bool,NRecursedType::EEnum,bool,int)+1B9j ...
.text:00002F92                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00002F99                 lea     ecx, [ebp+var_38] ; this
.text:00002F9C                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00002FA1                 jmp     loc_2DB9
.text:00002FA6 ; ---------------------------------------------------------------------------
.text:00002FA6
.text:00002FA6 loc_2FA6:                               ; CODE XREF: AddSwitchWildcardsToCensor(NWildcard::CCensor &,CObjectVector<UString> const &,bool,NRecursedType::EEnum,bool,int)+59j
.text:00002FA6                                         ; AddSwitchWildcardsToCensor(NWildcard::CCensor &,CObjectVector<UString> const &,bool,NRecursedType::EEnum,bool,int)+89j ...
.text:00002FA6                 mov     ecx, [ebp+arg_4]
.text:00002FA9                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:00002FAE                 cmp     [ebp+var_14], eax
.text:00002FB1                 jz      short loc_2FE1
.text:00002FB3                 mov     edx, [ebp+var_14]
.text:00002FB6                 push    edx
.text:00002FB7                 mov     ecx, [ebp+arg_4]
.text:00002FBA                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00002FBF                 mov     ecx, eax
.text:00002FC1                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00002FC6                 push    eax
.text:00002FC7                 mov     eax, [ebp+var_10]
.text:00002FCA                 push    eax
.text:00002FCB                 lea     ecx, [ebp+var_48]
.text:00002FCE                 call    ??0CArcCmdLineException@@QAE@PBDPB_W@Z ; CArcCmdLineException::CArcCmdLineException(char const *,wchar_t const *)
.text:00002FD3                 push    offset __TI2?AUCArcCmdLineException@@
.text:00002FD8                 lea     ecx, [ebp+var_48]
.text:00002FDB                 push    ecx
.text:00002FDC                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:00002FE1 ; ---------------------------------------------------------------------------
.text:00002FE1
.text:00002FE1 loc_2FE1:                               ; CODE XREF: AddSwitchWildcardsToCensor(NWildcard::CCensor &,CObjectVector<UString> const &,bool,NRecursedType::EEnum,bool,int)+23Dj
.text:00002FE1                 push    edx
.text:00002FE2                 mov     ecx, ebp
.text:00002FE4                 push    eax
.text:00002FE5                 lea     edx, $LN24_0
.text:00002FEB                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00002FF0                 pop     eax
.text:00002FF1                 pop     edx
.text:00002FF2                 mov     ecx, [ebp+var_C]
.text:00002FF5                 mov     large fs:0, ecx
.text:00002FFC                 pop     ecx
.text:00002FFD                 pop     edi
.text:00002FFE                 add     esp, 48h
.text:00003001                 cmp     ebp, esp
.text:00003003                 call    __RTC_CheckEsp
.text:00003008                 mov     esp, ebp
.text:0000300A                 pop     ebp
.text:0000300B                 retn    18h
.text:0000300B ?AddSwitchWildcardsToCensor@@YGXAAVCCensor@NWildcard@@ABV?$CObjectVector@VUString@@@@_NW4EEnum@NRecursedType@@2H@Z endp
.text:0000300B
.text:0000300B ; ---------------------------------------------------------------------------
.text:0000300E                 align 10h
.text:00003010 $LN24_0         dd 1                    ; DATA XREF: AddSwitchWildcardsToCensor(NWildcard::CCensor &,CObjectVector<UString> const &,bool,NRecursedType::EEnum,bool,int)+271o
.text:00003014                 dd offset $LN23_1
.text:00003018 $LN23_1         dd 0FFFFFFC8h, 0Ch      ; DATA XREF: .text:00003014o
.text:00003020                 dd offset $LN21_0       ; "tail"
.text:00003024 $LN21_0         db 'tail',0             ; DATA XREF: .text:00003020o
.text:00003029                 db 0Bh dup(0CCh)
.text:00003034
.text:00003034 ; =============== S U B R O U T I N E =======================================
.text:00003034
.text:00003034 ; Attributes: bp-based frame
.text:00003034
.text:00003034 ; int __stdcall ParseMapWithPaths(NWildcard::CCensor *, int, char, int, char)
.text:00003034 ?ParseMapWithPaths@@YGPBDAAVCCensor@NWildcard@@ABVUString@@_NW4EEnum@NRecursedType@@2@Z proc near
.text:00003034                                         ; CODE XREF: AddSwitchWildcardsToCensor(NWildcard::CCensor &,CObjectVector<UString> const &,bool,NRecursedType::EEnum,bool,int)+1E5p
.text:00003034
.text:00003034 var_C0          = dword ptr -0C0h
.text:00003034 var_BC          = dword ptr -0BCh
.text:00003034 var_B8          = dword ptr -0B8h
.text:00003034 var_B4          = dword ptr -0B4h
.text:00003034 var_B0          = dword ptr -0B0h
.text:00003034 var_AC          = dword ptr -0ACh
.text:00003034 var_A8          = dword ptr -0A8h
.text:00003034 var_A4          = byte ptr -0A4h
.text:00003034 var_95          = byte ptr -95h
.text:00003034 var_94          = dword ptr -94h
.text:00003034 var_90          = dword ptr -90h
.text:00003034 var_8C          = dword ptr -8Ch
.text:00003034 var_88          = word ptr -88h
.text:00003034 var_84          = dword ptr -84h
.text:00003034 var_80          = dword ptr -80h
.text:00003034 var_7C          = dword ptr -7Ch
.text:00003034 var_74          = byte ptr -74h
.text:00003034 var_60          = byte ptr -60h
.text:00003034 var_58          = dword ptr -58h
.text:00003034 var_50          = byte ptr -50h
.text:00003034 var_44          = dword ptr -44h
.text:00003034 var_38          = byte ptr -38h
.text:00003034 var_28          = dword ptr -28h
.text:00003034 var_24          = dword ptr -24h
.text:00003034 var_1C          = byte ptr -1Ch
.text:00003034 var_C           = dword ptr -0Ch
.text:00003034 var_4           = dword ptr -4
.text:00003034 arg_0           = dword ptr  8
.text:00003034 arg_4           = dword ptr  0Ch
.text:00003034 arg_8           = byte ptr  10h
.text:00003034 arg_C           = dword ptr  14h
.text:00003034 arg_10          = byte ptr  18h
.text:00003034
.text:00003034                 push    ebp
.text:00003035                 mov     ebp, esp
.text:00003037                 push    0FFFFFFFFh
.text:00003039                 push    offset __ehhandler$?ParseMapWithPaths@@YGPBDAAVCCensor@NWildcard@@ABVUString@@_NW4EEnum@NRecursedType@@2@Z
.text:0000303E                 mov     eax, large fs:0
.text:00003044                 push    eax
.text:00003045                 sub     esp, 0B4h
.text:0000304B                 push    edi
.text:0000304C                 lea     edi, [ebp+var_C0]
.text:00003052                 mov     ecx, 2Dh ; '-'
.text:00003057                 mov     eax, 0CCCCCCCCh
.text:0000305C                 rep stosd
.text:0000305E                 mov     eax, dword ptr ds:___security_cookie
.text:00003063                 xor     eax, ebp
.text:00003065                 push    eax
.text:00003066                 lea     eax, [ebp+var_C]
.text:00003069                 mov     large fs:0, eax
.text:0000306F                 mov     eax, [ebp+arg_4]
.text:00003072                 push    eax
.text:00003073                 lea     ecx, [ebp+var_1C]
.text:00003076                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:0000307B                 mov     [ebp+var_4], 0
.text:00003082                 push    3Ah ; ':'       ; wchar_t
.text:00003084                 lea     ecx, [ebp+var_1C] ; this
.text:00003087                 call    ?Find@UString@@QBEH_W@Z ; UString::Find(wchar_t)
.text:0000308C                 mov     [ebp+var_24], eax
.text:0000308F                 cmp     [ebp+var_24], 0
.text:00003093                 jge     short loc_30BB
.text:00003095                 mov     ecx, ds:?k_IncorrectMapCommand@@3PBDB ; char const * const k_IncorrectMapCommand
.text:0000309B                 mov     [ebp+var_8C], ecx
.text:000030A1                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000030A8                 lea     ecx, [ebp+var_1C] ; this
.text:000030AB                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000030B0                 mov     eax, [ebp+var_8C]
.text:000030B6                 jmp     loc_3451
.text:000030BB ; ---------------------------------------------------------------------------
.text:000030BB
.text:000030BB loc_30BB:                               ; CODE XREF: ParseMapWithPaths(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)+5Fj
.text:000030BB                 mov     edx, [ebp+var_24]
.text:000030BE                 add     edx, 1
.text:000030C1                 push    edx             ; unsigned int
.text:000030C2                 push    3Ah ; ':'       ; wchar_t
.text:000030C4                 lea     ecx, [ebp+var_1C] ; this
.text:000030C7                 call    ?Find@UString@@QBEH_WI@Z ; UString::Find(wchar_t,uint)
.text:000030CC                 mov     [ebp+var_28], eax
.text:000030CF                 cmp     [ebp+var_28], 0
.text:000030D3                 jge     short loc_30FA
.text:000030D5                 mov     eax, ds:?k_IncorrectMapCommand@@3PBDB ; char const * const k_IncorrectMapCommand
.text:000030DA                 mov     [ebp+var_90], eax
.text:000030E0                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000030E7                 lea     ecx, [ebp+var_1C] ; this
.text:000030EA                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000030EF                 mov     eax, [ebp+var_90]
.text:000030F5                 jmp     loc_3451
.text:000030FA ; ---------------------------------------------------------------------------
.text:000030FA
.text:000030FA loc_30FA:                               ; CODE XREF: ParseMapWithPaths(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)+9Fj
.text:000030FA                 lea     ecx, [ebp+var_1C]
.text:000030FD                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00003102                 mov     ecx, [ebp+var_28]
.text:00003105                 lea     edx, [eax+ecx*2+2]
.text:00003109                 push    edx             ; wchar_t *
.text:0000310A                 lea     ecx, [ebp+var_38] ; this
.text:0000310D                 call    ??0CEventSetEnd@@QAE@PB_W@Z ; CEventSetEnd::CEventSetEnd(wchar_t const *)
.text:00003112                 mov     byte ptr [ebp+var_4], 1
.text:00003116                 mov     eax, [ebp+var_28]
.text:00003119                 push    eax             ; unsigned int
.text:0000311A                 lea     ecx, [ebp+var_1C] ; this
.text:0000311D                 call    ?DeleteFrom@UString@@QAEXI@Z ; UString::DeleteFrom(uint)
.text:00003122                 lea     ecx, [ebp+var_44]
.text:00003125                 push    ecx             ; int
.text:00003126                 mov     edx, [ebp+var_24]
.text:00003129                 add     edx, 1
.text:0000312C                 push    edx             ; unsigned int
.text:0000312D                 lea     ecx, [ebp+var_1C] ; this
.text:00003130                 call    ?Ptr@UString@@QBEPB_WI@Z ; UString::Ptr(uint)
.text:00003135                 push    eax             ; wchar_t *
.text:00003136                 call    ?StringToUInt32@@YG_NPB_WAAI@Z ; StringToUInt32(wchar_t const *,uint &)
.text:0000313B                 movzx   eax, al
.text:0000313E                 test    eax, eax
.text:00003140                 jz      short loc_3161
.text:00003142                 cmp     [ebp+var_44], 2
.text:00003146                 jb      short loc_3161
.text:00003148                 cmp     [ebp+var_44], 80000000h
.text:0000314F                 ja      short loc_3161
.text:00003151                 mov     eax, [ebp+var_44]
.text:00003154                 xor     edx, edx
.text:00003156                 mov     ecx, 2
.text:0000315B                 div     ecx
.text:0000315D                 test    edx, edx
.text:0000315F                 jz      short loc_3191
.text:00003161
.text:00003161 loc_3161:                               ; CODE XREF: ParseMapWithPaths(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)+10Cj
.text:00003161                                         ; ParseMapWithPaths(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)+112j ...
.text:00003161                 mov     [ebp+var_94], offset $SG77195 ; "Unsupported Map data size"
.text:0000316B                 mov     byte ptr [ebp+var_4], 0
.text:0000316F                 lea     ecx, [ebp+var_38] ; this
.text:00003172                 call    ??1CEventSetEnd@@QAE@XZ ; CEventSetEnd::~CEventSetEnd(void)
.text:00003177                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000317E                 lea     ecx, [ebp+var_1C] ; this
.text:00003181                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003186                 mov     eax, [ebp+var_94]
.text:0000318C                 jmp     loc_3451
.text:00003191 ; ---------------------------------------------------------------------------
.text:00003191
.text:00003191 loc_3191:                               ; CODE XREF: ParseMapWithPaths(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)+12Bj
.text:00003191                 mov     edx, [ebp+var_24]
.text:00003194                 push    edx             ; unsigned int
.text:00003195                 lea     ecx, [ebp+var_1C] ; this
.text:00003198                 call    ?DeleteFrom@UString@@QAEXI@Z ; UString::DeleteFrom(uint)
.text:0000319D                 lea     ecx, [ebp+var_50] ; this
.text:000031A0                 call    ??0CFileMapping@NWindows@@QAE@XZ ; NWindows::CFileMapping::CFileMapping(void)
.text:000031A5                 mov     byte ptr [ebp+var_4], 2
.text:000031A9                 lea     eax, [ebp+var_1C]
.text:000031AC                 push    eax
.text:000031AD                 lea     ecx, [ebp+var_A4]
.text:000031B3                 push    ecx
.text:000031B4                 call    ?GetSystemString@@YG?AVAString@@ABVUString@@@Z ; GetSystemString(UString const &)
.text:000031B9                 mov     [ebp+var_BC], eax
.text:000031BF                 mov     edx, [ebp+var_BC]
.text:000031C5                 mov     [ebp+var_C0], edx
.text:000031CB                 mov     byte ptr [ebp+var_4], 3
.text:000031CF                 mov     ecx, [ebp+var_C0]
.text:000031D5                 call    ??BAString@@QBEPBDXZ ; AString::operator char const *(void)
.text:000031DA                 push    eax             ; char *
.text:000031DB                 push    4               ; dwDesiredAccess
.text:000031DD                 lea     ecx, [ebp+var_50] ; this
.text:000031E0                 call    ?Open@CFileMapping@NWindows@@QAEIKPBD@Z ; NWindows::CFileMapping::Open(ulong,char const *)
.text:000031E5                 neg     eax
.text:000031E7                 sbb     eax, eax
.text:000031E9                 neg     eax
.text:000031EB                 mov     [ebp+var_95], al
.text:000031F1                 mov     byte ptr [ebp+var_4], 2
.text:000031F5                 lea     ecx, [ebp+var_A4] ; this
.text:000031FB                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00003200                 movzx   eax, [ebp+var_95]
.text:00003207                 test    eax, eax
.text:00003209                 jz      short loc_3247
.text:0000320B                 mov     [ebp+var_A8], offset $SG77201 ; "Can not open mapping"
.text:00003215                 mov     byte ptr [ebp+var_4], 1
.text:00003219                 lea     ecx, [ebp+var_50] ; this
.text:0000321C                 call    ??1CFileMapping@NWindows@@QAE@XZ ; NWindows::CFileMapping::~CFileMapping(void)
.text:00003221                 mov     byte ptr [ebp+var_4], 0
.text:00003225                 lea     ecx, [ebp+var_38] ; this
.text:00003228                 call    ??1CEventSetEnd@@QAE@XZ ; CEventSetEnd::~CEventSetEnd(void)
.text:0000322D                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00003234                 lea     ecx, [ebp+var_1C] ; this
.text:00003237                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000323C                 mov     eax, [ebp+var_A8]
.text:00003242                 jmp     loc_3451
.text:00003247 ; ---------------------------------------------------------------------------
.text:00003247
.text:00003247 loc_3247:                               ; CODE XREF: ParseMapWithPaths(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)+1D5j
.text:00003247                 mov     ecx, [ebp+var_44]
.text:0000324A                 push    ecx
.text:0000324B                 push    0               ; dwNumberOfBytesToMap
.text:0000324D                 push    0               ; dwFileOffsetLow
.text:0000324F                 push    4               ; dwDesiredAccess
.text:00003251                 lea     ecx, [ebp+var_50] ; this
.text:00003254                 call    ?Map@CFileMapping@NWindows@@QAEPAXK_KK@Z ; NWindows::CFileMapping::Map(ulong,unsigned __int64,ulong)
.text:00003259                 mov     [ebp+var_58], eax
.text:0000325C                 cmp     [ebp+var_58], 0
.text:00003260                 jnz     short loc_329E
.text:00003262                 mov     [ebp+var_AC], offset $SG77205 ; "MapViewOfFile error"
.text:0000326C                 mov     byte ptr [ebp+var_4], 1
.text:00003270                 lea     ecx, [ebp+var_50] ; this
.text:00003273                 call    ??1CFileMapping@NWindows@@QAE@XZ ; NWindows::CFileMapping::~CFileMapping(void)
.text:00003278                 mov     byte ptr [ebp+var_4], 0
.text:0000327C                 lea     ecx, [ebp+var_38] ; this
.text:0000327F                 call    ??1CEventSetEnd@@QAE@XZ ; CEventSetEnd::~CEventSetEnd(void)
.text:00003284                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000328B                 lea     ecx, [ebp+var_1C] ; this
.text:0000328E                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003293                 mov     eax, [ebp+var_AC]
.text:00003299                 jmp     loc_3451
.text:0000329E ; ---------------------------------------------------------------------------
.text:0000329E
.text:0000329E loc_329E:                               ; CODE XREF: ParseMapWithPaths(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)+22Cj
.text:0000329E                 mov     edx, [ebp+var_58]
.text:000032A1                 push    edx             ; void *
.text:000032A2                 lea     ecx, [ebp+var_60] ; this
.text:000032A5                 call    ??0CFileUnmapper@NWindows@@QAE@PBX@Z ; NWindows::CFileUnmapper::CFileUnmapper(void const *)
.text:000032AA                 mov     byte ptr [ebp+var_4], 4
.text:000032AE                 lea     ecx, [ebp+var_74]
.text:000032B1                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:000032B6                 mov     byte ptr [ebp+var_4], 5
.text:000032BA                 mov     eax, [ebp+var_58]
.text:000032BD                 mov     [ebp+var_7C], eax
.text:000032C0                 mov     ecx, [ebp+var_7C]
.text:000032C3                 movzx   edx, word ptr [ecx]
.text:000032C6                 test    edx, edx
.text:000032C8                 jz      short loc_331E
.text:000032CA                 mov     [ebp+var_B0], offset $SG77212 ; "Unsupported Map data"
.text:000032D4                 mov     byte ptr [ebp+var_4], 4
.text:000032D8                 lea     ecx, [ebp+var_74] ; this
.text:000032DB                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000032E0                 mov     byte ptr [ebp+var_4], 2
.text:000032E4                 lea     ecx, [ebp+var_60] ; this
.text:000032E7                 call    ??1CFileUnmapper@NWindows@@QAE@XZ ; NWindows::CFileUnmapper::~CFileUnmapper(void)
.text:000032EC                 mov     byte ptr [ebp+var_4], 1
.text:000032F0                 lea     ecx, [ebp+var_50] ; this
.text:000032F3                 call    ??1CFileMapping@NWindows@@QAE@XZ ; NWindows::CFileMapping::~CFileMapping(void)
.text:000032F8                 mov     byte ptr [ebp+var_4], 0
.text:000032FC                 lea     ecx, [ebp+var_38] ; this
.text:000032FF                 call    ??1CEventSetEnd@@QAE@XZ ; CEventSetEnd::~CEventSetEnd(void)
.text:00003304                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000330B                 lea     ecx, [ebp+var_1C] ; this
.text:0000330E                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003313                 mov     eax, [ebp+var_B0]
.text:00003319                 jmp     loc_3451
.text:0000331E ; ---------------------------------------------------------------------------
.text:0000331E
.text:0000331E loc_331E:                               ; CODE XREF: ParseMapWithPaths(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)+294j
.text:0000331E                 mov     eax, [ebp+var_44]
.text:00003321                 shr     eax, 1
.text:00003323                 mov     [ebp+var_80], eax
.text:00003326                 mov     [ebp+var_84], 1
.text:00003330                 jmp     short loc_3341
.text:00003332 ; ---------------------------------------------------------------------------
.text:00003332
.text:00003332 loc_3332:                               ; CODE XREF: ParseMapWithPaths(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool):loc_33A0j
.text:00003332                 mov     ecx, [ebp+var_84]
.text:00003338                 add     ecx, 1
.text:0000333B                 mov     [ebp+var_84], ecx
.text:00003341
.text:00003341 loc_3341:                               ; CODE XREF: ParseMapWithPaths(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)+2FCj
.text:00003341                 mov     edx, [ebp+var_84]
.text:00003347                 cmp     edx, [ebp+var_80]
.text:0000334A                 jnb     short loc_33A2
.text:0000334C                 mov     eax, [ebp+var_84]
.text:00003352                 mov     ecx, [ebp+var_7C]
.text:00003355                 mov     dx, [ecx+eax*2]
.text:00003359                 mov     [ebp+var_88], dx
.text:00003360                 movzx   eax, [ebp+var_88]
.text:00003367                 test    eax, eax
.text:00003369                 jnz     short loc_3390
.text:0000336B                 movzx   ecx, [ebp+arg_10]
.text:0000336F                 push    ecx             ; char
.text:00003370                 mov     edx, [ebp+arg_C]
.text:00003373                 push    edx             ; int
.text:00003374                 movzx   eax, [ebp+arg_8]
.text:00003378                 push    eax             ; char
.text:00003379                 lea     ecx, [ebp+var_74]
.text:0000337C                 push    ecx             ; struct UString *
.text:0000337D                 mov     edx, [ebp+arg_0]
.text:00003380                 push    edx             ; NWildcard::CCensor *
.text:00003381                 call    ?AddNameToCensor@@YGXAAVCCensor@NWildcard@@ABVUString@@_NW4EEnum@NRecursedType@@2@Z ; AddNameToCensor(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)
.text:00003386                 lea     ecx, [ebp+var_74] ; this
.text:00003389                 call    ?Empty@UString@@QAEXXZ ; UString::Empty(void)
.text:0000338E                 jmp     short loc_33A0
.text:00003390 ; ---------------------------------------------------------------------------
.text:00003390
.text:00003390 loc_3390:                               ; CODE XREF: ParseMapWithPaths(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)+335j
.text:00003390                 movzx   eax, [ebp+var_88]
.text:00003397                 push    eax
.text:00003398                 lea     ecx, [ebp+var_74]
.text:0000339B                 call    ??YUString@@QAEAAV0@_W@Z ; UString::operator+=(wchar_t)
.text:000033A0
.text:000033A0 loc_33A0:                               ; CODE XREF: ParseMapWithPaths(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)+35Aj
.text:000033A0                 jmp     short loc_3332
.text:000033A2 ; ---------------------------------------------------------------------------
.text:000033A2
.text:000033A2 loc_33A2:                               ; CODE XREF: ParseMapWithPaths(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)+316j
.text:000033A2                 lea     ecx, [ebp+var_74] ; this
.text:000033A5                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:000033AA                 movzx   ecx, al
.text:000033AD                 test    ecx, ecx
.text:000033AF                 jnz     short loc_3402
.text:000033B1                 mov     [ebp+var_B4], offset $SG77224 ; "Map data error"
.text:000033BB                 mov     byte ptr [ebp+var_4], 4
.text:000033BF                 lea     ecx, [ebp+var_74] ; this
.text:000033C2                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000033C7                 mov     byte ptr [ebp+var_4], 2
.text:000033CB                 lea     ecx, [ebp+var_60] ; this
.text:000033CE                 call    ??1CFileUnmapper@NWindows@@QAE@XZ ; NWindows::CFileUnmapper::~CFileUnmapper(void)
.text:000033D3                 mov     byte ptr [ebp+var_4], 1
.text:000033D7                 lea     ecx, [ebp+var_50] ; this
.text:000033DA                 call    ??1CFileMapping@NWindows@@QAE@XZ ; NWindows::CFileMapping::~CFileMapping(void)
.text:000033DF                 mov     byte ptr [ebp+var_4], 0
.text:000033E3                 lea     ecx, [ebp+var_38] ; this
.text:000033E6                 call    ??1CEventSetEnd@@QAE@XZ ; CEventSetEnd::~CEventSetEnd(void)
.text:000033EB                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000033F2                 lea     ecx, [ebp+var_1C] ; this
.text:000033F5                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000033FA                 mov     eax, [ebp+var_B4]
.text:00003400                 jmp     short loc_3451
.text:00003402 ; ---------------------------------------------------------------------------
.text:00003402
.text:00003402 loc_3402:                               ; CODE XREF: ParseMapWithPaths(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)+37Bj
.text:00003402                 mov     [ebp+var_B8], 0
.text:0000340C                 mov     byte ptr [ebp+var_4], 4
.text:00003410                 lea     ecx, [ebp+var_74] ; this
.text:00003413                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003418                 mov     byte ptr [ebp+var_4], 2
.text:0000341C                 lea     ecx, [ebp+var_60] ; this
.text:0000341F                 call    ??1CFileUnmapper@NWindows@@QAE@XZ ; NWindows::CFileUnmapper::~CFileUnmapper(void)
.text:00003424                 mov     byte ptr [ebp+var_4], 1
.text:00003428                 lea     ecx, [ebp+var_50] ; this
.text:0000342B                 call    ??1CFileMapping@NWindows@@QAE@XZ ; NWindows::CFileMapping::~CFileMapping(void)
.text:00003430                 mov     byte ptr [ebp+var_4], 0
.text:00003434                 lea     ecx, [ebp+var_38] ; this
.text:00003437                 call    ??1CEventSetEnd@@QAE@XZ ; CEventSetEnd::~CEventSetEnd(void)
.text:0000343C                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00003443                 lea     ecx, [ebp+var_1C] ; this
.text:00003446                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000344B                 mov     eax, [ebp+var_B8]
.text:00003451
.text:00003451 loc_3451:                               ; CODE XREF: ParseMapWithPaths(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)+82j
.text:00003451                                         ; ParseMapWithPaths(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)+C1j ...
.text:00003451                 push    edx
.text:00003452                 mov     ecx, ebp
.text:00003454                 push    eax
.text:00003455                 lea     edx, $LN30
.text:0000345B                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00003460                 pop     eax
.text:00003461                 pop     edx
.text:00003462                 mov     ecx, [ebp+var_C]
.text:00003465                 mov     large fs:0, ecx
.text:0000346C                 pop     ecx
.text:0000346D                 pop     edi
.text:0000346E                 add     esp, 0C0h
.text:00003474                 cmp     ebp, esp
.text:00003476                 call    __RTC_CheckEsp
.text:0000347B                 mov     esp, ebp
.text:0000347D                 pop     ebp
.text:0000347E                 retn    14h
.text:0000347E ?ParseMapWithPaths@@YGPBDAAVCCensor@NWildcard@@ABVUString@@_NW4EEnum@NRecursedType@@2@Z endp
.text:0000347E
.text:0000347E ; ---------------------------------------------------------------------------
.text:00003481                 align 4
.text:00003484 $LN30           dd 6                    ; DATA XREF: ParseMapWithPaths(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)+421o
.text:00003488                 dd offset $LN29_0
.text:0000348C $LN29_0         dd 0FFFFFFE4h, 0Ch      ; DATA XREF: .text:00003488o
.text:00003494                 dd offset $LN22_1       ; "s"
.text:00003498                 dd 0FFFFFFC8h, 0Ch
.text:000034A0                 dd offset $LN23_2       ; "eventSetEnd"
.text:000034A4                 dd 0FFFFFFBCh, 4
.text:000034AC                 dd offset $LN24_1       ; "size"
.text:000034B0                 dd 0FFFFFFB0h, 4
.text:000034B8                 dd offset $LN25_1       ; "map"
.text:000034BC                 dd 0FFFFFFA0h, 4
.text:000034C4                 dd offset $LN26_1       ; "unmapper"
.text:000034C8                 dd 0FFFFFF8Ch, 0Ch
.text:000034D0                 dd offset $LN27         ; "name"
.text:000034D4 $LN27           db 'name',0             ; DATA XREF: .text:000034D0o
.text:000034D9 $LN26_1         db 'unmapper',0         ; DATA XREF: .text:000034C4o
.text:000034E2 $LN25_1         db 'map',0              ; DATA XREF: .text:000034B8o
.text:000034E6 $LN24_1         db 'size',0             ; DATA XREF: .text:000034ACo
.text:000034EB $LN23_2         db 'eventSetEnd',0      ; DATA XREF: .text:000034A0o
.text:000034F7 $LN22_1         db 's',0                ; DATA XREF: .text:00003494o
.text:000034F9                 db 0Bh dup(0CCh)
.text:00003504
.text:00003504 ; =============== S U B R O U T I N E =======================================
.text:00003504
.text:00003504 ; Attributes: bp-based frame
.text:00003504
.text:00003504 ; void __stdcall SetAddCommandOptions(enum  NCommandType::EEnum, class NCommandLineParser::CParser const &, struct CUpdateOptions &)
.text:00003504 ?SetAddCommandOptions@@YGXW4EEnum@NCommandType@@ABVCParser@NCommandLineParser@@AAUCUpdateOptions@@@Z proc near
.text:00003504                                         ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+8EEp
.text:00003504
.text:00003504 var_E8          = dword ptr -0E8h
.text:00003504 var_E4          = byte ptr -0E4h
.text:00003504 var_D4          = qword ptr -0D4h
.text:00003504 var_C8          = dword ptr -0C8h
.text:00003504 var_C4          = dword ptr -0C4h
.text:00003504 var_C0          = dword ptr -0C0h
.text:00003504 var_B8          = byte ptr -0B8h
.text:00003504 var_54          = byte ptr -54h
.text:00003504 var_30          = byte ptr -30h
.text:00003504 var_10          = dword ptr -10h
.text:00003504 var_C           = dword ptr -0Ch
.text:00003504 var_4           = dword ptr -4
.text:00003504 arg_0           = dword ptr  8
.text:00003504 arg_4           = dword ptr  0Ch
.text:00003504 arg_8           = dword ptr  10h
.text:00003504
.text:00003504                 push    ebp
.text:00003505                 mov     ebp, esp
.text:00003507                 push    0FFFFFFFFh
.text:00003509                 push    offset __ehhandler$?SetAddCommandOptions@@YGXW4EEnum@NCommandType@@ABVCParser@NCommandLineParser@@AAUCUpdateOptions@@@Z
.text:0000350E                 mov     eax, large fs:0
.text:00003514                 push    eax
.text:00003515                 sub     esp, 0DCh
.text:0000351B                 push    esi
.text:0000351C                 push    edi
.text:0000351D                 lea     edi, [ebp+var_E8]
.text:00003523                 mov     ecx, 37h ; '7'
.text:00003528                 mov     eax, 0CCCCCCCCh
.text:0000352D                 rep stosd
.text:0000352F                 mov     eax, dword ptr ds:___security_cookie
.text:00003534                 xor     eax, ebp
.text:00003536                 mov     [ebp+var_10], eax
.text:00003539                 push    eax             ; struct UString *
.text:0000353A                 lea     eax, [ebp+var_C]
.text:0000353D                 mov     large fs:0, eax
.text:00003543                 mov     eax, [ebp+arg_0]
.text:00003546                 mov     [ebp+var_E8], eax
.text:0000354C                 cmp     [ebp+var_E8], 0
.text:00003553                 jz      short loc_3560
.text:00003555                 cmp     [ebp+var_E8], 2
.text:0000355C                 jz      short loc_3571
.text:0000355E                 jmp     short loc_3582
.text:00003560 ; ---------------------------------------------------------------------------
.text:00003560
.text:00003560 loc_3560:                               ; CODE XREF: SetAddCommandOptions(NCommandType::EEnum,NCommandLineParser::CParser const &,CUpdateOptions &)+4Fj
.text:00003560                 mov     ecx, 7
.text:00003565                 mov     esi, offset ?k_ActionSet_Add@NUpdateArchive@@3UCActionSet@1@B ; NUpdateArchive::CActionSet const NUpdateArchive::k_ActionSet_Add
.text:0000356A                 lea     edi, [ebp+var_30]
.text:0000356D                 rep movsd
.text:0000356F                 jmp     short loc_3591
.text:00003571 ; ---------------------------------------------------------------------------
.text:00003571
.text:00003571 loc_3571:                               ; CODE XREF: SetAddCommandOptions(NCommandType::EEnum,NCommandLineParser::CParser const &,CUpdateOptions &)+58j
.text:00003571                 mov     ecx, 7
.text:00003576                 mov     esi, offset ?k_ActionSet_Delete@NUpdateArchive@@3UCActionSet@1@B ; NUpdateArchive::CActionSet const NUpdateArchive::k_ActionSet_Delete
.text:0000357B                 lea     edi, [ebp+var_30]
.text:0000357E                 rep movsd
.text:00003580                 jmp     short loc_3591
.text:00003582 ; ---------------------------------------------------------------------------
.text:00003582
.text:00003582 loc_3582:                               ; CODE XREF: SetAddCommandOptions(NCommandType::EEnum,NCommandLineParser::CParser const &,CUpdateOptions &)+5Aj
.text:00003582                 mov     ecx, 7
.text:00003587                 mov     esi, offset ?k_ActionSet_Update@NUpdateArchive@@3UCActionSet@1@B ; NUpdateArchive::CActionSet const NUpdateArchive::k_ActionSet_Update
.text:0000358C                 lea     edi, [ebp+var_30]
.text:0000358F                 rep movsd
.text:00003591
.text:00003591 loc_3591:                               ; CODE XREF: SetAddCommandOptions(NCommandType::EEnum,NCommandLineParser::CParser const &,CUpdateOptions &)+6Bj
.text:00003591                                         ; SetAddCommandOptions(NCommandType::EEnum,NCommandLineParser::CParser const &,CUpdateOptions &)+7Cj
.text:00003591                 mov     ecx, [ebp+arg_8]
.text:00003594                 mov     byte ptr [ecx+44h], 1
.text:00003598                 mov     ecx, [ebp+arg_8]
.text:0000359B                 add     ecx, 38h ; '8'
.text:0000359E                 call    ?Clear@?$CObjectVector@UCUpdateArchiveCommand@@@@QAEXXZ ; CObjectVector<CUpdateArchiveCommand>::Clear(void)
.text:000035A3                 lea     ecx, [ebp+var_B8] ; this
.text:000035A9                 call    ??0CUpdateArchiveCommand@@QAE@XZ ; CUpdateArchiveCommand::CUpdateArchiveCommand(void)
.text:000035AE                 mov     [ebp+var_4], 0
.text:000035B5                 mov     ecx, 7
.text:000035BA                 lea     esi, [ebp+var_30]
.text:000035BD                 lea     edi, [ebp+var_54]
.text:000035C0                 rep movsd
.text:000035C2                 lea     edx, [ebp+var_B8]
.text:000035C8                 push    edx
.text:000035C9                 mov     ecx, [ebp+arg_8]
.text:000035CC                 add     ecx, 38h ; '8'
.text:000035CF                 call    ?Add@?$CObjectVector@UCUpdateArchiveCommand@@@@QAEIABUCUpdateArchiveCommand@@@Z ; CObjectVector<CUpdateArchiveCommand>::Add(CUpdateArchiveCommand const &)
.text:000035D4                 push    17h
.text:000035D6                 mov     ecx, [ebp+arg_4]
.text:000035D9                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:000035DE                 movzx   eax, byte ptr [eax]
.text:000035E1                 test    eax, eax
.text:000035E3                 jz      short loc_3600
.text:000035E5                 lea     ecx, [ebp+var_30]
.text:000035E8                 push    ecx
.text:000035E9                 push    17h
.text:000035EB                 mov     ecx, [ebp+arg_4]
.text:000035EE                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:000035F3                 add     eax, 8
.text:000035F6                 push    eax
.text:000035F7                 mov     edx, [ebp+arg_8]
.text:000035FA                 push    edx
.text:000035FB                 call    ?ParseUpdateCommandString@@YGXAAUCUpdateOptions@@ABV?$CObjectVector@VUString@@@@ABUCActionSet@NUpdateArchive@@@Z ; ParseUpdateCommandString(CUpdateOptions &,CObjectVector<UString> const &,NUpdateArchive::CActionSet const &)
.text:00003600
.text:00003600 loc_3600:                               ; CODE XREF: SetAddCommandOptions(NCommandType::EEnum,NCommandLineParser::CParser const &,CUpdateOptions &)+DFj
.text:00003600                 push    11h
.text:00003602                 mov     ecx, [ebp+arg_4]
.text:00003605                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:0000360A                 movzx   eax, byte ptr [eax]
.text:0000360D                 test    eax, eax
.text:0000360F                 jz      short loc_3665
.text:00003611                 push    0
.text:00003613                 push    11h
.text:00003615                 mov     ecx, [ebp+arg_4]
.text:00003618                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:0000361D                 add     eax, 8
.text:00003620                 mov     ecx, eax
.text:00003622                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00003627                 mov     [ebp+var_C0], eax
.text:0000362D                 mov     ecx, [ebp+var_C0] ; this
.text:00003633                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:00003638                 movzx   ecx, al
.text:0000363B                 test    ecx, ecx
.text:0000363D                 jz      short loc_3650
.text:0000363F                 mov     edx, [ebp+arg_8]
.text:00003642                 add     edx, 0D4h ; '+'
.text:00003648                 push    edx             ; this
.text:00003649                 call    ?MyGetTempPath@NDir@NFile@NWindows@@YG_NAAVUString@@@Z ; NWindows::NFile::NDir::MyGetTempPath(UString &)
.text:0000364E                 jmp     short loc_3665
.text:00003650 ; ---------------------------------------------------------------------------
.text:00003650
.text:00003650 loc_3650:                               ; CODE XREF: SetAddCommandOptions(NCommandType::EEnum,NCommandLineParser::CParser const &,CUpdateOptions &)+139j
.text:00003650                 mov     eax, [ebp+var_C0]
.text:00003656                 push    eax
.text:00003657                 mov     ecx, [ebp+arg_8]
.text:0000365A                 add     ecx, 0D4h ; '+'
.text:00003660                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:00003665
.text:00003665 loc_3665:                               ; CODE XREF: SetAddCommandOptions(NCommandType::EEnum,NCommandLineParser::CParser const &,CUpdateOptions &)+10Bj
.text:00003665                                         ; SetAddCommandOptions(NCommandType::EEnum,NCommandLineParser::CParser const &,CUpdateOptions &)+14Aj
.text:00003665                 push    1Bh
.text:00003667                 mov     ecx, [ebp+arg_4]
.text:0000366A                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:0000366F                 mov     ecx, [ebp+arg_8]
.text:00003672                 mov     dl, [eax]
.text:00003674                 mov     [ecx+0A4h], dl
.text:0000367A                 mov     eax, [ebp+arg_8]
.text:0000367D                 movzx   ecx, byte ptr [eax+0A4h]
.text:00003684                 test    ecx, ecx
.text:00003686                 jz      short loc_36AD
.text:00003688                 push    0
.text:0000368A                 push    1Bh
.text:0000368C                 mov     ecx, [ebp+arg_4]
.text:0000368F                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00003694                 add     eax, 8
.text:00003697                 mov     ecx, eax
.text:00003699                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:0000369E                 push    eax
.text:0000369F                 mov     ecx, [ebp+arg_8]
.text:000036A2                 add     ecx, 0A8h ; 'Â¿'
.text:000036A8                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:000036AD
.text:000036AD loc_36AD:                               ; CODE XREF: SetAddCommandOptions(NCommandType::EEnum,NCommandLineParser::CParser const &,CUpdateOptions &)+182j
.text:000036AD                 push    18h
.text:000036AF                 mov     ecx, [ebp+arg_4]
.text:000036B2                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:000036B7                 movzx   edx, byte ptr [eax]
.text:000036BA                 test    edx, edx
.text:000036BC                 jz      loc_379E
.text:000036C2                 push    18h
.text:000036C4                 mov     ecx, [ebp+arg_4]
.text:000036C7                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:000036CC                 add     eax, 8
.text:000036CF                 mov     [ebp+var_C4], eax
.text:000036D5                 mov     [ebp+var_C8], 0
.text:000036DF                 jmp     short loc_36F0
.text:000036E1 ; ---------------------------------------------------------------------------
.text:000036E1
.text:000036E1 loc_36E1:                               ; CODE XREF: SetAddCommandOptions(NCommandType::EEnum,NCommandLineParser::CParser const &,CUpdateOptions &)+295j
.text:000036E1                 mov     eax, [ebp+var_C8]
.text:000036E7                 add     eax, 1
.text:000036EA                 mov     [ebp+var_C8], eax
.text:000036F0
.text:000036F0 loc_36F0:                               ; CODE XREF: SetAddCommandOptions(NCommandType::EEnum,NCommandLineParser::CParser const &,CUpdateOptions &)+1DBj
.text:000036F0                 mov     ecx, [ebp+var_C4]
.text:000036F6                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:000036FB                 cmp     [ebp+var_C8], eax
.text:00003701                 jnb     loc_379E
.text:00003707                 lea     ecx, [ebp+var_D4]
.text:0000370D                 push    ecx             ; unsigned __int64 *
.text:0000370E                 mov     edx, [ebp+var_C8]
.text:00003714                 push    edx
.text:00003715                 mov     ecx, [ebp+var_C4]
.text:0000371B                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00003720                 mov     ecx, eax
.text:00003722                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00003727                 push    eax             ; wchar_t *
.text:00003728                 call    ?ParseComplexSize@@YG_NPB_WAA_K@Z ; ParseComplexSize(wchar_t const *,unsigned __int64 &)
.text:0000372D                 movzx   eax, al
.text:00003730                 test    eax, eax
.text:00003732                 jz      short loc_3742
.text:00003734                 mov     ecx, dword ptr [ebp+var_D4]
.text:0000373A                 or      ecx, dword ptr [ebp+var_D4+4]
.text:00003740                 jnz     short loc_377D
.text:00003742
.text:00003742 loc_3742:                               ; CODE XREF: SetAddCommandOptions(NCommandType::EEnum,NCommandLineParser::CParser const &,CUpdateOptions &)+22Ej
.text:00003742                 mov     edx, [ebp+var_C8]
.text:00003748                 push    edx
.text:00003749                 mov     ecx, [ebp+var_C4]
.text:0000374F                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00003754                 mov     ecx, eax
.text:00003756                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:0000375B                 push    eax
.text:0000375C                 push    offset $SG77420 ; "Incorrect volume size:"
.text:00003761                 lea     ecx, [ebp+var_E4]
.text:00003767                 call    ??0CArcCmdLineException@@QAE@PBDPB_W@Z ; CArcCmdLineException::CArcCmdLineException(char const *,wchar_t const *)
.text:0000376C                 push    offset __TI2?AUCArcCmdLineException@@
.text:00003771                 lea     eax, [ebp+var_E4]
.text:00003777                 push    eax
.text:00003778                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:0000377D ; ---------------------------------------------------------------------------
.text:0000377D
.text:0000377D loc_377D:                               ; CODE XREF: SetAddCommandOptions(NCommandType::EEnum,NCommandLineParser::CParser const &,CUpdateOptions &)+23Cj
.text:0000377D                 mov     ecx, dword ptr [ebp+var_D4+4]
.text:00003783                 push    ecx
.text:00003784                 mov     edx, dword ptr [ebp+var_D4]
.text:0000378A                 push    edx
.text:0000378B                 mov     ecx, [ebp+arg_8]
.text:0000378E                 add     ecx, 108h
.text:00003794                 call    ?Add@?$CRecordVector@_K@@QAEI_K@Z ; CRecordVector<unsigned __int64>::Add(unsigned __int64)
.text:00003799                 jmp     loc_36E1
.text:0000379E ; ---------------------------------------------------------------------------
.text:0000379E
.text:0000379E loc_379E:                               ; CODE XREF: SetAddCommandOptions(NCommandType::EEnum,NCommandLineParser::CParser const &,CUpdateOptions &)+1B8j
.text:0000379E                                         ; SetAddCommandOptions(NCommandType::EEnum,NCommandLineParser::CParser const &,CUpdateOptions &)+1FDj
.text:0000379E                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000037A5                 lea     ecx, [ebp+var_B8] ; this
.text:000037AB                 call    ??1CUpdateArchiveCommand@@QAE@XZ ; CUpdateArchiveCommand::~CUpdateArchiveCommand(void)
.text:000037B0                 push    edx
.text:000037B1                 mov     ecx, ebp
.text:000037B3                 push    eax
.text:000037B4                 lea     edx, $LN25_2
.text:000037BA                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:000037BF                 pop     eax
.text:000037C0                 pop     edx
.text:000037C1                 mov     ecx, [ebp+var_C]
.text:000037C4                 mov     large fs:0, ecx
.text:000037CB                 pop     ecx
.text:000037CC                 pop     edi
.text:000037CD                 pop     esi
.text:000037CE                 mov     ecx, [ebp+var_10]
.text:000037D1                 xor     ecx, ebp
.text:000037D3                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text:000037D8                 add     esp, 0E8h
.text:000037DE                 cmp     ebp, esp
.text:000037E0                 call    __RTC_CheckEsp
.text:000037E5                 mov     esp, ebp
.text:000037E7                 pop     ebp
.text:000037E8                 retn    0Ch
.text:000037E8 ?SetAddCommandOptions@@YGXW4EEnum@NCommandType@@ABVCParser@NCommandLineParser@@AAUCUpdateOptions@@@Z endp ; sp-analysis failed
.text:000037E8
.text:000037E8 ; ---------------------------------------------------------------------------
.text:000037EB                 align 4
.text:000037EC $LN25_2         dd 3                    ; DATA XREF: SetAddCommandOptions(NCommandType::EEnum,NCommandLineParser::CParser const &,CUpdateOptions &)+2B0o
.text:000037F0                 dd offset $LN24_2
.text:000037F4 $LN24_2         dd 0FFFFFFD0h, 1Ch      ; DATA XREF: .text:000037F0o
.text:000037FC                 dd offset $LN20         ; "defaultActionSet"
.text:00003800                 dd 0FFFFFF48h, 80h
.text:00003808                 dd offset $LN21_1       ; "updateMainCommand"
.text:0000380C                 dd 0FFFFFF2Ch, 8
.text:00003814                 dd offset $LN22_2       ; "size"
.text:00003818 $LN22_2         db 'size',0             ; DATA XREF: .text:00003814o
.text:0000381D $LN21_1         db 'updateMainCommand',0 ; DATA XREF: .text:00003808o
.text:0000382F $LN20           db 'defaultActionSet',0 ; DATA XREF: .text:000037FCo
.text:00003840                 db 4 dup(0CCh)
.text:00003844
.text:00003844 ; =============== S U B R O U T I N E =======================================
.text:00003844
.text:00003844 ; Attributes: bp-based frame
.text:00003844
.text:00003844 ; void __stdcall ParseUpdateCommandString(struct CUpdateOptions &, class CObjectVector<class UString> const &, struct NUpdateArchive::CActionSet const &)
.text:00003844 ?ParseUpdateCommandString@@YGXAAUCUpdateOptions@@ABV?$CObjectVector@VUString@@@@ABUCActionSet@NUpdateArchive@@@Z proc near
.text:00003844                                         ; CODE XREF: SetAddCommandOptions(NCommandType::EEnum,NCommandLineParser::CParser const &,CUpdateOptions &)+F7p
.text:00003844
.text:00003844 var_FC          = byte ptr -0FCh
.text:00003844 var_EC          = byte ptr -0ECh
.text:00003844 var_D8          = byte ptr -0D8h
.text:00003844 var_74          = byte ptr -74h
.text:00003844 var_50          = byte ptr -50h
.text:00003844 var_3C          = dword ptr -3Ch
.text:00003844 var_1C          = dword ptr -1Ch
.text:00003844 var_18          = dword ptr -18h
.text:00003844 var_14          = dword ptr -14h
.text:00003844 var_10          = dword ptr -10h
.text:00003844 var_C           = dword ptr -0Ch
.text:00003844 var_4           = dword ptr -4
.text:00003844 arg_0           = dword ptr  8
.text:00003844 arg_4           = dword ptr  0Ch
.text:00003844 arg_8           = dword ptr  10h
.text:00003844
.text:00003844                 push    ebp
.text:00003845                 mov     ebp, esp
.text:00003847                 push    0FFFFFFFFh
.text:00003849                 push    offset __ehhandler$?ParseUpdateCommandString@@YGXAAUCUpdateOptions@@ABV?$CObjectVector@VUString@@@@ABUCActionSet@NUpdateArchive@@@Z
.text:0000384E                 mov     eax, large fs:0
.text:00003854                 push    eax
.text:00003855                 sub     esp, 0F0h
.text:0000385B                 push    esi
.text:0000385C                 push    edi
.text:0000385D                 lea     edi, [ebp+var_FC]
.text:00003863                 mov     ecx, 3Ch ; '<'
.text:00003868                 mov     eax, 0CCCCCCCCh
.text:0000386D                 rep stosd
.text:0000386F                 mov     eax, dword ptr ds:___security_cookie
.text:00003874                 xor     eax, ebp
.text:00003876                 mov     [ebp+var_10], eax
.text:00003879                 push    eax
.text:0000387A                 lea     eax, [ebp+var_C]
.text:0000387D                 mov     large fs:0, eax
.text:00003883                 mov     [ebp+var_14], offset $SG77364 ; "incorrect update switch command"
.text:0000388A                 mov     [ebp+var_18], 0
.text:00003891                 jmp     short loc_389C
.text:00003893 ; ---------------------------------------------------------------------------
.text:00003893
.text:00003893 loc_3893:                               ; CODE XREF: ParseUpdateCommandString(CUpdateOptions &,CObjectVector<UString> const &,NUpdateArchive::CActionSet const &):loc_3A65j
.text:00003893                 mov     eax, [ebp+var_18]
.text:00003896                 add     eax, 1
.text:00003899                 mov     [ebp+var_18], eax
.text:0000389C
.text:0000389C loc_389C:                               ; CODE XREF: ParseUpdateCommandString(CUpdateOptions &,CObjectVector<UString> const &,NUpdateArchive::CActionSet const &)+4Dj
.text:0000389C                 mov     ecx, [ebp+arg_4]
.text:0000389F                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:000038A4                 cmp     [ebp+var_18], eax
.text:000038A7                 jnb     loc_3A6A
.text:000038AD                 mov     ecx, [ebp+var_18]
.text:000038B0                 push    ecx
.text:000038B1                 mov     ecx, [ebp+arg_4]
.text:000038B4                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:000038B9                 mov     [ebp+var_1C], eax
.text:000038BC                 mov     edx, ds:_kUpdateIgnoreItselfPostStringID
.text:000038C2                 push    edx             ; char *
.text:000038C3                 mov     ecx, [ebp+var_1C] ; this
.text:000038C6                 call    ?IsEqualTo@UString@@QBE_NPBD@Z ; UString::IsEqualTo(char const *)
.text:000038CB                 movzx   eax, al
.text:000038CE                 test    eax, eax
.text:000038D0                 jz      short loc_38F6
.text:000038D2                 mov     ecx, [ebp+arg_0]
.text:000038D5                 movzx   edx, byte ptr [ecx+44h]
.text:000038D9                 test    edx, edx
.text:000038DB                 jz      short loc_38F1
.text:000038DD                 mov     eax, [ebp+arg_0]
.text:000038E0                 mov     byte ptr [eax+44h], 0
.text:000038E4                 push    0
.text:000038E6                 mov     ecx, [ebp+arg_0]
.text:000038E9                 add     ecx, 38h ; '8'
.text:000038EC                 call    ?Delete@?$CObjectVector@UCUpdateArchiveCommand@@@@QAEXI@Z ; CObjectVector<CUpdateArchiveCommand>::Delete(uint)
.text:000038F1
.text:000038F1 loc_38F1:                               ; CODE XREF: ParseUpdateCommandString(CUpdateOptions &,CObjectVector<UString> const &,NUpdateArchive::CActionSet const &)+97j
.text:000038F1                 jmp     loc_3A65
.text:000038F6 ; ---------------------------------------------------------------------------
.text:000038F6
.text:000038F6 loc_38F6:                               ; CODE XREF: ParseUpdateCommandString(CUpdateOptions &,CObjectVector<UString> const &,NUpdateArchive::CActionSet const &)+8Cj
.text:000038F6                 mov     esi, [ebp+arg_8]
.text:000038F9                 mov     ecx, 7
.text:000038FE                 lea     edi, [ebp+var_3C]
.text:00003901                 rep movsd
.text:00003903                 lea     ecx, [ebp+var_50]
.text:00003906                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:0000390B                 mov     [ebp+var_4], 0
.text:00003912                 lea     ecx, [ebp+var_50]
.text:00003915                 push    ecx             ; UString *
.text:00003916                 lea     edx, [ebp+var_3C]
.text:00003919                 push    edx             ; int
.text:0000391A                 mov     eax, [ebp+var_1C]
.text:0000391D                 push    eax             ; UString *
.text:0000391E                 call    ?ParseUpdateCommandString2@@YG_NABVUString@@AAUCActionSet@NUpdateArchive@@AAV1@@Z ; ParseUpdateCommandString2(UString const &,NUpdateArchive::CActionSet &,UString &)
.text:00003923                 movzx   ecx, al
.text:00003926                 test    ecx, ecx
.text:00003928                 jnz     short loc_393E
.text:0000392A                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00003931                 lea     ecx, [ebp+var_50] ; this
.text:00003934                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003939                 jmp     loc_3A6A
.text:0000393E ; ---------------------------------------------------------------------------
.text:0000393E
.text:0000393E loc_393E:                               ; CODE XREF: ParseUpdateCommandString(CUpdateOptions &,CObjectVector<UString> const &,NUpdateArchive::CActionSet const &)+E4j
.text:0000393E                 lea     ecx, [ebp+var_50] ; this
.text:00003941                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:00003946                 movzx   edx, al
.text:00003949                 test    edx, edx
.text:0000394B                 jz      short loc_3979
.text:0000394D                 mov     eax, [ebp+arg_0]
.text:00003950                 movzx   ecx, byte ptr [eax+44h]
.text:00003954                 test    ecx, ecx
.text:00003956                 jz      short loc_3974
.text:00003958                 push    0
.text:0000395A                 mov     ecx, [ebp+arg_0]
.text:0000395D                 add     ecx, 38h ; '8'
.text:00003960                 call    ??A?$CObjectVector@UCUpdateArchiveCommand@@@@QAEAAUCUpdateArchiveCommand@@I@Z ; CObjectVector<CUpdateArchiveCommand>::operator[](uint)
.text:00003965                 add     eax, 64h ; 'd'
.text:00003968                 mov     ecx, 7
.text:0000396D                 lea     esi, [ebp+var_3C]
.text:00003970                 mov     edi, eax
.text:00003972                 rep movsd
.text:00003974
.text:00003974 loc_3974:                               ; CODE XREF: ParseUpdateCommandString(CUpdateOptions &,CObjectVector<UString> const &,NUpdateArchive::CActionSet const &)+112j
.text:00003974                 jmp     loc_3A56
.text:00003979 ; ---------------------------------------------------------------------------
.text:00003979
.text:00003979 loc_3979:                               ; CODE XREF: ParseUpdateCommandString(CUpdateOptions &,CObjectVector<UString> const &,NUpdateArchive::CActionSet const &)+107j
.text:00003979                 lea     ecx, [ebp+var_50]
.text:0000397C                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00003981                 movzx   edx, word ptr [eax]
.text:00003984                 cmp     edx, 21h ; '!'
.text:00003987                 jz      short loc_399D
.text:00003989                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00003990                 lea     ecx, [ebp+var_50] ; this
.text:00003993                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003998                 jmp     loc_3A6A
.text:0000399D ; ---------------------------------------------------------------------------
.text:0000399D
.text:0000399D loc_399D:                               ; CODE XREF: ParseUpdateCommandString(CUpdateOptions &,CObjectVector<UString> const &,NUpdateArchive::CActionSet const &)+143j
.text:0000399D                 lea     ecx, [ebp+var_D8] ; this
.text:000039A3                 call    ??0CUpdateArchiveCommand@@QAE@XZ ; CUpdateArchiveCommand::CUpdateArchiveCommand(void)
.text:000039A8                 mov     byte ptr [ebp+var_4], 1
.text:000039AC                 push    1               ; unsigned int
.text:000039AE                 lea     ecx, [ebp+var_50] ; this
.text:000039B1                 call    ?Ptr@UString@@QBEPB_WI@Z ; UString::Ptr(uint)
.text:000039B6                 push    eax
.text:000039B7                 lea     ecx, [ebp+var_EC]
.text:000039BD                 call    ??0UString@@QAE@PB_W@Z ; UString::UString(wchar_t const *)
.text:000039C2                 mov     byte ptr [ebp+var_4], 2
.text:000039C6                 lea     ecx, [ebp+var_EC] ; this
.text:000039CC                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:000039D1                 movzx   eax, al
.text:000039D4                 test    eax, eax
.text:000039D6                 jz      short loc_3A07
.text:000039D8                 mov     byte ptr [ebp+var_4], 1
.text:000039DC                 lea     ecx, [ebp+var_EC] ; this
.text:000039E2                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000039E7                 mov     byte ptr [ebp+var_4], 0
.text:000039EB                 lea     ecx, [ebp+var_D8] ; this
.text:000039F1                 call    ??1CUpdateArchiveCommand@@QAE@XZ ; CUpdateArchiveCommand::~CUpdateArchiveCommand(void)
.text:000039F6                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000039FD                 lea     ecx, [ebp+var_50] ; this
.text:00003A00                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003A05                 jmp     short loc_3A6A
.text:00003A07 ; ---------------------------------------------------------------------------
.text:00003A07
.text:00003A07 loc_3A07:                               ; CODE XREF: ParseUpdateCommandString(CUpdateOptions &,CObjectVector<UString> const &,NUpdateArchive::CActionSet const &)+192j
.text:00003A07                 lea     ecx, [ebp+var_EC]
.text:00003A0D                 push    ecx
.text:00003A0E                 lea     ecx, [ebp+var_D8]
.text:00003A14                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:00003A19                 mov     ecx, 7
.text:00003A1E                 lea     esi, [ebp+var_3C]
.text:00003A21                 lea     edi, [ebp+var_74]
.text:00003A24                 rep movsd
.text:00003A26                 lea     edx, [ebp+var_D8]
.text:00003A2C                 push    edx
.text:00003A2D                 mov     ecx, [ebp+arg_0]
.text:00003A30                 add     ecx, 38h ; '8'
.text:00003A33                 call    ?Add@?$CObjectVector@UCUpdateArchiveCommand@@@@QAEIABUCUpdateArchiveCommand@@@Z ; CObjectVector<CUpdateArchiveCommand>::Add(CUpdateArchiveCommand const &)
.text:00003A38                 mov     byte ptr [ebp+var_4], 1
.text:00003A3C                 lea     ecx, [ebp+var_EC] ; this
.text:00003A42                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003A47                 mov     byte ptr [ebp+var_4], 0
.text:00003A4B                 lea     ecx, [ebp+var_D8] ; this
.text:00003A51                 call    ??1CUpdateArchiveCommand@@QAE@XZ ; CUpdateArchiveCommand::~CUpdateArchiveCommand(void)
.text:00003A56
.text:00003A56 loc_3A56:                               ; CODE XREF: ParseUpdateCommandString(CUpdateOptions &,CObjectVector<UString> const &,NUpdateArchive::CActionSet const &):loc_3974j
.text:00003A56                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00003A5D                 lea     ecx, [ebp+var_50] ; this
.text:00003A60                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003A65
.text:00003A65 loc_3A65:                               ; CODE XREF: ParseUpdateCommandString(CUpdateOptions &,CObjectVector<UString> const &,NUpdateArchive::CActionSet const &):loc_38F1j
.text:00003A65                 jmp     loc_3893
.text:00003A6A ; ---------------------------------------------------------------------------
.text:00003A6A
.text:00003A6A loc_3A6A:                               ; CODE XREF: ParseUpdateCommandString(CUpdateOptions &,CObjectVector<UString> const &,NUpdateArchive::CActionSet const &)+63j
.text:00003A6A                                         ; ParseUpdateCommandString(CUpdateOptions &,CObjectVector<UString> const &,NUpdateArchive::CActionSet const &)+F5j ...
.text:00003A6A                 mov     ecx, [ebp+arg_4]
.text:00003A6D                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:00003A72                 cmp     [ebp+var_18], eax
.text:00003A75                 jz      short loc_3AAB
.text:00003A77                 mov     eax, [ebp+var_18]
.text:00003A7A                 push    eax
.text:00003A7B                 mov     ecx, [ebp+arg_4]
.text:00003A7E                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00003A83                 mov     ecx, eax
.text:00003A85                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00003A8A                 push    eax
.text:00003A8B                 mov     ecx, [ebp+var_14]
.text:00003A8E                 push    ecx
.text:00003A8F                 lea     ecx, [ebp+var_FC]
.text:00003A95                 call    ??0CArcCmdLineException@@QAE@PBDPB_W@Z ; CArcCmdLineException::CArcCmdLineException(char const *,wchar_t const *)
.text:00003A9A                 push    offset __TI2?AUCArcCmdLineException@@
.text:00003A9F                 lea     edx, [ebp+var_FC]
.text:00003AA5                 push    edx
.text:00003AA6                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:00003AAB ; ---------------------------------------------------------------------------
.text:00003AAB
.text:00003AAB loc_3AAB:                               ; CODE XREF: ParseUpdateCommandString(CUpdateOptions &,CObjectVector<UString> const &,NUpdateArchive::CActionSet const &)+231j
.text:00003AAB                 push    edx
.text:00003AAC                 mov     ecx, ebp
.text:00003AAE                 push    eax
.text:00003AAF                 lea     edx, $LN25_3
.text:00003AB5                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00003ABA                 pop     eax
.text:00003ABB                 pop     edx
.text:00003ABC                 mov     ecx, [ebp+var_C]
.text:00003ABF                 mov     large fs:0, ecx
.text:00003AC6                 pop     ecx
.text:00003AC7                 pop     edi
.text:00003AC8                 pop     esi
.text:00003AC9                 mov     ecx, [ebp+var_10]
.text:00003ACC                 xor     ecx, ebp
.text:00003ACE                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text:00003AD3                 add     esp, 0FCh
.text:00003AD9                 cmp     ebp, esp
.text:00003ADB                 call    __RTC_CheckEsp
.text:00003AE0                 mov     esp, ebp
.text:00003AE2                 pop     ebp
.text:00003AE3                 retn    0Ch
.text:00003AE3 ?ParseUpdateCommandString@@YGXAAUCUpdateOptions@@ABV?$CObjectVector@VUString@@@@ABUCActionSet@NUpdateArchive@@@Z endp
.text:00003AE3
.text:00003AE3 ; ---------------------------------------------------------------------------
.text:00003AE6                 align 4
.text:00003AE8 $LN25_3         dd 4                    ; DATA XREF: ParseUpdateCommandString(CUpdateOptions &,CObjectVector<UString> const &,NUpdateArchive::CActionSet const &)+26Bo
.text:00003AEC                 dd offset $LN24_3
.text:00003AF0 $LN24_3         dd 0FFFFFFC4h, 1Ch      ; DATA XREF: .text:00003AECo
.text:00003AF8                 dd offset $LN19         ; "actionSet"
.text:00003AFC                 dd 0FFFFFFB0h, 0Ch
.text:00003B04                 dd offset $LN20_0       ; "postString"
.text:00003B08                 dd 0FFFFFF28h, 80h
.text:00003B10                 dd offset $LN21_2       ; "uc"
.text:00003B14                 dd 0FFFFFF14h, 0Ch
.text:00003B1C                 dd offset $LN22_3       ; "archivePath"
.text:00003B20 $LN22_3         db 'archivePath',0      ; DATA XREF: .text:00003B1Co
.text:00003B2C $LN21_2         db 'uc',0               ; DATA XREF: .text:00003B10o
.text:00003B2F $LN20_0         db 'postString',0       ; DATA XREF: .text:00003B04o
.text:00003B3A $LN19           db 'actionSet',0        ; DATA XREF: .text:00003AF8o
.text:00003B44
.text:00003B44 ; =============== S U B R O U T I N E =======================================
.text:00003B44
.text:00003B44 ; Attributes: bp-based frame
.text:00003B44
.text:00003B44 ; int __stdcall ParseUpdateCommandString2(UString *, int, UString *)
.text:00003B44 ?ParseUpdateCommandString2@@YG_NABVUString@@AAUCActionSet@NUpdateArchive@@AAV1@@Z proc near
.text:00003B44                                         ; CODE XREF: ParseUpdateCommandString(CUpdateOptions &,CObjectVector<UString> const &,NUpdateArchive::CActionSet const &)+DAp
.text:00003B44
.text:00003B44 var_10          = dword ptr -10h
.text:00003B44 var_C           = dword ptr -0Ch
.text:00003B44 var_8           = dword ptr -8
.text:00003B44 var_4           = dword ptr -4
.text:00003B44 arg_0           = dword ptr  8
.text:00003B44 arg_4           = dword ptr  0Ch
.text:00003B44 arg_8           = dword ptr  10h
.text:00003B44
.text:00003B44                 push    ebp
.text:00003B45                 mov     ebp, esp
.text:00003B47                 sub     esp, 10h
.text:00003B4A                 mov     eax, 0CCCCCCCCh
.text:00003B4F                 mov     [ebp+var_10], eax
.text:00003B52                 mov     [ebp+var_C], eax
.text:00003B55                 mov     [ebp+var_8], eax
.text:00003B58                 mov     [ebp+var_4], eax
.text:00003B5B                 mov     [ebp+var_4], 0
.text:00003B62
.text:00003B62 loc_3B62:                               ; CODE XREF: ParseUpdateCommandString2(UString const &,NUpdateArchive::CActionSet &,UString &)+F3j
.text:00003B62                 mov     ecx, [ebp+arg_0] ; this
.text:00003B65                 call    ?Len@UString@@QBEIXZ ; UString::Len(void)
.text:00003B6A                 cmp     [ebp+var_4], eax
.text:00003B6D                 jnb     loc_3C3C
.text:00003B73                 mov     ecx, [ebp+arg_0]
.text:00003B76                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00003B7B                 mov     ecx, [ebp+var_4]
.text:00003B7E                 movzx   edx, word ptr [eax+ecx*2]
.text:00003B82                 push    edx             ; wchar_t
.text:00003B83                 call    ?MyCharLower_Ascii@@YG_W_W@Z ; MyCharLower_Ascii(wchar_t)
.text:00003B88                 mov     word ptr [ebp+var_8], ax
.text:00003B8C                 movzx   eax, word ptr [ebp+var_8]
.text:00003B90                 push    eax             ; wchar_t
.text:00003B91                 mov     ecx, ds:_kUpdatePairStateIDSet
.text:00003B97                 push    ecx             ; wchar_t *
.text:00003B98                 call    ?FindCharPosInString@@YGHPB_W_W@Z ; FindCharPosInString(wchar_t const *,wchar_t)
.text:00003B9D                 mov     [ebp+var_C], eax
.text:00003BA0                 cmp     [ebp+var_C], 0
.text:00003BA4                 jge     short loc_3BC2
.text:00003BA6                 mov     edx, [ebp+var_4]
.text:00003BA9                 push    edx             ; unsigned int
.text:00003BAA                 mov     ecx, [ebp+arg_0] ; this
.text:00003BAD                 call    ?Ptr@UString@@QBEPB_WI@Z ; UString::Ptr(uint)
.text:00003BB2                 push    eax
.text:00003BB3                 mov     ecx, [ebp+arg_8]
.text:00003BB6                 call    ??4UString@@QAEAAV0@PB_W@Z ; UString::operator=(wchar_t const *)
.text:00003BBB                 mov     al, 1
.text:00003BBD                 jmp     loc_3C46
.text:00003BC2 ; ---------------------------------------------------------------------------
.text:00003BC2
.text:00003BC2 loc_3BC2:                               ; CODE XREF: ParseUpdateCommandString2(UString const &,NUpdateArchive::CActionSet &,UString &)+60j
.text:00003BC2                 mov     eax, [ebp+var_4]
.text:00003BC5                 add     eax, 1
.text:00003BC8                 mov     [ebp+var_4], eax
.text:00003BCB                 mov     ecx, [ebp+arg_0] ; this
.text:00003BCE                 call    ?Len@UString@@QBEIXZ ; UString::Len(void)
.text:00003BD3                 cmp     [ebp+var_4], eax
.text:00003BD6                 jb      short loc_3BDC
.text:00003BD8                 xor     al, al
.text:00003BDA                 jmp     short loc_3C46
.text:00003BDC ; ---------------------------------------------------------------------------
.text:00003BDC
.text:00003BDC loc_3BDC:                               ; CODE XREF: ParseUpdateCommandString2(UString const &,NUpdateArchive::CActionSet &,UString &)+92j
.text:00003BDC                 mov     ecx, [ebp+arg_0]
.text:00003BDF                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00003BE4                 mov     ecx, [ebp+var_4]
.text:00003BE7                 mov     dx, [eax+ecx*2]
.text:00003BEB                 mov     word ptr [ebp+var_8], dx
.text:00003BEF                 movzx   eax, word ptr [ebp+var_8]
.text:00003BF3                 cmp     eax, 30h ; '0'
.text:00003BF6                 jl      short loc_3C01
.text:00003BF8                 movzx   ecx, word ptr [ebp+var_8]
.text:00003BFC                 cmp     ecx, 34h ; '4'
.text:00003BFF                 jb      short loc_3C05
.text:00003C01
.text:00003C01 loc_3C01:                               ; CODE XREF: ParseUpdateCommandString2(UString const &,NUpdateArchive::CActionSet &,UString &)+B2j
.text:00003C01                 xor     al, al
.text:00003C03                 jmp     short loc_3C46
.text:00003C05 ; ---------------------------------------------------------------------------
.text:00003C05
.text:00003C05 loc_3C05:                               ; CODE XREF: ParseUpdateCommandString2(UString const &,NUpdateArchive::CActionSet &,UString &)+BBj
.text:00003C05                 movzx   edx, word ptr [ebp+var_8]
.text:00003C09                 sub     edx, 30h ; '0'
.text:00003C0C                 mov     [ebp+var_10], edx
.text:00003C0F                 mov     eax, [ebp+var_C]
.text:00003C12                 mov     ecx, [ebp+arg_4]
.text:00003C15                 mov     edx, [ebp+var_10]
.text:00003C18                 mov     [ecx+eax*4], edx
.text:00003C1B                 mov     eax, [ebp+var_C]
.text:00003C1E                 mov     ecx, _kUpdatePairStateNotSupportedActions[eax*4]
.text:00003C25                 cmp     ecx, [ebp+var_10]
.text:00003C28                 jnz     short loc_3C2E
.text:00003C2A                 xor     al, al
.text:00003C2C                 jmp     short loc_3C46
.text:00003C2E ; ---------------------------------------------------------------------------
.text:00003C2E
.text:00003C2E loc_3C2E:                               ; CODE XREF: ParseUpdateCommandString2(UString const &,NUpdateArchive::CActionSet &,UString &)+E4j
.text:00003C2E                 mov     edx, [ebp+var_4]
.text:00003C31                 add     edx, 1
.text:00003C34                 mov     [ebp+var_4], edx
.text:00003C37                 jmp     loc_3B62
.text:00003C3C ; ---------------------------------------------------------------------------
.text:00003C3C
.text:00003C3C loc_3C3C:                               ; CODE XREF: ParseUpdateCommandString2(UString const &,NUpdateArchive::CActionSet &,UString &)+29j
.text:00003C3C                 mov     ecx, [ebp+arg_8] ; this
.text:00003C3F                 call    ?Empty@UString@@QAEXXZ ; UString::Empty(void)
.text:00003C44                 mov     al, 1
.text:00003C46
.text:00003C46 loc_3C46:                               ; CODE XREF: ParseUpdateCommandString2(UString const &,NUpdateArchive::CActionSet &,UString &)+79j
.text:00003C46                                         ; ParseUpdateCommandString2(UString const &,NUpdateArchive::CActionSet &,UString &)+96j ...
.text:00003C46                 add     esp, 10h
.text:00003C49                 cmp     ebp, esp
.text:00003C4B                 call    __RTC_CheckEsp
.text:00003C50                 mov     esp, ebp
.text:00003C52                 pop     ebp
.text:00003C53                 retn    0Ch
.text:00003C53 ?ParseUpdateCommandString2@@YG_NABVUString@@AAUCActionSet@NUpdateArchive@@AAV1@@Z endp
.text:00003C53
.text:00003C53 ; ---------------------------------------------------------------------------
.text:00003C56                 db 0Eh dup(0CCh)
.text:00003C64
.text:00003C64 ; =============== S U B R O U T I N E =======================================
.text:00003C64
.text:00003C64 ; Attributes: bp-based frame
.text:00003C64
.text:00003C64 ; void __stdcall SetMethodOptions(class NCommandLineParser::CParser const &, class CObjectVector<struct CProperty> &)
.text:00003C64 ?SetMethodOptions@@YGXABVCParser@NCommandLineParser@@AAV?$CObjectVector@UCProperty@@@@@Z proc near
.text:00003C64                                         ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+50Ap
.text:00003C64
.text:00003C64 var_34          = dword ptr -34h
.text:00003C64 var_2C          = byte ptr -2Ch
.text:00003C64 var_20          = byte ptr -20h
.text:00003C64 var_10          = dword ptr -10h
.text:00003C64 var_C           = dword ptr -0Ch
.text:00003C64 var_4           = dword ptr -4
.text:00003C64 arg_0           = dword ptr  8
.text:00003C64 arg_4           = dword ptr  0Ch
.text:00003C64
.text:00003C64                 push    ebp
.text:00003C65                 mov     ebp, esp
.text:00003C67                 push    0FFFFFFFFh
.text:00003C69                 push    offset __ehhandler$?SetMethodOptions@@YGXABVCParser@NCommandLineParser@@AAV?$CObjectVector@UCProperty@@@@@Z
.text:00003C6E                 mov     eax, large fs:0
.text:00003C74                 push    eax
.text:00003C75                 sub     esp, 28h
.text:00003C78                 push    edi
.text:00003C79                 lea     edi, [ebp+var_34]
.text:00003C7C                 mov     ecx, 0Ah
.text:00003C81                 mov     eax, 0CCCCCCCCh
.text:00003C86                 rep stosd
.text:00003C88                 mov     eax, dword ptr ds:___security_cookie
.text:00003C8D                 xor     eax, ebp
.text:00003C8F                 push    eax
.text:00003C90                 lea     eax, [ebp+var_C]
.text:00003C93                 mov     large fs:0, eax
.text:00003C99                 push    0Fh
.text:00003C9B                 mov     ecx, [ebp+arg_0]
.text:00003C9E                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00003CA3                 movzx   eax, byte ptr [eax]
.text:00003CA6                 test    eax, eax
.text:00003CA8                 jz      loc_3D64
.text:00003CAE                 mov     [ebp+var_10], 0
.text:00003CB5                 jmp     short loc_3CC0
.text:00003CB7 ; ---------------------------------------------------------------------------
.text:00003CB7
.text:00003CB7 loc_3CB7:                               ; CODE XREF: SetMethodOptions(NCommandLineParser::CParser const &,CObjectVector<CProperty> &)+FBj
.text:00003CB7                 mov     ecx, [ebp+var_10]
.text:00003CBA                 add     ecx, 1
.text:00003CBD                 mov     [ebp+var_10], ecx
.text:00003CC0
.text:00003CC0 loc_3CC0:                               ; CODE XREF: SetMethodOptions(NCommandLineParser::CParser const &,CObjectVector<CProperty> &)+51j
.text:00003CC0                 push    0Fh
.text:00003CC2                 mov     ecx, [ebp+arg_0]
.text:00003CC5                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00003CCA                 add     eax, 8
.text:00003CCD                 mov     ecx, eax
.text:00003CCF                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:00003CD4                 cmp     [ebp+var_10], eax
.text:00003CD7                 jnb     loc_3D64
.text:00003CDD                 lea     ecx, [ebp+var_2C] ; this
.text:00003CE0                 call    ??0CProperty@@QAE@XZ ; CProperty::CProperty(void)
.text:00003CE5                 mov     [ebp+var_4], 0
.text:00003CEC                 mov     edx, [ebp+var_10]
.text:00003CEF                 push    edx
.text:00003CF0                 push    0Fh
.text:00003CF2                 mov     ecx, [ebp+arg_0]
.text:00003CF5                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00003CFA                 add     eax, 8
.text:00003CFD                 mov     ecx, eax
.text:00003CFF                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00003D04                 push    eax
.text:00003D05                 lea     ecx, [ebp+var_2C]
.text:00003D08                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:00003D0D                 push    3Dh ; '='       ; wchar_t
.text:00003D0F                 lea     ecx, [ebp+var_2C] ; this
.text:00003D12                 call    ?Find@UString@@QBEH_W@Z ; UString::Find(wchar_t)
.text:00003D17                 mov     [ebp+var_34], eax
.text:00003D1A                 cmp     [ebp+var_34], 0
.text:00003D1E                 jl      short loc_3D44
.text:00003D20                 mov     eax, [ebp+var_34]
.text:00003D23                 add     eax, 1
.text:00003D26                 push    eax             ; unsigned int
.text:00003D27                 lea     ecx, [ebp+var_2C] ; this
.text:00003D2A                 call    ?Ptr@UString@@QBEPB_WI@Z ; UString::Ptr(uint)
.text:00003D2F                 push    eax
.text:00003D30                 lea     ecx, [ebp+var_20]
.text:00003D33                 call    ??4UString@@QAEAAV0@PB_W@Z ; UString::operator=(wchar_t const *)
.text:00003D38                 mov     ecx, [ebp+var_34]
.text:00003D3B                 push    ecx             ; unsigned int
.text:00003D3C                 lea     ecx, [ebp+var_2C] ; this
.text:00003D3F                 call    ?DeleteFrom@UString@@QAEXI@Z ; UString::DeleteFrom(uint)
.text:00003D44
.text:00003D44 loc_3D44:                               ; CODE XREF: SetMethodOptions(NCommandLineParser::CParser const &,CObjectVector<CProperty> &)+BAj
.text:00003D44                 lea     edx, [ebp+var_2C]
.text:00003D47                 push    edx
.text:00003D48                 mov     ecx, [ebp+arg_4]
.text:00003D4B                 call    ?Add@?$CObjectVector@UCProperty@@@@QAEIABUCProperty@@@Z ; CObjectVector<CProperty>::Add(CProperty const &)
.text:00003D50                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00003D57                 lea     ecx, [ebp+var_2C] ; this
.text:00003D5A                 call    ??1CProperty@@QAE@XZ ; CProperty::~CProperty(void)
.text:00003D5F                 jmp     loc_3CB7
.text:00003D64 ; ---------------------------------------------------------------------------
.text:00003D64
.text:00003D64 loc_3D64:                               ; CODE XREF: SetMethodOptions(NCommandLineParser::CParser const &,CObjectVector<CProperty> &)+44j
.text:00003D64                                         ; SetMethodOptions(NCommandLineParser::CParser const &,CObjectVector<CProperty> &)+73j
.text:00003D64                 push    edx
.text:00003D65                 mov     ecx, ebp
.text:00003D67                 push    eax
.text:00003D68                 lea     edx, $LN12_0
.text:00003D6E                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00003D73                 pop     eax
.text:00003D74                 pop     edx
.text:00003D75                 mov     ecx, [ebp+var_C]
.text:00003D78                 mov     large fs:0, ecx
.text:00003D7F                 pop     ecx
.text:00003D80                 pop     edi
.text:00003D81                 add     esp, 34h
.text:00003D84                 cmp     ebp, esp
.text:00003D86                 call    __RTC_CheckEsp
.text:00003D8B                 mov     esp, ebp
.text:00003D8D                 pop     ebp
.text:00003D8E                 retn    8
.text:00003D8E ?SetMethodOptions@@YGXABVCParser@NCommandLineParser@@AAV?$CObjectVector@UCProperty@@@@@Z endp
.text:00003D8E
.text:00003D8E ; ---------------------------------------------------------------------------
.text:00003D91                 align 4
.text:00003D94 $LN12_0         dd 1                    ; DATA XREF: SetMethodOptions(NCommandLineParser::CParser const &,CObjectVector<CProperty> &)+104o
.text:00003D98                 dd offset $LN11_1
.text:00003D9C $LN11_1         dd 0FFFFFFD4h, 18h      ; DATA XREF: .text:00003D98o
.text:00003DA4                 dd offset $LN9_1        ; "prop"
.text:00003DA8 $LN9_1          db 'prop',0             ; DATA XREF: .text:00003DA4o
.text:00003DAD                 db 7 dup(0CCh)
.text:00003DB4
.text:00003DB4 ; =============== S U B R O U T I N E =======================================
.text:00003DB4
.text:00003DB4 ; Attributes: bp-based frame
.text:00003DB4
.text:00003DB4 ; int __stdcall FindCharset(class NCommandLineParser::CParser const &, unsigned int, bool, int)
.text:00003DB4 ?FindCharset@@YGHABVCParser@NCommandLineParser@@I_NH@Z proc near
.text:00003DB4                                         ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+1E8p
.text:00003DB4                                         ; CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+1FFp
.text:00003DB4
.text:00003DB4 var_4C          = dword ptr -4Ch
.text:00003DB4 var_48          = byte ptr -48h
.text:00003DB4 var_3C          = dword ptr -3Ch
.text:00003DB4 var_38          = dword ptr -38h
.text:00003DB4 var_34          = dword ptr -34h
.text:00003DB4 var_30          = dword ptr -30h
.text:00003DB4 var_28          = dword ptr -28h
.text:00003DB4 var_1C          = byte ptr -1Ch
.text:00003DB4 var_C           = dword ptr -0Ch
.text:00003DB4 var_4           = dword ptr -4
.text:00003DB4 arg_0           = dword ptr  8
.text:00003DB4 arg_4           = dword ptr  0Ch
.text:00003DB4 arg_8           = byte ptr  10h
.text:00003DB4 arg_C           = dword ptr  14h
.text:00003DB4
.text:00003DB4                 push    ebp
.text:00003DB5                 mov     ebp, esp
.text:00003DB7                 push    0FFFFFFFFh
.text:00003DB9                 push    offset __ehhandler$?FindCharset@@YGHABVCParser@NCommandLineParser@@I_NH@Z
.text:00003DBE                 mov     eax, large fs:0
.text:00003DC4                 push    eax
.text:00003DC5                 sub     esp, 40h
.text:00003DC8                 push    edi
.text:00003DC9                 lea     edi, [ebp+var_4C]
.text:00003DCC                 mov     ecx, 10h
.text:00003DD1                 mov     eax, 0CCCCCCCCh
.text:00003DD6                 rep stosd
.text:00003DD8                 mov     eax, dword ptr ds:___security_cookie
.text:00003DDD                 xor     eax, ebp
.text:00003DDF                 push    eax
.text:00003DE0                 lea     eax, [ebp+var_C]
.text:00003DE3                 mov     large fs:0, eax
.text:00003DE9                 mov     eax, [ebp+arg_4]
.text:00003DEC                 push    eax
.text:00003DED                 mov     ecx, [ebp+arg_0]
.text:00003DF0                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00003DF5                 movzx   ecx, byte ptr [eax]
.text:00003DF8                 test    ecx, ecx
.text:00003DFA                 jnz     short loc_3E04
.text:00003DFC                 mov     eax, [ebp+arg_C]
.text:00003DFF                 jmp     loc_3F10
.text:00003E04 ; ---------------------------------------------------------------------------
.text:00003E04
.text:00003E04 loc_3E04:                               ; CODE XREF: FindCharset(NCommandLineParser::CParser const &,uint,bool,int)+46j
.text:00003E04                 mov     edx, [ebp+arg_4]
.text:00003E07                 push    edx
.text:00003E08                 mov     ecx, [ebp+arg_0]
.text:00003E0B                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00003E10                 add     eax, 8
.text:00003E13                 mov     ecx, eax
.text:00003E15                 call    ?Back@?$CObjectVector@VUString@@@@QBEABVUString@@XZ ; CObjectVector<UString>::Back(void)
.text:00003E1A                 push    eax
.text:00003E1B                 lea     ecx, [ebp+var_1C]
.text:00003E1E                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00003E23                 mov     [ebp+var_4], 0
.text:00003E2A                 lea     eax, [ebp+var_28]
.text:00003E2D                 push    eax             ; int
.text:00003E2E                 lea     ecx, [ebp+var_1C]
.text:00003E31                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00003E36                 push    eax             ; wchar_t *
.text:00003E37                 call    ?StringToUInt32@@YG_NPB_WAAI@Z ; StringToUInt32(wchar_t const *,uint &)
.text:00003E3C                 movzx   ecx, al
.text:00003E3F                 test    ecx, ecx
.text:00003E41                 jz      short loc_3E69
.text:00003E43                 cmp     [ebp+var_28], 10000h
.text:00003E4A                 jnb     short loc_3E69
.text:00003E4C                 mov     edx, [ebp+var_28]
.text:00003E4F                 mov     [ebp+var_3C], edx
.text:00003E52                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00003E59                 lea     ecx, [ebp+var_1C] ; this
.text:00003E5C                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003E61                 mov     eax, [ebp+var_3C]
.text:00003E64                 jmp     loc_3F10
.text:00003E69 ; ---------------------------------------------------------------------------
.text:00003E69
.text:00003E69 loc_3E69:                               ; CODE XREF: FindCharset(NCommandLineParser::CParser const &,uint,bool,int)+8Dj
.text:00003E69                                         ; FindCharset(NCommandLineParser::CParser const &,uint,bool,int)+96j
.text:00003E69                 lea     ecx, [ebp+var_1C] ; this
.text:00003E6C                 call    ?MakeLower_Ascii@UString@@QAEXXZ ; UString::MakeLower_Ascii(void)
.text:00003E71                 movzx   eax, [ebp+arg_8]
.text:00003E75                 neg     eax
.text:00003E77                 sbb     eax, eax
.text:00003E79                 and     eax, 0FFFFFFFEh
.text:00003E7C                 add     eax, 5
.text:00003E7F                 mov     [ebp+var_30], eax
.text:00003E82                 mov     [ebp+var_34], 0
.text:00003E89                 jmp     short loc_3E94
.text:00003E8B ; ---------------------------------------------------------------------------
.text:00003E8B
.text:00003E8B loc_3E8B:                               ; CODE XREF: FindCharset(NCommandLineParser::CParser const &,uint,bool,int):loc_3EFFj
.text:00003E8B                 mov     ecx, [ebp+var_34]
.text:00003E8E                 add     ecx, 1
.text:00003E91                 mov     [ebp+var_34], ecx
.text:00003E94
.text:00003E94 loc_3E94:                               ; CODE XREF: FindCharset(NCommandLineParser::CParser const &,uint,bool,int)+D5j
.text:00003E94                 mov     edx, [ebp+var_34]
.text:00003E97                 cmp     edx, [ebp+var_30]
.text:00003E9A                 jnz     short loc_3EC0
.text:00003E9C                 lea     ecx, [ebp+var_1C]
.text:00003E9F                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00003EA4                 push    eax
.text:00003EA5                 push    offset $SG77519 ; "Unsupported charset:"
.text:00003EAA                 lea     ecx, [ebp+var_48]
.text:00003EAD                 call    ??0CArcCmdLineException@@QAE@PBDPB_W@Z ; CArcCmdLineException::CArcCmdLineException(char const *,wchar_t const *)
.text:00003EB2                 push    offset __TI2?AUCArcCmdLineException@@
.text:00003EB7                 lea     eax, [ebp+var_48]
.text:00003EBA                 push    eax
.text:00003EBB                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:00003EC0 ; ---------------------------------------------------------------------------
.text:00003EC0
.text:00003EC0 loc_3EC0:                               ; CODE XREF: FindCharset(NCommandLineParser::CParser const &,uint,bool,int)+E6j
.text:00003EC0                 mov     ecx, [ebp+var_34]
.text:00003EC3                 lea     edx, _g_CodePagePairs[ecx*8]
.text:00003ECA                 mov     [ebp+var_38], edx
.text:00003ECD                 mov     eax, [ebp+var_38]
.text:00003ED0                 mov     ecx, [eax]
.text:00003ED2                 push    ecx             ; char *
.text:00003ED3                 lea     ecx, [ebp+var_1C] ; this
.text:00003ED6                 call    ?IsEqualTo@UString@@QBE_NPBD@Z ; UString::IsEqualTo(char const *)
.text:00003EDB                 movzx   edx, al
.text:00003EDE                 test    edx, edx
.text:00003EE0                 jz      short loc_3EFF
.text:00003EE2                 mov     eax, [ebp+var_38]
.text:00003EE5                 mov     ecx, [eax+4]
.text:00003EE8                 mov     [ebp+var_4C], ecx
.text:00003EEB                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00003EF2                 lea     ecx, [ebp+var_1C] ; this
.text:00003EF5                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003EFA                 mov     eax, [ebp+var_4C]
.text:00003EFD                 jmp     short loc_3F10
.text:00003EFF ; ---------------------------------------------------------------------------
.text:00003EFF
.text:00003EFF loc_3EFF:                               ; CODE XREF: FindCharset(NCommandLineParser::CParser const &,uint,bool,int)+12Cj
.text:00003EFF                 jmp     short loc_3E8B
.text:00003F01 ; ---------------------------------------------------------------------------
.text:00003F01                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00003F08                 lea     ecx, [ebp+var_1C] ; this
.text:00003F0B                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003F10
.text:00003F10 loc_3F10:                               ; CODE XREF: FindCharset(NCommandLineParser::CParser const &,uint,bool,int)+4Bj
.text:00003F10                                         ; FindCharset(NCommandLineParser::CParser const &,uint,bool,int)+B0j ...
.text:00003F10                 push    edx
.text:00003F11                 mov     ecx, ebp
.text:00003F13                 push    eax
.text:00003F14                 lea     edx, $LN16
.text:00003F1A                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00003F1F                 pop     eax
.text:00003F20                 pop     edx
.text:00003F21                 mov     ecx, [ebp+var_C]
.text:00003F24                 mov     large fs:0, ecx
.text:00003F2B                 pop     ecx
.text:00003F2C                 pop     edi
.text:00003F2D                 add     esp, 4Ch
.text:00003F30                 cmp     ebp, esp
.text:00003F32                 call    __RTC_CheckEsp
.text:00003F37                 mov     esp, ebp
.text:00003F39                 pop     ebp
.text:00003F3A                 retn    10h
.text:00003F3A ?FindCharset@@YGHABVCParser@NCommandLineParser@@I_NH@Z endp
.text:00003F3A
.text:00003F3A ; ---------------------------------------------------------------------------
.text:00003F3D                 align 10h
.text:00003F40 $LN16           dd 2                    ; DATA XREF: FindCharset(NCommandLineParser::CParser const &,uint,bool,int)+160o
.text:00003F44                 dd offset $LN15_0
.text:00003F48 $LN15_0         dd 0FFFFFFE4h, 0Ch      ; DATA XREF: .text:00003F44o
.text:00003F50                 dd offset $LN12_1       ; "name"
.text:00003F54                 dd 0FFFFFFD8h, 4
.text:00003F5C                 dd offset $LN13_0
.text:00003F60 $LN13_0         db 76h, 0               ; DATA XREF: .text:00003F5Co
.text:00003F62 $LN12_1         db 'name',0             ; DATA XREF: .text:00003F50o
.text:00003F67                 db 0Dh dup(0CCh)
.text:00003F74
.text:00003F74 ; =============== S U B R O U T I N E =======================================
.text:00003F74
.text:00003F74 ; Attributes: bp-based frame
.text:00003F74
.text:00003F74 ; void __stdcall SetBoolPair(class NCommandLineParser::CParser &, unsigned int, struct CBoolPair &)
.text:00003F74 ?SetBoolPair@@YGXAAVCParser@NCommandLineParser@@IAAUCBoolPair@@@Z proc near
.text:00003F74                                         ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+53Ep
.text:00003F74                                         ; CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+553p ...
.text:00003F74
.text:00003F74 arg_0           = dword ptr  8
.text:00003F74 arg_4           = dword ptr  0Ch
.text:00003F74 arg_8           = dword ptr  10h
.text:00003F74
.text:00003F74                 push    ebp
.text:00003F75                 mov     ebp, esp
.text:00003F77                 mov     eax, [ebp+arg_4]
.text:00003F7A                 push    eax
.text:00003F7B                 mov     ecx, [ebp+arg_0]
.text:00003F7E                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00003F83                 mov     ecx, [ebp+arg_8]
.text:00003F86                 mov     dl, [eax]
.text:00003F88                 mov     [ecx+1], dl
.text:00003F8B                 mov     eax, [ebp+arg_8]
.text:00003F8E                 movzx   ecx, byte ptr [eax+1]
.text:00003F92                 test    ecx, ecx
.text:00003F94                 jz      short loc_3FB2
.text:00003F96                 mov     edx, [ebp+arg_4]
.text:00003F99                 push    edx
.text:00003F9A                 mov     ecx, [ebp+arg_0]
.text:00003F9D                 call    ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z ; NCommandLineParser::CParser::operator[](uint)
.text:00003FA2                 movzx   eax, byte ptr [eax+1]
.text:00003FA6                 neg     eax
.text:00003FA8                 sbb     eax, eax
.text:00003FAA                 add     eax, 1
.text:00003FAD                 mov     ecx, [ebp+arg_8]
.text:00003FB0                 mov     [ecx], al
.text:00003FB2
.text:00003FB2 loc_3FB2:                               ; CODE XREF: SetBoolPair(NCommandLineParser::CParser &,uint,CBoolPair &)+20j
.text:00003FB2                 cmp     ebp, esp
.text:00003FB4                 call    __RTC_CheckEsp
.text:00003FB9                 pop     ebp
.text:00003FBA                 retn    0Ch
.text:00003FBA ?SetBoolPair@@YGXAAVCParser@NCommandLineParser@@IAAUCBoolPair@@@Z endp
.text:00003FBA
.text:00003FBA ; ---------------------------------------------------------------------------
.text:00003FBD                 align 10h
.text:00003FBD _text           ends
.text:00003FBD
.text$x:00003FC0 ; ===========================================================================
.text$x:00003FC0
.text$x:00003FC0 ; Segment type: Pure code
.text$x:00003FC0 ; Segment permissions: Read/Execute
.text$x:00003FC0 _text$x         segment para public 'CODE' use32
.text$x:00003FC0                 assume cs:_text$x
.text$x:00003FC0                 ;org 3FC0h
.text$x:00003FC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003FC0
.text$x:00003FC0 ; =============== S U B R O U T I N E =======================================
.text$x:00003FC0
.text$x:00003FC0
.text$x:00003FC0 __unwindfunclet$??0CArcCmdLineException@@QAE@PBDPB_W@Z$0 proc near
.text$x:00003FC0                                         ; DATA XREF: .xdata$x:0000428Co
.text$x:00003FC0                 mov     ecx, [ebp-10h]  ; this
.text$x:00003FC3                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00003FC3 __unwindfunclet$??0CArcCmdLineException@@QAE@PBDPB_W@Z$0 endp
.text$x:00003FC3
.text$x:00003FC8
.text$x:00003FC8 ; =============== S U B R O U T I N E =======================================
.text$x:00003FC8
.text$x:00003FC8
.text$x:00003FC8 __unwindfunclet$??0CArcCmdLineException@@QAE@PBDPB_W@Z$1 proc near
.text$x:00003FC8                                         ; DATA XREF: .xdata$x:00004294o
.text$x:00003FC8                 lea     ecx, [ebp-1Ch]  ; this
.text$x:00003FCB                 jmp     ??1AString@@QAE@XZ ; AString::~AString(void)
.text$x:00003FCB __unwindfunclet$??0CArcCmdLineException@@QAE@PBDPB_W@Z$1 endp
.text$x:00003FCB
.text$x:00003FD0
.text$x:00003FD0 ; =============== S U B R O U T I N E =======================================
.text$x:00003FD0
.text$x:00003FD0
.text$x:00003FD0 __unwindfunclet$??0CArcCmdLineException@@QAE@PBDPB_W@Z$2 proc near
.text$x:00003FD0                                         ; DATA XREF: .xdata$x:0000429Co
.text$x:00003FD0                 lea     ecx, [ebp-28h]  ; this
.text$x:00003FD3                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00003FD3 __unwindfunclet$??0CArcCmdLineException@@QAE@PBDPB_W@Z$2 endp
.text$x:00003FD3
.text$x:00003FD8
.text$x:00003FD8 ; =============== S U B R O U T I N E =======================================
.text$x:00003FD8
.text$x:00003FD8
.text$x:00003FD8 __ehhandler$??0CArcCmdLineException@@QAE@PBDPB_W@Z proc near
.text$x:00003FD8                                         ; DATA XREF: CArcCmdLineException::CArcCmdLineException(char const *,wchar_t const *)+5o
.text$x:00003FD8
.text$x:00003FD8 arg_4           = dword ptr  8
.text$x:00003FD8
.text$x:00003FD8                 mov     edx, [esp+arg_4]
.text$x:00003FDC                 lea     eax, [edx+0Ch]
.text$x:00003FDF                 mov     ecx, [edx-28h]
.text$x:00003FE2                 xor     ecx, eax
.text$x:00003FE4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003FE9                 mov     eax, offset __ehfuncinfo$??0CArcCmdLineException@@QAE@PBDPB_W@Z
.text$x:00003FEE                 jmp     ___CxxFrameHandler3
.text$x:00003FEE __ehhandler$??0CArcCmdLineException@@QAE@PBDPB_W@Z endp
.text$x:00003FEE
.text$x:00003FF3
.text$x:00003FF3 ; =============== S U B R O U T I N E =======================================
.text$x:00003FF3
.text$x:00003FF3
.text$x:00003FF3 __unwindfunclet$?ConvertToLongNames@@YGXABVUString@@AAVCCensorNode@NWildcard@@@Z$0 proc near
.text$x:00003FF3                                         ; DATA XREF: .xdata$x:000042C8o
.text$x:00003FF3                 lea     ecx, [ebp-30h]  ; this
.text$x:00003FF6                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00003FF6 __unwindfunclet$?ConvertToLongNames@@YGXABVUString@@AAVCCensorNode@NWildcard@@@Z$0 endp
.text$x:00003FF6
.text$x:00003FFB
.text$x:00003FFB ; =============== S U B R O U T I N E =======================================
.text$x:00003FFB
.text$x:00003FFB
.text$x:00003FFB __unwindfunclet$?ConvertToLongNames@@YGXABVUString@@AAVCCensorNode@NWildcard@@@Z$1 proc near
.text$x:00003FFB                                         ; DATA XREF: .xdata$x:000042D0o
.text$x:00003FFB                 lea     ecx, [ebp-3Ch]  ; this
.text$x:00003FFE                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00003FFE __unwindfunclet$?ConvertToLongNames@@YGXABVUString@@AAVCCensorNode@NWildcard@@@Z$1 endp
.text$x:00003FFE
.text$x:00004003
.text$x:00004003 ; =============== S U B R O U T I N E =======================================
.text$x:00004003
.text$x:00004003
.text$x:00004003 __ehhandler$?ConvertToLongNames@@YGXABVUString@@AAVCCensorNode@NWildcard@@@Z proc near
.text$x:00004003                                         ; DATA XREF: ConvertToLongNames(UString const &,NWildcard::CCensorNode &)+5o
.text$x:00004003
.text$x:00004003 arg_4           = dword ptr  8
.text$x:00004003
.text$x:00004003                 mov     edx, [esp+arg_4]
.text$x:00004007                 lea     eax, [edx+0Ch]
.text$x:0000400A                 mov     ecx, [edx-48h]
.text$x:0000400D                 xor     ecx, eax
.text$x:0000400F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004014                 mov     eax, offset __ehfuncinfo$?ConvertToLongNames@@YGXABVUString@@AAVCCensorNode@NWildcard@@@Z
.text$x:00004019                 jmp     ___CxxFrameHandler3
.text$x:00004019 __ehhandler$?ConvertToLongNames@@YGXABVUString@@AAVCCensorNode@NWildcard@@@Z endp
.text$x:00004019
.text$x:0000401E
.text$x:0000401E ; =============== S U B R O U T I N E =======================================
.text$x:0000401E
.text$x:0000401E
.text$x:0000401E __unwindfunclet$?ConvertToLongName@@YGXABVUString@@AAV1@@Z$0 proc near
.text$x:0000401E                                         ; DATA XREF: .xdata$x:000042FCo
.text$x:0000401E                 lea     ecx, [ebp-48h]  ; this
.text$x:00004021                 jmp     ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text$x:00004021 __unwindfunclet$?ConvertToLongName@@YGXABVUString@@AAV1@@Z$0 endp
.text$x:00004021
.text$x:00004026
.text$x:00004026 ; =============== S U B R O U T I N E =======================================
.text$x:00004026
.text$x:00004026
.text$x:00004026 __unwindfunclet$?ConvertToLongName@@YGXABVUString@@AAV1@@Z$1 proc near
.text$x:00004026                                         ; DATA XREF: .xdata$x:00004304o
.text$x:00004026                 lea     ecx, [ebp-5Ch]  ; this
.text$x:00004029                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00004029 __unwindfunclet$?ConvertToLongName@@YGXABVUString@@AAV1@@Z$1 endp
.text$x:00004029
.text$x:0000402E
.text$x:0000402E ; =============== S U B R O U T I N E =======================================
.text$x:0000402E
.text$x:0000402E
.text$x:0000402E __ehhandler$?ConvertToLongName@@YGXABVUString@@AAV1@@Z proc near
.text$x:0000402E                                         ; DATA XREF: ConvertToLongName(UString const &,UString &)+5o
.text$x:0000402E
.text$x:0000402E arg_4           = dword ptr  8
.text$x:0000402E
.text$x:0000402E                 mov     edx, [esp+arg_4]
.text$x:00004032                 lea     eax, [edx+0Ch]
.text$x:00004035                 mov     ecx, [edx-5Ch]
.text$x:00004038                 xor     ecx, eax
.text$x:0000403A                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000403F                 mov     eax, offset __ehfuncinfo$?ConvertToLongName@@YGXABVUString@@AAV1@@Z
.text$x:00004044                 jmp     ___CxxFrameHandler3
.text$x:00004044 __ehhandler$?ConvertToLongName@@YGXABVUString@@AAV1@@Z endp
.text$x:00004044
.text$x:00004049
.text$x:00004049 ; =============== S U B R O U T I N E =======================================
.text$x:00004049
.text$x:00004049
.text$x:00004049 __unwindfunclet$?Parse1@CArcCmdLineParser@@QAEXABV?$CObjectVector@VUString@@@@AAUCArcCmdLineOptions@@@Z$0 proc near
.text$x:00004049                                         ; DATA XREF: .xdata$x:00004330o
.text$x:00004049                 lea     ecx, [ebp-38h]  ; this
.text$x:0000404C                 jmp     ??1AString@@QAE@XZ ; AString::~AString(void)
.text$x:0000404C __unwindfunclet$?Parse1@CArcCmdLineParser@@QAEXABV?$CObjectVector@VUString@@@@AAUCArcCmdLineOptions@@@Z$0 endp
.text$x:0000404C
.text$x:00004051
.text$x:00004051 ; =============== S U B R O U T I N E =======================================
.text$x:00004051
.text$x:00004051
.text$x:00004051 __ehhandler$?Parse1@CArcCmdLineParser@@QAEXABV?$CObjectVector@VUString@@@@AAUCArcCmdLineOptions@@@Z proc near
.text$x:00004051                                         ; DATA XREF: CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+5o
.text$x:00004051
.text$x:00004051 arg_4           = dword ptr  8
.text$x:00004051
.text$x:00004051                 mov     edx, [esp+arg_4]
.text$x:00004055                 lea     eax, [edx+0Ch]
.text$x:00004058                 mov     ecx, [edx-70h]
.text$x:0000405B                 xor     ecx, eax
.text$x:0000405D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004062                 mov     eax, offset __ehfuncinfo$?Parse1@CArcCmdLineParser@@QAEXABV?$CObjectVector@VUString@@@@AAUCArcCmdLineOptions@@@Z
.text$x:00004067                 jmp     ___CxxFrameHandler3
.text$x:00004067 __ehhandler$?Parse1@CArcCmdLineParser@@QAEXABV?$CObjectVector@VUString@@@@AAUCArcCmdLineOptions@@@Z endp
.text$x:00004067
.text$x:0000406C
.text$x:0000406C ; =============== S U B R O U T I N E =======================================
.text$x:0000406C
.text$x:0000406C
.text$x:0000406C __unwindfunclet$?EnumerateDirItemsAndSort@@YGJAAVCCensor@NWildcard@@W4ECensorPathMode@2@ABVUString@@AAV?$CObjectVector@VUString@@@@3AAUCDirItemsStat@@PAUIDirItemsCallback@@@Z$0 proc near
.text$x:0000406C                                         ; DATA XREF: .xdata$x:00004380o
.text$x:0000406C                 lea     ecx, [ebp-1Ch]
.text$x:0000406F                 jmp     ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text$x:0000406F __unwindfunclet$?EnumerateDirItemsAndSort@@YGJAAVCCensor@NWildcard@@W4ECensorPathMode@2@ABVUString@@AAV?$CObjectVector@VUString@@@@3AAUCDirItemsStat@@PAUIDirItemsCallback@@@Z$0 endp
.text$x:0000406F
.text$x:00004074
.text$x:00004074 ; =============== S U B R O U T I N E =======================================
.text$x:00004074
.text$x:00004074
.text$x:00004074 __unwindfunclet$?EnumerateDirItemsAndSort@@YGJAAVCCensor@NWildcard@@W4ECensorPathMode@2@ABVUString@@AAV?$CObjectVector@VUString@@@@3AAUCDirItemsStat@@PAUIDirItemsCallback@@@Z$1 proc near
.text$x:00004074                                         ; DATA XREF: .xdata$x:00004388o
.text$x:00004074                 lea     ecx, [ebp-0C4h] ; this
.text$x:0000407A                 jmp     ??1CDirItems@@QAE@XZ ; CDirItems::~CDirItems(void)
.text$x:0000407A __unwindfunclet$?EnumerateDirItemsAndSort@@YGJAAVCCensor@NWildcard@@W4ECensorPathMode@2@ABVUString@@AAV?$CObjectVector@VUString@@@@3AAUCDirItemsStat@@PAUIDirItemsCallback@@@Z$1 endp
.text$x:0000407A
.text$x:0000407F
.text$x:0000407F ; =============== S U B R O U T I N E =======================================
.text$x:0000407F
.text$x:0000407F
.text$x:0000407F __unwindfunclet$?EnumerateDirItemsAndSort@@YGJAAVCCensor@NWildcard@@W4ECensorPathMode@2@ABVUString@@AAV?$CObjectVector@VUString@@@@3AAUCDirItemsStat@@PAUIDirItemsCallback@@@Z$2 proc near
.text$x:0000407F                                         ; DATA XREF: .xdata$x:00004390o
.text$x:0000407F                 lea     ecx, [ebp-12Ch] ; this
.text$x:00004085                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00004085 __unwindfunclet$?EnumerateDirItemsAndSort@@YGJAAVCCensor@NWildcard@@W4ECensorPathMode@2@ABVUString@@AAV?$CObjectVector@VUString@@@@3AAUCDirItemsStat@@PAUIDirItemsCallback@@@Z$2 endp
.text$x:00004085
.text$x:0000408A
.text$x:0000408A ; =============== S U B R O U T I N E =======================================
.text$x:0000408A
.text$x:0000408A
.text$x:0000408A __unwindfunclet$?EnumerateDirItemsAndSort@@YGJAAVCCensor@NWildcard@@W4ECensorPathMode@2@ABVUString@@AAV?$CObjectVector@VUString@@@@3AAUCDirItemsStat@@PAUIDirItemsCallback@@@Z$3 proc near
.text$x:0000408A                                         ; DATA XREF: .xdata$x:00004398o
.text$x:0000408A                 lea     ecx, [ebp-0E8h]
.text$x:00004090                 jmp     ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text$x:00004090 __unwindfunclet$?EnumerateDirItemsAndSort@@YGJAAVCCensor@NWildcard@@W4ECensorPathMode@2@ABVUString@@AAV?$CObjectVector@VUString@@@@3AAUCDirItemsStat@@PAUIDirItemsCallback@@@Z$3 endp
.text$x:00004090
.text$x:00004095
.text$x:00004095 ; =============== S U B R O U T I N E =======================================
.text$x:00004095
.text$x:00004095
.text$x:00004095 __unwindfunclet$?EnumerateDirItemsAndSort@@YGJAAVCCensor@NWildcard@@W4ECensorPathMode@2@ABVUString@@AAV?$CObjectVector@VUString@@@@3AAUCDirItemsStat@@PAUIDirItemsCallback@@@Z$4 proc near
.text$x:00004095                                         ; DATA XREF: .xdata$x:000043A0o
.text$x:00004095                 lea     ecx, [ebp-100h] ; this
.text$x:0000409B                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:0000409B __unwindfunclet$?EnumerateDirItemsAndSort@@YGJAAVCCensor@NWildcard@@W4ECensorPathMode@2@ABVUString@@AAV?$CObjectVector@VUString@@@@3AAUCDirItemsStat@@PAUIDirItemsCallback@@@Z$4 endp
.text$x:0000409B
.text$x:000040A0
.text$x:000040A0 ; =============== S U B R O U T I N E =======================================
.text$x:000040A0
.text$x:000040A0
.text$x:000040A0 __unwindfunclet$?EnumerateDirItemsAndSort@@YGJAAVCCensor@NWildcard@@W4ECensorPathMode@2@ABVUString@@AAV?$CObjectVector@VUString@@@@3AAUCDirItemsStat@@PAUIDirItemsCallback@@@Z$5 proc near
.text$x:000040A0                                         ; DATA XREF: .xdata$x:000043A8o
.text$x:000040A0                 lea     ecx, [ebp-114h]
.text$x:000040A6                 jmp     ??1?$CRecordVector@I@@QAE@XZ ; CRecordVector<uint>::~CRecordVector<uint>(void)
.text$x:000040A6 __unwindfunclet$?EnumerateDirItemsAndSort@@YGJAAVCCensor@NWildcard@@W4ECensorPathMode@2@ABVUString@@AAV?$CObjectVector@VUString@@@@3AAUCDirItemsStat@@PAUIDirItemsCallback@@@Z$5 endp
.text$x:000040A6
.text$x:000040AB
.text$x:000040AB ; =============== S U B R O U T I N E =======================================
.text$x:000040AB
.text$x:000040AB
.text$x:000040AB __ehhandler$?EnumerateDirItemsAndSort@@YGJAAVCCensor@NWildcard@@W4ECensorPathMode@2@ABVUString@@AAV?$CObjectVector@VUString@@@@3AAUCDirItemsStat@@PAUIDirItemsCallback@@@Z proc near
.text$x:000040AB                                         ; DATA XREF: EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *)+5o
.text$x:000040AB
.text$x:000040AB arg_4           = dword ptr  8
.text$x:000040AB
.text$x:000040AB                 mov     edx, [esp+arg_4]
.text$x:000040AF                 lea     eax, [edx+0Ch]
.text$x:000040B2                 mov     ecx, [edx-150h]
.text$x:000040B8                 xor     ecx, eax
.text$x:000040BA                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000040BF                 mov     eax, offset __ehfuncinfo$?EnumerateDirItemsAndSort@@YGJAAVCCensor@NWildcard@@W4ECensorPathMode@2@ABVUString@@AAV?$CObjectVector@VUString@@@@3AAUCDirItemsStat@@PAUIDirItemsCallback@@@Z
.text$x:000040C4                 jmp     ___CxxFrameHandler3
.text$x:000040C4 __ehhandler$?EnumerateDirItemsAndSort@@YGJAAVCCensor@NWildcard@@W4ECensorPathMode@2@ABVUString@@AAV?$CObjectVector@VUString@@@@3AAUCDirItemsStat@@PAUIDirItemsCallback@@@Z endp
.text$x:000040C4
.text$x:000040C9
.text$x:000040C9 ; =============== S U B R O U T I N E =======================================
.text$x:000040C9
.text$x:000040C9
.text$x:000040C9 __unwindfunclet$?ParseArchiveCommand@@YG_NABVUString@@AAUCArcCommand@@@Z$0 proc near
.text$x:000040C9                                         ; DATA XREF: .xdata$x:000043B0o
.text$x:000040C9                 lea     ecx, [ebp-1Ch]  ; this
.text$x:000040CC                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000040CC __unwindfunclet$?ParseArchiveCommand@@YG_NABVUString@@AAUCArcCommand@@@Z$0 endp
.text$x:000040CC
.text$x:000040D1
.text$x:000040D1 ; =============== S U B R O U T I N E =======================================
.text$x:000040D1
.text$x:000040D1
.text$x:000040D1 __ehhandler$?ParseArchiveCommand@@YG_NABVUString@@AAUCArcCommand@@@Z proc near
.text$x:000040D1                                         ; DATA XREF: ParseArchiveCommand(UString const &,CArcCommand &)+5o
.text$x:000040D1
.text$x:000040D1 arg_4           = dword ptr  8
.text$x:000040D1
.text$x:000040D1                 mov     edx, [esp+arg_4]
.text$x:000040D5                 lea     eax, [edx+0Ch]
.text$x:000040D8                 mov     ecx, [edx-24h]
.text$x:000040DB                 xor     ecx, eax
.text$x:000040DD                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000040E2                 mov     eax, offset __ehfuncinfo$?ParseArchiveCommand@@YG_NABVUString@@AAUCArcCommand@@@Z
.text$x:000040E7                 jmp     ___CxxFrameHandler3
.text$x:000040E7 __ehhandler$?ParseArchiveCommand@@YG_NABVUString@@AAUCArcCommand@@@Z endp
.text$x:000040E7
.text$x:000040EC
.text$x:000040EC ; =============== S U B R O U T I N E =======================================
.text$x:000040EC
.text$x:000040EC
.text$x:000040EC __unwindfunclet$?AddToCensorFromNonSwitchesStrings@@YGXPAV?$CObjectVector@UCRenamePair@@@@IAAVCCensor@NWildcard@@ABV?$CObjectVector@VUString@@@@W4EEnum@NRecursedType@@_N4H@Z$0 proc near
.text$x:000040EC                                         ; DATA XREF: .xdata$x:000043DCo
.text$x:000040EC                 lea     ecx, [ebp-24h]  ; this
.text$x:000040EF                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000040EF __unwindfunclet$?AddToCensorFromNonSwitchesStrings@@YGXPAV?$CObjectVector@UCRenamePair@@@@IAAVCCensor@NWildcard@@ABV?$CObjectVector@VUString@@@@W4EEnum@NRecursedType@@_N4H@Z$0 endp
.text$x:000040EF
.text$x:000040F4
.text$x:000040F4 ; =============== S U B R O U T I N E =======================================
.text$x:000040F4
.text$x:000040F4
.text$x:000040F4 __ehhandler$?AddToCensorFromNonSwitchesStrings@@YGXPAV?$CObjectVector@UCRenamePair@@@@IAAVCCensor@NWildcard@@ABV?$CObjectVector@VUString@@@@W4EEnum@NRecursedType@@_N4H@Z proc near
.text$x:000040F4                                         ; DATA XREF: AddToCensorFromNonSwitchesStrings(CObjectVector<CRenamePair> *,uint,NWildcard::CCensor &,CObjectVector<UString> const &,NRecursedType::EEnum,bool,bool,int)+5o
.text$x:000040F4
.text$x:000040F4 arg_4           = dword ptr  8
.text$x:000040F4
.text$x:000040F4                 mov     edx, [esp+arg_4]
.text$x:000040F8                 lea     eax, [edx+0Ch]
.text$x:000040FB                 mov     ecx, [edx-38h]
.text$x:000040FE                 xor     ecx, eax
.text$x:00004100                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004105                 mov     eax, offset __ehfuncinfo$?AddToCensorFromNonSwitchesStrings@@YGXPAV?$CObjectVector@UCRenamePair@@@@IAAVCCensor@NWildcard@@ABV?$CObjectVector@VUString@@@@W4EEnum@NRecursedType@@_N4H@Z
.text$x:0000410A                 jmp     ___CxxFrameHandler3
.text$x:0000410A __ehhandler$?AddToCensorFromNonSwitchesStrings@@YGXPAV?$CObjectVector@UCRenamePair@@@@IAAVCCensor@NWildcard@@ABV?$CObjectVector@VUString@@@@W4EEnum@NRecursedType@@_N4H@Z endp
.text$x:0000410A
.text$x:0000410F
.text$x:0000410F ; =============== S U B R O U T I N E =======================================
.text$x:0000410F
.text$x:0000410F
.text$x:0000410F __unwindfunclet$?AddRenamePair@@YGXPAV?$CObjectVector@UCRenamePair@@@@ABVUString@@1W4EEnum@NRecursedType@@_N@Z$0 proc near
.text$x:0000410F                                         ; DATA XREF: .xdata$x:00004408o
.text$x:0000410F                 lea     ecx, [ebp-20h]  ; this
.text$x:00004112                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00004112 __unwindfunclet$?AddRenamePair@@YGXPAV?$CObjectVector@UCRenamePair@@@@ABVUString@@1W4EEnum@NRecursedType@@_N@Z$0 endp
.text$x:00004112
.text$x:00004117
.text$x:00004117 ; =============== S U B R O U T I N E =======================================
.text$x:00004117
.text$x:00004117
.text$x:00004117 __ehhandler$?AddRenamePair@@YGXPAV?$CObjectVector@UCRenamePair@@@@ABVUString@@1W4EEnum@NRecursedType@@_N@Z proc near
.text$x:00004117                                         ; DATA XREF: AddRenamePair(CObjectVector<CRenamePair> *,UString const &,UString const &,NRecursedType::EEnum,bool)+5o
.text$x:00004117
.text$x:00004117 arg_4           = dword ptr  8
.text$x:00004117
.text$x:00004117                 mov     edx, [esp+arg_4]
.text$x:0000411B                 lea     eax, [edx+0Ch]
.text$x:0000411E                 mov     ecx, [edx-28h]
.text$x:00004121                 xor     ecx, eax
.text$x:00004123                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004128                 mov     eax, offset __ehfuncinfo$?AddRenamePair@@YGXPAV?$CObjectVector@UCRenamePair@@@@ABVUString@@1W4EEnum@NRecursedType@@_N@Z
.text$x:0000412D                 jmp     ___CxxFrameHandler3
.text$x:0000412D __ehhandler$?AddRenamePair@@YGXPAV?$CObjectVector@UCRenamePair@@@@ABVUString@@1W4EEnum@NRecursedType@@_N@Z endp
.text$x:0000412D
.text$x:00004132
.text$x:00004132 ; =============== S U B R O U T I N E =======================================
.text$x:00004132
.text$x:00004132
.text$x:00004132 __unwindfunclet$?AddToCensorFromListFile@@YGXPAV?$CObjectVector@UCRenamePair@@@@AAVCCensor@NWildcard@@PB_W_NW4EEnum@NRecursedType@@3H@Z$0 proc near
.text$x:00004132                                         ; DATA XREF: .xdata$x:00004434o
.text$x:00004132                 lea     ecx, [ebp-1Ch]
.text$x:00004135                 jmp     ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text$x:00004135 __unwindfunclet$?AddToCensorFromListFile@@YGXPAV?$CObjectVector@UCRenamePair@@@@AAVCCensor@NWildcard@@PB_W_NW4EEnum@NRecursedType@@3H@Z$0 endp
.text$x:00004135
.text$x:0000413A
.text$x:0000413A ; =============== S U B R O U T I N E =======================================
.text$x:0000413A
.text$x:0000413A
.text$x:0000413A __ehhandler$?AddToCensorFromListFile@@YGXPAV?$CObjectVector@UCRenamePair@@@@AAVCCensor@NWildcard@@PB_W_NW4EEnum@NRecursedType@@3H@Z proc near
.text$x:0000413A                                         ; DATA XREF: AddToCensorFromListFile(CObjectVector<CRenamePair> *,NWildcard::CCensor &,wchar_t const *,bool,NRecursedType::EEnum,bool,int)+5o
.text$x:0000413A
.text$x:0000413A arg_4           = dword ptr  8
.text$x:0000413A
.text$x:0000413A                 mov     edx, [esp+arg_4]
.text$x:0000413E                 lea     eax, [edx+0Ch]
.text$x:00004141                 mov     ecx, [edx-48h]
.text$x:00004144                 xor     ecx, eax
.text$x:00004146                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000414B                 mov     eax, offset __ehfuncinfo$?AddToCensorFromListFile@@YGXPAV?$CObjectVector@UCRenamePair@@@@AAVCCensor@NWildcard@@PB_W_NW4EEnum@NRecursedType@@3H@Z
.text$x:00004150                 jmp     ___CxxFrameHandler3
.text$x:00004150 __ehhandler$?AddToCensorFromListFile@@YGXPAV?$CObjectVector@UCRenamePair@@@@AAVCCensor@NWildcard@@PB_W_NW4EEnum@NRecursedType@@3H@Z endp
.text$x:00004150
.text$x:00004155
.text$x:00004155 ; =============== S U B R O U T I N E =======================================
.text$x:00004155
.text$x:00004155
.text$x:00004155 __unwindfunclet$?AddSwitchWildcardsToCensor@@YGXAAVCCensor@NWildcard@@ABV?$CObjectVector@VUString@@@@_NW4EEnum@NRecursedType@@2H@Z$0 proc near
.text$x:00004155                                         ; DATA XREF: .xdata$x:00004460o
.text$x:00004155                 lea     ecx, [ebp-38h]  ; this
.text$x:00004158                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00004158 __unwindfunclet$?AddSwitchWildcardsToCensor@@YGXAAVCCensor@NWildcard@@ABV?$CObjectVector@VUString@@@@_NW4EEnum@NRecursedType@@2H@Z$0 endp
.text$x:00004158
.text$x:0000415D
.text$x:0000415D ; =============== S U B R O U T I N E =======================================
.text$x:0000415D
.text$x:0000415D
.text$x:0000415D __ehhandler$?AddSwitchWildcardsToCensor@@YGXAAVCCensor@NWildcard@@ABV?$CObjectVector@VUString@@@@_NW4EEnum@NRecursedType@@2H@Z proc near
.text$x:0000415D                                         ; DATA XREF: AddSwitchWildcardsToCensor(NWildcard::CCensor &,CObjectVector<UString> const &,bool,NRecursedType::EEnum,bool,int)+5o
.text$x:0000415D
.text$x:0000415D arg_4           = dword ptr  8
.text$x:0000415D
.text$x:0000415D                 mov     edx, [esp+arg_4]
.text$x:00004161                 lea     eax, [edx+0Ch]
.text$x:00004164                 mov     ecx, [edx-44h]
.text$x:00004167                 xor     ecx, eax
.text$x:00004169                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000416E                 mov     eax, offset __ehfuncinfo$?AddSwitchWildcardsToCensor@@YGXAAVCCensor@NWildcard@@ABV?$CObjectVector@VUString@@@@_NW4EEnum@NRecursedType@@2H@Z
.text$x:00004173                 jmp     ___CxxFrameHandler3
.text$x:00004173 __ehhandler$?AddSwitchWildcardsToCensor@@YGXAAVCCensor@NWildcard@@ABV?$CObjectVector@VUString@@@@_NW4EEnum@NRecursedType@@2H@Z endp
.text$x:00004173
.text$x:00004178
.text$x:00004178 ; =============== S U B R O U T I N E =======================================
.text$x:00004178
.text$x:00004178
.text$x:00004178 __unwindfunclet$?ParseMapWithPaths@@YGPBDAAVCCensor@NWildcard@@ABVUString@@_NW4EEnum@NRecursedType@@2@Z$0 proc near
.text$x:00004178                                         ; DATA XREF: .xdata$x:000044B0o
.text$x:00004178                 lea     ecx, [ebp-1Ch]  ; this
.text$x:0000417B                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:0000417B __unwindfunclet$?ParseMapWithPaths@@YGPBDAAVCCensor@NWildcard@@ABVUString@@_NW4EEnum@NRecursedType@@2@Z$0 endp
.text$x:0000417B
.text$x:00004180
.text$x:00004180 ; =============== S U B R O U T I N E =======================================
.text$x:00004180
.text$x:00004180
.text$x:00004180 __unwindfunclet$?ParseMapWithPaths@@YGPBDAAVCCensor@NWildcard@@ABVUString@@_NW4EEnum@NRecursedType@@2@Z$1 proc near
.text$x:00004180                                         ; DATA XREF: .xdata$x:000044B8o
.text$x:00004180                 lea     ecx, [ebp-38h]  ; this
.text$x:00004183                 jmp     ??1CEventSetEnd@@QAE@XZ ; CEventSetEnd::~CEventSetEnd(void)
.text$x:00004183 __unwindfunclet$?ParseMapWithPaths@@YGPBDAAVCCensor@NWildcard@@ABVUString@@_NW4EEnum@NRecursedType@@2@Z$1 endp
.text$x:00004183
.text$x:00004188
.text$x:00004188 ; =============== S U B R O U T I N E =======================================
.text$x:00004188
.text$x:00004188
.text$x:00004188 __unwindfunclet$?ParseMapWithPaths@@YGPBDAAVCCensor@NWildcard@@ABVUString@@_NW4EEnum@NRecursedType@@2@Z$2 proc near
.text$x:00004188                                         ; DATA XREF: .xdata$x:000044C0o
.text$x:00004188                 lea     ecx, [ebp-50h]  ; this
.text$x:0000418B                 jmp     ??1CFileMapping@NWindows@@QAE@XZ ; NWindows::CFileMapping::~CFileMapping(void)
.text$x:0000418B __unwindfunclet$?ParseMapWithPaths@@YGPBDAAVCCensor@NWildcard@@ABVUString@@_NW4EEnum@NRecursedType@@2@Z$2 endp
.text$x:0000418B
.text$x:00004190
.text$x:00004190 ; =============== S U B R O U T I N E =======================================
.text$x:00004190
.text$x:00004190
.text$x:00004190 __unwindfunclet$?ParseMapWithPaths@@YGPBDAAVCCensor@NWildcard@@ABVUString@@_NW4EEnum@NRecursedType@@2@Z$3 proc near
.text$x:00004190                                         ; DATA XREF: .xdata$x:000044C8o
.text$x:00004190                 lea     ecx, [ebp-0A4h] ; this
.text$x:00004196                 jmp     ??1AString@@QAE@XZ ; AString::~AString(void)
.text$x:00004196 __unwindfunclet$?ParseMapWithPaths@@YGPBDAAVCCensor@NWildcard@@ABVUString@@_NW4EEnum@NRecursedType@@2@Z$3 endp
.text$x:00004196
.text$x:0000419B
.text$x:0000419B ; =============== S U B R O U T I N E =======================================
.text$x:0000419B
.text$x:0000419B
.text$x:0000419B __unwindfunclet$?ParseMapWithPaths@@YGPBDAAVCCensor@NWildcard@@ABVUString@@_NW4EEnum@NRecursedType@@2@Z$4 proc near
.text$x:0000419B                                         ; DATA XREF: .xdata$x:000044D0o
.text$x:0000419B                 lea     ecx, [ebp-60h]  ; this
.text$x:0000419E                 jmp     ??1CFileUnmapper@NWindows@@QAE@XZ ; NWindows::CFileUnmapper::~CFileUnmapper(void)
.text$x:0000419E __unwindfunclet$?ParseMapWithPaths@@YGPBDAAVCCensor@NWildcard@@ABVUString@@_NW4EEnum@NRecursedType@@2@Z$4 endp
.text$x:0000419E
.text$x:000041A3
.text$x:000041A3 ; =============== S U B R O U T I N E =======================================
.text$x:000041A3
.text$x:000041A3
.text$x:000041A3 __unwindfunclet$?ParseMapWithPaths@@YGPBDAAVCCensor@NWildcard@@ABVUString@@_NW4EEnum@NRecursedType@@2@Z$5 proc near
.text$x:000041A3                                         ; DATA XREF: .xdata$x:000044D8o
.text$x:000041A3                 lea     ecx, [ebp-74h]  ; this
.text$x:000041A6                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000041A6 __unwindfunclet$?ParseMapWithPaths@@YGPBDAAVCCensor@NWildcard@@ABVUString@@_NW4EEnum@NRecursedType@@2@Z$5 endp
.text$x:000041A6
.text$x:000041AB
.text$x:000041AB ; =============== S U B R O U T I N E =======================================
.text$x:000041AB
.text$x:000041AB
.text$x:000041AB __ehhandler$?ParseMapWithPaths@@YGPBDAAVCCensor@NWildcard@@ABVUString@@_NW4EEnum@NRecursedType@@2@Z proc near
.text$x:000041AB                                         ; DATA XREF: ParseMapWithPaths(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)+5o
.text$x:000041AB
.text$x:000041AB arg_4           = dword ptr  8
.text$x:000041AB
.text$x:000041AB                 mov     edx, [esp+arg_4]
.text$x:000041AF                 lea     eax, [edx+0Ch]
.text$x:000041B2                 mov     ecx, [edx-0BCh]
.text$x:000041B8                 xor     ecx, eax
.text$x:000041BA                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000041BF                 mov     eax, offset __ehfuncinfo$?ParseMapWithPaths@@YGPBDAAVCCensor@NWildcard@@ABVUString@@_NW4EEnum@NRecursedType@@2@Z
.text$x:000041C4                 jmp     ___CxxFrameHandler3
.text$x:000041C4 __ehhandler$?ParseMapWithPaths@@YGPBDAAVCCensor@NWildcard@@ABVUString@@_NW4EEnum@NRecursedType@@2@Z endp
.text$x:000041C4
.text$x:000041C9
.text$x:000041C9 ; =============== S U B R O U T I N E =======================================
.text$x:000041C9
.text$x:000041C9
.text$x:000041C9 __unwindfunclet$?SetAddCommandOptions@@YGXW4EEnum@NCommandType@@ABVCParser@NCommandLineParser@@AAUCUpdateOptions@@@Z$0 proc near
.text$x:000041C9                                         ; DATA XREF: .xdata$x:000044E0o
.text$x:000041C9                 lea     ecx, [ebp-0B8h] ; this
.text$x:000041CF                 jmp     ??1CUpdateArchiveCommand@@QAE@XZ ; CUpdateArchiveCommand::~CUpdateArchiveCommand(void)
.text$x:000041CF __unwindfunclet$?SetAddCommandOptions@@YGXW4EEnum@NCommandType@@ABVCParser@NCommandLineParser@@AAUCUpdateOptions@@@Z$0 endp
.text$x:000041CF
.text$x:000041D4
.text$x:000041D4 ; =============== S U B R O U T I N E =======================================
.text$x:000041D4
.text$x:000041D4
.text$x:000041D4 __ehhandler$?SetAddCommandOptions@@YGXW4EEnum@NCommandType@@ABVCParser@NCommandLineParser@@AAUCUpdateOptions@@@Z proc near
.text$x:000041D4                                         ; DATA XREF: SetAddCommandOptions(NCommandType::EEnum,NCommandLineParser::CParser const &,CUpdateOptions &)+5o
.text$x:000041D4
.text$x:000041D4 arg_4           = dword ptr  8
.text$x:000041D4
.text$x:000041D4                 mov     edx, [esp+arg_4]
.text$x:000041D8                 lea     eax, [edx+0Ch]
.text$x:000041DB                 mov     ecx, [edx-0E8h]
.text$x:000041E1                 xor     ecx, eax
.text$x:000041E3                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000041E8                 mov     ecx, [edx-4]
.text$x:000041EB                 xor     ecx, eax
.text$x:000041ED                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000041F2                 mov     eax, offset __ehfuncinfo$?SetAddCommandOptions@@YGXW4EEnum@NCommandType@@ABVCParser@NCommandLineParser@@AAUCUpdateOptions@@@Z
.text$x:000041F7                 jmp     ___CxxFrameHandler3
.text$x:000041F7 __ehhandler$?SetAddCommandOptions@@YGXW4EEnum@NCommandType@@ABVCParser@NCommandLineParser@@AAUCUpdateOptions@@@Z endp
.text$x:000041F7
.text$x:000041FC
.text$x:000041FC ; =============== S U B R O U T I N E =======================================
.text$x:000041FC
.text$x:000041FC
.text$x:000041FC __unwindfunclet$?ParseUpdateCommandString@@YGXAAUCUpdateOptions@@ABV?$CObjectVector@VUString@@@@ABUCActionSet@NUpdateArchive@@@Z$0 proc near
.text$x:000041FC                                         ; DATA XREF: .xdata$x:0000450Co
.text$x:000041FC                 lea     ecx, [ebp-50h]  ; this
.text$x:000041FF                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000041FF __unwindfunclet$?ParseUpdateCommandString@@YGXAAUCUpdateOptions@@ABV?$CObjectVector@VUString@@@@ABUCActionSet@NUpdateArchive@@@Z$0 endp
.text$x:000041FF
.text$x:00004204
.text$x:00004204 ; =============== S U B R O U T I N E =======================================
.text$x:00004204
.text$x:00004204
.text$x:00004204 __unwindfunclet$?ParseUpdateCommandString@@YGXAAUCUpdateOptions@@ABV?$CObjectVector@VUString@@@@ABUCActionSet@NUpdateArchive@@@Z$1 proc near
.text$x:00004204                                         ; DATA XREF: .xdata$x:00004514o
.text$x:00004204                 lea     ecx, [ebp-0D8h] ; this
.text$x:0000420A                 jmp     ??1CUpdateArchiveCommand@@QAE@XZ ; CUpdateArchiveCommand::~CUpdateArchiveCommand(void)
.text$x:0000420A __unwindfunclet$?ParseUpdateCommandString@@YGXAAUCUpdateOptions@@ABV?$CObjectVector@VUString@@@@ABUCActionSet@NUpdateArchive@@@Z$1 endp
.text$x:0000420A
.text$x:0000420F
.text$x:0000420F ; =============== S U B R O U T I N E =======================================
.text$x:0000420F
.text$x:0000420F
.text$x:0000420F __unwindfunclet$?ParseUpdateCommandString@@YGXAAUCUpdateOptions@@ABV?$CObjectVector@VUString@@@@ABUCActionSet@NUpdateArchive@@@Z$2 proc near
.text$x:0000420F                                         ; DATA XREF: .xdata$x:0000451Co
.text$x:0000420F                 lea     ecx, [ebp-0ECh] ; this
.text$x:00004215                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00004215 __unwindfunclet$?ParseUpdateCommandString@@YGXAAUCUpdateOptions@@ABV?$CObjectVector@VUString@@@@ABUCActionSet@NUpdateArchive@@@Z$2 endp
.text$x:00004215
.text$x:0000421A
.text$x:0000421A ; =============== S U B R O U T I N E =======================================
.text$x:0000421A
.text$x:0000421A
.text$x:0000421A __ehhandler$?ParseUpdateCommandString@@YGXAAUCUpdateOptions@@ABV?$CObjectVector@VUString@@@@ABUCActionSet@NUpdateArchive@@@Z proc near
.text$x:0000421A                                         ; DATA XREF: ParseUpdateCommandString(CUpdateOptions &,CObjectVector<UString> const &,NUpdateArchive::CActionSet const &)+5o
.text$x:0000421A
.text$x:0000421A arg_4           = dword ptr  8
.text$x:0000421A
.text$x:0000421A                 mov     edx, [esp+arg_4]
.text$x:0000421E                 lea     eax, [edx+0Ch]
.text$x:00004221                 mov     ecx, [edx-0FCh]
.text$x:00004227                 xor     ecx, eax
.text$x:00004229                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000422E                 mov     ecx, [edx-4]
.text$x:00004231                 xor     ecx, eax
.text$x:00004233                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004238                 mov     eax, offset __ehfuncinfo$?ParseUpdateCommandString@@YGXAAUCUpdateOptions@@ABV?$CObjectVector@VUString@@@@ABUCActionSet@NUpdateArchive@@@Z
.text$x:0000423D                 jmp     ___CxxFrameHandler3
.text$x:0000423D __ehhandler$?ParseUpdateCommandString@@YGXAAUCUpdateOptions@@ABV?$CObjectVector@VUString@@@@ABUCActionSet@NUpdateArchive@@@Z endp
.text$x:0000423D
.text$x:00004242
.text$x:00004242 ; =============== S U B R O U T I N E =======================================
.text$x:00004242
.text$x:00004242
.text$x:00004242 __unwindfunclet$?SetMethodOptions@@YGXABVCParser@NCommandLineParser@@AAV?$CObjectVector@UCProperty@@@@@Z$0 proc near
.text$x:00004242                                         ; DATA XREF: .xdata$x:00004548o
.text$x:00004242                 lea     ecx, [ebp-2Ch]  ; this
.text$x:00004245                 jmp     ??1CProperty@@QAE@XZ ; CProperty::~CProperty(void)
.text$x:00004245 __unwindfunclet$?SetMethodOptions@@YGXABVCParser@NCommandLineParser@@AAV?$CObjectVector@UCProperty@@@@@Z$0 endp
.text$x:00004245
.text$x:0000424A
.text$x:0000424A ; =============== S U B R O U T I N E =======================================
.text$x:0000424A
.text$x:0000424A
.text$x:0000424A __ehhandler$?SetMethodOptions@@YGXABVCParser@NCommandLineParser@@AAV?$CObjectVector@UCProperty@@@@@Z proc near
.text$x:0000424A                                         ; DATA XREF: SetMethodOptions(NCommandLineParser::CParser const &,CObjectVector<CProperty> &)+5o
.text$x:0000424A
.text$x:0000424A arg_4           = dword ptr  8
.text$x:0000424A
.text$x:0000424A                 mov     edx, [esp+arg_4]
.text$x:0000424E                 lea     eax, [edx+0Ch]
.text$x:00004251                 mov     ecx, [edx-30h]
.text$x:00004254                 xor     ecx, eax
.text$x:00004256                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000425B                 mov     eax, offset __ehfuncinfo$?SetMethodOptions@@YGXABVCParser@NCommandLineParser@@AAV?$CObjectVector@UCProperty@@@@@Z
.text$x:00004260                 jmp     ___CxxFrameHandler3
.text$x:00004260 __ehhandler$?SetMethodOptions@@YGXABVCParser@NCommandLineParser@@AAV?$CObjectVector@UCProperty@@@@@Z endp
.text$x:00004260
.text$x:00004265
.text$x:00004265 ; =============== S U B R O U T I N E =======================================
.text$x:00004265
.text$x:00004265
.text$x:00004265 __unwindfunclet$?FindCharset@@YGHABVCParser@NCommandLineParser@@I_NH@Z$0 proc near
.text$x:00004265                                         ; DATA XREF: .xdata$x:00004574o
.text$x:00004265                 lea     ecx, [ebp-1Ch]  ; this
.text$x:00004268                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00004268 __unwindfunclet$?FindCharset@@YGHABVCParser@NCommandLineParser@@I_NH@Z$0 endp
.text$x:00004268
.text$x:0000426D
.text$x:0000426D ; =============== S U B R O U T I N E =======================================
.text$x:0000426D
.text$x:0000426D
.text$x:0000426D __ehhandler$?FindCharset@@YGHABVCParser@NCommandLineParser@@I_NH@Z proc near
.text$x:0000426D                                         ; DATA XREF: FindCharset(NCommandLineParser::CParser const &,uint,bool,int)+5o
.text$x:0000426D
.text$x:0000426D arg_4           = dword ptr  8
.text$x:0000426D
.text$x:0000426D                 mov     edx, [esp+arg_4]
.text$x:00004271                 lea     eax, [edx+0Ch]
.text$x:00004274                 mov     ecx, [edx-48h]
.text$x:00004277                 xor     ecx, eax
.text$x:00004279                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000427E                 mov     eax, offset __ehfuncinfo$?FindCharset@@YGHABVCParser@NCommandLineParser@@I_NH@Z
.text$x:00004283                 jmp     ___CxxFrameHandler3
.text$x:00004283 __ehhandler$?FindCharset@@YGHABVCParser@NCommandLineParser@@I_NH@Z endp
.text$x:00004283
.text$x:00004283 _text$x         ends
.text$x:00004283
.xdata$x:00004288 ; ===========================================================================
.xdata$x:00004288
.xdata$x:00004288 ; Segment type: Pure data
.xdata$x:00004288 ; Segment permissions: Read
.xdata$x:00004288 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004288                 assume cs:_xdata$x
.xdata$x:00004288                 ;org 4288h
.xdata$x:00004288 __unwindtable$??0CArcCmdLineException@@QAE@PBDPB_W@Z db 0FFh
.xdata$x:00004288                                         ; DATA XREF: .xdata$x:000042A8o
.xdata$x:00004289                 db 0FFh
.xdata$x:0000428A                 db 0FFh
.xdata$x:0000428B                 db 0FFh
.xdata$x:0000428C                 dd offset __unwindfunclet$??0CArcCmdLineException@@QAE@PBDPB_W@Z$0
.xdata$x:00004290                 db    0
.xdata$x:00004291                 db    0
.xdata$x:00004292                 db    0
.xdata$x:00004293                 db    0
.xdata$x:00004294                 dd offset __unwindfunclet$??0CArcCmdLineException@@QAE@PBDPB_W@Z$1
.xdata$x:00004298                 db    1
.xdata$x:00004299                 db    0
.xdata$x:0000429A                 db    0
.xdata$x:0000429B                 db    0
.xdata$x:0000429C                 dd offset __unwindfunclet$??0CArcCmdLineException@@QAE@PBDPB_W@Z$2
.xdata$x:000042A0 __ehfuncinfo$??0CArcCmdLineException@@QAE@PBDPB_W@Z db  22h ; "
.xdata$x:000042A0                                         ; DATA XREF: __ehhandler$??0CArcCmdLineException@@QAE@PBDPB_W@Z+11o
.xdata$x:000042A1                 db    5
.xdata$x:000042A2                 db  93h ; Ã´
.xdata$x:000042A3                 db  19h
.xdata$x:000042A4                 db    3
.xdata$x:000042A5                 db    0
.xdata$x:000042A6                 db    0
.xdata$x:000042A7                 db    0
.xdata$x:000042A8                 dd offset __unwindtable$??0CArcCmdLineException@@QAE@PBDPB_W@Z
.xdata$x:000042AC                 align 20h
.xdata$x:000042C0                 db    1
.xdata$x:000042C1                 db    0
.xdata$x:000042C2                 db    0
.xdata$x:000042C3                 db    0
.xdata$x:000042C4 __unwindtable$?ConvertToLongNames@@YGXABVUString@@AAVCCensorNode@NWildcard@@@Z db 0FFh
.xdata$x:000042C4                                         ; DATA XREF: .xdata$x:000042DCo
.xdata$x:000042C5                 db 0FFh
.xdata$x:000042C6                 db 0FFh
.xdata$x:000042C7                 db 0FFh
.xdata$x:000042C8                 dd offset __unwindfunclet$?ConvertToLongNames@@YGXABVUString@@AAVCCensorNode@NWildcard@@@Z$0
.xdata$x:000042CC                 align 10h
.xdata$x:000042D0                 dd offset __unwindfunclet$?ConvertToLongNames@@YGXABVUString@@AAVCCensorNode@NWildcard@@@Z$1
.xdata$x:000042D4 __ehfuncinfo$?ConvertToLongNames@@YGXABVUString@@AAVCCensorNode@NWildcard@@@Z db  22h ; "
.xdata$x:000042D4                                         ; DATA XREF: __ehhandler$?ConvertToLongNames@@YGXABVUString@@AAVCCensorNode@NWildcard@@@Z+11o
.xdata$x:000042D5                 db    5
.xdata$x:000042D6                 db  93h ; Ã´
.xdata$x:000042D7                 db  19h
.xdata$x:000042D8                 db    2
.xdata$x:000042D9                 db    0
.xdata$x:000042DA                 db    0
.xdata$x:000042DB                 db    0
.xdata$x:000042DC                 dd offset __unwindtable$?ConvertToLongNames@@YGXABVUString@@AAVCCensorNode@NWildcard@@@Z
.xdata$x:000042E0                 db    0
.xdata$x:000042E1                 db    0
.xdata$x:000042E2                 db    0
.xdata$x:000042E3                 db    0
.xdata$x:000042E4                 db    0
.xdata$x:000042E5                 db    0
.xdata$x:000042E6                 db    0
.xdata$x:000042E7                 db    0
.xdata$x:000042E8                 db    0
.xdata$x:000042E9                 db    0
.xdata$x:000042EA                 db    0
.xdata$x:000042EB                 db    0
.xdata$x:000042EC                 db    0
.xdata$x:000042ED                 db    0
.xdata$x:000042EE                 db    0
.xdata$x:000042EF                 db    0
.xdata$x:000042F0                 db    0
.xdata$x:000042F1                 db    0
.xdata$x:000042F2                 db    0
.xdata$x:000042F3                 db    0
.xdata$x:000042F4                 db    1
.xdata$x:000042F5                 db    0
.xdata$x:000042F6                 db    0
.xdata$x:000042F7                 db    0
.xdata$x:000042F8 __unwindtable$?ConvertToLongName@@YGXABVUString@@AAV1@@Z db 0FFh
.xdata$x:000042F8                                         ; DATA XREF: .xdata$x:00004310o
.xdata$x:000042F9                 db 0FFh
.xdata$x:000042FA                 db 0FFh
.xdata$x:000042FB                 db 0FFh
.xdata$x:000042FC                 dd offset __unwindfunclet$?ConvertToLongName@@YGXABVUString@@AAV1@@Z$0
.xdata$x:00004300                 db    0
.xdata$x:00004301                 db    0
.xdata$x:00004302                 db    0
.xdata$x:00004303                 db    0
.xdata$x:00004304                 dd offset __unwindfunclet$?ConvertToLongName@@YGXABVUString@@AAV1@@Z$1
.xdata$x:00004308 __ehfuncinfo$?ConvertToLongName@@YGXABVUString@@AAV1@@Z db  22h ; "
.xdata$x:00004308                                         ; DATA XREF: __ehhandler$?ConvertToLongName@@YGXABVUString@@AAV1@@Z+11o
.xdata$x:00004309                 db    5
.xdata$x:0000430A                 db  93h ; Ã´
.xdata$x:0000430B                 db  19h
.xdata$x:0000430C                 db    2
.xdata$x:0000430D                 db    0
.xdata$x:0000430E                 db    0
.xdata$x:0000430F                 db    0
.xdata$x:00004310                 dd offset __unwindtable$?ConvertToLongName@@YGXABVUString@@AAV1@@Z
.xdata$x:00004314                 db    0
.xdata$x:00004315                 db    0
.xdata$x:00004316                 db    0
.xdata$x:00004317                 db    0
.xdata$x:00004318                 db    0
.xdata$x:00004319                 db    0
.xdata$x:0000431A                 db    0
.xdata$x:0000431B                 db    0
.xdata$x:0000431C                 db    0
.xdata$x:0000431D                 db    0
.xdata$x:0000431E                 db    0
.xdata$x:0000431F                 db    0
.xdata$x:00004320                 db    0
.xdata$x:00004321                 db    0
.xdata$x:00004322                 db    0
.xdata$x:00004323                 db    0
.xdata$x:00004324                 db    0
.xdata$x:00004325                 db    0
.xdata$x:00004326                 db    0
.xdata$x:00004327                 db    0
.xdata$x:00004328                 db    1
.xdata$x:00004329                 db    0
.xdata$x:0000432A                 db    0
.xdata$x:0000432B                 db    0
.xdata$x:0000432C __unwindtable$?Parse1@CArcCmdLineParser@@QAEXABV?$CObjectVector@VUString@@@@AAUCArcCmdLineOptions@@@Z db 0FFh
.xdata$x:0000432C                                         ; DATA XREF: .xdata$x:0000433Co
.xdata$x:0000432D                 db 0FFh
.xdata$x:0000432E                 db 0FFh
.xdata$x:0000432F                 db 0FFh
.xdata$x:00004330                 dd offset __unwindfunclet$?Parse1@CArcCmdLineParser@@QAEXABV?$CObjectVector@VUString@@@@AAUCArcCmdLineOptions@@@Z$0
.xdata$x:00004334 __ehfuncinfo$?Parse1@CArcCmdLineParser@@QAEXABV?$CObjectVector@VUString@@@@AAUCArcCmdLineOptions@@@Z db  22h ; "
.xdata$x:00004334                                         ; DATA XREF: __ehhandler$?Parse1@CArcCmdLineParser@@QAEXABV?$CObjectVector@VUString@@@@AAUCArcCmdLineOptions@@@Z+11o
.xdata$x:00004335                 db    5
.xdata$x:00004336                 db  93h ; Ã´
.xdata$x:00004337                 db  19h
.xdata$x:00004338                 db    1
.xdata$x:00004339                 db    0
.xdata$x:0000433A                 db    0
.xdata$x:0000433B                 db    0
.xdata$x:0000433C                 dd offset __unwindtable$?Parse1@CArcCmdLineParser@@QAEXABV?$CObjectVector@VUString@@@@AAUCArcCmdLineOptions@@@Z
.xdata$x:00004340                 db    0
.xdata$x:00004341                 db    0
.xdata$x:00004342                 db    0
.xdata$x:00004343                 db    0
.xdata$x:00004344                 db    0
.xdata$x:00004345                 db    0
.xdata$x:00004346                 db    0
.xdata$x:00004347                 db    0
.xdata$x:00004348                 db    0
.xdata$x:00004349                 db    0
.xdata$x:0000434A                 db    0
.xdata$x:0000434B                 db    0
.xdata$x:0000434C                 db    0
.xdata$x:0000434D                 db    0
.xdata$x:0000434E                 db    0
.xdata$x:0000434F                 db    0
.xdata$x:00004350                 db    0
.xdata$x:00004351                 db    0
.xdata$x:00004352                 db    0
.xdata$x:00004353                 db    0
.xdata$x:00004354                 db    1
.xdata$x:00004355                 db    0
.xdata$x:00004356                 db    0
.xdata$x:00004357                 db    0
.xdata$x:00004358 __ehfuncinfo$?EnumerateDirItemsAndSort@@YGJAAVCCensor@NWildcard@@W4ECensorPathMode@2@ABVUString@@AAV?$CObjectVector@VUString@@@@3AAUCDirItemsStat@@PAUIDirItemsCallback@@@Z db  22h ; "
.xdata$x:00004358                                         ; DATA XREF: __ehhandler$?EnumerateDirItemsAndSort@@YGJAAVCCensor@NWildcard@@W4ECensorPathMode@2@ABVUString@@AAV?$CObjectVector@VUString@@@@3AAUCDirItemsStat@@PAUIDirItemsCallback@@@Z+14o
.xdata$x:00004359                 db    5
.xdata$x:0000435A                 db  93h ; Ã´
.xdata$x:0000435B                 db  19h
.xdata$x:0000435C                 db    6
.xdata$x:0000435D                 db    0
.xdata$x:0000435E                 db    0
.xdata$x:0000435F                 db    0
.xdata$x:00004360                 dd offset __unwindtable$?EnumerateDirItemsAndSort@@YGJAAVCCensor@NWildcard@@W4ECensorPathMode@2@ABVUString@@AAV?$CObjectVector@VUString@@@@3AAUCDirItemsStat@@PAUIDirItemsCallback@@@Z
.xdata$x:00004364                 db    0
.xdata$x:00004365                 db    0
.xdata$x:00004366                 db    0
.xdata$x:00004367                 db    0
.xdata$x:00004368                 db    0
.xdata$x:00004369                 db    0
.xdata$x:0000436A                 db    0
.xdata$x:0000436B                 db    0
.xdata$x:0000436C                 db    0
.xdata$x:0000436D                 db    0
.xdata$x:0000436E                 db    0
.xdata$x:0000436F                 db    0
.xdata$x:00004370                 db    0
.xdata$x:00004371                 db    0
.xdata$x:00004372                 db    0
.xdata$x:00004373                 db    0
.xdata$x:00004374                 db    0
.xdata$x:00004375                 db    0
.xdata$x:00004376                 db    0
.xdata$x:00004377                 db    0
.xdata$x:00004378                 db    1
.xdata$x:00004379                 db    0
.xdata$x:0000437A                 db    0
.xdata$x:0000437B                 db    0
.xdata$x:0000437C __unwindtable$?EnumerateDirItemsAndSort@@YGJAAVCCensor@NWildcard@@W4ECensorPathMode@2@ABVUString@@AAV?$CObjectVector@VUString@@@@3AAUCDirItemsStat@@PAUIDirItemsCallback@@@Z db 0FFh
.xdata$x:0000437C                                         ; DATA XREF: .xdata$x:00004360o
.xdata$x:0000437D                 db 0FFh
.xdata$x:0000437E                 db 0FFh
.xdata$x:0000437F                 db 0FFh
.xdata$x:00004380                 dd offset __unwindfunclet$?EnumerateDirItemsAndSort@@YGJAAVCCensor@NWildcard@@W4ECensorPathMode@2@ABVUString@@AAV?$CObjectVector@VUString@@@@3AAUCDirItemsStat@@PAUIDirItemsCallback@@@Z$0
.xdata$x:00004384                 align 8
.xdata$x:00004388                 dd offset __unwindfunclet$?EnumerateDirItemsAndSort@@YGJAAVCCensor@NWildcard@@W4ECensorPathMode@2@ABVUString@@AAV?$CObjectVector@VUString@@@@3AAUCDirItemsStat@@PAUIDirItemsCallback@@@Z$1
.xdata$x:0000438C                 db    1
.xdata$x:0000438D                 db    0
.xdata$x:0000438E                 db    0
.xdata$x:0000438F                 db    0
.xdata$x:00004390                 dd offset __unwindfunclet$?EnumerateDirItemsAndSort@@YGJAAVCCensor@NWildcard@@W4ECensorPathMode@2@ABVUString@@AAV?$CObjectVector@VUString@@@@3AAUCDirItemsStat@@PAUIDirItemsCallback@@@Z$2
.xdata$x:00004394                 align 8
.xdata$x:00004398                 dd offset __unwindfunclet$?EnumerateDirItemsAndSort@@YGJAAVCCensor@NWildcard@@W4ECensorPathMode@2@ABVUString@@AAV?$CObjectVector@VUString@@@@3AAUCDirItemsStat@@PAUIDirItemsCallback@@@Z$3
.xdata$x:0000439C                 db    3
.xdata$x:0000439D                 db    0
.xdata$x:0000439E                 db    0
.xdata$x:0000439F                 db    0
.xdata$x:000043A0                 dd offset __unwindfunclet$?EnumerateDirItemsAndSort@@YGJAAVCCensor@NWildcard@@W4ECensorPathMode@2@ABVUString@@AAV?$CObjectVector@VUString@@@@3AAUCDirItemsStat@@PAUIDirItemsCallback@@@Z$4
.xdata$x:000043A4                 db    3
.xdata$x:000043A5                 db    0
.xdata$x:000043A6                 db    0
.xdata$x:000043A7                 db    0
.xdata$x:000043A8                 dd offset __unwindfunclet$?EnumerateDirItemsAndSort@@YGJAAVCCensor@NWildcard@@W4ECensorPathMode@2@ABVUString@@AAV?$CObjectVector@VUString@@@@3AAUCDirItemsStat@@PAUIDirItemsCallback@@@Z$5
.xdata$x:000043AC __unwindtable$?ParseArchiveCommand@@YG_NABVUString@@AAUCArcCommand@@@Z db 0FFh
.xdata$x:000043AC                                         ; DATA XREF: .xdata$x:000043BCo
.xdata$x:000043AD                 db 0FFh
.xdata$x:000043AE                 db 0FFh
.xdata$x:000043AF                 db 0FFh
.xdata$x:000043B0                 dd offset __unwindfunclet$?ParseArchiveCommand@@YG_NABVUString@@AAUCArcCommand@@@Z$0
.xdata$x:000043B4 __ehfuncinfo$?ParseArchiveCommand@@YG_NABVUString@@AAUCArcCommand@@@Z db  22h ; "
.xdata$x:000043B4                                         ; DATA XREF: __ehhandler$?ParseArchiveCommand@@YG_NABVUString@@AAUCArcCommand@@@Z+11o
.xdata$x:000043B5                 db    5
.xdata$x:000043B6                 db  93h ; Ã´
.xdata$x:000043B7                 db  19h
.xdata$x:000043B8                 db    1
.xdata$x:000043B9                 db    0
.xdata$x:000043BA                 db    0
.xdata$x:000043BB                 db    0
.xdata$x:000043BC                 dd offset __unwindtable$?ParseArchiveCommand@@YG_NABVUString@@AAUCArcCommand@@@Z
.xdata$x:000043C0                 db    0
.xdata$x:000043C1                 db    0
.xdata$x:000043C2                 db    0
.xdata$x:000043C3                 db    0
.xdata$x:000043C4                 db    0
.xdata$x:000043C5                 db    0
.xdata$x:000043C6                 db    0
.xdata$x:000043C7                 db    0
.xdata$x:000043C8                 db    0
.xdata$x:000043C9                 db    0
.xdata$x:000043CA                 db    0
.xdata$x:000043CB                 db    0
.xdata$x:000043CC                 db    0
.xdata$x:000043CD                 db    0
.xdata$x:000043CE                 db    0
.xdata$x:000043CF                 db    0
.xdata$x:000043D0                 db    0
.xdata$x:000043D1                 db    0
.xdata$x:000043D2                 db    0
.xdata$x:000043D3                 db    0
.xdata$x:000043D4                 db    1
.xdata$x:000043D5                 db    0
.xdata$x:000043D6                 db    0
.xdata$x:000043D7                 db    0
.xdata$x:000043D8 __unwindtable$?AddToCensorFromNonSwitchesStrings@@YGXPAV?$CObjectVector@UCRenamePair@@@@IAAVCCensor@NWildcard@@ABV?$CObjectVector@VUString@@@@W4EEnum@NRecursedType@@_N4H@Z db 0FFh
.xdata$x:000043D8                                         ; DATA XREF: .xdata$x:000043E8o
.xdata$x:000043D9                 db 0FFh
.xdata$x:000043DA                 db 0FFh
.xdata$x:000043DB                 db 0FFh
.xdata$x:000043DC                 dd offset __unwindfunclet$?AddToCensorFromNonSwitchesStrings@@YGXPAV?$CObjectVector@UCRenamePair@@@@IAAVCCensor@NWildcard@@ABV?$CObjectVector@VUString@@@@W4EEnum@NRecursedType@@_N4H@Z$0
.xdata$x:000043E0 __ehfuncinfo$?AddToCensorFromNonSwitchesStrings@@YGXPAV?$CObjectVector@UCRenamePair@@@@IAAVCCensor@NWildcard@@ABV?$CObjectVector@VUString@@@@W4EEnum@NRecursedType@@_N4H@Z db  22h ; "
.xdata$x:000043E0                                         ; DATA XREF: __ehhandler$?AddToCensorFromNonSwitchesStrings@@YGXPAV?$CObjectVector@UCRenamePair@@@@IAAVCCensor@NWildcard@@ABV?$CObjectVector@VUString@@@@W4EEnum@NRecursedType@@_N4H@Z+11o
.xdata$x:000043E1                 db    5
.xdata$x:000043E2                 db  93h ; Ã´
.xdata$x:000043E3                 db  19h
.xdata$x:000043E4                 db    1
.xdata$x:000043E5                 db    0
.xdata$x:000043E6                 db    0
.xdata$x:000043E7                 db    0
.xdata$x:000043E8                 dd offset __unwindtable$?AddToCensorFromNonSwitchesStrings@@YGXPAV?$CObjectVector@UCRenamePair@@@@IAAVCCensor@NWildcard@@ABV?$CObjectVector@VUString@@@@W4EEnum@NRecursedType@@_N4H@Z
.xdata$x:000043EC                 align 20h
.xdata$x:00004400                 db    1
.xdata$x:00004401                 db    0
.xdata$x:00004402                 db    0
.xdata$x:00004403                 db    0
.xdata$x:00004404 __unwindtable$?AddRenamePair@@YGXPAV?$CObjectVector@UCRenamePair@@@@ABVUString@@1W4EEnum@NRecursedType@@_N@Z db 0FFh
.xdata$x:00004404                                         ; DATA XREF: .xdata$x:00004414o
.xdata$x:00004405                 db 0FFh
.xdata$x:00004406                 db 0FFh
.xdata$x:00004407                 db 0FFh
.xdata$x:00004408                 dd offset __unwindfunclet$?AddRenamePair@@YGXPAV?$CObjectVector@UCRenamePair@@@@ABVUString@@1W4EEnum@NRecursedType@@_N@Z$0
.xdata$x:0000440C __ehfuncinfo$?AddRenamePair@@YGXPAV?$CObjectVector@UCRenamePair@@@@ABVUString@@1W4EEnum@NRecursedType@@_N@Z db  22h ; "
.xdata$x:0000440C                                         ; DATA XREF: __ehhandler$?AddRenamePair@@YGXPAV?$CObjectVector@UCRenamePair@@@@ABVUString@@1W4EEnum@NRecursedType@@_N@Z+11o
.xdata$x:0000440D                 db    5
.xdata$x:0000440E                 db  93h ; Ã´
.xdata$x:0000440F                 db  19h
.xdata$x:00004410                 db    1
.xdata$x:00004411                 db    0
.xdata$x:00004412                 db    0
.xdata$x:00004413                 db    0
.xdata$x:00004414                 dd offset __unwindtable$?AddRenamePair@@YGXPAV?$CObjectVector@UCRenamePair@@@@ABVUString@@1W4EEnum@NRecursedType@@_N@Z
.xdata$x:00004418                 db    0
.xdata$x:00004419                 db    0
.xdata$x:0000441A                 db    0
.xdata$x:0000441B                 db    0
.xdata$x:0000441C                 db    0
.xdata$x:0000441D                 db    0
.xdata$x:0000441E                 db    0
.xdata$x:0000441F                 db    0
.xdata$x:00004420                 db    0
.xdata$x:00004421                 db    0
.xdata$x:00004422                 db    0
.xdata$x:00004423                 db    0
.xdata$x:00004424                 db    0
.xdata$x:00004425                 db    0
.xdata$x:00004426                 db    0
.xdata$x:00004427                 db    0
.xdata$x:00004428                 db    0
.xdata$x:00004429                 db    0
.xdata$x:0000442A                 db    0
.xdata$x:0000442B                 db    0
.xdata$x:0000442C                 db    1
.xdata$x:0000442D                 db    0
.xdata$x:0000442E                 db    0
.xdata$x:0000442F                 db    0
.xdata$x:00004430 __unwindtable$?AddToCensorFromListFile@@YGXPAV?$CObjectVector@UCRenamePair@@@@AAVCCensor@NWildcard@@PB_W_NW4EEnum@NRecursedType@@3H@Z db 0FFh
.xdata$x:00004430                                         ; DATA XREF: .xdata$x:00004440o
.xdata$x:00004431                 db 0FFh
.xdata$x:00004432                 db 0FFh
.xdata$x:00004433                 db 0FFh
.xdata$x:00004434                 dd offset __unwindfunclet$?AddToCensorFromListFile@@YGXPAV?$CObjectVector@UCRenamePair@@@@AAVCCensor@NWildcard@@PB_W_NW4EEnum@NRecursedType@@3H@Z$0
.xdata$x:00004438 __ehfuncinfo$?AddToCensorFromListFile@@YGXPAV?$CObjectVector@UCRenamePair@@@@AAVCCensor@NWildcard@@PB_W_NW4EEnum@NRecursedType@@3H@Z db  22h ; "
.xdata$x:00004438                                         ; DATA XREF: __ehhandler$?AddToCensorFromListFile@@YGXPAV?$CObjectVector@UCRenamePair@@@@AAVCCensor@NWildcard@@PB_W_NW4EEnum@NRecursedType@@3H@Z+11o
.xdata$x:00004439                 db    5
.xdata$x:0000443A                 db  93h ; Ã´
.xdata$x:0000443B                 db  19h
.xdata$x:0000443C                 db    1
.xdata$x:0000443D                 db    0
.xdata$x:0000443E                 db    0
.xdata$x:0000443F                 db    0
.xdata$x:00004440                 dd offset __unwindtable$?AddToCensorFromListFile@@YGXPAV?$CObjectVector@UCRenamePair@@@@AAVCCensor@NWildcard@@PB_W_NW4EEnum@NRecursedType@@3H@Z
.xdata$x:00004444                 db    0
.xdata$x:00004445                 db    0
.xdata$x:00004446                 db    0
.xdata$x:00004447                 db    0
.xdata$x:00004448                 db    0
.xdata$x:00004449                 db    0
.xdata$x:0000444A                 db    0
.xdata$x:0000444B                 db    0
.xdata$x:0000444C                 db    0
.xdata$x:0000444D                 db    0
.xdata$x:0000444E                 db    0
.xdata$x:0000444F                 db    0
.xdata$x:00004450                 db    0
.xdata$x:00004451                 db    0
.xdata$x:00004452                 db    0
.xdata$x:00004453                 db    0
.xdata$x:00004454                 db    0
.xdata$x:00004455                 db    0
.xdata$x:00004456                 db    0
.xdata$x:00004457                 db    0
.xdata$x:00004458                 db    1
.xdata$x:00004459                 db    0
.xdata$x:0000445A                 db    0
.xdata$x:0000445B                 db    0
.xdata$x:0000445C __unwindtable$?AddSwitchWildcardsToCensor@@YGXAAVCCensor@NWildcard@@ABV?$CObjectVector@VUString@@@@_NW4EEnum@NRecursedType@@2H@Z db 0FFh
.xdata$x:0000445C                                         ; DATA XREF: .xdata$x:0000446Co
.xdata$x:0000445D                 db 0FFh
.xdata$x:0000445E                 db 0FFh
.xdata$x:0000445F                 db 0FFh
.xdata$x:00004460                 dd offset __unwindfunclet$?AddSwitchWildcardsToCensor@@YGXAAVCCensor@NWildcard@@ABV?$CObjectVector@VUString@@@@_NW4EEnum@NRecursedType@@2H@Z$0
.xdata$x:00004464 __ehfuncinfo$?AddSwitchWildcardsToCensor@@YGXAAVCCensor@NWildcard@@ABV?$CObjectVector@VUString@@@@_NW4EEnum@NRecursedType@@2H@Z db  22h ; "
.xdata$x:00004464                                         ; DATA XREF: __ehhandler$?AddSwitchWildcardsToCensor@@YGXAAVCCensor@NWildcard@@ABV?$CObjectVector@VUString@@@@_NW4EEnum@NRecursedType@@2H@Z+11o
.xdata$x:00004465                 db    5
.xdata$x:00004466                 db  93h ; Ã´
.xdata$x:00004467                 db  19h
.xdata$x:00004468                 db    1
.xdata$x:00004469                 db    0
.xdata$x:0000446A                 db    0
.xdata$x:0000446B                 db    0
.xdata$x:0000446C                 dd offset __unwindtable$?AddSwitchWildcardsToCensor@@YGXAAVCCensor@NWildcard@@ABV?$CObjectVector@VUString@@@@_NW4EEnum@NRecursedType@@2H@Z
.xdata$x:00004470                 db    0
.xdata$x:00004471                 db    0
.xdata$x:00004472                 db    0
.xdata$x:00004473                 db    0
.xdata$x:00004474                 db    0
.xdata$x:00004475                 db    0
.xdata$x:00004476                 db    0
.xdata$x:00004477                 db    0
.xdata$x:00004478                 db    0
.xdata$x:00004479                 db    0
.xdata$x:0000447A                 db    0
.xdata$x:0000447B                 db    0
.xdata$x:0000447C                 db    0
.xdata$x:0000447D                 db    0
.xdata$x:0000447E                 db    0
.xdata$x:0000447F                 db    0
.xdata$x:00004480                 db    0
.xdata$x:00004481                 db    0
.xdata$x:00004482                 db    0
.xdata$x:00004483                 db    0
.xdata$x:00004484                 db    1
.xdata$x:00004485                 db    0
.xdata$x:00004486                 db    0
.xdata$x:00004487                 db    0
.xdata$x:00004488 __ehfuncinfo$?ParseMapWithPaths@@YGPBDAAVCCensor@NWildcard@@ABVUString@@_NW4EEnum@NRecursedType@@2@Z db  22h ; "
.xdata$x:00004488                                         ; DATA XREF: __ehhandler$?ParseMapWithPaths@@YGPBDAAVCCensor@NWildcard@@ABVUString@@_NW4EEnum@NRecursedType@@2@Z+14o
.xdata$x:00004489                 db    5
.xdata$x:0000448A                 db  93h ; Ã´
.xdata$x:0000448B                 db  19h
.xdata$x:0000448C                 db    6
.xdata$x:0000448D                 db    0
.xdata$x:0000448E                 db    0
.xdata$x:0000448F                 db    0
.xdata$x:00004490                 dd offset __unwindtable$?ParseMapWithPaths@@YGPBDAAVCCensor@NWildcard@@ABVUString@@_NW4EEnum@NRecursedType@@2@Z
.xdata$x:00004494                 db    0
.xdata$x:00004495                 db    0
.xdata$x:00004496                 db    0
.xdata$x:00004497                 db    0
.xdata$x:00004498                 db    0
.xdata$x:00004499                 db    0
.xdata$x:0000449A                 db    0
.xdata$x:0000449B                 db    0
.xdata$x:0000449C                 db    0
.xdata$x:0000449D                 db    0
.xdata$x:0000449E                 db    0
.xdata$x:0000449F                 db    0
.xdata$x:000044A0                 db    0
.xdata$x:000044A1                 db    0
.xdata$x:000044A2                 db    0
.xdata$x:000044A3                 db    0
.xdata$x:000044A4                 db    0
.xdata$x:000044A5                 db    0
.xdata$x:000044A6                 db    0
.xdata$x:000044A7                 db    0
.xdata$x:000044A8                 db    1
.xdata$x:000044A9                 db    0
.xdata$x:000044AA                 db    0
.xdata$x:000044AB                 db    0
.xdata$x:000044AC __unwindtable$?ParseMapWithPaths@@YGPBDAAVCCensor@NWildcard@@ABVUString@@_NW4EEnum@NRecursedType@@2@Z db 0FFh
.xdata$x:000044AC                                         ; DATA XREF: .xdata$x:00004490o
.xdata$x:000044AD                 db 0FFh
.xdata$x:000044AE                 db 0FFh
.xdata$x:000044AF                 db 0FFh
.xdata$x:000044B0                 dd offset __unwindfunclet$?ParseMapWithPaths@@YGPBDAAVCCensor@NWildcard@@ABVUString@@_NW4EEnum@NRecursedType@@2@Z$0
.xdata$x:000044B4                 align 8
.xdata$x:000044B8                 dd offset __unwindfunclet$?ParseMapWithPaths@@YGPBDAAVCCensor@NWildcard@@ABVUString@@_NW4EEnum@NRecursedType@@2@Z$1
.xdata$x:000044BC                 db    1
.xdata$x:000044BD                 db    0
.xdata$x:000044BE                 db    0
.xdata$x:000044BF                 db    0
.xdata$x:000044C0                 dd offset __unwindfunclet$?ParseMapWithPaths@@YGPBDAAVCCensor@NWildcard@@ABVUString@@_NW4EEnum@NRecursedType@@2@Z$2
.xdata$x:000044C4                 db    2
.xdata$x:000044C5                 db    0
.xdata$x:000044C6                 db    0
.xdata$x:000044C7                 db    0
.xdata$x:000044C8                 dd offset __unwindfunclet$?ParseMapWithPaths@@YGPBDAAVCCensor@NWildcard@@ABVUString@@_NW4EEnum@NRecursedType@@2@Z$3
.xdata$x:000044CC                 db    2
.xdata$x:000044CD                 db    0
.xdata$x:000044CE                 db    0
.xdata$x:000044CF                 db    0
.xdata$x:000044D0                 dd offset __unwindfunclet$?ParseMapWithPaths@@YGPBDAAVCCensor@NWildcard@@ABVUString@@_NW4EEnum@NRecursedType@@2@Z$4
.xdata$x:000044D4                 db    4
.xdata$x:000044D5                 db    0
.xdata$x:000044D6                 db    0
.xdata$x:000044D7                 db    0
.xdata$x:000044D8                 dd offset __unwindfunclet$?ParseMapWithPaths@@YGPBDAAVCCensor@NWildcard@@ABVUString@@_NW4EEnum@NRecursedType@@2@Z$5
.xdata$x:000044DC __unwindtable$?SetAddCommandOptions@@YGXW4EEnum@NCommandType@@ABVCParser@NCommandLineParser@@AAUCUpdateOptions@@@Z db 0FFh
.xdata$x:000044DC                                         ; DATA XREF: .xdata$x:000044ECo
.xdata$x:000044DD                 db 0FFh
.xdata$x:000044DE                 db 0FFh
.xdata$x:000044DF                 db 0FFh
.xdata$x:000044E0                 dd offset __unwindfunclet$?SetAddCommandOptions@@YGXW4EEnum@NCommandType@@ABVCParser@NCommandLineParser@@AAUCUpdateOptions@@@Z$0
.xdata$x:000044E4 __ehfuncinfo$?SetAddCommandOptions@@YGXW4EEnum@NCommandType@@ABVCParser@NCommandLineParser@@AAUCUpdateOptions@@@Z db  22h ; "
.xdata$x:000044E4                                         ; DATA XREF: __ehhandler$?SetAddCommandOptions@@YGXW4EEnum@NCommandType@@ABVCParser@NCommandLineParser@@AAUCUpdateOptions@@@Z+1Eo
.xdata$x:000044E5                 db    5
.xdata$x:000044E6                 db  93h ; Ã´
.xdata$x:000044E7                 db  19h
.xdata$x:000044E8                 db    1
.xdata$x:000044E9                 db    0
.xdata$x:000044EA                 db    0
.xdata$x:000044EB                 db    0
.xdata$x:000044EC                 dd offset __unwindtable$?SetAddCommandOptions@@YGXW4EEnum@NCommandType@@ABVCParser@NCommandLineParser@@AAUCUpdateOptions@@@Z
.xdata$x:000044F0                 db    0
.xdata$x:000044F1                 db    0
.xdata$x:000044F2                 db    0
.xdata$x:000044F3                 db    0
.xdata$x:000044F4                 db    0
.xdata$x:000044F5                 db    0
.xdata$x:000044F6                 db    0
.xdata$x:000044F7                 db    0
.xdata$x:000044F8                 db    0
.xdata$x:000044F9                 db    0
.xdata$x:000044FA                 db    0
.xdata$x:000044FB                 db    0
.xdata$x:000044FC                 db    0
.xdata$x:000044FD                 db    0
.xdata$x:000044FE                 db    0
.xdata$x:000044FF                 db    0
.xdata$x:00004500                 db    0
.xdata$x:00004501                 db    0
.xdata$x:00004502                 db    0
.xdata$x:00004503                 db    0
.xdata$x:00004504                 db    1
.xdata$x:00004505                 db    0
.xdata$x:00004506                 db    0
.xdata$x:00004507                 db    0
.xdata$x:00004508 __unwindtable$?ParseUpdateCommandString@@YGXAAUCUpdateOptions@@ABV?$CObjectVector@VUString@@@@ABUCActionSet@NUpdateArchive@@@Z db 0FFh
.xdata$x:00004508                                         ; DATA XREF: .xdata$x:00004528o
.xdata$x:00004509                 db 0FFh
.xdata$x:0000450A                 db 0FFh
.xdata$x:0000450B                 db 0FFh
.xdata$x:0000450C                 dd offset __unwindfunclet$?ParseUpdateCommandString@@YGXAAUCUpdateOptions@@ABV?$CObjectVector@VUString@@@@ABUCActionSet@NUpdateArchive@@@Z$0
.xdata$x:00004510                 db    0
.xdata$x:00004511                 db    0
.xdata$x:00004512                 db    0
.xdata$x:00004513                 db    0
.xdata$x:00004514                 dd offset __unwindfunclet$?ParseUpdateCommandString@@YGXAAUCUpdateOptions@@ABV?$CObjectVector@VUString@@@@ABUCActionSet@NUpdateArchive@@@Z$1
.xdata$x:00004518                 db    1
.xdata$x:00004519                 db    0
.xdata$x:0000451A                 db    0
.xdata$x:0000451B                 db    0
.xdata$x:0000451C                 dd offset __unwindfunclet$?ParseUpdateCommandString@@YGXAAUCUpdateOptions@@ABV?$CObjectVector@VUString@@@@ABUCActionSet@NUpdateArchive@@@Z$2
.xdata$x:00004520 __ehfuncinfo$?ParseUpdateCommandString@@YGXAAUCUpdateOptions@@ABV?$CObjectVector@VUString@@@@ABUCActionSet@NUpdateArchive@@@Z db  22h ; "
.xdata$x:00004520                                         ; DATA XREF: __ehhandler$?ParseUpdateCommandString@@YGXAAUCUpdateOptions@@ABV?$CObjectVector@VUString@@@@ABUCActionSet@NUpdateArchive@@@Z+1Eo
.xdata$x:00004521                 db    5
.xdata$x:00004522                 db  93h ; Ã´
.xdata$x:00004523                 db  19h
.xdata$x:00004524                 db    3
.xdata$x:00004525                 db    0
.xdata$x:00004526                 db    0
.xdata$x:00004527                 db    0
.xdata$x:00004528                 dd offset __unwindtable$?ParseUpdateCommandString@@YGXAAUCUpdateOptions@@ABV?$CObjectVector@VUString@@@@ABUCActionSet@NUpdateArchive@@@Z
.xdata$x:0000452C                 align 20h
.xdata$x:00004540                 db    1
.xdata$x:00004541                 db    0
.xdata$x:00004542                 db    0
.xdata$x:00004543                 db    0
.xdata$x:00004544 __unwindtable$?SetMethodOptions@@YGXABVCParser@NCommandLineParser@@AAV?$CObjectVector@UCProperty@@@@@Z db 0FFh
.xdata$x:00004544                                         ; DATA XREF: .xdata$x:00004554o
.xdata$x:00004545                 db 0FFh
.xdata$x:00004546                 db 0FFh
.xdata$x:00004547                 db 0FFh
.xdata$x:00004548                 dd offset __unwindfunclet$?SetMethodOptions@@YGXABVCParser@NCommandLineParser@@AAV?$CObjectVector@UCProperty@@@@@Z$0
.xdata$x:0000454C __ehfuncinfo$?SetMethodOptions@@YGXABVCParser@NCommandLineParser@@AAV?$CObjectVector@UCProperty@@@@@Z db  22h ; "
.xdata$x:0000454C                                         ; DATA XREF: __ehhandler$?SetMethodOptions@@YGXABVCParser@NCommandLineParser@@AAV?$CObjectVector@UCProperty@@@@@Z+11o
.xdata$x:0000454D                 db    5
.xdata$x:0000454E                 db  93h ; Ã´
.xdata$x:0000454F                 db  19h
.xdata$x:00004550                 db    1
.xdata$x:00004551                 db    0
.xdata$x:00004552                 db    0
.xdata$x:00004553                 db    0
.xdata$x:00004554                 dd offset __unwindtable$?SetMethodOptions@@YGXABVCParser@NCommandLineParser@@AAV?$CObjectVector@UCProperty@@@@@Z
.xdata$x:00004558                 db    0
.xdata$x:00004559                 db    0
.xdata$x:0000455A                 db    0
.xdata$x:0000455B                 db    0
.xdata$x:0000455C                 db    0
.xdata$x:0000455D                 db    0
.xdata$x:0000455E                 db    0
.xdata$x:0000455F                 db    0
.xdata$x:00004560                 db    0
.xdata$x:00004561                 db    0
.xdata$x:00004562                 db    0
.xdata$x:00004563                 db    0
.xdata$x:00004564                 db    0
.xdata$x:00004565                 db    0
.xdata$x:00004566                 db    0
.xdata$x:00004567                 db    0
.xdata$x:00004568                 db    0
.xdata$x:00004569                 db    0
.xdata$x:0000456A                 db    0
.xdata$x:0000456B                 db    0
.xdata$x:0000456C                 db    1
.xdata$x:0000456D                 db    0
.xdata$x:0000456E                 db    0
.xdata$x:0000456F                 db    0
.xdata$x:00004570 __unwindtable$?FindCharset@@YGHABVCParser@NCommandLineParser@@I_NH@Z db 0FFh
.xdata$x:00004570                                         ; DATA XREF: .xdata$x:00004580o
.xdata$x:00004571                 db 0FFh
.xdata$x:00004572                 db 0FFh
.xdata$x:00004573                 db 0FFh
.xdata$x:00004574                 dd offset __unwindfunclet$?FindCharset@@YGHABVCParser@NCommandLineParser@@I_NH@Z$0
.xdata$x:00004578 __ehfuncinfo$?FindCharset@@YGHABVCParser@NCommandLineParser@@I_NH@Z db  22h ; "
.xdata$x:00004578                                         ; DATA XREF: __ehhandler$?FindCharset@@YGHABVCParser@NCommandLineParser@@I_NH@Z+11o
.xdata$x:00004579                 db    5
.xdata$x:0000457A                 db  93h ; Ã´
.xdata$x:0000457B                 db  19h
.xdata$x:0000457C                 db    1
.xdata$x:0000457D                 db    0
.xdata$x:0000457E                 db    0
.xdata$x:0000457F                 db    0
.xdata$x:00004580                 dd offset __unwindtable$?FindCharset@@YGHABVCParser@NCommandLineParser@@I_NH@Z
.xdata$x:00004584                 db    0
.xdata$x:00004585                 db    0
.xdata$x:00004586                 db    0
.xdata$x:00004587                 db    0
.xdata$x:00004588                 db    0
.xdata$x:00004589                 db    0
.xdata$x:0000458A                 db    0
.xdata$x:0000458B                 db    0
.xdata$x:0000458C                 db    0
.xdata$x:0000458D                 db    0
.xdata$x:0000458E                 db    0
.xdata$x:0000458F                 db    0
.xdata$x:00004590                 db    0
.xdata$x:00004591                 db    0
.xdata$x:00004592                 db    0
.xdata$x:00004593                 db    0
.xdata$x:00004594                 db    0
.xdata$x:00004595                 db    0
.xdata$x:00004596                 db    0
.xdata$x:00004597                 db    0
.xdata$x:00004598                 db    1
.xdata$x:00004599                 db    0
.xdata$x:0000459A                 db    0
.xdata$x:0000459B                 db    0
.xdata$x:0000459B _xdata$x        ends
.xdata$x:0000459B
.rtc$TMZ:0000459C ; ===========================================================================
.rtc$TMZ:0000459C
.rtc$TMZ:0000459C ; Segment type: Pure data
.rtc$TMZ:0000459C ; Segment permissions: Read
.rtc$TMZ:0000459C _rtc$TMZ        segment dword public 'DATA' use32
.rtc$TMZ:0000459C                 assume cs:_rtc$TMZ
.rtc$TMZ:0000459C                 ;org 459Ch
.rtc$TMZ:0000459C ; COMDAT (pick any)
.rtc$TMZ:0000459C __RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
.rtc$TMZ:0000459C _rtc$TMZ        ends
.rtc$TMZ:0000459C
.rtc$IMZ:000045A0 ; ===========================================================================
.rtc$IMZ:000045A0
.rtc$IMZ:000045A0 ; Segment type: Pure data
.rtc$IMZ:000045A0 ; Segment permissions: Read
.rtc$IMZ:000045A0 _rtc$IMZ        segment dword public 'DATA' use32
.rtc$IMZ:000045A0                 assume cs:_rtc$IMZ
.rtc$IMZ:000045A0                 ;org 45A0h
.rtc$IMZ:000045A0 ; COMDAT (pick any)
.rtc$IMZ:000045A0 __RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
.rtc$IMZ:000045A0 _rtc$IMZ        ends
.rtc$IMZ:000045A0
.text:000045A4 ; ===========================================================================
.text:000045A4
.text:000045A4 ; Segment type: Pure code
.text:000045A4 ; Segment permissions: Read/Execute
.text:000045A4 _text           segment para public 'CODE' use32
.text:000045A4                 assume cs:_text
.text:000045A4                 ;org 45A4h
.text:000045A4 ; COMDAT (pick any)
.text:000045A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000045A4
.text:000045A4 ; =============== S U B R O U T I N E =======================================
.text:000045A4
.text:000045A4 ; Attributes: bp-based frame
.text:000045A4
.text:000045A4 ; _DWORD __thiscall AString::~AString(AString *__hidden this)
.text:000045A4                 public ??1AString@@QAE@XZ
.text:000045A4 ??1AString@@QAE@XZ proc near            ; CODE XREF: CArcCmdLineException::CArcCmdLineException(char const *,wchar_t const *)+A2p
.text:000045A4                                         ; CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+493p ...
.text:000045A4
.text:000045A4 var_8           = dword ptr -8
.text:000045A4 var_4           = dword ptr -4
.text:000045A4
.text:000045A4                 push    ebp
.text:000045A5                 mov     ebp, esp
.text:000045A7                 sub     esp, 8
.text:000045AA                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000045B1                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000045B8                 mov     [ebp+var_4], ecx
.text:000045BB                 mov     eax, [ebp+var_4]
.text:000045BE                 mov     ecx, [eax]
.text:000045C0                 mov     [ebp+var_8], ecx
.text:000045C3                 mov     edx, [ebp+var_8]
.text:000045C6                 push    edx             ; void *
.text:000045C7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:000045CC                 add     esp, 4
.text:000045CF                 add     esp, 8
.text:000045D2                 cmp     ebp, esp
.text:000045D4                 call    __RTC_CheckEsp
.text:000045D9                 mov     esp, ebp
.text:000045DB                 pop     ebp
.text:000045DC                 retn
.text:000045DC ??1AString@@QAE@XZ endp
.text:000045DC
.text:000045DC ; ---------------------------------------------------------------------------
.text:000045DD                 align 10h
.text:000045DD _text           ends
.text:000045DD
.text:000045E0 ; ===========================================================================
.text:000045E0
.text:000045E0 ; Segment type: Pure code
.text:000045E0 ; Segment permissions: Read/Execute
.text:000045E0 _text           segment para public 'CODE' use32
.text:000045E0                 assume cs:_text
.text:000045E0                 ;org 45E0h
.text:000045E0 ; COMDAT (pick any)
.text:000045E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000045E0
.text:000045E0 ; =============== S U B R O U T I N E =======================================
.text:000045E0
.text:000045E0 ; Attributes: bp-based frame
.text:000045E0
.text:000045E0 ; _DWORD __thiscall UString::~UString(UString *__hidden this)
.text:000045E0                 public ??1UString@@QAE@XZ
.text:000045E0 ??1UString@@QAE@XZ proc near            ; CODE XREF: CArcCmdLineException::CArcCmdLineException(char const *,wchar_t const *)+96p
.text:000045E0                                         ; ConvertToLongNames(UString const &,NWildcard::CCensorNode &)+20Fp ...
.text:000045E0
.text:000045E0 var_8           = dword ptr -8
.text:000045E0 var_4           = dword ptr -4
.text:000045E0
.text:000045E0                 push    ebp
.text:000045E1                 mov     ebp, esp
.text:000045E3                 sub     esp, 8
.text:000045E6                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000045ED                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000045F4                 mov     [ebp+var_4], ecx
.text:000045F7                 mov     eax, [ebp+var_4]
.text:000045FA                 mov     ecx, [eax]
.text:000045FC                 mov     [ebp+var_8], ecx
.text:000045FF                 mov     edx, [ebp+var_8]
.text:00004602                 push    edx             ; void *
.text:00004603                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00004608                 add     esp, 4
.text:0000460B                 add     esp, 8
.text:0000460E                 cmp     ebp, esp
.text:00004610                 call    __RTC_CheckEsp
.text:00004615                 mov     esp, ebp
.text:00004617                 pop     ebp
.text:00004618                 retn
.text:00004618 ??1UString@@QAE@XZ endp
.text:00004618
.text:00004618 ; ---------------------------------------------------------------------------
.text:00004619                 align 4
.text:00004619 _text           ends
.text:00004619
.text:0000461C ; ===========================================================================
.text:0000461C
.text:0000461C ; Segment type: Pure code
.text:0000461C ; Segment permissions: Read/Execute
.text:0000461C _text           segment para public 'CODE' use32
.text:0000461C                 assume cs:_text
.text:0000461C                 ;org 461Ch
.text:0000461C ; COMDAT (pick any)
.text:0000461C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000461C
.text:0000461C ; =============== S U B R O U T I N E =======================================
.text:0000461C
.text:0000461C ; Attributes: bp-based frame
.text:0000461C
.text:0000461C ; class UString __stdcall operator+(class UString const &, wchar_t)
.text:0000461C                 public ??H@YG?AVUString@@ABV0@_W@Z
.text:0000461C ??H@YG?AVUString@@ABV0@_W@Z proc near   ; CODE XREF: ConvertToLongNames(UString const &,NWildcard::CCensorNode &)+1EDp
.text:0000461C
.text:0000461C var_4           = dword ptr -4
.text:0000461C arg_0           = dword ptr  8
.text:0000461C arg_4           = dword ptr  0Ch
.text:0000461C arg_8           = word ptr  10h
.text:0000461C
.text:0000461C                 push    ebp
.text:0000461D                 mov     ebp, esp
.text:0000461F                 push    ecx
.text:00004620                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00004627                 mov     [ebp+var_4], 0
.text:0000462E                 movzx   eax, [ebp+arg_8]
.text:00004632                 push    eax
.text:00004633                 mov     ecx, [ebp+arg_4]
.text:00004636                 push    ecx
.text:00004637                 mov     ecx, [ebp+arg_0]
.text:0000463A                 call    ??0UString@@AAE@ABV0@_W@Z ; UString::UString(UString const &,wchar_t)
.text:0000463F                 mov     edx, [ebp+var_4]
.text:00004642                 or      edx, 1
.text:00004645                 mov     [ebp+var_4], edx
.text:00004648                 mov     eax, [ebp+arg_0]
.text:0000464B                 add     esp, 4
.text:0000464E                 cmp     ebp, esp
.text:00004650                 call    __RTC_CheckEsp
.text:00004655                 mov     esp, ebp
.text:00004657                 pop     ebp
.text:00004658                 retn    0Ch
.text:00004658 ??H@YG?AVUString@@ABV0@_W@Z endp
.text:00004658
.text:00004658 ; ---------------------------------------------------------------------------
.text:0000465B                 align 4
.text:0000465B _text           ends
.text:0000465B
.text:0000465C ; ===========================================================================
.text:0000465C
.text:0000465C ; Segment type: Pure code
.text:0000465C ; Segment permissions: Read/Execute
.text:0000465C _text           segment para public 'CODE' use32
.text:0000465C                 assume cs:_text
.text:0000465C                 ;org 465Ch
.text:0000465C ; COMDAT (pick any)
.text:0000465C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000465C
.text:0000465C ; =============== S U B R O U T I N E =======================================
.text:0000465C
.text:0000465C ; Attributes: bp-based frame
.text:0000465C
.text:0000465C ; bool __thiscall UString::IsEmpty(UString *__hidden this)
.text:0000465C                 public ?IsEmpty@UString@@QBE_NXZ
.text:0000465C ?IsEmpty@UString@@QBE_NXZ proc near     ; CODE XREF: ConvertToLongNames(UString const &,NWildcard::CCensorNode &)+8Fp
.text:0000465C                                         ; ConvertToLongName(UString const &,UString &)+38p ...
.text:0000465C
.text:0000465C var_4           = dword ptr -4
.text:0000465C
.text:0000465C                 push    ebp
.text:0000465D                 mov     ebp, esp
.text:0000465F                 push    ecx
.text:00004660                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00004667                 mov     [ebp+var_4], ecx
.text:0000466A                 mov     eax, [ebp+var_4]
.text:0000466D                 xor     ecx, ecx
.text:0000466F                 cmp     dword ptr [eax+4], 0
.text:00004673                 setz    cl
.text:00004676                 mov     al, cl
.text:00004678                 mov     esp, ebp
.text:0000467A                 pop     ebp
.text:0000467B                 retn
.text:0000467B ?IsEmpty@UString@@QBE_NXZ endp
.text:0000467B
.text:0000467B _text           ends
.text:0000467B
.text:0000467C ; ===========================================================================
.text:0000467C
.text:0000467C ; Segment type: Pure code
.text:0000467C ; Segment permissions: Read/Execute
.text:0000467C _text           segment para public 'CODE' use32
.text:0000467C                 assume cs:_text
.text:0000467C                 ;org 467Ch
.text:0000467C ; COMDAT (pick any)
.text:0000467C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000467C
.text:0000467C ; =============== S U B R O U T I N E =======================================
.text:0000467C
.text:0000467C ; Attributes: bp-based frame
.text:0000467C
.text:0000467C ; public: __thiscall UString::operator wchar_t const *(void)const
.text:0000467C                 public ??BUString@@QBEPB_WXZ
.text:0000467C ??BUString@@QBEPB_WXZ proc near         ; CODE XREF: ConvertToLongNames(UString const &,NWildcard::CCensorNode &)+9Ep
.text:0000467C                                         ; ConvertToLongNames(UString const &,NWildcard::CCensorNode &)+12Ap ...
.text:0000467C
.text:0000467C var_4           = dword ptr -4
.text:0000467C
.text:0000467C                 push    ebp
.text:0000467D                 mov     ebp, esp
.text:0000467F                 push    ecx
.text:00004680                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00004687                 mov     [ebp+var_4], ecx
.text:0000468A                 mov     eax, [ebp+var_4]
.text:0000468D                 mov     eax, [eax]
.text:0000468F                 mov     esp, ebp
.text:00004691                 pop     ebp
.text:00004692                 retn
.text:00004692 ??BUString@@QBEPB_WXZ endp
.text:00004692
.text:00004692 ; ---------------------------------------------------------------------------
.text:00004693                 align 4
.text:00004693 _text           ends
.text:00004693
.text:00004694 ; ===========================================================================
.text:00004694
.text:00004694 ; Segment type: Pure code
.text:00004694 ; Segment permissions: Read/Execute
.text:00004694 _text           segment para public 'CODE' use32
.text:00004694                 assume cs:_text
.text:00004694                 ;org 4694h
.text:00004694 ; COMDAT (pick any)
.text:00004694                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004694
.text:00004694 ; =============== S U B R O U T I N E =======================================
.text:00004694
.text:00004694 ; Attributes: bp-based frame
.text:00004694
.text:00004694 ; bool __thiscall UString::IsEqualTo_NoCase(UString *this, const wchar_t *)
.text:00004694                 public ?IsEqualTo_NoCase@UString@@QBE_NPB_W@Z
.text:00004694 ?IsEqualTo_NoCase@UString@@QBE_NPB_W@Z proc near
.text:00004694                                         ; CODE XREF: ConvertToLongNames(UString const &,NWildcard::CCensorNode &)+136p
.text:00004694
.text:00004694 var_4           = dword ptr -4
.text:00004694 arg_0           = dword ptr  8
.text:00004694
.text:00004694                 push    ebp
.text:00004695                 mov     ebp, esp
.text:00004697                 push    ecx
.text:00004698                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000469F                 mov     [ebp+var_4], ecx
.text:000046A2                 mov     eax, [ebp+arg_0]
.text:000046A5                 push    eax             ; wchar_t *
.text:000046A6                 mov     ecx, [ebp+var_4]
.text:000046A9                 mov     edx, [ecx]
.text:000046AB                 push    edx             ; wchar_t *
.text:000046AC                 call    ?StringsAreEqualNoCase@@YG_NPB_W0@Z ; StringsAreEqualNoCase(wchar_t const *,wchar_t const *)
.text:000046B1                 add     esp, 4
.text:000046B4                 cmp     ebp, esp
.text:000046B6                 call    __RTC_CheckEsp
.text:000046BB                 mov     esp, ebp
.text:000046BD                 pop     ebp
.text:000046BE                 retn    4
.text:000046BE ?IsEqualTo_NoCase@UString@@QBE_NPB_W@Z endp
.text:000046BE
.text:000046BE ; ---------------------------------------------------------------------------
.text:000046C1                 align 4
.text:000046C1 _text           ends
.text:000046C1
.text:000046C4 ; ===========================================================================
.text:000046C4
.text:000046C4 ; Segment type: Pure code
.text:000046C4 ; Segment permissions: Read/Execute
.text:000046C4 _text           segment para public 'CODE' use32
.text:000046C4                 assume cs:_text
.text:000046C4                 ;org 46C4h
.text:000046C4 ; COMDAT (pick any)
.text:000046C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000046C4
.text:000046C4 ; =============== S U B R O U T I N E =======================================
.text:000046C4
.text:000046C4 ; Attributes: bp-based frame
.text:000046C4
.text:000046C4 ; _DWORD __thiscall NWindows::NFile::NFind::CFileInfo::CFileInfo(NWindows::NFile::NFind::CFileInfo *__hidden this)
.text:000046C4                 public ??0CFileInfo@NFind@NFile@NWindows@@QAE@XZ
.text:000046C4 ??0CFileInfo@NFind@NFile@NWindows@@QAE@XZ proc near
.text:000046C4                                         ; CODE XREF: ConvertToLongName(UString const &,UString &)+5Cp
.text:000046C4
.text:000046C4 var_4           = dword ptr -4
.text:000046C4
.text:000046C4                 push    ebp
.text:000046C5                 mov     ebp, esp
.text:000046C7                 push    ecx
.text:000046C8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000046CF                 mov     [ebp+var_4], ecx
.text:000046D2                 mov     ecx, [ebp+var_4] ; this
.text:000046D5                 call    ??0CFileInfoBase@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfoBase::CFileInfoBase(void)
.text:000046DA                 mov     ecx, [ebp+var_4]
.text:000046DD                 add     ecx, 28h ; '('
.text:000046E0                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:000046E5                 mov     eax, [ebp+var_4]
.text:000046E8                 add     esp, 4
.text:000046EB                 cmp     ebp, esp
.text:000046ED                 call    __RTC_CheckEsp
.text:000046F2                 mov     esp, ebp
.text:000046F4                 pop     ebp
.text:000046F5                 retn
.text:000046F5 ??0CFileInfo@NFind@NFile@NWindows@@QAE@XZ endp
.text:000046F5
.text:000046F5 ; ---------------------------------------------------------------------------
.text:000046F6                 align 4
.text:000046F6 _text           ends
.text:000046F6
.text:000046F8 ; ===========================================================================
.text:000046F8
.text:000046F8 ; Segment type: Pure code
.text:000046F8 ; Segment permissions: Read/Execute
.text:000046F8 _text           segment para public 'CODE' use32
.text:000046F8                 assume cs:_text
.text:000046F8                 ;org 46F8h
.text:000046F8 ; COMDAT (pick any)
.text:000046F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000046F8
.text:000046F8 ; =============== S U B R O U T I N E =======================================
.text:000046F8
.text:000046F8 ; Attributes: bp-based frame
.text:000046F8
.text:000046F8 ; _DWORD __thiscall NWindows::NFile::NFind::CFileInfoBase::CFileInfoBase(NWindows::NFile::NFind::CFileInfoBase *__hidden this)
.text:000046F8                 public ??0CFileInfoBase@NFind@NFile@NWindows@@QAE@XZ
.text:000046F8 ??0CFileInfoBase@NFind@NFile@NWindows@@QAE@XZ proc near
.text:000046F8                                         ; CODE XREF: NWindows::NFile::NFind::CFileInfo::CFileInfo(void)+11p
.text:000046F8
.text:000046F8 var_4           = dword ptr -4
.text:000046F8
.text:000046F8                 push    ebp
.text:000046F9                 mov     ebp, esp
.text:000046FB                 push    ecx
.text:000046FC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00004703                 mov     [ebp+var_4], ecx
.text:00004706                 mov     ecx, [ebp+var_4] ; this
.text:00004709                 call    ?ClearBase@CFileInfoBase@NFind@NFile@NWindows@@QAEXXZ ; NWindows::NFile::NFind::CFileInfoBase::ClearBase(void)
.text:0000470E                 mov     eax, [ebp+var_4]
.text:00004711                 add     esp, 4
.text:00004714                 cmp     ebp, esp
.text:00004716                 call    __RTC_CheckEsp
.text:0000471B                 mov     esp, ebp
.text:0000471D                 pop     ebp
.text:0000471E                 retn
.text:0000471E ??0CFileInfoBase@NFind@NFile@NWindows@@QAE@XZ endp
.text:0000471E
.text:0000471E ; ---------------------------------------------------------------------------
.text:0000471F                 align 10h
.text:0000471F _text           ends
.text:0000471F
.text:00004720 ; ===========================================================================
.text:00004720
.text:00004720 ; Segment type: Pure code
.text:00004720 ; Segment permissions: Read/Execute
.text:00004720 _text           segment para public 'CODE' use32
.text:00004720                 assume cs:_text
.text:00004720                 ;org 4720h
.text:00004720 ; COMDAT (pick any)
.text:00004720                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004720
.text:00004720 ; =============== S U B R O U T I N E =======================================
.text:00004720
.text:00004720 ; Attributes: bp-based frame
.text:00004720
.text:00004720 ; _DWORD __thiscall NWindows::NFile::NFind::CFileInfo::~CFileInfo(NWindows::NFile::NFind::CFileInfo *__hidden this)
.text:00004720                 public ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ
.text:00004720 ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ proc near
.text:00004720                                         ; CODE XREF: ConvertToLongName(UString const &,UString &)+A8p
.text:00004720                                         ; ConvertToLongName(UString const &,UString &)+E9p ...
.text:00004720
.text:00004720 var_4           = dword ptr -4
.text:00004720
.text:00004720                 push    ebp
.text:00004721                 mov     ebp, esp
.text:00004723                 push    ecx
.text:00004724                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000472B                 mov     [ebp+var_4], ecx
.text:0000472E                 mov     ecx, [ebp+var_4]
.text:00004731                 add     ecx, 28h ; '('  ; this
.text:00004734                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00004739                 add     esp, 4
.text:0000473C                 cmp     ebp, esp
.text:0000473E                 call    __RTC_CheckEsp
.text:00004743                 mov     esp, ebp
.text:00004745                 pop     ebp
.text:00004746                 retn
.text:00004746 ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ endp
.text:00004746
.text:00004746 ; ---------------------------------------------------------------------------
.text:00004747                 align 4
.text:00004747 _text           ends
.text:00004747
.text:00004748 ; ===========================================================================
.text:00004748
.text:00004748 ; Segment type: Pure code
.text:00004748 ; Segment permissions: Read/Execute
.text:00004748 _text           segment para public 'CODE' use32
.text:00004748                 assume cs:_text
.text:00004748                 ;org 4748h
.text:00004748 ; COMDAT (pick any)
.text:00004748                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004748
.text:00004748 ; =============== S U B R O U T I N E =======================================
.text:00004748
.text:00004748 ; Attributes: bp-based frame
.text:00004748
.text:00004748 ; bool __thiscall NWildcard::CItem::IsDriveItem(NWildcard::CItem *__hidden this)
.text:00004748                 public ?IsDriveItem@CItem@NWildcard@@QBE_NXZ
.text:00004748 ?IsDriveItem@CItem@NWildcard@@QBE_NXZ proc near
.text:00004748                                         ; CODE XREF: ConvertToLongNames(UString const &,CObjectVector<NWildcard::CItem> &)+6Ep
.text:00004748
.text:00004748 var_8           = dword ptr -8
.text:00004748 var_4           = dword ptr -4
.text:00004748
.text:00004748                 push    ebp
.text:00004749                 mov     ebp, esp
.text:0000474B                 sub     esp, 8
.text:0000474E                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00004755                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000475C                 mov     [ebp+var_4], ecx
.text:0000475F                 mov     ecx, [ebp+var_4]
.text:00004762                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:00004767                 cmp     eax, 1
.text:0000476A                 jnz     short loc_47A9
.text:0000476C                 mov     eax, [ebp+var_4]
.text:0000476F                 movzx   ecx, byte ptr [eax+0Dh]
.text:00004773                 test    ecx, ecx
.text:00004775                 jnz     short loc_47A9
.text:00004777                 mov     edx, [ebp+var_4]
.text:0000477A                 movzx   eax, byte ptr [edx+0Eh]
.text:0000477E                 test    eax, eax
.text:00004780                 jz      short loc_47A9
.text:00004782                 push    0
.text:00004784                 mov     ecx, [ebp+var_4]
.text:00004787                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:0000478C                 mov     ecx, eax
.text:0000478E                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00004793                 push    eax             ; this
.text:00004794                 call    ?IsDriveColonName@NWildcard@@YG_NPB_W@Z ; NWildcard::IsDriveColonName(wchar_t const *)
.text:00004799                 movzx   ecx, al
.text:0000479C                 test    ecx, ecx
.text:0000479E                 jz      short loc_47A9
.text:000047A0                 mov     [ebp+var_8], 1
.text:000047A7                 jmp     short loc_47B0
.text:000047A9 ; ---------------------------------------------------------------------------
.text:000047A9
.text:000047A9 loc_47A9:                               ; CODE XREF: NWildcard::CItem::IsDriveItem(void)+22j
.text:000047A9                                         ; NWildcard::CItem::IsDriveItem(void)+2Dj ...
.text:000047A9                 mov     [ebp+var_8], 0
.text:000047B0
.text:000047B0 loc_47B0:                               ; CODE XREF: NWildcard::CItem::IsDriveItem(void)+5Fj
.text:000047B0                 mov     al, byte ptr [ebp+var_8]
.text:000047B3                 add     esp, 8
.text:000047B6                 cmp     ebp, esp
.text:000047B8                 call    __RTC_CheckEsp
.text:000047BD                 mov     esp, ebp
.text:000047BF                 pop     ebp
.text:000047C0                 retn
.text:000047C0 ?IsDriveItem@CItem@NWildcard@@QBE_NXZ endp ; sp-analysis failed
.text:000047C0
.text:000047C0 ; ---------------------------------------------------------------------------
.text:000047C1                 align 4
.text:000047C1 _text           ends
.text:000047C1
.xdata$x:000047C4 ; ===========================================================================
.xdata$x:000047C4
.xdata$x:000047C4 ; Segment type: Pure data
.xdata$x:000047C4 ; Segment permissions: Read
.xdata$x:000047C4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000047C4                 assume cs:_xdata$x
.xdata$x:000047C4                 ;org 47C4h
.xdata$x:000047C4 ; COMDAT (pick any)
.xdata$x:000047C4                 public __TI2?AUCArcCmdLineException@@
.xdata$x:000047C4 __TI2?AUCArcCmdLineException@@ db    0  ; DATA XREF: CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+73o
.xdata$x:000047C4                                         ; CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+30Bo ...
.xdata$x:000047C5                 db    0
.xdata$x:000047C6                 db    0
.xdata$x:000047C7                 db    0
.xdata$x:000047C8                 dd offset ??1CArcCmdLineException@@QAE@XZ ; CArcCmdLineException::~CArcCmdLineException(void)
.xdata$x:000047CC                 align 10h
.xdata$x:000047D0                 dd offset __CTA2?AUCArcCmdLineException@@
.xdata$x:000047D0 _xdata$x        ends
.xdata$x:000047D0
.xdata$x:000047D4 ; ===========================================================================
.xdata$x:000047D4
.xdata$x:000047D4 ; Segment type: Pure data
.xdata$x:000047D4 ; Segment permissions: Read
.xdata$x:000047D4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000047D4                 assume cs:_xdata$x
.xdata$x:000047D4                 ;org 47D4h
.xdata$x:000047D4 ; COMDAT (pick any)
.xdata$x:000047D4                 public __CTA2?AUCArcCmdLineException@@
.xdata$x:000047D4 __CTA2?AUCArcCmdLineException@@ db    2 ; DATA XREF: .xdata$x:000047D0o
.xdata$x:000047D5                 db    0
.xdata$x:000047D6                 db    0
.xdata$x:000047D7                 db    0
.xdata$x:000047D8                 dd offset __CT??_R0?AUCArcCmdLineException@@@8??0CArcCmdLineException@@QAE@ABU0@@Z12
.xdata$x:000047DC                 dd offset __CT??_R0?AVUString@@@8??0UString@@QAE@ABV0@@Z12
.xdata$x:000047DC _xdata$x        ends
.xdata$x:000047DC
.xdata$x:000047E0 ; ===========================================================================
.xdata$x:000047E0
.xdata$x:000047E0 ; Segment type: Pure data
.xdata$x:000047E0 ; Segment permissions: Read
.xdata$x:000047E0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000047E0                 assume cs:_xdata$x
.xdata$x:000047E0                 ;org 47E0h
.xdata$x:000047E0 ; COMDAT (pick any)
.xdata$x:000047E0                 public __CT??_R0?AUCArcCmdLineException@@@8??0CArcCmdLineException@@QAE@ABU0@@Z12
.xdata$x:000047E0 __CT??_R0?AUCArcCmdLineException@@@8??0CArcCmdLineException@@QAE@ABU0@@Z12 db    0
.xdata$x:000047E0                                         ; DATA XREF: .xdata$x:000047D8o
.xdata$x:000047E1                 db    0
.xdata$x:000047E2                 db    0
.xdata$x:000047E3                 db    0
.xdata$x:000047E4                 dd offset ??_R0?AUCArcCmdLineException@@@8 ; CArcCmdLineException `RTTI Type Descriptor'
.xdata$x:000047E8                 db    0
.xdata$x:000047E9                 db    0
.xdata$x:000047EA                 db    0
.xdata$x:000047EB                 db    0
.xdata$x:000047EC                 db 0FFh
.xdata$x:000047ED                 db 0FFh
.xdata$x:000047EE                 db 0FFh
.xdata$x:000047EF                 db 0FFh
.xdata$x:000047F0                 db    0
.xdata$x:000047F1                 db    0
.xdata$x:000047F2                 db    0
.xdata$x:000047F3                 db    0
.xdata$x:000047F4                 db  0Ch
.xdata$x:000047F5                 db    0
.xdata$x:000047F6                 db    0
.xdata$x:000047F7                 db    0
.xdata$x:000047F8                 dd offset ??0CArcCmdLineException@@QAE@ABU0@@Z ; CArcCmdLineException::CArcCmdLineException(CArcCmdLineException const &)
.xdata$x:000047F8 _xdata$x        ends
.xdata$x:000047F8
.data:000047FC ; ===========================================================================
.data:000047FC
.data:000047FC ; Segment type: Pure data
.data:000047FC ; Segment permissions: Read/Write
.data:000047FC _data           segment dword public 'DATA' use32
.data:000047FC                 assume cs:_data
.data:000047FC                 ;org 47FCh
.data:000047FC ; COMDAT (pick any)
.data:000047FC                 public ??_R0?AUCArcCmdLineException@@@8
.data:000047FC ; struct CArcCmdLineException `RTTI Type Descriptor'
.data:000047FC ??_R0?AUCArcCmdLineException@@@8 dd offset ??_7type_info@@6B@
.data:000047FC                                         ; DATA XREF: .xdata$x:000047E4o
.data:000047FC                                         ; const type_info::`vftable'
.data:00004800                 db    0
.data:00004801                 db    0
.data:00004802                 db    0
.data:00004803                 db    0
.data:00004804                 db  2Eh ; .
.data:00004805                 db  3Fh ; ?
.data:00004806                 db  41h ; A
.data:00004807                 db  55h ; U
.data:00004808                 db  43h ; C
.data:00004809                 db  41h ; A
.data:0000480A                 db  72h ; r
.data:0000480B                 db  63h ; c
.data:0000480C                 db  43h ; C
.data:0000480D                 db  6Dh ; m
.data:0000480E                 db  64h ; d
.data:0000480F                 db  4Ch ; L
.data:00004810                 db  69h ; i
.data:00004811                 db  6Eh ; n
.data:00004812                 db  65h ; e
.data:00004813                 db  45h ; E
.data:00004814                 db  78h ; x
.data:00004815                 db  63h ; c
.data:00004816                 db  65h ; e
.data:00004817                 db  70h ; p
.data:00004818                 db  74h ; t
.data:00004819                 db  69h ; i
.data:0000481A                 db  6Fh ; o
.data:0000481B                 db  6Eh ; n
.data:0000481C                 db  40h ; @
.data:0000481D                 db  40h ; @
.data:0000481E                 db    0
.data:0000481F                 align 10h
.data:0000481F _data           ends
.data:0000481F
.xdata$x:00004820 ; ===========================================================================
.xdata$x:00004820
.xdata$x:00004820 ; Segment type: Pure data
.xdata$x:00004820 ; Segment permissions: Read
.xdata$x:00004820 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004820                 assume cs:_xdata$x
.xdata$x:00004820                 ;org 4820h
.xdata$x:00004820 ; COMDAT (pick any)
.xdata$x:00004820                 public __CT??_R0?AVUString@@@8??0UString@@QAE@ABV0@@Z12
.xdata$x:00004820 __CT??_R0?AVUString@@@8??0UString@@QAE@ABV0@@Z12 db    0
.xdata$x:00004820                                         ; DATA XREF: .xdata$x:000047DCo
.xdata$x:00004821                 db    0
.xdata$x:00004822                 db    0
.xdata$x:00004823                 db    0
.xdata$x:00004824                 dd offset ??_R0?AVUString@@@8 ; UString `RTTI Type Descriptor'
.xdata$x:00004828                 db    0
.xdata$x:00004829                 db    0
.xdata$x:0000482A                 db    0
.xdata$x:0000482B                 db    0
.xdata$x:0000482C                 db 0FFh
.xdata$x:0000482D                 db 0FFh
.xdata$x:0000482E                 db 0FFh
.xdata$x:0000482F                 db 0FFh
.xdata$x:00004830                 db    0
.xdata$x:00004831                 db    0
.xdata$x:00004832                 db    0
.xdata$x:00004833                 db    0
.xdata$x:00004834                 db  0Ch
.xdata$x:00004835                 db    0
.xdata$x:00004836                 db    0
.xdata$x:00004837                 db    0
.xdata$x:00004838                 dd offset ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.xdata$x:00004838 _xdata$x        ends
.xdata$x:00004838
.data:0000483C ; ===========================================================================
.data:0000483C
.data:0000483C ; Segment type: Pure data
.data:0000483C ; Segment permissions: Read/Write
.data:0000483C _data           segment dword public 'DATA' use32
.data:0000483C                 assume cs:_data
.data:0000483C                 ;org 483Ch
.data:0000483C ; COMDAT (pick any)
.data:0000483C                 public ??_R0?AVUString@@@8
.data:0000483C ; class UString `RTTI Type Descriptor'
.data:0000483C ??_R0?AVUString@@@8 dd offset ??_7type_info@@6B@
.data:0000483C                                         ; DATA XREF: .xdata$x:00004824o
.data:0000483C                                         ; const type_info::`vftable'
.data:00004840                 db    0
.data:00004841                 db    0
.data:00004842                 db    0
.data:00004843                 db    0
.data:00004844                 db  2Eh ; .
.data:00004845                 db  3Fh ; ?
.data:00004846                 db  41h ; A
.data:00004847                 db  56h ; V
.data:00004848                 db  55h ; U
.data:00004849                 db  53h ; S
.data:0000484A                 db  74h ; t
.data:0000484B                 db  72h ; r
.data:0000484C                 db  69h ; i
.data:0000484D                 db  6Eh ; n
.data:0000484E                 db  67h ; g
.data:0000484F                 db  40h ; @
.data:00004850                 db  40h ; @
.data:00004851                 db    0
.data:00004852                 align 4
.data:00004852 _data           ends
.data:00004852
.text:00004854 ; ===========================================================================
.text:00004854
.text:00004854 ; Segment type: Pure code
.text:00004854 ; Segment permissions: Read/Execute
.text:00004854 _text           segment para public 'CODE' use32
.text:00004854                 assume cs:_text
.text:00004854                 ;org 4854h
.text:00004854 ; COMDAT (pick any)
.text:00004854                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004854
.text:00004854 ; =============== S U B R O U T I N E =======================================
.text:00004854
.text:00004854 ; Attributes: bp-based frame
.text:00004854
.text:00004854 ; bool __thiscall AString::IsEmpty(AString *__hidden this)
.text:00004854                 public ?IsEmpty@AString@@QBE_NXZ
.text:00004854 ?IsEmpty@AString@@QBE_NXZ proc near     ; CODE XREF: CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+400p
.text:00004854                                         ; CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+436p
.text:00004854
.text:00004854 var_4           = dword ptr -4
.text:00004854
.text:00004854                 push    ebp
.text:00004855                 mov     ebp, esp
.text:00004857                 push    ecx
.text:00004858                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000485F                 mov     [ebp+var_4], ecx
.text:00004862                 mov     eax, [ebp+var_4]
.text:00004865                 xor     ecx, ecx
.text:00004867                 cmp     dword ptr [eax+4], 0
.text:0000486B                 setz    cl
.text:0000486E                 mov     al, cl
.text:00004870                 mov     esp, ebp
.text:00004872                 pop     ebp
.text:00004873                 retn
.text:00004873 ?IsEmpty@AString@@QBE_NXZ endp
.text:00004873
.text:00004873 _text           ends
.text:00004873
.text:00004874 ; ===========================================================================
.text:00004874
.text:00004874 ; Segment type: Pure code
.text:00004874 ; Segment permissions: Read/Execute
.text:00004874 _text           segment para public 'CODE' use32
.text:00004874                 assume cs:_text
.text:00004874                 ;org 4874h
.text:00004874 ; COMDAT (pick any)
.text:00004874                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004874
.text:00004874 ; =============== S U B R O U T I N E =======================================
.text:00004874
.text:00004874 ; Attributes: bp-based frame
.text:00004874
.text:00004874 ; void __thiscall AString::Empty(AString *__hidden this)
.text:00004874                 public ?Empty@AString@@QAEXXZ
.text:00004874 ?Empty@AString@@QAEXXZ proc near        ; CODE XREF: CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+42Ep
.text:00004874
.text:00004874 var_4           = dword ptr -4
.text:00004874
.text:00004874                 push    ebp
.text:00004875                 mov     ebp, esp
.text:00004877                 push    ecx
.text:00004878                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000487F                 mov     [ebp+var_4], ecx
.text:00004882                 mov     eax, [ebp+var_4]
.text:00004885                 mov     dword ptr [eax+4], 0
.text:0000488C                 mov     ecx, [ebp+var_4]
.text:0000488F                 mov     edx, [ecx]
.text:00004891                 mov     byte ptr [edx], 0
.text:00004894                 mov     esp, ebp
.text:00004896                 pop     ebp
.text:00004897                 retn
.text:00004897 ?Empty@AString@@QAEXXZ endp
.text:00004897
.text:00004897 _text           ends
.text:00004897
.text:00004898 ; ===========================================================================
.text:00004898
.text:00004898 ; Segment type: Pure code
.text:00004898 ; Segment permissions: Read/Execute
.text:00004898 _text           segment para public 'CODE' use32
.text:00004898                 assume cs:_text
.text:00004898                 ;org 4898h
.text:00004898 ; COMDAT (pick any)
.text:00004898                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004898
.text:00004898 ; =============== S U B R O U T I N E =======================================
.text:00004898
.text:00004898 ; Attributes: bp-based frame
.text:00004898
.text:00004898 ; public: __thiscall AString::operator char const *(void)const
.text:00004898                 public ??BAString@@QBEPBDXZ
.text:00004898 ??BAString@@QBEPBDXZ proc near          ; CODE XREF: CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+65p
.text:00004898                                         ; CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+413p ...
.text:00004898
.text:00004898 var_4           = dword ptr -4
.text:00004898
.text:00004898                 push    ebp
.text:00004899                 mov     ebp, esp
.text:0000489B                 push    ecx
.text:0000489C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000048A3                 mov     [ebp+var_4], ecx
.text:000048A6                 mov     eax, [ebp+var_4]
.text:000048A9                 mov     eax, [eax]
.text:000048AB                 mov     esp, ebp
.text:000048AD                 pop     ebp
.text:000048AE                 retn
.text:000048AE ??BAString@@QBEPBDXZ endp
.text:000048AE
.text:000048AE ; ---------------------------------------------------------------------------
.text:000048AF                 align 10h
.text:000048AF _text           ends
.text:000048AF
.text:000048B0 ; ===========================================================================
.text:000048B0
.text:000048B0 ; Segment type: Pure code
.text:000048B0 ; Segment permissions: Read/Execute
.text:000048B0 _text           segment para public 'CODE' use32
.text:000048B0                 assume cs:_text
.text:000048B0                 ;org 48B0h
.text:000048B0 ; COMDAT (pick any)
.text:000048B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000048B0
.text:000048B0 ; =============== S U B R O U T I N E =======================================
.text:000048B0
.text:000048B0 ; Attributes: bp-based frame
.text:000048B0
.text:000048B0 ; public: struct NCommandLineParser::CSwitchResult const & __thiscall NCommandLineParser::CParser::operator[](unsigned int)const
.text:000048B0                 public ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z
.text:000048B0 ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z proc near
.text:000048B0                                         ; CODE XREF: CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+14Fp
.text:000048B0                                         ; CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+160p ...
.text:000048B0
.text:000048B0 var_4           = dword ptr -4
.text:000048B0 arg_0           = dword ptr  8
.text:000048B0
.text:000048B0                 push    ebp
.text:000048B1                 mov     ebp, esp
.text:000048B3                 push    ecx
.text:000048B4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000048BB                 mov     [ebp+var_4], ecx
.text:000048BE                 mov     eax, [ebp+arg_0]
.text:000048C1                 imul    eax, 14h
.text:000048C4                 mov     ecx, [ebp+var_4]
.text:000048C7                 add     eax, [ecx+4]
.text:000048CA                 mov     esp, ebp
.text:000048CC                 pop     ebp
.text:000048CD                 retn    4
.text:000048CD ??ACParser@NCommandLineParser@@QBEABUCSwitchResult@1@I@Z endp
.text:000048CD
.text:000048CD _text           ends
.text:000048CD
.text:000048D0 ; ===========================================================================
.text:000048D0
.text:000048D0 ; Segment type: Pure code
.text:000048D0 ; Segment permissions: Read/Execute
.text:000048D0 _text           segment para public 'CODE' use32
.text:000048D0                 assume cs:_text
.text:000048D0                 ;org 48D0h
.text:000048D0 ; COMDAT (pick any)
.text:000048D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000048D0
.text:000048D0 ; =============== S U B R O U T I N E =======================================
.text:000048D0
.text:000048D0 ; Attributes: bp-based frame
.text:000048D0
.text:000048D0 ; _DWORD __thiscall CArcCmdLineException::~CArcCmdLineException(CArcCmdLineException *__hidden this)
.text:000048D0                 public ??1CArcCmdLineException@@QAE@XZ
.text:000048D0 ??1CArcCmdLineException@@QAE@XZ proc near ; DATA XREF: .xdata$x:000047C8o
.text:000048D0
.text:000048D0 var_4           = dword ptr -4
.text:000048D0
.text:000048D0                 push    ebp
.text:000048D1                 mov     ebp, esp
.text:000048D3                 push    ecx
.text:000048D4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000048DB                 mov     [ebp+var_4], ecx
.text:000048DE                 mov     ecx, [ebp+var_4] ; this
.text:000048E1                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000048E6                 add     esp, 4
.text:000048E9                 cmp     ebp, esp
.text:000048EB                 call    __RTC_CheckEsp
.text:000048F0                 mov     esp, ebp
.text:000048F2                 pop     ebp
.text:000048F3                 retn
.text:000048F3 ??1CArcCmdLineException@@QAE@XZ endp
.text:000048F3
.text:000048F3 _text           ends
.text:000048F3
.text:000048F4 ; ===========================================================================
.text:000048F4
.text:000048F4 ; Segment type: Pure code
.text:000048F4 ; Segment permissions: Read/Execute
.text:000048F4 _text           segment para public 'CODE' use32
.text:000048F4                 assume cs:_text
.text:000048F4                 ;org 48F4h
.text:000048F4 ; COMDAT (pick any)
.text:000048F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000048F4
.text:000048F4 ; =============== S U B R O U T I N E =======================================
.text:000048F4
.text:000048F4 ; Attributes: bp-based frame
.text:000048F4
.text:000048F4 ; public: __thiscall CArcCmdLineException::CArcCmdLineException(struct CArcCmdLineException const &)
.text:000048F4                 public ??0CArcCmdLineException@@QAE@ABU0@@Z
.text:000048F4 ??0CArcCmdLineException@@QAE@ABU0@@Z proc near
.text:000048F4                                         ; DATA XREF: .xdata$x:000047F8o
.text:000048F4
.text:000048F4 var_4           = dword ptr -4
.text:000048F4 arg_0           = dword ptr  8
.text:000048F4
.text:000048F4                 push    ebp
.text:000048F5                 mov     ebp, esp
.text:000048F7                 push    ecx
.text:000048F8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000048FF                 mov     [ebp+var_4], ecx
.text:00004902                 mov     eax, [ebp+arg_0]
.text:00004905                 push    eax
.text:00004906                 mov     ecx, [ebp+var_4]
.text:00004909                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:0000490E                 mov     eax, [ebp+var_4]
.text:00004911                 add     esp, 4
.text:00004914                 cmp     ebp, esp
.text:00004916                 call    __RTC_CheckEsp
.text:0000491B                 mov     esp, ebp
.text:0000491D                 pop     ebp
.text:0000491E                 retn    4
.text:0000491E ??0CArcCmdLineException@@QAE@ABU0@@Z endp
.text:0000491E
.text:0000491E ; ---------------------------------------------------------------------------
.text:00004921                 align 4
.text:00004921 _text           ends
.text:00004921
.text:00004924 ; ===========================================================================
.text:00004924
.text:00004924 ; Segment type: Pure code
.text:00004924 ; Segment permissions: Read/Execute
.text:00004924 _text           segment para public 'CODE' use32
.text:00004924                 assume cs:_text
.text:00004924                 ;org 4924h
.text:00004924 ; COMDAT (pick any)
.text:00004924                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004924
.text:00004924 ; =============== S U B R O U T I N E =======================================
.text:00004924
.text:00004924 ; Attributes: bp-based frame
.text:00004924
.text:00004924 ; bool __thiscall CDirItem::IsDir(CDirItem *__hidden this)
.text:00004924                 public ?IsDir@CDirItem@@QBE_NXZ
.text:00004924 ?IsDir@CDirItem@@QBE_NXZ proc near      ; CODE XREF: EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *)+124p
.text:00004924
.text:00004924 var_4           = dword ptr -4
.text:00004924
.text:00004924                 push    ebp
.text:00004925                 mov     ebp, esp
.text:00004927                 push    ecx
.text:00004928                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000492F                 mov     [ebp+var_4], ecx
.text:00004932                 mov     eax, [ebp+var_4]
.text:00004935                 mov     eax, [eax+3Ch]
.text:00004938                 and     eax, 10h
.text:0000493B                 neg     eax
.text:0000493D                 sbb     eax, eax
.text:0000493F                 neg     eax
.text:00004941                 mov     esp, ebp
.text:00004943                 pop     ebp
.text:00004944                 retn
.text:00004944 ?IsDir@CDirItem@@QBE_NXZ endp
.text:00004944
.text:00004944 ; ---------------------------------------------------------------------------
.text:00004945                 align 4
.text:00004945 _text           ends
.text:00004945
.text:00004948 ; ===========================================================================
.text:00004948
.text:00004948 ; Segment type: Pure code
.text:00004948 ; Segment permissions: Read/Execute
.text:00004948 _text           segment para public 'CODE' use32
.text:00004948                 assume cs:_text
.text:00004948                 ;org 4948h
.text:00004948 ; COMDAT (pick any)
.text:00004948                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004948
.text:00004948 ; =============== S U B R O U T I N E =======================================
.text:00004948
.text:00004948 ; Attributes: bp-based frame
.text:00004948
.text:00004948 ; _DWORD __thiscall CDirItems::~CDirItems(CDirItems *__hidden this)
.text:00004948                 public ??1CDirItems@@QAE@XZ
.text:00004948 ??1CDirItems@@QAE@XZ proc near          ; CODE XREF: EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *)+B9p
.text:00004948                                         ; EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *)+18Cp ...
.text:00004948
.text:00004948 var_10          = dword ptr -10h
.text:00004948 var_C           = dword ptr -0Ch
.text:00004948 var_4           = dword ptr -4
.text:00004948
.text:00004948                 push    ebp
.text:00004949                 mov     ebp, esp
.text:0000494B                 push    0FFFFFFFFh
.text:0000494D                 push    offset __ehhandler$??1CDirItems@@QAE@XZ
.text:00004952                 mov     eax, large fs:0
.text:00004958                 push    eax
.text:00004959                 push    ecx
.text:0000495A                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00004961                 mov     eax, dword ptr ds:___security_cookie
.text:00004966                 xor     eax, ebp
.text:00004968                 push    eax
.text:00004969                 lea     eax, [ebp+var_C]
.text:0000496C                 mov     large fs:0, eax
.text:00004972                 mov     [ebp+var_10], ecx
.text:00004975                 mov     [ebp+var_4], 4
.text:0000497C                 mov     ecx, [ebp+var_10]
.text:0000497F                 add     ecx, 8Ch ; 'Ã®'
.text:00004985                 call    ??1?$CBuffer@E@@QAE@XZ ; CBuffer<uchar>::~CBuffer<uchar>(void)
.text:0000498A                 mov     byte ptr [ebp+var_4], 3
.text:0000498E                 mov     ecx, [ebp+var_10]
.text:00004991                 add     ecx, 68h ; 'h'  ; this
.text:00004994                 call    ??1CUniqBlocks@@QAE@XZ ; CUniqBlocks::~CUniqBlocks(void)
.text:00004999                 mov     byte ptr [ebp+var_4], 2
.text:0000499D                 mov     ecx, [ebp+var_10]
.text:000049A0                 add     ecx, 24h ; '$'
.text:000049A3                 call    ??1?$CObjectVector@UCDirItem@@@@QAE@XZ ; CObjectVector<CDirItem>::~CObjectVector<CDirItem>(void)
.text:000049A8                 mov     byte ptr [ebp+var_4], 1
.text:000049AC                 mov     ecx, [ebp+var_10]
.text:000049AF                 add     ecx, 18h
.text:000049B2                 call    ??1?$CRecordVector@H@@QAE@XZ ; CRecordVector<int>::~CRecordVector<int>(void)
.text:000049B7                 mov     byte ptr [ebp+var_4], 0
.text:000049BB                 mov     ecx, [ebp+var_10]
.text:000049BE                 add     ecx, 0Ch
.text:000049C1                 call    ??1?$CRecordVector@H@@QAE@XZ ; CRecordVector<int>::~CRecordVector<int>(void)
.text:000049C6                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000049CD                 mov     ecx, [ebp+var_10]
.text:000049D0                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:000049D5                 mov     ecx, [ebp+var_C]
.text:000049D8                 mov     large fs:0, ecx
.text:000049DF                 pop     ecx
.text:000049E0                 add     esp, 10h
.text:000049E3                 cmp     ebp, esp
.text:000049E5                 call    __RTC_CheckEsp
.text:000049EA                 mov     esp, ebp
.text:000049EC                 pop     ebp
.text:000049ED                 retn
.text:000049ED ??1CDirItems@@QAE@XZ endp
.text:000049ED
.text:000049ED ; ---------------------------------------------------------------------------
.text:000049EE                 align 10h
.text:000049EE _text           ends
.text:000049EE
.text$x:000049F0 ; ===========================================================================
.text$x:000049F0
.text$x:000049F0 ; Segment type: Pure code
.text$x:000049F0 ; Segment permissions: Read/Execute
.text$x:000049F0 _text$x         segment para public 'CODE' use32
.text$x:000049F0                 assume cs:_text$x
.text$x:000049F0                 ;org 49F0h
.text$x:000049F0 ; COMDAT (pick associative to section at 4948)
.text$x:000049F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000049F0
.text$x:000049F0 ; =============== S U B R O U T I N E =======================================
.text$x:000049F0
.text$x:000049F0
.text$x:000049F0 __unwindfunclet$??1CDirItems@@QAE@XZ$0 proc near
.text$x:000049F0                                         ; DATA XREF: .xdata$x:00004A68o
.text$x:000049F0                 mov     ecx, [ebp-10h]
.text$x:000049F3                 jmp     ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text$x:000049F3 __unwindfunclet$??1CDirItems@@QAE@XZ$0 endp
.text$x:000049F3
.text$x:000049F8
.text$x:000049F8 ; =============== S U B R O U T I N E =======================================
.text$x:000049F8
.text$x:000049F8
.text$x:000049F8 __unwindfunclet$??1CDirItems@@QAE@XZ$1 proc near
.text$x:000049F8                                         ; DATA XREF: .xdata$x:00004A70o
.text$x:000049F8                 mov     ecx, [ebp-10h]
.text$x:000049FB                 add     ecx, 0Ch
.text$x:000049FE                 jmp     ??1?$CRecordVector@H@@QAE@XZ ; CRecordVector<int>::~CRecordVector<int>(void)
.text$x:000049FE __unwindfunclet$??1CDirItems@@QAE@XZ$1 endp
.text$x:000049FE
.text$x:00004A03
.text$x:00004A03 ; =============== S U B R O U T I N E =======================================
.text$x:00004A03
.text$x:00004A03
.text$x:00004A03 __unwindfunclet$??1CDirItems@@QAE@XZ$2 proc near
.text$x:00004A03                                         ; DATA XREF: .xdata$x:00004A78o
.text$x:00004A03                 mov     ecx, [ebp-10h]
.text$x:00004A06                 add     ecx, 18h
.text$x:00004A09                 jmp     ??1?$CRecordVector@H@@QAE@XZ ; CRecordVector<int>::~CRecordVector<int>(void)
.text$x:00004A09 __unwindfunclet$??1CDirItems@@QAE@XZ$2 endp
.text$x:00004A09
.text$x:00004A0E
.text$x:00004A0E ; =============== S U B R O U T I N E =======================================
.text$x:00004A0E
.text$x:00004A0E
.text$x:00004A0E __unwindfunclet$??1CDirItems@@QAE@XZ$3 proc near
.text$x:00004A0E                                         ; DATA XREF: .xdata$x:00004A80o
.text$x:00004A0E                 mov     ecx, [ebp-10h]
.text$x:00004A11                 add     ecx, 24h ; '$'
.text$x:00004A14                 jmp     ??1?$CObjectVector@UCDirItem@@@@QAE@XZ ; CObjectVector<CDirItem>::~CObjectVector<CDirItem>(void)
.text$x:00004A14 __unwindfunclet$??1CDirItems@@QAE@XZ$3 endp
.text$x:00004A14
.text$x:00004A19
.text$x:00004A19 ; =============== S U B R O U T I N E =======================================
.text$x:00004A19
.text$x:00004A19
.text$x:00004A19 __unwindfunclet$??1CDirItems@@QAE@XZ$4 proc near
.text$x:00004A19                                         ; DATA XREF: .xdata$x:00004A88o
.text$x:00004A19                 mov     ecx, [ebp-10h]
.text$x:00004A1C                 add     ecx, 68h ; 'h'  ; this
.text$x:00004A1F                 jmp     ??1CUniqBlocks@@QAE@XZ ; CUniqBlocks::~CUniqBlocks(void)
.text$x:00004A1F __unwindfunclet$??1CDirItems@@QAE@XZ$4 endp
.text$x:00004A1F
.text$x:00004A24
.text$x:00004A24 ; =============== S U B R O U T I N E =======================================
.text$x:00004A24
.text$x:00004A24
.text$x:00004A24 __ehhandler$??1CDirItems@@QAE@XZ proc near
.text$x:00004A24                                         ; DATA XREF: CDirItems::~CDirItems(void)+5o
.text$x:00004A24
.text$x:00004A24 arg_4           = dword ptr  8
.text$x:00004A24
.text$x:00004A24                 mov     edx, [esp+arg_4]
.text$x:00004A28                 lea     eax, [edx+0Ch]
.text$x:00004A2B                 mov     ecx, [edx-8]
.text$x:00004A2E                 xor     ecx, eax
.text$x:00004A30                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004A35                 mov     eax, offset __ehfuncinfo$??1CDirItems@@QAE@XZ
.text$x:00004A3A                 jmp     ___CxxFrameHandler3
.text$x:00004A3A __ehhandler$??1CDirItems@@QAE@XZ endp
.text$x:00004A3A
.text$x:00004A3A ; ---------------------------------------------------------------------------
.text$x:00004A3F                 align 10h
.text$x:00004A3F _text$x         ends
.text$x:00004A3F
.xdata$x:00004A40 ; ===========================================================================
.xdata$x:00004A40
.xdata$x:00004A40 ; Segment type: Pure data
.xdata$x:00004A40 ; Segment permissions: Read
.xdata$x:00004A40 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004A40                 assume cs:_xdata$x
.xdata$x:00004A40                 ;org 4A40h
.xdata$x:00004A40 ; COMDAT (pick associative to section at 4948)
.xdata$x:00004A40 __ehfuncinfo$??1CDirItems@@QAE@XZ db  22h ; "
.xdata$x:00004A40                                         ; DATA XREF: __ehhandler$??1CDirItems@@QAE@XZ+11o
.xdata$x:00004A41                 db    5
.xdata$x:00004A42                 db  93h ; Ã´
.xdata$x:00004A43                 db  19h
.xdata$x:00004A44                 db    5
.xdata$x:00004A45                 db    0
.xdata$x:00004A46                 db    0
.xdata$x:00004A47                 db    0
.xdata$x:00004A48                 dd offset __unwindtable$??1CDirItems@@QAE@XZ
.xdata$x:00004A4C                 align 20h
.xdata$x:00004A60                 db    1
.xdata$x:00004A61                 db    0
.xdata$x:00004A62                 db    0
.xdata$x:00004A63                 db    0
.xdata$x:00004A64 __unwindtable$??1CDirItems@@QAE@XZ db 0FFh ; DATA XREF: .xdata$x:00004A48o
.xdata$x:00004A65                 db 0FFh
.xdata$x:00004A66                 db 0FFh
.xdata$x:00004A67                 db 0FFh
.xdata$x:00004A68                 dd offset __unwindfunclet$??1CDirItems@@QAE@XZ$0
.xdata$x:00004A6C                 align 10h
.xdata$x:00004A70                 dd offset __unwindfunclet$??1CDirItems@@QAE@XZ$1
.xdata$x:00004A74                 db    1
.xdata$x:00004A75                 db    0
.xdata$x:00004A76                 db    0
.xdata$x:00004A77                 db    0
.xdata$x:00004A78                 dd offset __unwindfunclet$??1CDirItems@@QAE@XZ$2
.xdata$x:00004A7C                 db    2
.xdata$x:00004A7D                 db    0
.xdata$x:00004A7E                 db    0
.xdata$x:00004A7F                 db    0
.xdata$x:00004A80                 dd offset __unwindfunclet$??1CDirItems@@QAE@XZ$3
.xdata$x:00004A84                 db    3
.xdata$x:00004A85                 db    0
.xdata$x:00004A86                 db    0
.xdata$x:00004A87                 db    0
.xdata$x:00004A88                 dd offset __unwindfunclet$??1CDirItems@@QAE@XZ$4
.xdata$x:00004A88 _xdata$x        ends
.xdata$x:00004A88
.text:00004A8C ; ===========================================================================
.text:00004A8C
.text:00004A8C ; Segment type: Pure code
.text:00004A8C ; Segment permissions: Read/Execute
.text:00004A8C _text           segment para public 'CODE' use32
.text:00004A8C                 assume cs:_text
.text:00004A8C                 ;org 4A8Ch
.text:00004A8C ; COMDAT (pick any)
.text:00004A8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004A8C
.text:00004A8C ; =============== S U B R O U T I N E =======================================
.text:00004A8C
.text:00004A8C ; Attributes: bp-based frame
.text:00004A8C
.text:00004A8C ; _DWORD __thiscall CUniqBlocks::~CUniqBlocks(CUniqBlocks *__hidden this)
.text:00004A8C                 public ??1CUniqBlocks@@QAE@XZ
.text:00004A8C ??1CUniqBlocks@@QAE@XZ proc near        ; CODE XREF: CDirItems::~CDirItems(void)+4Cp
.text:00004A8C                                         ; __unwindfunclet$??1CDirItems@@QAE@XZ$4+6j
.text:00004A8C
.text:00004A8C var_10          = dword ptr -10h
.text:00004A8C var_C           = dword ptr -0Ch
.text:00004A8C var_4           = dword ptr -4
.text:00004A8C
.text:00004A8C                 push    ebp
.text:00004A8D                 mov     ebp, esp
.text:00004A8F                 push    0FFFFFFFFh
.text:00004A91                 push    offset __ehhandler$??1CUniqBlocks@@QAE@XZ
.text:00004A96                 mov     eax, large fs:0
.text:00004A9C                 push    eax
.text:00004A9D                 push    ecx
.text:00004A9E                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00004AA5                 mov     eax, dword ptr ds:___security_cookie
.text:00004AAA                 xor     eax, ebp
.text:00004AAC                 push    eax
.text:00004AAD                 lea     eax, [ebp+var_C]
.text:00004AB0                 mov     large fs:0, eax
.text:00004AB6                 mov     [ebp+var_10], ecx
.text:00004AB9                 mov     [ebp+var_4], 1
.text:00004AC0                 mov     ecx, [ebp+var_10]
.text:00004AC3                 add     ecx, 18h
.text:00004AC6                 call    ??1?$CRecordVector@I@@QAE@XZ ; CRecordVector<uint>::~CRecordVector<uint>(void)
.text:00004ACB                 mov     byte ptr [ebp+var_4], 0
.text:00004ACF                 mov     ecx, [ebp+var_10]
.text:00004AD2                 add     ecx, 0Ch
.text:00004AD5                 call    ??1?$CRecordVector@I@@QAE@XZ ; CRecordVector<uint>::~CRecordVector<uint>(void)
.text:00004ADA                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00004AE1                 mov     ecx, [ebp+var_10]
.text:00004AE4                 call    ??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ ; CObjectVector<CBuffer<uchar>>::~CObjectVector<CBuffer<uchar>>(void)
.text:00004AE9                 mov     ecx, [ebp+var_C]
.text:00004AEC                 mov     large fs:0, ecx
.text:00004AF3                 pop     ecx
.text:00004AF4                 add     esp, 10h
.text:00004AF7                 cmp     ebp, esp
.text:00004AF9                 call    __RTC_CheckEsp
.text:00004AFE                 mov     esp, ebp
.text:00004B00                 pop     ebp
.text:00004B01                 retn
.text:00004B01 ??1CUniqBlocks@@QAE@XZ endp
.text:00004B01
.text:00004B01 ; ---------------------------------------------------------------------------
.text:00004B02                 align 4
.text:00004B02 _text           ends
.text:00004B02
.text$x:00004B04 ; ===========================================================================
.text$x:00004B04
.text$x:00004B04 ; Segment type: Pure code
.text$x:00004B04 ; Segment permissions: Read/Execute
.text$x:00004B04 _text$x         segment para public 'CODE' use32
.text$x:00004B04                 assume cs:_text$x
.text$x:00004B04                 ;org 4B04h
.text$x:00004B04 ; COMDAT (pick associative to section at 4A8C)
.text$x:00004B04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004B04
.text$x:00004B04 ; =============== S U B R O U T I N E =======================================
.text$x:00004B04
.text$x:00004B04
.text$x:00004B04 __unwindfunclet$??1CUniqBlocks@@QAE@XZ$0 proc near
.text$x:00004B04                                         ; DATA XREF: .xdata$x:00004B38o
.text$x:00004B04                 mov     ecx, [ebp-10h]
.text$x:00004B07                 jmp     ??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ ; CObjectVector<CBuffer<uchar>>::~CObjectVector<CBuffer<uchar>>(void)
.text$x:00004B07 __unwindfunclet$??1CUniqBlocks@@QAE@XZ$0 endp
.text$x:00004B07
.text$x:00004B0C
.text$x:00004B0C ; =============== S U B R O U T I N E =======================================
.text$x:00004B0C
.text$x:00004B0C
.text$x:00004B0C __unwindfunclet$??1CUniqBlocks@@QAE@XZ$1 proc near
.text$x:00004B0C                                         ; DATA XREF: .xdata$x:00004B40o
.text$x:00004B0C                 mov     ecx, [ebp-10h]
.text$x:00004B0F                 add     ecx, 0Ch
.text$x:00004B12                 jmp     ??1?$CRecordVector@I@@QAE@XZ ; CRecordVector<uint>::~CRecordVector<uint>(void)
.text$x:00004B12 __unwindfunclet$??1CUniqBlocks@@QAE@XZ$1 endp
.text$x:00004B12
.text$x:00004B17
.text$x:00004B17 ; =============== S U B R O U T I N E =======================================
.text$x:00004B17
.text$x:00004B17
.text$x:00004B17 __ehhandler$??1CUniqBlocks@@QAE@XZ proc near
.text$x:00004B17                                         ; DATA XREF: CUniqBlocks::~CUniqBlocks(void)+5o
.text$x:00004B17
.text$x:00004B17 arg_4           = dword ptr  8
.text$x:00004B17
.text$x:00004B17                 mov     edx, [esp+arg_4]
.text$x:00004B1B                 lea     eax, [edx+0Ch]
.text$x:00004B1E                 mov     ecx, [edx-8]
.text$x:00004B21                 xor     ecx, eax
.text$x:00004B23                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004B28                 mov     eax, offset __ehfuncinfo$??1CUniqBlocks@@QAE@XZ
.text$x:00004B2D                 jmp     ___CxxFrameHandler3
.text$x:00004B2D __ehhandler$??1CUniqBlocks@@QAE@XZ endp
.text$x:00004B2D
.text$x:00004B2D ; ---------------------------------------------------------------------------
.text$x:00004B32                 align 4
.text$x:00004B32 _text$x         ends
.text$x:00004B32
.xdata$x:00004B34 ; ===========================================================================
.xdata$x:00004B34
.xdata$x:00004B34 ; Segment type: Pure data
.xdata$x:00004B34 ; Segment permissions: Read
.xdata$x:00004B34 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004B34                 assume cs:_xdata$x
.xdata$x:00004B34                 ;org 4B34h
.xdata$x:00004B34 ; COMDAT (pick associative to section at 4A8C)
.xdata$x:00004B34 __unwindtable$??1CUniqBlocks@@QAE@XZ db 0FFh
.xdata$x:00004B34                                         ; DATA XREF: .xdata$x:00004B4Co
.xdata$x:00004B35                 db 0FFh
.xdata$x:00004B36                 db 0FFh
.xdata$x:00004B37                 db 0FFh
.xdata$x:00004B38                 dd offset __unwindfunclet$??1CUniqBlocks@@QAE@XZ$0
.xdata$x:00004B3C                 align 10h
.xdata$x:00004B40                 dd offset __unwindfunclet$??1CUniqBlocks@@QAE@XZ$1
.xdata$x:00004B44 __ehfuncinfo$??1CUniqBlocks@@QAE@XZ db  22h ; "
.xdata$x:00004B44                                         ; DATA XREF: __ehhandler$??1CUniqBlocks@@QAE@XZ+11o
.xdata$x:00004B45                 db    5
.xdata$x:00004B46                 db  93h ; Ã´
.xdata$x:00004B47                 db  19h
.xdata$x:00004B48                 db    2
.xdata$x:00004B49                 db    0
.xdata$x:00004B4A                 db    0
.xdata$x:00004B4B                 db    0
.xdata$x:00004B4C                 dd offset __unwindtable$??1CUniqBlocks@@QAE@XZ
.xdata$x:00004B50                 db    0
.xdata$x:00004B51                 db    0
.xdata$x:00004B52                 db    0
.xdata$x:00004B53                 db    0
.xdata$x:00004B54                 db    0
.xdata$x:00004B55                 db    0
.xdata$x:00004B56                 db    0
.xdata$x:00004B57                 db    0
.xdata$x:00004B58                 db    0
.xdata$x:00004B59                 db    0
.xdata$x:00004B5A                 db    0
.xdata$x:00004B5B                 db    0
.xdata$x:00004B5C                 db    0
.xdata$x:00004B5D                 db    0
.xdata$x:00004B5E                 db    0
.xdata$x:00004B5F                 db    0
.xdata$x:00004B60                 db    0
.xdata$x:00004B61                 db    0
.xdata$x:00004B62                 db    0
.xdata$x:00004B63                 db    0
.xdata$x:00004B64                 db    1
.xdata$x:00004B65                 db    0
.xdata$x:00004B66                 db    0
.xdata$x:00004B67                 db    0
.xdata$x:00004B67 _xdata$x        ends
.xdata$x:00004B67
.xdata$x:00004B68 ; ===========================================================================
.xdata$x:00004B68
.xdata$x:00004B68 ; Segment type: Pure data
.xdata$x:00004B68 ; Segment permissions: Read
.xdata$x:00004B68 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004B68                 assume cs:_xdata$x
.xdata$x:00004B68                 ;org 4B68h
.xdata$x:00004B68 ; COMDAT (pick any)
.xdata$x:00004B68                 public __TI1_J
.xdata$x:00004B68 __TI1_J         db    0                 ; DATA XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+C63o
.xdata$x:00004B69                 db    0
.xdata$x:00004B6A                 db    0
.xdata$x:00004B6B                 db    0
.xdata$x:00004B6C                 db    0
.xdata$x:00004B6D                 db    0
.xdata$x:00004B6E                 db    0
.xdata$x:00004B6F                 db    0
.xdata$x:00004B70                 db    0
.xdata$x:00004B71                 db    0
.xdata$x:00004B72                 db    0
.xdata$x:00004B73                 db    0
.xdata$x:00004B74                 dd offset __CTA1_J
.xdata$x:00004B74 _xdata$x        ends
.xdata$x:00004B74
.xdata$x:00004B78 ; ===========================================================================
.xdata$x:00004B78
.xdata$x:00004B78 ; Segment type: Pure data
.xdata$x:00004B78 ; Segment permissions: Read
.xdata$x:00004B78 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004B78                 assume cs:_xdata$x
.xdata$x:00004B78                 ;org 4B78h
.xdata$x:00004B78 ; COMDAT (pick any)
.xdata$x:00004B78                 public __CTA1_J
.xdata$x:00004B78 __CTA1_J        db    1                 ; DATA XREF: .xdata$x:00004B74o
.xdata$x:00004B79                 db    0
.xdata$x:00004B7A                 db    0
.xdata$x:00004B7B                 db    0
.xdata$x:00004B7C                 dd offset __CT??_R0_J@88
.xdata$x:00004B7C _xdata$x        ends
.xdata$x:00004B7C
.xdata$x:00004B80 ; ===========================================================================
.xdata$x:00004B80
.xdata$x:00004B80 ; Segment type: Pure data
.xdata$x:00004B80 ; Segment permissions: Read
.xdata$x:00004B80 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004B80                 assume cs:_xdata$x
.xdata$x:00004B80                 ;org 4B80h
.xdata$x:00004B80 ; COMDAT (pick any)
.xdata$x:00004B80                 public __CT??_R0_J@88
.xdata$x:00004B80 __CT??_R0_J@88  db    1                 ; DATA XREF: .xdata$x:00004B7Co
.xdata$x:00004B81                 db    0
.xdata$x:00004B82                 db    0
.xdata$x:00004B83                 db    0
.xdata$x:00004B84                 dd offset ??_R0_J@8     ; __int64 `RTTI Type Descriptor'
.xdata$x:00004B88                 db    0
.xdata$x:00004B89                 db    0
.xdata$x:00004B8A                 db    0
.xdata$x:00004B8B                 db    0
.xdata$x:00004B8C                 db 0FFh
.xdata$x:00004B8D                 db 0FFh
.xdata$x:00004B8E                 db 0FFh
.xdata$x:00004B8F                 db 0FFh
.xdata$x:00004B90                 db    0
.xdata$x:00004B91                 db    0
.xdata$x:00004B92                 db    0
.xdata$x:00004B93                 db    0
.xdata$x:00004B94                 db    8
.xdata$x:00004B95                 db    0
.xdata$x:00004B96                 db    0
.xdata$x:00004B97                 db    0
.xdata$x:00004B98                 db    0
.xdata$x:00004B99                 db    0
.xdata$x:00004B9A                 db    0
.xdata$x:00004B9B                 db    0
.xdata$x:00004B9B _xdata$x        ends
.xdata$x:00004B9B
.data:00004B9C ; ===========================================================================
.data:00004B9C
.data:00004B9C ; Segment type: Pure data
.data:00004B9C ; Segment permissions: Read/Write
.data:00004B9C _data           segment dword public 'DATA' use32
.data:00004B9C                 assume cs:_data
.data:00004B9C                 ;org 4B9Ch
.data:00004B9C ; COMDAT (pick any)
.data:00004B9C                 public ??_R0_J@8
.data:00004B9C ; __int64 `RTTI Type Descriptor'
.data:00004B9C ??_R0_J@8       dd offset ??_7type_info@@6B@ ; DATA XREF: .xdata$x:00004B84o
.data:00004B9C                                         ; const type_info::`vftable'
.data:00004BA0                 db    0
.data:00004BA1                 db    0
.data:00004BA2                 db    0
.data:00004BA3                 db    0
.data:00004BA4                 db  2Eh ; .
.data:00004BA5                 db  5Fh ; _
.data:00004BA6                 db  4Ah ; J
.data:00004BA7                 db    0
.data:00004BA7 _data           ends
.data:00004BA7
.text:00004BA8 ; ===========================================================================
.text:00004BA8
.text:00004BA8 ; Segment type: Pure code
.text:00004BA8 ; Segment permissions: Read/Execute
.text:00004BA8 _text           segment para public 'CODE' use32
.text:00004BA8                 assume cs:_text
.text:00004BA8                 ;org 4BA8h
.text:00004BA8 ; COMDAT (pick any)
.text:00004BA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004BA8
.text:00004BA8 ; =============== S U B R O U T I N E =======================================
.text:00004BA8
.text:00004BA8 ; Attributes: bp-based frame
.text:00004BA8
.text:00004BA8 ; void __thiscall CBoolPair::SetTrueTrue(CBoolPair *__hidden this)
.text:00004BA8                 public ?SetTrueTrue@CBoolPair@@QAEXXZ
.text:00004BA8 ?SetTrueTrue@CBoolPair@@QAEXXZ proc near
.text:00004BA8                                         ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+529p
.text:00004BA8
.text:00004BA8 var_4           = dword ptr -4
.text:00004BA8
.text:00004BA8                 push    ebp
.text:00004BA9                 mov     ebp, esp
.text:00004BAB                 push    ecx
.text:00004BAC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00004BB3                 mov     [ebp+var_4], ecx
.text:00004BB6                 mov     eax, [ebp+var_4]
.text:00004BB9                 mov     byte ptr [eax], 1
.text:00004BBC                 mov     ecx, [ebp+var_4]
.text:00004BBF                 mov     byte ptr [ecx+1], 1
.text:00004BC3                 mov     esp, ebp
.text:00004BC5                 pop     ebp
.text:00004BC6                 retn
.text:00004BC6 ?SetTrueTrue@CBoolPair@@QAEXXZ endp
.text:00004BC6
.text:00004BC6 ; ---------------------------------------------------------------------------
.text:00004BC7                 align 4
.text:00004BC7 _text           ends
.text:00004BC7
.text:00004BC8 ; ===========================================================================
.text:00004BC8
.text:00004BC8 ; Segment type: Pure code
.text:00004BC8 ; Segment permissions: Read/Execute
.text:00004BC8 _text           segment para public 'CODE' use32
.text:00004BC8                 assume cs:_text
.text:00004BC8                 ;org 4BC8h
.text:00004BC8 ; COMDAT (pick any)
.text:00004BC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004BC8
.text:00004BC8 ; =============== S U B R O U T I N E =======================================
.text:00004BC8
.text:00004BC8 ; Attributes: bp-based frame
.text:00004BC8
.text:00004BC8 ; unsigned int __thiscall UString::Len(UString *__hidden this)
.text:00004BC8                 public ?Len@UString@@QBEIXZ
.text:00004BC8 ?Len@UString@@QBEIXZ proc near          ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+9CBp
.text:00004BC8                                         ; ParseArchiveCommand(UString const &,CArcCommand &)+60p ...
.text:00004BC8
.text:00004BC8 var_4           = dword ptr -4
.text:00004BC8
.text:00004BC8                 push    ebp
.text:00004BC9                 mov     ebp, esp
.text:00004BCB                 push    ecx
.text:00004BCC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00004BD3                 mov     [ebp+var_4], ecx
.text:00004BD6                 mov     eax, [ebp+var_4]
.text:00004BD9                 mov     eax, [eax+4]
.text:00004BDC                 mov     esp, ebp
.text:00004BDE                 pop     ebp
.text:00004BDF                 retn
.text:00004BDF ?Len@UString@@QBEIXZ endp
.text:00004BDF
.text:00004BDF _text           ends
.text:00004BDF
.text:00004BE0 ; ===========================================================================
.text:00004BE0
.text:00004BE0 ; Segment type: Pure code
.text:00004BE0 ; Segment permissions: Read/Execute
.text:00004BE0 _text           segment para public 'CODE' use32
.text:00004BE0                 assume cs:_text
.text:00004BE0                 ;org 4BE0h
.text:00004BE0 ; COMDAT (pick any)
.text:00004BE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004BE0
.text:00004BE0 ; =============== S U B R O U T I N E =======================================
.text:00004BE0
.text:00004BE0 ; Attributes: bp-based frame
.text:00004BE0
.text:00004BE0 ; int __stdcall operator==(int, wchar_t *Str2)
.text:00004BE0                 public ??8@YG_NABVUString@@PB_W@Z
.text:00004BE0 ??8@YG_NABVUString@@PB_W@Z proc near    ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+15Cp
.text:00004BE0
.text:00004BE0 arg_0           = dword ptr  8
.text:00004BE0 Str2            = dword ptr  0Ch
.text:00004BE0
.text:00004BE0                 push    ebp
.text:00004BE1                 mov     ebp, esp
.text:00004BE3                 push    esi
.text:00004BE4                 mov     esi, esp
.text:00004BE6                 mov     eax, [ebp+Str2]
.text:00004BE9                 push    eax             ; Str2
.text:00004BEA                 mov     ecx, [ebp+arg_0]
.text:00004BED                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00004BF2                 push    eax             ; Str1
.text:00004BF3                 call    dword ptr ds:__imp__wcscmp
.text:00004BF9                 add     esp, 8
.text:00004BFC                 cmp     esi, esp
.text:00004BFE                 call    __RTC_CheckEsp
.text:00004C03                 neg     eax
.text:00004C05                 sbb     eax, eax
.text:00004C07                 add     eax, 1
.text:00004C0A                 pop     esi
.text:00004C0B                 cmp     ebp, esp
.text:00004C0D                 call    __RTC_CheckEsp
.text:00004C12                 pop     ebp
.text:00004C13                 retn    8
.text:00004C13 ??8@YG_NABVUString@@PB_W@Z endp
.text:00004C13
.text:00004C13 ; ---------------------------------------------------------------------------
.text:00004C16                 align 4
.text:00004C16 _text           ends
.text:00004C16
.text:00004C18 ; ===========================================================================
.text:00004C18
.text:00004C18 ; Segment type: Pure code
.text:00004C18 ; Segment permissions: Read/Execute
.text:00004C18 _text           segment para public 'CODE' use32
.text:00004C18                 assume cs:_text
.text:00004C18                 ;org 4C18h
.text:00004C18 ; COMDAT (pick any)
.text:00004C18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004C18
.text:00004C18 ; =============== S U B R O U T I N E =======================================
.text:00004C18
.text:00004C18 ; Attributes: bp-based frame
.text:00004C18
.text:00004C18 ; bool __thiscall NWildcard::CCensor::AllAreRelative(NWildcard::CCensor *__hidden this)
.text:00004C18                 public ?AllAreRelative@CCensor@NWildcard@@QBE_NXZ
.text:00004C18 ?AllAreRelative@CCensor@NWildcard@@QBE_NXZ proc near
.text:00004C18                                         ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+650p
.text:00004C18
.text:00004C18 var_8           = dword ptr -8
.text:00004C18 var_4           = dword ptr -4
.text:00004C18
.text:00004C18                 push    ebp
.text:00004C19                 mov     ebp, esp
.text:00004C1B                 sub     esp, 8
.text:00004C1E                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00004C25                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00004C2C                 mov     [ebp+var_4], ecx
.text:00004C2F                 mov     ecx, [ebp+var_4]
.text:00004C32                 call    ?Size@?$CObjectVector@UCPair@NWildcard@@@@QBEIXZ ; CObjectVector<NWildcard::CPair>::Size(void)
.text:00004C37                 cmp     eax, 1
.text:00004C3A                 jnz     short loc_4C5B
.text:00004C3C                 mov     ecx, [ebp+var_4]
.text:00004C3F                 call    ?Front@?$CObjectVector@UCPair@NWildcard@@@@QBEABUCPair@NWildcard@@XZ ; CObjectVector<NWildcard::CPair>::Front(void)
.text:00004C44                 mov     ecx, eax        ; this
.text:00004C46                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:00004C4B                 movzx   eax, al
.text:00004C4E                 test    eax, eax
.text:00004C50                 jz      short loc_4C5B
.text:00004C52                 mov     [ebp+var_8], 1
.text:00004C59                 jmp     short loc_4C62
.text:00004C5B ; ---------------------------------------------------------------------------
.text:00004C5B
.text:00004C5B loc_4C5B:                               ; CODE XREF: NWildcard::CCensor::AllAreRelative(void)+22j
.text:00004C5B                                         ; NWildcard::CCensor::AllAreRelative(void)+38j
.text:00004C5B                 mov     [ebp+var_8], 0
.text:00004C62
.text:00004C62 loc_4C62:                               ; CODE XREF: NWildcard::CCensor::AllAreRelative(void)+41j
.text:00004C62                 mov     al, byte ptr [ebp+var_8]
.text:00004C65                 add     esp, 8
.text:00004C68                 cmp     ebp, esp
.text:00004C6A                 call    __RTC_CheckEsp
.text:00004C6F                 mov     esp, ebp
.text:00004C71                 pop     ebp
.text:00004C72                 retn
.text:00004C72 ?AllAreRelative@CCensor@NWildcard@@QBE_NXZ endp
.text:00004C72
.text:00004C72 ; ---------------------------------------------------------------------------
.text:00004C73                 align 4
.text:00004C73 _text           ends
.text:00004C73
.text:00004C74 ; ===========================================================================
.text:00004C74
.text:00004C74 ; Segment type: Pure code
.text:00004C74 ; Segment permissions: Read/Execute
.text:00004C74 _text           segment para public 'CODE' use32
.text:00004C74                 assume cs:_text
.text:00004C74                 ;org 4C74h
.text:00004C74 ; COMDAT (pick any)
.text:00004C74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004C74
.text:00004C74 ; =============== S U B R O U T I N E =======================================
.text:00004C74
.text:00004C74 ; Attributes: bp-based frame
.text:00004C74
.text:00004C74 ; void __thiscall UString::MakeLower_Ascii(UString *__hidden this)
.text:00004C74                 public ?MakeLower_Ascii@UString@@QAEXXZ
.text:00004C74 ?MakeLower_Ascii@UString@@QAEXXZ proc near
.text:00004C74                                         ; CODE XREF: ParseArchiveCommand(UString const &,CArcCommand &)+58p
.text:00004C74                                         ; FindCharset(NCommandLineParser::CParser const &,uint,bool,int)+B8p
.text:00004C74
.text:00004C74 var_4           = dword ptr -4
.text:00004C74
.text:00004C74                 push    ebp
.text:00004C75                 mov     ebp, esp
.text:00004C77                 push    ecx
.text:00004C78                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00004C7F                 mov     [ebp+var_4], ecx
.text:00004C82                 mov     eax, [ebp+var_4]
.text:00004C85                 mov     ecx, [eax]
.text:00004C87                 push    ecx             ; wchar_t *
.text:00004C88                 call    ?MyStringLower_Ascii@@YGXPA_W@Z ; MyStringLower_Ascii(wchar_t *)
.text:00004C8D                 add     esp, 4
.text:00004C90                 cmp     ebp, esp
.text:00004C92                 call    __RTC_CheckEsp
.text:00004C97                 mov     esp, ebp
.text:00004C99                 pop     ebp
.text:00004C9A                 retn
.text:00004C9A ?MakeLower_Ascii@UString@@QAEXXZ endp
.text:00004C9A
.text:00004C9A ; ---------------------------------------------------------------------------
.text:00004C9B                 align 4
.text:00004C9B _text           ends
.text:00004C9B
.text:00004C9C ; ===========================================================================
.text:00004C9C
.text:00004C9C ; Segment type: Pure code
.text:00004C9C ; Segment permissions: Read/Execute
.text:00004C9C _text           segment para public 'CODE' use32
.text:00004C9C                 assume cs:_text
.text:00004C9C                 ;org 4C9Ch
.text:00004C9C ; COMDAT (pick any)
.text:00004C9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004C9C
.text:00004C9C ; =============== S U B R O U T I N E =======================================
.text:00004C9C
.text:00004C9C ; Attributes: bp-based frame
.text:00004C9C
.text:00004C9C ; const wchar_t *__thiscall UString::Ptr(UString *this, unsigned int)
.text:00004C9C                 public ?Ptr@UString@@QBEPB_WI@Z
.text:00004C9C ?Ptr@UString@@QBEPB_WI@Z proc near      ; CODE XREF: AddToCensorFromNonSwitchesStrings(CObjectVector<CRenamePair> *,uint,NWildcard::CCensor &,CObjectVector<UString> const &,NRecursedType::EEnum,bool,bool,int)+113p
.text:00004C9C                                         ; AddSwitchWildcardsToCensor(NWildcard::CCensor &,CObjectVector<UString> const &,bool,NRecursedType::EEnum,bool,int)+136p ...
.text:00004C9C
.text:00004C9C var_4           = dword ptr -4
.text:00004C9C arg_0           = dword ptr  8
.text:00004C9C
.text:00004C9C                 push    ebp
.text:00004C9D                 mov     ebp, esp
.text:00004C9F                 push    ecx
.text:00004CA0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00004CA7                 mov     [ebp+var_4], ecx
.text:00004CAA                 mov     eax, [ebp+var_4]
.text:00004CAD                 mov     ecx, [eax]
.text:00004CAF                 mov     edx, [ebp+arg_0]
.text:00004CB2                 lea     eax, [ecx+edx*2]
.text:00004CB5                 mov     esp, ebp
.text:00004CB7                 pop     ebp
.text:00004CB8                 retn    4
.text:00004CB8 ?Ptr@UString@@QBEPB_WI@Z endp
.text:00004CB8
.text:00004CB8 ; ---------------------------------------------------------------------------
.text:00004CBB                 align 4
.text:00004CBB _text           ends
.text:00004CBB
.text:00004CBC ; ===========================================================================
.text:00004CBC
.text:00004CBC ; Segment type: Pure code
.text:00004CBC ; Segment permissions: Read/Execute
.text:00004CBC _text           segment para public 'CODE' use32
.text:00004CBC                 assume cs:_text
.text:00004CBC                 ;org 4CBCh
.text:00004CBC ; COMDAT (pick any)
.text:00004CBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004CBC
.text:00004CBC ; =============== S U B R O U T I N E =======================================
.text:00004CBC
.text:00004CBC ; Attributes: bp-based frame
.text:00004CBC
.text:00004CBC ; wchar_t __stdcall MyCharLower_Ascii(wchar_t)
.text:00004CBC                 public ?MyCharLower_Ascii@@YG_W_W@Z
.text:00004CBC ?MyCharLower_Ascii@@YG_W_W@Z proc near  ; CODE XREF: AddSwitchWildcardsToCensor(NWildcard::CCensor &,CObjectVector<UString> const &,bool,NRecursedType::EEnum,bool,int)+9Ep
.text:00004CBC                                         ; ParseUpdateCommandString2(UString const &,NUpdateArchive::CActionSet &,UString &)+3Fp
.text:00004CBC
.text:00004CBC arg_0           = word ptr  8
.text:00004CBC
.text:00004CBC                 push    ebp
.text:00004CBD                 mov     ebp, esp
.text:00004CBF                 movzx   eax, [ebp+arg_0]
.text:00004CC3                 cmp     eax, 41h ; 'A'
.text:00004CC6                 jl      short loc_4CDA
.text:00004CC8                 movzx   ecx, [ebp+arg_0]
.text:00004CCC                 cmp     ecx, 5Ah ; 'Z'
.text:00004CCF                 jg      short loc_4CDA
.text:00004CD1                 movzx   eax, [ebp+arg_0]
.text:00004CD5                 add     eax, 20h ; ' '
.text:00004CD8                 jmp     short loc_4CDE
.text:00004CDA ; ---------------------------------------------------------------------------
.text:00004CDA
.text:00004CDA loc_4CDA:                               ; CODE XREF: MyCharLower_Ascii(wchar_t)+Aj
.text:00004CDA                                         ; MyCharLower_Ascii(wchar_t)+13j
.text:00004CDA                 mov     ax, [ebp+arg_0]
.text:00004CDE
.text:00004CDE loc_4CDE:                               ; CODE XREF: MyCharLower_Ascii(wchar_t)+1Cj
.text:00004CDE                 pop     ebp
.text:00004CDF                 retn    4
.text:00004CDF ?MyCharLower_Ascii@@YG_W_W@Z endp
.text:00004CDF
.text:00004CDF ; ---------------------------------------------------------------------------
.text:00004CE2                 align 4
.text:00004CE2 _text           ends
.text:00004CE2
.text:00004CE4 ; ===========================================================================
.text:00004CE4
.text:00004CE4 ; Segment type: Pure code
.text:00004CE4 ; Segment permissions: Read/Execute
.text:00004CE4 _text           segment para public 'CODE' use32
.text:00004CE4                 assume cs:_text
.text:00004CE4                 ;org 4CE4h
.text:00004CE4 ; COMDAT (pick any)
.text:00004CE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004CE4
.text:00004CE4 ; =============== S U B R O U T I N E =======================================
.text:00004CE4
.text:00004CE4 ; Attributes: bp-based frame
.text:00004CE4
.text:00004CE4 ; void __thiscall UString::Empty(UString *__hidden this)
.text:00004CE4                 public ?Empty@UString@@QAEXXZ
.text:00004CE4 ?Empty@UString@@QAEXXZ proc near        ; CODE XREF: ParseMapWithPaths(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)+355p
.text:00004CE4                                         ; ParseUpdateCommandString2(UString const &,NUpdateArchive::CActionSet &,UString &)+FBp
.text:00004CE4
.text:00004CE4 var_4           = dword ptr -4
.text:00004CE4
.text:00004CE4                 push    ebp
.text:00004CE5                 mov     ebp, esp
.text:00004CE7                 push    ecx
.text:00004CE8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00004CEF                 mov     [ebp+var_4], ecx
.text:00004CF2                 mov     eax, [ebp+var_4]
.text:00004CF5                 mov     dword ptr [eax+4], 0
.text:00004CFC                 mov     ecx, [ebp+var_4]
.text:00004CFF                 mov     edx, [ecx]
.text:00004D01                 xor     eax, eax
.text:00004D03                 mov     [edx], ax
.text:00004D06                 mov     esp, ebp
.text:00004D08                 pop     ebp
.text:00004D09                 retn
.text:00004D09 ?Empty@UString@@QAEXXZ endp
.text:00004D09
.text:00004D09 ; ---------------------------------------------------------------------------
.text:00004D0A                 align 4
.text:00004D0A _text           ends
.text:00004D0A
.text:00004D0C ; ===========================================================================
.text:00004D0C
.text:00004D0C ; Segment type: Pure code
.text:00004D0C ; Segment permissions: Read/Execute
.text:00004D0C _text           segment para public 'CODE' use32
.text:00004D0C                 assume cs:_text
.text:00004D0C                 ;org 4D0Ch
.text:00004D0C ; COMDAT (pick any)
.text:00004D0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004D0C
.text:00004D0C ; =============== S U B R O U T I N E =======================================
.text:00004D0C
.text:00004D0C ; Attributes: bp-based frame
.text:00004D0C
.text:00004D0C ; public: class UString & __thiscall UString::operator+=(wchar_t)
.text:00004D0C                 public ??YUString@@QAEAAV0@_W@Z
.text:00004D0C ??YUString@@QAEAAV0@_W@Z proc near      ; CODE XREF: ParseMapWithPaths(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)+367p
.text:00004D0C
.text:00004D0C var_C           = dword ptr -0Ch
.text:00004D0C var_8           = dword ptr -8
.text:00004D0C var_4           = dword ptr -4
.text:00004D0C arg_0           = word ptr  8
.text:00004D0C
.text:00004D0C                 push    ebp
.text:00004D0D                 mov     ebp, esp
.text:00004D0F                 sub     esp, 0Ch
.text:00004D12                 mov     [ebp+var_C], 0CCCCCCCCh
.text:00004D19                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00004D20                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00004D27                 mov     [ebp+var_4], ecx
.text:00004D2A                 mov     eax, [ebp+var_4]
.text:00004D2D                 mov     ecx, [ebp+var_4]
.text:00004D30                 mov     edx, [eax+8]
.text:00004D33                 cmp     edx, [ecx+4]
.text:00004D36                 jnz     short loc_4D40
.text:00004D38                 mov     ecx, [ebp+var_4] ; this
.text:00004D3B                 call    ?Grow_1@UString@@AAEXXZ ; UString::Grow_1(void)
.text:00004D40
.text:00004D40 loc_4D40:                               ; CODE XREF: UString::operator+=(wchar_t)+2Aj
.text:00004D40                 mov     eax, [ebp+var_4]
.text:00004D43                 mov     ecx, [eax+4]
.text:00004D46                 mov     [ebp+var_8], ecx
.text:00004D49                 mov     edx, [ebp+var_4]
.text:00004D4C                 mov     eax, [edx]
.text:00004D4E                 mov     [ebp+var_C], eax
.text:00004D51                 mov     ecx, [ebp+var_8]
.text:00004D54                 mov     edx, [ebp+var_C]
.text:00004D57                 mov     ax, [ebp+arg_0]
.text:00004D5B                 mov     [edx+ecx*2], ax
.text:00004D5F                 mov     ecx, [ebp+var_8]
.text:00004D62                 add     ecx, 1
.text:00004D65                 mov     [ebp+var_8], ecx
.text:00004D68                 xor     edx, edx
.text:00004D6A                 mov     eax, [ebp+var_8]
.text:00004D6D                 mov     ecx, [ebp+var_C]
.text:00004D70                 mov     [ecx+eax*2], dx
.text:00004D74                 mov     edx, [ebp+var_4]
.text:00004D77                 mov     eax, [ebp+var_8]
.text:00004D7A                 mov     [edx+4], eax
.text:00004D7D                 mov     eax, [ebp+var_4]
.text:00004D80                 add     esp, 0Ch
.text:00004D83                 cmp     ebp, esp
.text:00004D85                 call    __RTC_CheckEsp
.text:00004D8A                 mov     esp, ebp
.text:00004D8C                 pop     ebp
.text:00004D8D                 retn    4
.text:00004D8D ??YUString@@QAEAAV0@_W@Z endp
.text:00004D8D
.text:00004D8D _text           ends
.text:00004D8D
.text:00004D90 ; ===========================================================================
.text:00004D90
.text:00004D90 ; Segment type: Pure code
.text:00004D90 ; Segment permissions: Read/Execute
.text:00004D90 _text           segment para public 'CODE' use32
.text:00004D90                 assume cs:_text
.text:00004D90                 ;org 4D90h
.text:00004D90 ; COMDAT (pick any)
.text:00004D90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004D90
.text:00004D90 ; =============== S U B R O U T I N E =======================================
.text:00004D90
.text:00004D90 ; Attributes: bp-based frame
.text:00004D90
.text:00004D90 ; int __thiscall UString::Find(UString *this, wchar_t)
.text:00004D90                 public ?Find@UString@@QBEH_W@Z
.text:00004D90 ?Find@UString@@QBEH_W@Z proc near       ; CODE XREF: ParseMapWithPaths(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)+53p
.text:00004D90                                         ; SetMethodOptions(NCommandLineParser::CParser const &,CObjectVector<CProperty> &)+AEp
.text:00004D90
.text:00004D90 var_4           = dword ptr -4
.text:00004D90 arg_0           = word ptr  8
.text:00004D90
.text:00004D90                 push    ebp
.text:00004D91                 mov     ebp, esp
.text:00004D93                 push    ecx
.text:00004D94                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00004D9B                 mov     [ebp+var_4], ecx
.text:00004D9E                 movzx   eax, [ebp+arg_0]
.text:00004DA2                 push    eax             ; wchar_t
.text:00004DA3                 mov     ecx, [ebp+var_4]
.text:00004DA6                 mov     edx, [ecx]
.text:00004DA8                 push    edx             ; wchar_t *
.text:00004DA9                 call    ?FindCharPosInString@@YGHPB_W_W@Z ; FindCharPosInString(wchar_t const *,wchar_t)
.text:00004DAE                 add     esp, 4
.text:00004DB1                 cmp     ebp, esp
.text:00004DB3                 call    __RTC_CheckEsp
.text:00004DB8                 mov     esp, ebp
.text:00004DBA                 pop     ebp
.text:00004DBB                 retn    4
.text:00004DBB ?Find@UString@@QBEH_W@Z endp
.text:00004DBB
.text:00004DBB ; ---------------------------------------------------------------------------
.text:00004DBE                 align 10h
.text:00004DBE _text           ends
.text:00004DBE
.text:00004DC0 ; ===========================================================================
.text:00004DC0
.text:00004DC0 ; Segment type: Pure code
.text:00004DC0 ; Segment permissions: Read/Execute
.text:00004DC0 _text           segment para public 'CODE' use32
.text:00004DC0                 assume cs:_text
.text:00004DC0                 ;org 4DC0h
.text:00004DC0 ; COMDAT (pick any)
.text:00004DC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004DC0
.text:00004DC0 ; =============== S U B R O U T I N E =======================================
.text:00004DC0
.text:00004DC0 ; Attributes: bp-based frame
.text:00004DC0
.text:00004DC0 ; int __thiscall UString::Find(UString *this, wchar_t, unsigned int)
.text:00004DC0                 public ?Find@UString@@QBEH_WI@Z
.text:00004DC0 ?Find@UString@@QBEH_WI@Z proc near      ; CODE XREF: ParseMapWithPaths(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)+93p
.text:00004DC0
.text:00004DC0 var_C           = dword ptr -0Ch
.text:00004DC0 var_8           = dword ptr -8
.text:00004DC0 var_4           = dword ptr -4
.text:00004DC0 arg_0           = word ptr  8
.text:00004DC0 arg_4           = dword ptr  0Ch
.text:00004DC0
.text:00004DC0                 push    ebp
.text:00004DC1                 mov     ebp, esp
.text:00004DC3                 sub     esp, 0Ch
.text:00004DC6                 mov     [ebp+var_C], 0CCCCCCCCh
.text:00004DCD                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00004DD4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00004DDB                 mov     [ebp+var_4], ecx
.text:00004DDE                 movzx   eax, [ebp+arg_0]
.text:00004DE2                 push    eax             ; wchar_t
.text:00004DE3                 mov     ecx, [ebp+var_4]
.text:00004DE6                 mov     edx, [ecx]
.text:00004DE8                 mov     eax, [ebp+arg_4]
.text:00004DEB                 lea     ecx, [edx+eax*2]
.text:00004DEE                 push    ecx             ; wchar_t *
.text:00004DEF                 call    ?FindCharPosInString@@YGHPB_W_W@Z ; FindCharPosInString(wchar_t const *,wchar_t)
.text:00004DF4                 mov     [ebp+var_8], eax
.text:00004DF7                 cmp     [ebp+var_8], 0
.text:00004DFB                 jge     short loc_4E06
.text:00004DFD                 mov     [ebp+var_C], 0FFFFFFFFh
.text:00004E04                 jmp     short loc_4E0F
.text:00004E06 ; ---------------------------------------------------------------------------
.text:00004E06
.text:00004E06 loc_4E06:                               ; CODE XREF: UString::Find(wchar_t,uint)+3Bj
.text:00004E06                 mov     edx, [ebp+arg_4]
.text:00004E09                 add     edx, [ebp+var_8]
.text:00004E0C                 mov     [ebp+var_C], edx
.text:00004E0F
.text:00004E0F loc_4E0F:                               ; CODE XREF: UString::Find(wchar_t,uint)+44j
.text:00004E0F                 mov     eax, [ebp+var_C]
.text:00004E12                 add     esp, 0Ch
.text:00004E15                 cmp     ebp, esp
.text:00004E17                 call    __RTC_CheckEsp
.text:00004E1C                 mov     esp, ebp
.text:00004E1E                 pop     ebp
.text:00004E1F                 retn    8
.text:00004E1F ?Find@UString@@QBEH_WI@Z endp
.text:00004E1F
.text:00004E1F ; ---------------------------------------------------------------------------
.text:00004E22                 align 4
.text:00004E22 _text           ends
.text:00004E22
.text:00004E24 ; ===========================================================================
.text:00004E24
.text:00004E24 ; Segment type: Pure code
.text:00004E24 ; Segment permissions: Read/Execute
.text:00004E24 _text           segment para public 'CODE' use32
.text:00004E24                 assume cs:_text
.text:00004E24                 ;org 4E24h
.text:00004E24 ; COMDAT (pick any)
.text:00004E24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004E24
.text:00004E24 ; =============== S U B R O U T I N E =======================================
.text:00004E24
.text:00004E24 ; Attributes: bp-based frame
.text:00004E24
.text:00004E24 ; void __thiscall UString::DeleteFrom(UString *this, unsigned int)
.text:00004E24                 public ?DeleteFrom@UString@@QAEXI@Z
.text:00004E24 ?DeleteFrom@UString@@QAEXI@Z proc near  ; CODE XREF: ParseMapWithPaths(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)+E9p
.text:00004E24                                         ; ParseMapWithPaths(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)+164p ...
.text:00004E24
.text:00004E24 var_4           = dword ptr -4
.text:00004E24 arg_0           = dword ptr  8
.text:00004E24
.text:00004E24                 push    ebp
.text:00004E25                 mov     ebp, esp
.text:00004E27                 push    ecx
.text:00004E28                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00004E2F                 mov     [ebp+var_4], ecx
.text:00004E32                 mov     eax, [ebp+var_4]
.text:00004E35                 mov     ecx, [ebp+arg_0]
.text:00004E38                 cmp     ecx, [eax+4]
.text:00004E3B                 jnb     short loc_4E54
.text:00004E3D                 mov     edx, [ebp+var_4]
.text:00004E40                 mov     eax, [ebp+arg_0]
.text:00004E43                 mov     [edx+4], eax
.text:00004E46                 mov     ecx, [ebp+var_4]
.text:00004E49                 mov     edx, [ecx]
.text:00004E4B                 xor     eax, eax
.text:00004E4D                 mov     ecx, [ebp+arg_0]
.text:00004E50                 mov     [edx+ecx*2], ax
.text:00004E54
.text:00004E54 loc_4E54:                               ; CODE XREF: UString::DeleteFrom(uint)+17j
.text:00004E54                 mov     esp, ebp
.text:00004E56                 pop     ebp
.text:00004E57                 retn    4
.text:00004E57 ?DeleteFrom@UString@@QAEXI@Z endp
.text:00004E57
.text:00004E57 ; ---------------------------------------------------------------------------
.text:00004E5A                 align 4
.text:00004E5A _text           ends
.text:00004E5A
.text:00004E5C ; ===========================================================================
.text:00004E5C
.text:00004E5C ; Segment type: Pure code
.text:00004E5C ; Segment permissions: Read/Execute
.text:00004E5C _text           segment para public 'CODE' use32
.text:00004E5C                 assume cs:_text
.text:00004E5C                 ;org 4E5Ch
.text:00004E5C ; COMDAT (pick any)
.text:00004E5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004E5C
.text:00004E5C ; =============== S U B R O U T I N E =======================================
.text:00004E5C
.text:00004E5C ; Attributes: bp-based frame
.text:00004E5C
.text:00004E5C ; class AString __stdcall GetSystemString(class UString const &)
.text:00004E5C                 public ?GetSystemString@@YG?AVAString@@ABVUString@@@Z
.text:00004E5C ?GetSystemString@@YG?AVAString@@ABVUString@@@Z proc near
.text:00004E5C                                         ; CODE XREF: ParseMapWithPaths(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)+180p
.text:00004E5C                                         ; CEventSetEnd::~CEventSetEnd(void)+55p
.text:00004E5C
.text:00004E5C var_4           = dword ptr -4
.text:00004E5C arg_0           = dword ptr  8
.text:00004E5C arg_4           = dword ptr  0Ch
.text:00004E5C
.text:00004E5C                 push    ebp
.text:00004E5D                 mov     ebp, esp
.text:00004E5F                 push    ecx
.text:00004E60                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00004E67                 mov     [ebp+var_4], 0
.text:00004E6E                 push    0
.text:00004E70                 mov     eax, [ebp+arg_4]
.text:00004E73                 push    eax
.text:00004E74                 mov     ecx, [ebp+arg_0]
.text:00004E77                 push    ecx
.text:00004E78                 call    ?UnicodeStringToMultiByte@@YG?AVAString@@ABVUString@@I@Z ; UnicodeStringToMultiByte(UString const &,uint)
.text:00004E7D                 mov     edx, [ebp+var_4]
.text:00004E80                 or      edx, 1
.text:00004E83                 mov     [ebp+var_4], edx
.text:00004E86                 mov     eax, [ebp+arg_0]
.text:00004E89                 add     esp, 4
.text:00004E8C                 cmp     ebp, esp
.text:00004E8E                 call    __RTC_CheckEsp
.text:00004E93                 mov     esp, ebp
.text:00004E95                 pop     ebp
.text:00004E96                 retn    8
.text:00004E96 ?GetSystemString@@YG?AVAString@@ABVUString@@@Z endp
.text:00004E96
.text:00004E96 ; ---------------------------------------------------------------------------
.text:00004E99                 align 4
.text:00004E99 _text           ends
.text:00004E99
.text:00004E9C ; ===========================================================================
.text:00004E9C
.text:00004E9C ; Segment type: Pure code
.text:00004E9C ; Segment permissions: Read/Execute
.text:00004E9C _text           segment para public 'CODE' use32
.text:00004E9C                 assume cs:_text
.text:00004E9C                 ;org 4E9Ch
.text:00004E9C ; COMDAT (pick any)
.text:00004E9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004E9C
.text:00004E9C ; =============== S U B R O U T I N E =======================================
.text:00004E9C
.text:00004E9C ; Attributes: bp-based frame
.text:00004E9C
.text:00004E9C ; unsigned int __thiscall NWindows::CFileMapping::Open(NWindows::CFileMapping *this, DWORD dwDesiredAccess, const char *)
.text:00004E9C                 public ?Open@CFileMapping@NWindows@@QAEIKPBD@Z
.text:00004E9C ?Open@CFileMapping@NWindows@@QAEIKPBD@Z proc near
.text:00004E9C                                         ; CODE XREF: ParseMapWithPaths(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)+1ACp
.text:00004E9C
.text:00004E9C var_4           = dword ptr -4
.text:00004E9C dwDesiredAccess = dword ptr  8
.text:00004E9C lpName          = dword ptr  0Ch
.text:00004E9C
.text:00004E9C                 push    ebp
.text:00004E9D                 mov     ebp, esp
.text:00004E9F                 push    ecx
.text:00004EA0                 push    esi
.text:00004EA1                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00004EA8                 mov     [ebp+var_4], ecx
.text:00004EAB                 mov     esi, esp
.text:00004EAD                 mov     eax, [ebp+lpName]
.text:00004EB0                 push    eax             ; lpName
.text:00004EB1                 push    0               ; bInheritHandle
.text:00004EB3                 mov     ecx, [ebp+dwDesiredAccess]
.text:00004EB6                 push    ecx             ; dwDesiredAccess
.text:00004EB7                 call    dword ptr ds:__imp__OpenFileMappingA@12 ; OpenFileMappingA(x,x,x)
.text:00004EBD                 cmp     esi, esp
.text:00004EBF                 call    __RTC_CheckEsp
.text:00004EC4                 mov     edx, [ebp+var_4]
.text:00004EC7                 mov     [edx], eax
.text:00004EC9                 mov     eax, [ebp+var_4]
.text:00004ECC                 cmp     dword ptr [eax], 0
.text:00004ECF                 jz      short loc_4ED5
.text:00004ED1                 xor     eax, eax
.text:00004ED3                 jmp     short loc_4EE4
.text:00004ED5 ; ---------------------------------------------------------------------------
.text:00004ED5
.text:00004ED5 loc_4ED5:                               ; CODE XREF: NWindows::CFileMapping::Open(ulong,char const *)+33j
.text:00004ED5                 mov     esi, esp
.text:00004ED7                 call    dword ptr ds:__imp__GetLastError@0 ; GetLastError()
.text:00004EDD                 cmp     esi, esp
.text:00004EDF                 call    __RTC_CheckEsp
.text:00004EE4
.text:00004EE4 loc_4EE4:                               ; CODE XREF: NWindows::CFileMapping::Open(ulong,char const *)+37j
.text:00004EE4                 pop     esi
.text:00004EE5                 add     esp, 4
.text:00004EE8                 cmp     ebp, esp
.text:00004EEA                 call    __RTC_CheckEsp
.text:00004EEF                 mov     esp, ebp
.text:00004EF1                 pop     ebp
.text:00004EF2                 retn    8
.text:00004EF2 ?Open@CFileMapping@NWindows@@QAEIKPBD@Z endp
.text:00004EF2
.text:00004EF2 ; ---------------------------------------------------------------------------
.text:00004EF5                 align 4
.text:00004EF5 _text           ends
.text:00004EF5
.text:00004EF8 ; ===========================================================================
.text:00004EF8
.text:00004EF8 ; Segment type: Pure code
.text:00004EF8 ; Segment permissions: Read/Execute
.text:00004EF8 _text           segment para public 'CODE' use32
.text:00004EF8                 assume cs:_text
.text:00004EF8                 ;org 4EF8h
.text:00004EF8 ; COMDAT (pick any)
.text:00004EF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004EF8
.text:00004EF8 ; =============== S U B R O U T I N E =======================================
.text:00004EF8
.text:00004EF8 ; Attributes: bp-based frame
.text:00004EF8
.text:00004EF8 ; void *__thiscall NWindows::CFileMapping::Map(NWindows::CFileMapping *this, DWORD dwDesiredAccess, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap)
.text:00004EF8                 public ?Map@CFileMapping@NWindows@@QAEPAXK_KK@Z
.text:00004EF8 ?Map@CFileMapping@NWindows@@QAEPAXK_KK@Z proc near
.text:00004EF8                                         ; CODE XREF: ParseMapWithPaths(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)+220p
.text:00004EF8
.text:00004EF8 var_4           = dword ptr -4
.text:00004EF8 dwDesiredAccess = dword ptr  8
.text:00004EF8 dwFileOffsetLow = dword ptr  0Ch
.text:00004EF8 arg_8           = dword ptr  10h
.text:00004EF8 dwNumberOfBytesToMap= dword ptr  14h
.text:00004EF8
.text:00004EF8                 push    ebp
.text:00004EF9                 mov     ebp, esp
.text:00004EFB                 push    ecx
.text:00004EFC                 push    esi
.text:00004EFD                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00004F04                 mov     [ebp+var_4], ecx
.text:00004F07                 mov     esi, esp
.text:00004F09                 mov     eax, [ebp+dwNumberOfBytesToMap]
.text:00004F0C                 push    eax             ; dwNumberOfBytesToMap
.text:00004F0D                 mov     ecx, [ebp+dwFileOffsetLow]
.text:00004F10                 push    ecx             ; dwFileOffsetLow
.text:00004F11                 mov     eax, [ebp+dwFileOffsetLow]
.text:00004F14                 mov     edx, [ebp+arg_8]
.text:00004F17                 mov     cl, 20h ; ' '
.text:00004F19                 call    __aullshr
.text:00004F1E                 push    eax             ; dwFileOffsetHigh
.text:00004F1F                 mov     edx, [ebp+dwDesiredAccess]
.text:00004F22                 push    edx             ; dwDesiredAccess
.text:00004F23                 mov     eax, [ebp+var_4]
.text:00004F26                 mov     ecx, [eax]
.text:00004F28                 push    ecx             ; hFileMappingObject
.text:00004F29                 call    dword ptr ds:__imp__MapViewOfFile@20 ; MapViewOfFile(x,x,x,x,x)
.text:00004F2F                 cmp     esi, esp
.text:00004F31                 call    __RTC_CheckEsp
.text:00004F36                 pop     esi
.text:00004F37                 add     esp, 4
.text:00004F3A                 cmp     ebp, esp
.text:00004F3C                 call    __RTC_CheckEsp
.text:00004F41                 mov     esp, ebp
.text:00004F43                 pop     ebp
.text:00004F44                 retn    10h
.text:00004F44 ?Map@CFileMapping@NWindows@@QAEPAXK_KK@Z endp
.text:00004F44
.text:00004F44 ; ---------------------------------------------------------------------------
.text:00004F47                 align 4
.text:00004F47 _text           ends
.text:00004F47
.text:00004F48 ; ===========================================================================
.text:00004F48
.text:00004F48 ; Segment type: Pure code
.text:00004F48 ; Segment permissions: Read/Execute
.text:00004F48 _text           segment para public 'CODE' use32
.text:00004F48                 assume cs:_text
.text:00004F48                 ;org 4F48h
.text:00004F48 ; COMDAT (pick any)
.text:00004F48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004F48
.text:00004F48 ; =============== S U B R O U T I N E =======================================
.text:00004F48
.text:00004F48 ; Attributes: bp-based frame
.text:00004F48
.text:00004F48 ; _DWORD __thiscall NWindows::CFileUnmapper::CFileUnmapper(NWindows::CFileUnmapper *this, const void *)
.text:00004F48                 public ??0CFileUnmapper@NWindows@@QAE@PBX@Z
.text:00004F48 ??0CFileUnmapper@NWindows@@QAE@PBX@Z proc near
.text:00004F48                                         ; CODE XREF: ParseMapWithPaths(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)+271p
.text:00004F48
.text:00004F48 var_4           = dword ptr -4
.text:00004F48 arg_0           = dword ptr  8
.text:00004F48
.text:00004F48                 push    ebp
.text:00004F49                 mov     ebp, esp
.text:00004F4B                 push    ecx
.text:00004F4C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00004F53                 mov     [ebp+var_4], ecx
.text:00004F56                 mov     eax, [ebp+var_4]
.text:00004F59                 mov     ecx, [ebp+arg_0]
.text:00004F5C                 mov     [eax], ecx
.text:00004F5E                 mov     eax, [ebp+var_4]
.text:00004F61                 mov     esp, ebp
.text:00004F63                 pop     ebp
.text:00004F64                 retn    4
.text:00004F64 ??0CFileUnmapper@NWindows@@QAE@PBX@Z endp
.text:00004F64
.text:00004F64 ; ---------------------------------------------------------------------------
.text:00004F67                 align 4
.text:00004F67 _text           ends
.text:00004F67
.text:00004F68 ; ===========================================================================
.text:00004F68
.text:00004F68 ; Segment type: Pure code
.text:00004F68 ; Segment permissions: Read/Execute
.text:00004F68 _text           segment para public 'CODE' use32
.text:00004F68                 assume cs:_text
.text:00004F68                 ;org 4F68h
.text:00004F68 ; COMDAT (pick any)
.text:00004F68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004F68
.text:00004F68 ; =============== S U B R O U T I N E =======================================
.text:00004F68
.text:00004F68 ; Attributes: bp-based frame
.text:00004F68
.text:00004F68 ; _DWORD __thiscall NWindows::CFileUnmapper::~CFileUnmapper(NWindows::CFileUnmapper *__hidden this)
.text:00004F68                 public ??1CFileUnmapper@NWindows@@QAE@XZ
.text:00004F68 ??1CFileUnmapper@NWindows@@QAE@XZ proc near
.text:00004F68                                         ; CODE XREF: ParseMapWithPaths(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)+2B3p
.text:00004F68                                         ; ParseMapWithPaths(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)+39Ap ...
.text:00004F68
.text:00004F68 var_4           = dword ptr -4
.text:00004F68
.text:00004F68                 push    ebp
.text:00004F69                 mov     ebp, esp
.text:00004F6B                 push    ecx
.text:00004F6C                 push    esi
.text:00004F6D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00004F74                 mov     [ebp+var_4], ecx
.text:00004F77                 mov     esi, esp
.text:00004F79                 mov     eax, [ebp+var_4]
.text:00004F7C                 mov     ecx, [eax]
.text:00004F7E                 push    ecx             ; lpBaseAddress
.text:00004F7F                 call    dword ptr ds:__imp__UnmapViewOfFile@4 ; UnmapViewOfFile(x)
.text:00004F85                 cmp     esi, esp
.text:00004F87                 call    __RTC_CheckEsp
.text:00004F8C                 pop     esi
.text:00004F8D                 add     esp, 4
.text:00004F90                 cmp     ebp, esp
.text:00004F92                 call    __RTC_CheckEsp
.text:00004F97                 mov     esp, ebp
.text:00004F99                 pop     ebp
.text:00004F9A                 retn
.text:00004F9A ??1CFileUnmapper@NWindows@@QAE@XZ endp
.text:00004F9A
.text:00004F9A ; ---------------------------------------------------------------------------
.text:00004F9B                 align 4
.text:00004F9B _text           ends
.text:00004F9B
.text:00004F9C ; ===========================================================================
.text:00004F9C
.text:00004F9C ; Segment type: Pure code
.text:00004F9C ; Segment permissions: Read/Execute
.text:00004F9C _text           segment para public 'CODE' use32
.text:00004F9C                 assume cs:_text
.text:00004F9C                 ;org 4F9Ch
.text:00004F9C ; COMDAT (pick any)
.text:00004F9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004F9C
.text:00004F9C ; =============== S U B R O U T I N E =======================================
.text:00004F9C
.text:00004F9C ; Attributes: bp-based frame
.text:00004F9C
.text:00004F9C ; _DWORD __thiscall CEventSetEnd::CEventSetEnd(CEventSetEnd *this, const wchar_t *)
.text:00004F9C                 public ??0CEventSetEnd@@QAE@PB_W@Z
.text:00004F9C ??0CEventSetEnd@@QAE@PB_W@Z proc near   ; CODE XREF: ParseMapWithPaths(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)+D9p
.text:00004F9C
.text:00004F9C var_4           = dword ptr -4
.text:00004F9C arg_0           = dword ptr  8
.text:00004F9C
.text:00004F9C                 push    ebp
.text:00004F9D                 mov     ebp, esp
.text:00004F9F                 push    ecx
.text:00004FA0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00004FA7                 mov     [ebp+var_4], ecx
.text:00004FAA                 mov     eax, [ebp+arg_0]
.text:00004FAD                 push    eax
.text:00004FAE                 mov     ecx, [ebp+var_4]
.text:00004FB1                 call    ??0UString@@QAE@PB_W@Z ; UString::UString(wchar_t const *)
.text:00004FB6                 mov     eax, [ebp+var_4]
.text:00004FB9                 add     esp, 4
.text:00004FBC                 cmp     ebp, esp
.text:00004FBE                 call    __RTC_CheckEsp
.text:00004FC3                 mov     esp, ebp
.text:00004FC5                 pop     ebp
.text:00004FC6                 retn    4
.text:00004FC6 ??0CEventSetEnd@@QAE@PB_W@Z endp
.text:00004FC6
.text:00004FC6 ; ---------------------------------------------------------------------------
.text:00004FC9                 align 4
.text:00004FC9 _text           ends
.text:00004FC9
.text:00004FCC ; ===========================================================================
.text:00004FCC
.text:00004FCC ; Segment type: Pure code
.text:00004FCC ; Segment permissions: Read/Execute
.text:00004FCC _text           segment para public 'CODE' use32
.text:00004FCC                 assume cs:_text
.text:00004FCC                 ;org 4FCCh
.text:00004FCC ; COMDAT (pick any)
.text:00004FCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004FCC
.text:00004FCC ; =============== S U B R O U T I N E =======================================
.text:00004FCC
.text:00004FCC ; Attributes: bp-based frame
.text:00004FCC
.text:00004FCC ; _DWORD __thiscall CEventSetEnd::~CEventSetEnd(CEventSetEnd *__hidden this)
.text:00004FCC                 public ??1CEventSetEnd@@QAE@XZ
.text:00004FCC ??1CEventSetEnd@@QAE@XZ proc near       ; CODE XREF: ParseMapWithPaths(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)+13Ep
.text:00004FCC                                         ; ParseMapWithPaths(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)+1F4p ...
.text:00004FCC
.text:00004FCC var_34          = dword ptr -34h
.text:00004FCC var_30          = dword ptr -30h
.text:00004FCC var_2C          = byte ptr -2Ch
.text:00004FCC var_1D          = byte ptr -1Dh
.text:00004FCC var_18          = byte ptr -18h
.text:00004FCC var_10          = dword ptr -10h
.text:00004FCC var_C           = dword ptr -0Ch
.text:00004FCC var_4           = dword ptr -4
.text:00004FCC
.text:00004FCC                 push    ebp
.text:00004FCD                 mov     ebp, esp
.text:00004FCF                 push    0FFFFFFFFh
.text:00004FD1                 push    offset __ehhandler$??1CEventSetEnd@@QAE@XZ
.text:00004FD6                 mov     eax, large fs:0
.text:00004FDC                 push    eax
.text:00004FDD                 sub     esp, 28h
.text:00004FE0                 push    edi
.text:00004FE1                 push    ecx
.text:00004FE2                 lea     edi, [ebp+var_34]
.text:00004FE5                 mov     ecx, 0Ah
.text:00004FEA                 mov     eax, 0CCCCCCCCh
.text:00004FEF                 rep stosd
.text:00004FF1                 pop     ecx
.text:00004FF2                 mov     eax, dword ptr ds:___security_cookie
.text:00004FF7                 xor     eax, ebp
.text:00004FF9                 push    eax
.text:00004FFA                 lea     eax, [ebp+var_C]
.text:00004FFD                 mov     large fs:0, eax
.text:00005003                 mov     [ebp+var_10], ecx
.text:00005006                 mov     [ebp+var_4], 0
.text:0000500D                 lea     ecx, [ebp+var_18] ; this
.text:00005010                 call    ??0CManualResetEvent@NSynchronization@NWindows@@QAE@XZ ; NWindows::NSynchronization::CManualResetEvent::CManualResetEvent(void)
.text:00005015                 mov     byte ptr [ebp+var_4], 1
.text:00005019                 mov     eax, [ebp+var_10]
.text:0000501C                 push    eax
.text:0000501D                 lea     ecx, [ebp+var_2C]
.text:00005020                 push    ecx
.text:00005021                 call    ?GetSystemString@@YG?AVAString@@ABVUString@@@Z ; GetSystemString(UString const &)
.text:00005026                 mov     [ebp+var_30], eax
.text:00005029                 mov     edx, [ebp+var_30]
.text:0000502C                 mov     [ebp+var_34], edx
.text:0000502F                 mov     byte ptr [ebp+var_4], 2
.text:00005033                 mov     ecx, [ebp+var_34]
.text:00005036                 call    ??BAString@@QBEPBDXZ ; AString::operator char const *(void)
.text:0000503B                 push    eax             ; char *
.text:0000503C                 push    0               ; bool
.text:0000503E                 push    2               ; dwDesiredAccess
.text:00005040                 lea     ecx, [ebp+var_18] ; this
.text:00005043                 call    ?Open@CBaseEvent@NSynchronization@NWindows@@QAEIK_NPBD@Z ; NWindows::NSynchronization::CBaseEvent::Open(ulong,bool,char const *)
.text:00005048                 neg     eax
.text:0000504A                 sbb     eax, eax
.text:0000504C                 add     eax, 1
.text:0000504F                 mov     [ebp+var_1D], al
.text:00005052                 mov     byte ptr [ebp+var_4], 1
.text:00005056                 lea     ecx, [ebp+var_2C] ; this
.text:00005059                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:0000505E                 movzx   eax, [ebp+var_1D]
.text:00005062                 test    eax, eax
.text:00005064                 jz      short loc_506E
.text:00005066                 lea     ecx, [ebp+var_18] ; this
.text:00005069                 call    ?Set@CBaseEvent@NSynchronization@NWindows@@QAEIXZ ; NWindows::NSynchronization::CBaseEvent::Set(void)
.text:0000506E
.text:0000506E loc_506E:                               ; CODE XREF: CEventSetEnd::~CEventSetEnd(void)+98j
.text:0000506E                 mov     byte ptr [ebp+var_4], 0
.text:00005072                 lea     ecx, [ebp+var_18] ; this
.text:00005075                 call    ??1CManualResetEvent@NSynchronization@NWindows@@QAE@XZ ; NWindows::NSynchronization::CManualResetEvent::~CManualResetEvent(void)
.text:0000507A                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00005081                 mov     ecx, [ebp+var_10] ; this
.text:00005084                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00005089                 push    edx
.text:0000508A                 mov     ecx, ebp
.text:0000508C                 push    eax
.text:0000508D                 lea     edx, $LN10_2
.text:00005093                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00005098                 pop     eax
.text:00005099                 pop     edx
.text:0000509A                 mov     ecx, [ebp+var_C]
.text:0000509D                 mov     large fs:0, ecx
.text:000050A4                 pop     ecx
.text:000050A5                 pop     edi
.text:000050A6                 add     esp, 34h
.text:000050A9                 cmp     ebp, esp
.text:000050AB                 call    __RTC_CheckEsp
.text:000050B0                 mov     esp, ebp
.text:000050B2                 pop     ebp
.text:000050B3                 retn
.text:000050B3 ??1CEventSetEnd@@QAE@XZ endp
.text:000050B3
.text:000050B3 ; ---------------------------------------------------------------------------
.text:000050B4 $LN10_2         dd 1                    ; DATA XREF: CEventSetEnd::~CEventSetEnd(void)+C1o
.text:000050B8                 dd offset $LN9_0
.text:000050BC $LN9_0          dd 0FFFFFFE8h, 4        ; DATA XREF: .text:000050B8o
.text:000050C4                 dd offset $LN7          ; "event"
.text:000050C8 $LN7            db 'event',0            ; DATA XREF: .text:000050C4o
.text:000050CE                 align 10h
.text:000050CE _text           ends
.text:000050CE
.text$x:000050D0 ; ===========================================================================
.text$x:000050D0
.text$x:000050D0 ; Segment type: Pure code
.text$x:000050D0 ; Segment permissions: Read/Execute
.text$x:000050D0 _text$x         segment para public 'CODE' use32
.text$x:000050D0                 assume cs:_text$x
.text$x:000050D0                 ;org 50D0h
.text$x:000050D0 ; COMDAT (pick associative to section at 4FCC)
.text$x:000050D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000050D0
.text$x:000050D0 ; =============== S U B R O U T I N E =======================================
.text$x:000050D0
.text$x:000050D0
.text$x:000050D0 __unwindfunclet$??1CEventSetEnd@@QAE@XZ$0 proc near
.text$x:000050D0                                         ; DATA XREF: .xdata$x:00005108o
.text$x:000050D0                 mov     ecx, [ebp-10h]  ; this
.text$x:000050D3                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000050D3 __unwindfunclet$??1CEventSetEnd@@QAE@XZ$0 endp
.text$x:000050D3
.text$x:000050D8
.text$x:000050D8 ; =============== S U B R O U T I N E =======================================
.text$x:000050D8
.text$x:000050D8
.text$x:000050D8 __unwindfunclet$??1CEventSetEnd@@QAE@XZ$1 proc near
.text$x:000050D8                                         ; DATA XREF: .xdata$x:00005110o
.text$x:000050D8                 lea     ecx, [ebp-18h]  ; this
.text$x:000050DB                 jmp     ??1CManualResetEvent@NSynchronization@NWindows@@QAE@XZ ; NWindows::NSynchronization::CManualResetEvent::~CManualResetEvent(void)
.text$x:000050DB __unwindfunclet$??1CEventSetEnd@@QAE@XZ$1 endp
.text$x:000050DB
.text$x:000050E0
.text$x:000050E0 ; =============== S U B R O U T I N E =======================================
.text$x:000050E0
.text$x:000050E0
.text$x:000050E0 __unwindfunclet$??1CEventSetEnd@@QAE@XZ$2 proc near
.text$x:000050E0                                         ; DATA XREF: .xdata$x:00005118o
.text$x:000050E0                 lea     ecx, [ebp-2Ch]  ; this
.text$x:000050E3                 jmp     ??1AString@@QAE@XZ ; AString::~AString(void)
.text$x:000050E3 __unwindfunclet$??1CEventSetEnd@@QAE@XZ$2 endp
.text$x:000050E3
.text$x:000050E8
.text$x:000050E8 ; =============== S U B R O U T I N E =======================================
.text$x:000050E8
.text$x:000050E8
.text$x:000050E8 __ehhandler$??1CEventSetEnd@@QAE@XZ proc near
.text$x:000050E8                                         ; DATA XREF: CEventSetEnd::~CEventSetEnd(void)+5o
.text$x:000050E8
.text$x:000050E8 arg_4           = dword ptr  8
.text$x:000050E8
.text$x:000050E8                 mov     edx, [esp+arg_4]
.text$x:000050EC                 lea     eax, [edx+0Ch]
.text$x:000050EF                 mov     ecx, [edx-30h]
.text$x:000050F2                 xor     ecx, eax
.text$x:000050F4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000050F9                 mov     eax, offset __ehfuncinfo$??1CEventSetEnd@@QAE@XZ
.text$x:000050FE                 jmp     ___CxxFrameHandler3
.text$x:000050FE __ehhandler$??1CEventSetEnd@@QAE@XZ endp
.text$x:000050FE
.text$x:000050FE ; ---------------------------------------------------------------------------
.text$x:00005103                 align 4
.text$x:00005103 _text$x         ends
.text$x:00005103
.xdata$x:00005104 ; ===========================================================================
.xdata$x:00005104
.xdata$x:00005104 ; Segment type: Pure data
.xdata$x:00005104 ; Segment permissions: Read
.xdata$x:00005104 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005104                 assume cs:_xdata$x
.xdata$x:00005104                 ;org 5104h
.xdata$x:00005104 ; COMDAT (pick associative to section at 4FCC)
.xdata$x:00005104 __unwindtable$??1CEventSetEnd@@QAE@XZ db 0FFh
.xdata$x:00005104                                         ; DATA XREF: .xdata$x:00005124o
.xdata$x:00005105                 db 0FFh
.xdata$x:00005106                 db 0FFh
.xdata$x:00005107                 db 0FFh
.xdata$x:00005108                 dd offset __unwindfunclet$??1CEventSetEnd@@QAE@XZ$0
.xdata$x:0000510C                 align 10h
.xdata$x:00005110                 dd offset __unwindfunclet$??1CEventSetEnd@@QAE@XZ$1
.xdata$x:00005114                 db    1
.xdata$x:00005115                 db    0
.xdata$x:00005116                 db    0
.xdata$x:00005117                 db    0
.xdata$x:00005118                 dd offset __unwindfunclet$??1CEventSetEnd@@QAE@XZ$2
.xdata$x:0000511C __ehfuncinfo$??1CEventSetEnd@@QAE@XZ db  22h ; "
.xdata$x:0000511C                                         ; DATA XREF: __ehhandler$??1CEventSetEnd@@QAE@XZ+11o
.xdata$x:0000511D                 db    5
.xdata$x:0000511E                 db  93h ; Ã´
.xdata$x:0000511F                 db  19h
.xdata$x:00005120                 db    3
.xdata$x:00005121                 db    0
.xdata$x:00005122                 db    0
.xdata$x:00005123                 db    0
.xdata$x:00005124                 dd offset __unwindtable$??1CEventSetEnd@@QAE@XZ
.xdata$x:00005128                 db    0
.xdata$x:00005129                 db    0
.xdata$x:0000512A                 db    0
.xdata$x:0000512B                 db    0
.xdata$x:0000512C                 db    0
.xdata$x:0000512D                 db    0
.xdata$x:0000512E                 db    0
.xdata$x:0000512F                 db    0
.xdata$x:00005130                 db    0
.xdata$x:00005131                 db    0
.xdata$x:00005132                 db    0
.xdata$x:00005133                 db    0
.xdata$x:00005134                 db    0
.xdata$x:00005135                 db    0
.xdata$x:00005136                 db    0
.xdata$x:00005137                 db    0
.xdata$x:00005138                 db    0
.xdata$x:00005139                 db    0
.xdata$x:0000513A                 db    0
.xdata$x:0000513B                 db    0
.xdata$x:0000513C                 db    1
.xdata$x:0000513D                 db    0
.xdata$x:0000513E                 db    0
.xdata$x:0000513F                 db    0
.xdata$x:0000513F _xdata$x        ends
.xdata$x:0000513F
.text:00005140 ; ===========================================================================
.text:00005140
.text:00005140 ; Segment type: Pure code
.text:00005140 ; Segment permissions: Read/Execute
.text:00005140 _text           segment para public 'CODE' use32
.text:00005140                 assume cs:_text
.text:00005140                 ;org 5140h
.text:00005140 ; COMDAT (pick any)
.text:00005140                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00005140
.text:00005140 ; =============== S U B R O U T I N E =======================================
.text:00005140
.text:00005140 ; Attributes: bp-based frame
.text:00005140
.text:00005140 ; unsigned int __thiscall NWindows::NSynchronization::CBaseEvent::Open(NWindows::NSynchronization::CBaseEvent *this, DWORD dwDesiredAccess, bool, const char *)
.text:00005140                 public ?Open@CBaseEvent@NSynchronization@NWindows@@QAEIK_NPBD@Z
.text:00005140 ?Open@CBaseEvent@NSynchronization@NWindows@@QAEIK_NPBD@Z proc near
.text:00005140                                         ; CODE XREF: CEventSetEnd::~CEventSetEnd(void)+77p
.text:00005140
.text:00005140 var_4           = dword ptr -4
.text:00005140 dwDesiredAccess = dword ptr  8
.text:00005140 arg_4           = byte ptr  0Ch
.text:00005140 lpName          = dword ptr  10h
.text:00005140
.text:00005140                 push    ebp
.text:00005141                 mov     ebp, esp
.text:00005143                 push    ecx
.text:00005144                 push    esi
.text:00005145                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000514C                 mov     [ebp+var_4], ecx
.text:0000514F                 mov     esi, esp
.text:00005151                 mov     eax, [ebp+lpName]
.text:00005154                 push    eax             ; lpName
.text:00005155                 movzx   ecx, [ebp+arg_4]
.text:00005159                 push    ecx             ; bool
.text:0000515A                 call    ?BoolToBOOL@@YGH_N@Z ; BoolToBOOL(bool)
.text:0000515F                 push    eax             ; bInheritHandle
.text:00005160                 mov     edx, [ebp+dwDesiredAccess]
.text:00005163                 push    edx             ; dwDesiredAccess
.text:00005164                 call    dword ptr ds:__imp__OpenEventA@12 ; OpenEventA(x,x,x)
.text:0000516A                 cmp     esi, esp
.text:0000516C                 call    __RTC_CheckEsp
.text:00005171                 mov     ecx, [ebp+var_4]
.text:00005174                 mov     [ecx], eax
.text:00005176                 mov     edx, [ebp+var_4]
.text:00005179                 cmp     dword ptr [edx], 0
.text:0000517C                 jz      short loc_5182
.text:0000517E                 xor     eax, eax
.text:00005180                 jmp     short loc_5191
.text:00005182 ; ---------------------------------------------------------------------------
.text:00005182
.text:00005182 loc_5182:                               ; CODE XREF: NWindows::NSynchronization::CBaseEvent::Open(ulong,bool,char const *)+3Cj
.text:00005182                 mov     esi, esp
.text:00005184                 call    dword ptr ds:__imp__GetLastError@0 ; GetLastError()
.text:0000518A                 cmp     esi, esp
.text:0000518C                 call    __RTC_CheckEsp
.text:00005191
.text:00005191 loc_5191:                               ; CODE XREF: NWindows::NSynchronization::CBaseEvent::Open(ulong,bool,char const *)+40j
.text:00005191                 pop     esi
.text:00005192                 add     esp, 4
.text:00005195                 cmp     ebp, esp
.text:00005197                 call    __RTC_CheckEsp
.text:0000519C                 mov     esp, ebp
.text:0000519E                 pop     ebp
.text:0000519F                 retn    0Ch
.text:0000519F ?Open@CBaseEvent@NSynchronization@NWindows@@QAEIK_NPBD@Z endp
.text:0000519F
.text:0000519F ; ---------------------------------------------------------------------------
.text:000051A2                 align 4
.text:000051A2 _text           ends
.text:000051A2
.text:000051A4 ; ===========================================================================
.text:000051A4
.text:000051A4 ; Segment type: Pure code
.text:000051A4 ; Segment permissions: Read/Execute
.text:000051A4 _text           segment para public 'CODE' use32
.text:000051A4                 assume cs:_text
.text:000051A4                 ;org 51A4h
.text:000051A4 ; COMDAT (pick any)
.text:000051A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000051A4
.text:000051A4 ; =============== S U B R O U T I N E =======================================
.text:000051A4
.text:000051A4 ; Attributes: bp-based frame
.text:000051A4
.text:000051A4 ; int __stdcall BoolToBOOL(bool)
.text:000051A4                 public ?BoolToBOOL@@YGH_N@Z
.text:000051A4 ?BoolToBOOL@@YGH_N@Z proc near          ; CODE XREF: NWindows::NSynchronization::CBaseEvent::Open(ulong,bool,char const *)+1Ap
.text:000051A4
.text:000051A4 arg_0           = byte ptr  8
.text:000051A4
.text:000051A4                 push    ebp
.text:000051A5                 mov     ebp, esp
.text:000051A7                 movzx   eax, [ebp+arg_0]
.text:000051AB                 neg     eax
.text:000051AD                 sbb     eax, eax
.text:000051AF                 neg     eax
.text:000051B1                 pop     ebp
.text:000051B2                 retn    4
.text:000051B2 ?BoolToBOOL@@YGH_N@Z endp
.text:000051B2
.text:000051B2 ; ---------------------------------------------------------------------------
.text:000051B5                 align 4
.text:000051B5 _text           ends
.text:000051B5
.text:000051B8 ; ===========================================================================
.text:000051B8
.text:000051B8 ; Segment type: Pure code
.text:000051B8 ; Segment permissions: Read/Execute
.text:000051B8 _text           segment para public 'CODE' use32
.text:000051B8                 assume cs:_text
.text:000051B8                 ;org 51B8h
.text:000051B8 ; COMDAT (pick any)
.text:000051B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000051B8
.text:000051B8 ; =============== S U B R O U T I N E =======================================
.text:000051B8
.text:000051B8 ; Attributes: bp-based frame
.text:000051B8
.text:000051B8 ; unsigned int __thiscall NWindows::NSynchronization::CBaseEvent::Set(NWindows::NSynchronization::CBaseEvent *__hidden this)
.text:000051B8                 public ?Set@CBaseEvent@NSynchronization@NWindows@@QAEIXZ
.text:000051B8 ?Set@CBaseEvent@NSynchronization@NWindows@@QAEIXZ proc near
.text:000051B8                                         ; CODE XREF: CEventSetEnd::~CEventSetEnd(void)+9Dp
.text:000051B8
.text:000051B8 var_4           = dword ptr -4
.text:000051B8
.text:000051B8                 push    ebp
.text:000051B9                 mov     ebp, esp
.text:000051BB                 push    ecx
.text:000051BC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000051C3                 mov     [ebp+var_4], ecx
.text:000051C6                 mov     eax, [ebp+var_4]
.text:000051C9                 push    eax
.text:000051CA                 call    _Event_Set@4    ; Event_Set(x)
.text:000051CF                 add     esp, 4
.text:000051D2                 cmp     ebp, esp
.text:000051D4                 call    __RTC_CheckEsp
.text:000051D9                 mov     esp, ebp
.text:000051DB                 pop     ebp
.text:000051DC                 retn
.text:000051DC ?Set@CBaseEvent@NSynchronization@NWindows@@QAEIXZ endp
.text:000051DC
.text:000051DC ; ---------------------------------------------------------------------------
.text:000051DD                 align 10h
.text:000051DD _text           ends
.text:000051DD
.text:000051E0 ; ===========================================================================
.text:000051E0
.text:000051E0 ; Segment type: Pure code
.text:000051E0 ; Segment permissions: Read/Execute
.text:000051E0 _text           segment para public 'CODE' use32
.text:000051E0                 assume cs:_text
.text:000051E0                 ;org 51E0h
.text:000051E0 ; COMDAT (pick any)
.text:000051E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000051E0
.text:000051E0 ; =============== S U B R O U T I N E =======================================
.text:000051E0
.text:000051E0 ; Attributes: bp-based frame
.text:000051E0
.text:000051E0 ; _DWORD __thiscall NWindows::NSynchronization::CManualResetEvent::CManualResetEvent(NWindows::NSynchronization::CManualResetEvent *__hidden this)
.text:000051E0                 public ??0CManualResetEvent@NSynchronization@NWindows@@QAE@XZ
.text:000051E0 ??0CManualResetEvent@NSynchronization@NWindows@@QAE@XZ proc near
.text:000051E0                                         ; CODE XREF: CEventSetEnd::~CEventSetEnd(void)+44p
.text:000051E0
.text:000051E0 var_4           = dword ptr -4
.text:000051E0
.text:000051E0                 push    ebp
.text:000051E1                 mov     ebp, esp
.text:000051E3                 push    ecx
.text:000051E4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000051EB                 mov     [ebp+var_4], ecx
.text:000051EE                 mov     ecx, [ebp+var_4] ; this
.text:000051F1                 call    ??0CBaseEvent@NSynchronization@NWindows@@QAE@XZ ; NWindows::NSynchronization::CBaseEvent::CBaseEvent(void)
.text:000051F6                 mov     eax, [ebp+var_4]
.text:000051F9                 add     esp, 4
.text:000051FC                 cmp     ebp, esp
.text:000051FE                 call    __RTC_CheckEsp
.text:00005203                 mov     esp, ebp
.text:00005205                 pop     ebp
.text:00005206                 retn
.text:00005206 ??0CManualResetEvent@NSynchronization@NWindows@@QAE@XZ endp
.text:00005206
.text:00005206 ; ---------------------------------------------------------------------------
.text:00005207                 align 4
.text:00005207 _text           ends
.text:00005207
.text:00005208 ; ===========================================================================
.text:00005208
.text:00005208 ; Segment type: Pure code
.text:00005208 ; Segment permissions: Read/Execute
.text:00005208 _text           segment para public 'CODE' use32
.text:00005208                 assume cs:_text
.text:00005208                 ;org 5208h
.text:00005208 ; COMDAT (pick any)
.text:00005208                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00005208
.text:00005208 ; =============== S U B R O U T I N E =======================================
.text:00005208
.text:00005208 ; Attributes: bp-based frame
.text:00005208
.text:00005208 ; _DWORD __thiscall NWindows::NSynchronization::CBaseEvent::CBaseEvent(NWindows::NSynchronization::CBaseEvent *__hidden this)
.text:00005208                 public ??0CBaseEvent@NSynchronization@NWindows@@QAE@XZ
.text:00005208 ??0CBaseEvent@NSynchronization@NWindows@@QAE@XZ proc near
.text:00005208                                         ; CODE XREF: NWindows::NSynchronization::CManualResetEvent::CManualResetEvent(void)+11p
.text:00005208
.text:00005208 var_4           = dword ptr -4
.text:00005208
.text:00005208                 push    ebp
.text:00005209                 mov     ebp, esp
.text:0000520B                 push    ecx
.text:0000520C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00005213                 mov     [ebp+var_4], ecx
.text:00005216                 mov     eax, [ebp+var_4]
.text:00005219                 mov     dword ptr [eax], 0
.text:0000521F                 mov     eax, [ebp+var_4]
.text:00005222                 mov     esp, ebp
.text:00005224                 pop     ebp
.text:00005225                 retn
.text:00005225 ??0CBaseEvent@NSynchronization@NWindows@@QAE@XZ endp
.text:00005225
.text:00005225 ; ---------------------------------------------------------------------------
.text:00005226                 align 4
.text:00005226 _text           ends
.text:00005226
.text:00005228 ; ===========================================================================
.text:00005228
.text:00005228 ; Segment type: Pure code
.text:00005228 ; Segment permissions: Read/Execute
.text:00005228 _text           segment para public 'CODE' use32
.text:00005228                 assume cs:_text
.text:00005228                 ;org 5228h
.text:00005228 ; COMDAT (pick any)
.text:00005228                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00005228
.text:00005228 ; =============== S U B R O U T I N E =======================================
.text:00005228
.text:00005228 ; Attributes: bp-based frame
.text:00005228
.text:00005228 ; _DWORD __thiscall NWindows::NSynchronization::CManualResetEvent::~CManualResetEvent(NWindows::NSynchronization::CManualResetEvent *__hidden this)
.text:00005228                 public ??1CManualResetEvent@NSynchronization@NWindows@@QAE@XZ
.text:00005228 ??1CManualResetEvent@NSynchronization@NWindows@@QAE@XZ proc near
.text:00005228                                         ; CODE XREF: CEventSetEnd::~CEventSetEnd(void)+A9p
.text:00005228                                         ; __unwindfunclet$??1CEventSetEnd@@QAE@XZ$1+3j
.text:00005228
.text:00005228 var_4           = dword ptr -4
.text:00005228
.text:00005228                 push    ebp
.text:00005229                 mov     ebp, esp
.text:0000522B                 push    ecx
.text:0000522C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00005233                 mov     [ebp+var_4], ecx
.text:00005236                 mov     ecx, [ebp+var_4] ; this
.text:00005239                 call    ??1CBaseEvent@NSynchronization@NWindows@@QAE@XZ ; NWindows::NSynchronization::CBaseEvent::~CBaseEvent(void)
.text:0000523E                 add     esp, 4
.text:00005241                 cmp     ebp, esp
.text:00005243                 call    __RTC_CheckEsp
.text:00005248                 mov     esp, ebp
.text:0000524A                 pop     ebp
.text:0000524B                 retn
.text:0000524B ??1CManualResetEvent@NSynchronization@NWindows@@QAE@XZ endp
.text:0000524B
.text:0000524B _text           ends
.text:0000524B
.text:0000524C ; ===========================================================================
.text:0000524C
.text:0000524C ; Segment type: Pure code
.text:0000524C ; Segment permissions: Read/Execute
.text:0000524C _text           segment para public 'CODE' use32
.text:0000524C                 assume cs:_text
.text:0000524C                 ;org 524Ch
.text:0000524C ; COMDAT (pick any)
.text:0000524C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000524C
.text:0000524C ; =============== S U B R O U T I N E =======================================
.text:0000524C
.text:0000524C ; Attributes: bp-based frame
.text:0000524C
.text:0000524C ; _DWORD __thiscall NWindows::NSynchronization::CBaseEvent::~CBaseEvent(NWindows::NSynchronization::CBaseEvent *__hidden this)
.text:0000524C                 public ??1CBaseEvent@NSynchronization@NWindows@@QAE@XZ
.text:0000524C ??1CBaseEvent@NSynchronization@NWindows@@QAE@XZ proc near
.text:0000524C                                         ; CODE XREF: NWindows::NSynchronization::CManualResetEvent::~CManualResetEvent(void)+11p
.text:0000524C
.text:0000524C var_4           = dword ptr -4
.text:0000524C
.text:0000524C                 push    ebp
.text:0000524D                 mov     ebp, esp
.text:0000524F                 push    ecx
.text:00005250                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00005257                 mov     [ebp+var_4], ecx
.text:0000525A                 mov     ecx, [ebp+var_4] ; this
.text:0000525D                 call    ?Close@CBaseEvent@NSynchronization@NWindows@@QAEIXZ ; NWindows::NSynchronization::CBaseEvent::Close(void)
.text:00005262                 add     esp, 4
.text:00005265                 cmp     ebp, esp
.text:00005267                 call    __RTC_CheckEsp
.text:0000526C                 mov     esp, ebp
.text:0000526E                 pop     ebp
.text:0000526F                 retn
.text:0000526F ??1CBaseEvent@NSynchronization@NWindows@@QAE@XZ endp
.text:0000526F
.text:0000526F _text           ends
.text:0000526F
.text:00005270 ; ===========================================================================
.text:00005270
.text:00005270 ; Segment type: Pure code
.text:00005270 ; Segment permissions: Read/Execute
.text:00005270 _text           segment para public 'CODE' use32
.text:00005270                 assume cs:_text
.text:00005270                 ;org 5270h
.text:00005270 ; COMDAT (pick any)
.text:00005270                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00005270
.text:00005270 ; =============== S U B R O U T I N E =======================================
.text:00005270
.text:00005270 ; Attributes: bp-based frame
.text:00005270
.text:00005270 ; unsigned int __thiscall NWindows::NSynchronization::CBaseEvent::Close(NWindows::NSynchronization::CBaseEvent *__hidden this)
.text:00005270                 public ?Close@CBaseEvent@NSynchronization@NWindows@@QAEIXZ
.text:00005270 ?Close@CBaseEvent@NSynchronization@NWindows@@QAEIXZ proc near
.text:00005270                                         ; CODE XREF: NWindows::NSynchronization::CBaseEvent::~CBaseEvent(void)+11p
.text:00005270
.text:00005270 var_4           = dword ptr -4
.text:00005270
.text:00005270                 push    ebp
.text:00005271                 mov     ebp, esp
.text:00005273                 push    ecx
.text:00005274                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000527B                 mov     [ebp+var_4], ecx
.text:0000527E                 mov     eax, [ebp+var_4]
.text:00005281                 push    eax
.text:00005282                 call    _HandlePtr_Close@4 ; HandlePtr_Close(x)
.text:00005287                 add     esp, 4
.text:0000528A                 cmp     ebp, esp
.text:0000528C                 call    __RTC_CheckEsp
.text:00005291                 mov     esp, ebp
.text:00005293                 pop     ebp
.text:00005294                 retn
.text:00005294 ?Close@CBaseEvent@NSynchronization@NWindows@@QAEIXZ endp
.text:00005294
.text:00005294 ; ---------------------------------------------------------------------------
.text:00005295                 align 4
.text:00005295 _text           ends
.text:00005295
.text:00005298 ; ===========================================================================
.text:00005298
.text:00005298 ; Segment type: Pure code
.text:00005298 ; Segment permissions: Read/Execute
.text:00005298 _text           segment para public 'CODE' use32
.text:00005298                 assume cs:_text
.text:00005298                 ;org 5298h
.text:00005298 ; COMDAT (pick any)
.text:00005298                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00005298
.text:00005298 ; =============== S U B R O U T I N E =======================================
.text:00005298
.text:00005298 ; Attributes: bp-based frame
.text:00005298
.text:00005298 ; _DWORD __thiscall NWindows::CFileMapping::CFileMapping(NWindows::CFileMapping *__hidden this)
.text:00005298                 public ??0CFileMapping@NWindows@@QAE@XZ
.text:00005298 ??0CFileMapping@NWindows@@QAE@XZ proc near
.text:00005298                                         ; CODE XREF: ParseMapWithPaths(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)+16Cp
.text:00005298
.text:00005298 var_4           = dword ptr -4
.text:00005298
.text:00005298                 push    ebp
.text:00005299                 mov     ebp, esp
.text:0000529B                 push    ecx
.text:0000529C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000052A3                 mov     [ebp+var_4], ecx
.text:000052A6                 mov     ecx, [ebp+var_4] ; this
.text:000052A9                 call    ??0CHandle@NWindows@@QAE@XZ ; NWindows::CHandle::CHandle(void)
.text:000052AE                 mov     eax, [ebp+var_4]
.text:000052B1                 add     esp, 4
.text:000052B4                 cmp     ebp, esp
.text:000052B6                 call    __RTC_CheckEsp
.text:000052BB                 mov     esp, ebp
.text:000052BD                 pop     ebp
.text:000052BE                 retn
.text:000052BE ??0CFileMapping@NWindows@@QAE@XZ endp
.text:000052BE
.text:000052BE ; ---------------------------------------------------------------------------
.text:000052BF                 align 10h
.text:000052BF _text           ends
.text:000052BF
.text:000052C0 ; ===========================================================================
.text:000052C0
.text:000052C0 ; Segment type: Pure code
.text:000052C0 ; Segment permissions: Read/Execute
.text:000052C0 _text           segment para public 'CODE' use32
.text:000052C0                 assume cs:_text
.text:000052C0                 ;org 52C0h
.text:000052C0 ; COMDAT (pick any)
.text:000052C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000052C0
.text:000052C0 ; =============== S U B R O U T I N E =======================================
.text:000052C0
.text:000052C0 ; Attributes: bp-based frame
.text:000052C0
.text:000052C0 ; _DWORD __thiscall NWindows::CHandle::CHandle(NWindows::CHandle *__hidden this)
.text:000052C0                 public ??0CHandle@NWindows@@QAE@XZ
.text:000052C0 ??0CHandle@NWindows@@QAE@XZ proc near   ; CODE XREF: NWindows::CFileMapping::CFileMapping(void)+11p
.text:000052C0
.text:000052C0 var_4           = dword ptr -4
.text:000052C0
.text:000052C0                 push    ebp
.text:000052C1                 mov     ebp, esp
.text:000052C3                 push    ecx
.text:000052C4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000052CB                 mov     [ebp+var_4], ecx
.text:000052CE                 mov     eax, [ebp+var_4]
.text:000052D1                 mov     dword ptr [eax], 0
.text:000052D7                 mov     eax, [ebp+var_4]
.text:000052DA                 mov     esp, ebp
.text:000052DC                 pop     ebp
.text:000052DD                 retn
.text:000052DD ??0CHandle@NWindows@@QAE@XZ endp
.text:000052DD
.text:000052DD ; ---------------------------------------------------------------------------
.text:000052DE                 align 10h
.text:000052DE _text           ends
.text:000052DE
.text:000052E0 ; ===========================================================================
.text:000052E0
.text:000052E0 ; Segment type: Pure code
.text:000052E0 ; Segment permissions: Read/Execute
.text:000052E0 _text           segment para public 'CODE' use32
.text:000052E0                 assume cs:_text
.text:000052E0                 ;org 52E0h
.text:000052E0 ; COMDAT (pick any)
.text:000052E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000052E0
.text:000052E0 ; =============== S U B R O U T I N E =======================================
.text:000052E0
.text:000052E0 ; Attributes: bp-based frame
.text:000052E0
.text:000052E0 ; _DWORD __thiscall NWindows::CFileMapping::~CFileMapping(NWindows::CFileMapping *__hidden this)
.text:000052E0                 public ??1CFileMapping@NWindows@@QAE@XZ
.text:000052E0 ??1CFileMapping@NWindows@@QAE@XZ proc near
.text:000052E0                                         ; CODE XREF: ParseMapWithPaths(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)+1E8p
.text:000052E0                                         ; ParseMapWithPaths(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)+23Fp ...
.text:000052E0
.text:000052E0 var_4           = dword ptr -4
.text:000052E0
.text:000052E0                 push    ebp
.text:000052E1                 mov     ebp, esp
.text:000052E3                 push    ecx
.text:000052E4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000052EB                 mov     [ebp+var_4], ecx
.text:000052EE                 mov     ecx, [ebp+var_4] ; this
.text:000052F1                 call    ??1CHandle@NWindows@@QAE@XZ ; NWindows::CHandle::~CHandle(void)
.text:000052F6                 add     esp, 4
.text:000052F9                 cmp     ebp, esp
.text:000052FB                 call    __RTC_CheckEsp
.text:00005300                 mov     esp, ebp
.text:00005302                 pop     ebp
.text:00005303                 retn
.text:00005303 ??1CFileMapping@NWindows@@QAE@XZ endp
.text:00005303
.text:00005303 _text           ends
.text:00005303
.text:00005304 ; ===========================================================================
.text:00005304
.text:00005304 ; Segment type: Pure code
.text:00005304 ; Segment permissions: Read/Execute
.text:00005304 _text           segment para public 'CODE' use32
.text:00005304                 assume cs:_text
.text:00005304                 ;org 5304h
.text:00005304 ; COMDAT (pick any)
.text:00005304                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00005304
.text:00005304 ; =============== S U B R O U T I N E =======================================
.text:00005304
.text:00005304 ; Attributes: bp-based frame
.text:00005304
.text:00005304 ; _DWORD __thiscall NWindows::CHandle::~CHandle(NWindows::CHandle *__hidden this)
.text:00005304                 public ??1CHandle@NWindows@@QAE@XZ
.text:00005304 ??1CHandle@NWindows@@QAE@XZ proc near   ; CODE XREF: NWindows::CFileMapping::~CFileMapping(void)+11p
.text:00005304
.text:00005304 var_4           = dword ptr -4
.text:00005304
.text:00005304                 push    ebp
.text:00005305                 mov     ebp, esp
.text:00005307                 push    ecx
.text:00005308                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000530F                 mov     [ebp+var_4], ecx
.text:00005312                 mov     ecx, [ebp+var_4] ; this
.text:00005315                 call    ?Close@CHandle@NWindows@@QAE_NXZ ; NWindows::CHandle::Close(void)
.text:0000531A                 add     esp, 4
.text:0000531D                 cmp     ebp, esp
.text:0000531F                 call    __RTC_CheckEsp
.text:00005324                 mov     esp, ebp
.text:00005326                 pop     ebp
.text:00005327                 retn
.text:00005327 ??1CHandle@NWindows@@QAE@XZ endp
.text:00005327
.text:00005327 _text           ends
.text:00005327
.text:00005328 ; ===========================================================================
.text:00005328
.text:00005328 ; Segment type: Pure code
.text:00005328 ; Segment permissions: Read/Execute
.text:00005328 _text           segment para public 'CODE' use32
.text:00005328                 assume cs:_text
.text:00005328                 ;org 5328h
.text:00005328 ; COMDAT (pick any)
.text:00005328                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00005328
.text:00005328 ; =============== S U B R O U T I N E =======================================
.text:00005328
.text:00005328 ; Attributes: bp-based frame
.text:00005328
.text:00005328 ; bool __thiscall NWindows::CHandle::Close(NWindows::CHandle *__hidden this)
.text:00005328                 public ?Close@CHandle@NWindows@@QAE_NXZ
.text:00005328 ?Close@CHandle@NWindows@@QAE_NXZ proc near
.text:00005328                                         ; CODE XREF: NWindows::CHandle::~CHandle(void)+11p
.text:00005328
.text:00005328 var_4           = dword ptr -4
.text:00005328
.text:00005328                 push    ebp
.text:00005329                 mov     ebp, esp
.text:0000532B                 push    ecx
.text:0000532C                 push    esi
.text:0000532D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00005334                 mov     [ebp+var_4], ecx
.text:00005337                 mov     eax, [ebp+var_4]
.text:0000533A                 cmp     dword ptr [eax], 0
.text:0000533D                 jnz     short loc_5343
.text:0000533F                 mov     al, 1
.text:00005341                 jmp     short loc_536B
.text:00005343 ; ---------------------------------------------------------------------------
.text:00005343
.text:00005343 loc_5343:                               ; CODE XREF: NWindows::CHandle::Close(void)+15j
.text:00005343                 mov     esi, esp
.text:00005345                 mov     ecx, [ebp+var_4]
.text:00005348                 mov     edx, [ecx]
.text:0000534A                 push    edx             ; hObject
.text:0000534B                 call    dword ptr ds:__imp__CloseHandle@4 ; CloseHandle(x)
.text:00005351                 cmp     esi, esp
.text:00005353                 call    __RTC_CheckEsp
.text:00005358                 test    eax, eax
.text:0000535A                 jnz     short loc_5360
.text:0000535C                 xor     al, al
.text:0000535E                 jmp     short loc_536B
.text:00005360 ; ---------------------------------------------------------------------------
.text:00005360
.text:00005360 loc_5360:                               ; CODE XREF: NWindows::CHandle::Close(void)+32j
.text:00005360                 mov     eax, [ebp+var_4]
.text:00005363                 mov     dword ptr [eax], 0
.text:00005369                 mov     al, 1
.text:0000536B
.text:0000536B loc_536B:                               ; CODE XREF: NWindows::CHandle::Close(void)+19j
.text:0000536B                                         ; NWindows::CHandle::Close(void)+36j
.text:0000536B                 pop     esi
.text:0000536C                 add     esp, 4
.text:0000536F                 cmp     ebp, esp
.text:00005371                 call    __RTC_CheckEsp
.text:00005376                 mov     esp, ebp
.text:00005378                 pop     ebp
.text:00005379                 retn
.text:00005379 ?Close@CHandle@NWindows@@QAE_NXZ endp
.text:00005379
.text:00005379 ; ---------------------------------------------------------------------------
.text:0000537A                 align 4
.text:0000537A _text           ends
.text:0000537A
.text:0000537C ; ===========================================================================
.text:0000537C
.text:0000537C ; Segment type: Pure code
.text:0000537C ; Segment permissions: Read/Execute
.text:0000537C _text           segment para public 'CODE' use32
.text:0000537C                 assume cs:_text
.text:0000537C                 ;org 537Ch
.text:0000537C ; COMDAT (pick any)
.text:0000537C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000537C
.text:0000537C ; =============== S U B R O U T I N E =======================================
.text:0000537C
.text:0000537C ; Attributes: bp-based frame
.text:0000537C
.text:0000537C ; _DWORD __thiscall CUpdateArchiveCommand::CUpdateArchiveCommand(CUpdateArchiveCommand *__hidden this)
.text:0000537C                 public ??0CUpdateArchiveCommand@@QAE@XZ
.text:0000537C ??0CUpdateArchiveCommand@@QAE@XZ proc near
.text:0000537C                                         ; CODE XREF: SetAddCommandOptions(NCommandType::EEnum,NCommandLineParser::CParser const &,CUpdateOptions &)+A5p
.text:0000537C                                         ; ParseUpdateCommandString(CUpdateOptions &,CObjectVector<UString> const &,NUpdateArchive::CActionSet const &)+15Fp
.text:0000537C
.text:0000537C var_10          = dword ptr -10h
.text:0000537C var_C           = dword ptr -0Ch
.text:0000537C var_4           = dword ptr -4
.text:0000537C
.text:0000537C                 push    ebp
.text:0000537D                 mov     ebp, esp
.text:0000537F                 push    0FFFFFFFFh
.text:00005381                 push    offset __ehhandler$??0CUpdateArchiveCommand@@QAE@XZ
.text:00005386                 mov     eax, large fs:0
.text:0000538C                 push    eax
.text:0000538D                 push    ecx
.text:0000538E                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00005395                 mov     eax, dword ptr ds:___security_cookie
.text:0000539A                 xor     eax, ebp
.text:0000539C                 push    eax
.text:0000539D                 lea     eax, [ebp+var_C]
.text:000053A0                 mov     large fs:0, eax
.text:000053A6                 mov     [ebp+var_10], ecx
.text:000053A9                 mov     ecx, [ebp+var_10]
.text:000053AC                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:000053B1                 mov     [ebp+var_4], 0
.text:000053B8                 mov     ecx, [ebp+var_10]
.text:000053BB                 add     ecx, 0Ch        ; this
.text:000053BE                 call    ??0CArchivePath@@QAE@XZ ; CArchivePath::CArchivePath(void)
.text:000053C3                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000053CA                 mov     eax, [ebp+var_10]
.text:000053CD                 mov     ecx, [ebp+var_C]
.text:000053D0                 mov     large fs:0, ecx
.text:000053D7                 pop     ecx
.text:000053D8                 add     esp, 10h
.text:000053DB                 cmp     ebp, esp
.text:000053DD                 call    __RTC_CheckEsp
.text:000053E2                 mov     esp, ebp
.text:000053E4                 pop     ebp
.text:000053E5                 retn
.text:000053E5 ??0CUpdateArchiveCommand@@QAE@XZ endp
.text:000053E5
.text:000053E5 ; ---------------------------------------------------------------------------
.text:000053E6                 align 4
.text:000053E6 _text           ends
.text:000053E6
.text$x:000053E8 ; ===========================================================================
.text$x:000053E8
.text$x:000053E8 ; Segment type: Pure code
.text$x:000053E8 ; Segment permissions: Read/Execute
.text$x:000053E8 _text$x         segment para public 'CODE' use32
.text$x:000053E8                 assume cs:_text$x
.text$x:000053E8                 ;org 53E8h
.text$x:000053E8 ; COMDAT (pick associative to section at 537C)
.text$x:000053E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000053E8
.text$x:000053E8 ; =============== S U B R O U T I N E =======================================
.text$x:000053E8
.text$x:000053E8
.text$x:000053E8 __unwindfunclet$??0CUpdateArchiveCommand@@QAE@XZ$0 proc near
.text$x:000053E8                                         ; DATA XREF: .xdata$x:00005410o
.text$x:000053E8                 mov     ecx, [ebp-10h]  ; this
.text$x:000053EB                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000053EB __unwindfunclet$??0CUpdateArchiveCommand@@QAE@XZ$0 endp
.text$x:000053EB
.text$x:000053F0
.text$x:000053F0 ; =============== S U B R O U T I N E =======================================
.text$x:000053F0
.text$x:000053F0
.text$x:000053F0 __ehhandler$??0CUpdateArchiveCommand@@QAE@XZ proc near
.text$x:000053F0                                         ; DATA XREF: CUpdateArchiveCommand::CUpdateArchiveCommand(void)+5o
.text$x:000053F0
.text$x:000053F0 arg_4           = dword ptr  8
.text$x:000053F0
.text$x:000053F0                 mov     edx, [esp+arg_4]
.text$x:000053F4                 lea     eax, [edx+0Ch]
.text$x:000053F7                 mov     ecx, [edx-8]
.text$x:000053FA                 xor     ecx, eax
.text$x:000053FC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005401                 mov     eax, offset __ehfuncinfo$??0CUpdateArchiveCommand@@QAE@XZ
.text$x:00005406                 jmp     ___CxxFrameHandler3
.text$x:00005406 __ehhandler$??0CUpdateArchiveCommand@@QAE@XZ endp
.text$x:00005406
.text$x:00005406 ; ---------------------------------------------------------------------------
.text$x:0000540B                 align 4
.text$x:0000540B _text$x         ends
.text$x:0000540B
.xdata$x:0000540C ; ===========================================================================
.xdata$x:0000540C
.xdata$x:0000540C ; Segment type: Pure data
.xdata$x:0000540C ; Segment permissions: Read
.xdata$x:0000540C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000540C                 assume cs:_xdata$x
.xdata$x:0000540C                 ;org 540Ch
.xdata$x:0000540C ; COMDAT (pick associative to section at 537C)
.xdata$x:0000540C __unwindtable$??0CUpdateArchiveCommand@@QAE@XZ db 0FFh
.xdata$x:0000540C                                         ; DATA XREF: .xdata$x:0000541Co
.xdata$x:0000540D                 db 0FFh
.xdata$x:0000540E                 db 0FFh
.xdata$x:0000540F                 db 0FFh
.xdata$x:00005410                 dd offset __unwindfunclet$??0CUpdateArchiveCommand@@QAE@XZ$0
.xdata$x:00005414 __ehfuncinfo$??0CUpdateArchiveCommand@@QAE@XZ db  22h ; "
.xdata$x:00005414                                         ; DATA XREF: __ehhandler$??0CUpdateArchiveCommand@@QAE@XZ+11o
.xdata$x:00005415                 db    5
.xdata$x:00005416                 db  93h ; Ã´
.xdata$x:00005417                 db  19h
.xdata$x:00005418                 db    1
.xdata$x:00005419                 db    0
.xdata$x:0000541A                 db    0
.xdata$x:0000541B                 db    0
.xdata$x:0000541C                 dd offset __unwindtable$??0CUpdateArchiveCommand@@QAE@XZ
.xdata$x:00005420                 db    0
.xdata$x:00005421                 db    0
.xdata$x:00005422                 db    0
.xdata$x:00005423                 db    0
.xdata$x:00005424                 db    0
.xdata$x:00005425                 db    0
.xdata$x:00005426                 db    0
.xdata$x:00005427                 db    0
.xdata$x:00005428                 db    0
.xdata$x:00005429                 db    0
.xdata$x:0000542A                 db    0
.xdata$x:0000542B                 db    0
.xdata$x:0000542C                 db    0
.xdata$x:0000542D                 db    0
.xdata$x:0000542E                 db    0
.xdata$x:0000542F                 db    0
.xdata$x:00005430                 db    0
.xdata$x:00005431                 db    0
.xdata$x:00005432                 db    0
.xdata$x:00005433                 db    0
.xdata$x:00005434                 db    1
.xdata$x:00005435                 db    0
.xdata$x:00005436                 db    0
.xdata$x:00005437                 db    0
.xdata$x:00005437 _xdata$x        ends
.xdata$x:00005437
.text:00005438 ; ===========================================================================
.text:00005438
.text:00005438 ; Segment type: Pure code
.text:00005438 ; Segment permissions: Read/Execute
.text:00005438 _text           segment para public 'CODE' use32
.text:00005438                 assume cs:_text
.text:00005438                 ;org 5438h
.text:00005438 ; COMDAT (pick any)
.text:00005438                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00005438
.text:00005438 ; =============== S U B R O U T I N E =======================================
.text:00005438
.text:00005438 ; Attributes: bp-based frame
.text:00005438
.text:00005438 ; _DWORD __thiscall CArchivePath::CArchivePath(CArchivePath *__hidden this)
.text:00005438                 public ??0CArchivePath@@QAE@XZ
.text:00005438 ??0CArchivePath@@QAE@XZ proc near       ; CODE XREF: CUpdateArchiveCommand::CUpdateArchiveCommand(void)+42p
.text:00005438
.text:00005438 var_10          = dword ptr -10h
.text:00005438 var_C           = dword ptr -0Ch
.text:00005438 var_4           = dword ptr -4
.text:00005438
.text:00005438                 push    ebp
.text:00005439                 mov     ebp, esp
.text:0000543B                 push    0FFFFFFFFh
.text:0000543D                 push    offset __ehhandler$??0CArchivePath@@QAE@XZ
.text:00005442                 mov     eax, large fs:0
.text:00005448                 push    eax
.text:00005449                 push    ecx
.text:0000544A                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00005451                 mov     eax, dword ptr ds:___security_cookie
.text:00005456                 xor     eax, ebp
.text:00005458                 push    eax
.text:00005459                 lea     eax, [ebp+var_C]
.text:0000545C                 mov     large fs:0, eax
.text:00005462                 mov     [ebp+var_10], ecx
.text:00005465                 mov     ecx, [ebp+var_10]
.text:00005468                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:0000546D                 mov     [ebp+var_4], 0
.text:00005474                 mov     ecx, [ebp+var_10]
.text:00005477                 add     ecx, 0Ch
.text:0000547A                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:0000547F                 mov     byte ptr [ebp+var_4], 1
.text:00005483                 mov     ecx, [ebp+var_10]
.text:00005486                 add     ecx, 18h
.text:00005489                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:0000548E                 mov     byte ptr [ebp+var_4], 2
.text:00005492                 mov     ecx, [ebp+var_10]
.text:00005495                 add     ecx, 24h ; '$'
.text:00005498                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:0000549D                 mov     byte ptr [ebp+var_4], 3
.text:000054A1                 mov     ecx, [ebp+var_10]
.text:000054A4                 add     ecx, 30h ; '0'
.text:000054A7                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:000054AC                 mov     byte ptr [ebp+var_4], 4
.text:000054B0                 mov     eax, [ebp+var_10]
.text:000054B3                 mov     byte ptr [eax+3Ch], 0
.text:000054B7                 mov     ecx, [ebp+var_10]
.text:000054BA                 add     ecx, 40h ; '@'
.text:000054BD                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:000054C2                 mov     byte ptr [ebp+var_4], 5
.text:000054C6                 mov     ecx, [ebp+var_10]
.text:000054C9                 add     ecx, 4Ch ; 'L'
.text:000054CC                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:000054D1                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000054D8                 mov     eax, [ebp+var_10]
.text:000054DB                 mov     ecx, [ebp+var_C]
.text:000054DE                 mov     large fs:0, ecx
.text:000054E5                 pop     ecx
.text:000054E6                 add     esp, 10h
.text:000054E9                 cmp     ebp, esp
.text:000054EB                 call    __RTC_CheckEsp
.text:000054F0                 mov     esp, ebp
.text:000054F2                 pop     ebp
.text:000054F3                 retn
.text:000054F3 ??0CArchivePath@@QAE@XZ endp
.text:000054F3
.text:000054F3 _text           ends
.text:000054F3
.text$x:000054F4 ; ===========================================================================
.text$x:000054F4
.text$x:000054F4 ; Segment type: Pure code
.text$x:000054F4 ; Segment permissions: Read/Execute
.text$x:000054F4 _text$x         segment para public 'CODE' use32
.text$x:000054F4                 assume cs:_text$x
.text$x:000054F4                 ;org 54F4h
.text$x:000054F4 ; COMDAT (pick associative to section at 5438)
.text$x:000054F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000054F4
.text$x:000054F4 ; =============== S U B R O U T I N E =======================================
.text$x:000054F4
.text$x:000054F4
.text$x:000054F4 __unwindfunclet$??0CArchivePath@@QAE@XZ$0 proc near
.text$x:000054F4                                         ; DATA XREF: .xdata$x:00005578o
.text$x:000054F4                 mov     ecx, [ebp-10h]  ; this
.text$x:000054F7                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000054F7 __unwindfunclet$??0CArchivePath@@QAE@XZ$0 endp
.text$x:000054F7
.text$x:000054FC
.text$x:000054FC ; =============== S U B R O U T I N E =======================================
.text$x:000054FC
.text$x:000054FC
.text$x:000054FC __unwindfunclet$??0CArchivePath@@QAE@XZ$1 proc near
.text$x:000054FC                                         ; DATA XREF: .xdata$x:00005580o
.text$x:000054FC                 mov     ecx, [ebp-10h]
.text$x:000054FF                 add     ecx, 0Ch        ; this
.text$x:00005502                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00005502 __unwindfunclet$??0CArchivePath@@QAE@XZ$1 endp
.text$x:00005502
.text$x:00005507
.text$x:00005507 ; =============== S U B R O U T I N E =======================================
.text$x:00005507
.text$x:00005507
.text$x:00005507 __unwindfunclet$??0CArchivePath@@QAE@XZ$2 proc near
.text$x:00005507                                         ; DATA XREF: .xdata$x:00005588o
.text$x:00005507                 mov     ecx, [ebp-10h]
.text$x:0000550A                 add     ecx, 18h        ; this
.text$x:0000550D                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:0000550D __unwindfunclet$??0CArchivePath@@QAE@XZ$2 endp
.text$x:0000550D
.text$x:00005512
.text$x:00005512 ; =============== S U B R O U T I N E =======================================
.text$x:00005512
.text$x:00005512
.text$x:00005512 __unwindfunclet$??0CArchivePath@@QAE@XZ$3 proc near
.text$x:00005512                                         ; DATA XREF: .xdata$x:00005590o
.text$x:00005512                 mov     ecx, [ebp-10h]
.text$x:00005515                 add     ecx, 24h ; '$'  ; this
.text$x:00005518                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00005518 __unwindfunclet$??0CArchivePath@@QAE@XZ$3 endp
.text$x:00005518
.text$x:0000551D
.text$x:0000551D ; =============== S U B R O U T I N E =======================================
.text$x:0000551D
.text$x:0000551D
.text$x:0000551D __unwindfunclet$??0CArchivePath@@QAE@XZ$4 proc near
.text$x:0000551D                                         ; DATA XREF: .xdata$x:00005598o
.text$x:0000551D                 mov     ecx, [ebp-10h]
.text$x:00005520                 add     ecx, 30h ; '0'  ; this
.text$x:00005523                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00005523 __unwindfunclet$??0CArchivePath@@QAE@XZ$4 endp
.text$x:00005523
.text$x:00005528
.text$x:00005528 ; =============== S U B R O U T I N E =======================================
.text$x:00005528
.text$x:00005528
.text$x:00005528 __unwindfunclet$??0CArchivePath@@QAE@XZ$5 proc near
.text$x:00005528                                         ; DATA XREF: .xdata$x:000055A0o
.text$x:00005528                 mov     ecx, [ebp-10h]
.text$x:0000552B                 add     ecx, 40h ; '@'  ; this
.text$x:0000552E                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:0000552E __unwindfunclet$??0CArchivePath@@QAE@XZ$5 endp
.text$x:0000552E
.text$x:00005533
.text$x:00005533 ; =============== S U B R O U T I N E =======================================
.text$x:00005533
.text$x:00005533
.text$x:00005533 __ehhandler$??0CArchivePath@@QAE@XZ proc near
.text$x:00005533                                         ; DATA XREF: CArchivePath::CArchivePath(void)+5o
.text$x:00005533
.text$x:00005533 arg_4           = dword ptr  8
.text$x:00005533
.text$x:00005533                 mov     edx, [esp+arg_4]
.text$x:00005537                 lea     eax, [edx+0Ch]
.text$x:0000553A                 mov     ecx, [edx-8]
.text$x:0000553D                 xor     ecx, eax
.text$x:0000553F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005544                 mov     eax, offset __ehfuncinfo$??0CArchivePath@@QAE@XZ
.text$x:00005549                 jmp     ___CxxFrameHandler3
.text$x:00005549 __ehhandler$??0CArchivePath@@QAE@XZ endp
.text$x:00005549
.text$x:00005549 ; ---------------------------------------------------------------------------
.text$x:0000554E                 align 10h
.text$x:0000554E _text$x         ends
.text$x:0000554E
.xdata$x:00005550 ; ===========================================================================
.xdata$x:00005550
.xdata$x:00005550 ; Segment type: Pure data
.xdata$x:00005550 ; Segment permissions: Read
.xdata$x:00005550 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005550                 assume cs:_xdata$x
.xdata$x:00005550                 ;org 5550h
.xdata$x:00005550 ; COMDAT (pick associative to section at 5438)
.xdata$x:00005550 __ehfuncinfo$??0CArchivePath@@QAE@XZ db  22h ; "
.xdata$x:00005550                                         ; DATA XREF: __ehhandler$??0CArchivePath@@QAE@XZ+11o
.xdata$x:00005551                 db    5
.xdata$x:00005552                 db  93h ; Ã´
.xdata$x:00005553                 db  19h
.xdata$x:00005554                 db    6
.xdata$x:00005555                 db    0
.xdata$x:00005556                 db    0
.xdata$x:00005557                 db    0
.xdata$x:00005558                 dd offset __unwindtable$??0CArchivePath@@QAE@XZ
.xdata$x:0000555C                 db    0
.xdata$x:0000555D                 db    0
.xdata$x:0000555E                 db    0
.xdata$x:0000555F                 db    0
.xdata$x:00005560                 db    0
.xdata$x:00005561                 db    0
.xdata$x:00005562                 db    0
.xdata$x:00005563                 db    0
.xdata$x:00005564                 db    0
.xdata$x:00005565                 db    0
.xdata$x:00005566                 db    0
.xdata$x:00005567                 db    0
.xdata$x:00005568                 db    0
.xdata$x:00005569                 db    0
.xdata$x:0000556A                 db    0
.xdata$x:0000556B                 db    0
.xdata$x:0000556C                 db    0
.xdata$x:0000556D                 db    0
.xdata$x:0000556E                 db    0
.xdata$x:0000556F                 db    0
.xdata$x:00005570                 db    1
.xdata$x:00005571                 db    0
.xdata$x:00005572                 db    0
.xdata$x:00005573                 db    0
.xdata$x:00005574 __unwindtable$??0CArchivePath@@QAE@XZ db 0FFh
.xdata$x:00005574                                         ; DATA XREF: .xdata$x:00005558o
.xdata$x:00005575                 db 0FFh
.xdata$x:00005576                 db 0FFh
.xdata$x:00005577                 db 0FFh
.xdata$x:00005578                 dd offset __unwindfunclet$??0CArchivePath@@QAE@XZ$0
.xdata$x:0000557C                 align 10h
.xdata$x:00005580                 dd offset __unwindfunclet$??0CArchivePath@@QAE@XZ$1
.xdata$x:00005584                 db    1
.xdata$x:00005585                 db    0
.xdata$x:00005586                 db    0
.xdata$x:00005587                 db    0
.xdata$x:00005588                 dd offset __unwindfunclet$??0CArchivePath@@QAE@XZ$2
.xdata$x:0000558C                 db    2
.xdata$x:0000558D                 db    0
.xdata$x:0000558E                 db    0
.xdata$x:0000558F                 db    0
.xdata$x:00005590                 dd offset __unwindfunclet$??0CArchivePath@@QAE@XZ$3
.xdata$x:00005594                 db    3
.xdata$x:00005595                 db    0
.xdata$x:00005596                 db    0
.xdata$x:00005597                 db    0
.xdata$x:00005598                 dd offset __unwindfunclet$??0CArchivePath@@QAE@XZ$4
.xdata$x:0000559C                 db    4
.xdata$x:0000559D                 db    0
.xdata$x:0000559E                 db    0
.xdata$x:0000559F                 db    0
.xdata$x:000055A0                 dd offset __unwindfunclet$??0CArchivePath@@QAE@XZ$5
.xdata$x:000055A0 _xdata$x        ends
.xdata$x:000055A0
.text:000055A4 ; ===========================================================================
.text:000055A4
.text:000055A4 ; Segment type: Pure code
.text:000055A4 ; Segment permissions: Read/Execute
.text:000055A4 _text           segment para public 'CODE' use32
.text:000055A4                 assume cs:_text
.text:000055A4                 ;org 55A4h
.text:000055A4 ; COMDAT (pick any)
.text:000055A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000055A4
.text:000055A4 ; =============== S U B R O U T I N E =======================================
.text:000055A4
.text:000055A4 ; Attributes: bp-based frame
.text:000055A4
.text:000055A4 ; _DWORD __thiscall CUpdateArchiveCommand::~CUpdateArchiveCommand(CUpdateArchiveCommand *__hidden this)
.text:000055A4                 public ??1CUpdateArchiveCommand@@QAE@XZ
.text:000055A4 ??1CUpdateArchiveCommand@@QAE@XZ proc near
.text:000055A4                                         ; CODE XREF: SetAddCommandOptions(NCommandType::EEnum,NCommandLineParser::CParser const &,CUpdateOptions &)+2A7p
.text:000055A4                                         ; ParseUpdateCommandString(CUpdateOptions &,CObjectVector<UString> const &,NUpdateArchive::CActionSet const &)+1ADp ...
.text:000055A4
.text:000055A4 var_10          = dword ptr -10h
.text:000055A4 var_C           = dword ptr -0Ch
.text:000055A4 var_4           = dword ptr -4
.text:000055A4
.text:000055A4                 push    ebp
.text:000055A5                 mov     ebp, esp
.text:000055A7                 push    0FFFFFFFFh
.text:000055A9                 push    offset __ehhandler$??1CUpdateArchiveCommand@@QAE@XZ
.text:000055AE                 mov     eax, large fs:0
.text:000055B4                 push    eax
.text:000055B5                 push    ecx
.text:000055B6                 mov     [ebp+var_10], 0CCCCCCCCh
.text:000055BD                 mov     eax, dword ptr ds:___security_cookie
.text:000055C2                 xor     eax, ebp
.text:000055C4                 push    eax
.text:000055C5                 lea     eax, [ebp+var_C]
.text:000055C8                 mov     large fs:0, eax
.text:000055CE                 mov     [ebp+var_10], ecx
.text:000055D1                 mov     [ebp+var_4], 0
.text:000055D8                 mov     ecx, [ebp+var_10]
.text:000055DB                 add     ecx, 0Ch        ; this
.text:000055DE                 call    ??1CArchivePath@@QAE@XZ ; CArchivePath::~CArchivePath(void)
.text:000055E3                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000055EA                 mov     ecx, [ebp+var_10] ; this
.text:000055ED                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000055F2                 mov     ecx, [ebp+var_C]
.text:000055F5                 mov     large fs:0, ecx
.text:000055FC                 pop     ecx
.text:000055FD                 add     esp, 10h
.text:00005600                 cmp     ebp, esp
.text:00005602                 call    __RTC_CheckEsp
.text:00005607                 mov     esp, ebp
.text:00005609                 pop     ebp
.text:0000560A                 retn
.text:0000560A ??1CUpdateArchiveCommand@@QAE@XZ endp
.text:0000560A
.text:0000560A ; ---------------------------------------------------------------------------
.text:0000560B                 align 4
.text:0000560B _text           ends
.text:0000560B
.text$x:0000560C ; ===========================================================================
.text$x:0000560C
.text$x:0000560C ; Segment type: Pure code
.text$x:0000560C ; Segment permissions: Read/Execute
.text$x:0000560C _text$x         segment para public 'CODE' use32
.text$x:0000560C                 assume cs:_text$x
.text$x:0000560C                 ;org 560Ch
.text$x:0000560C ; COMDAT (pick associative to section at 55A4)
.text$x:0000560C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000560C
.text$x:0000560C ; =============== S U B R O U T I N E =======================================
.text$x:0000560C
.text$x:0000560C
.text$x:0000560C __unwindfunclet$??1CUpdateArchiveCommand@@QAE@XZ$0 proc near
.text$x:0000560C                                         ; DATA XREF: .xdata$x:00005634o
.text$x:0000560C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000560F                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:0000560F __unwindfunclet$??1CUpdateArchiveCommand@@QAE@XZ$0 endp
.text$x:0000560F
.text$x:00005614
.text$x:00005614 ; =============== S U B R O U T I N E =======================================
.text$x:00005614
.text$x:00005614
.text$x:00005614 __ehhandler$??1CUpdateArchiveCommand@@QAE@XZ proc near
.text$x:00005614                                         ; DATA XREF: CUpdateArchiveCommand::~CUpdateArchiveCommand(void)+5o
.text$x:00005614
.text$x:00005614 arg_4           = dword ptr  8
.text$x:00005614
.text$x:00005614                 mov     edx, [esp+arg_4]
.text$x:00005618                 lea     eax, [edx+0Ch]
.text$x:0000561B                 mov     ecx, [edx-8]
.text$x:0000561E                 xor     ecx, eax
.text$x:00005620                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005625                 mov     eax, offset __ehfuncinfo$??1CUpdateArchiveCommand@@QAE@XZ
.text$x:0000562A                 jmp     ___CxxFrameHandler3
.text$x:0000562A __ehhandler$??1CUpdateArchiveCommand@@QAE@XZ endp
.text$x:0000562A
.text$x:0000562A ; ---------------------------------------------------------------------------
.text$x:0000562F                 align 10h
.text$x:0000562F _text$x         ends
.text$x:0000562F
.xdata$x:00005630 ; ===========================================================================
.xdata$x:00005630
.xdata$x:00005630 ; Segment type: Pure data
.xdata$x:00005630 ; Segment permissions: Read
.xdata$x:00005630 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005630                 assume cs:_xdata$x
.xdata$x:00005630                 ;org 5630h
.xdata$x:00005630 ; COMDAT (pick associative to section at 55A4)
.xdata$x:00005630 __unwindtable$??1CUpdateArchiveCommand@@QAE@XZ db 0FFh
.xdata$x:00005630                                         ; DATA XREF: .xdata$x:00005640o
.xdata$x:00005631                 db 0FFh
.xdata$x:00005632                 db 0FFh
.xdata$x:00005633                 db 0FFh
.xdata$x:00005634                 dd offset __unwindfunclet$??1CUpdateArchiveCommand@@QAE@XZ$0
.xdata$x:00005638 __ehfuncinfo$??1CUpdateArchiveCommand@@QAE@XZ db  22h ; "
.xdata$x:00005638                                         ; DATA XREF: __ehhandler$??1CUpdateArchiveCommand@@QAE@XZ+11o
.xdata$x:00005639                 db    5
.xdata$x:0000563A                 db  93h ; Ã´
.xdata$x:0000563B                 db  19h
.xdata$x:0000563C                 db    1
.xdata$x:0000563D                 db    0
.xdata$x:0000563E                 db    0
.xdata$x:0000563F                 db    0
.xdata$x:00005640                 dd offset __unwindtable$??1CUpdateArchiveCommand@@QAE@XZ
.xdata$x:00005644                 db    0
.xdata$x:00005645                 db    0
.xdata$x:00005646                 db    0
.xdata$x:00005647                 db    0
.xdata$x:00005648                 db    0
.xdata$x:00005649                 db    0
.xdata$x:0000564A                 db    0
.xdata$x:0000564B                 db    0
.xdata$x:0000564C                 db    0
.xdata$x:0000564D                 db    0
.xdata$x:0000564E                 db    0
.xdata$x:0000564F                 db    0
.xdata$x:00005650                 db    0
.xdata$x:00005651                 db    0
.xdata$x:00005652                 db    0
.xdata$x:00005653                 db    0
.xdata$x:00005654                 db    0
.xdata$x:00005655                 db    0
.xdata$x:00005656                 db    0
.xdata$x:00005657                 db    0
.xdata$x:00005658                 db    1
.xdata$x:00005659                 db    0
.xdata$x:0000565A                 db    0
.xdata$x:0000565B                 db    0
.xdata$x:0000565B _xdata$x        ends
.xdata$x:0000565B
.text:0000565C ; ===========================================================================
.text:0000565C
.text:0000565C ; Segment type: Pure code
.text:0000565C ; Segment permissions: Read/Execute
.text:0000565C _text           segment para public 'CODE' use32
.text:0000565C                 assume cs:_text
.text:0000565C                 ;org 565Ch
.text:0000565C ; COMDAT (pick any)
.text:0000565C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000565C
.text:0000565C ; =============== S U B R O U T I N E =======================================
.text:0000565C
.text:0000565C ; Attributes: bp-based frame
.text:0000565C
.text:0000565C ; _DWORD __thiscall CArchivePath::~CArchivePath(CArchivePath *__hidden this)
.text:0000565C                 public ??1CArchivePath@@QAE@XZ
.text:0000565C ??1CArchivePath@@QAE@XZ proc near       ; CODE XREF: CUpdateArchiveCommand::~CUpdateArchiveCommand(void)+3Ap
.text:0000565C
.text:0000565C var_10          = dword ptr -10h
.text:0000565C var_C           = dword ptr -0Ch
.text:0000565C var_4           = dword ptr -4
.text:0000565C
.text:0000565C                 push    ebp
.text:0000565D                 mov     ebp, esp
.text:0000565F                 push    0FFFFFFFFh
.text:00005661                 push    offset __ehhandler$??1CArchivePath@@QAE@XZ
.text:00005666                 mov     eax, large fs:0
.text:0000566C                 push    eax
.text:0000566D                 push    ecx
.text:0000566E                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00005675                 mov     eax, dword ptr ds:___security_cookie
.text:0000567A                 xor     eax, ebp
.text:0000567C                 push    eax
.text:0000567D                 lea     eax, [ebp+var_C]
.text:00005680                 mov     large fs:0, eax
.text:00005686                 mov     [ebp+var_10], ecx
.text:00005689                 mov     [ebp+var_4], 5
.text:00005690                 mov     ecx, [ebp+var_10]
.text:00005693                 add     ecx, 4Ch ; 'L'  ; this
.text:00005696                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000569B                 mov     byte ptr [ebp+var_4], 4
.text:0000569F                 mov     ecx, [ebp+var_10]
.text:000056A2                 add     ecx, 40h ; '@'  ; this
.text:000056A5                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000056AA                 mov     byte ptr [ebp+var_4], 3
.text:000056AE                 mov     ecx, [ebp+var_10]
.text:000056B1                 add     ecx, 30h ; '0'  ; this
.text:000056B4                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000056B9                 mov     byte ptr [ebp+var_4], 2
.text:000056BD                 mov     ecx, [ebp+var_10]
.text:000056C0                 add     ecx, 24h ; '$'  ; this
.text:000056C3                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000056C8                 mov     byte ptr [ebp+var_4], 1
.text:000056CC                 mov     ecx, [ebp+var_10]
.text:000056CF                 add     ecx, 18h        ; this
.text:000056D2                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000056D7                 mov     byte ptr [ebp+var_4], 0
.text:000056DB                 mov     ecx, [ebp+var_10]
.text:000056DE                 add     ecx, 0Ch        ; this
.text:000056E1                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000056E6                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000056ED                 mov     ecx, [ebp+var_10] ; this
.text:000056F0                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000056F5                 mov     ecx, [ebp+var_C]
.text:000056F8                 mov     large fs:0, ecx
.text:000056FF                 pop     ecx
.text:00005700                 add     esp, 10h
.text:00005703                 cmp     ebp, esp
.text:00005705                 call    __RTC_CheckEsp
.text:0000570A                 mov     esp, ebp
.text:0000570C                 pop     ebp
.text:0000570D                 retn
.text:0000570D ??1CArchivePath@@QAE@XZ endp
.text:0000570D
.text:0000570D ; ---------------------------------------------------------------------------
.text:0000570E                 align 10h
.text:0000570E _text           ends
.text:0000570E
.text$x:00005710 ; ===========================================================================
.text$x:00005710
.text$x:00005710 ; Segment type: Pure code
.text$x:00005710 ; Segment permissions: Read/Execute
.text$x:00005710 _text$x         segment para public 'CODE' use32
.text$x:00005710                 assume cs:_text$x
.text$x:00005710                 ;org 5710h
.text$x:00005710 ; COMDAT (pick associative to section at 565C)
.text$x:00005710                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005710
.text$x:00005710 ; =============== S U B R O U T I N E =======================================
.text$x:00005710
.text$x:00005710
.text$x:00005710 __unwindfunclet$??1CArchivePath@@QAE@XZ$0 proc near
.text$x:00005710                                         ; DATA XREF: .xdata$x:00005794o
.text$x:00005710                 mov     ecx, [ebp-10h]  ; this
.text$x:00005713                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00005713 __unwindfunclet$??1CArchivePath@@QAE@XZ$0 endp
.text$x:00005713
.text$x:00005718
.text$x:00005718 ; =============== S U B R O U T I N E =======================================
.text$x:00005718
.text$x:00005718
.text$x:00005718 __unwindfunclet$??1CArchivePath@@QAE@XZ$1 proc near
.text$x:00005718                                         ; DATA XREF: .xdata$x:0000579Co
.text$x:00005718                 mov     ecx, [ebp-10h]
.text$x:0000571B                 add     ecx, 0Ch        ; this
.text$x:0000571E                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:0000571E __unwindfunclet$??1CArchivePath@@QAE@XZ$1 endp
.text$x:0000571E
.text$x:00005723
.text$x:00005723 ; =============== S U B R O U T I N E =======================================
.text$x:00005723
.text$x:00005723
.text$x:00005723 __unwindfunclet$??1CArchivePath@@QAE@XZ$2 proc near
.text$x:00005723                                         ; DATA XREF: .xdata$x:000057A4o
.text$x:00005723                 mov     ecx, [ebp-10h]
.text$x:00005726                 add     ecx, 18h        ; this
.text$x:00005729                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00005729 __unwindfunclet$??1CArchivePath@@QAE@XZ$2 endp
.text$x:00005729
.text$x:0000572E
.text$x:0000572E ; =============== S U B R O U T I N E =======================================
.text$x:0000572E
.text$x:0000572E
.text$x:0000572E __unwindfunclet$??1CArchivePath@@QAE@XZ$3 proc near
.text$x:0000572E                                         ; DATA XREF: .xdata$x:000057ACo
.text$x:0000572E                 mov     ecx, [ebp-10h]
.text$x:00005731                 add     ecx, 24h ; '$'  ; this
.text$x:00005734                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00005734 __unwindfunclet$??1CArchivePath@@QAE@XZ$3 endp
.text$x:00005734
.text$x:00005739
.text$x:00005739 ; =============== S U B R O U T I N E =======================================
.text$x:00005739
.text$x:00005739
.text$x:00005739 __unwindfunclet$??1CArchivePath@@QAE@XZ$4 proc near
.text$x:00005739                                         ; DATA XREF: .xdata$x:000057B4o
.text$x:00005739                 mov     ecx, [ebp-10h]
.text$x:0000573C                 add     ecx, 30h ; '0'  ; this
.text$x:0000573F                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:0000573F __unwindfunclet$??1CArchivePath@@QAE@XZ$4 endp
.text$x:0000573F
.text$x:00005744
.text$x:00005744 ; =============== S U B R O U T I N E =======================================
.text$x:00005744
.text$x:00005744
.text$x:00005744 __unwindfunclet$??1CArchivePath@@QAE@XZ$5 proc near
.text$x:00005744                                         ; DATA XREF: .xdata$x:000057BCo
.text$x:00005744                 mov     ecx, [ebp-10h]
.text$x:00005747                 add     ecx, 40h ; '@'  ; this
.text$x:0000574A                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:0000574A __unwindfunclet$??1CArchivePath@@QAE@XZ$5 endp
.text$x:0000574A
.text$x:0000574F
.text$x:0000574F ; =============== S U B R O U T I N E =======================================
.text$x:0000574F
.text$x:0000574F
.text$x:0000574F __ehhandler$??1CArchivePath@@QAE@XZ proc near
.text$x:0000574F                                         ; DATA XREF: CArchivePath::~CArchivePath(void)+5o
.text$x:0000574F
.text$x:0000574F arg_4           = dword ptr  8
.text$x:0000574F
.text$x:0000574F                 mov     edx, [esp+arg_4]
.text$x:00005753                 lea     eax, [edx+0Ch]
.text$x:00005756                 mov     ecx, [edx-8]
.text$x:00005759                 xor     ecx, eax
.text$x:0000575B                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005760                 mov     eax, offset __ehfuncinfo$??1CArchivePath@@QAE@XZ
.text$x:00005765                 jmp     ___CxxFrameHandler3
.text$x:00005765 __ehhandler$??1CArchivePath@@QAE@XZ endp
.text$x:00005765
.text$x:00005765 ; ---------------------------------------------------------------------------
.text$x:0000576A                 align 4
.text$x:0000576A _text$x         ends
.text$x:0000576A
.xdata$x:0000576C ; ===========================================================================
.xdata$x:0000576C
.xdata$x:0000576C ; Segment type: Pure data
.xdata$x:0000576C ; Segment permissions: Read
.xdata$x:0000576C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000576C                 assume cs:_xdata$x
.xdata$x:0000576C                 ;org 576Ch
.xdata$x:0000576C ; COMDAT (pick associative to section at 565C)
.xdata$x:0000576C __ehfuncinfo$??1CArchivePath@@QAE@XZ db  22h ; "
.xdata$x:0000576C                                         ; DATA XREF: __ehhandler$??1CArchivePath@@QAE@XZ+11o
.xdata$x:0000576D                 db    5
.xdata$x:0000576E                 db  93h ; Ã´
.xdata$x:0000576F                 db  19h
.xdata$x:00005770                 db    6
.xdata$x:00005771                 db    0
.xdata$x:00005772                 db    0
.xdata$x:00005773                 db    0
.xdata$x:00005774                 dd offset __unwindtable$??1CArchivePath@@QAE@XZ
.xdata$x:00005778                 db    0
.xdata$x:00005779                 db    0
.xdata$x:0000577A                 db    0
.xdata$x:0000577B                 db    0
.xdata$x:0000577C                 db    0
.xdata$x:0000577D                 db    0
.xdata$x:0000577E                 db    0
.xdata$x:0000577F                 db    0
.xdata$x:00005780                 db    0
.xdata$x:00005781                 db    0
.xdata$x:00005782                 db    0
.xdata$x:00005783                 db    0
.xdata$x:00005784                 db    0
.xdata$x:00005785                 db    0
.xdata$x:00005786                 db    0
.xdata$x:00005787                 db    0
.xdata$x:00005788                 db    0
.xdata$x:00005789                 db    0
.xdata$x:0000578A                 db    0
.xdata$x:0000578B                 db    0
.xdata$x:0000578C                 db    1
.xdata$x:0000578D                 db    0
.xdata$x:0000578E                 db    0
.xdata$x:0000578F                 db    0
.xdata$x:00005790 __unwindtable$??1CArchivePath@@QAE@XZ db 0FFh
.xdata$x:00005790                                         ; DATA XREF: .xdata$x:00005774o
.xdata$x:00005791                 db 0FFh
.xdata$x:00005792                 db 0FFh
.xdata$x:00005793                 db 0FFh
.xdata$x:00005794                 dd offset __unwindfunclet$??1CArchivePath@@QAE@XZ$0
.xdata$x:00005798                 db    0
.xdata$x:00005799                 db    0
.xdata$x:0000579A                 db    0
.xdata$x:0000579B                 db    0
.xdata$x:0000579C                 dd offset __unwindfunclet$??1CArchivePath@@QAE@XZ$1
.xdata$x:000057A0                 db    1
.xdata$x:000057A1                 db    0
.xdata$x:000057A2                 db    0
.xdata$x:000057A3                 db    0
.xdata$x:000057A4                 dd offset __unwindfunclet$??1CArchivePath@@QAE@XZ$2
.xdata$x:000057A8                 db    2
.xdata$x:000057A9                 db    0
.xdata$x:000057AA                 db    0
.xdata$x:000057AB                 db    0
.xdata$x:000057AC                 dd offset __unwindfunclet$??1CArchivePath@@QAE@XZ$3
.xdata$x:000057B0                 db    3
.xdata$x:000057B1                 db    0
.xdata$x:000057B2                 db    0
.xdata$x:000057B3                 db    0
.xdata$x:000057B4                 dd offset __unwindfunclet$??1CArchivePath@@QAE@XZ$4
.xdata$x:000057B8                 db    4
.xdata$x:000057B9                 db    0
.xdata$x:000057BA                 db    0
.xdata$x:000057BB                 db    0
.xdata$x:000057BC                 dd offset __unwindfunclet$??1CArchivePath@@QAE@XZ$5
.xdata$x:000057BC _xdata$x        ends
.xdata$x:000057BC
.text:000057C0 ; ===========================================================================
.text:000057C0
.text:000057C0 ; Segment type: Pure code
.text:000057C0 ; Segment permissions: Read/Execute
.text:000057C0 _text           segment para public 'CODE' use32
.text:000057C0                 assume cs:_text
.text:000057C0                 ;org 57C0h
.text:000057C0 ; COMDAT (pick any)
.text:000057C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000057C0
.text:000057C0 ; =============== S U B R O U T I N E =======================================
.text:000057C0
.text:000057C0 ; Attributes: bp-based frame
.text:000057C0
.text:000057C0 ; bool __thiscall UString::IsEqualTo(UString *this, const char *)
.text:000057C0                 public ?IsEqualTo@UString@@QBE_NPBD@Z
.text:000057C0 ?IsEqualTo@UString@@QBE_NPBD@Z proc near
.text:000057C0                                         ; CODE XREF: ParseUpdateCommandString(CUpdateOptions &,CObjectVector<UString> const &,NUpdateArchive::CActionSet const &)+82p
.text:000057C0                                         ; FindCharset(NCommandLineParser::CParser const &,uint,bool,int)+122p
.text:000057C0
.text:000057C0 var_4           = dword ptr -4
.text:000057C0 arg_0           = dword ptr  8
.text:000057C0
.text:000057C0                 push    ebp
.text:000057C1                 mov     ebp, esp
.text:000057C3                 push    ecx
.text:000057C4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000057CB                 mov     [ebp+var_4], ecx
.text:000057CE                 mov     eax, [ebp+arg_0]
.text:000057D1                 push    eax             ; char *
.text:000057D2                 mov     ecx, [ebp+var_4]
.text:000057D5                 mov     edx, [ecx]
.text:000057D7                 push    edx             ; wchar_t *
.text:000057D8                 call    ?StringsAreEqual_Ascii@@YG_NPB_WPBD@Z ; StringsAreEqual_Ascii(wchar_t const *,char const *)
.text:000057DD                 add     esp, 4
.text:000057E0                 cmp     ebp, esp
.text:000057E2                 call    __RTC_CheckEsp
.text:000057E7                 mov     esp, ebp
.text:000057E9                 pop     ebp
.text:000057EA                 retn    4
.text:000057EA ?IsEqualTo@UString@@QBE_NPBD@Z endp
.text:000057EA
.text:000057EA ; ---------------------------------------------------------------------------
.text:000057ED                 align 10h
.text:000057ED _text           ends
.text:000057ED
.text:000057F0 ; ===========================================================================
.text:000057F0
.text:000057F0 ; Segment type: Pure code
.text:000057F0 ; Segment permissions: Read/Execute
.text:000057F0 _text           segment para public 'CODE' use32
.text:000057F0                 assume cs:_text
.text:000057F0                 ;org 57F0h
.text:000057F0 ; COMDAT (pick any)
.text:000057F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000057F0
.text:000057F0 ; =============== S U B R O U T I N E =======================================
.text:000057F0
.text:000057F0 ; Attributes: bp-based frame
.text:000057F0
.text:000057F0 ; _DWORD __thiscall CProperty::CProperty(CProperty *__hidden this)
.text:000057F0                 public ??0CProperty@@QAE@XZ
.text:000057F0 ??0CProperty@@QAE@XZ proc near          ; CODE XREF: SetMethodOptions(NCommandLineParser::CParser const &,CObjectVector<CProperty> &)+7Cp
.text:000057F0
.text:000057F0 var_10          = dword ptr -10h
.text:000057F0 var_C           = dword ptr -0Ch
.text:000057F0 var_4           = dword ptr -4
.text:000057F0
.text:000057F0                 push    ebp
.text:000057F1                 mov     ebp, esp
.text:000057F3                 push    0FFFFFFFFh
.text:000057F5                 push    offset __ehhandler$??0CProperty@@QAE@XZ
.text:000057FA                 mov     eax, large fs:0
.text:00005800                 push    eax
.text:00005801                 push    ecx
.text:00005802                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00005809                 mov     eax, dword ptr ds:___security_cookie
.text:0000580E                 xor     eax, ebp
.text:00005810                 push    eax
.text:00005811                 lea     eax, [ebp+var_C]
.text:00005814                 mov     large fs:0, eax
.text:0000581A                 mov     [ebp+var_10], ecx
.text:0000581D                 mov     ecx, [ebp+var_10]
.text:00005820                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00005825                 mov     [ebp+var_4], 0
.text:0000582C                 mov     ecx, [ebp+var_10]
.text:0000582F                 add     ecx, 0Ch
.text:00005832                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00005837                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000583E                 mov     eax, [ebp+var_10]
.text:00005841                 mov     ecx, [ebp+var_C]
.text:00005844                 mov     large fs:0, ecx
.text:0000584B                 pop     ecx
.text:0000584C                 add     esp, 10h
.text:0000584F                 cmp     ebp, esp
.text:00005851                 call    __RTC_CheckEsp
.text:00005856                 mov     esp, ebp
.text:00005858                 pop     ebp
.text:00005859                 retn
.text:00005859 ??0CProperty@@QAE@XZ endp
.text:00005859
.text:00005859 ; ---------------------------------------------------------------------------
.text:0000585A                 align 4
.text:0000585A _text           ends
.text:0000585A
.text$x:0000585C ; ===========================================================================
.text$x:0000585C
.text$x:0000585C ; Segment type: Pure code
.text$x:0000585C ; Segment permissions: Read/Execute
.text$x:0000585C _text$x         segment para public 'CODE' use32
.text$x:0000585C                 assume cs:_text$x
.text$x:0000585C                 ;org 585Ch
.text$x:0000585C ; COMDAT (pick associative to section at 57F0)
.text$x:0000585C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000585C
.text$x:0000585C ; =============== S U B R O U T I N E =======================================
.text$x:0000585C
.text$x:0000585C
.text$x:0000585C __unwindfunclet$??0CProperty@@QAE@XZ$0 proc near
.text$x:0000585C                                         ; DATA XREF: .xdata$x:00005884o
.text$x:0000585C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000585F                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:0000585F __unwindfunclet$??0CProperty@@QAE@XZ$0 endp
.text$x:0000585F
.text$x:00005864
.text$x:00005864 ; =============== S U B R O U T I N E =======================================
.text$x:00005864
.text$x:00005864
.text$x:00005864 __ehhandler$??0CProperty@@QAE@XZ proc near
.text$x:00005864                                         ; DATA XREF: CProperty::CProperty(void)+5o
.text$x:00005864
.text$x:00005864 arg_4           = dword ptr  8
.text$x:00005864
.text$x:00005864                 mov     edx, [esp+arg_4]
.text$x:00005868                 lea     eax, [edx+0Ch]
.text$x:0000586B                 mov     ecx, [edx-8]
.text$x:0000586E                 xor     ecx, eax
.text$x:00005870                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005875                 mov     eax, offset __ehfuncinfo$??0CProperty@@QAE@XZ
.text$x:0000587A                 jmp     ___CxxFrameHandler3
.text$x:0000587A __ehhandler$??0CProperty@@QAE@XZ endp
.text$x:0000587A
.text$x:0000587A ; ---------------------------------------------------------------------------
.text$x:0000587F                 align 10h
.text$x:0000587F _text$x         ends
.text$x:0000587F
.xdata$x:00005880 ; ===========================================================================
.xdata$x:00005880
.xdata$x:00005880 ; Segment type: Pure data
.xdata$x:00005880 ; Segment permissions: Read
.xdata$x:00005880 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005880                 assume cs:_xdata$x
.xdata$x:00005880                 ;org 5880h
.xdata$x:00005880 ; COMDAT (pick associative to section at 57F0)
.xdata$x:00005880 __unwindtable$??0CProperty@@QAE@XZ db 0FFh ; DATA XREF: .xdata$x:00005890o
.xdata$x:00005881                 db 0FFh
.xdata$x:00005882                 db 0FFh
.xdata$x:00005883                 db 0FFh
.xdata$x:00005884                 dd offset __unwindfunclet$??0CProperty@@QAE@XZ$0
.xdata$x:00005888 __ehfuncinfo$??0CProperty@@QAE@XZ db  22h ; "
.xdata$x:00005888                                         ; DATA XREF: __ehhandler$??0CProperty@@QAE@XZ+11o
.xdata$x:00005889                 db    5
.xdata$x:0000588A                 db  93h ; Ã´
.xdata$x:0000588B                 db  19h
.xdata$x:0000588C                 db    1
.xdata$x:0000588D                 db    0
.xdata$x:0000588E                 db    0
.xdata$x:0000588F                 db    0
.xdata$x:00005890                 dd offset __unwindtable$??0CProperty@@QAE@XZ
.xdata$x:00005894                 db    0
.xdata$x:00005895                 db    0
.xdata$x:00005896                 db    0
.xdata$x:00005897                 db    0
.xdata$x:00005898                 db    0
.xdata$x:00005899                 db    0
.xdata$x:0000589A                 db    0
.xdata$x:0000589B                 db    0
.xdata$x:0000589C                 db    0
.xdata$x:0000589D                 db    0
.xdata$x:0000589E                 db    0
.xdata$x:0000589F                 db    0
.xdata$x:000058A0                 db    0
.xdata$x:000058A1                 db    0
.xdata$x:000058A2                 db    0
.xdata$x:000058A3                 db    0
.xdata$x:000058A4                 db    0
.xdata$x:000058A5                 db    0
.xdata$x:000058A6                 db    0
.xdata$x:000058A7                 db    0
.xdata$x:000058A8                 db    1
.xdata$x:000058A9                 db    0
.xdata$x:000058AA                 db    0
.xdata$x:000058AB                 db    0
.xdata$x:000058AB _xdata$x        ends
.xdata$x:000058AB
.text:000058AC ; ===========================================================================
.text:000058AC
.text:000058AC ; Segment type: Pure code
.text:000058AC ; Segment permissions: Read/Execute
.text:000058AC _text           segment para public 'CODE' use32
.text:000058AC                 assume cs:_text
.text:000058AC                 ;org 58ACh
.text:000058AC ; COMDAT (pick any)
.text:000058AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000058AC
.text:000058AC ; =============== S U B R O U T I N E =======================================
.text:000058AC
.text:000058AC ; Attributes: bp-based frame
.text:000058AC
.text:000058AC ; _DWORD __thiscall CProperty::~CProperty(CProperty *__hidden this)
.text:000058AC                 public ??1CProperty@@QAE@XZ
.text:000058AC ??1CProperty@@QAE@XZ proc near          ; CODE XREF: SetMethodOptions(NCommandLineParser::CParser const &,CObjectVector<CProperty> &)+F6p
.text:000058AC                                         ; __unwindfunclet$?SetMethodOptions@@YGXABVCParser@NCommandLineParser@@AAV?$CObjectVector@UCProperty@@@@@Z$0+3j ...
.text:000058AC
.text:000058AC var_10          = dword ptr -10h
.text:000058AC var_C           = dword ptr -0Ch
.text:000058AC var_4           = dword ptr -4
.text:000058AC
.text:000058AC                 push    ebp
.text:000058AD                 mov     ebp, esp
.text:000058AF                 push    0FFFFFFFFh
.text:000058B1                 push    offset __ehhandler$??1CProperty@@QAE@XZ
.text:000058B6                 mov     eax, large fs:0
.text:000058BC                 push    eax
.text:000058BD                 push    ecx
.text:000058BE                 mov     [ebp+var_10], 0CCCCCCCCh
.text:000058C5                 mov     eax, dword ptr ds:___security_cookie
.text:000058CA                 xor     eax, ebp
.text:000058CC                 push    eax
.text:000058CD                 lea     eax, [ebp+var_C]
.text:000058D0                 mov     large fs:0, eax
.text:000058D6                 mov     [ebp+var_10], ecx
.text:000058D9                 mov     [ebp+var_4], 0
.text:000058E0                 mov     ecx, [ebp+var_10]
.text:000058E3                 add     ecx, 0Ch        ; this
.text:000058E6                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000058EB                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000058F2                 mov     ecx, [ebp+var_10] ; this
.text:000058F5                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000058FA                 mov     ecx, [ebp+var_C]
.text:000058FD                 mov     large fs:0, ecx
.text:00005904                 pop     ecx
.text:00005905                 add     esp, 10h
.text:00005908                 cmp     ebp, esp
.text:0000590A                 call    __RTC_CheckEsp
.text:0000590F                 mov     esp, ebp
.text:00005911                 pop     ebp
.text:00005912                 retn
.text:00005912 ??1CProperty@@QAE@XZ endp
.text:00005912
.text:00005912 ; ---------------------------------------------------------------------------
.text:00005913                 align 4
.text:00005913 _text           ends
.text:00005913
.text$x:00005914 ; ===========================================================================
.text$x:00005914
.text$x:00005914 ; Segment type: Pure code
.text$x:00005914 ; Segment permissions: Read/Execute
.text$x:00005914 _text$x         segment para public 'CODE' use32
.text$x:00005914                 assume cs:_text$x
.text$x:00005914                 ;org 5914h
.text$x:00005914 ; COMDAT (pick associative to section at 58AC)
.text$x:00005914                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005914
.text$x:00005914 ; =============== S U B R O U T I N E =======================================
.text$x:00005914
.text$x:00005914
.text$x:00005914 __unwindfunclet$??1CProperty@@QAE@XZ$0 proc near
.text$x:00005914                                         ; DATA XREF: .xdata$x:0000593Co
.text$x:00005914                 mov     ecx, [ebp-10h]  ; this
.text$x:00005917                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00005917 __unwindfunclet$??1CProperty@@QAE@XZ$0 endp
.text$x:00005917
.text$x:0000591C
.text$x:0000591C ; =============== S U B R O U T I N E =======================================
.text$x:0000591C
.text$x:0000591C
.text$x:0000591C __ehhandler$??1CProperty@@QAE@XZ proc near
.text$x:0000591C                                         ; DATA XREF: CProperty::~CProperty(void)+5o
.text$x:0000591C
.text$x:0000591C arg_4           = dword ptr  8
.text$x:0000591C
.text$x:0000591C                 mov     edx, [esp+arg_4]
.text$x:00005920                 lea     eax, [edx+0Ch]
.text$x:00005923                 mov     ecx, [edx-8]
.text$x:00005926                 xor     ecx, eax
.text$x:00005928                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000592D                 mov     eax, offset __ehfuncinfo$??1CProperty@@QAE@XZ
.text$x:00005932                 jmp     ___CxxFrameHandler3
.text$x:00005932 __ehhandler$??1CProperty@@QAE@XZ endp
.text$x:00005932
.text$x:00005932 ; ---------------------------------------------------------------------------
.text$x:00005937                 align 4
.text$x:00005937 _text$x         ends
.text$x:00005937
.xdata$x:00005938 ; ===========================================================================
.xdata$x:00005938
.xdata$x:00005938 ; Segment type: Pure data
.xdata$x:00005938 ; Segment permissions: Read
.xdata$x:00005938 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005938                 assume cs:_xdata$x
.xdata$x:00005938                 ;org 5938h
.xdata$x:00005938 ; COMDAT (pick associative to section at 58AC)
.xdata$x:00005938 __unwindtable$??1CProperty@@QAE@XZ db 0FFh ; DATA XREF: .xdata$x:00005948o
.xdata$x:00005939                 db 0FFh
.xdata$x:0000593A                 db 0FFh
.xdata$x:0000593B                 db 0FFh
.xdata$x:0000593C                 dd offset __unwindfunclet$??1CProperty@@QAE@XZ$0
.xdata$x:00005940 __ehfuncinfo$??1CProperty@@QAE@XZ db  22h ; "
.xdata$x:00005940                                         ; DATA XREF: __ehhandler$??1CProperty@@QAE@XZ+11o
.xdata$x:00005941                 db    5
.xdata$x:00005942                 db  93h ; Ã´
.xdata$x:00005943                 db  19h
.xdata$x:00005944                 db    1
.xdata$x:00005945                 db    0
.xdata$x:00005946                 db    0
.xdata$x:00005947                 db    0
.xdata$x:00005948                 dd offset __unwindtable$??1CProperty@@QAE@XZ
.xdata$x:0000594C                 align 20h
.xdata$x:00005960                 db    1
.xdata$x:00005961                 db    0
.xdata$x:00005962                 db    0
.xdata$x:00005963                 db    0
.xdata$x:00005963 _xdata$x        ends
.xdata$x:00005963
.text:00005964 ; ===========================================================================
.text:00005964
.text:00005964 ; Segment type: Pure code
.text:00005964 ; Segment permissions: Read/Execute
.text:00005964 _text           segment para public 'CODE' use32
.text:00005964                 assume cs:_text
.text:00005964                 ;org 5964h
.text:00005964 ; COMDAT (pick any)
.text:00005964                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00005964
.text:00005964 ; =============== S U B R O U T I N E =======================================
.text:00005964
.text:00005964 ; Attributes: bp-based frame
.text:00005964
.text:00005964 ; public: unsigned int __thiscall CObjectVector<class UString>::Size(void)const
.text:00005964                 public ?Size@?$CObjectVector@VUString@@@@QBEIXZ
.text:00005964 ?Size@?$CObjectVector@VUString@@@@QBEIXZ proc near
.text:00005964                                         ; CODE XREF: ConvertToLongNames(UString const &,CObjectVector<NWildcard::CItem> &)+50p
.text:00005964                                         ; EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *)+194p ...
.text:00005964
.text:00005964 var_4           = dword ptr -4
.text:00005964
.text:00005964                 push    ebp
.text:00005965                 mov     ebp, esp
.text:00005967                 push    ecx
.text:00005968                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000596F                 mov     [ebp+var_4], ecx
.text:00005972                 mov     ecx, [ebp+var_4]
.text:00005975                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:0000597A                 add     esp, 4
.text:0000597D                 cmp     ebp, esp
.text:0000597F                 call    __RTC_CheckEsp
.text:00005984                 mov     esp, ebp
.text:00005986                 pop     ebp
.text:00005987                 retn
.text:00005987 ?Size@?$CObjectVector@VUString@@@@QBEIXZ endp
.text:00005987
.text:00005987 _text           ends
.text:00005987
.text:00005988 ; ===========================================================================
.text:00005988
.text:00005988 ; Segment type: Pure code
.text:00005988 ; Segment permissions: Read/Execute
.text:00005988 _text           segment para public 'CODE' use32
.text:00005988                 assume cs:_text
.text:00005988                 ;org 5988h
.text:00005988 ; COMDAT (pick any)
.text:00005988                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00005988
.text:00005988 ; =============== S U B R O U T I N E =======================================
.text:00005988
.text:00005988 ; Attributes: bp-based frame
.text:00005988
.text:00005988 ; public: void __thiscall CObjectVector<class UString>::ClearAndReserve(unsigned int)
.text:00005988                 public ?ClearAndReserve@?$CObjectVector@VUString@@@@QAEXI@Z
.text:00005988 ?ClearAndReserve@?$CObjectVector@VUString@@@@QAEXI@Z proc near
.text:00005988                                         ; CODE XREF: EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *)+282p
.text:00005988                                         ; EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *)+296p
.text:00005988
.text:00005988 var_4           = dword ptr -4
.text:00005988 arg_0           = dword ptr  8
.text:00005988
.text:00005988                 push    ebp
.text:00005989                 mov     ebp, esp
.text:0000598B                 push    ecx
.text:0000598C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00005993                 mov     [ebp+var_4], ecx
.text:00005996                 mov     ecx, [ebp+var_4]
.text:00005999                 call    ?Clear@?$CObjectVector@VUString@@@@QAEXXZ ; CObjectVector<UString>::Clear(void)
.text:0000599E                 mov     eax, [ebp+arg_0]
.text:000059A1                 push    eax
.text:000059A2                 mov     ecx, [ebp+var_4]
.text:000059A5                 call    ?ClearAndReserve@?$CRecordVector@PAX@@QAEXI@Z ; CRecordVector<void *>::ClearAndReserve(uint)
.text:000059AA                 add     esp, 4
.text:000059AD                 cmp     ebp, esp
.text:000059AF                 call    __RTC_CheckEsp
.text:000059B4                 mov     esp, ebp
.text:000059B6                 pop     ebp
.text:000059B7                 retn    4
.text:000059B7 ?ClearAndReserve@?$CObjectVector@VUString@@@@QAEXI@Z endp
.text:000059B7
.text:000059B7 ; ---------------------------------------------------------------------------
.text:000059BA                 align 4
.text:000059BA _text           ends
.text:000059BA
.text:000059BC ; ===========================================================================
.text:000059BC
.text:000059BC ; Segment type: Pure code
.text:000059BC ; Segment permissions: Read/Execute
.text:000059BC _text           segment para public 'CODE' use32
.text:000059BC                 assume cs:_text
.text:000059BC                 ;org 59BCh
.text:000059BC ; COMDAT (pick any)
.text:000059BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000059BC
.text:000059BC ; =============== S U B R O U T I N E =======================================
.text:000059BC
.text:000059BC ; Attributes: bp-based frame
.text:000059BC
.text:000059BC ; public: __thiscall CObjectVector<class UString>::CObjectVector<class UString>(void)
.text:000059BC                 public ??0?$CObjectVector@VUString@@@@QAE@XZ
.text:000059BC ??0?$CObjectVector@VUString@@@@QAE@XZ proc near
.text:000059BC                                         ; CODE XREF: EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *)+3Fp
.text:000059BC                                         ; EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *)+1C8p ...
.text:000059BC
.text:000059BC var_4           = dword ptr -4
.text:000059BC
.text:000059BC                 push    ebp
.text:000059BD                 mov     ebp, esp
.text:000059BF                 push    ecx
.text:000059C0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000059C7                 mov     [ebp+var_4], ecx
.text:000059CA                 mov     ecx, [ebp+var_4]
.text:000059CD                 call    ??0?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::CRecordVector<void *>(void)
.text:000059D2                 mov     eax, [ebp+var_4]
.text:000059D5                 add     esp, 4
.text:000059D8                 cmp     ebp, esp
.text:000059DA                 call    __RTC_CheckEsp
.text:000059DF                 mov     esp, ebp
.text:000059E1                 pop     ebp
.text:000059E2                 retn
.text:000059E2 ??0?$CObjectVector@VUString@@@@QAE@XZ endp
.text:000059E2
.text:000059E2 ; ---------------------------------------------------------------------------
.text:000059E3                 align 4
.text:000059E3 _text           ends
.text:000059E3
.text:000059E4 ; ===========================================================================
.text:000059E4
.text:000059E4 ; Segment type: Pure code
.text:000059E4 ; Segment permissions: Read/Execute
.text:000059E4 _text           segment para public 'CODE' use32
.text:000059E4                 assume cs:_text
.text:000059E4                 ;org 59E4h
.text:000059E4 ; COMDAT (pick any)
.text:000059E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000059E4
.text:000059E4 ; =============== S U B R O U T I N E =======================================
.text:000059E4
.text:000059E4 ; Attributes: bp-based frame
.text:000059E4
.text:000059E4 ; public: class CObjectVector<class UString> & __thiscall CObjectVector<class UString>::operator=(class CObjectVector<class UString> const &)
.text:000059E4                 public ??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z
.text:000059E4 ??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z proc near
.text:000059E4                                         ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+C8p
.text:000059E4                                         ; CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+4FAp ...
.text:000059E4
.text:000059E4 var_24          = dword ptr -24h
.text:000059E4 var_20          = dword ptr -20h
.text:000059E4 var_1C          = dword ptr -1Ch
.text:000059E4 var_18          = dword ptr -18h
.text:000059E4 var_14          = dword ptr -14h
.text:000059E4 var_10          = dword ptr -10h
.text:000059E4 var_C           = dword ptr -0Ch
.text:000059E4 var_4           = dword ptr -4
.text:000059E4 arg_0           = dword ptr  8
.text:000059E4
.text:000059E4                 push    ebp
.text:000059E5                 mov     ebp, esp
.text:000059E7                 push    0FFFFFFFFh
.text:000059E9                 push    offset __ehhandler$??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z
.text:000059EE                 mov     eax, large fs:0
.text:000059F4                 push    eax
.text:000059F5                 sub     esp, 18h
.text:000059F8                 mov     eax, 0CCCCCCCCh
.text:000059FD                 mov     [ebp+var_24], eax
.text:00005A00                 mov     [ebp+var_20], eax
.text:00005A03                 mov     [ebp+var_1C], eax
.text:00005A06                 mov     [ebp+var_18], eax
.text:00005A09                 mov     [ebp+var_14], eax
.text:00005A0C                 mov     [ebp+var_10], eax
.text:00005A0F                 mov     eax, dword ptr ds:___security_cookie
.text:00005A14                 xor     eax, ebp
.text:00005A16                 push    eax
.text:00005A17                 lea     eax, [ebp+var_C]
.text:00005A1A                 mov     large fs:0, eax
.text:00005A20                 mov     [ebp+var_10], ecx
.text:00005A23                 mov     eax, [ebp+arg_0]
.text:00005A26                 cmp     eax, [ebp+var_10]
.text:00005A29                 jnz     short loc_5A33
.text:00005A2B                 mov     eax, [ebp+var_10]
.text:00005A2E                 jmp     loc_5AC5
.text:00005A33 ; ---------------------------------------------------------------------------
.text:00005A33
.text:00005A33 loc_5A33:                               ; CODE XREF: CObjectVector<UString>::operator=(CObjectVector<UString> const &)+45j
.text:00005A33                 mov     ecx, [ebp+var_10]
.text:00005A36                 call    ?Clear@?$CObjectVector@VUString@@@@QAEXXZ ; CObjectVector<UString>::Clear(void)
.text:00005A3B                 mov     ecx, [ebp+arg_0]
.text:00005A3E                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:00005A43                 mov     [ebp+var_14], eax
.text:00005A46                 mov     ecx, [ebp+var_14]
.text:00005A49                 push    ecx
.text:00005A4A                 mov     ecx, [ebp+var_10]
.text:00005A4D                 call    ?Reserve@?$CRecordVector@PAX@@QAEXI@Z ; CRecordVector<void *>::Reserve(uint)
.text:00005A52                 mov     [ebp+var_18], 0
.text:00005A59                 jmp     short loc_5A64
.text:00005A5B ; ---------------------------------------------------------------------------
.text:00005A5B
.text:00005A5B loc_5A5B:                               ; CODE XREF: CObjectVector<UString>::operator=(CObjectVector<UString> const &)+DCj
.text:00005A5B                 mov     edx, [ebp+var_18]
.text:00005A5E                 add     edx, 1
.text:00005A61                 mov     [ebp+var_18], edx
.text:00005A64
.text:00005A64 loc_5A64:                               ; CODE XREF: CObjectVector<UString>::operator=(CObjectVector<UString> const &)+75j
.text:00005A64                 mov     eax, [ebp+var_18]
.text:00005A67                 cmp     eax, [ebp+var_14]
.text:00005A6A                 jnb     short loc_5AC2
.text:00005A6C                 push    0Ch             ; unsigned int
.text:00005A6E                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00005A73                 add     esp, 4
.text:00005A76                 mov     [ebp+var_20], eax
.text:00005A79                 mov     [ebp+var_4], 0
.text:00005A80                 cmp     [ebp+var_20], 0
.text:00005A84                 jz      short loc_5AA0
.text:00005A86                 mov     ecx, [ebp+var_18]
.text:00005A89                 push    ecx
.text:00005A8A                 mov     ecx, [ebp+arg_0]
.text:00005A8D                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00005A92                 push    eax
.text:00005A93                 mov     ecx, [ebp+var_20]
.text:00005A96                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00005A9B                 mov     [ebp+var_24], eax
.text:00005A9E                 jmp     short loc_5AA7
.text:00005AA0 ; ---------------------------------------------------------------------------
.text:00005AA0
.text:00005AA0 loc_5AA0:                               ; CODE XREF: CObjectVector<UString>::operator=(CObjectVector<UString> const &)+A0j
.text:00005AA0                 mov     [ebp+var_24], 0
.text:00005AA7
.text:00005AA7 loc_5AA7:                               ; CODE XREF: CObjectVector<UString>::operator=(CObjectVector<UString> const &)+BAj
.text:00005AA7                 mov     edx, [ebp+var_24]
.text:00005AAA                 mov     [ebp+var_1C], edx
.text:00005AAD                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00005AB4                 mov     eax, [ebp+var_1C]
.text:00005AB7                 push    eax
.text:00005AB8                 mov     ecx, [ebp+var_10]
.text:00005ABB                 call    ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z ; CRecordVector<void *>::AddInReserved(void * const)
.text:00005AC0                 jmp     short loc_5A5B
.text:00005AC2 ; ---------------------------------------------------------------------------
.text:00005AC2
.text:00005AC2 loc_5AC2:                               ; CODE XREF: CObjectVector<UString>::operator=(CObjectVector<UString> const &)+86j
.text:00005AC2                 mov     eax, [ebp+var_10]
.text:00005AC5
.text:00005AC5 loc_5AC5:                               ; CODE XREF: CObjectVector<UString>::operator=(CObjectVector<UString> const &)+4Aj
.text:00005AC5                 mov     ecx, [ebp+var_C]
.text:00005AC8                 mov     large fs:0, ecx
.text:00005ACF                 pop     ecx
.text:00005AD0                 add     esp, 24h
.text:00005AD3                 cmp     ebp, esp
.text:00005AD5                 call    __RTC_CheckEsp
.text:00005ADA                 mov     esp, ebp
.text:00005ADC                 pop     ebp
.text:00005ADD                 retn    4
.text:00005ADD ??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z endp
.text:00005ADD
.text:00005ADD _text           ends
.text:00005ADD
.text$x:00005AE0 ; ===========================================================================
.text$x:00005AE0
.text$x:00005AE0 ; Segment type: Pure code
.text$x:00005AE0 ; Segment permissions: Read/Execute
.text$x:00005AE0 _text$x         segment para public 'CODE' use32
.text$x:00005AE0                 assume cs:_text$x
.text$x:00005AE0                 ;org 5AE0h
.text$x:00005AE0 ; COMDAT (pick associative to section at 59E4)
.text$x:00005AE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005AE0
.text$x:00005AE0 ; =============== S U B R O U T I N E =======================================
.text$x:00005AE0
.text$x:00005AE0
.text$x:00005AE0 __unwindfunclet$??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z$0 proc near
.text$x:00005AE0                                         ; DATA XREF: .xdata$x:00005B0Co
.text$x:00005AE0                 mov     eax, [ebp-20h]
.text$x:00005AE3                 push    eax             ; void *
.text$x:00005AE4                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00005AE9                 pop     ecx
.text$x:00005AEA                 retn
.text$x:00005AEA __unwindfunclet$??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z$0 endp
.text$x:00005AEA
.text$x:00005AEB
.text$x:00005AEB ; =============== S U B R O U T I N E =======================================
.text$x:00005AEB
.text$x:00005AEB
.text$x:00005AEB __ehhandler$??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z proc near
.text$x:00005AEB                                         ; DATA XREF: CObjectVector<UString>::operator=(CObjectVector<UString> const &)+5o
.text$x:00005AEB
.text$x:00005AEB arg_4           = dword ptr  8
.text$x:00005AEB
.text$x:00005AEB                 mov     edx, [esp+arg_4]
.text$x:00005AEF                 lea     eax, [edx+0Ch]
.text$x:00005AF2                 mov     ecx, [edx-1Ch]
.text$x:00005AF5                 xor     ecx, eax
.text$x:00005AF7                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005AFC                 mov     eax, offset __ehfuncinfo$??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z
.text$x:00005B01                 jmp     ___CxxFrameHandler3
.text$x:00005B01 __ehhandler$??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z endp
.text$x:00005B01
.text$x:00005B01 ; ---------------------------------------------------------------------------
.text$x:00005B06                 align 4
.text$x:00005B06 _text$x         ends
.text$x:00005B06
.xdata$x:00005B08 ; ===========================================================================
.xdata$x:00005B08
.xdata$x:00005B08 ; Segment type: Pure data
.xdata$x:00005B08 ; Segment permissions: Read
.xdata$x:00005B08 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005B08                 assume cs:_xdata$x
.xdata$x:00005B08                 ;org 5B08h
.xdata$x:00005B08 ; COMDAT (pick associative to section at 59E4)
.xdata$x:00005B08 __unwindtable$??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z db 0FFh
.xdata$x:00005B08                                         ; DATA XREF: .xdata$x:00005B18o
.xdata$x:00005B09                 db 0FFh
.xdata$x:00005B0A                 db 0FFh
.xdata$x:00005B0B                 db 0FFh
.xdata$x:00005B0C                 dd offset __unwindfunclet$??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z$0
.xdata$x:00005B10 __ehfuncinfo$??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z db  22h ; "
.xdata$x:00005B10                                         ; DATA XREF: __ehhandler$??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z+11o
.xdata$x:00005B11                 db    5
.xdata$x:00005B12                 db  93h ; Ã´
.xdata$x:00005B13                 db  19h
.xdata$x:00005B14                 db    1
.xdata$x:00005B15                 db    0
.xdata$x:00005B16                 db    0
.xdata$x:00005B17                 db    0
.xdata$x:00005B18                 dd offset __unwindtable$??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z
.xdata$x:00005B1C                 db    0
.xdata$x:00005B1D                 db    0
.xdata$x:00005B1E                 db    0
.xdata$x:00005B1F                 db    0
.xdata$x:00005B20                 db    0
.xdata$x:00005B21                 db    0
.xdata$x:00005B22                 db    0
.xdata$x:00005B23                 db    0
.xdata$x:00005B24                 db    0
.xdata$x:00005B25                 db    0
.xdata$x:00005B26                 db    0
.xdata$x:00005B27                 db    0
.xdata$x:00005B28                 db    0
.xdata$x:00005B29                 db    0
.xdata$x:00005B2A                 db    0
.xdata$x:00005B2B                 db    0
.xdata$x:00005B2C                 db    0
.xdata$x:00005B2D                 db    0
.xdata$x:00005B2E                 db    0
.xdata$x:00005B2F                 db    0
.xdata$x:00005B30                 db    1
.xdata$x:00005B31                 db    0
.xdata$x:00005B32                 db    0
.xdata$x:00005B33                 db    0
.xdata$x:00005B33 _xdata$x        ends
.xdata$x:00005B33
.text:00005B34 ; ===========================================================================
.text:00005B34
.text:00005B34 ; Segment type: Pure code
.text:00005B34 ; Segment permissions: Read/Execute
.text:00005B34 _text           segment para public 'CODE' use32
.text:00005B34                 assume cs:_text
.text:00005B34                 ;org 5B34h
.text:00005B34 ; COMDAT (pick any)
.text:00005B34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00005B34
.text:00005B34 ; =============== S U B R O U T I N E =======================================
.text:00005B34
.text:00005B34 ; Attributes: bp-based frame
.text:00005B34
.text:00005B34 ; public: class UString const & __thiscall CObjectVector<class UString>::operator[](unsigned int)const
.text:00005B34                 public ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z
.text:00005B34 ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z proc near
.text:00005B34                                         ; CODE XREF: CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+2B6p
.text:00005B34                                         ; CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+3BBp ...
.text:00005B34
.text:00005B34 var_4           = dword ptr -4
.text:00005B34 arg_0           = dword ptr  8
.text:00005B34
.text:00005B34                 push    ebp
.text:00005B35                 mov     ebp, esp
.text:00005B37                 push    ecx
.text:00005B38                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00005B3F                 mov     [ebp+var_4], ecx
.text:00005B42                 mov     eax, [ebp+arg_0]
.text:00005B45                 push    eax
.text:00005B46                 mov     ecx, [ebp+var_4]
.text:00005B49                 call    ??A?$CRecordVector@PAX@@QBEABQAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00005B4E                 mov     eax, [eax]
.text:00005B50                 add     esp, 4
.text:00005B53                 cmp     ebp, esp
.text:00005B55                 call    __RTC_CheckEsp
.text:00005B5A                 mov     esp, ebp
.text:00005B5C                 pop     ebp
.text:00005B5D                 retn    4
.text:00005B5D ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z endp
.text:00005B5D
.text:00005B5D _text           ends
.text:00005B5D
.text:00005B60 ; ===========================================================================
.text:00005B60
.text:00005B60 ; Segment type: Pure code
.text:00005B60 ; Segment permissions: Read/Execute
.text:00005B60 _text           segment para public 'CODE' use32
.text:00005B60                 assume cs:_text
.text:00005B60                 ;org 5B60h
.text:00005B60 ; COMDAT (pick any)
.text:00005B60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00005B60
.text:00005B60 ; =============== S U B R O U T I N E =======================================
.text:00005B60
.text:00005B60 ; Attributes: bp-based frame
.text:00005B60
.text:00005B60 ; public: class UString & __thiscall CObjectVector<class UString>::operator[](unsigned int)
.text:00005B60                 public ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z
.text:00005B60 ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z proc near
.text:00005B60                                         ; CODE XREF: EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *)+21Cp
.text:00005B60                                         ; EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *)+2F1p ...
.text:00005B60
.text:00005B60 var_4           = dword ptr -4
.text:00005B60 arg_0           = dword ptr  8
.text:00005B60
.text:00005B60                 push    ebp
.text:00005B61                 mov     ebp, esp
.text:00005B63                 push    ecx
.text:00005B64                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00005B6B                 mov     [ebp+var_4], ecx
.text:00005B6E                 mov     eax, [ebp+arg_0]
.text:00005B71                 push    eax
.text:00005B72                 mov     ecx, [ebp+var_4]
.text:00005B75                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00005B7A                 mov     eax, [eax]
.text:00005B7C                 add     esp, 4
.text:00005B7F                 cmp     ebp, esp
.text:00005B81                 call    __RTC_CheckEsp
.text:00005B86                 mov     esp, ebp
.text:00005B88                 pop     ebp
.text:00005B89                 retn    4
.text:00005B89 ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z endp
.text:00005B89
.text:00005B89 _text           ends
.text:00005B89
.text:00005B8C ; ===========================================================================
.text:00005B8C
.text:00005B8C ; Segment type: Pure code
.text:00005B8C ; Segment permissions: Read/Execute
.text:00005B8C _text           segment para public 'CODE' use32
.text:00005B8C                 assume cs:_text
.text:00005B8C                 ;org 5B8Ch
.text:00005B8C ; COMDAT (pick any)
.text:00005B8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00005B8C
.text:00005B8C ; =============== S U B R O U T I N E =======================================
.text:00005B8C
.text:00005B8C ; Attributes: bp-based frame
.text:00005B8C
.text:00005B8C ; public: class UString const & __thiscall CObjectVector<class UString>::Front(void)const
.text:00005B8C                 public ?Front@?$CObjectVector@VUString@@@@QBEABVUString@@XZ
.text:00005B8C ?Front@?$CObjectVector@VUString@@@@QBEABVUString@@XZ proc near
.text:00005B8C                                         ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+748p
.text:00005B8C                                         ; CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+9AEp ...
.text:00005B8C
.text:00005B8C var_4           = dword ptr -4
.text:00005B8C
.text:00005B8C                 push    ebp
.text:00005B8D                 mov     ebp, esp
.text:00005B8F                 push    ecx
.text:00005B90                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00005B97                 mov     [ebp+var_4], ecx
.text:00005B9A                 push    0
.text:00005B9C                 mov     ecx, [ebp+var_4]
.text:00005B9F                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00005BA4                 add     esp, 4
.text:00005BA7                 cmp     ebp, esp
.text:00005BA9                 call    __RTC_CheckEsp
.text:00005BAE                 mov     esp, ebp
.text:00005BB0                 pop     ebp
.text:00005BB1                 retn
.text:00005BB1 ?Front@?$CObjectVector@VUString@@@@QBEABVUString@@XZ endp
.text:00005BB1
.text:00005BB1 ; ---------------------------------------------------------------------------
.text:00005BB2                 align 4
.text:00005BB2 _text           ends
.text:00005BB2
.text:00005BB4 ; ===========================================================================
.text:00005BB4
.text:00005BB4 ; Segment type: Pure code
.text:00005BB4 ; Segment permissions: Read/Execute
.text:00005BB4 _text           segment para public 'CODE' use32
.text:00005BB4                 assume cs:_text
.text:00005BB4                 ;org 5BB4h
.text:00005BB4 ; COMDAT (pick any)
.text:00005BB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00005BB4
.text:00005BB4 ; =============== S U B R O U T I N E =======================================
.text:00005BB4
.text:00005BB4 ; Attributes: bp-based frame
.text:00005BB4
.text:00005BB4 ; public: class UString & __thiscall CObjectVector<class UString>::Front(void)
.text:00005BB4                 public ?Front@?$CObjectVector@VUString@@@@QAEAAVUString@@XZ
.text:00005BB4 ?Front@?$CObjectVector@VUString@@@@QAEAAVUString@@XZ proc near
.text:00005BB4                                         ; CODE XREF: ConvertToLongNames(UString const &,CObjectVector<NWildcard::CItem> &)+7Fp
.text:00005BB4
.text:00005BB4 var_4           = dword ptr -4
.text:00005BB4
.text:00005BB4                 push    ebp
.text:00005BB5                 mov     ebp, esp
.text:00005BB7                 push    ecx
.text:00005BB8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00005BBF                 mov     [ebp+var_4], ecx
.text:00005BC2                 push    0
.text:00005BC4                 mov     ecx, [ebp+var_4]
.text:00005BC7                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00005BCC                 add     esp, 4
.text:00005BCF                 cmp     ebp, esp
.text:00005BD1                 call    __RTC_CheckEsp
.text:00005BD6                 mov     esp, ebp
.text:00005BD8                 pop     ebp
.text:00005BD9                 retn
.text:00005BD9 ?Front@?$CObjectVector@VUString@@@@QAEAAVUString@@XZ endp
.text:00005BD9
.text:00005BD9 ; ---------------------------------------------------------------------------
.text:00005BDA                 align 4
.text:00005BDA _text           ends
.text:00005BDA
.text:00005BDC ; ===========================================================================
.text:00005BDC
.text:00005BDC ; Segment type: Pure code
.text:00005BDC ; Segment permissions: Read/Execute
.text:00005BDC _text           segment para public 'CODE' use32
.text:00005BDC                 assume cs:_text
.text:00005BDC                 ;org 5BDCh
.text:00005BDC ; COMDAT (pick any)
.text:00005BDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00005BDC
.text:00005BDC ; =============== S U B R O U T I N E =======================================
.text:00005BDC
.text:00005BDC ; Attributes: bp-based frame
.text:00005BDC
.text:00005BDC ; public: class UString const & __thiscall CObjectVector<class UString>::Back(void)const
.text:00005BDC                 public ?Back@?$CObjectVector@VUString@@@@QBEABVUString@@XZ
.text:00005BDC ?Back@?$CObjectVector@VUString@@@@QBEABVUString@@XZ proc near
.text:00005BDC                                         ; CODE XREF: FindCharset(NCommandLineParser::CParser const &,uint,bool,int)+61p
.text:00005BDC
.text:00005BDC var_4           = dword ptr -4
.text:00005BDC
.text:00005BDC                 push    ebp
.text:00005BDD                 mov     ebp, esp
.text:00005BDF                 push    ecx
.text:00005BE0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00005BE7                 mov     [ebp+var_4], ecx
.text:00005BEA                 mov     ecx, [ebp+var_4]
.text:00005BED                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00005BF2                 sub     eax, 1
.text:00005BF5                 push    eax
.text:00005BF6                 mov     ecx, [ebp+var_4]
.text:00005BF9                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00005BFE                 add     esp, 4
.text:00005C01                 cmp     ebp, esp
.text:00005C03                 call    __RTC_CheckEsp
.text:00005C08                 mov     esp, ebp
.text:00005C0A                 pop     ebp
.text:00005C0B                 retn
.text:00005C0B ?Back@?$CObjectVector@VUString@@@@QBEABVUString@@XZ endp
.text:00005C0B
.text:00005C0B _text           ends
.text:00005C0B
.text:00005C0C ; ===========================================================================
.text:00005C0C
.text:00005C0C ; Segment type: Pure code
.text:00005C0C ; Segment permissions: Read/Execute
.text:00005C0C _text           segment para public 'CODE' use32
.text:00005C0C                 assume cs:_text
.text:00005C0C                 ;org 5C0Ch
.text:00005C0C ; COMDAT (pick any)
.text:00005C0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00005C0C
.text:00005C0C ; =============== S U B R O U T I N E =======================================
.text:00005C0C
.text:00005C0C ; Attributes: bp-based frame
.text:00005C0C
.text:00005C0C ; public: unsigned int __thiscall CObjectVector<class UString>::Add(class UString const &)
.text:00005C0C                 public ?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z
.text:00005C0C ?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z proc near
.text:00005C0C                                         ; CODE XREF: EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *)+169p
.text:00005C0C                                         ; EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *)+23Bp
.text:00005C0C
.text:00005C0C var_1C          = dword ptr -1Ch
.text:00005C0C var_18          = dword ptr -18h
.text:00005C0C var_14          = dword ptr -14h
.text:00005C0C var_10          = dword ptr -10h
.text:00005C0C var_C           = dword ptr -0Ch
.text:00005C0C var_4           = dword ptr -4
.text:00005C0C arg_0           = dword ptr  8
.text:00005C0C
.text:00005C0C                 push    ebp
.text:00005C0D                 mov     ebp, esp
.text:00005C0F                 push    0FFFFFFFFh
.text:00005C11                 push    offset __ehhandler$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z
.text:00005C16                 mov     eax, large fs:0
.text:00005C1C                 push    eax
.text:00005C1D                 sub     esp, 10h
.text:00005C20                 mov     eax, 0CCCCCCCCh
.text:00005C25                 mov     [ebp+var_1C], eax
.text:00005C28                 mov     [ebp+var_18], eax
.text:00005C2B                 mov     [ebp+var_14], eax
.text:00005C2E                 mov     [ebp+var_10], eax
.text:00005C31                 mov     eax, dword ptr ds:___security_cookie
.text:00005C36                 xor     eax, ebp
.text:00005C38                 push    eax
.text:00005C39                 lea     eax, [ebp+var_C]
.text:00005C3C                 mov     large fs:0, eax
.text:00005C42                 mov     [ebp+var_10], ecx
.text:00005C45                 push    0Ch             ; unsigned int
.text:00005C47                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00005C4C                 add     esp, 4
.text:00005C4F                 mov     [ebp+var_18], eax
.text:00005C52                 mov     [ebp+var_4], 0
.text:00005C59                 cmp     [ebp+var_18], 0
.text:00005C5D                 jz      short loc_5C70
.text:00005C5F                 mov     eax, [ebp+arg_0]
.text:00005C62                 push    eax
.text:00005C63                 mov     ecx, [ebp+var_18]
.text:00005C66                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00005C6B                 mov     [ebp+var_1C], eax
.text:00005C6E                 jmp     short loc_5C77
.text:00005C70 ; ---------------------------------------------------------------------------
.text:00005C70
.text:00005C70 loc_5C70:                               ; CODE XREF: CObjectVector<UString>::Add(UString const &)+51j
.text:00005C70                 mov     [ebp+var_1C], 0
.text:00005C77
.text:00005C77 loc_5C77:                               ; CODE XREF: CObjectVector<UString>::Add(UString const &)+62j
.text:00005C77                 mov     ecx, [ebp+var_1C]
.text:00005C7A                 mov     [ebp+var_14], ecx
.text:00005C7D                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00005C84                 mov     edx, [ebp+var_14]
.text:00005C87                 push    edx
.text:00005C88                 mov     ecx, [ebp+var_10]
.text:00005C8B                 call    ?Add@?$CRecordVector@PAX@@QAEIQAX@Z ; CRecordVector<void *>::Add(void * const)
.text:00005C90                 mov     ecx, [ebp+var_C]
.text:00005C93                 mov     large fs:0, ecx
.text:00005C9A                 pop     ecx
.text:00005C9B                 add     esp, 1Ch
.text:00005C9E                 cmp     ebp, esp
.text:00005CA0                 call    __RTC_CheckEsp
.text:00005CA5                 mov     esp, ebp
.text:00005CA7                 pop     ebp
.text:00005CA8                 retn    4
.text:00005CA8 ?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z endp
.text:00005CA8
.text:00005CA8 ; ---------------------------------------------------------------------------
.text:00005CAB                 align 4
.text:00005CAB _text           ends
.text:00005CAB
.text$x:00005CAC ; ===========================================================================
.text$x:00005CAC
.text$x:00005CAC ; Segment type: Pure code
.text$x:00005CAC ; Segment permissions: Read/Execute
.text$x:00005CAC _text$x         segment para public 'CODE' use32
.text$x:00005CAC                 assume cs:_text$x
.text$x:00005CAC                 ;org 5CACh
.text$x:00005CAC ; COMDAT (pick associative to section at 5C0C)
.text$x:00005CAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005CAC
.text$x:00005CAC ; =============== S U B R O U T I N E =======================================
.text$x:00005CAC
.text$x:00005CAC
.text$x:00005CAC __unwindfunclet$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z$0 proc near
.text$x:00005CAC                                         ; DATA XREF: .xdata$x:00005CD8o
.text$x:00005CAC                 mov     eax, [ebp-18h]
.text$x:00005CAF                 push    eax             ; void *
.text$x:00005CB0                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00005CB5                 pop     ecx
.text$x:00005CB6                 retn
.text$x:00005CB6 __unwindfunclet$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z$0 endp
.text$x:00005CB6
.text$x:00005CB7
.text$x:00005CB7 ; =============== S U B R O U T I N E =======================================
.text$x:00005CB7
.text$x:00005CB7
.text$x:00005CB7 __ehhandler$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z proc near
.text$x:00005CB7                                         ; DATA XREF: CObjectVector<UString>::Add(UString const &)+5o
.text$x:00005CB7
.text$x:00005CB7 arg_4           = dword ptr  8
.text$x:00005CB7
.text$x:00005CB7                 mov     edx, [esp+arg_4]
.text$x:00005CBB                 lea     eax, [edx+0Ch]
.text$x:00005CBE                 mov     ecx, [edx-14h]
.text$x:00005CC1                 xor     ecx, eax
.text$x:00005CC3                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005CC8                 mov     eax, offset __ehfuncinfo$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z
.text$x:00005CCD                 jmp     ___CxxFrameHandler3
.text$x:00005CCD __ehhandler$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z endp
.text$x:00005CCD
.text$x:00005CCD ; ---------------------------------------------------------------------------
.text$x:00005CD2                 align 4
.text$x:00005CD2 _text$x         ends
.text$x:00005CD2
.xdata$x:00005CD4 ; ===========================================================================
.xdata$x:00005CD4
.xdata$x:00005CD4 ; Segment type: Pure data
.xdata$x:00005CD4 ; Segment permissions: Read
.xdata$x:00005CD4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005CD4                 assume cs:_xdata$x
.xdata$x:00005CD4                 ;org 5CD4h
.xdata$x:00005CD4 ; COMDAT (pick associative to section at 5C0C)
.xdata$x:00005CD4 __unwindtable$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z db 0FFh
.xdata$x:00005CD4                                         ; DATA XREF: .xdata$x:00005CE4o
.xdata$x:00005CD5                 db 0FFh
.xdata$x:00005CD6                 db 0FFh
.xdata$x:00005CD7                 db 0FFh
.xdata$x:00005CD8                 dd offset __unwindfunclet$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z$0
.xdata$x:00005CDC __ehfuncinfo$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z db  22h ; "
.xdata$x:00005CDC                                         ; DATA XREF: __ehhandler$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z+11o
.xdata$x:00005CDD                 db    5
.xdata$x:00005CDE                 db  93h ; Ã´
.xdata$x:00005CDF                 db  19h
.xdata$x:00005CE0                 db    1
.xdata$x:00005CE1                 db    0
.xdata$x:00005CE2                 db    0
.xdata$x:00005CE3                 db    0
.xdata$x:00005CE4                 dd offset __unwindtable$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z
.xdata$x:00005CE8                 db    0
.xdata$x:00005CE9                 db    0
.xdata$x:00005CEA                 db    0
.xdata$x:00005CEB                 db    0
.xdata$x:00005CEC                 db    0
.xdata$x:00005CED                 db    0
.xdata$x:00005CEE                 db    0
.xdata$x:00005CEF                 db    0
.xdata$x:00005CF0                 db    0
.xdata$x:00005CF1                 db    0
.xdata$x:00005CF2                 db    0
.xdata$x:00005CF3                 db    0
.xdata$x:00005CF4                 db    0
.xdata$x:00005CF5                 db    0
.xdata$x:00005CF6                 db    0
.xdata$x:00005CF7                 db    0
.xdata$x:00005CF8                 db    0
.xdata$x:00005CF9                 db    0
.xdata$x:00005CFA                 db    0
.xdata$x:00005CFB                 db    0
.xdata$x:00005CFC                 db    1
.xdata$x:00005CFD                 db    0
.xdata$x:00005CFE                 db    0
.xdata$x:00005CFF                 db    0
.xdata$x:00005CFF _xdata$x        ends
.xdata$x:00005CFF
.text:00005D00 ; ===========================================================================
.text:00005D00
.text:00005D00 ; Segment type: Pure code
.text:00005D00 ; Segment permissions: Read/Execute
.text:00005D00 _text           segment para public 'CODE' use32
.text:00005D00                 assume cs:_text
.text:00005D00                 ;org 5D00h
.text:00005D00 ; COMDAT (pick any)
.text:00005D00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00005D00
.text:00005D00 ; =============== S U B R O U T I N E =======================================
.text:00005D00
.text:00005D00 ; Attributes: bp-based frame
.text:00005D00
.text:00005D00 ; public: void __thiscall CObjectVector<class UString>::AddInReserved(class UString const &)
.text:00005D00                 public ?AddInReserved@?$CObjectVector@VUString@@@@QAEXABVUString@@@Z
.text:00005D00 ?AddInReserved@?$CObjectVector@VUString@@@@QAEXABVUString@@@Z proc near
.text:00005D00                                         ; CODE XREF: EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *)+2FAp
.text:00005D00                                         ; EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *)+315p
.text:00005D00
.text:00005D00 var_1C          = dword ptr -1Ch
.text:00005D00 var_18          = dword ptr -18h
.text:00005D00 var_14          = dword ptr -14h
.text:00005D00 var_10          = dword ptr -10h
.text:00005D00 var_C           = dword ptr -0Ch
.text:00005D00 var_4           = dword ptr -4
.text:00005D00 arg_0           = dword ptr  8
.text:00005D00
.text:00005D00                 push    ebp
.text:00005D01                 mov     ebp, esp
.text:00005D03                 push    0FFFFFFFFh
.text:00005D05                 push    offset __ehhandler$?AddInReserved@?$CObjectVector@VUString@@@@QAEXABVUString@@@Z
.text:00005D0A                 mov     eax, large fs:0
.text:00005D10                 push    eax
.text:00005D11                 sub     esp, 10h
.text:00005D14                 mov     eax, 0CCCCCCCCh
.text:00005D19                 mov     [ebp+var_1C], eax
.text:00005D1C                 mov     [ebp+var_18], eax
.text:00005D1F                 mov     [ebp+var_14], eax
.text:00005D22                 mov     [ebp+var_10], eax
.text:00005D25                 mov     eax, dword ptr ds:___security_cookie
.text:00005D2A                 xor     eax, ebp
.text:00005D2C                 push    eax
.text:00005D2D                 lea     eax, [ebp+var_C]
.text:00005D30                 mov     large fs:0, eax
.text:00005D36                 mov     [ebp+var_10], ecx
.text:00005D39                 push    0Ch             ; unsigned int
.text:00005D3B                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00005D40                 add     esp, 4
.text:00005D43                 mov     [ebp+var_18], eax
.text:00005D46                 mov     [ebp+var_4], 0
.text:00005D4D                 cmp     [ebp+var_18], 0
.text:00005D51                 jz      short loc_5D64
.text:00005D53                 mov     eax, [ebp+arg_0]
.text:00005D56                 push    eax
.text:00005D57                 mov     ecx, [ebp+var_18]
.text:00005D5A                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00005D5F                 mov     [ebp+var_1C], eax
.text:00005D62                 jmp     short loc_5D6B
.text:00005D64 ; ---------------------------------------------------------------------------
.text:00005D64
.text:00005D64 loc_5D64:                               ; CODE XREF: CObjectVector<UString>::AddInReserved(UString const &)+51j
.text:00005D64                 mov     [ebp+var_1C], 0
.text:00005D6B
.text:00005D6B loc_5D6B:                               ; CODE XREF: CObjectVector<UString>::AddInReserved(UString const &)+62j
.text:00005D6B                 mov     ecx, [ebp+var_1C]
.text:00005D6E                 mov     [ebp+var_14], ecx
.text:00005D71                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00005D78                 mov     edx, [ebp+var_14]
.text:00005D7B                 push    edx
.text:00005D7C                 mov     ecx, [ebp+var_10]
.text:00005D7F                 call    ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z ; CRecordVector<void *>::AddInReserved(void * const)
.text:00005D84                 mov     ecx, [ebp+var_C]
.text:00005D87                 mov     large fs:0, ecx
.text:00005D8E                 pop     ecx
.text:00005D8F                 add     esp, 1Ch
.text:00005D92                 cmp     ebp, esp
.text:00005D94                 call    __RTC_CheckEsp
.text:00005D99                 mov     esp, ebp
.text:00005D9B                 pop     ebp
.text:00005D9C                 retn    4
.text:00005D9C ?AddInReserved@?$CObjectVector@VUString@@@@QAEXABVUString@@@Z endp
.text:00005D9C
.text:00005D9C ; ---------------------------------------------------------------------------
.text:00005D9F                 align 10h
.text:00005D9F _text           ends
.text:00005D9F
.text$x:00005DA0 ; ===========================================================================
.text$x:00005DA0
.text$x:00005DA0 ; Segment type: Pure code
.text$x:00005DA0 ; Segment permissions: Read/Execute
.text$x:00005DA0 _text$x         segment para public 'CODE' use32
.text$x:00005DA0                 assume cs:_text$x
.text$x:00005DA0                 ;org 5DA0h
.text$x:00005DA0 ; COMDAT (pick associative to section at 5D00)
.text$x:00005DA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005DA0
.text$x:00005DA0 ; =============== S U B R O U T I N E =======================================
.text$x:00005DA0
.text$x:00005DA0
.text$x:00005DA0 __unwindfunclet$?AddInReserved@?$CObjectVector@VUString@@@@QAEXABVUString@@@Z$0 proc near
.text$x:00005DA0                                         ; DATA XREF: .xdata$x:00005DCCo
.text$x:00005DA0                 mov     eax, [ebp-18h]
.text$x:00005DA3                 push    eax             ; void *
.text$x:00005DA4                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00005DA9                 pop     ecx
.text$x:00005DAA                 retn
.text$x:00005DAA __unwindfunclet$?AddInReserved@?$CObjectVector@VUString@@@@QAEXABVUString@@@Z$0 endp
.text$x:00005DAA
.text$x:00005DAB
.text$x:00005DAB ; =============== S U B R O U T I N E =======================================
.text$x:00005DAB
.text$x:00005DAB
.text$x:00005DAB __ehhandler$?AddInReserved@?$CObjectVector@VUString@@@@QAEXABVUString@@@Z proc near
.text$x:00005DAB                                         ; DATA XREF: CObjectVector<UString>::AddInReserved(UString const &)+5o
.text$x:00005DAB
.text$x:00005DAB arg_4           = dword ptr  8
.text$x:00005DAB
.text$x:00005DAB                 mov     edx, [esp+arg_4]
.text$x:00005DAF                 lea     eax, [edx+0Ch]
.text$x:00005DB2                 mov     ecx, [edx-14h]
.text$x:00005DB5                 xor     ecx, eax
.text$x:00005DB7                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005DBC                 mov     eax, offset __ehfuncinfo$?AddInReserved@?$CObjectVector@VUString@@@@QAEXABVUString@@@Z
.text$x:00005DC1                 jmp     ___CxxFrameHandler3
.text$x:00005DC1 __ehhandler$?AddInReserved@?$CObjectVector@VUString@@@@QAEXABVUString@@@Z endp
.text$x:00005DC1
.text$x:00005DC1 ; ---------------------------------------------------------------------------
.text$x:00005DC6                 align 4
.text$x:00005DC6 _text$x         ends
.text$x:00005DC6
.xdata$x:00005DC8 ; ===========================================================================
.xdata$x:00005DC8
.xdata$x:00005DC8 ; Segment type: Pure data
.xdata$x:00005DC8 ; Segment permissions: Read
.xdata$x:00005DC8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005DC8                 assume cs:_xdata$x
.xdata$x:00005DC8                 ;org 5DC8h
.xdata$x:00005DC8 ; COMDAT (pick associative to section at 5D00)
.xdata$x:00005DC8 __unwindtable$?AddInReserved@?$CObjectVector@VUString@@@@QAEXABVUString@@@Z db 0FFh
.xdata$x:00005DC8                                         ; DATA XREF: .xdata$x:00005DD8o
.xdata$x:00005DC9                 db 0FFh
.xdata$x:00005DCA                 db 0FFh
.xdata$x:00005DCB                 db 0FFh
.xdata$x:00005DCC                 dd offset __unwindfunclet$?AddInReserved@?$CObjectVector@VUString@@@@QAEXABVUString@@@Z$0
.xdata$x:00005DD0 __ehfuncinfo$?AddInReserved@?$CObjectVector@VUString@@@@QAEXABVUString@@@Z db  22h ; "
.xdata$x:00005DD0                                         ; DATA XREF: __ehhandler$?AddInReserved@?$CObjectVector@VUString@@@@QAEXABVUString@@@Z+11o
.xdata$x:00005DD1                 db    5
.xdata$x:00005DD2                 db  93h ; Ã´
.xdata$x:00005DD3                 db  19h
.xdata$x:00005DD4                 db    1
.xdata$x:00005DD5                 db    0
.xdata$x:00005DD6                 db    0
.xdata$x:00005DD7                 db    0
.xdata$x:00005DD8                 dd offset __unwindtable$?AddInReserved@?$CObjectVector@VUString@@@@QAEXABVUString@@@Z
.xdata$x:00005DDC                 db    0
.xdata$x:00005DDD                 db    0
.xdata$x:00005DDE                 db    0
.xdata$x:00005DDF                 db    0
.xdata$x:00005DE0                 db    0
.xdata$x:00005DE1                 db    0
.xdata$x:00005DE2                 db    0
.xdata$x:00005DE3                 db    0
.xdata$x:00005DE4                 db    0
.xdata$x:00005DE5                 db    0
.xdata$x:00005DE6                 db    0
.xdata$x:00005DE7                 db    0
.xdata$x:00005DE8                 db    0
.xdata$x:00005DE9                 db    0
.xdata$x:00005DEA                 db    0
.xdata$x:00005DEB                 db    0
.xdata$x:00005DEC                 db    0
.xdata$x:00005DED                 db    0
.xdata$x:00005DEE                 db    0
.xdata$x:00005DEF                 db    0
.xdata$x:00005DF0                 db    1
.xdata$x:00005DF1                 db    0
.xdata$x:00005DF2                 db    0
.xdata$x:00005DF3                 db    0
.xdata$x:00005DF3 _xdata$x        ends
.xdata$x:00005DF3
.text:00005DF4 ; ===========================================================================
.text:00005DF4
.text:00005DF4 ; Segment type: Pure code
.text:00005DF4 ; Segment permissions: Read/Execute
.text:00005DF4 _text           segment para public 'CODE' use32
.text:00005DF4                 assume cs:_text
.text:00005DF4                 ;org 5DF4h
.text:00005DF4 ; COMDAT (pick any)
.text:00005DF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00005DF4
.text:00005DF4 ; =============== S U B R O U T I N E =======================================
.text:00005DF4
.text:00005DF4 ; Attributes: bp-based frame
.text:00005DF4
.text:00005DF4 ; public: __thiscall CObjectVector<class UString>::~CObjectVector<class UString>(void)
.text:00005DF4                 public ??1?$CObjectVector@VUString@@@@QAE@XZ
.text:00005DF4 ??1?$CObjectVector@VUString@@@@QAE@XZ proc near
.text:00005DF4                                         ; CODE XREF: EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *)+C8p
.text:00005DF4                                         ; EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *)+3BDp ...
.text:00005DF4
.text:00005DF4 var_20          = dword ptr -20h
.text:00005DF4 var_1C          = dword ptr -1Ch
.text:00005DF4 var_18          = dword ptr -18h
.text:00005DF4 var_14          = dword ptr -14h
.text:00005DF4 var_10          = dword ptr -10h
.text:00005DF4 var_C           = dword ptr -0Ch
.text:00005DF4 var_4           = dword ptr -4
.text:00005DF4
.text:00005DF4                 push    ebp
.text:00005DF5                 mov     ebp, esp
.text:00005DF7                 push    0FFFFFFFFh
.text:00005DF9                 push    offset __ehhandler$??1?$CObjectVector@VUString@@@@QAE@XZ
.text:00005DFE                 mov     eax, large fs:0
.text:00005E04                 push    eax
.text:00005E05                 sub     esp, 14h
.text:00005E08                 mov     eax, 0CCCCCCCCh
.text:00005E0D                 mov     [ebp+var_20], eax
.text:00005E10                 mov     [ebp+var_1C], eax
.text:00005E13                 mov     [ebp+var_18], eax
.text:00005E16                 mov     [ebp+var_14], eax
.text:00005E19                 mov     [ebp+var_10], eax
.text:00005E1C                 mov     eax, dword ptr ds:___security_cookie
.text:00005E21                 xor     eax, ebp
.text:00005E23                 push    eax
.text:00005E24                 lea     eax, [ebp+var_C]
.text:00005E27                 mov     large fs:0, eax
.text:00005E2D                 mov     [ebp+var_10], ecx
.text:00005E30                 mov     [ebp+var_4], 0
.text:00005E37                 mov     ecx, [ebp+var_10]
.text:00005E3A                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00005E3F                 mov     [ebp+var_14], eax
.text:00005E42
.text:00005E42 loc_5E42:                               ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void):loc_5E84j
.text:00005E42                 cmp     [ebp+var_14], 0
.text:00005E46                 jz      short loc_5E86
.text:00005E48                 mov     eax, [ebp+var_14]
.text:00005E4B                 sub     eax, 1
.text:00005E4E                 mov     [ebp+var_14], eax
.text:00005E51                 mov     ecx, [ebp+var_14]
.text:00005E54                 push    ecx
.text:00005E55                 mov     ecx, [ebp+var_10]
.text:00005E58                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00005E5D                 mov     edx, [eax]
.text:00005E5F                 mov     [ebp+var_1C], edx
.text:00005E62                 mov     eax, [ebp+var_1C]
.text:00005E65                 mov     [ebp+var_18], eax
.text:00005E68                 cmp     [ebp+var_18], 0
.text:00005E6C                 jz      short loc_5E7D
.text:00005E6E                 push    1
.text:00005E70                 mov     ecx, [ebp+var_18]
.text:00005E73                 call    ??_GUString@@QAEPAXI@Z ; UString::`scalar deleting destructor'(uint)
.text:00005E78                 mov     [ebp+var_20], eax
.text:00005E7B                 jmp     short loc_5E84
.text:00005E7D ; ---------------------------------------------------------------------------
.text:00005E7D
.text:00005E7D loc_5E7D:                               ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+78j
.text:00005E7D                 mov     [ebp+var_20], 0
.text:00005E84
.text:00005E84 loc_5E84:                               ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+87j
.text:00005E84                 jmp     short loc_5E42
.text:00005E86 ; ---------------------------------------------------------------------------
.text:00005E86
.text:00005E86 loc_5E86:                               ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+52j
.text:00005E86                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00005E8D                 mov     ecx, [ebp+var_10]
.text:00005E90                 call    ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text:00005E95                 mov     ecx, [ebp+var_C]
.text:00005E98                 mov     large fs:0, ecx
.text:00005E9F                 pop     ecx
.text:00005EA0                 add     esp, 20h
.text:00005EA3                 cmp     ebp, esp
.text:00005EA5                 call    __RTC_CheckEsp
.text:00005EAA                 mov     esp, ebp
.text:00005EAC                 pop     ebp
.text:00005EAD                 retn
.text:00005EAD ??1?$CObjectVector@VUString@@@@QAE@XZ endp
.text:00005EAD
.text:00005EAD ; ---------------------------------------------------------------------------
.text:00005EAE                 align 10h
.text:00005EAE _text           ends
.text:00005EAE
.text$x:00005EB0 ; ===========================================================================
.text$x:00005EB0
.text$x:00005EB0 ; Segment type: Pure code
.text$x:00005EB0 ; Segment permissions: Read/Execute
.text$x:00005EB0 _text$x         segment para public 'CODE' use32
.text$x:00005EB0                 assume cs:_text$x
.text$x:00005EB0                 ;org 5EB0h
.text$x:00005EB0 ; COMDAT (pick associative to section at 5DF4)
.text$x:00005EB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005EB0
.text$x:00005EB0 ; =============== S U B R O U T I N E =======================================
.text$x:00005EB0
.text$x:00005EB0
.text$x:00005EB0 __unwindfunclet$??1?$CObjectVector@VUString@@@@QAE@XZ$0 proc near
.text$x:00005EB0                                         ; DATA XREF: .xdata$x:00005ED8o
.text$x:00005EB0                 mov     ecx, [ebp-10h]
.text$x:00005EB3                 jmp     ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text$x:00005EB3 __unwindfunclet$??1?$CObjectVector@VUString@@@@QAE@XZ$0 endp
.text$x:00005EB3
.text$x:00005EB8
.text$x:00005EB8 ; =============== S U B R O U T I N E =======================================
.text$x:00005EB8
.text$x:00005EB8
.text$x:00005EB8 __ehhandler$??1?$CObjectVector@VUString@@@@QAE@XZ proc near
.text$x:00005EB8                                         ; DATA XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+5o
.text$x:00005EB8
.text$x:00005EB8 arg_4           = dword ptr  8
.text$x:00005EB8
.text$x:00005EB8                 mov     edx, [esp+arg_4]
.text$x:00005EBC                 lea     eax, [edx+0Ch]
.text$x:00005EBF                 mov     ecx, [edx-18h]
.text$x:00005EC2                 xor     ecx, eax
.text$x:00005EC4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005EC9                 mov     eax, offset __ehfuncinfo$??1?$CObjectVector@VUString@@@@QAE@XZ
.text$x:00005ECE                 jmp     ___CxxFrameHandler3
.text$x:00005ECE __ehhandler$??1?$CObjectVector@VUString@@@@QAE@XZ endp
.text$x:00005ECE
.text$x:00005ECE ; ---------------------------------------------------------------------------
.text$x:00005ED3                 align 4
.text$x:00005ED3 _text$x         ends
.text$x:00005ED3
.xdata$x:00005ED4 ; ===========================================================================
.xdata$x:00005ED4
.xdata$x:00005ED4 ; Segment type: Pure data
.xdata$x:00005ED4 ; Segment permissions: Read
.xdata$x:00005ED4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005ED4                 assume cs:_xdata$x
.xdata$x:00005ED4                 ;org 5ED4h
.xdata$x:00005ED4 ; COMDAT (pick associative to section at 5DF4)
.xdata$x:00005ED4 __unwindtable$??1?$CObjectVector@VUString@@@@QAE@XZ db 0FFh
.xdata$x:00005ED4                                         ; DATA XREF: .xdata$x:00005EE4o
.xdata$x:00005ED5                 db 0FFh
.xdata$x:00005ED6                 db 0FFh
.xdata$x:00005ED7                 db 0FFh
.xdata$x:00005ED8                 dd offset __unwindfunclet$??1?$CObjectVector@VUString@@@@QAE@XZ$0
.xdata$x:00005EDC __ehfuncinfo$??1?$CObjectVector@VUString@@@@QAE@XZ db  22h ; "
.xdata$x:00005EDC                                         ; DATA XREF: __ehhandler$??1?$CObjectVector@VUString@@@@QAE@XZ+11o
.xdata$x:00005EDD                 db    5
.xdata$x:00005EDE                 db  93h ; Ã´
.xdata$x:00005EDF                 db  19h
.xdata$x:00005EE0                 db    1
.xdata$x:00005EE1                 db    0
.xdata$x:00005EE2                 db    0
.xdata$x:00005EE3                 db    0
.xdata$x:00005EE4                 dd offset __unwindtable$??1?$CObjectVector@VUString@@@@QAE@XZ
.xdata$x:00005EE8                 db    0
.xdata$x:00005EE9                 db    0
.xdata$x:00005EEA                 db    0
.xdata$x:00005EEB                 db    0
.xdata$x:00005EEC                 db    0
.xdata$x:00005EED                 db    0
.xdata$x:00005EEE                 db    0
.xdata$x:00005EEF                 db    0
.xdata$x:00005EF0                 db    0
.xdata$x:00005EF1                 db    0
.xdata$x:00005EF2                 db    0
.xdata$x:00005EF3                 db    0
.xdata$x:00005EF4                 db    0
.xdata$x:00005EF5                 db    0
.xdata$x:00005EF6                 db    0
.xdata$x:00005EF7                 db    0
.xdata$x:00005EF8                 db    0
.xdata$x:00005EF9                 db    0
.xdata$x:00005EFA                 db    0
.xdata$x:00005EFB                 db    0
.xdata$x:00005EFC                 db    1
.xdata$x:00005EFD                 db    0
.xdata$x:00005EFE                 db    0
.xdata$x:00005EFF                 db    0
.xdata$x:00005EFF _xdata$x        ends
.xdata$x:00005EFF
.text:00005F00 ; ===========================================================================
.text:00005F00
.text:00005F00 ; Segment type: Pure code
.text:00005F00 ; Segment permissions: Read/Execute
.text:00005F00 _text           segment para public 'CODE' use32
.text:00005F00                 assume cs:_text
.text:00005F00                 ;org 5F00h
.text:00005F00 ; COMDAT (pick any)
.text:00005F00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00005F00
.text:00005F00 ; =============== S U B R O U T I N E =======================================
.text:00005F00
.text:00005F00 ; Attributes: bp-based frame
.text:00005F00
.text:00005F00 ; public: void __thiscall CObjectVector<class UString>::Clear(void)
.text:00005F00                 public ?Clear@?$CObjectVector@VUString@@@@QAEXXZ
.text:00005F00 ?Clear@?$CObjectVector@VUString@@@@QAEXXZ proc near
.text:00005F00                                         ; CODE XREF: CObjectVector<UString>::ClearAndReserve(uint)+11p
.text:00005F00                                         ; CObjectVector<UString>::operator=(CObjectVector<UString> const &)+52p
.text:00005F00
.text:00005F00 var_14          = dword ptr -14h
.text:00005F00 var_10          = dword ptr -10h
.text:00005F00 var_C           = dword ptr -0Ch
.text:00005F00 var_8           = dword ptr -8
.text:00005F00 var_4           = dword ptr -4
.text:00005F00
.text:00005F00                 push    ebp
.text:00005F01                 mov     ebp, esp
.text:00005F03                 sub     esp, 14h
.text:00005F06                 mov     eax, 0CCCCCCCCh
.text:00005F0B                 mov     [ebp+var_14], eax
.text:00005F0E                 mov     [ebp+var_10], eax
.text:00005F11                 mov     [ebp+var_C], eax
.text:00005F14                 mov     [ebp+var_8], eax
.text:00005F17                 mov     [ebp+var_4], eax
.text:00005F1A                 mov     [ebp+var_4], ecx
.text:00005F1D                 mov     ecx, [ebp+var_4]
.text:00005F20                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00005F25                 mov     [ebp+var_8], eax
.text:00005F28
.text:00005F28 loc_5F28:                               ; CODE XREF: CObjectVector<UString>::Clear(void):loc_5F6Aj
.text:00005F28                 cmp     [ebp+var_8], 0
.text:00005F2C                 jz      short loc_5F6C
.text:00005F2E                 mov     eax, [ebp+var_8]
.text:00005F31                 sub     eax, 1
.text:00005F34                 mov     [ebp+var_8], eax
.text:00005F37                 mov     ecx, [ebp+var_8]
.text:00005F3A                 push    ecx
.text:00005F3B                 mov     ecx, [ebp+var_4]
.text:00005F3E                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00005F43                 mov     edx, [eax]
.text:00005F45                 mov     [ebp+var_10], edx
.text:00005F48                 mov     eax, [ebp+var_10]
.text:00005F4B                 mov     [ebp+var_C], eax
.text:00005F4E                 cmp     [ebp+var_C], 0
.text:00005F52                 jz      short loc_5F63
.text:00005F54                 push    1
.text:00005F56                 mov     ecx, [ebp+var_C]
.text:00005F59                 call    ??_GUString@@QAEPAXI@Z ; UString::`scalar deleting destructor'(uint)
.text:00005F5E                 mov     [ebp+var_14], eax
.text:00005F61                 jmp     short loc_5F6A
.text:00005F63 ; ---------------------------------------------------------------------------
.text:00005F63
.text:00005F63 loc_5F63:                               ; CODE XREF: CObjectVector<UString>::Clear(void)+52j
.text:00005F63                 mov     [ebp+var_14], 0
.text:00005F6A
.text:00005F6A loc_5F6A:                               ; CODE XREF: CObjectVector<UString>::Clear(void)+61j
.text:00005F6A                 jmp     short loc_5F28
.text:00005F6C ; ---------------------------------------------------------------------------
.text:00005F6C
.text:00005F6C loc_5F6C:                               ; CODE XREF: CObjectVector<UString>::Clear(void)+2Cj
.text:00005F6C                 mov     ecx, [ebp+var_4]
.text:00005F6F                 call    ?Clear@?$CRecordVector@PAX@@QAEXXZ ; CRecordVector<void *>::Clear(void)
.text:00005F74                 add     esp, 14h
.text:00005F77                 cmp     ebp, esp
.text:00005F79                 call    __RTC_CheckEsp
.text:00005F7E                 mov     esp, ebp
.text:00005F80                 pop     ebp
.text:00005F81                 retn
.text:00005F81 ?Clear@?$CObjectVector@VUString@@@@QAEXXZ endp
.text:00005F81
.text:00005F81 ; ---------------------------------------------------------------------------
.text:00005F82                 align 4
.text:00005F82 _text           ends
.text:00005F82
.text:00005F84 ; ===========================================================================
.text:00005F84
.text:00005F84 ; Segment type: Pure code
.text:00005F84 ; Segment permissions: Read/Execute
.text:00005F84 _text           segment para public 'CODE' use32
.text:00005F84                 assume cs:_text
.text:00005F84                 ;org 5F84h
.text:00005F84 ; COMDAT (pick any)
.text:00005F84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00005F84
.text:00005F84 ; =============== S U B R O U T I N E =======================================
.text:00005F84
.text:00005F84 ; Attributes: bp-based frame
.text:00005F84
.text:00005F84 ; public: unsigned int __thiscall CObjectVector<class NWildcard::CCensorNode>::Size(void)const
.text:00005F84                 public ?Size@?$CObjectVector@VCCensorNode@NWildcard@@@@QBEIXZ
.text:00005F84 ?Size@?$CObjectVector@VCCensorNode@NWildcard@@@@QBEIXZ proc near
.text:00005F84                                         ; CODE XREF: ConvertToLongNames(UString const &,NWildcard::CCensorNode &)+6Dp
.text:00005F84                                         ; ConvertToLongNames(UString const &,NWildcard::CCensorNode &)+D9p ...
.text:00005F84
.text:00005F84 var_4           = dword ptr -4
.text:00005F84
.text:00005F84                 push    ebp
.text:00005F85                 mov     ebp, esp
.text:00005F87                 push    ecx
.text:00005F88                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00005F8F                 mov     [ebp+var_4], ecx
.text:00005F92                 mov     ecx, [ebp+var_4]
.text:00005F95                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00005F9A                 add     esp, 4
.text:00005F9D                 cmp     ebp, esp
.text:00005F9F                 call    __RTC_CheckEsp
.text:00005FA4                 mov     esp, ebp
.text:00005FA6                 pop     ebp
.text:00005FA7                 retn
.text:00005FA7 ?Size@?$CObjectVector@VCCensorNode@NWildcard@@@@QBEIXZ endp
.text:00005FA7
.text:00005FA7 _text           ends
.text:00005FA7
.text:00005FA8 ; ===========================================================================
.text:00005FA8
.text:00005FA8 ; Segment type: Pure code
.text:00005FA8 ; Segment permissions: Read/Execute
.text:00005FA8 _text           segment para public 'CODE' use32
.text:00005FA8                 assume cs:_text
.text:00005FA8                 ;org 5FA8h
.text:00005FA8 ; COMDAT (pick any)
.text:00005FA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00005FA8
.text:00005FA8 ; =============== S U B R O U T I N E =======================================
.text:00005FA8
.text:00005FA8 ; Attributes: bp-based frame
.text:00005FA8
.text:00005FA8 ; public: class NWildcard::CCensorNode & __thiscall CObjectVector<class NWildcard::CCensorNode>::operator[](unsigned int)
.text:00005FA8                 public ??A?$CObjectVector@VCCensorNode@NWildcard@@@@QAEAAVCCensorNode@NWildcard@@I@Z
.text:00005FA8 ??A?$CObjectVector@VCCensorNode@NWildcard@@@@QAEAAVCCensorNode@NWildcard@@I@Z proc near
.text:00005FA8                                         ; CODE XREF: ConvertToLongNames(UString const &,NWildcard::CCensorNode &)+81p
.text:00005FA8                                         ; ConvertToLongNames(UString const &,NWildcard::CCensorNode &)+F1p ...
.text:00005FA8
.text:00005FA8 var_4           = dword ptr -4
.text:00005FA8 arg_0           = dword ptr  8
.text:00005FA8
.text:00005FA8                 push    ebp
.text:00005FA9                 mov     ebp, esp
.text:00005FAB                 push    ecx
.text:00005FAC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00005FB3                 mov     [ebp+var_4], ecx
.text:00005FB6                 mov     eax, [ebp+arg_0]
.text:00005FB9                 push    eax
.text:00005FBA                 mov     ecx, [ebp+var_4]
.text:00005FBD                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00005FC2                 mov     eax, [eax]
.text:00005FC4                 add     esp, 4
.text:00005FC7                 cmp     ebp, esp
.text:00005FC9                 call    __RTC_CheckEsp
.text:00005FCE                 mov     esp, ebp
.text:00005FD0                 pop     ebp
.text:00005FD1                 retn    4
.text:00005FD1 ??A?$CObjectVector@VCCensorNode@NWildcard@@@@QAEAAVCCensorNode@NWildcard@@I@Z endp
.text:00005FD1
.text:00005FD1 _text           ends
.text:00005FD1
.text:00005FD4 ; ===========================================================================
.text:00005FD4
.text:00005FD4 ; Segment type: Pure code
.text:00005FD4 ; Segment permissions: Read/Execute
.text:00005FD4 _text           segment para public 'CODE' use32
.text:00005FD4                 assume cs:_text
.text:00005FD4                 ;org 5FD4h
.text:00005FD4 ; COMDAT (pick any)
.text:00005FD4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00005FD4
.text:00005FD4 ; =============== S U B R O U T I N E =======================================
.text:00005FD4
.text:00005FD4 ; Attributes: bp-based frame
.text:00005FD4
.text:00005FD4 ; public: void __thiscall CObjectVector<class NWildcard::CCensorNode>::Delete(unsigned int)
.text:00005FD4                 public ?Delete@?$CObjectVector@VCCensorNode@NWildcard@@@@QAEXI@Z
.text:00005FD4 ?Delete@?$CObjectVector@VCCensorNode@NWildcard@@@@QAEXI@Z proc near
.text:00005FD4                                         ; CODE XREF: ConvertToLongNames(UString const &,NWildcard::CCensorNode &)+170p
.text:00005FD4
.text:00005FD4 var_10          = dword ptr -10h
.text:00005FD4 var_C           = dword ptr -0Ch
.text:00005FD4 var_8           = dword ptr -8
.text:00005FD4 var_4           = dword ptr -4
.text:00005FD4 arg_0           = dword ptr  8
.text:00005FD4
.text:00005FD4                 push    ebp
.text:00005FD5                 mov     ebp, esp
.text:00005FD7                 sub     esp, 10h
.text:00005FDA                 mov     eax, 0CCCCCCCCh
.text:00005FDF                 mov     [ebp+var_10], eax
.text:00005FE2                 mov     [ebp+var_C], eax
.text:00005FE5                 mov     [ebp+var_8], eax
.text:00005FE8                 mov     [ebp+var_4], eax
.text:00005FEB                 mov     [ebp+var_4], ecx
.text:00005FEE                 mov     eax, [ebp+arg_0]
.text:00005FF1                 push    eax
.text:00005FF2                 mov     ecx, [ebp+var_4]
.text:00005FF5                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00005FFA                 mov     ecx, [eax]
.text:00005FFC                 mov     [ebp+var_C], ecx
.text:00005FFF                 mov     edx, [ebp+var_C]
.text:00006002                 mov     [ebp+var_8], edx
.text:00006005                 cmp     [ebp+var_8], 0
.text:00006009                 jz      short loc_601A
.text:0000600B                 push    1
.text:0000600D                 mov     ecx, [ebp+var_8]
.text:00006010                 call    ??_GCCensorNode@NWildcard@@QAEPAXI@Z ; NWildcard::CCensorNode::`scalar deleting destructor'(uint)
.text:00006015                 mov     [ebp+var_10], eax
.text:00006018                 jmp     short loc_6021
.text:0000601A ; ---------------------------------------------------------------------------
.text:0000601A
.text:0000601A loc_601A:                               ; CODE XREF: CObjectVector<NWildcard::CCensorNode>::Delete(uint)+35j
.text:0000601A                 mov     [ebp+var_10], 0
.text:00006021
.text:00006021 loc_6021:                               ; CODE XREF: CObjectVector<NWildcard::CCensorNode>::Delete(uint)+44j
.text:00006021                 mov     eax, [ebp+arg_0]
.text:00006024                 push    eax
.text:00006025                 mov     ecx, [ebp+var_4]
.text:00006028                 call    ?Delete@?$CRecordVector@PAX@@QAEXI@Z ; CRecordVector<void *>::Delete(uint)
.text:0000602D                 add     esp, 10h
.text:00006030                 cmp     ebp, esp
.text:00006032                 call    __RTC_CheckEsp
.text:00006037                 mov     esp, ebp
.text:00006039                 pop     ebp
.text:0000603A                 retn    4
.text:0000603A ?Delete@?$CObjectVector@VCCensorNode@NWildcard@@@@QAEXI@Z endp
.text:0000603A
.text:0000603A ; ---------------------------------------------------------------------------
.text:0000603D                 align 10h
.text:0000603D _text           ends
.text:0000603D
.text:00006040 ; ===========================================================================
.text:00006040
.text:00006040 ; Segment type: Pure code
.text:00006040 ; Segment permissions: Read/Execute
.text:00006040 _text           segment para public 'CODE' use32
.text:00006040                 assume cs:_text
.text:00006040                 ;org 6040h
.text:00006040 ; COMDAT (pick any)
.text:00006040                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00006040
.text:00006040 ; =============== S U B R O U T I N E =======================================
.text:00006040
.text:00006040 ; Attributes: bp-based frame
.text:00006040
.text:00006040 ; public: unsigned int __thiscall CObjectVector<struct NWildcard::CItem>::Size(void)const
.text:00006040                 public ?Size@?$CObjectVector@UCItem@NWildcard@@@@QBEIXZ
.text:00006040 ?Size@?$CObjectVector@UCItem@NWildcard@@@@QBEIXZ proc near
.text:00006040                                         ; CODE XREF: ConvertToLongNames(UString const &,CObjectVector<NWildcard::CItem> &)+29p
.text:00006040                                         ; CObjectVector<NWildcard::CItem>::operator+=(CObjectVector<NWildcard::CItem> const &)+42p ...
.text:00006040
.text:00006040 var_4           = dword ptr -4
.text:00006040
.text:00006040                 push    ebp
.text:00006041                 mov     ebp, esp
.text:00006043                 push    ecx
.text:00006044                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000604B                 mov     [ebp+var_4], ecx
.text:0000604E                 mov     ecx, [ebp+var_4]
.text:00006051                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00006056                 add     esp, 4
.text:00006059                 cmp     ebp, esp
.text:0000605B                 call    __RTC_CheckEsp
.text:00006060                 mov     esp, ebp
.text:00006062                 pop     ebp
.text:00006063                 retn
.text:00006063 ?Size@?$CObjectVector@UCItem@NWildcard@@@@QBEIXZ endp
.text:00006063
.text:00006063 _text           ends
.text:00006063
.text:00006064 ; ===========================================================================
.text:00006064
.text:00006064 ; Segment type: Pure code
.text:00006064 ; Segment permissions: Read/Execute
.text:00006064 _text           segment para public 'CODE' use32
.text:00006064                 assume cs:_text
.text:00006064                 ;org 6064h
.text:00006064 ; COMDAT (pick any)
.text:00006064                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00006064
.text:00006064 ; =============== S U B R O U T I N E =======================================
.text:00006064
.text:00006064 ; Attributes: bp-based frame
.text:00006064
.text:00006064 ; public: class CObjectVector<struct NWildcard::CItem> & __thiscall CObjectVector<struct NWildcard::CItem>::operator+=(class CObjectVector<struct NWildcard::CItem> const &)
.text:00006064                 public ??Y?$CObjectVector@UCItem@NWildcard@@@@QAEAAV0@ABV0@@Z
.text:00006064 ??Y?$CObjectVector@UCItem@NWildcard@@@@QAEAAV0@ABV0@@Z proc near
.text:00006064                                         ; CODE XREF: ConvertToLongNames(UString const &,NWildcard::CCensorNode &)+14Fp
.text:00006064                                         ; ConvertToLongNames(UString const &,NWildcard::CCensorNode &)+161p
.text:00006064
.text:00006064 var_24          = dword ptr -24h
.text:00006064 var_20          = dword ptr -20h
.text:00006064 var_1C          = dword ptr -1Ch
.text:00006064 var_18          = dword ptr -18h
.text:00006064 var_14          = dword ptr -14h
.text:00006064 var_10          = dword ptr -10h
.text:00006064 var_C           = dword ptr -0Ch
.text:00006064 var_4           = dword ptr -4
.text:00006064 arg_0           = dword ptr  8
.text:00006064
.text:00006064                 push    ebp
.text:00006065                 mov     ebp, esp
.text:00006067                 push    0FFFFFFFFh
.text:00006069                 push    offset __ehhandler$??Y?$CObjectVector@UCItem@NWildcard@@@@QAEAAV0@ABV0@@Z
.text:0000606E                 mov     eax, large fs:0
.text:00006074                 push    eax
.text:00006075                 sub     esp, 18h
.text:00006078                 mov     eax, 0CCCCCCCCh
.text:0000607D                 mov     [ebp+var_24], eax
.text:00006080                 mov     [ebp+var_20], eax
.text:00006083                 mov     [ebp+var_1C], eax
.text:00006086                 mov     [ebp+var_18], eax
.text:00006089                 mov     [ebp+var_14], eax
.text:0000608C                 mov     [ebp+var_10], eax
.text:0000608F                 mov     eax, dword ptr ds:___security_cookie
.text:00006094                 xor     eax, ebp
.text:00006096                 push    eax
.text:00006097                 lea     eax, [ebp+var_C]
.text:0000609A                 mov     large fs:0, eax
.text:000060A0                 mov     [ebp+var_10], ecx
.text:000060A3                 mov     ecx, [ebp+arg_0]
.text:000060A6                 call    ?Size@?$CObjectVector@UCItem@NWildcard@@@@QBEIXZ ; CObjectVector<NWildcard::CItem>::Size(void)
.text:000060AB                 mov     [ebp+var_14], eax
.text:000060AE                 mov     ecx, [ebp+var_10]
.text:000060B1                 call    ?Size@?$CObjectVector@UCItem@NWildcard@@@@QBEIXZ ; CObjectVector<NWildcard::CItem>::Size(void)
.text:000060B6                 add     eax, [ebp+var_14]
.text:000060B9                 push    eax
.text:000060BA                 mov     ecx, [ebp+var_10]
.text:000060BD                 call    ?Reserve@?$CRecordVector@PAX@@QAEXI@Z ; CRecordVector<void *>::Reserve(uint)
.text:000060C2                 mov     [ebp+var_18], 0
.text:000060C9                 jmp     short loc_60D4
.text:000060CB ; ---------------------------------------------------------------------------
.text:000060CB
.text:000060CB loc_60CB:                               ; CODE XREF: CObjectVector<NWildcard::CItem>::operator+=(CObjectVector<NWildcard::CItem> const &)+CCj
.text:000060CB                 mov     eax, [ebp+var_18]
.text:000060CE                 add     eax, 1
.text:000060D1                 mov     [ebp+var_18], eax
.text:000060D4
.text:000060D4 loc_60D4:                               ; CODE XREF: CObjectVector<NWildcard::CItem>::operator+=(CObjectVector<NWildcard::CItem> const &)+65j
.text:000060D4                 mov     ecx, [ebp+var_18]
.text:000060D7                 cmp     ecx, [ebp+var_14]
.text:000060DA                 jnb     short loc_6132
.text:000060DC                 push    10h             ; unsigned int
.text:000060DE                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:000060E3                 add     esp, 4
.text:000060E6                 mov     [ebp+var_20], eax
.text:000060E9                 mov     [ebp+var_4], 0
.text:000060F0                 cmp     [ebp+var_20], 0
.text:000060F4                 jz      short loc_6110
.text:000060F6                 mov     edx, [ebp+var_18]
.text:000060F9                 push    edx
.text:000060FA                 mov     ecx, [ebp+arg_0]
.text:000060FD                 call    ??A?$CObjectVector@UCItem@NWildcard@@@@QBEABUCItem@NWildcard@@I@Z ; CObjectVector<NWildcard::CItem>::operator[](uint)
.text:00006102                 push    eax             ; struct NWildcard::CItem *
.text:00006103                 mov     ecx, [ebp+var_20] ; this
.text:00006106                 call    ??0CItem@NWildcard@@QAE@ABU01@@Z ; NWildcard::CItem::CItem(NWildcard::CItem const &)
.text:0000610B                 mov     [ebp+var_24], eax
.text:0000610E                 jmp     short loc_6117
.text:00006110 ; ---------------------------------------------------------------------------
.text:00006110
.text:00006110 loc_6110:                               ; CODE XREF: CObjectVector<NWildcard::CItem>::operator+=(CObjectVector<NWildcard::CItem> const &)+90j
.text:00006110                 mov     [ebp+var_24], 0
.text:00006117
.text:00006117 loc_6117:                               ; CODE XREF: CObjectVector<NWildcard::CItem>::operator+=(CObjectVector<NWildcard::CItem> const &)+AAj
.text:00006117                 mov     eax, [ebp+var_24]
.text:0000611A                 mov     [ebp+var_1C], eax
.text:0000611D                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00006124                 mov     ecx, [ebp+var_1C]
.text:00006127                 push    ecx
.text:00006128                 mov     ecx, [ebp+var_10]
.text:0000612B                 call    ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z ; CRecordVector<void *>::AddInReserved(void * const)
.text:00006130                 jmp     short loc_60CB
.text:00006132 ; ---------------------------------------------------------------------------
.text:00006132
.text:00006132 loc_6132:                               ; CODE XREF: CObjectVector<NWildcard::CItem>::operator+=(CObjectVector<NWildcard::CItem> const &)+76j
.text:00006132                 mov     eax, [ebp+var_10]
.text:00006135                 mov     ecx, [ebp+var_C]
.text:00006138                 mov     large fs:0, ecx
.text:0000613F                 pop     ecx
.text:00006140                 add     esp, 24h
.text:00006143                 cmp     ebp, esp
.text:00006145                 call    __RTC_CheckEsp
.text:0000614A                 mov     esp, ebp
.text:0000614C                 pop     ebp
.text:0000614D                 retn    4
.text:0000614D ??Y?$CObjectVector@UCItem@NWildcard@@@@QAEAAV0@ABV0@@Z endp
.text:0000614D
.text:0000614D _text           ends
.text:0000614D
.text$x:00006150 ; ===========================================================================
.text$x:00006150
.text$x:00006150 ; Segment type: Pure code
.text$x:00006150 ; Segment permissions: Read/Execute
.text$x:00006150 _text$x         segment para public 'CODE' use32
.text$x:00006150                 assume cs:_text$x
.text$x:00006150                 ;org 6150h
.text$x:00006150 ; COMDAT (pick associative to section at 6064)
.text$x:00006150                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006150
.text$x:00006150 ; =============== S U B R O U T I N E =======================================
.text$x:00006150
.text$x:00006150
.text$x:00006150 __unwindfunclet$??Y?$CObjectVector@UCItem@NWildcard@@@@QAEAAV0@ABV0@@Z$0 proc near
.text$x:00006150                                         ; DATA XREF: .xdata$x:0000617Co
.text$x:00006150                 mov     eax, [ebp-20h]
.text$x:00006153                 push    eax             ; void *
.text$x:00006154                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00006159                 pop     ecx
.text$x:0000615A                 retn
.text$x:0000615A __unwindfunclet$??Y?$CObjectVector@UCItem@NWildcard@@@@QAEAAV0@ABV0@@Z$0 endp
.text$x:0000615A
.text$x:0000615B
.text$x:0000615B ; =============== S U B R O U T I N E =======================================
.text$x:0000615B
.text$x:0000615B
.text$x:0000615B __ehhandler$??Y?$CObjectVector@UCItem@NWildcard@@@@QAEAAV0@ABV0@@Z proc near
.text$x:0000615B                                         ; DATA XREF: CObjectVector<NWildcard::CItem>::operator+=(CObjectVector<NWildcard::CItem> const &)+5o
.text$x:0000615B
.text$x:0000615B arg_4           = dword ptr  8
.text$x:0000615B
.text$x:0000615B                 mov     edx, [esp+arg_4]
.text$x:0000615F                 lea     eax, [edx+0Ch]
.text$x:00006162
.text$x:00006162 loc_6162:                               ; DATA XREF: .rdata:$SG76893o
.text$x:00006162                 mov     ecx, [edx-1Ch]
.text$x:00006165                 xor     ecx, eax
.text$x:00006167                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000616C                 mov     eax, offset __ehfuncinfo$??Y?$CObjectVector@UCItem@NWildcard@@@@QAEAAV0@ABV0@@Z
.text$x:00006171
.text$x:00006171 loc_6171:                               ; DATA XREF: .rdata:$SG76930o
.text$x:00006171                 jmp     ___CxxFrameHandler3
.text$x:00006171 __ehhandler$??Y?$CObjectVector@UCItem@NWildcard@@@@QAEAAV0@ABV0@@Z endp
.text$x:00006171
.text$x:00006171 ; ---------------------------------------------------------------------------
.text$x:00006176                 align 4
.text$x:00006176 _text$x         ends
.text$x:00006176
.xdata$x:00006178 ; ===========================================================================
.xdata$x:00006178
.xdata$x:00006178 ; Segment type: Pure data
.xdata$x:00006178 ; Segment permissions: Read
.xdata$x:00006178 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006178                 assume cs:_xdata$x
.xdata$x:00006178                 ;org 6178h
.xdata$x:00006178 ; COMDAT (pick associative to section at 6064)
.xdata$x:00006178 __unwindtable$??Y?$CObjectVector@UCItem@NWildcard@@@@QAEAAV0@ABV0@@Z db 0FFh
.xdata$x:00006178                                         ; DATA XREF: .xdata$x:00006188o
.xdata$x:00006179                 db 0FFh
.xdata$x:0000617A                 db 0FFh
.xdata$x:0000617B                 db 0FFh
.xdata$x:0000617C                 dd offset __unwindfunclet$??Y?$CObjectVector@UCItem@NWildcard@@@@QAEAAV0@ABV0@@Z$0
.xdata$x:00006180 __ehfuncinfo$??Y?$CObjectVector@UCItem@NWildcard@@@@QAEAAV0@ABV0@@Z db  22h ; "
.xdata$x:00006180                                         ; DATA XREF: __ehhandler$??Y?$CObjectVector@UCItem@NWildcard@@@@QAEAAV0@ABV0@@Z+11o
.xdata$x:00006181                 db    5
.xdata$x:00006182                 db  93h ; Ã´
.xdata$x:00006183                 db  19h
.xdata$x:00006184                 db    1
.xdata$x:00006185                 db    0
.xdata$x:00006186                 db    0
.xdata$x:00006187                 db    0
.xdata$x:00006188                 dd offset __unwindtable$??Y?$CObjectVector@UCItem@NWildcard@@@@QAEAAV0@ABV0@@Z
.xdata$x:0000618C                 align 20h
.xdata$x:000061A0                 db    1
.xdata$x:000061A1                 db    0
.xdata$x:000061A2                 db    0
.xdata$x:000061A3                 db    0
.xdata$x:000061A3 _xdata$x        ends
.xdata$x:000061A3
.text:000061A4 ; ===========================================================================
.text:000061A4
.text:000061A4 ; Segment type: Pure code
.text:000061A4 ; Segment permissions: Read/Execute
.text:000061A4 _text           segment para public 'CODE' use32
.text:000061A4                 assume cs:_text
.text:000061A4                 ;org 61A4h
.text:000061A4 ; COMDAT (pick any)
.text:000061A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000061A4
.text:000061A4 ; =============== S U B R O U T I N E =======================================
.text:000061A4
.text:000061A4 ; Attributes: bp-based frame
.text:000061A4
.text:000061A4 ; public: struct NWildcard::CItem & __thiscall CObjectVector<struct NWildcard::CItem>::operator[](unsigned int)
.text:000061A4                 public ??A?$CObjectVector@UCItem@NWildcard@@@@QAEAAUCItem@NWildcard@@I@Z
.text:000061A4 ??A?$CObjectVector@UCItem@NWildcard@@@@QAEAAUCItem@NWildcard@@I@Z proc near
.text:000061A4                                         ; CODE XREF: ConvertToLongNames(UString const &,CObjectVector<NWildcard::CItem> &)+3Ap
.text:000061A4
.text:000061A4 var_4           = dword ptr -4
.text:000061A4 arg_0           = dword ptr  8
.text:000061A4
.text:000061A4                 push    ebp
.text:000061A5                 mov     ebp, esp
.text:000061A7                 push    ecx
.text:000061A8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000061AF                 mov     [ebp+var_4], ecx
.text:000061B2                 mov     eax, [ebp+arg_0]
.text:000061B5                 push    eax
.text:000061B6                 mov     ecx, [ebp+var_4]
.text:000061B9                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:000061BE                 mov     eax, [eax]
.text:000061C0                 add     esp, 4
.text:000061C3                 cmp     ebp, esp
.text:000061C5                 call    __RTC_CheckEsp
.text:000061CA                 mov     esp, ebp
.text:000061CC                 pop     ebp
.text:000061CD                 retn    4
.text:000061CD ??A?$CObjectVector@UCItem@NWildcard@@@@QAEAAUCItem@NWildcard@@I@Z endp
.text:000061CD
.text:000061CD _text           ends
.text:000061CD
.text:000061D0 ; ===========================================================================
.text:000061D0
.text:000061D0 ; Segment type: Pure code
.text:000061D0 ; Segment permissions: Read/Execute
.text:000061D0 _text           segment para public 'CODE' use32
.text:000061D0                 assume cs:_text
.text:000061D0                 ;org 61D0h
.text:000061D0 ; COMDAT (pick any)
.text:000061D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000061D0
.text:000061D0 ; =============== S U B R O U T I N E =======================================
.text:000061D0
.text:000061D0 ; Attributes: bp-based frame
.text:000061D0
.text:000061D0 ; public: unsigned int __thiscall CObjectVector<struct NWildcard::CPair>::Size(void)const
.text:000061D0                 public ?Size@?$CObjectVector@UCPair@NWildcard@@@@QBEIXZ
.text:000061D0 ?Size@?$CObjectVector@UCPair@NWildcard@@@@QBEIXZ proc near
.text:000061D0                                         ; CODE XREF: ConvertToLongNames(NWildcard::CCensor &)+29p
.text:000061D0                                         ; NWildcard::CCensor::AllAreRelative(void)+1Ap
.text:000061D0
.text:000061D0 var_4           = dword ptr -4
.text:000061D0
.text:000061D0                 push    ebp
.text:000061D1                 mov     ebp, esp
.text:000061D3                 push    ecx
.text:000061D4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000061DB                 mov     [ebp+var_4], ecx
.text:000061DE                 mov     ecx, [ebp+var_4]
.text:000061E1                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:000061E6                 add     esp, 4
.text:000061E9                 cmp     ebp, esp
.text:000061EB                 call    __RTC_CheckEsp
.text:000061F0                 mov     esp, ebp
.text:000061F2                 pop     ebp
.text:000061F3                 retn
.text:000061F3 ?Size@?$CObjectVector@UCPair@NWildcard@@@@QBEIXZ endp
.text:000061F3
.text:000061F3 _text           ends
.text:000061F3
.text:000061F4 ; ===========================================================================
.text:000061F4
.text:000061F4 ; Segment type: Pure code
.text:000061F4 ; Segment permissions: Read/Execute
.text:000061F4 _text           segment para public 'CODE' use32
.text:000061F4                 assume cs:_text
.text:000061F4                 ;org 61F4h
.text:000061F4 ; COMDAT (pick any)
.text:000061F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000061F4
.text:000061F4 ; =============== S U B R O U T I N E =======================================
.text:000061F4
.text:000061F4 ; Attributes: bp-based frame
.text:000061F4
.text:000061F4 ; public: struct NWildcard::CPair & __thiscall CObjectVector<struct NWildcard::CPair>::operator[](unsigned int)
.text:000061F4                 public ??A?$CObjectVector@UCPair@NWildcard@@@@QAEAAUCPair@NWildcard@@I@Z
.text:000061F4 ??A?$CObjectVector@UCPair@NWildcard@@@@QAEAAUCPair@NWildcard@@I@Z proc near
.text:000061F4                                         ; CODE XREF: ConvertToLongNames(NWildcard::CCensor &)+3Ap
.text:000061F4
.text:000061F4 var_4           = dword ptr -4
.text:000061F4 arg_0           = dword ptr  8
.text:000061F4
.text:000061F4                 push    ebp
.text:000061F5                 mov     ebp, esp
.text:000061F7                 push    ecx
.text:000061F8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000061FF                 mov     [ebp+var_4], ecx
.text:00006202                 mov     eax, [ebp+arg_0]
.text:00006205                 push    eax
.text:00006206                 mov     ecx, [ebp+var_4]
.text:00006209                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:0000620E                 mov     eax, [eax]
.text:00006210                 add     esp, 4
.text:00006213                 cmp     ebp, esp
.text:00006215                 call    __RTC_CheckEsp
.text:0000621A                 mov     esp, ebp
.text:0000621C                 pop     ebp
.text:0000621D                 retn    4
.text:0000621D ??A?$CObjectVector@UCPair@NWildcard@@@@QAEAAUCPair@NWildcard@@I@Z endp
.text:0000621D
.text:0000621D _text           ends
.text:0000621D
.text:00006220 ; ===========================================================================
.text:00006220
.text:00006220 ; Segment type: Pure code
.text:00006220 ; Segment permissions: Read/Execute
.text:00006220 _text           segment para public 'CODE' use32
.text:00006220                 assume cs:_text
.text:00006220                 ;org 6220h
.text:00006220 ; COMDAT (pick any)
.text:00006220                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00006220
.text:00006220 ; =============== S U B R O U T I N E =======================================
.text:00006220
.text:00006220 ; Attributes: bp-based frame
.text:00006220
.text:00006220 ; public: struct NWildcard::CPair const & __thiscall CObjectVector<struct NWildcard::CPair>::Front(void)const
.text:00006220                 public ?Front@?$CObjectVector@UCPair@NWildcard@@@@QBEABUCPair@NWildcard@@XZ
.text:00006220 ?Front@?$CObjectVector@UCPair@NWildcard@@@@QBEABUCPair@NWildcard@@XZ proc near
.text:00006220                                         ; CODE XREF: NWildcard::CCensor::AllAreRelative(void)+27p
.text:00006220
.text:00006220 var_4           = dword ptr -4
.text:00006220
.text:00006220                 push    ebp
.text:00006221                 mov     ebp, esp
.text:00006223                 push    ecx
.text:00006224                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000622B                 mov     [ebp+var_4], ecx
.text:0000622E                 push    0
.text:00006230                 mov     ecx, [ebp+var_4]
.text:00006233                 call    ??A?$CObjectVector@UCPair@NWildcard@@@@QBEABUCPair@NWildcard@@I@Z ; CObjectVector<NWildcard::CPair>::operator[](uint)
.text:00006238                 add     esp, 4
.text:0000623B                 cmp     ebp, esp
.text:0000623D                 call    __RTC_CheckEsp
.text:00006242                 mov     esp, ebp
.text:00006244                 pop     ebp
.text:00006245                 retn
.text:00006245 ?Front@?$CObjectVector@UCPair@NWildcard@@@@QBEABUCPair@NWildcard@@XZ endp
.text:00006245
.text:00006245 ; ---------------------------------------------------------------------------
.text:00006246                 align 4
.text:00006246 _text           ends
.text:00006246
.text:00006248 ; ===========================================================================
.text:00006248
.text:00006248 ; Segment type: Pure code
.text:00006248 ; Segment permissions: Read/Execute
.text:00006248 _text           segment para public 'CODE' use32
.text:00006248                 assume cs:_text
.text:00006248                 ;org 6248h
.text:00006248 ; COMDAT (pick any)
.text:00006248                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00006248
.text:00006248 ; =============== S U B R O U T I N E =======================================
.text:00006248
.text:00006248 ; Attributes: bp-based frame
.text:00006248
.text:00006248 ; public: __thiscall CObjectVector<class CBuffer<unsigned char>>::~CObjectVector<class CBuffer<unsigned char>>(void)
.text:00006248                 public ??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ
.text:00006248 ??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ proc near
.text:00006248                                         ; CODE XREF: CUniqBlocks::~CUniqBlocks(void)+58p
.text:00006248                                         ; __unwindfunclet$??1CUniqBlocks@@QAE@XZ$0+3j
.text:00006248
.text:00006248 var_20          = dword ptr -20h
.text:00006248 var_1C          = dword ptr -1Ch
.text:00006248 var_18          = dword ptr -18h
.text:00006248 var_14          = dword ptr -14h
.text:00006248 var_10          = dword ptr -10h
.text:00006248 var_C           = dword ptr -0Ch
.text:00006248 var_4           = dword ptr -4
.text:00006248
.text:00006248                 push    ebp
.text:00006249                 mov     ebp, esp
.text:0000624B                 push    0FFFFFFFFh
.text:0000624D                 push    offset __ehhandler$??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ
.text:00006252                 mov     eax, large fs:0
.text:00006258                 push    eax
.text:00006259                 sub     esp, 14h
.text:0000625C                 mov     eax, 0CCCCCCCCh
.text:00006261
.text:00006261 loc_6261:                               ; DATA XREF: .rdata:$SG76896o
.text:00006261                 mov     [ebp+var_20], eax
.text:00006264                 mov     [ebp+var_1C], eax
.text:00006267                 mov     [ebp+var_18], eax
.text:0000626A                 mov     [ebp+var_14], eax
.text:0000626D                 mov     [ebp+var_10], eax
.text:00006270                 mov     eax, dword ptr ds:___security_cookie
.text:00006275                 xor     eax, ebp
.text:00006277                 push    eax
.text:00006278                 lea     eax, [ebp+var_C]
.text:0000627B                 mov     large fs:0, eax
.text:00006281                 mov     [ebp+var_10], ecx
.text:00006284                 mov     [ebp+var_4], 0
.text:0000628B                 mov     ecx, [ebp+var_10]
.text:0000628E                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00006293                 mov     [ebp+var_14], eax
.text:00006296
.text:00006296 loc_6296:                               ; CODE XREF: CObjectVector<CBuffer<uchar>>::~CObjectVector<CBuffer<uchar>>(void):loc_62D8j
.text:00006296                 cmp     [ebp+var_14], 0
.text:0000629A                 jz      short loc_62DA
.text:0000629C                 mov     eax, [ebp+var_14]
.text:0000629F                 sub     eax, 1
.text:000062A2                 mov     [ebp+var_14], eax
.text:000062A5                 mov     ecx, [ebp+var_14]
.text:000062A8                 push    ecx
.text:000062A9                 mov     ecx, [ebp+var_10]
.text:000062AC                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:000062B1                 mov     edx, [eax]
.text:000062B3                 mov     [ebp+var_1C], edx
.text:000062B6                 mov     eax, [ebp+var_1C]
.text:000062B9                 mov     [ebp+var_18], eax
.text:000062BC                 cmp     [ebp+var_18], 0
.text:000062C0                 jz      short loc_62D1
.text:000062C2                 push    1
.text:000062C4                 mov     ecx, [ebp+var_18]
.text:000062C7                 call    ??_G?$CBuffer@E@@QAEPAXI@Z ; CBuffer<uchar>::`scalar deleting destructor'(uint)
.text:000062CC                 mov     [ebp+var_20], eax
.text:000062CF                 jmp     short loc_62D8
.text:000062D1 ; ---------------------------------------------------------------------------
.text:000062D1
.text:000062D1 loc_62D1:                               ; CODE XREF: CObjectVector<CBuffer<uchar>>::~CObjectVector<CBuffer<uchar>>(void)+78j
.text:000062D1                 mov     [ebp+var_20], 0
.text:000062D8
.text:000062D8 loc_62D8:                               ; CODE XREF: CObjectVector<CBuffer<uchar>>::~CObjectVector<CBuffer<uchar>>(void)+87j
.text:000062D8                 jmp     short loc_6296
.text:000062DA ; ---------------------------------------------------------------------------
.text:000062DA
.text:000062DA loc_62DA:                               ; CODE XREF: CObjectVector<CBuffer<uchar>>::~CObjectVector<CBuffer<uchar>>(void)+52j
.text:000062DA                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000062E1                 mov     ecx, [ebp+var_10]
.text:000062E4                 call    ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text:000062E9                 mov     ecx, [ebp+var_C]
.text:000062EC                 mov     large fs:0, ecx
.text:000062F3                 pop     ecx
.text:000062F4                 add     esp, 20h
.text:000062F7                 cmp     ebp, esp
.text:000062F9                 call    __RTC_CheckEsp
.text:000062FE                 mov     esp, ebp
.text:00006300                 pop     ebp
.text:00006301                 retn
.text:00006301 ??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ endp
.text:00006301
.text:00006301 ; ---------------------------------------------------------------------------
.text:00006302                 align 4
.text:00006302 _text           ends
.text:00006302
.text$x:00006304 ; ===========================================================================
.text$x:00006304
.text$x:00006304 ; Segment type: Pure code
.text$x:00006304 ; Segment permissions: Read/Execute
.text$x:00006304 _text$x         segment para public 'CODE' use32
.text$x:00006304                 assume cs:_text$x
.text$x:00006304                 ;org 6304h
.text$x:00006304 ; COMDAT (pick associative to section at 6248)
.text$x:00006304                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006304
.text$x:00006304 ; =============== S U B R O U T I N E =======================================
.text$x:00006304
.text$x:00006304
.text$x:00006304 __unwindfunclet$??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ$0 proc near
.text$x:00006304                                         ; DATA XREF: .xdata$x:0000632Co
.text$x:00006304                 mov     ecx, [ebp-10h]
.text$x:00006307                 jmp     ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text$x:00006307 __unwindfunclet$??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ$0 endp
.text$x:00006307
.text$x:0000630C
.text$x:0000630C ; =============== S U B R O U T I N E =======================================
.text$x:0000630C
.text$x:0000630C
.text$x:0000630C __ehhandler$??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ proc near
.text$x:0000630C                                         ; DATA XREF: CObjectVector<CBuffer<uchar>>::~CObjectVector<CBuffer<uchar>>(void)+5o
.text$x:0000630C
.text$x:0000630C arg_4           = dword ptr  8
.text$x:0000630C
.text$x:0000630C                 mov     edx, [esp+arg_4]
.text$x:00006310                 lea     eax, [edx+0Ch]
.text$x:00006313                 mov     ecx, [edx-18h]
.text$x:00006316                 xor     ecx, eax
.text$x:00006318                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000631D                 mov     eax, offset __ehfuncinfo$??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ
.text$x:00006322                 jmp     ___CxxFrameHandler3
.text$x:00006322 __ehhandler$??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ endp
.text$x:00006322
.text$x:00006322 ; ---------------------------------------------------------------------------
.text$x:00006327                 align 4
.text$x:00006327 _text$x         ends
.text$x:00006327
.xdata$x:00006328 ; ===========================================================================
.xdata$x:00006328
.xdata$x:00006328 ; Segment type: Pure data
.xdata$x:00006328 ; Segment permissions: Read
.xdata$x:00006328 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006328                 assume cs:_xdata$x
.xdata$x:00006328                 ;org 6328h
.xdata$x:00006328 ; COMDAT (pick associative to section at 6248)
.xdata$x:00006328 __unwindtable$??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ db 0FFh
.xdata$x:00006328                                         ; DATA XREF: .xdata$x:00006338o
.xdata$x:00006329                 db 0FFh
.xdata$x:0000632A                 db 0FFh
.xdata$x:0000632B                 db 0FFh
.xdata$x:0000632C                 dd offset __unwindfunclet$??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ$0
.xdata$x:00006330 __ehfuncinfo$??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ db  22h ; "
.xdata$x:00006330                                         ; DATA XREF: __ehhandler$??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ+11o
.xdata$x:00006331                 db    5
.xdata$x:00006332                 db  93h ; Ã´
.xdata$x:00006333                 db  19h
.xdata$x:00006334                 db    1
.xdata$x:00006335                 db    0
.xdata$x:00006336                 db    0
.xdata$x:00006337                 db    0
.xdata$x:00006338                 dd offset __unwindtable$??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ
.xdata$x:0000633C                 db    0
.xdata$x:0000633D                 db    0
.xdata$x:0000633E                 db    0
.xdata$x:0000633F                 db    0
.xdata$x:00006340                 db    0
.xdata$x:00006341                 db    0
.xdata$x:00006342                 db    0
.xdata$x:00006343                 db    0
.xdata$x:00006344                 db    0
.xdata$x:00006345                 db    0
.xdata$x:00006346                 db    0
.xdata$x:00006347                 db    0
.xdata$x:00006348                 db    0
.xdata$x:00006349                 db    0
.xdata$x:0000634A                 db    0
.xdata$x:0000634B                 db    0
.xdata$x:0000634C                 db    0
.xdata$x:0000634D                 db    0
.xdata$x:0000634E                 db    0
.xdata$x:0000634F                 db    0
.xdata$x:00006350                 db    1
.xdata$x:00006351                 db    0
.xdata$x:00006352                 db    0
.xdata$x:00006353                 db    0
.xdata$x:00006353 _xdata$x        ends
.xdata$x:00006353
.text:00006354 ; ===========================================================================
.text:00006354
.text:00006354 ; Segment type: Pure code
.text:00006354 ; Segment permissions: Read/Execute
.text:00006354 _text           segment para public 'CODE' use32
.text:00006354                 assume cs:_text
.text:00006354                 ;org 6354h
.text:00006354 ; COMDAT (pick any)
.text:00006354                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00006354
.text:00006354 ; =============== S U B R O U T I N E =======================================
.text:00006354
.text:00006354 ; Attributes: bp-based frame
.text:00006354
.text:00006354 ; public: unsigned int __thiscall CRecordVector<unsigned __int64>::Add(unsigned __int64)
.text:00006354                 public ?Add@?$CRecordVector@_K@@QAEI_K@Z
.text:00006354 ?Add@?$CRecordVector@_K@@QAEI_K@Z proc near
.text:00006354                                         ; CODE XREF: SetAddCommandOptions(NCommandType::EEnum,NCommandLineParser::CParser const &,CUpdateOptions &)+290p
.text:00006354
.text:00006354 var_8           = dword ptr -8
.text:00006354 var_4           = dword ptr -4
.text:00006354 arg_0           = dword ptr  8
.text:00006354 arg_4           = dword ptr  0Ch
.text:00006354
.text:00006354                 push    ebp
.text:00006355                 mov     ebp, esp
.text:00006357                 sub     esp, 8
.text:0000635A                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00006361                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00006368                 mov     [ebp+var_4], ecx
.text:0000636B                 mov     ecx, [ebp+var_4]
.text:0000636E                 call    ?ReserveOnePosition@?$CRecordVector@_K@@AAEXXZ ; CRecordVector<unsigned __int64>::ReserveOnePosition(void)
.text:00006373                 mov     eax, [ebp+var_4]
.text:00006376                 mov     ecx, [eax+4]
.text:00006379                 mov     edx, [ebp+var_4]
.text:0000637C                 mov     eax, [edx]
.text:0000637E                 mov     edx, [ebp+arg_0]
.text:00006381                 mov     [eax+ecx*8], edx
.text:00006384                 mov     edx, [ebp+arg_4]
.text:00006387                 mov     [eax+ecx*8+4], edx
.text:0000638B                 mov     eax, [ebp+var_4]
.text:0000638E                 mov     ecx, [eax+4]
.text:00006391                 mov     [ebp+var_8], ecx
.text:00006394                 mov     edx, [ebp+var_4]
.text:00006397                 mov     eax, [edx+4]
.text:0000639A                 add     eax, 1
.text:0000639D                 mov     ecx, [ebp+var_4]
.text:000063A0                 mov     [ecx+4], eax
.text:000063A3                 mov     eax, [ebp+var_8]
.text:000063A6                 add     esp, 8
.text:000063A9                 cmp     ebp, esp
.text:000063AB                 call    __RTC_CheckEsp
.text:000063B0                 mov     esp, ebp
.text:000063B2                 pop     ebp
.text:000063B3                 retn    8
.text:000063B3 ?Add@?$CRecordVector@_K@@QAEI_K@Z endp
.text:000063B3
.text:000063B3 ; ---------------------------------------------------------------------------
.text:000063B6                 align 4
.text:000063B6 _text           ends
.text:000063B6
.text:000063B8 ; ===========================================================================
.text:000063B8
.text:000063B8 ; Segment type: Pure code
.text:000063B8 ; Segment permissions: Read/Execute
.text:000063B8 _text           segment para public 'CODE' use32
.text:000063B8                 assume cs:_text
.text:000063B8                 ;org 63B8h
.text:000063B8 ; COMDAT (pick any)
.text:000063B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000063B8
.text:000063B8 ; =============== S U B R O U T I N E =======================================
.text:000063B8
.text:000063B8 ; Attributes: bp-based frame
.text:000063B8
.text:000063B8 ; public: __thiscall CRecordVector<unsigned int>::CRecordVector<unsigned int>(void)
.text:000063B8                 public ??0?$CRecordVector@I@@QAE@XZ
.text:000063B8 ??0?$CRecordVector@I@@QAE@XZ proc near  ; CODE XREF: EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *)+257p
.text:000063B8
.text:000063B8 var_4           = dword ptr -4
.text:000063B8
.text:000063B8                 push    ebp
.text:000063B9                 mov     ebp, esp
.text:000063BB                 push    ecx
.text:000063BC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000063C3                 mov     [ebp+var_4], ecx
.text:000063C6                 mov     eax, [ebp+var_4]
.text:000063C9                 mov     dword ptr [eax], 0
.text:000063CF                 mov     ecx, [ebp+var_4]
.text:000063D2                 mov     dword ptr [ecx+4], 0
.text:000063D9                 mov     edx, [ebp+var_4]
.text:000063DC                 mov     dword ptr [edx+8], 0
.text:000063E3                 mov     eax, [ebp+var_4]
.text:000063E6                 mov     esp, ebp
.text:000063E8                 pop     ebp
.text:000063E9                 retn
.text:000063E9 ??0?$CRecordVector@I@@QAE@XZ endp
.text:000063E9
.text:000063E9 ; ---------------------------------------------------------------------------
.text:000063EA                 align 4
.text:000063EA _text           ends
.text:000063EA
.text:000063EC ; ===========================================================================
.text:000063EC
.text:000063EC ; Segment type: Pure code
.text:000063EC ; Segment permissions: Read/Execute
.text:000063EC _text           segment para public 'CODE' use32
.text:000063EC                 assume cs:_text
.text:000063EC                 ;org 63ECh
.text:000063EC ; COMDAT (pick any)
.text:000063EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000063EC
.text:000063EC ; =============== S U B R O U T I N E =======================================
.text:000063EC
.text:000063EC ; Attributes: bp-based frame
.text:000063EC
.text:000063EC ; public: unsigned int __thiscall CRecordVector<unsigned int>::Size(void)const
.text:000063EC                 public ?Size@?$CRecordVector@I@@QBEIXZ
.text:000063EC ?Size@?$CRecordVector@I@@QBEIXZ proc near
.text:000063EC                                         ; CODE XREF: EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *)+279p
.text:000063EC                                         ; EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *)+28Dp ...
.text:000063EC
.text:000063EC var_4           = dword ptr -4
.text:000063EC
.text:000063EC                 push    ebp
.text:000063ED                 mov     ebp, esp
.text:000063EF                 push    ecx
.text:000063F0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000063F7                 mov     [ebp+var_4], ecx
.text:000063FA                 mov     eax, [ebp+var_4]
.text:000063FD                 mov     eax, [eax+4]
.text:00006400                 mov     esp, ebp
.text:00006402                 pop     ebp
.text:00006403                 retn
.text:00006403 ?Size@?$CRecordVector@I@@QBEIXZ endp
.text:00006403
.text:00006403 _text           ends
.text:00006403
.text:00006404 ; ===========================================================================
.text:00006404
.text:00006404 ; Segment type: Pure code
.text:00006404 ; Segment permissions: Read/Execute
.text:00006404 _text           segment para public 'CODE' use32
.text:00006404                 assume cs:_text
.text:00006404                 ;org 6404h
.text:00006404 ; COMDAT (pick any)
.text:00006404                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00006404
.text:00006404 ; =============== S U B R O U T I N E =======================================
.text:00006404
.text:00006404 ; Attributes: bp-based frame
.text:00006404
.text:00006404 ; public: __thiscall CRecordVector<unsigned int>::~CRecordVector<unsigned int>(void)
.text:00006404                 public ??1?$CRecordVector@I@@QAE@XZ
.text:00006404 ??1?$CRecordVector@I@@QAE@XZ proc near  ; CODE XREF: EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *)+3AEp
.text:00006404                                         ; __unwindfunclet$?EnumerateDirItemsAndSort@@YGJAAVCCensor@NWildcard@@W4ECensorPathMode@2@ABVUString@@AAV?$CObjectVector@VUString@@@@3AAUCDirItemsStat@@PAUIDirItemsCallback@@@Z$5+6j ...
.text:00006404
.text:00006404 var_8           = dword ptr -8
.text:00006404 var_4           = dword ptr -4
.text:00006404
.text:00006404                 push    ebp
.text:00006405                 mov     ebp, esp
.text:00006407                 sub     esp, 8
.text:0000640A                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00006411                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00006418                 mov     [ebp+var_4], ecx
.text:0000641B                 mov     eax, [ebp+var_4]
.text:0000641E                 mov     ecx, [eax]
.text:00006420                 mov     [ebp+var_8], ecx
.text:00006423                 mov     edx, [ebp+var_8]
.text:00006426                 push    edx             ; void *
.text:00006427                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000642C                 add     esp, 4
.text:0000642F                 add     esp, 8
.text:00006432                 cmp     ebp, esp
.text:00006434                 call    __RTC_CheckEsp
.text:00006439                 mov     esp, ebp
.text:0000643B                 pop     ebp
.text:0000643C                 retn
.text:0000643C ??1?$CRecordVector@I@@QAE@XZ endp
.text:0000643C
.text:0000643C ; ---------------------------------------------------------------------------
.text:0000643D                 align 10h
.text:0000643D _text           ends
.text:0000643D
.text:00006440 ; ===========================================================================
.text:00006440
.text:00006440 ; Segment type: Pure code
.text:00006440 ; Segment permissions: Read/Execute
.text:00006440 _text           segment para public 'CODE' use32
.text:00006440                 assume cs:_text
.text:00006440                 ;org 6440h
.text:00006440 ; COMDAT (pick any)
.text:00006440                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00006440
.text:00006440 ; =============== S U B R O U T I N E =======================================
.text:00006440
.text:00006440 ; Attributes: bp-based frame
.text:00006440
.text:00006440 ; public: unsigned int & __thiscall CRecordVector<unsigned int>::operator[](unsigned int)
.text:00006440                 public ??A?$CRecordVector@I@@QAEAAII@Z
.text:00006440 ??A?$CRecordVector@I@@QAEAAII@Z proc near
.text:00006440                                         ; CODE XREF: EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *)+2DAp
.text:00006440
.text:00006440 var_4           = dword ptr -4
.text:00006440 arg_0           = dword ptr  8
.text:00006440
.text:00006440                 push    ebp
.text:00006441                 mov     ebp, esp
.text:00006443                 push    ecx
.text:00006444                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000644B                 mov     [ebp+var_4], ecx
.text:0000644E                 mov     eax, [ebp+var_4]
.text:00006451                 mov     ecx, [eax]
.text:00006453                 mov     edx, [ebp+arg_0]
.text:00006456                 lea     eax, [ecx+edx*4]
.text:00006459                 mov     esp, ebp
.text:0000645B                 pop     ebp
.text:0000645C                 retn    4
.text:0000645C ??A?$CRecordVector@I@@QAEAAII@Z endp
.text:0000645C
.text:0000645C ; ---------------------------------------------------------------------------
.text:0000645F                 align 10h
.text:0000645F _text           ends
.text:0000645F
.text:00006460 ; ===========================================================================
.text:00006460
.text:00006460 ; Segment type: Pure code
.text:00006460 ; Segment permissions: Read/Execute
.text:00006460 _text           segment para public 'CODE' use32
.text:00006460                 assume cs:_text
.text:00006460                 ;org 6460h
.text:00006460 ; COMDAT (pick any)
.text:00006460                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00006460
.text:00006460 ; =============== S U B R O U T I N E =======================================
.text:00006460
.text:00006460 ; Attributes: bp-based frame
.text:00006460
.text:00006460 ; public: __thiscall CBuffer<unsigned char>::~CBuffer<unsigned char>(void)
.text:00006460                 public ??1?$CBuffer@E@@QAE@XZ
.text:00006460 ??1?$CBuffer@E@@QAE@XZ proc near        ; CODE XREF: CDirItems::~CDirItems(void)+3Dp
.text:00006460                                         ; CBuffer<uchar>::`scalar deleting destructor'(uint)+11p ...
.text:00006460
.text:00006460 var_8           = dword ptr -8
.text:00006460 var_4           = dword ptr -4
.text:00006460
.text:00006460                 push    ebp
.text:00006461
.text:00006461 loc_6461:                               ; DATA XREF: .rdata:$SG76903o
.text:00006461                                         ; .rdata:$SG76894o
.text:00006461                 mov     ebp, esp
.text:00006463                 sub     esp, 8
.text:00006466                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000646D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00006474                 mov     [ebp+var_4], ecx
.text:00006477                 mov     eax, [ebp+var_4]
.text:0000647A                 mov     ecx, [eax]
.text:0000647C                 mov     [ebp+var_8], ecx
.text:0000647F                 mov     edx, [ebp+var_8]
.text:00006482                 push    edx             ; void *
.text:00006483                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00006488                 add     esp, 4
.text:0000648B                 add     esp, 8
.text:0000648E                 cmp     ebp, esp
.text:00006490                 call    __RTC_CheckEsp
.text:00006495                 mov     esp, ebp
.text:00006497                 pop     ebp
.text:00006498                 retn
.text:00006498 ??1?$CBuffer@E@@QAE@XZ endp
.text:00006498
.text:00006498 ; ---------------------------------------------------------------------------
.text:00006499                 align 4
.text:00006499 _text           ends
.text:00006499
.text:0000649C ; ===========================================================================
.text:0000649C
.text:0000649C ; Segment type: Pure code
.text:0000649C ; Segment permissions: Read/Execute
.text:0000649C _text           segment para public 'CODE' use32
.text:0000649C                 assume cs:_text
.text:0000649C                 ;org 649Ch
.text:0000649C ; COMDAT (pick any)
.text:0000649C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000649C
.text:0000649C ; =============== S U B R O U T I N E =======================================
.text:0000649C
.text:0000649C ; Attributes: bp-based frame
.text:0000649C
.text:0000649C ; public: __thiscall CRecordVector<int>::~CRecordVector<int>(void)
.text:0000649C                 public ??1?$CRecordVector@H@@QAE@XZ
.text:0000649C ??1?$CRecordVector@H@@QAE@XZ proc near  ; CODE XREF: CDirItems::~CDirItems(void)+6Ap
.text:0000649C                                         ; CDirItems::~CDirItems(void)+79p ...
.text:0000649C
.text:0000649C var_8           = dword ptr -8
.text:0000649C var_4           = dword ptr -4
.text:0000649C
.text:0000649C                 push    ebp
.text:0000649D                 mov     ebp, esp
.text:0000649F                 sub     esp, 8
.text:000064A2                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000064A9                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000064B0                 mov     [ebp+var_4], ecx
.text:000064B3                 mov     eax, [ebp+var_4]
.text:000064B6                 mov     ecx, [eax]
.text:000064B8                 mov     [ebp+var_8], ecx
.text:000064BB                 mov     edx, [ebp+var_8]
.text:000064BE                 push    edx             ; void *
.text:000064BF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:000064C4                 add     esp, 4
.text:000064C7                 add     esp, 8
.text:000064CA                 cmp     ebp, esp
.text:000064CC                 call    __RTC_CheckEsp
.text:000064D1                 mov     esp, ebp
.text:000064D3                 pop     ebp
.text:000064D4                 retn
.text:000064D4 ??1?$CRecordVector@H@@QAE@XZ endp
.text:000064D4
.text:000064D4 ; ---------------------------------------------------------------------------
.text:000064D5                 align 4
.text:000064D5 _text           ends
.text:000064D5
.text:000064D8 ; ===========================================================================
.text:000064D8
.text:000064D8 ; Segment type: Pure code
.text:000064D8 ; Segment permissions: Read/Execute
.text:000064D8 _text           segment para public 'CODE' use32
.text:000064D8                 assume cs:_text
.text:000064D8                 ;org 64D8h
.text:000064D8 ; COMDAT (pick any)
.text:000064D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000064D8
.text:000064D8 ; =============== S U B R O U T I N E =======================================
.text:000064D8
.text:000064D8 ; Attributes: bp-based frame
.text:000064D8
.text:000064D8 ; public: unsigned int __thiscall CObjectVector<struct CDirItem>::Size(void)const
.text:000064D8                 public ?Size@?$CObjectVector@UCDirItem@@@@QBEIXZ
.text:000064D8 ?Size@?$CObjectVector@UCDirItem@@@@QBEIXZ proc near
.text:000064D8                                         ; CODE XREF: EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *)+F9p
.text:000064D8
.text:000064D8 var_4           = dword ptr -4
.text:000064D8
.text:000064D8                 push    ebp
.text:000064D9                 mov     ebp, esp
.text:000064DB                 push    ecx
.text:000064DC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000064E3                 mov     [ebp+var_4], ecx
.text:000064E6                 mov     ecx, [ebp+var_4]
.text:000064E9                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:000064EE                 add     esp, 4
.text:000064F1                 cmp     ebp, esp
.text:000064F3                 call    __RTC_CheckEsp
.text:000064F8                 mov     esp, ebp
.text:000064FA                 pop     ebp
.text:000064FB                 retn
.text:000064FB ?Size@?$CObjectVector@UCDirItem@@@@QBEIXZ endp
.text:000064FB
.text:000064FB _text           ends
.text:000064FB
.text:000064FC ; ===========================================================================
.text:000064FC
.text:000064FC ; Segment type: Pure code
.text:000064FC ; Segment permissions: Read/Execute
.text:000064FC _text           segment para public 'CODE' use32
.text:000064FC                 assume cs:_text
.text:000064FC                 ;org 64FCh
.text:000064FC ; COMDAT (pick any)
.text:000064FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000064FC
.text:000064FC ; =============== S U B R O U T I N E =======================================
.text:000064FC
.text:000064FC ; Attributes: bp-based frame
.text:000064FC
.text:000064FC ; public: struct CDirItem & __thiscall CObjectVector<struct CDirItem>::operator[](unsigned int)
.text:000064FC                 public ??A?$CObjectVector@UCDirItem@@@@QAEAAUCDirItem@@I@Z
.text:000064FC ??A?$CObjectVector@UCDirItem@@@@QAEAAUCDirItem@@I@Z proc near
.text:000064FC                                         ; CODE XREF: EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *)+113p
.text:000064FC
.text:000064FC var_4           = dword ptr -4
.text:000064FC arg_0           = dword ptr  8
.text:000064FC
.text:000064FC                 push    ebp
.text:000064FD                 mov     ebp, esp
.text:000064FF                 push    ecx
.text:00006500                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00006507                 mov     [ebp+var_4], ecx
.text:0000650A                 mov     eax, [ebp+arg_0]
.text:0000650D                 push    eax
.text:0000650E                 mov     ecx, [ebp+var_4]
.text:00006511                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00006516                 mov     eax, [eax]
.text:00006518                 add     esp, 4
.text:0000651B                 cmp     ebp, esp
.text:0000651D                 call    __RTC_CheckEsp
.text:00006522                 mov     esp, ebp
.text:00006524                 pop     ebp
.text:00006525                 retn    4
.text:00006525 ??A?$CObjectVector@UCDirItem@@@@QAEAAUCDirItem@@I@Z endp
.text:00006525
.text:00006525 _text           ends
.text:00006525
.text:00006528 ; ===========================================================================
.text:00006528
.text:00006528 ; Segment type: Pure code
.text:00006528 ; Segment permissions: Read/Execute
.text:00006528 _text           segment para public 'CODE' use32
.text:00006528                 assume cs:_text
.text:00006528                 ;org 6528h
.text:00006528 ; COMDAT (pick any)
.text:00006528                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00006528
.text:00006528 ; =============== S U B R O U T I N E =======================================
.text:00006528
.text:00006528 ; Attributes: bp-based frame
.text:00006528
.text:00006528 ; public: __thiscall CObjectVector<struct CDirItem>::~CObjectVector<struct CDirItem>(void)
.text:00006528                 public ??1?$CObjectVector@UCDirItem@@@@QAE@XZ
.text:00006528 ??1?$CObjectVector@UCDirItem@@@@QAE@XZ proc near
.text:00006528                                         ; CODE XREF: CDirItems::~CDirItems(void)+5Bp
.text:00006528                                         ; __unwindfunclet$??1CDirItems@@QAE@XZ$3+6j
.text:00006528
.text:00006528 var_20          = dword ptr -20h
.text:00006528 var_1C          = dword ptr -1Ch
.text:00006528 var_18          = dword ptr -18h
.text:00006528 var_14          = dword ptr -14h
.text:00006528 var_10          = dword ptr -10h
.text:00006528 var_C           = dword ptr -0Ch
.text:00006528 var_4           = dword ptr -4
.text:00006528
.text:00006528                 push    ebp
.text:00006529                 mov     ebp, esp
.text:0000652B                 push    0FFFFFFFFh
.text:0000652D                 push    offset __ehhandler$??1?$CObjectVector@UCDirItem@@@@QAE@XZ
.text:00006532                 mov     eax, large fs:0
.text:00006538                 push    eax
.text:00006539                 sub     esp, 14h
.text:0000653C                 mov     eax, 0CCCCCCCCh
.text:00006541                 mov     [ebp+var_20], eax
.text:00006544                 mov     [ebp+var_1C], eax
.text:00006547                 mov     [ebp+var_18], eax
.text:0000654A                 mov     [ebp+var_14], eax
.text:0000654D                 mov     [ebp+var_10], eax
.text:00006550                 mov     eax, dword ptr ds:___security_cookie
.text:00006555                 xor     eax, ebp
.text:00006557                 push    eax
.text:00006558                 lea     eax, [ebp+var_C]
.text:0000655B                 mov     large fs:0, eax
.text:00006561                 mov     [ebp+var_10], ecx
.text:00006564                 mov     [ebp+var_4], 0
.text:0000656B                 mov     ecx, [ebp+var_10]
.text:0000656E                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00006573                 mov     [ebp+var_14], eax
.text:00006576
.text:00006576 loc_6576:                               ; CODE XREF: CObjectVector<CDirItem>::~CObjectVector<CDirItem>(void):loc_65B8j
.text:00006576                 cmp     [ebp+var_14], 0
.text:0000657A                 jz      short loc_65BA
.text:0000657C                 mov     eax, [ebp+var_14]
.text:0000657F                 sub     eax, 1
.text:00006582                 mov     [ebp+var_14], eax
.text:00006585                 mov     ecx, [ebp+var_14]
.text:00006588                 push    ecx
.text:00006589                 mov     ecx, [ebp+var_10]
.text:0000658C                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00006591                 mov     edx, [eax]
.text:00006593                 mov     [ebp+var_1C], edx
.text:00006596                 mov     eax, [ebp+var_1C]
.text:00006599                 mov     [ebp+var_18], eax
.text:0000659C                 cmp     [ebp+var_18], 0
.text:000065A0                 jz      short loc_65B1
.text:000065A2                 push    1
.text:000065A4                 mov     ecx, [ebp+var_18]
.text:000065A7                 call    ??_GCDirItem@@QAEPAXI@Z ; CDirItem::`scalar deleting destructor'(uint)
.text:000065AC                 mov     [ebp+var_20], eax
.text:000065AF                 jmp     short loc_65B8
.text:000065B1 ; ---------------------------------------------------------------------------
.text:000065B1
.text:000065B1 loc_65B1:                               ; CODE XREF: CObjectVector<CDirItem>::~CObjectVector<CDirItem>(void)+78j
.text:000065B1                 mov     [ebp+var_20], 0
.text:000065B8
.text:000065B8 loc_65B8:                               ; CODE XREF: CObjectVector<CDirItem>::~CObjectVector<CDirItem>(void)+87j
.text:000065B8                 jmp     short loc_6576
.text:000065BA ; ---------------------------------------------------------------------------
.text:000065BA
.text:000065BA loc_65BA:                               ; CODE XREF: CObjectVector<CDirItem>::~CObjectVector<CDirItem>(void)+52j
.text:000065BA                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000065C1                 mov     ecx, [ebp+var_10]
.text:000065C4                 call    ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text:000065C9                 mov     ecx, [ebp+var_C]
.text:000065CC                 mov     large fs:0, ecx
.text:000065D3                 pop     ecx
.text:000065D4                 add     esp, 20h
.text:000065D7                 cmp     ebp, esp
.text:000065D9                 call    __RTC_CheckEsp
.text:000065DE                 mov     esp, ebp
.text:000065E0                 pop     ebp
.text:000065E1                 retn
.text:000065E1 ??1?$CObjectVector@UCDirItem@@@@QAE@XZ endp
.text:000065E1
.text:000065E1 ; ---------------------------------------------------------------------------
.text:000065E2                 align 4
.text:000065E2 _text           ends
.text:000065E2
.text$x:000065E4 ; ===========================================================================
.text$x:000065E4
.text$x:000065E4 ; Segment type: Pure code
.text$x:000065E4 ; Segment permissions: Read/Execute
.text$x:000065E4 _text$x         segment para public 'CODE' use32
.text$x:000065E4                 assume cs:_text$x
.text$x:000065E4                 ;org 65E4h
.text$x:000065E4 ; COMDAT (pick associative to section at 6528)
.text$x:000065E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000065E4
.text$x:000065E4 ; =============== S U B R O U T I N E =======================================
.text$x:000065E4
.text$x:000065E4
.text$x:000065E4 __unwindfunclet$??1?$CObjectVector@UCDirItem@@@@QAE@XZ$0 proc near
.text$x:000065E4                                         ; DATA XREF: .xdata$x:0000660Co
.text$x:000065E4                 mov     ecx, [ebp-10h]
.text$x:000065E7                 jmp     ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text$x:000065E7 __unwindfunclet$??1?$CObjectVector@UCDirItem@@@@QAE@XZ$0 endp
.text$x:000065E7
.text$x:000065EC
.text$x:000065EC ; =============== S U B R O U T I N E =======================================
.text$x:000065EC
.text$x:000065EC
.text$x:000065EC __ehhandler$??1?$CObjectVector@UCDirItem@@@@QAE@XZ proc near
.text$x:000065EC                                         ; DATA XREF: CObjectVector<CDirItem>::~CObjectVector<CDirItem>(void)+5o
.text$x:000065EC
.text$x:000065EC arg_4           = dword ptr  8
.text$x:000065EC
.text$x:000065EC                 mov     edx, [esp+arg_4]
.text$x:000065F0                 lea     eax, [edx+0Ch]
.text$x:000065F3                 mov     ecx, [edx-18h]
.text$x:000065F6                 xor     ecx, eax
.text$x:000065F8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000065FD                 mov     eax, offset __ehfuncinfo$??1?$CObjectVector@UCDirItem@@@@QAE@XZ
.text$x:00006602                 jmp     ___CxxFrameHandler3
.text$x:00006602 __ehhandler$??1?$CObjectVector@UCDirItem@@@@QAE@XZ endp
.text$x:00006602
.text$x:00006602 ; ---------------------------------------------------------------------------
.text$x:00006607                 align 4
.text$x:00006607 _text$x         ends
.text$x:00006607
.xdata$x:00006608 ; ===========================================================================
.xdata$x:00006608
.xdata$x:00006608 ; Segment type: Pure data
.xdata$x:00006608 ; Segment permissions: Read
.xdata$x:00006608 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006608                 assume cs:_xdata$x
.xdata$x:00006608                 ;org 6608h
.xdata$x:00006608 ; COMDAT (pick associative to section at 6528)
.xdata$x:00006608 __unwindtable$??1?$CObjectVector@UCDirItem@@@@QAE@XZ db 0FFh
.xdata$x:00006608                                         ; DATA XREF: .xdata$x:00006618o
.xdata$x:00006609                 db 0FFh
.xdata$x:0000660A                 db 0FFh
.xdata$x:0000660B                 db 0FFh
.xdata$x:0000660C                 dd offset __unwindfunclet$??1?$CObjectVector@UCDirItem@@@@QAE@XZ$0
.xdata$x:00006610 __ehfuncinfo$??1?$CObjectVector@UCDirItem@@@@QAE@XZ db  22h ; "
.xdata$x:00006610                                         ; DATA XREF: __ehhandler$??1?$CObjectVector@UCDirItem@@@@QAE@XZ+11o
.xdata$x:00006611                 db    5
.xdata$x:00006612                 db  93h ; Ã´
.xdata$x:00006613                 db  19h
.xdata$x:00006614                 db    1
.xdata$x:00006615                 db    0
.xdata$x:00006616                 db    0
.xdata$x:00006617                 db    0
.xdata$x:00006618                 dd offset __unwindtable$??1?$CObjectVector@UCDirItem@@@@QAE@XZ
.xdata$x:0000661C                 db    0
.xdata$x:0000661D                 db    0
.xdata$x:0000661E                 db    0
.xdata$x:0000661F                 db    0
.xdata$x:00006620                 db    0
.xdata$x:00006621                 db    0
.xdata$x:00006622                 db    0
.xdata$x:00006623                 db    0
.xdata$x:00006624                 db    0
.xdata$x:00006625                 db    0
.xdata$x:00006626                 db    0
.xdata$x:00006627                 db    0
.xdata$x:00006628                 db    0
.xdata$x:00006629                 db    0
.xdata$x:0000662A                 db    0
.xdata$x:0000662B                 db    0
.xdata$x:0000662C                 db    0
.xdata$x:0000662D                 db    0
.xdata$x:0000662E                 db    0
.xdata$x:0000662F                 db    0
.xdata$x:00006630                 db    1
.xdata$x:00006631                 db    0
.xdata$x:00006632                 db    0
.xdata$x:00006633                 db    0
.xdata$x:00006633 _xdata$x        ends
.xdata$x:00006633
.text:00006634 ; ===========================================================================
.text:00006634
.text:00006634 ; Segment type: Pure code
.text:00006634 ; Segment permissions: Read/Execute
.text:00006634 _text           segment para public 'CODE' use32
.text:00006634                 assume cs:_text
.text:00006634                 ;org 6634h
.text:00006634 ; COMDAT (pick any)
.text:00006634                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00006634
.text:00006634 ; =============== S U B R O U T I N E =======================================
.text:00006634
.text:00006634 ; Attributes: bp-based frame
.text:00006634
.text:00006634 ; public: class CObjectVector<struct CProperty> & __thiscall CObjectVector<struct CProperty>::operator=(class CObjectVector<struct CProperty> const &)
.text:00006634                 public ??4?$CObjectVector@UCProperty@@@@QAEAAV0@ABV0@@Z
.text:00006634 ??4?$CObjectVector@UCProperty@@@@QAEAAV0@ABV0@@Z proc near
.text:00006634                                         ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+900p
.text:00006634
.text:00006634 var_24          = dword ptr -24h
.text:00006634 var_20          = dword ptr -20h
.text:00006634 var_1C          = dword ptr -1Ch
.text:00006634 var_18          = dword ptr -18h
.text:00006634 var_14          = dword ptr -14h
.text:00006634 var_10          = dword ptr -10h
.text:00006634 var_C           = dword ptr -0Ch
.text:00006634 var_4           = dword ptr -4
.text:00006634 arg_0           = dword ptr  8
.text:00006634
.text:00006634                 push    ebp
.text:00006635                 mov     ebp, esp
.text:00006637                 push    0FFFFFFFFh
.text:00006639                 push    offset __ehhandler$??4?$CObjectVector@UCProperty@@@@QAEAAV0@ABV0@@Z
.text:0000663E                 mov     eax, large fs:0
.text:00006644                 push    eax
.text:00006645                 sub     esp, 18h
.text:00006648                 mov     eax, 0CCCCCCCCh
.text:0000664D                 mov     [ebp+var_24], eax
.text:00006650                 mov     [ebp+var_20], eax
.text:00006653                 mov     [ebp+var_1C], eax
.text:00006656                 mov     [ebp+var_18], eax
.text:00006659                 mov     [ebp+var_14], eax
.text:0000665C                 mov     [ebp+var_10], eax
.text:0000665F                 mov     eax, dword ptr ds:___security_cookie
.text:00006664                 xor     eax, ebp
.text:00006666                 push    eax
.text:00006667                 lea     eax, [ebp+var_C]
.text:0000666A                 mov     large fs:0, eax
.text:00006670                 mov     [ebp+var_10], ecx
.text:00006673                 mov     eax, [ebp+arg_0]
.text:00006676                 cmp     eax, [ebp+var_10]
.text:00006679                 jnz     short loc_6683
.text:0000667B                 mov     eax, [ebp+var_10]
.text:0000667E                 jmp     loc_6715
.text:00006683 ; ---------------------------------------------------------------------------
.text:00006683
.text:00006683 loc_6683:                               ; CODE XREF: CObjectVector<CProperty>::operator=(CObjectVector<CProperty> const &)+45j
.text:00006683                 mov     ecx, [ebp+var_10]
.text:00006686                 call    ?Clear@?$CObjectVector@UCProperty@@@@QAEXXZ ; CObjectVector<CProperty>::Clear(void)
.text:0000668B                 mov     ecx, [ebp+arg_0]
.text:0000668E                 call    ?Size@?$CObjectVector@UCProperty@@@@QBEIXZ ; CObjectVector<CProperty>::Size(void)
.text:00006693                 mov     [ebp+var_14], eax
.text:00006696                 mov     ecx, [ebp+var_14]
.text:00006699                 push    ecx
.text:0000669A                 mov     ecx, [ebp+var_10]
.text:0000669D                 call    ?Reserve@?$CRecordVector@PAX@@QAEXI@Z ; CRecordVector<void *>::Reserve(uint)
.text:000066A2                 mov     [ebp+var_18], 0
.text:000066A9                 jmp     short loc_66B4
.text:000066AB ; ---------------------------------------------------------------------------
.text:000066AB
.text:000066AB loc_66AB:                               ; CODE XREF: CObjectVector<CProperty>::operator=(CObjectVector<CProperty> const &)+DCj
.text:000066AB                 mov     edx, [ebp+var_18]
.text:000066AE                 add     edx, 1
.text:000066B1                 mov     [ebp+var_18], edx
.text:000066B4
.text:000066B4 loc_66B4:                               ; CODE XREF: CObjectVector<CProperty>::operator=(CObjectVector<CProperty> const &)+75j
.text:000066B4                 mov     eax, [ebp+var_18]
.text:000066B7                 cmp     eax, [ebp+var_14]
.text:000066BA                 jnb     short loc_6712
.text:000066BC                 push    18h             ; unsigned int
.text:000066BE                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:000066C3                 add     esp, 4
.text:000066C6                 mov     [ebp+var_20], eax
.text:000066C9                 mov     [ebp+var_4], 0
.text:000066D0                 cmp     [ebp+var_20], 0
.text:000066D4                 jz      short loc_66F0
.text:000066D6                 mov     ecx, [ebp+var_18]
.text:000066D9                 push    ecx
.text:000066DA                 mov     ecx, [ebp+arg_0]
.text:000066DD                 call    ??A?$CObjectVector@UCProperty@@@@QBEABUCProperty@@I@Z ; CObjectVector<CProperty>::operator[](uint)
.text:000066E2                 push    eax
.text:000066E3                 mov     ecx, [ebp+var_20]
.text:000066E6                 call    ??0CProperty@@QAE@ABU0@@Z ; CProperty::CProperty(CProperty const &)
.text:000066EB                 mov     [ebp+var_24], eax
.text:000066EE                 jmp     short loc_66F7
.text:000066F0 ; ---------------------------------------------------------------------------
.text:000066F0
.text:000066F0 loc_66F0:                               ; CODE XREF: CObjectVector<CProperty>::operator=(CObjectVector<CProperty> const &)+A0j
.text:000066F0                 mov     [ebp+var_24], 0
.text:000066F7
.text:000066F7 loc_66F7:                               ; CODE XREF: CObjectVector<CProperty>::operator=(CObjectVector<CProperty> const &)+BAj
.text:000066F7                 mov     edx, [ebp+var_24]
.text:000066FA                 mov     [ebp+var_1C], edx
.text:000066FD                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00006704                 mov     eax, [ebp+var_1C]
.text:00006707                 push    eax
.text:00006708                 mov     ecx, [ebp+var_10]
.text:0000670B                 call    ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z ; CRecordVector<void *>::AddInReserved(void * const)
.text:00006710                 jmp     short loc_66AB
.text:00006712 ; ---------------------------------------------------------------------------
.text:00006712
.text:00006712 loc_6712:                               ; CODE XREF: CObjectVector<CProperty>::operator=(CObjectVector<CProperty> const &)+86j
.text:00006712                 mov     eax, [ebp+var_10]
.text:00006715
.text:00006715 loc_6715:                               ; CODE XREF: CObjectVector<CProperty>::operator=(CObjectVector<CProperty> const &)+4Aj
.text:00006715                 mov     ecx, [ebp+var_C]
.text:00006718                 mov     large fs:0, ecx
.text:0000671F                 pop     ecx
.text:00006720                 add     esp, 24h
.text:00006723                 cmp     ebp, esp
.text:00006725                 call    __RTC_CheckEsp
.text:0000672A                 mov     esp, ebp
.text:0000672C                 pop     ebp
.text:0000672D                 retn    4
.text:0000672D ??4?$CObjectVector@UCProperty@@@@QAEAAV0@ABV0@@Z endp
.text:0000672D
.text:0000672D _text           ends
.text:0000672D
.text$x:00006730 ; ===========================================================================
.text$x:00006730
.text$x:00006730 ; Segment type: Pure code
.text$x:00006730 ; Segment permissions: Read/Execute
.text$x:00006730 _text$x         segment para public 'CODE' use32
.text$x:00006730                 assume cs:_text$x
.text$x:00006730                 ;org 6730h
.text$x:00006730 ; COMDAT (pick associative to section at 6634)
.text$x:00006730                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006730
.text$x:00006730 ; =============== S U B R O U T I N E =======================================
.text$x:00006730
.text$x:00006730
.text$x:00006730 __unwindfunclet$??4?$CObjectVector@UCProperty@@@@QAEAAV0@ABV0@@Z$0 proc near
.text$x:00006730                                         ; DATA XREF: .xdata$x:0000675Co
.text$x:00006730                 mov     eax, [ebp-20h]
.text$x:00006733                 push    eax             ; void *
.text$x:00006734                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00006739                 pop     ecx
.text$x:0000673A                 retn
.text$x:0000673A __unwindfunclet$??4?$CObjectVector@UCProperty@@@@QAEAAV0@ABV0@@Z$0 endp
.text$x:0000673A
.text$x:0000673B
.text$x:0000673B ; =============== S U B R O U T I N E =======================================
.text$x:0000673B
.text$x:0000673B
.text$x:0000673B __ehhandler$??4?$CObjectVector@UCProperty@@@@QAEAAV0@ABV0@@Z proc near
.text$x:0000673B                                         ; DATA XREF: CObjectVector<CProperty>::operator=(CObjectVector<CProperty> const &)+5o
.text$x:0000673B
.text$x:0000673B arg_4           = dword ptr  8
.text$x:0000673B
.text$x:0000673B                 mov     edx, [esp+arg_4]
.text$x:0000673F                 lea     eax, [edx+0Ch]
.text$x:00006742                 mov     ecx, [edx-1Ch]
.text$x:00006745                 xor     ecx, eax
.text$x:00006747                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000674C                 mov     eax, offset __ehfuncinfo$??4?$CObjectVector@UCProperty@@@@QAEAAV0@ABV0@@Z
.text$x:00006751                 jmp     ___CxxFrameHandler3
.text$x:00006751 __ehhandler$??4?$CObjectVector@UCProperty@@@@QAEAAV0@ABV0@@Z endp
.text$x:00006751
.text$x:00006751 ; ---------------------------------------------------------------------------
.text$x:00006756                 align 4
.text$x:00006756 _text$x         ends
.text$x:00006756
.xdata$x:00006758 ; ===========================================================================
.xdata$x:00006758
.xdata$x:00006758 ; Segment type: Pure data
.xdata$x:00006758 ; Segment permissions: Read
.xdata$x:00006758 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006758                 assume cs:_xdata$x
.xdata$x:00006758                 ;org 6758h
.xdata$x:00006758 ; COMDAT (pick associative to section at 6634)
.xdata$x:00006758 __unwindtable$??4?$CObjectVector@UCProperty@@@@QAEAAV0@ABV0@@Z db 0FFh
.xdata$x:00006758                                         ; DATA XREF: .xdata$x:00006768o
.xdata$x:00006759                 db 0FFh
.xdata$x:0000675A                 db 0FFh
.xdata$x:0000675B                 db 0FFh
.xdata$x:0000675C                 dd offset __unwindfunclet$??4?$CObjectVector@UCProperty@@@@QAEAAV0@ABV0@@Z$0
.xdata$x:00006760 __ehfuncinfo$??4?$CObjectVector@UCProperty@@@@QAEAAV0@ABV0@@Z db  22h ; "
.xdata$x:00006760                                         ; DATA XREF: __ehhandler$??4?$CObjectVector@UCProperty@@@@QAEAAV0@ABV0@@Z+11o
.xdata$x:00006761                 db    5
.xdata$x:00006762                 db  93h ; Ã´
.xdata$x:00006763                 db  19h
.xdata$x:00006764                 db    1
.xdata$x:00006765                 db    0
.xdata$x:00006766                 db    0
.xdata$x:00006767                 db    0
.xdata$x:00006768                 dd offset __unwindtable$??4?$CObjectVector@UCProperty@@@@QAEAAV0@ABV0@@Z
.xdata$x:0000676C                 align 20h
.xdata$x:00006780                 db    1
.xdata$x:00006781                 db    0
.xdata$x:00006782                 db    0
.xdata$x:00006783                 db    0
.xdata$x:00006783 _xdata$x        ends
.xdata$x:00006783
.text:00006784 ; ===========================================================================
.text:00006784
.text:00006784 ; Segment type: Pure code
.text:00006784 ; Segment permissions: Read/Execute
.text:00006784 _text           segment para public 'CODE' use32
.text:00006784                 assume cs:_text
.text:00006784                 ;org 6784h
.text:00006784 ; COMDAT (pick any)
.text:00006784                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00006784
.text:00006784 ; =============== S U B R O U T I N E =======================================
.text:00006784
.text:00006784 ; Attributes: bp-based frame
.text:00006784
.text:00006784 ; public: unsigned int __thiscall CObjectVector<struct CProperty>::Add(struct CProperty const &)
.text:00006784                 public ?Add@?$CObjectVector@UCProperty@@@@QAEIABUCProperty@@@Z
.text:00006784 ?Add@?$CObjectVector@UCProperty@@@@QAEIABUCProperty@@@Z proc near
.text:00006784                                         ; CODE XREF: SetMethodOptions(NCommandLineParser::CParser const &,CObjectVector<CProperty> &)+E7p
.text:00006784
.text:00006784 var_1C          = dword ptr -1Ch
.text:00006784 var_18          = dword ptr -18h
.text:00006784 var_14          = dword ptr -14h
.text:00006784 var_10          = dword ptr -10h
.text:00006784 var_C           = dword ptr -0Ch
.text:00006784 var_4           = dword ptr -4
.text:00006784 arg_0           = dword ptr  8
.text:00006784
.text:00006784                 push    ebp
.text:00006785                 mov     ebp, esp
.text:00006787                 push    0FFFFFFFFh
.text:00006789                 push    offset __ehhandler$?Add@?$CObjectVector@UCProperty@@@@QAEIABUCProperty@@@Z
.text:0000678E                 mov     eax, large fs:0
.text:00006794                 push    eax
.text:00006795                 sub     esp, 10h
.text:00006798                 mov     eax, 0CCCCCCCCh
.text:0000679D                 mov     [ebp+var_1C], eax
.text:000067A0                 mov     [ebp+var_18], eax
.text:000067A3                 mov     [ebp+var_14], eax
.text:000067A6                 mov     [ebp+var_10], eax
.text:000067A9                 mov     eax, dword ptr ds:___security_cookie
.text:000067AE                 xor     eax, ebp
.text:000067B0                 push    eax
.text:000067B1                 lea     eax, [ebp+var_C]
.text:000067B4                 mov     large fs:0, eax
.text:000067BA                 mov     [ebp+var_10], ecx
.text:000067BD                 push    18h             ; unsigned int
.text:000067BF                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:000067C4                 add     esp, 4
.text:000067C7                 mov     [ebp+var_18], eax
.text:000067CA                 mov     [ebp+var_4], 0
.text:000067D1                 cmp     [ebp+var_18], 0
.text:000067D5                 jz      short loc_67E8
.text:000067D7                 mov     eax, [ebp+arg_0]
.text:000067DA                 push    eax
.text:000067DB                 mov     ecx, [ebp+var_18]
.text:000067DE                 call    ??0CProperty@@QAE@ABU0@@Z ; CProperty::CProperty(CProperty const &)
.text:000067E3                 mov     [ebp+var_1C], eax
.text:000067E6                 jmp     short loc_67EF
.text:000067E8 ; ---------------------------------------------------------------------------
.text:000067E8
.text:000067E8 loc_67E8:                               ; CODE XREF: CObjectVector<CProperty>::Add(CProperty const &)+51j
.text:000067E8                 mov     [ebp+var_1C], 0
.text:000067EF
.text:000067EF loc_67EF:                               ; CODE XREF: CObjectVector<CProperty>::Add(CProperty const &)+62j
.text:000067EF                 mov     ecx, [ebp+var_1C]
.text:000067F2                 mov     [ebp+var_14], ecx
.text:000067F5                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000067FC                 mov     edx, [ebp+var_14]
.text:000067FF                 push    edx
.text:00006800                 mov     ecx, [ebp+var_10]
.text:00006803                 call    ?Add@?$CRecordVector@PAX@@QAEIQAX@Z ; CRecordVector<void *>::Add(void * const)
.text:00006808                 mov     ecx, [ebp+var_C]
.text:0000680B                 mov     large fs:0, ecx
.text:00006812                 pop     ecx
.text:00006813                 add     esp, 1Ch
.text:00006816                 cmp     ebp, esp
.text:00006818                 call    __RTC_CheckEsp
.text:0000681D                 mov     esp, ebp
.text:0000681F                 pop     ebp
.text:00006820                 retn    4
.text:00006820 ?Add@?$CObjectVector@UCProperty@@@@QAEIABUCProperty@@@Z endp
.text:00006820
.text:00006820 ; ---------------------------------------------------------------------------
.text:00006823                 align 4
.text:00006823 _text           ends
.text:00006823
.text$x:00006824 ; ===========================================================================
.text$x:00006824
.text$x:00006824 ; Segment type: Pure code
.text$x:00006824 ; Segment permissions: Read/Execute
.text$x:00006824 _text$x         segment para public 'CODE' use32
.text$x:00006824                 assume cs:_text$x
.text$x:00006824                 ;org 6824h
.text$x:00006824 ; COMDAT (pick associative to section at 6784)
.text$x:00006824                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006824
.text$x:00006824 ; =============== S U B R O U T I N E =======================================
.text$x:00006824
.text$x:00006824
.text$x:00006824 __unwindfunclet$?Add@?$CObjectVector@UCProperty@@@@QAEIABUCProperty@@@Z$0 proc near
.text$x:00006824                                         ; DATA XREF: .xdata$x:00006850o
.text$x:00006824                 mov     eax, [ebp-18h]
.text$x:00006827                 push    eax             ; void *
.text$x:00006828                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:0000682D                 pop     ecx
.text$x:0000682E                 retn
.text$x:0000682E __unwindfunclet$?Add@?$CObjectVector@UCProperty@@@@QAEIABUCProperty@@@Z$0 endp
.text$x:0000682E
.text$x:0000682F
.text$x:0000682F ; =============== S U B R O U T I N E =======================================
.text$x:0000682F
.text$x:0000682F
.text$x:0000682F __ehhandler$?Add@?$CObjectVector@UCProperty@@@@QAEIABUCProperty@@@Z proc near
.text$x:0000682F                                         ; DATA XREF: CObjectVector<CProperty>::Add(CProperty const &)+5o
.text$x:0000682F
.text$x:0000682F arg_4           = dword ptr  8
.text$x:0000682F
.text$x:0000682F                 mov     edx, [esp+arg_4]
.text$x:00006833                 lea     eax, [edx+0Ch]
.text$x:00006836                 mov     ecx, [edx-14h]
.text$x:00006839                 xor     ecx, eax
.text$x:0000683B                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006840                 mov     eax, offset __ehfuncinfo$?Add@?$CObjectVector@UCProperty@@@@QAEIABUCProperty@@@Z
.text$x:00006845                 jmp     ___CxxFrameHandler3
.text$x:00006845 __ehhandler$?Add@?$CObjectVector@UCProperty@@@@QAEIABUCProperty@@@Z endp
.text$x:00006845
.text$x:00006845 ; ---------------------------------------------------------------------------
.text$x:0000684A                 align 4
.text$x:0000684A _text$x         ends
.text$x:0000684A
.xdata$x:0000684C ; ===========================================================================
.xdata$x:0000684C
.xdata$x:0000684C ; Segment type: Pure data
.xdata$x:0000684C ; Segment permissions: Read
.xdata$x:0000684C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000684C                 assume cs:_xdata$x
.xdata$x:0000684C                 ;org 684Ch
.xdata$x:0000684C ; COMDAT (pick associative to section at 6784)
.xdata$x:0000684C __unwindtable$?Add@?$CObjectVector@UCProperty@@@@QAEIABUCProperty@@@Z db 0FFh
.xdata$x:0000684C                                         ; DATA XREF: .xdata$x:0000685Co
.xdata$x:0000684D                 db 0FFh
.xdata$x:0000684E                 db 0FFh
.xdata$x:0000684F                 db 0FFh
.xdata$x:00006850                 dd offset __unwindfunclet$?Add@?$CObjectVector@UCProperty@@@@QAEIABUCProperty@@@Z$0
.xdata$x:00006854 __ehfuncinfo$?Add@?$CObjectVector@UCProperty@@@@QAEIABUCProperty@@@Z db  22h ; "
.xdata$x:00006854                                         ; DATA XREF: __ehhandler$?Add@?$CObjectVector@UCProperty@@@@QAEIABUCProperty@@@Z+11o
.xdata$x:00006855                 db    5
.xdata$x:00006856                 db  93h ; Ã´
.xdata$x:00006857                 db  19h
.xdata$x:00006858                 db    1
.xdata$x:00006859                 db    0
.xdata$x:0000685A                 db    0
.xdata$x:0000685B                 db    0
.xdata$x:0000685C                 dd offset __unwindtable$?Add@?$CObjectVector@UCProperty@@@@QAEIABUCProperty@@@Z
.xdata$x:00006860                 db    0
.xdata$x:00006861                 db    0
.xdata$x:00006862                 db    0
.xdata$x:00006863                 db    0
.xdata$x:00006864                 db    0
.xdata$x:00006865                 db    0
.xdata$x:00006866                 db    0
.xdata$x:00006867                 db    0
.xdata$x:00006868                 db    0
.xdata$x:00006869                 db    0
.xdata$x:0000686A                 db    0
.xdata$x:0000686B                 db    0
.xdata$x:0000686C                 db    0
.xdata$x:0000686D                 db    0
.xdata$x:0000686E                 db    0
.xdata$x:0000686F                 db    0
.xdata$x:00006870                 db    0
.xdata$x:00006871                 db    0
.xdata$x:00006872                 db    0
.xdata$x:00006873                 db    0
.xdata$x:00006874                 db    1
.xdata$x:00006875                 db    0
.xdata$x:00006876                 db    0
.xdata$x:00006877                 db    0
.xdata$x:00006877 _xdata$x        ends
.xdata$x:00006877
.text:00006878 ; ===========================================================================
.text:00006878
.text:00006878 ; Segment type: Pure code
.text:00006878 ; Segment permissions: Read/Execute
.text:00006878 _text           segment para public 'CODE' use32
.text:00006878                 assume cs:_text
.text:00006878                 ;org 6878h
.text:00006878 ; COMDAT (pick any)
.text:00006878                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00006878
.text:00006878 ; =============== S U B R O U T I N E =======================================
.text:00006878
.text:00006878 ; Attributes: bp-based frame
.text:00006878
.text:00006878 ; public: unsigned int __thiscall CObjectVector<struct CUpdateArchiveCommand>::Size(void)const
.text:00006878                 public ?Size@?$CObjectVector@UCUpdateArchiveCommand@@@@QBEIXZ
.text:00006878 ?Size@?$CObjectVector@UCUpdateArchiveCommand@@@@QBEIXZ proc near
.text:00006878                                         ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+B08p
.text:00006878
.text:00006878 var_4           = dword ptr -4
.text:00006878
.text:00006878                 push    ebp
.text:00006879                 mov     ebp, esp
.text:0000687B                 push    ecx
.text:0000687C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00006883                 mov     [ebp+var_4], ecx
.text:00006886                 mov     ecx, [ebp+var_4]
.text:00006889                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:0000688E                 add     esp, 4
.text:00006891                 cmp     ebp, esp
.text:00006893                 call    __RTC_CheckEsp
.text:00006898                 mov     esp, ebp
.text:0000689A                 pop     ebp
.text:0000689B                 retn
.text:0000689B ?Size@?$CObjectVector@UCUpdateArchiveCommand@@@@QBEIXZ endp
.text:0000689B
.text:0000689B _text           ends
.text:0000689B
.text:0000689C ; ===========================================================================
.text:0000689C
.text:0000689C ; Segment type: Pure code
.text:0000689C ; Segment permissions: Read/Execute
.text:0000689C _text           segment para public 'CODE' use32
.text:0000689C                 assume cs:_text
.text:0000689C                 ;org 689Ch
.text:0000689C ; COMDAT (pick any)
.text:0000689C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000689C
.text:0000689C ; =============== S U B R O U T I N E =======================================
.text:0000689C
.text:0000689C ; Attributes: bp-based frame
.text:0000689C
.text:0000689C ; public: struct CUpdateArchiveCommand & __thiscall CObjectVector<struct CUpdateArchiveCommand>::operator[](unsigned int)
.text:0000689C                 public ??A?$CObjectVector@UCUpdateArchiveCommand@@@@QAEAAUCUpdateArchiveCommand@@I@Z
.text:0000689C ??A?$CObjectVector@UCUpdateArchiveCommand@@@@QAEAAUCUpdateArchiveCommand@@I@Z proc near
.text:0000689C                                         ; CODE XREF: ParseUpdateCommandString(CUpdateOptions &,CObjectVector<UString> const &,NUpdateArchive::CActionSet const &)+11Cp
.text:0000689C
.text:0000689C var_4           = dword ptr -4
.text:0000689C arg_0           = dword ptr  8
.text:0000689C
.text:0000689C                 push    ebp
.text:0000689D                 mov     ebp, esp
.text:0000689F                 push    ecx
.text:000068A0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000068A7                 mov     [ebp+var_4], ecx
.text:000068AA                 mov     eax, [ebp+arg_0]
.text:000068AD                 push    eax
.text:000068AE                 mov     ecx, [ebp+var_4]
.text:000068B1                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:000068B6                 mov     eax, [eax]
.text:000068B8                 add     esp, 4
.text:000068BB                 cmp     ebp, esp
.text:000068BD                 call    __RTC_CheckEsp
.text:000068C2                 mov     esp, ebp
.text:000068C4                 pop     ebp
.text:000068C5                 retn    4
.text:000068C5 ??A?$CObjectVector@UCUpdateArchiveCommand@@@@QAEAAUCUpdateArchiveCommand@@I@Z endp
.text:000068C5
.text:000068C5 _text           ends
.text:000068C5
.text:000068C8 ; ===========================================================================
.text:000068C8
.text:000068C8 ; Segment type: Pure code
.text:000068C8 ; Segment permissions: Read/Execute
.text:000068C8 _text           segment para public 'CODE' use32
.text:000068C8                 assume cs:_text
.text:000068C8                 ;org 68C8h
.text:000068C8 ; COMDAT (pick any)
.text:000068C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000068C8
.text:000068C8 ; =============== S U B R O U T I N E =======================================
.text:000068C8
.text:000068C8 ; Attributes: bp-based frame
.text:000068C8
.text:000068C8 ; public: unsigned int __thiscall CObjectVector<struct CUpdateArchiveCommand>::Add(struct CUpdateArchiveCommand const &)
.text:000068C8                 public ?Add@?$CObjectVector@UCUpdateArchiveCommand@@@@QAEIABUCUpdateArchiveCommand@@@Z
.text:000068C8 ?Add@?$CObjectVector@UCUpdateArchiveCommand@@@@QAEIABUCUpdateArchiveCommand@@@Z proc near
.text:000068C8                                         ; CODE XREF: SetAddCommandOptions(NCommandType::EEnum,NCommandLineParser::CParser const &,CUpdateOptions &)+CBp
.text:000068C8                                         ; ParseUpdateCommandString(CUpdateOptions &,CObjectVector<UString> const &,NUpdateArchive::CActionSet const &)+1EFp
.text:000068C8
.text:000068C8 var_1C          = dword ptr -1Ch
.text:000068C8 var_18          = dword ptr -18h
.text:000068C8 var_14          = dword ptr -14h
.text:000068C8 var_10          = dword ptr -10h
.text:000068C8 var_C           = dword ptr -0Ch
.text:000068C8 var_4           = dword ptr -4
.text:000068C8 arg_0           = dword ptr  8
.text:000068C8
.text:000068C8                 push    ebp
.text:000068C9                 mov     ebp, esp
.text:000068CB                 push    0FFFFFFFFh
.text:000068CD                 push    offset __ehhandler$?Add@?$CObjectVector@UCUpdateArchiveCommand@@@@QAEIABUCUpdateArchiveCommand@@@Z
.text:000068D2                 mov     eax, large fs:0
.text:000068D8                 push    eax
.text:000068D9                 sub     esp, 10h
.text:000068DC                 mov     eax, 0CCCCCCCCh
.text:000068E1                 mov     [ebp+var_1C], eax
.text:000068E4                 mov     [ebp+var_18], eax
.text:000068E7                 mov     [ebp+var_14], eax
.text:000068EA                 mov     [ebp+var_10], eax
.text:000068ED                 mov     eax, dword ptr ds:___security_cookie
.text:000068F2                 xor     eax, ebp
.text:000068F4                 push    eax
.text:000068F5                 lea     eax, [ebp+var_C]
.text:000068F8                 mov     large fs:0, eax
.text:000068FE                 mov     [ebp+var_10], ecx
.text:00006901                 push    80h ; 'Ã'       ; unsigned int
.text:00006906                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0000690B                 add     esp, 4
.text:0000690E                 mov     [ebp+var_18], eax
.text:00006911                 mov     [ebp+var_4], 0
.text:00006918                 cmp     [ebp+var_18], 0
.text:0000691C                 jz      short loc_692F
.text:0000691E                 mov     eax, [ebp+arg_0]
.text:00006921                 push    eax
.text:00006922                 mov     ecx, [ebp+var_18]
.text:00006925                 call    ??0CUpdateArchiveCommand@@QAE@ABU0@@Z ; CUpdateArchiveCommand::CUpdateArchiveCommand(CUpdateArchiveCommand const &)
.text:0000692A                 mov     [ebp+var_1C], eax
.text:0000692D                 jmp     short loc_6936
.text:0000692F ; ---------------------------------------------------------------------------
.text:0000692F
.text:0000692F loc_692F:                               ; CODE XREF: CObjectVector<CUpdateArchiveCommand>::Add(CUpdateArchiveCommand const &)+54j
.text:0000692F                 mov     [ebp+var_1C], 0
.text:00006936
.text:00006936 loc_6936:                               ; CODE XREF: CObjectVector<CUpdateArchiveCommand>::Add(CUpdateArchiveCommand const &)+65j
.text:00006936                 mov     ecx, [ebp+var_1C]
.text:00006939                 mov     [ebp+var_14], ecx
.text:0000693C                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00006943                 mov     edx, [ebp+var_14]
.text:00006946                 push    edx
.text:00006947                 mov     ecx, [ebp+var_10]
.text:0000694A                 call    ?Add@?$CRecordVector@PAX@@QAEIQAX@Z ; CRecordVector<void *>::Add(void * const)
.text:0000694F                 mov     ecx, [ebp+var_C]
.text:00006952                 mov     large fs:0, ecx
.text:00006959                 pop     ecx
.text:0000695A                 add     esp, 1Ch
.text:0000695D                 cmp     ebp, esp
.text:0000695F
.text:0000695F loc_695F:                               ; DATA XREF: .rdata:$SG76912o
.text:0000695F                 call    __RTC_CheckEsp
.text:00006964                 mov     esp, ebp
.text:00006966                 pop     ebp
.text:00006967                 retn    4
.text:00006967 ?Add@?$CObjectVector@UCUpdateArchiveCommand@@@@QAEIABUCUpdateArchiveCommand@@@Z endp
.text:00006967
.text:00006967 ; ---------------------------------------------------------------------------
.text:0000696A                 align 4
.text:0000696A _text           ends
.text:0000696A
.text$x:0000696C ; ===========================================================================
.text$x:0000696C
.text$x:0000696C ; Segment type: Pure code
.text$x:0000696C ; Segment permissions: Read/Execute
.text$x:0000696C _text$x         segment para public 'CODE' use32
.text$x:0000696C                 assume cs:_text$x
.text$x:0000696C                 ;org 696Ch
.text$x:0000696C ; COMDAT (pick associative to section at 68C8)
.text$x:0000696C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000696C
.text$x:0000696C ; =============== S U B R O U T I N E =======================================
.text$x:0000696C
.text$x:0000696C
.text$x:0000696C __unwindfunclet$?Add@?$CObjectVector@UCUpdateArchiveCommand@@@@QAEIABUCUpdateArchiveCommand@@@Z$0 proc near
.text$x:0000696C                                         ; DATA XREF: .xdata$x:00006998o
.text$x:0000696C                 mov     eax, [ebp-18h]
.text$x:0000696F                 push    eax             ; void *
.text$x:00006970
.text$x:00006970 loc_6970:                               ; DATA XREF: .rdata:$SG76922o
.text$x:00006970                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00006975                 pop     ecx
.text$x:00006976                 retn
.text$x:00006976 __unwindfunclet$?Add@?$CObjectVector@UCUpdateArchiveCommand@@@@QAEIABUCUpdateArchiveCommand@@@Z$0 endp
.text$x:00006976
.text$x:00006977
.text$x:00006977 ; =============== S U B R O U T I N E =======================================
.text$x:00006977
.text$x:00006977
.text$x:00006977 __ehhandler$?Add@?$CObjectVector@UCUpdateArchiveCommand@@@@QAEIABUCUpdateArchiveCommand@@@Z proc near
.text$x:00006977                                         ; DATA XREF: CObjectVector<CUpdateArchiveCommand>::Add(CUpdateArchiveCommand const &)+5o
.text$x:00006977
.text$x:00006977 arg_4           = dword ptr  8
.text$x:00006977
.text$x:00006977                 mov     edx, [esp+arg_4]
.text$x:0000697B                 lea     eax, [edx+0Ch]
.text$x:0000697E                 mov     ecx, [edx-14h]
.text$x:00006981                 xor     ecx, eax
.text$x:00006983                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006988                 mov     eax, offset __ehfuncinfo$?Add@?$CObjectVector@UCUpdateArchiveCommand@@@@QAEIABUCUpdateArchiveCommand@@@Z
.text$x:0000698D                 jmp     ___CxxFrameHandler3
.text$x:0000698D __ehhandler$?Add@?$CObjectVector@UCUpdateArchiveCommand@@@@QAEIABUCUpdateArchiveCommand@@@Z endp
.text$x:0000698D
.text$x:0000698D ; ---------------------------------------------------------------------------
.text$x:00006992                 align 4
.text$x:00006992 _text$x         ends
.text$x:00006992
.xdata$x:00006994 ; ===========================================================================
.xdata$x:00006994
.xdata$x:00006994 ; Segment type: Pure data
.xdata$x:00006994 ; Segment permissions: Read
.xdata$x:00006994 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006994                 assume cs:_xdata$x
.xdata$x:00006994                 ;org 6994h
.xdata$x:00006994 ; COMDAT (pick associative to section at 68C8)
.xdata$x:00006994 __unwindtable$?Add@?$CObjectVector@UCUpdateArchiveCommand@@@@QAEIABUCUpdateArchiveCommand@@@Z db 0FFh
.xdata$x:00006994                                         ; DATA XREF: .xdata$x:000069A4o
.xdata$x:00006995                 db 0FFh
.xdata$x:00006996                 db 0FFh
.xdata$x:00006997                 db 0FFh
.xdata$x:00006998                 dd offset __unwindfunclet$?Add@?$CObjectVector@UCUpdateArchiveCommand@@@@QAEIABUCUpdateArchiveCommand@@@Z$0
.xdata$x:0000699C __ehfuncinfo$?Add@?$CObjectVector@UCUpdateArchiveCommand@@@@QAEIABUCUpdateArchiveCommand@@@Z db  22h ; "
.xdata$x:0000699C                                         ; DATA XREF: __ehhandler$?Add@?$CObjectVector@UCUpdateArchiveCommand@@@@QAEIABUCUpdateArchiveCommand@@@Z+11o
.xdata$x:0000699D                 db    5
.xdata$x:0000699E                 db  93h ; Ã´
.xdata$x:0000699F                 db  19h
.xdata$x:000069A0                 db    1
.xdata$x:000069A1                 db    0
.xdata$x:000069A2                 db    0
.xdata$x:000069A3                 db    0
.xdata$x:000069A4                 dd offset __unwindtable$?Add@?$CObjectVector@UCUpdateArchiveCommand@@@@QAEIABUCUpdateArchiveCommand@@@Z
.xdata$x:000069A8                 db    0
.xdata$x:000069A9                 db    0
.xdata$x:000069AA                 db    0
.xdata$x:000069AB                 db    0
.xdata$x:000069AC                 db    0
.xdata$x:000069AD                 db    0
.xdata$x:000069AE                 db    0
.xdata$x:000069AF                 db    0
.xdata$x:000069B0                 db    0
.xdata$x:000069B1                 db    0
.xdata$x:000069B2                 db    0
.xdata$x:000069B3                 db    0
.xdata$x:000069B4                 db    0
.xdata$x:000069B5                 db    0
.xdata$x:000069B6                 db    0
.xdata$x:000069B7                 db    0
.xdata$x:000069B8                 db    0
.xdata$x:000069B9                 db    0
.xdata$x:000069BA                 db    0
.xdata$x:000069BB                 db    0
.xdata$x:000069BC                 db    1
.xdata$x:000069BD                 db    0
.xdata$x:000069BE                 db    0
.xdata$x:000069BF                 db    0
.xdata$x:000069BF _xdata$x        ends
.xdata$x:000069BF
.text:000069C0 ; ===========================================================================
.text:000069C0
.text:000069C0 ; Segment type: Pure code
.text:000069C0 ; Segment permissions: Read/Execute
.text:000069C0 _text           segment para public 'CODE' use32
.text:000069C0                 assume cs:_text
.text:000069C0                 ;org 69C0h
.text:000069C0 ; COMDAT (pick any)
.text:000069C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000069C0
.text:000069C0 ; =============== S U B R O U T I N E =======================================
.text:000069C0
.text:000069C0 ; Attributes: bp-based frame
.text:000069C0
.text:000069C0 ; public: void __thiscall CObjectVector<struct CUpdateArchiveCommand>::Clear(void)
.text:000069C0                 public ?Clear@?$CObjectVector@UCUpdateArchiveCommand@@@@QAEXXZ
.text:000069C0 ?Clear@?$CObjectVector@UCUpdateArchiveCommand@@@@QAEXXZ proc near
.text:000069C0                                         ; CODE XREF: SetAddCommandOptions(NCommandType::EEnum,NCommandLineParser::CParser const &,CUpdateOptions &)+9Ap
.text:000069C0
.text:000069C0 var_14          = dword ptr -14h
.text:000069C0 var_10          = dword ptr -10h
.text:000069C0 var_C           = dword ptr -0Ch
.text:000069C0 var_8           = dword ptr -8
.text:000069C0 var_4           = dword ptr -4
.text:000069C0
.text:000069C0                 push    ebp
.text:000069C1                 mov     ebp, esp
.text:000069C3                 sub     esp, 14h
.text:000069C6                 mov     eax, 0CCCCCCCCh
.text:000069CB                 mov     [ebp+var_14], eax
.text:000069CE                 mov     [ebp+var_10], eax
.text:000069D1                 mov     [ebp+var_C], eax
.text:000069D4                 mov     [ebp+var_8], eax
.text:000069D7                 mov     [ebp+var_4], eax
.text:000069DA                 mov     [ebp+var_4], ecx
.text:000069DD                 mov     ecx, [ebp+var_4]
.text:000069E0                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:000069E5                 mov     [ebp+var_8], eax
.text:000069E8
.text:000069E8 loc_69E8:                               ; CODE XREF: CObjectVector<CUpdateArchiveCommand>::Clear(void):loc_6A2Aj
.text:000069E8                 cmp     [ebp+var_8], 0
.text:000069EC                 jz      short loc_6A2C
.text:000069EE                 mov     eax, [ebp+var_8]
.text:000069F1                 sub     eax, 1
.text:000069F4                 mov     [ebp+var_8], eax
.text:000069F7                 mov     ecx, [ebp+var_8]
.text:000069FA                 push    ecx
.text:000069FB                 mov     ecx, [ebp+var_4]
.text:000069FE                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00006A03                 mov     edx, [eax]
.text:00006A05                 mov     [ebp+var_10], edx
.text:00006A08                 mov     eax, [ebp+var_10]
.text:00006A0B                 mov     [ebp+var_C], eax
.text:00006A0E                 cmp     [ebp+var_C], 0
.text:00006A12                 jz      short loc_6A23
.text:00006A14                 push    1
.text:00006A16                 mov     ecx, [ebp+var_C]
.text:00006A19                 call    ??_GCUpdateArchiveCommand@@QAEPAXI@Z ; CUpdateArchiveCommand::`scalar deleting destructor'(uint)
.text:00006A1E                 mov     [ebp+var_14], eax
.text:00006A21                 jmp     short loc_6A2A
.text:00006A23 ; ---------------------------------------------------------------------------
.text:00006A23
.text:00006A23 loc_6A23:                               ; CODE XREF: CObjectVector<CUpdateArchiveCommand>::Clear(void)+52j
.text:00006A23                 mov     [ebp+var_14], 0
.text:00006A2A
.text:00006A2A loc_6A2A:                               ; CODE XREF: CObjectVector<CUpdateArchiveCommand>::Clear(void)+61j
.text:00006A2A                 jmp     short loc_69E8
.text:00006A2C ; ---------------------------------------------------------------------------
.text:00006A2C
.text:00006A2C loc_6A2C:                               ; CODE XREF: CObjectVector<CUpdateArchiveCommand>::Clear(void)+2Cj
.text:00006A2C                 mov     ecx, [ebp+var_4]
.text:00006A2F                 call    ?Clear@?$CRecordVector@PAX@@QAEXXZ ; CRecordVector<void *>::Clear(void)
.text:00006A34                 add     esp, 14h
.text:00006A37                 cmp     ebp, esp
.text:00006A39                 call    __RTC_CheckEsp
.text:00006A3E                 mov     esp, ebp
.text:00006A40                 pop     ebp
.text:00006A41                 retn
.text:00006A41 ?Clear@?$CObjectVector@UCUpdateArchiveCommand@@@@QAEXXZ endp
.text:00006A41
.text:00006A41 ; ---------------------------------------------------------------------------
.text:00006A42                 align 4
.text:00006A42 _text           ends
.text:00006A42
.text:00006A44 ; ===========================================================================
.text:00006A44
.text:00006A44 ; Segment type: Pure code
.text:00006A44 ; Segment permissions: Read/Execute
.text:00006A44 _text           segment para public 'CODE' use32
.text:00006A44                 assume cs:_text
.text:00006A44                 ;org 6A44h
.text:00006A44 ; COMDAT (pick any)
.text:00006A44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00006A44
.text:00006A44 ; =============== S U B R O U T I N E =======================================
.text:00006A44
.text:00006A44 ; Attributes: bp-based frame
.text:00006A44
.text:00006A44 ; public: void __thiscall CObjectVector<struct CUpdateArchiveCommand>::Delete(unsigned int)
.text:00006A44                 public ?Delete@?$CObjectVector@UCUpdateArchiveCommand@@@@QAEXI@Z
.text:00006A44 ?Delete@?$CObjectVector@UCUpdateArchiveCommand@@@@QAEXI@Z proc near
.text:00006A44                                         ; CODE XREF: ParseUpdateCommandString(CUpdateOptions &,CObjectVector<UString> const &,NUpdateArchive::CActionSet const &)+A8p
.text:00006A44
.text:00006A44 var_10          = dword ptr -10h
.text:00006A44 var_C           = dword ptr -0Ch
.text:00006A44 var_8           = dword ptr -8
.text:00006A44 var_4           = dword ptr -4
.text:00006A44 arg_0           = dword ptr  8
.text:00006A44
.text:00006A44                 push    ebp
.text:00006A45                 mov     ebp, esp
.text:00006A47                 sub     esp, 10h
.text:00006A4A                 mov     eax, 0CCCCCCCCh
.text:00006A4F                 mov     [ebp+var_10], eax
.text:00006A52                 mov     [ebp+var_C], eax
.text:00006A55                 mov     [ebp+var_8], eax
.text:00006A58                 mov     [ebp+var_4], eax
.text:00006A5B                 mov     [ebp+var_4], ecx
.text:00006A5E                 mov     eax, [ebp+arg_0]
.text:00006A61                 push    eax
.text:00006A62                 mov     ecx, [ebp+var_4]
.text:00006A65                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00006A6A                 mov     ecx, [eax]
.text:00006A6C                 mov     [ebp+var_C], ecx
.text:00006A6F                 mov     edx, [ebp+var_C]
.text:00006A72                 mov     [ebp+var_8], edx
.text:00006A75                 cmp     [ebp+var_8], 0
.text:00006A79                 jz      short loc_6A8A
.text:00006A7B                 push    1
.text:00006A7D                 mov     ecx, [ebp+var_8]
.text:00006A80                 call    ??_GCUpdateArchiveCommand@@QAEPAXI@Z ; CUpdateArchiveCommand::`scalar deleting destructor'(uint)
.text:00006A85                 mov     [ebp+var_10], eax
.text:00006A88                 jmp     short loc_6A91
.text:00006A8A ; ---------------------------------------------------------------------------
.text:00006A8A
.text:00006A8A loc_6A8A:                               ; CODE XREF: CObjectVector<CUpdateArchiveCommand>::Delete(uint)+35j
.text:00006A8A                 mov     [ebp+var_10], 0
.text:00006A91
.text:00006A91 loc_6A91:                               ; CODE XREF: CObjectVector<CUpdateArchiveCommand>::Delete(uint)+44j
.text:00006A91                 mov     eax, [ebp+arg_0]
.text:00006A94                 push    eax
.text:00006A95                 mov     ecx, [ebp+var_4]
.text:00006A98                 call    ?Delete@?$CRecordVector@PAX@@QAEXI@Z ; CRecordVector<void *>::Delete(uint)
.text:00006A9D                 add     esp, 10h
.text:00006AA0                 cmp     ebp, esp
.text:00006AA2                 call    __RTC_CheckEsp
.text:00006AA7                 mov     esp, ebp
.text:00006AA9                 pop     ebp
.text:00006AAA                 retn    4
.text:00006AAA ?Delete@?$CObjectVector@UCUpdateArchiveCommand@@@@QAEXI@Z endp
.text:00006AAA
.text:00006AAA ; ---------------------------------------------------------------------------
.text:00006AAD                 align 10h
.text:00006AAD _text           ends
.text:00006AAD
.text:00006AB0 ; ===========================================================================
.text:00006AB0
.text:00006AB0 ; Segment type: Pure code
.text:00006AB0 ; Segment permissions: Read/Execute
.text:00006AB0 _text           segment para public 'CODE' use32
.text:00006AB0                 assume cs:_text
.text:00006AB0                 ;org 6AB0h
.text:00006AB0 ; COMDAT (pick any)
.text:00006AB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00006AB0
.text:00006AB0 ; =============== S U B R O U T I N E =======================================
.text:00006AB0
.text:00006AB0 ; Attributes: bp-based frame
.text:00006AB0
.text:00006AB0 ; public: struct CRenamePair & __thiscall CObjectVector<struct CRenamePair>::AddNew(void)
.text:00006AB0                 public ?AddNew@?$CObjectVector@UCRenamePair@@@@QAEAAUCRenamePair@@XZ
.text:00006AB0 ?AddNew@?$CObjectVector@UCRenamePair@@@@QAEAAUCRenamePair@@XZ proc near
.text:00006AB0                                         ; CODE XREF: AddRenamePair(CObjectVector<CRenamePair> *,UString const &,UString const &,NRecursedType::EEnum,bool)+48p
.text:00006AB0
.text:00006AB0 var_20          = dword ptr -20h
.text:00006AB0 var_1C          = dword ptr -1Ch
.text:00006AB0 var_18          = dword ptr -18h
.text:00006AB0 var_14          = dword ptr -14h
.text:00006AB0 var_10          = dword ptr -10h
.text:00006AB0 var_C           = dword ptr -0Ch
.text:00006AB0 var_4           = dword ptr -4
.text:00006AB0
.text:00006AB0                 push    ebp
.text:00006AB1                 mov     ebp, esp
.text:00006AB3                 push    0FFFFFFFFh
.text:00006AB5                 push    offset __ehhandler$?AddNew@?$CObjectVector@UCRenamePair@@@@QAEAAUCRenamePair@@XZ
.text:00006ABA                 mov     eax, large fs:0
.text:00006AC0                 push    eax
.text:00006AC1                 sub     esp, 14h
.text:00006AC4                 mov     eax, 0CCCCCCCCh
.text:00006AC9                 mov     [ebp+var_20], eax
.text:00006ACC                 mov     [ebp+var_1C], eax
.text:00006ACF                 mov     [ebp+var_18], eax
.text:00006AD2                 mov     [ebp+var_14], eax
.text:00006AD5                 mov     [ebp+var_10], eax
.text:00006AD8                 mov     eax, dword ptr ds:___security_cookie
.text:00006ADD                 xor     eax, ebp
.text:00006ADF                 push    eax
.text:00006AE0                 lea     eax, [ebp+var_C]
.text:00006AE3                 mov     large fs:0, eax
.text:00006AE9                 mov     [ebp+var_10], ecx
.text:00006AEC                 push    20h ; ' '       ; unsigned int
.text:00006AEE                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00006AF3                 add     esp, 4
.text:00006AF6                 mov     [ebp+var_1C], eax
.text:00006AF9                 mov     [ebp+var_4], 0
.text:00006B00                 cmp     [ebp+var_1C], 0
.text:00006B04                 jz      short loc_6B13
.text:00006B06                 mov     ecx, [ebp+var_1C]
.text:00006B09                 call    ??0CRenamePair@@QAE@XZ ; CRenamePair::CRenamePair(void)
.text:00006B0E                 mov     [ebp+var_20], eax
.text:00006B11                 jmp     short loc_6B1A
.text:00006B13 ; ---------------------------------------------------------------------------
.text:00006B13
.text:00006B13 loc_6B13:                               ; CODE XREF: CObjectVector<CRenamePair>::AddNew(void)+54j
.text:00006B13                 mov     [ebp+var_20], 0
.text:00006B1A
.text:00006B1A loc_6B1A:                               ; CODE XREF: CObjectVector<CRenamePair>::AddNew(void)+61j
.text:00006B1A                 mov     eax, [ebp+var_20]
.text:00006B1D                 mov     [ebp+var_18], eax
.text:00006B20                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00006B27                 mov     ecx, [ebp+var_18]
.text:00006B2A                 mov     [ebp+var_14], ecx
.text:00006B2D                 mov     edx, [ebp+var_14]
.text:00006B30                 push    edx
.text:00006B31                 mov     ecx, [ebp+var_10]
.text:00006B34                 call    ?Add@?$CRecordVector@PAX@@QAEIQAX@Z ; CRecordVector<void *>::Add(void * const)
.text:00006B39                 mov     eax, [ebp+var_14]
.text:00006B3C                 mov     ecx, [ebp+var_C]
.text:00006B3F                 mov     large fs:0, ecx
.text:00006B46                 pop     ecx
.text:00006B47                 add     esp, 20h
.text:00006B4A                 cmp     ebp, esp
.text:00006B4C                 call    __RTC_CheckEsp
.text:00006B51                 mov     esp, ebp
.text:00006B53                 pop     ebp
.text:00006B54                 retn
.text:00006B54 ?AddNew@?$CObjectVector@UCRenamePair@@@@QAEAAUCRenamePair@@XZ endp
.text:00006B54
.text:00006B54 ; ---------------------------------------------------------------------------
.text:00006B55                 align 4
.text:00006B55 _text           ends
.text:00006B55
.text$x:00006B58 ; ===========================================================================
.text$x:00006B58
.text$x:00006B58 ; Segment type: Pure code
.text$x:00006B58 ; Segment permissions: Read/Execute
.text$x:00006B58 _text$x         segment para public 'CODE' use32
.text$x:00006B58                 assume cs:_text$x
.text$x:00006B58                 ;org 6B58h
.text$x:00006B58 ; COMDAT (pick associative to section at 6AB0)
.text$x:00006B58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006B58
.text$x:00006B58 ; =============== S U B R O U T I N E =======================================
.text$x:00006B58
.text$x:00006B58
.text$x:00006B58 __unwindfunclet$?AddNew@?$CObjectVector@UCRenamePair@@@@QAEAAUCRenamePair@@XZ$0 proc near
.text$x:00006B58                                         ; DATA XREF: .xdata$x:00006B84o
.text$x:00006B58                 mov     eax, [ebp-1Ch]
.text$x:00006B5B                 push    eax             ; void *
.text$x:00006B5C                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00006B61                 pop     ecx
.text$x:00006B62                 retn
.text$x:00006B62 __unwindfunclet$?AddNew@?$CObjectVector@UCRenamePair@@@@QAEAAUCRenamePair@@XZ$0 endp
.text$x:00006B62
.text$x:00006B63
.text$x:00006B63 ; =============== S U B R O U T I N E =======================================
.text$x:00006B63
.text$x:00006B63
.text$x:00006B63 __ehhandler$?AddNew@?$CObjectVector@UCRenamePair@@@@QAEAAUCRenamePair@@XZ proc near
.text$x:00006B63                                         ; DATA XREF: CObjectVector<CRenamePair>::AddNew(void)+5o
.text$x:00006B63
.text$x:00006B63 arg_4           = dword ptr  8
.text$x:00006B63
.text$x:00006B63                 mov     edx, [esp+arg_4]
.text$x:00006B67                 lea     eax, [edx+0Ch]
.text$x:00006B6A                 mov     ecx, [edx-18h]
.text$x:00006B6D                 xor     ecx, eax
.text$x:00006B6F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006B74                 mov     eax, offset __ehfuncinfo$?AddNew@?$CObjectVector@UCRenamePair@@@@QAEAAUCRenamePair@@XZ
.text$x:00006B79                 jmp     ___CxxFrameHandler3
.text$x:00006B79 __ehhandler$?AddNew@?$CObjectVector@UCRenamePair@@@@QAEAAUCRenamePair@@XZ endp
.text$x:00006B79
.text$x:00006B79 ; ---------------------------------------------------------------------------
.text$x:00006B7E                 align 10h
.text$x:00006B7E _text$x         ends
.text$x:00006B7E
.xdata$x:00006B80 ; ===========================================================================
.xdata$x:00006B80
.xdata$x:00006B80 ; Segment type: Pure data
.xdata$x:00006B80 ; Segment permissions: Read
.xdata$x:00006B80 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006B80                 assume cs:_xdata$x
.xdata$x:00006B80                 ;org 6B80h
.xdata$x:00006B80 ; COMDAT (pick associative to section at 6AB0)
.xdata$x:00006B80 __unwindtable$?AddNew@?$CObjectVector@UCRenamePair@@@@QAEAAUCRenamePair@@XZ db 0FFh
.xdata$x:00006B80                                         ; DATA XREF: .xdata$x:00006B90o
.xdata$x:00006B81                 db 0FFh
.xdata$x:00006B82                 db 0FFh
.xdata$x:00006B83                 db 0FFh
.xdata$x:00006B84                 dd offset __unwindfunclet$?AddNew@?$CObjectVector@UCRenamePair@@@@QAEAAUCRenamePair@@XZ$0
.xdata$x:00006B88 __ehfuncinfo$?AddNew@?$CObjectVector@UCRenamePair@@@@QAEAAUCRenamePair@@XZ db  22h ; "
.xdata$x:00006B88                                         ; DATA XREF: __ehhandler$?AddNew@?$CObjectVector@UCRenamePair@@@@QAEAAUCRenamePair@@XZ+11o
.xdata$x:00006B89                 db    5
.xdata$x:00006B8A                 db  93h ; Ã´
.xdata$x:00006B8B                 db  19h
.xdata$x:00006B8C                 db    1
.xdata$x:00006B8D                 db    0
.xdata$x:00006B8E                 db    0
.xdata$x:00006B8F                 db    0
.xdata$x:00006B90                 dd offset __unwindtable$?AddNew@?$CObjectVector@UCRenamePair@@@@QAEAAUCRenamePair@@XZ
.xdata$x:00006B94                 db    0
.xdata$x:00006B95                 db    0
.xdata$x:00006B96                 db    0
.xdata$x:00006B97                 db    0
.xdata$x:00006B98                 db    0
.xdata$x:00006B99                 db    0
.xdata$x:00006B9A                 db    0
.xdata$x:00006B9B                 db    0
.xdata$x:00006B9C                 db    0
.xdata$x:00006B9D                 db    0
.xdata$x:00006B9E                 db    0
.xdata$x:00006B9F                 db    0
.xdata$x:00006BA0                 db    0
.xdata$x:00006BA1                 db    0
.xdata$x:00006BA2                 db    0
.xdata$x:00006BA3                 db    0
.xdata$x:00006BA4                 db    0
.xdata$x:00006BA5                 db    0
.xdata$x:00006BA6                 db    0
.xdata$x:00006BA7                 db    0
.xdata$x:00006BA8                 db    1
.xdata$x:00006BA9                 db    0
.xdata$x:00006BAA                 db    0
.xdata$x:00006BAB                 db    0
.xdata$x:00006BAB _xdata$x        ends
.xdata$x:00006BAB
.text:00006BAC ; ===========================================================================
.text:00006BAC
.text:00006BAC ; Segment type: Pure code
.text:00006BAC ; Segment permissions: Read/Execute
.text:00006BAC _text           segment para public 'CODE' use32
.text:00006BAC                 assume cs:_text
.text:00006BAC                 ;org 6BACh
.text:00006BAC ; COMDAT (pick any)
.text:00006BAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00006BAC
.text:00006BAC ; =============== S U B R O U T I N E =======================================
.text:00006BAC
.text:00006BAC ; Attributes: bp-based frame
.text:00006BAC
.text:00006BAC ; public: __thiscall CRenamePair::CRenamePair(void)
.text:00006BAC                 public ??0CRenamePair@@QAE@XZ
.text:00006BAC ??0CRenamePair@@QAE@XZ proc near        ; CODE XREF: CObjectVector<CRenamePair>::AddNew(void)+59p
.text:00006BAC
.text:00006BAC var_10          = dword ptr -10h
.text:00006BAC var_C           = dword ptr -0Ch
.text:00006BAC var_4           = dword ptr -4
.text:00006BAC
.text:00006BAC                 push    ebp
.text:00006BAD                 mov     ebp, esp
.text:00006BAF                 push    0FFFFFFFFh
.text:00006BB1                 push    offset __ehhandler$??0CRenamePair@@QAE@XZ
.text:00006BB6                 mov     eax, large fs:0
.text:00006BBC                 push    eax
.text:00006BBD                 push    ecx
.text:00006BBE                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00006BC5                 mov     eax, dword ptr ds:___security_cookie
.text:00006BCA                 xor     eax, ebp
.text:00006BCC                 push    eax
.text:00006BCD                 lea     eax, [ebp+var_C]
.text:00006BD0                 mov     large fs:0, eax
.text:00006BD6                 mov     [ebp+var_10], ecx
.text:00006BD9                 mov     ecx, [ebp+var_10]
.text:00006BDC                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00006BE1                 mov     [ebp+var_4], 0
.text:00006BE8                 mov     ecx, [ebp+var_10]
.text:00006BEB                 add     ecx, 0Ch
.text:00006BEE                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00006BF3                 mov     eax, [ebp+var_10]
.text:00006BF6                 mov     byte ptr [eax+18h], 1
.text:00006BFA                 mov     ecx, [ebp+var_10]
.text:00006BFD                 mov     dword ptr [ecx+1Ch], 2
.text:00006C04                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00006C0B                 mov     eax, [ebp+var_10]
.text:00006C0E                 mov     ecx, [ebp+var_C]
.text:00006C11                 mov     large fs:0, ecx
.text:00006C18                 pop     ecx
.text:00006C19                 add     esp, 10h
.text:00006C1C                 cmp     ebp, esp
.text:00006C1E                 call    __RTC_CheckEsp
.text:00006C23                 mov     esp, ebp
.text:00006C25                 pop     ebp
.text:00006C26                 retn
.text:00006C26 ??0CRenamePair@@QAE@XZ endp
.text:00006C26
.text:00006C26 ; ---------------------------------------------------------------------------
.text:00006C27                 align 4
.text:00006C27 _text           ends
.text:00006C27
.text$x:00006C28 ; ===========================================================================
.text$x:00006C28
.text$x:00006C28 ; Segment type: Pure code
.text$x:00006C28 ; Segment permissions: Read/Execute
.text$x:00006C28 _text$x         segment para public 'CODE' use32
.text$x:00006C28                 assume cs:_text$x
.text$x:00006C28                 ;org 6C28h
.text$x:00006C28 ; COMDAT (pick associative to section at 6BAC)
.text$x:00006C28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006C28
.text$x:00006C28 ; =============== S U B R O U T I N E =======================================
.text$x:00006C28
.text$x:00006C28
.text$x:00006C28 __unwindfunclet$??0CRenamePair@@QAE@XZ$0 proc near
.text$x:00006C28                                         ; DATA XREF: .xdata$x:00006C50o
.text$x:00006C28                 mov     ecx, [ebp-10h]  ; this
.text$x:00006C2B                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00006C2B __unwindfunclet$??0CRenamePair@@QAE@XZ$0 endp
.text$x:00006C2B
.text$x:00006C30
.text$x:00006C30 ; =============== S U B R O U T I N E =======================================
.text$x:00006C30
.text$x:00006C30
.text$x:00006C30 __ehhandler$??0CRenamePair@@QAE@XZ proc near
.text$x:00006C30                                         ; DATA XREF: CRenamePair::CRenamePair(void)+5o
.text$x:00006C30
.text$x:00006C30 arg_4           = dword ptr  8
.text$x:00006C30
.text$x:00006C30                 mov     edx, [esp+arg_4]
.text$x:00006C34                 lea     eax, [edx+0Ch]
.text$x:00006C37                 mov     ecx, [edx-8]
.text$x:00006C3A                 xor     ecx, eax
.text$x:00006C3C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006C41                 mov     eax, offset __ehfuncinfo$??0CRenamePair@@QAE@XZ
.text$x:00006C46                 jmp     ___CxxFrameHandler3
.text$x:00006C46 __ehhandler$??0CRenamePair@@QAE@XZ endp
.text$x:00006C46
.text$x:00006C46 ; ---------------------------------------------------------------------------
.text$x:00006C4B                 align 4
.text$x:00006C4B _text$x         ends
.text$x:00006C4B
.xdata$x:00006C4C ; ===========================================================================
.xdata$x:00006C4C
.xdata$x:00006C4C ; Segment type: Pure data
.xdata$x:00006C4C ; Segment permissions: Read
.xdata$x:00006C4C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006C4C                 assume cs:_xdata$x
.xdata$x:00006C4C                 ;org 6C4Ch
.xdata$x:00006C4C ; COMDAT (pick associative to section at 6BAC)
.xdata$x:00006C4C __unwindtable$??0CRenamePair@@QAE@XZ db 0FFh
.xdata$x:00006C4C                                         ; DATA XREF: .xdata$x:00006C5Co
.xdata$x:00006C4D                 db 0FFh
.xdata$x:00006C4E                 db 0FFh
.xdata$x:00006C4F                 db 0FFh
.xdata$x:00006C50                 dd offset __unwindfunclet$??0CRenamePair@@QAE@XZ$0
.xdata$x:00006C54 __ehfuncinfo$??0CRenamePair@@QAE@XZ db  22h ; "
.xdata$x:00006C54                                         ; DATA XREF: __ehhandler$??0CRenamePair@@QAE@XZ+11o
.xdata$x:00006C55                 db    5
.xdata$x:00006C56                 db  93h ; Ã´
.xdata$x:00006C57                 db  19h
.xdata$x:00006C58                 db    1
.xdata$x:00006C59                 db    0
.xdata$x:00006C5A                 db    0
.xdata$x:00006C5B                 db    0
.xdata$x:00006C5C                 dd offset __unwindtable$??0CRenamePair@@QAE@XZ
.xdata$x:00006C60                 db    0
.xdata$x:00006C61                 db    0
.xdata$x:00006C62                 db    0
.xdata$x:00006C63                 db    0
.xdata$x:00006C64                 db    0
.xdata$x:00006C65                 db    0
.xdata$x:00006C66                 db    0
.xdata$x:00006C67                 db    0
.xdata$x:00006C68                 db    0
.xdata$x:00006C69                 db    0
.xdata$x:00006C6A                 db    0
.xdata$x:00006C6B                 db    0
.xdata$x:00006C6C                 db    0
.xdata$x:00006C6D                 db    0
.xdata$x:00006C6E                 db    0
.xdata$x:00006C6F                 db    0
.xdata$x:00006C70                 db    0
.xdata$x:00006C71                 db    0
.xdata$x:00006C72                 db    0
.xdata$x:00006C73                 db    0
.xdata$x:00006C74                 db    1
.xdata$x:00006C75                 db    0
.xdata$x:00006C76                 db    0
.xdata$x:00006C77                 db    0
.xdata$x:00006C77 _xdata$x        ends
.xdata$x:00006C77
.text:00006C78 ; ===========================================================================
.text:00006C78
.text:00006C78 ; Segment type: Pure code
.text:00006C78 ; Segment permissions: Read/Execute
.text:00006C78 _text           segment para public 'CODE' use32
.text:00006C78                 assume cs:_text
.text:00006C78                 ;org 6C78h
.text:00006C78 ; COMDAT (pick any)
.text:00006C78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00006C78
.text:00006C78 ; =============== S U B R O U T I N E =======================================
.text:00006C78
.text:00006C78 ; Attributes: bp-based frame
.text:00006C78
.text:00006C78 ; public: void * __thiscall UString::`scalar deleting destructor'(unsigned int)
.text:00006C78                 public ??_GUString@@QAEPAXI@Z
.text:00006C78 ??_GUString@@QAEPAXI@Z proc near        ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+7Fp
.text:00006C78                                         ; CObjectVector<UString>::Clear(void)+59p
.text:00006C78
.text:00006C78 var_4           = dword ptr -4
.text:00006C78 arg_0           = dword ptr  8
.text:00006C78
.text:00006C78                 push    ebp
.text:00006C79                 mov     ebp, esp
.text:00006C7B                 push    ecx
.text:00006C7C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00006C83                 mov     [ebp+var_4], ecx
.text:00006C86                 mov     ecx, [ebp+var_4] ; this
.text:00006C89                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00006C8E                 mov     eax, [ebp+arg_0]
.text:00006C91                 and     eax, 1
.text:00006C94                 jz      short loc_6CA2
.text:00006C96                 mov     ecx, [ebp+var_4]
.text:00006C99                 push    ecx             ; void *
.text:00006C9A                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00006C9F                 add     esp, 4
.text:00006CA2
.text:00006CA2 loc_6CA2:                               ; CODE XREF: UString::`scalar deleting destructor'(uint)+1Cj
.text:00006CA2                 mov     eax, [ebp+var_4]
.text:00006CA5                 add     esp, 4
.text:00006CA8                 cmp     ebp, esp
.text:00006CAA                 call    __RTC_CheckEsp
.text:00006CAF                 mov     esp, ebp
.text:00006CB1                 pop     ebp
.text:00006CB2                 retn    4
.text:00006CB2 ??_GUString@@QAEPAXI@Z endp
.text:00006CB2
.text:00006CB2 ; ---------------------------------------------------------------------------
.text:00006CB5                 align 4
.text:00006CB5 _text           ends
.text:00006CB5
.text:00006CB8 ; ===========================================================================
.text:00006CB8
.text:00006CB8 ; Segment type: Pure code
.text:00006CB8 ; Segment permissions: Read/Execute
.text:00006CB8 _text           segment para public 'CODE' use32
.text:00006CB8                 assume cs:_text
.text:00006CB8                 ;org 6CB8h
.text:00006CB8 ; COMDAT (pick any)
.text:00006CB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00006CB8
.text:00006CB8 ; =============== S U B R O U T I N E =======================================
.text:00006CB8
.text:00006CB8 ; Attributes: bp-based frame
.text:00006CB8
.text:00006CB8 ; public: void * __thiscall NWildcard::CCensorNode::`scalar deleting destructor'(unsigned int)
.text:00006CB8                 public ??_GCCensorNode@NWildcard@@QAEPAXI@Z
.text:00006CB8 ??_GCCensorNode@NWildcard@@QAEPAXI@Z proc near
.text:00006CB8                                         ; CODE XREF: CObjectVector<NWildcard::CCensorNode>::Delete(uint)+3Cp
.text:00006CB8                                         ; CObjectVector<NWildcard::CCensorNode>::~CObjectVector<NWildcard::CCensorNode>(void)+7Fp
.text:00006CB8
.text:00006CB8 var_4           = dword ptr -4
.text:00006CB8 arg_0           = dword ptr  8
.text:00006CB8
.text:00006CB8                 push    ebp
.text:00006CB9                 mov     ebp, esp
.text:00006CBB                 push    ecx
.text:00006CBC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00006CC3                 mov     [ebp+var_4], ecx
.text:00006CC6                 mov     ecx, [ebp+var_4] ; this
.text:00006CC9                 call    ??1CCensorNode@NWildcard@@QAE@XZ ; NWildcard::CCensorNode::~CCensorNode(void)
.text:00006CCE                 mov     eax, [ebp+arg_0]
.text:00006CD1                 and     eax, 1
.text:00006CD4                 jz      short loc_6CE2
.text:00006CD6                 mov     ecx, [ebp+var_4]
.text:00006CD9                 push    ecx             ; void *
.text:00006CDA                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00006CDF                 add     esp, 4
.text:00006CE2
.text:00006CE2 loc_6CE2:                               ; CODE XREF: NWildcard::CCensorNode::`scalar deleting destructor'(uint)+1Cj
.text:00006CE2                 mov     eax, [ebp+var_4]
.text:00006CE5                 add     esp, 4
.text:00006CE8                 cmp     ebp, esp
.text:00006CEA                 call    __RTC_CheckEsp
.text:00006CEF                 mov     esp, ebp
.text:00006CF1                 pop     ebp
.text:00006CF2                 retn    4
.text:00006CF2 ??_GCCensorNode@NWildcard@@QAEPAXI@Z endp
.text:00006CF2
.text:00006CF2 ; ---------------------------------------------------------------------------
.text:00006CF5                 align 4
.text:00006CF5 _text           ends
.text:00006CF5
.text:00006CF8 ; ===========================================================================
.text:00006CF8
.text:00006CF8 ; Segment type: Pure code
.text:00006CF8 ; Segment permissions: Read/Execute
.text:00006CF8 _text           segment para public 'CODE' use32
.text:00006CF8                 assume cs:_text
.text:00006CF8                 ;org 6CF8h
.text:00006CF8 ; COMDAT (pick any)
.text:00006CF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00006CF8
.text:00006CF8 ; =============== S U B R O U T I N E =======================================
.text:00006CF8
.text:00006CF8 ; Attributes: bp-based frame
.text:00006CF8
.text:00006CF8 ; _DWORD __thiscall NWildcard::CCensorNode::~CCensorNode(NWildcard::CCensorNode *__hidden this)
.text:00006CF8                 public ??1CCensorNode@NWildcard@@QAE@XZ
.text:00006CF8 ??1CCensorNode@NWildcard@@QAE@XZ proc near
.text:00006CF8                                         ; CODE XREF: NWildcard::CCensorNode::`scalar deleting destructor'(uint)+11p
.text:00006CF8
.text:00006CF8 var_10          = dword ptr -10h
.text:00006CF8 var_C           = dword ptr -0Ch
.text:00006CF8 var_4           = dword ptr -4
.text:00006CF8
.text:00006CF8                 push    ebp
.text:00006CF9                 mov     ebp, esp
.text:00006CFB                 push    0FFFFFFFFh
.text:00006CFD                 push    offset __ehhandler$??1CCensorNode@NWildcard@@QAE@XZ
.text:00006D02                 mov     eax, large fs:0
.text:00006D08                 push    eax
.text:00006D09                 push    ecx
.text:00006D0A                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00006D11                 mov     eax, dword ptr ds:___security_cookie
.text:00006D16                 xor     eax, ebp
.text:00006D18                 push    eax
.text:00006D19                 lea     eax, [ebp+var_C]
.text:00006D1C                 mov     large fs:0, eax
.text:00006D22                 mov     [ebp+var_10], ecx
.text:00006D25                 mov     [ebp+var_4], 2
.text:00006D2C                 mov     ecx, [ebp+var_10]
.text:00006D2F                 add     ecx, 28h ; '('
.text:00006D32                 call    ??1?$CObjectVector@UCItem@NWildcard@@@@QAE@XZ ; CObjectVector<NWildcard::CItem>::~CObjectVector<NWildcard::CItem>(void)
.text:00006D37                 mov     byte ptr [ebp+var_4], 1
.text:00006D3B                 mov     ecx, [ebp+var_10]
.text:00006D3E                 add     ecx, 1Ch
.text:00006D41                 call    ??1?$CObjectVector@UCItem@NWildcard@@@@QAE@XZ ; CObjectVector<NWildcard::CItem>::~CObjectVector<NWildcard::CItem>(void)
.text:00006D46                 mov     byte ptr [ebp+var_4], 0
.text:00006D4A                 mov     ecx, [ebp+var_10]
.text:00006D4D                 add     ecx, 10h
.text:00006D50                 call    ??1?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@XZ ; CObjectVector<NWildcard::CCensorNode>::~CObjectVector<NWildcard::CCensorNode>(void)
.text:00006D55                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00006D5C                 mov     ecx, [ebp+var_10]
.text:00006D5F                 add     ecx, 4          ; this
.text:00006D62                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00006D67                 mov     ecx, [ebp+var_C]
.text:00006D6A                 mov     large fs:0, ecx
.text:00006D71                 pop     ecx
.text:00006D72                 add     esp, 10h
.text:00006D75                 cmp     ebp, esp
.text:00006D77                 call    __RTC_CheckEsp
.text:00006D7C                 mov     esp, ebp
.text:00006D7E                 pop     ebp
.text:00006D7F                 retn
.text:00006D7F ??1CCensorNode@NWildcard@@QAE@XZ endp
.text:00006D7F
.text:00006D7F _text           ends
.text:00006D7F
.text$x:00006D80 ; ===========================================================================
.text$x:00006D80
.text$x:00006D80 ; Segment type: Pure code
.text$x:00006D80 ; Segment permissions: Read/Execute
.text$x:00006D80 _text$x         segment para public 'CODE' use32
.text$x:00006D80                 assume cs:_text$x
.text$x:00006D80                 ;org 6D80h
.text$x:00006D80 ; COMDAT (pick associative to section at 6CF8)
.text$x:00006D80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006D80
.text$x:00006D80 ; =============== S U B R O U T I N E =======================================
.text$x:00006D80
.text$x:00006D80
.text$x:00006D80 __unwindfunclet$??1CCensorNode@NWildcard@@QAE@XZ$0 proc near
.text$x:00006D80                                         ; DATA XREF: .xdata$x:00006DC0o
.text$x:00006D80                 mov     ecx, [ebp-10h]
.text$x:00006D83                 add     ecx, 4          ; this
.text$x:00006D86                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00006D86 __unwindfunclet$??1CCensorNode@NWildcard@@QAE@XZ$0 endp
.text$x:00006D86
.text$x:00006D8B
.text$x:00006D8B ; =============== S U B R O U T I N E =======================================
.text$x:00006D8B
.text$x:00006D8B
.text$x:00006D8B __unwindfunclet$??1CCensorNode@NWildcard@@QAE@XZ$1 proc near
.text$x:00006D8B                                         ; DATA XREF: .xdata$x:00006DC8o
.text$x:00006D8B                 mov     ecx, [ebp-10h]
.text$x:00006D8E                 add     ecx, 10h
.text$x:00006D91                 jmp     ??1?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@XZ ; CObjectVector<NWildcard::CCensorNode>::~CObjectVector<NWildcard::CCensorNode>(void)
.text$x:00006D91 __unwindfunclet$??1CCensorNode@NWildcard@@QAE@XZ$1 endp
.text$x:00006D91
.text$x:00006D96
.text$x:00006D96 ; =============== S U B R O U T I N E =======================================
.text$x:00006D96
.text$x:00006D96
.text$x:00006D96 __unwindfunclet$??1CCensorNode@NWildcard@@QAE@XZ$2 proc near
.text$x:00006D96                                         ; DATA XREF: .xdata$x:00006DD0o
.text$x:00006D96                 mov     ecx, [ebp-10h]
.text$x:00006D99                 add     ecx, 1Ch
.text$x:00006D9C                 jmp     ??1?$CObjectVector@UCItem@NWildcard@@@@QAE@XZ ; CObjectVector<NWildcard::CItem>::~CObjectVector<NWildcard::CItem>(void)
.text$x:00006D9C __unwindfunclet$??1CCensorNode@NWildcard@@QAE@XZ$2 endp
.text$x:00006D9C
.text$x:00006DA1
.text$x:00006DA1 ; =============== S U B R O U T I N E =======================================
.text$x:00006DA1
.text$x:00006DA1
.text$x:00006DA1 __ehhandler$??1CCensorNode@NWildcard@@QAE@XZ proc near
.text$x:00006DA1                                         ; DATA XREF: NWildcard::CCensorNode::~CCensorNode(void)+5o
.text$x:00006DA1
.text$x:00006DA1 arg_4           = dword ptr  8
.text$x:00006DA1
.text$x:00006DA1                 mov     edx, [esp+arg_4]
.text$x:00006DA5                 lea     eax, [edx+0Ch]
.text$x:00006DA8                 mov     ecx, [edx-8]
.text$x:00006DAB                 xor     ecx, eax
.text$x:00006DAD                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006DB2                 mov     eax, offset __ehfuncinfo$??1CCensorNode@NWildcard@@QAE@XZ
.text$x:00006DB7                 jmp     ___CxxFrameHandler3
.text$x:00006DB7 __ehhandler$??1CCensorNode@NWildcard@@QAE@XZ endp
.text$x:00006DB7
.text$x:00006DB7 _text$x         ends
.text$x:00006DB7
.xdata$x:00006DBC ; ===========================================================================
.xdata$x:00006DBC
.xdata$x:00006DBC ; Segment type: Pure data
.xdata$x:00006DBC ; Segment permissions: Read
.xdata$x:00006DBC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006DBC                 assume cs:_xdata$x
.xdata$x:00006DBC                 ;org 6DBCh
.xdata$x:00006DBC ; COMDAT (pick associative to section at 6CF8)
.xdata$x:00006DBC __unwindtable$??1CCensorNode@NWildcard@@QAE@XZ db 0FFh
.xdata$x:00006DBC                                         ; DATA XREF: .xdata$x:00006DDCo
.xdata$x:00006DBD                 db 0FFh
.xdata$x:00006DBE                 db 0FFh
.xdata$x:00006DBF                 db 0FFh
.xdata$x:00006DC0                 dd offset __unwindfunclet$??1CCensorNode@NWildcard@@QAE@XZ$0
.xdata$x:00006DC4                 align 8
.xdata$x:00006DC8                 dd offset __unwindfunclet$??1CCensorNode@NWildcard@@QAE@XZ$1
.xdata$x:00006DCC                 db    1
.xdata$x:00006DCD                 db    0
.xdata$x:00006DCE                 db    0
.xdata$x:00006DCF                 db    0
.xdata$x:00006DD0                 dd offset __unwindfunclet$??1CCensorNode@NWildcard@@QAE@XZ$2
.xdata$x:00006DD4 __ehfuncinfo$??1CCensorNode@NWildcard@@QAE@XZ db  22h ; "
.xdata$x:00006DD4                                         ; DATA XREF: __ehhandler$??1CCensorNode@NWildcard@@QAE@XZ+11o
.xdata$x:00006DD5                 db    5
.xdata$x:00006DD6                 db  93h ; Ã´
.xdata$x:00006DD7                 db  19h
.xdata$x:00006DD8                 db    3
.xdata$x:00006DD9                 db    0
.xdata$x:00006DDA                 db    0
.xdata$x:00006DDB                 db    0
.xdata$x:00006DDC                 dd offset __unwindtable$??1CCensorNode@NWildcard@@QAE@XZ
.xdata$x:00006DE0                 db    0
.xdata$x:00006DE1                 db    0
.xdata$x:00006DE2                 db    0
.xdata$x:00006DE3                 db    0
.xdata$x:00006DE4                 db    0
.xdata$x:00006DE5                 db    0
.xdata$x:00006DE6                 db    0
.xdata$x:00006DE7                 db    0
.xdata$x:00006DE8                 db    0
.xdata$x:00006DE9                 db    0
.xdata$x:00006DEA                 db    0
.xdata$x:00006DEB                 db    0
.xdata$x:00006DEC                 db    0
.xdata$x:00006DED                 db    0
.xdata$x:00006DEE                 db    0
.xdata$x:00006DEF                 db    0
.xdata$x:00006DF0                 db    0
.xdata$x:00006DF1                 db    0
.xdata$x:00006DF2                 db    0
.xdata$x:00006DF3                 db    0
.xdata$x:00006DF4                 db    1
.xdata$x:00006DF5                 db    0
.xdata$x:00006DF6                 db    0
.xdata$x:00006DF7                 db    0
.xdata$x:00006DF7 _xdata$x        ends
.xdata$x:00006DF7
.text:00006DF8 ; ===========================================================================
.text:00006DF8
.text:00006DF8 ; Segment type: Pure code
.text:00006DF8 ; Segment permissions: Read/Execute
.text:00006DF8 _text           segment para public 'CODE' use32
.text:00006DF8                 assume cs:_text
.text:00006DF8                 ;org 6DF8h
.text:00006DF8 ; COMDAT (pick any)
.text:00006DF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00006DF8
.text:00006DF8 ; =============== S U B R O U T I N E =======================================
.text:00006DF8
.text:00006DF8 ; Attributes: bp-based frame
.text:00006DF8
.text:00006DF8 ; public: __thiscall CObjectVector<class NWildcard::CCensorNode>::~CObjectVector<class NWildcard::CCensorNode>(void)
.text:00006DF8                 public ??1?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@XZ
.text:00006DF8 ??1?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@XZ proc near
.text:00006DF8                                         ; CODE XREF: NWildcard::CCensorNode::~CCensorNode(void)+58p
.text:00006DF8                                         ; __unwindfunclet$??1CCensorNode@NWildcard@@QAE@XZ$1+6j
.text:00006DF8
.text:00006DF8 var_20          = dword ptr -20h
.text:00006DF8 var_1C          = dword ptr -1Ch
.text:00006DF8 var_18          = dword ptr -18h
.text:00006DF8 var_14          = dword ptr -14h
.text:00006DF8 var_10          = dword ptr -10h
.text:00006DF8 var_C           = dword ptr -0Ch
.text:00006DF8 var_4           = dword ptr -4
.text:00006DF8
.text:00006DF8                 push    ebp
.text:00006DF9                 mov     ebp, esp
.text:00006DFB                 push    0FFFFFFFFh
.text:00006DFD                 push    offset __ehhandler$??1?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@XZ
.text:00006E02                 mov     eax, large fs:0
.text:00006E08                 push    eax
.text:00006E09                 sub     esp, 14h
.text:00006E0C                 mov     eax, 0CCCCCCCCh
.text:00006E11                 mov     [ebp+var_20], eax
.text:00006E14                 mov     [ebp+var_1C], eax
.text:00006E17                 mov     [ebp+var_18], eax
.text:00006E1A                 mov     [ebp+var_14], eax
.text:00006E1D                 mov     [ebp+var_10], eax
.text:00006E20                 mov     eax, dword ptr ds:___security_cookie
.text:00006E25                 xor     eax, ebp
.text:00006E27                 push    eax
.text:00006E28                 lea     eax, [ebp+var_C]
.text:00006E2B                 mov     large fs:0, eax
.text:00006E31                 mov     [ebp+var_10], ecx
.text:00006E34                 mov     [ebp+var_4], 0
.text:00006E3B                 mov     ecx, [ebp+var_10]
.text:00006E3E                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00006E43                 mov     [ebp+var_14], eax
.text:00006E46
.text:00006E46 loc_6E46:                               ; CODE XREF: CObjectVector<NWildcard::CCensorNode>::~CObjectVector<NWildcard::CCensorNode>(void):loc_6E88j
.text:00006E46                 cmp     [ebp+var_14], 0
.text:00006E4A                 jz      short loc_6E8A
.text:00006E4C                 mov     eax, [ebp+var_14]
.text:00006E4F                 sub     eax, 1
.text:00006E52                 mov     [ebp+var_14], eax
.text:00006E55                 mov     ecx, [ebp+var_14]
.text:00006E58                 push    ecx
.text:00006E59                 mov     ecx, [ebp+var_10]
.text:00006E5C                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00006E61
.text:00006E61 loc_6E61:                               ; DATA XREF: .rdata:$SG76914o
.text:00006E61                 mov     edx, [eax]
.text:00006E63                 mov     [ebp+var_1C], edx
.text:00006E66                 mov     eax, [ebp+var_1C]
.text:00006E69                 mov     [ebp+var_18], eax
.text:00006E6C                 cmp     [ebp+var_18], 0
.text:00006E70                 jz      short loc_6E81
.text:00006E72                 push    1
.text:00006E74                 mov     ecx, [ebp+var_18]
.text:00006E77                 call    ??_GCCensorNode@NWildcard@@QAEPAXI@Z ; NWildcard::CCensorNode::`scalar deleting destructor'(uint)
.text:00006E7C                 mov     [ebp+var_20], eax
.text:00006E7F                 jmp     short loc_6E88
.text:00006E81 ; ---------------------------------------------------------------------------
.text:00006E81
.text:00006E81 loc_6E81:                               ; CODE XREF: CObjectVector<NWildcard::CCensorNode>::~CObjectVector<NWildcard::CCensorNode>(void)+78j
.text:00006E81                 mov     [ebp+var_20], 0
.text:00006E88
.text:00006E88 loc_6E88:                               ; CODE XREF: CObjectVector<NWildcard::CCensorNode>::~CObjectVector<NWildcard::CCensorNode>(void)+87j
.text:00006E88                 jmp     short loc_6E46
.text:00006E8A ; ---------------------------------------------------------------------------
.text:00006E8A
.text:00006E8A loc_6E8A:                               ; CODE XREF: CObjectVector<NWildcard::CCensorNode>::~CObjectVector<NWildcard::CCensorNode>(void)+52j
.text:00006E8A                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00006E91                 mov     ecx, [ebp+var_10]
.text:00006E94                 call    ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text:00006E99                 mov     ecx, [ebp+var_C]
.text:00006E9C                 mov     large fs:0, ecx
.text:00006EA3                 pop     ecx
.text:00006EA4                 add     esp, 20h
.text:00006EA7                 cmp     ebp, esp
.text:00006EA9                 call    __RTC_CheckEsp
.text:00006EAE                 mov     esp, ebp
.text:00006EB0                 pop     ebp
.text:00006EB1                 retn
.text:00006EB1 ??1?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@XZ endp
.text:00006EB1
.text:00006EB1 ; ---------------------------------------------------------------------------
.text:00006EB2                 align 4
.text:00006EB2 _text           ends
.text:00006EB2
.text$x:00006EB4 ; ===========================================================================
.text$x:00006EB4
.text$x:00006EB4 ; Segment type: Pure code
.text$x:00006EB4 ; Segment permissions: Read/Execute
.text$x:00006EB4 _text$x         segment para public 'CODE' use32
.text$x:00006EB4                 assume cs:_text$x
.text$x:00006EB4                 ;org 6EB4h
.text$x:00006EB4 ; COMDAT (pick associative to section at 6DF8)
.text$x:00006EB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006EB4
.text$x:00006EB4 ; =============== S U B R O U T I N E =======================================
.text$x:00006EB4
.text$x:00006EB4
.text$x:00006EB4 __unwindfunclet$??1?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@XZ$0 proc near
.text$x:00006EB4                                         ; DATA XREF: .xdata$x:00006EDCo
.text$x:00006EB4                 mov     ecx, [ebp-10h]
.text$x:00006EB7                 jmp     ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text$x:00006EB7 __unwindfunclet$??1?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@XZ$0 endp
.text$x:00006EB7
.text$x:00006EBC
.text$x:00006EBC ; =============== S U B R O U T I N E =======================================
.text$x:00006EBC
.text$x:00006EBC
.text$x:00006EBC __ehhandler$??1?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@XZ proc near
.text$x:00006EBC                                         ; DATA XREF: CObjectVector<NWildcard::CCensorNode>::~CObjectVector<NWildcard::CCensorNode>(void)+5o
.text$x:00006EBC
.text$x:00006EBC arg_4           = dword ptr  8
.text$x:00006EBC
.text$x:00006EBC                 mov     edx, [esp+arg_4]
.text$x:00006EC0                 lea     eax, [edx+0Ch]
.text$x:00006EC3                 mov     ecx, [edx-18h]
.text$x:00006EC6                 xor     ecx, eax
.text$x:00006EC8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006ECD                 mov     eax, offset __ehfuncinfo$??1?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@XZ
.text$x:00006ED2                 jmp     ___CxxFrameHandler3
.text$x:00006ED2 __ehhandler$??1?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@XZ endp
.text$x:00006ED2
.text$x:00006ED2 ; ---------------------------------------------------------------------------
.text$x:00006ED7                 align 4
.text$x:00006ED7 _text$x         ends
.text$x:00006ED7
.xdata$x:00006ED8 ; ===========================================================================
.xdata$x:00006ED8
.xdata$x:00006ED8 ; Segment type: Pure data
.xdata$x:00006ED8 ; Segment permissions: Read
.xdata$x:00006ED8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006ED8                 assume cs:_xdata$x
.xdata$x:00006ED8                 ;org 6ED8h
.xdata$x:00006ED8 ; COMDAT (pick associative to section at 6DF8)
.xdata$x:00006ED8 __unwindtable$??1?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@XZ db 0FFh
.xdata$x:00006ED8                                         ; DATA XREF: .xdata$x:00006EE8o
.xdata$x:00006ED9                 db 0FFh
.xdata$x:00006EDA                 db 0FFh
.xdata$x:00006EDB                 db 0FFh
.xdata$x:00006EDC                 dd offset __unwindfunclet$??1?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@XZ$0
.xdata$x:00006EE0 __ehfuncinfo$??1?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@XZ db  22h ; "
.xdata$x:00006EE0                                         ; DATA XREF: __ehhandler$??1?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@XZ+11o
.xdata$x:00006EE1                 db    5
.xdata$x:00006EE2                 db  93h ; Ã´
.xdata$x:00006EE3                 db  19h
.xdata$x:00006EE4                 db    1
.xdata$x:00006EE5                 db    0
.xdata$x:00006EE6                 db    0
.xdata$x:00006EE7                 db    0
.xdata$x:00006EE8                 dd offset __unwindtable$??1?$CObjectVector@VCCensorNode@NWildcard@@@@QAE@XZ
.xdata$x:00006EEC                 align 20h
.xdata$x:00006F00                 db    1
.xdata$x:00006F01                 db    0
.xdata$x:00006F02                 db    0
.xdata$x:00006F03                 db    0
.xdata$x:00006F03 _xdata$x        ends
.xdata$x:00006F03
.text:00006F04 ; ===========================================================================
.text:00006F04
.text:00006F04 ; Segment type: Pure code
.text:00006F04 ; Segment permissions: Read/Execute
.text:00006F04 _text           segment para public 'CODE' use32
.text:00006F04                 assume cs:_text
.text:00006F04                 ;org 6F04h
.text:00006F04 ; COMDAT (pick any)
.text:00006F04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00006F04
.text:00006F04 ; =============== S U B R O U T I N E =======================================
.text:00006F04
.text:00006F04 ; Attributes: bp-based frame
.text:00006F04
.text:00006F04 ; public: __thiscall CObjectVector<struct NWildcard::CItem>::~CObjectVector<struct NWildcard::CItem>(void)
.text:00006F04                 public ??1?$CObjectVector@UCItem@NWildcard@@@@QAE@XZ
.text:00006F04 ??1?$CObjectVector@UCItem@NWildcard@@@@QAE@XZ proc near
.text:00006F04                                         ; CODE XREF: NWildcard::CCensorNode::~CCensorNode(void)+3Ap
.text:00006F04                                         ; NWildcard::CCensorNode::~CCensorNode(void)+49p ...
.text:00006F04
.text:00006F04 var_20          = dword ptr -20h
.text:00006F04 var_1C          = dword ptr -1Ch
.text:00006F04 var_18          = dword ptr -18h
.text:00006F04 var_14          = dword ptr -14h
.text:00006F04 var_10          = dword ptr -10h
.text:00006F04 var_C           = dword ptr -0Ch
.text:00006F04 var_4           = dword ptr -4
.text:00006F04
.text:00006F04                 push    ebp
.text:00006F05                 mov     ebp, esp
.text:00006F07                 push    0FFFFFFFFh
.text:00006F09                 push    offset __ehhandler$??1?$CObjectVector@UCItem@NWildcard@@@@QAE@XZ
.text:00006F0E                 mov     eax, large fs:0
.text:00006F14                 push    eax
.text:00006F15                 sub     esp, 14h
.text:00006F18                 mov     eax, 0CCCCCCCCh
.text:00006F1D                 mov     [ebp+var_20], eax
.text:00006F20                 mov     [ebp+var_1C], eax
.text:00006F23                 mov     [ebp+var_18], eax
.text:00006F26                 mov     [ebp+var_14], eax
.text:00006F29                 mov     [ebp+var_10], eax
.text:00006F2C                 mov     eax, dword ptr ds:___security_cookie
.text:00006F31                 xor     eax, ebp
.text:00006F33                 push    eax
.text:00006F34                 lea     eax, [ebp+var_C]
.text:00006F37                 mov     large fs:0, eax
.text:00006F3D                 mov     [ebp+var_10], ecx
.text:00006F40                 mov     [ebp+var_4], 0
.text:00006F47                 mov     ecx, [ebp+var_10]
.text:00006F4A                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00006F4F                 mov     [ebp+var_14], eax
.text:00006F52
.text:00006F52 loc_6F52:                               ; CODE XREF: CObjectVector<NWildcard::CItem>::~CObjectVector<NWildcard::CItem>(void):loc_6F94j
.text:00006F52                 cmp     [ebp+var_14], 0
.text:00006F56                 jz      short loc_6F96
.text:00006F58                 mov     eax, [ebp+var_14]
.text:00006F5B                 sub     eax, 1
.text:00006F5E                 mov     [ebp+var_14], eax
.text:00006F61
.text:00006F61 loc_6F61:                               ; DATA XREF: .rdata:$SG76904o
.text:00006F61                 mov     ecx, [ebp+var_14]
.text:00006F64                 push    ecx
.text:00006F65                 mov     ecx, [ebp+var_10]
.text:00006F68                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00006F6D                 mov     edx, [eax]
.text:00006F6F                 mov     [ebp+var_1C], edx
.text:00006F72
.text:00006F72 loc_6F72:                               ; DATA XREF: .rdata:$SG76923o
.text:00006F72                 mov     eax, [ebp+var_1C]
.text:00006F75                 mov     [ebp+var_18], eax
.text:00006F78                 cmp     [ebp+var_18], 0
.text:00006F7C                 jz      short loc_6F8D
.text:00006F7E                 push    1
.text:00006F80                 mov     ecx, [ebp+var_18]
.text:00006F83                 call    ??_GCItem@NWildcard@@QAEPAXI@Z ; NWildcard::CItem::`scalar deleting destructor'(uint)
.text:00006F88                 mov     [ebp+var_20], eax
.text:00006F8B                 jmp     short loc_6F94
.text:00006F8D ; ---------------------------------------------------------------------------
.text:00006F8D
.text:00006F8D loc_6F8D:                               ; CODE XREF: CObjectVector<NWildcard::CItem>::~CObjectVector<NWildcard::CItem>(void)+78j
.text:00006F8D                 mov     [ebp+var_20], 0
.text:00006F94
.text:00006F94 loc_6F94:                               ; CODE XREF: CObjectVector<NWildcard::CItem>::~CObjectVector<NWildcard::CItem>(void)+87j
.text:00006F94                 jmp     short loc_6F52
.text:00006F96 ; ---------------------------------------------------------------------------
.text:00006F96
.text:00006F96 loc_6F96:                               ; CODE XREF: CObjectVector<NWildcard::CItem>::~CObjectVector<NWildcard::CItem>(void)+52j
.text:00006F96                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00006F9D                 mov     ecx, [ebp+var_10]
.text:00006FA0                 call    ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text:00006FA5                 mov     ecx, [ebp+var_C]
.text:00006FA8                 mov     large fs:0, ecx
.text:00006FAF                 pop     ecx
.text:00006FB0                 add     esp, 20h
.text:00006FB3                 cmp     ebp, esp
.text:00006FB5                 call    __RTC_CheckEsp
.text:00006FBA                 mov     esp, ebp
.text:00006FBC                 pop     ebp
.text:00006FBD                 retn
.text:00006FBD ??1?$CObjectVector@UCItem@NWildcard@@@@QAE@XZ endp
.text:00006FBD
.text:00006FBD ; ---------------------------------------------------------------------------
.text:00006FBE                 align 10h
.text:00006FBE _text           ends
.text:00006FBE
.text$x:00006FC0 ; ===========================================================================
.text$x:00006FC0
.text$x:00006FC0 ; Segment type: Pure code
.text$x:00006FC0 ; Segment permissions: Read/Execute
.text$x:00006FC0 _text$x         segment para public 'CODE' use32
.text$x:00006FC0                 assume cs:_text$x
.text$x:00006FC0                 ;org 6FC0h
.text$x:00006FC0 ; COMDAT (pick associative to section at 6F04)
.text$x:00006FC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006FC0
.text$x:00006FC0 ; =============== S U B R O U T I N E =======================================
.text$x:00006FC0
.text$x:00006FC0
.text$x:00006FC0 __unwindfunclet$??1?$CObjectVector@UCItem@NWildcard@@@@QAE@XZ$0 proc near
.text$x:00006FC0                                         ; DATA XREF: .xdata$x:00006FE8o
.text$x:00006FC0                 mov     ecx, [ebp-10h]
.text$x:00006FC3                 jmp     ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text$x:00006FC3 __unwindfunclet$??1?$CObjectVector@UCItem@NWildcard@@@@QAE@XZ$0 endp
.text$x:00006FC3
.text$x:00006FC8
.text$x:00006FC8 ; =============== S U B R O U T I N E =======================================
.text$x:00006FC8
.text$x:00006FC8
.text$x:00006FC8 __ehhandler$??1?$CObjectVector@UCItem@NWildcard@@@@QAE@XZ proc near
.text$x:00006FC8                                         ; DATA XREF: CObjectVector<NWildcard::CItem>::~CObjectVector<NWildcard::CItem>(void)+5o
.text$x:00006FC8
.text$x:00006FC8 arg_4           = dword ptr  8
.text$x:00006FC8
.text$x:00006FC8                 mov     edx, [esp+arg_4]
.text$x:00006FCC                 lea     eax, [edx+0Ch]
.text$x:00006FCF                 mov     ecx, [edx-18h]
.text$x:00006FD2                 xor     ecx, eax
.text$x:00006FD4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006FD9                 mov     eax, offset __ehfuncinfo$??1?$CObjectVector@UCItem@NWildcard@@@@QAE@XZ
.text$x:00006FDE                 jmp     ___CxxFrameHandler3
.text$x:00006FDE __ehhandler$??1?$CObjectVector@UCItem@NWildcard@@@@QAE@XZ endp
.text$x:00006FDE
.text$x:00006FDE ; ---------------------------------------------------------------------------
.text$x:00006FE3                 align 4
.text$x:00006FE3 _text$x         ends
.text$x:00006FE3
.xdata$x:00006FE4 ; ===========================================================================
.xdata$x:00006FE4
.xdata$x:00006FE4 ; Segment type: Pure data
.xdata$x:00006FE4 ; Segment permissions: Read
.xdata$x:00006FE4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006FE4                 assume cs:_xdata$x
.xdata$x:00006FE4                 ;org 6FE4h
.xdata$x:00006FE4 ; COMDAT (pick associative to section at 6F04)
.xdata$x:00006FE4 __unwindtable$??1?$CObjectVector@UCItem@NWildcard@@@@QAE@XZ db 0FFh
.xdata$x:00006FE4                                         ; DATA XREF: .xdata$x:00006FF4o
.xdata$x:00006FE5                 db 0FFh
.xdata$x:00006FE6                 db 0FFh
.xdata$x:00006FE7                 db 0FFh
.xdata$x:00006FE8                 dd offset __unwindfunclet$??1?$CObjectVector@UCItem@NWildcard@@@@QAE@XZ$0
.xdata$x:00006FEC __ehfuncinfo$??1?$CObjectVector@UCItem@NWildcard@@@@QAE@XZ db  22h ; "
.xdata$x:00006FEC                                         ; DATA XREF: __ehhandler$??1?$CObjectVector@UCItem@NWildcard@@@@QAE@XZ+11o
.xdata$x:00006FED                 db    5
.xdata$x:00006FEE                 db  93h ; Ã´
.xdata$x:00006FEF                 db  19h
.xdata$x:00006FF0                 db    1
.xdata$x:00006FF1                 db    0
.xdata$x:00006FF2                 db    0
.xdata$x:00006FF3                 db    0
.xdata$x:00006FF4                 dd offset __unwindtable$??1?$CObjectVector@UCItem@NWildcard@@@@QAE@XZ
.xdata$x:00006FF8                 db    0
.xdata$x:00006FF9                 db    0
.xdata$x:00006FFA                 db    0
.xdata$x:00006FFB                 db    0
.xdata$x:00006FFC                 db    0
.xdata$x:00006FFD                 db    0
.xdata$x:00006FFE                 db    0
.xdata$x:00006FFF                 db    0
.xdata$x:00007000                 db    0
.xdata$x:00007001                 db    0
.xdata$x:00007002                 db    0
.xdata$x:00007003                 db    0
.xdata$x:00007004                 db    0
.xdata$x:00007005                 db    0
.xdata$x:00007006                 db    0
.xdata$x:00007007                 db    0
.xdata$x:00007008                 db    0
.xdata$x:00007009                 db    0
.xdata$x:0000700A                 db    0
.xdata$x:0000700B                 db    0
.xdata$x:0000700C                 db    1
.xdata$x:0000700D                 db    0
.xdata$x:0000700E                 db    0
.xdata$x:0000700F                 db    0
.xdata$x:0000700F _xdata$x        ends
.xdata$x:0000700F
.text:00007010 ; ===========================================================================
.text:00007010
.text:00007010 ; Segment type: Pure code
.text:00007010 ; Segment permissions: Read/Execute
.text:00007010 _text           segment para public 'CODE' use32
.text:00007010                 assume cs:_text
.text:00007010                 ;org 7010h
.text:00007010 ; COMDAT (pick any)
.text:00007010                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007010
.text:00007010 ; =============== S U B R O U T I N E =======================================
.text:00007010
.text:00007010 ; Attributes: bp-based frame
.text:00007010
.text:00007010 ; _DWORD __thiscall NWildcard::CItem::CItem(NWildcard::CItem *this, const struct NWildcard::CItem *)
.text:00007010                 public ??0CItem@NWildcard@@QAE@ABU01@@Z
.text:00007010 ??0CItem@NWildcard@@QAE@ABU01@@Z proc near
.text:00007010                                         ; CODE XREF: CObjectVector<NWildcard::CItem>::operator+=(CObjectVector<NWildcard::CItem> const &)+A2p
.text:00007010
.text:00007010 var_4           = dword ptr -4
.text:00007010 arg_0           = dword ptr  8
.text:00007010
.text:00007010                 push    ebp
.text:00007011                 mov     ebp, esp
.text:00007013                 push    ecx
.text:00007014                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000701B                 mov     [ebp+var_4], ecx
.text:0000701E                 mov     eax, [ebp+arg_0]
.text:00007021                 push    eax
.text:00007022                 mov     ecx, [ebp+var_4]
.text:00007025                 call    ??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z ; CObjectVector<UString>::CObjectVector<UString>(CObjectVector<UString> const &)
.text:0000702A                 mov     ecx, [ebp+var_4]
.text:0000702D                 mov     edx, [ebp+arg_0]
.text:00007030                 mov     al, [edx+0Ch]
.text:00007033                 mov     [ecx+0Ch], al
.text:00007036                 mov     ecx, [ebp+var_4]
.text:00007039                 mov     edx, [ebp+arg_0]
.text:0000703C                 mov     al, [edx+0Dh]
.text:0000703F                 mov     [ecx+0Dh], al
.text:00007042                 mov     ecx, [ebp+var_4]
.text:00007045                 mov     edx, [ebp+arg_0]
.text:00007048                 mov     al, [edx+0Eh]
.text:0000704B                 mov     [ecx+0Eh], al
.text:0000704E                 mov     ecx, [ebp+var_4]
.text:00007051                 mov     edx, [ebp+arg_0]
.text:00007054                 mov     al, [edx+0Fh]
.text:00007057                 mov     [ecx+0Fh], al
.text:0000705A                 mov     eax, [ebp+var_4]
.text:0000705D                 add     esp, 4
.text:00007060                 cmp     ebp, esp
.text:00007062                 call    __RTC_CheckEsp
.text:00007067                 mov     esp, ebp
.text:00007069                 pop     ebp
.text:0000706A                 retn    4
.text:0000706A ??0CItem@NWildcard@@QAE@ABU01@@Z endp
.text:0000706A
.text:0000706A ; ---------------------------------------------------------------------------
.text:0000706D                 align 10h
.text:0000706D _text           ends
.text:0000706D
.text:00007070 ; ===========================================================================
.text:00007070
.text:00007070 ; Segment type: Pure code
.text:00007070 ; Segment permissions: Read/Execute
.text:00007070 _text           segment para public 'CODE' use32
.text:00007070                 assume cs:_text
.text:00007070                 ;org 7070h
.text:00007070 ; COMDAT (pick any)
.text:00007070                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007070
.text:00007070 ; =============== S U B R O U T I N E =======================================
.text:00007070
.text:00007070 ; Attributes: bp-based frame
.text:00007070
.text:00007070 ; public: void * __thiscall NWildcard::CItem::`scalar deleting destructor'(unsigned int)
.text:00007070                 public ??_GCItem@NWildcard@@QAEPAXI@Z
.text:00007070 ??_GCItem@NWildcard@@QAEPAXI@Z proc near
.text:00007070                                         ; CODE XREF: CObjectVector<NWildcard::CItem>::~CObjectVector<NWildcard::CItem>(void)+7Fp
.text:00007070
.text:00007070 var_4           = dword ptr -4
.text:00007070 arg_0           = dword ptr  8
.text:00007070
.text:00007070                 push    ebp
.text:00007071                 mov     ebp, esp
.text:00007073                 push    ecx
.text:00007074                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000707B                 mov     [ebp+var_4], ecx
.text:0000707E                 mov     ecx, [ebp+var_4] ; this
.text:00007081                 call    ??1CItem@NWildcard@@QAE@XZ ; NWildcard::CItem::~CItem(void)
.text:00007086                 mov     eax, [ebp+arg_0]
.text:00007089                 and     eax, 1
.text:0000708C                 jz      short loc_709A
.text:0000708E                 mov     ecx, [ebp+var_4]
.text:00007091                 push    ecx             ; void *
.text:00007092                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00007097                 add     esp, 4
.text:0000709A
.text:0000709A loc_709A:                               ; CODE XREF: NWildcard::CItem::`scalar deleting destructor'(uint)+1Cj
.text:0000709A                 mov     eax, [ebp+var_4]
.text:0000709D                 add     esp, 4
.text:000070A0                 cmp     ebp, esp
.text:000070A2                 call    __RTC_CheckEsp
.text:000070A7                 mov     esp, ebp
.text:000070A9                 pop     ebp
.text:000070AA                 retn    4
.text:000070AA ??_GCItem@NWildcard@@QAEPAXI@Z endp
.text:000070AA
.text:000070AA ; ---------------------------------------------------------------------------
.text:000070AD                 align 10h
.text:000070AD _text           ends
.text:000070AD
.text:000070B0 ; ===========================================================================
.text:000070B0
.text:000070B0 ; Segment type: Pure code
.text:000070B0 ; Segment permissions: Read/Execute
.text:000070B0 _text           segment para public 'CODE' use32
.text:000070B0                 assume cs:_text
.text:000070B0                 ;org 70B0h
.text:000070B0 ; COMDAT (pick any)
.text:000070B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000070B0
.text:000070B0 ; =============== S U B R O U T I N E =======================================
.text:000070B0
.text:000070B0 ; Attributes: bp-based frame
.text:000070B0
.text:000070B0 ; public: void * __thiscall CBuffer<unsigned char>::`scalar deleting destructor'(unsigned int)
.text:000070B0                 public ??_G?$CBuffer@E@@QAEPAXI@Z
.text:000070B0 ??_G?$CBuffer@E@@QAEPAXI@Z proc near    ; CODE XREF: CObjectVector<CBuffer<uchar>>::~CObjectVector<CBuffer<uchar>>(void)+7Fp
.text:000070B0
.text:000070B0 var_4           = dword ptr -4
.text:000070B0 arg_0           = dword ptr  8
.text:000070B0
.text:000070B0                 push    ebp
.text:000070B1                 mov     ebp, esp
.text:000070B3                 push    ecx
.text:000070B4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000070BB                 mov     [ebp+var_4], ecx
.text:000070BE                 mov     ecx, [ebp+var_4]
.text:000070C1                 call    ??1?$CBuffer@E@@QAE@XZ ; CBuffer<uchar>::~CBuffer<uchar>(void)
.text:000070C6                 mov     eax, [ebp+arg_0]
.text:000070C9                 and     eax, 1
.text:000070CC                 jz      short loc_70DA
.text:000070CE                 mov     ecx, [ebp+var_4]
.text:000070D1                 push    ecx             ; void *
.text:000070D2                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:000070D7                 add     esp, 4
.text:000070DA
.text:000070DA loc_70DA:                               ; CODE XREF: CBuffer<uchar>::`scalar deleting destructor'(uint)+1Cj
.text:000070DA                 mov     eax, [ebp+var_4]
.text:000070DD                 add     esp, 4
.text:000070E0                 cmp     ebp, esp
.text:000070E2                 call    __RTC_CheckEsp
.text:000070E7                 mov     esp, ebp
.text:000070E9                 pop     ebp
.text:000070EA                 retn    4
.text:000070EA ??_G?$CBuffer@E@@QAEPAXI@Z endp
.text:000070EA
.text:000070EA ; ---------------------------------------------------------------------------
.text:000070ED                 align 10h
.text:000070ED _text           ends
.text:000070ED
.text:000070F0 ; ===========================================================================
.text:000070F0
.text:000070F0 ; Segment type: Pure code
.text:000070F0 ; Segment permissions: Read/Execute
.text:000070F0 _text           segment para public 'CODE' use32
.text:000070F0                 assume cs:_text
.text:000070F0                 ;org 70F0h
.text:000070F0 ; COMDAT (pick any)
.text:000070F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000070F0
.text:000070F0 ; =============== S U B R O U T I N E =======================================
.text:000070F0
.text:000070F0 ; Attributes: bp-based frame
.text:000070F0
.text:000070F0 ; public: void * __thiscall CDirItem::`scalar deleting destructor'(unsigned int)
.text:000070F0                 public ??_GCDirItem@@QAEPAXI@Z
.text:000070F0 ??_GCDirItem@@QAEPAXI@Z proc near       ; CODE XREF: CObjectVector<CDirItem>::~CObjectVector<CDirItem>(void)+7Fp
.text:000070F0
.text:000070F0 var_4           = dword ptr -4
.text:000070F0 arg_0           = dword ptr  8
.text:000070F0
.text:000070F0                 push    ebp
.text:000070F1                 mov     ebp, esp
.text:000070F3                 push    ecx
.text:000070F4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000070FB                 mov     [ebp+var_4], ecx
.text:000070FE                 mov     ecx, [ebp+var_4] ; this
.text:00007101                 call    ??1CDirItem@@QAE@XZ ; CDirItem::~CDirItem(void)
.text:00007106                 mov     eax, [ebp+arg_0]
.text:00007109                 and     eax, 1
.text:0000710C                 jz      short loc_711A
.text:0000710E                 mov     ecx, [ebp+var_4]
.text:00007111                 push    ecx             ; void *
.text:00007112                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00007117                 add     esp, 4
.text:0000711A
.text:0000711A loc_711A:                               ; CODE XREF: CDirItem::`scalar deleting destructor'(uint)+1Cj
.text:0000711A                 mov     eax, [ebp+var_4]
.text:0000711D                 add     esp, 4
.text:00007120                 cmp     ebp, esp
.text:00007122                 call    __RTC_CheckEsp
.text:00007127                 mov     esp, ebp
.text:00007129                 pop     ebp
.text:0000712A                 retn    4
.text:0000712A ??_GCDirItem@@QAEPAXI@Z endp
.text:0000712A
.text:0000712A ; ---------------------------------------------------------------------------
.text:0000712D                 align 10h
.text:0000712D _text           ends
.text:0000712D
.text:00007130 ; ===========================================================================
.text:00007130
.text:00007130 ; Segment type: Pure code
.text:00007130 ; Segment permissions: Read/Execute
.text:00007130 _text           segment para public 'CODE' use32
.text:00007130                 assume cs:_text
.text:00007130                 ;org 7130h
.text:00007130 ; COMDAT (pick any)
.text:00007130                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007130
.text:00007130 ; =============== S U B R O U T I N E =======================================
.text:00007130
.text:00007130 ; Attributes: bp-based frame
.text:00007130
.text:00007130 ; public: __thiscall CProperty::CProperty(struct CProperty const &)
.text:00007130                 public ??0CProperty@@QAE@ABU0@@Z
.text:00007130 ??0CProperty@@QAE@ABU0@@Z proc near     ; CODE XREF: CObjectVector<CProperty>::operator=(CObjectVector<CProperty> const &)+B2p
.text:00007130                                         ; CObjectVector<CProperty>::Add(CProperty const &)+5Ap
.text:00007130
.text:00007130 var_10          = dword ptr -10h
.text:00007130 var_C           = dword ptr -0Ch
.text:00007130 var_4           = dword ptr -4
.text:00007130 arg_0           = dword ptr  8
.text:00007130
.text:00007130                 push    ebp
.text:00007131                 mov     ebp, esp
.text:00007133                 push    0FFFFFFFFh
.text:00007135                 push    offset __ehhandler$??0CProperty@@QAE@ABU0@@Z
.text:0000713A                 mov     eax, large fs:0
.text:00007140                 push    eax
.text:00007141                 push    ecx
.text:00007142                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00007149                 mov     eax, dword ptr ds:___security_cookie
.text:0000714E                 xor     eax, ebp
.text:00007150                 push    eax
.text:00007151                 lea     eax, [ebp+var_C]
.text:00007154                 mov     large fs:0, eax
.text:0000715A                 mov     [ebp+var_10], ecx
.text:0000715D                 mov     eax, [ebp+arg_0]
.text:00007160                 push    eax
.text:00007161                 mov     ecx, [ebp+var_10]
.text:00007164                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00007169                 mov     [ebp+var_4], 0
.text:00007170                 mov     ecx, [ebp+arg_0]
.text:00007173                 add     ecx, 0Ch
.text:00007176                 push    ecx
.text:00007177                 mov     ecx, [ebp+var_10]
.text:0000717A                 add     ecx, 0Ch
.text:0000717D                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00007182                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00007189                 mov     eax, [ebp+var_10]
.text:0000718C                 mov     ecx, [ebp+var_C]
.text:0000718F                 mov     large fs:0, ecx
.text:00007196                 pop     ecx
.text:00007197                 add     esp, 10h
.text:0000719A                 cmp     ebp, esp
.text:0000719C                 call    __RTC_CheckEsp
.text:000071A1                 mov     esp, ebp
.text:000071A3                 pop     ebp
.text:000071A4                 retn    4
.text:000071A4 ??0CProperty@@QAE@ABU0@@Z endp
.text:000071A4
.text:000071A4 ; ---------------------------------------------------------------------------
.text:000071A7                 align 4
.text:000071A7 _text           ends
.text:000071A7
.text$x:000071A8 ; ===========================================================================
.text$x:000071A8
.text$x:000071A8 ; Segment type: Pure code
.text$x:000071A8 ; Segment permissions: Read/Execute
.text$x:000071A8 _text$x         segment para public 'CODE' use32
.text$x:000071A8                 assume cs:_text$x
.text$x:000071A8                 ;org 71A8h
.text$x:000071A8 ; COMDAT (pick associative to section at 7130)
.text$x:000071A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000071A8
.text$x:000071A8 ; =============== S U B R O U T I N E =======================================
.text$x:000071A8
.text$x:000071A8
.text$x:000071A8 __unwindfunclet$??0CProperty@@QAE@ABU0@@Z$0 proc near
.text$x:000071A8                                         ; DATA XREF: .xdata$x:000071D0o
.text$x:000071A8                 mov     ecx, [ebp-10h]  ; this
.text$x:000071AB                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000071AB __unwindfunclet$??0CProperty@@QAE@ABU0@@Z$0 endp
.text$x:000071AB
.text$x:000071B0
.text$x:000071B0 ; =============== S U B R O U T I N E =======================================
.text$x:000071B0
.text$x:000071B0
.text$x:000071B0 __ehhandler$??0CProperty@@QAE@ABU0@@Z proc near
.text$x:000071B0                                         ; DATA XREF: CProperty::CProperty(CProperty const &)+5o
.text$x:000071B0
.text$x:000071B0 arg_4           = dword ptr  8
.text$x:000071B0
.text$x:000071B0                 mov     edx, [esp+arg_4]
.text$x:000071B4                 lea     eax, [edx+0Ch]
.text$x:000071B7                 mov     ecx, [edx-8]
.text$x:000071BA                 xor     ecx, eax
.text$x:000071BC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000071C1                 mov     eax, offset __ehfuncinfo$??0CProperty@@QAE@ABU0@@Z
.text$x:000071C6                 jmp     ___CxxFrameHandler3
.text$x:000071C6 __ehhandler$??0CProperty@@QAE@ABU0@@Z endp
.text$x:000071C6
.text$x:000071C6 ; ---------------------------------------------------------------------------
.text$x:000071CB                 align 4
.text$x:000071CB _text$x         ends
.text$x:000071CB
.xdata$x:000071CC ; ===========================================================================
.xdata$x:000071CC
.xdata$x:000071CC ; Segment type: Pure data
.xdata$x:000071CC ; Segment permissions: Read
.xdata$x:000071CC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000071CC                 assume cs:_xdata$x
.xdata$x:000071CC                 ;org 71CCh
.xdata$x:000071CC ; COMDAT (pick associative to section at 7130)
.xdata$x:000071CC __unwindtable$??0CProperty@@QAE@ABU0@@Z db 0FFh
.xdata$x:000071CC                                         ; DATA XREF: .xdata$x:000071DCo
.xdata$x:000071CD                 db 0FFh
.xdata$x:000071CE                 db 0FFh
.xdata$x:000071CF                 db 0FFh
.xdata$x:000071D0                 dd offset __unwindfunclet$??0CProperty@@QAE@ABU0@@Z$0
.xdata$x:000071D4 __ehfuncinfo$??0CProperty@@QAE@ABU0@@Z db  22h ; "
.xdata$x:000071D4                                         ; DATA XREF: __ehhandler$??0CProperty@@QAE@ABU0@@Z+11o
.xdata$x:000071D5                 db    5
.xdata$x:000071D6                 db  93h ; Ã´
.xdata$x:000071D7                 db  19h
.xdata$x:000071D8                 db    1
.xdata$x:000071D9                 db    0
.xdata$x:000071DA                 db    0
.xdata$x:000071DB                 db    0
.xdata$x:000071DC                 dd offset __unwindtable$??0CProperty@@QAE@ABU0@@Z
.xdata$x:000071E0                 db    0
.xdata$x:000071E1                 db    0
.xdata$x:000071E2                 db    0
.xdata$x:000071E3                 db    0
.xdata$x:000071E4                 db    0
.xdata$x:000071E5                 db    0
.xdata$x:000071E6                 db    0
.xdata$x:000071E7                 db    0
.xdata$x:000071E8                 db    0
.xdata$x:000071E9                 db    0
.xdata$x:000071EA                 db    0
.xdata$x:000071EB                 db    0
.xdata$x:000071EC                 db    0
.xdata$x:000071ED                 db    0
.xdata$x:000071EE                 db    0
.xdata$x:000071EF                 db    0
.xdata$x:000071F0                 db    0
.xdata$x:000071F1                 db    0
.xdata$x:000071F2                 db    0
.xdata$x:000071F3                 db    0
.xdata$x:000071F4                 db    1
.xdata$x:000071F5                 db    0
.xdata$x:000071F6                 db    0
.xdata$x:000071F7                 db    0
.xdata$x:000071F7 _xdata$x        ends
.xdata$x:000071F7
.text:000071F8 ; ===========================================================================
.text:000071F8
.text:000071F8 ; Segment type: Pure code
.text:000071F8 ; Segment permissions: Read/Execute
.text:000071F8 _text           segment para public 'CODE' use32
.text:000071F8                 assume cs:_text
.text:000071F8                 ;org 71F8h
.text:000071F8 ; COMDAT (pick any)
.text:000071F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000071F8
.text:000071F8 ; =============== S U B R O U T I N E =======================================
.text:000071F8
.text:000071F8 ; Attributes: bp-based frame
.text:000071F8
.text:000071F8 ; public: __thiscall CUpdateArchiveCommand::CUpdateArchiveCommand(struct CUpdateArchiveCommand const &)
.text:000071F8                 public ??0CUpdateArchiveCommand@@QAE@ABU0@@Z
.text:000071F8 ??0CUpdateArchiveCommand@@QAE@ABU0@@Z proc near
.text:000071F8                                         ; CODE XREF: CObjectVector<CUpdateArchiveCommand>::Add(CUpdateArchiveCommand const &)+5Dp
.text:000071F8
.text:000071F8 var_10          = dword ptr -10h
.text:000071F8 var_C           = dword ptr -0Ch
.text:000071F8 var_4           = dword ptr -4
.text:000071F8 arg_0           = dword ptr  8
.text:000071F8
.text:000071F8                 push    ebp
.text:000071F9                 mov     ebp, esp
.text:000071FB                 push    0FFFFFFFFh
.text:000071FD                 push    offset __ehhandler$??0CUpdateArchiveCommand@@QAE@ABU0@@Z
.text:00007202                 mov     eax, large fs:0
.text:00007208                 push    eax
.text:00007209                 push    ecx
.text:0000720A                 push    esi
.text:0000720B                 push    edi
.text:0000720C                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00007213                 mov     eax, dword ptr ds:___security_cookie
.text:00007218                 xor     eax, ebp
.text:0000721A                 push    eax
.text:0000721B                 lea     eax, [ebp+var_C]
.text:0000721E                 mov     large fs:0, eax
.text:00007224                 mov     [ebp+var_10], ecx
.text:00007227                 mov     eax, [ebp+arg_0]
.text:0000722A                 push    eax
.text:0000722B
.text:0000722B loc_722B:                               ; DATA XREF: .rdata:$SG77063o
.text:0000722B                 mov     ecx, [ebp+var_10]
.text:0000722E                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00007233                 mov     [ebp+var_4], 0
.text:0000723A                 mov     ecx, [ebp+arg_0]
.text:0000723D                 add     ecx, 0Ch
.text:00007240                 push    ecx
.text:00007241                 mov     ecx, [ebp+var_10]
.text:00007244                 add     ecx, 0Ch
.text:00007247                 call    ??0CArchivePath@@QAE@ABU0@@Z ; CArchivePath::CArchivePath(CArchivePath const &)
.text:0000724C                 mov     esi, [ebp+arg_0]
.text:0000724F                 add     esi, 64h ; 'd'
.text:00007252                 mov     edi, [ebp+var_10]
.text:00007255                 add     edi, 64h ; 'd'
.text:00007258                 mov     ecx, 7
.text:0000725D                 rep movsd
.text:0000725F                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00007266                 mov     eax, [ebp+var_10]
.text:00007269                 mov     ecx, [ebp+var_C]
.text:0000726C                 mov     large fs:0, ecx
.text:00007273                 pop     ecx
.text:00007274                 pop     edi
.text:00007275                 pop     esi
.text:00007276                 add     esp, 10h
.text:00007279                 cmp     ebp, esp
.text:0000727B                 call    __RTC_CheckEsp
.text:00007280                 mov     esp, ebp
.text:00007282                 pop     ebp
.text:00007283                 retn    4
.text:00007283 ??0CUpdateArchiveCommand@@QAE@ABU0@@Z endp
.text:00007283
.text:00007283 ; ---------------------------------------------------------------------------
.text:00007286                 align 4
.text:00007286 _text           ends
.text:00007286
.text$x:00007288 ; ===========================================================================
.text$x:00007288
.text$x:00007288 ; Segment type: Pure code
.text$x:00007288 ; Segment permissions: Read/Execute
.text$x:00007288 _text$x         segment para public 'CODE' use32
.text$x:00007288                 assume cs:_text$x
.text$x:00007288                 ;org 7288h
.text$x:00007288 ; COMDAT (pick associative to section at 71F8)
.text$x:00007288                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007288
.text$x:00007288 ; =============== S U B R O U T I N E =======================================
.text$x:00007288
.text$x:00007288
.text$x:00007288 __unwindfunclet$??0CUpdateArchiveCommand@@QAE@ABU0@@Z$0 proc near
.text$x:00007288                                         ; DATA XREF: .xdata$x:000072B0o
.text$x:00007288                 mov     ecx, [ebp-10h]  ; this
.text$x:0000728B                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:0000728B __unwindfunclet$??0CUpdateArchiveCommand@@QAE@ABU0@@Z$0 endp
.text$x:0000728B
.text$x:00007290
.text$x:00007290 ; =============== S U B R O U T I N E =======================================
.text$x:00007290
.text$x:00007290
.text$x:00007290 __ehhandler$??0CUpdateArchiveCommand@@QAE@ABU0@@Z proc near
.text$x:00007290                                         ; DATA XREF: CUpdateArchiveCommand::CUpdateArchiveCommand(CUpdateArchiveCommand const &)+5o
.text$x:00007290
.text$x:00007290 arg_4           = dword ptr  8
.text$x:00007290
.text$x:00007290                 mov     edx, [esp+arg_4]
.text$x:00007294                 lea     eax, [edx+0Ch]
.text$x:00007297                 mov     ecx, [edx-10h]
.text$x:0000729A                 xor     ecx, eax
.text$x:0000729C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000072A1                 mov     eax, offset __ehfuncinfo$??0CUpdateArchiveCommand@@QAE@ABU0@@Z
.text$x:000072A6                 jmp     ___CxxFrameHandler3
.text$x:000072A6 __ehhandler$??0CUpdateArchiveCommand@@QAE@ABU0@@Z endp
.text$x:000072A6
.text$x:000072A6 ; ---------------------------------------------------------------------------
.text$x:000072AB                 align 4
.text$x:000072AB _text$x         ends
.text$x:000072AB
.xdata$x:000072AC ; ===========================================================================
.xdata$x:000072AC
.xdata$x:000072AC ; Segment type: Pure data
.xdata$x:000072AC ; Segment permissions: Read
.xdata$x:000072AC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000072AC                 assume cs:_xdata$x
.xdata$x:000072AC                 ;org 72ACh
.xdata$x:000072AC ; COMDAT (pick associative to section at 71F8)
.xdata$x:000072AC __unwindtable$??0CUpdateArchiveCommand@@QAE@ABU0@@Z db 0FFh
.xdata$x:000072AC                                         ; DATA XREF: .xdata$x:000072BCo
.xdata$x:000072AD                 db 0FFh
.xdata$x:000072AE                 db 0FFh
.xdata$x:000072AF                 db 0FFh
.xdata$x:000072B0                 dd offset __unwindfunclet$??0CUpdateArchiveCommand@@QAE@ABU0@@Z$0
.xdata$x:000072B4 __ehfuncinfo$??0CUpdateArchiveCommand@@QAE@ABU0@@Z db  22h ; "
.xdata$x:000072B4                                         ; DATA XREF: __ehhandler$??0CUpdateArchiveCommand@@QAE@ABU0@@Z+11o
.xdata$x:000072B5                 db    5
.xdata$x:000072B6                 db  93h ; Ã´
.xdata$x:000072B7                 db  19h
.xdata$x:000072B8                 db    1
.xdata$x:000072B9                 db    0
.xdata$x:000072BA                 db    0
.xdata$x:000072BB                 db    0
.xdata$x:000072BC                 dd offset __unwindtable$??0CUpdateArchiveCommand@@QAE@ABU0@@Z
.xdata$x:000072C0                 db    0
.xdata$x:000072C1                 db    0
.xdata$x:000072C2                 db    0
.xdata$x:000072C3                 db    0
.xdata$x:000072C4                 db    0
.xdata$x:000072C5                 db    0
.xdata$x:000072C6                 db    0
.xdata$x:000072C7                 db    0
.xdata$x:000072C8                 db    0
.xdata$x:000072C9                 db    0
.xdata$x:000072CA                 db    0
.xdata$x:000072CB                 db    0
.xdata$x:000072CC                 db    0
.xdata$x:000072CD                 db    0
.xdata$x:000072CE                 db    0
.xdata$x:000072CF                 db    0
.xdata$x:000072D0                 db    0
.xdata$x:000072D1                 db    0
.xdata$x:000072D2                 db    0
.xdata$x:000072D3                 db    0
.xdata$x:000072D4                 db    1
.xdata$x:000072D5                 db    0
.xdata$x:000072D6                 db    0
.xdata$x:000072D7                 db    0
.xdata$x:000072D7 _xdata$x        ends
.xdata$x:000072D7
.text:000072D8 ; ===========================================================================
.text:000072D8
.text:000072D8 ; Segment type: Pure code
.text:000072D8 ; Segment permissions: Read/Execute
.text:000072D8 _text           segment para public 'CODE' use32
.text:000072D8                 assume cs:_text
.text:000072D8                 ;org 72D8h
.text:000072D8 ; COMDAT (pick any)
.text:000072D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000072D8
.text:000072D8 ; =============== S U B R O U T I N E =======================================
.text:000072D8
.text:000072D8 ; Attributes: bp-based frame
.text:000072D8
.text:000072D8 ; public: void * __thiscall CUpdateArchiveCommand::`scalar deleting destructor'(unsigned int)
.text:000072D8                 public ??_GCUpdateArchiveCommand@@QAEPAXI@Z
.text:000072D8 ??_GCUpdateArchiveCommand@@QAEPAXI@Z proc near
.text:000072D8                                         ; CODE XREF: CObjectVector<CUpdateArchiveCommand>::Clear(void)+59p
.text:000072D8                                         ; CObjectVector<CUpdateArchiveCommand>::Delete(uint)+3Cp
.text:000072D8
.text:000072D8 var_4           = dword ptr -4
.text:000072D8 arg_0           = dword ptr  8
.text:000072D8
.text:000072D8                 push    ebp
.text:000072D9                 mov     ebp, esp
.text:000072DB                 push    ecx
.text:000072DC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000072E3                 mov     [ebp+var_4], ecx
.text:000072E6                 mov     ecx, [ebp+var_4] ; this
.text:000072E9                 call    ??1CUpdateArchiveCommand@@QAE@XZ ; CUpdateArchiveCommand::~CUpdateArchiveCommand(void)
.text:000072EE                 mov     eax, [ebp+arg_0]
.text:000072F1                 and     eax, 1
.text:000072F4                 jz      short loc_7302
.text:000072F6                 mov     ecx, [ebp+var_4]
.text:000072F9                 push    ecx             ; void *
.text:000072FA                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:000072FF                 add     esp, 4
.text:00007302
.text:00007302 loc_7302:                               ; CODE XREF: CUpdateArchiveCommand::`scalar deleting destructor'(uint)+1Cj
.text:00007302                 mov     eax, [ebp+var_4]
.text:00007305                 add     esp, 4
.text:00007308                 cmp     ebp, esp
.text:0000730A                 call    __RTC_CheckEsp
.text:0000730F                 mov     esp, ebp
.text:00007311                 pop     ebp
.text:00007312                 retn    4
.text:00007312 ??_GCUpdateArchiveCommand@@QAEPAXI@Z endp
.text:00007312
.text:00007312 ; ---------------------------------------------------------------------------
.text:00007315                 align 4
.text:00007315 _text           ends
.text:00007315
.text:00007318 ; ===========================================================================
.text:00007318
.text:00007318 ; Segment type: Pure code
.text:00007318 ; Segment permissions: Read/Execute
.text:00007318 _text           segment para public 'CODE' use32
.text:00007318                 assume cs:_text
.text:00007318                 ;org 7318h
.text:00007318 ; COMDAT (pick any)
.text:00007318                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007318
.text:00007318 ; =============== S U B R O U T I N E =======================================
.text:00007318
.text:00007318 ; Attributes: bp-based frame
.text:00007318
.text:00007318 ; _DWORD __thiscall NWildcard::CItem::~CItem(NWildcard::CItem *__hidden this)
.text:00007318                 public ??1CItem@NWildcard@@QAE@XZ
.text:00007318 ??1CItem@NWildcard@@QAE@XZ proc near    ; CODE XREF: NWildcard::CItem::`scalar deleting destructor'(uint)+11p
.text:00007318
.text:00007318 var_4           = dword ptr -4
.text:00007318
.text:00007318                 push    ebp
.text:00007319                 mov     ebp, esp
.text:0000731B                 push    ecx
.text:0000731C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00007323                 mov     [ebp+var_4], ecx
.text:00007326                 mov     ecx, [ebp+var_4]
.text:00007329                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:0000732E                 add     esp, 4
.text:00007331                 cmp     ebp, esp
.text:00007333                 call    __RTC_CheckEsp
.text:00007338                 mov     esp, ebp
.text:0000733A                 pop     ebp
.text:0000733B                 retn
.text:0000733B ??1CItem@NWildcard@@QAE@XZ endp
.text:0000733B
.text:0000733B _text           ends
.text:0000733B
.text:0000733C ; ===========================================================================
.text:0000733C
.text:0000733C ; Segment type: Pure code
.text:0000733C ; Segment permissions: Read/Execute
.text:0000733C _text           segment para public 'CODE' use32
.text:0000733C                 assume cs:_text
.text:0000733C                 ;org 733Ch
.text:0000733C ; COMDAT (pick any)
.text:0000733C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000733C
.text:0000733C ; =============== S U B R O U T I N E =======================================
.text:0000733C
.text:0000733C ; Attributes: bp-based frame
.text:0000733C
.text:0000733C ; _DWORD __thiscall CDirItem::~CDirItem(CDirItem *__hidden this)
.text:0000733C                 public ??1CDirItem@@QAE@XZ
.text:0000733C ??1CDirItem@@QAE@XZ proc near           ; CODE XREF: CDirItem::`scalar deleting destructor'(uint)+11p
.text:0000733C
.text:0000733C var_10          = dword ptr -10h
.text:0000733C var_C           = dword ptr -0Ch
.text:0000733C var_4           = dword ptr -4
.text:0000733C
.text:0000733C                 push    ebp
.text:0000733D                 mov     ebp, esp
.text:0000733F                 push    0FFFFFFFFh
.text:00007341                 push    offset __ehhandler$??1CDirItem@@QAE@XZ
.text:00007346                 mov     eax, large fs:0
.text:0000734C                 push    eax
.text:0000734D                 push    ecx
.text:0000734E                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00007355                 mov     eax, dword ptr ds:___security_cookie
.text:0000735A                 xor     eax, ebp
.text:0000735C                 push    eax
.text:0000735D                 lea     eax, [ebp+var_C]
.text:00007360                 mov     large fs:0, eax
.text:00007366                 mov     [ebp+var_10], ecx
.text:00007369                 mov     [ebp+var_4], 1
.text:00007370                 mov     ecx, [ebp+var_10]
.text:00007373                 add     ecx, 34h ; '4'
.text:00007376                 call    ??1?$CBuffer@E@@QAE@XZ ; CBuffer<uchar>::~CBuffer<uchar>(void)
.text:0000737B                 mov     byte ptr [ebp+var_4], 0
.text:0000737F                 mov     ecx, [ebp+var_10]
.text:00007382                 add     ecx, 2Ch ; ','
.text:00007385                 call    ??1?$CBuffer@E@@QAE@XZ ; CBuffer<uchar>::~CBuffer<uchar>(void)
.text:0000738A                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00007391                 mov     ecx, [ebp+var_10]
.text:00007394                 add     ecx, 20h ; ' '  ; this
.text:00007397                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000739C                 mov     ecx, [ebp+var_C]
.text:0000739F                 mov     large fs:0, ecx
.text:000073A6                 pop     ecx
.text:000073A7                 add     esp, 10h
.text:000073AA                 cmp     ebp, esp
.text:000073AC                 call    __RTC_CheckEsp
.text:000073B1                 mov     esp, ebp
.text:000073B3                 pop     ebp
.text:000073B4                 retn
.text:000073B4 ??1CDirItem@@QAE@XZ endp
.text:000073B4
.text:000073B4 ; ---------------------------------------------------------------------------
.text:000073B5                 align 4
.text:000073B5 _text           ends
.text:000073B5
.text$x:000073B8 ; ===========================================================================
.text$x:000073B8
.text$x:000073B8 ; Segment type: Pure code
.text$x:000073B8 ; Segment permissions: Read/Execute
.text$x:000073B8 _text$x         segment para public 'CODE' use32
.text$x:000073B8                 assume cs:_text$x
.text$x:000073B8                 ;org 73B8h
.text$x:000073B8 ; COMDAT (pick associative to section at 733C)
.text$x:000073B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000073B8
.text$x:000073B8 ; =============== S U B R O U T I N E =======================================
.text$x:000073B8
.text$x:000073B8
.text$x:000073B8 __unwindfunclet$??1CDirItem@@QAE@XZ$0 proc near
.text$x:000073B8                                         ; DATA XREF: .xdata$x:000073F0o
.text$x:000073B8                 mov     ecx, [ebp-10h]
.text$x:000073BB                 add     ecx, 20h ; ' '  ; this
.text$x:000073BE                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000073BE __unwindfunclet$??1CDirItem@@QAE@XZ$0 endp
.text$x:000073BE
.text$x:000073C3
.text$x:000073C3 ; =============== S U B R O U T I N E =======================================
.text$x:000073C3
.text$x:000073C3
.text$x:000073C3 __unwindfunclet$??1CDirItem@@QAE@XZ$1 proc near
.text$x:000073C3                                         ; DATA XREF: .xdata$x:000073F8o
.text$x:000073C3                 mov     ecx, [ebp-10h]
.text$x:000073C6                 add     ecx, 2Ch ; ','
.text$x:000073C9                 jmp     ??1?$CBuffer@E@@QAE@XZ ; CBuffer<uchar>::~CBuffer<uchar>(void)
.text$x:000073C9 __unwindfunclet$??1CDirItem@@QAE@XZ$1 endp
.text$x:000073C9
.text$x:000073CE
.text$x:000073CE ; =============== S U B R O U T I N E =======================================
.text$x:000073CE
.text$x:000073CE
.text$x:000073CE __ehhandler$??1CDirItem@@QAE@XZ proc near
.text$x:000073CE                                         ; DATA XREF: CDirItem::~CDirItem(void)+5o
.text$x:000073CE
.text$x:000073CE arg_4           = dword ptr  8
.text$x:000073CE
.text$x:000073CE                 mov     edx, [esp+arg_4]
.text$x:000073D2                 lea     eax, [edx+0Ch]
.text$x:000073D5                 mov     ecx, [edx-8]
.text$x:000073D8                 xor     ecx, eax
.text$x:000073DA                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000073DF                 mov     eax, offset __ehfuncinfo$??1CDirItem@@QAE@XZ
.text$x:000073E4                 jmp     ___CxxFrameHandler3
.text$x:000073E4 __ehhandler$??1CDirItem@@QAE@XZ endp
.text$x:000073E4
.text$x:000073E4 ; ---------------------------------------------------------------------------
.text$x:000073E9                 align 4
.text$x:000073E9 _text$x         ends
.text$x:000073E9
.xdata$x:000073EC ; ===========================================================================
.xdata$x:000073EC
.xdata$x:000073EC ; Segment type: Pure data
.xdata$x:000073EC ; Segment permissions: Read
.xdata$x:000073EC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000073EC                 assume cs:_xdata$x
.xdata$x:000073EC                 ;org 73ECh
.xdata$x:000073EC ; COMDAT (pick associative to section at 733C)
.xdata$x:000073EC __unwindtable$??1CDirItem@@QAE@XZ db 0FFh ; DATA XREF: .xdata$x:00007404o
.xdata$x:000073ED                 db 0FFh
.xdata$x:000073EE                 db 0FFh
.xdata$x:000073EF                 db 0FFh
.xdata$x:000073F0                 dd offset __unwindfunclet$??1CDirItem@@QAE@XZ$0
.xdata$x:000073F4                 align 8
.xdata$x:000073F8                 dd offset __unwindfunclet$??1CDirItem@@QAE@XZ$1
.xdata$x:000073FC __ehfuncinfo$??1CDirItem@@QAE@XZ db  22h ; "
.xdata$x:000073FC                                         ; DATA XREF: __ehhandler$??1CDirItem@@QAE@XZ+11o
.xdata$x:000073FD                 db    5
.xdata$x:000073FE                 db  93h ; Ã´
.xdata$x:000073FF                 db  19h
.xdata$x:00007400                 db    2
.xdata$x:00007401                 db    0
.xdata$x:00007402                 db    0
.xdata$x:00007403                 db    0
.xdata$x:00007404                 dd offset __unwindtable$??1CDirItem@@QAE@XZ
.xdata$x:00007408                 db    0
.xdata$x:00007409                 db    0
.xdata$x:0000740A                 db    0
.xdata$x:0000740B                 db    0
.xdata$x:0000740C                 db    0
.xdata$x:0000740D                 db    0
.xdata$x:0000740E                 db    0
.xdata$x:0000740F                 db    0
.xdata$x:00007410                 db    0
.xdata$x:00007411                 db    0
.xdata$x:00007412                 db    0
.xdata$x:00007413                 db    0
.xdata$x:00007414                 db    0
.xdata$x:00007415                 db    0
.xdata$x:00007416                 db    0
.xdata$x:00007417                 db    0
.xdata$x:00007418                 db    0
.xdata$x:00007419                 db    0
.xdata$x:0000741A                 db    0
.xdata$x:0000741B                 db    0
.xdata$x:0000741C                 db    1
.xdata$x:0000741D                 db    0
.xdata$x:0000741E                 db    0
.xdata$x:0000741F                 db    0
.xdata$x:0000741F _xdata$x        ends
.xdata$x:0000741F
.text:00007420 ; ===========================================================================
.text:00007420
.text:00007420 ; Segment type: Pure code
.text:00007420 ; Segment permissions: Read/Execute
.text:00007420 _text           segment para public 'CODE' use32
.text:00007420                 assume cs:_text
.text:00007420                 ;org 7420h
.text:00007420 ; COMDAT (pick any)
.text:00007420                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007420
.text:00007420 ; =============== S U B R O U T I N E =======================================
.text:00007420
.text:00007420 ; Attributes: bp-based frame
.text:00007420
.text:00007420 ; public: __thiscall CArchivePath::CArchivePath(struct CArchivePath const &)
.text:00007420                 public ??0CArchivePath@@QAE@ABU0@@Z
.text:00007420 ??0CArchivePath@@QAE@ABU0@@Z proc near  ; CODE XREF: CUpdateArchiveCommand::CUpdateArchiveCommand(CUpdateArchiveCommand const &)+4Fp
.text:00007420
.text:00007420 var_10          = dword ptr -10h
.text:00007420 var_C           = dword ptr -0Ch
.text:00007420 var_4           = dword ptr -4
.text:00007420 arg_0           = dword ptr  8
.text:00007420
.text:00007420                 push    ebp
.text:00007421                 mov     ebp, esp
.text:00007423                 push    0FFFFFFFFh
.text:00007425                 push    offset __ehhandler$??0CArchivePath@@QAE@ABU0@@Z
.text:0000742A                 mov     eax, large fs:0
.text:00007430                 push    eax
.text:00007431                 push    ecx
.text:00007432                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00007439                 mov     eax, dword ptr ds:___security_cookie
.text:0000743E                 xor     eax, ebp
.text:00007440                 push    eax
.text:00007441                 lea     eax, [ebp+var_C]
.text:00007444                 mov     large fs:0, eax
.text:0000744A                 mov     [ebp+var_10], ecx
.text:0000744D                 mov     eax, [ebp+arg_0]
.text:00007450                 push    eax
.text:00007451                 mov     ecx, [ebp+var_10]
.text:00007454                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00007459                 mov     [ebp+var_4], 0
.text:00007460                 mov     ecx, [ebp+arg_0]
.text:00007463                 add     ecx, 0Ch
.text:00007466                 push    ecx
.text:00007467                 mov     ecx, [ebp+var_10]
.text:0000746A                 add     ecx, 0Ch
.text:0000746D                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00007472                 mov     byte ptr [ebp+var_4], 1
.text:00007476                 mov     edx, [ebp+arg_0]
.text:00007479                 add     edx, 18h
.text:0000747C                 push    edx
.text:0000747D                 mov     ecx, [ebp+var_10]
.text:00007480                 add     ecx, 18h
.text:00007483                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00007488                 mov     byte ptr [ebp+var_4], 2
.text:0000748C                 mov     eax, [ebp+arg_0]
.text:0000748F                 add     eax, 24h ; '$'
.text:00007492                 push    eax
.text:00007493                 mov     ecx, [ebp+var_10]
.text:00007496                 add     ecx, 24h ; '$'
.text:00007499                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:0000749E                 mov     byte ptr [ebp+var_4], 3
.text:000074A2                 mov     ecx, [ebp+arg_0]
.text:000074A5                 add     ecx, 30h ; '0'
.text:000074A8                 push    ecx
.text:000074A9                 mov     ecx, [ebp+var_10]
.text:000074AC                 add     ecx, 30h ; '0'
.text:000074AF                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:000074B4                 mov     byte ptr [ebp+var_4], 4
.text:000074B8                 mov     edx, [ebp+var_10]
.text:000074BB                 mov     eax, [ebp+arg_0]
.text:000074BE                 mov     cl, [eax+3Ch]
.text:000074C1                 mov     [edx+3Ch], cl
.text:000074C4                 mov     edx, [ebp+arg_0]
.text:000074C7                 add     edx, 40h ; '@'
.text:000074CA                 push    edx
.text:000074CB                 mov     ecx, [ebp+var_10]
.text:000074CE                 add     ecx, 40h ; '@'
.text:000074D1                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:000074D6                 mov     byte ptr [ebp+var_4], 5
.text:000074DA                 mov     eax, [ebp+arg_0]
.text:000074DD                 add     eax, 4Ch ; 'L'
.text:000074E0                 push    eax
.text:000074E1                 mov     ecx, [ebp+var_10]
.text:000074E4                 add     ecx, 4Ch ; 'L'
.text:000074E7                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:000074EC                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000074F3                 mov     eax, [ebp+var_10]
.text:000074F6                 mov     ecx, [ebp+var_C]
.text:000074F9                 mov     large fs:0, ecx
.text:00007500                 pop     ecx
.text:00007501                 add     esp, 10h
.text:00007504                 cmp     ebp, esp
.text:00007506                 call    __RTC_CheckEsp
.text:0000750B                 mov     esp, ebp
.text:0000750D                 pop     ebp
.text:0000750E                 retn    4
.text:0000750E ??0CArchivePath@@QAE@ABU0@@Z endp
.text:0000750E
.text:0000750E ; ---------------------------------------------------------------------------
.text:00007511                 align 4
.text:00007511 _text           ends
.text:00007511
.text$x:00007514 ; ===========================================================================
.text$x:00007514
.text$x:00007514 ; Segment type: Pure code
.text$x:00007514 ; Segment permissions: Read/Execute
.text$x:00007514 _text$x         segment para public 'CODE' use32
.text$x:00007514                 assume cs:_text$x
.text$x:00007514                 ;org 7514h
.text$x:00007514 ; COMDAT (pick associative to section at 7420)
.text$x:00007514                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007514
.text$x:00007514 ; =============== S U B R O U T I N E =======================================
.text$x:00007514
.text$x:00007514
.text$x:00007514 __unwindfunclet$??0CArchivePath@@QAE@ABU0@@Z$0 proc near
.text$x:00007514                                         ; DATA XREF: .xdata$x:00007598o
.text$x:00007514                 mov     ecx, [ebp-10h]  ; this
.text$x:00007517                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00007517 __unwindfunclet$??0CArchivePath@@QAE@ABU0@@Z$0 endp
.text$x:00007517
.text$x:0000751C
.text$x:0000751C ; =============== S U B R O U T I N E =======================================
.text$x:0000751C
.text$x:0000751C
.text$x:0000751C __unwindfunclet$??0CArchivePath@@QAE@ABU0@@Z$1 proc near
.text$x:0000751C                                         ; DATA XREF: .xdata$x:000075A0o
.text$x:0000751C                 mov     ecx, [ebp-10h]
.text$x:0000751F                 add     ecx, 0Ch        ; this
.text$x:00007522                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00007522 __unwindfunclet$??0CArchivePath@@QAE@ABU0@@Z$1 endp
.text$x:00007522
.text$x:00007527
.text$x:00007527 ; =============== S U B R O U T I N E =======================================
.text$x:00007527
.text$x:00007527
.text$x:00007527 __unwindfunclet$??0CArchivePath@@QAE@ABU0@@Z$2 proc near
.text$x:00007527                                         ; DATA XREF: .xdata$x:000075A8o
.text$x:00007527                 mov     ecx, [ebp-10h]
.text$x:0000752A                 add     ecx, 18h        ; this
.text$x:0000752D                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:0000752D __unwindfunclet$??0CArchivePath@@QAE@ABU0@@Z$2 endp
.text$x:0000752D
.text$x:00007532
.text$x:00007532 ; =============== S U B R O U T I N E =======================================
.text$x:00007532
.text$x:00007532
.text$x:00007532 __unwindfunclet$??0CArchivePath@@QAE@ABU0@@Z$3 proc near
.text$x:00007532                                         ; DATA XREF: .xdata$x:000075B0o
.text$x:00007532                 mov     ecx, [ebp-10h]
.text$x:00007535                 add     ecx, 24h ; '$'  ; this
.text$x:00007538                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00007538 __unwindfunclet$??0CArchivePath@@QAE@ABU0@@Z$3 endp
.text$x:00007538
.text$x:0000753D
.text$x:0000753D ; =============== S U B R O U T I N E =======================================
.text$x:0000753D
.text$x:0000753D
.text$x:0000753D __unwindfunclet$??0CArchivePath@@QAE@ABU0@@Z$4 proc near
.text$x:0000753D                                         ; DATA XREF: .xdata$x:000075B8o
.text$x:0000753D                 mov     ecx, [ebp-10h]
.text$x:00007540                 add     ecx, 30h ; '0'  ; this
.text$x:00007543                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00007543 __unwindfunclet$??0CArchivePath@@QAE@ABU0@@Z$4 endp
.text$x:00007543
.text$x:00007548
.text$x:00007548 ; =============== S U B R O U T I N E =======================================
.text$x:00007548
.text$x:00007548
.text$x:00007548 __unwindfunclet$??0CArchivePath@@QAE@ABU0@@Z$5 proc near
.text$x:00007548                                         ; DATA XREF: .xdata$x:000075C0o
.text$x:00007548                 mov     ecx, [ebp-10h]
.text$x:0000754B                 add     ecx, 40h ; '@'  ; this
.text$x:0000754E                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:0000754E __unwindfunclet$??0CArchivePath@@QAE@ABU0@@Z$5 endp
.text$x:0000754E
.text$x:00007553
.text$x:00007553 ; =============== S U B R O U T I N E =======================================
.text$x:00007553
.text$x:00007553
.text$x:00007553 __ehhandler$??0CArchivePath@@QAE@ABU0@@Z proc near
.text$x:00007553                                         ; DATA XREF: CArchivePath::CArchivePath(CArchivePath const &)+5o
.text$x:00007553
.text$x:00007553 arg_4           = dword ptr  8
.text$x:00007553
.text$x:00007553                 mov     edx, [esp+arg_4]
.text$x:00007557                 lea     eax, [edx+0Ch]
.text$x:0000755A                 mov     ecx, [edx-8]
.text$x:0000755D                 xor     ecx, eax
.text$x:0000755F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007564                 mov     eax, offset __ehfuncinfo$??0CArchivePath@@QAE@ABU0@@Z
.text$x:00007569                 jmp     ___CxxFrameHandler3
.text$x:00007569 __ehhandler$??0CArchivePath@@QAE@ABU0@@Z endp
.text$x:00007569
.text$x:00007569 ; ---------------------------------------------------------------------------
.text$x:0000756E                 align 10h
.text$x:0000756E _text$x         ends
.text$x:0000756E
.xdata$x:00007570 ; ===========================================================================
.xdata$x:00007570
.xdata$x:00007570 ; Segment type: Pure data
.xdata$x:00007570 ; Segment permissions: Read
.xdata$x:00007570 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007570                 assume cs:_xdata$x
.xdata$x:00007570                 ;org 7570h
.xdata$x:00007570 ; COMDAT (pick associative to section at 7420)
.xdata$x:00007570 __ehfuncinfo$??0CArchivePath@@QAE@ABU0@@Z db  22h ; "
.xdata$x:00007570                                         ; DATA XREF: __ehhandler$??0CArchivePath@@QAE@ABU0@@Z+11o
.xdata$x:00007571                 db    5
.xdata$x:00007572                 db  93h ; Ã´
.xdata$x:00007573                 db  19h
.xdata$x:00007574                 db    6
.xdata$x:00007575                 db    0
.xdata$x:00007576                 db    0
.xdata$x:00007577                 db    0
.xdata$x:00007578                 dd offset __unwindtable$??0CArchivePath@@QAE@ABU0@@Z
.xdata$x:0000757C                 db    0
.xdata$x:0000757D                 db    0
.xdata$x:0000757E                 db    0
.xdata$x:0000757F                 db    0
.xdata$x:00007580                 db    0
.xdata$x:00007581                 db    0
.xdata$x:00007582                 db    0
.xdata$x:00007583                 db    0
.xdata$x:00007584                 db    0
.xdata$x:00007585                 db    0
.xdata$x:00007586                 db    0
.xdata$x:00007587                 db    0
.xdata$x:00007588                 db    0
.xdata$x:00007589                 db    0
.xdata$x:0000758A                 db    0
.xdata$x:0000758B                 db    0
.xdata$x:0000758C                 db    0
.xdata$x:0000758D                 db    0
.xdata$x:0000758E                 db    0
.xdata$x:0000758F                 db    0
.xdata$x:00007590                 db    1
.xdata$x:00007591                 db    0
.xdata$x:00007592                 db    0
.xdata$x:00007593                 db    0
.xdata$x:00007594 __unwindtable$??0CArchivePath@@QAE@ABU0@@Z db 0FFh
.xdata$x:00007594                                         ; DATA XREF: .xdata$x:00007578o
.xdata$x:00007595                 db 0FFh
.xdata$x:00007596                 db 0FFh
.xdata$x:00007597                 db 0FFh
.xdata$x:00007598                 dd offset __unwindfunclet$??0CArchivePath@@QAE@ABU0@@Z$0
.xdata$x:0000759C                 align 10h
.xdata$x:000075A0                 dd offset __unwindfunclet$??0CArchivePath@@QAE@ABU0@@Z$1
.xdata$x:000075A4                 db    1
.xdata$x:000075A5                 db    0
.xdata$x:000075A6                 db    0
.xdata$x:000075A7                 db    0
.xdata$x:000075A8                 dd offset __unwindfunclet$??0CArchivePath@@QAE@ABU0@@Z$2
.xdata$x:000075AC                 db    2
.xdata$x:000075AD                 db    0
.xdata$x:000075AE                 db    0
.xdata$x:000075AF                 db    0
.xdata$x:000075B0                 dd offset __unwindfunclet$??0CArchivePath@@QAE@ABU0@@Z$3
.xdata$x:000075B4                 db    3
.xdata$x:000075B5                 db    0
.xdata$x:000075B6                 db    0
.xdata$x:000075B7                 db    0
.xdata$x:000075B8                 dd offset __unwindfunclet$??0CArchivePath@@QAE@ABU0@@Z$4
.xdata$x:000075BC                 db    4
.xdata$x:000075BD                 db    0
.xdata$x:000075BE                 db    0
.xdata$x:000075BF                 db    0
.xdata$x:000075C0                 dd offset __unwindfunclet$??0CArchivePath@@QAE@ABU0@@Z$5
.xdata$x:000075C0 _xdata$x        ends
.xdata$x:000075C0
.text:000075C4 ; ===========================================================================
.text:000075C4
.text:000075C4 ; Segment type: Pure code
.text:000075C4 ; Segment permissions: Read/Execute
.text:000075C4 _text           segment para public 'CODE' use32
.text:000075C4                 assume cs:_text
.text:000075C4                 ;org 75C4h
.text:000075C4 ; COMDAT (pick any)
.text:000075C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000075C4
.text:000075C4 ; =============== S U B R O U T I N E =======================================
.text:000075C4
.text:000075C4 ; Attributes: bp-based frame
.text:000075C4
.text:000075C4 ; public: __thiscall CRecordVector<void *>::CRecordVector<void *>(void)
.text:000075C4                 public ??0?$CRecordVector@PAX@@QAE@XZ
.text:000075C4 ??0?$CRecordVector@PAX@@QAE@XZ proc near
.text:000075C4                                         ; CODE XREF: CObjectVector<UString>::CObjectVector<UString>(void)+11p
.text:000075C4                                         ; CObjectVector<UString>::CObjectVector<UString>(CObjectVector<UString> const &)+42p
.text:000075C4
.text:000075C4 var_4           = dword ptr -4
.text:000075C4
.text:000075C4                 push    ebp
.text:000075C5                 mov     ebp, esp
.text:000075C7                 push    ecx
.text:000075C8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000075CF                 mov     [ebp+var_4], ecx
.text:000075D2                 mov     eax, [ebp+var_4]
.text:000075D5                 mov     dword ptr [eax], 0
.text:000075DB                 mov     ecx, [ebp+var_4]
.text:000075DE                 mov     dword ptr [ecx+4], 0
.text:000075E5                 mov     edx, [ebp+var_4]
.text:000075E8                 mov     dword ptr [edx+8], 0
.text:000075EF                 mov     eax, [ebp+var_4]
.text:000075F2                 mov     esp, ebp
.text:000075F4                 pop     ebp
.text:000075F5                 retn
.text:000075F5 ??0?$CRecordVector@PAX@@QAE@XZ endp
.text:000075F5
.text:000075F5 ; ---------------------------------------------------------------------------
.text:000075F6                 align 4
.text:000075F6 _text           ends
.text:000075F6
.text:000075F8 ; ===========================================================================
.text:000075F8
.text:000075F8 ; Segment type: Pure code
.text:000075F8 ; Segment permissions: Read/Execute
.text:000075F8 _text           segment para public 'CODE' use32
.text:000075F8                 assume cs:_text
.text:000075F8                 ;org 75F8h
.text:000075F8 ; COMDAT (pick any)
.text:000075F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000075F8
.text:000075F8 ; =============== S U B R O U T I N E =======================================
.text:000075F8
.text:000075F8 ; Attributes: bp-based frame
.text:000075F8
.text:000075F8 ; public: unsigned int __thiscall CRecordVector<void *>::Size(void)const
.text:000075F8                 public ?Size@?$CRecordVector@PAX@@QBEIXZ
.text:000075F8 ?Size@?$CRecordVector@PAX@@QBEIXZ proc near
.text:000075F8                                         ; CODE XREF: CObjectVector<UString>::Size(void)+11p
.text:000075F8                                         ; CObjectVector<UString>::Back(void)+11p ...
.text:000075F8
.text:000075F8 var_4           = dword ptr -4
.text:000075F8
.text:000075F8                 push    ebp
.text:000075F9                 mov     ebp, esp
.text:000075FB                 push    ecx
.text:000075FC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00007603                 mov     [ebp+var_4], ecx
.text:00007606                 mov     eax, [ebp+var_4]
.text:00007609                 mov     eax, [eax+4]
.text:0000760C                 mov     esp, ebp
.text:0000760E                 pop     ebp
.text:0000760F                 retn
.text:0000760F ?Size@?$CRecordVector@PAX@@QBEIXZ endp
.text:0000760F
.text:0000760F _text           ends
.text:0000760F
.text:00007610 ; ===========================================================================
.text:00007610
.text:00007610 ; Segment type: Pure code
.text:00007610 ; Segment permissions: Read/Execute
.text:00007610 _text           segment para public 'CODE' use32
.text:00007610                 assume cs:_text
.text:00007610                 ;org 7610h
.text:00007610 ; COMDAT (pick any)
.text:00007610                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007610
.text:00007610 ; =============== S U B R O U T I N E =======================================
.text:00007610
.text:00007610 ; Attributes: bp-based frame
.text:00007610
.text:00007610 ; public: void __thiscall CRecordVector<void *>::Reserve(unsigned int)
.text:00007610                 public ?Reserve@?$CRecordVector@PAX@@QAEXI@Z
.text:00007610 ?Reserve@?$CRecordVector@PAX@@QAEXI@Z proc near
.text:00007610                                         ; CODE XREF: CObjectVector<UString>::operator=(CObjectVector<UString> const &)+69p
.text:00007610                                         ; CObjectVector<NWildcard::CItem>::operator+=(CObjectVector<NWildcard::CItem> const &)+59p ...
.text:00007610
.text:00007610 var_10          = dword ptr -10h
.text:00007610 var_C           = dword ptr -0Ch
.text:00007610 Dst             = dword ptr -8
.text:00007610 var_4           = dword ptr -4
.text:00007610 arg_0           = dword ptr  8
.text:00007610
.text:00007610                 push    ebp
.text:00007611                 mov     ebp, esp
.text:00007613                 sub     esp, 10h
.text:00007616                 mov     eax, 0CCCCCCCCh
.text:0000761B                 mov     [ebp+var_10], eax
.text:0000761E                 mov     [ebp+var_C], eax
.text:00007621                 mov     [ebp+Dst], eax
.text:00007624                 mov     [ebp+var_4], eax
.text:00007627                 mov     [ebp+var_4], ecx
.text:0000762A                 mov     eax, [ebp+var_4]
.text:0000762D                 mov     ecx, [ebp+arg_0]
.text:00007630                 cmp     ecx, [eax+8]
.text:00007633                 jbe     short loc_76A4
.text:00007635                 xor     ecx, ecx
.text:00007637                 mov     eax, [ebp+arg_0]
.text:0000763A                 mov     edx, 4
.text:0000763F                 mul     edx
.text:00007641                 seto    cl
.text:00007644                 neg     ecx
.text:00007646                 or      ecx, eax
.text:00007648                 push    ecx             ; unsigned int
.text:00007649                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0000764E                 add     esp, 4
.text:00007651                 mov     [ebp+var_C], eax
.text:00007654                 mov     eax, [ebp+var_C]
.text:00007657                 mov     [ebp+Dst], eax
.text:0000765A                 mov     ecx, [ebp+var_4]
.text:0000765D                 cmp     dword ptr [ecx+4], 0
.text:00007661                 jz      short loc_767F
.text:00007663                 mov     edx, [ebp+var_4]
.text:00007666                 mov     eax, [edx+4]
.text:00007669                 shl     eax, 2
.text:0000766C                 push    eax             ; Size
.text:0000766D                 mov     ecx, [ebp+var_4]
.text:00007670                 mov     edx, [ecx]
.text:00007672                 push    edx             ; Src
.text:00007673                 mov     eax, [ebp+Dst]
.text:00007676                 push    eax             ; Dst
.text:00007677                 call    _memcpy
.text:0000767C                 add     esp, 0Ch
.text:0000767F
.text:0000767F loc_767F:                               ; CODE XREF: CRecordVector<void *>::Reserve(uint)+51j
.text:0000767F                 mov     ecx, [ebp+var_4]
.text:00007682                 mov     edx, [ecx]
.text:00007684                 mov     [ebp+var_10], edx
.text:00007687                 mov     eax, [ebp+var_10]
.text:0000768A                 push    eax             ; void *
.text:0000768B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00007690                 add     esp, 4
.text:00007693                 mov     ecx, [ebp+var_4]
.text:00007696                 mov     edx, [ebp+Dst]
.text:00007699                 mov     [ecx], edx
.text:0000769B                 mov     eax, [ebp+var_4]
.text:0000769E                 mov     ecx, [ebp+arg_0]
.text:000076A1                 mov     [eax+8], ecx
.text:000076A4
.text:000076A4 loc_76A4:                               ; CODE XREF: CRecordVector<void *>::Reserve(uint)+23j
.text:000076A4                 add     esp, 10h
.text:000076A7                 cmp     ebp, esp
.text:000076A9                 call    __RTC_CheckEsp
.text:000076AE                 mov     esp, ebp
.text:000076B0                 pop     ebp
.text:000076B1                 retn    4
.text:000076B1 ?Reserve@?$CRecordVector@PAX@@QAEXI@Z endp
.text:000076B1
.text:000076B1 _text           ends
.text:000076B1
.text:000076B4 ; ===========================================================================
.text:000076B4
.text:000076B4 ; Segment type: Pure code
.text:000076B4 ; Segment permissions: Read/Execute
.text:000076B4 _text           segment para public 'CODE' use32
.text:000076B4                 assume cs:_text
.text:000076B4                 ;org 76B4h
.text:000076B4 ; COMDAT (pick any)
.text:000076B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000076B4
.text:000076B4 ; =============== S U B R O U T I N E =======================================
.text:000076B4
.text:000076B4 ; Attributes: bp-based frame
.text:000076B4
.text:000076B4 ; public: void __thiscall CRecordVector<void *>::ClearAndReserve(unsigned int)
.text:000076B4                 public ?ClearAndReserve@?$CRecordVector@PAX@@QAEXI@Z
.text:000076B4 ?ClearAndReserve@?$CRecordVector@PAX@@QAEXI@Z proc near
.text:000076B4                                         ; CODE XREF: CObjectVector<UString>::ClearAndReserve(uint)+1Dp
.text:000076B4
.text:000076B4 var_C           = dword ptr -0Ch
.text:000076B4 var_8           = dword ptr -8
.text:000076B4 var_4           = dword ptr -4
.text:000076B4 arg_0           = dword ptr  8
.text:000076B4
.text:000076B4                 push    ebp
.text:000076B5                 mov     ebp, esp
.text:000076B7                 sub     esp, 0Ch
.text:000076BA                 mov     [ebp+var_C], 0CCCCCCCCh
.text:000076C1                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000076C8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000076CF                 mov     [ebp+var_4], ecx
.text:000076D2                 mov     ecx, [ebp+var_4]
.text:000076D5                 call    ?Clear@?$CRecordVector@PAX@@QAEXXZ ; CRecordVector<void *>::Clear(void)
.text:000076DA                 mov     eax, [ebp+var_4]
.text:000076DD                 mov     ecx, [ebp+arg_0]
.text:000076E0                 cmp     ecx, [eax+8]
.text:000076E3                 jbe     short loc_773C
.text:000076E5                 mov     edx, [ebp+var_4]
.text:000076E8                 mov     eax, [edx]
.text:000076EA                 mov     [ebp+var_8], eax
.text:000076ED                 mov     ecx, [ebp+var_8]
.text:000076F0                 push    ecx             ; void *
.text:000076F1                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:000076F6                 add     esp, 4
.text:000076F9                 mov     edx, [ebp+var_4]
.text:000076FC                 mov     dword ptr [edx], 0
.text:00007702                 mov     eax, [ebp+var_4]
.text:00007705                 mov     dword ptr [eax+8], 0
.text:0000770C                 xor     ecx, ecx
.text:0000770E                 mov     eax, [ebp+arg_0]
.text:00007711                 mov     edx, 4
.text:00007716                 mul     edx
.text:00007718                 seto    cl
.text:0000771B                 neg     ecx
.text:0000771D                 or      ecx, eax
.text:0000771F                 push    ecx             ; unsigned int
.text:00007720                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00007725                 add     esp, 4
.text:00007728                 mov     [ebp+var_C], eax
.text:0000772B                 mov     eax, [ebp+var_4]
.text:0000772E                 mov     ecx, [ebp+var_C]
.text:00007731                 mov     [eax], ecx
.text:00007733                 mov     edx, [ebp+var_4]
.text:00007736                 mov     eax, [ebp+arg_0]
.text:00007739                 mov     [edx+8], eax
.text:0000773C
.text:0000773C loc_773C:                               ; CODE XREF: CRecordVector<void *>::ClearAndReserve(uint)+2Fj
.text:0000773C                 add     esp, 0Ch
.text:0000773F                 cmp     ebp, esp
.text:00007741                 call    __RTC_CheckEsp
.text:00007746                 mov     esp, ebp
.text:00007748                 pop     ebp
.text:00007749                 retn    4
.text:00007749 ?ClearAndReserve@?$CRecordVector@PAX@@QAEXI@Z endp
.text:00007749
.text:00007749 _text           ends
.text:00007749
.text:0000774C ; ===========================================================================
.text:0000774C
.text:0000774C ; Segment type: Pure code
.text:0000774C ; Segment permissions: Read/Execute
.text:0000774C _text           segment para public 'CODE' use32
.text:0000774C                 assume cs:_text
.text:0000774C                 ;org 774Ch
.text:0000774C ; COMDAT (pick any)
.text:0000774C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000774C
.text:0000774C ; =============== S U B R O U T I N E =======================================
.text:0000774C
.text:0000774C ; Attributes: bp-based frame
.text:0000774C
.text:0000774C ; public: __thiscall CRecordVector<void *>::~CRecordVector<void *>(void)
.text:0000774C                 public ??1?$CRecordVector@PAX@@QAE@XZ
.text:0000774C ??1?$CRecordVector@PAX@@QAE@XZ proc near
.text:0000774C                                         ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+9Cp
.text:0000774C                                         ; __unwindfunclet$??1?$CObjectVector@VUString@@@@QAE@XZ$0+3j ...
.text:0000774C
.text:0000774C var_8           = dword ptr -8
.text:0000774C var_4           = dword ptr -4
.text:0000774C
.text:0000774C                 push    ebp
.text:0000774D                 mov     ebp, esp
.text:0000774F                 sub     esp, 8
.text:00007752                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00007759                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00007760                 mov     [ebp+var_4], ecx
.text:00007763                 mov     eax, [ebp+var_4]
.text:00007766                 mov     ecx, [eax]
.text:00007768                 mov     [ebp+var_8], ecx
.text:0000776B                 mov     edx, [ebp+var_8]
.text:0000776E                 push    edx             ; void *
.text:0000776F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00007774                 add     esp, 4
.text:00007777                 add     esp, 8
.text:0000777A                 cmp     ebp, esp
.text:0000777C                 call    __RTC_CheckEsp
.text:00007781                 mov     esp, ebp
.text:00007783                 pop     ebp
.text:00007784                 retn
.text:00007784 ??1?$CRecordVector@PAX@@QAE@XZ endp
.text:00007784
.text:00007784 ; ---------------------------------------------------------------------------
.text:00007785                 align 4
.text:00007785 _text           ends
.text:00007785
.text:00007788 ; ===========================================================================
.text:00007788
.text:00007788 ; Segment type: Pure code
.text:00007788 ; Segment permissions: Read/Execute
.text:00007788 _text           segment para public 'CODE' use32
.text:00007788                 assume cs:_text
.text:00007788                 ;org 7788h
.text:00007788 ; COMDAT (pick any)
.text:00007788                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007788
.text:00007788 ; =============== S U B R O U T I N E =======================================
.text:00007788
.text:00007788 ; Attributes: bp-based frame
.text:00007788
.text:00007788 ; public: void __thiscall CRecordVector<void *>::Clear(void)
.text:00007788                 public ?Clear@?$CRecordVector@PAX@@QAEXXZ
.text:00007788 ?Clear@?$CRecordVector@PAX@@QAEXXZ proc near
.text:00007788                                         ; CODE XREF: CObjectVector<UString>::Clear(void)+6Fp
.text:00007788                                         ; CObjectVector<CUpdateArchiveCommand>::Clear(void)+6Fp ...
.text:00007788
.text:00007788 var_4           = dword ptr -4
.text:00007788
.text:00007788                 push    ebp
.text:00007789                 mov     ebp, esp
.text:0000778B                 push    ecx
.text:0000778C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00007793                 mov     [ebp+var_4], ecx
.text:00007796                 mov     eax, [ebp+var_4]
.text:00007799                 mov     dword ptr [eax+4], 0
.text:000077A0                 mov     esp, ebp
.text:000077A2                 pop     ebp
.text:000077A3                 retn
.text:000077A3 ?Clear@?$CRecordVector@PAX@@QAEXXZ endp
.text:000077A3
.text:000077A3 _text           ends
.text:000077A3
.text:000077A4 ; ===========================================================================
.text:000077A4
.text:000077A4 ; Segment type: Pure code
.text:000077A4 ; Segment permissions: Read/Execute
.text:000077A4 _text           segment para public 'CODE' use32
.text:000077A4                 assume cs:_text
.text:000077A4                 ;org 77A4h
.text:000077A4 ; COMDAT (pick any)
.text:000077A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000077A4
.text:000077A4 ; =============== S U B R O U T I N E =======================================
.text:000077A4
.text:000077A4 ; Attributes: bp-based frame
.text:000077A4
.text:000077A4 ; public: void __thiscall CRecordVector<void *>::Delete(unsigned int)
.text:000077A4                 public ?Delete@?$CRecordVector@PAX@@QAEXI@Z
.text:000077A4 ?Delete@?$CRecordVector@PAX@@QAEXI@Z proc near
.text:000077A4                                         ; CODE XREF: CObjectVector<NWildcard::CCensorNode>::Delete(uint)+54p
.text:000077A4                                         ; CObjectVector<CUpdateArchiveCommand>::Delete(uint)+54p
.text:000077A4
.text:000077A4 var_4           = dword ptr -4
.text:000077A4 arg_0           = dword ptr  8
.text:000077A4
.text:000077A4                 push    ebp
.text:000077A5                 mov     ebp, esp
.text:000077A7                 push    ecx
.text:000077A8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000077AF                 mov     [ebp+var_4], ecx
.text:000077B2                 mov     eax, [ebp+arg_0]
.text:000077B5                 add     eax, 1
.text:000077B8                 push    eax
.text:000077B9                 mov     ecx, [ebp+arg_0]
.text:000077BC                 push    ecx
.text:000077BD                 mov     ecx, [ebp+var_4]
.text:000077C0                 call    ?MoveItems@?$CRecordVector@PAX@@AAEXII@Z ; CRecordVector<void *>::MoveItems(uint,uint)
.text:000077C5                 mov     edx, [ebp+var_4]
.text:000077C8                 mov     eax, [edx+4]
.text:000077CB                 sub     eax, 1
.text:000077CE                 mov     ecx, [ebp+var_4]
.text:000077D1                 mov     [ecx+4], eax
.text:000077D4                 add     esp, 4
.text:000077D7                 cmp     ebp, esp
.text:000077D9                 call    __RTC_CheckEsp
.text:000077DE                 mov     esp, ebp
.text:000077E0                 pop     ebp
.text:000077E1                 retn    4
.text:000077E1 ?Delete@?$CRecordVector@PAX@@QAEXI@Z endp
.text:000077E1
.text:000077E1 _text           ends
.text:000077E1
.text:000077E4 ; ===========================================================================
.text:000077E4
.text:000077E4 ; Segment type: Pure code
.text:000077E4 ; Segment permissions: Read/Execute
.text:000077E4 _text           segment para public 'CODE' use32
.text:000077E4                 assume cs:_text
.text:000077E4                 ;org 77E4h
.text:000077E4 ; COMDAT (pick any)
.text:000077E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000077E4
.text:000077E4 ; =============== S U B R O U T I N E =======================================
.text:000077E4
.text:000077E4 ; Attributes: bp-based frame
.text:000077E4
.text:000077E4 ; public: unsigned int __thiscall CRecordVector<void *>::Add(void * const)
.text:000077E4                 public ?Add@?$CRecordVector@PAX@@QAEIQAX@Z
.text:000077E4 ?Add@?$CRecordVector@PAX@@QAEIQAX@Z proc near
.text:000077E4                                         ; CODE XREF: CObjectVector<UString>::Add(UString const &)+7Fp
.text:000077E4                                         ; CObjectVector<CProperty>::Add(CProperty const &)+7Fp ...
.text:000077E4
.text:000077E4 var_8           = dword ptr -8
.text:000077E4 var_4           = dword ptr -4
.text:000077E4 arg_0           = dword ptr  8
.text:000077E4
.text:000077E4                 push    ebp
.text:000077E5                 mov     ebp, esp
.text:000077E7                 sub     esp, 8
.text:000077EA                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000077F1                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000077F8                 mov     [ebp+var_4], ecx
.text:000077FB                 mov     ecx, [ebp+var_4]
.text:000077FE                 call    ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ ; CRecordVector<void *>::ReserveOnePosition(void)
.text:00007803                 mov     eax, [ebp+var_4]
.text:00007806                 mov     ecx, [eax+4]
.text:00007809                 mov     edx, [ebp+var_4]
.text:0000780C                 mov     eax, [edx]
.text:0000780E                 mov     edx, [ebp+arg_0]
.text:00007811                 mov     [eax+ecx*4], edx
.text:00007814                 mov     eax, [ebp+var_4]
.text:00007817                 mov     ecx, [eax+4]
.text:0000781A                 mov     [ebp+var_8], ecx
.text:0000781D                 mov     edx, [ebp+var_4]
.text:00007820                 mov     eax, [edx+4]
.text:00007823                 add     eax, 1
.text:00007826                 mov     ecx, [ebp+var_4]
.text:00007829                 mov     [ecx+4], eax
.text:0000782C                 mov     eax, [ebp+var_8]
.text:0000782F                 add     esp, 8
.text:00007832                 cmp     ebp, esp
.text:00007834                 call    __RTC_CheckEsp
.text:00007839                 mov     esp, ebp
.text:0000783B                 pop     ebp
.text:0000783C                 retn    4
.text:0000783C ?Add@?$CRecordVector@PAX@@QAEIQAX@Z endp
.text:0000783C
.text:0000783C ; ---------------------------------------------------------------------------
.text:0000783F                 align 10h
.text:0000783F _text           ends
.text:0000783F
.text:00007840 ; ===========================================================================
.text:00007840
.text:00007840 ; Segment type: Pure code
.text:00007840 ; Segment permissions: Read/Execute
.text:00007840 _text           segment para public 'CODE' use32
.text:00007840                 assume cs:_text
.text:00007840                 ;org 7840h
.text:00007840 ; COMDAT (pick any)
.text:00007840                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007840
.text:00007840 ; =============== S U B R O U T I N E =======================================
.text:00007840
.text:00007840 ; Attributes: bp-based frame
.text:00007840
.text:00007840 ; public: void __thiscall CRecordVector<void *>::AddInReserved(void * const)
.text:00007840                 public ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z
.text:00007840 ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z proc near
.text:00007840                                         ; CODE XREF: CObjectVector<UString>::operator=(CObjectVector<UString> const &)+D7p
.text:00007840                                         ; CObjectVector<UString>::AddInReserved(UString const &)+7Fp ...
.text:00007840
.text:00007840 var_4           = dword ptr -4
.text:00007840 arg_0           = dword ptr  8
.text:00007840
.text:00007840                 push    ebp
.text:00007841                 mov     ebp, esp
.text:00007843                 push    ecx
.text:00007844                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000784B                 mov     [ebp+var_4], ecx
.text:0000784E                 mov     eax, [ebp+var_4]
.text:00007851                 mov     ecx, [eax+4]
.text:00007854                 mov     edx, [ebp+var_4]
.text:00007857                 mov     eax, [edx]
.text:00007859                 mov     edx, [ebp+arg_0]
.text:0000785C                 mov     [eax+ecx*4], edx
.text:0000785F
.text:0000785F loc_785F:                               ; DATA XREF: .rdata:$SG76913o
.text:0000785F                 mov     eax, [ebp+var_4]
.text:00007862                 mov     ecx, [eax+4]
.text:00007865                 add     ecx, 1
.text:00007868                 mov     edx, [ebp+var_4]
.text:0000786B                 mov     [edx+4], ecx
.text:0000786E                 mov     esp, ebp
.text:00007870                 pop     ebp
.text:00007871                 retn    4
.text:00007871 ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z endp
.text:00007871
.text:00007871 _text           ends
.text:00007871
.text:00007874 ; ===========================================================================
.text:00007874
.text:00007874 ; Segment type: Pure code
.text:00007874 ; Segment permissions: Read/Execute
.text:00007874 _text           segment para public 'CODE' use32
.text:00007874                 assume cs:_text
.text:00007874                 ;org 7874h
.text:00007874 ; COMDAT (pick any)
.text:00007874                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007874
.text:00007874 ; =============== S U B R O U T I N E =======================================
.text:00007874
.text:00007874 ; Attributes: bp-based frame
.text:00007874
.text:00007874 ; public: void * const & __thiscall CRecordVector<void *>::operator[](unsigned int)const
.text:00007874                 public ??A?$CRecordVector@PAX@@QBEABQAXI@Z
.text:00007874 ??A?$CRecordVector@PAX@@QBEABQAXI@Z proc near
.text:00007874                                         ; CODE XREF: CObjectVector<UString>::operator[](uint)+15p
.text:00007874                                         ; CObjectVector<NWildcard::CItem>::operator[](uint)+15p ...
.text:00007874
.text:00007874 var_4           = dword ptr -4
.text:00007874 arg_0           = dword ptr  8
.text:00007874
.text:00007874                 push    ebp
.text:00007875                 mov     ebp, esp
.text:00007877                 push    ecx
.text:00007878                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000787F                 mov     [ebp+var_4], ecx
.text:00007882                 mov     eax, [ebp+var_4]
.text:00007885                 mov     ecx, [eax]
.text:00007887                 mov     edx, [ebp+arg_0]
.text:0000788A                 lea     eax, [ecx+edx*4]
.text:0000788D                 mov     esp, ebp
.text:0000788F                 pop     ebp
.text:00007890                 retn    4
.text:00007890 ??A?$CRecordVector@PAX@@QBEABQAXI@Z endp
.text:00007890
.text:00007890 ; ---------------------------------------------------------------------------
.text:00007893                 align 4
.text:00007893 _text           ends
.text:00007893
.text:00007894 ; ===========================================================================
.text:00007894
.text:00007894 ; Segment type: Pure code
.text:00007894 ; Segment permissions: Read/Execute
.text:00007894 _text           segment para public 'CODE' use32
.text:00007894                 assume cs:_text
.text:00007894                 ;org 7894h
.text:00007894 ; COMDAT (pick any)
.text:00007894                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007894
.text:00007894 ; =============== S U B R O U T I N E =======================================
.text:00007894
.text:00007894 ; Attributes: bp-based frame
.text:00007894
.text:00007894 ; public: void * & __thiscall CRecordVector<void *>::operator[](unsigned int)
.text:00007894                 public ??A?$CRecordVector@PAX@@QAEAAPAXI@Z
.text:00007894 ??A?$CRecordVector@PAX@@QAEAAPAXI@Z proc near
.text:00007894                                         ; CODE XREF: CObjectVector<UString>::operator[](uint)+15p
.text:00007894                                         ; CObjectVector<UString>::~CObjectVector<UString>(void)+64p ...
.text:00007894
.text:00007894 var_4           = dword ptr -4
.text:00007894 arg_0           = dword ptr  8
.text:00007894
.text:00007894                 push    ebp
.text:00007895                 mov     ebp, esp
.text:00007897                 push    ecx
.text:00007898                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000789F                 mov     [ebp+var_4], ecx
.text:000078A2                 mov     eax, [ebp+var_4]
.text:000078A5                 mov     ecx, [eax]
.text:000078A7                 mov     edx, [ebp+arg_0]
.text:000078AA                 lea     eax, [ecx+edx*4]
.text:000078AD                 mov     esp, ebp
.text:000078AF                 pop     ebp
.text:000078B0                 retn    4
.text:000078B0 ??A?$CRecordVector@PAX@@QAEAAPAXI@Z endp
.text:000078B0
.text:000078B0 ; ---------------------------------------------------------------------------
.text:000078B3                 align 4
.text:000078B3 _text           ends
.text:000078B3
.text:000078B4 ; ===========================================================================
.text:000078B4
.text:000078B4 ; Segment type: Pure code
.text:000078B4 ; Segment permissions: Read/Execute
.text:000078B4 _text           segment para public 'CODE' use32
.text:000078B4                 assume cs:_text
.text:000078B4                 ;org 78B4h
.text:000078B4 ; COMDAT (pick any)
.text:000078B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000078B4
.text:000078B4 ; =============== S U B R O U T I N E =======================================
.text:000078B4
.text:000078B4 ; Attributes: bp-based frame
.text:000078B4
.text:000078B4 ; public: __thiscall CObjectVector<class UString>::CObjectVector<class UString>(class CObjectVector<class UString> const &)
.text:000078B4                 public ??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z
.text:000078B4 ??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z proc near
.text:000078B4                                         ; CODE XREF: NWildcard::CItem::CItem(NWildcard::CItem const &)+15p
.text:000078B4
.text:000078B4 var_24          = dword ptr -24h
.text:000078B4 var_20          = dword ptr -20h
.text:000078B4 var_1C          = dword ptr -1Ch
.text:000078B4 var_18          = dword ptr -18h
.text:000078B4 var_14          = dword ptr -14h
.text:000078B4 var_10          = dword ptr -10h
.text:000078B4 var_C           = dword ptr -0Ch
.text:000078B4 var_4           = dword ptr -4
.text:000078B4 arg_0           = dword ptr  8
.text:000078B4
.text:000078B4                 push    ebp
.text:000078B5                 mov     ebp, esp
.text:000078B7                 push    0FFFFFFFFh
.text:000078B9                 push    offset __ehhandler$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z
.text:000078BE                 mov     eax, large fs:0
.text:000078C4                 push    eax
.text:000078C5                 sub     esp, 18h
.text:000078C8                 mov     eax, 0CCCCCCCCh
.text:000078CD                 mov     [ebp+var_24], eax
.text:000078D0                 mov     [ebp+var_20], eax
.text:000078D3                 mov     [ebp+var_1C], eax
.text:000078D6                 mov     [ebp+var_18], eax
.text:000078D9                 mov     [ebp+var_14], eax
.text:000078DC                 mov     [ebp+var_10], eax
.text:000078DF                 mov     eax, dword ptr ds:___security_cookie
.text:000078E4                 xor     eax, ebp
.text:000078E6                 push    eax
.text:000078E7                 lea     eax, [ebp+var_C]
.text:000078EA                 mov     large fs:0, eax
.text:000078F0                 mov     [ebp+var_10], ecx
.text:000078F3                 mov     ecx, [ebp+var_10]
.text:000078F6                 call    ??0?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::CRecordVector<void *>(void)
.text:000078FB                 mov     [ebp+var_4], 0
.text:00007902                 mov     ecx, [ebp+arg_0]
.text:00007905                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:0000790A                 mov     [ebp+var_14], eax
.text:0000790D                 mov     eax, [ebp+var_14]
.text:00007910                 push    eax
.text:00007911                 mov     ecx, [ebp+var_10]
.text:00007914                 call    ?ConstructReserve@?$CRecordVector@PAX@@QAEXI@Z ; CRecordVector<void *>::ConstructReserve(uint)
.text:00007919                 mov     [ebp+var_18], 0
.text:00007920                 jmp     short loc_792B
.text:00007922 ; ---------------------------------------------------------------------------
.text:00007922
.text:00007922 loc_7922:                               ; CODE XREF: CObjectVector<UString>::CObjectVector<UString>(CObjectVector<UString> const &)+CDj
.text:00007922                 mov     ecx, [ebp+var_18]
.text:00007925                 add     ecx, 1
.text:00007928                 mov     [ebp+var_18], ecx
.text:0000792B
.text:0000792B loc_792B:                               ; CODE XREF: CObjectVector<UString>::CObjectVector<UString>(CObjectVector<UString> const &)+6Cj
.text:0000792B                 mov     edx, [ebp+var_18]
.text:0000792E                 cmp     edx, [ebp+var_14]
.text:00007931                 jnb     short loc_7983
.text:00007933                 push    0Ch             ; unsigned int
.text:00007935                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0000793A                 add     esp, 4
.text:0000793D                 mov     [ebp+var_20], eax
.text:00007940                 mov     byte ptr [ebp+var_4], 1
.text:00007944                 cmp     [ebp+var_20], 0
.text:00007948                 jz      short loc_7964
.text:0000794A                 mov     eax, [ebp+var_18]
.text:0000794D                 push    eax
.text:0000794E                 mov     ecx, [ebp+arg_0]
.text:00007951                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00007956                 push    eax
.text:00007957                 mov     ecx, [ebp+var_20]
.text:0000795A                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:0000795F                 mov     [ebp+var_24], eax
.text:00007962                 jmp     short loc_796B
.text:00007964 ; ---------------------------------------------------------------------------
.text:00007964
.text:00007964 loc_7964:                               ; CODE XREF: CObjectVector<UString>::CObjectVector<UString>(CObjectVector<UString> const &)+94j
.text:00007964                 mov     [ebp+var_24], 0
.text:0000796B
.text:0000796B loc_796B:                               ; CODE XREF: CObjectVector<UString>::CObjectVector<UString>(CObjectVector<UString> const &)+AEj
.text:0000796B                 mov     ecx, [ebp+var_24]
.text:0000796E                 mov     [ebp+var_1C], ecx
.text:00007971                 mov     byte ptr [ebp+var_4], 0
.text:00007975                 mov     edx, [ebp+var_1C]
.text:00007978                 push    edx
.text:00007979                 mov     ecx, [ebp+var_10]
.text:0000797C                 call    ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z ; CRecordVector<void *>::AddInReserved(void * const)
.text:00007981                 jmp     short loc_7922
.text:00007983 ; ---------------------------------------------------------------------------
.text:00007983
.text:00007983 loc_7983:                               ; CODE XREF: CObjectVector<UString>::CObjectVector<UString>(CObjectVector<UString> const &)+7Dj
.text:00007983                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000798A                 mov     eax, [ebp+var_10]
.text:0000798D                 mov     ecx, [ebp+var_C]
.text:00007990                 mov     large fs:0, ecx
.text:00007997                 pop     ecx
.text:00007998                 add     esp, 24h
.text:0000799B                 cmp     ebp, esp
.text:0000799D                 call    __RTC_CheckEsp
.text:000079A2                 mov     esp, ebp
.text:000079A4                 pop     ebp
.text:000079A5                 retn    4
.text:000079A5 ??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z endp
.text:000079A5
.text:000079A5 _text           ends
.text:000079A5
.text$x:000079A8 ; ===========================================================================
.text$x:000079A8
.text$x:000079A8 ; Segment type: Pure code
.text$x:000079A8 ; Segment permissions: Read/Execute
.text$x:000079A8 _text$x         segment para public 'CODE' use32
.text$x:000079A8                 assume cs:_text$x
.text$x:000079A8                 ;org 79A8h
.text$x:000079A8 ; COMDAT (pick associative to section at 78B4)
.text$x:000079A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000079A8
.text$x:000079A8 ; =============== S U B R O U T I N E =======================================
.text$x:000079A8
.text$x:000079A8
.text$x:000079A8 __unwindfunclet$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z$0 proc near
.text$x:000079A8                                         ; DATA XREF: .xdata$x:000079DCo
.text$x:000079A8                 mov     ecx, [ebp-10h]
.text$x:000079AB                 jmp     ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text$x:000079AB __unwindfunclet$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z$0 endp
.text$x:000079AB
.text$x:000079B0
.text$x:000079B0 ; =============== S U B R O U T I N E =======================================
.text$x:000079B0
.text$x:000079B0
.text$x:000079B0 __unwindfunclet$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z$1 proc near
.text$x:000079B0                                         ; DATA XREF: .xdata$x:000079E4o
.text$x:000079B0                 mov     eax, [ebp-20h]
.text$x:000079B3                 push    eax             ; void *
.text$x:000079B4                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:000079B9                 pop     ecx
.text$x:000079BA                 retn
.text$x:000079BA __unwindfunclet$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z$1 endp
.text$x:000079BA
.text$x:000079BB
.text$x:000079BB ; =============== S U B R O U T I N E =======================================
.text$x:000079BB
.text$x:000079BB
.text$x:000079BB __ehhandler$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z proc near
.text$x:000079BB                                         ; DATA XREF: CObjectVector<UString>::CObjectVector<UString>(CObjectVector<UString> const &)+5o
.text$x:000079BB
.text$x:000079BB arg_4           = dword ptr  8
.text$x:000079BB
.text$x:000079BB                 mov     edx, [esp+arg_4]
.text$x:000079BF                 lea     eax, [edx+0Ch]
.text$x:000079C2                 mov     ecx, [edx-1Ch]
.text$x:000079C5                 xor     ecx, eax
.text$x:000079C7                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000079CC                 mov     eax, offset __ehfuncinfo$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z
.text$x:000079D1                 jmp     ___CxxFrameHandler3
.text$x:000079D1 __ehhandler$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z endp
.text$x:000079D1
.text$x:000079D1 ; ---------------------------------------------------------------------------
.text$x:000079D6                 align 4
.text$x:000079D6 _text$x         ends
.text$x:000079D6
.xdata$x:000079D8 ; ===========================================================================
.xdata$x:000079D8
.xdata$x:000079D8 ; Segment type: Pure data
.xdata$x:000079D8 ; Segment permissions: Read
.xdata$x:000079D8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000079D8                 assume cs:_xdata$x
.xdata$x:000079D8                 ;org 79D8h
.xdata$x:000079D8 ; COMDAT (pick associative to section at 78B4)
.xdata$x:000079D8 __unwindtable$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z db 0FFh
.xdata$x:000079D8                                         ; DATA XREF: .xdata$x:000079F0o
.xdata$x:000079D9                 db 0FFh
.xdata$x:000079DA                 db 0FFh
.xdata$x:000079DB                 db 0FFh
.xdata$x:000079DC                 dd offset __unwindfunclet$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z$0
.xdata$x:000079E0                 db    0
.xdata$x:000079E1                 db    0
.xdata$x:000079E2                 db    0
.xdata$x:000079E3                 db    0
.xdata$x:000079E4                 dd offset __unwindfunclet$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z$1
.xdata$x:000079E8 __ehfuncinfo$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z db  22h ; "
.xdata$x:000079E8                                         ; DATA XREF: __ehhandler$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z+11o
.xdata$x:000079E9                 db    5
.xdata$x:000079EA                 db  93h ; Ã´
.xdata$x:000079EB                 db  19h
.xdata$x:000079EC                 db    2
.xdata$x:000079ED                 db    0
.xdata$x:000079EE                 db    0
.xdata$x:000079EF                 db    0
.xdata$x:000079F0                 dd offset __unwindtable$??0?$CObjectVector@VUString@@@@QAE@ABV0@@Z
.xdata$x:000079F4                 db    0
.xdata$x:000079F5                 db    0
.xdata$x:000079F6                 db    0
.xdata$x:000079F7                 db    0
.xdata$x:000079F8                 db    0
.xdata$x:000079F9                 db    0
.xdata$x:000079FA                 db    0
.xdata$x:000079FB                 db    0
.xdata$x:000079FC                 db    0
.xdata$x:000079FD                 db    0
.xdata$x:000079FE                 db    0
.xdata$x:000079FF                 db    0
.xdata$x:00007A00                 db    0
.xdata$x:00007A01                 db    0
.xdata$x:00007A02                 db    0
.xdata$x:00007A03                 db    0
.xdata$x:00007A04                 db    0
.xdata$x:00007A05                 db    0
.xdata$x:00007A06                 db    0
.xdata$x:00007A07                 db    0
.xdata$x:00007A08                 db    1
.xdata$x:00007A09                 db    0
.xdata$x:00007A0A                 db    0
.xdata$x:00007A0B                 db    0
.xdata$x:00007A0B _xdata$x        ends
.xdata$x:00007A0B
.text:00007A0C ; ===========================================================================
.text:00007A0C
.text:00007A0C ; Segment type: Pure code
.text:00007A0C ; Segment permissions: Read/Execute
.text:00007A0C _text           segment para public 'CODE' use32
.text:00007A0C                 assume cs:_text
.text:00007A0C                 ;org 7A0Ch
.text:00007A0C ; COMDAT (pick any)
.text:00007A0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007A0C
.text:00007A0C ; =============== S U B R O U T I N E =======================================
.text:00007A0C
.text:00007A0C ; Attributes: bp-based frame
.text:00007A0C
.text:00007A0C ; public: struct NWildcard::CItem const & __thiscall CObjectVector<struct NWildcard::CItem>::operator[](unsigned int)const
.text:00007A0C                 public ??A?$CObjectVector@UCItem@NWildcard@@@@QBEABUCItem@NWildcard@@I@Z
.text:00007A0C ??A?$CObjectVector@UCItem@NWildcard@@@@QBEABUCItem@NWildcard@@I@Z proc near
.text:00007A0C                                         ; CODE XREF: CObjectVector<NWildcard::CItem>::operator+=(CObjectVector<NWildcard::CItem> const &)+99p
.text:00007A0C
.text:00007A0C var_4           = dword ptr -4
.text:00007A0C arg_0           = dword ptr  8
.text:00007A0C
.text:00007A0C                 push    ebp
.text:00007A0D                 mov     ebp, esp
.text:00007A0F                 push    ecx
.text:00007A10                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00007A17                 mov     [ebp+var_4], ecx
.text:00007A1A                 mov     eax, [ebp+arg_0]
.text:00007A1D                 push    eax
.text:00007A1E                 mov     ecx, [ebp+var_4]
.text:00007A21                 call    ??A?$CRecordVector@PAX@@QBEABQAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00007A26                 mov     eax, [eax]
.text:00007A28                 add     esp, 4
.text:00007A2B                 cmp     ebp, esp
.text:00007A2D                 call    __RTC_CheckEsp
.text:00007A32                 mov     esp, ebp
.text:00007A34                 pop     ebp
.text:00007A35                 retn    4
.text:00007A35 ??A?$CObjectVector@UCItem@NWildcard@@@@QBEABUCItem@NWildcard@@I@Z endp
.text:00007A35
.text:00007A35 _text           ends
.text:00007A35
.text:00007A38 ; ===========================================================================
.text:00007A38
.text:00007A38 ; Segment type: Pure code
.text:00007A38 ; Segment permissions: Read/Execute
.text:00007A38 _text           segment para public 'CODE' use32
.text:00007A38                 assume cs:_text
.text:00007A38                 ;org 7A38h
.text:00007A38 ; COMDAT (pick any)
.text:00007A38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007A38
.text:00007A38 ; =============== S U B R O U T I N E =======================================
.text:00007A38
.text:00007A38 ; Attributes: bp-based frame
.text:00007A38
.text:00007A38 ; public: struct NWildcard::CPair const & __thiscall CObjectVector<struct NWildcard::CPair>::operator[](unsigned int)const
.text:00007A38                 public ??A?$CObjectVector@UCPair@NWildcard@@@@QBEABUCPair@NWildcard@@I@Z
.text:00007A38 ??A?$CObjectVector@UCPair@NWildcard@@@@QBEABUCPair@NWildcard@@I@Z proc near
.text:00007A38                                         ; CODE XREF: CObjectVector<NWildcard::CPair>::Front(void)+13p
.text:00007A38
.text:00007A38 var_4           = dword ptr -4
.text:00007A38 arg_0           = dword ptr  8
.text:00007A38
.text:00007A38                 push    ebp
.text:00007A39                 mov     ebp, esp
.text:00007A3B                 push    ecx
.text:00007A3C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00007A43                 mov     [ebp+var_4], ecx
.text:00007A46                 mov     eax, [ebp+arg_0]
.text:00007A49                 push    eax
.text:00007A4A                 mov     ecx, [ebp+var_4]
.text:00007A4D                 call    ??A?$CRecordVector@PAX@@QBEABQAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00007A52                 mov     eax, [eax]
.text:00007A54                 add     esp, 4
.text:00007A57                 cmp     ebp, esp
.text:00007A59                 call    __RTC_CheckEsp
.text:00007A5E                 mov     esp, ebp
.text:00007A60                 pop     ebp
.text:00007A61                 retn    4
.text:00007A61 ??A?$CObjectVector@UCPair@NWildcard@@@@QBEABUCPair@NWildcard@@I@Z endp
.text:00007A61
.text:00007A61 _text           ends
.text:00007A61
.text:00007A64 ; ===========================================================================
.text:00007A64
.text:00007A64 ; Segment type: Pure code
.text:00007A64 ; Segment permissions: Read/Execute
.text:00007A64 _text           segment para public 'CODE' use32
.text:00007A64                 assume cs:_text
.text:00007A64                 ;org 7A64h
.text:00007A64 ; COMDAT (pick any)
.text:00007A64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007A64
.text:00007A64 ; =============== S U B R O U T I N E =======================================
.text:00007A64
.text:00007A64 ; Attributes: bp-based frame
.text:00007A64
.text:00007A64 ; private: void __thiscall CRecordVector<unsigned __int64>::ReserveOnePosition(void)
.text:00007A64                 public ?ReserveOnePosition@?$CRecordVector@_K@@AAEXXZ
.text:00007A64 ?ReserveOnePosition@?$CRecordVector@_K@@AAEXXZ proc near
.text:00007A64                                         ; CODE XREF: CRecordVector<unsigned __int64>::Add(unsigned __int64)+1Ap
.text:00007A64
.text:00007A64 var_14          = dword ptr -14h
.text:00007A64 var_10          = dword ptr -10h
.text:00007A64 Dst             = dword ptr -0Ch
.text:00007A64 var_8           = dword ptr -8
.text:00007A64 var_4           = dword ptr -4
.text:00007A64
.text:00007A64                 push    ebp
.text:00007A65                 mov     ebp, esp
.text:00007A67                 sub     esp, 14h
.text:00007A6A                 mov     eax, 0CCCCCCCCh
.text:00007A6F                 mov     [ebp+var_14], eax
.text:00007A72                 mov     [ebp+var_10], eax
.text:00007A75                 mov     [ebp+Dst], eax
.text:00007A78                 mov     [ebp+var_8], eax
.text:00007A7B                 mov     [ebp+var_4], eax
.text:00007A7E                 mov     [ebp+var_4], ecx
.text:00007A81                 mov     eax, [ebp+var_4]
.text:00007A84                 mov     ecx, [ebp+var_4]
.text:00007A87                 mov     edx, [eax+4]
.text:00007A8A                 cmp     edx, [ecx+8]
.text:00007A8D                 jnz     loc_7B18
.text:00007A93                 mov     eax, [ebp+var_4]
.text:00007A96                 mov     ecx, [eax+8]
.text:00007A99                 shr     ecx, 2
.text:00007A9C                 mov     edx, [ebp+var_4]
.text:00007A9F                 mov     eax, [edx+8]
.text:00007AA2                 lea     ecx, [eax+ecx+1]
.text:00007AA6                 mov     [ebp+var_8], ecx
.text:00007AA9                 xor     ecx, ecx
.text:00007AAB                 mov     eax, [ebp+var_8]
.text:00007AAE                 mov     edx, 8
.text:00007AB3                 mul     edx
.text:00007AB5                 seto    cl
.text:00007AB8                 neg     ecx
.text:00007ABA                 or      ecx, eax
.text:00007ABC                 push    ecx             ; unsigned int
.text:00007ABD                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00007AC2                 add     esp, 4
.text:00007AC5                 mov     [ebp+var_10], eax
.text:00007AC8                 mov     eax, [ebp+var_10]
.text:00007ACB                 mov     [ebp+Dst], eax
.text:00007ACE                 mov     ecx, [ebp+var_4]
.text:00007AD1                 cmp     dword ptr [ecx+4], 0
.text:00007AD5                 jz      short loc_7AF3
.text:00007AD7                 mov     edx, [ebp+var_4]
.text:00007ADA                 mov     eax, [edx+4]
.text:00007ADD                 shl     eax, 3
.text:00007AE0                 push    eax             ; Size
.text:00007AE1                 mov     ecx, [ebp+var_4]
.text:00007AE4                 mov     edx, [ecx]
.text:00007AE6                 push    edx             ; Src
.text:00007AE7                 mov     eax, [ebp+Dst]
.text:00007AEA                 push    eax             ; Dst
.text:00007AEB                 call    _memcpy
.text:00007AF0                 add     esp, 0Ch
.text:00007AF3
.text:00007AF3 loc_7AF3:                               ; CODE XREF: CRecordVector<unsigned __int64>::ReserveOnePosition(void)+71j
.text:00007AF3                 mov     ecx, [ebp+var_4]
.text:00007AF6                 mov     edx, [ecx]
.text:00007AF8                 mov     [ebp+var_14], edx
.text:00007AFB                 mov     eax, [ebp+var_14]
.text:00007AFE                 push    eax             ; void *
.text:00007AFF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00007B04                 add     esp, 4
.text:00007B07                 mov     ecx, [ebp+var_4]
.text:00007B0A                 mov     edx, [ebp+Dst]
.text:00007B0D                 mov     [ecx], edx
.text:00007B0F                 mov     eax, [ebp+var_4]
.text:00007B12                 mov     ecx, [ebp+var_8]
.text:00007B15                 mov     [eax+8], ecx
.text:00007B18
.text:00007B18 loc_7B18:                               ; CODE XREF: CRecordVector<unsigned __int64>::ReserveOnePosition(void)+29j
.text:00007B18                 add     esp, 14h
.text:00007B1B                 cmp     ebp, esp
.text:00007B1D                 call    __RTC_CheckEsp
.text:00007B22                 mov     esp, ebp
.text:00007B24                 pop     ebp
.text:00007B25                 retn
.text:00007B25 ?ReserveOnePosition@?$CRecordVector@_K@@AAEXXZ endp
.text:00007B25
.text:00007B25 ; ---------------------------------------------------------------------------
.text:00007B26                 align 4
.text:00007B26 _text           ends
.text:00007B26
.text:00007B28 ; ===========================================================================
.text:00007B28
.text:00007B28 ; Segment type: Pure code
.text:00007B28 ; Segment permissions: Read/Execute
.text:00007B28 _text           segment para public 'CODE' use32
.text:00007B28                 assume cs:_text
.text:00007B28                 ;org 7B28h
.text:00007B28 ; COMDAT (pick any)
.text:00007B28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007B28
.text:00007B28 ; =============== S U B R O U T I N E =======================================
.text:00007B28
.text:00007B28 ; Attributes: bp-based frame
.text:00007B28
.text:00007B28 ; public: unsigned int __thiscall CObjectVector<struct CProperty>::Size(void)const
.text:00007B28                 public ?Size@?$CObjectVector@UCProperty@@@@QBEIXZ
.text:00007B28 ?Size@?$CObjectVector@UCProperty@@@@QBEIXZ proc near
.text:00007B28                                         ; CODE XREF: CObjectVector<CProperty>::operator=(CObjectVector<CProperty> const &)+5Ap
.text:00007B28
.text:00007B28 var_4           = dword ptr -4
.text:00007B28
.text:00007B28                 push    ebp
.text:00007B29                 mov     ebp, esp
.text:00007B2B                 push    ecx
.text:00007B2C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00007B33                 mov     [ebp+var_4], ecx
.text:00007B36                 mov     ecx, [ebp+var_4]
.text:00007B39                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00007B3E                 add     esp, 4
.text:00007B41                 cmp     ebp, esp
.text:00007B43                 call    __RTC_CheckEsp
.text:00007B48                 mov     esp, ebp
.text:00007B4A                 pop     ebp
.text:00007B4B                 retn
.text:00007B4B ?Size@?$CObjectVector@UCProperty@@@@QBEIXZ endp
.text:00007B4B
.text:00007B4B _text           ends
.text:00007B4B
.text:00007B4C ; ===========================================================================
.text:00007B4C
.text:00007B4C ; Segment type: Pure code
.text:00007B4C ; Segment permissions: Read/Execute
.text:00007B4C _text           segment para public 'CODE' use32
.text:00007B4C                 assume cs:_text
.text:00007B4C                 ;org 7B4Ch
.text:00007B4C ; COMDAT (pick any)
.text:00007B4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007B4C
.text:00007B4C ; =============== S U B R O U T I N E =======================================
.text:00007B4C
.text:00007B4C ; Attributes: bp-based frame
.text:00007B4C
.text:00007B4C ; public: struct CProperty const & __thiscall CObjectVector<struct CProperty>::operator[](unsigned int)const
.text:00007B4C                 public ??A?$CObjectVector@UCProperty@@@@QBEABUCProperty@@I@Z
.text:00007B4C ??A?$CObjectVector@UCProperty@@@@QBEABUCProperty@@I@Z proc near
.text:00007B4C                                         ; CODE XREF: CObjectVector<CProperty>::operator=(CObjectVector<CProperty> const &)+A9p
.text:00007B4C
.text:00007B4C var_4           = dword ptr -4
.text:00007B4C arg_0           = dword ptr  8
.text:00007B4C
.text:00007B4C                 push    ebp
.text:00007B4D                 mov     ebp, esp
.text:00007B4F                 push    ecx
.text:00007B50                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00007B57                 mov     [ebp+var_4], ecx
.text:00007B5A                 mov     eax, [ebp+arg_0]
.text:00007B5D                 push    eax
.text:00007B5E                 mov     ecx, [ebp+var_4]
.text:00007B61                 call    ??A?$CRecordVector@PAX@@QBEABQAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00007B66                 mov     eax, [eax]
.text:00007B68                 add     esp, 4
.text:00007B6B                 cmp     ebp, esp
.text:00007B6D                 call    __RTC_CheckEsp
.text:00007B72                 mov     esp, ebp
.text:00007B74                 pop     ebp
.text:00007B75                 retn    4
.text:00007B75 ??A?$CObjectVector@UCProperty@@@@QBEABUCProperty@@I@Z endp
.text:00007B75
.text:00007B75 _text           ends
.text:00007B75
.text:00007B78 ; ===========================================================================
.text:00007B78
.text:00007B78 ; Segment type: Pure code
.text:00007B78 ; Segment permissions: Read/Execute
.text:00007B78 _text           segment para public 'CODE' use32
.text:00007B78                 assume cs:_text
.text:00007B78                 ;org 7B78h
.text:00007B78 ; COMDAT (pick any)
.text:00007B78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007B78
.text:00007B78 ; =============== S U B R O U T I N E =======================================
.text:00007B78
.text:00007B78 ; Attributes: bp-based frame
.text:00007B78
.text:00007B78 ; public: void __thiscall CObjectVector<struct CProperty>::Clear(void)
.text:00007B78                 public ?Clear@?$CObjectVector@UCProperty@@@@QAEXXZ
.text:00007B78 ?Clear@?$CObjectVector@UCProperty@@@@QAEXXZ proc near
.text:00007B78                                         ; CODE XREF: CObjectVector<CProperty>::operator=(CObjectVector<CProperty> const &)+52p
.text:00007B78
.text:00007B78 var_14          = dword ptr -14h
.text:00007B78 var_10          = dword ptr -10h
.text:00007B78 var_C           = dword ptr -0Ch
.text:00007B78 var_8           = dword ptr -8
.text:00007B78 var_4           = dword ptr -4
.text:00007B78
.text:00007B78                 push    ebp
.text:00007B79                 mov     ebp, esp
.text:00007B7B                 sub     esp, 14h
.text:00007B7E                 mov     eax, 0CCCCCCCCh
.text:00007B83                 mov     [ebp+var_14], eax
.text:00007B86                 mov     [ebp+var_10], eax
.text:00007B89                 mov     [ebp+var_C], eax
.text:00007B8C                 mov     [ebp+var_8], eax
.text:00007B8F                 mov     [ebp+var_4], eax
.text:00007B92                 mov     [ebp+var_4], ecx
.text:00007B95                 mov     ecx, [ebp+var_4]
.text:00007B98                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00007B9D                 mov     [ebp+var_8], eax
.text:00007BA0
.text:00007BA0 loc_7BA0:                               ; CODE XREF: CObjectVector<CProperty>::Clear(void):loc_7BE2j
.text:00007BA0                 cmp     [ebp+var_8], 0
.text:00007BA4                 jz      short loc_7BE4
.text:00007BA6                 mov     eax, [ebp+var_8]
.text:00007BA9                 sub     eax, 1
.text:00007BAC                 mov     [ebp+var_8], eax
.text:00007BAF                 mov     ecx, [ebp+var_8]
.text:00007BB2                 push    ecx
.text:00007BB3                 mov     ecx, [ebp+var_4]
.text:00007BB6                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00007BBB                 mov     edx, [eax]
.text:00007BBD                 mov     [ebp+var_10], edx
.text:00007BC0                 mov     eax, [ebp+var_10]
.text:00007BC3                 mov     [ebp+var_C], eax
.text:00007BC6                 cmp     [ebp+var_C], 0
.text:00007BCA                 jz      short loc_7BDB
.text:00007BCC                 push    1
.text:00007BCE                 mov     ecx, [ebp+var_C]
.text:00007BD1                 call    ??_GCProperty@@QAEPAXI@Z ; CProperty::`scalar deleting destructor'(uint)
.text:00007BD6                 mov     [ebp+var_14], eax
.text:00007BD9                 jmp     short loc_7BE2
.text:00007BDB ; ---------------------------------------------------------------------------
.text:00007BDB
.text:00007BDB loc_7BDB:                               ; CODE XREF: CObjectVector<CProperty>::Clear(void)+52j
.text:00007BDB                 mov     [ebp+var_14], 0
.text:00007BE2
.text:00007BE2 loc_7BE2:                               ; CODE XREF: CObjectVector<CProperty>::Clear(void)+61j
.text:00007BE2                 jmp     short loc_7BA0
.text:00007BE4 ; ---------------------------------------------------------------------------
.text:00007BE4
.text:00007BE4 loc_7BE4:                               ; CODE XREF: CObjectVector<CProperty>::Clear(void)+2Cj
.text:00007BE4                 mov     ecx, [ebp+var_4]
.text:00007BE7                 call    ?Clear@?$CRecordVector@PAX@@QAEXXZ ; CRecordVector<void *>::Clear(void)
.text:00007BEC                 add     esp, 14h
.text:00007BEF                 cmp     ebp, esp
.text:00007BF1                 call    __RTC_CheckEsp
.text:00007BF6                 mov     esp, ebp
.text:00007BF8                 pop     ebp
.text:00007BF9                 retn
.text:00007BF9 ?Clear@?$CObjectVector@UCProperty@@@@QAEXXZ endp
.text:00007BF9
.text:00007BF9 ; ---------------------------------------------------------------------------
.text:00007BFA                 align 4
.text:00007BFA _text           ends
.text:00007BFA
.text:00007BFC ; ===========================================================================
.text:00007BFC
.text:00007BFC ; Segment type: Pure code
.text:00007BFC ; Segment permissions: Read/Execute
.text:00007BFC _text           segment para public 'CODE' use32
.text:00007BFC                 assume cs:_text
.text:00007BFC                 ;org 7BFCh
.text:00007BFC ; COMDAT (pick any)
.text:00007BFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007BFC
.text:00007BFC ; =============== S U B R O U T I N E =======================================
.text:00007BFC
.text:00007BFC ; Attributes: bp-based frame
.text:00007BFC
.text:00007BFC ; public: void * __thiscall CProperty::`scalar deleting destructor'(unsigned int)
.text:00007BFC                 public ??_GCProperty@@QAEPAXI@Z
.text:00007BFC ??_GCProperty@@QAEPAXI@Z proc near      ; CODE XREF: CObjectVector<CProperty>::Clear(void)+59p
.text:00007BFC
.text:00007BFC var_4           = dword ptr -4
.text:00007BFC arg_0           = dword ptr  8
.text:00007BFC
.text:00007BFC                 push    ebp
.text:00007BFD                 mov     ebp, esp
.text:00007BFF                 push    ecx
.text:00007C00                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00007C07                 mov     [ebp+var_4], ecx
.text:00007C0A                 mov     ecx, [ebp+var_4] ; this
.text:00007C0D                 call    ??1CProperty@@QAE@XZ ; CProperty::~CProperty(void)
.text:00007C12                 mov     eax, [ebp+arg_0]
.text:00007C15                 and     eax, 1
.text:00007C18                 jz      short loc_7C26
.text:00007C1A                 mov     ecx, [ebp+var_4]
.text:00007C1D                 push    ecx             ; void *
.text:00007C1E                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00007C23                 add     esp, 4
.text:00007C26
.text:00007C26 loc_7C26:                               ; CODE XREF: CProperty::`scalar deleting destructor'(uint)+1Cj
.text:00007C26                 mov     eax, [ebp+var_4]
.text:00007C29                 add     esp, 4
.text:00007C2C                 cmp     ebp, esp
.text:00007C2E                 call    __RTC_CheckEsp
.text:00007C33                 mov     esp, ebp
.text:00007C35                 pop     ebp
.text:00007C36                 retn    4
.text:00007C36 ??_GCProperty@@QAEPAXI@Z endp
.text:00007C36
.text:00007C36 ; ---------------------------------------------------------------------------
.text:00007C39                 align 4
.text:00007C39 _text           ends
.text:00007C39
.text:00007C3C ; ===========================================================================
.text:00007C3C
.text:00007C3C ; Segment type: Pure code
.text:00007C3C ; Segment permissions: Read/Execute
.text:00007C3C _text           segment para public 'CODE' use32
.text:00007C3C                 assume cs:_text
.text:00007C3C                 ;org 7C3Ch
.text:00007C3C ; COMDAT (pick any)
.text:00007C3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007C3C
.text:00007C3C ; =============== S U B R O U T I N E =======================================
.text:00007C3C
.text:00007C3C ; Attributes: bp-based frame
.text:00007C3C
.text:00007C3C ; private: void __thiscall CRecordVector<void *>::MoveItems(unsigned int, unsigned int)
.text:00007C3C                 public ?MoveItems@?$CRecordVector@PAX@@AAEXII@Z
.text:00007C3C ?MoveItems@?$CRecordVector@PAX@@AAEXII@Z proc near
.text:00007C3C                                         ; CODE XREF: CRecordVector<void *>::Delete(uint)+1Cp
.text:00007C3C
.text:00007C3C var_4           = dword ptr -4
.text:00007C3C arg_0           = dword ptr  8
.text:00007C3C arg_4           = dword ptr  0Ch
.text:00007C3C
.text:00007C3C                 push    ebp
.text:00007C3D                 mov     ebp, esp
.text:00007C3F                 push    ecx
.text:00007C40                 push    esi
.text:00007C41                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00007C48                 mov     [ebp+var_4], ecx
.text:00007C4B                 mov     eax, [ebp+var_4]
.text:00007C4E                 mov     ecx, [eax+4]
.text:00007C51                 sub     ecx, [ebp+arg_4]
.text:00007C54                 shl     ecx, 2
.text:00007C57                 mov     esi, esp
.text:00007C59                 push    ecx             ; Size
.text:00007C5A                 mov     edx, [ebp+var_4]
.text:00007C5D                 mov     eax, [edx]
.text:00007C5F                 mov     ecx, [ebp+arg_4]
.text:00007C62                 lea     edx, [eax+ecx*4]
.text:00007C65                 push    edx             ; Src
.text:00007C66                 mov     eax, [ebp+var_4]
.text:00007C69                 mov     ecx, [eax]
.text:00007C6B                 mov     edx, [ebp+arg_0]
.text:00007C6E                 lea     eax, [ecx+edx*4]
.text:00007C71                 push    eax             ; Dst
.text:00007C72                 call    dword ptr ds:__imp__memmove
.text:00007C78                 add     esp, 0Ch
.text:00007C7B                 cmp     esi, esp
.text:00007C7D                 call    __RTC_CheckEsp
.text:00007C82                 pop     esi
.text:00007C83                 add     esp, 4
.text:00007C86                 cmp     ebp, esp
.text:00007C88                 call    __RTC_CheckEsp
.text:00007C8D                 mov     esp, ebp
.text:00007C8F                 pop     ebp
.text:00007C90                 retn    8
.text:00007C90 ?MoveItems@?$CRecordVector@PAX@@AAEXII@Z endp
.text:00007C90
.text:00007C90 ; ---------------------------------------------------------------------------
.text:00007C93                 align 4
.text:00007C93 _text           ends
.text:00007C93
.text:00007C94 ; ===========================================================================
.text:00007C94
.text:00007C94 ; Segment type: Pure code
.text:00007C94 ; Segment permissions: Read/Execute
.text:00007C94 _text           segment para public 'CODE' use32
.text:00007C94                 assume cs:_text
.text:00007C94                 ;org 7C94h
.text:00007C94 ; COMDAT (pick any)
.text:00007C94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007C94
.text:00007C94 ; =============== S U B R O U T I N E =======================================
.text:00007C94
.text:00007C94 ; Attributes: bp-based frame
.text:00007C94
.text:00007C94 ; private: void __thiscall CRecordVector<void *>::ReserveOnePosition(void)
.text:00007C94                 public ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ
.text:00007C94 ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ proc near
.text:00007C94                                         ; CODE XREF: CRecordVector<void *>::Add(void * const)+1Ap
.text:00007C94
.text:00007C94 var_14          = dword ptr -14h
.text:00007C94 var_10          = dword ptr -10h
.text:00007C94 Dst             = dword ptr -0Ch
.text:00007C94 var_8           = dword ptr -8
.text:00007C94 var_4           = dword ptr -4
.text:00007C94
.text:00007C94                 push    ebp
.text:00007C95                 mov     ebp, esp
.text:00007C97                 sub     esp, 14h
.text:00007C9A                 mov     eax, 0CCCCCCCCh
.text:00007C9F                 mov     [ebp+var_14], eax
.text:00007CA2                 mov     [ebp+var_10], eax
.text:00007CA5                 mov     [ebp+Dst], eax
.text:00007CA8                 mov     [ebp+var_8], eax
.text:00007CAB                 mov     [ebp+var_4], eax
.text:00007CAE                 mov     [ebp+var_4], ecx
.text:00007CB1                 mov     eax, [ebp+var_4]
.text:00007CB4                 mov     ecx, [ebp+var_4]
.text:00007CB7                 mov     edx, [eax+4]
.text:00007CBA                 cmp     edx, [ecx+8]
.text:00007CBD                 jnz     loc_7D48
.text:00007CC3                 mov     eax, [ebp+var_4]
.text:00007CC6                 mov     ecx, [eax+8]
.text:00007CC9                 shr     ecx, 2
.text:00007CCC                 mov     edx, [ebp+var_4]
.text:00007CCF                 mov     eax, [edx+8]
.text:00007CD2                 lea     ecx, [eax+ecx+1]
.text:00007CD6                 mov     [ebp+var_8], ecx
.text:00007CD9                 xor     ecx, ecx
.text:00007CDB                 mov     eax, [ebp+var_8]
.text:00007CDE                 mov     edx, 4
.text:00007CE3                 mul     edx
.text:00007CE5                 seto    cl
.text:00007CE8                 neg     ecx
.text:00007CEA                 or      ecx, eax
.text:00007CEC                 push    ecx             ; unsigned int
.text:00007CED                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00007CF2                 add     esp, 4
.text:00007CF5                 mov     [ebp+var_10], eax
.text:00007CF8                 mov     eax, [ebp+var_10]
.text:00007CFB                 mov     [ebp+Dst], eax
.text:00007CFE                 mov     ecx, [ebp+var_4]
.text:00007D01                 cmp     dword ptr [ecx+4], 0
.text:00007D05                 jz      short loc_7D23
.text:00007D07                 mov     edx, [ebp+var_4]
.text:00007D0A                 mov     eax, [edx+4]
.text:00007D0D                 shl     eax, 2
.text:00007D10                 push    eax             ; Size
.text:00007D11                 mov     ecx, [ebp+var_4]
.text:00007D14                 mov     edx, [ecx]
.text:00007D16                 push    edx             ; Src
.text:00007D17                 mov     eax, [ebp+Dst]
.text:00007D1A                 push    eax             ; Dst
.text:00007D1B                 call    _memcpy
.text:00007D20                 add     esp, 0Ch
.text:00007D23
.text:00007D23 loc_7D23:                               ; CODE XREF: CRecordVector<void *>::ReserveOnePosition(void)+71j
.text:00007D23                 mov     ecx, [ebp+var_4]
.text:00007D26                 mov     edx, [ecx]
.text:00007D28                 mov     [ebp+var_14], edx
.text:00007D2B                 mov     eax, [ebp+var_14]
.text:00007D2E                 push    eax             ; void *
.text:00007D2F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00007D34                 add     esp, 4
.text:00007D37                 mov     ecx, [ebp+var_4]
.text:00007D3A                 mov     edx, [ebp+Dst]
.text:00007D3D                 mov     [ecx], edx
.text:00007D3F                 mov     eax, [ebp+var_4]
.text:00007D42                 mov     ecx, [ebp+var_8]
.text:00007D45                 mov     [eax+8], ecx
.text:00007D48
.text:00007D48 loc_7D48:                               ; CODE XREF: CRecordVector<void *>::ReserveOnePosition(void)+29j
.text:00007D48                 add     esp, 14h
.text:00007D4B                 cmp     ebp, esp
.text:00007D4D                 call    __RTC_CheckEsp
.text:00007D52                 mov     esp, ebp
.text:00007D54                 pop     ebp
.text:00007D55                 retn
.text:00007D55 ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ endp
.text:00007D55
.text:00007D55 ; ---------------------------------------------------------------------------
.text:00007D56                 align 4
.text:00007D56 _text           ends
.text:00007D56
.text:00007D58 ; ===========================================================================
.text:00007D58
.text:00007D58 ; Segment type: Pure code
.text:00007D58 ; Segment permissions: Read/Execute
.text:00007D58 _text           segment para public 'CODE' use32
.text:00007D58                 assume cs:_text
.text:00007D58                 ;org 7D58h
.text:00007D58 ; COMDAT (pick any)
.text:00007D58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007D58
.text:00007D58 ; =============== S U B R O U T I N E =======================================
.text:00007D58
.text:00007D58 ; Attributes: bp-based frame
.text:00007D58
.text:00007D58 ; public: void __thiscall CRecordVector<void *>::ConstructReserve(unsigned int)
.text:00007D58                 public ?ConstructReserve@?$CRecordVector@PAX@@QAEXI@Z
.text:00007D58 ?ConstructReserve@?$CRecordVector@PAX@@QAEXI@Z proc near
.text:00007D58                                         ; CODE XREF: CObjectVector<UString>::CObjectVector<UString>(CObjectVector<UString> const &)+60p
.text:00007D58
.text:00007D58 var_8           = dword ptr -8
.text:00007D58 var_4           = dword ptr -4
.text:00007D58 arg_0           = dword ptr  8
.text:00007D58
.text:00007D58                 push    ebp
.text:00007D59                 mov     ebp, esp
.text:00007D5B                 sub     esp, 8
.text:00007D5E                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00007D65                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00007D6C                 mov     [ebp+var_4], ecx
.text:00007D6F                 cmp     [ebp+arg_0], 0
.text:00007D73                 jz      short loc_7DA5
.text:00007D75                 xor     ecx, ecx
.text:00007D77                 mov     eax, [ebp+arg_0]
.text:00007D7A                 mov     edx, 4
.text:00007D7F                 mul     edx
.text:00007D81                 seto    cl
.text:00007D84                 neg     ecx
.text:00007D86                 or      ecx, eax
.text:00007D88                 push    ecx             ; unsigned int
.text:00007D89                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00007D8E                 add     esp, 4
.text:00007D91                 mov     [ebp+var_8], eax
.text:00007D94                 mov     eax, [ebp+var_4]
.text:00007D97                 mov     ecx, [ebp+var_8]
.text:00007D9A                 mov     [eax], ecx
.text:00007D9C                 mov     edx, [ebp+var_4]
.text:00007D9F                 mov     eax, [ebp+arg_0]
.text:00007DA2                 mov     [edx+8], eax
.text:00007DA5
.text:00007DA5 loc_7DA5:                               ; CODE XREF: CRecordVector<void *>::ConstructReserve(uint)+1Bj
.text:00007DA5                 add     esp, 8
.text:00007DA8                 cmp     ebp, esp
.text:00007DAA                 call    __RTC_CheckEsp
.text:00007DAF                 mov     esp, ebp
.text:00007DB1                 pop     ebp
.text:00007DB2                 retn    4
.text:00007DB2 ?ConstructReserve@?$CRecordVector@PAX@@QAEXI@Z endp
.text:00007DB2
.text:00007DB2 ; ---------------------------------------------------------------------------
.text:00007DB5                 align 4
.text:00007DB5 _text           ends
.text:00007DB5
.text$yc:00007DB8 ; ===========================================================================
.text$yc:00007DB8
.text$yc:00007DB8 ; Segment type: Pure code
.text$yc:00007DB8 ; Segment permissions: Read/Execute
.text$yc:00007DB8 _text$yc        segment para public 'CODE' use32
.text$yc:00007DB8                 assume cs:_text$yc
.text$yc:00007DB8                 ;org 7DB8h
.text$yc:00007DB8 ; COMDAT (pick any)
.text$yc:00007DB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yc:00007DB8
.text$yc:00007DB8 ; =============== S U B R O U T I N E =======================================
.text$yc:00007DB8
.text$yc:00007DB8 ; Attributes: bp-based frame
.text$yc:00007DB8
.text$yc:00007DB8 ; void __cdecl `dynamic initializer for 'kSwitchForms''(void)
.text$yc:00007DB8 ??__EkSwitchForms@@YAXXZ proc near      ; DATA XREF: .CRT$XCU:_kSwitchForms$initializer$o
.text$yc:00007DB8                 push    ebp
.text$yc:00007DB9                 mov     ebp, esp
.text$yc:00007DBB                 mov     eax, ds:_k_Stream_PostCharSet
.text$yc:00007DC0                 mov     ds:dword_65C, eax
.text$yc:00007DC5                 mov     ds:dword_660, offset $SG76900
.text$yc:00007DCF                 mov     ds:byte_664, 3
.text$yc:00007DD6                 mov     ds:byte_665, 0
.text$yc:00007DDD                 mov     ds:byte_666, 1
.text$yc:00007DE4                 mov     ecx, ds:_k_Stream_PostCharSet
.text$yc:00007DEA                 mov     ds:dword_668, ecx
.text$yc:00007DF0                 mov     ds:dword_66C, offset $SG76901
.text$yc:00007DFA                 mov     ds:byte_670, 3
.text$yc:00007E01                 mov     ds:byte_671, 0
.text$yc:00007E08                 mov     ds:byte_672, 1
.text$yc:00007E0F                 mov     edx, ds:_k_Stream_PostCharSet
.text$yc:00007E15                 mov     ds:dword_674, edx
.text$yc:00007E1B                 mov     ds:dword_678, offset $SG76902
.text$yc:00007E25                 xor     eax, eax
.text$yc:00007E27                 mov     ds:dword_67C, eax
.text$yc:00007E2C                 mov     ds:dword_680, eax
.text$yc:00007E31                 mov     ds:dword_684, offset $SG76903
.text$yc:00007E3B                 xor     ecx, ecx
.text$yc:00007E3D                 mov     ds:dword_688, ecx
.text$yc:00007E43                 mov     ds:dword_68C, ecx
.text$yc:00007E49                 mov     ds:dword_690, offset $SG76904
.text$yc:00007E53                 mov     ds:byte_694, 3
.text$yc:00007E5A                 mov     ds:byte_695, 0
.text$yc:00007E61                 mov     ds:byte_696, 1
.text$yc:00007E68                 mov     edx, ds:_kOverwritePostCharSet
.text$yc:00007E6E                 mov     ds:dword_698, edx
.text$yc:00007E74                 mov     ds:dword_69C, offset $SG76905
.text$yc:00007E7E                 mov     ds:byte_6A0, 2
.text$yc:00007E85                 mov     ds:byte_6A1, 0
.text$yc:00007E8C                 mov     ds:byte_6A2, 1
.text$yc:00007E93                 xor     eax, eax
.text$yc:00007E95                 mov     ds:dword_6A4, eax
.text$yc:00007E9A                 mov     ds:dword_6A8, offset $SG76906
.text$yc:00007EA4                 mov     ds:byte_6AC, 2
.text$yc:00007EAB                 mov     ds:byte_6AD, 1
.text$yc:00007EB2                 mov     ds:byte_6AE, 1
.text$yc:00007EB9                 xor     ecx, ecx
.text$yc:00007EBB                 mov     ds:dword_6B0, ecx
.text$yc:00007EC1                 mov     ds:dword_6B4, offset $SG76907
.text$yc:00007ECB                 mov     ds:byte_6B8, 2
.text$yc:00007ED2                 mov     ds:byte_6B9, 1
.text$yc:00007ED9                 mov     ds:byte_6BA, 1
.text$yc:00007EE0                 xor     edx, edx
.text$yc:00007EE2                 mov     ds:dword_6BC, edx
.text$yc:00007EE8                 mov     ds:dword_6C0, offset $SG76908
.text$yc:00007EF2                 mov     ds:byte_6C4, 2
.text$yc:00007EF9                 mov     ds:byte_6C5, 0
.text$yc:00007F00                 mov     ds:byte_6C6, 1
.text$yc:00007F07                 xor     eax, eax
.text$yc:00007F09                 mov     ds:dword_6C8, eax
.text$yc:00007F0E                 mov     ds:dword_6CC, offset $SG76909
.text$yc:00007F18                 mov     ds:byte_6D0, 2
.text$yc:00007F1F                 xor     ecx, ecx
.text$yc:00007F21                 mov     ds:dword_6D1, ecx
.text$yc:00007F27                 mov     ds:word_6D5, cx
.text$yc:00007F2E                 mov     ds:byte_6D7, cl
.text$yc:00007F34                 mov     ds:dword_6D8, offset $SG76910
.text$yc:00007F3E                 mov     ds:byte_6DC, 2
.text$yc:00007F45                 mov     ds:byte_6DD, 1
.text$yc:00007F4C                 mov     ds:byte_6DE, 2
.text$yc:00007F53                 xor     edx, edx
.text$yc:00007F55                 mov     ds:dword_6E0, edx
.text$yc:00007F5B                 mov     ds:dword_6E4, offset $SG76911
.text$yc:00007F65                 mov     ds:byte_6E8, 2
.text$yc:00007F6C                 mov     ds:byte_6E9, 1
.text$yc:00007F73                 mov     ds:byte_6EA, 2
.text$yc:00007F7A                 xor     eax, eax
.text$yc:00007F7C                 mov     ds:dword_6EC, eax
.text$yc:00007F81                 mov     ds:dword_6F0, offset $SG76912
.text$yc:00007F8B                 mov     ds:byte_6F4, 2
.text$yc:00007F92                 mov     ds:byte_6F5, 1
.text$yc:00007F99                 mov     ds:byte_6F6, 2
.text$yc:00007FA0                 xor     ecx, ecx
.text$yc:00007FA2                 mov     ds:dword_6F8, ecx
.text$yc:00007FA8                 mov     ds:dword_6FC, offset $SG76913
.text$yc:00007FB2                 mov     ds:byte_700, 2
.text$yc:00007FB9                 mov     ds:byte_701, 1
.text$yc:00007FC0                 mov     ds:byte_702, 2
.text$yc:00007FC7                 xor     edx, edx
.text$yc:00007FC9                 mov     ds:dword_704, edx
.text$yc:00007FCF                 mov     ds:dword_708, offset $SG76914
.text$yc:00007FD9                 xor     eax, eax
.text$yc:00007FDB                 mov     ds:dword_70C, eax
.text$yc:00007FE0                 mov     ds:dword_710, eax
.text$yc:00007FE5                 mov     ds:dword_714, offset $SG76915
.text$yc:00007FEF                 mov     ds:byte_718, 2
.text$yc:00007FF6                 mov     ds:byte_719, 1
.text$yc:00007FFD                 mov     ds:byte_71A, 1
.text$yc:00008004                 xor     ecx, ecx
.text$yc:00008006                 mov     ds:dword_71C, ecx
.text$yc:0000800C                 mov     ds:dword_720, offset $SG76916
.text$yc:00008016                 mov     ds:byte_724, 2
.text$yc:0000801D                 mov     ds:byte_725, 1
.text$yc:00008024                 mov     ds:byte_726, 1
.text$yc:0000802B                 xor     edx, edx
.text$yc:0000802D                 mov     ds:dword_728, edx
.text$yc:00008033                 mov     ds:dword_72C, offset $SG76917
.text$yc:0000803D                 mov     ds:byte_730, 3
.text$yc:00008044                 mov     ds:byte_731, 0
.text$yc:0000804B                 mov     ds:byte_732, 0
.text$yc:00008052                 mov     eax, ds:_kRecursedPostCharSet
.text$yc:00008057                 mov     ds:dword_734, eax
.text$yc:0000805C                 mov     ds:dword_738, offset $SG76918 ; "stm"
.text$yc:00008066                 mov     ds:byte_73C, 2
.text$yc:0000806D                 xor     ecx, ecx
.text$yc:0000806F                 mov     ds:dword_73D, ecx
.text$yc:00008075                 mov     ds:word_741, cx
.text$yc:0000807C                 mov     ds:byte_743, cl
.text$yc:00008082                 mov     ds:dword_744, offset $SG76919 ; "sfx"
.text$yc:0000808C                 mov     ds:byte_748, 2
.text$yc:00008093                 xor     edx, edx
.text$yc:00008095                 mov     ds:dword_749, edx
.text$yc:0000809B                 mov     ds:word_74D, dx
.text$yc:000080A2                 mov     ds:byte_74F, dl
.text$yc:000080A8                 mov     ds:dword_750, offset $SG76920 ; "seml"
.text$yc:000080B2                 mov     ds:byte_754, 2
.text$yc:000080B9                 mov     ds:byte_755, 0
.text$yc:000080C0                 mov     ds:byte_756, 0
.text$yc:000080C7                 xor     eax, eax
.text$yc:000080C9                 mov     ds:dword_758, eax
.text$yc:000080CE                 mov     ds:dword_75C, offset $SG76921 ; "scrc"
.text$yc:000080D8                 mov     ds:byte_760, 2
.text$yc:000080DF                 mov     ds:byte_761, 1
.text$yc:000080E6                 mov     ds:byte_762, 0
.text$yc:000080ED                 xor     ecx, ecx
.text$yc:000080EF                 mov     ds:dword_764, ecx
.text$yc:000080F5                 mov     ds:dword_768, offset $SG76922
.text$yc:000080FF                 mov     ds:byte_76C, 2
.text$yc:00008106                 xor     edx, edx
.text$yc:00008108                 mov     ds:dword_76D, edx
.text$yc:0000810E                 mov     ds:word_771, dx
.text$yc:00008115                 mov     ds:byte_773, dl
.text$yc:0000811B                 mov     ds:dword_774, offset $SG76923
.text$yc:00008125                 xor     eax, eax
.text$yc:00008127                 mov     ds:dword_778, eax
.text$yc:0000812C                 mov     ds:dword_77C, eax
.text$yc:00008131                 mov     ds:dword_780, offset $SG76924
.text$yc:0000813B                 mov     ds:byte_784, 1
.text$yc:00008142                 xor     ecx, ecx
.text$yc:00008144                 mov     ds:dword_785, ecx
.text$yc:0000814A                 mov     ds:word_789, cx
.text$yc:00008151                 mov     ds:byte_78B, cl
.text$yc:00008157                 mov     ds:dword_78C, offset $SG76925
.text$yc:00008161                 mov     ds:byte_790, 2
.text$yc:00008168                 xor     edx, edx
.text$yc:0000816A                 mov     ds:dword_791, edx
.text$yc:00008170                 mov     ds:word_795, dx
.text$yc:00008177                 mov     ds:byte_797, dl
.text$yc:0000817D                 mov     ds:dword_798, offset $SG76926
.text$yc:00008187                 mov     ds:byte_79C, 2
.text$yc:0000818E                 xor     eax, eax
.text$yc:00008190                 mov     ds:dword_79D, eax
.text$yc:00008195                 mov     ds:word_7A1, ax
.text$yc:0000819B                 mov     ds:byte_7A3, al
.text$yc:000081A0                 mov     ds:dword_7A4, offset $SG76927
.text$yc:000081AA                 xor     ecx, ecx
.text$yc:000081AC                 mov     ds:dword_7A8, ecx
.text$yc:000081B2                 mov     ds:dword_7AC, ecx
.text$yc:000081B8                 mov     ds:dword_7B0, offset $SG76928
.text$yc:000081C2                 xor     edx, edx
.text$yc:000081C4                 mov     ds:dword_7B4, edx
.text$yc:000081CA                 mov     ds:dword_7B8, edx
.text$yc:000081D0                 mov     ds:dword_7BC, offset $SG76929
.text$yc:000081DA                 mov     ds:byte_7C0, 1
.text$yc:000081E1                 xor     eax, eax
.text$yc:000081E3                 mov     ds:dword_7C1, eax
.text$yc:000081E8                 mov     ds:word_7C5, ax
.text$yc:000081EE                 mov     ds:byte_7C7, al
.text$yc:000081F3                 mov     ds:dword_7C8, offset $SG76930
.text$yc:000081FD                 mov     ds:byte_7CC, 3
.text$yc:00008204                 mov     ds:byte_7CD, 0
.text$yc:0000820B                 mov     ds:byte_7CE, 1
.text$yc:00008212                 mov     ecx, ds:_k_ArcNameMode_PostCharSet
.text$yc:00008218                 mov     ds:dword_7D0, ecx
.text$yc:0000821E                 mov     ds:dword_7D4, offset $SG76931 ; "spd"
.text$yc:00008228                 xor     edx, edx
.text$yc:0000822A                 mov     ds:dword_7D8, edx
.text$yc:00008230                 mov     ds:dword_7DC, edx
.text$yc:00008236                 mov     ds:dword_7E0, offset $SG76932 ; "spe"
.text$yc:00008240                 mov     ds:byte_7E4, 1
.text$yc:00008247                 xor     eax, eax
.text$yc:00008249                 mov     ds:dword_7E5, eax
.text$yc:0000824E                 mov     ds:word_7E9, ax
.text$yc:00008254                 mov     ds:byte_7EB, al
.text$yc:00008259                 mov     ds:dword_7EC, offset $SG76933 ; "spf"
.text$yc:00008263                 mov     ds:byte_7F0, 2
.text$yc:0000826A                 mov     ds:byte_7F1, 0
.text$yc:00008271                 mov     ds:byte_7F2, 0
.text$yc:00008278                 xor     ecx, ecx
.text$yc:0000827A                 mov     ds:dword_7F4, ecx
.text$yc:00008280                 mov     ds:dword_7F8, offset $SG76934 ; "snh"
.text$yc:0000828A                 mov     ds:byte_7FC, 1
.text$yc:00008291                 xor     edx, edx
.text$yc:00008293                 mov     ds:dword_7FD, edx
.text$yc:00008299                 mov     ds:word_801, dx
.text$yc:000082A0                 mov     ds:byte_803, dl
.text$yc:000082A6                 mov     ds:dword_804, offset $SG76935 ; "snl"
.text$yc:000082B0                 mov     ds:byte_808, 1
.text$yc:000082B7                 xor     eax, eax
.text$yc:000082B9                 mov     ds:dword_809, eax
.text$yc:000082BE                 mov     ds:word_80D, ax
.text$yc:000082C4                 mov     ds:byte_80F, al
.text$yc:000082C9                 mov     ds:dword_810, offset $SG76936 ; "sni"
.text$yc:000082D3                 xor     ecx, ecx
.text$yc:000082D5                 mov     ds:dword_814, ecx
.text$yc:000082DB                 mov     ds:dword_818, ecx
.text$yc:000082E1                 mov     ds:dword_81C, offset $SG76937 ; "sns"
.text$yc:000082EB                 mov     ds:byte_820, 1
.text$yc:000082F2                 xor     edx, edx
.text$yc:000082F4                 mov     ds:dword_821, edx
.text$yc:000082FA                 mov     ds:word_825, dx
.text$yc:00008301                 mov     ds:byte_827, dl
.text$yc:00008307                 mov     ds:dword_828, offset $SG76938 ; "snr"
.text$yc:00008311                 xor     eax, eax
.text$yc:00008313                 mov     ds:dword_82C, eax
.text$yc:00008318                 mov     ds:dword_830, eax
.text$yc:0000831D                 mov     ds:dword_834, offset $SG76939 ; "snc"
.text$yc:00008327                 xor     ecx, ecx
.text$yc:00008329                 mov     ds:dword_838, ecx
.text$yc:0000832F                 mov     ds:dword_83C, ecx
.text$yc:00008335                 mov     ds:dword_840, offset $SG76940 ; "sdel"
.text$yc:0000833F                 xor     edx, edx
.text$yc:00008341                 mov     ds:dword_844, edx
.text$yc:00008347                 mov     ds:dword_848, edx
.text$yc:0000834D                 mov     ds:dword_84C, offset $SG76941
.text$yc:00008357                 xor     eax, eax
.text$yc:00008359                 mov     ds:dword_850, eax
.text$yc:0000835E                 mov     ds:dword_854, eax
.text$yc:00008363                 mov     ds:dword_858, offset $SG76942
.text$yc:0000836D                 mov     ds:byte_85C, 2
.text$yc:00008374                 xor     ecx, ecx
.text$yc:00008376                 mov     ds:dword_85D, ecx
.text$yc:0000837C                 mov     ds:word_861, cx
.text$yc:00008383                 mov     ds:byte_863, cl
.text$yc:00008389                 pop     ebp
.text$yc:0000838A                 retn
.text$yc:0000838A ??__EkSwitchForms@@YAXXZ endp
.text$yc:0000838A
.text$yc:0000838A ; ---------------------------------------------------------------------------
.text$yc:0000838B                 align 4
.text$yc:0000838B _text$yc        ends
.text$yc:0000838B
.CRT$XCU:0000838C ; ===========================================================================
.CRT$XCU:0000838C
.CRT$XCU:0000838C ; Segment type: Pure data
.CRT$XCU:0000838C ; Segment permissions: Read
.CRT$XCU:0000838C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000838C                 assume cs:_CRT$XCU
.CRT$XCU:0000838C                 ;org 838Ch
.CRT$XCU:0000838C _kSwitchForms$initializer$ dd offset ??__EkSwitchForms@@YAXXZ ; `dynamic initializer for 'kSwitchForms''(void)
.CRT$XCU:0000838C _CRT$XCU        ends
.CRT$XCU:0000838C
UNDEF:00008390 ; ===========================================================================
UNDEF:00008390
UNDEF:00008390 ; Segment type: Externs
UNDEF:00008390 ; UNDEF
UNDEF:00008390 ; public: class UString & __thiscall UString::operator+=(wchar_t const *)
UNDEF:00008390                 extrn ??YUString@@QAEAAV0@PB_W@Z:near
UNDEF:00008390                                         ; CODE XREF: CArcCmdLineException::CArcCmdLineException(char const *,wchar_t const *)+BCp
UNDEF:00008394 ; void __thiscall UString::Add_LF(UString *__hidden this)
UNDEF:00008394                 extrn ?Add_LF@UString@@QAEXXZ:near
UNDEF:00008394                                         ; CODE XREF: CArcCmdLineException::CArcCmdLineException(char const *,wchar_t const *)+B0p
UNDEF:00008394                                         ; AddRenamePair(CObjectVector<CRenamePair> *,UString const &,UString const &,NRecursedType::EEnum,bool)+AEp ...
UNDEF:00008398 ; public: class UString & __thiscall UString::operator+=(class UString const &)
UNDEF:00008398                 extrn ??YUString@@QAEAAV0@ABV0@@Z:near
UNDEF:00008398                                         ; CODE XREF: CArcCmdLineException::CArcCmdLineException(char const *,wchar_t const *)+8Ap
UNDEF:00008398                                         ; AddRenamePair(CObjectVector<CRenamePair> *,UString const &,UString const &,NRecursedType::EEnum,bool)+A6p ...
UNDEF:0000839C ; struct UString __stdcall __high MultiByteToUnicodeString(const struct AString *, unsigned int)
UNDEF:0000839C                 extrn ?MultiByteToUnicodeString@@YG?AVUString@@ABVAString@@I@Z:near
UNDEF:0000839C                                         ; CODE XREF: CArcCmdLineException::CArcCmdLineException(char const *,wchar_t const *)+71p
UNDEF:000083A0 ; public: __thiscall AString::AString(char const *)
UNDEF:000083A0                 extrn ??0AString@@QAE@PBD@Z:near
UNDEF:000083A0                                         ; CODE XREF: CArcCmdLineException::CArcCmdLineException(char const *,wchar_t const *)+5Ep
UNDEF:000083A4 ; public: __thiscall UString::UString(void)
UNDEF:000083A4                 extrn ??0UString@@QAE@XZ:near
UNDEF:000083A4                                         ; CODE XREF: CArcCmdLineException::CArcCmdLineException(char const *,wchar_t const *)+4Bp
UNDEF:000083A4                                         ; EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *)+202p ...
UNDEF:000083A8                 extrn ___security_cookie:near
UNDEF:000083A8                                         ; DATA XREF: CArcCmdLineException::CArcCmdLineException(char const *,wchar_t const *)+34r
UNDEF:000083A8                                         ; ConvertToLongNames(UString const &,NWildcard::CCensorNode &)+24r ...
UNDEF:000083AC                 extrn ___CxxFrameHandler3:near
UNDEF:000083AC                                         ; CODE XREF: __ehhandler$??0CArcCmdLineException@@QAE@PBDPB_W@Z+16j
UNDEF:000083AC                                         ; __ehhandler$?ConvertToLongNames@@YGXABVUString@@AAVCCensorNode@NWildcard@@@Z+16j ...
UNDEF:000083B0 ; __fastcall __security_check_cookie(x)
UNDEF:000083B0                 extrn @__security_check_cookie@4:near
UNDEF:000083B0                                         ; CODE XREF: SetAddCommandOptions(NCommandType::EEnum,NCommandLineParser::CParser const &,CUpdateOptions &)+2CFp
UNDEF:000083B0                                         ; ParseUpdateCommandString(CUpdateOptions &,CObjectVector<UString> const &,NUpdateArchive::CActionSet const &)+28Ap ...
UNDEF:000083B4                 extrn __RTC_CheckEsp:near
UNDEF:000083B4                                         ; CODE XREF: CArcCmdLineException::CArcCmdLineException(char const *,wchar_t const *)+DBp
UNDEF:000083B4                                         ; ConvertToLongNames(NWildcard::CCensor &)+59p ...
UNDEF:000083B8                 extrn __RTC_Shutdown:near
UNDEF:000083B8                                         ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
UNDEF:000083BC                 extrn __RTC_InitBase:near
UNDEF:000083BC                                         ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
UNDEF:000083C0 ; void __cdecl operator delete(void *)
UNDEF:000083C0                 extrn ??3@YAXPAX@Z:near ; CODE XREF: AString::~AString(void)+23p
UNDEF:000083C0                                         ; UString::~UString(void)+23p ...
UNDEF:000083C4 ; class UString __stdcall operator+(class UString const &, class UString const &)
UNDEF:000083C4                 extrn ??H@YG?AVUString@@ABV0@0@Z:near
UNDEF:000083C4                                         ; CODE XREF: ConvertToLongNames(UString const &,NWildcard::CCensorNode &)+1D0p
UNDEF:000083C4                                         ; ConvertToLongName(UString const &,UString &)+74p
UNDEF:000083C8 ; bool NWildcard::IsDriveColonName(NWildcard *__hidden this, const wchar_t *)
UNDEF:000083C8                 extrn ?IsDriveColonName@NWildcard@@YG_NPB_W@Z:near
UNDEF:000083C8                                         ; CODE XREF: ConvertToLongNames(UString const &,NWildcard::CCensorNode &)+A4p
UNDEF:000083C8                                         ; NWildcard::CItem::IsDriveItem(void)+4Cp
UNDEF:000083CC ; private: __thiscall UString::UString(class UString const &, wchar_t)
UNDEF:000083CC                 extrn ??0UString@@AAE@ABV0@_W@Z:near
UNDEF:000083CC                                         ; CODE XREF: operator+(UString const &,wchar_t)+1Ep
UNDEF:000083D0 ; bool __stdcall StringsAreEqualNoCase(const wchar_t *, const wchar_t *)
UNDEF:000083D0                 extrn ?StringsAreEqualNoCase@@YG_NPB_W0@Z:near
UNDEF:000083D0                                         ; CODE XREF: UString::IsEqualTo_NoCase(wchar_t const *)+18p
UNDEF:000083D4 ; public: class UString & __thiscall UString::operator=(class UString const &)
UNDEF:000083D4                 extrn ??4UString@@QAEAAV0@ABV0@@Z:near
UNDEF:000083D4                                         ; CODE XREF: ConvertToLongName(UString const &,UString &)+CEp
UNDEF:000083D4                                         ; CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+3C7p ...
UNDEF:000083D8 ; bool __thiscall NWindows::NFile::NFind::CFileInfo::Find(NWindows::NFile::NFind::CFileInfo *__hidden this, const wchar_t *)
UNDEF:000083D8                 extrn ?Find@CFileInfo@NFind@NFile@NWindows@@QAE_NPB_W@Z:near
UNDEF:000083D8                                         ; CODE XREF: ConvertToLongName(UString const &,UString &)+BBp
UNDEF:000083DC ; bool NWindows::NFile::NName::IsDevicePath(NWindows::NFile::NName *__hidden this, const wchar_t *)
UNDEF:000083DC                 extrn ?IsDevicePath@NName@NFile@NWindows@@YG_NPB_W@Z:near
UNDEF:000083DC                                         ; CODE XREF: ConvertToLongName(UString const &,UString &)+86p
UNDEF:000083E0 ; bool __stdcall DoesNameContainWildcard(const struct UString *)
UNDEF:000083E0                 extrn ?DoesNameContainWildcard@@YG_NABVUString@@@Z:near
UNDEF:000083E0                                         ; CODE XREF: ConvertToLongName(UString const &,UString &)+48p
UNDEF:000083E0                                         ; AddNameToCensor(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)+30p
UNDEF:000083E4 ; __fastcall _RTC_CheckStackVars(x, x)
UNDEF:000083E4                 extrn @_RTC_CheckStackVars@8:near
UNDEF:000083E4                                         ; CODE XREF: ConvertToLongName(UString const &,UString &)+F8p
UNDEF:000083E4                                         ; CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+4A2p ...
UNDEF:000083E8 ; void __thiscall NWindows::NFile::NFind::CFileInfoBase::ClearBase(NWindows::NFile::NFind::CFileInfoBase *__hidden this)
UNDEF:000083E8                 extrn ?ClearBase@CFileInfoBase@NFind@NFile@NWindows@@QAEXXZ:near
UNDEF:000083E8                                         ; CODE XREF: NWindows::NFile::NFind::CFileInfoBase::CFileInfoBase(void)+11p
UNDEF:000083EC ; _DWORD __thiscall NCommandLineParser::CParser::CParser(NCommandLineParser::CParser *__hidden this, unsigned int)
UNDEF:000083EC                 extrn ??0CParser@NCommandLineParser@@QAE@I@Z:near
UNDEF:000083EC                                         ; CODE XREF: CArcCmdLineParser::CArcCmdLineParser(void)+13p
UNDEF:000083F0 ; BOOL __stdcall SetProcessAffinityMask(HANDLE hProcess, DWORD_PTR dwProcessAffinityMask)
UNDEF:000083F0                 extrn __imp__SetProcessAffinityMask@8:near
UNDEF:000083F0                                         ; CODE XREF: CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+47Cp
UNDEF:000083F0                                         ; DATA XREF: CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+47Cr
UNDEF:000083F4 ; HANDLE __stdcall GetCurrentProcess()
UNDEF:000083F4                 extrn __imp__GetCurrentProcess@0:near
UNDEF:000083F4                                         ; CODE XREF: CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+46Ep
UNDEF:000083F4                                         ; DATA XREF: CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+46Er
UNDEF:000083F8 ; unsigned int __stdcall ConvertHexStringToUInt32(const char *, const char **)
UNDEF:000083F8                 extrn ?ConvertHexStringToUInt32@@YGIPBDPAPBD@Z:near
UNDEF:000083F8                                         ; CODE XREF: CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+419p
UNDEF:000083FC ; void __thiscall AString::SetFromWStr_if_Ascii(AString *__hidden this, const wchar_t *)
UNDEF:000083FC                 extrn ?SetFromWStr_if_Ascii@AString@@QAEXPB_W@Z:near
UNDEF:000083FC                                         ; CODE XREF: CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+3F8p
UNDEF:00008400 ; public: __thiscall AString::AString(void)
UNDEF:00008400                 extrn ??0AString@@QAE@XZ:near
UNDEF:00008400                                         ; CODE XREF: CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+3E0p
UNDEF:00008404 ; bool g_CaseSensitive
UNDEF:00008404                 extrn ?g_CaseSensitive@@3_NA:near
UNDEF:00008404                                         ; DATA XREF: CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+34Bw
UNDEF:00008404                                         ; CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+35Ar
UNDEF:00008408                 extrn __imp___isatty:near
UNDEF:00008408                                         ; CODE XREF: CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+A6p
UNDEF:00008408                                         ; CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+EAp ...
UNDEF:0000840C ; int __cdecl __fileno(FILE *File)
UNDEF:0000840C                 extrn __imp___fileno:near
UNDEF:0000840C                                         ; CODE XREF: CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+93p
UNDEF:0000840C                                         ; CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+D7p ...
UNDEF:00008410 ; FILE *__cdecl ___iob_func()
UNDEF:00008410                 extrn __imp____iob_func:near
UNDEF:00008410                                         ; CODE XREF: CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+83p
UNDEF:00008410                                         ; CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+C4p ...
UNDEF:00008414 ; public: bool __thiscall NCommandLineParser::CParser::ParseStrings(struct NCommandLineParser::CSwitchForm const *, class CObjectVector<class UString> const &)
UNDEF:00008414                 extrn ?ParseStrings@CParser@NCommandLineParser@@QAE_NPBUCSwitchForm@2@ABV?$CObjectVector@VUString@@@@@Z:near
UNDEF:00008414                                         ; CODE XREF: CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+47p
UNDEF:00008418 ; __stdcall _CxxThrowException(x, x)
UNDEF:00008418                 extrn __CxxThrowException@8:near
UNDEF:00008418                                         ; CODE XREF: CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+7Cp
UNDEF:00008418                                         ; CArcCmdLineParser::Parse1(CObjectVector<UString> const &,CArcCmdLineOptions &)+314p ...
UNDEF:0000841C ; const type_info::`vftable'
UNDEF:0000841C                 extrn ??_7type_info@@6B@:near
UNDEF:0000841C                                         ; DATA XREF: .data:CArcCmdLineException `RTTI Type Descriptor'o
UNDEF:0000841C                                         ; .data:UString `RTTI Type Descriptor'o ...
UNDEF:00008420 ; public: __thiscall UString::UString(class UString const &)
UNDEF:00008420                 extrn ??0UString@@QAE@ABV0@@Z:near
UNDEF:00008420                                         ; CODE XREF: ParseArchiveCommand(UString const &,CArcCommand &)+49p
UNDEF:00008420                                         ; ParseMapWithPaths(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)+42p ...
UNDEF:00008424 ; unsigned int __stdcall ConvertStringToUInt32(const wchar_t *, const wchar_t **)
UNDEF:00008424                 extrn ?ConvertStringToUInt32@@YGIPB_WPAPB_W@Z:near
UNDEF:00008424                                         ; CODE XREF: StringToUInt32(wchar_t const *,uint &)+31p
UNDEF:00008428 ; int __stdcall CompareFileNames(const wchar_t *, const wchar_t *)
UNDEF:00008428                 extrn ?CompareFileNames@@YGHPB_W0@Z:near
UNDEF:00008428                                         ; CODE XREF: EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *)+354p
UNDEF:0000842C ; void __stdcall SortFileNames(class CObjectVector<class UString> const &, class CRecordVector<unsigned int> &)
UNDEF:0000842C                 extrn ?SortFileNames@@YGXABV?$CObjectVector@VUString@@@@AAV?$CRecordVector@I@@@Z:near
UNDEF:0000842C                                         ; CODE XREF: EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *)+26Ep
UNDEF:00008430 ; bool NWindows::NFile::NDir::MyGetFullPathName(NWindows::NFile::NDir *__hidden this, const wchar_t *, struct UString *)
UNDEF:00008430                 extrn ?MyGetFullPathName@NDir@NFile@NWindows@@YG_NPB_WAAVUString@@@Z:near
UNDEF:00008430                                         ; CODE XREF: EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *)+229p
UNDEF:00008434 ; struct UString __thiscall __high CDirItems::GetPhyPath(unsigned int)
UNDEF:00008434                 extrn ?GetPhyPath@CDirItems@@QBE?AVUString@@I@Z:near
UNDEF:00008434                                         ; CODE XREF: EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *)+144p
UNDEF:00008438 ; __int32 __stdcall __high EnumerateItems(const struct NWildcard::CCensor *, enum NWildcard::ECensorPathMode, const struct UString *, struct CDirItems *)
UNDEF:00008438                 extrn ?EnumerateItems@@YGJABVCCensor@NWildcard@@W4ECensorPathMode@2@ABVUString@@AAVCDirItems@@@Z:near
UNDEF:00008438                                         ; CODE XREF: EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *)+73p
UNDEF:0000843C ; _DWORD __thiscall CDirItems::CDirItems(CDirItems *__hidden this)
UNDEF:0000843C                 extrn ??0CDirItems@@QAE@XZ:near
UNDEF:0000843C                                         ; CODE XREF: EnumerateDirItemsAndSort(NWildcard::CCensor &,NWildcard::ECensorPathMode,UString const &,CObjectVector<UString> &,CObjectVector<UString> &,CDirItemsStat &,IDirItemsCallback *)+51p
UNDEF:00008440 ; void __thiscall UString::Delete(UString *__hidden this, unsigned int)
UNDEF:00008440                 extrn ?Delete@UString@@QAEXI@Z:near
UNDEF:00008440                                         ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+9FFp
UNDEF:00008444 ; void NWindows::NFile::NName::NormalizeDirPathPrefix(NWindows::NFile::NName *__hidden this, struct UString *)
UNDEF:00008444                 extrn ?NormalizeDirPathPrefix@NName@NFile@NWindows@@YGXAAVUString@@@Z:near
UNDEF:00008444                                         ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+7E5p
UNDEF:00008448 ; void __thiscall NWildcard::CCensor::ExtendExclude(NWildcard::CCensor *__hidden this)
UNDEF:00008448                 extrn ?ExtendExclude@CCensor@NWildcard@@QAEXXZ:near
UNDEF:00008448                                         ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+645p
UNDEF:00008448                                         ; CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+729p ...
UNDEF:0000844C ; void __thiscall __high NWildcard::CCensor::AddPathsToCensor(enum NWildcard::ECensorPathMode)
UNDEF:0000844C                 extrn ?AddPathsToCensor@CCensor@NWildcard@@QAEXW4ECensorPathMode@2@@Z:near
UNDEF:0000844C                                         ; CODE XREF: CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+63Ap
UNDEF:0000844C                                         ; CArcCmdLineParser::Parse2(CArcCmdLineOptions &)+718p ...
UNDEF:00008450 ; int __cdecl _wcscmp(const wchar_t *Str1, const wchar_t *Str2)
UNDEF:00008450                 extrn __imp__wcscmp:near
UNDEF:00008450                                         ; CODE XREF: operator==(UString const &,wchar_t const *)+13p
UNDEF:00008450                                         ; DATA XREF: operator==(UString const &,wchar_t const *)+13r
UNDEF:00008454 ; int __stdcall FindCharPosInString(const char *, char)
UNDEF:00008454                 extrn ?FindCharPosInString@@YGHPBDD@Z:near
UNDEF:00008454                                         ; CODE XREF: ParseArchiveCommand(UString const &,CArcCommand &)+ABp
UNDEF:00008454                                         ; AddSwitchWildcardsToCensor(NWildcard::CCensor &,CObjectVector<UString> const &,bool,NRecursedType::EEnum,bool,int)+E3p
UNDEF:00008458 ; void __stdcall MyStringLower_Ascii(wchar_t *)
UNDEF:00008458                 extrn ?MyStringLower_Ascii@@YGXPA_W@Z:near
UNDEF:00008458                                         ; CODE XREF: UString::MakeLower_Ascii(void)+14p
UNDEF:0000845C ; void __thiscall NWildcard::CCensor::AddPreItem(NWildcard::CCensor *__hidden this, bool, const struct UString *, bool, bool)
UNDEF:0000845C                 extrn ?AddPreItem@CCensor@NWildcard@@QAEX_NABVUString@@00@Z:near
UNDEF:0000845C                                         ; CODE XREF: AddNameToCensor(NWildcard::CCensor &,UString const &,bool,NRecursedType::EEnum,bool)+54p
UNDEF:00008460 ; public: __thiscall UString::UString(wchar_t const *)
UNDEF:00008460                 extrn ??0UString@@QAE@PB_W@Z:near
UNDEF:00008460                                         ; CODE XREF: AddToCensorFromNonSwitchesStrings(CObjectVector<CRenamePair> *,uint,NWildcard::CCensor &,CObjectVector<UString> const &,NRecursedType::EEnum,bool,bool,int)+5Ap
UNDEF:00008460                                         ; AddSwitchWildcardsToCensor(NWildcard::CCensor &,CObjectVector<UString> const &,bool,NRecursedType::EEnum,bool,int)+13Fp ...
UNDEF:00008464 ; void __thiscall UString::AddAscii(UString *__hidden this, const char *)
UNDEF:00008464                 extrn ?AddAscii@UString@@QAEXPBD@Z:near
UNDEF:00008464                                         ; CODE XREF: AddRenamePair(CObjectVector<CRenamePair> *,UString const &,UString const &,NRecursedType::EEnum,bool)+D8p
UNDEF:00008464                                         ; AddRenamePair(CObjectVector<CRenamePair> *,UString const &,UString const &,NRecursedType::EEnum,bool)+EDp
UNDEF:00008468 ; bool __thiscall CRenamePair::Prepare(CRenamePair *__hidden this)
UNDEF:00008468                 extrn ?Prepare@CRenamePair@@QAE_NXZ:near
UNDEF:00008468                                         ; CODE XREF: AddRenamePair(CObjectVector<CRenamePair> *,UString const &,UString const &,NRecursedType::EEnum,bool)+80p
UNDEF:0000846C ; bool __stdcall ReadNamesFromListFile(wchar_t const *, class CObjectVector<class UString> &, unsigned int)
UNDEF:0000846C                 extrn ?ReadNamesFromListFile@@YG_NPB_WAAV?$CObjectVector@VUString@@@@I@Z:near
UNDEF:0000846C                                         ; CODE XREF: AddToCensorFromListFile(CObjectVector<CRenamePair> *,NWildcard::CCensor &,wchar_t const *,bool,NRecursedType::EEnum,bool,int)+80p
UNDEF:00008470 ; bool NWindows::NFile::NFind::DoesFileExist(NWindows::NFile::NFind *__hidden this, const wchar_t *)
UNDEF:00008470                 extrn ?DoesFileExist@NFind@NFile@NWindows@@YG_NPB_W@Z:near
UNDEF:00008470                                         ; CODE XREF: AddToCensorFromListFile(CObjectVector<CRenamePair> *,NWildcard::CCensor &,wchar_t const *,bool,NRecursedType::EEnum,bool,int)+48p
UNDEF:00008474 ; void __thiscall UString::Grow_1(UString *__hidden this)
UNDEF:00008474                 extrn ?Grow_1@UString@@AAEXXZ:near
UNDEF:00008474                                         ; CODE XREF: UString::operator+=(wchar_t)+2Fp
UNDEF:00008478 ; int __stdcall FindCharPosInString(const wchar_t *, wchar_t)
UNDEF:00008478                 extrn ?FindCharPosInString@@YGHPB_W_W@Z:near
UNDEF:00008478                                         ; CODE XREF: ParseUpdateCommandString2(UString const &,NUpdateArchive::CActionSet &,UString &)+54p
UNDEF:00008478                                         ; UString::Find(wchar_t)+19p ...
UNDEF:0000847C ; struct AString __stdcall __high UnicodeStringToMultiByte(const struct UString *, unsigned int)
UNDEF:0000847C                 extrn ?UnicodeStringToMultiByte@@YG?AVAString@@ABVUString@@I@Z:near
UNDEF:0000847C                                         ; CODE XREF: GetSystemString(UString const &)+1Cp
UNDEF:00008480 ; DWORD __stdcall GetLastError()
UNDEF:00008480                 extrn __imp__GetLastError@0:near
UNDEF:00008480                                         ; CODE XREF: NWindows::CFileMapping::Open(ulong,char const *)+3Bp
UNDEF:00008480                                         ; NWindows::NSynchronization::CBaseEvent::Open(ulong,bool,char const *)+44p
UNDEF:00008480                                         ; DATA XREF: ...
UNDEF:00008484 ; HANDLE __stdcall OpenFileMappingA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
UNDEF:00008484                 extrn __imp__OpenFileMappingA@12:near
UNDEF:00008484                                         ; CODE XREF: NWindows::CFileMapping::Open(ulong,char const *)+1Bp
UNDEF:00008484                                         ; DATA XREF: NWindows::CFileMapping::Open(ulong,char const *)+1Br
UNDEF:00008488 ; LPVOID __stdcall MapViewOfFile(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap)
UNDEF:00008488                 extrn __imp__MapViewOfFile@20:near
UNDEF:00008488                                         ; CODE XREF: NWindows::CFileMapping::Map(ulong,unsigned __int64,ulong)+31p
UNDEF:00008488                                         ; DATA XREF: NWindows::CFileMapping::Map(ulong,unsigned __int64,ulong)+31r
UNDEF:0000848C                 extrn __aullshr:near    ; CODE XREF: NWindows::CFileMapping::Map(ulong,unsigned __int64,ulong)+21p
UNDEF:00008490 ; BOOL __stdcall UnmapViewOfFile(LPCVOID lpBaseAddress)
UNDEF:00008490                 extrn __imp__UnmapViewOfFile@4:near
UNDEF:00008490                                         ; CODE XREF: NWindows::CFileUnmapper::~CFileUnmapper(void)+17p
UNDEF:00008490                                         ; DATA XREF: NWindows::CFileUnmapper::~CFileUnmapper(void)+17r
UNDEF:00008494 ; HANDLE __stdcall OpenEventA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
UNDEF:00008494                 extrn __imp__OpenEventA@12:near
UNDEF:00008494                                         ; CODE XREF: NWindows::NSynchronization::CBaseEvent::Open(ulong,bool,char const *)+24p
UNDEF:00008494                                         ; DATA XREF: NWindows::NSynchronization::CBaseEvent::Open(ulong,bool,char const *)+24r
UNDEF:00008498 ; __stdcall Event_Set(x)
UNDEF:00008498                 extrn _Event_Set@4:near ; CODE XREF: NWindows::NSynchronization::CBaseEvent::Set(void)+12p
UNDEF:0000849C ; __stdcall HandlePtr_Close(x)
UNDEF:0000849C                 extrn _HandlePtr_Close@4:near
UNDEF:0000849C                                         ; CODE XREF: NWindows::NSynchronization::CBaseEvent::Close(void)+12p
UNDEF:000084A0 ; BOOL __stdcall CloseHandle(HANDLE hObject)
UNDEF:000084A0                 extrn __imp__CloseHandle@4:near
UNDEF:000084A0                                         ; CODE XREF: NWindows::CHandle::Close(void)+23p
UNDEF:000084A0                                         ; DATA XREF: NWindows::CHandle::Close(void)+23r
UNDEF:000084A4 ; bool __stdcall ParseComplexSize(const wchar_t *, unsigned __int64 *)
UNDEF:000084A4                 extrn ?ParseComplexSize@@YG_NPB_WAA_K@Z:near
UNDEF:000084A4                                         ; CODE XREF: SetAddCommandOptions(NCommandType::EEnum,NCommandLineParser::CParser const &,CUpdateOptions &)+224p
UNDEF:000084A8 ; bool NWindows::NFile::NDir::MyGetTempPath(NWindows::NFile::NDir *__hidden this, struct UString *)
UNDEF:000084A8                 extrn ?MyGetTempPath@NDir@NFile@NWindows@@YG_NAAVUString@@@Z:near
UNDEF:000084A8                                         ; CODE XREF: SetAddCommandOptions(NCommandType::EEnum,NCommandLineParser::CParser const &,CUpdateOptions &)+145p
UNDEF:000084AC ; struct NUpdateArchive::CActionSet const NUpdateArchive::k_ActionSet_Update
UNDEF:000084AC                 extrn ?k_ActionSet_Update@NUpdateArchive@@3UCActionSet@1@B:near
UNDEF:000084AC                                         ; DATA XREF: SetAddCommandOptions(NCommandType::EEnum,NCommandLineParser::CParser const &,CUpdateOptions &)+83o
UNDEF:000084B0 ; struct NUpdateArchive::CActionSet const NUpdateArchive::k_ActionSet_Delete
UNDEF:000084B0                 extrn ?k_ActionSet_Delete@NUpdateArchive@@3UCActionSet@1@B:near
UNDEF:000084B0                                         ; DATA XREF: SetAddCommandOptions(NCommandType::EEnum,NCommandLineParser::CParser const &,CUpdateOptions &)+72o
UNDEF:000084B4 ; struct NUpdateArchive::CActionSet const NUpdateArchive::k_ActionSet_Add
UNDEF:000084B4                 extrn ?k_ActionSet_Add@NUpdateArchive@@3UCActionSet@1@B:near
UNDEF:000084B4                                         ; DATA XREF: SetAddCommandOptions(NCommandType::EEnum,NCommandLineParser::CParser const &,CUpdateOptions &)+61o
UNDEF:000084B8 ; bool __stdcall StringsAreEqual_Ascii(const wchar_t *, const char *)
UNDEF:000084B8                 extrn ?StringsAreEqual_Ascii@@YG_NPB_WPBD@Z:near
UNDEF:000084B8                                         ; CODE XREF: UString::IsEqualTo(char const *)+18p
UNDEF:000084BC ; public: class UString & __thiscall UString::operator=(wchar_t const *)
UNDEF:000084BC                 extrn ??4UString@@QAEAAV0@PB_W@Z:near
UNDEF:000084BC                                         ; CODE XREF: ParseUpdateCommandString2(UString const &,NUpdateArchive::CActionSet &,UString &)+72p
UNDEF:000084BC                                         ; SetMethodOptions(NCommandLineParser::CParser const &,CObjectVector<CProperty> &)+CFp
UNDEF:000084C0 ; void *__cdecl operator new(unsigned int)
UNDEF:000084C0                 extrn ??2@YAPAXI@Z:near ; CODE XREF: CObjectVector<UString>::operator=(CObjectVector<UString> const &)+8Ap
UNDEF:000084C0                                         ; CObjectVector<UString>::Add(UString const &)+3Bp ...
UNDEF:000084C4 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:000084C4                 extrn _memcpy:near      ; CODE XREF: CRecordVector<void *>::Reserve(uint)+67p
UNDEF:000084C4                                         ; CRecordVector<unsigned __int64>::ReserveOnePosition(void)+87p ...
UNDEF:000084C8 ; void *__cdecl _memmove(void *Dst, const void *Src, size_t Size)
UNDEF:000084C8                 extrn __imp__memmove:near
UNDEF:000084C8                                         ; CODE XREF: CRecordVector<void *>::MoveItems(uint,uint)+36p
UNDEF:000084C8                                         ; DATA XREF: CRecordVector<void *>::MoveItems(uint,uint)+36r
UNDEF:000084C8
UNDEF:000084C8