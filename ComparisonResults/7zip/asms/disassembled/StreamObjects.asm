.text:00000000 ;
.text:00000000 ; +-------------------------------------------------------------------------+
.text:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.text:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.text:00000000 ; |                      License info: 48-3677-7074-51                      |
.text:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.text:00000000 ; +-------------------------------------------------------------------------+
.text:00000000 ;
.text:00000000 ; Input MD5   : 7495D50D1482B19B312AB91102128338
.text:00000000 ; Input CRC32 : 0FBD0841
.text:00000000
.text:00000000 ; File Name   : C:\workspace\7z1505-src\CPP\7zip\Bundles\Alone\Debug\StreamObjects.obj
.text:00000000 ; Format      : COFF (X386MAGIC)
.text:00000000 ; includelib "uuid.lib"
.text:00000000 ; includelib "MSVCRTD"
.text:00000000 ; includelib "OLDNAMES"
.text:00000000
.text:00000000                 .686p
.text:00000000                 .mmx
.text:00000000                 .model flat
.text:00000000
.text:00000000 ; ===========================================================================
.text:00000000
.text:00000000 ; Segment type: Pure code
.text:00000000 ; Segment permissions: Read/Execute
.text:00000000 _text           segment para public 'CODE' use32
.text:00000000                 assume cs:_text
.text:00000000                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000000
.text:00000000 ; =============== S U B R O U T I N E =======================================
.text:00000000
.text:00000000 ; Attributes: bp-based frame
.text:00000000
.text:00000000 ; __int32 __stdcall CBufferInStream::Read(CBufferInStream *this, void *Dst, unsigned int, unsigned int *)
.text:00000000                 public ?Read@CBufferInStream@@UAGJPAXIPAI@Z
.text:00000000 ?Read@CBufferInStream@@UAGJPAXIPAI@Z proc near ; DATA XREF: .rdata:0000147Co
.text:00000000
.text:00000000 var_10          = dword ptr -10h
.text:00000000 var_C           = dword ptr -0Ch
.text:00000000 var_8           = dword ptr -8
.text:00000000 Size            = dword ptr -4
.text:00000000 this            = dword ptr  8
.text:00000000 Dst             = dword ptr  0Ch
.text:00000000 arg_8           = dword ptr  10h
.text:00000000 arg_C           = dword ptr  14h
.text:00000000
.text:00000000                 push    ebp
.text:00000001                 mov     ebp, esp
.text:00000003                 sub     esp, 10h
.text:00000006                 mov     eax, 0CCCCCCCCh
.text:0000000B                 mov     [ebp+var_10], eax
.text:0000000E                 mov     [ebp+var_C], eax
.text:00000011                 mov     [ebp+var_8], eax
.text:00000014                 mov     [ebp+Size], eax
.text:00000017                 cmp     [ebp+arg_C], 0
.text:0000001B                 jz      short loc_26
.text:0000001D                 mov     eax, [ebp+arg_C]
.text:00000020                 mov     dword ptr [eax], 0
.text:00000026
.text:00000026 loc_26:                                 ; CODE XREF: CBufferInStream::Read(void *,uint,uint *)+1Bj
.text:00000026                 cmp     [ebp+arg_8], 0
.text:0000002A                 jnz     short loc_33
.text:0000002C                 xor     eax, eax
.text:0000002E                 jmp     loc_D7
.text:00000033 ; ---------------------------------------------------------------------------
.text:00000033
.text:00000033 loc_33:                                 ; CODE XREF: CBufferInStream::Read(void *,uint,uint *)+2Aj
.text:00000033                 mov     ecx, [ebp+this]
.text:00000036                 add     ecx, 10h
.text:00000039                 call    ?Size@?$CBuffer@E@@QBEIXZ ; CBuffer<uchar>::Size(void)
.text:0000003E                 xor     ecx, ecx
.text:00000040                 mov     edx, [ebp+this]
.text:00000043                 mov     [ebp+var_8], edx
.text:00000046                 mov     [ebp+var_10], eax
.text:00000049                 mov     [ebp+var_C], ecx
.text:0000004C                 mov     eax, [ebp+var_8]
.text:0000004F                 mov     ecx, [eax+0Ch]
.text:00000052                 cmp     ecx, [ebp+var_C]
.text:00000055                 jb      short loc_68
.text:00000057                 ja      short loc_64
.text:00000059                 mov     edx, [ebp+var_8]
.text:0000005C                 mov     eax, [edx+8]
.text:0000005F                 cmp     eax, [ebp+var_10]
.text:00000062                 jb      short loc_68
.text:00000064
.text:00000064 loc_64:                                 ; CODE XREF: CBufferInStream::Read(void *,uint,uint *)+57j
.text:00000064                 xor     eax, eax
.text:00000066                 jmp     short loc_D7
.text:00000068 ; ---------------------------------------------------------------------------
.text:00000068
.text:00000068 loc_68:                                 ; CODE XREF: CBufferInStream::Read(void *,uint,uint *)+55j
.text:00000068                                         ; CBufferInStream::Read(void *,uint,uint *)+62j
.text:00000068                 mov     ecx, [ebp+this]
.text:0000006B                 add     ecx, 10h
.text:0000006E                 call    ?Size@?$CBuffer@E@@QBEIXZ ; CBuffer<uchar>::Size(void)
.text:00000073                 mov     ecx, [ebp+this]
.text:00000076                 mov     edx, [ecx+8]
.text:00000079                 sub     eax, edx
.text:0000007B                 mov     [ebp+Size], eax
.text:0000007E                 mov     eax, [ebp+Size]
.text:00000081                 cmp     eax, [ebp+arg_8]
.text:00000084                 jbe     short loc_8C
.text:00000086                 mov     ecx, [ebp+arg_8]
.text:00000089                 mov     [ebp+Size], ecx
.text:0000008C
.text:0000008C loc_8C:                                 ; CODE XREF: CBufferInStream::Read(void *,uint,uint *)+84j
.text:0000008C                 mov     edx, [ebp+Size]
.text:0000008F                 push    edx             ; Size
.text:00000090                 mov     ecx, [ebp+this]
.text:00000093                 add     ecx, 10h
.text:00000096                 call    ??B?$CBuffer@E@@QAEPAEXZ ; CBuffer<uchar>::operator uchar *(void)
.text:0000009B                 mov     ecx, [ebp+this]
.text:0000009E                 mov     edx, [ecx+8]
.text:000000A1                 add     eax, edx
.text:000000A3                 push    eax             ; Src
.text:000000A4                 mov     eax, [ebp+Dst]
.text:000000A7                 push    eax             ; Dst
.text:000000A8                 call    _memcpy
.text:000000AD                 add     esp, 0Ch
.text:000000B0                 mov     ecx, [ebp+Size]
.text:000000B3                 xor     edx, edx
.text:000000B5                 mov     eax, [ebp+this]
.text:000000B8                 add     ecx, [eax+8]
.text:000000BB                 adc     edx, [eax+0Ch]
.text:000000BE                 mov     eax, [ebp+this]
.text:000000C1                 mov     [eax+8], ecx
.text:000000C4                 mov     [eax+0Ch], edx
.text:000000C7                 cmp     [ebp+arg_C], 0
.text:000000CB                 jz      short loc_D5
.text:000000CD                 mov     ecx, [ebp+arg_C]
.text:000000D0                 mov     edx, [ebp+Size]
.text:000000D3                 mov     [ecx], edx
.text:000000D5
.text:000000D5 loc_D5:                                 ; CODE XREF: CBufferInStream::Read(void *,uint,uint *)+CBj
.text:000000D5                 xor     eax, eax
.text:000000D7
.text:000000D7 loc_D7:                                 ; CODE XREF: CBufferInStream::Read(void *,uint,uint *)+2Ej
.text:000000D7                                         ; CBufferInStream::Read(void *,uint,uint *)+66j
.text:000000D7                 add     esp, 10h
.text:000000DA                 cmp     ebp, esp
.text:000000DC                 call    __RTC_CheckEsp
.text:000000E1                 mov     esp, ebp
.text:000000E3                 pop     ebp
.text:000000E4                 retn    10h
.text:000000E4 ?Read@CBufferInStream@@UAGJPAXIPAI@Z endp
.text:000000E4
.text:000000E4 ; ---------------------------------------------------------------------------
.text:000000E7                 align 10h
.text:000000F0
.text:000000F0 ; =============== S U B R O U T I N E =======================================
.text:000000F0
.text:000000F0 ; Attributes: bp-based frame
.text:000000F0
.text:000000F0 ; __int32 __stdcall CBufferInStream::Seek(CBufferInStream *this, __int64, unsigned int, unsigned __int64 *)
.text:000000F0                 public ?Seek@CBufferInStream@@UAGJ_JIPA_K@Z
.text:000000F0 ?Seek@CBufferInStream@@UAGJ_JIPA_K@Z proc near ; DATA XREF: .rdata:00001480o
.text:000000F0
.text:000000F0 var_4           = dword ptr -4
.text:000000F0 this            = dword ptr  8
.text:000000F0 arg_4           = qword ptr  0Ch
.text:000000F0 arg_C           = dword ptr  14h
.text:000000F0 arg_10          = dword ptr  18h
.text:000000F0
.text:000000F0                 push    ebp
.text:000000F1                 mov     ebp, esp
.text:000000F3                 push    ecx
.text:000000F4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000000FB                 mov     eax, [ebp+arg_C]
.text:000000FE                 mov     [ebp+var_4], eax
.text:00000101                 cmp     [ebp+var_4], 0
.text:00000105                 jz      short loc_115
.text:00000107                 cmp     [ebp+var_4], 1
.text:0000010B                 jz      short loc_117
.text:0000010D                 cmp     [ebp+var_4], 2
.text:00000111                 jz      short loc_12E
.text:00000113                 jmp     short loc_149
.text:00000115 ; ---------------------------------------------------------------------------
.text:00000115
.text:00000115 loc_115:                                ; CODE XREF: CBufferInStream::Seek(__int64,uint,unsigned __int64 *)+15j
.text:00000115                 jmp     short loc_150
.text:00000117 ; ---------------------------------------------------------------------------
.text:00000117
.text:00000117 loc_117:                                ; CODE XREF: CBufferInStream::Seek(__int64,uint,unsigned __int64 *)+1Bj
.text:00000117                 mov     ecx, [ebp+this]
.text:0000011A                 mov     edx, dword ptr [ebp+arg_4]
.text:0000011D                 add     edx, [ecx+8]
.text:00000120                 mov     eax, dword ptr [ebp+arg_4+4]
.text:00000123                 adc     eax, [ecx+0Ch]
.text:00000126                 mov     dword ptr [ebp+arg_4], edx
.text:00000129                 mov     dword ptr [ebp+arg_4+4], eax
.text:0000012C                 jmp     short loc_150
.text:0000012E ; ---------------------------------------------------------------------------
.text:0000012E
.text:0000012E loc_12E:                                ; CODE XREF: CBufferInStream::Seek(__int64,uint,unsigned __int64 *)+21j
.text:0000012E                 mov     ecx, [ebp+this]
.text:00000131                 add     ecx, 10h
.text:00000134                 call    ?Size@?$CBuffer@E@@QBEIXZ ; CBuffer<uchar>::Size(void)
.text:00000139                 xor     ecx, ecx
.text:0000013B                 add     eax, dword ptr [ebp+arg_4]
.text:0000013E                 adc     ecx, dword ptr [ebp+arg_4+4]
.text:00000141                 mov     dword ptr [ebp+arg_4], eax
.text:00000144                 mov     dword ptr [ebp+arg_4+4], ecx
.text:00000147                 jmp     short loc_150
.text:00000149 ; ---------------------------------------------------------------------------
.text:00000149
.text:00000149 loc_149:                                ; CODE XREF: CBufferInStream::Seek(__int64,uint,unsigned __int64 *)+23j
.text:00000149                 mov     eax, 80030001h
.text:0000014E                 jmp     short loc_18A
.text:00000150 ; ---------------------------------------------------------------------------
.text:00000150
.text:00000150 loc_150:                                ; CODE XREF: CBufferInStream::Seek(__int64,uint,unsigned __int64 *):loc_115j
.text:00000150                                         ; CBufferInStream::Seek(__int64,uint,unsigned __int64 *)+3Cj ...
.text:00000150                 cmp     dword ptr [ebp+arg_4+4], 0
.text:00000154                 jg      short loc_165
.text:00000156                 jl      short loc_15E
.text:00000158                 cmp     dword ptr [ebp+arg_4], 0
.text:0000015C                 jnb     short loc_165
.text:0000015E
.text:0000015E loc_15E:                                ; CODE XREF: CBufferInStream::Seek(__int64,uint,unsigned __int64 *)+66j
.text:0000015E                 mov     eax, 80070083h
.text:00000163                 jmp     short loc_18A
.text:00000165 ; ---------------------------------------------------------------------------
.text:00000165
.text:00000165 loc_165:                                ; CODE XREF: CBufferInStream::Seek(__int64,uint,unsigned __int64 *)+64j
.text:00000165                                         ; CBufferInStream::Seek(__int64,uint,unsigned __int64 *)+6Cj
.text:00000165                 mov     edx, [ebp+this]
.text:00000168                 mov     eax, dword ptr [ebp+arg_4]
.text:0000016B                 mov     [edx+8], eax
.text:0000016E                 mov     ecx, dword ptr [ebp+arg_4+4]
.text:00000171                 mov     [edx+0Ch], ecx
.text:00000174                 cmp     [ebp+arg_10], 0
.text:00000178                 jz      short loc_188
.text:0000017A                 mov     edx, [ebp+arg_10]
.text:0000017D                 mov     eax, dword ptr [ebp+arg_4]
.text:00000180                 mov     [edx], eax
.text:00000182                 mov     ecx, dword ptr [ebp+arg_4+4]
.text:00000185                 mov     [edx+4], ecx
.text:00000188
.text:00000188 loc_188:                                ; CODE XREF: CBufferInStream::Seek(__int64,uint,unsigned __int64 *)+88j
.text:00000188                 xor     eax, eax
.text:0000018A
.text:0000018A loc_18A:                                ; CODE XREF: CBufferInStream::Seek(__int64,uint,unsigned __int64 *)+5Ej
.text:0000018A                                         ; CBufferInStream::Seek(__int64,uint,unsigned __int64 *)+73j
.text:0000018A                 add     esp, 4
.text:0000018D                 cmp     ebp, esp
.text:0000018F                 call    __RTC_CheckEsp
.text:00000194                 mov     esp, ebp
.text:00000196                 pop     ebp
.text:00000197                 retn    14h
.text:00000197 ?Seek@CBufferInStream@@UAGJ_JIPA_K@Z endp
.text:00000197
.text:00000197 ; ---------------------------------------------------------------------------
.text:0000019A                 align 10h
.text:000001A0
.text:000001A0 ; =============== S U B R O U T I N E =======================================
.text:000001A0
.text:000001A0 ; Attributes: bp-based frame
.text:000001A0
.text:000001A0 ; __int32 __stdcall CBufInStream::Read(CBufInStream *this, void *Dst, unsigned int, unsigned int *)
.text:000001A0                 public ?Read@CBufInStream@@UAGJPAXIPAI@Z
.text:000001A0 ?Read@CBufInStream@@UAGJPAXIPAI@Z proc near ; DATA XREF: .rdata:00000F60o
.text:000001A0
.text:000001A0 var_10          = dword ptr -10h
.text:000001A0 var_C           = dword ptr -0Ch
.text:000001A0 var_8           = dword ptr -8
.text:000001A0 Size            = dword ptr -4
.text:000001A0 this            = dword ptr  8
.text:000001A0 Dst             = dword ptr  0Ch
.text:000001A0 arg_8           = dword ptr  10h
.text:000001A0 arg_C           = dword ptr  14h
.text:000001A0
.text:000001A0                 push    ebp
.text:000001A1                 mov     ebp, esp
.text:000001A3                 sub     esp, 10h
.text:000001A6                 mov     eax, 0CCCCCCCCh
.text:000001AB                 mov     [ebp+var_10], eax
.text:000001AE                 mov     [ebp+var_C], eax
.text:000001B1                 mov     [ebp+var_8], eax
.text:000001B4                 mov     [ebp+Size], eax
.text:000001B7                 cmp     [ebp+arg_C], 0
.text:000001BB                 jz      short loc_1C6
.text:000001BD                 mov     eax, [ebp+arg_C]
.text:000001C0                 mov     dword ptr [eax], 0
.text:000001C6
.text:000001C6 loc_1C6:                                ; CODE XREF: CBufInStream::Read(void *,uint,uint *)+1Bj
.text:000001C6                 cmp     [ebp+arg_8], 0
.text:000001CA                 jnz     short loc_1D3
.text:000001CC                 xor     eax, eax
.text:000001CE                 jmp     loc_266
.text:000001D3 ; ---------------------------------------------------------------------------
.text:000001D3
.text:000001D3 loc_1D3:                                ; CODE XREF: CBufInStream::Read(void *,uint,uint *)+2Aj
.text:000001D3                 mov     ecx, [ebp+this]
.text:000001D6                 mov     edx, [ecx+18h]
.text:000001D9                 xor     eax, eax
.text:000001DB                 mov     ecx, [ebp+this]
.text:000001DE                 mov     [ebp+var_8], ecx
.text:000001E1                 mov     [ebp+var_10], edx
.text:000001E4                 mov     [ebp+var_C], eax
.text:000001E7                 mov     edx, [ebp+var_8]
.text:000001EA                 mov     eax, [edx+14h]
.text:000001ED                 cmp     eax, [ebp+var_C]
.text:000001F0                 jb      short loc_203
.text:000001F2                 ja      short loc_1FF
.text:000001F4                 mov     ecx, [ebp+var_8]
.text:000001F7                 mov     edx, [ecx+10h]
.text:000001FA                 cmp     edx, [ebp+var_10]
.text:000001FD                 jb      short loc_203
.text:000001FF
.text:000001FF loc_1FF:                                ; CODE XREF: CBufInStream::Read(void *,uint,uint *)+52j
.text:000001FF                 xor     eax, eax
.text:00000201                 jmp     short loc_266
.text:00000203 ; ---------------------------------------------------------------------------
.text:00000203
.text:00000203 loc_203:                                ; CODE XREF: CBufInStream::Read(void *,uint,uint *)+50j
.text:00000203                                         ; CBufInStream::Read(void *,uint,uint *)+5Dj
.text:00000203                 mov     eax, [ebp+this]
.text:00000206                 mov     ecx, [eax+10h]
.text:00000209                 mov     edx, [ebp+this]
.text:0000020C                 mov     eax, [edx+18h]
.text:0000020F                 sub     eax, ecx
.text:00000211                 mov     [ebp+Size], eax
.text:00000214                 mov     ecx, [ebp+Size]
.text:00000217                 cmp     ecx, [ebp+arg_8]
.text:0000021A                 jbe     short loc_222
.text:0000021C                 mov     edx, [ebp+arg_8]
.text:0000021F                 mov     [ebp+Size], edx
.text:00000222
.text:00000222 loc_222:                                ; CODE XREF: CBufInStream::Read(void *,uint,uint *)+7Aj
.text:00000222                 mov     eax, [ebp+Size]
.text:00000225                 push    eax             ; Size
.text:00000226                 mov     ecx, [ebp+this]
.text:00000229                 mov     edx, [ecx+10h]
.text:0000022C                 mov     eax, [ebp+this]
.text:0000022F                 add     edx, [eax+8]
.text:00000232                 push    edx             ; Src
.text:00000233                 mov     ecx, [ebp+Dst]
.text:00000236                 push    ecx             ; Dst
.text:00000237                 call    _memcpy
.text:0000023C                 add     esp, 0Ch
.text:0000023F                 mov     edx, [ebp+Size]
.text:00000242                 xor     eax, eax
.text:00000244                 mov     ecx, [ebp+this]
.text:00000247                 add     edx, [ecx+10h]
.text:0000024A                 adc     eax, [ecx+14h]
.text:0000024D                 mov     ecx, [ebp+this]
.text:00000250                 mov     [ecx+10h], edx
.text:00000253                 mov     [ecx+14h], eax
.text:00000256                 cmp     [ebp+arg_C], 0
.text:0000025A                 jz      short loc_264
.text:0000025C                 mov     edx, [ebp+arg_C]
.text:0000025F                 mov     eax, [ebp+Size]
.text:00000262                 mov     [edx], eax
.text:00000264
.text:00000264 loc_264:                                ; CODE XREF: CBufInStream::Read(void *,uint,uint *)+BAj
.text:00000264                 xor     eax, eax
.text:00000266
.text:00000266 loc_266:                                ; CODE XREF: CBufInStream::Read(void *,uint,uint *)+2Ej
.text:00000266                                         ; CBufInStream::Read(void *,uint,uint *)+61j
.text:00000266                 add     esp, 10h
.text:00000269                 cmp     ebp, esp
.text:0000026B                 call    __RTC_CheckEsp
.text:00000270                 mov     esp, ebp
.text:00000272                 pop     ebp
.text:00000273                 retn    10h
.text:00000273 ?Read@CBufInStream@@UAGJPAXIPAI@Z endp
.text:00000273
.text:00000273 ; ---------------------------------------------------------------------------
.text:00000276                 align 10h
.text:00000280
.text:00000280 ; =============== S U B R O U T I N E =======================================
.text:00000280
.text:00000280 ; Attributes: bp-based frame
.text:00000280
.text:00000280 ; __int32 __stdcall CBufInStream::Seek(CBufInStream *this, __int64, unsigned int, unsigned __int64 *)
.text:00000280                 public ?Seek@CBufInStream@@UAGJ_JIPA_K@Z
.text:00000280 ?Seek@CBufInStream@@UAGJ_JIPA_K@Z proc near ; DATA XREF: .rdata:00000F64o
.text:00000280
.text:00000280 var_4           = dword ptr -4
.text:00000280 this            = dword ptr  8
.text:00000280 arg_4           = qword ptr  0Ch
.text:00000280 arg_C           = dword ptr  14h
.text:00000280 arg_10          = dword ptr  18h
.text:00000280
.text:00000280                 push    ebp
.text:00000281                 mov     ebp, esp
.text:00000283                 push    ecx
.text:00000284                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000028B                 mov     eax, [ebp+arg_C]
.text:0000028E                 mov     [ebp+var_4], eax
.text:00000291                 cmp     [ebp+var_4], 0
.text:00000295                 jz      short loc_2A5
.text:00000297                 cmp     [ebp+var_4], 1
.text:0000029B                 jz      short loc_2A7
.text:0000029D                 cmp     [ebp+var_4], 2
.text:000002A1                 jz      short loc_2BE
.text:000002A3                 jmp     short loc_2D4
.text:000002A5 ; ---------------------------------------------------------------------------
.text:000002A5
.text:000002A5 loc_2A5:                                ; CODE XREF: CBufInStream::Seek(__int64,uint,unsigned __int64 *)+15j
.text:000002A5                 jmp     short loc_2DB
.text:000002A7 ; ---------------------------------------------------------------------------
.text:000002A7
.text:000002A7 loc_2A7:                                ; CODE XREF: CBufInStream::Seek(__int64,uint,unsigned __int64 *)+1Bj
.text:000002A7                 mov     ecx, [ebp+this]
.text:000002AA                 mov     edx, dword ptr [ebp+arg_4]
.text:000002AD                 add     edx, [ecx+10h]
.text:000002B0                 mov     eax, dword ptr [ebp+arg_4+4]
.text:000002B3                 adc     eax, [ecx+14h]
.text:000002B6                 mov     dword ptr [ebp+arg_4], edx
.text:000002B9                 mov     dword ptr [ebp+arg_4+4], eax
.text:000002BC                 jmp     short loc_2DB
.text:000002BE ; ---------------------------------------------------------------------------
.text:000002BE
.text:000002BE loc_2BE:                                ; CODE XREF: CBufInStream::Seek(__int64,uint,unsigned __int64 *)+21j
.text:000002BE                 mov     ecx, [ebp+this]
.text:000002C1                 mov     edx, [ecx+18h]
.text:000002C4                 xor     eax, eax
.text:000002C6                 add     edx, dword ptr [ebp+arg_4]
.text:000002C9                 adc     eax, dword ptr [ebp+arg_4+4]
.text:000002CC                 mov     dword ptr [ebp+arg_4], edx
.text:000002CF                 mov     dword ptr [ebp+arg_4+4], eax
.text:000002D2                 jmp     short loc_2DB
.text:000002D4 ; ---------------------------------------------------------------------------
.text:000002D4
.text:000002D4 loc_2D4:                                ; CODE XREF: CBufInStream::Seek(__int64,uint,unsigned __int64 *)+23j
.text:000002D4                 mov     eax, 80030001h
.text:000002D9                 jmp     short loc_315
.text:000002DB ; ---------------------------------------------------------------------------
.text:000002DB
.text:000002DB loc_2DB:                                ; CODE XREF: CBufInStream::Seek(__int64,uint,unsigned __int64 *):loc_2A5j
.text:000002DB                                         ; CBufInStream::Seek(__int64,uint,unsigned __int64 *)+3Cj ...
.text:000002DB                 cmp     dword ptr [ebp+arg_4+4], 0
.text:000002DF                 jg      short loc_2F0
.text:000002E1                 jl      short loc_2E9
.text:000002E3                 cmp     dword ptr [ebp+arg_4], 0
.text:000002E7                 jnb     short loc_2F0
.text:000002E9
.text:000002E9 loc_2E9:                                ; CODE XREF: CBufInStream::Seek(__int64,uint,unsigned __int64 *)+61j
.text:000002E9                 mov     eax, 80070083h
.text:000002EE                 jmp     short loc_315
.text:000002F0 ; ---------------------------------------------------------------------------
.text:000002F0
.text:000002F0 loc_2F0:                                ; CODE XREF: CBufInStream::Seek(__int64,uint,unsigned __int64 *)+5Fj
.text:000002F0                                         ; CBufInStream::Seek(__int64,uint,unsigned __int64 *)+67j
.text:000002F0                 mov     ecx, [ebp+this]
.text:000002F3                 mov     edx, dword ptr [ebp+arg_4]
.text:000002F6                 mov     [ecx+10h], edx
.text:000002F9                 mov     eax, dword ptr [ebp+arg_4+4]
.text:000002FC                 mov     [ecx+14h], eax
.text:000002FF                 cmp     [ebp+arg_10], 0
.text:00000303                 jz      short loc_313
.text:00000305                 mov     ecx, [ebp+arg_10]
.text:00000308                 mov     edx, dword ptr [ebp+arg_4]
.text:0000030B                 mov     [ecx], edx
.text:0000030D                 mov     eax, dword ptr [ebp+arg_4+4]
.text:00000310                 mov     [ecx+4], eax
.text:00000313
.text:00000313 loc_313:                                ; CODE XREF: CBufInStream::Seek(__int64,uint,unsigned __int64 *)+83j
.text:00000313                 xor     eax, eax
.text:00000315
.text:00000315 loc_315:                                ; CODE XREF: CBufInStream::Seek(__int64,uint,unsigned __int64 *)+59j
.text:00000315                                         ; CBufInStream::Seek(__int64,uint,unsigned __int64 *)+6Ej
.text:00000315                 mov     esp, ebp
.text:00000317                 pop     ebp
.text:00000318                 retn    14h
.text:00000318 ?Seek@CBufInStream@@UAGJ_JIPA_K@Z endp
.text:00000318
.text:00000318 ; ---------------------------------------------------------------------------
.text:0000031B                 align 10h
.text:00000320
.text:00000320 ; =============== S U B R O U T I N E =======================================
.text:00000320
.text:00000320 ; Attributes: bp-based frame
.text:00000320
.text:00000320 ; void __stdcall Create_BufInStream_WithReference(unsigned __int8 *, unsigned int, struct IUnknown *, struct ISequentialInStream **)
.text:00000320                 public ?Create_BufInStream_WithReference@@YGXPBXIPAUIUnknown@@PAPAUISequentialInStream@@@Z
.text:00000320 ?Create_BufInStream_WithReference@@YGXPBXIPAUIUnknown@@PAPAUISequentialInStream@@@Z proc near
.text:00000320
.text:00000320 var_28          = dword ptr -28h
.text:00000320 var_24          = dword ptr -24h
.text:00000320 var_20          = dword ptr -20h
.text:00000320 var_1C          = dword ptr -1Ch
.text:00000320 var_18          = dword ptr -18h
.text:00000320 var_14          = dword ptr -14h
.text:00000320 var_10          = dword ptr -10h
.text:00000320 var_C           = dword ptr -0Ch
.text:00000320 var_4           = dword ptr -4
.text:00000320 arg_0           = dword ptr  8
.text:00000320 arg_4           = dword ptr  0Ch
.text:00000320 arg_8           = dword ptr  10h
.text:00000320 arg_C           = dword ptr  14h
.text:00000320
.text:00000320                 push    ebp
.text:00000321                 mov     ebp, esp
.text:00000323                 push    0FFFFFFFFh
.text:00000325                 push    offset __ehhandler$?Create_BufInStream_WithReference@@YGXPBXIPAUIUnknown@@PAPAUISequentialInStream@@@Z
.text:0000032A                 mov     eax, large fs:0
.text:00000330                 push    eax
.text:00000331                 sub     esp, 1Ch
.text:00000334                 mov     eax, 0CCCCCCCCh
.text:00000339                 mov     [ebp+var_28], eax
.text:0000033C                 mov     [ebp+var_24], eax
.text:0000033F                 mov     [ebp+var_20], eax
.text:00000342                 mov     [ebp+var_1C], eax
.text:00000345                 mov     [ebp+var_18], eax
.text:00000348                 mov     [ebp+var_14], eax
.text:0000034B                 mov     [ebp+var_10], eax
.text:0000034E                 mov     eax, dword ptr ds:___security_cookie
.text:00000353                 xor     eax, ebp
.text:00000355                 push    eax
.text:00000356                 lea     eax, [ebp+var_C]
.text:00000359                 mov     large fs:0, eax
.text:0000035F                 mov     eax, [ebp+arg_C]
.text:00000362                 mov     dword ptr [eax], 0
.text:00000368                 push    20h ; ' '       ; unsigned int
.text:0000036A                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0000036F                 add     esp, 4
.text:00000372                 mov     [ebp+var_24], eax
.text:00000375                 mov     [ebp+var_4], 0
.text:0000037C                 cmp     [ebp+var_24], 0
.text:00000380                 jz      short loc_38F
.text:00000382                 mov     ecx, [ebp+var_24]
.text:00000385                 call    ??0CBufInStream@@QAE@XZ ; CBufInStream::CBufInStream(void)
.text:0000038A                 mov     [ebp+var_28], eax
.text:0000038D                 jmp     short loc_396
.text:0000038F ; ---------------------------------------------------------------------------
.text:0000038F
.text:0000038F loc_38F:                                ; CODE XREF: Create_BufInStream_WithReference(void const *,uint,IUnknown *,ISequentialInStream * *)+60j
.text:0000038F                 mov     [ebp+var_28], 0
.text:00000396
.text:00000396 loc_396:                                ; CODE XREF: Create_BufInStream_WithReference(void const *,uint,IUnknown *,ISequentialInStream * *)+6Dj
.text:00000396                 mov     ecx, [ebp+var_28]
.text:00000399                 mov     [ebp+var_20], ecx
.text:0000039C                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000003A3                 mov     edx, [ebp+var_20]
.text:000003A6                 mov     [ebp+var_10], edx
.text:000003A9                 mov     eax, [ebp+var_10]
.text:000003AC                 push    eax
.text:000003AD                 lea     ecx, [ebp+var_18]
.text:000003B0                 call    ??0?$CMyComPtr@UISequentialInStream@@@@QAE@PAUISequentialInStream@@@Z ; CMyComPtr<ISequentialInStream>::CMyComPtr<ISequentialInStream>(ISequentialInStream *)
.text:000003B5                 mov     [ebp+var_4], 1
.text:000003BC                 mov     ecx, [ebp+arg_8]
.text:000003BF                 push    ecx             ; struct IUnknown *
.text:000003C0                 mov     edx, [ebp+arg_4]
.text:000003C3                 push    edx             ; unsigned int
.text:000003C4                 mov     eax, [ebp+arg_0]
.text:000003C7                 push    eax             ; unsigned __int8 *
.text:000003C8                 mov     ecx, [ebp+var_10] ; this
.text:000003CB                 call    ?Init@CBufInStream@@QAEXPBEIPAUIUnknown@@@Z ; CBufInStream::Init(uchar const *,uint,IUnknown *)
.text:000003D0                 lea     ecx, [ebp+var_18]
.text:000003D3                 call    ?Detach@?$CMyComPtr@UISequentialInStream@@@@QAEPAUISequentialInStream@@XZ ; CMyComPtr<ISequentialInStream>::Detach(void)
.text:000003D8                 mov     ecx, [ebp+arg_C]
.text:000003DB                 mov     [ecx], eax
.text:000003DD                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000003E4                 lea     ecx, [ebp+var_18]
.text:000003E7                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:000003EC                 push    edx
.text:000003ED                 mov     ecx, ebp
.text:000003EF                 push    eax
.text:000003F0                 lea     edx, $LN10
.text:000003F6                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:000003FB                 pop     eax
.text:000003FC                 pop     edx
.text:000003FD                 mov     ecx, [ebp+var_C]
.text:00000400                 mov     large fs:0, ecx
.text:00000407                 pop     ecx
.text:00000408                 add     esp, 28h
.text:0000040B                 cmp     ebp, esp
.text:0000040D                 call    __RTC_CheckEsp
.text:00000412                 mov     esp, ebp
.text:00000414                 pop     ebp
.text:00000415                 retn    10h
.text:00000415 ?Create_BufInStream_WithReference@@YGXPBXIPAUIUnknown@@PAPAUISequentialInStream@@@Z endp
.text:00000415
.text:00000415 ; ---------------------------------------------------------------------------
.text:00000418 $LN10           dd 1                    ; DATA XREF: Create_BufInStream_WithReference(void const *,uint,IUnknown *,ISequentialInStream * *)+D0o
.text:0000041C                 dd offset $LN9
.text:00000420 $LN9            dd 0FFFFFFE8h, 4        ; DATA XREF: .text:0000041Co
.text:00000428                 dd offset $LN7          ; "streamTemp"
.text:0000042C $LN7            db 'streamTemp',0       ; DATA XREF: .text:00000428o
.text:00000437                 align 10h
.text:00000440
.text:00000440 ; =============== S U B R O U T I N E =======================================
.text:00000440
.text:00000440 ; Attributes: bp-based frame
.text:00000440
.text:00000440 ; void __stdcall Create_BufInStream_WithNewBuffer(const void *Src, size_t Size, struct ISequentialInStream **)
.text:00000440                 public ?Create_BufInStream_WithNewBuffer@@YGXPBXIPAPAUISequentialInStream@@@Z
.text:00000440 ?Create_BufInStream_WithNewBuffer@@YGXPBXIPAPAUISequentialInStream@@@Z proc near
.text:00000440
.text:00000440 var_28          = dword ptr -28h
.text:00000440 var_24          = dword ptr -24h
.text:00000440 var_20          = dword ptr -20h
.text:00000440 var_1C          = dword ptr -1Ch
.text:00000440 var_18          = dword ptr -18h
.text:00000440 var_14          = dword ptr -14h
.text:00000440 var_10          = dword ptr -10h
.text:00000440 var_C           = dword ptr -0Ch
.text:00000440 var_4           = dword ptr -4
.text:00000440 Src             = dword ptr  8
.text:00000440 Size            = dword ptr  0Ch
.text:00000440 arg_8           = dword ptr  10h
.text:00000440
.text:00000440                 push    ebp
.text:00000441                 mov     ebp, esp
.text:00000443                 push    0FFFFFFFFh
.text:00000445                 push    offset __ehhandler$?Create_BufInStream_WithNewBuffer@@YGXPBXIPAPAUISequentialInStream@@@Z
.text:0000044A                 mov     eax, large fs:0
.text:00000450                 push    eax
.text:00000451                 sub     esp, 1Ch
.text:00000454                 mov     eax, 0CCCCCCCCh
.text:00000459                 mov     [ebp+var_28], eax
.text:0000045C                 mov     [ebp+var_24], eax
.text:0000045F                 mov     [ebp+var_20], eax
.text:00000462                 mov     [ebp+var_1C], eax
.text:00000465                 mov     [ebp+var_18], eax
.text:00000468                 mov     [ebp+var_14], eax
.text:0000046B                 mov     [ebp+var_10], eax
.text:0000046E                 mov     eax, dword ptr ds:___security_cookie
.text:00000473                 xor     eax, ebp
.text:00000475                 push    eax
.text:00000476                 lea     eax, [ebp+var_C]
.text:00000479                 mov     large fs:0, eax
.text:0000047F                 mov     eax, [ebp+arg_8]
.text:00000482                 mov     dword ptr [eax], 0
.text:00000488                 push    18h             ; unsigned int
.text:0000048A                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0000048F                 add     esp, 4
.text:00000492                 mov     [ebp+var_24], eax
.text:00000495                 mov     [ebp+var_4], 0
.text:0000049C                 cmp     [ebp+var_24], 0
.text:000004A0                 jz      short loc_4AF
.text:000004A2                 mov     ecx, [ebp+var_24]
.text:000004A5                 call    ??0CBufferInStream@@QAE@XZ ; CBufferInStream::CBufferInStream(void)
.text:000004AA                 mov     [ebp+var_28], eax
.text:000004AD                 jmp     short loc_4B6
.text:000004AF ; ---------------------------------------------------------------------------
.text:000004AF
.text:000004AF loc_4AF:                                ; CODE XREF: Create_BufInStream_WithNewBuffer(void const *,uint,ISequentialInStream * *)+60j
.text:000004AF                 mov     [ebp+var_28], 0
.text:000004B6
.text:000004B6 loc_4B6:                                ; CODE XREF: Create_BufInStream_WithNewBuffer(void const *,uint,ISequentialInStream * *)+6Dj
.text:000004B6                 mov     ecx, [ebp+var_28]
.text:000004B9                 mov     [ebp+var_20], ecx
.text:000004BC                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000004C3                 mov     edx, [ebp+var_20]
.text:000004C6                 mov     [ebp+var_10], edx
.text:000004C9                 mov     eax, [ebp+var_10]
.text:000004CC                 push    eax
.text:000004CD                 lea     ecx, [ebp+var_18]
.text:000004D0                 call    ??0?$CMyComPtr@UISequentialInStream@@@@QAE@PAUISequentialInStream@@@Z ; CMyComPtr<ISequentialInStream>::CMyComPtr<ISequentialInStream>(ISequentialInStream *)
.text:000004D5                 mov     [ebp+var_4], 1
.text:000004DC                 mov     ecx, [ebp+Size]
.text:000004DF                 push    ecx             ; Size
.text:000004E0                 mov     edx, [ebp+Src]
.text:000004E3                 push    edx             ; Src
.text:000004E4                 mov     ecx, [ebp+var_10]
.text:000004E7                 add     ecx, 10h
.text:000004EA                 call    ?CopyFrom@?$CBuffer@E@@QAEXPBEI@Z ; CBuffer<uchar>::CopyFrom(uchar const *,uint)
.text:000004EF                 mov     ecx, [ebp+var_10] ; this
.text:000004F2                 call    ?Init@CBufferInStream@@QAEXXZ ; CBufferInStream::Init(void)
.text:000004F7                 lea     ecx, [ebp+var_18]
.text:000004FA                 call    ?Detach@?$CMyComPtr@UISequentialInStream@@@@QAEPAUISequentialInStream@@XZ ; CMyComPtr<ISequentialInStream>::Detach(void)
.text:000004FF                 mov     ecx, [ebp+arg_8]
.text:00000502                 mov     [ecx], eax
.text:00000504                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000050B                 lea     ecx, [ebp+var_18]
.text:0000050E                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:00000513                 push    edx
.text:00000514                 mov     ecx, ebp
.text:00000516                 push    eax
.text:00000517                 lea     edx, $LN10_0
.text:0000051D                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00000522                 pop     eax
.text:00000523                 pop     edx
.text:00000524                 mov     ecx, [ebp+var_C]
.text:00000527                 mov     large fs:0, ecx
.text:0000052E                 pop     ecx
.text:0000052F                 add     esp, 28h
.text:00000532                 cmp     ebp, esp
.text:00000534                 call    __RTC_CheckEsp
.text:00000539                 mov     esp, ebp
.text:0000053B                 pop     ebp
.text:0000053C                 retn    0Ch
.text:0000053C ?Create_BufInStream_WithNewBuffer@@YGXPBXIPAPAUISequentialInStream@@@Z endp
.text:0000053C
.text:0000053C ; ---------------------------------------------------------------------------
.text:0000053F                 align 10h
.text:00000540 $LN10_0         dd 1                    ; DATA XREF: Create_BufInStream_WithNewBuffer(void const *,uint,ISequentialInStream * *)+D7o
.text:00000544                 dd offset $LN9_0
.text:00000548 $LN9_0          dd 0FFFFFFE8h, 4        ; DATA XREF: .text:00000544o
.text:00000550                 dd offset $LN7_0        ; "streamTemp"
.text:00000554 $LN7_0          db 'streamTemp',0       ; DATA XREF: .text:00000550o
.text:0000055F                 align 10h
.text:00000560
.text:00000560 ; =============== S U B R O U T I N E =======================================
.text:00000560
.text:00000560 ; Attributes: bp-based frame
.text:00000560
.text:00000560 ; void __thiscall CByteDynBuffer::Free(CByteDynBuffer *__hidden this)
.text:00000560                 public ?Free@CByteDynBuffer@@QAEXXZ
.text:00000560 ?Free@CByteDynBuffer@@QAEXXZ proc near
.text:00000560
.text:00000560 var_4           = dword ptr -4
.text:00000560
.text:00000560                 push    ebp
.text:00000561                 mov     ebp, esp
.text:00000563                 push    ecx
.text:00000564                 push    esi
.text:00000565                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000056C                 mov     [ebp+var_4], ecx
.text:0000056F                 mov     esi, esp
.text:00000571                 mov     eax, [ebp+var_4]
.text:00000574                 mov     ecx, [eax+4]
.text:00000577                 push    ecx             ; Memory
.text:00000578                 call    dword ptr ds:__imp__free
.text:0000057E                 add     esp, 4
.text:00000581                 cmp     esi, esp
.text:00000583                 call    __RTC_CheckEsp
.text:00000588                 mov     edx, [ebp+var_4]
.text:0000058B                 mov     dword ptr [edx+4], 0
.text:00000592                 mov     eax, [ebp+var_4]
.text:00000595                 mov     dword ptr [eax], 0
.text:0000059B                 pop     esi
.text:0000059C                 add     esp, 4
.text:0000059F                 cmp     ebp, esp
.text:000005A1                 call    __RTC_CheckEsp
.text:000005A6                 mov     esp, ebp
.text:000005A8                 pop     ebp
.text:000005A9                 retn
.text:000005A9 ?Free@CByteDynBuffer@@QAEXXZ endp
.text:000005A9
.text:000005A9 ; ---------------------------------------------------------------------------
.text:000005AA                 align 10h
.text:000005B0
.text:000005B0 ; =============== S U B R O U T I N E =======================================
.text:000005B0
.text:000005B0 ; Attributes: bp-based frame
.text:000005B0
.text:000005B0 ; bool __thiscall CByteDynBuffer::EnsureCapacity(CByteDynBuffer *this, unsigned int)
.text:000005B0                 public ?EnsureCapacity@CByteDynBuffer@@QAE_NI@Z
.text:000005B0 ?EnsureCapacity@CByteDynBuffer@@QAE_NI@Z proc near
.text:000005B0                                         ; CODE XREF: CDynBufSeqOutStream::GetBufPtrForWriting(uint)+33p
.text:000005B0
.text:000005B0 var_C           = dword ptr -0Ch
.text:000005B0 var_8           = dword ptr -8
.text:000005B0 var_4           = dword ptr -4
.text:000005B0 NewSize         = dword ptr  8
.text:000005B0
.text:000005B0                 push    ebp
.text:000005B1                 mov     ebp, esp
.text:000005B3                 sub     esp, 0Ch
.text:000005B6                 push    esi
.text:000005B7                 mov     [ebp+var_C], 0CCCCCCCCh
.text:000005BE                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000005C5                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000005CC                 mov     [ebp+var_4], ecx
.text:000005CF                 mov     eax, [ebp+var_4]
.text:000005D2                 mov     ecx, [ebp+NewSize]
.text:000005D5                 cmp     ecx, [eax]
.text:000005D7                 ja      short loc_5DD
.text:000005D9                 mov     al, 1
.text:000005DB                 jmp     short loc_65C
.text:000005DD ; ---------------------------------------------------------------------------
.text:000005DD
.text:000005DD loc_5DD:                                ; CODE XREF: CByteDynBuffer::EnsureCapacity(uint)+27j
.text:000005DD                 mov     edx, [ebp+var_4]
.text:000005E0                 cmp     dword ptr [edx], 40h ; '@'
.text:000005E3                 jbe     short loc_5F2
.text:000005E5                 mov     eax, [ebp+var_4]
.text:000005E8                 mov     ecx, [eax]
.text:000005EA                 shr     ecx, 2
.text:000005ED                 mov     [ebp+var_8], ecx
.text:000005F0                 jmp     short loc_60A
.text:000005F2 ; ---------------------------------------------------------------------------
.text:000005F2
.text:000005F2 loc_5F2:                                ; CODE XREF: CByteDynBuffer::EnsureCapacity(uint)+33j
.text:000005F2                 mov     edx, [ebp+var_4]
.text:000005F5                 cmp     dword ptr [edx], 8
.text:000005F8                 jbe     short loc_603
.text:000005FA                 mov     [ebp+var_8], 10h
.text:00000601                 jmp     short loc_60A
.text:00000603 ; ---------------------------------------------------------------------------
.text:00000603
.text:00000603 loc_603:                                ; CODE XREF: CByteDynBuffer::EnsureCapacity(uint)+48j
.text:00000603                 mov     [ebp+var_8], 4
.text:0000060A
.text:0000060A loc_60A:                                ; CODE XREF: CByteDynBuffer::EnsureCapacity(uint)+40j
.text:0000060A                                         ; CByteDynBuffer::EnsureCapacity(uint)+51j
.text:0000060A                 mov     eax, [ebp+NewSize]
.text:0000060D                 push    eax
.text:0000060E                 mov     ecx, [ebp+var_4]
.text:00000611                 mov     edx, [ecx]
.text:00000613                 add     edx, [ebp+var_8]
.text:00000616                 push    edx
.text:00000617                 call    ??$MyMax@I@@YGIII@Z ; MyMax<uint>(uint,uint)
.text:0000061C                 mov     [ebp+NewSize], eax
.text:0000061F                 mov     esi, esp
.text:00000621                 mov     eax, [ebp+NewSize]
.text:00000624                 push    eax             ; NewSize
.text:00000625                 mov     ecx, [ebp+var_4]
.text:00000628                 mov     edx, [ecx+4]
.text:0000062B                 push    edx             ; Memory
.text:0000062C                 call    dword ptr ds:__imp__realloc
.text:00000632                 add     esp, 8
.text:00000635                 cmp     esi, esp
.text:00000637                 call    __RTC_CheckEsp
.text:0000063C                 mov     [ebp+var_C], eax
.text:0000063F                 cmp     [ebp+var_C], 0
.text:00000643                 jnz     short loc_649
.text:00000645                 xor     al, al
.text:00000647                 jmp     short loc_65C
.text:00000649 ; ---------------------------------------------------------------------------
.text:00000649
.text:00000649 loc_649:                                ; CODE XREF: CByteDynBuffer::EnsureCapacity(uint)+93j
.text:00000649                 mov     eax, [ebp+var_4]
.text:0000064C                 mov     ecx, [ebp+var_C]
.text:0000064F                 mov     [eax+4], ecx
.text:00000652                 mov     edx, [ebp+var_4]
.text:00000655                 mov     eax, [ebp+NewSize]
.text:00000658                 mov     [edx], eax
.text:0000065A                 mov     al, 1
.text:0000065C
.text:0000065C loc_65C:                                ; CODE XREF: CByteDynBuffer::EnsureCapacity(uint)+2Bj
.text:0000065C                                         ; CByteDynBuffer::EnsureCapacity(uint)+97j
.text:0000065C                 pop     esi
.text:0000065D                 add     esp, 0Ch
.text:00000660                 cmp     ebp, esp
.text:00000662                 call    __RTC_CheckEsp
.text:00000667                 mov     esp, ebp
.text:00000669                 pop     ebp
.text:0000066A                 retn    4
.text:0000066A ?EnsureCapacity@CByteDynBuffer@@QAE_NI@Z endp
.text:0000066A
.text:0000066A ; ---------------------------------------------------------------------------
.text:0000066D                 align 10h
.text:00000670
.text:00000670 ; =============== S U B R O U T I N E =======================================
.text:00000670
.text:00000670 ; Attributes: bp-based frame
.text:00000670
.text:00000670 ; unsigned __int8 *__thiscall CDynBufSeqOutStream::GetBufPtrForWriting(CDynBufSeqOutStream *this, unsigned int)
.text:00000670                 public ?GetBufPtrForWriting@CDynBufSeqOutStream@@QAEPAEI@Z
.text:00000670 ?GetBufPtrForWriting@CDynBufSeqOutStream@@QAEPAEI@Z proc near
.text:00000670                                         ; CODE XREF: CDynBufSeqOutStream::Write(void const *,uint,uint *)+2Bp
.text:00000670
.text:00000670 var_4           = dword ptr -4
.text:00000670 arg_0           = dword ptr  8
.text:00000670
.text:00000670                 push    ebp
.text:00000671                 mov     ebp, esp
.text:00000673                 push    ecx
.text:00000674                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000067B                 mov     [ebp+var_4], ecx
.text:0000067E                 mov     eax, [ebp+var_4]
.text:00000681                 mov     ecx, [ebp+arg_0]
.text:00000684                 add     ecx, [eax+10h]
.text:00000687                 mov     [ebp+arg_0], ecx
.text:0000068A                 mov     edx, [ebp+var_4]
.text:0000068D                 mov     eax, [ebp+arg_0]
.text:00000690                 cmp     eax, [edx+10h]
.text:00000693                 jnb     short loc_699
.text:00000695                 xor     eax, eax
.text:00000697                 jmp     short loc_6C4
.text:00000699 ; ---------------------------------------------------------------------------
.text:00000699
.text:00000699 loc_699:                                ; CODE XREF: CDynBufSeqOutStream::GetBufPtrForWriting(uint)+23j
.text:00000699                 mov     ecx, [ebp+arg_0]
.text:0000069C                 push    ecx             ; unsigned int
.text:0000069D                 mov     ecx, [ebp+var_4]
.text:000006A0                 add     ecx, 8          ; this
.text:000006A3                 call    ?EnsureCapacity@CByteDynBuffer@@QAE_NI@Z ; CByteDynBuffer::EnsureCapacity(uint)
.text:000006A8                 movzx   edx, al
.text:000006AB                 test    edx, edx
.text:000006AD                 jnz     short loc_6B3
.text:000006AF                 xor     eax, eax
.text:000006B1                 jmp     short loc_6C4
.text:000006B3 ; ---------------------------------------------------------------------------
.text:000006B3
.text:000006B3 loc_6B3:                                ; CODE XREF: CDynBufSeqOutStream::GetBufPtrForWriting(uint)+3Dj
.text:000006B3                 mov     ecx, [ebp+var_4]
.text:000006B6                 add     ecx, 8
.text:000006B9                 call    ??BCByteDynBuffer@@QBEPAEXZ ; CByteDynBuffer::operator uchar *(void)
.text:000006BE                 mov     ecx, [ebp+var_4]
.text:000006C1                 add     eax, [ecx+10h]
.text:000006C4
.text:000006C4 loc_6C4:                                ; CODE XREF: CDynBufSeqOutStream::GetBufPtrForWriting(uint)+27j
.text:000006C4                                         ; CDynBufSeqOutStream::GetBufPtrForWriting(uint)+41j
.text:000006C4                 add     esp, 4
.text:000006C7                 cmp     ebp, esp
.text:000006C9                 call    __RTC_CheckEsp
.text:000006CE                 mov     esp, ebp
.text:000006D0                 pop     ebp
.text:000006D1                 retn    4
.text:000006D1 ?GetBufPtrForWriting@CDynBufSeqOutStream@@QAEPAEI@Z endp
.text:000006D1
.text:000006D1 ; ---------------------------------------------------------------------------
.text:000006D4                 align 10h
.text:000006E0
.text:000006E0 ; =============== S U B R O U T I N E =======================================
.text:000006E0
.text:000006E0 ; Attributes: bp-based frame
.text:000006E0
.text:000006E0 ; public: void __thiscall CDynBufSeqOutStream::CopyToBuffer(class CBuffer<unsigned char> &)const
.text:000006E0                 public ?CopyToBuffer@CDynBufSeqOutStream@@QBEXAAV?$CBuffer@E@@@Z
.text:000006E0 ?CopyToBuffer@CDynBufSeqOutStream@@QBEXAAV?$CBuffer@E@@@Z proc near
.text:000006E0
.text:000006E0 var_4           = dword ptr -4
.text:000006E0 arg_0           = dword ptr  8
.text:000006E0
.text:000006E0                 push    ebp
.text:000006E1                 mov     ebp, esp
.text:000006E3                 push    ecx
.text:000006E4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000006EB                 mov     [ebp+var_4], ecx
.text:000006EE                 mov     eax, [ebp+var_4]
.text:000006F1                 mov     ecx, [eax+10h]
.text:000006F4                 push    ecx             ; Size
.text:000006F5                 mov     ecx, [ebp+var_4]
.text:000006F8                 add     ecx, 8
.text:000006FB                 call    ??BCByteDynBuffer@@QBEPBEXZ ; CByteDynBuffer::operator uchar const *(void)
.text:00000700                 push    eax             ; Src
.text:00000701                 mov     ecx, [ebp+arg_0]
.text:00000704                 call    ?CopyFrom@?$CBuffer@E@@QAEXPBEI@Z ; CBuffer<uchar>::CopyFrom(uchar const *,uint)
.text:00000709                 add     esp, 4
.text:0000070C                 cmp     ebp, esp
.text:0000070E                 call    __RTC_CheckEsp
.text:00000713                 mov     esp, ebp
.text:00000715                 pop     ebp
.text:00000716                 retn    4
.text:00000716 ?CopyToBuffer@CDynBufSeqOutStream@@QBEXAAV?$CBuffer@E@@@Z endp
.text:00000716
.text:00000716 ; ---------------------------------------------------------------------------
.text:00000719                 align 10h
.text:00000720
.text:00000720 ; =============== S U B R O U T I N E =======================================
.text:00000720
.text:00000720 ; Attributes: bp-based frame
.text:00000720
.text:00000720 ; __int32 __stdcall CDynBufSeqOutStream::Write(CDynBufSeqOutStream *this, const void *Src, size_t Size, unsigned int *)
.text:00000720                 public ?Write@CDynBufSeqOutStream@@UAGJPBXIPAI@Z
.text:00000720 ?Write@CDynBufSeqOutStream@@UAGJPBXIPAI@Z proc near
.text:00000720
.text:00000720 Dst             = dword ptr -4
.text:00000720 this            = dword ptr  8
.text:00000720 Src             = dword ptr  0Ch
.text:00000720 Size            = dword ptr  10h
.text:00000720 arg_C           = dword ptr  14h
.text:00000720
.text:00000720                 push    ebp
.text:00000721                 mov     ebp, esp
.text:00000723                 push    ecx
.text:00000724                 mov     [ebp+Dst], 0CCCCCCCCh
.text:0000072B                 cmp     [ebp+arg_C], 0
.text:0000072F                 jz      short loc_73A
.text:00000731                 mov     eax, [ebp+arg_C]
.text:00000734                 mov     dword ptr [eax], 0
.text:0000073A
.text:0000073A loc_73A:                                ; CODE XREF: CDynBufSeqOutStream::Write(void const *,uint,uint *)+Fj
.text:0000073A                 cmp     [ebp+Size], 0
.text:0000073E                 jnz     short loc_744
.text:00000740                 xor     eax, eax
.text:00000742                 jmp     short loc_790
.text:00000744 ; ---------------------------------------------------------------------------
.text:00000744
.text:00000744 loc_744:                                ; CODE XREF: CDynBufSeqOutStream::Write(void const *,uint,uint *)+1Ej
.text:00000744                 mov     ecx, [ebp+Size]
.text:00000747                 push    ecx             ; unsigned int
.text:00000748                 mov     ecx, [ebp+this] ; this
.text:0000074B                 call    ?GetBufPtrForWriting@CDynBufSeqOutStream@@QAEPAEI@Z ; CDynBufSeqOutStream::GetBufPtrForWriting(uint)
.text:00000750                 mov     [ebp+Dst], eax
.text:00000753                 cmp     [ebp+Dst], 0
.text:00000757                 jnz     short loc_760
.text:00000759                 mov     eax, 8007000Eh
.text:0000075E                 jmp     short loc_790
.text:00000760 ; ---------------------------------------------------------------------------
.text:00000760
.text:00000760 loc_760:                                ; CODE XREF: CDynBufSeqOutStream::Write(void const *,uint,uint *)+37j
.text:00000760                 mov     edx, [ebp+Size]
.text:00000763                 push    edx             ; Size
.text:00000764                 mov     eax, [ebp+Src]
.text:00000767                 push    eax             ; Src
.text:00000768                 mov     ecx, [ebp+Dst]
.text:0000076B                 push    ecx             ; Dst
.text:0000076C                 call    _memcpy
.text:00000771                 add     esp, 0Ch
.text:00000774                 mov     edx, [ebp+Size]
.text:00000777                 push    edx             ; unsigned int
.text:00000778                 mov     ecx, [ebp+this] ; this
.text:0000077B                 call    ?UpdateSize@CDynBufSeqOutStream@@QAEXI@Z ; CDynBufSeqOutStream::UpdateSize(uint)
.text:00000780                 cmp     [ebp+arg_C], 0
.text:00000784                 jz      short loc_78E
.text:00000786                 mov     eax, [ebp+arg_C]
.text:00000789                 mov     ecx, [ebp+Size]
.text:0000078C                 mov     [eax], ecx
.text:0000078E
.text:0000078E loc_78E:                                ; CODE XREF: CDynBufSeqOutStream::Write(void const *,uint,uint *)+64j
.text:0000078E                 xor     eax, eax
.text:00000790
.text:00000790 loc_790:                                ; CODE XREF: CDynBufSeqOutStream::Write(void const *,uint,uint *)+22j
.text:00000790                                         ; CDynBufSeqOutStream::Write(void const *,uint,uint *)+3Ej
.text:00000790                 add     esp, 4
.text:00000793                 cmp     ebp, esp
.text:00000795                 call    __RTC_CheckEsp
.text:0000079A                 mov     esp, ebp
.text:0000079C                 pop     ebp
.text:0000079D                 retn    10h
.text:0000079D ?Write@CDynBufSeqOutStream@@UAGJPBXIPAI@Z endp
.text:0000079D
.text:000007A0
.text:000007A0 ; =============== S U B R O U T I N E =======================================
.text:000007A0
.text:000007A0 ; Attributes: bp-based frame
.text:000007A0
.text:000007A0 ; __int32 __stdcall CBufPtrSeqOutStream::Write(CBufPtrSeqOutStream *this, const void *Src, unsigned int, unsigned int *)
.text:000007A0                 public ?Write@CBufPtrSeqOutStream@@UAGJPBXIPAI@Z
.text:000007A0 ?Write@CBufPtrSeqOutStream@@UAGJPBXIPAI@Z proc near
.text:000007A0
.text:000007A0 var_8           = dword ptr -8
.text:000007A0 Size            = dword ptr -4
.text:000007A0 this            = dword ptr  8
.text:000007A0 Src             = dword ptr  0Ch
.text:000007A0 arg_8           = dword ptr  10h
.text:000007A0 arg_C           = dword ptr  14h
.text:000007A0
.text:000007A0                 push    ebp
.text:000007A1                 mov     ebp, esp
.text:000007A3                 sub     esp, 8
.text:000007A6                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000007AD                 mov     [ebp+Size], 0CCCCCCCCh
.text:000007B4                 mov     eax, [ebp+this]
.text:000007B7                 mov     ecx, [ebp+this]
.text:000007BA                 mov     edx, [eax+0Ch]
.text:000007BD                 sub     edx, [ecx+10h]
.text:000007C0                 mov     [ebp+Size], edx
.text:000007C3                 mov     eax, [ebp+Size]
.text:000007C6                 cmp     eax, [ebp+arg_8]
.text:000007C9                 jbe     short loc_7D1
.text:000007CB                 mov     ecx, [ebp+arg_8]
.text:000007CE                 mov     [ebp+Size], ecx
.text:000007D1
.text:000007D1 loc_7D1:                                ; CODE XREF: CBufPtrSeqOutStream::Write(void const *,uint,uint *)+29j
.text:000007D1                 cmp     [ebp+Size], 0
.text:000007D5                 jz      short loc_803
.text:000007D7                 mov     edx, [ebp+Size]
.text:000007DA                 push    edx             ; Size
.text:000007DB                 mov     eax, [ebp+Src]
.text:000007DE                 push    eax             ; Src
.text:000007DF                 mov     ecx, [ebp+this]
.text:000007E2                 mov     edx, [ecx+8]
.text:000007E5                 mov     eax, [ebp+this]
.text:000007E8                 add     edx, [eax+10h]
.text:000007EB                 push    edx             ; Dst
.text:000007EC                 call    _memcpy
.text:000007F1                 add     esp, 0Ch
.text:000007F4                 mov     ecx, [ebp+this]
.text:000007F7                 mov     edx, [ecx+10h]
.text:000007FA                 add     edx, [ebp+Size]
.text:000007FD                 mov     eax, [ebp+this]
.text:00000800                 mov     [eax+10h], edx
.text:00000803
.text:00000803 loc_803:                                ; CODE XREF: CBufPtrSeqOutStream::Write(void const *,uint,uint *)+35j
.text:00000803                 cmp     [ebp+arg_C], 0
.text:00000807                 jz      short loc_811
.text:00000809                 mov     ecx, [ebp+arg_C]
.text:0000080C                 mov     edx, [ebp+Size]
.text:0000080F                 mov     [ecx], edx
.text:00000811
.text:00000811 loc_811:                                ; CODE XREF: CBufPtrSeqOutStream::Write(void const *,uint,uint *)+67j
.text:00000811                 cmp     [ebp+Size], 0
.text:00000815                 jnz     short loc_826
.text:00000817                 cmp     [ebp+arg_8], 0
.text:0000081B                 jz      short loc_826
.text:0000081D                 mov     [ebp+var_8], 80004005h
.text:00000824                 jmp     short loc_82D
.text:00000826 ; ---------------------------------------------------------------------------
.text:00000826
.text:00000826 loc_826:                                ; CODE XREF: CBufPtrSeqOutStream::Write(void const *,uint,uint *)+75j
.text:00000826                                         ; CBufPtrSeqOutStream::Write(void const *,uint,uint *)+7Bj
.text:00000826                 mov     [ebp+var_8], 0
.text:0000082D
.text:0000082D loc_82D:                                ; CODE XREF: CBufPtrSeqOutStream::Write(void const *,uint,uint *)+84j
.text:0000082D                 mov     eax, [ebp+var_8]
.text:00000830                 add     esp, 8
.text:00000833                 cmp     ebp, esp
.text:00000835                 call    __RTC_CheckEsp
.text:0000083A                 mov     esp, ebp
.text:0000083C                 pop     ebp
.text:0000083D                 retn    10h
.text:0000083D ?Write@CBufPtrSeqOutStream@@UAGJPBXIPAI@Z endp
.text:0000083D
.text:00000840
.text:00000840 ; =============== S U B R O U T I N E =======================================
.text:00000840
.text:00000840 ; Attributes: bp-based frame
.text:00000840
.text:00000840 ; __int32 __stdcall CSequentialOutStreamSizeCount::Write(CSequentialOutStreamSizeCount *this, const void *, unsigned int, unsigned int *)
.text:00000840                 public ?Write@CSequentialOutStreamSizeCount@@UAGJPBXIPAI@Z
.text:00000840 ?Write@CSequentialOutStreamSizeCount@@UAGJPBXIPAI@Z proc near
.text:00000840
.text:00000840 var_14          = dword ptr -14h
.text:00000840 var_10          = dword ptr -10h
.text:00000840 var_C           = dword ptr -0Ch
.text:00000840 var_8           = dword ptr -8
.text:00000840 var_4           = dword ptr -4
.text:00000840 this            = dword ptr  8
.text:00000840 arg_4           = dword ptr  0Ch
.text:00000840 arg_8           = dword ptr  10h
.text:00000840 arg_C           = dword ptr  14h
.text:00000840
.text:00000840                 push    ebp
.text:00000841                 mov     ebp, esp
.text:00000843                 sub     esp, 14h
.text:00000846                 push    esi
.text:00000847                 mov     eax, 0CCCCCCCCh
.text:0000084C                 mov     [ebp+var_14], eax
.text:0000084F                 mov     [ebp+var_10], eax
.text:00000852                 mov     [ebp+var_C], eax
.text:00000855                 mov     [ebp+var_8], eax
.text:00000858                 mov     [ebp+var_4], eax
.text:0000085B                 mov     ecx, [ebp+this]
.text:0000085E                 add     ecx, 8
.text:00000861                 call    ??C?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ ; CMyComPtr<ISequentialOutStream>::operator->(void)
.text:00000866                 mov     [ebp+var_14], eax
.text:00000869                 mov     esi, esp
.text:0000086B                 lea     eax, [ebp+var_8]
.text:0000086E                 push    eax
.text:0000086F                 mov     ecx, [ebp+arg_8]
.text:00000872                 push    ecx
.text:00000873                 mov     edx, [ebp+arg_4]
.text:00000876                 push    edx
.text:00000877                 mov     eax, [ebp+var_14]
.text:0000087A                 push    eax
.text:0000087B                 mov     ecx, [ebp+var_14]
.text:0000087E                 mov     edx, [ecx]
.text:00000880                 mov     eax, [edx+0Ch]
.text:00000883                 call    eax
.text:00000885                 cmp     esi, esp
.text:00000887                 call    __RTC_CheckEsp
.text:0000088C                 mov     [ebp+var_10], eax
.text:0000088F                 mov     ecx, [ebp+var_8]
.text:00000892                 xor     edx, edx
.text:00000894                 mov     eax, [ebp+this]
.text:00000897                 add     ecx, [eax+10h]
.text:0000089A                 adc     edx, [eax+14h]
.text:0000089D                 mov     eax, [ebp+this]
.text:000008A0                 mov     [eax+10h], ecx
.text:000008A3                 mov     [eax+14h], edx
.text:000008A6                 cmp     [ebp+arg_C], 0
.text:000008AA                 jz      short loc_8B4
.text:000008AC                 mov     ecx, [ebp+arg_C]
.text:000008AF                 mov     edx, [ebp+var_8]
.text:000008B2                 mov     [ecx], edx
.text:000008B4
.text:000008B4 loc_8B4:                                ; CODE XREF: CSequentialOutStreamSizeCount::Write(void const *,uint,uint *)+6Aj
.text:000008B4                 mov     eax, [ebp+var_10]
.text:000008B7                 push    edx
.text:000008B8                 mov     ecx, ebp
.text:000008BA                 push    eax
.text:000008BB                 lea     edx, $LN6
.text:000008C1                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:000008C6                 pop     eax
.text:000008C7                 pop     edx
.text:000008C8                 pop     esi
.text:000008C9                 add     esp, 14h
.text:000008CC                 cmp     ebp, esp
.text:000008CE                 call    __RTC_CheckEsp
.text:000008D3                 mov     esp, ebp
.text:000008D5                 pop     ebp
.text:000008D6                 retn    10h
.text:000008D6 ?Write@CSequentialOutStreamSizeCount@@UAGJPBXIPAI@Z endp
.text:000008D6
.text:000008D6 ; ---------------------------------------------------------------------------
.text:000008D9                 align 4
.text:000008DC $LN6            dd 1                    ; DATA XREF: CSequentialOutStreamSizeCount::Write(void const *,uint,uint *)+7Bo
.text:000008E0                 dd offset $LN5
.text:000008E4 $LN5            dd 0FFFFFFF8h, 4        ; DATA XREF: .text:000008E0o
.text:000008EC                 dd offset $LN4          ; "realProcessedSize"
.text:000008F0 $LN4            db 'realProcessedSize',0 ; DATA XREF: .text:000008ECo
.text:00000902                 align 10h
.text:00000910
.text:00000910 ; =============== S U B R O U T I N E =======================================
.text:00000910
.text:00000910 ; Attributes: bp-based frame
.text:00000910
.text:00000910 ; void __thiscall CCachedInStream::Free(CCachedInStream *__hidden this)
.text:00000910                 public ?Free@CCachedInStream@@QAEXXZ
.text:00000910 ?Free@CCachedInStream@@QAEXXZ proc near
.text:00000910
.text:00000910 var_4           = dword ptr -4
.text:00000910
.text:00000910                 push    ebp
.text:00000911                 mov     ebp, esp
.text:00000913                 push    ecx
.text:00000914                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000091B                 mov     [ebp+var_4], ecx
.text:0000091E                 mov     eax, [ebp+var_4]
.text:00000921                 mov     ecx, [eax+8]
.text:00000924                 push    ecx
.text:00000925                 call    _MyFree@4       ; MyFree(x)
.text:0000092A                 mov     edx, [ebp+var_4]
.text:0000092D                 mov     dword ptr [edx+8], 0
.text:00000934                 mov     eax, [ebp+var_4]
.text:00000937                 mov     ecx, [eax+0Ch]
.text:0000093A                 push    ecx
.text:0000093B                 call    _MidFree@4      ; MidFree(x)
.text:00000940                 mov     edx, [ebp+var_4]
.text:00000943                 mov     dword ptr [edx+0Ch], 0
.text:0000094A                 add     esp, 4
.text:0000094D                 cmp     ebp, esp
.text:0000094F                 call    __RTC_CheckEsp
.text:00000954                 mov     esp, ebp
.text:00000956                 pop     ebp
.text:00000957                 retn
.text:00000957 ?Free@CCachedInStream@@QAEXXZ endp
.text:00000957
.text:00000957 ; ---------------------------------------------------------------------------
.text:00000958                 align 10h
.text:00000960
.text:00000960 ; =============== S U B R O U T I N E =======================================
.text:00000960
.text:00000960 ; Attributes: bp-based frame
.text:00000960
.text:00000960 ; bool __thiscall CCachedInStream::Alloc(CCachedInStream *this, unsigned int, unsigned int)
.text:00000960                 public ?Alloc@CCachedInStream@@QAE_NII@Z
.text:00000960 ?Alloc@CCachedInStream@@QAE_NII@Z proc near
.text:00000960
.text:00000960 var_C           = dword ptr -0Ch
.text:00000960 var_8           = dword ptr -8
.text:00000960 var_4           = dword ptr -4
.text:00000960 arg_0           = dword ptr  8
.text:00000960 arg_4           = dword ptr  0Ch
.text:00000960
.text:00000960                 push    ebp
.text:00000961                 mov     ebp, esp
.text:00000963                 sub     esp, 0Ch
.text:00000966                 mov     [ebp+var_C], 0CCCCCCCCh
.text:0000096D                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00000974                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000097B                 mov     [ebp+var_4], ecx
.text:0000097E                 mov     eax, [ebp+arg_0]
.text:00000981                 add     eax, [ebp+arg_4]
.text:00000984                 mov     [ebp+var_8], eax
.text:00000987                 cmp     [ebp+var_8], 20h ; ' '
.text:0000098B                 jb      short loc_994
.text:0000098D                 xor     al, al
.text:0000098F                 jmp     loc_A3D
.text:00000994 ; ---------------------------------------------------------------------------
.text:00000994
.text:00000994 loc_994:                                ; CODE XREF: CCachedInStream::Alloc(uint,uint)+2Bj
.text:00000994                 mov     edx, 1
.text:00000999                 mov     ecx, [ebp+var_8]
.text:0000099C                 shl     edx, cl
.text:0000099E                 mov     [ebp+var_C], edx
.text:000009A1                 mov     eax, [ebp+var_4]
.text:000009A4                 cmp     dword ptr [eax+0Ch], 0
.text:000009A8                 jz      short loc_9B5
.text:000009AA                 mov     ecx, [ebp+var_4]
.text:000009AD                 mov     edx, [ebp+var_C]
.text:000009B0                 cmp     edx, [ecx+10h]
.text:000009B3                 jz      short loc_9E6
.text:000009B5
.text:000009B5 loc_9B5:                                ; CODE XREF: CCachedInStream::Alloc(uint,uint)+48j
.text:000009B5                 mov     eax, [ebp+var_4]
.text:000009B8                 mov     ecx, [eax+0Ch]
.text:000009BB                 push    ecx
.text:000009BC                 call    _MidFree@4      ; MidFree(x)
.text:000009C1                 mov     edx, [ebp+var_C]
.text:000009C4                 push    edx
.text:000009C5                 call    _MidAlloc@4     ; MidAlloc(x)
.text:000009CA                 mov     ecx, [ebp+var_4]
.text:000009CD                 mov     [ecx+0Ch], eax
.text:000009D0                 mov     edx, [ebp+var_4]
.text:000009D3                 cmp     dword ptr [edx+0Ch], 0
.text:000009D7                 jnz     short loc_9DD
.text:000009D9                 xor     al, al
.text:000009DB                 jmp     short loc_A3D
.text:000009DD ; ---------------------------------------------------------------------------
.text:000009DD
.text:000009DD loc_9DD:                                ; CODE XREF: CCachedInStream::Alloc(uint,uint)+77j
.text:000009DD                 mov     eax, [ebp+var_4]
.text:000009E0                 mov     ecx, [ebp+var_C]
.text:000009E3                 mov     [eax+10h], ecx
.text:000009E6
.text:000009E6 loc_9E6:                                ; CODE XREF: CCachedInStream::Alloc(uint,uint)+53j
.text:000009E6                 mov     edx, [ebp+var_4]
.text:000009E9                 cmp     dword ptr [edx+8], 0
.text:000009ED                 jz      short loc_9FA
.text:000009EF                 mov     eax, [ebp+var_4]
.text:000009F2                 mov     ecx, [ebp+arg_4]
.text:000009F5                 cmp     ecx, [eax+18h]
.text:000009F8                 jz      short loc_A32
.text:000009FA
.text:000009FA loc_9FA:                                ; CODE XREF: CCachedInStream::Alloc(uint,uint)+8Dj
.text:000009FA                 mov     edx, [ebp+var_4]
.text:000009FD                 mov     eax, [edx+8]
.text:00000A00                 push    eax
.text:00000A01                 call    _MyFree@4       ; MyFree(x)
.text:00000A06                 mov     edx, 8
.text:00000A0B                 mov     ecx, [ebp+arg_4]
.text:00000A0E                 shl     edx, cl
.text:00000A10                 push    edx
.text:00000A11                 call    _MyAlloc@4      ; MyAlloc(x)
.text:00000A16                 mov     ecx, [ebp+var_4]
.text:00000A19                 mov     [ecx+8], eax
.text:00000A1C                 mov     edx, [ebp+var_4]
.text:00000A1F                 cmp     dword ptr [edx+8], 0
.text:00000A23                 jnz     short loc_A29
.text:00000A25                 xor     al, al
.text:00000A27                 jmp     short loc_A3D
.text:00000A29 ; ---------------------------------------------------------------------------
.text:00000A29
.text:00000A29 loc_A29:                                ; CODE XREF: CCachedInStream::Alloc(uint,uint)+C3j
.text:00000A29                 mov     eax, [ebp+var_4]
.text:00000A2C                 mov     ecx, [ebp+arg_4]
.text:00000A2F                 mov     [eax+18h], ecx
.text:00000A32
.text:00000A32 loc_A32:                                ; CODE XREF: CCachedInStream::Alloc(uint,uint)+98j
.text:00000A32                 mov     edx, [ebp+var_4]
.text:00000A35                 mov     eax, [ebp+arg_0]
.text:00000A38                 mov     [edx+14h], eax
.text:00000A3B                 mov     al, 1
.text:00000A3D
.text:00000A3D loc_A3D:                                ; CODE XREF: CCachedInStream::Alloc(uint,uint)+2Fj
.text:00000A3D                                         ; CCachedInStream::Alloc(uint,uint)+7Bj ...
.text:00000A3D                 add     esp, 0Ch
.text:00000A40                 cmp     ebp, esp
.text:00000A42                 call    __RTC_CheckEsp
.text:00000A47                 mov     esp, ebp
.text:00000A49                 pop     ebp
.text:00000A4A                 retn    8
.text:00000A4A ?Alloc@CCachedInStream@@QAE_NII@Z endp
.text:00000A4A
.text:00000A4A ; ---------------------------------------------------------------------------
.text:00000A4D                 align 10h
.text:00000A50
.text:00000A50 ; =============== S U B R O U T I N E =======================================
.text:00000A50
.text:00000A50 ; Attributes: bp-based frame
.text:00000A50
.text:00000A50 ; void __thiscall CCachedInStream::Init(CCachedInStream *this, unsigned __int64)
.text:00000A50                 public ?Init@CCachedInStream@@QAEX_K@Z
.text:00000A50 ?Init@CCachedInStream@@QAEX_K@Z proc near
.text:00000A50
.text:00000A50 var_C           = dword ptr -0Ch
.text:00000A50 var_8           = dword ptr -8
.text:00000A50 var_4           = dword ptr -4
.text:00000A50 arg_0           = qword ptr  8
.text:00000A50
.text:00000A50                 push    ebp
.text:00000A51                 mov     ebp, esp
.text:00000A53                 sub     esp, 0Ch
.text:00000A56                 mov     [ebp+var_C], 0CCCCCCCCh
.text:00000A5D                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00000A64                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000A6B                 mov     [ebp+var_4], ecx
.text:00000A6E                 mov     eax, [ebp+var_4]
.text:00000A71                 mov     ecx, dword ptr [ebp+arg_0]
.text:00000A74                 mov     [eax+20h], ecx
.text:00000A77                 mov     edx, dword ptr [ebp+arg_0+4]
.text:00000A7A                 mov     [eax+24h], edx
.text:00000A7D                 mov     eax, [ebp+var_4]
.text:00000A80                 mov     dword ptr [eax+28h], 0
.text:00000A87                 mov     dword ptr [eax+2Ch], 0
.text:00000A8E                 mov     ecx, [ebp+var_4]
.text:00000A91                 mov     edx, 1
.text:00000A96                 mov     ecx, [ecx+18h]
.text:00000A99                 shl     edx, cl
.text:00000A9B                 mov     [ebp+var_8], edx
.text:00000A9E                 mov     [ebp+var_C], 0
.text:00000AA5                 jmp     short loc_AB0
.text:00000AA7 ; ---------------------------------------------------------------------------
.text:00000AA7
.text:00000AA7 loc_AA7:                                ; CODE XREF: CCachedInStream::Init(unsigned __int64)+80j
.text:00000AA7                 mov     eax, [ebp+var_C]
.text:00000AAA                 add     eax, 1
.text:00000AAD                 mov     [ebp+var_C], eax
.text:00000AB0
.text:00000AB0 loc_AB0:                                ; CODE XREF: CCachedInStream::Init(unsigned __int64)+55j
.text:00000AB0                 mov     ecx, [ebp+var_C]
.text:00000AB3                 cmp     ecx, [ebp+var_8]
.text:00000AB6                 jnb     short loc_AD2
.text:00000AB8                 mov     edx, [ebp+var_4]
.text:00000ABB                 mov     eax, [edx+8]
.text:00000ABE                 mov     ecx, [ebp+var_C]
.text:00000AC1                 mov     dword ptr [eax+ecx*8], 0FFFFFFFFh
.text:00000AC8                 mov     dword ptr [eax+ecx*8+4], 0FFFFFFFFh
.text:00000AD0                 jmp     short loc_AA7
.text:00000AD2 ; ---------------------------------------------------------------------------
.text:00000AD2
.text:00000AD2 loc_AD2:                                ; CODE XREF: CCachedInStream::Init(unsigned __int64)+66j
.text:00000AD2                 mov     esp, ebp
.text:00000AD4                 pop     ebp
.text:00000AD5                 retn    8
.text:00000AD5 ?Init@CCachedInStream@@QAEX_K@Z endp
.text:00000AD5
.text:00000AD5 ; ---------------------------------------------------------------------------
.text:00000AD8                 align 10h
.text:00000AE0
.text:00000AE0 ; =============== S U B R O U T I N E =======================================
.text:00000AE0
.text:00000AE0 ; Attributes: bp-based frame
.text:00000AE0
.text:00000AE0 ; __int32 __stdcall CCachedInStream::Read(CCachedInStream *this, void *Dst, unsigned int, unsigned int *)
.text:00000AE0                 public ?Read@CCachedInStream@@UAGJPAXIPAI@Z
.text:00000AE0 ?Read@CCachedInStream@@UAGJPAXIPAI@Z proc near
.text:00000AE0
.text:00000AE0 var_50          = dword ptr -50h
.text:00000AE0 var_4C          = dword ptr -4Ch
.text:00000AE0 var_48          = dword ptr -48h
.text:00000AE0 var_44          = dword ptr -44h
.text:00000AE0 var_40          = dword ptr -40h
.text:00000AE0 var_3C          = dword ptr -3Ch
.text:00000AE0 var_38          = dword ptr -38h
.text:00000AE0 var_34          = dword ptr -34h
.text:00000AE0 Size            = dword ptr -30h
.text:00000AE0 var_2C          = dword ptr -2Ch
.text:00000AE0 var_28          = dword ptr -28h
.text:00000AE0 var_24          = dword ptr -24h
.text:00000AE0 var_20          = dword ptr -20h
.text:00000AE0 var_1C          = dword ptr -1Ch
.text:00000AE0 var_18          = dword ptr -18h
.text:00000AE0 var_14          = dword ptr -14h
.text:00000AE0 var_10          = dword ptr -10h
.text:00000AE0 var_C           = dword ptr -0Ch
.text:00000AE0 var_8           = dword ptr -8
.text:00000AE0 var_4           = dword ptr -4
.text:00000AE0 this            = dword ptr  8
.text:00000AE0 Dst             = dword ptr  0Ch
.text:00000AE0 arg_8           = dword ptr  10h
.text:00000AE0 arg_C           = dword ptr  14h
.text:00000AE0
.text:00000AE0                 push    ebp
.text:00000AE1                 mov     ebp, esp
.text:00000AE3                 sub     esp, 50h
.text:00000AE6                 push    esi
.text:00000AE7                 push    edi
.text:00000AE8                 lea     edi, [ebp+var_50]
.text:00000AEB                 mov     ecx, 14h
.text:00000AF0                 mov     eax, 0CCCCCCCCh
.text:00000AF5                 rep stosd
.text:00000AF7                 cmp     [ebp+arg_C], 0
.text:00000AFB                 jz      short loc_B06
.text:00000AFD                 mov     eax, [ebp+arg_C]
.text:00000B00                 mov     dword ptr [eax], 0
.text:00000B06
.text:00000B06 loc_B06:                                ; CODE XREF: CCachedInStream::Read(void *,uint,uint *)+1Bj
.text:00000B06                 cmp     [ebp+arg_8], 0
.text:00000B0A                 jnz     short loc_B13
.text:00000B0C                 xor     eax, eax
.text:00000B0E                 jmp     loc_D35
.text:00000B13 ; ---------------------------------------------------------------------------
.text:00000B13
.text:00000B13 loc_B13:                                ; CODE XREF: CCachedInStream::Read(void *,uint,uint *)+2Aj
.text:00000B13                 mov     ecx, [ebp+this]
.text:00000B16                 mov     edx, [ebp+this]
.text:00000B19                 mov     [ebp+var_34], ecx
.text:00000B1C                 mov     [ebp+var_38], edx
.text:00000B1F                 mov     eax, [ebp+var_34]
.text:00000B22                 mov     ecx, [ebp+var_38]
.text:00000B25                 mov     edx, [eax+2Ch]
.text:00000B28                 cmp     edx, [ecx+24h]
.text:00000B2B                 jb      short loc_B44
.text:00000B2D                 ja      short loc_B3D
.text:00000B2F                 mov     eax, [ebp+var_34]
.text:00000B32                 mov     ecx, [ebp+var_38]
.text:00000B35                 mov     edx, [eax+28h]
.text:00000B38                 cmp     edx, [ecx+20h]
.text:00000B3B                 jb      short loc_B44
.text:00000B3D
.text:00000B3D loc_B3D:                                ; CODE XREF: CCachedInStream::Read(void *,uint,uint *)+4Dj
.text:00000B3D                 xor     eax, eax
.text:00000B3F                 jmp     loc_D35
.text:00000B44 ; ---------------------------------------------------------------------------
.text:00000B44
.text:00000B44 loc_B44:                                ; CODE XREF: CCachedInStream::Read(void *,uint,uint *)+4Bj
.text:00000B44                                         ; CCachedInStream::Read(void *,uint,uint *)+5Bj
.text:00000B44                 mov     eax, [ebp+this]
.text:00000B47                 mov     ecx, [ebp+this]
.text:00000B4A                 mov     edx, [eax+20h]
.text:00000B4D                 sub     edx, [ecx+28h]
.text:00000B50                 mov     eax, [eax+24h]
.text:00000B53                 sbb     eax, [ecx+2Ch]
.text:00000B56                 mov     [ebp+var_8], edx
.text:00000B59                 mov     [ebp+var_4], eax
.text:00000B5C                 mov     ecx, [ebp+arg_8]
.text:00000B5F                 xor     edx, edx
.text:00000B61                 mov     [ebp+var_40], ecx
.text:00000B64                 mov     [ebp+var_3C], edx
.text:00000B67                 mov     eax, [ebp+var_3C]
.text:00000B6A                 cmp     eax, [ebp+var_4]
.text:00000B6D                 jb      short loc_B7F
.text:00000B6F                 ja      short loc_B79
.text:00000B71                 mov     ecx, [ebp+var_40]
.text:00000B74                 cmp     ecx, [ebp+var_8]
.text:00000B77                 jbe     short loc_B7F
.text:00000B79
.text:00000B79 loc_B79:                                ; CODE XREF: CCachedInStream::Read(void *,uint,uint *)+8Fj
.text:00000B79                 mov     edx, [ebp+var_8]
.text:00000B7C                 mov     [ebp+arg_8], edx
.text:00000B7F
.text:00000B7F loc_B7F:                                ; CODE XREF: CCachedInStream::Read(void *,uint,uint *)+8Dj
.text:00000B7F                                         ; CCachedInStream::Read(void *,uint,uint *)+97j ...
.text:00000B7F                 cmp     [ebp+arg_8], 0
.text:00000B83                 jz      loc_D33
.text:00000B89                 mov     ecx, [ebp+this]
.text:00000B8C                 mov     esi, [ebp+this]
.text:00000B8F                 mov     eax, [ecx+28h]
.text:00000B92                 mov     edx, [ecx+2Ch]
.text:00000B95                 mov     ecx, [esi+14h]
.text:00000B98                 call    __aullshr
.text:00000B9D                 mov     [ebp+var_10], eax
.text:00000BA0                 mov     [ebp+var_C], edx
.text:00000BA3                 mov     edx, [ebp+var_10]
.text:00000BA6                 mov     eax, [ebp+this]
.text:00000BA9                 mov     esi, 1
.text:00000BAE                 mov     ecx, [eax+18h]
.text:00000BB1                 shl     esi, cl
.text:00000BB3                 sub     esi, 1
.text:00000BB6                 and     edx, esi
.text:00000BB8                 mov     [ebp+var_14], edx
.text:00000BBB                 mov     ecx, [ebp+this]
.text:00000BBE                 mov     edx, [ebp+var_14]
.text:00000BC1                 mov     ecx, [ecx+14h]
.text:00000BC4                 shl     edx, cl
.text:00000BC6                 mov     eax, [ebp+this]
.text:00000BC9                 add     edx, [eax+0Ch]
.text:00000BCC                 mov     [ebp+var_18], edx
.text:00000BCF                 mov     ecx, [ebp+this]
.text:00000BD2                 mov     edx, [ecx+8]
.text:00000BD5                 mov     eax, [ebp+var_14]
.text:00000BD8                 mov     [ebp+var_44], edx
.text:00000BDB                 mov     [ebp+var_48], eax
.text:00000BDE                 mov     ecx, [ebp+var_48]
.text:00000BE1                 mov     edx, [ebp+var_44]
.text:00000BE4                 mov     eax, [edx+ecx*8]
.text:00000BE7                 cmp     eax, [ebp+var_10]
.text:00000BEA                 jnz     short loc_BFF
.text:00000BEC                 mov     ecx, [ebp+var_48]
.text:00000BEF                 mov     edx, [ebp+var_44]
.text:00000BF2                 mov     eax, [edx+ecx*8+4]
.text:00000BF6                 cmp     eax, [ebp+var_C]
.text:00000BF9                 jz      loc_CA3
.text:00000BFF
.text:00000BFF loc_BFF:                                ; CODE XREF: CCachedInStream::Read(void *,uint,uint *)+10Aj
.text:00000BFF                 mov     ecx, [ebp+this]
.text:00000C02                 mov     eax, [ebp+var_10]
.text:00000C05                 mov     edx, [ebp+var_C]
.text:00000C08                 mov     ecx, [ecx+14h]
.text:00000C0B                 call    __allshl
.text:00000C10                 mov     ecx, [ebp+this]
.text:00000C13                 mov     esi, [ecx+20h]
.text:00000C16                 sub     esi, eax
.text:00000C18                 mov     eax, [ecx+24h]
.text:00000C1B                 sbb     eax, edx
.text:00000C1D                 mov     [ebp+var_20], esi
.text:00000C20                 mov     [ebp+var_1C], eax
.text:00000C23                 mov     ecx, [ebp+this]
.text:00000C26                 mov     edx, 1
.text:00000C2B                 mov     ecx, [ecx+14h]
.text:00000C2E                 shl     edx, cl
.text:00000C30                 mov     [ebp+var_24], edx
.text:00000C33                 mov     eax, [ebp+var_24]
.text:00000C36                 xor     ecx, ecx
.text:00000C38                 mov     [ebp+var_50], eax
.text:00000C3B                 mov     [ebp+var_4C], ecx
.text:00000C3E                 mov     edx, [ebp+var_4C]
.text:00000C41                 cmp     edx, [ebp+var_1C]
.text:00000C44                 jb      short loc_C56
.text:00000C46                 ja      short loc_C50
.text:00000C48                 mov     eax, [ebp+var_50]
.text:00000C4B                 cmp     eax, [ebp+var_20]
.text:00000C4E                 jbe     short loc_C56
.text:00000C50
.text:00000C50 loc_C50:                                ; CODE XREF: CCachedInStream::Read(void *,uint,uint *)+166j
.text:00000C50                 mov     ecx, [ebp+var_20]
.text:00000C53                 mov     [ebp+var_24], ecx
.text:00000C56
.text:00000C56 loc_C56:                                ; CODE XREF: CCachedInStream::Read(void *,uint,uint *)+164j
.text:00000C56                                         ; CCachedInStream::Read(void *,uint,uint *)+16Ej
.text:00000C56                 mov     esi, esp
.text:00000C58                 mov     edx, [ebp+var_24]
.text:00000C5B                 push    edx
.text:00000C5C                 mov     eax, [ebp+var_18]
.text:00000C5F                 push    eax
.text:00000C60                 mov     ecx, [ebp+var_C]
.text:00000C63                 push    ecx
.text:00000C64                 mov     edx, [ebp+var_10]
.text:00000C67                 push    edx
.text:00000C68                 mov     eax, [ebp+this]
.text:00000C6B                 mov     edx, [eax]
.text:00000C6D                 mov     ecx, [ebp+this]
.text:00000C70                 mov     eax, [edx+14h]
.text:00000C73                 call    eax
.text:00000C75                 cmp     esi, esp
.text:00000C77                 call    __RTC_CheckEsp
.text:00000C7C                 mov     [ebp+var_28], eax
.text:00000C7F                 cmp     [ebp+var_28], 0
.text:00000C83                 jz      short loc_C8D
.text:00000C85                 mov     eax, [ebp+var_28]
.text:00000C88                 jmp     loc_D35
.text:00000C8D ; ---------------------------------------------------------------------------
.text:00000C8D
.text:00000C8D loc_C8D:                                ; CODE XREF: CCachedInStream::Read(void *,uint,uint *)+1A3j
.text:00000C8D                 mov     ecx, [ebp+this]
.text:00000C90                 mov     edx, [ecx+8]
.text:00000C93                 mov     eax, [ebp+var_14]
.text:00000C96                 mov     ecx, [ebp+var_10]
.text:00000C99                 mov     [edx+eax*8], ecx
.text:00000C9C                 mov     ecx, [ebp+var_C]
.text:00000C9F                 mov     [edx+eax*8+4], ecx
.text:00000CA3
.text:00000CA3 loc_CA3:                                ; CODE XREF: CCachedInStream::Read(void *,uint,uint *)+119j
.text:00000CA3                 mov     edx, [ebp+this]
.text:00000CA6                 mov     eax, [edx+28h]
.text:00000CA9                 mov     ecx, [ebp+this]
.text:00000CAC                 mov     edx, 1
.text:00000CB1                 mov     ecx, [ecx+14h]
.text:00000CB4                 shl     edx, cl
.text:00000CB6                 sub     edx, 1
.text:00000CB9                 and     eax, edx
.text:00000CBB                 mov     [ebp+var_2C], eax
.text:00000CBE                 mov     eax, [ebp+arg_8]
.text:00000CC1                 push    eax
.text:00000CC2                 mov     ecx, [ebp+this]
.text:00000CC5                 mov     edx, 1
.text:00000CCA                 mov     ecx, [ecx+14h]
.text:00000CCD                 shl     edx, cl
.text:00000CCF                 sub     edx, [ebp+var_2C]
.text:00000CD2                 push    edx
.text:00000CD3                 call    ??$MyMin@I@@YGIII@Z ; MyMin<uint>(uint,uint)
.text:00000CD8                 mov     [ebp+Size], eax
.text:00000CDB                 mov     eax, [ebp+Size]
.text:00000CDE                 push    eax             ; Size
.text:00000CDF                 mov     ecx, [ebp+var_18]
.text:00000CE2                 add     ecx, [ebp+var_2C]
.text:00000CE5                 push    ecx             ; Src
.text:00000CE6                 mov     edx, [ebp+Dst]
.text:00000CE9                 push    edx             ; Dst
.text:00000CEA                 call    _memcpy
.text:00000CEF                 add     esp, 0Ch
.text:00000CF2                 cmp     [ebp+arg_C], 0
.text:00000CF6                 jz      short loc_D05
.text:00000CF8                 mov     eax, [ebp+arg_C]
.text:00000CFB                 mov     ecx, [eax]
.text:00000CFD                 add     ecx, [ebp+Size]
.text:00000D00                 mov     edx, [ebp+arg_C]
.text:00000D03                 mov     [edx], ecx
.text:00000D05
.text:00000D05 loc_D05:                                ; CODE XREF: CCachedInStream::Read(void *,uint,uint *)+216j
.text:00000D05                 mov     eax, [ebp+Dst]
.text:00000D08                 add     eax, [ebp+Size]
.text:00000D0B                 mov     [ebp+Dst], eax
.text:00000D0E                 mov     ecx, [ebp+Size]
.text:00000D11                 xor     edx, edx
.text:00000D13                 mov     eax, [ebp+this]
.text:00000D16                 add     ecx, [eax+28h]
.text:00000D19                 adc     edx, [eax+2Ch]
.text:00000D1C                 mov     eax, [ebp+this]
.text:00000D1F                 mov     [eax+28h], ecx
.text:00000D22                 mov     [eax+2Ch], edx
.text:00000D25                 mov     ecx, [ebp+arg_8]
.text:00000D28                 sub     ecx, [ebp+Size]
.text:00000D2B                 mov     [ebp+arg_8], ecx
.text:00000D2E                 jmp     loc_B7F
.text:00000D33 ; ---------------------------------------------------------------------------
.text:00000D33
.text:00000D33 loc_D33:                                ; CODE XREF: CCachedInStream::Read(void *,uint,uint *)+A3j
.text:00000D33                 xor     eax, eax
.text:00000D35
.text:00000D35 loc_D35:                                ; CODE XREF: CCachedInStream::Read(void *,uint,uint *)+2Ej
.text:00000D35                                         ; CCachedInStream::Read(void *,uint,uint *)+5Fj ...
.text:00000D35                 pop     edi
.text:00000D36                 pop     esi
.text:00000D37                 add     esp, 50h
.text:00000D3A                 cmp     ebp, esp
.text:00000D3C                 call    __RTC_CheckEsp
.text:00000D41                 mov     esp, ebp
.text:00000D43                 pop     ebp
.text:00000D44                 retn    10h
.text:00000D44 ?Read@CCachedInStream@@UAGJPAXIPAI@Z endp
.text:00000D44
.text:00000D44 ; ---------------------------------------------------------------------------
.text:00000D47                 align 10h
.text:00000D50
.text:00000D50 ; =============== S U B R O U T I N E =======================================
.text:00000D50
.text:00000D50 ; Attributes: bp-based frame
.text:00000D50
.text:00000D50 ; __int32 __stdcall CCachedInStream::Seek(CCachedInStream *this, __int64, unsigned int, unsigned __int64 *)
.text:00000D50                 public ?Seek@CCachedInStream@@UAGJ_JIPA_K@Z
.text:00000D50 ?Seek@CCachedInStream@@UAGJ_JIPA_K@Z proc near
.text:00000D50
.text:00000D50 var_4           = dword ptr -4
.text:00000D50 this            = dword ptr  8
.text:00000D50 arg_4           = qword ptr  0Ch
.text:00000D50 arg_C           = dword ptr  14h
.text:00000D50 arg_10          = dword ptr  18h
.text:00000D50
.text:00000D50                 push    ebp
.text:00000D51                 mov     ebp, esp
.text:00000D53                 push    ecx
.text:00000D54                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000D5B                 mov     eax, [ebp+arg_C]
.text:00000D5E                 mov     [ebp+var_4], eax
.text:00000D61                 cmp     [ebp+var_4], 0
.text:00000D65                 jz      short loc_D75
.text:00000D67                 cmp     [ebp+var_4], 1
.text:00000D6B                 jz      short loc_D77
.text:00000D6D                 cmp     [ebp+var_4], 2
.text:00000D71                 jz      short loc_D8E
.text:00000D73                 jmp     short loc_DA5
.text:00000D75 ; ---------------------------------------------------------------------------
.text:00000D75
.text:00000D75 loc_D75:                                ; CODE XREF: CCachedInStream::Seek(__int64,uint,unsigned __int64 *)+15j
.text:00000D75                 jmp     short loc_DAC
.text:00000D77 ; ---------------------------------------------------------------------------
.text:00000D77
.text:00000D77 loc_D77:                                ; CODE XREF: CCachedInStream::Seek(__int64,uint,unsigned __int64 *)+1Bj
.text:00000D77                 mov     ecx, [ebp+this]
.text:00000D7A                 mov     edx, dword ptr [ebp+arg_4]
.text:00000D7D                 add     edx, [ecx+28h]
.text:00000D80                 mov     eax, dword ptr [ebp+arg_4+4]
.text:00000D83                 adc     eax, [ecx+2Ch]
.text:00000D86                 mov     dword ptr [ebp+arg_4], edx
.text:00000D89                 mov     dword ptr [ebp+arg_4+4], eax
.text:00000D8C                 jmp     short loc_DAC
.text:00000D8E ; ---------------------------------------------------------------------------
.text:00000D8E
.text:00000D8E loc_D8E:                                ; CODE XREF: CCachedInStream::Seek(__int64,uint,unsigned __int64 *)+21j
.text:00000D8E                 mov     ecx, [ebp+this]
.text:00000D91                 mov     edx, dword ptr [ebp+arg_4]
.text:00000D94                 add     edx, [ecx+20h]
.text:00000D97                 mov     eax, dword ptr [ebp+arg_4+4]
.text:00000D9A                 adc     eax, [ecx+24h]
.text:00000D9D                 mov     dword ptr [ebp+arg_4], edx
.text:00000DA0                 mov     dword ptr [ebp+arg_4+4], eax
.text:00000DA3                 jmp     short loc_DAC
.text:00000DA5 ; ---------------------------------------------------------------------------
.text:00000DA5
.text:00000DA5 loc_DA5:                                ; CODE XREF: CCachedInStream::Seek(__int64,uint,unsigned __int64 *)+23j
.text:00000DA5                 mov     eax, 80030001h
.text:00000DAA                 jmp     short loc_DE6
.text:00000DAC ; ---------------------------------------------------------------------------
.text:00000DAC
.text:00000DAC loc_DAC:                                ; CODE XREF: CCachedInStream::Seek(__int64,uint,unsigned __int64 *):loc_D75j
.text:00000DAC                                         ; CCachedInStream::Seek(__int64,uint,unsigned __int64 *)+3Cj ...
.text:00000DAC                 cmp     dword ptr [ebp+arg_4+4], 0
.text:00000DB0                 jg      short loc_DC1
.text:00000DB2                 jl      short loc_DBA
.text:00000DB4                 cmp     dword ptr [ebp+arg_4], 0
.text:00000DB8                 jnb     short loc_DC1
.text:00000DBA
.text:00000DBA loc_DBA:                                ; CODE XREF: CCachedInStream::Seek(__int64,uint,unsigned __int64 *)+62j
.text:00000DBA                 mov     eax, 80070083h
.text:00000DBF                 jmp     short loc_DE6
.text:00000DC1 ; ---------------------------------------------------------------------------
.text:00000DC1
.text:00000DC1 loc_DC1:                                ; CODE XREF: CCachedInStream::Seek(__int64,uint,unsigned __int64 *)+60j
.text:00000DC1                                         ; CCachedInStream::Seek(__int64,uint,unsigned __int64 *)+68j
.text:00000DC1                 mov     ecx, [ebp+this]
.text:00000DC4                 mov     edx, dword ptr [ebp+arg_4]
.text:00000DC7                 mov     [ecx+28h], edx
.text:00000DCA                 mov     eax, dword ptr [ebp+arg_4+4]
.text:00000DCD                 mov     [ecx+2Ch], eax
.text:00000DD0                 cmp     [ebp+arg_10], 0
.text:00000DD4                 jz      short loc_DE4
.text:00000DD6                 mov     ecx, [ebp+arg_10]
.text:00000DD9                 mov     edx, dword ptr [ebp+arg_4]
.text:00000DDC                 mov     [ecx], edx
.text:00000DDE                 mov     eax, dword ptr [ebp+arg_4+4]
.text:00000DE1                 mov     [ecx+4], eax
.text:00000DE4
.text:00000DE4 loc_DE4:                                ; CODE XREF: CCachedInStream::Seek(__int64,uint,unsigned __int64 *)+84j
.text:00000DE4                 xor     eax, eax
.text:00000DE6
.text:00000DE6 loc_DE6:                                ; CODE XREF: CCachedInStream::Seek(__int64,uint,unsigned __int64 *)+5Aj
.text:00000DE6                                         ; CCachedInStream::Seek(__int64,uint,unsigned __int64 *)+6Fj
.text:00000DE6                 mov     esp, ebp
.text:00000DE8                 pop     ebp
.text:00000DE9                 retn    14h
.text:00000DE9 ?Seek@CCachedInStream@@UAGJ_JIPA_K@Z endp
.text:00000DE9
.text:00000DE9 _text           ends
.text:00000DE9
.rtc$TMZ:00000DEC ; ===========================================================================
.rtc$TMZ:00000DEC
.rtc$TMZ:00000DEC ; Segment type: Pure data
.rtc$TMZ:00000DEC ; Segment permissions: Read
.rtc$TMZ:00000DEC _rtc$TMZ        segment dword public 'DATA' use32
.rtc$TMZ:00000DEC                 assume cs:_rtc$TMZ
.rtc$TMZ:00000DEC                 ;org 0DECh
.rtc$TMZ:00000DEC ; COMDAT (pick any)
.rtc$TMZ:00000DEC __RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
.rtc$TMZ:00000DEC _rtc$TMZ        ends
.rtc$TMZ:00000DEC
.rtc$IMZ:00000DF0 ; ===========================================================================
.rtc$IMZ:00000DF0
.rtc$IMZ:00000DF0 ; Segment type: Pure data
.rtc$IMZ:00000DF0 ; Segment permissions: Read
.rtc$IMZ:00000DF0 _rtc$IMZ        segment dword public 'DATA' use32
.rtc$IMZ:00000DF0                 assume cs:_rtc$IMZ
.rtc$IMZ:00000DF0                 ;org 0DF0h
.rtc$IMZ:00000DF0 ; COMDAT (pick any)
.rtc$IMZ:00000DF0 __RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
.rtc$IMZ:00000DF0 _rtc$IMZ        ends
.rtc$IMZ:00000DF0
.text$x:00000DF4 ; ===========================================================================
.text$x:00000DF4
.text$x:00000DF4 ; Segment type: Pure code
.text$x:00000DF4 ; Segment permissions: Read/Execute
.text$x:00000DF4 _text$x         segment para public 'CODE' use32
.text$x:00000DF4                 assume cs:_text$x
.text$x:00000DF4                 ;org 0DF4h
.text$x:00000DF4                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text$x:00000DF4
.text$x:00000DF4 ; =============== S U B R O U T I N E =======================================
.text$x:00000DF4
.text$x:00000DF4
.text$x:00000DF4 __unwindfunclet$?Create_BufInStream_WithReference@@YGXPBXIPAUIUnknown@@PAPAUISequentialInStream@@@Z$0 proc near
.text$x:00000DF4                                         ; DATA XREF: .xdata$x:00000E54o
.text$x:00000DF4                 mov     eax, [ebp-24h]
.text$x:00000DF7                 push    eax             ; void *
.text$x:00000DF8                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00000DFD                 pop     ecx
.text$x:00000DFE                 retn
.text$x:00000DFE __unwindfunclet$?Create_BufInStream_WithReference@@YGXPBXIPAUIUnknown@@PAPAUISequentialInStream@@@Z$0 endp
.text$x:00000DFE
.text$x:00000DFF
.text$x:00000DFF ; =============== S U B R O U T I N E =======================================
.text$x:00000DFF
.text$x:00000DFF
.text$x:00000DFF __unwindfunclet$?Create_BufInStream_WithReference@@YGXPBXIPAUIUnknown@@PAPAUISequentialInStream@@@Z$1 proc near
.text$x:00000DFF                                         ; DATA XREF: .xdata$x:00000E5Co
.text$x:00000DFF                 lea     ecx, [ebp-18h]
.text$x:00000E02                 jmp     ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text$x:00000E02 __unwindfunclet$?Create_BufInStream_WithReference@@YGXPBXIPAUIUnknown@@PAPAUISequentialInStream@@@Z$1 endp
.text$x:00000E02
.text$x:00000E07
.text$x:00000E07 ; =============== S U B R O U T I N E =======================================
.text$x:00000E07
.text$x:00000E07
.text$x:00000E07 __ehhandler$?Create_BufInStream_WithReference@@YGXPBXIPAUIUnknown@@PAPAUISequentialInStream@@@Z proc near
.text$x:00000E07                                         ; DATA XREF: Create_BufInStream_WithReference(void const *,uint,IUnknown *,ISequentialInStream * *)+5o
.text$x:00000E07
.text$x:00000E07 arg_4           = dword ptr  8
.text$x:00000E07
.text$x:00000E07                 mov     edx, [esp+arg_4]
.text$x:00000E0B                 lea     eax, [edx+0Ch]
.text$x:00000E0E                 mov     ecx, [edx-20h]
.text$x:00000E11                 xor     ecx, eax
.text$x:00000E13                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000E18                 mov     eax, offset __ehfuncinfo$?Create_BufInStream_WithReference@@YGXPBXIPAUIUnknown@@PAPAUISequentialInStream@@@Z
.text$x:00000E1D                 jmp     ___CxxFrameHandler3
.text$x:00000E1D __ehhandler$?Create_BufInStream_WithReference@@YGXPBXIPAUIUnknown@@PAPAUISequentialInStream@@@Z endp
.text$x:00000E1D
.text$x:00000E22
.text$x:00000E22 ; =============== S U B R O U T I N E =======================================
.text$x:00000E22
.text$x:00000E22
.text$x:00000E22 __unwindfunclet$?Create_BufInStream_WithNewBuffer@@YGXPBXIPAPAUISequentialInStream@@@Z$0 proc near
.text$x:00000E22                                         ; DATA XREF: .xdata$x:00000E88o
.text$x:00000E22                 mov     eax, [ebp-24h]
.text$x:00000E25                 push    eax             ; void *
.text$x:00000E26                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00000E2B                 pop     ecx
.text$x:00000E2C                 retn
.text$x:00000E2C __unwindfunclet$?Create_BufInStream_WithNewBuffer@@YGXPBXIPAPAUISequentialInStream@@@Z$0 endp
.text$x:00000E2C
.text$x:00000E2D
.text$x:00000E2D ; =============== S U B R O U T I N E =======================================
.text$x:00000E2D
.text$x:00000E2D
.text$x:00000E2D __unwindfunclet$?Create_BufInStream_WithNewBuffer@@YGXPBXIPAPAUISequentialInStream@@@Z$1 proc near
.text$x:00000E2D                                         ; DATA XREF: .xdata$x:00000E90o
.text$x:00000E2D                 lea     ecx, [ebp-18h]
.text$x:00000E30                 jmp     ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text$x:00000E30 __unwindfunclet$?Create_BufInStream_WithNewBuffer@@YGXPBXIPAPAUISequentialInStream@@@Z$1 endp
.text$x:00000E30
.text$x:00000E35
.text$x:00000E35 ; =============== S U B R O U T I N E =======================================
.text$x:00000E35
.text$x:00000E35
.text$x:00000E35 __ehhandler$?Create_BufInStream_WithNewBuffer@@YGXPBXIPAPAUISequentialInStream@@@Z proc near
.text$x:00000E35                                         ; DATA XREF: Create_BufInStream_WithNewBuffer(void const *,uint,ISequentialInStream * *)+5o
.text$x:00000E35
.text$x:00000E35 arg_4           = dword ptr  8
.text$x:00000E35
.text$x:00000E35                 mov     edx, [esp+arg_4]
.text$x:00000E39                 lea     eax, [edx+0Ch]
.text$x:00000E3C                 mov     ecx, [edx-20h]
.text$x:00000E3F                 xor     ecx, eax
.text$x:00000E41                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000E46                 mov     eax, offset __ehfuncinfo$?Create_BufInStream_WithNewBuffer@@YGXPBXIPAPAUISequentialInStream@@@Z
.text$x:00000E4B                 jmp     ___CxxFrameHandler3
.text$x:00000E4B __ehhandler$?Create_BufInStream_WithNewBuffer@@YGXPBXIPAPAUISequentialInStream@@@Z endp
.text$x:00000E4B
.text$x:00000E4B _text$x         ends
.text$x:00000E4B
.xdata$x:00000E50 ; ===========================================================================
.xdata$x:00000E50
.xdata$x:00000E50 ; Segment type: Pure data
.xdata$x:00000E50 ; Segment permissions: Read
.xdata$x:00000E50 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00000E50                 assume cs:_xdata$x
.xdata$x:00000E50                 ;org 0E50h
.xdata$x:00000E50 __unwindtable$?Create_BufInStream_WithReference@@YGXPBXIPAUIUnknown@@PAPAUISequentialInStream@@@Z db 0FFh
.xdata$x:00000E50                                         ; DATA XREF: .xdata$x:00000E68o
.xdata$x:00000E51                 db 0FFh
.xdata$x:00000E52                 db 0FFh
.xdata$x:00000E53                 db 0FFh
.xdata$x:00000E54                 dd offset __unwindfunclet$?Create_BufInStream_WithReference@@YGXPBXIPAUIUnknown@@PAPAUISequentialInStream@@@Z$0
.xdata$x:00000E58                 db 0FFh
.xdata$x:00000E59                 db 0FFh
.xdata$x:00000E5A                 db 0FFh
.xdata$x:00000E5B                 db 0FFh
.xdata$x:00000E5C                 dd offset __unwindfunclet$?Create_BufInStream_WithReference@@YGXPBXIPAUIUnknown@@PAPAUISequentialInStream@@@Z$1
.xdata$x:00000E60 __ehfuncinfo$?Create_BufInStream_WithReference@@YGXPBXIPAUIUnknown@@PAPAUISequentialInStream@@@Z db  22h ; "
.xdata$x:00000E60                                         ; DATA XREF: __ehhandler$?Create_BufInStream_WithReference@@YGXPBXIPAUIUnknown@@PAPAUISequentialInStream@@@Z+11o
.xdata$x:00000E61                 db    5
.xdata$x:00000E62                 db  93h ; Ã´
.xdata$x:00000E63                 db  19h
.xdata$x:00000E64                 db    2
.xdata$x:00000E65                 db    0
.xdata$x:00000E66                 db    0
.xdata$x:00000E67                 db    0
.xdata$x:00000E68                 dd offset __unwindtable$?Create_BufInStream_WithReference@@YGXPBXIPAUIUnknown@@PAPAUISequentialInStream@@@Z
.xdata$x:00000E6C                 align 20h
.xdata$x:00000E80                 db    1
.xdata$x:00000E81                 db    0
.xdata$x:00000E82                 db    0
.xdata$x:00000E83                 db    0
.xdata$x:00000E84 __unwindtable$?Create_BufInStream_WithNewBuffer@@YGXPBXIPAPAUISequentialInStream@@@Z db 0FFh
.xdata$x:00000E84                                         ; DATA XREF: .xdata$x:00000E9Co
.xdata$x:00000E85                 db 0FFh
.xdata$x:00000E86                 db 0FFh
.xdata$x:00000E87                 db 0FFh
.xdata$x:00000E88                 dd offset __unwindfunclet$?Create_BufInStream_WithNewBuffer@@YGXPBXIPAPAUISequentialInStream@@@Z$0
.xdata$x:00000E8C                 db 0FFh
.xdata$x:00000E8D                 db 0FFh
.xdata$x:00000E8E                 db 0FFh
.xdata$x:00000E8F                 db 0FFh
.xdata$x:00000E90                 dd offset __unwindfunclet$?Create_BufInStream_WithNewBuffer@@YGXPBXIPAPAUISequentialInStream@@@Z$1
.xdata$x:00000E94 __ehfuncinfo$?Create_BufInStream_WithNewBuffer@@YGXPBXIPAPAUISequentialInStream@@@Z db  22h ; "
.xdata$x:00000E94                                         ; DATA XREF: __ehhandler$?Create_BufInStream_WithNewBuffer@@YGXPBXIPAPAUISequentialInStream@@@Z+11o
.xdata$x:00000E95                 db    5
.xdata$x:00000E96                 db  93h ; Ã´
.xdata$x:00000E97                 db  19h
.xdata$x:00000E98                 db    2
.xdata$x:00000E99                 db    0
.xdata$x:00000E9A                 db    0
.xdata$x:00000E9B                 db    0
.xdata$x:00000E9C                 dd offset __unwindtable$?Create_BufInStream_WithNewBuffer@@YGXPBXIPAPAUISequentialInStream@@@Z
.xdata$x:00000EA0                 db    0
.xdata$x:00000EA1                 db    0
.xdata$x:00000EA2                 db    0
.xdata$x:00000EA3                 db    0
.xdata$x:00000EA4                 db    0
.xdata$x:00000EA5                 db    0
.xdata$x:00000EA6                 db    0
.xdata$x:00000EA7                 db    0
.xdata$x:00000EA8                 db    0
.xdata$x:00000EA9                 db    0
.xdata$x:00000EAA                 db    0
.xdata$x:00000EAB                 db    0
.xdata$x:00000EAC                 db    0
.xdata$x:00000EAD                 db    0
.xdata$x:00000EAE                 db    0
.xdata$x:00000EAF                 db    0
.xdata$x:00000EB0                 db    0
.xdata$x:00000EB1                 db    0
.xdata$x:00000EB2                 db    0
.xdata$x:00000EB3                 db    0
.xdata$x:00000EB4                 db    1
.xdata$x:00000EB5                 db    0
.xdata$x:00000EB6                 db    0
.xdata$x:00000EB7                 db    0
.xdata$x:00000EB7 _xdata$x        ends
.xdata$x:00000EB7
.text:00000EB8 ; ===========================================================================
.text:00000EB8
.text:00000EB8 ; Segment type: Pure code
.text:00000EB8 ; Segment permissions: Read/Execute
.text:00000EB8 _text           segment para public 'CODE' use32
.text:00000EB8                 assume cs:_text
.text:00000EB8                 ;org 0EB8h
.text:00000EB8 ; COMDAT (pick any)
.text:00000EB8                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000EB8
.text:00000EB8 ; =============== S U B R O U T I N E =======================================
.text:00000EB8
.text:00000EB8 ; Attributes: bp-based frame
.text:00000EB8
.text:00000EB8 ; void __thiscall CBufInStream::Init(CBufInStream *this, const unsigned __int8 *, unsigned int, struct IUnknown *)
.text:00000EB8                 public ?Init@CBufInStream@@QAEXPBEIPAUIUnknown@@@Z
.text:00000EB8 ?Init@CBufInStream@@QAEXPBEIPAUIUnknown@@@Z proc near
.text:00000EB8                                         ; CODE XREF: Create_BufInStream_WithReference(void const *,uint,IUnknown *,ISequentialInStream * *)+ABp
.text:00000EB8
.text:00000EB8 var_4           = dword ptr -4
.text:00000EB8 arg_0           = dword ptr  8
.text:00000EB8 arg_4           = dword ptr  0Ch
.text:00000EB8 arg_8           = dword ptr  10h
.text:00000EB8
.text:00000EB8                 push    ebp
.text:00000EB9                 mov     ebp, esp
.text:00000EBB                 push    ecx
.text:00000EBC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000EC3                 mov     [ebp+var_4], ecx
.text:00000EC6                 mov     eax, [ebp+var_4]
.text:00000EC9                 mov     ecx, [ebp+arg_0]
.text:00000ECC                 mov     [eax+8], ecx
.text:00000ECF                 mov     edx, [ebp+var_4]
.text:00000ED2                 mov     eax, [ebp+arg_4]
.text:00000ED5                 mov     [edx+18h], eax
.text:00000ED8                 mov     ecx, [ebp+var_4]
.text:00000EDB                 mov     dword ptr [ecx+10h], 0
.text:00000EE2                 mov     dword ptr [ecx+14h], 0
.text:00000EE9                 mov     edx, [ebp+arg_8]
.text:00000EEC                 push    edx
.text:00000EED                 mov     ecx, [ebp+var_4]
.text:00000EF0                 add     ecx, 1Ch
.text:00000EF3                 call    ??4?$CMyComPtr@UIUnknown@@@@QAEPAUIUnknown@@PAU1@@Z ; CMyComPtr<IUnknown>::operator=(IUnknown *)
.text:00000EF8                 add     esp, 4
.text:00000EFB                 cmp     ebp, esp
.text:00000EFD                 call    __RTC_CheckEsp
.text:00000F02                 mov     esp, ebp
.text:00000F04                 pop     ebp
.text:00000F05                 retn    0Ch
.text:00000F05 ?Init@CBufInStream@@QAEXPBEIPAUIUnknown@@@Z endp
.text:00000F05
.text:00000F05 _text           ends
.text:00000F05
.text:00000F08 ; ===========================================================================
.text:00000F08
.text:00000F08 ; Segment type: Pure code
.text:00000F08 ; Segment permissions: Read/Execute
.text:00000F08 _text           segment para public 'CODE' use32
.text:00000F08                 assume cs:_text
.text:00000F08                 ;org 0F08h
.text:00000F08 ; COMDAT (pick any)
.text:00000F08                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000F08
.text:00000F08 ; =============== S U B R O U T I N E =======================================
.text:00000F08
.text:00000F08 ; Attributes: bp-based frame
.text:00000F08
.text:00000F08 ; public: __thiscall CBufInStream::CBufInStream(void)
.text:00000F08                 public ??0CBufInStream@@QAE@XZ
.text:00000F08 ??0CBufInStream@@QAE@XZ proc near       ; CODE XREF: Create_BufInStream_WithReference(void const *,uint,IUnknown *,ISequentialInStream * *)+65p
.text:00000F08
.text:00000F08 var_4           = dword ptr -4
.text:00000F08
.text:00000F08                 push    ebp
.text:00000F09                 mov     ebp, esp
.text:00000F0B                 push    ecx
.text:00000F0C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000F13                 mov     [ebp+var_4], ecx
.text:00000F16                 mov     ecx, [ebp+var_4] ; this
.text:00000F19                 call    ??0IInStream@@QAE@XZ ; IInStream::IInStream(void)
.text:00000F1E                 mov     ecx, [ebp+var_4]
.text:00000F21                 add     ecx, 4          ; this
.text:00000F24                 call    ??0CMyUnknownImp@@QAE@XZ ; CMyUnknownImp::CMyUnknownImp(void)
.text:00000F29                 mov     eax, [ebp+var_4]
.text:00000F2C                 mov     dword ptr [eax], offset ??_7CBufInStream@@6B@ ; const CBufInStream::`vftable'
.text:00000F32                 mov     ecx, [ebp+var_4]
.text:00000F35                 add     ecx, 1Ch
.text:00000F38                 call    ??0?$CMyComPtr@UIUnknown@@@@QAE@XZ ; CMyComPtr<IUnknown>::CMyComPtr<IUnknown>(void)
.text:00000F3D                 mov     eax, [ebp+var_4]
.text:00000F40                 add     esp, 4
.text:00000F43                 cmp     ebp, esp
.text:00000F45                 call    __RTC_CheckEsp
.text:00000F4A                 mov     esp, ebp
.text:00000F4C                 pop     ebp
.text:00000F4D                 retn
.text:00000F4D ??0CBufInStream@@QAE@XZ endp
.text:00000F4D
.text:00000F4D ; ---------------------------------------------------------------------------
.text:00000F4E                 align 10h
.text:00000F4E _text           ends
.text:00000F4E
.rdata:00000F50 ; ===========================================================================
.rdata:00000F50
.rdata:00000F50 ; Segment type: Pure data
.rdata:00000F50 ; Segment permissions: Read
.rdata:00000F50 _rdata          segment dword public 'DATA' use32
.rdata:00000F50                 assume cs:_rdata
.rdata:00000F50                 ;org 0F50h
.rdata:00000F50 ; COMDAT (pick largest)
.rdata:00000F50                 dd offset ??_R4CBufInStream@@6B@ ; const CBufInStream::`RTTI Complete Object Locator'
.rdata:00000F54                 public ??_7CBufInStream@@6B@
.rdata:00000F54 ; const CBufInStream::`vftable'
.rdata:00000F54 ??_7CBufInStream@@6B@ dd offset ?QueryInterface@CBufInStream@@UAGJABU_GUID@@PAPAX@Z
.rdata:00000F54                                         ; DATA XREF: CBufInStream::CBufInStream(void)+24o
.rdata:00000F54                                         ; CBufInStream::QueryInterface(_GUID const &,void * *)
.rdata:00000F58                 dd offset ?AddRef@CBufInStream@@UAGKXZ ; CBufInStream::AddRef(void)
.rdata:00000F5C                 dd offset ?Release@CBufInStream@@UAGKXZ ; CBufInStream::Release(void)
.rdata:00000F60                 dd offset ?Read@CBufInStream@@UAGJPAXIPAI@Z ; CBufInStream::Read(void *,uint,uint *)
.rdata:00000F64                 dd offset ?Seek@CBufInStream@@UAGJ_JIPA_K@Z ; CBufInStream::Seek(__int64,uint,unsigned __int64 *)
.rdata:00000F64 _rdata          ends
.rdata:00000F64
.rdata$r:00000F68 ; ===========================================================================
.rdata$r:00000F68
.rdata$r:00000F68 ; Segment type: Pure data
.rdata$r:00000F68 ; Segment permissions: Read
.rdata$r:00000F68 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00000F68                 assume cs:_rdata$r
.rdata$r:00000F68                 ;org 0F68h
.rdata$r:00000F68 ; COMDAT (pick any)
.rdata$r:00000F68                 public ??_R4CBufInStream@@6B@
.rdata$r:00000F68 ; const CBufInStream::`RTTI Complete Object Locator'
.rdata$r:00000F68 ??_R4CBufInStream@@6B@ db    0          ; DATA XREF: .rdata:00000F50o
.rdata$r:00000F69                 db    0
.rdata$r:00000F6A                 db    0
.rdata$r:00000F6B                 db    0
.rdata$r:00000F6C                 db    0
.rdata$r:00000F6D                 db    0
.rdata$r:00000F6E                 db    0
.rdata$r:00000F6F                 db    0
.rdata$r:00000F70                 db    0
.rdata$r:00000F71                 db    0
.rdata$r:00000F72                 db    0
.rdata$r:00000F73                 db    0
.rdata$r:00000F74                 dd offset ??_R0?AVCBufInStream@@@8 ; CBufInStream `RTTI Type Descriptor'
.rdata$r:00000F78                 dd offset ??_R3CBufInStream@@8 ; CBufInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00000F78 _rdata$r        ends
.rdata$r:00000F78
.data:00000F7C ; ===========================================================================
.data:00000F7C
.data:00000F7C ; Segment type: Pure data
.data:00000F7C ; Segment permissions: Read/Write
.data:00000F7C _data           segment dword public 'DATA' use32
.data:00000F7C                 assume cs:_data
.data:00000F7C                 ;org 0F7Ch
.data:00000F7C ; COMDAT (pick any)
.data:00000F7C                 public ??_R0?AVCBufInStream@@@8
.data:00000F7C ; class CBufInStream `RTTI Type Descriptor'
.data:00000F7C ??_R0?AVCBufInStream@@@8 dd offset ??_7type_info@@6B@
.data:00000F7C                                         ; DATA XREF: .rdata$r:00000F74o
.data:00000F7C                                         ; .rdata$r:CBufInStream::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:00000F7C                                         ; const type_info::`vftable'
.data:00000F80                 db    0
.data:00000F81                 db    0
.data:00000F82                 db    0
.data:00000F83                 db    0
.data:00000F84                 db  2Eh ; .
.data:00000F85                 db  3Fh ; ?
.data:00000F86                 db  41h ; A
.data:00000F87                 db  56h ; V
.data:00000F88                 db  43h ; C
.data:00000F89                 db  42h ; B
.data:00000F8A                 db  75h ; u
.data:00000F8B                 db  66h ; f
.data:00000F8C                 db  49h ; I
.data:00000F8D                 db  6Eh ; n
.data:00000F8E                 db  53h ; S
.data:00000F8F                 db  74h ; t
.data:00000F90                 db  72h ; r
.data:00000F91                 db  65h ; e
.data:00000F92                 db  61h ; a
.data:00000F93                 db  6Dh ; m
.data:00000F94                 db  40h ; @
.data:00000F95                 db  40h ; @
.data:00000F96                 db    0
.data:00000F97                 align 4
.data:00000F97 _data           ends
.data:00000F97
.rdata$r:00000F98 ; ===========================================================================
.rdata$r:00000F98
.rdata$r:00000F98 ; Segment type: Pure data
.rdata$r:00000F98 ; Segment permissions: Read
.rdata$r:00000F98 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00000F98                 assume cs:_rdata$r
.rdata$r:00000F98                 ;org 0F98h
.rdata$r:00000F98 ; COMDAT (pick any)
.rdata$r:00000F98                 public ??_R3CBufInStream@@8
.rdata$r:00000F98 ; CBufInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00000F98 ??_R3CBufInStream@@8 db    0            ; DATA XREF: .rdata$r:00000F78o
.rdata$r:00000F98                                         ; .rdata$r:00000FD8o
.rdata$r:00000F99                 db    0
.rdata$r:00000F9A                 db    0
.rdata$r:00000F9B                 db    0
.rdata$r:00000F9C                 db    1
.rdata$r:00000F9D                 db    0
.rdata$r:00000F9E                 db    0
.rdata$r:00000F9F                 db    0
.rdata$r:00000FA0                 db    5
.rdata$r:00000FA1                 db    0
.rdata$r:00000FA2                 db    0
.rdata$r:00000FA3                 db    0
.rdata$r:00000FA4                 dd offset ??_R2CBufInStream@@8 ; CBufInStream::`RTTI Base Class Array'
.rdata$r:00000FA4 _rdata$r        ends
.rdata$r:00000FA4
.rdata$r:00000FA8 ; ===========================================================================
.rdata$r:00000FA8
.rdata$r:00000FA8 ; Segment type: Pure data
.rdata$r:00000FA8 ; Segment permissions: Read
.rdata$r:00000FA8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00000FA8                 assume cs:_rdata$r
.rdata$r:00000FA8                 ;org 0FA8h
.rdata$r:00000FA8 ; COMDAT (pick any)
.rdata$r:00000FA8                 public ??_R2CBufInStream@@8
.rdata$r:00000FA8 ; CBufInStream::`RTTI Base Class Array'
.rdata$r:00000FA8 ??_R2CBufInStream@@8 dd offset ??_R1A@?0A@EA@CBufInStream@@8
.rdata$r:00000FA8                                         ; DATA XREF: .rdata$r:00000FA4o
.rdata$r:00000FA8                                         ; CBufInStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00000FAC                 dd offset ??_R1A@?0A@EA@IInStream@@8 ; IInStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00000FB0                 dd offset ??_R1A@?0A@EA@ISequentialInStream@@8 ; ISequentialInStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00000FB4                 dd offset ??_R1A@?0A@EA@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00000FB8                 dd offset ??_R13?0A@EA@CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Base Class Descriptor at (4,-1,0,64)'
.rdata$r:00000FBC                 db    0
.rdata$r:00000FBD                 align 10h
.rdata$r:00000FBD _rdata$r        ends
.rdata$r:00000FBD
.rdata$r:00000FC0 ; ===========================================================================
.rdata$r:00000FC0
.rdata$r:00000FC0 ; Segment type: Pure data
.rdata$r:00000FC0 ; Segment permissions: Read
.rdata$r:00000FC0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00000FC0                 assume cs:_rdata$r
.rdata$r:00000FC0                 ;org 0FC0h
.rdata$r:00000FC0 ; COMDAT (pick any)
.rdata$r:00000FC0                 public ??_R1A@?0A@EA@CBufInStream@@8
.rdata$r:00000FC0 ; CBufInStream::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00000FC0 ??_R1A@?0A@EA@CBufInStream@@8 dd offset ??_R0?AVCBufInStream@@@8
.rdata$r:00000FC0                                         ; DATA XREF: .rdata$r:CBufInStream::`RTTI Base Class Array'o
.rdata$r:00000FC0                                         ; CBufInStream `RTTI Type Descriptor'
.rdata$r:00000FC4                 db    4
.rdata$r:00000FC5                 db    0
.rdata$r:00000FC6                 db    0
.rdata$r:00000FC7                 db    0
.rdata$r:00000FC8                 db    0
.rdata$r:00000FC9                 db    0
.rdata$r:00000FCA                 db    0
.rdata$r:00000FCB                 db    0
.rdata$r:00000FCC                 db 0FFh
.rdata$r:00000FCD                 db 0FFh
.rdata$r:00000FCE                 db 0FFh
.rdata$r:00000FCF                 db 0FFh
.rdata$r:00000FD0                 db    0
.rdata$r:00000FD1                 db    0
.rdata$r:00000FD2                 db    0
.rdata$r:00000FD3                 db    0
.rdata$r:00000FD4                 db  40h ; @
.rdata$r:00000FD5                 db    0
.rdata$r:00000FD6                 db    0
.rdata$r:00000FD7                 db    0
.rdata$r:00000FD8                 dd offset ??_R3CBufInStream@@8 ; CBufInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00000FD8 _rdata$r        ends
.rdata$r:00000FD8
.rdata$r:00000FDC ; ===========================================================================
.rdata$r:00000FDC
.rdata$r:00000FDC ; Segment type: Pure data
.rdata$r:00000FDC ; Segment permissions: Read
.rdata$r:00000FDC _rdata$r        segment dword public 'DATA' use32
.rdata$r:00000FDC                 assume cs:_rdata$r
.rdata$r:00000FDC                 ;org 0FDCh
.rdata$r:00000FDC ; COMDAT (pick any)
.rdata$r:00000FDC                 public ??_R1A@?0A@EA@IInStream@@8
.rdata$r:00000FDC ; IInStream::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00000FDC ??_R1A@?0A@EA@IInStream@@8 dd offset ??_R0?AUIInStream@@@8
.rdata$r:00000FDC                                         ; DATA XREF: .rdata$r:00000FACo
.rdata$r:00000FDC                                         ; .rdata$r:IInStream::`RTTI Base Class Array'o ...
.rdata$r:00000FDC                                         ; IInStream `RTTI Type Descriptor'
.rdata$r:00000FE0                 db    2
.rdata$r:00000FE1                 db    0
.rdata$r:00000FE2                 db    0
.rdata$r:00000FE3                 db    0
.rdata$r:00000FE4                 db    0
.rdata$r:00000FE5                 db    0
.rdata$r:00000FE6                 db    0
.rdata$r:00000FE7                 db    0
.rdata$r:00000FE8                 db 0FFh
.rdata$r:00000FE9                 db 0FFh
.rdata$r:00000FEA                 db 0FFh
.rdata$r:00000FEB                 db 0FFh
.rdata$r:00000FEC                 db    0
.rdata$r:00000FED                 db    0
.rdata$r:00000FEE                 db    0
.rdata$r:00000FEF                 db    0
.rdata$r:00000FF0                 db  40h ; @
.rdata$r:00000FF1                 db    0
.rdata$r:00000FF2                 db    0
.rdata$r:00000FF3                 db    0
.rdata$r:00000FF4                 dd offset ??_R3IInStream@@8 ; IInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00000FF4 _rdata$r        ends
.rdata$r:00000FF4
.data:00000FF8 ; ===========================================================================
.data:00000FF8
.data:00000FF8 ; Segment type: Pure data
.data:00000FF8 ; Segment permissions: Read/Write
.data:00000FF8 _data           segment dword public 'DATA' use32
.data:00000FF8                 assume cs:_data
.data:00000FF8                 ;org 0FF8h
.data:00000FF8 ; COMDAT (pick any)
.data:00000FF8                 public ??_R0?AUIInStream@@@8
.data:00000FF8 ; struct IInStream `RTTI Type Descriptor'
.data:00000FF8 ??_R0?AUIInStream@@@8 dd offset ??_7type_info@@6B@
.data:00000FF8                                         ; DATA XREF: .rdata$r:IInStream::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:00000FF8                                         ; .rdata$r:00001388o
.data:00000FF8                                         ; const type_info::`vftable'
.data:00000FFC                 align 10h
.data:00001000 a_?auiinstream@ db '.?AUIInStream@@',0
.data:00001000 _data           ends
.data:00001000
.rdata$r:00001010 ; ===========================================================================
.rdata$r:00001010
.rdata$r:00001010 ; Segment type: Pure data
.rdata$r:00001010 ; Segment permissions: Read
.rdata$r:00001010 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001010                 assume cs:_rdata$r
.rdata$r:00001010                 ;org 1010h
.rdata$r:00001010 ; COMDAT (pick any)
.rdata$r:00001010                 public ??_R3IInStream@@8
.rdata$r:00001010 ; IInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00001010 ??_R3IInStream@@8 db    0               ; DATA XREF: .rdata$r:00000FF4o
.rdata$r:00001010                                         ; .rdata$r:0000138Co
.rdata$r:00001011                 db    0
.rdata$r:00001012                 db    0
.rdata$r:00001013                 db    0
.rdata$r:00001014                 db    0
.rdata$r:00001015                 db    0
.rdata$r:00001016                 db    0
.rdata$r:00001017                 db    0
.rdata$r:00001018                 db    3
.rdata$r:00001019                 db    0
.rdata$r:0000101A                 db    0
.rdata$r:0000101B                 db    0
.rdata$r:0000101C                 dd offset ??_R2IInStream@@8 ; IInStream::`RTTI Base Class Array'
.rdata$r:0000101C _rdata$r        ends
.rdata$r:0000101C
.rdata$r:00001020 ; ===========================================================================
.rdata$r:00001020
.rdata$r:00001020 ; Segment type: Pure data
.rdata$r:00001020 ; Segment permissions: Read
.rdata$r:00001020 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001020                 assume cs:_rdata$r
.rdata$r:00001020                 ;org 1020h
.rdata$r:00001020 ; COMDAT (pick any)
.rdata$r:00001020                 public ??_R2IInStream@@8
.rdata$r:00001020 ; IInStream::`RTTI Base Class Array'
.rdata$r:00001020 ??_R2IInStream@@8 dd offset ??_R1A@?0A@EA@IInStream@@8
.rdata$r:00001020                                         ; DATA XREF: .rdata$r:0000101Co
.rdata$r:00001020                                         ; IInStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00001024                 dd offset ??_R1A@?0A@EA@ISequentialInStream@@8 ; ISequentialInStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00001028                 dd offset ??_R1A@?0A@EA@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000102C                 db    0
.rdata$r:0000102D                 align 10h
.rdata$r:0000102D _rdata$r        ends
.rdata$r:0000102D
.rdata$r:00001030 ; ===========================================================================
.rdata$r:00001030
.rdata$r:00001030 ; Segment type: Pure data
.rdata$r:00001030 ; Segment permissions: Read
.rdata$r:00001030 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001030                 assume cs:_rdata$r
.rdata$r:00001030                 ;org 1030h
.rdata$r:00001030 ; COMDAT (pick any)
.rdata$r:00001030                 public ??_R1A@?0A@EA@ISequentialInStream@@8
.rdata$r:00001030 ; ISequentialInStream::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00001030 ??_R1A@?0A@EA@ISequentialInStream@@8 dd offset ??_R0?AUISequentialInStream@@@8
.rdata$r:00001030                                         ; DATA XREF: .rdata$r:00000FB0o
.rdata$r:00001030                                         ; .rdata$r:00001024o ...
.rdata$r:00001030                                         ; ISequentialInStream `RTTI Type Descriptor'
.rdata$r:00001034                 db    1
.rdata$r:00001035                 db    0
.rdata$r:00001036                 db    0
.rdata$r:00001037                 db    0
.rdata$r:00001038                 db    0
.rdata$r:00001039                 db    0
.rdata$r:0000103A                 db    0
.rdata$r:0000103B                 db    0
.rdata$r:0000103C                 db 0FFh
.rdata$r:0000103D                 db 0FFh
.rdata$r:0000103E                 db 0FFh
.rdata$r:0000103F                 db 0FFh
.rdata$r:00001040                 db    0
.rdata$r:00001041                 db    0
.rdata$r:00001042                 db    0
.rdata$r:00001043                 db    0
.rdata$r:00001044                 db  40h ; @
.rdata$r:00001045                 db    0
.rdata$r:00001046                 db    0
.rdata$r:00001047                 db    0
.rdata$r:00001048                 dd offset ??_R3ISequentialInStream@@8 ; ISequentialInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00001048 _rdata$r        ends
.rdata$r:00001048
.data:0000104C ; ===========================================================================
.data:0000104C
.data:0000104C ; Segment type: Pure data
.data:0000104C ; Segment permissions: Read/Write
.data:0000104C _data           segment dword public 'DATA' use32
.data:0000104C                 assume cs:_data
.data:0000104C                 ;org 104Ch
.data:0000104C ; COMDAT (pick any)
.data:0000104C                 public ??_R0?AUISequentialInStream@@@8
.data:0000104C ; struct ISequentialInStream `RTTI Type Descriptor'
.data:0000104C ??_R0?AUISequentialInStream@@@8 dd offset ??_7type_info@@6B@
.data:0000104C                                         ; DATA XREF: .rdata$r:ISequentialInStream::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:0000104C                                         ; .rdata$r:000013E0o
.data:0000104C                                         ; const type_info::`vftable'
.data:00001050                 db    0
.data:00001051                 db    0
.data:00001052                 db    0
.data:00001053                 db    0
.data:00001054                 db  2Eh ; .
.data:00001055                 db  3Fh ; ?
.data:00001056                 db  41h ; A
.data:00001057                 db  55h ; U
.data:00001058                 db  49h ; I
.data:00001059                 db  53h ; S
.data:0000105A                 db  65h ; e
.data:0000105B                 db  71h ; q
.data:0000105C                 db  75h ; u
.data:0000105D                 db  65h ; e
.data:0000105E                 db  6Eh ; n
.data:0000105F                 db  74h ; t
.data:00001060                 db  69h ; i
.data:00001061                 db  61h ; a
.data:00001062                 db  6Ch ; l
.data:00001063                 db  49h ; I
.data:00001064                 db  6Eh ; n
.data:00001065                 db  53h ; S
.data:00001066                 db  74h ; t
.data:00001067                 db  72h ; r
.data:00001068                 db  65h ; e
.data:00001069                 db  61h ; a
.data:0000106A                 db  6Dh ; m
.data:0000106B                 db  40h ; @
.data:0000106C                 db  40h ; @
.data:0000106D                 db    0
.data:0000106E                 align 10h
.data:0000106E _data           ends
.data:0000106E
.rdata$r:00001070 ; ===========================================================================
.rdata$r:00001070
.rdata$r:00001070 ; Segment type: Pure data
.rdata$r:00001070 ; Segment permissions: Read
.rdata$r:00001070 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001070                 assume cs:_rdata$r
.rdata$r:00001070                 ;org 1070h
.rdata$r:00001070 ; COMDAT (pick any)
.rdata$r:00001070                 public ??_R3ISequentialInStream@@8
.rdata$r:00001070 ; ISequentialInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00001070 ??_R3ISequentialInStream@@8 db    0     ; DATA XREF: .rdata$r:00001048o
.rdata$r:00001070                                         ; .rdata$r:000013E4o
.rdata$r:00001071                 db    0
.rdata$r:00001072                 db    0
.rdata$r:00001073                 db    0
.rdata$r:00001074                 db    0
.rdata$r:00001075                 db    0
.rdata$r:00001076                 db    0
.rdata$r:00001077                 db    0
.rdata$r:00001078                 db    2
.rdata$r:00001079                 db    0
.rdata$r:0000107A                 db    0
.rdata$r:0000107B                 db    0
.rdata$r:0000107C                 dd offset ??_R2ISequentialInStream@@8 ; ISequentialInStream::`RTTI Base Class Array'
.rdata$r:0000107C _rdata$r        ends
.rdata$r:0000107C
.rdata$r:00001080 ; ===========================================================================
.rdata$r:00001080
.rdata$r:00001080 ; Segment type: Pure data
.rdata$r:00001080 ; Segment permissions: Read
.rdata$r:00001080 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001080                 assume cs:_rdata$r
.rdata$r:00001080                 ;org 1080h
.rdata$r:00001080 ; COMDAT (pick any)
.rdata$r:00001080                 public ??_R2ISequentialInStream@@8
.rdata$r:00001080 ; ISequentialInStream::`RTTI Base Class Array'
.rdata$r:00001080 ??_R2ISequentialInStream@@8 dd offset ??_R1A@?0A@EA@ISequentialInStream@@8
.rdata$r:00001080                                         ; DATA XREF: .rdata$r:0000107Co
.rdata$r:00001080                                         ; ISequentialInStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00001084                 dd offset ??_R1A@?0A@EA@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00001088                 db    0
.rdata$r:00001089                 align 4
.rdata$r:00001089 _rdata$r        ends
.rdata$r:00001089
.rdata$r:0000108C ; ===========================================================================
.rdata$r:0000108C
.rdata$r:0000108C ; Segment type: Pure data
.rdata$r:0000108C ; Segment permissions: Read
.rdata$r:0000108C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000108C                 assume cs:_rdata$r
.rdata$r:0000108C                 ;org 108Ch
.rdata$r:0000108C ; COMDAT (pick any)
.rdata$r:0000108C                 public ??_R1A@?0A@EA@IUnknown@@8
.rdata$r:0000108C ; IUnknown::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000108C ??_R1A@?0A@EA@IUnknown@@8 dd offset ??_R0?AUIUnknown@@@8
.rdata$r:0000108C                                         ; DATA XREF: .rdata$r:00000FB4o
.rdata$r:0000108C                                         ; .rdata$r:00001028o ...
.rdata$r:0000108C                                         ; IUnknown `RTTI Type Descriptor'
.rdata$r:00001090                 db    0
.rdata$r:00001091                 db    0
.rdata$r:00001092                 db    0
.rdata$r:00001093                 db    0
.rdata$r:00001094                 db    0
.rdata$r:00001095                 db    0
.rdata$r:00001096                 db    0
.rdata$r:00001097                 db    0
.rdata$r:00001098                 db 0FFh
.rdata$r:00001099                 db 0FFh
.rdata$r:0000109A                 db 0FFh
.rdata$r:0000109B                 db 0FFh
.rdata$r:0000109C                 db    0
.rdata$r:0000109D                 db    0
.rdata$r:0000109E                 db    0
.rdata$r:0000109F                 db    0
.rdata$r:000010A0                 db  40h ; @
.rdata$r:000010A1                 db    0
.rdata$r:000010A2                 db    0
.rdata$r:000010A3                 db    0
.rdata$r:000010A4                 dd offset ??_R3IUnknown@@8 ; IUnknown::`RTTI Class Hierarchy Descriptor'
.rdata$r:000010A4 _rdata$r        ends
.rdata$r:000010A4
.data:000010A8 ; ===========================================================================
.data:000010A8
.data:000010A8 ; Segment type: Pure data
.data:000010A8 ; Segment permissions: Read/Write
.data:000010A8 _data           segment dword public 'DATA' use32
.data:000010A8                 assume cs:_data
.data:000010A8                 ;org 10A8h
.data:000010A8 ; COMDAT (pick any)
.data:000010A8                 public ??_R0?AUIUnknown@@@8
.data:000010A8 ; struct IUnknown `RTTI Type Descriptor'
.data:000010A8 ??_R0?AUIUnknown@@@8 dd offset ??_7type_info@@6B@
.data:000010A8                                         ; DATA XREF: .rdata$r:IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:000010A8                                         ; const type_info::`vftable'
.data:000010AC                 align 10h
.data:000010B0 a_?auiunknown@@ db '.?AUIUnknown@@',0
.data:000010BF                 align 10h
.data:000010BF _data           ends
.data:000010BF
.rdata$r:000010C0 ; ===========================================================================
.rdata$r:000010C0
.rdata$r:000010C0 ; Segment type: Pure data
.rdata$r:000010C0 ; Segment permissions: Read
.rdata$r:000010C0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000010C0                 assume cs:_rdata$r
.rdata$r:000010C0                 ;org 10C0h
.rdata$r:000010C0 ; COMDAT (pick any)
.rdata$r:000010C0                 public ??_R3IUnknown@@8
.rdata$r:000010C0 ; IUnknown::`RTTI Class Hierarchy Descriptor'
.rdata$r:000010C0 ??_R3IUnknown@@8 db    0                ; DATA XREF: .rdata$r:000010A4o
.rdata$r:000010C1                 db    0
.rdata$r:000010C2                 db    0
.rdata$r:000010C3                 db    0
.rdata$r:000010C4                 db    0
.rdata$r:000010C5                 db    0
.rdata$r:000010C6                 db    0
.rdata$r:000010C7                 db    0
.rdata$r:000010C8                 db    1
.rdata$r:000010C9                 db    0
.rdata$r:000010CA                 db    0
.rdata$r:000010CB                 db    0
.rdata$r:000010CC                 dd offset ??_R2IUnknown@@8 ; IUnknown::`RTTI Base Class Array'
.rdata$r:000010CC _rdata$r        ends
.rdata$r:000010CC
.rdata$r:000010D0 ; ===========================================================================
.rdata$r:000010D0
.rdata$r:000010D0 ; Segment type: Pure data
.rdata$r:000010D0 ; Segment permissions: Read
.rdata$r:000010D0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000010D0                 assume cs:_rdata$r
.rdata$r:000010D0                 ;org 10D0h
.rdata$r:000010D0 ; COMDAT (pick any)
.rdata$r:000010D0                 public ??_R2IUnknown@@8
.rdata$r:000010D0 ; IUnknown::`RTTI Base Class Array'
.rdata$r:000010D0 ??_R2IUnknown@@8 dd offset ??_R1A@?0A@EA@IUnknown@@8
.rdata$r:000010D0                                         ; DATA XREF: .rdata$r:000010CCo
.rdata$r:000010D0                                         ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000010D4                 db    0
.rdata$r:000010D5                 align 4
.rdata$r:000010D5 _rdata$r        ends
.rdata$r:000010D5
.rdata$r:000010D8 ; ===========================================================================
.rdata$r:000010D8
.rdata$r:000010D8 ; Segment type: Pure data
.rdata$r:000010D8 ; Segment permissions: Read
.rdata$r:000010D8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000010D8                 assume cs:_rdata$r
.rdata$r:000010D8                 ;org 10D8h
.rdata$r:000010D8 ; COMDAT (pick any)
.rdata$r:000010D8                 public ??_R13?0A@EA@CMyUnknownImp@@8
.rdata$r:000010D8 ; CMyUnknownImp::`RTTI Base Class Descriptor at (4, -1, 0, 64)'
.rdata$r:000010D8 ??_R13?0A@EA@CMyUnknownImp@@8 dd offset ??_R0?AVCMyUnknownImp@@@8
.rdata$r:000010D8                                         ; DATA XREF: .rdata$r:00000FB8o
.rdata$r:000010D8                                         ; .rdata$r:000014D8o
.rdata$r:000010D8                                         ; CMyUnknownImp `RTTI Type Descriptor'
.rdata$r:000010DC                 align 10h
.rdata$r:000010E0                 db    4
.rdata$r:000010E1                 db    0
.rdata$r:000010E2                 db    0
.rdata$r:000010E3                 db    0
.rdata$r:000010E4                 db 0FFh
.rdata$r:000010E5                 db 0FFh
.rdata$r:000010E6                 db 0FFh
.rdata$r:000010E7                 db 0FFh
.rdata$r:000010E8                 db    0
.rdata$r:000010E9                 db    0
.rdata$r:000010EA                 db    0
.rdata$r:000010EB                 db    0
.rdata$r:000010EC                 db  40h ; @
.rdata$r:000010ED                 db    0
.rdata$r:000010EE                 db    0
.rdata$r:000010EF                 db    0
.rdata$r:000010F0                 dd offset ??_R3CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Class Hierarchy Descriptor'
.rdata$r:000010F0 _rdata$r        ends
.rdata$r:000010F0
.data:000010F4 ; ===========================================================================
.data:000010F4
.data:000010F4 ; Segment type: Pure data
.data:000010F4 ; Segment permissions: Read/Write
.data:000010F4 _data           segment dword public 'DATA' use32
.data:000010F4                 assume cs:_data
.data:000010F4                 ;org 10F4h
.data:000010F4 ; COMDAT (pick any)
.data:000010F4                 public ??_R0?AVCMyUnknownImp@@@8
.data:000010F4 ; class CMyUnknownImp `RTTI Type Descriptor'
.data:000010F4 ??_R0?AVCMyUnknownImp@@@8 dd offset ??_7type_info@@6B@
.data:000010F4                                         ; DATA XREF: .rdata$r:CMyUnknownImp::`RTTI Base Class Descriptor at (4,-1,0,64)'o
.data:000010F4                                         ; .rdata$r:CMyUnknownImp::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:000010F4                                         ; const type_info::`vftable'
.data:000010F8                 db    0
.data:000010F9                 db    0
.data:000010FA                 db    0
.data:000010FB                 db    0
.data:000010FC                 db  2Eh ; .
.data:000010FD                 db  3Fh ; ?
.data:000010FE                 db  41h ; A
.data:000010FF                 db  56h ; V
.data:00001100                 db  43h ; C
.data:00001101                 db  4Dh ; M
.data:00001102                 db  79h ; y
.data:00001103                 db  55h ; U
.data:00001104                 db  6Eh ; n
.data:00001105                 db  6Bh ; k
.data:00001106                 db  6Eh ; n
.data:00001107                 db  6Fh ; o
.data:00001108                 db  77h ; w
.data:00001109                 db  6Eh ; n
.data:0000110A                 db  49h ; I
.data:0000110B                 db  6Dh ; m
.data:0000110C                 db  70h ; p
.data:0000110D                 db  40h ; @
.data:0000110E                 db  40h ; @
.data:0000110F                 db    0
.data:0000110F _data           ends
.data:0000110F
.rdata$r:00001110 ; ===========================================================================
.rdata$r:00001110
.rdata$r:00001110 ; Segment type: Pure data
.rdata$r:00001110 ; Segment permissions: Read
.rdata$r:00001110 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001110                 assume cs:_rdata$r
.rdata$r:00001110                 ;org 1110h
.rdata$r:00001110 ; COMDAT (pick any)
.rdata$r:00001110                 public ??_R3CMyUnknownImp@@8
.rdata$r:00001110 ; CMyUnknownImp::`RTTI Class Hierarchy Descriptor'
.rdata$r:00001110 ??_R3CMyUnknownImp@@8 db    0           ; DATA XREF: .rdata$r:000010F0o
.rdata$r:00001110                                         ; .rdata$r:00001140o
.rdata$r:00001111                 db    0
.rdata$r:00001112                 db    0
.rdata$r:00001113                 db    0
.rdata$r:00001114                 db    0
.rdata$r:00001115                 db    0
.rdata$r:00001116                 db    0
.rdata$r:00001117                 db    0
.rdata$r:00001118                 db    1
.rdata$r:00001119                 db    0
.rdata$r:0000111A                 db    0
.rdata$r:0000111B                 db    0
.rdata$r:0000111C                 dd offset ??_R2CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Base Class Array'
.rdata$r:0000111C _rdata$r        ends
.rdata$r:0000111C
.rdata$r:00001120 ; ===========================================================================
.rdata$r:00001120
.rdata$r:00001120 ; Segment type: Pure data
.rdata$r:00001120 ; Segment permissions: Read
.rdata$r:00001120 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001120                 assume cs:_rdata$r
.rdata$r:00001120                 ;org 1120h
.rdata$r:00001120 ; COMDAT (pick any)
.rdata$r:00001120                 public ??_R2CMyUnknownImp@@8
.rdata$r:00001120 ; CMyUnknownImp::`RTTI Base Class Array'
.rdata$r:00001120 ??_R2CMyUnknownImp@@8 dd offset ??_R1A@?0A@EA@CMyUnknownImp@@8
.rdata$r:00001120                                         ; DATA XREF: .rdata$r:0000111Co
.rdata$r:00001120                                         ; CMyUnknownImp::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00001124                 db    0
.rdata$r:00001125                 align 4
.rdata$r:00001125 _rdata$r        ends
.rdata$r:00001125
.rdata$r:00001128 ; ===========================================================================
.rdata$r:00001128
.rdata$r:00001128 ; Segment type: Pure data
.rdata$r:00001128 ; Segment permissions: Read
.rdata$r:00001128 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001128                 assume cs:_rdata$r
.rdata$r:00001128                 ;org 1128h
.rdata$r:00001128 ; COMDAT (pick any)
.rdata$r:00001128                 public ??_R1A@?0A@EA@CMyUnknownImp@@8
.rdata$r:00001128 ; CMyUnknownImp::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00001128 ??_R1A@?0A@EA@CMyUnknownImp@@8 dd offset ??_R0?AVCMyUnknownImp@@@8
.rdata$r:00001128                                         ; DATA XREF: .rdata$r:CMyUnknownImp::`RTTI Base Class Array'o
.rdata$r:00001128                                         ; CMyUnknownImp `RTTI Type Descriptor'
.rdata$r:0000112C                 db    0
.rdata$r:0000112D                 db    0
.rdata$r:0000112E                 db    0
.rdata$r:0000112F                 db    0
.rdata$r:00001130                 db    0
.rdata$r:00001131                 db    0
.rdata$r:00001132                 db    0
.rdata$r:00001133                 db    0
.rdata$r:00001134                 db 0FFh
.rdata$r:00001135                 db 0FFh
.rdata$r:00001136                 db 0FFh
.rdata$r:00001137                 db 0FFh
.rdata$r:00001138                 db    0
.rdata$r:00001139                 db    0
.rdata$r:0000113A                 db    0
.rdata$r:0000113B                 db    0
.rdata$r:0000113C                 db  40h ; @
.rdata$r:0000113D                 db    0
.rdata$r:0000113E                 db    0
.rdata$r:0000113F                 db    0
.rdata$r:00001140                 dd offset ??_R3CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Class Hierarchy Descriptor'
.rdata$r:00001140 _rdata$r        ends
.rdata$r:00001140
.text:00001144 ; ===========================================================================
.text:00001144
.text:00001144 ; Segment type: Pure code
.text:00001144 ; Segment permissions: Read/Execute
.text:00001144 _text           segment para public 'CODE' use32
.text:00001144                 assume cs:_text
.text:00001144                 ;org 1144h
.text:00001144 ; COMDAT (pick any)
.text:00001144                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001144
.text:00001144 ; =============== S U B R O U T I N E =======================================
.text:00001144
.text:00001144 ; Attributes: bp-based frame
.text:00001144
.text:00001144 ; _DWORD __thiscall CMyUnknownImp::CMyUnknownImp(CMyUnknownImp *__hidden this)
.text:00001144                 public ??0CMyUnknownImp@@QAE@XZ
.text:00001144 ??0CMyUnknownImp@@QAE@XZ proc near      ; CODE XREF: CBufInStream::CBufInStream(void)+1Cp
.text:00001144                                         ; CBufferInStream::CBufferInStream(void)+1Cp
.text:00001144
.text:00001144 var_4           = dword ptr -4
.text:00001144
.text:00001144                 push    ebp
.text:00001145                 mov     ebp, esp
.text:00001147                 push    ecx
.text:00001148                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000114F                 mov     [ebp+var_4], ecx
.text:00001152                 mov     eax, [ebp+var_4]
.text:00001155                 mov     dword ptr [eax], 0
.text:0000115B                 mov     eax, [ebp+var_4]
.text:0000115E                 mov     esp, ebp
.text:00001160                 pop     ebp
.text:00001161                 retn
.text:00001161 ??0CMyUnknownImp@@QAE@XZ endp
.text:00001161
.text:00001161 ; ---------------------------------------------------------------------------
.text:00001162                 align 4
.text:00001162 _text           ends
.text:00001162
.text:00001164 ; ===========================================================================
.text:00001164
.text:00001164 ; Segment type: Pure code
.text:00001164 ; Segment permissions: Read/Execute
.text:00001164 _text           segment para public 'CODE' use32
.text:00001164                 assume cs:_text
.text:00001164                 ;org 1164h
.text:00001164 ; COMDAT (pick any)
.text:00001164                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001164
.text:00001164 ; =============== S U B R O U T I N E =======================================
.text:00001164
.text:00001164 ; Attributes: bp-based frame
.text:00001164
.text:00001164 ; __int32 __stdcall CBufInStream::QueryInterface(CBufInStream *this, const struct _GUID *Buf1, void **)
.text:00001164                 public ?QueryInterface@CBufInStream@@UAGJABU_GUID@@PAPAX@Z
.text:00001164 ?QueryInterface@CBufInStream@@UAGJABU_GUID@@PAPAX@Z proc near
.text:00001164                                         ; DATA XREF: .rdata:const CBufInStream::`vftable'o
.text:00001164
.text:00001164 this            = dword ptr  8
.text:00001164 Buf1            = dword ptr  0Ch
.text:00001164 arg_8           = dword ptr  10h
.text:00001164
.text:00001164                 push    ebp
.text:00001165                 mov     ebp, esp
.text:00001167                 mov     eax, [ebp+arg_8]
.text:0000116A                 mov     dword ptr [eax], 0
.text:00001170                 push    offset _IID_IUnknown ; Buf2
.text:00001175                 mov     ecx, [ebp+Buf1]
.text:00001178                 push    ecx             ; Buf1
.text:00001179                 call    ___@8           ; __(x,x)
.text:0000117E                 test    eax, eax
.text:00001180                 jz      short loc_118C
.text:00001182                 mov     edx, [ebp+arg_8]
.text:00001185                 mov     eax, [ebp+this]
.text:00001188                 mov     [edx], eax
.text:0000118A                 jmp     short loc_11CB
.text:0000118C ; ---------------------------------------------------------------------------
.text:0000118C
.text:0000118C loc_118C:                               ; CODE XREF: CBufInStream::QueryInterface(_GUID const &,void * *)+1Cj
.text:0000118C                 push    offset _IID_ISequentialInStream ; Buf2
.text:00001191                 mov     ecx, [ebp+Buf1]
.text:00001194                 push    ecx             ; Buf1
.text:00001195                 call    ___@8           ; __(x,x)
.text:0000119A                 test    eax, eax
.text:0000119C                 jz      short loc_11A8
.text:0000119E                 mov     edx, [ebp+arg_8]
.text:000011A1                 mov     eax, [ebp+this]
.text:000011A4                 mov     [edx], eax
.text:000011A6                 jmp     short loc_11CB
.text:000011A8 ; ---------------------------------------------------------------------------
.text:000011A8
.text:000011A8 loc_11A8:                               ; CODE XREF: CBufInStream::QueryInterface(_GUID const &,void * *)+38j
.text:000011A8                 push    offset _IID_IInStream ; Buf2
.text:000011AD                 mov     ecx, [ebp+Buf1]
.text:000011B0                 push    ecx             ; Buf1
.text:000011B1                 call    ___@8           ; __(x,x)
.text:000011B6                 test    eax, eax
.text:000011B8                 jz      short loc_11C4
.text:000011BA                 mov     edx, [ebp+arg_8]
.text:000011BD                 mov     eax, [ebp+this]
.text:000011C0                 mov     [edx], eax
.text:000011C2                 jmp     short loc_11CB
.text:000011C4 ; ---------------------------------------------------------------------------
.text:000011C4
.text:000011C4 loc_11C4:                               ; CODE XREF: CBufInStream::QueryInterface(_GUID const &,void * *)+54j
.text:000011C4                 mov     eax, 80004002h
.text:000011C9                 jmp     short loc_11DC
.text:000011CB ; ---------------------------------------------------------------------------
.text:000011CB
.text:000011CB loc_11CB:                               ; CODE XREF: CBufInStream::QueryInterface(_GUID const &,void * *)+26j
.text:000011CB                                         ; CBufInStream::QueryInterface(_GUID const &,void * *)+42j ...
.text:000011CB                 mov     ecx, [ebp+this]
.text:000011CE                 mov     edx, [ecx+4]
.text:000011D1                 add     edx, 1
.text:000011D4                 mov     eax, [ebp+this]
.text:000011D7                 mov     [eax+4], edx
.text:000011DA                 xor     eax, eax
.text:000011DC
.text:000011DC loc_11DC:                               ; CODE XREF: CBufInStream::QueryInterface(_GUID const &,void * *)+65j
.text:000011DC                 cmp     ebp, esp
.text:000011DE                 call    __RTC_CheckEsp
.text:000011E3                 pop     ebp
.text:000011E4                 retn    0Ch
.text:000011E4 ?QueryInterface@CBufInStream@@UAGJABU_GUID@@PAPAX@Z endp
.text:000011E4
.text:000011E4 ; ---------------------------------------------------------------------------
.text:000011E7                 align 4
.text:000011E7 _text           ends
.text:000011E7
.text:000011E8 ; ===========================================================================
.text:000011E8
.text:000011E8 ; Segment type: Pure code
.text:000011E8 ; Segment permissions: Read/Execute
.text:000011E8 _text           segment para public 'CODE' use32
.text:000011E8                 assume cs:_text
.text:000011E8                 ;org 11E8h
.text:000011E8 ; COMDAT (pick any)
.text:000011E8                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000011E8
.text:000011E8 ; =============== S U B R O U T I N E =======================================
.text:000011E8
.text:000011E8 ; Attributes: bp-based frame
.text:000011E8
.text:000011E8 ; int __stdcall __(void *Buf1, void *Buf2)
.text:000011E8                 public ___@8
.text:000011E8 ___@8           proc near               ; CODE XREF: CBufInStream::QueryInterface(_GUID const &,void * *)+15p
.text:000011E8                                         ; CBufInStream::QueryInterface(_GUID const &,void * *)+31p ...
.text:000011E8
.text:000011E8 Buf1            = dword ptr  8
.text:000011E8 Buf2            = dword ptr  0Ch
.text:000011E8
.text:000011E8                 push    ebp
.text:000011E9                 mov     ebp, esp
.text:000011EB                 mov     eax, [ebp+Buf2]
.text:000011EE                 push    eax             ; Buf2
.text:000011EF                 mov     ecx, [ebp+Buf1]
.text:000011F2                 push    ecx             ; Buf1
.text:000011F3                 call    _IsEqualGUID@8  ; IsEqualGUID(x,x)
.text:000011F8                 cmp     ebp, esp
.text:000011FA                 call    __RTC_CheckEsp
.text:000011FF                 pop     ebp
.text:00001200                 retn    8
.text:00001200 ___@8           endp
.text:00001200
.text:00001200 ; ---------------------------------------------------------------------------
.text:00001203                 align 4
.text:00001203 _text           ends
.text:00001203
.text:00001204 ; ===========================================================================
.text:00001204
.text:00001204 ; Segment type: Pure code
.text:00001204 ; Segment permissions: Read/Execute
.text:00001204 _text           segment para public 'CODE' use32
.text:00001204                 assume cs:_text
.text:00001204                 ;org 1204h
.text:00001204 ; COMDAT (pick any)
.text:00001204                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001204
.text:00001204 ; =============== S U B R O U T I N E =======================================
.text:00001204
.text:00001204 ; Attributes: bp-based frame
.text:00001204
.text:00001204 ; int __stdcall IsEqualGUID(void *Buf1, void *Buf2)
.text:00001204                 public _IsEqualGUID@8
.text:00001204 _IsEqualGUID@8  proc near               ; CODE XREF: __(x,x)+Bp
.text:00001204
.text:00001204 Buf1            = dword ptr  8
.text:00001204 Buf2            = dword ptr  0Ch
.text:00001204
.text:00001204                 push    ebp
.text:00001205                 mov     ebp, esp
.text:00001207                 push    10h             ; Size
.text:00001209                 mov     eax, [ebp+Buf2]
.text:0000120C                 push    eax             ; Buf2
.text:0000120D                 mov     ecx, [ebp+Buf1]
.text:00001210                 push    ecx             ; Buf1
.text:00001211                 call    _memcmp
.text:00001216                 add     esp, 0Ch
.text:00001219                 neg     eax
.text:0000121B                 sbb     eax, eax
.text:0000121D                 add     eax, 1
.text:00001220                 cmp     ebp, esp
.text:00001222                 call    __RTC_CheckEsp
.text:00001227                 pop     ebp
.text:00001228                 retn    8
.text:00001228 _IsEqualGUID@8  endp
.text:00001228
.text:00001228 ; ---------------------------------------------------------------------------
.text:0000122B                 align 4
.text:0000122B _text           ends
.text:0000122B
.text:0000122C ; ===========================================================================
.text:0000122C
.text:0000122C ; Segment type: Pure code
.text:0000122C ; Segment permissions: Read/Execute
.text:0000122C _text           segment para public 'CODE' use32
.text:0000122C                 assume cs:_text
.text:0000122C                 ;org 122Ch
.text:0000122C ; COMDAT (pick any)
.text:0000122C                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:0000122C
.text:0000122C ; =============== S U B R O U T I N E =======================================
.text:0000122C
.text:0000122C ; Attributes: bp-based frame
.text:0000122C
.text:0000122C ; unsigned __int32 __stdcall CBufInStream::AddRef(CBufInStream *this)
.text:0000122C                 public ?AddRef@CBufInStream@@UAGKXZ
.text:0000122C ?AddRef@CBufInStream@@UAGKXZ proc near  ; DATA XREF: .rdata:00000F58o
.text:0000122C
.text:0000122C var_4           = dword ptr -4
.text:0000122C this            = dword ptr  8
.text:0000122C
.text:0000122C                 push    ebp
.text:0000122D                 mov     ebp, esp
.text:0000122F                 push    ecx
.text:00001230                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001237                 mov     eax, [ebp+this]
.text:0000123A                 mov     ecx, [eax+4]
.text:0000123D                 add     ecx, 1
.text:00001240                 mov     [ebp+var_4], ecx
.text:00001243                 mov     edx, [ebp+this]
.text:00001246                 mov     eax, [ebp+var_4]
.text:00001249                 mov     [edx+4], eax
.text:0000124C                 mov     eax, [ebp+var_4]
.text:0000124F                 mov     esp, ebp
.text:00001251                 pop     ebp
.text:00001252                 retn    4
.text:00001252 ?AddRef@CBufInStream@@UAGKXZ endp
.text:00001252
.text:00001252 ; ---------------------------------------------------------------------------
.text:00001255                 align 4
.text:00001255 _text           ends
.text:00001255
.text:00001258 ; ===========================================================================
.text:00001258
.text:00001258 ; Segment type: Pure code
.text:00001258 ; Segment permissions: Read/Execute
.text:00001258 _text           segment para public 'CODE' use32
.text:00001258                 assume cs:_text
.text:00001258                 ;org 1258h
.text:00001258 ; COMDAT (pick any)
.text:00001258                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001258
.text:00001258 ; =============== S U B R O U T I N E =======================================
.text:00001258
.text:00001258 ; Attributes: bp-based frame
.text:00001258
.text:00001258 ; unsigned __int32 __stdcall CBufInStream::Release(CBufInStream *this)
.text:00001258                 public ?Release@CBufInStream@@UAGKXZ
.text:00001258 ?Release@CBufInStream@@UAGKXZ proc near ; DATA XREF: .rdata:00000F5Co
.text:00001258
.text:00001258 var_10          = dword ptr -10h
.text:00001258 var_C           = dword ptr -0Ch
.text:00001258 var_8           = dword ptr -8
.text:00001258 var_4           = dword ptr -4
.text:00001258 this            = dword ptr  8
.text:00001258
.text:00001258                 push    ebp
.text:00001259                 mov     ebp, esp
.text:0000125B                 sub     esp, 10h
.text:0000125E                 mov     eax, 0CCCCCCCCh
.text:00001263                 mov     [ebp+var_10], eax
.text:00001266                 mov     [ebp+var_C], eax
.text:00001269                 mov     [ebp+var_8], eax
.text:0000126C                 mov     [ebp+var_4], eax
.text:0000126F                 mov     eax, [ebp+this]
.text:00001272                 mov     ecx, [eax+4]
.text:00001275                 sub     ecx, 1
.text:00001278                 mov     [ebp+var_C], ecx
.text:0000127B                 mov     edx, [ebp+this]
.text:0000127E                 mov     eax, [ebp+var_C]
.text:00001281                 mov     [edx+4], eax
.text:00001284                 cmp     [ebp+var_C], 0
.text:00001288                 jz      short loc_1292
.text:0000128A                 mov     ecx, [ebp+this]
.text:0000128D                 mov     eax, [ecx+4]
.text:00001290                 jmp     short loc_12BC
.text:00001292 ; ---------------------------------------------------------------------------
.text:00001292
.text:00001292 loc_1292:                               ; CODE XREF: CBufInStream::Release(void)+30j
.text:00001292                 mov     edx, [ebp+this]
.text:00001295                 mov     [ebp+var_8], edx
.text:00001298                 mov     eax, [ebp+var_8]
.text:0000129B                 mov     [ebp+var_4], eax
.text:0000129E                 cmp     [ebp+var_4], 0
.text:000012A2                 jz      short loc_12B3
.text:000012A4                 push    1
.text:000012A6                 mov     ecx, [ebp+var_4]
.text:000012A9                 call    ??_GCBufInStream@@QAEPAXI@Z ; CBufInStream::`scalar deleting destructor'(uint)
.text:000012AE                 mov     [ebp+var_10], eax
.text:000012B1                 jmp     short loc_12BA
.text:000012B3 ; ---------------------------------------------------------------------------
.text:000012B3
.text:000012B3 loc_12B3:                               ; CODE XREF: CBufInStream::Release(void)+4Aj
.text:000012B3                 mov     [ebp+var_10], 0
.text:000012BA
.text:000012BA loc_12BA:                               ; CODE XREF: CBufInStream::Release(void)+59j
.text:000012BA                 xor     eax, eax
.text:000012BC
.text:000012BC loc_12BC:                               ; CODE XREF: CBufInStream::Release(void)+38j
.text:000012BC                 add     esp, 10h
.text:000012BF                 cmp     ebp, esp
.text:000012C1                 call    __RTC_CheckEsp
.text:000012C6                 mov     esp, ebp
.text:000012C8                 pop     ebp
.text:000012C9                 retn    4
.text:000012C9 ?Release@CBufInStream@@UAGKXZ endp
.text:000012C9
.text:000012C9 _text           ends
.text:000012C9
.text:000012CC ; ===========================================================================
.text:000012CC
.text:000012CC ; Segment type: Pure code
.text:000012CC ; Segment permissions: Read/Execute
.text:000012CC _text           segment para public 'CODE' use32
.text:000012CC                 assume cs:_text
.text:000012CC                 ;org 12CCh
.text:000012CC ; COMDAT (pick any)
.text:000012CC                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000012CC
.text:000012CC ; =============== S U B R O U T I N E =======================================
.text:000012CC
.text:000012CC ; Attributes: bp-based frame
.text:000012CC
.text:000012CC ; public: void * __thiscall CBufInStream::`scalar deleting destructor'(unsigned int)
.text:000012CC                 public ??_GCBufInStream@@QAEPAXI@Z
.text:000012CC ??_GCBufInStream@@QAEPAXI@Z proc near   ; CODE XREF: CBufInStream::Release(void)+51p
.text:000012CC
.text:000012CC var_4           = dword ptr -4
.text:000012CC arg_0           = dword ptr  8
.text:000012CC
.text:000012CC                 push    ebp
.text:000012CD                 mov     ebp, esp
.text:000012CF                 push    ecx
.text:000012D0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000012D7                 mov     [ebp+var_4], ecx
.text:000012DA                 mov     ecx, [ebp+var_4] ; this
.text:000012DD                 call    ??1CBufInStream@@QAE@XZ ; CBufInStream::~CBufInStream(void)
.text:000012E2                 mov     eax, [ebp+arg_0]
.text:000012E5                 and     eax, 1
.text:000012E8                 jz      short loc_12F6
.text:000012EA                 mov     ecx, [ebp+var_4]
.text:000012ED                 push    ecx             ; void *
.text:000012EE                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:000012F3                 add     esp, 4
.text:000012F6
.text:000012F6 loc_12F6:                               ; CODE XREF: CBufInStream::`scalar deleting destructor'(uint)+1Cj
.text:000012F6                 mov     eax, [ebp+var_4]
.text:000012F9                 add     esp, 4
.text:000012FC                 cmp     ebp, esp
.text:000012FE                 call    __RTC_CheckEsp
.text:00001303                 mov     esp, ebp
.text:00001305                 pop     ebp
.text:00001306                 retn    4
.text:00001306 ??_GCBufInStream@@QAEPAXI@Z endp
.text:00001306
.text:00001306 ; ---------------------------------------------------------------------------
.text:00001309                 align 4
.text:00001309 _text           ends
.text:00001309
.text:0000130C ; ===========================================================================
.text:0000130C
.text:0000130C ; Segment type: Pure code
.text:0000130C ; Segment permissions: Read/Execute
.text:0000130C _text           segment para public 'CODE' use32
.text:0000130C                 assume cs:_text
.text:0000130C                 ;org 130Ch
.text:0000130C ; COMDAT (pick any)
.text:0000130C                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:0000130C
.text:0000130C ; =============== S U B R O U T I N E =======================================
.text:0000130C
.text:0000130C ; Attributes: bp-based frame
.text:0000130C
.text:0000130C ; _DWORD __thiscall CBufInStream::~CBufInStream(CBufInStream *__hidden this)
.text:0000130C                 public ??1CBufInStream@@QAE@XZ
.text:0000130C ??1CBufInStream@@QAE@XZ proc near       ; CODE XREF: CBufInStream::`scalar deleting destructor'(uint)+11p
.text:0000130C
.text:0000130C var_4           = dword ptr -4
.text:0000130C
.text:0000130C                 push    ebp
.text:0000130D                 mov     ebp, esp
.text:0000130F                 push    ecx
.text:00001310                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001317                 mov     [ebp+var_4], ecx
.text:0000131A                 mov     ecx, [ebp+var_4]
.text:0000131D                 add     ecx, 1Ch
.text:00001320                 call    ??1?$CMyComPtr@UIUnknown@@@@QAE@XZ ; CMyComPtr<IUnknown>::~CMyComPtr<IUnknown>(void)
.text:00001325                 add     esp, 4
.text:00001328                 cmp     ebp, esp
.text:0000132A                 call    __RTC_CheckEsp
.text:0000132F                 mov     esp, ebp
.text:00001331                 pop     ebp
.text:00001332                 retn
.text:00001332 ??1CBufInStream@@QAE@XZ endp
.text:00001332
.text:00001332 ; ---------------------------------------------------------------------------
.text:00001333                 align 4
.text:00001333 _text           ends
.text:00001333
.text:00001334 ; ===========================================================================
.text:00001334
.text:00001334 ; Segment type: Pure code
.text:00001334 ; Segment permissions: Read/Execute
.text:00001334 _text           segment para public 'CODE' use32
.text:00001334                 assume cs:_text
.text:00001334                 ;org 1334h
.text:00001334 ; COMDAT (pick any)
.text:00001334                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001334
.text:00001334 ; =============== S U B R O U T I N E =======================================
.text:00001334
.text:00001334 ; Attributes: bp-based frame
.text:00001334
.text:00001334 ; _DWORD __thiscall IInStream::IInStream(IInStream *__hidden this)
.text:00001334                 public ??0IInStream@@QAE@XZ
.text:00001334 ??0IInStream@@QAE@XZ proc near          ; CODE XREF: CBufInStream::CBufInStream(void)+11p
.text:00001334                                         ; CBufferInStream::CBufferInStream(void)+11p
.text:00001334
.text:00001334 var_4           = dword ptr -4
.text:00001334
.text:00001334                 push    ebp
.text:00001335                 mov     ebp, esp
.text:00001337                 push    ecx
.text:00001338                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000133F                 mov     [ebp+var_4], ecx
.text:00001342                 mov     ecx, [ebp+var_4] ; this
.text:00001345                 call    ??0ISequentialInStream@@QAE@XZ ; ISequentialInStream::ISequentialInStream(void)
.text:0000134A                 mov     eax, [ebp+var_4]
.text:0000134D                 mov     dword ptr [eax], offset ??_7IInStream@@6B@ ; const IInStream::`vftable'
.text:00001353                 mov     eax, [ebp+var_4]
.text:00001356                 add     esp, 4
.text:00001359                 cmp     ebp, esp
.text:0000135B                 call    __RTC_CheckEsp
.text:00001360                 mov     esp, ebp
.text:00001362                 pop     ebp
.text:00001363                 retn
.text:00001363 ??0IInStream@@QAE@XZ endp
.text:00001363
.text:00001363 _text           ends
.text:00001363
.rdata:00001364 ; ===========================================================================
.rdata:00001364
.rdata:00001364 ; Segment type: Pure data
.rdata:00001364 ; Segment permissions: Read
.rdata:00001364 _rdata          segment dword public 'DATA' use32
.rdata:00001364                 assume cs:_rdata
.rdata:00001364                 ;org 1364h
.rdata:00001364 ; COMDAT (pick largest)
.rdata:00001364                 dd offset ??_R4IInStream@@6B@ ; const IInStream::`RTTI Complete Object Locator'
.rdata:00001368                 public ??_7IInStream@@6B@
.rdata:00001368 ; const IInStream::`vftable'
.rdata:00001368 ??_7IInStream@@6B@ dd offset __purecall ; DATA XREF: IInStream::IInStream(void)+19o
.rdata:0000136C                 dd offset __purecall
.rdata:00001370                 dd offset __purecall
.rdata:00001374                 dd offset __purecall
.rdata:00001378                 dd offset __purecall
.rdata:00001378 _rdata          ends
.rdata:00001378
.rdata$r:0000137C ; ===========================================================================
.rdata$r:0000137C
.rdata$r:0000137C ; Segment type: Pure data
.rdata$r:0000137C ; Segment permissions: Read
.rdata$r:0000137C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000137C                 assume cs:_rdata$r
.rdata$r:0000137C                 ;org 137Ch
.rdata$r:0000137C ; COMDAT (pick any)
.rdata$r:0000137C                 public ??_R4IInStream@@6B@
.rdata$r:0000137C ; const IInStream::`RTTI Complete Object Locator'
.rdata$r:0000137C ??_R4IInStream@@6B@ db    0             ; DATA XREF: .rdata:00001364o
.rdata$r:0000137D                 db    0
.rdata$r:0000137E                 db    0
.rdata$r:0000137F                 db    0
.rdata$r:00001380                 db    0
.rdata$r:00001381                 db    0
.rdata$r:00001382                 db    0
.rdata$r:00001383                 db    0
.rdata$r:00001384                 db    0
.rdata$r:00001385                 db    0
.rdata$r:00001386                 db    0
.rdata$r:00001387                 db    0
.rdata$r:00001388                 dd offset ??_R0?AUIInStream@@@8 ; IInStream `RTTI Type Descriptor'
.rdata$r:0000138C                 dd offset ??_R3IInStream@@8 ; IInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000138C _rdata$r        ends
.rdata$r:0000138C
.text:00001390 ; ===========================================================================
.text:00001390
.text:00001390 ; Segment type: Pure code
.text:00001390 ; Segment permissions: Read/Execute
.text:00001390 _text           segment para public 'CODE' use32
.text:00001390                 assume cs:_text
.text:00001390                 ;org 1390h
.text:00001390 ; COMDAT (pick any)
.text:00001390                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001390
.text:00001390 ; =============== S U B R O U T I N E =======================================
.text:00001390
.text:00001390 ; Attributes: bp-based frame
.text:00001390
.text:00001390 ; _DWORD __thiscall ISequentialInStream::ISequentialInStream(ISequentialInStream *__hidden this)
.text:00001390                 public ??0ISequentialInStream@@QAE@XZ
.text:00001390 ??0ISequentialInStream@@QAE@XZ proc near
.text:00001390                                         ; CODE XREF: IInStream::IInStream(void)+11p
.text:00001390
.text:00001390 var_4           = dword ptr -4
.text:00001390
.text:00001390                 push    ebp
.text:00001391                 mov     ebp, esp
.text:00001393                 push    ecx
.text:00001394                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000139B                 mov     [ebp+var_4], ecx
.text:0000139E                 mov     ecx, [ebp+var_4]
.text:000013A1                 call    ??0IUnknown@@QAE@XZ ; IUnknown::IUnknown(void)
.text:000013A6                 mov     eax, [ebp+var_4]
.text:000013A9                 mov     dword ptr [eax], offset ??_7ISequentialInStream@@6B@ ; const ISequentialInStream::`vftable'
.text:000013AF                 mov     eax, [ebp+var_4]
.text:000013B2                 add     esp, 4
.text:000013B5                 cmp     ebp, esp
.text:000013B7                 call    __RTC_CheckEsp
.text:000013BC                 mov     esp, ebp
.text:000013BE                 pop     ebp
.text:000013BF                 retn
.text:000013BF ??0ISequentialInStream@@QAE@XZ endp
.text:000013BF
.text:000013BF _text           ends
.text:000013BF
.rdata:000013C0 ; ===========================================================================
.rdata:000013C0
.rdata:000013C0 ; Segment type: Pure data
.rdata:000013C0 ; Segment permissions: Read
.rdata:000013C0 _rdata          segment dword public 'DATA' use32
.rdata:000013C0                 assume cs:_rdata
.rdata:000013C0                 ;org 13C0h
.rdata:000013C0 ; COMDAT (pick largest)
.rdata:000013C0                 dd offset ??_R4ISequentialInStream@@6B@ ; const ISequentialInStream::`RTTI Complete Object Locator'
.rdata:000013C4                 public ??_7ISequentialInStream@@6B@
.rdata:000013C4 ; const ISequentialInStream::`vftable'
.rdata:000013C4 ??_7ISequentialInStream@@6B@ dd offset __purecall
.rdata:000013C4                                         ; DATA XREF: ISequentialInStream::ISequentialInStream(void)+19o
.rdata:000013C8                 dd offset __purecall
.rdata:000013CC                 dd offset __purecall
.rdata:000013D0                 dd offset __purecall
.rdata:000013D0 _rdata          ends
.rdata:000013D0
.rdata$r:000013D4 ; ===========================================================================
.rdata$r:000013D4
.rdata$r:000013D4 ; Segment type: Pure data
.rdata$r:000013D4 ; Segment permissions: Read
.rdata$r:000013D4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000013D4                 assume cs:_rdata$r
.rdata$r:000013D4                 ;org 13D4h
.rdata$r:000013D4 ; COMDAT (pick any)
.rdata$r:000013D4                 public ??_R4ISequentialInStream@@6B@
.rdata$r:000013D4 ; const ISequentialInStream::`RTTI Complete Object Locator'
.rdata$r:000013D4 ??_R4ISequentialInStream@@6B@ db    0   ; DATA XREF: .rdata:000013C0o
.rdata$r:000013D5                 db    0
.rdata$r:000013D6                 db    0
.rdata$r:000013D7                 db    0
.rdata$r:000013D8                 db    0
.rdata$r:000013D9                 db    0
.rdata$r:000013DA                 db    0
.rdata$r:000013DB                 db    0
.rdata$r:000013DC                 db    0
.rdata$r:000013DD                 db    0
.rdata$r:000013DE                 db    0
.rdata$r:000013DF                 db    0
.rdata$r:000013E0                 dd offset ??_R0?AUISequentialInStream@@@8 ; ISequentialInStream `RTTI Type Descriptor'
.rdata$r:000013E4                 dd offset ??_R3ISequentialInStream@@8 ; ISequentialInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:000013E4 _rdata$r        ends
.rdata$r:000013E4
.text:000013E8 ; ===========================================================================
.text:000013E8
.text:000013E8 ; Segment type: Pure code
.text:000013E8 ; Segment permissions: Read/Execute
.text:000013E8 _text           segment para public 'CODE' use32
.text:000013E8                 assume cs:_text
.text:000013E8                 ;org 13E8h
.text:000013E8 ; COMDAT (pick any)
.text:000013E8                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000013E8
.text:000013E8 ; =============== S U B R O U T I N E =======================================
.text:000013E8
.text:000013E8 ; Attributes: bp-based frame
.text:000013E8
.text:000013E8 ; public: __thiscall IUnknown::IUnknown(void)
.text:000013E8                 public ??0IUnknown@@QAE@XZ
.text:000013E8 ??0IUnknown@@QAE@XZ proc near           ; CODE XREF: ISequentialInStream::ISequentialInStream(void)+11p
.text:000013E8
.text:000013E8 var_4           = dword ptr -4
.text:000013E8
.text:000013E8                 push    ebp
.text:000013E9                 mov     ebp, esp
.text:000013EB                 push    ecx
.text:000013EC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000013F3                 mov     [ebp+var_4], ecx
.text:000013F6                 mov     eax, [ebp+var_4]
.text:000013F9                 mov     esp, ebp
.text:000013FB                 pop     ebp
.text:000013FC                 retn
.text:000013FC ??0IUnknown@@QAE@XZ endp
.text:000013FC
.text:000013FC ; ---------------------------------------------------------------------------
.text:000013FD                 align 10h
.text:000013FD _text           ends
.text:000013FD
.text:00001400 ; ===========================================================================
.text:00001400
.text:00001400 ; Segment type: Pure code
.text:00001400 ; Segment permissions: Read/Execute
.text:00001400 _text           segment para public 'CODE' use32
.text:00001400                 assume cs:_text
.text:00001400                 ;org 1400h
.text:00001400 ; COMDAT (pick any)
.text:00001400                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001400
.text:00001400 ; =============== S U B R O U T I N E =======================================
.text:00001400
.text:00001400 ; Attributes: bp-based frame
.text:00001400
.text:00001400 ; void __thiscall CBufferInStream::Init(CBufferInStream *__hidden this)
.text:00001400                 public ?Init@CBufferInStream@@QAEXXZ
.text:00001400 ?Init@CBufferInStream@@QAEXXZ proc near ; CODE XREF: Create_BufInStream_WithNewBuffer(void const *,uint,ISequentialInStream * *)+B2p
.text:00001400
.text:00001400 var_4           = dword ptr -4
.text:00001400
.text:00001400                 push    ebp
.text:00001401                 mov     ebp, esp
.text:00001403                 push    ecx
.text:00001404                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000140B                 mov     [ebp+var_4], ecx
.text:0000140E                 mov     eax, [ebp+var_4]
.text:00001411                 mov     dword ptr [eax+8], 0
.text:00001418                 mov     dword ptr [eax+0Ch], 0
.text:0000141F                 mov     esp, ebp
.text:00001421                 pop     ebp
.text:00001422                 retn
.text:00001422 ?Init@CBufferInStream@@QAEXXZ endp
.text:00001422
.text:00001422 ; ---------------------------------------------------------------------------
.text:00001423                 align 4
.text:00001423 _text           ends
.text:00001423
.text:00001424 ; ===========================================================================
.text:00001424
.text:00001424 ; Segment type: Pure code
.text:00001424 ; Segment permissions: Read/Execute
.text:00001424 _text           segment para public 'CODE' use32
.text:00001424                 assume cs:_text
.text:00001424                 ;org 1424h
.text:00001424 ; COMDAT (pick any)
.text:00001424                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001424
.text:00001424 ; =============== S U B R O U T I N E =======================================
.text:00001424
.text:00001424 ; Attributes: bp-based frame
.text:00001424
.text:00001424 ; public: __thiscall CBufferInStream::CBufferInStream(void)
.text:00001424                 public ??0CBufferInStream@@QAE@XZ
.text:00001424 ??0CBufferInStream@@QAE@XZ proc near    ; CODE XREF: Create_BufInStream_WithNewBuffer(void const *,uint,ISequentialInStream * *)+65p
.text:00001424
.text:00001424 var_4           = dword ptr -4
.text:00001424
.text:00001424                 push    ebp
.text:00001425                 mov     ebp, esp
.text:00001427                 push    ecx
.text:00001428                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000142F                 mov     [ebp+var_4], ecx
.text:00001432                 mov     ecx, [ebp+var_4] ; this
.text:00001435                 call    ??0IInStream@@QAE@XZ ; IInStream::IInStream(void)
.text:0000143A                 mov     ecx, [ebp+var_4]
.text:0000143D                 add     ecx, 4          ; this
.text:00001440                 call    ??0CMyUnknownImp@@QAE@XZ ; CMyUnknownImp::CMyUnknownImp(void)
.text:00001445                 mov     eax, [ebp+var_4]
.text:00001448                 mov     dword ptr [eax], offset ??_7CBufferInStream@@6B@ ; const CBufferInStream::`vftable'
.text:0000144E                 mov     ecx, [ebp+var_4]
.text:00001451                 add     ecx, 10h
.text:00001454                 call    ??0?$CBuffer@E@@QAE@XZ ; CBuffer<uchar>::CBuffer<uchar>(void)
.text:00001459                 mov     eax, [ebp+var_4]
.text:0000145C                 add     esp, 4
.text:0000145F                 cmp     ebp, esp
.text:00001461                 call    __RTC_CheckEsp
.text:00001466                 mov     esp, ebp
.text:00001468                 pop     ebp
.text:00001469                 retn
.text:00001469 ??0CBufferInStream@@QAE@XZ endp
.text:00001469
.text:00001469 ; ---------------------------------------------------------------------------
.text:0000146A                 align 4
.text:0000146A _text           ends
.text:0000146A
.rdata:0000146C ; ===========================================================================
.rdata:0000146C
.rdata:0000146C ; Segment type: Pure data
.rdata:0000146C ; Segment permissions: Read
.rdata:0000146C _rdata          segment dword public 'DATA' use32
.rdata:0000146C                 assume cs:_rdata
.rdata:0000146C                 ;org 146Ch
.rdata:0000146C ; COMDAT (pick largest)
.rdata:0000146C                 dd offset ??_R4CBufferInStream@@6B@ ; const CBufferInStream::`RTTI Complete Object Locator'
.rdata:00001470                 public ??_7CBufferInStream@@6B@
.rdata:00001470 ; const CBufferInStream::`vftable'
.rdata:00001470 ??_7CBufferInStream@@6B@ dd offset ?QueryInterface@CBufferInStream@@UAGJABU_GUID@@PAPAX@Z
.rdata:00001470                                         ; DATA XREF: CBufferInStream::CBufferInStream(void)+24o
.rdata:00001470                                         ; CBufferInStream::QueryInterface(_GUID const &,void * *)
.rdata:00001474                 dd offset ?AddRef@CBufferInStream@@UAGKXZ ; CBufferInStream::AddRef(void)
.rdata:00001478                 dd offset ?Release@CBufferInStream@@UAGKXZ ; CBufferInStream::Release(void)
.rdata:0000147C                 dd offset ?Read@CBufferInStream@@UAGJPAXIPAI@Z ; CBufferInStream::Read(void *,uint,uint *)
.rdata:00001480                 dd offset ?Seek@CBufferInStream@@UAGJ_JIPA_K@Z ; CBufferInStream::Seek(__int64,uint,unsigned __int64 *)
.rdata:00001480 _rdata          ends
.rdata:00001480
.rdata$r:00001484 ; ===========================================================================
.rdata$r:00001484
.rdata$r:00001484 ; Segment type: Pure data
.rdata$r:00001484 ; Segment permissions: Read
.rdata$r:00001484 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001484                 assume cs:_rdata$r
.rdata$r:00001484                 ;org 1484h
.rdata$r:00001484 ; COMDAT (pick any)
.rdata$r:00001484                 public ??_R4CBufferInStream@@6B@
.rdata$r:00001484 ; const CBufferInStream::`RTTI Complete Object Locator'
.rdata$r:00001484 ??_R4CBufferInStream@@6B@ db    0       ; DATA XREF: .rdata:0000146Co
.rdata$r:00001485                 db    0
.rdata$r:00001486                 db    0
.rdata$r:00001487                 db    0
.rdata$r:00001488                 db    0
.rdata$r:00001489                 db    0
.rdata$r:0000148A                 db    0
.rdata$r:0000148B                 db    0
.rdata$r:0000148C                 db    0
.rdata$r:0000148D                 db    0
.rdata$r:0000148E                 db    0
.rdata$r:0000148F                 db    0
.rdata$r:00001490                 dd offset ??_R0?AVCBufferInStream@@@8 ; CBufferInStream `RTTI Type Descriptor'
.rdata$r:00001494                 dd offset ??_R3CBufferInStream@@8 ; CBufferInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00001494 _rdata$r        ends
.rdata$r:00001494
.data:00001498 ; ===========================================================================
.data:00001498
.data:00001498 ; Segment type: Pure data
.data:00001498 ; Segment permissions: Read/Write
.data:00001498 _data           segment dword public 'DATA' use32
.data:00001498                 assume cs:_data
.data:00001498                 ;org 1498h
.data:00001498 ; COMDAT (pick any)
.data:00001498                 public ??_R0?AVCBufferInStream@@@8
.data:00001498 ; class CBufferInStream `RTTI Type Descriptor'
.data:00001498 ??_R0?AVCBufferInStream@@@8 dd offset ??_7type_info@@6B@
.data:00001498                                         ; DATA XREF: .rdata$r:00001490o
.data:00001498                                         ; .rdata$r:CBufferInStream::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:00001498                                         ; const type_info::`vftable'
.data:0000149C                 align 10h
.data:000014A0 a_?avcbufferins db '.?AVCBufferInStream@@',0
.data:000014B6                 align 4
.data:000014B6 _data           ends
.data:000014B6
.rdata$r:000014B8 ; ===========================================================================
.rdata$r:000014B8
.rdata$r:000014B8 ; Segment type: Pure data
.rdata$r:000014B8 ; Segment permissions: Read
.rdata$r:000014B8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000014B8                 assume cs:_rdata$r
.rdata$r:000014B8                 ;org 14B8h
.rdata$r:000014B8 ; COMDAT (pick any)
.rdata$r:000014B8                 public ??_R3CBufferInStream@@8
.rdata$r:000014B8 ; CBufferInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:000014B8 ??_R3CBufferInStream@@8 db    0         ; DATA XREF: .rdata$r:00001494o
.rdata$r:000014B8                                         ; .rdata$r:000014F8o
.rdata$r:000014B9                 db    0
.rdata$r:000014BA                 db    0
.rdata$r:000014BB                 db    0
.rdata$r:000014BC                 db    1
.rdata$r:000014BD                 db    0
.rdata$r:000014BE                 db    0
.rdata$r:000014BF                 db    0
.rdata$r:000014C0                 db    5
.rdata$r:000014C1                 db    0
.rdata$r:000014C2                 db    0
.rdata$r:000014C3                 db    0
.rdata$r:000014C4                 dd offset ??_R2CBufferInStream@@8 ; CBufferInStream::`RTTI Base Class Array'
.rdata$r:000014C4 _rdata$r        ends
.rdata$r:000014C4
.rdata$r:000014C8 ; ===========================================================================
.rdata$r:000014C8
.rdata$r:000014C8 ; Segment type: Pure data
.rdata$r:000014C8 ; Segment permissions: Read
.rdata$r:000014C8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000014C8                 assume cs:_rdata$r
.rdata$r:000014C8                 ;org 14C8h
.rdata$r:000014C8 ; COMDAT (pick any)
.rdata$r:000014C8                 public ??_R2CBufferInStream@@8
.rdata$r:000014C8 ; CBufferInStream::`RTTI Base Class Array'
.rdata$r:000014C8 ??_R2CBufferInStream@@8 dd offset ??_R1A@?0A@EA@CBufferInStream@@8
.rdata$r:000014C8                                         ; DATA XREF: .rdata$r:000014C4o
.rdata$r:000014C8                                         ; CBufferInStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000014CC                 dd offset ??_R1A@?0A@EA@IInStream@@8 ; IInStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000014D0                 dd offset ??_R1A@?0A@EA@ISequentialInStream@@8 ; ISequentialInStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000014D4                 dd offset ??_R1A@?0A@EA@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000014D8                 dd offset ??_R13?0A@EA@CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Base Class Descriptor at (4,-1,0,64)'
.rdata$r:000014DC                 db    0
.rdata$r:000014DD                 align 10h
.rdata$r:000014DD _rdata$r        ends
.rdata$r:000014DD
.rdata$r:000014E0 ; ===========================================================================
.rdata$r:000014E0
.rdata$r:000014E0 ; Segment type: Pure data
.rdata$r:000014E0 ; Segment permissions: Read
.rdata$r:000014E0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000014E0                 assume cs:_rdata$r
.rdata$r:000014E0                 ;org 14E0h
.rdata$r:000014E0 ; COMDAT (pick any)
.rdata$r:000014E0                 public ??_R1A@?0A@EA@CBufferInStream@@8
.rdata$r:000014E0 ; CBufferInStream::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000014E0 ??_R1A@?0A@EA@CBufferInStream@@8 dd offset ??_R0?AVCBufferInStream@@@8
.rdata$r:000014E0                                         ; DATA XREF: .rdata$r:CBufferInStream::`RTTI Base Class Array'o
.rdata$r:000014E0                                         ; CBufferInStream `RTTI Type Descriptor'
.rdata$r:000014E4                 db    4
.rdata$r:000014E5                 db    0
.rdata$r:000014E6                 db    0
.rdata$r:000014E7                 db    0
.rdata$r:000014E8                 db    0
.rdata$r:000014E9                 db    0
.rdata$r:000014EA                 db    0
.rdata$r:000014EB                 db    0
.rdata$r:000014EC                 db 0FFh
.rdata$r:000014ED                 db 0FFh
.rdata$r:000014EE                 db 0FFh
.rdata$r:000014EF                 db 0FFh
.rdata$r:000014F0                 db    0
.rdata$r:000014F1                 db    0
.rdata$r:000014F2                 db    0
.rdata$r:000014F3                 db    0
.rdata$r:000014F4                 db  40h ; @
.rdata$r:000014F5                 db    0
.rdata$r:000014F6                 db    0
.rdata$r:000014F7                 db    0
.rdata$r:000014F8                 dd offset ??_R3CBufferInStream@@8 ; CBufferInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:000014F8 _rdata$r        ends
.rdata$r:000014F8
.text:000014FC ; ===========================================================================
.text:000014FC
.text:000014FC ; Segment type: Pure code
.text:000014FC ; Segment permissions: Read/Execute
.text:000014FC _text           segment para public 'CODE' use32
.text:000014FC                 assume cs:_text
.text:000014FC                 ;org 14FCh
.text:000014FC ; COMDAT (pick any)
.text:000014FC                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000014FC
.text:000014FC ; =============== S U B R O U T I N E =======================================
.text:000014FC
.text:000014FC ; Attributes: bp-based frame
.text:000014FC
.text:000014FC ; __int32 __stdcall CBufferInStream::QueryInterface(CBufferInStream *this, const struct _GUID *Buf1, void **)
.text:000014FC                 public ?QueryInterface@CBufferInStream@@UAGJABU_GUID@@PAPAX@Z
.text:000014FC ?QueryInterface@CBufferInStream@@UAGJABU_GUID@@PAPAX@Z proc near
.text:000014FC                                         ; DATA XREF: .rdata:const CBufferInStream::`vftable'o
.text:000014FC
.text:000014FC this            = dword ptr  8
.text:000014FC Buf1            = dword ptr  0Ch
.text:000014FC arg_8           = dword ptr  10h
.text:000014FC
.text:000014FC                 push    ebp
.text:000014FD                 mov     ebp, esp
.text:000014FF                 mov     eax, [ebp+arg_8]
.text:00001502                 mov     dword ptr [eax], 0
.text:00001508                 push    offset _IID_IUnknown ; Buf2
.text:0000150D                 mov     ecx, [ebp+Buf1]
.text:00001510                 push    ecx             ; Buf1
.text:00001511                 call    ___@8           ; __(x,x)
.text:00001516                 test    eax, eax
.text:00001518                 jz      short loc_1524
.text:0000151A                 mov     edx, [ebp+arg_8]
.text:0000151D                 mov     eax, [ebp+this]
.text:00001520                 mov     [edx], eax
.text:00001522                 jmp     short loc_1563
.text:00001524 ; ---------------------------------------------------------------------------
.text:00001524
.text:00001524 loc_1524:                               ; CODE XREF: CBufferInStream::QueryInterface(_GUID const &,void * *)+1Cj
.text:00001524                 push    offset _IID_ISequentialInStream ; Buf2
.text:00001529                 mov     ecx, [ebp+Buf1]
.text:0000152C                 push    ecx             ; Buf1
.text:0000152D                 call    ___@8           ; __(x,x)
.text:00001532                 test    eax, eax
.text:00001534                 jz      short loc_1540
.text:00001536                 mov     edx, [ebp+arg_8]
.text:00001539                 mov     eax, [ebp+this]
.text:0000153C                 mov     [edx], eax
.text:0000153E                 jmp     short loc_1563
.text:00001540 ; ---------------------------------------------------------------------------
.text:00001540
.text:00001540 loc_1540:                               ; CODE XREF: CBufferInStream::QueryInterface(_GUID const &,void * *)+38j
.text:00001540                 push    offset _IID_IInStream ; Buf2
.text:00001545                 mov     ecx, [ebp+Buf1]
.text:00001548                 push    ecx             ; Buf1
.text:00001549                 call    ___@8           ; __(x,x)
.text:0000154E                 test    eax, eax
.text:00001550                 jz      short loc_155C
.text:00001552                 mov     edx, [ebp+arg_8]
.text:00001555                 mov     eax, [ebp+this]
.text:00001558                 mov     [edx], eax
.text:0000155A                 jmp     short loc_1563
.text:0000155C ; ---------------------------------------------------------------------------
.text:0000155C
.text:0000155C loc_155C:                               ; CODE XREF: CBufferInStream::QueryInterface(_GUID const &,void * *)+54j
.text:0000155C                 mov     eax, 80004002h
.text:00001561                 jmp     short loc_1574
.text:00001563 ; ---------------------------------------------------------------------------
.text:00001563
.text:00001563 loc_1563:                               ; CODE XREF: CBufferInStream::QueryInterface(_GUID const &,void * *)+26j
.text:00001563                                         ; CBufferInStream::QueryInterface(_GUID const &,void * *)+42j ...
.text:00001563                 mov     ecx, [ebp+this]
.text:00001566                 mov     edx, [ecx+4]
.text:00001569                 add     edx, 1
.text:0000156C                 mov     eax, [ebp+this]
.text:0000156F                 mov     [eax+4], edx
.text:00001572                 xor     eax, eax
.text:00001574
.text:00001574 loc_1574:                               ; CODE XREF: CBufferInStream::QueryInterface(_GUID const &,void * *)+65j
.text:00001574                 cmp     ebp, esp
.text:00001576                 call    __RTC_CheckEsp
.text:0000157B                 pop     ebp
.text:0000157C                 retn    0Ch
.text:0000157C ?QueryInterface@CBufferInStream@@UAGJABU_GUID@@PAPAX@Z endp
.text:0000157C
.text:0000157C ; ---------------------------------------------------------------------------
.text:0000157F                 align 10h
.text:0000157F _text           ends
.text:0000157F
.text:00001580 ; ===========================================================================
.text:00001580
.text:00001580 ; Segment type: Pure code
.text:00001580 ; Segment permissions: Read/Execute
.text:00001580 _text           segment para public 'CODE' use32
.text:00001580                 assume cs:_text
.text:00001580                 ;org 1580h
.text:00001580 ; COMDAT (pick any)
.text:00001580                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001580
.text:00001580 ; =============== S U B R O U T I N E =======================================
.text:00001580
.text:00001580 ; Attributes: bp-based frame
.text:00001580
.text:00001580 ; unsigned __int32 __stdcall CBufferInStream::AddRef(CBufferInStream *this)
.text:00001580                 public ?AddRef@CBufferInStream@@UAGKXZ
.text:00001580 ?AddRef@CBufferInStream@@UAGKXZ proc near ; DATA XREF: .rdata:00001474o
.text:00001580
.text:00001580 var_4           = dword ptr -4
.text:00001580 this            = dword ptr  8
.text:00001580
.text:00001580                 push    ebp
.text:00001581                 mov     ebp, esp
.text:00001583                 push    ecx
.text:00001584                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000158B                 mov     eax, [ebp+this]
.text:0000158E                 mov     ecx, [eax+4]
.text:00001591                 add     ecx, 1
.text:00001594                 mov     [ebp+var_4], ecx
.text:00001597                 mov     edx, [ebp+this]
.text:0000159A                 mov     eax, [ebp+var_4]
.text:0000159D                 mov     [edx+4], eax
.text:000015A0                 mov     eax, [ebp+var_4]
.text:000015A3                 mov     esp, ebp
.text:000015A5                 pop     ebp
.text:000015A6                 retn    4
.text:000015A6 ?AddRef@CBufferInStream@@UAGKXZ endp
.text:000015A6
.text:000015A6 ; ---------------------------------------------------------------------------
.text:000015A9                 align 4
.text:000015A9 _text           ends
.text:000015A9
.text:000015AC ; ===========================================================================
.text:000015AC
.text:000015AC ; Segment type: Pure code
.text:000015AC ; Segment permissions: Read/Execute
.text:000015AC _text           segment para public 'CODE' use32
.text:000015AC                 assume cs:_text
.text:000015AC                 ;org 15ACh
.text:000015AC ; COMDAT (pick any)
.text:000015AC                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000015AC
.text:000015AC ; =============== S U B R O U T I N E =======================================
.text:000015AC
.text:000015AC ; Attributes: bp-based frame
.text:000015AC
.text:000015AC ; unsigned __int32 __stdcall CBufferInStream::Release(CBufferInStream *this)
.text:000015AC                 public ?Release@CBufferInStream@@UAGKXZ
.text:000015AC ?Release@CBufferInStream@@UAGKXZ proc near ; DATA XREF: .rdata:00001478o
.text:000015AC
.text:000015AC var_10          = dword ptr -10h
.text:000015AC var_C           = dword ptr -0Ch
.text:000015AC var_8           = dword ptr -8
.text:000015AC var_4           = dword ptr -4
.text:000015AC this            = dword ptr  8
.text:000015AC
.text:000015AC                 push    ebp
.text:000015AD                 mov     ebp, esp
.text:000015AF                 sub     esp, 10h
.text:000015B2                 mov     eax, 0CCCCCCCCh
.text:000015B7                 mov     [ebp+var_10], eax
.text:000015BA                 mov     [ebp+var_C], eax
.text:000015BD                 mov     [ebp+var_8], eax
.text:000015C0                 mov     [ebp+var_4], eax
.text:000015C3                 mov     eax, [ebp+this]
.text:000015C6                 mov     ecx, [eax+4]
.text:000015C9                 sub     ecx, 1
.text:000015CC                 mov     [ebp+var_C], ecx
.text:000015CF                 mov     edx, [ebp+this]
.text:000015D2                 mov     eax, [ebp+var_C]
.text:000015D5                 mov     [edx+4], eax
.text:000015D8                 cmp     [ebp+var_C], 0
.text:000015DC                 jz      short loc_15E6
.text:000015DE                 mov     ecx, [ebp+this]
.text:000015E1                 mov     eax, [ecx+4]
.text:000015E4                 jmp     short loc_1610
.text:000015E6 ; ---------------------------------------------------------------------------
.text:000015E6
.text:000015E6 loc_15E6:                               ; CODE XREF: CBufferInStream::Release(void)+30j
.text:000015E6                 mov     edx, [ebp+this]
.text:000015E9                 mov     [ebp+var_8], edx
.text:000015EC                 mov     eax, [ebp+var_8]
.text:000015EF                 mov     [ebp+var_4], eax
.text:000015F2                 cmp     [ebp+var_4], 0
.text:000015F6                 jz      short loc_1607
.text:000015F8                 push    1
.text:000015FA                 mov     ecx, [ebp+var_4]
.text:000015FD                 call    ??_GCBufferInStream@@QAEPAXI@Z ; CBufferInStream::`scalar deleting destructor'(uint)
.text:00001602                 mov     [ebp+var_10], eax
.text:00001605                 jmp     short loc_160E
.text:00001607 ; ---------------------------------------------------------------------------
.text:00001607
.text:00001607 loc_1607:                               ; CODE XREF: CBufferInStream::Release(void)+4Aj
.text:00001607                 mov     [ebp+var_10], 0
.text:0000160E
.text:0000160E loc_160E:                               ; CODE XREF: CBufferInStream::Release(void)+59j
.text:0000160E                 xor     eax, eax
.text:00001610
.text:00001610 loc_1610:                               ; CODE XREF: CBufferInStream::Release(void)+38j
.text:00001610                 add     esp, 10h
.text:00001613                 cmp     ebp, esp
.text:00001615                 call    __RTC_CheckEsp
.text:0000161A                 mov     esp, ebp
.text:0000161C                 pop     ebp
.text:0000161D                 retn    4
.text:0000161D ?Release@CBufferInStream@@UAGKXZ endp
.text:0000161D
.text:0000161D _text           ends
.text:0000161D
.text:00001620 ; ===========================================================================
.text:00001620
.text:00001620 ; Segment type: Pure code
.text:00001620 ; Segment permissions: Read/Execute
.text:00001620 _text           segment para public 'CODE' use32
.text:00001620                 assume cs:_text
.text:00001620                 ;org 1620h
.text:00001620 ; COMDAT (pick any)
.text:00001620                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001620
.text:00001620 ; =============== S U B R O U T I N E =======================================
.text:00001620
.text:00001620 ; Attributes: bp-based frame
.text:00001620
.text:00001620 ; public: void * __thiscall CBufferInStream::`scalar deleting destructor'(unsigned int)
.text:00001620                 public ??_GCBufferInStream@@QAEPAXI@Z
.text:00001620 ??_GCBufferInStream@@QAEPAXI@Z proc near
.text:00001620                                         ; CODE XREF: CBufferInStream::Release(void)+51p
.text:00001620
.text:00001620 var_4           = dword ptr -4
.text:00001620 arg_0           = dword ptr  8
.text:00001620
.text:00001620                 push    ebp
.text:00001621                 mov     ebp, esp
.text:00001623                 push    ecx
.text:00001624                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000162B                 mov     [ebp+var_4], ecx
.text:0000162E                 mov     ecx, [ebp+var_4] ; this
.text:00001631                 call    ??1CBufferInStream@@QAE@XZ ; CBufferInStream::~CBufferInStream(void)
.text:00001636                 mov     eax, [ebp+arg_0]
.text:00001639                 and     eax, 1
.text:0000163C                 jz      short loc_164A
.text:0000163E                 mov     ecx, [ebp+var_4]
.text:00001641                 push    ecx             ; void *
.text:00001642                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00001647                 add     esp, 4
.text:0000164A
.text:0000164A loc_164A:                               ; CODE XREF: CBufferInStream::`scalar deleting destructor'(uint)+1Cj
.text:0000164A                 mov     eax, [ebp+var_4]
.text:0000164D                 add     esp, 4
.text:00001650                 cmp     ebp, esp
.text:00001652                 call    __RTC_CheckEsp
.text:00001657                 mov     esp, ebp
.text:00001659                 pop     ebp
.text:0000165A                 retn    4
.text:0000165A ??_GCBufferInStream@@QAEPAXI@Z endp
.text:0000165A
.text:0000165A ; ---------------------------------------------------------------------------
.text:0000165D                 align 10h
.text:0000165D _text           ends
.text:0000165D
.text:00001660 ; ===========================================================================
.text:00001660
.text:00001660 ; Segment type: Pure code
.text:00001660 ; Segment permissions: Read/Execute
.text:00001660 _text           segment para public 'CODE' use32
.text:00001660                 assume cs:_text
.text:00001660                 ;org 1660h
.text:00001660 ; COMDAT (pick any)
.text:00001660                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001660
.text:00001660 ; =============== S U B R O U T I N E =======================================
.text:00001660
.text:00001660 ; Attributes: bp-based frame
.text:00001660
.text:00001660 ; _DWORD __thiscall CBufferInStream::~CBufferInStream(CBufferInStream *__hidden this)
.text:00001660                 public ??1CBufferInStream@@QAE@XZ
.text:00001660 ??1CBufferInStream@@QAE@XZ proc near    ; CODE XREF: CBufferInStream::`scalar deleting destructor'(uint)+11p
.text:00001660
.text:00001660 var_4           = dword ptr -4
.text:00001660
.text:00001660                 push    ebp
.text:00001661                 mov     ebp, esp
.text:00001663                 push    ecx
.text:00001664                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000166B                 mov     [ebp+var_4], ecx
.text:0000166E                 mov     ecx, [ebp+var_4]
.text:00001671                 add     ecx, 10h
.text:00001674                 call    ??1?$CBuffer@E@@QAE@XZ ; CBuffer<uchar>::~CBuffer<uchar>(void)
.text:00001679                 add     esp, 4
.text:0000167C                 cmp     ebp, esp
.text:0000167E                 call    __RTC_CheckEsp
.text:00001683                 mov     esp, ebp
.text:00001685                 pop     ebp
.text:00001686                 retn
.text:00001686 ??1CBufferInStream@@QAE@XZ endp
.text:00001686
.text:00001686 ; ---------------------------------------------------------------------------
.text:00001687                 align 4
.text:00001687 _text           ends
.text:00001687
.text:00001688 ; ===========================================================================
.text:00001688
.text:00001688 ; Segment type: Pure code
.text:00001688 ; Segment permissions: Read/Execute
.text:00001688 _text           segment para public 'CODE' use32
.text:00001688                 assume cs:_text
.text:00001688                 ;org 1688h
.text:00001688 ; COMDAT (pick any)
.text:00001688                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001688
.text:00001688 ; =============== S U B R O U T I N E =======================================
.text:00001688
.text:00001688 ; Attributes: bp-based frame
.text:00001688
.text:00001688 ; public: __thiscall CByteDynBuffer::operator unsigned char *(void)const
.text:00001688                 public ??BCByteDynBuffer@@QBEPAEXZ
.text:00001688 ??BCByteDynBuffer@@QBEPAEXZ proc near   ; CODE XREF: CDynBufSeqOutStream::GetBufPtrForWriting(uint)+49p
.text:00001688
.text:00001688 var_4           = dword ptr -4
.text:00001688
.text:00001688                 push    ebp
.text:00001689                 mov     ebp, esp
.text:0000168B                 push    ecx
.text:0000168C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001693                 mov     [ebp+var_4], ecx
.text:00001696                 mov     eax, [ebp+var_4]
.text:00001699                 mov     eax, [eax+4]
.text:0000169C                 mov     esp, ebp
.text:0000169E                 pop     ebp
.text:0000169F                 retn
.text:0000169F ??BCByteDynBuffer@@QBEPAEXZ endp
.text:0000169F
.text:0000169F _text           ends
.text:0000169F
.text:000016A0 ; ===========================================================================
.text:000016A0
.text:000016A0 ; Segment type: Pure code
.text:000016A0 ; Segment permissions: Read/Execute
.text:000016A0 _text           segment para public 'CODE' use32
.text:000016A0                 assume cs:_text
.text:000016A0                 ;org 16A0h
.text:000016A0 ; COMDAT (pick any)
.text:000016A0                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000016A0
.text:000016A0 ; =============== S U B R O U T I N E =======================================
.text:000016A0
.text:000016A0 ; Attributes: bp-based frame
.text:000016A0
.text:000016A0 ; public: __thiscall CByteDynBuffer::operator unsigned char const *(void)const
.text:000016A0                 public ??BCByteDynBuffer@@QBEPBEXZ
.text:000016A0 ??BCByteDynBuffer@@QBEPBEXZ proc near   ; CODE XREF: CDynBufSeqOutStream::CopyToBuffer(CBuffer<uchar> &)+1Bp
.text:000016A0
.text:000016A0 var_4           = dword ptr -4
.text:000016A0
.text:000016A0                 push    ebp
.text:000016A1                 mov     ebp, esp
.text:000016A3                 push    ecx
.text:000016A4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000016AB                 mov     [ebp+var_4], ecx
.text:000016AE                 mov     eax, [ebp+var_4]
.text:000016B1                 mov     eax, [eax+4]
.text:000016B4                 mov     esp, ebp
.text:000016B6                 pop     ebp
.text:000016B7                 retn
.text:000016B7 ??BCByteDynBuffer@@QBEPBEXZ endp
.text:000016B7
.text:000016B7 _text           ends
.text:000016B7
.text:000016B8 ; ===========================================================================
.text:000016B8
.text:000016B8 ; Segment type: Pure code
.text:000016B8 ; Segment permissions: Read/Execute
.text:000016B8 _text           segment para public 'CODE' use32
.text:000016B8                 assume cs:_text
.text:000016B8                 ;org 16B8h
.text:000016B8 ; COMDAT (pick any)
.text:000016B8                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000016B8
.text:000016B8 ; =============== S U B R O U T I N E =======================================
.text:000016B8
.text:000016B8 ; Attributes: bp-based frame
.text:000016B8
.text:000016B8 ; void __thiscall CDynBufSeqOutStream::UpdateSize(CDynBufSeqOutStream *this, unsigned int)
.text:000016B8                 public ?UpdateSize@CDynBufSeqOutStream@@QAEXI@Z
.text:000016B8 ?UpdateSize@CDynBufSeqOutStream@@QAEXI@Z proc near
.text:000016B8                                         ; CODE XREF: CDynBufSeqOutStream::Write(void const *,uint,uint *)+5Bp
.text:000016B8
.text:000016B8 var_4           = dword ptr -4
.text:000016B8 arg_0           = dword ptr  8
.text:000016B8
.text:000016B8                 push    ebp
.text:000016B9                 mov     ebp, esp
.text:000016BB                 push    ecx
.text:000016BC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000016C3                 mov     [ebp+var_4], ecx
.text:000016C6                 mov     eax, [ebp+var_4]
.text:000016C9                 mov     ecx, [eax+10h]
.text:000016CC                 add     ecx, [ebp+arg_0]
.text:000016CF                 mov     edx, [ebp+var_4]
.text:000016D2                 mov     [edx+10h], ecx
.text:000016D5                 mov     esp, ebp
.text:000016D7                 pop     ebp
.text:000016D8                 retn    4
.text:000016D8 ?UpdateSize@CDynBufSeqOutStream@@QAEXI@Z endp
.text:000016D8
.text:000016D8 ; ---------------------------------------------------------------------------
.text:000016DB                 align 4
.text:000016DB _text           ends
.text:000016DB
.text:000016DC ; ===========================================================================
.text:000016DC
.text:000016DC ; Segment type: Pure code
.text:000016DC ; Segment permissions: Read/Execute
.text:000016DC _text           segment para public 'CODE' use32
.text:000016DC                 assume cs:_text
.text:000016DC                 ;org 16DCh
.text:000016DC ; COMDAT (pick any)
.text:000016DC                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000016DC
.text:000016DC ; =============== S U B R O U T I N E =======================================
.text:000016DC
.text:000016DC ; Attributes: bp-based frame
.text:000016DC
.text:000016DC ; public: __thiscall CBuffer<unsigned char>::CBuffer<unsigned char>(void)
.text:000016DC                 public ??0?$CBuffer@E@@QAE@XZ
.text:000016DC ??0?$CBuffer@E@@QAE@XZ proc near        ; CODE XREF: CBufferInStream::CBufferInStream(void)+30p
.text:000016DC
.text:000016DC var_4           = dword ptr -4
.text:000016DC
.text:000016DC                 push    ebp
.text:000016DD                 mov     ebp, esp
.text:000016DF                 push    ecx
.text:000016E0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000016E7                 mov     [ebp+var_4], ecx
.text:000016EA                 mov     eax, [ebp+var_4]
.text:000016ED                 mov     dword ptr [eax], 0
.text:000016F3                 mov     ecx, [ebp+var_4]
.text:000016F6                 mov     dword ptr [ecx+4], 0
.text:000016FD                 mov     eax, [ebp+var_4]
.text:00001700                 mov     esp, ebp
.text:00001702                 pop     ebp
.text:00001703                 retn
.text:00001703 ??0?$CBuffer@E@@QAE@XZ endp
.text:00001703
.text:00001703 _text           ends
.text:00001703
.text:00001704 ; ===========================================================================
.text:00001704
.text:00001704 ; Segment type: Pure code
.text:00001704 ; Segment permissions: Read/Execute
.text:00001704 _text           segment para public 'CODE' use32
.text:00001704                 assume cs:_text
.text:00001704                 ;org 1704h
.text:00001704 ; COMDAT (pick any)
.text:00001704                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001704
.text:00001704 ; =============== S U B R O U T I N E =======================================
.text:00001704
.text:00001704 ; Attributes: bp-based frame
.text:00001704
.text:00001704 ; public: __thiscall CBuffer<unsigned char>::~CBuffer<unsigned char>(void)
.text:00001704                 public ??1?$CBuffer@E@@QAE@XZ
.text:00001704 ??1?$CBuffer@E@@QAE@XZ proc near        ; CODE XREF: CBufferInStream::~CBufferInStream(void)+14p
.text:00001704
.text:00001704 var_8           = dword ptr -8
.text:00001704 var_4           = dword ptr -4
.text:00001704
.text:00001704                 push    ebp
.text:00001705                 mov     ebp, esp
.text:00001707                 sub     esp, 8
.text:0000170A                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00001711                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001718                 mov     [ebp+var_4], ecx
.text:0000171B                 mov     eax, [ebp+var_4]
.text:0000171E                 mov     ecx, [eax]
.text:00001720                 mov     [ebp+var_8], ecx
.text:00001723                 mov     edx, [ebp+var_8]
.text:00001726                 push    edx             ; void *
.text:00001727                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000172C                 add     esp, 4
.text:0000172F                 add     esp, 8
.text:00001732                 cmp     ebp, esp
.text:00001734                 call    __RTC_CheckEsp
.text:00001739                 mov     esp, ebp
.text:0000173B                 pop     ebp
.text:0000173C                 retn
.text:0000173C ??1?$CBuffer@E@@QAE@XZ endp
.text:0000173C
.text:0000173C ; ---------------------------------------------------------------------------
.text:0000173D                 align 10h
.text:0000173D _text           ends
.text:0000173D
.text:00001740 ; ===========================================================================
.text:00001740
.text:00001740 ; Segment type: Pure code
.text:00001740 ; Segment permissions: Read/Execute
.text:00001740 _text           segment para public 'CODE' use32
.text:00001740                 assume cs:_text
.text:00001740                 ;org 1740h
.text:00001740 ; COMDAT (pick any)
.text:00001740                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001740
.text:00001740 ; =============== S U B R O U T I N E =======================================
.text:00001740
.text:00001740 ; Attributes: bp-based frame
.text:00001740
.text:00001740 ; public: __thiscall CBuffer<unsigned char>::operator unsigned char *(void)
.text:00001740                 public ??B?$CBuffer@E@@QAEPAEXZ
.text:00001740 ??B?$CBuffer@E@@QAEPAEXZ proc near      ; CODE XREF: CBufferInStream::Read(void *,uint,uint *)+96p
.text:00001740
.text:00001740 var_4           = dword ptr -4
.text:00001740
.text:00001740                 push    ebp
.text:00001741                 mov     ebp, esp
.text:00001743                 push    ecx
.text:00001744                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000174B                 mov     [ebp+var_4], ecx
.text:0000174E                 mov     eax, [ebp+var_4]
.text:00001751                 mov     eax, [eax]
.text:00001753                 mov     esp, ebp
.text:00001755                 pop     ebp
.text:00001756                 retn
.text:00001756 ??B?$CBuffer@E@@QAEPAEXZ endp
.text:00001756
.text:00001756 ; ---------------------------------------------------------------------------
.text:00001757                 align 4
.text:00001757 _text           ends
.text:00001757
.text:00001758 ; ===========================================================================
.text:00001758
.text:00001758 ; Segment type: Pure code
.text:00001758 ; Segment permissions: Read/Execute
.text:00001758 _text           segment para public 'CODE' use32
.text:00001758                 assume cs:_text
.text:00001758                 ;org 1758h
.text:00001758 ; COMDAT (pick any)
.text:00001758                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001758
.text:00001758 ; =============== S U B R O U T I N E =======================================
.text:00001758
.text:00001758 ; Attributes: bp-based frame
.text:00001758
.text:00001758 ; public: unsigned int __thiscall CBuffer<unsigned char>::Size(void)const
.text:00001758                 public ?Size@?$CBuffer@E@@QBEIXZ
.text:00001758 ?Size@?$CBuffer@E@@QBEIXZ proc near     ; CODE XREF: CBufferInStream::Read(void *,uint,uint *)+39p
.text:00001758                                         ; CBufferInStream::Read(void *,uint,uint *)+6Ep ...
.text:00001758
.text:00001758 var_4           = dword ptr -4
.text:00001758
.text:00001758                 push    ebp
.text:00001759                 mov     ebp, esp
.text:0000175B                 push    ecx
.text:0000175C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001763                 mov     [ebp+var_4], ecx
.text:00001766                 mov     eax, [ebp+var_4]
.text:00001769                 mov     eax, [eax+4]
.text:0000176C                 mov     esp, ebp
.text:0000176E                 pop     ebp
.text:0000176F                 retn
.text:0000176F ?Size@?$CBuffer@E@@QBEIXZ endp
.text:0000176F
.text:0000176F _text           ends
.text:0000176F
.text:00001770 ; ===========================================================================
.text:00001770
.text:00001770 ; Segment type: Pure code
.text:00001770 ; Segment permissions: Read/Execute
.text:00001770 _text           segment para public 'CODE' use32
.text:00001770                 assume cs:_text
.text:00001770                 ;org 1770h
.text:00001770 ; COMDAT (pick any)
.text:00001770                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001770
.text:00001770 ; =============== S U B R O U T I N E =======================================
.text:00001770
.text:00001770 ; Attributes: bp-based frame
.text:00001770
.text:00001770 ; int __stdcall CBuffer<unsigned char>::CopyFrom(void *Src, size_t Size)
.text:00001770                 public ?CopyFrom@?$CBuffer@E@@QAEXPBEI@Z
.text:00001770 ?CopyFrom@?$CBuffer@E@@QAEXPBEI@Z proc near
.text:00001770                                         ; CODE XREF: Create_BufInStream_WithNewBuffer(void const *,uint,ISequentialInStream * *)+AAp
.text:00001770                                         ; CDynBufSeqOutStream::CopyToBuffer(CBuffer<uchar> &)+24p
.text:00001770
.text:00001770 var_4           = dword ptr -4
.text:00001770 Src             = dword ptr  8
.text:00001770 Size            = dword ptr  0Ch
.text:00001770
.text:00001770                 push    ebp
.text:00001771                 mov     ebp, esp
.text:00001773                 push    ecx
.text:00001774                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000177B                 mov     [ebp+var_4], ecx
.text:0000177E                 mov     eax, [ebp+Size]
.text:00001781                 push    eax
.text:00001782                 mov     ecx, [ebp+var_4]
.text:00001785                 call    ?Alloc@?$CBuffer@E@@QAEXI@Z ; CBuffer<uchar>::Alloc(uint)
.text:0000178A                 cmp     [ebp+Size], 0
.text:0000178E                 jz      short loc_17A6
.text:00001790                 mov     ecx, [ebp+Size]
.text:00001793                 push    ecx             ; Size
.text:00001794                 mov     edx, [ebp+Src]
.text:00001797                 push    edx             ; Src
.text:00001798                 mov     eax, [ebp+var_4]
.text:0000179B                 mov     ecx, [eax]
.text:0000179D                 push    ecx             ; Dst
.text:0000179E                 call    _memcpy
.text:000017A3                 add     esp, 0Ch
.text:000017A6
.text:000017A6 loc_17A6:                               ; CODE XREF: CBuffer<uchar>::CopyFrom(uchar const *,uint)+1Ej
.text:000017A6                 add     esp, 4
.text:000017A9                 cmp     ebp, esp
.text:000017AB                 call    __RTC_CheckEsp
.text:000017B0                 mov     esp, ebp
.text:000017B2                 pop     ebp
.text:000017B3                 retn    8
.text:000017B3 ?CopyFrom@?$CBuffer@E@@QAEXPBEI@Z endp
.text:000017B3
.text:000017B3 ; ---------------------------------------------------------------------------
.text:000017B6                 align 4
.text:000017B6 _text           ends
.text:000017B6
.text:000017B8 ; ===========================================================================
.text:000017B8
.text:000017B8 ; Segment type: Pure code
.text:000017B8 ; Segment permissions: Read/Execute
.text:000017B8 _text           segment para public 'CODE' use32
.text:000017B8                 assume cs:_text
.text:000017B8                 ;org 17B8h
.text:000017B8 ; COMDAT (pick any)
.text:000017B8                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000017B8
.text:000017B8 ; =============== S U B R O U T I N E =======================================
.text:000017B8
.text:000017B8 ; Attributes: bp-based frame
.text:000017B8
.text:000017B8 ; public: __thiscall CMyComPtr<struct IUnknown>::CMyComPtr<struct IUnknown>(void)
.text:000017B8                 public ??0?$CMyComPtr@UIUnknown@@@@QAE@XZ
.text:000017B8 ??0?$CMyComPtr@UIUnknown@@@@QAE@XZ proc near
.text:000017B8                                         ; CODE XREF: CBufInStream::CBufInStream(void)+30p
.text:000017B8
.text:000017B8 var_4           = dword ptr -4
.text:000017B8
.text:000017B8                 push    ebp
.text:000017B9                 mov     ebp, esp
.text:000017BB                 push    ecx
.text:000017BC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000017C3                 mov     [ebp+var_4], ecx
.text:000017C6                 mov     eax, [ebp+var_4]
.text:000017C9                 mov     dword ptr [eax], 0
.text:000017CF                 mov     eax, [ebp+var_4]
.text:000017D2                 mov     esp, ebp
.text:000017D4                 pop     ebp
.text:000017D5                 retn
.text:000017D5 ??0?$CMyComPtr@UIUnknown@@@@QAE@XZ endp
.text:000017D5
.text:000017D5 ; ---------------------------------------------------------------------------
.text:000017D6                 align 4
.text:000017D6 _text           ends
.text:000017D6
.text:000017D8 ; ===========================================================================
.text:000017D8
.text:000017D8 ; Segment type: Pure code
.text:000017D8 ; Segment permissions: Read/Execute
.text:000017D8 _text           segment para public 'CODE' use32
.text:000017D8                 assume cs:_text
.text:000017D8                 ;org 17D8h
.text:000017D8 ; COMDAT (pick any)
.text:000017D8                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000017D8
.text:000017D8 ; =============== S U B R O U T I N E =======================================
.text:000017D8
.text:000017D8 ; Attributes: bp-based frame
.text:000017D8
.text:000017D8 ; public: __thiscall CMyComPtr<struct IUnknown>::~CMyComPtr<struct IUnknown>(void)
.text:000017D8                 public ??1?$CMyComPtr@UIUnknown@@@@QAE@XZ
.text:000017D8 ??1?$CMyComPtr@UIUnknown@@@@QAE@XZ proc near
.text:000017D8                                         ; CODE XREF: CBufInStream::~CBufInStream(void)+14p
.text:000017D8
.text:000017D8 var_4           = dword ptr -4
.text:000017D8
.text:000017D8                 push    ebp
.text:000017D9                 mov     ebp, esp
.text:000017DB                 push    ecx
.text:000017DC                 push    esi
.text:000017DD                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000017E4                 mov     [ebp+var_4], ecx
.text:000017E7                 mov     eax, [ebp+var_4]
.text:000017EA                 cmp     dword ptr [eax], 0
.text:000017ED                 jz      short loc_180A
.text:000017EF                 mov     ecx, [ebp+var_4]
.text:000017F2                 mov     edx, [ecx]
.text:000017F4                 mov     eax, [ebp+var_4]
.text:000017F7                 mov     ecx, [eax]
.text:000017F9                 mov     edx, [edx]
.text:000017FB                 mov     esi, esp
.text:000017FD                 push    ecx
.text:000017FE                 mov     eax, [edx+8]
.text:00001801                 call    eax
.text:00001803                 cmp     esi, esp
.text:00001805                 call    __RTC_CheckEsp
.text:0000180A
.text:0000180A loc_180A:                               ; CODE XREF: CMyComPtr<IUnknown>::~CMyComPtr<IUnknown>(void)+15j
.text:0000180A                 pop     esi
.text:0000180B                 add     esp, 4
.text:0000180E                 cmp     ebp, esp
.text:00001810                 call    __RTC_CheckEsp
.text:00001815                 mov     esp, ebp
.text:00001817                 pop     ebp
.text:00001818                 retn
.text:00001818 ??1?$CMyComPtr@UIUnknown@@@@QAE@XZ endp
.text:00001818
.text:00001818 ; ---------------------------------------------------------------------------
.text:00001819                 align 4
.text:00001819 _text           ends
.text:00001819
.text:0000181C ; ===========================================================================
.text:0000181C
.text:0000181C ; Segment type: Pure code
.text:0000181C ; Segment permissions: Read/Execute
.text:0000181C _text           segment para public 'CODE' use32
.text:0000181C                 assume cs:_text
.text:0000181C                 ;org 181Ch
.text:0000181C ; COMDAT (pick any)
.text:0000181C                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:0000181C
.text:0000181C ; =============== S U B R O U T I N E =======================================
.text:0000181C
.text:0000181C ; Attributes: bp-based frame
.text:0000181C
.text:0000181C ; public: struct IUnknown * __thiscall CMyComPtr<struct IUnknown>::operator=(struct IUnknown *)
.text:0000181C                 public ??4?$CMyComPtr@UIUnknown@@@@QAEPAUIUnknown@@PAU1@@Z
.text:0000181C ??4?$CMyComPtr@UIUnknown@@@@QAEPAUIUnknown@@PAU1@@Z proc near
.text:0000181C                                         ; CODE XREF: CBufInStream::Init(uchar const *,uint,IUnknown *)+3Bp
.text:0000181C
.text:0000181C var_4           = dword ptr -4
.text:0000181C arg_0           = dword ptr  8
.text:0000181C
.text:0000181C                 push    ebp
.text:0000181D                 mov     ebp, esp
.text:0000181F                 push    ecx
.text:00001820                 push    esi
.text:00001821                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001828                 mov     [ebp+var_4], ecx
.text:0000182B                 cmp     [ebp+arg_0], 0
.text:0000182F                 jz      short loc_1848
.text:00001831                 mov     eax, [ebp+arg_0]
.text:00001834                 mov     ecx, [eax]
.text:00001836                 mov     esi, esp
.text:00001838                 mov     edx, [ebp+arg_0]
.text:0000183B                 push    edx
.text:0000183C                 mov     eax, [ecx+4]
.text:0000183F                 call    eax
.text:00001841                 cmp     esi, esp
.text:00001843                 call    __RTC_CheckEsp
.text:00001848
.text:00001848 loc_1848:                               ; CODE XREF: CMyComPtr<IUnknown>::operator=(IUnknown *)+13j
.text:00001848                 mov     ecx, [ebp+var_4]
.text:0000184B                 cmp     dword ptr [ecx], 0
.text:0000184E                 jz      short loc_186B
.text:00001850                 mov     edx, [ebp+var_4]
.text:00001853                 mov     eax, [edx]
.text:00001855                 mov     ecx, [ebp+var_4]
.text:00001858                 mov     edx, [ecx]
.text:0000185A                 mov     eax, [eax]
.text:0000185C                 mov     esi, esp
.text:0000185E                 push    edx
.text:0000185F                 mov     ecx, [eax+8]
.text:00001862                 call    ecx
.text:00001864                 cmp     esi, esp
.text:00001866                 call    __RTC_CheckEsp
.text:0000186B
.text:0000186B loc_186B:                               ; CODE XREF: CMyComPtr<IUnknown>::operator=(IUnknown *)+32j
.text:0000186B                 mov     edx, [ebp+var_4]
.text:0000186E                 mov     eax, [ebp+arg_0]
.text:00001871                 mov     [edx], eax
.text:00001873                 mov     eax, [ebp+arg_0]
.text:00001876                 pop     esi
.text:00001877                 add     esp, 4
.text:0000187A                 cmp     ebp, esp
.text:0000187C                 call    __RTC_CheckEsp
.text:00001881                 mov     esp, ebp
.text:00001883                 pop     ebp
.text:00001884                 retn    4
.text:00001884 ??4?$CMyComPtr@UIUnknown@@@@QAEPAUIUnknown@@PAU1@@Z endp
.text:00001884
.text:00001884 ; ---------------------------------------------------------------------------
.text:00001887                 align 4
.text:00001887 _text           ends
.text:00001887
.text:00001888 ; ===========================================================================
.text:00001888
.text:00001888 ; Segment type: Pure code
.text:00001888 ; Segment permissions: Read/Execute
.text:00001888 _text           segment para public 'CODE' use32
.text:00001888                 assume cs:_text
.text:00001888                 ;org 1888h
.text:00001888 ; COMDAT (pick any)
.text:00001888                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001888
.text:00001888 ; =============== S U B R O U T I N E =======================================
.text:00001888
.text:00001888 ; Attributes: bp-based frame
.text:00001888
.text:00001888 ; public: struct ISequentialOutStream * __thiscall CMyComPtr<struct ISequentialOutStream>::operator->(void)const
.text:00001888                 public ??C?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ
.text:00001888 ??C?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ proc near
.text:00001888                                         ; CODE XREF: CSequentialOutStreamSizeCount::Write(void const *,uint,uint *)+21p
.text:00001888
.text:00001888 var_4           = dword ptr -4
.text:00001888
.text:00001888                 push    ebp
.text:00001889                 mov     ebp, esp
.text:0000188B                 push    ecx
.text:0000188C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001893                 mov     [ebp+var_4], ecx
.text:00001896                 mov     eax, [ebp+var_4]
.text:00001899                 mov     eax, [eax]
.text:0000189B                 mov     esp, ebp
.text:0000189D                 pop     ebp
.text:0000189E                 retn
.text:0000189E ??C?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ endp
.text:0000189E
.text:0000189E ; ---------------------------------------------------------------------------
.text:0000189F                 align 10h
.text:0000189F _text           ends
.text:0000189F
.text:000018A0 ; ===========================================================================
.text:000018A0
.text:000018A0 ; Segment type: Pure code
.text:000018A0 ; Segment permissions: Read/Execute
.text:000018A0 _text           segment para public 'CODE' use32
.text:000018A0                 assume cs:_text
.text:000018A0                 ;org 18A0h
.text:000018A0 ; COMDAT (pick any)
.text:000018A0                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000018A0
.text:000018A0 ; =============== S U B R O U T I N E =======================================
.text:000018A0
.text:000018A0 ; Attributes: bp-based frame
.text:000018A0
.text:000018A0 ; public: __thiscall CMyComPtr<struct ISequentialInStream>::CMyComPtr<struct ISequentialInStream>(struct ISequentialInStream *)
.text:000018A0                 public ??0?$CMyComPtr@UISequentialInStream@@@@QAE@PAUISequentialInStream@@@Z
.text:000018A0 ??0?$CMyComPtr@UISequentialInStream@@@@QAE@PAUISequentialInStream@@@Z proc near
.text:000018A0                                         ; CODE XREF: Create_BufInStream_WithReference(void const *,uint,IUnknown *,ISequentialInStream * *)+90p
.text:000018A0                                         ; Create_BufInStream_WithNewBuffer(void const *,uint,ISequentialInStream * *)+90p
.text:000018A0
.text:000018A0 var_4           = dword ptr -4
.text:000018A0 arg_0           = dword ptr  8
.text:000018A0
.text:000018A0                 push    ebp
.text:000018A1                 mov     ebp, esp
.text:000018A3                 push    ecx
.text:000018A4                 push    esi
.text:000018A5                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000018AC                 mov     [ebp+var_4], ecx
.text:000018AF                 mov     eax, [ebp+var_4]
.text:000018B2                 mov     ecx, [ebp+arg_0]
.text:000018B5                 mov     [eax], ecx
.text:000018B7                 cmp     [ebp+arg_0], 0
.text:000018BB                 jz      short loc_18D4
.text:000018BD                 mov     edx, [ebp+arg_0]
.text:000018C0                 mov     eax, [edx]
.text:000018C2                 mov     esi, esp
.text:000018C4                 mov     ecx, [ebp+arg_0]
.text:000018C7                 push    ecx
.text:000018C8                 mov     edx, [eax+4]
.text:000018CB                 call    edx
.text:000018CD                 cmp     esi, esp
.text:000018CF                 call    __RTC_CheckEsp
.text:000018D4
.text:000018D4 loc_18D4:                               ; CODE XREF: CMyComPtr<ISequentialInStream>::CMyComPtr<ISequentialInStream>(ISequentialInStream *)+1Bj
.text:000018D4                 mov     eax, [ebp+var_4]
.text:000018D7                 pop     esi
.text:000018D8                 add     esp, 4
.text:000018DB                 cmp     ebp, esp
.text:000018DD                 call    __RTC_CheckEsp
.text:000018E2                 mov     esp, ebp
.text:000018E4                 pop     ebp
.text:000018E5                 retn    4
.text:000018E5 ??0?$CMyComPtr@UISequentialInStream@@@@QAE@PAUISequentialInStream@@@Z endp
.text:000018E5
.text:000018E5 _text           ends
.text:000018E5
.text:000018E8 ; ===========================================================================
.text:000018E8
.text:000018E8 ; Segment type: Pure code
.text:000018E8 ; Segment permissions: Read/Execute
.text:000018E8 _text           segment para public 'CODE' use32
.text:000018E8                 assume cs:_text
.text:000018E8                 ;org 18E8h
.text:000018E8 ; COMDAT (pick any)
.text:000018E8                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000018E8
.text:000018E8 ; =============== S U B R O U T I N E =======================================
.text:000018E8
.text:000018E8 ; Attributes: bp-based frame
.text:000018E8
.text:000018E8 ; public: __thiscall CMyComPtr<struct ISequentialInStream>::~CMyComPtr<struct ISequentialInStream>(void)
.text:000018E8                 public ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ
.text:000018E8 ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ proc near
.text:000018E8                                         ; CODE XREF: Create_BufInStream_WithReference(void const *,uint,IUnknown *,ISequentialInStream * *)+C7p
.text:000018E8                                         ; Create_BufInStream_WithNewBuffer(void const *,uint,ISequentialInStream * *)+CEp ...
.text:000018E8
.text:000018E8 var_4           = dword ptr -4
.text:000018E8
.text:000018E8                 push    ebp
.text:000018E9                 mov     ebp, esp
.text:000018EB                 push    ecx
.text:000018EC                 push    esi
.text:000018ED                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000018F4                 mov     [ebp+var_4], ecx
.text:000018F7                 mov     eax, [ebp+var_4]
.text:000018FA                 cmp     dword ptr [eax], 0
.text:000018FD                 jz      short loc_191A
.text:000018FF                 mov     ecx, [ebp+var_4]
.text:00001902                 mov     edx, [ecx]
.text:00001904                 mov     eax, [ebp+var_4]
.text:00001907                 mov     ecx, [eax]
.text:00001909                 mov     edx, [edx]
.text:0000190B                 mov     esi, esp
.text:0000190D                 push    ecx
.text:0000190E                 mov     eax, [edx+8]
.text:00001911                 call    eax
.text:00001913                 cmp     esi, esp
.text:00001915                 call    __RTC_CheckEsp
.text:0000191A
.text:0000191A loc_191A:                               ; CODE XREF: CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)+15j
.text:0000191A                 pop     esi
.text:0000191B                 add     esp, 4
.text:0000191E                 cmp     ebp, esp
.text:00001920                 call    __RTC_CheckEsp
.text:00001925                 mov     esp, ebp
.text:00001927                 pop     ebp
.text:00001928                 retn
.text:00001928 ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ endp
.text:00001928
.text:00001928 ; ---------------------------------------------------------------------------
.text:00001929                 align 4
.text:00001929 _text           ends
.text:00001929
.text:0000192C ; ===========================================================================
.text:0000192C
.text:0000192C ; Segment type: Pure code
.text:0000192C ; Segment permissions: Read/Execute
.text:0000192C _text           segment para public 'CODE' use32
.text:0000192C                 assume cs:_text
.text:0000192C                 ;org 192Ch
.text:0000192C ; COMDAT (pick any)
.text:0000192C                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:0000192C
.text:0000192C ; =============== S U B R O U T I N E =======================================
.text:0000192C
.text:0000192C ; Attributes: bp-based frame
.text:0000192C
.text:0000192C ; public: struct ISequentialInStream * __thiscall CMyComPtr<struct ISequentialInStream>::Detach(void)
.text:0000192C                 public ?Detach@?$CMyComPtr@UISequentialInStream@@@@QAEPAUISequentialInStream@@XZ
.text:0000192C ?Detach@?$CMyComPtr@UISequentialInStream@@@@QAEPAUISequentialInStream@@XZ proc near
.text:0000192C                                         ; CODE XREF: Create_BufInStream_WithReference(void const *,uint,IUnknown *,ISequentialInStream * *)+B3p
.text:0000192C                                         ; Create_BufInStream_WithNewBuffer(void const *,uint,ISequentialInStream * *)+BAp
.text:0000192C
.text:0000192C var_8           = dword ptr -8
.text:0000192C var_4           = dword ptr -4
.text:0000192C
.text:0000192C                 push    ebp
.text:0000192D                 mov     ebp, esp
.text:0000192F                 sub     esp, 8
.text:00001932                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00001939                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001940                 mov     [ebp+var_4], ecx
.text:00001943                 mov     eax, [ebp+var_4]
.text:00001946                 mov     ecx, [eax]
.text:00001948                 mov     [ebp+var_8], ecx
.text:0000194B                 mov     edx, [ebp+var_4]
.text:0000194E                 mov     dword ptr [edx], 0
.text:00001954                 mov     eax, [ebp+var_8]
.text:00001957                 mov     esp, ebp
.text:00001959                 pop     ebp
.text:0000195A                 retn
.text:0000195A ?Detach@?$CMyComPtr@UISequentialInStream@@@@QAEPAUISequentialInStream@@XZ endp
.text:0000195A
.text:0000195A ; ---------------------------------------------------------------------------
.text:0000195B                 align 4
.text:0000195B _text           ends
.text:0000195B
.text:0000195C ; ===========================================================================
.text:0000195C
.text:0000195C ; Segment type: Pure code
.text:0000195C ; Segment permissions: Read/Execute
.text:0000195C _text           segment para public 'CODE' use32
.text:0000195C                 assume cs:_text
.text:0000195C                 ;org 195Ch
.text:0000195C ; COMDAT (pick any)
.text:0000195C                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:0000195C
.text:0000195C ; =============== S U B R O U T I N E =======================================
.text:0000195C
.text:0000195C ; Attributes: bp-based frame
.text:0000195C
.text:0000195C ; public: void __thiscall CBuffer<unsigned char>::Alloc(unsigned int)
.text:0000195C                 public ?Alloc@?$CBuffer@E@@QAEXI@Z
.text:0000195C ?Alloc@?$CBuffer@E@@QAEXI@Z proc near   ; CODE XREF: CBuffer<uchar>::CopyFrom(uchar const *,uint)+15p
.text:0000195C
.text:0000195C var_8           = dword ptr -8
.text:0000195C var_4           = dword ptr -4
.text:0000195C arg_0           = dword ptr  8
.text:0000195C
.text:0000195C                 push    ebp
.text:0000195D                 mov     ebp, esp
.text:0000195F                 sub     esp, 8
.text:00001962                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00001969                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001970                 mov     [ebp+var_4], ecx
.text:00001973                 mov     eax, [ebp+var_4]
.text:00001976                 mov     ecx, [ebp+arg_0]
.text:00001979                 cmp     ecx, [eax+4]
.text:0000197C                 jz      short loc_19AC
.text:0000197E                 mov     ecx, [ebp+var_4]
.text:00001981                 call    ?Free@?$CBuffer@E@@QAEXXZ ; CBuffer<uchar>::Free(void)
.text:00001986                 cmp     [ebp+arg_0], 0
.text:0000198A                 jz      short loc_19AC
.text:0000198C                 mov     edx, [ebp+arg_0]
.text:0000198F                 push    edx             ; unsigned int
.text:00001990                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00001995                 add     esp, 4
.text:00001998                 mov     [ebp+var_8], eax
.text:0000199B                 mov     eax, [ebp+var_4]
.text:0000199E                 mov     ecx, [ebp+var_8]
.text:000019A1                 mov     [eax], ecx
.text:000019A3                 mov     edx, [ebp+var_4]
.text:000019A6                 mov     eax, [ebp+arg_0]
.text:000019A9                 mov     [edx+4], eax
.text:000019AC
.text:000019AC loc_19AC:                               ; CODE XREF: CBuffer<uchar>::Alloc(uint)+20j
.text:000019AC                                         ; CBuffer<uchar>::Alloc(uint)+2Ej
.text:000019AC                 add     esp, 8
.text:000019AF                 cmp     ebp, esp
.text:000019B1                 call    __RTC_CheckEsp
.text:000019B6                 mov     esp, ebp
.text:000019B8                 pop     ebp
.text:000019B9                 retn    4
.text:000019B9 ?Alloc@?$CBuffer@E@@QAEXI@Z endp
.text:000019B9
.text:000019B9 _text           ends
.text:000019B9
.text:000019BC ; ===========================================================================
.text:000019BC
.text:000019BC ; Segment type: Pure code
.text:000019BC ; Segment permissions: Read/Execute
.text:000019BC _text           segment para public 'CODE' use32
.text:000019BC                 assume cs:_text
.text:000019BC                 ;org 19BCh
.text:000019BC ; COMDAT (pick any)
.text:000019BC                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000019BC
.text:000019BC ; =============== S U B R O U T I N E =======================================
.text:000019BC
.text:000019BC ; Attributes: bp-based frame
.text:000019BC
.text:000019BC ; public: void __thiscall CBuffer<unsigned char>::Free(void)
.text:000019BC                 public ?Free@?$CBuffer@E@@QAEXXZ
.text:000019BC ?Free@?$CBuffer@E@@QAEXXZ proc near     ; CODE XREF: CBuffer<uchar>::Alloc(uint)+25p
.text:000019BC
.text:000019BC var_8           = dword ptr -8
.text:000019BC var_4           = dword ptr -4
.text:000019BC
.text:000019BC                 push    ebp
.text:000019BD                 mov     ebp, esp
.text:000019BF                 sub     esp, 8
.text:000019C2                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000019C9                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000019D0                 mov     [ebp+var_4], ecx
.text:000019D3                 mov     eax, [ebp+var_4]
.text:000019D6                 cmp     dword ptr [eax], 0
.text:000019D9                 jz      short loc_19F8
.text:000019DB                 mov     ecx, [ebp+var_4]
.text:000019DE                 mov     edx, [ecx]
.text:000019E0                 mov     [ebp+var_8], edx
.text:000019E3                 mov     eax, [ebp+var_8]
.text:000019E6                 push    eax             ; void *
.text:000019E7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:000019EC                 add     esp, 4
.text:000019EF                 mov     ecx, [ebp+var_4]
.text:000019F2                 mov     dword ptr [ecx], 0
.text:000019F8
.text:000019F8 loc_19F8:                               ; CODE XREF: CBuffer<uchar>::Free(void)+1Dj
.text:000019F8                 mov     edx, [ebp+var_4]
.text:000019FB                 mov     dword ptr [edx+4], 0
.text:00001A02                 add     esp, 8
.text:00001A05                 cmp     ebp, esp
.text:00001A07                 call    __RTC_CheckEsp
.text:00001A0C                 mov     esp, ebp
.text:00001A0E                 pop     ebp
.text:00001A0F                 retn
.text:00001A0F ?Free@?$CBuffer@E@@QAEXXZ endp
.text:00001A0F
.text:00001A0F _text           ends
.text:00001A0F
.text:00001A10 ; ===========================================================================
.text:00001A10
.text:00001A10 ; Segment type: Pure code
.text:00001A10 ; Segment permissions: Read/Execute
.text:00001A10 _text           segment para public 'CODE' use32
.text:00001A10                 assume cs:_text
.text:00001A10                 ;org 1A10h
.text:00001A10 ; COMDAT (pick any)
.text:00001A10                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001A10
.text:00001A10 ; =============== S U B R O U T I N E =======================================
.text:00001A10
.text:00001A10 ; Attributes: bp-based frame
.text:00001A10
.text:00001A10 ; unsigned int __stdcall MyMax<unsigned int>(unsigned int, unsigned int)
.text:00001A10                 public ??$MyMax@I@@YGIII@Z
.text:00001A10 ??$MyMax@I@@YGIII@Z proc near           ; CODE XREF: CByteDynBuffer::EnsureCapacity(uint)+67p
.text:00001A10
.text:00001A10 var_4           = dword ptr -4
.text:00001A10 arg_0           = dword ptr  8
.text:00001A10 arg_4           = dword ptr  0Ch
.text:00001A10
.text:00001A10                 push    ebp
.text:00001A11                 mov     ebp, esp
.text:00001A13                 push    ecx
.text:00001A14                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001A1B                 mov     eax, [ebp+arg_0]
.text:00001A1E                 cmp     eax, [ebp+arg_4]
.text:00001A21                 jbe     short loc_1A2B
.text:00001A23                 mov     ecx, [ebp+arg_0]
.text:00001A26                 mov     [ebp+var_4], ecx
.text:00001A29                 jmp     short loc_1A31
.text:00001A2B ; ---------------------------------------------------------------------------
.text:00001A2B
.text:00001A2B loc_1A2B:                               ; CODE XREF: MyMax<uint>(uint,uint)+11j
.text:00001A2B                 mov     edx, [ebp+arg_4]
.text:00001A2E                 mov     [ebp+var_4], edx
.text:00001A31
.text:00001A31 loc_1A31:                               ; CODE XREF: MyMax<uint>(uint,uint)+19j
.text:00001A31                 mov     eax, [ebp+var_4]
.text:00001A34                 mov     esp, ebp
.text:00001A36                 pop     ebp
.text:00001A37                 retn    8
.text:00001A37 ??$MyMax@I@@YGIII@Z endp
.text:00001A37
.text:00001A37 ; ---------------------------------------------------------------------------
.text:00001A3A                 align 4
.text:00001A3A _text           ends
.text:00001A3A
.text:00001A3C ; ===========================================================================
.text:00001A3C
.text:00001A3C ; Segment type: Pure code
.text:00001A3C ; Segment permissions: Read/Execute
.text:00001A3C _text           segment para public 'CODE' use32
.text:00001A3C                 assume cs:_text
.text:00001A3C                 ;org 1A3Ch
.text:00001A3C ; COMDAT (pick any)
.text:00001A3C                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001A3C
.text:00001A3C ; =============== S U B R O U T I N E =======================================
.text:00001A3C
.text:00001A3C ; Attributes: bp-based frame
.text:00001A3C
.text:00001A3C ; unsigned int __stdcall MyMin<unsigned int>(unsigned int, unsigned int)
.text:00001A3C                 public ??$MyMin@I@@YGIII@Z
.text:00001A3C ??$MyMin@I@@YGIII@Z proc near           ; CODE XREF: CCachedInStream::Read(void *,uint,uint *)+1F3p
.text:00001A3C
.text:00001A3C var_4           = dword ptr -4
.text:00001A3C arg_0           = dword ptr  8
.text:00001A3C arg_4           = dword ptr  0Ch
.text:00001A3C
.text:00001A3C                 push    ebp
.text:00001A3D                 mov     ebp, esp
.text:00001A3F                 push    ecx
.text:00001A40                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001A47                 mov     eax, [ebp+arg_0]
.text:00001A4A                 cmp     eax, [ebp+arg_4]
.text:00001A4D                 jnb     short loc_1A57
.text:00001A4F                 mov     ecx, [ebp+arg_0]
.text:00001A52                 mov     [ebp+var_4], ecx
.text:00001A55                 jmp     short loc_1A5D
.text:00001A57 ; ---------------------------------------------------------------------------
.text:00001A57
.text:00001A57 loc_1A57:                               ; CODE XREF: MyMin<uint>(uint,uint)+11j
.text:00001A57                 mov     edx, [ebp+arg_4]
.text:00001A5A                 mov     [ebp+var_4], edx
.text:00001A5D
.text:00001A5D loc_1A5D:                               ; CODE XREF: MyMin<uint>(uint,uint)+19j
.text:00001A5D                 mov     eax, [ebp+var_4]
.text:00001A60                 mov     esp, ebp
.text:00001A62                 pop     ebp
.text:00001A63                 retn    8
.text:00001A63 ??$MyMin@I@@YGIII@Z endp
.text:00001A63
.text:00001A63 _text           ends
.text:00001A63
UNDEF:00001A70 ; ===========================================================================
UNDEF:00001A70
UNDEF:00001A70 ; Segment type: Externs
UNDEF:00001A70 ; UNDEF
UNDEF:00001A70 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:00001A70                 extrn _memcpy:near      ; CODE XREF: CBufferInStream::Read(void *,uint,uint *)+A8p
UNDEF:00001A70                                         ; CBufInStream::Read(void *,uint,uint *)+97p ...
UNDEF:00001A74                 extrn __RTC_CheckEsp:near
UNDEF:00001A74                                         ; CODE XREF: CBufferInStream::Read(void *,uint,uint *)+DCp
UNDEF:00001A74                                         ; CBufferInStream::Seek(__int64,uint,unsigned __int64 *)+9Fp ...
UNDEF:00001A78                 extrn __RTC_Shutdown:near
UNDEF:00001A78                                         ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
UNDEF:00001A7C                 extrn __RTC_InitBase:near
UNDEF:00001A7C                                         ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
UNDEF:00001A80 ; void __cdecl operator delete(void *)
UNDEF:00001A80                 extrn ??3@YAXPAX@Z:near ; CODE XREF: __unwindfunclet$?Create_BufInStream_WithReference@@YGXPBXIPAUIUnknown@@PAPAUISequentialInStream@@@Z$0+4p
UNDEF:00001A80                                         ; __unwindfunclet$?Create_BufInStream_WithNewBuffer@@YGXPBXIPAPAUISequentialInStream@@@Z$0+4p ...
UNDEF:00001A84 ; void *__cdecl operator new(unsigned int)
UNDEF:00001A84                 extrn ??2@YAPAXI@Z:near ; CODE XREF: Create_BufInStream_WithReference(void const *,uint,IUnknown *,ISequentialInStream * *)+4Ap
UNDEF:00001A84                                         ; Create_BufInStream_WithNewBuffer(void const *,uint,ISequentialInStream * *)+4Ap ...
UNDEF:00001A88                 extrn ___security_cookie:near
UNDEF:00001A88                                         ; DATA XREF: Create_BufInStream_WithReference(void const *,uint,IUnknown *,ISequentialInStream * *)+2Er
UNDEF:00001A88                                         ; Create_BufInStream_WithNewBuffer(void const *,uint,ISequentialInStream * *)+2Er
UNDEF:00001A8C                 extrn ___CxxFrameHandler3:near
UNDEF:00001A8C                                         ; CODE XREF: __ehhandler$?Create_BufInStream_WithReference@@YGXPBXIPAUIUnknown@@PAPAUISequentialInStream@@@Z+16j
UNDEF:00001A8C                                         ; __ehhandler$?Create_BufInStream_WithNewBuffer@@YGXPBXIPAPAUISequentialInStream@@@Z+16j
UNDEF:00001A90 ; __fastcall __security_check_cookie(x)
UNDEF:00001A90                 extrn @__security_check_cookie@4:near
UNDEF:00001A90                                         ; CODE XREF: __ehhandler$?Create_BufInStream_WithReference@@YGXPBXIPAUIUnknown@@PAPAUISequentialInStream@@@Z+Cp
UNDEF:00001A90                                         ; __ehhandler$?Create_BufInStream_WithNewBuffer@@YGXPBXIPAPAUISequentialInStream@@@Z+Cp
UNDEF:00001A94 ; __fastcall _RTC_CheckStackVars(x, x)
UNDEF:00001A94                 extrn @_RTC_CheckStackVars@8:near
UNDEF:00001A94                                         ; CODE XREF: Create_BufInStream_WithReference(void const *,uint,IUnknown *,ISequentialInStream * *)+D6p
UNDEF:00001A94                                         ; Create_BufInStream_WithNewBuffer(void const *,uint,ISequentialInStream * *)+DDp ...
UNDEF:00001A98 ; const type_info::`vftable'
UNDEF:00001A98                 extrn ??_7type_info@@6B@:near
UNDEF:00001A98                                         ; DATA XREF: .data:CBufInStream `RTTI Type Descriptor'o
UNDEF:00001A98                                         ; .data:IInStream `RTTI Type Descriptor'o ...
UNDEF:00001A9C                 extrn _IID_IInStream:near
UNDEF:00001A9C                                         ; DATA XREF: CBufInStream::QueryInterface(_GUID const &,void * *):loc_11A8o
UNDEF:00001A9C                                         ; CBufferInStream::QueryInterface(_GUID const &,void * *):loc_1540o
UNDEF:00001AA0                 extrn _IID_ISequentialInStream:near
UNDEF:00001AA0                                         ; DATA XREF: CBufInStream::QueryInterface(_GUID const &,void * *):loc_118Co
UNDEF:00001AA0                                         ; CBufferInStream::QueryInterface(_GUID const &,void * *):loc_1524o
UNDEF:00001AA4 ; const IID IID_IUnknown
UNDEF:00001AA4                 extrn _IID_IUnknown:near
UNDEF:00001AA4                                         ; DATA XREF: CBufInStream::QueryInterface(_GUID const &,void * *)+Co
UNDEF:00001AA4                                         ; CBufferInStream::QueryInterface(_GUID const &,void * *)+Co
UNDEF:00001AA8 ; int __cdecl memcmp(const void *Buf1, const void *Buf2, size_t Size)
UNDEF:00001AA8                 extrn _memcmp:near      ; CODE XREF: IsEqualGUID(x,x)+Dp
UNDEF:00001AAC                 extrn __purecall:near   ; DATA XREF: .rdata:const IInStream::`vftable'o
UNDEF:00001AAC                                         ; .rdata:0000136Co ...
UNDEF:00001AB0 ; void __cdecl _free(void *Memory)
UNDEF:00001AB0                 extrn __imp__free:near  ; CODE XREF: CByteDynBuffer::Free(void)+18p
UNDEF:00001AB0                                         ; DATA XREF: CByteDynBuffer::Free(void)+18r
UNDEF:00001AB4 ; void *__cdecl _realloc(void *Memory, size_t NewSize)
UNDEF:00001AB4                 extrn __imp__realloc:near
UNDEF:00001AB4                                         ; CODE XREF: CByteDynBuffer::EnsureCapacity(uint)+7Cp
UNDEF:00001AB4                                         ; DATA XREF: CByteDynBuffer::EnsureCapacity(uint)+7Cr
UNDEF:00001AB8 ; __stdcall MidFree(x)
UNDEF:00001AB8                 extrn _MidFree@4:near   ; CODE XREF: CCachedInStream::Free(void)+2Bp
UNDEF:00001AB8                                         ; CCachedInStream::Alloc(uint,uint)+5Cp
UNDEF:00001ABC ; __stdcall MyFree(x)
UNDEF:00001ABC                 extrn _MyFree@4:near    ; CODE XREF: CCachedInStream::Free(void)+15p
UNDEF:00001ABC                                         ; CCachedInStream::Alloc(uint,uint)+A1p
UNDEF:00001AC0 ; __stdcall MyAlloc(x)
UNDEF:00001AC0                 extrn _MyAlloc@4:near   ; CODE XREF: CCachedInStream::Alloc(uint,uint)+B1p
UNDEF:00001AC4 ; __stdcall MidAlloc(x)
UNDEF:00001AC4                 extrn _MidAlloc@4:near  ; CODE XREF: CCachedInStream::Alloc(uint,uint)+65p
UNDEF:00001AC8                 extrn __allshl:near     ; CODE XREF: CCachedInStream::Read(void *,uint,uint *)+12Bp
UNDEF:00001ACC                 extrn __aullshr:near    ; CODE XREF: CCachedInStream::Read(void *,uint,uint *)+B8p
UNDEF:00001ACC
UNDEF:00001ACC
UNDEF:00001ACC                 end