.text:00000000 ;
.text:00000000 ; +-------------------------------------------------------------------------+
.text:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.text:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.text:00000000 ; |                      License info: 48-3677-7074-51                      |
.text:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.text:00000000 ; +-------------------------------------------------------------------------+
.text:00000000 ;
.text:00000000 ; Input MD5   : 2BF282F96353837DBE36443B573A5EB0
.text:00000000 ; Input CRC32 : C7BFA01B
.text:00000000
.text:00000000 ; File Name   : C:\workspace\7z1505-src\CPP\7zip\Bundles\Alone\Debug\TarHandlerOut.obj
.text:00000000 ; Format      : COFF (X386MAGIC)
.text:00000000 ; includelib "uuid.lib"
.text:00000000 ; includelib "MSVCRTD"
.text:00000000 ; includelib "OLDNAMES"
.text:00000000
.text:00000000                 .686p
.text:00000000                 .mmx
.text:00000000                 .model flat
.text:00000000
.text:00000000 ; ===========================================================================
.text:00000000
.text:00000000 ; Segment type: Pure code
.text:00000000 ; Segment permissions: Read/Execute
.text:00000000 _text           segment para public 'CODE' use32
.text:00000000                 assume cs:_text
.text:00000000                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000000
.text:00000000 ; =============== S U B R O U T I N E =======================================
.text:00000000
.text:00000000 ; Attributes: bp-based frame
.text:00000000
.text:00000000 ; __int32 __stdcall NArchive::NTar::CHandler::GetFileTimeType(NArchive::NTar::CHandler *this, unsigned int *)
.text:00000000                 public ?GetFileTimeType@CHandler@NTar@NArchive@@UAGJPAI@Z
.text:00000000 ?GetFileTimeType@CHandler@NTar@NArchive@@UAGJPAI@Z proc near
.text:00000000
.text:00000000 this            = dword ptr  8
.text:00000000 arg_4           = dword ptr  0Ch
.text:00000000
.text:00000000                 push    ebp
.text:00000001                 mov     ebp, esp
.text:00000003                 mov     eax, [ebp+arg_4]
.text:00000006                 mov     dword ptr [eax], 1
.text:0000000C                 xor     eax, eax
.text:0000000E                 pop     ebp
.text:0000000F                 retn    8
.text:0000000F ?GetFileTimeType@CHandler@NTar@NArchive@@UAGJPAI@Z endp
.text:0000000F
.text:0000000F ; ---------------------------------------------------------------------------
.text:00000012                 align 10h
.text:00000020
.text:00000020 ; =============== S U B R O U T I N E =======================================
.text:00000020
.text:00000020 ; Attributes: bp-based frame
.text:00000020
.text:00000020 ; __int32 __stdcall NArchive::NTar::GetPropString(NArchive::NTar *this, struct IArchiveUpdateCallback *, unsigned int, struct AString *, struct AString *, char, bool)
.text:00000020                 public ?GetPropString@NTar@NArchive@@YGJPAUIArchiveUpdateCallback@@IKAAVAString@@I_N@Z
.text:00000020 ?GetPropString@NTar@NArchive@@YGJPAUIArchiveUpdateCallback@@IKAAVAString@@I_N@Z proc near
.text:00000020                                         ; CODE XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+571p
.text:00000020                                         ; NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+619p ...
.text:00000020
.text:00000020 var_5C          = dword ptr -5Ch
.text:00000020 var_58          = dword ptr -58h
.text:00000020 var_54          = dword ptr -54h
.text:00000020 var_50          = dword ptr -50h
.text:00000020 var_4C          = byte ptr -4Ch
.text:00000020 var_40          = dword ptr -40h
.text:00000020 var_38          = byte ptr -38h
.text:00000020 var_28          = dword ptr -28h
.text:00000020 var_20          = word ptr -20h
.text:00000020 var_18          = dword ptr -18h
.text:00000020 var_C           = dword ptr -0Ch
.text:00000020 var_4           = dword ptr -4
.text:00000020 this            = dword ptr  8
.text:00000020 arg_4           = dword ptr  0Ch
.text:00000020 arg_8           = dword ptr  10h
.text:00000020 arg_C           = dword ptr  14h
.text:00000020 arg_10          = dword ptr  18h
.text:00000020 arg_14          = byte ptr  1Ch
.text:00000020
.text:00000020                 push    ebp
.text:00000021                 mov     ebp, esp
.text:00000023                 push    0FFFFFFFFh
.text:00000025                 push    offset __ehhandler$?GetPropString@NTar@NArchive@@YGJPAUIArchiveUpdateCallback@@IKAAVAString@@I_N@Z
.text:0000002A                 mov     eax, large fs:0
.text:00000030                 push    eax
.text:00000031                 sub     esp, 50h
.text:00000034                 push    esi
.text:00000035                 push    edi
.text:00000036                 lea     edi, [ebp+var_5C]
.text:00000039                 mov     ecx, 14h
.text:0000003E
.text:0000003E loc_3E:                                 ; DATA XREF: .xdata$x:__catchsym$?UpdateItems@CHandler@NTar@NArchive@@UAGJPAUISequentialOutStream@@IPAUIArchiveUpdateCallback@@@Z$8o
.text:0000003E                 mov     eax, 0CCCCCCCCh
.text:00000043                 rep stosd
.text:00000045
.text:00000045 loc_45:                                 ; DATA XREF: .text:00000AC4o
.text:00000045                 mov     eax, dword ptr ds:___security_cookie
.text:0000004A                 xor     eax, ebp
.text:0000004C                 push    eax
.text:0000004D                 lea     eax, [ebp+var_C]
.text:00000050                 mov     large fs:0, eax
.text:00000056                 lea     ecx, [ebp+var_20] ; this
.text:00000059                 call    ??0CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::CPropVariant(void)
.text:0000005E                 mov     [ebp+var_4], 0
.text:00000065                 mov     esi, esp
.text:00000067                 lea     eax, [ebp+var_20]
.text:0000006A                 push    eax
.text:0000006B                 mov     ecx, [ebp+arg_8]
.text:0000006E                 push    ecx
.text:0000006F                 mov     edx, [ebp+arg_4]
.text:00000072                 push    edx
.text:00000073                 mov     eax, [ebp+this]
.text:00000076                 mov     ecx, [eax]
.text:00000078                 mov     edx, [ebp+this]
.text:0000007B                 push    edx
.text:0000007C                 mov     eax, [ecx+18h]
.text:0000007F                 call    eax
.text:00000081                 cmp     esi, esp
.text:00000083                 call    __RTC_CheckEsp
.text:00000088                 mov     [ebp+var_28], eax
.text:0000008B                 cmp     [ebp+var_28], 0
.text:0000008F                 jz      short loc_AE
.text:00000091                 mov     ecx, [ebp+var_28]
.text:00000094                 mov     [ebp+var_40], ecx
.text:00000097                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000009E                 lea     ecx, [ebp+var_20] ; this
.text:000000A1                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:000000A6                 mov     eax, [ebp+var_40]
.text:000000A9                 jmp     loc_178
.text:000000AE ; ---------------------------------------------------------------------------
.text:000000AE
.text:000000AE loc_AE:                                 ; CODE XREF: NArchive::NTar::GetPropString(IArchiveUpdateCallback *,uint,ulong,AString &,uint,bool)+6Fj
.text:000000AE                 movzx   edx, [ebp+var_20]
.text:000000B2                 cmp     edx, 8
.text:000000B5                 jnz     loc_13C
.text:000000BB                 mov     eax, [ebp+var_18]
.text:000000BE                 push    eax             ; wchar_t *
.text:000000BF                 lea     ecx, [ebp+var_38] ; this
.text:000000C2                 call    ??0UString@@QAE@PB_W@Z ; UString::UString(wchar_t const *)
.text:000000C7                 mov     byte ptr [ebp+var_4], 1
.text:000000CB                 movzx   ecx, [ebp+arg_14]
.text:000000CF                 test    ecx, ecx
.text:000000D1                 jz      short loc_105
.text:000000D3                 lea     edx, [ebp+var_38]
.text:000000D6                 push    edx
.text:000000D7                 lea     eax, [ebp+var_4C]
.text:000000DA                 push    eax
.text:000000DB                 call    ?MakeLegalName@NItemName@NArchive@@YG?AVUString@@ABV3@@Z ; NArchive::NItemName::MakeLegalName(UString const &)
.text:000000E0                 mov     [ebp+var_58], eax
.text:000000E3                 mov     ecx, [ebp+var_58]
.text:000000E6                 mov     [ebp+var_5C], ecx
.text:000000E9                 mov     byte ptr [ebp+var_4], 2
.text:000000ED                 mov     edx, [ebp+var_5C]
.text:000000F0                 push    edx
.text:000000F1                 lea     ecx, [ebp+var_38]
.text:000000F4                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:000000F9                 mov     byte ptr [ebp+var_4], 1
.text:000000FD                 lea     ecx, [ebp+var_4C] ; this
.text:00000100                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000105
.text:00000105 loc_105:                                ; CODE XREF: NArchive::NTar::GetPropString(IArchiveUpdateCallback *,uint,ulong,AString &,uint,bool)+B1j
.text:00000105                 cmp     [ebp+arg_10], 0FDE9h
.text:0000010C                 jnz     short loc_11D
.text:0000010E                 mov     eax, [ebp+arg_C]
.text:00000111                 push    eax             ; struct AString *
.text:00000112                 lea     ecx, [ebp+var_38]
.text:00000115                 push    ecx             ; struct UString *
.text:00000116                 call    ?ConvertUnicodeToUTF8@@YGXABVUString@@AAVAString@@@Z ; ConvertUnicodeToUTF8(UString const &,AString &)
.text:0000011B                 jmp     short loc_12E
.text:0000011D ; ---------------------------------------------------------------------------
.text:0000011D
.text:0000011D loc_11D:                                ; CODE XREF: NArchive::NTar::GetPropString(IArchiveUpdateCallback *,uint,ulong,AString &,uint,bool)+ECj
.text:0000011D                 mov     edx, [ebp+arg_10]
.text:00000120                 push    edx             ; unsigned int
.text:00000121                 lea     eax, [ebp+var_38]
.text:00000124                 push    eax             ; struct UString *
.text:00000125                 mov     ecx, [ebp+arg_C]
.text:00000128                 push    ecx             ; struct AString *
.text:00000129                 call    ?UnicodeStringToMultiByte2@@YGXAAVAString@@ABVUString@@I@Z ; UnicodeStringToMultiByte2(AString &,UString const &,uint)
.text:0000012E
.text:0000012E loc_12E:                                ; CODE XREF: NArchive::NTar::GetPropString(IArchiveUpdateCallback *,uint,ulong,AString &,uint,bool)+FBj
.text:0000012E                 mov     byte ptr [ebp+var_4], 0
.text:00000132                 lea     ecx, [ebp+var_38] ; this
.text:00000135                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000013A                 jmp     short loc_15F
.text:0000013C ; ---------------------------------------------------------------------------
.text:0000013C
.text:0000013C loc_13C:                                ; CODE XREF: NArchive::NTar::GetPropString(IArchiveUpdateCallback *,uint,ulong,AString &,uint,bool)+95j
.text:0000013C                 movzx   edx, [ebp+var_20]
.text:00000140                 test    edx, edx
.text:00000142                 jz      short loc_15F
.text:00000144                 mov     [ebp+var_50], 80070057h
.text:0000014B                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000152                 lea     ecx, [ebp+var_20] ; this
.text:00000155                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:0000015A                 mov     eax, [ebp+var_50]
.text:0000015D                 jmp     short loc_178
.text:0000015F ; ---------------------------------------------------------------------------
.text:0000015F
.text:0000015F loc_15F:                                ; CODE XREF: NArchive::NTar::GetPropString(IArchiveUpdateCallback *,uint,ulong,AString &,uint,bool)+11Aj
.text:0000015F                                         ; NArchive::NTar::GetPropString(IArchiveUpdateCallback *,uint,ulong,AString &,uint,bool)+122j
.text:0000015F                 mov     [ebp+var_54], 0
.text:00000166                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000016D                 lea     ecx, [ebp+var_20] ; this
.text:00000170                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:00000175                 mov     eax, [ebp+var_54]
.text:00000178
.text:00000178 loc_178:                                ; CODE XREF: NArchive::NTar::GetPropString(IArchiveUpdateCallback *,uint,ulong,AString &,uint,bool)+89j
.text:00000178                                         ; NArchive::NTar::GetPropString(IArchiveUpdateCallback *,uint,ulong,AString &,uint,bool)+13Dj
.text:00000178                 push    edx
.text:00000179                 mov     ecx, ebp
.text:0000017B                 push    eax
.text:0000017C                 lea     edx, $LN17
.text:00000182                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00000187                 pop     eax
.text:00000188                 pop     edx
.text:00000189                 mov     ecx, [ebp+var_C]
.text:0000018C                 mov     large fs:0, ecx
.text:00000193                 pop     ecx
.text:00000194                 pop     edi
.text:00000195                 pop     esi
.text:00000196                 add     esp, 5Ch
.text:00000199                 cmp     ebp, esp
.text:0000019B                 call    __RTC_CheckEsp
.text:000001A0                 mov     esp, ebp
.text:000001A2                 pop     ebp
.text:000001A3                 retn    18h
.text:000001A3 ?GetPropString@NTar@NArchive@@YGJPAUIArchiveUpdateCallback@@IKAAVAString@@I_N@Z endp
.text:000001A3
.text:000001A3 ; ---------------------------------------------------------------------------
.text:000001A6                 align 4
.text:000001A8 $LN17           dd 2                    ; DATA XREF: NArchive::NTar::GetPropString(IArchiveUpdateCallback *,uint,ulong,AString &,uint,bool)+15Co
.text:000001AC                 dd offset $LN16
.text:000001B0 $LN16           dd 0FFFFFFE0h, 10h      ; DATA XREF: .text:000001ACo
.text:000001B8                 dd offset $LN13         ; "prop"
.text:000001BC                 dd 0FFFFFFC8h, 0Ch
.text:000001C4                 dd offset $LN14
.text:000001C8 $LN14           db 73h, 0               ; DATA XREF: .text:000001C4o
.text:000001CA $LN13           db 'prop',0             ; DATA XREF: .text:000001B8o
.text:000001CF                 align 10h
.text:000001D0
.text:000001D0 ; =============== S U B R O U T I N E =======================================
.text:000001D0
.text:000001D0 ; Attributes: bp-based frame
.text:000001D0
.text:000001D0 ; __int32 __cdecl NArchive::NTar::CHandler::UpdateItems(NArchive::NTar::CHandler *this, struct ISequentialOutStream *, unsigned int, struct IArchiveUpdateCallback *)
.text:000001D0                 public ?UpdateItems@CHandler@NTar@NArchive@@UAGJPAUISequentialOutStream@@IPAUIArchiveUpdateCallback@@@Z
.text:000001D0 ?UpdateItems@CHandler@NTar@NArchive@@UAGJPAUISequentialOutStream@@IPAUIArchiveUpdateCallback@@@Z proc near
.text:000001D0
.text:000001D0 var_1B4         = dword ptr -1B4h
.text:000001D0 var_1B0         = dword ptr -1B0h
.text:000001D0 var_1AC         = dword ptr -1ACh
.text:000001D0 var_1A8         = dword ptr -1A8h
.text:000001D0 var_1A1         = byte ptr -1A1h
.text:000001D0 var_1A0         = dword ptr -1A0h
.text:000001D0 var_19C         = dword ptr -19Ch
.text:000001D0 var_196         = byte ptr -196h
.text:000001D0 var_195         = byte ptr -195h
.text:000001D0 var_194         = dword ptr -194h
.text:000001D0 var_190         = dword ptr -190h
.text:000001D0 var_18C         = dword ptr -18Ch
.text:000001D0 var_188         = dword ptr -188h
.text:000001D0 var_184         = dword ptr -184h
.text:000001D0 var_180         = dword ptr -180h
.text:000001D0 var_17C         = dword ptr -17Ch
.text:000001D0 var_177         = byte ptr -177h
.text:000001D0 var_176         = byte ptr -176h
.text:000001D0 var_175         = byte ptr -175h
.text:000001D0 var_174         = dword ptr -174h
.text:000001D0 var_170         = dword ptr -170h
.text:000001D0 var_16C         = dword ptr -16Ch
.text:000001D0 var_168         = dword ptr -168h
.text:000001D0 var_164         = dword ptr -164h
.text:000001D0 var_160         = dword ptr -160h
.text:000001D0 var_158         = dword ptr -158h
.text:000001D0 var_154         = dword ptr -154h
.text:000001D0 var_150         = dword ptr -150h
.text:000001D0 var_14C         = dword ptr -14Ch
.text:000001D0 var_148         = dword ptr -148h
.text:000001D0 var_144         = dword ptr -144h
.text:000001D0 var_140         = dword ptr -140h
.text:000001D0 var_13C         = dword ptr -13Ch
.text:000001D0 var_138         = dword ptr -138h
.text:000001D0 var_134         = dword ptr -134h
.text:000001D0 var_130         = dword ptr -130h
.text:000001D0 var_12C         = dword ptr -12Ch
.text:000001D0 var_128         = dword ptr -128h
.text:000001D0 var_124         = dword ptr -124h
.text:000001D0 var_120         = dword ptr -120h
.text:000001D0 var_118         = word ptr -118h
.text:000001D0 var_110         = dword ptr -110h
.text:000001D0 var_10C         = dword ptr -10Ch
.text:000001D0 var_104         = dword ptr -104h
.text:000001D0 var_100         = dword ptr -100h
.text:000001D0 var_FC          = dword ptr -0FCh
.text:000001D0 var_F8          = dword ptr -0F8h
.text:000001D0 var_F0          = word ptr -0F0h
.text:000001D0 var_E8          = byte ptr -0E8h
.text:000001D0 var_DC          = dword ptr -0DCh
.text:000001D0 var_D4          = word ptr -0D4h
.text:000001D0 var_CC          = dword ptr -0CCh
.text:000001D0 var_C0          = dword ptr -0C0h
.text:000001D0 var_B8          = word ptr -0B8h
.text:000001D0 var_B0          = word ptr -0B0h
.text:000001D0 var_A4          = dword ptr -0A4h
.text:000001D0 var_9C          = dword ptr -9Ch
.text:000001D0 var_90          = dword ptr -90h
.text:000001D0 var_84          = dword ptr -84h
.text:000001D0 var_78          = dword ptr -78h
.text:000001D0 var_74          = dword ptr -74h
.text:000001D0 var_70          = dword ptr -70h
.text:000001D0 var_6C          = dword ptr -6Ch
.text:000001D0 var_68          = dword ptr -68h
.text:000001D0 var_64          = dword ptr -64h
.text:000001D0 var_60          = dword ptr -60h
.text:000001D0 var_5C          = byte ptr -5Ch
.text:000001D0 var_5B          = byte ptr -5Bh
.text:000001D0 var_5A          = byte ptr -5Ah
.text:000001D0 var_58          = byte ptr -58h
.text:000001D0 var_4C          = byte ptr -4Ch
.text:000001D0 var_40          = byte ptr -40h
.text:000001D0 var_2C          = dword ptr -2Ch
.text:000001D0 var_28          = dword ptr -28h
.text:000001D0 var_20          = byte ptr -20h
.text:000001D0 var_10          = dword ptr -10h
.text:000001D0 var_C           = dword ptr -0Ch
.text:000001D0 var_4           = dword ptr -4
.text:000001D0 this            = dword ptr  8
.text:000001D0 arg_4           = dword ptr  0Ch
.text:000001D0 arg_8           = dword ptr  10h
.text:000001D0 arg_C           = dword ptr  14h
.text:000001D0
.text:000001D0 ; FUNCTION CHUNK AT .text:00000A77 SIZE 00000032 BYTES
.text:000001D0
.text:000001D0                 push    ebp
.text:000001D1                 mov     ebp, esp
.text:000001D3                 push    0FFFFFFFFh
.text:000001D5                 push    offset __ehhandler$?UpdateItems@CHandler@NTar@NArchive@@UAGJPAUISequentialOutStream@@IPAUIArchiveUpdateCallback@@@Z
.text:000001DA                 mov     eax, large fs:0
.text:000001E0                 push    eax
.text:000001E1                 push    ecx
.text:000001E2                 sub     esp, 1A4h
.text:000001E8                 push    ebx
.text:000001E9                 push    esi
.text:000001EA                 push    edi
.text:000001EB                 lea     edi, [ebp+var_1B4]
.text:000001F1                 mov     ecx, 69h ; 'i'
.text:000001F6                 mov     eax, 0CCCCCCCCh
.text:000001FB                 rep stosd
.text:000001FD                 mov     eax, dword ptr ds:___security_cookie
.text:00000202                 xor     eax, ebp
.text:00000204                 push    eax             ; struct _FILETIME *
.text:00000205                 lea     eax, [ebp+var_C]
.text:00000208                 mov     large fs:0, eax
.text:0000020E                 mov     [ebp+var_10], esp
.text:00000211                 mov     [ebp+var_4], 0
.text:00000218                 mov     ecx, [ebp+this]
.text:0000021B                 add     ecx, 14h
.text:0000021E                 call    ??B?$CMyComPtr@UIInStream@@@@QBEPAUIInStream@@XZ ; CMyComPtr<IInStream>::operator IInStream *(void)
.text:00000223                 mov     [ebp+var_160], eax
.text:00000229                 cmp     [ebp+var_160], 0
.text:00000230                 jz      short loc_23E
.text:00000232                 mov     eax, [ebp+this]
.text:00000235                 cmp     dword ptr [eax+0C4h], 0
.text:0000023C                 jnz     short loc_258
.text:0000023E
.text:0000023E loc_23E:                                ; CODE XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+60j
.text:0000023E                 mov     ecx, [ebp+this]
.text:00000241                 add     ecx, 18h
.text:00000244                 call    ??B?$CMyComPtr@UISequentialInStream@@@@QBEPAUISequentialInStream@@XZ ; CMyComPtr<ISequentialInStream>::operator ISequentialInStream *(void)
.text:00000249                 mov     [ebp+var_164], eax
.text:0000024F                 cmp     [ebp+var_164], 0
.text:00000256                 jz      short loc_262
.text:00000258
.text:00000258 loc_258:                                ; CODE XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+6Cj
.text:00000258                 mov     eax, 80004001h
.text:0000025D                 jmp     loc_A77
.text:00000262 ; ---------------------------------------------------------------------------
.text:00000262
.text:00000262 loc_262:                                ; CODE XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+86j
.text:00000262                 lea     ecx, [ebp+var_20]
.text:00000265                 call    ??0?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAE@XZ ; CObjectVector<NArchive::NTar::CUpdateItem>::CObjectVector<NArchive::NTar::CUpdateItem>(void)
.text:0000026A                 mov     [ebp+var_168], eax
.text:00000270                 mov     byte ptr [ebp+var_4], 1
.text:00000274                 mov     ecx, [ebp+this]
.text:00000277                 movzx   edx, byte ptr [ecx+0CAh]
.text:0000027E                 test    edx, edx
.text:00000280                 jz      short loc_293
.text:00000282                 mov     eax, [ebp+this]
.text:00000285                 mov     ecx, [eax+0CCh]
.text:0000028B                 mov     [ebp+var_16C], ecx
.text:00000291                 jmp     short loc_2A2
.text:00000293 ; ---------------------------------------------------------------------------
.text:00000293
.text:00000293 loc_293:                                ; CODE XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+B0j
.text:00000293                 mov     edx, [ebp+this]
.text:00000296                 mov     eax, [edx+0D4h]
.text:0000029C                 mov     [ebp+var_16C], eax
.text:000002A2
.text:000002A2 loc_2A2:                                ; CODE XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+C1j
.text:000002A2                 mov     ecx, [ebp+var_16C]
.text:000002A8                 mov     [ebp+var_28], ecx
.text:000002AB                 mov     [ebp+var_2C], 0
.text:000002B2                 jmp     short loc_2BD
.text:000002B4 ; ---------------------------------------------------------------------------
.text:000002B4
.text:000002B4 loc_2B4:                                ; CODE XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+7FFj
.text:000002B4                 mov     edx, [ebp+var_2C]
.text:000002B7                 add     edx, 1
.text:000002BA                 mov     [ebp+var_2C], edx
.text:000002BD
.text:000002BD loc_2BD:                                ; CODE XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+E2j
.text:000002BD                 mov     eax, [ebp+var_2C]
.text:000002C0                 cmp     eax, [ebp+arg_8]
.text:000002C3                 jnb     loc_9D4
.text:000002C9                 lea     ecx, [ebp+var_78] ; this
.text:000002CC                 call    ??0CUpdateItem@NTar@NArchive@@QAE@XZ ; NArchive::NTar::CUpdateItem::CUpdateItem(void)
.text:000002D1                 mov     [ebp+var_170], eax
.text:000002D7                 mov     byte ptr [ebp+var_4], 2
.text:000002DB                 cmp     [ebp+arg_C], 0
.text:000002DF                 jnz     short loc_30E
.text:000002E1                 mov     [ebp+var_124], 80004005h
.text:000002EB                 mov     byte ptr [ebp+var_4], 1
.text:000002EF                 lea     ecx, [ebp+var_78] ; this
.text:000002F2                 call    ??1CUpdateItem@NTar@NArchive@@QAE@XZ ; NArchive::NTar::CUpdateItem::~CUpdateItem(void)
.text:000002F7                 mov     byte ptr [ebp+var_4], 0
.text:000002FB                 lea     ecx, [ebp+var_20]
.text:000002FE                 call    ??1?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAE@XZ ; CObjectVector<NArchive::NTar::CUpdateItem>::~CObjectVector<NArchive::NTar::CUpdateItem>(void)
.text:00000303                 mov     eax, [ebp+var_124]
.text:00000309                 jmp     loc_A77
.text:0000030E ; ---------------------------------------------------------------------------
.text:0000030E
.text:0000030E loc_30E:                                ; CODE XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+10Fj
.text:0000030E                 mov     esi, esp
.text:00000310                 lea     ecx, [ebp+var_9C]
.text:00000316                 push    ecx
.text:00000317                 lea     edx, [ebp+var_90]
.text:0000031D                 push    edx
.text:0000031E                 lea     eax, [ebp+var_84]
.text:00000324                 push    eax
.text:00000325                 mov     ecx, [ebp+var_2C]
.text:00000328                 push    ecx
.text:00000329                 mov     edx, [ebp+arg_C]
.text:0000032C                 push    edx
.text:0000032D                 mov     eax, [ebp+arg_C]
.text:00000330                 mov     ecx, [eax]
.text:00000332                 mov     edx, [ecx+14h]
.text:00000335                 call    edx
.text:00000337                 cmp     esi, esp
.text:00000339                 call    __RTC_CheckEsp
.text:0000033E                 mov     [ebp+var_174], eax
.text:00000344                 mov     eax, [ebp+var_174]
.text:0000034A                 mov     [ebp+var_A4], eax
.text:00000350                 cmp     [ebp+var_A4], 0
.text:00000357                 jz      short loc_388
.text:00000359                 mov     ecx, [ebp+var_A4]
.text:0000035F                 mov     [ebp+var_128], ecx
.text:00000365                 mov     byte ptr [ebp+var_4], 1
.text:00000369                 lea     ecx, [ebp+var_78] ; this
.text:0000036C                 call    ??1CUpdateItem@NTar@NArchive@@QAE@XZ ; NArchive::NTar::CUpdateItem::~CUpdateItem(void)
.text:00000371                 mov     byte ptr [ebp+var_4], 0
.text:00000375                 lea     ecx, [ebp+var_20]
.text:00000378                 call    ??1?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAE@XZ ; CObjectVector<NArchive::NTar::CUpdateItem>::~CObjectVector<NArchive::NTar::CUpdateItem>(void)
.text:0000037D                 mov     eax, [ebp+var_128]
.text:00000383                 jmp     loc_A77
.text:00000388 ; ---------------------------------------------------------------------------
.text:00000388
.text:00000388 loc_388:                                ; CODE XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+187j
.text:00000388                 mov     edx, [ebp+var_90]
.text:0000038E                 push    edx             ; int
.text:0000038F                 call    ?IntToBool@@YG_NH@Z ; IntToBool(int)
.text:00000394                 mov     [ebp+var_175], al
.text:0000039A                 mov     al, [ebp+var_175]
.text:000003A0                 mov     [ebp+var_5B], al
.text:000003A3                 mov     ecx, [ebp+var_84]
.text:000003A9                 push    ecx             ; int
.text:000003AA                 call    ?IntToBool@@YG_NH@Z ; IntToBool(int)
.text:000003AF                 mov     [ebp+var_176], al
.text:000003B5                 mov     dl, [ebp+var_176]
.text:000003BB                 mov     [ebp+var_5C], dl
.text:000003BE                 mov     eax, [ebp+var_9C]
.text:000003C4                 mov     [ebp+var_78], eax
.text:000003C7                 mov     ecx, [ebp+var_2C]
.text:000003CA                 mov     [ebp+var_74], ecx
.text:000003CD                 mov     edx, [ebp+var_90]
.text:000003D3                 push    edx             ; int
.text:000003D4                 call    ?IntToBool@@YG_NH@Z ; IntToBool(int)
.text:000003D9                 mov     [ebp+var_177], al
.text:000003DF                 movzx   eax, [ebp+var_177]
.text:000003E6                 test    eax, eax
.text:000003E8                 jz      loc_89B
.text:000003EE                 lea     ecx, [ebp+var_B8] ; this
.text:000003F4                 call    ??0CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::CPropVariant(void)
.text:000003F9                 mov     [ebp+var_17C], eax
.text:000003FF                 mov     byte ptr [ebp+var_4], 3
.text:00000403                 mov     esi, esp
.text:00000405                 lea     ecx, [ebp+var_B8]
.text:0000040B                 push    ecx
.text:0000040C                 push    6
.text:0000040E                 mov     edx, [ebp+var_2C]
.text:00000411                 push    edx
.text:00000412                 mov     eax, [ebp+arg_C]
.text:00000415                 push    eax
.text:00000416                 mov     ecx, [ebp+arg_C]
.text:00000419                 mov     edx, [ecx]
.text:0000041B                 mov     eax, [edx+18h]
.text:0000041E                 call    eax
.text:00000420                 cmp     esi, esp
.text:00000422                 call    __RTC_CheckEsp
.text:00000427                 mov     [ebp+var_180], eax
.text:0000042D                 mov     ecx, [ebp+var_180]
.text:00000433                 mov     [ebp+var_C0], ecx
.text:00000439                 cmp     [ebp+var_C0], 0
.text:00000440                 jz      short loc_480
.text:00000442                 mov     edx, [ebp+var_C0]
.text:00000448                 mov     [ebp+var_12C], edx
.text:0000044E                 mov     byte ptr [ebp+var_4], 2
.text:00000452                 lea     ecx, [ebp+var_B8] ; this
.text:00000458                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:0000045D                 mov     byte ptr [ebp+var_4], 1
.text:00000461                 lea     ecx, [ebp+var_78] ; this
.text:00000464                 call    ??1CUpdateItem@NTar@NArchive@@QAE@XZ ; NArchive::NTar::CUpdateItem::~CUpdateItem(void)
.text:00000469                 mov     byte ptr [ebp+var_4], 0
.text:0000046D                 lea     ecx, [ebp+var_20]
.text:00000470                 call    ??1?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAE@XZ ; CObjectVector<NArchive::NTar::CUpdateItem>::~CObjectVector<NArchive::NTar::CUpdateItem>(void)
.text:00000475                 mov     eax, [ebp+var_12C]
.text:0000047B                 jmp     loc_A77
.text:00000480 ; ---------------------------------------------------------------------------
.text:00000480
.text:00000480 loc_480:                                ; CODE XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+270j
.text:00000480                 movzx   eax, [ebp+var_B8]
.text:00000487                 test    eax, eax
.text:00000489                 jnz     short loc_491
.text:0000048B                 mov     [ebp+var_5A], 0
.text:0000048F                 jmp     short loc_4EB
.text:00000491 ; ---------------------------------------------------------------------------
.text:00000491
.text:00000491 loc_491:                                ; CODE XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+2B9j
.text:00000491                 movzx   ecx, [ebp+var_B8]
.text:00000498                 cmp     ecx, 0Bh
.text:0000049B                 jz      short loc_4DB
.text:0000049D                 mov     [ebp+var_130], 80070057h
.text:000004A7                 mov     byte ptr [ebp+var_4], 2
.text:000004AB                 lea     ecx, [ebp+var_B8] ; this
.text:000004B1                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:000004B6                 mov     byte ptr [ebp+var_4], 1
.text:000004BA                 lea     ecx, [ebp+var_78] ; this
.text:000004BD                 call    ??1CUpdateItem@NTar@NArchive@@QAE@XZ ; NArchive::NTar::CUpdateItem::~CUpdateItem(void)
.text:000004C2                 mov     byte ptr [ebp+var_4], 0
.text:000004C6                 lea     ecx, [ebp+var_20]
.text:000004C9                 call    ??1?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAE@XZ ; CObjectVector<NArchive::NTar::CUpdateItem>::~CObjectVector<NArchive::NTar::CUpdateItem>(void)
.text:000004CE                 mov     eax, [ebp+var_130]
.text:000004D4                 jmp     loc_A77
.text:000004D9 ; ---------------------------------------------------------------------------
.text:000004D9                 jmp     short loc_4EB
.text:000004DB ; ---------------------------------------------------------------------------
.text:000004DB
.text:000004DB loc_4DB:                                ; CODE XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+2CBj
.text:000004DB                 movsx   edx, [ebp+var_B0]
.text:000004E2                 neg     edx
.text:000004E4                 sbb     edx, edx
.text:000004E6                 neg     edx
.text:000004E8                 mov     [ebp+var_5A], dl
.text:000004EB
.text:000004EB loc_4EB:                                ; CODE XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+2BFj
.text:000004EB                                         ; NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+309j
.text:000004EB                 mov     byte ptr [ebp+var_4], 2
.text:000004EF                 lea     ecx, [ebp+var_B8] ; this
.text:000004F5                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:000004FA                 lea     ecx, [ebp+var_D4] ; this
.text:00000500                 call    ??0CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::CPropVariant(void)
.text:00000505                 mov     [ebp+var_184], eax
.text:0000050B                 mov     byte ptr [ebp+var_4], 4
.text:0000050F                 mov     esi, esp
.text:00000511                 lea     eax, [ebp+var_D4]
.text:00000517                 push    eax
.text:00000518                 push    35h ; '5'
.text:0000051A                 mov     ecx, [ebp+var_2C]
.text:0000051D                 push    ecx
.text:0000051E                 mov     edx, [ebp+arg_C]
.text:00000521                 push    edx
.text:00000522                 mov     eax, [ebp+arg_C]
.text:00000525                 mov     ecx, [eax]
.text:00000527                 mov     edx, [ecx+18h]
.text:0000052A                 call    edx
.text:0000052C                 cmp     esi, esp
.text:0000052E                 call    __RTC_CheckEsp
.text:00000533                 mov     [ebp+var_188], eax
.text:00000539                 mov     eax, [ebp+var_188]
.text:0000053F                 mov     [ebp+var_DC], eax
.text:00000545                 cmp     [ebp+var_DC], 0
.text:0000054C                 jz      short loc_58C
.text:0000054E                 mov     ecx, [ebp+var_DC]
.text:00000554                 mov     [ebp+var_134], ecx
.text:0000055A                 mov     byte ptr [ebp+var_4], 2
.text:0000055E                 lea     ecx, [ebp+var_D4] ; this
.text:00000564                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:00000569                 mov     byte ptr [ebp+var_4], 1
.text:0000056D                 lea     ecx, [ebp+var_78] ; this
.text:00000570                 call    ??1CUpdateItem@NTar@NArchive@@QAE@XZ ; NArchive::NTar::CUpdateItem::~CUpdateItem(void)
.text:00000575                 mov     byte ptr [ebp+var_4], 0
.text:00000579                 lea     ecx, [ebp+var_20]
.text:0000057C                 call    ??1?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAE@XZ ; CObjectVector<NArchive::NTar::CUpdateItem>::~CObjectVector<NArchive::NTar::CUpdateItem>(void)
.text:00000581                 mov     eax, [ebp+var_134]
.text:00000587                 jmp     loc_A77
.text:0000058C ; ---------------------------------------------------------------------------
.text:0000058C
.text:0000058C loc_58C:                                ; CODE XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+37Cj
.text:0000058C                 movzx   edx, [ebp+var_D4]
.text:00000593                 test    edx, edx
.text:00000595                 jnz     short loc_5B3
.text:00000597                 movzx   eax, [ebp+var_5A]
.text:0000059B                 neg     eax
.text:0000059D                 sbb     eax, eax
.text:0000059F                 and     eax, 0FFFFC000h
.text:000005A4                 add     eax, 8000h
.text:000005A9                 or      eax, 1FFh
.text:000005AE                 mov     [ebp+var_60], eax
.text:000005B1                 jmp     short loc_606
.text:000005B3 ; ---------------------------------------------------------------------------
.text:000005B3
.text:000005B3 loc_5B3:                                ; CODE XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+3C5j
.text:000005B3                 movzx   ecx, [ebp+var_D4]
.text:000005BA                 cmp     ecx, 13h
.text:000005BD                 jz      short loc_5FD
.text:000005BF                 mov     [ebp+var_138], 80070057h
.text:000005C9                 mov     byte ptr [ebp+var_4], 2
.text:000005CD                 lea     ecx, [ebp+var_D4] ; this
.text:000005D3                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:000005D8                 mov     byte ptr [ebp+var_4], 1
.text:000005DC                 lea     ecx, [ebp+var_78] ; this
.text:000005DF                 call    ??1CUpdateItem@NTar@NArchive@@QAE@XZ ; NArchive::NTar::CUpdateItem::~CUpdateItem(void)
.text:000005E4                 mov     byte ptr [ebp+var_4], 0
.text:000005E8                 lea     ecx, [ebp+var_20]
.text:000005EB                 call    ??1?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAE@XZ ; CObjectVector<NArchive::NTar::CUpdateItem>::~CObjectVector<NArchive::NTar::CUpdateItem>(void)
.text:000005F0                 mov     eax, [ebp+var_138]
.text:000005F6                 jmp     loc_A77
.text:000005FB ; ---------------------------------------------------------------------------
.text:000005FB                 jmp     short loc_606
.text:000005FD ; ---------------------------------------------------------------------------
.text:000005FD
.text:000005FD loc_5FD:                                ; CODE XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+3EDj
.text:000005FD                 mov     edx, [ebp+var_CC]
.text:00000603                 mov     [ebp+var_60], edx
.text:00000606
.text:00000606 loc_606:                                ; CODE XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+3E1j
.text:00000606                                         ; NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+42Bj
.text:00000606                 mov     byte ptr [ebp+var_4], 2
.text:0000060A                 lea     ecx, [ebp+var_D4] ; this
.text:00000610                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:00000615                 lea     ecx, [ebp+var_F0] ; this
.text:0000061B                 call    ??0CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::CPropVariant(void)
.text:00000620                 mov     [ebp+var_18C], eax
.text:00000626                 mov     byte ptr [ebp+var_4], 5
.text:0000062A                 mov     esi, esp
.text:0000062C                 lea     eax, [ebp+var_F0]
.text:00000632                 push    eax
.text:00000633                 push    0Ch
.text:00000635                 mov     ecx, [ebp+var_2C]
.text:00000638                 push    ecx
.text:00000639                 mov     edx, [ebp+arg_C]
.text:0000063C                 push    edx
.text:0000063D                 mov     eax, [ebp+arg_C]
.text:00000640                 mov     ecx, [eax]
.text:00000642                 mov     edx, [ecx+18h]
.text:00000645                 call    edx
.text:00000647                 cmp     esi, esp
.text:00000649                 call    __RTC_CheckEsp
.text:0000064E                 mov     [ebp+var_190], eax
.text:00000654                 mov     eax, [ebp+var_190]
.text:0000065A                 mov     [ebp+var_F8], eax
.text:00000660                 cmp     [ebp+var_F8], 0
.text:00000667                 jz      short loc_6A7
.text:00000669                 mov     ecx, [ebp+var_F8]
.text:0000066F                 mov     [ebp+var_13C], ecx
.text:00000675                 mov     byte ptr [ebp+var_4], 2
.text:00000679                 lea     ecx, [ebp+var_F0] ; this
.text:0000067F                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:00000684                 mov     byte ptr [ebp+var_4], 1
.text:00000688                 lea     ecx, [ebp+var_78] ; this
.text:0000068B                 call    ??1CUpdateItem@NTar@NArchive@@QAE@XZ ; NArchive::NTar::CUpdateItem::~CUpdateItem(void)
.text:00000690                 mov     byte ptr [ebp+var_4], 0
.text:00000694                 lea     ecx, [ebp+var_20]
.text:00000697                 call    ??1?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAE@XZ ; CObjectVector<NArchive::NTar::CUpdateItem>::~CObjectVector<NArchive::NTar::CUpdateItem>(void)
.text:0000069C                 mov     eax, [ebp+var_13C]
.text:000006A2                 jmp     loc_A77
.text:000006A7 ; ---------------------------------------------------------------------------
.text:000006A7
.text:000006A7 loc_6A7:                                ; CODE XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+497j
.text:000006A7                 movzx   edx, [ebp+var_F0]
.text:000006AE                 test    edx, edx
.text:000006B0                 jnz     short loc_6C2
.text:000006B2                 mov     [ebp+var_70], 0
.text:000006B9                 mov     [ebp+var_6C], 0
.text:000006C0                 jmp     short loc_71E
.text:000006C2 ; ---------------------------------------------------------------------------
.text:000006C2
.text:000006C2 loc_6C2:                                ; CODE XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+4E0j
.text:000006C2                 movzx   eax, [ebp+var_F0]
.text:000006C9                 cmp     eax, 40h ; '@'
.text:000006CC                 jz      short loc_70C
.text:000006CE                 mov     [ebp+var_140], 80070057h
.text:000006D8                 mov     byte ptr [ebp+var_4], 2
.text:000006DC                 lea     ecx, [ebp+var_F0] ; this
.text:000006E2                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:000006E7                 mov     byte ptr [ebp+var_4], 1
.text:000006EB                 lea     ecx, [ebp+var_78] ; this
.text:000006EE                 call    ??1CUpdateItem@NTar@NArchive@@QAE@XZ ; NArchive::NTar::CUpdateItem::~CUpdateItem(void)
.text:000006F3                 mov     byte ptr [ebp+var_4], 0
.text:000006F7                 lea     ecx, [ebp+var_20]
.text:000006FA                 call    ??1?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAE@XZ ; CObjectVector<NArchive::NTar::CUpdateItem>::~CObjectVector<NArchive::NTar::CUpdateItem>(void)
.text:000006FF                 mov     eax, [ebp+var_140]
.text:00000705                 jmp     loc_A77
.text:0000070A ; ---------------------------------------------------------------------------
.text:0000070A                 jmp     short loc_71E
.text:0000070C ; ---------------------------------------------------------------------------
.text:0000070C
.text:0000070C loc_70C:                                ; CODE XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+4FCj
.text:0000070C                 lea     ecx, [ebp+var_E8]
.text:00000712                 push    ecx             ; bool
.text:00000713                 call    ?FileTimeToUnixTime64@NTime@NWindows@@YG_JABU_FILETIME@@@Z ; NWindows::NTime::FileTimeToUnixTime64(_FILETIME const &)
.text:00000718                 mov     [ebp+var_70], eax
.text:0000071B                 mov     [ebp+var_6C], edx
.text:0000071E
.text:0000071E loc_71E:                                ; CODE XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+4F0j
.text:0000071E                                         ; NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+53Aj
.text:0000071E                 mov     byte ptr [ebp+var_4], 2
.text:00000722                 lea     ecx, [ebp+var_F0] ; this
.text:00000728                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:0000072D                 push    1               ; char
.text:0000072F                 mov     edx, [ebp+var_28]
.text:00000732                 push    edx             ; struct AString *
.text:00000733                 lea     eax, [ebp+var_58]
.text:00000736                 push    eax             ; struct AString *
.text:00000737                 push    3               ; unsigned int
.text:00000739                 mov     ecx, [ebp+var_2C]
.text:0000073C                 push    ecx             ; struct IArchiveUpdateCallback *
.text:0000073D                 mov     edx, [ebp+arg_C]
.text:00000740                 push    edx             ; this
.text:00000741                 call    ?GetPropString@NTar@NArchive@@YGJPAUIArchiveUpdateCallback@@IKAAVAString@@I_N@Z ; NArchive::NTar::GetPropString(IArchiveUpdateCallback *,uint,ulong,AString &,uint,bool)
.text:00000746                 mov     [ebp+var_194], eax
.text:0000074C                 mov     eax, [ebp+var_194]
.text:00000752                 mov     [ebp+var_FC], eax
.text:00000758                 cmp     [ebp+var_FC], 0
.text:0000075F                 jz      short loc_790
.text:00000761                 mov     ecx, [ebp+var_FC]
.text:00000767                 mov     [ebp+var_144], ecx
.text:0000076D                 mov     byte ptr [ebp+var_4], 1
.text:00000771                 lea     ecx, [ebp+var_78] ; this
.text:00000774                 call    ??1CUpdateItem@NTar@NArchive@@QAE@XZ ; NArchive::NTar::CUpdateItem::~CUpdateItem(void)
.text:00000779                 mov     byte ptr [ebp+var_4], 0
.text:0000077D                 lea     ecx, [ebp+var_20]
.text:00000780                 call    ??1?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAE@XZ ; CObjectVector<NArchive::NTar::CUpdateItem>::~CObjectVector<NArchive::NTar::CUpdateItem>(void)
.text:00000785                 mov     eax, [ebp+var_144]
.text:0000078B                 jmp     loc_A77
.text:00000790 ; ---------------------------------------------------------------------------
.text:00000790
.text:00000790 loc_790:                                ; CODE XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+58Fj
.text:00000790                 movzx   edx, [ebp+var_5A]
.text:00000794                 test    edx, edx
.text:00000796                 jz      short loc_7D5
.text:00000798                 lea     ecx, [ebp+var_58] ; this
.text:0000079B                 call    ?IsEmpty@AString@@QBE_NXZ ; AString::IsEmpty(void)
.text:000007A0                 mov     [ebp+var_195], al
.text:000007A6                 movzx   eax, [ebp+var_195]
.text:000007AD                 test    eax, eax
.text:000007AF                 jnz     short loc_7D5
.text:000007B1                 lea     ecx, [ebp+var_58] ; this
.text:000007B4                 call    ?Back@AString@@QBEDXZ ; AString::Back(void)
.text:000007B9                 mov     [ebp+var_196], al
.text:000007BF                 movsx   ecx, [ebp+var_196]
.text:000007C6                 cmp     ecx, 2Fh ; '/'
.text:000007C9                 jz      short loc_7D5
.text:000007CB                 push    2Fh ; '/'
.text:000007CD                 lea     ecx, [ebp+var_58]
.text:000007D0                 call    ??YAString@@QAEAAV0@D@Z ; AString::operator+=(char)
.text:000007D5
.text:000007D5 loc_7D5:                                ; CODE XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+5C6j
.text:000007D5                                         ; NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+5DFj ...
.text:000007D5                 push    0               ; char
.text:000007D7                 mov     edx, [ebp+var_28]
.text:000007DA                 push    edx             ; struct AString *
.text:000007DB                 lea     eax, [ebp+var_4C]
.text:000007DE                 push    eax             ; struct AString *
.text:000007DF                 push    19h             ; unsigned int
.text:000007E1                 mov     ecx, [ebp+var_2C]
.text:000007E4                 push    ecx             ; struct IArchiveUpdateCallback *
.text:000007E5                 mov     edx, [ebp+arg_C]
.text:000007E8                 push    edx             ; this
.text:000007E9                 call    ?GetPropString@NTar@NArchive@@YGJPAUIArchiveUpdateCallback@@IKAAVAString@@I_N@Z ; NArchive::NTar::GetPropString(IArchiveUpdateCallback *,uint,ulong,AString &,uint,bool)
.text:000007EE                 mov     [ebp+var_19C], eax
.text:000007F4                 mov     eax, [ebp+var_19C]
.text:000007FA                 mov     [ebp+var_100], eax
.text:00000800                 cmp     [ebp+var_100], 0
.text:00000807                 jz      short loc_838
.text:00000809                 mov     ecx, [ebp+var_100]
.text:0000080F                 mov     [ebp+var_148], ecx
.text:00000815                 mov     byte ptr [ebp+var_4], 1
.text:00000819                 lea     ecx, [ebp+var_78] ; this
.text:0000081C                 call    ??1CUpdateItem@NTar@NArchive@@QAE@XZ ; NArchive::NTar::CUpdateItem::~CUpdateItem(void)
.text:00000821                 mov     byte ptr [ebp+var_4], 0
.text:00000825                 lea     ecx, [ebp+var_20]
.text:00000828                 call    ??1?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAE@XZ ; CObjectVector<NArchive::NTar::CUpdateItem>::~CObjectVector<NArchive::NTar::CUpdateItem>(void)
.text:0000082D                 mov     eax, [ebp+var_148]
.text:00000833                 jmp     loc_A77
.text:00000838 ; ---------------------------------------------------------------------------
.text:00000838
.text:00000838 loc_838:                                ; CODE XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+637j
.text:00000838                 push    0               ; char
.text:0000083A                 mov     edx, [ebp+var_28]
.text:0000083D                 push    edx             ; struct AString *
.text:0000083E                 lea     eax, [ebp+var_40]
.text:00000841                 push    eax             ; struct AString *
.text:00000842                 push    1Ah             ; unsigned int
.text:00000844                 mov     ecx, [ebp+var_2C]
.text:00000847                 push    ecx             ; struct IArchiveUpdateCallback *
.text:00000848                 mov     edx, [ebp+arg_C]
.text:0000084B                 push    edx             ; this
.text:0000084C                 call    ?GetPropString@NTar@NArchive@@YGJPAUIArchiveUpdateCallback@@IKAAVAString@@I_N@Z ; NArchive::NTar::GetPropString(IArchiveUpdateCallback *,uint,ulong,AString &,uint,bool)
.text:00000851                 mov     [ebp+var_1A0], eax
.text:00000857                 mov     eax, [ebp+var_1A0]
.text:0000085D                 mov     [ebp+var_104], eax
.text:00000863                 cmp     [ebp+var_104], 0
.text:0000086A                 jz      short loc_89B
.text:0000086C                 mov     ecx, [ebp+var_104]
.text:00000872                 mov     [ebp+var_14C], ecx
.text:00000878                 mov     byte ptr [ebp+var_4], 1
.text:0000087C                 lea     ecx, [ebp+var_78] ; this
.text:0000087F                 call    ??1CUpdateItem@NTar@NArchive@@QAE@XZ ; NArchive::NTar::CUpdateItem::~CUpdateItem(void)
.text:00000884                 mov     byte ptr [ebp+var_4], 0
.text:00000888                 lea     ecx, [ebp+var_20]
.text:0000088B                 call    ??1?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAE@XZ ; CObjectVector<NArchive::NTar::CUpdateItem>::~CObjectVector<NArchive::NTar::CUpdateItem>(void)
.text:00000890                 mov     eax, [ebp+var_14C]
.text:00000896                 jmp     loc_A77
.text:0000089B ; ---------------------------------------------------------------------------
.text:0000089B
.text:0000089B loc_89B:                                ; CODE XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+218j
.text:0000089B                                         ; NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+69Aj
.text:0000089B                 mov     edx, [ebp+var_84]
.text:000008A1                 push    edx             ; int
.text:000008A2                 call    ?IntToBool@@YG_NH@Z ; IntToBool(int)
.text:000008A7                 mov     [ebp+var_1A1], al
.text:000008AD                 movzx   eax, [ebp+var_1A1]
.text:000008B4                 test    eax, eax
.text:000008B6                 jz      loc_9B7
.text:000008BC                 lea     ecx, [ebp+var_118] ; this
.text:000008C2                 call    ??0CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::CPropVariant(void)
.text:000008C7                 mov     [ebp+var_1A8], eax
.text:000008CD                 mov     byte ptr [ebp+var_4], 6
.text:000008D1                 mov     esi, esp
.text:000008D3                 lea     ecx, [ebp+var_118]
.text:000008D9                 push    ecx
.text:000008DA                 push    7
.text:000008DC                 mov     edx, [ebp+var_2C]
.text:000008DF                 push    edx
.text:000008E0                 mov     eax, [ebp+arg_C]
.text:000008E3                 push    eax
.text:000008E4                 mov     ecx, [ebp+arg_C]
.text:000008E7                 mov     edx, [ecx]
.text:000008E9                 mov     eax, [edx+18h]
.text:000008EC                 call    eax
.text:000008EE                 cmp     esi, esp
.text:000008F0                 call    __RTC_CheckEsp
.text:000008F5                 mov     [ebp+var_1AC], eax
.text:000008FB                 mov     ecx, [ebp+var_1AC]
.text:00000901                 mov     [ebp+var_120], ecx
.text:00000907                 cmp     [ebp+var_120], 0
.text:0000090E                 jz      short loc_94E
.text:00000910                 mov     edx, [ebp+var_120]
.text:00000916                 mov     [ebp+var_150], edx
.text:0000091C                 mov     byte ptr [ebp+var_4], 2
.text:00000920                 lea     ecx, [ebp+var_118] ; this
.text:00000926                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:0000092B                 mov     byte ptr [ebp+var_4], 1
.text:0000092F                 lea     ecx, [ebp+var_78] ; this
.text:00000932                 call    ??1CUpdateItem@NTar@NArchive@@QAE@XZ ; NArchive::NTar::CUpdateItem::~CUpdateItem(void)
.text:00000937                 mov     byte ptr [ebp+var_4], 0
.text:0000093B                 lea     ecx, [ebp+var_20]
.text:0000093E                 call    ??1?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAE@XZ ; CObjectVector<NArchive::NTar::CUpdateItem>::~CObjectVector<NArchive::NTar::CUpdateItem>(void)
.text:00000943                 mov     eax, [ebp+var_150]
.text:00000949                 jmp     loc_A77
.text:0000094E ; ---------------------------------------------------------------------------
.text:0000094E
.text:0000094E loc_94E:                                ; CODE XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+73Ej
.text:0000094E                 movzx   eax, [ebp+var_118]
.text:00000955                 cmp     eax, 15h
.text:00000958                 jz      short loc_996
.text:0000095A                 mov     [ebp+var_154], 80070057h
.text:00000964                 mov     byte ptr [ebp+var_4], 2
.text:00000968                 lea     ecx, [ebp+var_118] ; this
.text:0000096E                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:00000973                 mov     byte ptr [ebp+var_4], 1
.text:00000977                 lea     ecx, [ebp+var_78] ; this
.text:0000097A                 call    ??1CUpdateItem@NTar@NArchive@@QAE@XZ ; NArchive::NTar::CUpdateItem::~CUpdateItem(void)
.text:0000097F                 mov     byte ptr [ebp+var_4], 0
.text:00000983                 lea     ecx, [ebp+var_20]
.text:00000986                 call    ??1?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAE@XZ ; CObjectVector<NArchive::NTar::CUpdateItem>::~CObjectVector<NArchive::NTar::CUpdateItem>(void)
.text:0000098B                 mov     eax, [ebp+var_154]
.text:00000991                 jmp     loc_A77
.text:00000996 ; ---------------------------------------------------------------------------
.text:00000996
.text:00000996 loc_996:                                ; CODE XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+788j
.text:00000996                 mov     ecx, [ebp+var_110]
.text:0000099C                 mov     [ebp+var_68], ecx
.text:0000099F                 mov     edx, [ebp+var_10C]
.text:000009A5                 mov     [ebp+var_64], edx
.text:000009A8                 mov     byte ptr [ebp+var_4], 2
.text:000009AC                 lea     ecx, [ebp+var_118] ; this
.text:000009B2                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:000009B7
.text:000009B7 loc_9B7:                                ; CODE XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+6E6j
.text:000009B7                 lea     eax, [ebp+var_78]
.text:000009BA                 push    eax             ; struct NArchive::NTar::CUpdateItem *
.text:000009BB                 lea     ecx, [ebp+var_20]
.text:000009BE                 call    ?Add@?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAEIABUCUpdateItem@NTar@NArchive@@@Z ; CObjectVector<NArchive::NTar::CUpdateItem>::Add(NArchive::NTar::CUpdateItem const &)
.text:000009C3                 mov     byte ptr [ebp+var_4], 1
.text:000009C7                 lea     ecx, [ebp+var_78] ; this
.text:000009CA                 call    ??1CUpdateItem@NTar@NArchive@@QAE@XZ ; NArchive::NTar::CUpdateItem::~CUpdateItem(void)
.text:000009CF                 jmp     loc_2B4
.text:000009D4 ; ---------------------------------------------------------------------------
.text:000009D4
.text:000009D4 loc_9D4:                                ; CODE XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+F3j
.text:000009D4                 mov     ecx, [ebp+this]
.text:000009D7                 movzx   edx, byte ptr [ecx+0C9h]
.text:000009DE                 test    edx, edx
.text:000009E0                 jz      short loc_9F1
.text:000009E2                 push    0
.text:000009E4                 push    offset ?CompareUpdateItems@NTar@NArchive@@YGHPBQAX0PAX@Z ; NArchive::NTar::CompareUpdateItems(void * const *,void * const *,void *)
.text:000009E9                 lea     ecx, [ebp+var_20]
.text:000009EC                 call    ?Sort@?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAEXP6GHPBQAX0PAX@Z1@Z ; CObjectVector<NArchive::NTar::CUpdateItem>::Sort(int (*)(void * const *,void * const *,void *),void *)
.text:000009F1
.text:000009F1 loc_9F1:                                ; CODE XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+810j
.text:000009F1                 mov     ecx, [ebp+this]
.text:000009F4                 add     ecx, 14h
.text:000009F7                 call    ??B?$CMyComPtr@UIInStream@@@@QBEPAUIInStream@@XZ ; CMyComPtr<IInStream>::operator IInStream *(void)
.text:000009FC                 mov     [ebp+var_1B0], eax
.text:00000A02                 mov     eax, [ebp+arg_C]
.text:00000A05                 push    eax
.text:00000A06                 mov     ecx, [ebp+var_28]
.text:00000A09                 push    ecx
.text:00000A0A                 lea     edx, [ebp+var_20]
.text:00000A0D                 push    edx
.text:00000A0E                 mov     eax, [ebp+this]
.text:00000A11                 add     eax, 8
.text:00000A14                 push    eax
.text:00000A15                 mov     ecx, [ebp+arg_4]
.text:00000A18                 push    ecx
.text:00000A19                 mov     edx, [ebp+var_1B0]
.text:00000A1F                 push    edx
.text:00000A20                 call    ?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z ; NArchive::NTar::UpdateArchive(IInStream *,ISequentialOutStream *,CObjectVector<NArchive::NTar::CItemEx> const &,CObjectVector<NArchive::NTar::CUpdateItem> const &,uint,IArchiveUpdateCallback *)
.text:00000A25                 mov     [ebp+var_1B4], eax
.text:00000A2B                 mov     eax, [ebp+var_1B4]
.text:00000A31                 mov     [ebp+var_158], eax
.text:00000A37                 mov     byte ptr [ebp+var_4], 0
.text:00000A3B                 lea     ecx, [ebp+var_20]
.text:00000A3E                 call    ??1?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAE@XZ ; CObjectVector<NArchive::NTar::CUpdateItem>::~CObjectVector<NArchive::NTar::CUpdateItem>(void)
.text:00000A43                 mov     eax, [ebp+var_158]
.text:00000A49                 jmp     short loc_A77
.text:00000A49 ?UpdateItems@CHandler@NTar@NArchive@@UAGJPAUISequentialOutStream@@IPAUIArchiveUpdateCallback@@@Z endp ; sp-analysis failed
.text:00000A49
.text:00000A4B
.text:00000A4B ; =============== S U B R O U T I N E =======================================
.text:00000A4B
.text:00000A4B
.text:00000A4B __catch$?UpdateItems@CHandler@NTar@NArchive@@UAGJPAUISequentialOutStream@@IPAUIArchiveUpdateCallback@@@Z$0 proc near
.text:00000A4B                                         ; DATA XREF: .xdata$x:00000CD8o
.text:00000A4B                 mov     dword ptr [ebp-15Ch], 8007000Eh
.text:00000A55                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text:00000A5C                 mov     eax, offset $LN47
.text:00000A61                 retn
.text:00000A61 __catch$?UpdateItems@CHandler@NTar@NArchive@@UAGJPAUISequentialOutStream@@IPAUIArchiveUpdateCallback@@@Z$0 endp
.text:00000A61
.text:00000A62 ; ---------------------------------------------------------------------------
.text:00000A62                 mov     eax, offset __tryend$?UpdateItems@CHandler@NTar@NArchive@@UAGJPAUISequentialOutStream@@IPAUIArchiveUpdateCallback@@@Z$1
.text:00000A67                 retn
.text:00000A68 ; ---------------------------------------------------------------------------
.text:00000A68
.text:00000A68 __tryend$?UpdateItems@CHandler@NTar@NArchive@@UAGJPAUISequentialOutStream@@IPAUIArchiveUpdateCallback@@@Z$1:
.text:00000A68                                         ; DATA XREF: .text:00000A62o
.text:00000A68                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text:00000A6F                 jmp     short loc_A77
.text:00000A71 ; ---------------------------------------------------------------------------
.text:00000A71
.text:00000A71 $LN47:                                  ; DATA XREF: __catch$?UpdateItems@CHandler@NTar@NArchive@@UAGJPAUISequentialOutStream@@IPAUIArchiveUpdateCallback@@@Z$0+11o
.text:00000A71                 mov     eax, [ebp-15Ch]
.text:00000A77 ; START OF FUNCTION CHUNK FOR ?UpdateItems@CHandler@NTar@NArchive@@UAGJPAUISequentialOutStream@@IPAUIArchiveUpdateCallback@@@Z
.text:00000A77
.text:00000A77 loc_A77:                                ; CODE XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+8Dj
.text:00000A77                                         ; NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+139j ...
.text:00000A77                 push    edx
.text:00000A78                 mov     ecx, ebp
.text:00000A7A                 push    eax
.text:00000A7B                 lea     edx, $LN60
.text:00000A81                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00000A86                 pop     eax
.text:00000A87                 pop     edx
.text:00000A88                 mov     ecx, [ebp+var_C]
.text:00000A8B                 mov     large fs:0, ecx
.text:00000A92                 pop     ecx
.text:00000A93                 pop     edi
.text:00000A94                 pop     esi
.text:00000A95                 pop     ebx
.text:00000A96                 add     esp, 1B4h
.text:00000A9C                 cmp     ebp, esp
.text:00000A9E                 call    __RTC_CheckEsp
.text:00000AA3                 mov     esp, ebp
.text:00000AA5                 pop     ebp
.text:00000AA6                 retn    10h
.text:00000AA6 ; END OF FUNCTION CHUNK FOR ?UpdateItems@CHandler@NTar@NArchive@@UAGJPAUISequentialOutStream@@IPAUIArchiveUpdateCallback@@@Z
.text:00000AA6 ; ---------------------------------------------------------------------------
.text:00000AA9                 align 4
.text:00000AAC $LN60           dd 9                    ; DATA XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+8ABo
.text:00000AB0                 dd offset $LN59
.text:00000AB4 $LN59           dd 0FFFFFFE0h, 0Ch      ; DATA XREF: .text:00000AB0o
.text:00000ABC                 dd offset $LN49         ; "updateItems"
.text:00000AC0                 db 88h, 0FFh
.text:00000AC2                 dw 0FFFFh
.text:00000AC4                 dd offset loc_45+3
.text:00000AC8                 dd offset $LN50         ; "ui"
.text:00000ACC                 dd 0FFFFFF7Ch, 4
.text:00000AD4                 dd offset $LN51         ; "newData"
.text:00000AD8                 dd 0FFFFFF70h, 4
.text:00000AE0                 dd offset $LN52         ; "newProps"
.text:00000AE4                 dd 0FFFFFF64h, 4
.text:00000AEC                 dd offset $LN53         ; "indexInArchive"
.text:00000AF0                 dd 0FFFFFF48h, 10h
.text:00000AF8                 dd offset $LN54         ; "prop"
.text:00000AFC                 dd 0FFFFFF2Ch, 10h
.text:00000B04                 dd offset $LN55         ; "prop"
.text:00000B08                 dd 0FFFFFF10h, 10h
.text:00000B10                 dd offset $LN56         ; "prop"
.text:00000B14                 dd 0FFFFFEE8h, 10h
.text:00000B1C                 dd offset $LN57         ; "prop"
.text:00000B20 $LN57           db 'prop',0             ; DATA XREF: .text:00000B1Co
.text:00000B25 $LN56           db 'prop',0             ; DATA XREF: .text:00000B10o
.text:00000B2A $LN55           db 'prop',0             ; DATA XREF: .text:00000B04o
.text:00000B2F $LN54           db 'prop',0             ; DATA XREF: .text:00000AF8o
.text:00000B34 $LN53           db 'indexInArchive',0   ; DATA XREF: .text:00000AECo
.text:00000B43 $LN52           db 'newProps',0         ; DATA XREF: .text:00000AE0o
.text:00000B4C $LN51           db 'newData',0          ; DATA XREF: .text:00000AD4o
.text:00000B54 $LN50           db 'ui',0               ; DATA XREF: .text:00000AC8o
.text:00000B57 $LN49           db 'updateItems',0      ; DATA XREF: .text:00000ABCo
.text:00000B63                 align 10h
.text:00000B70
.text:00000B70 ; =============== S U B R O U T I N E =======================================
.text:00000B70
.text:00000B70 ; Attributes: bp-based frame
.text:00000B70
.text:00000B70 ; int __stdcall NArchive::NTar::CompareUpdateItems(void * const *, void * const *, void *)
.text:00000B70 ?CompareUpdateItems@NTar@NArchive@@YGHPBQAX0PAX@Z proc near
.text:00000B70                                         ; DATA XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+814o
.text:00000B70
.text:00000B70 var_8           = dword ptr -8
.text:00000B70 var_4           = dword ptr -4
.text:00000B70 arg_0           = dword ptr  8
.text:00000B70 arg_4           = dword ptr  0Ch
.text:00000B70
.text:00000B70                 push    ebp
.text:00000B71                 mov     ebp, esp
.text:00000B73                 sub     esp, 8
.text:00000B76                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00000B7D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000B84                 mov     eax, [ebp+arg_0]
.text:00000B87                 mov     ecx, [eax]
.text:00000B89                 mov     [ebp+var_4], ecx
.text:00000B8C                 mov     edx, [ebp+arg_4]
.text:00000B8F                 mov     eax, [edx]
.text:00000B91                 mov     [ebp+var_8], eax
.text:00000B94                 mov     ecx, [ebp+var_4]
.text:00000B97                 movzx   edx, byte ptr [ecx+1Dh]
.text:00000B9B                 test    edx, edx
.text:00000B9D                 jnz     short loc_BC2
.text:00000B9F                 mov     eax, [ebp+var_8]
.text:00000BA2                 movzx   ecx, byte ptr [eax+1Dh]
.text:00000BA6                 test    ecx, ecx
.text:00000BA8                 jz      short loc_BAF
.text:00000BAA                 or      eax, 0FFFFFFFFh
.text:00000BAD                 jmp     short loc_BE7
.text:00000BAF ; ---------------------------------------------------------------------------
.text:00000BAF
.text:00000BAF loc_BAF:                                ; CODE XREF: NArchive::NTar::CompareUpdateItems(void * const *,void * const *,void *)+38j
.text:00000BAF                 mov     edx, [ebp+var_8]
.text:00000BB2                 mov     eax, [edx]
.text:00000BB4                 push    eax
.text:00000BB5                 mov     ecx, [ebp+var_4]
.text:00000BB8                 mov     edx, [ecx]
.text:00000BBA                 push    edx
.text:00000BBB                 call    ??$MyCompare@H@@YGHHH@Z ; MyCompare<int>(int,int)
.text:00000BC0                 jmp     short loc_BE7
.text:00000BC2 ; ---------------------------------------------------------------------------
.text:00000BC2
.text:00000BC2 loc_BC2:                                ; CODE XREF: NArchive::NTar::CompareUpdateItems(void * const *,void * const *,void *)+2Dj
.text:00000BC2                 mov     eax, [ebp+var_8]
.text:00000BC5                 movzx   ecx, byte ptr [eax+1Dh]
.text:00000BC9                 test    ecx, ecx
.text:00000BCB                 jnz     short loc_BD4
.text:00000BCD                 mov     eax, 1
.text:00000BD2                 jmp     short loc_BE7
.text:00000BD4 ; ---------------------------------------------------------------------------
.text:00000BD4
.text:00000BD4 loc_BD4:                                ; CODE XREF: NArchive::NTar::CompareUpdateItems(void * const *,void * const *,void *)+5Bj
.text:00000BD4                 mov     edx, [ebp+var_8]
.text:00000BD7                 mov     eax, [edx+4]
.text:00000BDA                 push    eax
.text:00000BDB                 mov     ecx, [ebp+var_4]
.text:00000BDE                 mov     edx, [ecx+4]
.text:00000BE1                 push    edx
.text:00000BE2                 call    ??$MyCompare@H@@YGHHH@Z ; MyCompare<int>(int,int)
.text:00000BE7
.text:00000BE7 loc_BE7:                                ; CODE XREF: NArchive::NTar::CompareUpdateItems(void * const *,void * const *,void *)+3Dj
.text:00000BE7                                         ; NArchive::NTar::CompareUpdateItems(void * const *,void * const *,void *)+50j ...
.text:00000BE7                 add     esp, 8
.text:00000BEA                 cmp     ebp, esp
.text:00000BEC                 call    __RTC_CheckEsp
.text:00000BF1                 mov     esp, ebp
.text:00000BF3                 pop     ebp
.text:00000BF4                 retn    0Ch
.text:00000BF4 ?CompareUpdateItems@NTar@NArchive@@YGHPBQAX0PAX@Z endp
.text:00000BF4
.text:00000BF4 ; ---------------------------------------------------------------------------
.text:00000BF7                 align 4
.text:00000BF7 _text           ends
.text:00000BF7
.rtc$TMZ:00000BF8 ; ===========================================================================
.rtc$TMZ:00000BF8
.rtc$TMZ:00000BF8 ; Segment type: Pure data
.rtc$TMZ:00000BF8 ; Segment permissions: Read
.rtc$TMZ:00000BF8 _rtc$TMZ        segment dword public 'DATA' use32
.rtc$TMZ:00000BF8                 assume cs:_rtc$TMZ
.rtc$TMZ:00000BF8                 ;org 0BF8h
.rtc$TMZ:00000BF8 ; COMDAT (pick any)
.rtc$TMZ:00000BF8 __RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
.rtc$TMZ:00000BF8 _rtc$TMZ        ends
.rtc$TMZ:00000BF8
.rtc$IMZ:00000BFC ; ===========================================================================
.rtc$IMZ:00000BFC
.rtc$IMZ:00000BFC ; Segment type: Pure data
.rtc$IMZ:00000BFC ; Segment permissions: Read
.rtc$IMZ:00000BFC _rtc$IMZ        segment dword public 'DATA' use32
.rtc$IMZ:00000BFC                 assume cs:_rtc$IMZ
.rtc$IMZ:00000BFC                 ;org 0BFCh
.rtc$IMZ:00000BFC ; COMDAT (pick any)
.rtc$IMZ:00000BFC __RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
.rtc$IMZ:00000BFC _rtc$IMZ        ends
.rtc$IMZ:00000BFC
.text$x:00000C00 ; ===========================================================================
.text$x:00000C00
.text$x:00000C00 ; Segment type: Pure code
.text$x:00000C00 ; Segment permissions: Read/Execute
.text$x:00000C00 _text$x         segment para public 'CODE' use32
.text$x:00000C00                 assume cs:_text$x
.text$x:00000C00                 ;org 0C00h
.text$x:00000C00                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text$x:00000C00
.text$x:00000C00 ; =============== S U B R O U T I N E =======================================
.text$x:00000C00
.text$x:00000C00
.text$x:00000C00 __unwindfunclet$?GetPropString@NTar@NArchive@@YGJPAUIArchiveUpdateCallback@@IKAAVAString@@I_N@Z$0 proc near
.text$x:00000C00                                         ; DATA XREF: .xdata$x:00000C94o
.text$x:00000C00                 lea     ecx, [ebp-20h]  ; this
.text$x:00000C03                 jmp     ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text$x:00000C03 __unwindfunclet$?GetPropString@NTar@NArchive@@YGJPAUIArchiveUpdateCallback@@IKAAVAString@@I_N@Z$0 endp
.text$x:00000C03
.text$x:00000C08
.text$x:00000C08 ; =============== S U B R O U T I N E =======================================
.text$x:00000C08
.text$x:00000C08
.text$x:00000C08 __unwindfunclet$?GetPropString@NTar@NArchive@@YGJPAUIArchiveUpdateCallback@@IKAAVAString@@I_N@Z$1 proc near
.text$x:00000C08                                         ; DATA XREF: .xdata$x:00000C9Co
.text$x:00000C08                 lea     ecx, [ebp-38h]  ; this
.text$x:00000C0B                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00000C0B __unwindfunclet$?GetPropString@NTar@NArchive@@YGJPAUIArchiveUpdateCallback@@IKAAVAString@@I_N@Z$1 endp
.text$x:00000C0B
.text$x:00000C10
.text$x:00000C10 ; =============== S U B R O U T I N E =======================================
.text$x:00000C10
.text$x:00000C10
.text$x:00000C10 __unwindfunclet$?GetPropString@NTar@NArchive@@YGJPAUIArchiveUpdateCallback@@IKAAVAString@@I_N@Z$2 proc near
.text$x:00000C10                                         ; DATA XREF: .xdata$x:00000CA4o
.text$x:00000C10                 lea     ecx, [ebp-4Ch]  ; this
.text$x:00000C13                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00000C13 __unwindfunclet$?GetPropString@NTar@NArchive@@YGJPAUIArchiveUpdateCallback@@IKAAVAString@@I_N@Z$2 endp
.text$x:00000C13
.text$x:00000C18
.text$x:00000C18 ; =============== S U B R O U T I N E =======================================
.text$x:00000C18
.text$x:00000C18
.text$x:00000C18 __ehhandler$?GetPropString@NTar@NArchive@@YGJPAUIArchiveUpdateCallback@@IKAAVAString@@I_N@Z proc near
.text$x:00000C18                                         ; DATA XREF: NArchive::NTar::GetPropString(IArchiveUpdateCallback *,uint,ulong,AString &,uint,bool)+5o
.text$x:00000C18
.text$x:00000C18 arg_4           = dword ptr  8
.text$x:00000C18
.text$x:00000C18                 mov     edx, [esp+arg_4]
.text$x:00000C1C                 lea     eax, [edx+0Ch]
.text$x:00000C1F                 mov     ecx, [edx-5Ch]
.text$x:00000C22                 xor     ecx, eax
.text$x:00000C24                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000C29                 mov     eax, offset __ehfuncinfo$?GetPropString@NTar@NArchive@@YGJPAUIArchiveUpdateCallback@@IKAAVAString@@I_N@Z
.text$x:00000C2E                 jmp     ___CxxFrameHandler3
.text$x:00000C2E __ehhandler$?GetPropString@NTar@NArchive@@YGJPAUIArchiveUpdateCallback@@IKAAVAString@@I_N@Z endp
.text$x:00000C2E
.text$x:00000C33
.text$x:00000C33 ; =============== S U B R O U T I N E =======================================
.text$x:00000C33
.text$x:00000C33
.text$x:00000C33 __unwindfunclet$?UpdateItems@CHandler@NTar@NArchive@@UAGJPAUISequentialOutStream@@IPAUIArchiveUpdateCallback@@@Z$2 proc near
.text$x:00000C33                                         ; DATA XREF: .xdata$x:00000D20o
.text$x:00000C33                 lea     ecx, [ebp-20h]
.text$x:00000C36                 jmp     ??1?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAE@XZ ; CObjectVector<NArchive::NTar::CUpdateItem>::~CObjectVector<NArchive::NTar::CUpdateItem>(void)
.text$x:00000C36 __unwindfunclet$?UpdateItems@CHandler@NTar@NArchive@@UAGJPAUISequentialOutStream@@IPAUIArchiveUpdateCallback@@@Z$2 endp
.text$x:00000C36
.text$x:00000C3B
.text$x:00000C3B ; =============== S U B R O U T I N E =======================================
.text$x:00000C3B
.text$x:00000C3B
.text$x:00000C3B __unwindfunclet$?UpdateItems@CHandler@NTar@NArchive@@UAGJPAUISequentialOutStream@@IPAUIArchiveUpdateCallback@@@Z$3 proc near
.text$x:00000C3B                                         ; DATA XREF: .xdata$x:00000D28o
.text$x:00000C3B                 lea     ecx, [ebp-78h]  ; this
.text$x:00000C3E                 jmp     ??1CUpdateItem@NTar@NArchive@@QAE@XZ ; NArchive::NTar::CUpdateItem::~CUpdateItem(void)
.text$x:00000C3E __unwindfunclet$?UpdateItems@CHandler@NTar@NArchive@@UAGJPAUISequentialOutStream@@IPAUIArchiveUpdateCallback@@@Z$3 endp
.text$x:00000C3E
.text$x:00000C43
.text$x:00000C43 ; =============== S U B R O U T I N E =======================================
.text$x:00000C43
.text$x:00000C43
.text$x:00000C43 __unwindfunclet$?UpdateItems@CHandler@NTar@NArchive@@UAGJPAUISequentialOutStream@@IPAUIArchiveUpdateCallback@@@Z$4 proc near
.text$x:00000C43                                         ; DATA XREF: .xdata$x:00000D30o
.text$x:00000C43                 lea     ecx, [ebp-0B8h] ; this
.text$x:00000C49                 jmp     ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text$x:00000C49 __unwindfunclet$?UpdateItems@CHandler@NTar@NArchive@@UAGJPAUISequentialOutStream@@IPAUIArchiveUpdateCallback@@@Z$4 endp
.text$x:00000C49
.text$x:00000C4E
.text$x:00000C4E ; =============== S U B R O U T I N E =======================================
.text$x:00000C4E
.text$x:00000C4E
.text$x:00000C4E __unwindfunclet$?UpdateItems@CHandler@NTar@NArchive@@UAGJPAUISequentialOutStream@@IPAUIArchiveUpdateCallback@@@Z$5 proc near
.text$x:00000C4E                                         ; DATA XREF: .xdata$x:00000D38o
.text$x:00000C4E                 lea     ecx, [ebp-0D4h] ; this
.text$x:00000C54                 jmp     ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text$x:00000C54 __unwindfunclet$?UpdateItems@CHandler@NTar@NArchive@@UAGJPAUISequentialOutStream@@IPAUIArchiveUpdateCallback@@@Z$5 endp
.text$x:00000C54
.text$x:00000C59
.text$x:00000C59 ; =============== S U B R O U T I N E =======================================
.text$x:00000C59
.text$x:00000C59
.text$x:00000C59 __unwindfunclet$?UpdateItems@CHandler@NTar@NArchive@@UAGJPAUISequentialOutStream@@IPAUIArchiveUpdateCallback@@@Z$6 proc near
.text$x:00000C59                                         ; DATA XREF: .xdata$x:00000D40o
.text$x:00000C59                 lea     ecx, [ebp-0F0h] ; this
.text$x:00000C5F                 jmp     ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text$x:00000C5F __unwindfunclet$?UpdateItems@CHandler@NTar@NArchive@@UAGJPAUISequentialOutStream@@IPAUIArchiveUpdateCallback@@@Z$6 endp
.text$x:00000C5F
.text$x:00000C64
.text$x:00000C64 ; =============== S U B R O U T I N E =======================================
.text$x:00000C64
.text$x:00000C64
.text$x:00000C64 __unwindfunclet$?UpdateItems@CHandler@NTar@NArchive@@UAGJPAUISequentialOutStream@@IPAUIArchiveUpdateCallback@@@Z$7 proc near
.text$x:00000C64                                         ; DATA XREF: .xdata$x:00000D48o
.text$x:00000C64                 lea     ecx, [ebp-118h] ; this
.text$x:00000C6A                 jmp     ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text$x:00000C6A __unwindfunclet$?UpdateItems@CHandler@NTar@NArchive@@UAGJPAUISequentialOutStream@@IPAUIArchiveUpdateCallback@@@Z$7 endp
.text$x:00000C6A
.text$x:00000C6F
.text$x:00000C6F ; =============== S U B R O U T I N E =======================================
.text$x:00000C6F
.text$x:00000C6F
.text$x:00000C6F __ehhandler$?UpdateItems@CHandler@NTar@NArchive@@UAGJPAUISequentialOutStream@@IPAUIArchiveUpdateCallback@@@Z proc near
.text$x:00000C6F                                         ; DATA XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+5o
.text$x:00000C6F
.text$x:00000C6F arg_4           = dword ptr  8
.text$x:00000C6F
.text$x:00000C6F                 mov     edx, [esp+arg_4]
.text$x:00000C73                 lea     eax, [edx+0Ch]
.text$x:00000C76                 mov     ecx, [edx-1B8h]
.text$x:00000C7C                 xor     ecx, eax
.text$x:00000C7E                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000C83                 mov     eax, offset __ehfuncinfo$?UpdateItems@CHandler@NTar@NArchive@@UAGJPAUISequentialOutStream@@IPAUIArchiveUpdateCallback@@@Z
.text$x:00000C88                 jmp     ___CxxFrameHandler3
.text$x:00000C88 __ehhandler$?UpdateItems@CHandler@NTar@NArchive@@UAGJPAUISequentialOutStream@@IPAUIArchiveUpdateCallback@@@Z endp
.text$x:00000C88
.text$x:00000C88 ; ---------------------------------------------------------------------------
.text$x:00000C8D                 align 10h
.text$x:00000C8D _text$x         ends
.text$x:00000C8D
.xdata$x:00000C90 ; ===========================================================================
.xdata$x:00000C90
.xdata$x:00000C90 ; Segment type: Pure data
.xdata$x:00000C90 ; Segment permissions: Read
.xdata$x:00000C90 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00000C90                 assume cs:_xdata$x
.xdata$x:00000C90                 ;org 0C90h
.xdata$x:00000C90 __unwindtable$?GetPropString@NTar@NArchive@@YGJPAUIArchiveUpdateCallback@@IKAAVAString@@I_N@Z db 0FFh
.xdata$x:00000C90                                         ; DATA XREF: .xdata$x:00000CB0o
.xdata$x:00000C91                 db 0FFh
.xdata$x:00000C92                 db 0FFh
.xdata$x:00000C93                 db 0FFh
.xdata$x:00000C94                 dd offset __unwindfunclet$?GetPropString@NTar@NArchive@@YGJPAUIArchiveUpdateCallback@@IKAAVAString@@I_N@Z$0
.xdata$x:00000C98                 db    0
.xdata$x:00000C99                 db    0
.xdata$x:00000C9A                 db    0
.xdata$x:00000C9B                 db    0
.xdata$x:00000C9C                 dd offset __unwindfunclet$?GetPropString@NTar@NArchive@@YGJPAUIArchiveUpdateCallback@@IKAAVAString@@I_N@Z$1
.xdata$x:00000CA0                 db    1
.xdata$x:00000CA1                 db    0
.xdata$x:00000CA2                 db    0
.xdata$x:00000CA3                 db    0
.xdata$x:00000CA4                 dd offset __unwindfunclet$?GetPropString@NTar@NArchive@@YGJPAUIArchiveUpdateCallback@@IKAAVAString@@I_N@Z$2
.xdata$x:00000CA8 __ehfuncinfo$?GetPropString@NTar@NArchive@@YGJPAUIArchiveUpdateCallback@@IKAAVAString@@I_N@Z db  22h ; "
.xdata$x:00000CA8                                         ; DATA XREF: __ehhandler$?GetPropString@NTar@NArchive@@YGJPAUIArchiveUpdateCallback@@IKAAVAString@@I_N@Z+11o
.xdata$x:00000CA9                 db    5
.xdata$x:00000CAA                 db  93h ; 
.xdata$x:00000CAB                 db  19h
.xdata$x:00000CAC                 db    3
.xdata$x:00000CAD                 db    0
.xdata$x:00000CAE                 db    0
.xdata$x:00000CAF                 db    0
.xdata$x:00000CB0                 dd offset __unwindtable$?GetPropString@NTar@NArchive@@YGJPAUIArchiveUpdateCallback@@IKAAVAString@@I_N@Z
.xdata$x:00000CB4                 db    0
.xdata$x:00000CB5                 db    0
.xdata$x:00000CB6                 db    0
.xdata$x:00000CB7                 db    0
.xdata$x:00000CB8                 db    0
.xdata$x:00000CB9                 db    0
.xdata$x:00000CBA                 db    0
.xdata$x:00000CBB                 db    0
.xdata$x:00000CBC                 db    0
.xdata$x:00000CBD                 db    0
.xdata$x:00000CBE                 db    0
.xdata$x:00000CBF                 db    0
.xdata$x:00000CC0                 db    0
.xdata$x:00000CC1                 db    0
.xdata$x:00000CC2                 db    0
.xdata$x:00000CC3                 db    0
.xdata$x:00000CC4                 db    0
.xdata$x:00000CC5                 db    0
.xdata$x:00000CC6                 db    0
.xdata$x:00000CC7                 db    0
.xdata$x:00000CC8                 db    1
.xdata$x:00000CC9                 db    0
.xdata$x:00000CCA                 db    0
.xdata$x:00000CCB                 db    0
.xdata$x:00000CCC __catchsym$?UpdateItems@CHandler@NTar@NArchive@@UAGJPAUISequentialOutStream@@IPAUIArchiveUpdateCallback@@@Z$8 dd offset loc_3E+2
.xdata$x:00000CCC                                         ; DATA XREF: .xdata$x:00000CECo
.xdata$x:00000CD0                 db    0
.xdata$x:00000CD1                 db    0
.xdata$x:00000CD2                 db    0
.xdata$x:00000CD3                 db    0
.xdata$x:00000CD4                 db    0
.xdata$x:00000CD5                 db    0
.xdata$x:00000CD6                 db    0
.xdata$x:00000CD7                 db    0
.xdata$x:00000CD8                 dd offset __catch$?UpdateItems@CHandler@NTar@NArchive@@UAGJPAUISequentialOutStream@@IPAUIArchiveUpdateCallback@@@Z$0
.xdata$x:00000CDC __tryblocktable$?UpdateItems@CHandler@NTar@NArchive@@UAGJPAUISequentialOutStream@@IPAUIArchiveUpdateCallback@@@Z db    0
.xdata$x:00000CDC                                         ; DATA XREF: .xdata$x:00000D00o
.xdata$x:00000CDD                 db    0
.xdata$x:00000CDE                 db    0
.xdata$x:00000CDF                 db    0
.xdata$x:00000CE0                 db    6
.xdata$x:00000CE1                 db    0
.xdata$x:00000CE2                 db    0
.xdata$x:00000CE3                 db    0
.xdata$x:00000CE4                 db    7
.xdata$x:00000CE5                 db    0
.xdata$x:00000CE6                 db    0
.xdata$x:00000CE7                 db    0
.xdata$x:00000CE8                 db    1
.xdata$x:00000CE9                 db    0
.xdata$x:00000CEA                 db    0
.xdata$x:00000CEB                 db    0
.xdata$x:00000CEC                 dd offset __catchsym$?UpdateItems@CHandler@NTar@NArchive@@UAGJPAUISequentialOutStream@@IPAUIArchiveUpdateCallback@@@Z$8
.xdata$x:00000CF0 __ehfuncinfo$?UpdateItems@CHandler@NTar@NArchive@@UAGJPAUISequentialOutStream@@IPAUIArchiveUpdateCallback@@@Z db  22h ; "
.xdata$x:00000CF0                                         ; DATA XREF: __ehhandler$?UpdateItems@CHandler@NTar@NArchive@@UAGJPAUISequentialOutStream@@IPAUIArchiveUpdateCallback@@@Z+14o
.xdata$x:00000CF1                 db    5
.xdata$x:00000CF2                 db  93h ; 
.xdata$x:00000CF3                 db  19h
.xdata$x:00000CF4                 db    8
.xdata$x:00000CF5                 db    0
.xdata$x:00000CF6                 db    0
.xdata$x:00000CF7                 db    0
.xdata$x:00000CF8                 dd offset __unwindtable$?UpdateItems@CHandler@NTar@NArchive@@UAGJPAUISequentialOutStream@@IPAUIArchiveUpdateCallback@@@Z
.xdata$x:00000CFC                 db    1
.xdata$x:00000CFD                 db    0
.xdata$x:00000CFE                 db    0
.xdata$x:00000CFF                 db    0
.xdata$x:00000D00                 dd offset __tryblocktable$?UpdateItems@CHandler@NTar@NArchive@@UAGJPAUISequentialOutStream@@IPAUIArchiveUpdateCallback@@@Z
.xdata$x:00000D04                 align 10h
.xdata$x:00000D10                 db    1
.xdata$x:00000D11                 db    0
.xdata$x:00000D12                 db    0
.xdata$x:00000D13                 db    0
.xdata$x:00000D14 __unwindtable$?UpdateItems@CHandler@NTar@NArchive@@UAGJPAUISequentialOutStream@@IPAUIArchiveUpdateCallback@@@Z db 0FFh
.xdata$x:00000D14                                         ; DATA XREF: .xdata$x:00000CF8o
.xdata$x:00000D15                 db 0FFh
.xdata$x:00000D16                 db 0FFh
.xdata$x:00000D17                 db 0FFh
.xdata$x:00000D18                 db    0
.xdata$x:00000D19                 db    0
.xdata$x:00000D1A                 db    0
.xdata$x:00000D1B                 db    0
.xdata$x:00000D1C                 db    0
.xdata$x:00000D1D                 db    0
.xdata$x:00000D1E                 db    0
.xdata$x:00000D1F                 db    0
.xdata$x:00000D20                 dd offset __unwindfunclet$?UpdateItems@CHandler@NTar@NArchive@@UAGJPAUISequentialOutStream@@IPAUIArchiveUpdateCallback@@@Z$2
.xdata$x:00000D24                 db    1
.xdata$x:00000D25                 db    0
.xdata$x:00000D26                 db    0
.xdata$x:00000D27                 db    0
.xdata$x:00000D28                 dd offset __unwindfunclet$?UpdateItems@CHandler@NTar@NArchive@@UAGJPAUISequentialOutStream@@IPAUIArchiveUpdateCallback@@@Z$3
.xdata$x:00000D2C                 db    2
.xdata$x:00000D2D                 db    0
.xdata$x:00000D2E                 db    0
.xdata$x:00000D2F                 db    0
.xdata$x:00000D30                 dd offset __unwindfunclet$?UpdateItems@CHandler@NTar@NArchive@@UAGJPAUISequentialOutStream@@IPAUIArchiveUpdateCallback@@@Z$4
.xdata$x:00000D34                 db    2
.xdata$x:00000D35                 db    0
.xdata$x:00000D36                 db    0
.xdata$x:00000D37                 db    0
.xdata$x:00000D38                 dd offset __unwindfunclet$?UpdateItems@CHandler@NTar@NArchive@@UAGJPAUISequentialOutStream@@IPAUIArchiveUpdateCallback@@@Z$5
.xdata$x:00000D3C                 db    2
.xdata$x:00000D3D                 db    0
.xdata$x:00000D3E                 db    0
.xdata$x:00000D3F                 db    0
.xdata$x:00000D40                 dd offset __unwindfunclet$?UpdateItems@CHandler@NTar@NArchive@@UAGJPAUISequentialOutStream@@IPAUIArchiveUpdateCallback@@@Z$6
.xdata$x:00000D44                 db    2
.xdata$x:00000D45                 db    0
.xdata$x:00000D46                 db    0
.xdata$x:00000D47                 db    0
.xdata$x:00000D48                 dd offset __unwindfunclet$?UpdateItems@CHandler@NTar@NArchive@@UAGJPAUISequentialOutStream@@IPAUIArchiveUpdateCallback@@@Z$7
.xdata$x:00000D4C                 db 0FFh
.xdata$x:00000D4D                 db 0FFh
.xdata$x:00000D4E                 db 0FFh
.xdata$x:00000D4F                 db 0FFh
.xdata$x:00000D50                 db    0
.xdata$x:00000D51                 db    0
.xdata$x:00000D52                 db    0
.xdata$x:00000D53                 db    0
.xdata$x:00000D53 _xdata$x        ends
.xdata$x:00000D53
.text:00000D54 ; ===========================================================================
.text:00000D54
.text:00000D54 ; Segment type: Pure code
.text:00000D54 ; Segment permissions: Read/Execute
.text:00000D54 _text           segment para public 'CODE' use32
.text:00000D54                 assume cs:_text
.text:00000D54                 ;org 0D54h
.text:00000D54 ; COMDAT (pick any)
.text:00000D54                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000D54
.text:00000D54 ; =============== S U B R O U T I N E =======================================
.text:00000D54
.text:00000D54 ; Attributes: bp-based frame
.text:00000D54
.text:00000D54 ; _DWORD __thiscall UString::~UString(UString *__hidden this)
.text:00000D54                 public ??1UString@@QAE@XZ
.text:00000D54 ??1UString@@QAE@XZ proc near            ; CODE XREF: NArchive::NTar::GetPropString(IArchiveUpdateCallback *,uint,ulong,AString &,uint,bool)+E0p
.text:00000D54                                         ; NArchive::NTar::GetPropString(IArchiveUpdateCallback *,uint,ulong,AString &,uint,bool)+115p ...
.text:00000D54
.text:00000D54 var_8           = dword ptr -8
.text:00000D54 var_4           = dword ptr -4
.text:00000D54
.text:00000D54                 push    ebp
.text:00000D55                 mov     ebp, esp
.text:00000D57                 sub     esp, 8
.text:00000D5A                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00000D61                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000D68                 mov     [ebp+var_4], ecx
.text:00000D6B                 mov     eax, [ebp+var_4]
.text:00000D6E                 mov     ecx, [eax]
.text:00000D70                 mov     [ebp+var_8], ecx
.text:00000D73                 mov     edx, [ebp+var_8]
.text:00000D76                 push    edx             ; void *
.text:00000D77                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00000D7C                 add     esp, 4
.text:00000D7F                 add     esp, 8
.text:00000D82                 cmp     ebp, esp
.text:00000D84                 call    __RTC_CheckEsp
.text:00000D89                 mov     esp, ebp
.text:00000D8B                 pop     ebp
.text:00000D8C                 retn
.text:00000D8C ??1UString@@QAE@XZ endp
.text:00000D8C
.text:00000D8C ; ---------------------------------------------------------------------------
.text:00000D8D                 align 10h
.text:00000D8D _text           ends
.text:00000D8D
.text:00000D90 ; ===========================================================================
.text:00000D90
.text:00000D90 ; Segment type: Pure code
.text:00000D90 ; Segment permissions: Read/Execute
.text:00000D90 _text           segment para public 'CODE' use32
.text:00000D90                 assume cs:_text
.text:00000D90                 ;org 0D90h
.text:00000D90 ; COMDAT (pick any)
.text:00000D90                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000D90
.text:00000D90 ; =============== S U B R O U T I N E =======================================
.text:00000D90
.text:00000D90 ; Attributes: bp-based frame
.text:00000D90
.text:00000D90 ; _DWORD __thiscall NWindows::NCOM::CPropVariant::CPropVariant(NWindows::NCOM::CPropVariant *__hidden this)
.text:00000D90                 public ??0CPropVariant@NCOM@NWindows@@QAE@XZ
.text:00000D90 ??0CPropVariant@NCOM@NWindows@@QAE@XZ proc near
.text:00000D90                                         ; CODE XREF: NArchive::NTar::GetPropString(IArchiveUpdateCallback *,uint,ulong,AString &,uint,bool)+39p
.text:00000D90                                         ; NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+224p ...
.text:00000D90
.text:00000D90 var_4           = dword ptr -4
.text:00000D90
.text:00000D90                 push    ebp
.text:00000D91                 mov     ebp, esp
.text:00000D93                 push    ecx
.text:00000D94                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000D9B                 mov     [ebp+var_4], ecx
.text:00000D9E                 xor     eax, eax
.text:00000DA0                 mov     ecx, [ebp+var_4]
.text:00000DA3                 mov     [ecx], ax
.text:00000DA6                 xor     edx, edx
.text:00000DA8                 mov     eax, [ebp+var_4]
.text:00000DAB                 mov     [eax+2], dx
.text:00000DAF                 mov     ecx, [ebp+var_4]
.text:00000DB2                 mov     dword ptr [ecx+8], 0
.text:00000DB9                 mov     eax, [ebp+var_4]
.text:00000DBC                 mov     esp, ebp
.text:00000DBE                 pop     ebp
.text:00000DBF                 retn
.text:00000DBF ??0CPropVariant@NCOM@NWindows@@QAE@XZ endp
.text:00000DBF
.text:00000DBF _text           ends
.text:00000DBF
.text:00000DC0 ; ===========================================================================
.text:00000DC0
.text:00000DC0 ; Segment type: Pure code
.text:00000DC0 ; Segment permissions: Read/Execute
.text:00000DC0 _text           segment para public 'CODE' use32
.text:00000DC0                 assume cs:_text
.text:00000DC0                 ;org 0DC0h
.text:00000DC0 ; COMDAT (pick any)
.text:00000DC0                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000DC0
.text:00000DC0 ; =============== S U B R O U T I N E =======================================
.text:00000DC0
.text:00000DC0 ; Attributes: bp-based frame
.text:00000DC0
.text:00000DC0 ; _DWORD __thiscall NWindows::NCOM::CPropVariant::~CPropVariant(NWindows::NCOM::CPropVariant *__hidden this)
.text:00000DC0                 public ??1CPropVariant@NCOM@NWindows@@QAE@XZ
.text:00000DC0 ??1CPropVariant@NCOM@NWindows@@QAE@XZ proc near
.text:00000DC0                                         ; CODE XREF: NArchive::NTar::GetPropString(IArchiveUpdateCallback *,uint,ulong,AString &,uint,bool)+81p
.text:00000DC0                                         ; NArchive::NTar::GetPropString(IArchiveUpdateCallback *,uint,ulong,AString &,uint,bool)+135p ...
.text:00000DC0
.text:00000DC0 var_4           = dword ptr -4
.text:00000DC0
.text:00000DC0                 push    ebp
.text:00000DC1                 mov     ebp, esp
.text:00000DC3                 push    ecx
.text:00000DC4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000DCB                 mov     [ebp+var_4], ecx
.text:00000DCE                 mov     ecx, [ebp+var_4] ; this
.text:00000DD1                 call    ?Clear@CPropVariant@NCOM@NWindows@@QAEJXZ ; NWindows::NCOM::CPropVariant::Clear(void)
.text:00000DD6                 add     esp, 4
.text:00000DD9                 cmp     ebp, esp
.text:00000DDB                 call    __RTC_CheckEsp
.text:00000DE0                 mov     esp, ebp
.text:00000DE2                 pop     ebp
.text:00000DE3                 retn
.text:00000DE3 ??1CPropVariant@NCOM@NWindows@@QAE@XZ endp
.text:00000DE3
.text:00000DE3 _text           ends
.text:00000DE3
.text:00000DE4 ; ===========================================================================
.text:00000DE4
.text:00000DE4 ; Segment type: Pure code
.text:00000DE4 ; Segment permissions: Read/Execute
.text:00000DE4 _text           segment para public 'CODE' use32
.text:00000DE4                 assume cs:_text
.text:00000DE4                 ;org 0DE4h
.text:00000DE4 ; COMDAT (pick any)
.text:00000DE4                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000DE4
.text:00000DE4 ; =============== S U B R O U T I N E =======================================
.text:00000DE4
.text:00000DE4 ; Attributes: bp-based frame
.text:00000DE4
.text:00000DE4 ; bool __stdcall IntToBool(int)
.text:00000DE4                 public ?IntToBool@@YG_NH@Z
.text:00000DE4 ?IntToBool@@YG_NH@Z proc near           ; CODE XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+1BFp
.text:00000DE4                                         ; NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+1DAp ...
.text:00000DE4
.text:00000DE4 arg_0           = dword ptr  8
.text:00000DE4
.text:00000DE4                 push    ebp
.text:00000DE5                 mov     ebp, esp
.text:00000DE7                 xor     eax, eax
.text:00000DE9                 cmp     [ebp+arg_0], 0
.text:00000DED                 setnz   al
.text:00000DF0                 pop     ebp
.text:00000DF1                 retn    4
.text:00000DF1 ?IntToBool@@YG_NH@Z endp
.text:00000DF1
.text:00000DF1 _text           ends
.text:00000DF1
.text:00000DF4 ; ===========================================================================
.text:00000DF4
.text:00000DF4 ; Segment type: Pure code
.text:00000DF4 ; Segment permissions: Read/Execute
.text:00000DF4 _text           segment para public 'CODE' use32
.text:00000DF4                 assume cs:_text
.text:00000DF4                 ;org 0DF4h
.text:00000DF4 ; COMDAT (pick any)
.text:00000DF4                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000DF4
.text:00000DF4 ; =============== S U B R O U T I N E =======================================
.text:00000DF4
.text:00000DF4 ; Attributes: bp-based frame
.text:00000DF4
.text:00000DF4 ; bool __thiscall AString::IsEmpty(AString *__hidden this)
.text:00000DF4                 public ?IsEmpty@AString@@QBE_NXZ
.text:00000DF4 ?IsEmpty@AString@@QBE_NXZ proc near     ; CODE XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+5CBp
.text:00000DF4
.text:00000DF4 var_4           = dword ptr -4
.text:00000DF4
.text:00000DF4                 push    ebp
.text:00000DF5                 mov     ebp, esp
.text:00000DF7                 push    ecx
.text:00000DF8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000DFF                 mov     [ebp+var_4], ecx
.text:00000E02                 mov     eax, [ebp+var_4]
.text:00000E05                 xor     ecx, ecx
.text:00000E07                 cmp     dword ptr [eax+4], 0
.text:00000E0B                 setz    cl
.text:00000E0E                 mov     al, cl
.text:00000E10                 mov     esp, ebp
.text:00000E12                 pop     ebp
.text:00000E13                 retn
.text:00000E13 ?IsEmpty@AString@@QBE_NXZ endp
.text:00000E13
.text:00000E13 _text           ends
.text:00000E13
.text:00000E14 ; ===========================================================================
.text:00000E14
.text:00000E14 ; Segment type: Pure code
.text:00000E14 ; Segment permissions: Read/Execute
.text:00000E14 _text           segment para public 'CODE' use32
.text:00000E14                 assume cs:_text
.text:00000E14                 ;org 0E14h
.text:00000E14 ; COMDAT (pick any)
.text:00000E14                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000E14
.text:00000E14 ; =============== S U B R O U T I N E =======================================
.text:00000E14
.text:00000E14 ; Attributes: bp-based frame
.text:00000E14
.text:00000E14 ; char __thiscall AString::Back(AString *__hidden this)
.text:00000E14                 public ?Back@AString@@QBEDXZ
.text:00000E14 ?Back@AString@@QBEDXZ proc near         ; CODE XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+5E4p
.text:00000E14
.text:00000E14 var_4           = dword ptr -4
.text:00000E14
.text:00000E14                 push    ebp
.text:00000E15                 mov     ebp, esp
.text:00000E17                 push    ecx
.text:00000E18                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000E1F                 mov     [ebp+var_4], ecx
.text:00000E22                 mov     eax, [ebp+var_4]
.text:00000E25                 mov     ecx, [eax+4]
.text:00000E28                 mov     edx, [ebp+var_4]
.text:00000E2B                 mov     eax, [edx]
.text:00000E2D                 mov     al, [ecx+eax-1]
.text:00000E31                 mov     esp, ebp
.text:00000E33                 pop     ebp
.text:00000E34                 retn
.text:00000E34 ?Back@AString@@QBEDXZ endp
.text:00000E34
.text:00000E34 ; ---------------------------------------------------------------------------
.text:00000E35                 align 4
.text:00000E35 _text           ends
.text:00000E35
.text:00000E38 ; ===========================================================================
.text:00000E38
.text:00000E38 ; Segment type: Pure code
.text:00000E38 ; Segment permissions: Read/Execute
.text:00000E38 _text           segment para public 'CODE' use32
.text:00000E38                 assume cs:_text
.text:00000E38                 ;org 0E38h
.text:00000E38 ; COMDAT (pick any)
.text:00000E38                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000E38
.text:00000E38 ; =============== S U B R O U T I N E =======================================
.text:00000E38
.text:00000E38 ; Attributes: bp-based frame
.text:00000E38
.text:00000E38 ; public: class AString & __thiscall AString::operator+=(char)
.text:00000E38                 public ??YAString@@QAEAAV0@D@Z
.text:00000E38 ??YAString@@QAEAAV0@D@Z proc near       ; CODE XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+600p
.text:00000E38
.text:00000E38 var_C           = dword ptr -0Ch
.text:00000E38 var_8           = dword ptr -8
.text:00000E38 var_4           = dword ptr -4
.text:00000E38 arg_0           = byte ptr  8
.text:00000E38
.text:00000E38                 push    ebp
.text:00000E39                 mov     ebp, esp
.text:00000E3B                 sub     esp, 0Ch
.text:00000E3E                 mov     [ebp+var_C], 0CCCCCCCCh
.text:00000E45                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00000E4C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000E53                 mov     [ebp+var_4], ecx
.text:00000E56                 mov     eax, [ebp+var_4]
.text:00000E59                 mov     ecx, [ebp+var_4]
.text:00000E5C                 mov     edx, [eax+8]
.text:00000E5F                 cmp     edx, [ecx+4]
.text:00000E62                 jnz     short loc_E6C
.text:00000E64                 mov     ecx, [ebp+var_4] ; this
.text:00000E67                 call    ?Grow_1@AString@@AAEXXZ ; AString::Grow_1(void)
.text:00000E6C
.text:00000E6C loc_E6C:                                ; CODE XREF: AString::operator+=(char)+2Aj
.text:00000E6C                 mov     eax, [ebp+var_4]
.text:00000E6F                 mov     ecx, [eax+4]
.text:00000E72                 mov     [ebp+var_8], ecx
.text:00000E75                 mov     edx, [ebp+var_4]
.text:00000E78                 mov     eax, [edx]
.text:00000E7A                 mov     [ebp+var_C], eax
.text:00000E7D                 mov     ecx, [ebp+var_C]
.text:00000E80                 add     ecx, [ebp+var_8]
.text:00000E83                 mov     dl, [ebp+arg_0]
.text:00000E86                 mov     [ecx], dl
.text:00000E88                 mov     eax, [ebp+var_8]
.text:00000E8B                 add     eax, 1
.text:00000E8E                 mov     [ebp+var_8], eax
.text:00000E91                 mov     ecx, [ebp+var_C]
.text:00000E94                 add     ecx, [ebp+var_8]
.text:00000E97                 mov     byte ptr [ecx], 0
.text:00000E9A                 mov     edx, [ebp+var_4]
.text:00000E9D                 mov     eax, [ebp+var_8]
.text:00000EA0                 mov     [edx+4], eax
.text:00000EA3                 mov     eax, [ebp+var_4]
.text:00000EA6                 add     esp, 0Ch
.text:00000EA9                 cmp     ebp, esp
.text:00000EAB                 call    __RTC_CheckEsp
.text:00000EB0                 mov     esp, ebp
.text:00000EB2                 pop     ebp
.text:00000EB3                 retn    4
.text:00000EB3 ??YAString@@QAEAAV0@D@Z endp
.text:00000EB3
.text:00000EB3 ; ---------------------------------------------------------------------------
.text:00000EB6                 align 4
.text:00000EB6 _text           ends
.text:00000EB6
.text:00000EB8 ; ===========================================================================
.text:00000EB8
.text:00000EB8 ; Segment type: Pure code
.text:00000EB8 ; Segment permissions: Read/Execute
.text:00000EB8 _text           segment para public 'CODE' use32
.text:00000EB8                 assume cs:_text
.text:00000EB8                 ;org 0EB8h
.text:00000EB8 ; COMDAT (pick any)
.text:00000EB8                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000EB8
.text:00000EB8 ; =============== S U B R O U T I N E =======================================
.text:00000EB8
.text:00000EB8 ; Attributes: bp-based frame
.text:00000EB8
.text:00000EB8 ; _DWORD __thiscall NArchive::NTar::CUpdateItem::CUpdateItem(NArchive::NTar::CUpdateItem *__hidden this)
.text:00000EB8                 public ??0CUpdateItem@NTar@NArchive@@QAE@XZ
.text:00000EB8 ??0CUpdateItem@NTar@NArchive@@QAE@XZ proc near
.text:00000EB8                                         ; CODE XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+FCp
.text:00000EB8
.text:00000EB8 var_10          = dword ptr -10h
.text:00000EB8 var_C           = dword ptr -0Ch
.text:00000EB8 var_4           = dword ptr -4
.text:00000EB8
.text:00000EB8                 push    ebp
.text:00000EB9                 mov     ebp, esp
.text:00000EBB                 push    0FFFFFFFFh
.text:00000EBD                 push    offset __ehhandler$??0CUpdateItem@NTar@NArchive@@QAE@XZ
.text:00000EC2                 mov     eax, large fs:0
.text:00000EC8                 push    eax
.text:00000EC9                 push    ecx
.text:00000ECA                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00000ED1                 mov     eax, dword ptr ds:___security_cookie
.text:00000ED6                 xor     eax, ebp
.text:00000ED8                 push    eax
.text:00000ED9                 lea     eax, [ebp+var_C]
.text:00000EDC                 mov     large fs:0, eax
.text:00000EE2                 mov     [ebp+var_10], ecx
.text:00000EE5                 mov     ecx, [ebp+var_10]
.text:00000EE8                 add     ecx, 20h ; ' '
.text:00000EEB                 call    ??0AString@@QAE@XZ ; AString::AString(void)
.text:00000EF0                 mov     [ebp+var_4], 0
.text:00000EF7                 mov     ecx, [ebp+var_10]
.text:00000EFA                 add     ecx, 2Ch ; ','
.text:00000EFD                 call    ??0AString@@QAE@XZ ; AString::AString(void)
.text:00000F02                 mov     byte ptr [ebp+var_4], 1
.text:00000F06                 mov     ecx, [ebp+var_10]
.text:00000F09                 add     ecx, 38h ; '8'
.text:00000F0C                 call    ??0AString@@QAE@XZ ; AString::AString(void)
.text:00000F11                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000F18                 mov     eax, [ebp+var_10]
.text:00000F1B                 mov     ecx, [ebp+var_C]
.text:00000F1E                 mov     large fs:0, ecx
.text:00000F25                 pop     ecx
.text:00000F26                 add     esp, 10h
.text:00000F29                 cmp     ebp, esp
.text:00000F2B                 call    __RTC_CheckEsp
.text:00000F30                 mov     esp, ebp
.text:00000F32                 pop     ebp
.text:00000F33                 retn
.text:00000F33 ??0CUpdateItem@NTar@NArchive@@QAE@XZ endp
.text:00000F33
.text:00000F33 _text           ends
.text:00000F33
.text$x:00000F34 ; ===========================================================================
.text$x:00000F34
.text$x:00000F34 ; Segment type: Pure code
.text$x:00000F34 ; Segment permissions: Read/Execute
.text$x:00000F34 _text$x         segment para public 'CODE' use32
.text$x:00000F34                 assume cs:_text$x
.text$x:00000F34                 ;org 0F34h
.text$x:00000F34 ; COMDAT (pick associative to section at EB8)
.text$x:00000F34                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text$x:00000F34
.text$x:00000F34 ; =============== S U B R O U T I N E =======================================
.text$x:00000F34
.text$x:00000F34
.text$x:00000F34 __unwindfunclet$??0CUpdateItem@NTar@NArchive@@QAE@XZ$0 proc near
.text$x:00000F34                                         ; DATA XREF: .xdata$x:00000F6Co
.text$x:00000F34                 mov     ecx, [ebp-10h]
.text$x:00000F37                 add     ecx, 20h ; ' '  ; this
.text$x:00000F3A                 jmp     ??1AString@@QAE@XZ ; AString::~AString(void)
.text$x:00000F3A __unwindfunclet$??0CUpdateItem@NTar@NArchive@@QAE@XZ$0 endp
.text$x:00000F3A
.text$x:00000F3F
.text$x:00000F3F ; =============== S U B R O U T I N E =======================================
.text$x:00000F3F
.text$x:00000F3F
.text$x:00000F3F __unwindfunclet$??0CUpdateItem@NTar@NArchive@@QAE@XZ$1 proc near
.text$x:00000F3F                                         ; DATA XREF: .xdata$x:00000F74o
.text$x:00000F3F                 mov     ecx, [ebp-10h]
.text$x:00000F42                 add     ecx, 2Ch ; ','  ; this
.text$x:00000F45                 jmp     ??1AString@@QAE@XZ ; AString::~AString(void)
.text$x:00000F45 __unwindfunclet$??0CUpdateItem@NTar@NArchive@@QAE@XZ$1 endp
.text$x:00000F45
.text$x:00000F4A
.text$x:00000F4A ; =============== S U B R O U T I N E =======================================
.text$x:00000F4A
.text$x:00000F4A
.text$x:00000F4A __ehhandler$??0CUpdateItem@NTar@NArchive@@QAE@XZ proc near
.text$x:00000F4A                                         ; DATA XREF: NArchive::NTar::CUpdateItem::CUpdateItem(void)+5o
.text$x:00000F4A
.text$x:00000F4A arg_4           = dword ptr  8
.text$x:00000F4A
.text$x:00000F4A                 mov     edx, [esp+arg_4]
.text$x:00000F4E                 lea     eax, [edx+0Ch]
.text$x:00000F51                 mov     ecx, [edx-8]
.text$x:00000F54                 xor     ecx, eax
.text$x:00000F56                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000F5B                 mov     eax, offset __ehfuncinfo$??0CUpdateItem@NTar@NArchive@@QAE@XZ
.text$x:00000F60                 jmp     ___CxxFrameHandler3
.text$x:00000F60 __ehhandler$??0CUpdateItem@NTar@NArchive@@QAE@XZ endp
.text$x:00000F60
.text$x:00000F60 ; ---------------------------------------------------------------------------
.text$x:00000F65                 align 4
.text$x:00000F65 _text$x         ends
.text$x:00000F65
.xdata$x:00000F68 ; ===========================================================================
.xdata$x:00000F68
.xdata$x:00000F68 ; Segment type: Pure data
.xdata$x:00000F68 ; Segment permissions: Read
.xdata$x:00000F68 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00000F68                 assume cs:_xdata$x
.xdata$x:00000F68                 ;org 0F68h
.xdata$x:00000F68 ; COMDAT (pick associative to section at EB8)
.xdata$x:00000F68 __unwindtable$??0CUpdateItem@NTar@NArchive@@QAE@XZ db 0FFh
.xdata$x:00000F68                                         ; DATA XREF: .xdata$x:00000F80o
.xdata$x:00000F69                 db 0FFh
.xdata$x:00000F6A                 db 0FFh
.xdata$x:00000F6B                 db 0FFh
.xdata$x:00000F6C                 dd offset __unwindfunclet$??0CUpdateItem@NTar@NArchive@@QAE@XZ$0
.xdata$x:00000F70                 db    0
.xdata$x:00000F71                 db    0
.xdata$x:00000F72                 db    0
.xdata$x:00000F73                 db    0
.xdata$x:00000F74                 dd offset __unwindfunclet$??0CUpdateItem@NTar@NArchive@@QAE@XZ$1
.xdata$x:00000F78 __ehfuncinfo$??0CUpdateItem@NTar@NArchive@@QAE@XZ db  22h ; "
.xdata$x:00000F78                                         ; DATA XREF: __ehhandler$??0CUpdateItem@NTar@NArchive@@QAE@XZ+11o
.xdata$x:00000F79                 db    5
.xdata$x:00000F7A                 db  93h ; 
.xdata$x:00000F7B                 db  19h
.xdata$x:00000F7C                 db    2
.xdata$x:00000F7D                 db    0
.xdata$x:00000F7E                 db    0
.xdata$x:00000F7F                 db    0
.xdata$x:00000F80                 dd offset __unwindtable$??0CUpdateItem@NTar@NArchive@@QAE@XZ
.xdata$x:00000F84                 db    0
.xdata$x:00000F85                 db    0
.xdata$x:00000F86                 db    0
.xdata$x:00000F87                 db    0
.xdata$x:00000F88                 db    0
.xdata$x:00000F89                 db    0
.xdata$x:00000F8A                 db    0
.xdata$x:00000F8B                 db    0
.xdata$x:00000F8C                 db    0
.xdata$x:00000F8D                 db    0
.xdata$x:00000F8E                 db    0
.xdata$x:00000F8F                 db    0
.xdata$x:00000F90                 db    0
.xdata$x:00000F91                 db    0
.xdata$x:00000F92                 db    0
.xdata$x:00000F93                 db    0
.xdata$x:00000F94                 db    0
.xdata$x:00000F95                 db    0
.xdata$x:00000F96                 db    0
.xdata$x:00000F97                 db    0
.xdata$x:00000F98                 db    1
.xdata$x:00000F99                 db    0
.xdata$x:00000F9A                 db    0
.xdata$x:00000F9B                 db    0
.xdata$x:00000F9B _xdata$x        ends
.xdata$x:00000F9B
.text:00000F9C ; ===========================================================================
.text:00000F9C
.text:00000F9C ; Segment type: Pure code
.text:00000F9C ; Segment permissions: Read/Execute
.text:00000F9C _text           segment para public 'CODE' use32
.text:00000F9C                 assume cs:_text
.text:00000F9C                 ;org 0F9Ch
.text:00000F9C ; COMDAT (pick any)
.text:00000F9C                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000F9C
.text:00000F9C ; =============== S U B R O U T I N E =======================================
.text:00000F9C
.text:00000F9C ; Attributes: bp-based frame
.text:00000F9C
.text:00000F9C ; _DWORD __thiscall AString::~AString(AString *__hidden this)
.text:00000F9C                 public ??1AString@@QAE@XZ
.text:00000F9C ??1AString@@QAE@XZ proc near            ; CODE XREF: __unwindfunclet$??0CUpdateItem@NTar@NArchive@@QAE@XZ$0+6j
.text:00000F9C                                         ; __unwindfunclet$??0CUpdateItem@NTar@NArchive@@QAE@XZ$1+6j ...
.text:00000F9C
.text:00000F9C var_8           = dword ptr -8
.text:00000F9C var_4           = dword ptr -4
.text:00000F9C
.text:00000F9C                 push    ebp
.text:00000F9D                 mov     ebp, esp
.text:00000F9F                 sub     esp, 8
.text:00000FA2                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00000FA9                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000FB0                 mov     [ebp+var_4], ecx
.text:00000FB3                 mov     eax, [ebp+var_4]
.text:00000FB6                 mov     ecx, [eax]
.text:00000FB8                 mov     [ebp+var_8], ecx
.text:00000FBB                 mov     edx, [ebp+var_8]
.text:00000FBE                 push    edx             ; void *
.text:00000FBF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00000FC4                 add     esp, 4
.text:00000FC7                 add     esp, 8
.text:00000FCA                 cmp     ebp, esp
.text:00000FCC                 call    __RTC_CheckEsp
.text:00000FD1                 mov     esp, ebp
.text:00000FD3                 pop     ebp
.text:00000FD4                 retn
.text:00000FD4 ??1AString@@QAE@XZ endp
.text:00000FD4
.text:00000FD4 ; ---------------------------------------------------------------------------
.text:00000FD5                 align 4
.text:00000FD5 _text           ends
.text:00000FD5
.text:00000FD8 ; ===========================================================================
.text:00000FD8
.text:00000FD8 ; Segment type: Pure code
.text:00000FD8 ; Segment permissions: Read/Execute
.text:00000FD8 _text           segment para public 'CODE' use32
.text:00000FD8                 assume cs:_text
.text:00000FD8                 ;org 0FD8h
.text:00000FD8 ; COMDAT (pick any)
.text:00000FD8                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000FD8
.text:00000FD8 ; =============== S U B R O U T I N E =======================================
.text:00000FD8
.text:00000FD8 ; Attributes: bp-based frame
.text:00000FD8
.text:00000FD8 ; _DWORD __thiscall NArchive::NTar::CUpdateItem::~CUpdateItem(NArchive::NTar::CUpdateItem *__hidden this)
.text:00000FD8                 public ??1CUpdateItem@NTar@NArchive@@QAE@XZ
.text:00000FD8 ??1CUpdateItem@NTar@NArchive@@QAE@XZ proc near
.text:00000FD8                                         ; CODE XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+122p
.text:00000FD8                                         ; NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+19Cp ...
.text:00000FD8
.text:00000FD8 var_10          = dword ptr -10h
.text:00000FD8 var_C           = dword ptr -0Ch
.text:00000FD8 var_4           = dword ptr -4
.text:00000FD8
.text:00000FD8                 push    ebp
.text:00000FD9                 mov     ebp, esp
.text:00000FDB                 push    0FFFFFFFFh
.text:00000FDD                 push    offset __ehhandler$??1CUpdateItem@NTar@NArchive@@QAE@XZ
.text:00000FE2                 mov     eax, large fs:0
.text:00000FE8                 push    eax
.text:00000FE9                 push    ecx
.text:00000FEA                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00000FF1                 mov     eax, dword ptr ds:___security_cookie
.text:00000FF6                 xor     eax, ebp
.text:00000FF8                 push    eax
.text:00000FF9                 lea     eax, [ebp+var_C]
.text:00000FFC                 mov     large fs:0, eax
.text:00001002                 mov     [ebp+var_10], ecx
.text:00001005                 mov     [ebp+var_4], 1
.text:0000100C                 mov     ecx, [ebp+var_10]
.text:0000100F                 add     ecx, 38h ; '8'  ; this
.text:00001012                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00001017                 mov     byte ptr [ebp+var_4], 0
.text:0000101B                 mov     ecx, [ebp+var_10]
.text:0000101E                 add     ecx, 2Ch ; ','  ; this
.text:00001021                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00001026                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000102D                 mov     ecx, [ebp+var_10]
.text:00001030                 add     ecx, 20h ; ' '  ; this
.text:00001033                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00001038                 mov     ecx, [ebp+var_C]
.text:0000103B                 mov     large fs:0, ecx
.text:00001042                 pop     ecx
.text:00001043                 add     esp, 10h
.text:00001046                 cmp     ebp, esp
.text:00001048                 call    __RTC_CheckEsp
.text:0000104D                 mov     esp, ebp
.text:0000104F                 pop     ebp
.text:00001050                 retn
.text:00001050 ??1CUpdateItem@NTar@NArchive@@QAE@XZ endp
.text:00001050
.text:00001050 ; ---------------------------------------------------------------------------
.text:00001051                 align 4
.text:00001051 _text           ends
.text:00001051
.text$x:00001054 ; ===========================================================================
.text$x:00001054
.text$x:00001054 ; Segment type: Pure code
.text$x:00001054 ; Segment permissions: Read/Execute
.text$x:00001054 _text$x         segment para public 'CODE' use32
.text$x:00001054                 assume cs:_text$x
.text$x:00001054                 ;org 1054h
.text$x:00001054 ; COMDAT (pick associative to section at FD8)
.text$x:00001054                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text$x:00001054
.text$x:00001054 ; =============== S U B R O U T I N E =======================================
.text$x:00001054
.text$x:00001054
.text$x:00001054 __unwindfunclet$??1CUpdateItem@NTar@NArchive@@QAE@XZ$0 proc near
.text$x:00001054                                         ; DATA XREF: .xdata$x:0000108Co
.text$x:00001054                 mov     ecx, [ebp-10h]
.text$x:00001057                 add     ecx, 20h ; ' '  ; this
.text$x:0000105A                 jmp     ??1AString@@QAE@XZ ; AString::~AString(void)
.text$x:0000105A __unwindfunclet$??1CUpdateItem@NTar@NArchive@@QAE@XZ$0 endp
.text$x:0000105A
.text$x:0000105F
.text$x:0000105F ; =============== S U B R O U T I N E =======================================
.text$x:0000105F
.text$x:0000105F
.text$x:0000105F __unwindfunclet$??1CUpdateItem@NTar@NArchive@@QAE@XZ$1 proc near
.text$x:0000105F                                         ; DATA XREF: .xdata$x:00001094o
.text$x:0000105F                 mov     ecx, [ebp-10h]
.text$x:00001062                 add     ecx, 2Ch ; ','  ; this
.text$x:00001065                 jmp     ??1AString@@QAE@XZ ; AString::~AString(void)
.text$x:00001065 __unwindfunclet$??1CUpdateItem@NTar@NArchive@@QAE@XZ$1 endp
.text$x:00001065
.text$x:0000106A
.text$x:0000106A ; =============== S U B R O U T I N E =======================================
.text$x:0000106A
.text$x:0000106A
.text$x:0000106A __ehhandler$??1CUpdateItem@NTar@NArchive@@QAE@XZ proc near
.text$x:0000106A                                         ; DATA XREF: NArchive::NTar::CUpdateItem::~CUpdateItem(void)+5o
.text$x:0000106A
.text$x:0000106A arg_4           = dword ptr  8
.text$x:0000106A
.text$x:0000106A                 mov     edx, [esp+arg_4]
.text$x:0000106E                 lea     eax, [edx+0Ch]
.text$x:00001071                 mov     ecx, [edx-8]
.text$x:00001074                 xor     ecx, eax
.text$x:00001076                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000107B                 mov     eax, offset __ehfuncinfo$??1CUpdateItem@NTar@NArchive@@QAE@XZ
.text$x:00001080                 jmp     ___CxxFrameHandler3
.text$x:00001080 __ehhandler$??1CUpdateItem@NTar@NArchive@@QAE@XZ endp
.text$x:00001080
.text$x:00001080 ; ---------------------------------------------------------------------------
.text$x:00001085                 align 4
.text$x:00001085 _text$x         ends
.text$x:00001085
.xdata$x:00001088 ; ===========================================================================
.xdata$x:00001088
.xdata$x:00001088 ; Segment type: Pure data
.xdata$x:00001088 ; Segment permissions: Read
.xdata$x:00001088 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001088                 assume cs:_xdata$x
.xdata$x:00001088                 ;org 1088h
.xdata$x:00001088 ; COMDAT (pick associative to section at FD8)
.xdata$x:00001088 __unwindtable$??1CUpdateItem@NTar@NArchive@@QAE@XZ db 0FFh
.xdata$x:00001088                                         ; DATA XREF: .xdata$x:000010A0o
.xdata$x:00001089                 db 0FFh
.xdata$x:0000108A                 db 0FFh
.xdata$x:0000108B                 db 0FFh
.xdata$x:0000108C                 dd offset __unwindfunclet$??1CUpdateItem@NTar@NArchive@@QAE@XZ$0
.xdata$x:00001090                 db    0
.xdata$x:00001091                 db    0
.xdata$x:00001092                 db    0
.xdata$x:00001093                 db    0
.xdata$x:00001094                 dd offset __unwindfunclet$??1CUpdateItem@NTar@NArchive@@QAE@XZ$1
.xdata$x:00001098 __ehfuncinfo$??1CUpdateItem@NTar@NArchive@@QAE@XZ db  22h ; "
.xdata$x:00001098                                         ; DATA XREF: __ehhandler$??1CUpdateItem@NTar@NArchive@@QAE@XZ+11o
.xdata$x:00001099                 db    5
.xdata$x:0000109A                 db  93h ; 
.xdata$x:0000109B                 db  19h
.xdata$x:0000109C                 db    2
.xdata$x:0000109D                 db    0
.xdata$x:0000109E                 db    0
.xdata$x:0000109F                 db    0
.xdata$x:000010A0                 dd offset __unwindtable$??1CUpdateItem@NTar@NArchive@@QAE@XZ
.xdata$x:000010A4                 db    0
.xdata$x:000010A5                 db    0
.xdata$x:000010A6                 db    0
.xdata$x:000010A7                 db    0
.xdata$x:000010A8                 db    0
.xdata$x:000010A9                 db    0
.xdata$x:000010AA                 db    0
.xdata$x:000010AB                 db    0
.xdata$x:000010AC                 db    0
.xdata$x:000010AD                 db    0
.xdata$x:000010AE                 db    0
.xdata$x:000010AF                 db    0
.xdata$x:000010B0                 db    0
.xdata$x:000010B1                 db    0
.xdata$x:000010B2                 db    0
.xdata$x:000010B3                 db    0
.xdata$x:000010B4                 db    0
.xdata$x:000010B5                 db    0
.xdata$x:000010B6                 db    0
.xdata$x:000010B7                 db    0
.xdata$x:000010B8                 db    1
.xdata$x:000010B9                 db    0
.xdata$x:000010BA                 db    0
.xdata$x:000010BB                 db    0
.xdata$x:000010BB _xdata$x        ends
.xdata$x:000010BB
.text:000010BC ; ===========================================================================
.text:000010BC
.text:000010BC ; Segment type: Pure code
.text:000010BC ; Segment permissions: Read/Execute
.text:000010BC _text           segment para public 'CODE' use32
.text:000010BC                 assume cs:_text
.text:000010BC                 ;org 10BCh
.text:000010BC ; COMDAT (pick any)
.text:000010BC                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000010BC
.text:000010BC ; =============== S U B R O U T I N E =======================================
.text:000010BC
.text:000010BC ; Attributes: bp-based frame
.text:000010BC
.text:000010BC ; public: __thiscall CMyComPtr<struct ISequentialInStream>::operator struct ISequentialInStream *(void)const
.text:000010BC                 public ??B?$CMyComPtr@UISequentialInStream@@@@QBEPAUISequentialInStream@@XZ
.text:000010BC ??B?$CMyComPtr@UISequentialInStream@@@@QBEPAUISequentialInStream@@XZ proc near
.text:000010BC                                         ; CODE XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+74p
.text:000010BC
.text:000010BC var_4           = dword ptr -4
.text:000010BC
.text:000010BC                 push    ebp
.text:000010BD                 mov     ebp, esp
.text:000010BF                 push    ecx
.text:000010C0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000010C7                 mov     [ebp+var_4], ecx
.text:000010CA                 mov     eax, [ebp+var_4]
.text:000010CD                 mov     eax, [eax]
.text:000010CF                 mov     esp, ebp
.text:000010D1                 pop     ebp
.text:000010D2                 retn
.text:000010D2 ??B?$CMyComPtr@UISequentialInStream@@@@QBEPAUISequentialInStream@@XZ endp
.text:000010D2
.text:000010D2 ; ---------------------------------------------------------------------------
.text:000010D3                 align 4
.text:000010D3 _text           ends
.text:000010D3
.text:000010D4 ; ===========================================================================
.text:000010D4
.text:000010D4 ; Segment type: Pure code
.text:000010D4 ; Segment permissions: Read/Execute
.text:000010D4 _text           segment para public 'CODE' use32
.text:000010D4                 assume cs:_text
.text:000010D4                 ;org 10D4h
.text:000010D4 ; COMDAT (pick any)
.text:000010D4                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000010D4
.text:000010D4 ; =============== S U B R O U T I N E =======================================
.text:000010D4
.text:000010D4 ; Attributes: bp-based frame
.text:000010D4
.text:000010D4 ; public: __thiscall CMyComPtr<struct IInStream>::operator struct IInStream *(void)const
.text:000010D4                 public ??B?$CMyComPtr@UIInStream@@@@QBEPAUIInStream@@XZ
.text:000010D4 ??B?$CMyComPtr@UIInStream@@@@QBEPAUIInStream@@XZ proc near
.text:000010D4                                         ; CODE XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+4Ep
.text:000010D4                                         ; NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+827p
.text:000010D4
.text:000010D4 var_4           = dword ptr -4
.text:000010D4
.text:000010D4                 push    ebp
.text:000010D5                 mov     ebp, esp
.text:000010D7                 push    ecx
.text:000010D8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000010DF                 mov     [ebp+var_4], ecx
.text:000010E2                 mov     eax, [ebp+var_4]
.text:000010E5                 mov     eax, [eax]
.text:000010E7                 mov     esp, ebp
.text:000010E9                 pop     ebp
.text:000010EA                 retn
.text:000010EA ??B?$CMyComPtr@UIInStream@@@@QBEPAUIInStream@@XZ endp
.text:000010EA
.text:000010EA ; ---------------------------------------------------------------------------
.text:000010EB                 align 4
.text:000010EB _text           ends
.text:000010EB
.text:000010EC ; ===========================================================================
.text:000010EC
.text:000010EC ; Segment type: Pure code
.text:000010EC ; Segment permissions: Read/Execute
.text:000010EC _text           segment para public 'CODE' use32
.text:000010EC                 assume cs:_text
.text:000010EC                 ;org 10ECh
.text:000010EC ; COMDAT (pick any)
.text:000010EC                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000010EC
.text:000010EC ; =============== S U B R O U T I N E =======================================
.text:000010EC
.text:000010EC ; Attributes: bp-based frame
.text:000010EC
.text:000010EC ; public: __thiscall CObjectVector<struct NArchive::NTar::CUpdateItem>::CObjectVector<struct NArchive::NTar::CUpdateItem>(void)
.text:000010EC                 public ??0?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAE@XZ
.text:000010EC ??0?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAE@XZ proc near
.text:000010EC                                         ; CODE XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+95p
.text:000010EC
.text:000010EC var_4           = dword ptr -4
.text:000010EC
.text:000010EC                 push    ebp
.text:000010ED                 mov     ebp, esp
.text:000010EF                 push    ecx
.text:000010F0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000010F7                 mov     [ebp+var_4], ecx
.text:000010FA                 mov     ecx, [ebp+var_4]
.text:000010FD                 call    ??0?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::CRecordVector<void *>(void)
.text:00001102                 mov     eax, [ebp+var_4]
.text:00001105                 add     esp, 4
.text:00001108                 cmp     ebp, esp
.text:0000110A                 call    __RTC_CheckEsp
.text:0000110F                 mov     esp, ebp
.text:00001111                 pop     ebp
.text:00001112                 retn
.text:00001112 ??0?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAE@XZ endp
.text:00001112
.text:00001112 ; ---------------------------------------------------------------------------
.text:00001113                 align 4
.text:00001113 _text           ends
.text:00001113
.text:00001114 ; ===========================================================================
.text:00001114
.text:00001114 ; Segment type: Pure code
.text:00001114 ; Segment permissions: Read/Execute
.text:00001114 _text           segment para public 'CODE' use32
.text:00001114                 assume cs:_text
.text:00001114                 ;org 1114h
.text:00001114 ; COMDAT (pick any)
.text:00001114                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001114
.text:00001114 ; =============== S U B R O U T I N E =======================================
.text:00001114
.text:00001114 ; Attributes: bp-based frame
.text:00001114
.text:00001114 ; int __stdcall CObjectVector<NArchive::NTar::CUpdateItem>::Add(struct NArchive::NTar::CUpdateItem *)
.text:00001114                 public ?Add@?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAEIABUCUpdateItem@NTar@NArchive@@@Z
.text:00001114 ?Add@?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAEIABUCUpdateItem@NTar@NArchive@@@Z proc near
.text:00001114                                         ; CODE XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+7EEp
.text:00001114
.text:00001114 var_1C          = dword ptr -1Ch
.text:00001114 var_18          = dword ptr -18h
.text:00001114 var_14          = dword ptr -14h
.text:00001114 var_10          = dword ptr -10h
.text:00001114 var_C           = dword ptr -0Ch
.text:00001114 var_4           = dword ptr -4
.text:00001114 arg_0           = dword ptr  8
.text:00001114
.text:00001114                 push    ebp
.text:00001115                 mov     ebp, esp
.text:00001117                 push    0FFFFFFFFh
.text:00001119                 push    offset __ehhandler$?Add@?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAEIABUCUpdateItem@NTar@NArchive@@@Z
.text:0000111E                 mov     eax, large fs:0
.text:00001124                 push    eax
.text:00001125                 sub     esp, 10h
.text:00001128                 mov     eax, 0CCCCCCCCh
.text:0000112D                 mov     [ebp+var_1C], eax
.text:00001130                 mov     [ebp+var_18], eax
.text:00001133                 mov     [ebp+var_14], eax
.text:00001136                 mov     [ebp+var_10], eax
.text:00001139                 mov     eax, dword ptr ds:___security_cookie
.text:0000113E                 xor     eax, ebp
.text:00001140                 push    eax
.text:00001141                 lea     eax, [ebp+var_C]
.text:00001144                 mov     large fs:0, eax
.text:0000114A                 mov     [ebp+var_10], ecx
.text:0000114D                 push    48h ; 'H'       ; unsigned int
.text:0000114F                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00001154                 add     esp, 4
.text:00001157                 mov     [ebp+var_18], eax
.text:0000115A                 mov     [ebp+var_4], 0
.text:00001161                 cmp     [ebp+var_18], 0
.text:00001165                 jz      short loc_1178
.text:00001167                 mov     eax, [ebp+arg_0]
.text:0000116A                 push    eax             ; struct NArchive::NTar::CUpdateItem *
.text:0000116B                 mov     ecx, [ebp+var_18] ; this
.text:0000116E                 call    ??0CUpdateItem@NTar@NArchive@@QAE@ABU012@@Z ; NArchive::NTar::CUpdateItem::CUpdateItem(NArchive::NTar::CUpdateItem const &)
.text:00001173                 mov     [ebp+var_1C], eax
.text:00001176                 jmp     short loc_117F
.text:00001178 ; ---------------------------------------------------------------------------
.text:00001178
.text:00001178 loc_1178:                               ; CODE XREF: CObjectVector<NArchive::NTar::CUpdateItem>::Add(NArchive::NTar::CUpdateItem const &)+51j
.text:00001178                 mov     [ebp+var_1C], 0
.text:0000117F
.text:0000117F loc_117F:                               ; CODE XREF: CObjectVector<NArchive::NTar::CUpdateItem>::Add(NArchive::NTar::CUpdateItem const &)+62j
.text:0000117F                 mov     ecx, [ebp+var_1C]
.text:00001182                 mov     [ebp+var_14], ecx
.text:00001185                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000118C                 mov     edx, [ebp+var_14]
.text:0000118F                 push    edx
.text:00001190                 mov     ecx, [ebp+var_10]
.text:00001193                 call    ?Add@?$CRecordVector@PAX@@QAEIQAX@Z ; CRecordVector<void *>::Add(void * const)
.text:00001198                 mov     ecx, [ebp+var_C]
.text:0000119B                 mov     large fs:0, ecx
.text:000011A2                 pop     ecx
.text:000011A3                 add     esp, 1Ch
.text:000011A6                 cmp     ebp, esp
.text:000011A8                 call    __RTC_CheckEsp
.text:000011AD                 mov     esp, ebp
.text:000011AF                 pop     ebp
.text:000011B0                 retn    4
.text:000011B0 ?Add@?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAEIABUCUpdateItem@NTar@NArchive@@@Z endp
.text:000011B0
.text:000011B0 ; ---------------------------------------------------------------------------
.text:000011B3                 align 4
.text:000011B3 _text           ends
.text:000011B3
.text$x:000011B4 ; ===========================================================================
.text$x:000011B4
.text$x:000011B4 ; Segment type: Pure code
.text$x:000011B4 ; Segment permissions: Read/Execute
.text$x:000011B4 _text$x         segment para public 'CODE' use32
.text$x:000011B4                 assume cs:_text$x
.text$x:000011B4                 ;org 11B4h
.text$x:000011B4 ; COMDAT (pick associative to section at 1114)
.text$x:000011B4                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text$x:000011B4
.text$x:000011B4 ; =============== S U B R O U T I N E =======================================
.text$x:000011B4
.text$x:000011B4
.text$x:000011B4 __unwindfunclet$?Add@?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAEIABUCUpdateItem@NTar@NArchive@@@Z$0 proc near
.text$x:000011B4                                         ; DATA XREF: .xdata$x:000011E0o
.text$x:000011B4                 mov     eax, [ebp-18h]
.text$x:000011B7                 push    eax             ; void *
.text$x:000011B8                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:000011BD                 pop     ecx
.text$x:000011BE                 retn
.text$x:000011BE __unwindfunclet$?Add@?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAEIABUCUpdateItem@NTar@NArchive@@@Z$0 endp
.text$x:000011BE
.text$x:000011BF
.text$x:000011BF ; =============== S U B R O U T I N E =======================================
.text$x:000011BF
.text$x:000011BF
.text$x:000011BF __ehhandler$?Add@?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAEIABUCUpdateItem@NTar@NArchive@@@Z proc near
.text$x:000011BF                                         ; DATA XREF: CObjectVector<NArchive::NTar::CUpdateItem>::Add(NArchive::NTar::CUpdateItem const &)+5o
.text$x:000011BF
.text$x:000011BF arg_4           = dword ptr  8
.text$x:000011BF
.text$x:000011BF                 mov     edx, [esp+arg_4]
.text$x:000011C3                 lea     eax, [edx+0Ch]
.text$x:000011C6                 mov     ecx, [edx-14h]
.text$x:000011C9                 xor     ecx, eax
.text$x:000011CB                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000011D0                 mov     eax, offset __ehfuncinfo$?Add@?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAEIABUCUpdateItem@NTar@NArchive@@@Z
.text$x:000011D5                 jmp     ___CxxFrameHandler3
.text$x:000011D5 __ehhandler$?Add@?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAEIABUCUpdateItem@NTar@NArchive@@@Z endp
.text$x:000011D5
.text$x:000011D5 ; ---------------------------------------------------------------------------
.text$x:000011DA                 align 4
.text$x:000011DA _text$x         ends
.text$x:000011DA
.xdata$x:000011DC ; ===========================================================================
.xdata$x:000011DC
.xdata$x:000011DC ; Segment type: Pure data
.xdata$x:000011DC ; Segment permissions: Read
.xdata$x:000011DC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000011DC                 assume cs:_xdata$x
.xdata$x:000011DC                 ;org 11DCh
.xdata$x:000011DC ; COMDAT (pick associative to section at 1114)
.xdata$x:000011DC __unwindtable$?Add@?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAEIABUCUpdateItem@NTar@NArchive@@@Z db 0FFh
.xdata$x:000011DC                                         ; DATA XREF: .xdata$x:000011ECo
.xdata$x:000011DD                 db 0FFh
.xdata$x:000011DE                 db 0FFh
.xdata$x:000011DF                 db 0FFh
.xdata$x:000011E0                 dd offset __unwindfunclet$?Add@?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAEIABUCUpdateItem@NTar@NArchive@@@Z$0
.xdata$x:000011E4 __ehfuncinfo$?Add@?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAEIABUCUpdateItem@NTar@NArchive@@@Z db  22h ; "
.xdata$x:000011E4                                         ; DATA XREF: __ehhandler$?Add@?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAEIABUCUpdateItem@NTar@NArchive@@@Z+11o
.xdata$x:000011E5                 db    5
.xdata$x:000011E6                 db  93h ; 
.xdata$x:000011E7                 db  19h
.xdata$x:000011E8                 db    1
.xdata$x:000011E9                 db    0
.xdata$x:000011EA                 db    0
.xdata$x:000011EB                 db    0
.xdata$x:000011EC                 dd offset __unwindtable$?Add@?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAEIABUCUpdateItem@NTar@NArchive@@@Z
.xdata$x:000011F0                 db    0
.xdata$x:000011F1                 db    0
.xdata$x:000011F2                 db    0
.xdata$x:000011F3                 db    0
.xdata$x:000011F4                 db    0
.xdata$x:000011F5                 db    0
.xdata$x:000011F6                 db    0
.xdata$x:000011F7                 db    0
.xdata$x:000011F8                 db    0
.xdata$x:000011F9                 db    0
.xdata$x:000011FA                 db    0
.xdata$x:000011FB                 db    0
.xdata$x:000011FC                 db    0
.xdata$x:000011FD                 db    0
.xdata$x:000011FE                 db    0
.xdata$x:000011FF                 db    0
.xdata$x:00001200                 db    0
.xdata$x:00001201                 db    0
.xdata$x:00001202                 db    0
.xdata$x:00001203                 db    0
.xdata$x:00001204                 db    1
.xdata$x:00001205                 db    0
.xdata$x:00001206                 db    0
.xdata$x:00001207                 db    0
.xdata$x:00001207 _xdata$x        ends
.xdata$x:00001207
.text:00001208 ; ===========================================================================
.text:00001208
.text:00001208 ; Segment type: Pure code
.text:00001208 ; Segment permissions: Read/Execute
.text:00001208 _text           segment para public 'CODE' use32
.text:00001208                 assume cs:_text
.text:00001208                 ;org 1208h
.text:00001208 ; COMDAT (pick any)
.text:00001208                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001208
.text:00001208 ; =============== S U B R O U T I N E =======================================
.text:00001208
.text:00001208 ; Attributes: bp-based frame
.text:00001208
.text:00001208 ; public: __thiscall CObjectVector<struct NArchive::NTar::CUpdateItem>::~CObjectVector<struct NArchive::NTar::CUpdateItem>(void)
.text:00001208                 public ??1?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAE@XZ
.text:00001208 ??1?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAE@XZ proc near
.text:00001208                                         ; CODE XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+12Ep
.text:00001208                                         ; NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+1A8p ...
.text:00001208
.text:00001208 var_20          = dword ptr -20h
.text:00001208 var_1C          = dword ptr -1Ch
.text:00001208 var_18          = dword ptr -18h
.text:00001208 var_14          = dword ptr -14h
.text:00001208 var_10          = dword ptr -10h
.text:00001208 var_C           = dword ptr -0Ch
.text:00001208 var_4           = dword ptr -4
.text:00001208
.text:00001208                 push    ebp
.text:00001209                 mov     ebp, esp
.text:0000120B                 push    0FFFFFFFFh
.text:0000120D                 push    offset __ehhandler$??1?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAE@XZ
.text:00001212                 mov     eax, large fs:0
.text:00001218                 push    eax
.text:00001219                 sub     esp, 14h
.text:0000121C                 mov     eax, 0CCCCCCCCh
.text:00001221                 mov     [ebp+var_20], eax
.text:00001224                 mov     [ebp+var_1C], eax
.text:00001227                 mov     [ebp+var_18], eax
.text:0000122A                 mov     [ebp+var_14], eax
.text:0000122D                 mov     [ebp+var_10], eax
.text:00001230                 mov     eax, dword ptr ds:___security_cookie
.text:00001235                 xor     eax, ebp
.text:00001237                 push    eax
.text:00001238                 lea     eax, [ebp+var_C]
.text:0000123B                 mov     large fs:0, eax
.text:00001241                 mov     [ebp+var_10], ecx
.text:00001244                 mov     [ebp+var_4], 0
.text:0000124B                 mov     ecx, [ebp+var_10]
.text:0000124E                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00001253                 mov     [ebp+var_14], eax
.text:00001256
.text:00001256 loc_1256:                               ; CODE XREF: CObjectVector<NArchive::NTar::CUpdateItem>::~CObjectVector<NArchive::NTar::CUpdateItem>(void):loc_1298j
.text:00001256                 cmp     [ebp+var_14], 0
.text:0000125A                 jz      short loc_129A
.text:0000125C                 mov     eax, [ebp+var_14]
.text:0000125F                 sub     eax, 1
.text:00001262                 mov     [ebp+var_14], eax
.text:00001265                 mov     ecx, [ebp+var_14]
.text:00001268                 push    ecx
.text:00001269                 mov     ecx, [ebp+var_10]
.text:0000126C                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00001271                 mov     edx, [eax]
.text:00001273                 mov     [ebp+var_1C], edx
.text:00001276                 mov     eax, [ebp+var_1C]
.text:00001279                 mov     [ebp+var_18], eax
.text:0000127C                 cmp     [ebp+var_18], 0
.text:00001280                 jz      short loc_1291
.text:00001282                 push    1
.text:00001284                 mov     ecx, [ebp+var_18]
.text:00001287                 call    ??_GCUpdateItem@NTar@NArchive@@QAEPAXI@Z ; NArchive::NTar::CUpdateItem::`scalar deleting destructor'(uint)
.text:0000128C                 mov     [ebp+var_20], eax
.text:0000128F                 jmp     short loc_1298
.text:00001291 ; ---------------------------------------------------------------------------
.text:00001291
.text:00001291 loc_1291:                               ; CODE XREF: CObjectVector<NArchive::NTar::CUpdateItem>::~CObjectVector<NArchive::NTar::CUpdateItem>(void)+78j
.text:00001291                 mov     [ebp+var_20], 0
.text:00001298
.text:00001298 loc_1298:                               ; CODE XREF: CObjectVector<NArchive::NTar::CUpdateItem>::~CObjectVector<NArchive::NTar::CUpdateItem>(void)+87j
.text:00001298                 jmp     short loc_1256
.text:0000129A ; ---------------------------------------------------------------------------
.text:0000129A
.text:0000129A loc_129A:                               ; CODE XREF: CObjectVector<NArchive::NTar::CUpdateItem>::~CObjectVector<NArchive::NTar::CUpdateItem>(void)+52j
.text:0000129A                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000012A1                 mov     ecx, [ebp+var_10]
.text:000012A4                 call    ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text:000012A9                 mov     ecx, [ebp+var_C]
.text:000012AC                 mov     large fs:0, ecx
.text:000012B3                 pop     ecx
.text:000012B4                 add     esp, 20h
.text:000012B7                 cmp     ebp, esp
.text:000012B9                 call    __RTC_CheckEsp
.text:000012BE                 mov     esp, ebp
.text:000012C0                 pop     ebp
.text:000012C1                 retn
.text:000012C1 ??1?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAE@XZ endp
.text:000012C1
.text:000012C1 ; ---------------------------------------------------------------------------
.text:000012C2                 align 4
.text:000012C2 _text           ends
.text:000012C2
.text$x:000012C4 ; ===========================================================================
.text$x:000012C4
.text$x:000012C4 ; Segment type: Pure code
.text$x:000012C4 ; Segment permissions: Read/Execute
.text$x:000012C4 _text$x         segment para public 'CODE' use32
.text$x:000012C4                 assume cs:_text$x
.text$x:000012C4                 ;org 12C4h
.text$x:000012C4 ; COMDAT (pick associative to section at 1208)
.text$x:000012C4                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text$x:000012C4
.text$x:000012C4 ; =============== S U B R O U T I N E =======================================
.text$x:000012C4
.text$x:000012C4
.text$x:000012C4 __unwindfunclet$??1?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAE@XZ$0 proc near
.text$x:000012C4                                         ; DATA XREF: .xdata$x:000012ECo
.text$x:000012C4                 mov     ecx, [ebp-10h]
.text$x:000012C7                 jmp     ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text$x:000012C7 __unwindfunclet$??1?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAE@XZ$0 endp
.text$x:000012C7
.text$x:000012CC
.text$x:000012CC ; =============== S U B R O U T I N E =======================================
.text$x:000012CC
.text$x:000012CC
.text$x:000012CC __ehhandler$??1?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAE@XZ proc near
.text$x:000012CC                                         ; DATA XREF: CObjectVector<NArchive::NTar::CUpdateItem>::~CObjectVector<NArchive::NTar::CUpdateItem>(void)+5o
.text$x:000012CC
.text$x:000012CC arg_4           = dword ptr  8
.text$x:000012CC
.text$x:000012CC                 mov     edx, [esp+arg_4]
.text$x:000012D0                 lea     eax, [edx+0Ch]
.text$x:000012D3                 mov     ecx, [edx-18h]
.text$x:000012D6                 xor     ecx, eax
.text$x:000012D8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000012DD                 mov     eax, offset __ehfuncinfo$??1?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAE@XZ
.text$x:000012E2                 jmp     ___CxxFrameHandler3
.text$x:000012E2 __ehhandler$??1?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAE@XZ endp
.text$x:000012E2
.text$x:000012E2 ; ---------------------------------------------------------------------------
.text$x:000012E7                 align 4
.text$x:000012E7 _text$x         ends
.text$x:000012E7
.xdata$x:000012E8 ; ===========================================================================
.xdata$x:000012E8
.xdata$x:000012E8 ; Segment type: Pure data
.xdata$x:000012E8 ; Segment permissions: Read
.xdata$x:000012E8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000012E8                 assume cs:_xdata$x
.xdata$x:000012E8                 ;org 12E8h
.xdata$x:000012E8 ; COMDAT (pick associative to section at 1208)
.xdata$x:000012E8 __unwindtable$??1?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAE@XZ db 0FFh
.xdata$x:000012E8                                         ; DATA XREF: .xdata$x:000012F8o
.xdata$x:000012E9                 db 0FFh
.xdata$x:000012EA                 db 0FFh
.xdata$x:000012EB                 db 0FFh
.xdata$x:000012EC                 dd offset __unwindfunclet$??1?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAE@XZ$0
.xdata$x:000012F0 __ehfuncinfo$??1?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAE@XZ db  22h ; "
.xdata$x:000012F0                                         ; DATA XREF: __ehhandler$??1?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAE@XZ+11o
.xdata$x:000012F1                 db    5
.xdata$x:000012F2                 db  93h ; 
.xdata$x:000012F3                 db  19h
.xdata$x:000012F4                 db    1
.xdata$x:000012F5                 db    0
.xdata$x:000012F6                 db    0
.xdata$x:000012F7                 db    0
.xdata$x:000012F8                 dd offset __unwindtable$??1?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAE@XZ
.xdata$x:000012FC                 db    0
.xdata$x:000012FD                 db    0
.xdata$x:000012FE                 db    0
.xdata$x:000012FF                 db    0
.xdata$x:00001300                 db    0
.xdata$x:00001301                 db    0
.xdata$x:00001302                 db    0
.xdata$x:00001303                 db    0
.xdata$x:00001304                 db    0
.xdata$x:00001305                 db    0
.xdata$x:00001306                 db    0
.xdata$x:00001307                 db    0
.xdata$x:00001308                 db    0
.xdata$x:00001309                 db    0
.xdata$x:0000130A                 db    0
.xdata$x:0000130B                 db    0
.xdata$x:0000130C                 db    0
.xdata$x:0000130D                 db    0
.xdata$x:0000130E                 db    0
.xdata$x:0000130F                 db    0
.xdata$x:00001310                 db    1
.xdata$x:00001311                 db    0
.xdata$x:00001312                 db    0
.xdata$x:00001313                 db    0
.xdata$x:00001313 _xdata$x        ends
.xdata$x:00001313
.text:00001314 ; ===========================================================================
.text:00001314
.text:00001314 ; Segment type: Pure code
.text:00001314 ; Segment permissions: Read/Execute
.text:00001314 _text           segment para public 'CODE' use32
.text:00001314                 assume cs:_text
.text:00001314                 ;org 1314h
.text:00001314 ; COMDAT (pick any)
.text:00001314                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001314
.text:00001314 ; =============== S U B R O U T I N E =======================================
.text:00001314
.text:00001314 ; Attributes: bp-based frame
.text:00001314
.text:00001314 ; public: void __thiscall CObjectVector<struct NArchive::NTar::CUpdateItem>::Sort(int (__stdcall *)(void * const *, void * const *, void *), void *)
.text:00001314                 public ?Sort@?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAEXP6GHPBQAX0PAX@Z1@Z
.text:00001314 ?Sort@?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAEXP6GHPBQAX0PAX@Z1@Z proc near
.text:00001314                                         ; CODE XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+81Cp
.text:00001314
.text:00001314 var_4           = dword ptr -4
.text:00001314 arg_0           = dword ptr  8
.text:00001314 arg_4           = dword ptr  0Ch
.text:00001314
.text:00001314                 push    ebp
.text:00001315                 mov     ebp, esp
.text:00001317                 push    ecx
.text:00001318                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000131F                 mov     [ebp+var_4], ecx
.text:00001322                 mov     eax, [ebp+arg_4]
.text:00001325                 push    eax
.text:00001326                 mov     ecx, [ebp+arg_0]
.text:00001329                 push    ecx
.text:0000132A                 mov     ecx, [ebp+var_4]
.text:0000132D                 call    ?Sort@?$CRecordVector@PAX@@QAEXP6GHPBQAX0PAX@Z1@Z ; CRecordVector<void *>::Sort(int (*)(void * const *,void * const *,void *),void *)
.text:00001332                 add     esp, 4
.text:00001335                 cmp     ebp, esp
.text:00001337                 call    __RTC_CheckEsp
.text:0000133C                 mov     esp, ebp
.text:0000133E                 pop     ebp
.text:0000133F                 retn    8
.text:0000133F ?Sort@?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAEXP6GHPBQAX0PAX@Z1@Z endp
.text:0000133F
.text:0000133F ; ---------------------------------------------------------------------------
.text:00001342                 align 4
.text:00001342 _text           ends
.text:00001342
.text:00001344 ; ===========================================================================
.text:00001344
.text:00001344 ; Segment type: Pure code
.text:00001344 ; Segment permissions: Read/Execute
.text:00001344 _text           segment para public 'CODE' use32
.text:00001344                 assume cs:_text
.text:00001344                 ;org 1344h
.text:00001344 ; COMDAT (pick any)
.text:00001344                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001344
.text:00001344 ; =============== S U B R O U T I N E =======================================
.text:00001344
.text:00001344 ; Attributes: bp-based frame
.text:00001344
.text:00001344 ; _DWORD __thiscall NArchive::NTar::CUpdateItem::CUpdateItem(NArchive::NTar::CUpdateItem *this, const struct NArchive::NTar::CUpdateItem *)
.text:00001344                 public ??0CUpdateItem@NTar@NArchive@@QAE@ABU012@@Z
.text:00001344 ??0CUpdateItem@NTar@NArchive@@QAE@ABU012@@Z proc near
.text:00001344                                         ; CODE XREF: CObjectVector<NArchive::NTar::CUpdateItem>::Add(NArchive::NTar::CUpdateItem const &)+5Ap
.text:00001344
.text:00001344 var_10          = dword ptr -10h
.text:00001344 var_C           = dword ptr -0Ch
.text:00001344 var_4           = dword ptr -4
.text:00001344 arg_0           = dword ptr  8
.text:00001344
.text:00001344                 push    ebp
.text:00001345                 mov     ebp, esp
.text:00001347                 push    0FFFFFFFFh
.text:00001349                 push    offset __ehhandler$??0CUpdateItem@NTar@NArchive@@QAE@ABU012@@Z
.text:0000134E                 mov     eax, large fs:0
.text:00001354                 push    eax
.text:00001355                 push    ecx
.text:00001356                 mov     [ebp+var_10], 0CCCCCCCCh
.text:0000135D                 mov     eax, dword ptr ds:___security_cookie
.text:00001362                 xor     eax, ebp
.text:00001364                 push    eax
.text:00001365                 lea     eax, [ebp+var_C]
.text:00001368                 mov     large fs:0, eax
.text:0000136E                 mov     [ebp+var_10], ecx
.text:00001371                 mov     eax, [ebp+var_10]
.text:00001374                 mov     ecx, [ebp+arg_0]
.text:00001377                 mov     edx, [ecx]
.text:00001379                 mov     [eax], edx
.text:0000137B                 mov     eax, [ebp+var_10]
.text:0000137E                 mov     ecx, [ebp+arg_0]
.text:00001381                 mov     edx, [ecx+4]
.text:00001384                 mov     [eax+4], edx
.text:00001387                 mov     eax, [ebp+var_10]
.text:0000138A                 mov     ecx, [ebp+arg_0]
.text:0000138D                 mov     edx, [ecx+8]
.text:00001390                 mov     [eax+8], edx
.text:00001393                 mov     ecx, [ecx+0Ch]
.text:00001396                 mov     [eax+0Ch], ecx
.text:00001399                 mov     edx, [ebp+var_10]
.text:0000139C                 mov     eax, [ebp+arg_0]
.text:0000139F                 mov     ecx, [eax+10h]
.text:000013A2                 mov     [edx+10h], ecx
.text:000013A5                 mov     eax, [eax+14h]
.text:000013A8                 mov     [edx+14h], eax
.text:000013AB                 mov     ecx, [ebp+var_10]
.text:000013AE                 mov     edx, [ebp+arg_0]
.text:000013B1                 mov     eax, [edx+18h]
.text:000013B4                 mov     [ecx+18h], eax
.text:000013B7                 mov     ecx, [ebp+var_10]
.text:000013BA                 mov     edx, [ebp+arg_0]
.text:000013BD                 mov     al, [edx+1Ch]
.text:000013C0                 mov     [ecx+1Ch], al
.text:000013C3                 mov     ecx, [ebp+var_10]
.text:000013C6                 mov     edx, [ebp+arg_0]
.text:000013C9                 mov     al, [edx+1Dh]
.text:000013CC                 mov     [ecx+1Dh], al
.text:000013CF                 mov     ecx, [ebp+var_10]
.text:000013D2                 mov     edx, [ebp+arg_0]
.text:000013D5                 mov     al, [edx+1Eh]
.text:000013D8                 mov     [ecx+1Eh], al
.text:000013DB                 mov     ecx, [ebp+arg_0]
.text:000013DE                 add     ecx, 20h ; ' '
.text:000013E1                 push    ecx
.text:000013E2                 mov     ecx, [ebp+var_10]
.text:000013E5                 add     ecx, 20h ; ' '
.text:000013E8                 call    ??0AString@@QAE@ABV0@@Z ; AString::AString(AString const &)
.text:000013ED                 mov     [ebp+var_4], 0
.text:000013F4                 mov     edx, [ebp+arg_0]
.text:000013F7                 add     edx, 2Ch ; ','
.text:000013FA                 push    edx
.text:000013FB                 mov     ecx, [ebp+var_10]
.text:000013FE                 add     ecx, 2Ch ; ','
.text:00001401                 call    ??0AString@@QAE@ABV0@@Z ; AString::AString(AString const &)
.text:00001406                 mov     byte ptr [ebp+var_4], 1
.text:0000140A                 mov     eax, [ebp+arg_0]
.text:0000140D                 add     eax, 38h ; '8'
.text:00001410                 push    eax
.text:00001411                 mov     ecx, [ebp+var_10]
.text:00001414                 add     ecx, 38h ; '8'
.text:00001417                 call    ??0AString@@QAE@ABV0@@Z ; AString::AString(AString const &)
.text:0000141C                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001423                 mov     eax, [ebp+var_10]
.text:00001426                 mov     ecx, [ebp+var_C]
.text:00001429                 mov     large fs:0, ecx
.text:00001430                 pop     ecx
.text:00001431                 add     esp, 10h
.text:00001434                 cmp     ebp, esp
.text:00001436                 call    __RTC_CheckEsp
.text:0000143B                 mov     esp, ebp
.text:0000143D                 pop     ebp
.text:0000143E                 retn    4
.text:0000143E ??0CUpdateItem@NTar@NArchive@@QAE@ABU012@@Z endp
.text:0000143E
.text:0000143E ; ---------------------------------------------------------------------------
.text:00001441                 align 4
.text:00001441 _text           ends
.text:00001441
.text$x:00001444 ; ===========================================================================
.text$x:00001444
.text$x:00001444 ; Segment type: Pure code
.text$x:00001444 ; Segment permissions: Read/Execute
.text$x:00001444 _text$x         segment para public 'CODE' use32
.text$x:00001444                 assume cs:_text$x
.text$x:00001444                 ;org 1444h
.text$x:00001444 ; COMDAT (pick associative to section at 1344)
.text$x:00001444                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text$x:00001444
.text$x:00001444 ; =============== S U B R O U T I N E =======================================
.text$x:00001444
.text$x:00001444
.text$x:00001444 __unwindfunclet$??0CUpdateItem@NTar@NArchive@@QAE@ABU012@@Z$0 proc near
.text$x:00001444                                         ; DATA XREF: .xdata$x:0000147Co
.text$x:00001444                 mov     ecx, [ebp-10h]
.text$x:00001447                 add     ecx, 20h ; ' '  ; this
.text$x:0000144A                 jmp     ??1AString@@QAE@XZ ; AString::~AString(void)
.text$x:0000144A __unwindfunclet$??0CUpdateItem@NTar@NArchive@@QAE@ABU012@@Z$0 endp
.text$x:0000144A
.text$x:0000144F
.text$x:0000144F ; =============== S U B R O U T I N E =======================================
.text$x:0000144F
.text$x:0000144F
.text$x:0000144F __unwindfunclet$??0CUpdateItem@NTar@NArchive@@QAE@ABU012@@Z$1 proc near
.text$x:0000144F                                         ; DATA XREF: .xdata$x:00001484o
.text$x:0000144F                 mov     ecx, [ebp-10h]
.text$x:00001452                 add     ecx, 2Ch ; ','  ; this
.text$x:00001455                 jmp     ??1AString@@QAE@XZ ; AString::~AString(void)
.text$x:00001455 __unwindfunclet$??0CUpdateItem@NTar@NArchive@@QAE@ABU012@@Z$1 endp
.text$x:00001455
.text$x:0000145A
.text$x:0000145A ; =============== S U B R O U T I N E =======================================
.text$x:0000145A
.text$x:0000145A
.text$x:0000145A __ehhandler$??0CUpdateItem@NTar@NArchive@@QAE@ABU012@@Z proc near
.text$x:0000145A                                         ; DATA XREF: NArchive::NTar::CUpdateItem::CUpdateItem(NArchive::NTar::CUpdateItem const &)+5o
.text$x:0000145A
.text$x:0000145A arg_4           = dword ptr  8
.text$x:0000145A
.text$x:0000145A                 mov     edx, [esp+arg_4]
.text$x:0000145E                 lea     eax, [edx+0Ch]
.text$x:00001461                 mov     ecx, [edx-8]
.text$x:00001464                 xor     ecx, eax
.text$x:00001466                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000146B                 mov     eax, offset __ehfuncinfo$??0CUpdateItem@NTar@NArchive@@QAE@ABU012@@Z
.text$x:00001470                 jmp     ___CxxFrameHandler3
.text$x:00001470 __ehhandler$??0CUpdateItem@NTar@NArchive@@QAE@ABU012@@Z endp
.text$x:00001470
.text$x:00001470 ; ---------------------------------------------------------------------------
.text$x:00001475                 align 4
.text$x:00001475 _text$x         ends
.text$x:00001475
.xdata$x:00001478 ; ===========================================================================
.xdata$x:00001478
.xdata$x:00001478 ; Segment type: Pure data
.xdata$x:00001478 ; Segment permissions: Read
.xdata$x:00001478 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001478                 assume cs:_xdata$x
.xdata$x:00001478                 ;org 1478h
.xdata$x:00001478 ; COMDAT (pick associative to section at 1344)
.xdata$x:00001478 __unwindtable$??0CUpdateItem@NTar@NArchive@@QAE@ABU012@@Z db 0FFh
.xdata$x:00001478                                         ; DATA XREF: .xdata$x:00001490o
.xdata$x:00001479                 db 0FFh
.xdata$x:0000147A                 db 0FFh
.xdata$x:0000147B                 db 0FFh
.xdata$x:0000147C                 dd offset __unwindfunclet$??0CUpdateItem@NTar@NArchive@@QAE@ABU012@@Z$0
.xdata$x:00001480                 db    0
.xdata$x:00001481                 db    0
.xdata$x:00001482                 db    0
.xdata$x:00001483                 db    0
.xdata$x:00001484                 dd offset __unwindfunclet$??0CUpdateItem@NTar@NArchive@@QAE@ABU012@@Z$1
.xdata$x:00001488 __ehfuncinfo$??0CUpdateItem@NTar@NArchive@@QAE@ABU012@@Z db  22h ; "
.xdata$x:00001488                                         ; DATA XREF: __ehhandler$??0CUpdateItem@NTar@NArchive@@QAE@ABU012@@Z+11o
.xdata$x:00001489                 db    5
.xdata$x:0000148A                 db  93h ; 
.xdata$x:0000148B                 db  19h
.xdata$x:0000148C                 db    2
.xdata$x:0000148D                 db    0
.xdata$x:0000148E                 db    0
.xdata$x:0000148F                 db    0
.xdata$x:00001490                 dd offset __unwindtable$??0CUpdateItem@NTar@NArchive@@QAE@ABU012@@Z
.xdata$x:00001494                 db    0
.xdata$x:00001495                 db    0
.xdata$x:00001496                 db    0
.xdata$x:00001497                 db    0
.xdata$x:00001498                 db    0
.xdata$x:00001499                 db    0
.xdata$x:0000149A                 db    0
.xdata$x:0000149B                 db    0
.xdata$x:0000149C                 db    0
.xdata$x:0000149D                 db    0
.xdata$x:0000149E                 db    0
.xdata$x:0000149F                 db    0
.xdata$x:000014A0                 db    0
.xdata$x:000014A1                 db    0
.xdata$x:000014A2                 db    0
.xdata$x:000014A3                 db    0
.xdata$x:000014A4                 db    0
.xdata$x:000014A5                 db    0
.xdata$x:000014A6                 db    0
.xdata$x:000014A7                 db    0
.xdata$x:000014A8                 db    1
.xdata$x:000014A9                 db    0
.xdata$x:000014AA                 db    0
.xdata$x:000014AB                 db    0
.xdata$x:000014AB _xdata$x        ends
.xdata$x:000014AB
.text:000014AC ; ===========================================================================
.text:000014AC
.text:000014AC ; Segment type: Pure code
.text:000014AC ; Segment permissions: Read/Execute
.text:000014AC _text           segment para public 'CODE' use32
.text:000014AC                 assume cs:_text
.text:000014AC                 ;org 14ACh
.text:000014AC ; COMDAT (pick any)
.text:000014AC                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000014AC
.text:000014AC ; =============== S U B R O U T I N E =======================================
.text:000014AC
.text:000014AC ; Attributes: bp-based frame
.text:000014AC
.text:000014AC ; public: void * __thiscall NArchive::NTar::CUpdateItem::`scalar deleting destructor'(unsigned int)
.text:000014AC                 public ??_GCUpdateItem@NTar@NArchive@@QAEPAXI@Z
.text:000014AC ??_GCUpdateItem@NTar@NArchive@@QAEPAXI@Z proc near
.text:000014AC                                         ; CODE XREF: CObjectVector<NArchive::NTar::CUpdateItem>::~CObjectVector<NArchive::NTar::CUpdateItem>(void)+7Fp
.text:000014AC
.text:000014AC var_4           = dword ptr -4
.text:000014AC arg_0           = dword ptr  8
.text:000014AC
.text:000014AC                 push    ebp
.text:000014AD                 mov     ebp, esp
.text:000014AF                 push    ecx
.text:000014B0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000014B7                 mov     [ebp+var_4], ecx
.text:000014BA                 mov     ecx, [ebp+var_4] ; this
.text:000014BD                 call    ??1CUpdateItem@NTar@NArchive@@QAE@XZ ; NArchive::NTar::CUpdateItem::~CUpdateItem(void)
.text:000014C2                 mov     eax, [ebp+arg_0]
.text:000014C5                 and     eax, 1
.text:000014C8                 jz      short loc_14D6
.text:000014CA                 mov     ecx, [ebp+var_4]
.text:000014CD                 push    ecx             ; void *
.text:000014CE                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:000014D3                 add     esp, 4
.text:000014D6
.text:000014D6 loc_14D6:                               ; CODE XREF: NArchive::NTar::CUpdateItem::`scalar deleting destructor'(uint)+1Cj
.text:000014D6                 mov     eax, [ebp+var_4]
.text:000014D9                 add     esp, 4
.text:000014DC                 cmp     ebp, esp
.text:000014DE                 call    __RTC_CheckEsp
.text:000014E3                 mov     esp, ebp
.text:000014E5                 pop     ebp
.text:000014E6                 retn    4
.text:000014E6 ??_GCUpdateItem@NTar@NArchive@@QAEPAXI@Z endp
.text:000014E6
.text:000014E6 ; ---------------------------------------------------------------------------
.text:000014E9                 align 4
.text:000014E9 _text           ends
.text:000014E9
.text:000014EC ; ===========================================================================
.text:000014EC
.text:000014EC ; Segment type: Pure code
.text:000014EC ; Segment permissions: Read/Execute
.text:000014EC _text           segment para public 'CODE' use32
.text:000014EC                 assume cs:_text
.text:000014EC                 ;org 14ECh
.text:000014EC ; COMDAT (pick any)
.text:000014EC                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000014EC
.text:000014EC ; =============== S U B R O U T I N E =======================================
.text:000014EC
.text:000014EC ; Attributes: bp-based frame
.text:000014EC
.text:000014EC ; public: __thiscall CRecordVector<void *>::CRecordVector<void *>(void)
.text:000014EC                 public ??0?$CRecordVector@PAX@@QAE@XZ
.text:000014EC ??0?$CRecordVector@PAX@@QAE@XZ proc near
.text:000014EC                                         ; CODE XREF: CObjectVector<NArchive::NTar::CUpdateItem>::CObjectVector<NArchive::NTar::CUpdateItem>(void)+11p
.text:000014EC
.text:000014EC var_4           = dword ptr -4
.text:000014EC
.text:000014EC                 push    ebp
.text:000014ED                 mov     ebp, esp
.text:000014EF                 push    ecx
.text:000014F0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000014F7                 mov     [ebp+var_4], ecx
.text:000014FA                 mov     eax, [ebp+var_4]
.text:000014FD                 mov     dword ptr [eax], 0
.text:00001503                 mov     ecx, [ebp+var_4]
.text:00001506                 mov     dword ptr [ecx+4], 0
.text:0000150D                 mov     edx, [ebp+var_4]
.text:00001510                 mov     dword ptr [edx+8], 0
.text:00001517                 mov     eax, [ebp+var_4]
.text:0000151A                 mov     esp, ebp
.text:0000151C                 pop     ebp
.text:0000151D                 retn
.text:0000151D ??0?$CRecordVector@PAX@@QAE@XZ endp
.text:0000151D
.text:0000151D ; ---------------------------------------------------------------------------
.text:0000151E                 align 10h
.text:0000151E _text           ends
.text:0000151E
.text:00001520 ; ===========================================================================
.text:00001520
.text:00001520 ; Segment type: Pure code
.text:00001520 ; Segment permissions: Read/Execute
.text:00001520 _text           segment para public 'CODE' use32
.text:00001520                 assume cs:_text
.text:00001520                 ;org 1520h
.text:00001520 ; COMDAT (pick any)
.text:00001520                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001520
.text:00001520 ; =============== S U B R O U T I N E =======================================
.text:00001520
.text:00001520 ; Attributes: bp-based frame
.text:00001520
.text:00001520 ; public: unsigned int __thiscall CRecordVector<void *>::Size(void)const
.text:00001520                 public ?Size@?$CRecordVector@PAX@@QBEIXZ
.text:00001520 ?Size@?$CRecordVector@PAX@@QBEIXZ proc near
.text:00001520                                         ; CODE XREF: CObjectVector<NArchive::NTar::CUpdateItem>::~CObjectVector<NArchive::NTar::CUpdateItem>(void)+46p
.text:00001520
.text:00001520 var_4           = dword ptr -4
.text:00001520
.text:00001520                 push    ebp
.text:00001521                 mov     ebp, esp
.text:00001523                 push    ecx
.text:00001524                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000152B                 mov     [ebp+var_4], ecx
.text:0000152E                 mov     eax, [ebp+var_4]
.text:00001531                 mov     eax, [eax+4]
.text:00001534                 mov     esp, ebp
.text:00001536                 pop     ebp
.text:00001537                 retn
.text:00001537 ?Size@?$CRecordVector@PAX@@QBEIXZ endp
.text:00001537
.text:00001537 _text           ends
.text:00001537
.text:00001538 ; ===========================================================================
.text:00001538
.text:00001538 ; Segment type: Pure code
.text:00001538 ; Segment permissions: Read/Execute
.text:00001538 _text           segment para public 'CODE' use32
.text:00001538                 assume cs:_text
.text:00001538                 ;org 1538h
.text:00001538 ; COMDAT (pick any)
.text:00001538                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001538
.text:00001538 ; =============== S U B R O U T I N E =======================================
.text:00001538
.text:00001538 ; Attributes: bp-based frame
.text:00001538
.text:00001538 ; public: __thiscall CRecordVector<void *>::~CRecordVector<void *>(void)
.text:00001538                 public ??1?$CRecordVector@PAX@@QAE@XZ
.text:00001538 ??1?$CRecordVector@PAX@@QAE@XZ proc near
.text:00001538                                         ; CODE XREF: CObjectVector<NArchive::NTar::CUpdateItem>::~CObjectVector<NArchive::NTar::CUpdateItem>(void)+9Cp
.text:00001538                                         ; __unwindfunclet$??1?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@QAE@XZ$0+3j
.text:00001538
.text:00001538 var_8           = dword ptr -8
.text:00001538 var_4           = dword ptr -4
.text:00001538
.text:00001538                 push    ebp
.text:00001539                 mov     ebp, esp
.text:0000153B                 sub     esp, 8
.text:0000153E                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00001545                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000154C                 mov     [ebp+var_4], ecx
.text:0000154F                 mov     eax, [ebp+var_4]
.text:00001552                 mov     ecx, [eax]
.text:00001554                 mov     [ebp+var_8], ecx
.text:00001557                 mov     edx, [ebp+var_8]
.text:0000155A                 push    edx             ; void *
.text:0000155B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00001560                 add     esp, 4
.text:00001563                 add     esp, 8
.text:00001566                 cmp     ebp, esp
.text:00001568                 call    __RTC_CheckEsp
.text:0000156D                 mov     esp, ebp
.text:0000156F                 pop     ebp
.text:00001570                 retn
.text:00001570 ??1?$CRecordVector@PAX@@QAE@XZ endp
.text:00001570
.text:00001570 ; ---------------------------------------------------------------------------
.text:00001571                 align 4
.text:00001571 _text           ends
.text:00001571
.text:00001574 ; ===========================================================================
.text:00001574
.text:00001574 ; Segment type: Pure code
.text:00001574 ; Segment permissions: Read/Execute
.text:00001574 _text           segment para public 'CODE' use32
.text:00001574                 assume cs:_text
.text:00001574                 ;org 1574h
.text:00001574 ; COMDAT (pick any)
.text:00001574                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001574
.text:00001574 ; =============== S U B R O U T I N E =======================================
.text:00001574
.text:00001574 ; Attributes: bp-based frame
.text:00001574
.text:00001574 ; public: unsigned int __thiscall CRecordVector<void *>::Add(void * const)
.text:00001574                 public ?Add@?$CRecordVector@PAX@@QAEIQAX@Z
.text:00001574 ?Add@?$CRecordVector@PAX@@QAEIQAX@Z proc near
.text:00001574                                         ; CODE XREF: CObjectVector<NArchive::NTar::CUpdateItem>::Add(NArchive::NTar::CUpdateItem const &)+7Fp
.text:00001574
.text:00001574 var_8           = dword ptr -8
.text:00001574 var_4           = dword ptr -4
.text:00001574 arg_0           = dword ptr  8
.text:00001574
.text:00001574                 push    ebp
.text:00001575                 mov     ebp, esp
.text:00001577                 sub     esp, 8
.text:0000157A                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00001581                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001588                 mov     [ebp+var_4], ecx
.text:0000158B                 mov     ecx, [ebp+var_4]
.text:0000158E                 call    ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ ; CRecordVector<void *>::ReserveOnePosition(void)
.text:00001593                 mov     eax, [ebp+var_4]
.text:00001596                 mov     ecx, [eax+4]
.text:00001599                 mov     edx, [ebp+var_4]
.text:0000159C                 mov     eax, [edx]
.text:0000159E                 mov     edx, [ebp+arg_0]
.text:000015A1                 mov     [eax+ecx*4], edx
.text:000015A4                 mov     eax, [ebp+var_4]
.text:000015A7                 mov     ecx, [eax+4]
.text:000015AA                 mov     [ebp+var_8], ecx
.text:000015AD                 mov     edx, [ebp+var_4]
.text:000015B0                 mov     eax, [edx+4]
.text:000015B3                 add     eax, 1
.text:000015B6                 mov     ecx, [ebp+var_4]
.text:000015B9                 mov     [ecx+4], eax
.text:000015BC                 mov     eax, [ebp+var_8]
.text:000015BF                 add     esp, 8
.text:000015C2                 cmp     ebp, esp
.text:000015C4                 call    __RTC_CheckEsp
.text:000015C9                 mov     esp, ebp
.text:000015CB                 pop     ebp
.text:000015CC                 retn    4
.text:000015CC ?Add@?$CRecordVector@PAX@@QAEIQAX@Z endp
.text:000015CC
.text:000015CC ; ---------------------------------------------------------------------------
.text:000015CF                 align 10h
.text:000015CF _text           ends
.text:000015CF
.text:000015D0 ; ===========================================================================
.text:000015D0
.text:000015D0 ; Segment type: Pure code
.text:000015D0 ; Segment permissions: Read/Execute
.text:000015D0 _text           segment para public 'CODE' use32
.text:000015D0                 assume cs:_text
.text:000015D0                 ;org 15D0h
.text:000015D0 ; COMDAT (pick any)
.text:000015D0                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000015D0
.text:000015D0 ; =============== S U B R O U T I N E =======================================
.text:000015D0
.text:000015D0 ; Attributes: bp-based frame
.text:000015D0
.text:000015D0 ; public: void * & __thiscall CRecordVector<void *>::operator[](unsigned int)
.text:000015D0                 public ??A?$CRecordVector@PAX@@QAEAAPAXI@Z
.text:000015D0 ??A?$CRecordVector@PAX@@QAEAAPAXI@Z proc near
.text:000015D0                                         ; CODE XREF: CObjectVector<NArchive::NTar::CUpdateItem>::~CObjectVector<NArchive::NTar::CUpdateItem>(void)+64p
.text:000015D0
.text:000015D0 var_4           = dword ptr -4
.text:000015D0 arg_0           = dword ptr  8
.text:000015D0
.text:000015D0                 push    ebp
.text:000015D1                 mov     ebp, esp
.text:000015D3                 push    ecx
.text:000015D4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000015DB                 mov     [ebp+var_4], ecx
.text:000015DE                 mov     eax, [ebp+var_4]
.text:000015E1                 mov     ecx, [eax]
.text:000015E3                 mov     edx, [ebp+arg_0]
.text:000015E6                 lea     eax, [ecx+edx*4]
.text:000015E9                 mov     esp, ebp
.text:000015EB                 pop     ebp
.text:000015EC                 retn    4
.text:000015EC ??A?$CRecordVector@PAX@@QAEAAPAXI@Z endp
.text:000015EC
.text:000015EC ; ---------------------------------------------------------------------------
.text:000015EF                 align 10h
.text:000015EF _text           ends
.text:000015EF
.text:000015F0 ; ===========================================================================
.text:000015F0
.text:000015F0 ; Segment type: Pure code
.text:000015F0 ; Segment permissions: Read/Execute
.text:000015F0 _text           segment para public 'CODE' use32
.text:000015F0                 assume cs:_text
.text:000015F0                 ;org 15F0h
.text:000015F0 ; COMDAT (pick any)
.text:000015F0                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000015F0
.text:000015F0 ; =============== S U B R O U T I N E =======================================
.text:000015F0
.text:000015F0 ; Attributes: bp-based frame
.text:000015F0
.text:000015F0 ; public: void __thiscall CRecordVector<void *>::Sort(int (__stdcall *)(void * const *, void * const *, void *), void *)
.text:000015F0                 public ?Sort@?$CRecordVector@PAX@@QAEXP6GHPBQAX0PAX@Z1@Z
.text:000015F0 ?Sort@?$CRecordVector@PAX@@QAEXP6GHPBQAX0PAX@Z1@Z proc near
.text:000015F0                                         ; CODE XREF: CObjectVector<NArchive::NTar::CUpdateItem>::Sort(int (*)(void * const *,void * const *,void *),void *)+19p
.text:000015F0
.text:000015F0 var_14          = dword ptr -14h
.text:000015F0 var_10          = dword ptr -10h
.text:000015F0 var_C           = dword ptr -0Ch
.text:000015F0 var_8           = dword ptr -8
.text:000015F0 var_4           = dword ptr -4
.text:000015F0 arg_0           = dword ptr  8
.text:000015F0 arg_4           = dword ptr  0Ch
.text:000015F0
.text:000015F0                 push    ebp
.text:000015F1                 mov     ebp, esp
.text:000015F3                 sub     esp, 14h
.text:000015F6                 mov     eax, 0CCCCCCCCh
.text:000015FB                 mov     [ebp+var_14], eax
.text:000015FE                 mov     [ebp+var_10], eax
.text:00001601                 mov     [ebp+var_C], eax
.text:00001604                 mov     [ebp+var_8], eax
.text:00001607                 mov     [ebp+var_4], eax
.text:0000160A                 mov     [ebp+var_4], ecx
.text:0000160D                 mov     eax, [ebp+var_4]
.text:00001610                 mov     ecx, [eax+4]
.text:00001613                 mov     [ebp+var_8], ecx
.text:00001616                 cmp     [ebp+var_8], 1
.text:0000161A                 ja      short loc_1621
.text:0000161C                 jmp     loc_16A5
.text:00001621 ; ---------------------------------------------------------------------------
.text:00001621
.text:00001621 loc_1621:                               ; CODE XREF: CRecordVector<void *>::Sort(int (*)(void * const *,void * const *,void *),void *)+2Aj
.text:00001621                 mov     ecx, [ebp+var_4]
.text:00001624                 call    ?Front@?$CRecordVector@PAX@@QAEAAPAXXZ ; CRecordVector<void *>::Front(void)
.text:00001629                 sub     eax, 4
.text:0000162C                 mov     [ebp+var_C], eax
.text:0000162F                 mov     edx, [ebp+var_8]
.text:00001632                 shr     edx, 1
.text:00001634                 mov     [ebp+var_10], edx
.text:00001637
.text:00001637 loc_1637:                               ; CODE XREF: CRecordVector<void *>::Sort(int (*)(void * const *,void * const *,void *),void *)+69j
.text:00001637                 mov     eax, [ebp+arg_4]
.text:0000163A                 push    eax
.text:0000163B                 mov     ecx, [ebp+arg_0]
.text:0000163E                 push    ecx
.text:0000163F                 mov     edx, [ebp+var_8]
.text:00001642                 push    edx
.text:00001643                 mov     eax, [ebp+var_10]
.text:00001646                 push    eax
.text:00001647                 mov     ecx, [ebp+var_C]
.text:0000164A                 push    ecx
.text:0000164B                 call    ?SortRefDown@?$CRecordVector@PAX@@SGXPAPAXIIP6GHPBQAX1PAX@Z2@Z ; CRecordVector<void *>::SortRefDown(void * *,uint,uint,int (*)(void * const *,void * const *,void *),void *)
.text:00001650                 mov     edx, [ebp+var_10]
.text:00001653                 sub     edx, 1
.text:00001656                 mov     [ebp+var_10], edx
.text:00001659                 jnz     short loc_1637
.text:0000165B
.text:0000165B loc_165B:                               ; CODE XREF: CRecordVector<void *>::Sort(int (*)(void * const *,void * const *,void *),void *)+B3j
.text:0000165B                 mov     eax, [ebp+var_8]
.text:0000165E                 mov     ecx, [ebp+var_C]
.text:00001661                 mov     edx, [ecx+eax*4]
.text:00001664                 mov     [ebp+var_14], edx
.text:00001667                 mov     eax, [ebp+var_8]
.text:0000166A                 mov     ecx, [ebp+var_C]
.text:0000166D                 mov     edx, [ebp+var_C]
.text:00001670                 mov     edx, [edx+4]
.text:00001673                 mov     [ecx+eax*4], edx
.text:00001676                 mov     eax, [ebp+var_8]
.text:00001679                 sub     eax, 1
.text:0000167C                 mov     [ebp+var_8], eax
.text:0000167F                 mov     ecx, [ebp+var_C]
.text:00001682                 mov     edx, [ebp+var_14]
.text:00001685                 mov     [ecx+4], edx
.text:00001688                 mov     eax, [ebp+arg_4]
.text:0000168B                 push    eax
.text:0000168C                 mov     ecx, [ebp+arg_0]
.text:0000168F                 push    ecx
.text:00001690                 mov     edx, [ebp+var_8]
.text:00001693                 push    edx
.text:00001694                 push    1
.text:00001696                 mov     eax, [ebp+var_C]
.text:00001699                 push    eax
.text:0000169A                 call    ?SortRefDown@?$CRecordVector@PAX@@SGXPAPAXIIP6GHPBQAX1PAX@Z2@Z ; CRecordVector<void *>::SortRefDown(void * *,uint,uint,int (*)(void * const *,void * const *,void *),void *)
.text:0000169F                 cmp     [ebp+var_8], 1
.text:000016A3                 ja      short loc_165B
.text:000016A5
.text:000016A5 loc_16A5:                               ; CODE XREF: CRecordVector<void *>::Sort(int (*)(void * const *,void * const *,void *),void *)+2Cj
.text:000016A5                 add     esp, 14h
.text:000016A8                 cmp     ebp, esp
.text:000016AA                 call    __RTC_CheckEsp
.text:000016AF                 mov     esp, ebp
.text:000016B1                 pop     ebp
.text:000016B2                 retn    8
.text:000016B2 ?Sort@?$CRecordVector@PAX@@QAEXP6GHPBQAX0PAX@Z1@Z endp
.text:000016B2
.text:000016B2 ; ---------------------------------------------------------------------------
.text:000016B5                 align 4
.text:000016B5 _text           ends
.text:000016B5
.text:000016B8 ; ===========================================================================
.text:000016B8
.text:000016B8 ; Segment type: Pure code
.text:000016B8 ; Segment permissions: Read/Execute
.text:000016B8 _text           segment para public 'CODE' use32
.text:000016B8                 assume cs:_text
.text:000016B8                 ;org 16B8h
.text:000016B8 ; COMDAT (pick any)
.text:000016B8                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000016B8
.text:000016B8 ; =============== S U B R O U T I N E =======================================
.text:000016B8
.text:000016B8 ; Attributes: bp-based frame
.text:000016B8
.text:000016B8 ; private: void __thiscall CRecordVector<void *>::ReserveOnePosition(void)
.text:000016B8                 public ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ
.text:000016B8 ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ proc near
.text:000016B8                                         ; CODE XREF: CRecordVector<void *>::Add(void * const)+1Ap
.text:000016B8
.text:000016B8 var_14          = dword ptr -14h
.text:000016B8 var_10          = dword ptr -10h
.text:000016B8 Dst             = dword ptr -0Ch
.text:000016B8 var_8           = dword ptr -8
.text:000016B8 var_4           = dword ptr -4
.text:000016B8
.text:000016B8                 push    ebp
.text:000016B9                 mov     ebp, esp
.text:000016BB                 sub     esp, 14h
.text:000016BE                 mov     eax, 0CCCCCCCCh
.text:000016C3                 mov     [ebp+var_14], eax
.text:000016C6                 mov     [ebp+var_10], eax
.text:000016C9                 mov     [ebp+Dst], eax
.text:000016CC                 mov     [ebp+var_8], eax
.text:000016CF                 mov     [ebp+var_4], eax
.text:000016D2                 mov     [ebp+var_4], ecx
.text:000016D5                 mov     eax, [ebp+var_4]
.text:000016D8                 mov     ecx, [ebp+var_4]
.text:000016DB                 mov     edx, [eax+4]
.text:000016DE                 cmp     edx, [ecx+8]
.text:000016E1                 jnz     loc_176C
.text:000016E7                 mov     eax, [ebp+var_4]
.text:000016EA                 mov     ecx, [eax+8]
.text:000016ED                 shr     ecx, 2
.text:000016F0                 mov     edx, [ebp+var_4]
.text:000016F3                 mov     eax, [edx+8]
.text:000016F6                 lea     ecx, [eax+ecx+1]
.text:000016FA                 mov     [ebp+var_8], ecx
.text:000016FD                 xor     ecx, ecx
.text:000016FF                 mov     eax, [ebp+var_8]
.text:00001702                 mov     edx, 4
.text:00001707                 mul     edx
.text:00001709                 seto    cl
.text:0000170C                 neg     ecx
.text:0000170E                 or      ecx, eax
.text:00001710                 push    ecx             ; unsigned int
.text:00001711                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00001716                 add     esp, 4
.text:00001719                 mov     [ebp+var_10], eax
.text:0000171C                 mov     eax, [ebp+var_10]
.text:0000171F                 mov     [ebp+Dst], eax
.text:00001722                 mov     ecx, [ebp+var_4]
.text:00001725                 cmp     dword ptr [ecx+4], 0
.text:00001729                 jz      short loc_1747
.text:0000172B                 mov     edx, [ebp+var_4]
.text:0000172E                 mov     eax, [edx+4]
.text:00001731                 shl     eax, 2
.text:00001734                 push    eax             ; Size
.text:00001735                 mov     ecx, [ebp+var_4]
.text:00001738                 mov     edx, [ecx]
.text:0000173A                 push    edx             ; Src
.text:0000173B                 mov     eax, [ebp+Dst]
.text:0000173E                 push    eax             ; Dst
.text:0000173F                 call    _memcpy
.text:00001744                 add     esp, 0Ch
.text:00001747
.text:00001747 loc_1747:                               ; CODE XREF: CRecordVector<void *>::ReserveOnePosition(void)+71j
.text:00001747                 mov     ecx, [ebp+var_4]
.text:0000174A                 mov     edx, [ecx]
.text:0000174C                 mov     [ebp+var_14], edx
.text:0000174F                 mov     eax, [ebp+var_14]
.text:00001752                 push    eax             ; void *
.text:00001753                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00001758                 add     esp, 4
.text:0000175B                 mov     ecx, [ebp+var_4]
.text:0000175E                 mov     edx, [ebp+Dst]
.text:00001761                 mov     [ecx], edx
.text:00001763                 mov     eax, [ebp+var_4]
.text:00001766                 mov     ecx, [ebp+var_8]
.text:00001769                 mov     [eax+8], ecx
.text:0000176C
.text:0000176C loc_176C:                               ; CODE XREF: CRecordVector<void *>::ReserveOnePosition(void)+29j
.text:0000176C                 add     esp, 14h
.text:0000176F                 cmp     ebp, esp
.text:00001771                 call    __RTC_CheckEsp
.text:00001776                 mov     esp, ebp
.text:00001778                 pop     ebp
.text:00001779                 retn
.text:00001779 ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ endp
.text:00001779
.text:00001779 ; ---------------------------------------------------------------------------
.text:0000177A                 align 4
.text:0000177A _text           ends
.text:0000177A
.text:0000177C ; ===========================================================================
.text:0000177C
.text:0000177C ; Segment type: Pure code
.text:0000177C ; Segment permissions: Read/Execute
.text:0000177C _text           segment para public 'CODE' use32
.text:0000177C                 assume cs:_text
.text:0000177C                 ;org 177Ch
.text:0000177C ; COMDAT (pick any)
.text:0000177C                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:0000177C
.text:0000177C ; =============== S U B R O U T I N E =======================================
.text:0000177C
.text:0000177C ; Attributes: bp-based frame
.text:0000177C
.text:0000177C ; public: void * & __thiscall CRecordVector<void *>::Front(void)
.text:0000177C                 public ?Front@?$CRecordVector@PAX@@QAEAAPAXXZ
.text:0000177C ?Front@?$CRecordVector@PAX@@QAEAAPAXXZ proc near
.text:0000177C                                         ; CODE XREF: CRecordVector<void *>::Sort(int (*)(void * const *,void * const *,void *),void *)+34p
.text:0000177C
.text:0000177C var_4           = dword ptr -4
.text:0000177C
.text:0000177C                 push    ebp
.text:0000177D                 mov     ebp, esp
.text:0000177F                 push    ecx
.text:00001780                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001787                 mov     [ebp+var_4], ecx
.text:0000178A                 mov     eax, [ebp+var_4]
.text:0000178D                 mov     eax, [eax]
.text:0000178F                 mov     esp, ebp
.text:00001791                 pop     ebp
.text:00001792                 retn
.text:00001792 ?Front@?$CRecordVector@PAX@@QAEAAPAXXZ endp
.text:00001792
.text:00001792 ; ---------------------------------------------------------------------------
.text:00001793                 align 4
.text:00001793 _text           ends
.text:00001793
.text:00001794 ; ===========================================================================
.text:00001794
.text:00001794 ; Segment type: Pure code
.text:00001794 ; Segment permissions: Read/Execute
.text:00001794 _text           segment para public 'CODE' use32
.text:00001794                 assume cs:_text
.text:00001794                 ;org 1794h
.text:00001794 ; COMDAT (pick any)
.text:00001794                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001794
.text:00001794 ; =============== S U B R O U T I N E =======================================
.text:00001794
.text:00001794 ; Attributes: bp-based frame
.text:00001794
.text:00001794 ; public: static void __stdcall CRecordVector<void *>::SortRefDown(void * *, unsigned int, unsigned int, int (__stdcall *)(void * const *, void * const *, void *), void *)
.text:00001794                 public ?SortRefDown@?$CRecordVector@PAX@@SGXPAPAXIIP6GHPBQAX1PAX@Z2@Z
.text:00001794 ?SortRefDown@?$CRecordVector@PAX@@SGXPAPAXIIP6GHPBQAX1PAX@Z2@Z proc near
.text:00001794                                         ; CODE XREF: CRecordVector<void *>::Sort(int (*)(void * const *,void * const *,void *),void *)+5Bp
.text:00001794                                         ; CRecordVector<void *>::Sort(int (*)(void * const *,void * const *,void *),void *)+AAp
.text:00001794
.text:00001794 var_10          = dword ptr -10h
.text:00001794 var_C           = dword ptr -0Ch
.text:00001794 var_8           = dword ptr -8
.text:00001794 var_4           = dword ptr -4
.text:00001794 arg_0           = dword ptr  8
.text:00001794 arg_4           = dword ptr  0Ch
.text:00001794 arg_8           = dword ptr  10h
.text:00001794 arg_C           = dword ptr  14h
.text:00001794 arg_10          = dword ptr  18h
.text:00001794
.text:00001794                 push    ebp
.text:00001795                 mov     ebp, esp
.text:00001797                 sub     esp, 10h
.text:0000179A                 push    esi
.text:0000179B                 mov     eax, 0CCCCCCCCh
.text:000017A0                 mov     [ebp+var_10], eax
.text:000017A3                 mov     [ebp+var_C], eax
.text:000017A6                 mov     [ebp+var_8], eax
.text:000017A9                 mov     [ebp+var_4], eax
.text:000017AC                 mov     eax, [ebp+arg_4]
.text:000017AF                 mov     ecx, [ebp+arg_0]
.text:000017B2                 mov     edx, [ecx+eax*4]
.text:000017B5                 mov     [ebp+var_8], edx
.text:000017B8
.text:000017B8 loc_17B8:                               ; CODE XREF: CRecordVector<void *>::SortRefDown(void * *,uint,uint,int (*)(void * const *,void * const *,void *),void *)+ACj
.text:000017B8                 mov     eax, [ebp+arg_4]
.text:000017BB                 shl     eax, 1
.text:000017BD                 mov     [ebp+var_10], eax
.text:000017C0                 mov     ecx, [ebp+var_10]
.text:000017C3                 cmp     ecx, [ebp+arg_8]
.text:000017C6                 jbe     short loc_17CA
.text:000017C8                 jmp     short loc_1845
.text:000017CA ; ---------------------------------------------------------------------------
.text:000017CA
.text:000017CA loc_17CA:                               ; CODE XREF: CRecordVector<void *>::SortRefDown(void * *,uint,uint,int (*)(void * const *,void * const *,void *),void *)+32j
.text:000017CA                 mov     edx, [ebp+var_10]
.text:000017CD                 cmp     edx, [ebp+arg_8]
.text:000017D0                 jnb     short loc_1804
.text:000017D2                 mov     esi, esp
.text:000017D4                 mov     eax, [ebp+arg_10]
.text:000017D7                 push    eax
.text:000017D8                 mov     ecx, [ebp+var_10]
.text:000017DB                 mov     edx, [ebp+arg_0]
.text:000017DE                 lea     eax, [edx+ecx*4]
.text:000017E1                 push    eax
.text:000017E2                 mov     ecx, [ebp+var_10]
.text:000017E5                 mov     edx, [ebp+arg_0]
.text:000017E8                 lea     eax, [edx+ecx*4+4]
.text:000017EC                 push    eax
.text:000017ED                 call    [ebp+arg_C]
.text:000017F0                 cmp     esi, esp
.text:000017F2                 call    __RTC_CheckEsp
.text:000017F7                 test    eax, eax
.text:000017F9                 jle     short loc_1804
.text:000017FB                 mov     ecx, [ebp+var_10]
.text:000017FE                 add     ecx, 1
.text:00001801                 mov     [ebp+var_10], ecx
.text:00001804
.text:00001804 loc_1804:                               ; CODE XREF: CRecordVector<void *>::SortRefDown(void * *,uint,uint,int (*)(void * const *,void * const *,void *),void *)+3Cj
.text:00001804                                         ; CRecordVector<void *>::SortRefDown(void * *,uint,uint,int (*)(void * const *,void * const *,void *),void *)+65j
.text:00001804                 mov     esi, esp
.text:00001806                 mov     edx, [ebp+arg_10]
.text:00001809                 push    edx
.text:0000180A                 mov     eax, [ebp+var_10]
.text:0000180D                 mov     ecx, [ebp+arg_0]
.text:00001810                 lea     edx, [ecx+eax*4]
.text:00001813                 push    edx
.text:00001814                 lea     eax, [ebp+var_8]
.text:00001817                 push    eax
.text:00001818                 call    [ebp+arg_C]
.text:0000181B                 cmp     esi, esp
.text:0000181D                 call    __RTC_CheckEsp
.text:00001822                 test    eax, eax
.text:00001824                 jl      short loc_1828
.text:00001826                 jmp     short loc_1845
.text:00001828 ; ---------------------------------------------------------------------------
.text:00001828
.text:00001828 loc_1828:                               ; CODE XREF: CRecordVector<void *>::SortRefDown(void * *,uint,uint,int (*)(void * const *,void * const *,void *),void *)+90j
.text:00001828                 mov     ecx, [ebp+arg_4]
.text:0000182B                 mov     edx, [ebp+arg_0]
.text:0000182E                 mov     eax, [ebp+var_10]
.text:00001831                 mov     esi, [ebp+arg_0]
.text:00001834                 mov     eax, [esi+eax*4]
.text:00001837                 mov     [edx+ecx*4], eax
.text:0000183A                 mov     ecx, [ebp+var_10]
.text:0000183D                 mov     [ebp+arg_4], ecx
.text:00001840                 jmp     loc_17B8
.text:00001845 ; ---------------------------------------------------------------------------
.text:00001845
.text:00001845 loc_1845:                               ; CODE XREF: CRecordVector<void *>::SortRefDown(void * *,uint,uint,int (*)(void * const *,void * const *,void *),void *)+34j
.text:00001845                                         ; CRecordVector<void *>::SortRefDown(void * *,uint,uint,int (*)(void * const *,void * const *,void *),void *)+92j
.text:00001845                 mov     edx, [ebp+arg_4]
.text:00001848                 mov     eax, [ebp+arg_0]
.text:0000184B                 mov     ecx, [ebp+var_8]
.text:0000184E                 mov     [eax+edx*4], ecx
.text:00001851                 push    edx
.text:00001852                 mov     ecx, ebp
.text:00001854                 push    eax
.text:00001855                 lea     edx, $LN10
.text:0000185B                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00001860                 pop     eax
.text:00001861                 pop     edx
.text:00001862                 pop     esi
.text:00001863                 add     esp, 10h
.text:00001866                 cmp     ebp, esp
.text:00001868                 call    __RTC_CheckEsp
.text:0000186D                 mov     esp, ebp
.text:0000186F                 pop     ebp
.text:00001870                 retn    14h
.text:00001870 ?SortRefDown@?$CRecordVector@PAX@@SGXPAPAXIIP6GHPBQAX1PAX@Z2@Z endp
.text:00001870
.text:00001870 ; ---------------------------------------------------------------------------
.text:00001873                 align 4
.text:00001874 $LN10           dd 1                    ; DATA XREF: CRecordVector<void *>::SortRefDown(void * *,uint,uint,int (*)(void * const *,void * const *,void *),void *)+C1o
.text:00001878                 dd offset $LN9
.text:0000187C $LN9            dd 0FFFFFFF8h, 4        ; DATA XREF: .text:00001878o
.text:00001884                 dd offset $LN8          ; "temp"
.text:00001888 $LN8            db 'temp',0             ; DATA XREF: .text:00001884o
.text:0000188D                 align 10h
.text:0000188D _text           ends
.text:0000188D
.text:00001890 ; ===========================================================================
.text:00001890
.text:00001890 ; Segment type: Pure code
.text:00001890 ; Segment permissions: Read/Execute
.text:00001890 _text           segment para public 'CODE' use32
.text:00001890                 assume cs:_text
.text:00001890                 ;org 1890h
.text:00001890 ; COMDAT (pick any)
.text:00001890                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001890
.text:00001890 ; =============== S U B R O U T I N E =======================================
.text:00001890
.text:00001890 ; Attributes: bp-based frame
.text:00001890
.text:00001890 ; int __stdcall MyCompare<int>(int, int)
.text:00001890                 public ??$MyCompare@H@@YGHHH@Z
.text:00001890 ??$MyCompare@H@@YGHHH@Z proc near       ; CODE XREF: NArchive::NTar::CompareUpdateItems(void * const *,void * const *,void *)+4Bp
.text:00001890                                         ; NArchive::NTar::CompareUpdateItems(void * const *,void * const *,void *)+72p
.text:00001890
.text:00001890 var_4           = dword ptr -4
.text:00001890 arg_0           = dword ptr  8
.text:00001890 arg_4           = dword ptr  0Ch
.text:00001890
.text:00001890                 push    ebp
.text:00001891                 mov     ebp, esp
.text:00001893                 push    ecx
.text:00001894                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000189B                 mov     eax, [ebp+arg_0]
.text:0000189E                 cmp     eax, [ebp+arg_4]
.text:000018A1                 jge     short loc_18AC
.text:000018A3                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000018AA                 jmp     short loc_18BA
.text:000018AC ; ---------------------------------------------------------------------------
.text:000018AC
.text:000018AC loc_18AC:                               ; CODE XREF: MyCompare<int>(int,int)+11j
.text:000018AC                 mov     ecx, [ebp+arg_0]
.text:000018AF                 xor     edx, edx
.text:000018B1                 cmp     ecx, [ebp+arg_4]
.text:000018B4                 setnz   dl
.text:000018B7                 mov     [ebp+var_4], edx
.text:000018BA
.text:000018BA loc_18BA:                               ; CODE XREF: MyCompare<int>(int,int)+1Aj
.text:000018BA                 mov     eax, [ebp+var_4]
.text:000018BD                 mov     esp, ebp
.text:000018BF                 pop     ebp
.text:000018C0                 retn    8
.text:000018C0 ??$MyCompare@H@@YGHHH@Z endp
.text:000018C0
.text:000018C0 _text           ends
.text:000018C0
UNDEF:000018D0 ; ===========================================================================
UNDEF:000018D0
UNDEF:000018D0 ; Segment type: Externs
UNDEF:000018D0 ; UNDEF
UNDEF:000018D0                 extrn __RTC_Shutdown:near
UNDEF:000018D0                                         ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
UNDEF:000018D4                 extrn __RTC_InitBase:near
UNDEF:000018D4                                         ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
UNDEF:000018D8 ; void __stdcall UnicodeStringToMultiByte2(struct AString *, const struct UString *, unsigned int)
UNDEF:000018D8                 extrn ?UnicodeStringToMultiByte2@@YGXAAVAString@@ABVUString@@I@Z:near
UNDEF:000018D8                                         ; CODE XREF: NArchive::NTar::GetPropString(IArchiveUpdateCallback *,uint,ulong,AString &,uint,bool)+109p
UNDEF:000018DC ; void __stdcall ConvertUnicodeToUTF8(const struct UString *, struct AString *)
UNDEF:000018DC                 extrn ?ConvertUnicodeToUTF8@@YGXABVUString@@AAVAString@@@Z:near
UNDEF:000018DC                                         ; CODE XREF: NArchive::NTar::GetPropString(IArchiveUpdateCallback *,uint,ulong,AString &,uint,bool)+F6p
UNDEF:000018E0 ; public: class UString & __thiscall UString::operator=(class UString const &)
UNDEF:000018E0                 extrn ??4UString@@QAEAAV0@ABV0@@Z:near
UNDEF:000018E0                                         ; CODE XREF: NArchive::NTar::GetPropString(IArchiveUpdateCallback *,uint,ulong,AString &,uint,bool)+D4p
UNDEF:000018E4 ; struct UString __stdcall __high NArchive::NItemName::MakeLegalName(const struct UString *)
UNDEF:000018E4                 extrn ?MakeLegalName@NItemName@NArchive@@YG?AVUString@@ABV3@@Z:near
UNDEF:000018E4                                         ; CODE XREF: NArchive::NTar::GetPropString(IArchiveUpdateCallback *,uint,ulong,AString &,uint,bool)+BBp
UNDEF:000018E8 ; _DWORD __thiscall UString::UString(UString *__hidden this, const wchar_t *)
UNDEF:000018E8                 extrn ??0UString@@QAE@PB_W@Z:near
UNDEF:000018E8                                         ; CODE XREF: NArchive::NTar::GetPropString(IArchiveUpdateCallback *,uint,ulong,AString &,uint,bool)+A2p
UNDEF:000018EC                 extrn ___security_cookie:near
UNDEF:000018EC                                         ; DATA XREF: NArchive::NTar::GetPropString(IArchiveUpdateCallback *,uint,ulong,AString &,uint,bool):loc_45r
UNDEF:000018EC                                         ; NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+2Dr ...
UNDEF:000018F0                 extrn ___CxxFrameHandler3:near
UNDEF:000018F0                                         ; CODE XREF: __ehhandler$?GetPropString@NTar@NArchive@@YGJPAUIArchiveUpdateCallback@@IKAAVAString@@I_N@Z+16j
UNDEF:000018F0                                         ; __ehhandler$?UpdateItems@CHandler@NTar@NArchive@@UAGJPAUISequentialOutStream@@IPAUIArchiveUpdateCallback@@@Z+19j ...
UNDEF:000018F4 ; __fastcall __security_check_cookie(x)
UNDEF:000018F4                 extrn @__security_check_cookie@4:near
UNDEF:000018F4                                         ; CODE XREF: __ehhandler$?GetPropString@NTar@NArchive@@YGJPAUIArchiveUpdateCallback@@IKAAVAString@@I_N@Z+Cp
UNDEF:000018F4                                         ; __ehhandler$?UpdateItems@CHandler@NTar@NArchive@@UAGJPAUISequentialOutStream@@IPAUIArchiveUpdateCallback@@@Z+Fp ...
UNDEF:000018F8 ; __fastcall _RTC_CheckStackVars(x, x)
UNDEF:000018F8                 extrn @_RTC_CheckStackVars@8:near
UNDEF:000018F8                                         ; CODE XREF: NArchive::NTar::GetPropString(IArchiveUpdateCallback *,uint,ulong,AString &,uint,bool)+162p
UNDEF:000018F8                                         ; NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+8B1p ...
UNDEF:000018FC                 extrn __RTC_CheckEsp:near
UNDEF:000018FC                                         ; CODE XREF: NArchive::NTar::GetPropString(IArchiveUpdateCallback *,uint,ulong,AString &,uint,bool)+63p
UNDEF:000018FC                                         ; NArchive::NTar::GetPropString(IArchiveUpdateCallback *,uint,ulong,AString &,uint,bool)+17Bp ...
UNDEF:00001900 ; void __cdecl operator delete(void *)
UNDEF:00001900                 extrn ??3@YAXPAX@Z:near ; CODE XREF: UString::~UString(void)+23p
UNDEF:00001900                                         ; AString::~AString(void)+23p ...
UNDEF:00001904 ; __int32 __thiscall NWindows::NCOM::CPropVariant::Clear(NWindows::NCOM::CPropVariant *__hidden this)
UNDEF:00001904                 extrn ?Clear@CPropVariant@NCOM@NWindows@@QAEJXZ:near
UNDEF:00001904                                         ; CODE XREF: NWindows::NCOM::CPropVariant::~CPropVariant(void)+11p
UNDEF:00001908 ; long __stdcall NArchive::NTar::UpdateArchive(struct IInStream *, struct ISequentialOutStream *, class CObjectVector<struct NArchive::NTar::CItemEx> const &, class CObjectVector<struct NArchive::NTar::CUpdateItem> const &, unsigned int, struct IArchiveUpdateCallback *)
UNDEF:00001908                 extrn ?UpdateArchive@NTar@NArchive@@YGJPAUIInStream@@PAUISequentialOutStream@@ABV?$CObjectVector@UCItemEx@NTar@NArchive@@@@ABV?$CObjectVector@UCUpdateItem@NTar@NArchive@@@@IPAUIArchiveUpdateCallback@@@Z:near
UNDEF:00001908                                         ; CODE XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+850p
UNDEF:0000190C ; __int64 NWindows::NTime::FileTimeToUnixTime64(NWindows::NTime *__hidden this, const struct _FILETIME *)
UNDEF:0000190C                 extrn ?FileTimeToUnixTime64@NTime@NWindows@@YG_JABU_FILETIME@@@Z:near
UNDEF:0000190C                                         ; CODE XREF: NArchive::NTar::CHandler::UpdateItems(ISequentialOutStream *,uint,IArchiveUpdateCallback *)+543p
UNDEF:00001910 ; void __thiscall AString::Grow_1(AString *__hidden this)
UNDEF:00001910                 extrn ?Grow_1@AString@@AAEXXZ:near
UNDEF:00001910                                         ; CODE XREF: AString::operator+=(char)+2Fp
UNDEF:00001914 ; public: __thiscall AString::AString(void)
UNDEF:00001914                 extrn ??0AString@@QAE@XZ:near
UNDEF:00001914                                         ; CODE XREF: NArchive::NTar::CUpdateItem::CUpdateItem(void)+33p
UNDEF:00001914                                         ; NArchive::NTar::CUpdateItem::CUpdateItem(void)+45p ...
UNDEF:00001918 ; void *__cdecl operator new(unsigned int)
UNDEF:00001918                 extrn ??2@YAPAXI@Z:near ; CODE XREF: CObjectVector<NArchive::NTar::CUpdateItem>::Add(NArchive::NTar::CUpdateItem const &)+3Bp
UNDEF:00001918                                         ; CRecordVector<void *>::ReserveOnePosition(void)+59p
UNDEF:0000191C ; public: __thiscall AString::AString(class AString const &)
UNDEF:0000191C                 extrn ??0AString@@QAE@ABV0@@Z:near
UNDEF:0000191C                                         ; CODE XREF: NArchive::NTar::CUpdateItem::CUpdateItem(NArchive::NTar::CUpdateItem const &)+A4p
UNDEF:0000191C                                         ; NArchive::NTar::CUpdateItem::CUpdateItem(NArchive::NTar::CUpdateItem const &)+BDp ...
UNDEF:00001920 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:00001920                 extrn _memcpy:near      ; CODE XREF: CRecordVector<void *>::ReserveOnePosition(void)+87p
UNDEF:00001920
UNDEF:00001920