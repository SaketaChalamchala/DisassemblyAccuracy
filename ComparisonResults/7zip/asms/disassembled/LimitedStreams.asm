.text:00000000 ;
.text:00000000 ; +-------------------------------------------------------------------------+
.text:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.text:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.text:00000000 ; |                      License info: 48-3677-7074-51                      |
.text:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.text:00000000 ; +-------------------------------------------------------------------------+
.text:00000000 ;
.text:00000000 ; Input MD5   : CADA9D9090C27DA2F5C12E819CECA271
.text:00000000 ; Input CRC32 : 0E455CF0
.text:00000000
.text:00000000 ; File Name   : C:\workspace\7z1505-src\CPP\7zip\Bundles\Alone\Debug\LimitedStreams.obj
.text:00000000 ; Format      : COFF (X386MAGIC)
.text:00000000 ; includelib "uuid.lib"
.text:00000000 ; includelib "MSVCRTD"
.text:00000000 ; includelib "OLDNAMES"
.text:00000000
.text:00000000                 .686p
.text:00000000                 .mmx
.text:00000000                 .model flat
.text:00000000
.text:00000000 ; ===========================================================================
.text:00000000
.text:00000000 ; Segment type: Pure code
.text:00000000 ; Segment permissions: Read/Execute
.text:00000000 _text           segment para public 'CODE' use32
.text:00000000                 assume cs:_text
.text:00000000                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000000
.text:00000000 ; =============== S U B R O U T I N E =======================================
.text:00000000
.text:00000000 ; Attributes: bp-based frame
.text:00000000
.text:00000000 ; __int32 __stdcall CLimitedSequentialInStream::Read(CLimitedSequentialInStream *this, void *, unsigned int, unsigned int *)
.text:00000000                 public ?Read@CLimitedSequentialInStream@@UAGJPAXIPAI@Z
.text:00000000 ?Read@CLimitedSequentialInStream@@UAGJPAXIPAI@Z proc near
.text:00000000
.text:00000000 var_18          = dword ptr -18h
.text:00000000 var_14          = dword ptr -14h
.text:00000000 var_10          = dword ptr -10h
.text:00000000 var_C           = dword ptr -0Ch
.text:00000000 var_8           = dword ptr -8
.text:00000000 var_4           = dword ptr -4
.text:00000000 this            = dword ptr  8
.text:00000000 arg_4           = dword ptr  0Ch
.text:00000000 arg_8           = dword ptr  10h
.text:00000000 arg_C           = dword ptr  14h
.text:00000000
.text:00000000                 push    ebp
.text:00000001                 mov     ebp, esp
.text:00000003                 sub     esp, 18h
.text:00000006                 push    esi
.text:00000007                 mov     eax, 0CCCCCCCCh
.text:0000000C                 mov     [ebp+var_18], eax
.text:0000000F                 mov     [ebp+var_14], eax
.text:00000012                 mov     [ebp+var_10], eax
.text:00000015                 mov     [ebp+var_C], eax
.text:00000018                 mov     [ebp+var_8], eax
.text:0000001B                 mov     [ebp+var_4], eax
.text:0000001E                 mov     [ebp+var_8], 0
.text:00000025                 mov     eax, [ebp+arg_8]
.text:00000028                 xor     ecx, ecx
.text:0000002A                 push    ecx
.text:0000002B                 push    eax
.text:0000002C                 mov     edx, [ebp+this]
.text:0000002F                 mov     eax, [ebp+this]
.text:00000032                 mov     ecx, [edx+10h]
.text:00000035                 sub     ecx, [eax+18h]
.text:00000038                 mov     edx, [edx+14h]
.text:0000003B                 sbb     edx, [eax+1Ch]
.text:0000003E                 push    edx
.text:0000003F                 push    ecx
.text:00000040                 call    ??$MyMin@_K@@YG_K_K0@Z ; MyMin<unsigned __int64>(unsigned __int64,unsigned __int64)
.text:00000045                 mov     [ebp+var_10], eax
.text:00000048                 mov     [ebp+var_14], 0
.text:0000004F                 cmp     [ebp+var_10], 0
.text:00000053                 jbe     short loc_AD
.text:00000055                 mov     ecx, [ebp+this]
.text:00000058                 add     ecx, 8
.text:0000005B                 call    ??C?$CMyComPtr@UISequentialInStream@@@@QBEPAUISequentialInStream@@XZ ; CMyComPtr<ISequentialInStream>::operator->(void)
.text:00000060                 mov     [ebp+var_18], eax
.text:00000063                 mov     esi, esp
.text:00000065                 lea     eax, [ebp+var_8]
.text:00000068                 push    eax
.text:00000069                 mov     ecx, [ebp+var_10]
.text:0000006C                 push    ecx
.text:0000006D                 mov     edx, [ebp+arg_4]
.text:00000070                 push    edx
.text:00000071                 mov     eax, [ebp+var_18]
.text:00000074                 push    eax
.text:00000075                 mov     ecx, [ebp+var_18]
.text:00000078                 mov     edx, [ecx]
.text:0000007A                 mov     eax, [edx+0Ch]
.text:0000007D                 call    eax
.text:0000007F                 cmp     esi, esp
.text:00000081                 call    __RTC_CheckEsp
.text:00000086                 mov     [ebp+var_14], eax
.text:00000089                 mov     ecx, [ebp+var_8]
.text:0000008C                 xor     edx, edx
.text:0000008E                 mov     eax, [ebp+this]
.text:00000091                 add     ecx, [eax+18h]
.text:00000094                 adc     edx, [eax+1Ch]
.text:00000097                 mov     eax, [ebp+this]
.text:0000009A                 mov     [eax+18h], ecx
.text:0000009D                 mov     [eax+1Ch], edx
.text:000000A0                 cmp     [ebp+var_8], 0
.text:000000A4                 jnz     short loc_AD
.text:000000A6                 mov     ecx, [ebp+this]
.text:000000A9                 mov     byte ptr [ecx+20h], 1
.text:000000AD
.text:000000AD loc_AD:                                 ; CODE XREF: CLimitedSequentialInStream::Read(void *,uint,uint *)+53j
.text:000000AD                                         ; CLimitedSequentialInStream::Read(void *,uint,uint *)+A4j
.text:000000AD                 cmp     [ebp+arg_C], 0
.text:000000B1                 jz      short loc_BB
.text:000000B3                 mov     edx, [ebp+arg_C]
.text:000000B6                 mov     eax, [ebp+var_8]
.text:000000B9                 mov     [edx], eax
.text:000000BB
.text:000000BB loc_BB:                                 ; CODE XREF: CLimitedSequentialInStream::Read(void *,uint,uint *)+B1j
.text:000000BB                 mov     eax, [ebp+var_14]
.text:000000BE                 push    edx
.text:000000BF                 mov     ecx, ebp
.text:000000C1                 push    eax
.text:000000C2                 lea     edx, $LN8
.text:000000C8                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:000000CD                 pop     eax
.text:000000CE                 pop     edx
.text:000000CF                 pop     esi
.text:000000D0                 add     esp, 18h
.text:000000D3                 cmp     ebp, esp
.text:000000D5                 call    __RTC_CheckEsp
.text:000000DA                 mov     esp, ebp
.text:000000DC                 pop     ebp
.text:000000DD                 retn    10h
.text:000000DD ?Read@CLimitedSequentialInStream@@UAGJPAXIPAI@Z endp
.text:000000DD
.text:000000DD ; ---------------------------------------------------------------------------
.text:000000E0 $LN8            dd 1                    ; DATA XREF: CLimitedSequentialInStream::Read(void *,uint,uint *)+C2o
.text:000000E4                 dd offset $LN7
.text:000000E8 $LN7            dd 0FFFFFFF8h, 4        ; DATA XREF: .text:000000E4o
.text:000000F0                 dd offset $LN6          ; "realProcessedSize"
.text:000000F4 $LN6            db 'realProcessedSize',0 ; DATA XREF: .text:000000F0o
.text:00000106                 align 10h
.text:00000110
.text:00000110 ; =============== S U B R O U T I N E =======================================
.text:00000110
.text:00000110 ; Attributes: bp-based frame
.text:00000110
.text:00000110 ; __int32 __stdcall CLimitedInStream::Read(CLimitedInStream *this, void *, unsigned int, unsigned int *)
.text:00000110                 public ?Read@CLimitedInStream@@UAGJPAXIPAI@Z
.text:00000110 ?Read@CLimitedInStream@@UAGJPAXIPAI@Z proc near ; DATA XREF: .rdata:00001588o
.text:00000110
.text:00000110 var_30          = dword ptr -30h
.text:00000110 var_2C          = dword ptr -2Ch
.text:00000110 var_28          = dword ptr -28h
.text:00000110 var_24          = dword ptr -24h
.text:00000110 var_20          = dword ptr -20h
.text:00000110 var_1C          = dword ptr -1Ch
.text:00000110 var_18          = dword ptr -18h
.text:00000110 var_14          = dword ptr -14h
.text:00000110 var_10          = dword ptr -10h
.text:00000110 var_C           = dword ptr -0Ch
.text:00000110 var_8           = dword ptr -8
.text:00000110 var_4           = dword ptr -4
.text:00000110 this            = dword ptr  8
.text:00000110 arg_4           = dword ptr  0Ch
.text:00000110 arg_8           = dword ptr  10h
.text:00000110 arg_C           = dword ptr  14h
.text:00000110
.text:00000110                 push    ebp
.text:00000111                 mov     ebp, esp
.text:00000113                 sub     esp, 30h
.text:00000116                 push    esi
.text:00000117                 push    edi
.text:00000118                 lea     edi, [ebp+var_30]
.text:0000011B                 mov     ecx, 0Ch
.text:00000120                 mov     eax, 0CCCCCCCCh
.text:00000125                 rep stosd
.text:00000127                 cmp     [ebp+arg_C], 0
.text:0000012B                 jz      short loc_136
.text:0000012D                 mov     eax, [ebp+arg_C]
.text:00000130                 mov     dword ptr [eax], 0
.text:00000136
.text:00000136 loc_136:                                ; CODE XREF: CLimitedInStream::Read(void *,uint,uint *)+1Bj
.text:00000136                 mov     ecx, [ebp+this]
.text:00000139                 mov     edx, [ebp+this]
.text:0000013C                 mov     [ebp+var_1C], ecx
.text:0000013F                 mov     [ebp+var_20], edx
.text:00000142                 mov     eax, [ebp+var_1C]
.text:00000145                 mov     ecx, [ebp+var_20]
.text:00000148                 mov     edx, [eax+14h]
.text:0000014B                 cmp     edx, [ecx+24h]
.text:0000014E                 jb      short loc_167
.text:00000150                 ja      short loc_160
.text:00000152                 mov     eax, [ebp+var_1C]
.text:00000155                 mov     ecx, [ebp+var_20]
.text:00000158                 mov     edx, [eax+10h]
.text:0000015B                 cmp     edx, [ecx+20h]
.text:0000015E                 jb      short loc_167
.text:00000160
.text:00000160 loc_160:                                ; CODE XREF: CLimitedInStream::Read(void *,uint,uint *)+40j
.text:00000160                 xor     eax, eax
.text:00000162                 jmp     loc_26E
.text:00000167 ; ---------------------------------------------------------------------------
.text:00000167
.text:00000167 loc_167:                                ; CODE XREF: CLimitedInStream::Read(void *,uint,uint *)+3Ej
.text:00000167                                         ; CLimitedInStream::Read(void *,uint,uint *)+4Ej
.text:00000167                 mov     eax, [ebp+this]
.text:0000016A                 mov     ecx, [ebp+this]
.text:0000016D                 mov     edx, [eax+20h]
.text:00000170                 sub     edx, [ecx+10h]
.text:00000173                 mov     eax, [eax+24h]
.text:00000176                 sbb     eax, [ecx+14h]
.text:00000179                 mov     [ebp+var_8], edx
.text:0000017C                 mov     [ebp+var_4], eax
.text:0000017F                 mov     ecx, [ebp+arg_8]
.text:00000182                 xor     edx, edx
.text:00000184                 mov     [ebp+var_28], ecx
.text:00000187                 mov     [ebp+var_24], edx
.text:0000018A                 mov     eax, [ebp+var_4]
.text:0000018D                 cmp     eax, [ebp+var_24]
.text:00000190                 ja      short loc_1A2
.text:00000192                 jb      short loc_19C
.text:00000194                 mov     ecx, [ebp+var_8]
.text:00000197                 cmp     ecx, [ebp+var_28]
.text:0000019A                 jnb     short loc_1A2
.text:0000019C
.text:0000019C loc_19C:                                ; CODE XREF: CLimitedInStream::Read(void *,uint,uint *)+82j
.text:0000019C                 mov     edx, [ebp+var_8]
.text:0000019F                 mov     [ebp+arg_8], edx
.text:000001A2
.text:000001A2 loc_1A2:                                ; CODE XREF: CLimitedInStream::Read(void *,uint,uint *)+80j
.text:000001A2                                         ; CLimitedInStream::Read(void *,uint,uint *)+8Aj
.text:000001A2                 mov     eax, [ebp+this]
.text:000001A5                 mov     ecx, [ebp+this]
.text:000001A8                 mov     edx, [eax+28h]
.text:000001AB                 add     edx, [ecx+10h]
.text:000001AE                 mov     eax, [eax+2Ch]
.text:000001B1                 adc     eax, [ecx+14h]
.text:000001B4                 mov     [ebp+var_10], edx
.text:000001B7                 mov     [ebp+var_C], eax
.text:000001BA                 mov     ecx, [ebp+this]
.text:000001BD                 mov     [ebp+var_2C], ecx
.text:000001C0                 mov     edx, [ebp+var_2C]
.text:000001C3                 mov     eax, [ebp+var_10]
.text:000001C6                 cmp     eax, [edx+18h]
.text:000001C9                 jnz     short loc_1D6
.text:000001CB                 mov     ecx, [ebp+var_2C]
.text:000001CE                 mov     edx, [ebp+var_C]
.text:000001D1                 cmp     edx, [ecx+1Ch]
.text:000001D4                 jz      short loc_1FB
.text:000001D6
.text:000001D6 loc_1D6:                                ; CODE XREF: CLimitedInStream::Read(void *,uint,uint *)+B9j
.text:000001D6                 mov     eax, [ebp+this]
.text:000001D9                 mov     ecx, [ebp+var_10]
.text:000001DC                 mov     [eax+18h], ecx
.text:000001DF                 mov     edx, [ebp+var_C]
.text:000001E2                 mov     [eax+1Ch], edx
.text:000001E5                 mov     ecx, [ebp+this] ; this
.text:000001E8                 call    ?SeekToPhys@CLimitedInStream@@AAEJXZ ; CLimitedInStream::SeekToPhys(void)
.text:000001ED                 mov     [ebp+var_14], eax
.text:000001F0                 cmp     [ebp+var_14], 0
.text:000001F4                 jz      short loc_1FB
.text:000001F6                 mov     eax, [ebp+var_14]
.text:000001F9                 jmp     short loc_26E
.text:000001FB ; ---------------------------------------------------------------------------
.text:000001FB
.text:000001FB loc_1FB:                                ; CODE XREF: CLimitedInStream::Read(void *,uint,uint *)+C4j
.text:000001FB                                         ; CLimitedInStream::Read(void *,uint,uint *)+E4j
.text:000001FB                 mov     ecx, [ebp+this]
.text:000001FE                 add     ecx, 8
.text:00000201                 call    ??C?$CMyComPtr@UIInStream@@@@QBEPAUIInStream@@XZ ; CMyComPtr<IInStream>::operator->(void)
.text:00000206                 mov     [ebp+var_30], eax
.text:00000209                 mov     esi, esp
.text:0000020B                 lea     eax, [ebp+arg_8]
.text:0000020E                 push    eax
.text:0000020F                 mov     ecx, [ebp+arg_8]
.text:00000212                 push    ecx
.text:00000213                 mov     edx, [ebp+arg_4]
.text:00000216                 push    edx
.text:00000217                 mov     eax, [ebp+var_30]
.text:0000021A                 push    eax
.text:0000021B                 mov     ecx, [ebp+var_30]
.text:0000021E                 mov     edx, [ecx]
.text:00000220                 mov     eax, [edx+0Ch]
.text:00000223                 call    eax
.text:00000225                 cmp     esi, esp
.text:00000227                 call    __RTC_CheckEsp
.text:0000022C                 mov     [ebp+var_18], eax
.text:0000022F                 cmp     [ebp+arg_C], 0
.text:00000233                 jz      short loc_23D
.text:00000235                 mov     ecx, [ebp+arg_C]
.text:00000238                 mov     edx, [ebp+arg_8]
.text:0000023B                 mov     [ecx], edx
.text:0000023D
.text:0000023D loc_23D:                                ; CODE XREF: CLimitedInStream::Read(void *,uint,uint *)+123j
.text:0000023D                 mov     eax, [ebp+arg_8]
.text:00000240                 xor     ecx, ecx
.text:00000242                 mov     edx, [ebp+this]
.text:00000245                 add     eax, [edx+18h]
.text:00000248                 adc     ecx, [edx+1Ch]
.text:0000024B                 mov     edx, [ebp+this]
.text:0000024E                 mov     [edx+18h], eax
.text:00000251                 mov     [edx+1Ch], ecx
.text:00000254                 mov     eax, [ebp+arg_8]
.text:00000257                 xor     ecx, ecx
.text:00000259                 mov     edx, [ebp+this]
.text:0000025C                 add     eax, [edx+10h]
.text:0000025F                 adc     ecx, [edx+14h]
.text:00000262                 mov     edx, [ebp+this]
.text:00000265                 mov     [edx+10h], eax
.text:00000268                 mov     [edx+14h], ecx
.text:0000026B                 mov     eax, [ebp+var_18]
.text:0000026E
.text:0000026E loc_26E:                                ; CODE XREF: CLimitedInStream::Read(void *,uint,uint *)+52j
.text:0000026E                                         ; CLimitedInStream::Read(void *,uint,uint *)+E9j
.text:0000026E                 pop     edi
.text:0000026F                 pop     esi
.text:00000270                 add     esp, 30h
.text:00000273                 cmp     ebp, esp
.text:00000275                 call    __RTC_CheckEsp
.text:0000027A                 mov     esp, ebp
.text:0000027C                 pop     ebp
.text:0000027D                 retn    10h
.text:0000027D ?Read@CLimitedInStream@@UAGJPAXIPAI@Z endp
.text:0000027D
.text:00000280
.text:00000280 ; =============== S U B R O U T I N E =======================================
.text:00000280
.text:00000280 ; Attributes: bp-based frame
.text:00000280
.text:00000280 ; __int32 __stdcall CLimitedInStream::Seek(CLimitedInStream *this, __int64, unsigned int, unsigned __int64 *)
.text:00000280                 public ?Seek@CLimitedInStream@@UAGJ_JIPA_K@Z
.text:00000280 ?Seek@CLimitedInStream@@UAGJ_JIPA_K@Z proc near ; DATA XREF: .rdata:0000158Co
.text:00000280
.text:00000280 var_4           = dword ptr -4
.text:00000280 this            = dword ptr  8
.text:00000280 arg_4           = qword ptr  0Ch
.text:00000280 arg_C           = dword ptr  14h
.text:00000280 arg_10          = dword ptr  18h
.text:00000280
.text:00000280                 push    ebp
.text:00000281                 mov     ebp, esp
.text:00000283                 push    ecx
.text:00000284                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000028B                 mov     eax, [ebp+arg_C]
.text:0000028E                 mov     [ebp+var_4], eax
.text:00000291                 cmp     [ebp+var_4], 0
.text:00000295                 jz      short loc_2A5
.text:00000297                 cmp     [ebp+var_4], 1
.text:0000029B                 jz      short loc_2A7
.text:0000029D                 cmp     [ebp+var_4], 2
.text:000002A1                 jz      short loc_2BE
.text:000002A3                 jmp     short loc_2D5
.text:000002A5 ; ---------------------------------------------------------------------------
.text:000002A5
.text:000002A5 loc_2A5:                                ; CODE XREF: CLimitedInStream::Seek(__int64,uint,unsigned __int64 *)+15j
.text:000002A5                 jmp     short loc_2DC
.text:000002A7 ; ---------------------------------------------------------------------------
.text:000002A7
.text:000002A7 loc_2A7:                                ; CODE XREF: CLimitedInStream::Seek(__int64,uint,unsigned __int64 *)+1Bj
.text:000002A7                 mov     ecx, [ebp+this]
.text:000002AA                 mov     edx, dword ptr [ebp+arg_4]
.text:000002AD                 add     edx, [ecx+10h]
.text:000002B0                 mov     eax, dword ptr [ebp+arg_4+4]
.text:000002B3                 adc     eax, [ecx+14h]
.text:000002B6                 mov     dword ptr [ebp+arg_4], edx
.text:000002B9                 mov     dword ptr [ebp+arg_4+4], eax
.text:000002BC                 jmp     short loc_2DC
.text:000002BE ; ---------------------------------------------------------------------------
.text:000002BE
.text:000002BE loc_2BE:                                ; CODE XREF: CLimitedInStream::Seek(__int64,uint,unsigned __int64 *)+21j
.text:000002BE                 mov     ecx, [ebp+this]
.text:000002C1                 mov     edx, dword ptr [ebp+arg_4]
.text:000002C4                 add     edx, [ecx+20h]
.text:000002C7                 mov     eax, dword ptr [ebp+arg_4+4]
.text:000002CA                 adc     eax, [ecx+24h]
.text:000002CD                 mov     dword ptr [ebp+arg_4], edx
.text:000002D0                 mov     dword ptr [ebp+arg_4+4], eax
.text:000002D3                 jmp     short loc_2DC
.text:000002D5 ; ---------------------------------------------------------------------------
.text:000002D5
.text:000002D5 loc_2D5:                                ; CODE XREF: CLimitedInStream::Seek(__int64,uint,unsigned __int64 *)+23j
.text:000002D5                 mov     eax, 80030001h
.text:000002DA                 jmp     short loc_319
.text:000002DC ; ---------------------------------------------------------------------------
.text:000002DC
.text:000002DC loc_2DC:                                ; CODE XREF: CLimitedInStream::Seek(__int64,uint,unsigned __int64 *):loc_2A5j
.text:000002DC                                         ; CLimitedInStream::Seek(__int64,uint,unsigned __int64 *)+3Cj ...
.text:000002DC                 cmp     dword ptr [ebp+arg_4+4], 0
.text:000002E0                 jg      short loc_2F1
.text:000002E2                 jl      short loc_2EA
.text:000002E4                 cmp     dword ptr [ebp+arg_4], 0
.text:000002E8                 jnb     short loc_2F1
.text:000002EA
.text:000002EA loc_2EA:                                ; CODE XREF: CLimitedInStream::Seek(__int64,uint,unsigned __int64 *)+62j
.text:000002EA                 mov     eax, 80070083h
.text:000002EF                 jmp     short loc_319
.text:000002F1 ; ---------------------------------------------------------------------------
.text:000002F1
.text:000002F1 loc_2F1:                                ; CODE XREF: CLimitedInStream::Seek(__int64,uint,unsigned __int64 *)+60j
.text:000002F1                                         ; CLimitedInStream::Seek(__int64,uint,unsigned __int64 *)+68j
.text:000002F1                 mov     ecx, [ebp+this]
.text:000002F4                 mov     edx, dword ptr [ebp+arg_4]
.text:000002F7                 mov     [ecx+10h], edx
.text:000002FA                 mov     eax, dword ptr [ebp+arg_4+4]
.text:000002FD                 mov     [ecx+14h], eax
.text:00000300                 cmp     [ebp+arg_10], 0
.text:00000304                 jz      short loc_317
.text:00000306                 mov     ecx, [ebp+arg_10]
.text:00000309                 mov     edx, [ebp+this]
.text:0000030C                 mov     eax, [edx+10h]
.text:0000030F                 mov     [ecx], eax
.text:00000311                 mov     edx, [edx+14h]
.text:00000314                 mov     [ecx+4], edx
.text:00000317
.text:00000317 loc_317:                                ; CODE XREF: CLimitedInStream::Seek(__int64,uint,unsigned __int64 *)+84j
.text:00000317                 xor     eax, eax
.text:00000319
.text:00000319 loc_319:                                ; CODE XREF: CLimitedInStream::Seek(__int64,uint,unsigned __int64 *)+5Aj
.text:00000319                                         ; CLimitedInStream::Seek(__int64,uint,unsigned __int64 *)+6Fj
.text:00000319                 mov     esp, ebp
.text:0000031B                 pop     ebp
.text:0000031C                 retn    14h
.text:0000031C ?Seek@CLimitedInStream@@UAGJ_JIPA_K@Z endp
.text:0000031C
.text:0000031C ; ---------------------------------------------------------------------------
.text:0000031F                 align 10h
.text:00000320
.text:00000320 ; =============== S U B R O U T I N E =======================================
.text:00000320
.text:00000320 ; Attributes: bp-based frame
.text:00000320
.text:00000320 ; __int32 __stdcall CreateLimitedInStream(struct IInStream *, unsigned __int64, unsigned __int64, struct ISequentialInStream **)
.text:00000320                 public ?CreateLimitedInStream@@YGJPAUIInStream@@_K1PAPAUISequentialInStream@@@Z
.text:00000320 ?CreateLimitedInStream@@YGJPAUIInStream@@_K1PAPAUISequentialInStream@@@Z proc near
.text:00000320
.text:00000320 var_34          = dword ptr -34h
.text:00000320 var_30          = dword ptr -30h
.text:00000320 var_2C          = dword ptr -2Ch
.text:00000320 var_28          = dword ptr -28h
.text:00000320 var_24          = dword ptr -24h
.text:00000320 var_20          = dword ptr -20h
.text:00000320 var_18          = byte ptr -18h
.text:00000320 var_10          = dword ptr -10h
.text:00000320 var_C           = dword ptr -0Ch
.text:00000320 var_4           = dword ptr -4
.text:00000320 arg_0           = dword ptr  8
.text:00000320 arg_4           = qword ptr  0Ch
.text:00000320 arg_C           = qword ptr  14h
.text:00000320 arg_14          = dword ptr  1Ch
.text:00000320
.text:00000320                 push    ebp
.text:00000321                 mov     ebp, esp
.text:00000323                 push    0FFFFFFFFh
.text:00000325                 push    offset __ehhandler$?CreateLimitedInStream@@YGJPAUIInStream@@_K1PAPAUISequentialInStream@@@Z
.text:0000032A                 mov     eax, large fs:0
.text:00000330                 push    eax
.text:00000331                 sub     esp, 28h
.text:00000334                 push    edi
.text:00000335                 lea     edi, [ebp+var_34]
.text:00000338                 mov     ecx, 0Ah
.text:0000033D                 mov     eax, 0CCCCCCCCh
.text:00000342                 rep stosd
.text:00000344                 mov     eax, dword ptr ds:___security_cookie
.text:00000349                 xor     eax, ebp
.text:0000034B                 push    eax
.text:0000034C                 lea     eax, [ebp+var_C]
.text:0000034F                 mov     large fs:0, eax
.text:00000355                 mov     eax, [ebp+arg_14]
.text:00000358                 mov     dword ptr [eax], 0
.text:0000035E                 push    30h ; '0'       ; unsigned int
.text:00000360                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00000365                 add     esp, 4
.text:00000368                 mov     [ebp+var_28], eax
.text:0000036B                 mov     [ebp+var_4], 0
.text:00000372                 cmp     [ebp+var_28], 0
.text:00000376                 jz      short loc_385
.text:00000378                 mov     ecx, [ebp+var_28]
.text:0000037B                 call    ??0CLimitedInStream@@QAE@XZ ; CLimitedInStream::CLimitedInStream(void)
.text:00000380                 mov     [ebp+var_34], eax
.text:00000383                 jmp     short loc_38C
.text:00000385 ; ---------------------------------------------------------------------------
.text:00000385
.text:00000385 loc_385:                                ; CODE XREF: CreateLimitedInStream(IInStream *,unsigned __int64,unsigned __int64,ISequentialInStream * *)+56j
.text:00000385                 mov     [ebp+var_34], 0
.text:0000038C
.text:0000038C loc_38C:                                ; CODE XREF: CreateLimitedInStream(IInStream *,unsigned __int64,unsigned __int64,ISequentialInStream * *)+63j
.text:0000038C                 mov     ecx, [ebp+var_34]
.text:0000038F                 mov     [ebp+var_24], ecx
.text:00000392                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000399                 mov     edx, [ebp+var_24]
.text:0000039C                 mov     [ebp+var_10], edx
.text:0000039F                 mov     eax, [ebp+var_10]
.text:000003A2                 push    eax
.text:000003A3                 lea     ecx, [ebp+var_18]
.text:000003A6                 call    ??0?$CMyComPtr@UISequentialInStream@@@@QAE@PAUISequentialInStream@@@Z ; CMyComPtr<ISequentialInStream>::CMyComPtr<ISequentialInStream>(ISequentialInStream *)
.text:000003AB                 mov     [ebp+var_4], 1
.text:000003B2                 mov     ecx, [ebp+arg_0]
.text:000003B5                 push    ecx             ; struct IInStream *
.text:000003B6                 mov     ecx, [ebp+var_10] ; this
.text:000003B9                 call    ?SetStream@CLimitedInStream@@QAEXPAUIInStream@@@Z ; CLimitedInStream::SetStream(IInStream *)
.text:000003BE                 mov     edx, dword ptr [ebp+arg_C+4]
.text:000003C1                 push    edx
.text:000003C2                 mov     eax, dword ptr [ebp+arg_C]
.text:000003C5                 push    eax             ; unsigned __int64
.text:000003C6                 mov     ecx, dword ptr [ebp+arg_4+4]
.text:000003C9                 push    ecx
.text:000003CA                 mov     edx, dword ptr [ebp+arg_4]
.text:000003CD                 push    edx             ; unsigned __int64
.text:000003CE                 mov     ecx, [ebp+var_10] ; this
.text:000003D1                 call    ?InitAndSeek@CLimitedInStream@@QAEJ_K0@Z ; CLimitedInStream::InitAndSeek(unsigned __int64,unsigned __int64)
.text:000003D6                 mov     [ebp+var_20], eax
.text:000003D9                 cmp     [ebp+var_20], 0
.text:000003DD                 jz      short loc_3F9
.text:000003DF                 mov     eax, [ebp+var_20]
.text:000003E2                 mov     [ebp+var_2C], eax
.text:000003E5                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000003EC                 lea     ecx, [ebp+var_18]
.text:000003EF                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:000003F4                 mov     eax, [ebp+var_2C]
.text:000003F7                 jmp     short loc_427
.text:000003F9 ; ---------------------------------------------------------------------------
.text:000003F9
.text:000003F9 loc_3F9:                                ; CODE XREF: CreateLimitedInStream(IInStream *,unsigned __int64,unsigned __int64,ISequentialInStream * *)+BDj
.text:000003F9                 mov     ecx, [ebp+var_10] ; this
.text:000003FC                 call    ?SeekToStart@CLimitedInStream@@QAEJXZ ; CLimitedInStream::SeekToStart(void)
.text:00000401                 lea     ecx, [ebp+var_18]
.text:00000404                 call    ?Detach@?$CMyComPtr@UISequentialInStream@@@@QAEPAUISequentialInStream@@XZ ; CMyComPtr<ISequentialInStream>::Detach(void)
.text:00000409                 mov     ecx, [ebp+arg_14]
.text:0000040C                 mov     [ecx], eax
.text:0000040E                 mov     [ebp+var_30], 0
.text:00000415                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000041C                 lea     ecx, [ebp+var_18]
.text:0000041F                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:00000424                 mov     eax, [ebp+var_30]
.text:00000427
.text:00000427 loc_427:                                ; CODE XREF: CreateLimitedInStream(IInStream *,unsigned __int64,unsigned __int64,ISequentialInStream * *)+D7j
.text:00000427                 push    edx
.text:00000428                 mov     ecx, ebp
.text:0000042A                 push    eax
.text:0000042B                 lea     edx, $LN11
.text:00000431                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00000436                 pop     eax
.text:00000437                 pop     edx
.text:00000438                 mov     ecx, [ebp+var_C]
.text:0000043B                 mov     large fs:0, ecx
.text:00000442                 pop     ecx
.text:00000443                 pop     edi
.text:00000444                 add     esp, 34h
.text:00000447                 cmp     ebp, esp
.text:00000449                 call    __RTC_CheckEsp
.text:0000044E                 mov     esp, ebp
.text:00000450                 pop     ebp
.text:00000451                 retn    18h
.text:00000451 ?CreateLimitedInStream@@YGJPAUIInStream@@_K1PAPAUISequentialInStream@@@Z endp
.text:00000451
.text:00000451 ; ---------------------------------------------------------------------------
.text:00000454 $LN11           dd 1                    ; DATA XREF: CreateLimitedInStream(IInStream *,unsigned __int64,unsigned __int64,ISequentialInStream * *)+10Bo
.text:00000458                 dd offset $LN10
.text:0000045C $LN10           dd 0FFFFFFE8h, 4        ; DATA XREF: .text:00000458o
.text:00000464                 dd offset $LN8_0        ; "streamTemp"
.text:00000468 $LN8_0          db 'streamTemp',0       ; DATA XREF: .text:00000464o
.text:00000473                 align 10h
.text:00000480
.text:00000480 ; =============== S U B R O U T I N E =======================================
.text:00000480
.text:00000480 ; Attributes: bp-based frame
.text:00000480
.text:00000480 ; __int32 __stdcall CClusterInStream::Read(CClusterInStream *this, void *, unsigned int, unsigned int *)
.text:00000480                 public ?Read@CClusterInStream@@UAGJPAXIPAI@Z
.text:00000480 ?Read@CClusterInStream@@UAGJPAXIPAI@Z proc near
.text:00000480
.text:00000480 var_44          = dword ptr -44h
.text:00000480 var_40          = dword ptr -40h
.text:00000480 var_3C          = dword ptr -3Ch
.text:00000480 var_38          = dword ptr -38h
.text:00000480 var_34          = dword ptr -34h
.text:00000480 var_30          = dword ptr -30h
.text:00000480 var_2C          = dword ptr -2Ch
.text:00000480 var_28          = dword ptr -28h
.text:00000480 var_24          = dword ptr -24h
.text:00000480 var_20          = dword ptr -20h
.text:00000480 var_1C          = dword ptr -1Ch
.text:00000480 var_18          = dword ptr -18h
.text:00000480 var_14          = dword ptr -14h
.text:00000480 var_10          = dword ptr -10h
.text:00000480 var_C           = dword ptr -0Ch
.text:00000480 var_8           = dword ptr -8
.text:00000480 var_4           = dword ptr -4
.text:00000480 this            = dword ptr  8
.text:00000480 arg_4           = dword ptr  0Ch
.text:00000480 arg_8           = dword ptr  10h
.text:00000480 arg_C           = dword ptr  14h
.text:00000480
.text:00000480                 push    ebp
.text:00000481                 mov     ebp, esp
.text:00000483                 sub     esp, 44h
.text:00000486                 push    esi
.text:00000487                 push    edi
.text:00000488                 lea     edi, [ebp+var_44]
.text:0000048B                 mov     ecx, 11h
.text:00000490                 mov     eax, 0CCCCCCCCh
.text:00000495                 rep stosd
.text:00000497                 cmp     [ebp+arg_C], 0
.text:0000049B                 jz      short loc_4A6
.text:0000049D                 mov     eax, [ebp+arg_C]
.text:000004A0                 mov     dword ptr [eax], 0
.text:000004A6
.text:000004A6 loc_4A6:                                ; CODE XREF: CClusterInStream::Read(void *,uint,uint *)+1Bj
.text:000004A6                 mov     ecx, [ebp+this]
.text:000004A9                 mov     edx, [ebp+this]
.text:000004AC                 mov     [ebp+var_30], ecx
.text:000004AF                 mov     [ebp+var_34], edx
.text:000004B2                 mov     eax, [ebp+var_30]
.text:000004B5                 mov     ecx, [ebp+var_34]
.text:000004B8                 mov     edx, [eax+0Ch]
.text:000004BB                 cmp     edx, [ecx+2Ch]
.text:000004BE                 jb      short loc_4D7
.text:000004C0                 ja      short loc_4D0
.text:000004C2                 mov     eax, [ebp+var_30]
.text:000004C5                 mov     ecx, [ebp+var_34]
.text:000004C8                 mov     edx, [eax+8]
.text:000004CB                 cmp     edx, [ecx+28h]
.text:000004CE                 jb      short loc_4D7
.text:000004D0
.text:000004D0 loc_4D0:                                ; CODE XREF: CClusterInStream::Read(void *,uint,uint *)+40j
.text:000004D0                 xor     eax, eax
.text:000004D2                 jmp     loc_6E3
.text:000004D7 ; ---------------------------------------------------------------------------
.text:000004D7
.text:000004D7 loc_4D7:                                ; CODE XREF: CClusterInStream::Read(void *,uint,uint *)+3Ej
.text:000004D7                                         ; CClusterInStream::Read(void *,uint,uint *)+4Ej
.text:000004D7                 mov     eax, [ebp+this]
.text:000004DA                 cmp     dword ptr [eax+18h], 0
.text:000004DE                 jnz     loc_64D
.text:000004E4                 mov     ecx, [ebp+this]
.text:000004E7                 mov     edx, 1
.text:000004EC                 mov     ecx, [ecx+30h]
.text:000004EF                 shl     edx, cl
.text:000004F1                 mov     [ebp+var_4], edx
.text:000004F4                 mov     ecx, [ebp+this]
.text:000004F7                 mov     esi, [ebp+this]
.text:000004FA                 mov     eax, [ecx+8]
.text:000004FD                 mov     edx, [ecx+0Ch]
.text:00000500                 mov     ecx, [esi+30h]
.text:00000503                 call    __aullshr
.text:00000508                 mov     [ebp+var_8], eax
.text:0000050B                 mov     edx, [ebp+this]
.text:0000050E                 mov     eax, [edx+8]
.text:00000511                 mov     ecx, [ebp+var_4]
.text:00000514                 sub     ecx, 1
.text:00000517                 and     eax, ecx
.text:00000519                 mov     [ebp+var_C], eax
.text:0000051C                 mov     edx, [ebp+var_8]
.text:0000051F                 push    edx
.text:00000520                 mov     ecx, [ebp+this]
.text:00000523                 add     ecx, 34h ; '4'
.text:00000526                 call    ??A?$CRecordVector@I@@QAEAAII@Z ; CRecordVector<uint>::operator[](uint)
.text:0000052B                 mov     eax, [eax]
.text:0000052D                 mov     [ebp+var_10], eax
.text:00000530                 mov     eax, [ebp+var_10]
.text:00000533                 xor     edx, edx
.text:00000535                 mov     ecx, [ebp+this]
.text:00000538                 mov     ecx, [ecx+30h]
.text:0000053B                 call    __allshl
.text:00000540                 mov     ecx, [ebp+this]
.text:00000543                 add     eax, [ecx+20h]
.text:00000546                 adc     edx, [ecx+24h]
.text:00000549                 mov     ecx, [ebp+var_C]
.text:0000054C                 xor     esi, esi
.text:0000054E                 add     eax, ecx
.text:00000550                 adc     edx, esi
.text:00000552                 mov     [ebp+var_18], eax
.text:00000555                 mov     [ebp+var_14], edx
.text:00000558                 mov     edx, [ebp+this]
.text:0000055B                 mov     [ebp+var_38], edx
.text:0000055E                 mov     eax, [ebp+var_38]
.text:00000561                 mov     ecx, [ebp+var_18]
.text:00000564                 cmp     ecx, [eax+10h]
.text:00000567                 jnz     short loc_574
.text:00000569                 mov     edx, [ebp+var_38]
.text:0000056C                 mov     eax, [ebp+var_14]
.text:0000056F                 cmp     eax, [edx+14h]
.text:00000572                 jz      short loc_59C
.text:00000574
.text:00000574 loc_574:                                ; CODE XREF: CClusterInStream::Read(void *,uint,uint *)+E7j
.text:00000574                 mov     ecx, [ebp+this]
.text:00000577                 mov     edx, [ebp+var_18]
.text:0000057A                 mov     [ecx+10h], edx
.text:0000057D                 mov     eax, [ebp+var_14]
.text:00000580                 mov     [ecx+14h], eax
.text:00000583                 mov     ecx, [ebp+this] ; this
.text:00000586                 call    ?SeekToPhys@CClusterInStream@@QAEJXZ ; CClusterInStream::SeekToPhys(void)
.text:0000058B                 mov     [ebp+var_1C], eax
.text:0000058E                 cmp     [ebp+var_1C], 0
.text:00000592                 jz      short loc_59C
.text:00000594                 mov     eax, [ebp+var_1C]
.text:00000597                 jmp     loc_6E3
.text:0000059C ; ---------------------------------------------------------------------------
.text:0000059C
.text:0000059C loc_59C:                                ; CODE XREF: CClusterInStream::Read(void *,uint,uint *)+F2j
.text:0000059C                                         ; CClusterInStream::Read(void *,uint,uint *)+112j
.text:0000059C                 mov     ecx, [ebp+var_4]
.text:0000059F                 sub     ecx, [ebp+var_C]
.text:000005A2                 mov     edx, [ebp+this]
.text:000005A5                 mov     [edx+18h], ecx
.text:000005A8                 mov     [ebp+var_20], 1
.text:000005AF                 jmp     short loc_5BA
.text:000005B1 ; ---------------------------------------------------------------------------
.text:000005B1
.text:000005B1 loc_5B1:                                ; CODE XREF: CClusterInStream::Read(void *,uint,uint *)+18Aj
.text:000005B1                 mov     eax, [ebp+var_20]
.text:000005B4                 add     eax, 1
.text:000005B7                 mov     [ebp+var_20], eax
.text:000005BA
.text:000005BA loc_5BA:                                ; CODE XREF: CClusterInStream::Read(void *,uint,uint *)+12Fj
.text:000005BA                 cmp     [ebp+var_20], 40h ; '@'
.text:000005BE                 jge     short loc_60C
.text:000005C0                 mov     esi, [ebp+var_8]
.text:000005C3                 add     esi, [ebp+var_20]
.text:000005C6                 mov     ecx, [ebp+this]
.text:000005C9                 add     ecx, 34h ; '4'
.text:000005CC                 call    ?Size@?$CRecordVector@I@@QBEIXZ ; CRecordVector<uint>::Size(void)
.text:000005D1                 cmp     esi, eax
.text:000005D3                 jnb     short loc_60C
.text:000005D5                 mov     esi, [ebp+var_10]
.text:000005D8                 add     esi, [ebp+var_20]
.text:000005DB                 mov     ecx, [ebp+var_8]
.text:000005DE                 add     ecx, [ebp+var_20]
.text:000005E1                 push    ecx
.text:000005E2                 mov     ecx, [ebp+this]
.text:000005E5                 add     ecx, 34h ; '4'
.text:000005E8                 call    ??A?$CRecordVector@I@@QAEAAII@Z ; CRecordVector<uint>::operator[](uint)
.text:000005ED                 cmp     esi, [eax]
.text:000005EF                 jnz     short loc_60C
.text:000005F1                 mov     edx, [ebp+this]
.text:000005F4                 mov     eax, 1
.text:000005F9                 mov     ecx, [edx+30h]
.text:000005FC                 shl     eax, cl
.text:000005FE                 mov     ecx, [ebp+this]
.text:00000601                 add     eax, [ecx+18h]
.text:00000604                 mov     edx, [ebp+this]
.text:00000607                 mov     [edx+18h], eax
.text:0000060A                 jmp     short loc_5B1
.text:0000060C ; ---------------------------------------------------------------------------
.text:0000060C
.text:0000060C loc_60C:                                ; CODE XREF: CClusterInStream::Read(void *,uint,uint *)+13Ej
.text:0000060C                                         ; CClusterInStream::Read(void *,uint,uint *)+153j ...
.text:0000060C                 mov     eax, [ebp+this]
.text:0000060F                 mov     ecx, [ebp+this]
.text:00000612                 mov     edx, [eax+28h]
.text:00000615                 sub     edx, [ecx+8]
.text:00000618                 mov     eax, [eax+2Ch]
.text:0000061B                 sbb     eax, [ecx+0Ch]
.text:0000061E                 mov     [ebp+var_28], edx
.text:00000621                 mov     [ebp+var_24], eax
.text:00000624                 mov     ecx, [ebp+this]
.text:00000627                 mov     edx, [ecx+18h]
.text:0000062A                 xor     eax, eax
.text:0000062C                 mov     [ebp+var_40], edx
.text:0000062F                 mov     [ebp+var_3C], eax
.text:00000632                 mov     ecx, [ebp+var_3C]
.text:00000635                 cmp     ecx, [ebp+var_24]
.text:00000638                 jb      short loc_64D
.text:0000063A                 ja      short loc_644
.text:0000063C                 mov     edx, [ebp+var_40]
.text:0000063F                 cmp     edx, [ebp+var_28]
.text:00000642                 jbe     short loc_64D
.text:00000644
.text:00000644 loc_644:                                ; CODE XREF: CClusterInStream::Read(void *,uint,uint *)+1BAj
.text:00000644                 mov     eax, [ebp+var_28]
.text:00000647                 mov     ecx, [ebp+this]
.text:0000064A                 mov     [ecx+18h], eax
.text:0000064D
.text:0000064D loc_64D:                                ; CODE XREF: CClusterInStream::Read(void *,uint,uint *)+5Ej
.text:0000064D                                         ; CClusterInStream::Read(void *,uint,uint *)+1B8j ...
.text:0000064D                 mov     edx, [ebp+this]
.text:00000650                 mov     eax, [ebp+arg_8]
.text:00000653                 cmp     eax, [edx+18h]
.text:00000656                 jbe     short loc_661
.text:00000658                 mov     ecx, [ebp+this]
.text:0000065B                 mov     edx, [ecx+18h]
.text:0000065E                 mov     [ebp+arg_8], edx
.text:00000661
.text:00000661 loc_661:                                ; CODE XREF: CClusterInStream::Read(void *,uint,uint *)+1D6j
.text:00000661                 mov     ecx, [ebp+this]
.text:00000664                 add     ecx, 1Ch
.text:00000667                 call    ??C?$CMyComPtr@UIInStream@@@@QBEPAUIInStream@@XZ ; CMyComPtr<IInStream>::operator->(void)
.text:0000066C                 mov     [ebp+var_44], eax
.text:0000066F                 mov     esi, esp
.text:00000671                 lea     eax, [ebp+arg_8]
.text:00000674                 push    eax
.text:00000675                 mov     ecx, [ebp+arg_8]
.text:00000678                 push    ecx
.text:00000679                 mov     edx, [ebp+arg_4]
.text:0000067C                 push    edx
.text:0000067D                 mov     eax, [ebp+var_44]
.text:00000680                 push    eax
.text:00000681                 mov     ecx, [ebp+var_44]
.text:00000684                 mov     edx, [ecx]
.text:00000686                 mov     eax, [edx+0Ch]
.text:00000689                 call    eax
.text:0000068B                 cmp     esi, esp
.text:0000068D                 call    __RTC_CheckEsp
.text:00000692                 mov     [ebp+var_2C], eax
.text:00000695                 cmp     [ebp+arg_C], 0
.text:00000699                 jz      short loc_6A3
.text:0000069B                 mov     ecx, [ebp+arg_C]
.text:0000069E                 mov     edx, [ebp+arg_8]
.text:000006A1                 mov     [ecx], edx
.text:000006A3
.text:000006A3 loc_6A3:                                ; CODE XREF: CClusterInStream::Read(void *,uint,uint *)+219j
.text:000006A3                 mov     eax, [ebp+arg_8]
.text:000006A6                 xor     ecx, ecx
.text:000006A8                 mov     edx, [ebp+this]
.text:000006AB                 add     eax, [edx+10h]
.text:000006AE                 adc     ecx, [edx+14h]
.text:000006B1                 mov     edx, [ebp+this]
.text:000006B4                 mov     [edx+10h], eax
.text:000006B7                 mov     [edx+14h], ecx
.text:000006BA                 mov     eax, [ebp+arg_8]
.text:000006BD                 xor     ecx, ecx
.text:000006BF                 mov     edx, [ebp+this]
.text:000006C2                 add     eax, [edx+8]
.text:000006C5                 adc     ecx, [edx+0Ch]
.text:000006C8                 mov     edx, [ebp+this]
.text:000006CB                 mov     [edx+8], eax
.text:000006CE                 mov     [edx+0Ch], ecx
.text:000006D1                 mov     eax, [ebp+this]
.text:000006D4                 mov     ecx, [eax+18h]
.text:000006D7                 sub     ecx, [ebp+arg_8]
.text:000006DA                 mov     edx, [ebp+this]
.text:000006DD                 mov     [edx+18h], ecx
.text:000006E0                 mov     eax, [ebp+var_2C]
.text:000006E3
.text:000006E3 loc_6E3:                                ; CODE XREF: CClusterInStream::Read(void *,uint,uint *)+52j
.text:000006E3                                         ; CClusterInStream::Read(void *,uint,uint *)+117j
.text:000006E3                 pop     edi
.text:000006E4                 pop     esi
.text:000006E5                 add     esp, 44h
.text:000006E8                 cmp     ebp, esp
.text:000006EA                 call    __RTC_CheckEsp
.text:000006EF                 mov     esp, ebp
.text:000006F1                 pop     ebp
.text:000006F2                 retn    10h
.text:000006F2 ?Read@CClusterInStream@@UAGJPAXIPAI@Z endp
.text:000006F2
.text:000006F2 ; ---------------------------------------------------------------------------
.text:000006F5                 align 10h
.text:00000700
.text:00000700 ; =============== S U B R O U T I N E =======================================
.text:00000700
.text:00000700 ; Attributes: bp-based frame
.text:00000700
.text:00000700 ; __int32 __stdcall CClusterInStream::Seek(CClusterInStream *this, __int64, unsigned int, unsigned __int64 *)
.text:00000700                 public ?Seek@CClusterInStream@@UAGJ_JIPA_K@Z
.text:00000700 ?Seek@CClusterInStream@@UAGJ_JIPA_K@Z proc near
.text:00000700
.text:00000700 var_8           = dword ptr -8
.text:00000700 var_4           = dword ptr -4
.text:00000700 this            = dword ptr  8
.text:00000700 arg_4           = qword ptr  0Ch
.text:00000700 arg_C           = dword ptr  14h
.text:00000700 arg_10          = dword ptr  18h
.text:00000700
.text:00000700                 push    ebp
.text:00000701                 mov     ebp, esp
.text:00000703                 sub     esp, 8
.text:00000706                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000070D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000714                 mov     eax, [ebp+arg_C]
.text:00000717                 mov     [ebp+var_4], eax
.text:0000071A                 cmp     [ebp+var_4], 0
.text:0000071E                 jz      short loc_72E
.text:00000720                 cmp     [ebp+var_4], 1
.text:00000724                 jz      short loc_730
.text:00000726                 cmp     [ebp+var_4], 2
.text:0000072A                 jz      short loc_747
.text:0000072C                 jmp     short loc_75E
.text:0000072E ; ---------------------------------------------------------------------------
.text:0000072E
.text:0000072E loc_72E:                                ; CODE XREF: CClusterInStream::Seek(__int64,uint,unsigned __int64 *)+1Ej
.text:0000072E                 jmp     short loc_765
.text:00000730 ; ---------------------------------------------------------------------------
.text:00000730
.text:00000730 loc_730:                                ; CODE XREF: CClusterInStream::Seek(__int64,uint,unsigned __int64 *)+24j
.text:00000730                 mov     ecx, [ebp+this]
.text:00000733                 mov     edx, dword ptr [ebp+arg_4]
.text:00000736                 add     edx, [ecx+8]
.text:00000739                 mov     eax, dword ptr [ebp+arg_4+4]
.text:0000073C                 adc     eax, [ecx+0Ch]
.text:0000073F                 mov     dword ptr [ebp+arg_4], edx
.text:00000742                 mov     dword ptr [ebp+arg_4+4], eax
.text:00000745                 jmp     short loc_765
.text:00000747 ; ---------------------------------------------------------------------------
.text:00000747
.text:00000747 loc_747:                                ; CODE XREF: CClusterInStream::Seek(__int64,uint,unsigned __int64 *)+2Aj
.text:00000747                 mov     ecx, [ebp+this]
.text:0000074A                 mov     edx, dword ptr [ebp+arg_4]
.text:0000074D                 add     edx, [ecx+28h]
.text:00000750                 mov     eax, dword ptr [ebp+arg_4+4]
.text:00000753                 adc     eax, [ecx+2Ch]
.text:00000756                 mov     dword ptr [ebp+arg_4], edx
.text:00000759                 mov     dword ptr [ebp+arg_4+4], eax
.text:0000075C                 jmp     short loc_765
.text:0000075E ; ---------------------------------------------------------------------------
.text:0000075E
.text:0000075E loc_75E:                                ; CODE XREF: CClusterInStream::Seek(__int64,uint,unsigned __int64 *)+2Cj
.text:0000075E                 mov     eax, 80030001h
.text:00000763                 jmp     short loc_7C5
.text:00000765 ; ---------------------------------------------------------------------------
.text:00000765
.text:00000765 loc_765:                                ; CODE XREF: CClusterInStream::Seek(__int64,uint,unsigned __int64 *):loc_72Ej
.text:00000765                                         ; CClusterInStream::Seek(__int64,uint,unsigned __int64 *)+45j ...
.text:00000765                 cmp     dword ptr [ebp+arg_4+4], 0
.text:00000769                 jg      short loc_77A
.text:0000076B                 jl      short loc_773
.text:0000076D                 cmp     dword ptr [ebp+arg_4], 0
.text:00000771                 jnb     short loc_77A
.text:00000773
.text:00000773 loc_773:                                ; CODE XREF: CClusterInStream::Seek(__int64,uint,unsigned __int64 *)+6Bj
.text:00000773                 mov     eax, 80070083h
.text:00000778                 jmp     short loc_7C5
.text:0000077A ; ---------------------------------------------------------------------------
.text:0000077A
.text:0000077A loc_77A:                                ; CODE XREF: CClusterInStream::Seek(__int64,uint,unsigned __int64 *)+69j
.text:0000077A                                         ; CClusterInStream::Seek(__int64,uint,unsigned __int64 *)+71j
.text:0000077A                 mov     ecx, [ebp+this]
.text:0000077D                 mov     [ebp+var_8], ecx
.text:00000780                 mov     edx, [ebp+var_8]
.text:00000783                 mov     eax, [edx+8]
.text:00000786                 cmp     eax, dword ptr [ebp+arg_4]
.text:00000789                 jnz     short loc_796
.text:0000078B                 mov     ecx, [ebp+var_8]
.text:0000078E                 mov     edx, [ecx+0Ch]
.text:00000791                 cmp     edx, dword ptr [ebp+arg_4+4]
.text:00000794                 jz      short loc_7A0
.text:00000796
.text:00000796 loc_796:                                ; CODE XREF: CClusterInStream::Seek(__int64,uint,unsigned __int64 *)+89j
.text:00000796                 mov     eax, [ebp+this]
.text:00000799                 mov     dword ptr [eax+18h], 0
.text:000007A0
.text:000007A0 loc_7A0:                                ; CODE XREF: CClusterInStream::Seek(__int64,uint,unsigned __int64 *)+94j
.text:000007A0                 mov     ecx, [ebp+this]
.text:000007A3                 mov     edx, dword ptr [ebp+arg_4]
.text:000007A6                 mov     [ecx+8], edx
.text:000007A9                 mov     eax, dword ptr [ebp+arg_4+4]
.text:000007AC                 mov     [ecx+0Ch], eax
.text:000007AF                 cmp     [ebp+arg_10], 0
.text:000007B3                 jz      short loc_7C3
.text:000007B5                 mov     ecx, [ebp+arg_10]
.text:000007B8                 mov     edx, dword ptr [ebp+arg_4]
.text:000007BB                 mov     [ecx], edx
.text:000007BD                 mov     eax, dword ptr [ebp+arg_4+4]
.text:000007C0                 mov     [ecx+4], eax
.text:000007C3
.text:000007C3 loc_7C3:                                ; CODE XREF: CClusterInStream::Seek(__int64,uint,unsigned __int64 *)+B3j
.text:000007C3                 xor     eax, eax
.text:000007C5
.text:000007C5 loc_7C5:                                ; CODE XREF: CClusterInStream::Seek(__int64,uint,unsigned __int64 *)+63j
.text:000007C5                                         ; CClusterInStream::Seek(__int64,uint,unsigned __int64 *)+78j
.text:000007C5                 mov     esp, ebp
.text:000007C7                 pop     ebp
.text:000007C8                 retn    14h
.text:000007C8 ?Seek@CClusterInStream@@UAGJ_JIPA_K@Z endp
.text:000007C8
.text:000007C8 ; ---------------------------------------------------------------------------
.text:000007CB                 align 10h
.text:000007D0
.text:000007D0 ; =============== S U B R O U T I N E =======================================
.text:000007D0
.text:000007D0 ; Attributes: bp-based frame
.text:000007D0
.text:000007D0 ; __int32 __stdcall CExtentsStream::Read(CExtentsStream *this, void *, unsigned int, unsigned int *)
.text:000007D0                 public ?Read@CExtentsStream@@UAGJPAXIPAI@Z
.text:000007D0 ?Read@CExtentsStream@@UAGJPAXIPAI@Z proc near
.text:000007D0
.text:000007D0 var_48          = dword ptr -48h
.text:000007D0 var_44          = dword ptr -44h
.text:000007D0 var_40          = dword ptr -40h
.text:000007D0 var_3C          = dword ptr -3Ch
.text:000007D0 var_38          = dword ptr -38h
.text:000007D0 var_34          = dword ptr -34h
.text:000007D0 var_30          = dword ptr -30h
.text:000007D0 var_2C          = dword ptr -2Ch
.text:000007D0 var_28          = dword ptr -28h
.text:000007D0 var_24          = dword ptr -24h
.text:000007D0 var_20          = dword ptr -20h
.text:000007D0 var_1C          = dword ptr -1Ch
.text:000007D0 var_18          = dword ptr -18h
.text:000007D0 var_14          = dword ptr -14h
.text:000007D0 var_10          = dword ptr -10h
.text:000007D0 var_C           = dword ptr -0Ch
.text:000007D0 var_8           = dword ptr -8
.text:000007D0 var_4           = dword ptr -4
.text:000007D0 this            = dword ptr  8
.text:000007D0 arg_4           = dword ptr  0Ch
.text:000007D0 arg_8           = dword ptr  10h
.text:000007D0 arg_C           = dword ptr  14h
.text:000007D0
.text:000007D0                 push    ebp
.text:000007D1                 mov     ebp, esp
.text:000007D3                 sub     esp, 48h
.text:000007D6                 push    esi
.text:000007D7                 push    edi
.text:000007D8                 lea     edi, [ebp+var_48]
.text:000007DB                 mov     ecx, 12h
.text:000007E0                 mov     eax, 0CCCCCCCCh
.text:000007E5                 rep stosd
.text:000007E7                 cmp     [ebp+arg_C], 0
.text:000007EB                 jz      short loc_7F6
.text:000007ED                 mov     eax, [ebp+arg_C]
.text:000007F0                 mov     dword ptr [eax], 0
.text:000007F6
.text:000007F6 loc_7F6:                                ; CODE XREF: CExtentsStream::Read(void *,uint,uint *)+1Bj
.text:000007F6                 mov     ecx, [ebp+this]
.text:000007F9                 add     ecx, 20h ; ' '
.text:000007FC                 call    ?Back@?$CRecordVector@UCSeekExtent@@@@QAEAAUCSeekExtent@@XZ ; CRecordVector<CSeekExtent>::Back(void)
.text:00000801                 mov     ecx, [ebp+this]
.text:00000804                 mov     [ebp+var_2C], ecx
.text:00000807                 mov     [ebp+var_30], eax
.text:0000080A                 mov     edx, [ebp+var_2C]
.text:0000080D                 mov     eax, [ebp+var_30]
.text:00000810                 mov     ecx, [edx+14h]
.text:00000813                 cmp     ecx, [eax+0Ch]
.text:00000816                 jb      short loc_82F
.text:00000818                 ja      short loc_828
.text:0000081A                 mov     edx, [ebp+var_2C]
.text:0000081D                 mov     eax, [ebp+var_30]
.text:00000820                 mov     ecx, [edx+10h]
.text:00000823                 cmp     ecx, [eax+8]
.text:00000826                 jb      short loc_82F
.text:00000828
.text:00000828 loc_828:                                ; CODE XREF: CExtentsStream::Read(void *,uint,uint *)+48j
.text:00000828                 xor     eax, eax
.text:0000082A                 jmp     loc_9F4
.text:0000082F ; ---------------------------------------------------------------------------
.text:0000082F
.text:0000082F loc_82F:                                ; CODE XREF: CExtentsStream::Read(void *,uint,uint *)+46j
.text:0000082F                                         ; CExtentsStream::Read(void *,uint,uint *)+56j
.text:0000082F                 cmp     [ebp+arg_8], 0
.text:00000833                 jnz     short loc_83C
.text:00000835                 xor     eax, eax
.text:00000837                 jmp     loc_9F4
.text:0000083C ; ---------------------------------------------------------------------------
.text:0000083C
.text:0000083C loc_83C:                                ; CODE XREF: CExtentsStream::Read(void *,uint,uint *)+63j
.text:0000083C                 mov     [ebp+var_4], 0
.text:00000843                 mov     ecx, [ebp+this]
.text:00000846                 add     ecx, 20h ; ' '
.text:00000849                 call    ?Size@?$CRecordVector@UCSeekExtent@@@@QBEIXZ ; CRecordVector<CSeekExtent>::Size(void)
.text:0000084E                 sub     eax, 1
.text:00000851                 mov     [ebp+var_8], eax
.text:00000854
.text:00000854 loc_854:                                ; CODE XREF: CExtentsStream::Read(void *,uint,uint *):loc_8ADj
.text:00000854                 mov     edx, [ebp+var_4]
.text:00000857                 add     edx, [ebp+var_8]
.text:0000085A                 shr     edx, 1
.text:0000085C                 mov     [ebp+var_C], edx
.text:0000085F                 mov     eax, [ebp+var_C]
.text:00000862                 cmp     eax, [ebp+var_4]
.text:00000865                 jnz     short loc_869
.text:00000867                 jmp     short loc_8AF
.text:00000869 ; ---------------------------------------------------------------------------
.text:00000869
.text:00000869 loc_869:                                ; CODE XREF: CExtentsStream::Read(void *,uint,uint *)+95j
.text:00000869                 mov     ecx, [ebp+var_C]
.text:0000086C                 push    ecx
.text:0000086D                 mov     ecx, [ebp+this]
.text:00000870                 add     ecx, 20h ; ' '
.text:00000873                 call    ??A?$CRecordVector@UCSeekExtent@@@@QAEAAUCSeekExtent@@I@Z ; CRecordVector<CSeekExtent>::operator[](uint)
.text:00000878                 mov     edx, [ebp+this]
.text:0000087B                 mov     [ebp+var_34], edx
.text:0000087E                 mov     [ebp+var_38], eax
.text:00000881                 mov     eax, [ebp+var_34]
.text:00000884                 mov     ecx, [ebp+var_38]
.text:00000887                 mov     edx, [eax+14h]
.text:0000088A                 cmp     edx, [ecx+0Ch]
.text:0000088D                 ja      short loc_8A7
.text:0000088F                 jb      short loc_89F
.text:00000891                 mov     eax, [ebp+var_34]
.text:00000894                 mov     ecx, [ebp+var_38]
.text:00000897                 mov     edx, [eax+10h]
.text:0000089A                 cmp     edx, [ecx+8]
.text:0000089D                 jnb     short loc_8A7
.text:0000089F
.text:0000089F loc_89F:                                ; CODE XREF: CExtentsStream::Read(void *,uint,uint *)+BFj
.text:0000089F                 mov     eax, [ebp+var_C]
.text:000008A2                 mov     [ebp+var_8], eax
.text:000008A5                 jmp     short loc_8AD
.text:000008A7 ; ---------------------------------------------------------------------------
.text:000008A7
.text:000008A7 loc_8A7:                                ; CODE XREF: CExtentsStream::Read(void *,uint,uint *)+BDj
.text:000008A7                                         ; CExtentsStream::Read(void *,uint,uint *)+CDj
.text:000008A7                 mov     ecx, [ebp+var_C]
.text:000008AA                 mov     [ebp+var_4], ecx
.text:000008AD
.text:000008AD loc_8AD:                                ; CODE XREF: CExtentsStream::Read(void *,uint,uint *)+D5j
.text:000008AD                 jmp     short loc_854
.text:000008AF ; ---------------------------------------------------------------------------
.text:000008AF
.text:000008AF loc_8AF:                                ; CODE XREF: CExtentsStream::Read(void *,uint,uint *)+97j
.text:000008AF                 mov     edx, [ebp+var_4]
.text:000008B2                 push    edx
.text:000008B3                 mov     ecx, [ebp+this]
.text:000008B6                 add     ecx, 20h ; ' '
.text:000008B9                 call    ??A?$CRecordVector@UCSeekExtent@@@@QAEAAUCSeekExtent@@I@Z ; CRecordVector<CSeekExtent>::operator[](uint)
.text:000008BE                 mov     [ebp+var_10], eax
.text:000008C1                 mov     eax, [ebp+this]
.text:000008C4                 mov     ecx, [ebp+var_10]
.text:000008C7                 mov     edx, [eax+10h]
.text:000008CA                 sub     edx, [ecx+8]
.text:000008CD                 mov     eax, [eax+14h]
.text:000008D0                 sbb     eax, [ecx+0Ch]
.text:000008D3                 mov     ecx, [ebp+var_10]
.text:000008D6                 add     edx, [ecx]
.text:000008D8                 adc     eax, [ecx+4]
.text:000008DB                 mov     [ebp+var_18], edx
.text:000008DE                 mov     [ebp+var_14], eax
.text:000008E1                 mov     edx, [ebp+this]
.text:000008E4                 movzx   eax, byte ptr [edx+18h]
.text:000008E8                 test    eax, eax
.text:000008EA                 jnz     short loc_908
.text:000008EC                 mov     ecx, [ebp+this]
.text:000008EF                 mov     [ebp+var_3C], ecx
.text:000008F2                 mov     edx, [ebp+var_3C]
.text:000008F5                 mov     eax, [edx+8]
.text:000008F8                 cmp     eax, [ebp+var_18]
.text:000008FB                 jnz     short loc_908
.text:000008FD                 mov     ecx, [ebp+var_3C]
.text:00000900                 mov     edx, [ecx+0Ch]
.text:00000903                 cmp     edx, [ebp+var_14]
.text:00000906                 jz      short loc_937
.text:00000908
.text:00000908 loc_908:                                ; CODE XREF: CExtentsStream::Read(void *,uint,uint *)+11Aj
.text:00000908                                         ; CExtentsStream::Read(void *,uint,uint *)+12Bj
.text:00000908                 mov     eax, [ebp+this]
.text:0000090B                 mov     byte ptr [eax+18h], 0
.text:0000090F                 mov     ecx, [ebp+this]
.text:00000912                 mov     edx, [ebp+var_18]
.text:00000915                 mov     [ecx+8], edx
.text:00000918                 mov     eax, [ebp+var_14]
.text:0000091B                 mov     [ecx+0Ch], eax
.text:0000091E                 mov     ecx, [ebp+this] ; this
.text:00000921                 call    ?SeekToPhys@CExtentsStream@@AAEJXZ ; CExtentsStream::SeekToPhys(void)
.text:00000926                 mov     [ebp+var_1C], eax
.text:00000929                 cmp     [ebp+var_1C], 0
.text:0000092D                 jz      short loc_937
.text:0000092F                 mov     eax, [ebp+var_1C]
.text:00000932                 jmp     loc_9F4
.text:00000937 ; ---------------------------------------------------------------------------
.text:00000937
.text:00000937 loc_937:                                ; CODE XREF: CExtentsStream::Read(void *,uint,uint *)+136j
.text:00000937                                         ; CExtentsStream::Read(void *,uint,uint *)+15Dj
.text:00000937                 mov     ecx, [ebp+var_4]
.text:0000093A                 add     ecx, 1
.text:0000093D                 push    ecx
.text:0000093E                 mov     ecx, [ebp+this]
.text:00000941                 add     ecx, 20h ; ' '
.text:00000944                 call    ??A?$CRecordVector@UCSeekExtent@@@@QAEAAUCSeekExtent@@I@Z ; CRecordVector<CSeekExtent>::operator[](uint)
.text:00000949                 mov     edx, [ebp+this]
.text:0000094C                 mov     ecx, [eax+8]
.text:0000094F                 sub     ecx, [edx+10h]
.text:00000952                 mov     eax, [eax+0Ch]
.text:00000955                 sbb     eax, [edx+14h]
.text:00000958                 mov     [ebp+var_24], ecx
.text:0000095B                 mov     [ebp+var_20], eax
.text:0000095E                 mov     ecx, [ebp+arg_8]
.text:00000961                 xor     edx, edx
.text:00000963                 mov     [ebp+var_44], ecx
.text:00000966                 mov     [ebp+var_40], edx
.text:00000969                 mov     eax, [ebp+var_40]
.text:0000096C                 cmp     eax, [ebp+var_20]
.text:0000096F                 jb      short loc_981
.text:00000971                 ja      short loc_97B
.text:00000973                 mov     ecx, [ebp+var_44]
.text:00000976                 cmp     ecx, [ebp+var_24]
.text:00000979                 jbe     short loc_981
.text:0000097B
.text:0000097B loc_97B:                                ; CODE XREF: CExtentsStream::Read(void *,uint,uint *)+1A1j
.text:0000097B                 mov     edx, [ebp+var_24]
.text:0000097E                 mov     [ebp+arg_8], edx
.text:00000981
.text:00000981 loc_981:                                ; CODE XREF: CExtentsStream::Read(void *,uint,uint *)+19Fj
.text:00000981                                         ; CExtentsStream::Read(void *,uint,uint *)+1A9j
.text:00000981                 mov     ecx, [ebp+this]
.text:00000984                 add     ecx, 1Ch
.text:00000987                 call    ??C?$CMyComPtr@UIInStream@@@@QBEPAUIInStream@@XZ ; CMyComPtr<IInStream>::operator->(void)
.text:0000098C                 mov     [ebp+var_48], eax
.text:0000098F                 mov     esi, esp
.text:00000991                 lea     eax, [ebp+arg_8]
.text:00000994                 push    eax
.text:00000995                 mov     ecx, [ebp+arg_8]
.text:00000998                 push    ecx
.text:00000999                 mov     edx, [ebp+arg_4]
.text:0000099C                 push    edx
.text:0000099D                 mov     eax, [ebp+var_48]
.text:000009A0                 push    eax
.text:000009A1                 mov     ecx, [ebp+var_48]
.text:000009A4                 mov     edx, [ecx]
.text:000009A6                 mov     eax, [edx+0Ch]
.text:000009A9                 call    eax
.text:000009AB                 cmp     esi, esp
.text:000009AD                 call    __RTC_CheckEsp
.text:000009B2                 mov     [ebp+var_28], eax
.text:000009B5                 mov     ecx, [ebp+arg_8]
.text:000009B8                 xor     edx, edx
.text:000009BA                 mov     eax, [ebp+this]
.text:000009BD                 add     ecx, [eax+8]
.text:000009C0                 adc     edx, [eax+0Ch]
.text:000009C3                 mov     eax, [ebp+this]
.text:000009C6                 mov     [eax+8], ecx
.text:000009C9                 mov     [eax+0Ch], edx
.text:000009CC                 mov     ecx, [ebp+arg_8]
.text:000009CF                 xor     edx, edx
.text:000009D1                 mov     eax, [ebp+this]
.text:000009D4                 add     ecx, [eax+10h]
.text:000009D7                 adc     edx, [eax+14h]
.text:000009DA                 mov     eax, [ebp+this]
.text:000009DD                 mov     [eax+10h], ecx
.text:000009E0                 mov     [eax+14h], edx
.text:000009E3                 cmp     [ebp+arg_C], 0
.text:000009E7                 jz      short loc_9F1
.text:000009E9                 mov     ecx, [ebp+arg_C]
.text:000009EC                 mov     edx, [ebp+arg_8]
.text:000009EF                 mov     [ecx], edx
.text:000009F1
.text:000009F1 loc_9F1:                                ; CODE XREF: CExtentsStream::Read(void *,uint,uint *)+217j
.text:000009F1                 mov     eax, [ebp+var_28]
.text:000009F4
.text:000009F4 loc_9F4:                                ; CODE XREF: CExtentsStream::Read(void *,uint,uint *)+5Aj
.text:000009F4                                         ; CExtentsStream::Read(void *,uint,uint *)+67j ...
.text:000009F4                 pop     edi
.text:000009F5                 pop     esi
.text:000009F6                 add     esp, 48h
.text:000009F9                 cmp     ebp, esp
.text:000009FB                 call    __RTC_CheckEsp
.text:00000A00                 mov     esp, ebp
.text:00000A02                 pop     ebp
.text:00000A03                 retn    10h
.text:00000A03 ?Read@CExtentsStream@@UAGJPAXIPAI@Z endp
.text:00000A03
.text:00000A03 ; ---------------------------------------------------------------------------
.text:00000A06                 align 10h
.text:00000A10
.text:00000A10 ; =============== S U B R O U T I N E =======================================
.text:00000A10
.text:00000A10 ; Attributes: bp-based frame
.text:00000A10
.text:00000A10 ; __int32 __stdcall CExtentsStream::Seek(CExtentsStream *this, __int64, unsigned int, unsigned __int64 *)
.text:00000A10                 public ?Seek@CExtentsStream@@UAGJ_JIPA_K@Z
.text:00000A10 ?Seek@CExtentsStream@@UAGJ_JIPA_K@Z proc near
.text:00000A10
.text:00000A10 var_4           = dword ptr -4
.text:00000A10 this            = dword ptr  8
.text:00000A10 arg_4           = qword ptr  0Ch
.text:00000A10 arg_C           = dword ptr  14h
.text:00000A10 arg_10          = dword ptr  18h
.text:00000A10
.text:00000A10                 push    ebp
.text:00000A11                 mov     ebp, esp
.text:00000A13                 push    ecx
.text:00000A14                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000A1B                 mov     eax, [ebp+arg_C]
.text:00000A1E                 mov     [ebp+var_4], eax
.text:00000A21                 cmp     [ebp+var_4], 0
.text:00000A25                 jz      short loc_A35
.text:00000A27                 cmp     [ebp+var_4], 1
.text:00000A2B                 jz      short loc_A37
.text:00000A2D                 cmp     [ebp+var_4], 2
.text:00000A31                 jz      short loc_A4E
.text:00000A33                 jmp     short loc_A6D
.text:00000A35 ; ---------------------------------------------------------------------------
.text:00000A35
.text:00000A35 loc_A35:                                ; CODE XREF: CExtentsStream::Seek(__int64,uint,unsigned __int64 *)+15j
.text:00000A35                 jmp     short loc_A74
.text:00000A37 ; ---------------------------------------------------------------------------
.text:00000A37
.text:00000A37 loc_A37:                                ; CODE XREF: CExtentsStream::Seek(__int64,uint,unsigned __int64 *)+1Bj
.text:00000A37                 mov     ecx, [ebp+this]
.text:00000A3A                 mov     edx, dword ptr [ebp+arg_4]
.text:00000A3D                 add     edx, [ecx+10h]
.text:00000A40                 mov     eax, dword ptr [ebp+arg_4+4]
.text:00000A43                 adc     eax, [ecx+14h]
.text:00000A46                 mov     dword ptr [ebp+arg_4], edx
.text:00000A49                 mov     dword ptr [ebp+arg_4+4], eax
.text:00000A4C                 jmp     short loc_A74
.text:00000A4E ; ---------------------------------------------------------------------------
.text:00000A4E
.text:00000A4E loc_A4E:                                ; CODE XREF: CExtentsStream::Seek(__int64,uint,unsigned __int64 *)+21j
.text:00000A4E                 mov     ecx, [ebp+this]
.text:00000A51                 add     ecx, 20h ; ' '
.text:00000A54                 call    ?Back@?$CRecordVector@UCSeekExtent@@@@QAEAAUCSeekExtent@@XZ ; CRecordVector<CSeekExtent>::Back(void)
.text:00000A59                 mov     ecx, dword ptr [ebp+arg_4]
.text:00000A5C                 add     ecx, [eax+8]
.text:00000A5F                 mov     edx, dword ptr [ebp+arg_4+4]
.text:00000A62                 adc     edx, [eax+0Ch]
.text:00000A65                 mov     dword ptr [ebp+arg_4], ecx
.text:00000A68                 mov     dword ptr [ebp+arg_4+4], edx
.text:00000A6B                 jmp     short loc_A74
.text:00000A6D ; ---------------------------------------------------------------------------
.text:00000A6D
.text:00000A6D loc_A6D:                                ; CODE XREF: CExtentsStream::Seek(__int64,uint,unsigned __int64 *)+23j
.text:00000A6D                 mov     eax, 80030001h
.text:00000A72                 jmp     short loc_AB1
.text:00000A74 ; ---------------------------------------------------------------------------
.text:00000A74
.text:00000A74 loc_A74:                                ; CODE XREF: CExtentsStream::Seek(__int64,uint,unsigned __int64 *):loc_A35j
.text:00000A74                                         ; CExtentsStream::Seek(__int64,uint,unsigned __int64 *)+3Cj ...
.text:00000A74                 cmp     dword ptr [ebp+arg_4+4], 0
.text:00000A78                 jg      short loc_A89
.text:00000A7A                 jl      short loc_A82
.text:00000A7C                 cmp     dword ptr [ebp+arg_4], 0
.text:00000A80                 jnb     short loc_A89
.text:00000A82
.text:00000A82 loc_A82:                                ; CODE XREF: CExtentsStream::Seek(__int64,uint,unsigned __int64 *)+6Aj
.text:00000A82                 mov     eax, 80070083h
.text:00000A87                 jmp     short loc_AB1
.text:00000A89 ; ---------------------------------------------------------------------------
.text:00000A89
.text:00000A89 loc_A89:                                ; CODE XREF: CExtentsStream::Seek(__int64,uint,unsigned __int64 *)+68j
.text:00000A89                                         ; CExtentsStream::Seek(__int64,uint,unsigned __int64 *)+70j
.text:00000A89                 mov     eax, [ebp+this]
.text:00000A8C                 mov     ecx, dword ptr [ebp+arg_4]
.text:00000A8F                 mov     [eax+10h], ecx
.text:00000A92                 mov     edx, dword ptr [ebp+arg_4+4]
.text:00000A95                 mov     [eax+14h], edx
.text:00000A98                 cmp     [ebp+arg_10], 0
.text:00000A9C                 jz      short loc_AAF
.text:00000A9E                 mov     eax, [ebp+arg_10]
.text:00000AA1                 mov     ecx, [ebp+this]
.text:00000AA4                 mov     edx, [ecx+10h]
.text:00000AA7                 mov     [eax], edx
.text:00000AA9                 mov     ecx, [ecx+14h]
.text:00000AAC                 mov     [eax+4], ecx
.text:00000AAF
.text:00000AAF loc_AAF:                                ; CODE XREF: CExtentsStream::Seek(__int64,uint,unsigned __int64 *)+8Cj
.text:00000AAF                 xor     eax, eax
.text:00000AB1
.text:00000AB1 loc_AB1:                                ; CODE XREF: CExtentsStream::Seek(__int64,uint,unsigned __int64 *)+62j
.text:00000AB1                                         ; CExtentsStream::Seek(__int64,uint,unsigned __int64 *)+77j
.text:00000AB1                 add     esp, 4
.text:00000AB4                 cmp     ebp, esp
.text:00000AB6                 call    __RTC_CheckEsp
.text:00000ABB                 mov     esp, ebp
.text:00000ABD                 pop     ebp
.text:00000ABE                 retn    14h
.text:00000ABE ?Seek@CExtentsStream@@UAGJ_JIPA_K@Z endp
.text:00000ABE
.text:00000ABE ; ---------------------------------------------------------------------------
.text:00000AC1                 align 10h
.text:00000AD0
.text:00000AD0 ; =============== S U B R O U T I N E =======================================
.text:00000AD0
.text:00000AD0 ; Attributes: bp-based frame
.text:00000AD0
.text:00000AD0 ; __int32 __stdcall CLimitedSequentialOutStream::Write(CLimitedSequentialOutStream *this, const void *, unsigned int, unsigned int *)
.text:00000AD0                 public ?Write@CLimitedSequentialOutStream@@UAGJPBXIPAI@Z
.text:00000AD0 ?Write@CLimitedSequentialOutStream@@UAGJPBXIPAI@Z proc near
.text:00000AD0
.text:00000AD0 var_18          = dword ptr -18h
.text:00000AD0 var_14          = dword ptr -14h
.text:00000AD0 var_10          = dword ptr -10h
.text:00000AD0 var_C           = dword ptr -0Ch
.text:00000AD0 var_8           = dword ptr -8
.text:00000AD0 var_4           = dword ptr -4
.text:00000AD0 this            = dword ptr  8
.text:00000AD0 arg_4           = dword ptr  0Ch
.text:00000AD0 arg_8           = dword ptr  10h
.text:00000AD0 arg_C           = dword ptr  14h
.text:00000AD0
.text:00000AD0                 push    ebp
.text:00000AD1                 mov     ebp, esp
.text:00000AD3                 sub     esp, 18h
.text:00000AD6                 push    esi
.text:00000AD7                 mov     eax, 0CCCCCCCCh
.text:00000ADC                 mov     [ebp+var_18], eax
.text:00000ADF                 mov     [ebp+var_14], eax
.text:00000AE2                 mov     [ebp+var_10], eax
.text:00000AE5                 mov     [ebp+var_C], eax
.text:00000AE8                 mov     [ebp+var_8], eax
.text:00000AEB                 mov     [ebp+var_4], eax
.text:00000AEE                 mov     [ebp+var_4], 0
.text:00000AF5                 cmp     [ebp+arg_C], 0
.text:00000AF9                 jz      short loc_B04
.text:00000AFB                 mov     eax, [ebp+arg_C]
.text:00000AFE                 mov     dword ptr [eax], 0
.text:00000B04
.text:00000B04 loc_B04:                                ; CODE XREF: CLimitedSequentialOutStream::Write(void const *,uint,uint *)+29j
.text:00000B04                 mov     ecx, [ebp+arg_8]
.text:00000B07                 xor     edx, edx
.text:00000B09                 mov     eax, [ebp+this]
.text:00000B0C                 mov     [ebp+var_C], ecx
.text:00000B0F                 mov     [ebp+var_8], edx
.text:00000B12                 mov     [ebp+var_10], eax
.text:00000B15                 mov     ecx, [ebp+var_10]
.text:00000B18                 mov     edx, [ebp+var_8]
.text:00000B1B                 cmp     edx, [ecx+14h]
.text:00000B1E                 jb      short loc_B78
.text:00000B20                 ja      short loc_B2D
.text:00000B22                 mov     eax, [ebp+var_10]
.text:00000B25                 mov     ecx, [ebp+var_C]
.text:00000B28                 cmp     ecx, [eax+10h]
.text:00000B2B                 jbe     short loc_B78
.text:00000B2D
.text:00000B2D loc_B2D:                                ; CODE XREF: CLimitedSequentialOutStream::Write(void const *,uint,uint *)+50j
.text:00000B2D                 mov     edx, [ebp+this]
.text:00000B30                 mov     [ebp+var_14], edx
.text:00000B33                 mov     eax, [ebp+var_14]
.text:00000B36                 mov     ecx, [ebp+var_14]
.text:00000B39                 mov     edx, [eax+10h]
.text:00000B3C                 or      edx, [ecx+14h]
.text:00000B3F                 jnz     short loc_B6F
.text:00000B41                 mov     eax, [ebp+this]
.text:00000B44                 mov     byte ptr [eax+18h], 1
.text:00000B48                 mov     ecx, [ebp+this]
.text:00000B4B                 movzx   edx, byte ptr [ecx+19h]
.text:00000B4F                 test    edx, edx
.text:00000B51                 jnz     short loc_B5D
.text:00000B53                 mov     eax, 80004005h
.text:00000B58                 jmp     loc_BE7
.text:00000B5D ; ---------------------------------------------------------------------------
.text:00000B5D
.text:00000B5D loc_B5D:                                ; CODE XREF: CLimitedSequentialOutStream::Write(void const *,uint,uint *)+81j
.text:00000B5D                 cmp     [ebp+arg_C], 0
.text:00000B61                 jz      short loc_B6B
.text:00000B63                 mov     eax, [ebp+arg_C]
.text:00000B66                 mov     ecx, [ebp+arg_8]
.text:00000B69                 mov     [eax], ecx
.text:00000B6B
.text:00000B6B loc_B6B:                                ; CODE XREF: CLimitedSequentialOutStream::Write(void const *,uint,uint *)+91j
.text:00000B6B                 xor     eax, eax
.text:00000B6D                 jmp     short loc_BE7
.text:00000B6F ; ---------------------------------------------------------------------------
.text:00000B6F
.text:00000B6F loc_B6F:                                ; CODE XREF: CLimitedSequentialOutStream::Write(void const *,uint,uint *)+6Fj
.text:00000B6F                 mov     edx, [ebp+this]
.text:00000B72                 mov     eax, [edx+10h]
.text:00000B75                 mov     [ebp+arg_8], eax
.text:00000B78
.text:00000B78 loc_B78:                                ; CODE XREF: CLimitedSequentialOutStream::Write(void const *,uint,uint *)+4Ej
.text:00000B78                                         ; CLimitedSequentialOutStream::Write(void const *,uint,uint *)+5Bj
.text:00000B78                 mov     ecx, [ebp+this]
.text:00000B7B                 add     ecx, 8
.text:00000B7E                 call    ??B?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ ; CMyComPtr<ISequentialOutStream>::operator ISequentialOutStream *(void)
.text:00000B83                 test    eax, eax
.text:00000B85                 jz      short loc_BBB
.text:00000B87                 mov     ecx, [ebp+this]
.text:00000B8A                 add     ecx, 8
.text:00000B8D                 call    ??C?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ ; CMyComPtr<ISequentialOutStream>::operator->(void)
.text:00000B92                 mov     [ebp+var_18], eax
.text:00000B95                 mov     esi, esp
.text:00000B97                 lea     ecx, [ebp+arg_8]
.text:00000B9A                 push    ecx
.text:00000B9B                 mov     edx, [ebp+arg_8]
.text:00000B9E                 push    edx
.text:00000B9F                 mov     eax, [ebp+arg_4]
.text:00000BA2                 push    eax
.text:00000BA3                 mov     ecx, [ebp+var_18]
.text:00000BA6                 push    ecx
.text:00000BA7                 mov     edx, [ebp+var_18]
.text:00000BAA                 mov     eax, [edx]
.text:00000BAC                 mov     ecx, [eax+0Ch]
.text:00000BAF                 call    ecx
.text:00000BB1                 cmp     esi, esp
.text:00000BB3                 call    __RTC_CheckEsp
.text:00000BB8                 mov     [ebp+var_4], eax
.text:00000BBB
.text:00000BBB loc_BBB:                                ; CODE XREF: CLimitedSequentialOutStream::Write(void const *,uint,uint *)+B5j
.text:00000BBB                 mov     edx, [ebp+arg_8]
.text:00000BBE                 xor     eax, eax
.text:00000BC0                 mov     ecx, [ebp+this]
.text:00000BC3                 mov     esi, [ecx+10h]
.text:00000BC6                 sub     esi, edx
.text:00000BC8                 mov     edx, [ecx+14h]
.text:00000BCB                 sbb     edx, eax
.text:00000BCD                 mov     eax, [ebp+this]
.text:00000BD0                 mov     [eax+10h], esi
.text:00000BD3                 mov     [eax+14h], edx
.text:00000BD6                 cmp     [ebp+arg_C], 0
.text:00000BDA                 jz      short loc_BE4
.text:00000BDC                 mov     ecx, [ebp+arg_C]
.text:00000BDF                 mov     edx, [ebp+arg_8]
.text:00000BE2                 mov     [ecx], edx
.text:00000BE4
.text:00000BE4 loc_BE4:                                ; CODE XREF: CLimitedSequentialOutStream::Write(void const *,uint,uint *)+10Aj
.text:00000BE4                 mov     eax, [ebp+var_4]
.text:00000BE7
.text:00000BE7 loc_BE7:                                ; CODE XREF: CLimitedSequentialOutStream::Write(void const *,uint,uint *)+88j
.text:00000BE7                                         ; CLimitedSequentialOutStream::Write(void const *,uint,uint *)+9Dj
.text:00000BE7                 pop     esi
.text:00000BE8                 add     esp, 18h
.text:00000BEB                 cmp     ebp, esp
.text:00000BED                 call    __RTC_CheckEsp
.text:00000BF2                 mov     esp, ebp
.text:00000BF4                 pop     ebp
.text:00000BF5                 retn    10h
.text:00000BF5 ?Write@CLimitedSequentialOutStream@@UAGJPBXIPAI@Z endp
.text:00000BF5
.text:00000BF5 ; ---------------------------------------------------------------------------
.text:00000BF8                 align 10h
.text:00000C00
.text:00000C00 ; =============== S U B R O U T I N E =======================================
.text:00000C00
.text:00000C00 ; Attributes: bp-based frame
.text:00000C00
.text:00000C00 ; __int32 __stdcall CTailInStream::Read(CTailInStream *this, void *, unsigned int, unsigned int *)
.text:00000C00                 public ?Read@CTailInStream@@UAGJPAXIPAI@Z
.text:00000C00 ?Read@CTailInStream@@UAGJPAXIPAI@Z proc near
.text:00000C00
.text:00000C00 var_14          = dword ptr -14h
.text:00000C00 var_10          = dword ptr -10h
.text:00000C00 var_C           = dword ptr -0Ch
.text:00000C00 var_8           = dword ptr -8
.text:00000C00 var_4           = dword ptr -4
.text:00000C00 this            = dword ptr  8
.text:00000C00 arg_4           = dword ptr  0Ch
.text:00000C00 arg_8           = dword ptr  10h
.text:00000C00 arg_C           = dword ptr  14h
.text:00000C00
.text:00000C00                 push    ebp
.text:00000C01                 mov     ebp, esp
.text:00000C03                 sub     esp, 14h
.text:00000C06                 push    esi
.text:00000C07                 mov     eax, 0CCCCCCCCh
.text:00000C0C                 mov     [ebp+var_14], eax
.text:00000C0F                 mov     [ebp+var_10], eax
.text:00000C12                 mov     [ebp+var_C], eax
.text:00000C15                 mov     [ebp+var_8], eax
.text:00000C18                 mov     [ebp+var_4], eax
.text:00000C1B                 mov     ecx, [ebp+this]
.text:00000C1E                 add     ecx, 10h
.text:00000C21                 call    ??C?$CMyComPtr@UIInStream@@@@QBEPAUIInStream@@XZ ; CMyComPtr<IInStream>::operator->(void)
.text:00000C26                 mov     [ebp+var_14], eax
.text:00000C29                 mov     esi, esp
.text:00000C2B                 lea     eax, [ebp+var_8]
.text:00000C2E                 push    eax
.text:00000C2F                 mov     ecx, [ebp+arg_8]
.text:00000C32                 push    ecx
.text:00000C33                 mov     edx, [ebp+arg_4]
.text:00000C36                 push    edx
.text:00000C37                 mov     eax, [ebp+var_14]
.text:00000C3A                 push    eax
.text:00000C3B                 mov     ecx, [ebp+var_14]
.text:00000C3E                 mov     edx, [ecx]
.text:00000C40                 mov     eax, [edx+0Ch]
.text:00000C43                 call    eax
.text:00000C45                 cmp     esi, esp
.text:00000C47                 call    __RTC_CheckEsp
.text:00000C4C                 mov     [ebp+var_10], eax
.text:00000C4F                 cmp     [ebp+arg_C], 0
.text:00000C53                 jz      short loc_C5D
.text:00000C55                 mov     ecx, [ebp+arg_C]
.text:00000C58                 mov     edx, [ebp+var_8]
.text:00000C5B                 mov     [ecx], edx
.text:00000C5D
.text:00000C5D loc_C5D:                                ; CODE XREF: CTailInStream::Read(void *,uint,uint *)+53j
.text:00000C5D                 mov     eax, [ebp+var_8]
.text:00000C60                 xor     ecx, ecx
.text:00000C62                 mov     edx, [ebp+this]
.text:00000C65                 add     eax, [edx+8]
.text:00000C68                 adc     ecx, [edx+0Ch]
.text:00000C6B                 mov     edx, [ebp+this]
.text:00000C6E                 mov     [edx+8], eax
.text:00000C71                 mov     [edx+0Ch], ecx
.text:00000C74                 mov     eax, [ebp+var_10]
.text:00000C77                 push    edx
.text:00000C78                 mov     ecx, ebp
.text:00000C7A                 push    eax
.text:00000C7B                 lea     edx, $LN6_0
.text:00000C81                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00000C86                 pop     eax
.text:00000C87                 pop     edx
.text:00000C88                 pop     esi
.text:00000C89                 add     esp, 14h
.text:00000C8C                 cmp     ebp, esp
.text:00000C8E                 call    __RTC_CheckEsp
.text:00000C93                 mov     esp, ebp
.text:00000C95                 pop     ebp
.text:00000C96                 retn    10h
.text:00000C96 ?Read@CTailInStream@@UAGJPAXIPAI@Z endp
.text:00000C96
.text:00000C96 ; ---------------------------------------------------------------------------
.text:00000C99                 align 4
.text:00000C9C $LN6_0          dd 1                    ; DATA XREF: CTailInStream::Read(void *,uint,uint *)+7Bo
.text:00000CA0                 dd offset $LN5
.text:00000CA4 $LN5            dd 0FFFFFFF8h, 4        ; DATA XREF: .text:00000CA0o
.text:00000CAC                 dd offset $LN4
.text:00000CB0 $LN4            dd 727563h, 3 dup(0CCCCCCCCh) ; DATA XREF: .text:00000CACo
.text:00000CC0
.text:00000CC0 ; =============== S U B R O U T I N E =======================================
.text:00000CC0
.text:00000CC0 ; Attributes: bp-based frame
.text:00000CC0
.text:00000CC0 ; __int32 __stdcall CTailInStream::Seek(CTailInStream *this, __int64, unsigned int, unsigned __int64 *)
.text:00000CC0                 public ?Seek@CTailInStream@@UAGJ_JIPA_K@Z
.text:00000CC0 ?Seek@CTailInStream@@UAGJ_JIPA_K@Z proc near
.text:00000CC0
.text:00000CC0 var_24          = dword ptr -24h
.text:00000CC0 var_20          = dword ptr -20h
.text:00000CC0 var_1C          = dword ptr -1Ch
.text:00000CC0 var_18          = dword ptr -18h
.text:00000CC0 var_14          = dword ptr -14h
.text:00000CC0 var_10          = dword ptr -10h
.text:00000CC0 var_C           = dword ptr -0Ch
.text:00000CC0 var_8           = dword ptr -8
.text:00000CC0 var_4           = dword ptr -4
.text:00000CC0 this            = dword ptr  8
.text:00000CC0 arg_4           = qword ptr  0Ch
.text:00000CC0 arg_C           = dword ptr  14h
.text:00000CC0 arg_10          = dword ptr  18h
.text:00000CC0
.text:00000CC0                 push    ebp
.text:00000CC1                 mov     ebp, esp
.text:00000CC3                 sub     esp, 24h
.text:00000CC6                 push    esi
.text:00000CC7                 mov     eax, 0CCCCCCCCh
.text:00000CCC                 mov     [ebp+var_24], eax
.text:00000CCF                 mov     [ebp+var_20], eax
.text:00000CD2                 mov     [ebp+var_1C], eax
.text:00000CD5                 mov     [ebp+var_18], eax
.text:00000CD8                 mov     [ebp+var_14], eax
.text:00000CDB                 mov     [ebp+var_10], eax
.text:00000CDE                 mov     [ebp+var_C], eax
.text:00000CE1                 mov     [ebp+var_8], eax
.text:00000CE4                 mov     [ebp+var_4], eax
.text:00000CE7                 mov     eax, [ebp+arg_C]
.text:00000CEA                 mov     [ebp+var_18], eax
.text:00000CED                 cmp     [ebp+var_18], 0
.text:00000CF1                 jz      short loc_D04
.text:00000CF3                 cmp     [ebp+var_18], 1
.text:00000CF7                 jz      short loc_D09
.text:00000CF9                 cmp     [ebp+var_18], 2
.text:00000CFD                 jz      short loc_D23
.text:00000CFF                 jmp     loc_DD0
.text:00000D04 ; ---------------------------------------------------------------------------
.text:00000D04
.text:00000D04 loc_D04:                                ; CODE XREF: CTailInStream::Seek(__int64,uint,unsigned __int64 *)+31j
.text:00000D04                 jmp     loc_DD7
.text:00000D09 ; ---------------------------------------------------------------------------
.text:00000D09
.text:00000D09 loc_D09:                                ; CODE XREF: CTailInStream::Seek(__int64,uint,unsigned __int64 *)+37j
.text:00000D09                 mov     ecx, [ebp+this]
.text:00000D0C                 mov     edx, dword ptr [ebp+arg_4]
.text:00000D0F                 add     edx, [ecx+8]
.text:00000D12                 mov     eax, dword ptr [ebp+arg_4+4]
.text:00000D15                 adc     eax, [ecx+0Ch]
.text:00000D18                 mov     dword ptr [ebp+arg_4], edx
.text:00000D1B                 mov     dword ptr [ebp+arg_4+4], eax
.text:00000D1E                 jmp     loc_DD7
.text:00000D23 ; ---------------------------------------------------------------------------
.text:00000D23
.text:00000D23 loc_D23:                                ; CODE XREF: CTailInStream::Seek(__int64,uint,unsigned __int64 *)+3Dj
.text:00000D23                 mov     [ebp+var_C], 0
.text:00000D2A                 mov     [ebp+var_8], 0
.text:00000D31                 mov     ecx, [ebp+this]
.text:00000D34                 add     ecx, 10h
.text:00000D37                 call    ??C?$CMyComPtr@UIInStream@@@@QBEPAUIInStream@@XZ ; CMyComPtr<IInStream>::operator->(void)
.text:00000D3C                 mov     [ebp+var_1C], eax
.text:00000D3F                 mov     esi, esp
.text:00000D41                 lea     ecx, [ebp+var_C]
.text:00000D44                 push    ecx
.text:00000D45                 push    2
.text:00000D47                 mov     edx, dword ptr [ebp+arg_4+4]
.text:00000D4A                 push    edx
.text:00000D4B                 mov     eax, dword ptr [ebp+arg_4]
.text:00000D4E                 push    eax
.text:00000D4F                 mov     ecx, [ebp+var_1C]
.text:00000D52                 push    ecx
.text:00000D53                 mov     edx, [ebp+var_1C]
.text:00000D56                 mov     eax, [edx]
.text:00000D58                 mov     ecx, [eax+10h]
.text:00000D5B                 call    ecx
.text:00000D5D                 cmp     esi, esp
.text:00000D5F                 call    __RTC_CheckEsp
.text:00000D64                 mov     [ebp+var_14], eax
.text:00000D67                 cmp     [ebp+var_14], 0
.text:00000D6B                 jz      short loc_D75
.text:00000D6D                 mov     eax, [ebp+var_14]
.text:00000D70                 jmp     loc_E4F
.text:00000D75 ; ---------------------------------------------------------------------------
.text:00000D75
.text:00000D75 loc_D75:                                ; CODE XREF: CTailInStream::Seek(__int64,uint,unsigned __int64 *)+ABj
.text:00000D75                 mov     edx, [ebp+this]
.text:00000D78                 mov     [ebp+var_20], edx
.text:00000D7B                 mov     eax, [ebp+var_20]
.text:00000D7E                 mov     ecx, [ebp+var_8]
.text:00000D81                 cmp     ecx, [eax+1Ch]
.text:00000D84                 ja      short loc_D9D
.text:00000D86                 jb      short loc_D93
.text:00000D88                 mov     edx, [ebp+var_20]
.text:00000D8B                 mov     eax, [ebp+var_C]
.text:00000D8E                 cmp     eax, [edx+18h]
.text:00000D91                 jnb     short loc_D9D
.text:00000D93
.text:00000D93 loc_D93:                                ; CODE XREF: CTailInStream::Seek(__int64,uint,unsigned __int64 *)+C6j
.text:00000D93                 mov     eax, 80070083h
.text:00000D98                 jmp     loc_E4F
.text:00000D9D ; ---------------------------------------------------------------------------
.text:00000D9D
.text:00000D9D loc_D9D:                                ; CODE XREF: CTailInStream::Seek(__int64,uint,unsigned __int64 *)+C4j
.text:00000D9D                                         ; CTailInStream::Seek(__int64,uint,unsigned __int64 *)+D1j
.text:00000D9D                 mov     ecx, [ebp+this]
.text:00000DA0                 mov     edx, [ebp+var_C]
.text:00000DA3                 sub     edx, [ecx+18h]
.text:00000DA6                 mov     eax, [ebp+var_8]
.text:00000DA9                 sbb     eax, [ecx+1Ch]
.text:00000DAC                 mov     ecx, [ebp+this]
.text:00000DAF                 mov     [ecx+8], edx
.text:00000DB2                 mov     [ecx+0Ch], eax
.text:00000DB5                 cmp     [ebp+arg_10], 0
.text:00000DB9                 jz      short loc_DCC
.text:00000DBB                 mov     edx, [ebp+arg_10]
.text:00000DBE                 mov     eax, [ebp+this]
.text:00000DC1                 mov     ecx, [eax+8]
.text:00000DC4                 mov     [edx], ecx
.text:00000DC6                 mov     eax, [eax+0Ch]
.text:00000DC9                 mov     [edx+4], eax
.text:00000DCC
.text:00000DCC loc_DCC:                                ; CODE XREF: CTailInStream::Seek(__int64,uint,unsigned __int64 *)+F9j
.text:00000DCC                 xor     eax, eax
.text:00000DCE                 jmp     short loc_E4F
.text:00000DD0 ; ---------------------------------------------------------------------------
.text:00000DD0
.text:00000DD0 loc_DD0:                                ; CODE XREF: CTailInStream::Seek(__int64,uint,unsigned __int64 *)+3Fj
.text:00000DD0                 mov     eax, 80030001h
.text:00000DD5                 jmp     short loc_E4F
.text:00000DD7 ; ---------------------------------------------------------------------------
.text:00000DD7
.text:00000DD7 loc_DD7:                                ; CODE XREF: CTailInStream::Seek(__int64,uint,unsigned __int64 *):loc_D04j
.text:00000DD7                                         ; CTailInStream::Seek(__int64,uint,unsigned __int64 *)+5Ej
.text:00000DD7                 cmp     dword ptr [ebp+arg_4+4], 0
.text:00000DDB                 jg      short loc_DEC
.text:00000DDD                 jl      short loc_DE5
.text:00000DDF                 cmp     dword ptr [ebp+arg_4], 0
.text:00000DE3                 jnb     short loc_DEC
.text:00000DE5
.text:00000DE5 loc_DE5:                                ; CODE XREF: CTailInStream::Seek(__int64,uint,unsigned __int64 *)+11Dj
.text:00000DE5                 mov     eax, 80070083h
.text:00000DEA                 jmp     short loc_E4F
.text:00000DEC ; ---------------------------------------------------------------------------
.text:00000DEC
.text:00000DEC loc_DEC:                                ; CODE XREF: CTailInStream::Seek(__int64,uint,unsigned __int64 *)+11Bj
.text:00000DEC                                         ; CTailInStream::Seek(__int64,uint,unsigned __int64 *)+123j
.text:00000DEC                 mov     ecx, [ebp+this]
.text:00000DEF                 mov     edx, dword ptr [ebp+arg_4]
.text:00000DF2                 mov     [ecx+8], edx
.text:00000DF5                 mov     eax, dword ptr [ebp+arg_4+4]
.text:00000DF8                 mov     [ecx+0Ch], eax
.text:00000DFB                 cmp     [ebp+arg_10], 0
.text:00000DFF                 jz      short loc_E12
.text:00000E01                 mov     ecx, [ebp+arg_10]
.text:00000E04                 mov     edx, [ebp+this]
.text:00000E07                 mov     eax, [edx+8]
.text:00000E0A                 mov     [ecx], eax
.text:00000E0C                 mov     edx, [edx+0Ch]
.text:00000E0F                 mov     [ecx+4], edx
.text:00000E12
.text:00000E12 loc_E12:                                ; CODE XREF: CTailInStream::Seek(__int64,uint,unsigned __int64 *)+13Fj
.text:00000E12                 mov     ecx, [ebp+this]
.text:00000E15                 add     ecx, 10h
.text:00000E18                 call    ??C?$CMyComPtr@UIInStream@@@@QBEPAUIInStream@@XZ ; CMyComPtr<IInStream>::operator->(void)
.text:00000E1D                 mov     [ebp+var_24], eax
.text:00000E20                 mov     esi, esp
.text:00000E22                 push    0
.text:00000E24                 push    0
.text:00000E26                 mov     eax, [ebp+this]
.text:00000E29                 mov     ecx, [ebp+this]
.text:00000E2C                 mov     edx, [eax+18h]
.text:00000E2F                 add     edx, [ecx+8]
.text:00000E32                 mov     eax, [eax+1Ch]
.text:00000E35                 adc     eax, [ecx+0Ch]
.text:00000E38                 push    eax
.text:00000E39                 push    edx
.text:00000E3A                 mov     ecx, [ebp+var_24]
.text:00000E3D                 push    ecx
.text:00000E3E                 mov     edx, [ebp+var_24]
.text:00000E41                 mov     eax, [edx]
.text:00000E43                 mov     ecx, [eax+10h]
.text:00000E46                 call    ecx
.text:00000E48                 cmp     esi, esp
.text:00000E4A                 call    __RTC_CheckEsp
.text:00000E4F
.text:00000E4F loc_E4F:                                ; CODE XREF: CTailInStream::Seek(__int64,uint,unsigned __int64 *)+B0j
.text:00000E4F                                         ; CTailInStream::Seek(__int64,uint,unsigned __int64 *)+D8j ...
.text:00000E4F                 push    edx
.text:00000E50                 mov     ecx, ebp
.text:00000E52                 push    eax
.text:00000E53                 lea     edx, $LN18
.text:00000E59                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00000E5E                 pop     eax
.text:00000E5F                 pop     edx
.text:00000E60                 pop     esi
.text:00000E61                 add     esp, 24h
.text:00000E64                 cmp     ebp, esp
.text:00000E66                 call    __RTC_CheckEsp
.text:00000E6B                 mov     esp, ebp
.text:00000E6D                 pop     ebp
.text:00000E6E                 retn    14h
.text:00000E6E ?Seek@CTailInStream@@UAGJ_JIPA_K@Z endp
.text:00000E6E
.text:00000E6E ; ---------------------------------------------------------------------------
.text:00000E71                 align 4
.text:00000E74 $LN18           dd 1                    ; DATA XREF: CTailInStream::Seek(__int64,uint,unsigned __int64 *)+193o
.text:00000E78                 dd offset $LN17
.text:00000E7C $LN17           dd 0FFFFFFF4h, 8        ; DATA XREF: .text:00000E78o
.text:00000E84                 dd offset $LN16
.text:00000E88 $LN16           dd 736F70h, 0CCCCCCCCh  ; DATA XREF: .text:00000E84o
.text:00000E90
.text:00000E90 ; =============== S U B R O U T I N E =======================================
.text:00000E90
.text:00000E90 ; Attributes: bp-based frame
.text:00000E90
.text:00000E90 ; __int32 __stdcall CLimitedCachedInStream::Read(CLimitedCachedInStream *this, void *Dst, size_t Size, unsigned int *)
.text:00000E90                 public ?Read@CLimitedCachedInStream@@UAGJPAXIPAI@Z
.text:00000E90 ?Read@CLimitedCachedInStream@@UAGJPAXIPAI@Z proc near
.text:00000E90
.text:00000E90 var_48          = dword ptr -48h
.text:00000E90 var_44          = dword ptr -44h
.text:00000E90 var_40          = dword ptr -40h
.text:00000E90 var_3C          = dword ptr -3Ch
.text:00000E90 var_38          = dword ptr -38h
.text:00000E90 var_34          = dword ptr -34h
.text:00000E90 var_30          = dword ptr -30h
.text:00000E90 var_2C          = dword ptr -2Ch
.text:00000E90 var_28          = dword ptr -28h
.text:00000E90 var_24          = dword ptr -24h
.text:00000E90 var_20          = dword ptr -20h
.text:00000E90 var_1C          = dword ptr -1Ch
.text:00000E90 var_18          = dword ptr -18h
.text:00000E90 var_14          = dword ptr -14h
.text:00000E90 var_10          = dword ptr -10h
.text:00000E90 var_C           = dword ptr -0Ch
.text:00000E90 var_8           = dword ptr -8
.text:00000E90 var_4           = dword ptr -4
.text:00000E90 this            = dword ptr  8
.text:00000E90 Dst             = dword ptr  0Ch
.text:00000E90 Size            = dword ptr  10h
.text:00000E90 arg_C           = dword ptr  14h
.text:00000E90
.text:00000E90                 push    ebp
.text:00000E91                 mov     ebp, esp
.text:00000E93                 sub     esp, 48h
.text:00000E96                 push    esi
.text:00000E97                 push    edi
.text:00000E98                 lea     edi, [ebp+var_48]
.text:00000E9B                 mov     ecx, 12h
.text:00000EA0                 mov     eax, 0CCCCCCCCh
.text:00000EA5                 rep stosd
.text:00000EA7                 cmp     [ebp+arg_C], 0
.text:00000EAB                 jz      short loc_EB6
.text:00000EAD                 mov     eax, [ebp+arg_C]
.text:00000EB0                 mov     dword ptr [eax], 0
.text:00000EB6
.text:00000EB6 loc_EB6:                                ; CODE XREF: CLimitedCachedInStream::Read(void *,uint,uint *)+1Bj
.text:00000EB6                 mov     ecx, [ebp+this]
.text:00000EB9                 mov     edx, [ebp+this]
.text:00000EBC                 mov     [ebp+var_24], ecx
.text:00000EBF                 mov     [ebp+var_28], edx
.text:00000EC2                 mov     eax, [ebp+var_24]
.text:00000EC5                 mov     ecx, [ebp+var_28]
.text:00000EC8                 mov     edx, [eax+14h]
.text:00000ECB                 cmp     edx, [ecx+24h]
.text:00000ECE                 jb      short loc_EE7
.text:00000ED0                 ja      short loc_EE0
.text:00000ED2                 mov     eax, [ebp+var_24]
.text:00000ED5                 mov     ecx, [ebp+var_28]
.text:00000ED8                 mov     edx, [eax+10h]
.text:00000EDB                 cmp     edx, [ecx+20h]
.text:00000EDE                 jb      short loc_EE7
.text:00000EE0
.text:00000EE0 loc_EE0:                                ; CODE XREF: CLimitedCachedInStream::Read(void *,uint,uint *)+40j
.text:00000EE0                 xor     eax, eax
.text:00000EE2                 jmp     loc_1082
.text:00000EE7 ; ---------------------------------------------------------------------------
.text:00000EE7
.text:00000EE7 loc_EE7:                                ; CODE XREF: CLimitedCachedInStream::Read(void *,uint,uint *)+3Ej
.text:00000EE7                                         ; CLimitedCachedInStream::Read(void *,uint,uint *)+4Ej
.text:00000EE7                 mov     eax, [ebp+this]
.text:00000EEA                 mov     ecx, [ebp+this]
.text:00000EED                 mov     edx, [eax+20h]
.text:00000EF0                 sub     edx, [ecx+10h]
.text:00000EF3                 mov     eax, [eax+24h]
.text:00000EF6                 sbb     eax, [ecx+14h]
.text:00000EF9                 mov     [ebp+var_8], edx
.text:00000EFC                 mov     [ebp+var_4], eax
.text:00000EFF                 mov     ecx, [ebp+Size]
.text:00000F02                 xor     edx, edx
.text:00000F04                 mov     [ebp+var_30], ecx
.text:00000F07                 mov     [ebp+var_2C], edx
.text:00000F0A                 mov     eax, [ebp+var_4]
.text:00000F0D                 cmp     eax, [ebp+var_2C]
.text:00000F10                 ja      short loc_F22
.text:00000F12                 jb      short loc_F1C
.text:00000F14                 mov     ecx, [ebp+var_8]
.text:00000F17                 cmp     ecx, [ebp+var_30]
.text:00000F1A                 jnb     short loc_F22
.text:00000F1C
.text:00000F1C loc_F1C:                                ; CODE XREF: CLimitedCachedInStream::Read(void *,uint,uint *)+82j
.text:00000F1C                 mov     edx, [ebp+var_8]
.text:00000F1F                 mov     [ebp+Size], edx
.text:00000F22
.text:00000F22 loc_F22:                                ; CODE XREF: CLimitedCachedInStream::Read(void *,uint,uint *)+80j
.text:00000F22                                         ; CLimitedCachedInStream::Read(void *,uint,uint *)+8Aj
.text:00000F22                 mov     eax, [ebp+this]
.text:00000F25                 mov     ecx, [ebp+this]
.text:00000F28                 mov     edx, [eax+28h]
.text:00000F2B                 add     edx, [ecx+10h]
.text:00000F2E                 mov     eax, [eax+2Ch]
.text:00000F31                 adc     eax, [ecx+14h]
.text:00000F34                 mov     [ebp+var_10], edx
.text:00000F37                 mov     [ebp+var_C], eax
.text:00000F3A                 mov     ecx, [ebp+this]
.text:00000F3D                 mov     edx, [ecx+38h]
.text:00000F40                 xor     eax, eax
.text:00000F42                 mov     ecx, [ebp+var_10]
.text:00000F45                 sub     ecx, edx
.text:00000F47                 mov     edx, [ebp+var_C]
.text:00000F4A                 sbb     edx, eax
.text:00000F4C                 mov     [ebp+var_18], ecx
.text:00000F4F                 mov     [ebp+var_14], edx
.text:00000F52                 mov     [ebp+var_1C], 0
.text:00000F59                 mov     eax, [ebp+this]
.text:00000F5C                 mov     ecx, [eax+38h]
.text:00000F5F                 xor     edx, edx
.text:00000F61                 mov     [ebp+var_38], ecx
.text:00000F64                 mov     [ebp+var_34], edx
.text:00000F67                 mov     eax, [ebp+var_C]
.text:00000F6A                 cmp     eax, [ebp+var_34]
.text:00000F6D                 jb      short loc_FCE
.text:00000F6F                 ja      short loc_F79
.text:00000F71                 mov     ecx, [ebp+var_10]
.text:00000F74                 cmp     ecx, [ebp+var_38]
.text:00000F77                 jb      short loc_FCE
.text:00000F79
.text:00000F79 loc_F79:                                ; CODE XREF: CLimitedCachedInStream::Read(void *,uint,uint *)+DFj
.text:00000F79                 mov     edx, [ebp+this]
.text:00000F7C                 mov     eax, [edx+34h]
.text:00000F7F                 xor     ecx, ecx
.text:00000F81                 mov     [ebp+var_40], eax
.text:00000F84                 mov     [ebp+var_3C], ecx
.text:00000F87                 mov     edx, [ebp+var_14]
.text:00000F8A                 cmp     edx, [ebp+var_3C]
.text:00000F8D                 ja      short loc_FCE
.text:00000F8F                 jb      short loc_F99
.text:00000F91                 mov     eax, [ebp+var_18]
.text:00000F94                 cmp     eax, [ebp+var_40]
.text:00000F97                 ja      short loc_FCE
.text:00000F99
.text:00000F99 loc_F99:                                ; CODE XREF: CLimitedCachedInStream::Read(void *,uint,uint *)+FFj
.text:00000F99                 mov     ecx, [ebp+var_18]
.text:00000F9C                 mov     edx, [ebp+this]
.text:00000F9F                 mov     eax, [edx+34h]
.text:00000FA2                 sub     eax, ecx
.text:00000FA4                 cmp     [ebp+Size], eax
.text:00000FA7                 ja      short loc_FCE
.text:00000FA9                 cmp     [ebp+Size], 0
.text:00000FAD                 jz      short loc_FC9
.text:00000FAF                 mov     ecx, [ebp+Size]
.text:00000FB2                 push    ecx             ; Size
.text:00000FB3                 mov     edx, [ebp+var_18]
.text:00000FB6                 mov     eax, [ebp+this]
.text:00000FB9                 add     edx, [eax+30h]
.text:00000FBC                 push    edx             ; Src
.text:00000FBD                 mov     ecx, [ebp+Dst]
.text:00000FC0                 push    ecx             ; Dst
.text:00000FC1                 call    _memcpy
.text:00000FC6                 add     esp, 0Ch
.text:00000FC9
.text:00000FC9 loc_FC9:                                ; CODE XREF: CLimitedCachedInStream::Read(void *,uint,uint *)+11Dj
.text:00000FC9                 jmp     loc_105A
.text:00000FCE ; ---------------------------------------------------------------------------
.text:00000FCE
.text:00000FCE loc_FCE:                                ; CODE XREF: CLimitedCachedInStream::Read(void *,uint,uint *)+DDj
.text:00000FCE                                         ; CLimitedCachedInStream::Read(void *,uint,uint *)+E7j ...
.text:00000FCE                 mov     edx, [ebp+this]
.text:00000FD1                 mov     [ebp+var_44], edx
.text:00000FD4                 mov     eax, [ebp+var_44]
.text:00000FD7                 mov     ecx, [ebp+var_10]
.text:00000FDA                 cmp     ecx, [eax+18h]
.text:00000FDD                 jnz     short loc_FEA
.text:00000FDF                 mov     edx, [ebp+var_44]
.text:00000FE2                 mov     eax, [ebp+var_C]
.text:00000FE5                 cmp     eax, [edx+1Ch]
.text:00000FE8                 jz      short loc_100F
.text:00000FEA
.text:00000FEA loc_FEA:                                ; CODE XREF: CLimitedCachedInStream::Read(void *,uint,uint *)+14Dj
.text:00000FEA                 mov     ecx, [ebp+this]
.text:00000FED                 mov     edx, [ebp+var_10]
.text:00000FF0                 mov     [ecx+18h], edx
.text:00000FF3                 mov     eax, [ebp+var_C]
.text:00000FF6                 mov     [ecx+1Ch], eax
.text:00000FF9                 mov     ecx, [ebp+this] ; this
.text:00000FFC                 call    ?SeekToPhys@CLimitedCachedInStream@@AAEJXZ ; CLimitedCachedInStream::SeekToPhys(void)
.text:00001001                 mov     [ebp+var_20], eax
.text:00001004                 cmp     [ebp+var_20], 0
.text:00001008                 jz      short loc_100F
.text:0000100A                 mov     eax, [ebp+var_20]
.text:0000100D                 jmp     short loc_1082
.text:0000100F ; ---------------------------------------------------------------------------
.text:0000100F
.text:0000100F loc_100F:                               ; CODE XREF: CLimitedCachedInStream::Read(void *,uint,uint *)+158j
.text:0000100F                                         ; CLimitedCachedInStream::Read(void *,uint,uint *)+178j
.text:0000100F                 mov     ecx, [ebp+this]
.text:00001012                 add     ecx, 8
.text:00001015                 call    ??C?$CMyComPtr@UIInStream@@@@QBEPAUIInStream@@XZ ; CMyComPtr<IInStream>::operator->(void)
.text:0000101A                 mov     [ebp+var_48], eax
.text:0000101D                 mov     esi, esp
.text:0000101F                 lea     ecx, [ebp+Size]
.text:00001022                 push    ecx
.text:00001023                 mov     edx, [ebp+Size]
.text:00001026                 push    edx
.text:00001027                 mov     eax, [ebp+Dst]
.text:0000102A                 push    eax
.text:0000102B                 mov     ecx, [ebp+var_48]
.text:0000102E                 push    ecx
.text:0000102F                 mov     edx, [ebp+var_48]
.text:00001032                 mov     eax, [edx]
.text:00001034                 mov     ecx, [eax+0Ch]
.text:00001037                 call    ecx
.text:00001039                 cmp     esi, esp
.text:0000103B                 call    __RTC_CheckEsp
.text:00001040                 mov     [ebp+var_1C], eax
.text:00001043                 mov     edx, [ebp+Size]
.text:00001046                 xor     eax, eax
.text:00001048                 mov     ecx, [ebp+this]
.text:0000104B                 add     edx, [ecx+18h]
.text:0000104E                 adc     eax, [ecx+1Ch]
.text:00001051                 mov     ecx, [ebp+this]
.text:00001054                 mov     [ecx+18h], edx
.text:00001057                 mov     [ecx+1Ch], eax
.text:0000105A
.text:0000105A loc_105A:                               ; CODE XREF: CLimitedCachedInStream::Read(void *,uint,uint *):loc_FC9j
.text:0000105A                 cmp     [ebp+arg_C], 0
.text:0000105E                 jz      short loc_1068
.text:00001060                 mov     edx, [ebp+arg_C]
.text:00001063                 mov     eax, [ebp+Size]
.text:00001066                 mov     [edx], eax
.text:00001068
.text:00001068 loc_1068:                               ; CODE XREF: CLimitedCachedInStream::Read(void *,uint,uint *)+1CEj
.text:00001068                 mov     ecx, [ebp+Size]
.text:0000106B                 xor     edx, edx
.text:0000106D                 mov     eax, [ebp+this]
.text:00001070                 add     ecx, [eax+10h]
.text:00001073                 adc     edx, [eax+14h]
.text:00001076                 mov     eax, [ebp+this]
.text:00001079                 mov     [eax+10h], ecx
.text:0000107C                 mov     [eax+14h], edx
.text:0000107F                 mov     eax, [ebp+var_1C]
.text:00001082
.text:00001082 loc_1082:                               ; CODE XREF: CLimitedCachedInStream::Read(void *,uint,uint *)+52j
.text:00001082                                         ; CLimitedCachedInStream::Read(void *,uint,uint *)+17Dj
.text:00001082                 pop     edi
.text:00001083                 pop     esi
.text:00001084                 add     esp, 48h
.text:00001087                 cmp     ebp, esp
.text:00001089                 call    __RTC_CheckEsp
.text:0000108E                 mov     esp, ebp
.text:00001090                 pop     ebp
.text:00001091                 retn    10h
.text:00001091 ?Read@CLimitedCachedInStream@@UAGJPAXIPAI@Z endp
.text:00001091
.text:00001091 ; ---------------------------------------------------------------------------
.text:00001094                 align 10h
.text:000010A0
.text:000010A0 ; =============== S U B R O U T I N E =======================================
.text:000010A0
.text:000010A0 ; Attributes: bp-based frame
.text:000010A0
.text:000010A0 ; __int32 __stdcall CLimitedCachedInStream::Seek(CLimitedCachedInStream *this, __int64, unsigned int, unsigned __int64 *)
.text:000010A0                 public ?Seek@CLimitedCachedInStream@@UAGJ_JIPA_K@Z
.text:000010A0 ?Seek@CLimitedCachedInStream@@UAGJ_JIPA_K@Z proc near
.text:000010A0
.text:000010A0 var_4           = dword ptr -4
.text:000010A0 this            = dword ptr  8
.text:000010A0 arg_4           = qword ptr  0Ch
.text:000010A0 arg_C           = dword ptr  14h
.text:000010A0 arg_10          = dword ptr  18h
.text:000010A0
.text:000010A0                 push    ebp
.text:000010A1                 mov     ebp, esp
.text:000010A3                 push    ecx
.text:000010A4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000010AB                 mov     eax, [ebp+arg_C]
.text:000010AE                 mov     [ebp+var_4], eax
.text:000010B1                 cmp     [ebp+var_4], 0
.text:000010B5                 jz      short loc_10C5
.text:000010B7                 cmp     [ebp+var_4], 1
.text:000010BB                 jz      short loc_10C7
.text:000010BD                 cmp     [ebp+var_4], 2
.text:000010C1                 jz      short loc_10DE
.text:000010C3                 jmp     short loc_10F5
.text:000010C5 ; ---------------------------------------------------------------------------
.text:000010C5
.text:000010C5 loc_10C5:                               ; CODE XREF: CLimitedCachedInStream::Seek(__int64,uint,unsigned __int64 *)+15j
.text:000010C5                 jmp     short loc_10FC
.text:000010C7 ; ---------------------------------------------------------------------------
.text:000010C7
.text:000010C7 loc_10C7:                               ; CODE XREF: CLimitedCachedInStream::Seek(__int64,uint,unsigned __int64 *)+1Bj
.text:000010C7                 mov     ecx, [ebp+this]
.text:000010CA                 mov     edx, dword ptr [ebp+arg_4]
.text:000010CD                 add     edx, [ecx+10h]
.text:000010D0                 mov     eax, dword ptr [ebp+arg_4+4]
.text:000010D3                 adc     eax, [ecx+14h]
.text:000010D6                 mov     dword ptr [ebp+arg_4], edx
.text:000010D9                 mov     dword ptr [ebp+arg_4+4], eax
.text:000010DC                 jmp     short loc_10FC
.text:000010DE ; ---------------------------------------------------------------------------
.text:000010DE
.text:000010DE loc_10DE:                               ; CODE XREF: CLimitedCachedInStream::Seek(__int64,uint,unsigned __int64 *)+21j
.text:000010DE                 mov     ecx, [ebp+this]
.text:000010E1                 mov     edx, dword ptr [ebp+arg_4]
.text:000010E4                 add     edx, [ecx+20h]
.text:000010E7                 mov     eax, dword ptr [ebp+arg_4+4]
.text:000010EA                 adc     eax, [ecx+24h]
.text:000010ED                 mov     dword ptr [ebp+arg_4], edx
.text:000010F0                 mov     dword ptr [ebp+arg_4+4], eax
.text:000010F3                 jmp     short loc_10FC
.text:000010F5 ; ---------------------------------------------------------------------------
.text:000010F5
.text:000010F5 loc_10F5:                               ; CODE XREF: CLimitedCachedInStream::Seek(__int64,uint,unsigned __int64 *)+23j
.text:000010F5                 mov     eax, 80030001h
.text:000010FA                 jmp     short loc_1139
.text:000010FC ; ---------------------------------------------------------------------------
.text:000010FC
.text:000010FC loc_10FC:                               ; CODE XREF: CLimitedCachedInStream::Seek(__int64,uint,unsigned __int64 *):loc_10C5j
.text:000010FC                                         ; CLimitedCachedInStream::Seek(__int64,uint,unsigned __int64 *)+3Cj ...
.text:000010FC                 cmp     dword ptr [ebp+arg_4+4], 0
.text:00001100                 jg      short loc_1111
.text:00001102                 jl      short loc_110A
.text:00001104                 cmp     dword ptr [ebp+arg_4], 0
.text:00001108                 jnb     short loc_1111
.text:0000110A
.text:0000110A loc_110A:                               ; CODE XREF: CLimitedCachedInStream::Seek(__int64,uint,unsigned __int64 *)+62j
.text:0000110A                 mov     eax, 80070083h
.text:0000110F                 jmp     short loc_1139
.text:00001111 ; ---------------------------------------------------------------------------
.text:00001111
.text:00001111 loc_1111:                               ; CODE XREF: CLimitedCachedInStream::Seek(__int64,uint,unsigned __int64 *)+60j
.text:00001111                                         ; CLimitedCachedInStream::Seek(__int64,uint,unsigned __int64 *)+68j
.text:00001111                 mov     ecx, [ebp+this]
.text:00001114                 mov     edx, dword ptr [ebp+arg_4]
.text:00001117                 mov     [ecx+10h], edx
.text:0000111A                 mov     eax, dword ptr [ebp+arg_4+4]
.text:0000111D                 mov     [ecx+14h], eax
.text:00001120                 cmp     [ebp+arg_10], 0
.text:00001124                 jz      short loc_1137
.text:00001126                 mov     ecx, [ebp+arg_10]
.text:00001129                 mov     edx, [ebp+this]
.text:0000112C                 mov     eax, [edx+10h]
.text:0000112F                 mov     [ecx], eax
.text:00001131                 mov     edx, [edx+14h]
.text:00001134                 mov     [ecx+4], edx
.text:00001137
.text:00001137 loc_1137:                               ; CODE XREF: CLimitedCachedInStream::Seek(__int64,uint,unsigned __int64 *)+84j
.text:00001137                 xor     eax, eax
.text:00001139
.text:00001139 loc_1139:                               ; CODE XREF: CLimitedCachedInStream::Seek(__int64,uint,unsigned __int64 *)+5Aj
.text:00001139                                         ; CLimitedCachedInStream::Seek(__int64,uint,unsigned __int64 *)+6Fj
.text:00001139                 mov     esp, ebp
.text:0000113B                 pop     ebp
.text:0000113C                 retn    14h
.text:0000113C ?Seek@CLimitedCachedInStream@@UAGJ_JIPA_K@Z endp
.text:0000113C
.text:0000113C ; ---------------------------------------------------------------------------
.text:0000113F                 align 10h
.text:00001140
.text:00001140 ; =============== S U B R O U T I N E =======================================
.text:00001140
.text:00001140 ; Attributes: bp-based frame
.text:00001140
.text:00001140 ; __int32 __stdcall CTailOutStream::Write(CTailOutStream *this, const void *, unsigned int, unsigned int *)
.text:00001140                 public ?Write@CTailOutStream@@UAGJPBXIPAI@Z
.text:00001140 ?Write@CTailOutStream@@UAGJPBXIPAI@Z proc near
.text:00001140
.text:00001140 var_1C          = dword ptr -1Ch
.text:00001140 var_18          = dword ptr -18h
.text:00001140 var_14          = dword ptr -14h
.text:00001140 var_10          = dword ptr -10h
.text:00001140 var_C           = dword ptr -0Ch
.text:00001140 var_8           = dword ptr -8
.text:00001140 var_4           = dword ptr -4
.text:00001140 this            = dword ptr  8
.text:00001140 arg_4           = dword ptr  0Ch
.text:00001140 arg_8           = dword ptr  10h
.text:00001140 arg_C           = dword ptr  14h
.text:00001140
.text:00001140                 push    ebp
.text:00001141                 mov     ebp, esp
.text:00001143                 sub     esp, 1Ch
.text:00001146                 push    esi
.text:00001147                 mov     eax, 0CCCCCCCCh
.text:0000114C                 mov     [ebp+var_1C], eax
.text:0000114F                 mov     [ebp+var_18], eax
.text:00001152                 mov     [ebp+var_14], eax
.text:00001155                 mov     [ebp+var_10], eax
.text:00001158                 mov     [ebp+var_C], eax
.text:0000115B                 mov     [ebp+var_8], eax
.text:0000115E                 mov     [ebp+var_4], eax
.text:00001161                 mov     ecx, [ebp+this]
.text:00001164                 add     ecx, 18h
.text:00001167                 call    ??C?$CMyComPtr@UIOutStream@@@@QBEPAUIOutStream@@XZ ; CMyComPtr<IOutStream>::operator->(void)
.text:0000116C                 mov     [ebp+var_14], eax
.text:0000116F                 mov     esi, esp
.text:00001171                 lea     eax, [ebp+var_8]
.text:00001174                 push    eax
.text:00001175                 mov     ecx, [ebp+arg_8]
.text:00001178                 push    ecx
.text:00001179                 mov     edx, [ebp+arg_4]
.text:0000117C                 push    edx
.text:0000117D                 mov     eax, [ebp+var_14]
.text:00001180                 push    eax
.text:00001181                 mov     ecx, [ebp+var_14]
.text:00001184                 mov     edx, [ecx]
.text:00001186                 mov     eax, [edx+0Ch]
.text:00001189                 call    eax
.text:0000118B                 cmp     esi, esp
.text:0000118D                 call    __RTC_CheckEsp
.text:00001192                 mov     [ebp+var_10], eax
.text:00001195                 cmp     [ebp+arg_C], 0
.text:00001199                 jz      short loc_11A3
.text:0000119B                 mov     ecx, [ebp+arg_C]
.text:0000119E                 mov     edx, [ebp+var_8]
.text:000011A1                 mov     [ecx], edx
.text:000011A3
.text:000011A3 loc_11A3:                               ; CODE XREF: CTailOutStream::Write(void const *,uint,uint *)+59j
.text:000011A3                 mov     eax, [ebp+var_8]
.text:000011A6                 xor     ecx, ecx
.text:000011A8                 mov     edx, [ebp+this]
.text:000011AB                 add     eax, [edx+8]
.text:000011AE                 adc     ecx, [edx+0Ch]
.text:000011B1                 mov     edx, [ebp+this]
.text:000011B4                 mov     [edx+8], eax
.text:000011B7                 mov     [edx+0Ch], ecx
.text:000011BA                 mov     eax, [ebp+this]
.text:000011BD                 mov     ecx, [ebp+this]
.text:000011C0                 mov     [ebp+var_18], eax
.text:000011C3                 mov     [ebp+var_1C], ecx
.text:000011C6                 mov     edx, [ebp+var_18]
.text:000011C9                 mov     eax, [ebp+var_1C]
.text:000011CC                 mov     ecx, [edx+14h]
.text:000011CF                 cmp     ecx, [eax+0Ch]
.text:000011D2                 ja      short loc_11F6
.text:000011D4                 jb      short loc_11E4
.text:000011D6                 mov     edx, [ebp+var_18]
.text:000011D9                 mov     eax, [ebp+var_1C]
.text:000011DC                 mov     ecx, [edx+10h]
.text:000011DF                 cmp     ecx, [eax+8]
.text:000011E2                 jnb     short loc_11F6
.text:000011E4
.text:000011E4 loc_11E4:                               ; CODE XREF: CTailOutStream::Write(void const *,uint,uint *)+94j
.text:000011E4                 mov     edx, [ebp+this]
.text:000011E7                 mov     eax, [ebp+this]
.text:000011EA                 mov     ecx, [eax+8]
.text:000011ED                 mov     [edx+10h], ecx
.text:000011F0                 mov     eax, [eax+0Ch]
.text:000011F3                 mov     [edx+14h], eax
.text:000011F6
.text:000011F6 loc_11F6:                               ; CODE XREF: CTailOutStream::Write(void const *,uint,uint *)+92j
.text:000011F6                                         ; CTailOutStream::Write(void const *,uint,uint *)+A2j
.text:000011F6                 mov     eax, [ebp+var_10]
.text:000011F9                 push    edx
.text:000011FA                 mov     ecx, ebp
.text:000011FC                 push    eax
.text:000011FD                 lea     edx, $LN8_1
.text:00001203                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00001208                 pop     eax
.text:00001209                 pop     edx
.text:0000120A                 pop     esi
.text:0000120B                 add     esp, 1Ch
.text:0000120E                 cmp     ebp, esp
.text:00001210                 call    __RTC_CheckEsp
.text:00001215                 mov     esp, ebp
.text:00001217                 pop     ebp
.text:00001218                 retn    10h
.text:00001218 ?Write@CTailOutStream@@UAGJPBXIPAI@Z endp
.text:00001218
.text:00001218 ; ---------------------------------------------------------------------------
.text:0000121B                 align 4
.text:0000121C $LN8_1          dd 1                    ; DATA XREF: CTailOutStream::Write(void const *,uint,uint *)+BDo
.text:00001220                 dd offset $LN7_0
.text:00001224 $LN7_0          dd 0FFFFFFF8h, 4        ; DATA XREF: .text:00001220o
.text:0000122C                 dd offset $LN6_1
.text:00001230 $LN6_1          dd 727563h, 3 dup(0CCCCCCCCh) ; DATA XREF: .text:0000122Co
.text:00001240
.text:00001240 ; =============== S U B R O U T I N E =======================================
.text:00001240
.text:00001240 ; Attributes: bp-based frame
.text:00001240
.text:00001240 ; __int32 __stdcall CTailOutStream::Seek(CTailOutStream *this, __int64, unsigned int, unsigned __int64 *)
.text:00001240                 public ?Seek@CTailOutStream@@UAGJ_JIPA_K@Z
.text:00001240 ?Seek@CTailOutStream@@UAGJ_JIPA_K@Z proc near
.text:00001240
.text:00001240 var_8           = dword ptr -8
.text:00001240 var_4           = dword ptr -4
.text:00001240 this            = dword ptr  8
.text:00001240 arg_4           = qword ptr  0Ch
.text:00001240 arg_C           = dword ptr  14h
.text:00001240 arg_10          = dword ptr  18h
.text:00001240
.text:00001240                 push    ebp
.text:00001241                 mov     ebp, esp
.text:00001243                 sub     esp, 8
.text:00001246                 push    esi
.text:00001247                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000124E                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001255                 mov     eax, [ebp+arg_C]
.text:00001258                 mov     [ebp+var_4], eax
.text:0000125B                 cmp     [ebp+var_4], 0
.text:0000125F                 jz      short loc_126F
.text:00001261                 cmp     [ebp+var_4], 1
.text:00001265                 jz      short loc_1271
.text:00001267                 cmp     [ebp+var_4], 2
.text:0000126B                 jz      short loc_1288
.text:0000126D                 jmp     short loc_129F
.text:0000126F ; ---------------------------------------------------------------------------
.text:0000126F
.text:0000126F loc_126F:                               ; CODE XREF: CTailOutStream::Seek(__int64,uint,unsigned __int64 *)+1Fj
.text:0000126F                 jmp     short loc_12A6
.text:00001271 ; ---------------------------------------------------------------------------
.text:00001271
.text:00001271 loc_1271:                               ; CODE XREF: CTailOutStream::Seek(__int64,uint,unsigned __int64 *)+25j
.text:00001271                 mov     ecx, [ebp+this]
.text:00001274                 mov     edx, dword ptr [ebp+arg_4]
.text:00001277                 add     edx, [ecx+8]
.text:0000127A                 mov     eax, dword ptr [ebp+arg_4+4]
.text:0000127D                 adc     eax, [ecx+0Ch]
.text:00001280                 mov     dword ptr [ebp+arg_4], edx
.text:00001283                 mov     dword ptr [ebp+arg_4+4], eax
.text:00001286                 jmp     short loc_12A6
.text:00001288 ; ---------------------------------------------------------------------------
.text:00001288
.text:00001288 loc_1288:                               ; CODE XREF: CTailOutStream::Seek(__int64,uint,unsigned __int64 *)+2Bj
.text:00001288                 mov     ecx, [ebp+this]
.text:0000128B                 mov     edx, dword ptr [ebp+arg_4]
.text:0000128E                 add     edx, [ecx+10h]
.text:00001291                 mov     eax, dword ptr [ebp+arg_4+4]
.text:00001294                 adc     eax, [ecx+14h]
.text:00001297                 mov     dword ptr [ebp+arg_4], edx
.text:0000129A                 mov     dword ptr [ebp+arg_4+4], eax
.text:0000129D                 jmp     short loc_12A6
.text:0000129F ; ---------------------------------------------------------------------------
.text:0000129F
.text:0000129F loc_129F:                               ; CODE XREF: CTailOutStream::Seek(__int64,uint,unsigned __int64 *)+2Dj
.text:0000129F                 mov     eax, 80030001h
.text:000012A4                 jmp     short loc_131E
.text:000012A6 ; ---------------------------------------------------------------------------
.text:000012A6
.text:000012A6 loc_12A6:                               ; CODE XREF: CTailOutStream::Seek(__int64,uint,unsigned __int64 *):loc_126Fj
.text:000012A6                                         ; CTailOutStream::Seek(__int64,uint,unsigned __int64 *)+46j ...
.text:000012A6                 cmp     dword ptr [ebp+arg_4+4], 0
.text:000012AA                 jg      short loc_12BB
.text:000012AC                 jl      short loc_12B4
.text:000012AE                 cmp     dword ptr [ebp+arg_4], 0
.text:000012B2                 jnb     short loc_12BB
.text:000012B4
.text:000012B4 loc_12B4:                               ; CODE XREF: CTailOutStream::Seek(__int64,uint,unsigned __int64 *)+6Cj
.text:000012B4                 mov     eax, 80070083h
.text:000012B9                 jmp     short loc_131E
.text:000012BB ; ---------------------------------------------------------------------------
.text:000012BB
.text:000012BB loc_12BB:                               ; CODE XREF: CTailOutStream::Seek(__int64,uint,unsigned __int64 *)+6Aj
.text:000012BB                                         ; CTailOutStream::Seek(__int64,uint,unsigned __int64 *)+72j
.text:000012BB                 mov     ecx, [ebp+this]
.text:000012BE                 mov     edx, dword ptr [ebp+arg_4]
.text:000012C1                 mov     [ecx+8], edx
.text:000012C4                 mov     eax, dword ptr [ebp+arg_4+4]
.text:000012C7                 mov     [ecx+0Ch], eax
.text:000012CA                 cmp     [ebp+arg_10], 0
.text:000012CE                 jz      short loc_12E1
.text:000012D0                 mov     ecx, [ebp+arg_10]
.text:000012D3                 mov     edx, [ebp+this]
.text:000012D6                 mov     eax, [edx+8]
.text:000012D9                 mov     [ecx], eax
.text:000012DB                 mov     edx, [edx+0Ch]
.text:000012DE                 mov     [ecx+4], edx
.text:000012E1
.text:000012E1 loc_12E1:                               ; CODE XREF: CTailOutStream::Seek(__int64,uint,unsigned __int64 *)+8Ej
.text:000012E1                 mov     ecx, [ebp+this]
.text:000012E4                 add     ecx, 18h
.text:000012E7                 call    ??C?$CMyComPtr@UIOutStream@@@@QBEPAUIOutStream@@XZ ; CMyComPtr<IOutStream>::operator->(void)
.text:000012EC                 mov     [ebp+var_8], eax
.text:000012EF                 mov     esi, esp
.text:000012F1                 push    0
.text:000012F3                 push    0
.text:000012F5                 mov     eax, [ebp+this]
.text:000012F8                 mov     ecx, [ebp+this]
.text:000012FB                 mov     edx, [eax+20h]
.text:000012FE                 add     edx, [ecx+8]
.text:00001301                 mov     eax, [eax+24h]
.text:00001304                 adc     eax, [ecx+0Ch]
.text:00001307                 push    eax
.text:00001308                 push    edx
.text:00001309                 mov     ecx, [ebp+var_8]
.text:0000130C                 push    ecx
.text:0000130D                 mov     edx, [ebp+var_8]
.text:00001310                 mov     eax, [edx]
.text:00001312                 mov     ecx, [eax+10h]
.text:00001315                 call    ecx
.text:00001317                 cmp     esi, esp
.text:00001319                 call    __RTC_CheckEsp
.text:0000131E
.text:0000131E loc_131E:                               ; CODE XREF: CTailOutStream::Seek(__int64,uint,unsigned __int64 *)+64j
.text:0000131E                                         ; CTailOutStream::Seek(__int64,uint,unsigned __int64 *)+79j
.text:0000131E                 pop     esi
.text:0000131F                 add     esp, 8
.text:00001322                 cmp     ebp, esp
.text:00001324                 call    __RTC_CheckEsp
.text:00001329                 mov     esp, ebp
.text:0000132B                 pop     ebp
.text:0000132C                 retn    14h
.text:0000132C ?Seek@CTailOutStream@@UAGJ_JIPA_K@Z endp
.text:0000132C
.text:0000132C ; ---------------------------------------------------------------------------
.text:0000132F                 align 10h
.text:00001330
.text:00001330 ; =============== S U B R O U T I N E =======================================
.text:00001330
.text:00001330 ; Attributes: bp-based frame
.text:00001330
.text:00001330 ; __int32 __stdcall CTailOutStream::SetSize(CTailOutStream *this, unsigned __int64)
.text:00001330                 public ?SetSize@CTailOutStream@@UAGJ_K@Z
.text:00001330 ?SetSize@CTailOutStream@@UAGJ_K@Z proc near
.text:00001330
.text:00001330 var_4           = dword ptr -4
.text:00001330 this            = dword ptr  8
.text:00001330 arg_4           = qword ptr  0Ch
.text:00001330
.text:00001330                 push    ebp
.text:00001331                 mov     ebp, esp
.text:00001333                 push    ecx
.text:00001334                 push    esi
.text:00001335                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000133C                 mov     eax, [ebp+this]
.text:0000133F                 mov     ecx, dword ptr [ebp+arg_4]
.text:00001342                 mov     [eax+10h], ecx
.text:00001345                 mov     edx, dword ptr [ebp+arg_4+4]
.text:00001348                 mov     [eax+14h], edx
.text:0000134B                 mov     ecx, [ebp+this]
.text:0000134E                 add     ecx, 18h
.text:00001351                 call    ??C?$CMyComPtr@UIOutStream@@@@QBEPAUIOutStream@@XZ ; CMyComPtr<IOutStream>::operator->(void)
.text:00001356                 mov     [ebp+var_4], eax
.text:00001359                 mov     eax, [ebp+this]
.text:0000135C                 mov     ecx, [eax+20h]
.text:0000135F                 add     ecx, dword ptr [ebp+arg_4]
.text:00001362                 mov     edx, [eax+24h]
.text:00001365                 adc     edx, dword ptr [ebp+arg_4+4]
.text:00001368                 mov     esi, esp
.text:0000136A                 push    edx
.text:0000136B                 push    ecx
.text:0000136C                 mov     eax, [ebp+var_4]
.text:0000136F                 push    eax
.text:00001370                 mov     ecx, [ebp+var_4]
.text:00001373                 mov     edx, [ecx]
.text:00001375                 mov     eax, [edx+14h]
.text:00001378                 call    eax
.text:0000137A                 cmp     esi, esp
.text:0000137C                 call    __RTC_CheckEsp
.text:00001381                 pop     esi
.text:00001382                 add     esp, 4
.text:00001385                 cmp     ebp, esp
.text:00001387                 call    __RTC_CheckEsp
.text:0000138C                 mov     esp, ebp
.text:0000138E                 pop     ebp
.text:0000138F                 retn    0Ch
.text:0000138F ?SetSize@CTailOutStream@@UAGJ_K@Z endp
.text:0000138F
.text:0000138F ; ---------------------------------------------------------------------------
.text:00001392                 align 4
.text:00001392 _text           ends
.text:00001392
.rtc$TMZ:00001394 ; ===========================================================================
.rtc$TMZ:00001394
.rtc$TMZ:00001394 ; Segment type: Pure data
.rtc$TMZ:00001394 ; Segment permissions: Read
.rtc$TMZ:00001394 _rtc$TMZ        segment dword public 'DATA' use32
.rtc$TMZ:00001394                 assume cs:_rtc$TMZ
.rtc$TMZ:00001394                 ;org 1394h
.rtc$TMZ:00001394 ; COMDAT (pick any)
.rtc$TMZ:00001394 __RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
.rtc$TMZ:00001394 _rtc$TMZ        ends
.rtc$TMZ:00001394
.rtc$IMZ:00001398 ; ===========================================================================
.rtc$IMZ:00001398
.rtc$IMZ:00001398 ; Segment type: Pure data
.rtc$IMZ:00001398 ; Segment permissions: Read
.rtc$IMZ:00001398 _rtc$IMZ        segment dword public 'DATA' use32
.rtc$IMZ:00001398                 assume cs:_rtc$IMZ
.rtc$IMZ:00001398                 ;org 1398h
.rtc$IMZ:00001398 ; COMDAT (pick any)
.rtc$IMZ:00001398 __RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
.rtc$IMZ:00001398 _rtc$IMZ        ends
.rtc$IMZ:00001398
.text:0000139C ; ===========================================================================
.text:0000139C
.text:0000139C ; Segment type: Pure code
.text:0000139C ; Segment permissions: Read/Execute
.text:0000139C _text           segment para public 'CODE' use32
.text:0000139C                 assume cs:_text
.text:0000139C                 ;org 139Ch
.text:0000139C ; COMDAT (pick any)
.text:0000139C                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:0000139C
.text:0000139C ; =============== S U B R O U T I N E =======================================
.text:0000139C
.text:0000139C ; Attributes: bp-based frame
.text:0000139C
.text:0000139C ; __int32 __thiscall CLimitedInStream::SeekToPhys(CLimitedInStream *__hidden this)
.text:0000139C                 public ?SeekToPhys@CLimitedInStream@@AAEJXZ
.text:0000139C ?SeekToPhys@CLimitedInStream@@AAEJXZ proc near
.text:0000139C                                         ; CODE XREF: CLimitedInStream::Read(void *,uint,uint *)+D8p
.text:0000139C                                         ; CLimitedInStream::InitAndSeek(unsigned __int64,unsigned __int64)+4Fp
.text:0000139C
.text:0000139C var_8           = dword ptr -8
.text:0000139C var_4           = dword ptr -4
.text:0000139C
.text:0000139C                 push    ebp
.text:0000139D                 mov     ebp, esp
.text:0000139F                 sub     esp, 8
.text:000013A2                 push    esi
.text:000013A3                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000013AA                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000013B1                 mov     [ebp+var_4], ecx
.text:000013B4                 mov     ecx, [ebp+var_4]
.text:000013B7                 add     ecx, 8
.text:000013BA                 call    ??C?$CMyComPtr@UIInStream@@@@QBEPAUIInStream@@XZ ; CMyComPtr<IInStream>::operator->(void)
.text:000013BF                 mov     [ebp+var_8], eax
.text:000013C2                 mov     esi, esp
.text:000013C4                 push    0
.text:000013C6                 push    0
.text:000013C8                 mov     eax, [ebp+var_4]
.text:000013CB                 mov     ecx, [eax+1Ch]
.text:000013CE                 push    ecx
.text:000013CF                 mov     edx, [eax+18h]
.text:000013D2                 push    edx
.text:000013D3                 mov     eax, [ebp+var_8]
.text:000013D6                 push    eax
.text:000013D7                 mov     ecx, [ebp+var_8]
.text:000013DA                 mov     edx, [ecx]
.text:000013DC                 mov     eax, [edx+10h]
.text:000013DF                 call    eax
.text:000013E1                 cmp     esi, esp
.text:000013E3                 call    __RTC_CheckEsp
.text:000013E8                 pop     esi
.text:000013E9                 add     esp, 8
.text:000013EC                 cmp     ebp, esp
.text:000013EE                 call    __RTC_CheckEsp
.text:000013F3                 mov     esp, ebp
.text:000013F5                 pop     ebp
.text:000013F6                 retn
.text:000013F6 ?SeekToPhys@CLimitedInStream@@AAEJXZ endp
.text:000013F6
.text:000013F6 ; ---------------------------------------------------------------------------
.text:000013F7                 align 4
.text:000013F7 _text           ends
.text:000013F7
.text$x:000013F8 ; ===========================================================================
.text$x:000013F8
.text$x:000013F8 ; Segment type: Pure code
.text$x:000013F8 ; Segment permissions: Read/Execute
.text$x:000013F8 _text$x         segment para public 'CODE' use32
.text$x:000013F8                 assume cs:_text$x
.text$x:000013F8                 ;org 13F8h
.text$x:000013F8                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text$x:000013F8
.text$x:000013F8 ; =============== S U B R O U T I N E =======================================
.text$x:000013F8
.text$x:000013F8
.text$x:000013F8 __unwindfunclet$?CreateLimitedInStream@@YGJPAUIInStream@@_K1PAPAUISequentialInStream@@@Z$0 proc near
.text$x:000013F8                                         ; DATA XREF: .xdata$x:0000142Co
.text$x:000013F8                 mov     eax, [ebp-28h]
.text$x:000013FB                 push    eax             ; void *
.text$x:000013FC                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00001401                 pop     ecx
.text$x:00001402                 retn
.text$x:00001402 __unwindfunclet$?CreateLimitedInStream@@YGJPAUIInStream@@_K1PAPAUISequentialInStream@@@Z$0 endp
.text$x:00001402
.text$x:00001403
.text$x:00001403 ; =============== S U B R O U T I N E =======================================
.text$x:00001403
.text$x:00001403
.text$x:00001403 __unwindfunclet$?CreateLimitedInStream@@YGJPAUIInStream@@_K1PAPAUISequentialInStream@@@Z$1 proc near
.text$x:00001403                                         ; DATA XREF: .xdata$x:00001434o
.text$x:00001403                 lea     ecx, [ebp-18h]
.text$x:00001406                 jmp     ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text$x:00001406 __unwindfunclet$?CreateLimitedInStream@@YGJPAUIInStream@@_K1PAPAUISequentialInStream@@@Z$1 endp
.text$x:00001406
.text$x:0000140B
.text$x:0000140B ; =============== S U B R O U T I N E =======================================
.text$x:0000140B
.text$x:0000140B
.text$x:0000140B __ehhandler$?CreateLimitedInStream@@YGJPAUIInStream@@_K1PAPAUISequentialInStream@@@Z proc near
.text$x:0000140B                                         ; DATA XREF: CreateLimitedInStream(IInStream *,unsigned __int64,unsigned __int64,ISequentialInStream * *)+5o
.text$x:0000140B
.text$x:0000140B arg_4           = dword ptr  8
.text$x:0000140B
.text$x:0000140B                 mov     edx, [esp+arg_4]
.text$x:0000140F                 lea     eax, [edx+0Ch]
.text$x:00001412                 mov     ecx, [edx-30h]
.text$x:00001415                 xor     ecx, eax
.text$x:00001417                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000141C                 mov     eax, offset __ehfuncinfo$?CreateLimitedInStream@@YGJPAUIInStream@@_K1PAPAUISequentialInStream@@@Z
.text$x:00001421                 jmp     ___CxxFrameHandler3
.text$x:00001421 __ehhandler$?CreateLimitedInStream@@YGJPAUIInStream@@_K1PAPAUISequentialInStream@@@Z endp
.text$x:00001421
.text$x:00001421 ; ---------------------------------------------------------------------------
.text$x:00001426                 align 4
.text$x:00001426 _text$x         ends
.text$x:00001426
.xdata$x:00001428 ; ===========================================================================
.xdata$x:00001428
.xdata$x:00001428 ; Segment type: Pure data
.xdata$x:00001428 ; Segment permissions: Read
.xdata$x:00001428 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001428                 assume cs:_xdata$x
.xdata$x:00001428                 ;org 1428h
.xdata$x:00001428 __unwindtable$?CreateLimitedInStream@@YGJPAUIInStream@@_K1PAPAUISequentialInStream@@@Z db 0FFh
.xdata$x:00001428                                         ; DATA XREF: .xdata$x:00001440o
.xdata$x:00001429                 db 0FFh
.xdata$x:0000142A                 db 0FFh
.xdata$x:0000142B                 db 0FFh
.xdata$x:0000142C                 dd offset __unwindfunclet$?CreateLimitedInStream@@YGJPAUIInStream@@_K1PAPAUISequentialInStream@@@Z$0
.xdata$x:00001430                 db 0FFh
.xdata$x:00001431                 db 0FFh
.xdata$x:00001432                 db 0FFh
.xdata$x:00001433                 db 0FFh
.xdata$x:00001434                 dd offset __unwindfunclet$?CreateLimitedInStream@@YGJPAUIInStream@@_K1PAPAUISequentialInStream@@@Z$1
.xdata$x:00001438 __ehfuncinfo$?CreateLimitedInStream@@YGJPAUIInStream@@_K1PAPAUISequentialInStream@@@Z db  22h ; "
.xdata$x:00001438                                         ; DATA XREF: __ehhandler$?CreateLimitedInStream@@YGJPAUIInStream@@_K1PAPAUISequentialInStream@@@Z+11o
.xdata$x:00001439                 db    5
.xdata$x:0000143A                 db  93h ; 
.xdata$x:0000143B                 db  19h
.xdata$x:0000143C                 db    2
.xdata$x:0000143D                 db    0
.xdata$x:0000143E                 db    0
.xdata$x:0000143F                 db    0
.xdata$x:00001440                 dd offset __unwindtable$?CreateLimitedInStream@@YGJPAUIInStream@@_K1PAPAUISequentialInStream@@@Z
.xdata$x:00001444                 db    0
.xdata$x:00001445                 db    0
.xdata$x:00001446                 db    0
.xdata$x:00001447                 db    0
.xdata$x:00001448                 db    0
.xdata$x:00001449                 db    0
.xdata$x:0000144A                 db    0
.xdata$x:0000144B                 db    0
.xdata$x:0000144C                 db    0
.xdata$x:0000144D                 db    0
.xdata$x:0000144E                 db    0
.xdata$x:0000144F                 db    0
.xdata$x:00001450                 db    0
.xdata$x:00001451                 db    0
.xdata$x:00001452                 db    0
.xdata$x:00001453                 db    0
.xdata$x:00001454                 db    0
.xdata$x:00001455                 db    0
.xdata$x:00001456                 db    0
.xdata$x:00001457                 db    0
.xdata$x:00001458                 db    1
.xdata$x:00001459                 db    0
.xdata$x:0000145A                 db    0
.xdata$x:0000145B                 db    0
.xdata$x:0000145B _xdata$x        ends
.xdata$x:0000145B
.text:0000145C ; ===========================================================================
.text:0000145C
.text:0000145C ; Segment type: Pure code
.text:0000145C ; Segment permissions: Read/Execute
.text:0000145C _text           segment para public 'CODE' use32
.text:0000145C                 assume cs:_text
.text:0000145C                 ;org 145Ch
.text:0000145C ; COMDAT (pick any)
.text:0000145C                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:0000145C
.text:0000145C ; =============== S U B R O U T I N E =======================================
.text:0000145C
.text:0000145C ; Attributes: bp-based frame
.text:0000145C
.text:0000145C ; void __thiscall CLimitedInStream::SetStream(CLimitedInStream *this, struct IInStream *)
.text:0000145C                 public ?SetStream@CLimitedInStream@@QAEXPAUIInStream@@@Z
.text:0000145C ?SetStream@CLimitedInStream@@QAEXPAUIInStream@@@Z proc near
.text:0000145C                                         ; CODE XREF: CreateLimitedInStream(IInStream *,unsigned __int64,unsigned __int64,ISequentialInStream * *)+99p
.text:0000145C
.text:0000145C var_4           = dword ptr -4
.text:0000145C arg_0           = dword ptr  8
.text:0000145C
.text:0000145C                 push    ebp
.text:0000145D                 mov     ebp, esp
.text:0000145F                 push    ecx
.text:00001460                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001467                 mov     [ebp+var_4], ecx
.text:0000146A                 mov     eax, [ebp+arg_0]
.text:0000146D                 push    eax
.text:0000146E                 mov     ecx, [ebp+var_4]
.text:00001471                 add     ecx, 8
.text:00001474                 call    ??4?$CMyComPtr@UIInStream@@@@QAEPAUIInStream@@PAU1@@Z ; CMyComPtr<IInStream>::operator=(IInStream *)
.text:00001479                 add     esp, 4
.text:0000147C                 cmp     ebp, esp
.text:0000147E                 call    __RTC_CheckEsp
.text:00001483                 mov     esp, ebp
.text:00001485                 pop     ebp
.text:00001486                 retn    4
.text:00001486 ?SetStream@CLimitedInStream@@QAEXPAUIInStream@@@Z endp
.text:00001486
.text:00001486 ; ---------------------------------------------------------------------------
.text:00001489                 align 4
.text:00001489 _text           ends
.text:00001489
.text:0000148C ; ===========================================================================
.text:0000148C
.text:0000148C ; Segment type: Pure code
.text:0000148C ; Segment permissions: Read/Execute
.text:0000148C _text           segment para public 'CODE' use32
.text:0000148C                 assume cs:_text
.text:0000148C                 ;org 148Ch
.text:0000148C ; COMDAT (pick any)
.text:0000148C                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:0000148C
.text:0000148C ; =============== S U B R O U T I N E =======================================
.text:0000148C
.text:0000148C ; Attributes: bp-based frame
.text:0000148C
.text:0000148C ; __int32 __thiscall CLimitedInStream::InitAndSeek(CLimitedInStream *this, unsigned __int64, unsigned __int64)
.text:0000148C                 public ?InitAndSeek@CLimitedInStream@@QAEJ_K0@Z
.text:0000148C ?InitAndSeek@CLimitedInStream@@QAEJ_K0@Z proc near
.text:0000148C                                         ; CODE XREF: CreateLimitedInStream(IInStream *,unsigned __int64,unsigned __int64,ISequentialInStream * *)+B1p
.text:0000148C
.text:0000148C var_4           = dword ptr -4
.text:0000148C arg_0           = qword ptr  8
.text:0000148C arg_8           = qword ptr  10h
.text:0000148C
.text:0000148C                 push    ebp
.text:0000148D                 mov     ebp, esp
.text:0000148F                 push    ecx
.text:00001490                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001497                 mov     [ebp+var_4], ecx
.text:0000149A                 mov     eax, [ebp+var_4]
.text:0000149D                 mov     ecx, dword ptr [ebp+arg_0]
.text:000014A0                 mov     [eax+28h], ecx
.text:000014A3                 mov     edx, dword ptr [ebp+arg_0+4]
.text:000014A6                 mov     [eax+2Ch], edx
.text:000014A9                 mov     eax, [ebp+var_4]
.text:000014AC                 mov     ecx, dword ptr [ebp+arg_0]
.text:000014AF                 mov     [eax+18h], ecx
.text:000014B2                 mov     edx, dword ptr [ebp+arg_0+4]
.text:000014B5                 mov     [eax+1Ch], edx
.text:000014B8                 mov     eax, [ebp+var_4]
.text:000014BB                 mov     dword ptr [eax+10h], 0
.text:000014C2                 mov     dword ptr [eax+14h], 0
.text:000014C9                 mov     ecx, [ebp+var_4]
.text:000014CC                 mov     edx, dword ptr [ebp+arg_8]
.text:000014CF                 mov     [ecx+20h], edx
.text:000014D2                 mov     eax, dword ptr [ebp+arg_8+4]
.text:000014D5                 mov     [ecx+24h], eax
.text:000014D8                 mov     ecx, [ebp+var_4] ; this
.text:000014DB                 call    ?SeekToPhys@CLimitedInStream@@AAEJXZ ; CLimitedInStream::SeekToPhys(void)
.text:000014E0                 add     esp, 4
.text:000014E3                 cmp     ebp, esp
.text:000014E5                 call    __RTC_CheckEsp
.text:000014EA                 mov     esp, ebp
.text:000014EC                 pop     ebp
.text:000014ED                 retn    10h
.text:000014ED ?InitAndSeek@CLimitedInStream@@QAEJ_K0@Z endp
.text:000014ED
.text:000014ED _text           ends
.text:000014ED
.text:000014F0 ; ===========================================================================
.text:000014F0
.text:000014F0 ; Segment type: Pure code
.text:000014F0 ; Segment permissions: Read/Execute
.text:000014F0 _text           segment para public 'CODE' use32
.text:000014F0                 assume cs:_text
.text:000014F0                 ;org 14F0h
.text:000014F0 ; COMDAT (pick any)
.text:000014F0                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000014F0
.text:000014F0 ; =============== S U B R O U T I N E =======================================
.text:000014F0
.text:000014F0 ; Attributes: bp-based frame
.text:000014F0
.text:000014F0 ; __int32 __thiscall CLimitedInStream::SeekToStart(CLimitedInStream *__hidden this)
.text:000014F0                 public ?SeekToStart@CLimitedInStream@@QAEJXZ
.text:000014F0 ?SeekToStart@CLimitedInStream@@QAEJXZ proc near
.text:000014F0                                         ; CODE XREF: CreateLimitedInStream(IInStream *,unsigned __int64,unsigned __int64,ISequentialInStream * *)+DCp
.text:000014F0
.text:000014F0 var_4           = dword ptr -4
.text:000014F0
.text:000014F0                 push    ebp
.text:000014F1                 mov     ebp, esp
.text:000014F3                 push    ecx
.text:000014F4                 push    esi
.text:000014F5                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000014FC                 mov     [ebp+var_4], ecx
.text:000014FF                 mov     esi, esp
.text:00001501                 push    0
.text:00001503                 push    0
.text:00001505                 push    0
.text:00001507                 push    0
.text:00001509                 mov     eax, [ebp+var_4]
.text:0000150C                 mov     ecx, [eax]
.text:0000150E                 mov     edx, [ebp+var_4]
.text:00001511                 push    edx
.text:00001512                 mov     eax, [ecx+10h]
.text:00001515                 call    eax
.text:00001517                 cmp     esi, esp
.text:00001519                 call    __RTC_CheckEsp
.text:0000151E                 pop     esi
.text:0000151F                 add     esp, 4
.text:00001522                 cmp     ebp, esp
.text:00001524                 call    __RTC_CheckEsp
.text:00001529                 mov     esp, ebp
.text:0000152B                 pop     ebp
.text:0000152C                 retn
.text:0000152C ?SeekToStart@CLimitedInStream@@QAEJXZ endp
.text:0000152C
.text:0000152C ; ---------------------------------------------------------------------------
.text:0000152D                 align 10h
.text:0000152D _text           ends
.text:0000152D
.text:00001530 ; ===========================================================================
.text:00001530
.text:00001530 ; Segment type: Pure code
.text:00001530 ; Segment permissions: Read/Execute
.text:00001530 _text           segment para public 'CODE' use32
.text:00001530                 assume cs:_text
.text:00001530                 ;org 1530h
.text:00001530 ; COMDAT (pick any)
.text:00001530                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001530
.text:00001530 ; =============== S U B R O U T I N E =======================================
.text:00001530
.text:00001530 ; Attributes: bp-based frame
.text:00001530
.text:00001530 ; public: __thiscall CLimitedInStream::CLimitedInStream(void)
.text:00001530                 public ??0CLimitedInStream@@QAE@XZ
.text:00001530 ??0CLimitedInStream@@QAE@XZ proc near   ; CODE XREF: CreateLimitedInStream(IInStream *,unsigned __int64,unsigned __int64,ISequentialInStream * *)+5Bp
.text:00001530
.text:00001530 var_4           = dword ptr -4
.text:00001530
.text:00001530                 push    ebp
.text:00001531                 mov     ebp, esp
.text:00001533                 push    ecx
.text:00001534                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000153B                 mov     [ebp+var_4], ecx
.text:0000153E                 mov     ecx, [ebp+var_4] ; this
.text:00001541                 call    ??0IInStream@@QAE@XZ ; IInStream::IInStream(void)
.text:00001546                 mov     ecx, [ebp+var_4]
.text:00001549                 add     ecx, 4          ; this
.text:0000154C                 call    ??0CMyUnknownImp@@QAE@XZ ; CMyUnknownImp::CMyUnknownImp(void)
.text:00001551                 mov     eax, [ebp+var_4]
.text:00001554                 mov     dword ptr [eax], offset ??_7CLimitedInStream@@6B@ ; const CLimitedInStream::`vftable'
.text:0000155A                 mov     ecx, [ebp+var_4]
.text:0000155D                 add     ecx, 8
.text:00001560                 call    ??0?$CMyComPtr@UIInStream@@@@QAE@XZ ; CMyComPtr<IInStream>::CMyComPtr<IInStream>(void)
.text:00001565                 mov     eax, [ebp+var_4]
.text:00001568                 add     esp, 4
.text:0000156B                 cmp     ebp, esp
.text:0000156D                 call    __RTC_CheckEsp
.text:00001572                 mov     esp, ebp
.text:00001574                 pop     ebp
.text:00001575                 retn
.text:00001575 ??0CLimitedInStream@@QAE@XZ endp
.text:00001575
.text:00001575 ; ---------------------------------------------------------------------------
.text:00001576                 align 4
.text:00001576 _text           ends
.text:00001576
.rdata:00001578 ; ===========================================================================
.rdata:00001578
.rdata:00001578 ; Segment type: Pure data
.rdata:00001578 ; Segment permissions: Read
.rdata:00001578 _rdata          segment dword public 'DATA' use32
.rdata:00001578                 assume cs:_rdata
.rdata:00001578                 ;org 1578h
.rdata:00001578 ; COMDAT (pick largest)
.rdata:00001578                 dd offset ??_R4CLimitedInStream@@6B@ ; const CLimitedInStream::`RTTI Complete Object Locator'
.rdata:0000157C                 public ??_7CLimitedInStream@@6B@
.rdata:0000157C ; const CLimitedInStream::`vftable'
.rdata:0000157C ??_7CLimitedInStream@@6B@ dd offset ?QueryInterface@CLimitedInStream@@UAGJABU_GUID@@PAPAX@Z
.rdata:0000157C                                         ; DATA XREF: CLimitedInStream::CLimitedInStream(void)+24o
.rdata:0000157C                                         ; CLimitedInStream::QueryInterface(_GUID const &,void * *)
.rdata:00001580                 dd offset ?AddRef@CLimitedInStream@@UAGKXZ ; CLimitedInStream::AddRef(void)
.rdata:00001584                 dd offset ?Release@CLimitedInStream@@UAGKXZ ; CLimitedInStream::Release(void)
.rdata:00001588                 dd offset ?Read@CLimitedInStream@@UAGJPAXIPAI@Z ; CLimitedInStream::Read(void *,uint,uint *)
.rdata:0000158C                 dd offset ?Seek@CLimitedInStream@@UAGJ_JIPA_K@Z ; CLimitedInStream::Seek(__int64,uint,unsigned __int64 *)
.rdata:0000158C _rdata          ends
.rdata:0000158C
.rdata$r:00001590 ; ===========================================================================
.rdata$r:00001590
.rdata$r:00001590 ; Segment type: Pure data
.rdata$r:00001590 ; Segment permissions: Read
.rdata$r:00001590 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001590                 assume cs:_rdata$r
.rdata$r:00001590                 ;org 1590h
.rdata$r:00001590 ; COMDAT (pick any)
.rdata$r:00001590                 public ??_R4CLimitedInStream@@6B@
.rdata$r:00001590 ; const CLimitedInStream::`RTTI Complete Object Locator'
.rdata$r:00001590 ??_R4CLimitedInStream@@6B@ db    0      ; DATA XREF: .rdata:00001578o
.rdata$r:00001591                 db    0
.rdata$r:00001592                 db    0
.rdata$r:00001593                 db    0
.rdata$r:00001594                 db    0
.rdata$r:00001595                 db    0
.rdata$r:00001596                 db    0
.rdata$r:00001597                 db    0
.rdata$r:00001598                 db    0
.rdata$r:00001599                 db    0
.rdata$r:0000159A                 db    0
.rdata$r:0000159B                 db    0
.rdata$r:0000159C                 dd offset ??_R0?AVCLimitedInStream@@@8 ; CLimitedInStream `RTTI Type Descriptor'
.rdata$r:000015A0                 dd offset ??_R3CLimitedInStream@@8 ; CLimitedInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:000015A0 _rdata$r        ends
.rdata$r:000015A0
.data:000015A4 ; ===========================================================================
.data:000015A4
.data:000015A4 ; Segment type: Pure data
.data:000015A4 ; Segment permissions: Read/Write
.data:000015A4 _data           segment dword public 'DATA' use32
.data:000015A4                 assume cs:_data
.data:000015A4                 ;org 15A4h
.data:000015A4 ; COMDAT (pick any)
.data:000015A4                 public ??_R0?AVCLimitedInStream@@@8
.data:000015A4 ; class CLimitedInStream `RTTI Type Descriptor'
.data:000015A4 ??_R0?AVCLimitedInStream@@@8 dd offset ??_7type_info@@6B@
.data:000015A4                                         ; DATA XREF: .rdata$r:0000159Co
.data:000015A4                                         ; .rdata$r:CLimitedInStream::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:000015A4                                         ; const type_info::`vftable'
.data:000015A8                 db    0
.data:000015A9                 db    0
.data:000015AA                 db    0
.data:000015AB                 db    0
.data:000015AC                 db  2Eh ; .
.data:000015AD                 db  3Fh ; ?
.data:000015AE                 db  41h ; A
.data:000015AF                 db  56h ; V
.data:000015B0                 db  43h ; C
.data:000015B1                 db  4Ch ; L
.data:000015B2                 db  69h ; i
.data:000015B3                 db  6Dh ; m
.data:000015B4                 db  69h ; i
.data:000015B5                 db  74h ; t
.data:000015B6                 db  65h ; e
.data:000015B7                 db  64h ; d
.data:000015B8                 db  49h ; I
.data:000015B9                 db  6Eh ; n
.data:000015BA                 db  53h ; S
.data:000015BB                 db  74h ; t
.data:000015BC                 db  72h ; r
.data:000015BD                 db  65h ; e
.data:000015BE                 db  61h ; a
.data:000015BF                 db  6Dh ; m
.data:000015C0                 db  40h ; @
.data:000015C1                 db  40h ; @
.data:000015C2                 db    0
.data:000015C3                 align 4
.data:000015C3 _data           ends
.data:000015C3
.rdata$r:000015C4 ; ===========================================================================
.rdata$r:000015C4
.rdata$r:000015C4 ; Segment type: Pure data
.rdata$r:000015C4 ; Segment permissions: Read
.rdata$r:000015C4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000015C4                 assume cs:_rdata$r
.rdata$r:000015C4                 ;org 15C4h
.rdata$r:000015C4 ; COMDAT (pick any)
.rdata$r:000015C4                 public ??_R3CLimitedInStream@@8
.rdata$r:000015C4 ; CLimitedInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:000015C4 ??_R3CLimitedInStream@@8 db    0        ; DATA XREF: .rdata$r:000015A0o
.rdata$r:000015C4                                         ; .rdata$r:00001604o
.rdata$r:000015C5                 db    0
.rdata$r:000015C6                 db    0
.rdata$r:000015C7                 db    0
.rdata$r:000015C8                 db    1
.rdata$r:000015C9                 db    0
.rdata$r:000015CA                 db    0
.rdata$r:000015CB                 db    0
.rdata$r:000015CC                 db    5
.rdata$r:000015CD                 db    0
.rdata$r:000015CE                 db    0
.rdata$r:000015CF                 db    0
.rdata$r:000015D0                 dd offset ??_R2CLimitedInStream@@8 ; CLimitedInStream::`RTTI Base Class Array'
.rdata$r:000015D0 _rdata$r        ends
.rdata$r:000015D0
.rdata$r:000015D4 ; ===========================================================================
.rdata$r:000015D4
.rdata$r:000015D4 ; Segment type: Pure data
.rdata$r:000015D4 ; Segment permissions: Read
.rdata$r:000015D4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000015D4                 assume cs:_rdata$r
.rdata$r:000015D4                 ;org 15D4h
.rdata$r:000015D4 ; COMDAT (pick any)
.rdata$r:000015D4                 public ??_R2CLimitedInStream@@8
.rdata$r:000015D4 ; CLimitedInStream::`RTTI Base Class Array'
.rdata$r:000015D4 ??_R2CLimitedInStream@@8 dd offset ??_R1A@?0A@EA@CLimitedInStream@@8
.rdata$r:000015D4                                         ; DATA XREF: .rdata$r:000015D0o
.rdata$r:000015D4                                         ; CLimitedInStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000015D8                 dd offset ??_R1A@?0A@EA@IInStream@@8 ; IInStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000015DC                 dd offset ??_R1A@?0A@EA@ISequentialInStream@@8 ; ISequentialInStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000015E0                 dd offset ??_R1A@?0A@EA@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000015E4                 dd offset ??_R13?0A@EA@CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Base Class Descriptor at (4,-1,0,64)'
.rdata$r:000015E8                 db    0
.rdata$r:000015E9                 align 4
.rdata$r:000015E9 _rdata$r        ends
.rdata$r:000015E9
.rdata$r:000015EC ; ===========================================================================
.rdata$r:000015EC
.rdata$r:000015EC ; Segment type: Pure data
.rdata$r:000015EC ; Segment permissions: Read
.rdata$r:000015EC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000015EC                 assume cs:_rdata$r
.rdata$r:000015EC                 ;org 15ECh
.rdata$r:000015EC ; COMDAT (pick any)
.rdata$r:000015EC                 public ??_R1A@?0A@EA@CLimitedInStream@@8
.rdata$r:000015EC ; CLimitedInStream::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000015EC ??_R1A@?0A@EA@CLimitedInStream@@8 dd offset ??_R0?AVCLimitedInStream@@@8
.rdata$r:000015EC                                         ; DATA XREF: .rdata$r:CLimitedInStream::`RTTI Base Class Array'o
.rdata$r:000015EC                                         ; CLimitedInStream `RTTI Type Descriptor'
.rdata$r:000015F0                 db    4
.rdata$r:000015F1                 db    0
.rdata$r:000015F2                 db    0
.rdata$r:000015F3                 db    0
.rdata$r:000015F4                 db    0
.rdata$r:000015F5                 db    0
.rdata$r:000015F6                 db    0
.rdata$r:000015F7                 db    0
.rdata$r:000015F8                 db 0FFh
.rdata$r:000015F9                 db 0FFh
.rdata$r:000015FA                 db 0FFh
.rdata$r:000015FB                 db 0FFh
.rdata$r:000015FC                 db    0
.rdata$r:000015FD                 db    0
.rdata$r:000015FE                 db    0
.rdata$r:000015FF                 db    0
.rdata$r:00001600                 db  40h ; @
.rdata$r:00001601                 db    0
.rdata$r:00001602                 db    0
.rdata$r:00001603                 db    0
.rdata$r:00001604                 dd offset ??_R3CLimitedInStream@@8 ; CLimitedInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00001604 _rdata$r        ends
.rdata$r:00001604
.rdata$r:00001608 ; ===========================================================================
.rdata$r:00001608
.rdata$r:00001608 ; Segment type: Pure data
.rdata$r:00001608 ; Segment permissions: Read
.rdata$r:00001608 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001608                 assume cs:_rdata$r
.rdata$r:00001608                 ;org 1608h
.rdata$r:00001608 ; COMDAT (pick any)
.rdata$r:00001608                 public ??_R1A@?0A@EA@IInStream@@8
.rdata$r:00001608 ; IInStream::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00001608 ??_R1A@?0A@EA@IInStream@@8 dd offset ??_R0?AUIInStream@@@8
.rdata$r:00001608                                         ; DATA XREF: .rdata$r:000015D8o
.rdata$r:00001608                                         ; .rdata$r:IInStream::`RTTI Base Class Array'o
.rdata$r:00001608                                         ; IInStream `RTTI Type Descriptor'
.rdata$r:0000160C                 db    2
.rdata$r:0000160D                 db    0
.rdata$r:0000160E                 db    0
.rdata$r:0000160F                 db    0
.rdata$r:00001610                 db    0
.rdata$r:00001611                 db    0
.rdata$r:00001612                 db    0
.rdata$r:00001613                 db    0
.rdata$r:00001614                 db 0FFh
.rdata$r:00001615                 db 0FFh
.rdata$r:00001616                 db 0FFh
.rdata$r:00001617                 db 0FFh
.rdata$r:00001618                 db    0
.rdata$r:00001619                 db    0
.rdata$r:0000161A                 db    0
.rdata$r:0000161B                 db    0
.rdata$r:0000161C                 db  40h ; @
.rdata$r:0000161D                 db    0
.rdata$r:0000161E                 db    0
.rdata$r:0000161F                 db    0
.rdata$r:00001620                 dd offset ??_R3IInStream@@8 ; IInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00001620 _rdata$r        ends
.rdata$r:00001620
.data:00001624 ; ===========================================================================
.data:00001624
.data:00001624 ; Segment type: Pure data
.data:00001624 ; Segment permissions: Read/Write
.data:00001624 _data           segment dword public 'DATA' use32
.data:00001624                 assume cs:_data
.data:00001624                 ;org 1624h
.data:00001624 ; COMDAT (pick any)
.data:00001624                 public ??_R0?AUIInStream@@@8
.data:00001624 ; struct IInStream `RTTI Type Descriptor'
.data:00001624 ??_R0?AUIInStream@@@8 dd offset ??_7type_info@@6B@
.data:00001624                                         ; DATA XREF: .rdata$r:IInStream::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:00001624                                         ; .rdata$r:000019B4o
.data:00001624                                         ; const type_info::`vftable'
.data:00001628                 db    0
.data:00001629                 db    0
.data:0000162A                 db    0
.data:0000162B                 db    0
.data:0000162C                 db  2Eh ; .
.data:0000162D                 db  3Fh ; ?
.data:0000162E                 db  41h ; A
.data:0000162F                 db  55h ; U
.data:00001630                 db  49h ; I
.data:00001631                 db  49h ; I
.data:00001632                 db  6Eh ; n
.data:00001633                 db  53h ; S
.data:00001634                 db  74h ; t
.data:00001635                 db  72h ; r
.data:00001636                 db  65h ; e
.data:00001637                 db  61h ; a
.data:00001638                 db  6Dh ; m
.data:00001639                 db  40h ; @
.data:0000163A                 db  40h ; @
.data:0000163B                 db    0
.data:0000163B _data           ends
.data:0000163B
.rdata$r:0000163C ; ===========================================================================
.rdata$r:0000163C
.rdata$r:0000163C ; Segment type: Pure data
.rdata$r:0000163C ; Segment permissions: Read
.rdata$r:0000163C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000163C                 assume cs:_rdata$r
.rdata$r:0000163C                 ;org 163Ch
.rdata$r:0000163C ; COMDAT (pick any)
.rdata$r:0000163C                 public ??_R3IInStream@@8
.rdata$r:0000163C ; IInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000163C ??_R3IInStream@@8 db    0               ; DATA XREF: .rdata$r:00001620o
.rdata$r:0000163C                                         ; .rdata$r:000019B8o
.rdata$r:0000163D                 db    0
.rdata$r:0000163E                 db    0
.rdata$r:0000163F                 db    0
.rdata$r:00001640                 db    0
.rdata$r:00001641                 db    0
.rdata$r:00001642                 db    0
.rdata$r:00001643                 db    0
.rdata$r:00001644                 db    3
.rdata$r:00001645                 db    0
.rdata$r:00001646                 db    0
.rdata$r:00001647                 db    0
.rdata$r:00001648                 dd offset ??_R2IInStream@@8 ; IInStream::`RTTI Base Class Array'
.rdata$r:00001648 _rdata$r        ends
.rdata$r:00001648
.rdata$r:0000164C ; ===========================================================================
.rdata$r:0000164C
.rdata$r:0000164C ; Segment type: Pure data
.rdata$r:0000164C ; Segment permissions: Read
.rdata$r:0000164C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000164C                 assume cs:_rdata$r
.rdata$r:0000164C                 ;org 164Ch
.rdata$r:0000164C ; COMDAT (pick any)
.rdata$r:0000164C                 public ??_R2IInStream@@8
.rdata$r:0000164C ; IInStream::`RTTI Base Class Array'
.rdata$r:0000164C ??_R2IInStream@@8 dd offset ??_R1A@?0A@EA@IInStream@@8
.rdata$r:0000164C                                         ; DATA XREF: .rdata$r:00001648o
.rdata$r:0000164C                                         ; IInStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00001650                 dd offset ??_R1A@?0A@EA@ISequentialInStream@@8 ; ISequentialInStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00001654                 dd offset ??_R1A@?0A@EA@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00001658                 db    0
.rdata$r:00001659                 align 4
.rdata$r:00001659 _rdata$r        ends
.rdata$r:00001659
.rdata$r:0000165C ; ===========================================================================
.rdata$r:0000165C
.rdata$r:0000165C ; Segment type: Pure data
.rdata$r:0000165C ; Segment permissions: Read
.rdata$r:0000165C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000165C                 assume cs:_rdata$r
.rdata$r:0000165C                 ;org 165Ch
.rdata$r:0000165C ; COMDAT (pick any)
.rdata$r:0000165C                 public ??_R1A@?0A@EA@ISequentialInStream@@8
.rdata$r:0000165C ; ISequentialInStream::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000165C ??_R1A@?0A@EA@ISequentialInStream@@8 dd offset ??_R0?AUISequentialInStream@@@8
.rdata$r:0000165C                                         ; DATA XREF: .rdata$r:000015DCo
.rdata$r:0000165C                                         ; .rdata$r:00001650o ...
.rdata$r:0000165C                                         ; ISequentialInStream `RTTI Type Descriptor'
.rdata$r:00001660                 db    1
.rdata$r:00001661                 db    0
.rdata$r:00001662                 db    0
.rdata$r:00001663                 db    0
.rdata$r:00001664                 db    0
.rdata$r:00001665                 db    0
.rdata$r:00001666                 db    0
.rdata$r:00001667                 db    0
.rdata$r:00001668                 db 0FFh
.rdata$r:00001669                 db 0FFh
.rdata$r:0000166A                 db 0FFh
.rdata$r:0000166B                 db 0FFh
.rdata$r:0000166C                 db    0
.rdata$r:0000166D                 db    0
.rdata$r:0000166E                 db    0
.rdata$r:0000166F                 db    0
.rdata$r:00001670                 db  40h ; @
.rdata$r:00001671                 db    0
.rdata$r:00001672                 db    0
.rdata$r:00001673                 db    0
.rdata$r:00001674                 dd offset ??_R3ISequentialInStream@@8 ; ISequentialInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00001674 _rdata$r        ends
.rdata$r:00001674
.data:00001678 ; ===========================================================================
.data:00001678
.data:00001678 ; Segment type: Pure data
.data:00001678 ; Segment permissions: Read/Write
.data:00001678 _data           segment dword public 'DATA' use32
.data:00001678                 assume cs:_data
.data:00001678                 ;org 1678h
.data:00001678 ; COMDAT (pick any)
.data:00001678                 public ??_R0?AUISequentialInStream@@@8
.data:00001678 ; struct ISequentialInStream `RTTI Type Descriptor'
.data:00001678 ??_R0?AUISequentialInStream@@@8 dd offset ??_7type_info@@6B@
.data:00001678                                         ; DATA XREF: .rdata$r:ISequentialInStream::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:00001678                                         ; .rdata$r:00001A0Co
.data:00001678                                         ; const type_info::`vftable'
.data:0000167C                 align 10h
.data:00001680 a_?auisequentia db '.?AUISequentialInStream@@',0
.data:0000169A                 align 4
.data:0000169A _data           ends
.data:0000169A
.rdata$r:0000169C ; ===========================================================================
.rdata$r:0000169C
.rdata$r:0000169C ; Segment type: Pure data
.rdata$r:0000169C ; Segment permissions: Read
.rdata$r:0000169C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000169C                 assume cs:_rdata$r
.rdata$r:0000169C                 ;org 169Ch
.rdata$r:0000169C ; COMDAT (pick any)
.rdata$r:0000169C                 public ??_R3ISequentialInStream@@8
.rdata$r:0000169C ; ISequentialInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000169C ??_R3ISequentialInStream@@8 db    0     ; DATA XREF: .rdata$r:00001674o
.rdata$r:0000169C                                         ; .rdata$r:00001A10o
.rdata$r:0000169D                 db    0
.rdata$r:0000169E                 db    0
.rdata$r:0000169F                 db    0
.rdata$r:000016A0                 db    0
.rdata$r:000016A1                 db    0
.rdata$r:000016A2                 db    0
.rdata$r:000016A3                 db    0
.rdata$r:000016A4                 db    2
.rdata$r:000016A5                 db    0
.rdata$r:000016A6                 db    0
.rdata$r:000016A7                 db    0
.rdata$r:000016A8                 dd offset ??_R2ISequentialInStream@@8 ; ISequentialInStream::`RTTI Base Class Array'
.rdata$r:000016A8 _rdata$r        ends
.rdata$r:000016A8
.rdata$r:000016AC ; ===========================================================================
.rdata$r:000016AC
.rdata$r:000016AC ; Segment type: Pure data
.rdata$r:000016AC ; Segment permissions: Read
.rdata$r:000016AC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000016AC                 assume cs:_rdata$r
.rdata$r:000016AC                 ;org 16ACh
.rdata$r:000016AC ; COMDAT (pick any)
.rdata$r:000016AC                 public ??_R2ISequentialInStream@@8
.rdata$r:000016AC ; ISequentialInStream::`RTTI Base Class Array'
.rdata$r:000016AC ??_R2ISequentialInStream@@8 dd offset ??_R1A@?0A@EA@ISequentialInStream@@8
.rdata$r:000016AC                                         ; DATA XREF: .rdata$r:000016A8o
.rdata$r:000016AC                                         ; ISequentialInStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000016B0                 dd offset ??_R1A@?0A@EA@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000016B4                 db    0
.rdata$r:000016B5                 align 4
.rdata$r:000016B5 _rdata$r        ends
.rdata$r:000016B5
.rdata$r:000016B8 ; ===========================================================================
.rdata$r:000016B8
.rdata$r:000016B8 ; Segment type: Pure data
.rdata$r:000016B8 ; Segment permissions: Read
.rdata$r:000016B8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000016B8                 assume cs:_rdata$r
.rdata$r:000016B8                 ;org 16B8h
.rdata$r:000016B8 ; COMDAT (pick any)
.rdata$r:000016B8                 public ??_R1A@?0A@EA@IUnknown@@8
.rdata$r:000016B8 ; IUnknown::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000016B8 ??_R1A@?0A@EA@IUnknown@@8 dd offset ??_R0?AUIUnknown@@@8
.rdata$r:000016B8                                         ; DATA XREF: .rdata$r:000015E0o
.rdata$r:000016B8                                         ; .rdata$r:00001654o ...
.rdata$r:000016B8                                         ; IUnknown `RTTI Type Descriptor'
.rdata$r:000016BC                 db    0
.rdata$r:000016BD                 db    0
.rdata$r:000016BE                 db    0
.rdata$r:000016BF                 db    0
.rdata$r:000016C0                 db    0
.rdata$r:000016C1                 db    0
.rdata$r:000016C2                 db    0
.rdata$r:000016C3                 db    0
.rdata$r:000016C4                 db 0FFh
.rdata$r:000016C5                 db 0FFh
.rdata$r:000016C6                 db 0FFh
.rdata$r:000016C7                 db 0FFh
.rdata$r:000016C8                 db    0
.rdata$r:000016C9                 db    0
.rdata$r:000016CA                 db    0
.rdata$r:000016CB                 db    0
.rdata$r:000016CC                 db  40h ; @
.rdata$r:000016CD                 db    0
.rdata$r:000016CE                 db    0
.rdata$r:000016CF                 db    0
.rdata$r:000016D0                 dd offset ??_R3IUnknown@@8 ; IUnknown::`RTTI Class Hierarchy Descriptor'
.rdata$r:000016D0 _rdata$r        ends
.rdata$r:000016D0
.data:000016D4 ; ===========================================================================
.data:000016D4
.data:000016D4 ; Segment type: Pure data
.data:000016D4 ; Segment permissions: Read/Write
.data:000016D4 _data           segment dword public 'DATA' use32
.data:000016D4                 assume cs:_data
.data:000016D4                 ;org 16D4h
.data:000016D4 ; COMDAT (pick any)
.data:000016D4                 public ??_R0?AUIUnknown@@@8
.data:000016D4 ; struct IUnknown `RTTI Type Descriptor'
.data:000016D4 ??_R0?AUIUnknown@@@8 dd offset ??_7type_info@@6B@
.data:000016D4                                         ; DATA XREF: .rdata$r:IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:000016D4                                         ; const type_info::`vftable'
.data:000016D8                 db    0
.data:000016D9                 db    0
.data:000016DA                 db    0
.data:000016DB                 db    0
.data:000016DC                 db  2Eh ; .
.data:000016DD                 db  3Fh ; ?
.data:000016DE                 db  41h ; A
.data:000016DF                 db  55h ; U
.data:000016E0                 db  49h ; I
.data:000016E1                 db  55h ; U
.data:000016E2                 db  6Eh ; n
.data:000016E3                 db  6Bh ; k
.data:000016E4                 db  6Eh ; n
.data:000016E5                 db  6Fh ; o
.data:000016E6                 db  77h ; w
.data:000016E7                 db  6Eh ; n
.data:000016E8                 db  40h ; @
.data:000016E9                 db  40h ; @
.data:000016EA                 db    0
.data:000016EB                 align 4
.data:000016EB _data           ends
.data:000016EB
.rdata$r:000016EC ; ===========================================================================
.rdata$r:000016EC
.rdata$r:000016EC ; Segment type: Pure data
.rdata$r:000016EC ; Segment permissions: Read
.rdata$r:000016EC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000016EC                 assume cs:_rdata$r
.rdata$r:000016EC                 ;org 16ECh
.rdata$r:000016EC ; COMDAT (pick any)
.rdata$r:000016EC                 public ??_R3IUnknown@@8
.rdata$r:000016EC ; IUnknown::`RTTI Class Hierarchy Descriptor'
.rdata$r:000016EC ??_R3IUnknown@@8 db    0                ; DATA XREF: .rdata$r:000016D0o
.rdata$r:000016ED                 db    0
.rdata$r:000016EE                 db    0
.rdata$r:000016EF                 db    0
.rdata$r:000016F0                 db    0
.rdata$r:000016F1                 db    0
.rdata$r:000016F2                 db    0
.rdata$r:000016F3                 db    0
.rdata$r:000016F4                 db    1
.rdata$r:000016F5                 db    0
.rdata$r:000016F6                 db    0
.rdata$r:000016F7                 db    0
.rdata$r:000016F8                 dd offset ??_R2IUnknown@@8 ; IUnknown::`RTTI Base Class Array'
.rdata$r:000016F8 _rdata$r        ends
.rdata$r:000016F8
.rdata$r:000016FC ; ===========================================================================
.rdata$r:000016FC
.rdata$r:000016FC ; Segment type: Pure data
.rdata$r:000016FC ; Segment permissions: Read
.rdata$r:000016FC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000016FC                 assume cs:_rdata$r
.rdata$r:000016FC                 ;org 16FCh
.rdata$r:000016FC ; COMDAT (pick any)
.rdata$r:000016FC                 public ??_R2IUnknown@@8
.rdata$r:000016FC ; IUnknown::`RTTI Base Class Array'
.rdata$r:000016FC ??_R2IUnknown@@8 dd offset ??_R1A@?0A@EA@IUnknown@@8
.rdata$r:000016FC                                         ; DATA XREF: .rdata$r:000016F8o
.rdata$r:000016FC                                         ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00001700                 db    0
.rdata$r:00001701                 align 4
.rdata$r:00001701 _rdata$r        ends
.rdata$r:00001701
.rdata$r:00001704 ; ===========================================================================
.rdata$r:00001704
.rdata$r:00001704 ; Segment type: Pure data
.rdata$r:00001704 ; Segment permissions: Read
.rdata$r:00001704 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001704                 assume cs:_rdata$r
.rdata$r:00001704                 ;org 1704h
.rdata$r:00001704 ; COMDAT (pick any)
.rdata$r:00001704                 public ??_R13?0A@EA@CMyUnknownImp@@8
.rdata$r:00001704 ; CMyUnknownImp::`RTTI Base Class Descriptor at (4, -1, 0, 64)'
.rdata$r:00001704 ??_R13?0A@EA@CMyUnknownImp@@8 dd offset ??_R0?AVCMyUnknownImp@@@8
.rdata$r:00001704                                         ; DATA XREF: .rdata$r:000015E4o
.rdata$r:00001704                                         ; CMyUnknownImp `RTTI Type Descriptor'
.rdata$r:00001708                 db    0
.rdata$r:00001709                 db    0
.rdata$r:0000170A                 db    0
.rdata$r:0000170B                 db    0
.rdata$r:0000170C                 db    4
.rdata$r:0000170D                 db    0
.rdata$r:0000170E                 db    0
.rdata$r:0000170F                 db    0
.rdata$r:00001710                 db 0FFh
.rdata$r:00001711                 db 0FFh
.rdata$r:00001712                 db 0FFh
.rdata$r:00001713                 db 0FFh
.rdata$r:00001714                 db    0
.rdata$r:00001715                 db    0
.rdata$r:00001716                 db    0
.rdata$r:00001717                 db    0
.rdata$r:00001718                 db  40h ; @
.rdata$r:00001719                 db    0
.rdata$r:0000171A                 db    0
.rdata$r:0000171B                 db    0
.rdata$r:0000171C                 dd offset ??_R3CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000171C _rdata$r        ends
.rdata$r:0000171C
.data:00001720 ; ===========================================================================
.data:00001720
.data:00001720 ; Segment type: Pure data
.data:00001720 ; Segment permissions: Read/Write
.data:00001720 _data           segment dword public 'DATA' use32
.data:00001720                 assume cs:_data
.data:00001720                 ;org 1720h
.data:00001720 ; COMDAT (pick any)
.data:00001720                 public ??_R0?AVCMyUnknownImp@@@8
.data:00001720 ; class CMyUnknownImp `RTTI Type Descriptor'
.data:00001720 ??_R0?AVCMyUnknownImp@@@8 dd offset ??_7type_info@@6B@
.data:00001720                                         ; DATA XREF: .rdata$r:CMyUnknownImp::`RTTI Base Class Descriptor at (4,-1,0,64)'o
.data:00001720                                         ; .rdata$r:CMyUnknownImp::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:00001720                                         ; const type_info::`vftable'
.data:00001724                 align 8
.data:00001728 a_?avcmyunknown db '.?AVCMyUnknownImp@@',0
.data:00001728 _data           ends
.data:00001728
.rdata$r:0000173C ; ===========================================================================
.rdata$r:0000173C
.rdata$r:0000173C ; Segment type: Pure data
.rdata$r:0000173C ; Segment permissions: Read
.rdata$r:0000173C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000173C                 assume cs:_rdata$r
.rdata$r:0000173C                 ;org 173Ch
.rdata$r:0000173C ; COMDAT (pick any)
.rdata$r:0000173C                 public ??_R3CMyUnknownImp@@8
.rdata$r:0000173C ; CMyUnknownImp::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000173C ??_R3CMyUnknownImp@@8 db    0           ; DATA XREF: .rdata$r:0000171Co
.rdata$r:0000173C                                         ; .rdata$r:0000176Co
.rdata$r:0000173D                 db    0
.rdata$r:0000173E                 db    0
.rdata$r:0000173F                 db    0
.rdata$r:00001740                 db    0
.rdata$r:00001741                 db    0
.rdata$r:00001742                 db    0
.rdata$r:00001743                 db    0
.rdata$r:00001744                 db    1
.rdata$r:00001745                 db    0
.rdata$r:00001746                 db    0
.rdata$r:00001747                 db    0
.rdata$r:00001748                 dd offset ??_R2CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Base Class Array'
.rdata$r:00001748 _rdata$r        ends
.rdata$r:00001748
.rdata$r:0000174C ; ===========================================================================
.rdata$r:0000174C
.rdata$r:0000174C ; Segment type: Pure data
.rdata$r:0000174C ; Segment permissions: Read
.rdata$r:0000174C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000174C                 assume cs:_rdata$r
.rdata$r:0000174C                 ;org 174Ch
.rdata$r:0000174C ; COMDAT (pick any)
.rdata$r:0000174C                 public ??_R2CMyUnknownImp@@8
.rdata$r:0000174C ; CMyUnknownImp::`RTTI Base Class Array'
.rdata$r:0000174C ??_R2CMyUnknownImp@@8 dd offset ??_R1A@?0A@EA@CMyUnknownImp@@8
.rdata$r:0000174C                                         ; DATA XREF: .rdata$r:00001748o
.rdata$r:0000174C                                         ; CMyUnknownImp::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00001750                 db    0
.rdata$r:00001751                 align 4
.rdata$r:00001751 _rdata$r        ends
.rdata$r:00001751
.rdata$r:00001754 ; ===========================================================================
.rdata$r:00001754
.rdata$r:00001754 ; Segment type: Pure data
.rdata$r:00001754 ; Segment permissions: Read
.rdata$r:00001754 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001754                 assume cs:_rdata$r
.rdata$r:00001754                 ;org 1754h
.rdata$r:00001754 ; COMDAT (pick any)
.rdata$r:00001754                 public ??_R1A@?0A@EA@CMyUnknownImp@@8
.rdata$r:00001754 ; CMyUnknownImp::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00001754 ??_R1A@?0A@EA@CMyUnknownImp@@8 dd offset ??_R0?AVCMyUnknownImp@@@8
.rdata$r:00001754                                         ; DATA XREF: .rdata$r:CMyUnknownImp::`RTTI Base Class Array'o
.rdata$r:00001754                                         ; CMyUnknownImp `RTTI Type Descriptor'
.rdata$r:00001758                 align 10h
.rdata$r:00001760                 db 0FFh
.rdata$r:00001761                 db 0FFh
.rdata$r:00001762                 db 0FFh
.rdata$r:00001763                 db 0FFh
.rdata$r:00001764                 db    0
.rdata$r:00001765                 db    0
.rdata$r:00001766                 db    0
.rdata$r:00001767                 db    0
.rdata$r:00001768                 db  40h ; @
.rdata$r:00001769                 db    0
.rdata$r:0000176A                 db    0
.rdata$r:0000176B                 db    0
.rdata$r:0000176C                 dd offset ??_R3CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000176C _rdata$r        ends
.rdata$r:0000176C
.text:00001770 ; ===========================================================================
.text:00001770
.text:00001770 ; Segment type: Pure code
.text:00001770 ; Segment permissions: Read/Execute
.text:00001770 _text           segment para public 'CODE' use32
.text:00001770                 assume cs:_text
.text:00001770                 ;org 1770h
.text:00001770 ; COMDAT (pick any)
.text:00001770                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001770
.text:00001770 ; =============== S U B R O U T I N E =======================================
.text:00001770
.text:00001770 ; Attributes: bp-based frame
.text:00001770
.text:00001770 ; _DWORD __thiscall CMyUnknownImp::CMyUnknownImp(CMyUnknownImp *__hidden this)
.text:00001770                 public ??0CMyUnknownImp@@QAE@XZ
.text:00001770 ??0CMyUnknownImp@@QAE@XZ proc near      ; CODE XREF: CLimitedInStream::CLimitedInStream(void)+1Cp
.text:00001770
.text:00001770 var_4           = dword ptr -4
.text:00001770
.text:00001770                 push    ebp
.text:00001771                 mov     ebp, esp
.text:00001773                 push    ecx
.text:00001774                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000177B                 mov     [ebp+var_4], ecx
.text:0000177E                 mov     eax, [ebp+var_4]
.text:00001781                 mov     dword ptr [eax], 0
.text:00001787                 mov     eax, [ebp+var_4]
.text:0000178A                 mov     esp, ebp
.text:0000178C                 pop     ebp
.text:0000178D                 retn
.text:0000178D ??0CMyUnknownImp@@QAE@XZ endp
.text:0000178D
.text:0000178D ; ---------------------------------------------------------------------------
.text:0000178E                 align 10h
.text:0000178E _text           ends
.text:0000178E
.text:00001790 ; ===========================================================================
.text:00001790
.text:00001790 ; Segment type: Pure code
.text:00001790 ; Segment permissions: Read/Execute
.text:00001790 _text           segment para public 'CODE' use32
.text:00001790                 assume cs:_text
.text:00001790                 ;org 1790h
.text:00001790 ; COMDAT (pick any)
.text:00001790                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001790
.text:00001790 ; =============== S U B R O U T I N E =======================================
.text:00001790
.text:00001790 ; Attributes: bp-based frame
.text:00001790
.text:00001790 ; __int32 __stdcall CLimitedInStream::QueryInterface(CLimitedInStream *this, const struct _GUID *Buf1, void **)
.text:00001790                 public ?QueryInterface@CLimitedInStream@@UAGJABU_GUID@@PAPAX@Z
.text:00001790 ?QueryInterface@CLimitedInStream@@UAGJABU_GUID@@PAPAX@Z proc near
.text:00001790                                         ; DATA XREF: .rdata:const CLimitedInStream::`vftable'o
.text:00001790
.text:00001790 this            = dword ptr  8
.text:00001790 Buf1            = dword ptr  0Ch
.text:00001790 arg_8           = dword ptr  10h
.text:00001790
.text:00001790                 push    ebp
.text:00001791                 mov     ebp, esp
.text:00001793                 mov     eax, [ebp+arg_8]
.text:00001796                 mov     dword ptr [eax], 0
.text:0000179C                 push    offset _IID_IUnknown ; Buf2
.text:000017A1                 mov     ecx, [ebp+Buf1]
.text:000017A4                 push    ecx             ; Buf1
.text:000017A5                 call    ___@8           ; __(x,x)
.text:000017AA                 test    eax, eax
.text:000017AC                 jz      short loc_17B8
.text:000017AE                 mov     edx, [ebp+arg_8]
.text:000017B1                 mov     eax, [ebp+this]
.text:000017B4                 mov     [edx], eax
.text:000017B6                 jmp     short loc_17F7
.text:000017B8 ; ---------------------------------------------------------------------------
.text:000017B8
.text:000017B8 loc_17B8:                               ; CODE XREF: CLimitedInStream::QueryInterface(_GUID const &,void * *)+1Cj
.text:000017B8                 push    offset _IID_ISequentialInStream ; Buf2
.text:000017BD                 mov     ecx, [ebp+Buf1]
.text:000017C0                 push    ecx             ; Buf1
.text:000017C1                 call    ___@8           ; __(x,x)
.text:000017C6                 test    eax, eax
.text:000017C8                 jz      short loc_17D4
.text:000017CA                 mov     edx, [ebp+arg_8]
.text:000017CD                 mov     eax, [ebp+this]
.text:000017D0                 mov     [edx], eax
.text:000017D2                 jmp     short loc_17F7
.text:000017D4 ; ---------------------------------------------------------------------------
.text:000017D4
.text:000017D4 loc_17D4:                               ; CODE XREF: CLimitedInStream::QueryInterface(_GUID const &,void * *)+38j
.text:000017D4                 push    offset _IID_IInStream ; Buf2
.text:000017D9                 mov     ecx, [ebp+Buf1]
.text:000017DC                 push    ecx             ; Buf1
.text:000017DD                 call    ___@8           ; __(x,x)
.text:000017E2                 test    eax, eax
.text:000017E4                 jz      short loc_17F0
.text:000017E6                 mov     edx, [ebp+arg_8]
.text:000017E9                 mov     eax, [ebp+this]
.text:000017EC                 mov     [edx], eax
.text:000017EE                 jmp     short loc_17F7
.text:000017F0 ; ---------------------------------------------------------------------------
.text:000017F0
.text:000017F0 loc_17F0:                               ; CODE XREF: CLimitedInStream::QueryInterface(_GUID const &,void * *)+54j
.text:000017F0                 mov     eax, 80004002h
.text:000017F5                 jmp     short loc_1808
.text:000017F7 ; ---------------------------------------------------------------------------
.text:000017F7
.text:000017F7 loc_17F7:                               ; CODE XREF: CLimitedInStream::QueryInterface(_GUID const &,void * *)+26j
.text:000017F7                                         ; CLimitedInStream::QueryInterface(_GUID const &,void * *)+42j ...
.text:000017F7                 mov     ecx, [ebp+this]
.text:000017FA                 mov     edx, [ecx+4]
.text:000017FD                 add     edx, 1
.text:00001800                 mov     eax, [ebp+this]
.text:00001803                 mov     [eax+4], edx
.text:00001806                 xor     eax, eax
.text:00001808
.text:00001808 loc_1808:                               ; CODE XREF: CLimitedInStream::QueryInterface(_GUID const &,void * *)+65j
.text:00001808                 cmp     ebp, esp
.text:0000180A                 call    __RTC_CheckEsp
.text:0000180F                 pop     ebp
.text:00001810                 retn    0Ch
.text:00001810 ?QueryInterface@CLimitedInStream@@UAGJABU_GUID@@PAPAX@Z endp
.text:00001810
.text:00001810 ; ---------------------------------------------------------------------------
.text:00001813                 align 4
.text:00001813 _text           ends
.text:00001813
.text:00001814 ; ===========================================================================
.text:00001814
.text:00001814 ; Segment type: Pure code
.text:00001814 ; Segment permissions: Read/Execute
.text:00001814 _text           segment para public 'CODE' use32
.text:00001814                 assume cs:_text
.text:00001814                 ;org 1814h
.text:00001814 ; COMDAT (pick any)
.text:00001814                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001814
.text:00001814 ; =============== S U B R O U T I N E =======================================
.text:00001814
.text:00001814 ; Attributes: bp-based frame
.text:00001814
.text:00001814 ; int __stdcall __(void *Buf1, void *Buf2)
.text:00001814                 public ___@8
.text:00001814 ___@8           proc near               ; CODE XREF: CLimitedInStream::QueryInterface(_GUID const &,void * *)+15p
.text:00001814                                         ; CLimitedInStream::QueryInterface(_GUID const &,void * *)+31p ...
.text:00001814
.text:00001814 Buf1            = dword ptr  8
.text:00001814 Buf2            = dword ptr  0Ch
.text:00001814
.text:00001814                 push    ebp
.text:00001815                 mov     ebp, esp
.text:00001817                 mov     eax, [ebp+Buf2]
.text:0000181A                 push    eax             ; Buf2
.text:0000181B                 mov     ecx, [ebp+Buf1]
.text:0000181E                 push    ecx             ; Buf1
.text:0000181F                 call    _IsEqualGUID@8  ; IsEqualGUID(x,x)
.text:00001824                 cmp     ebp, esp
.text:00001826                 call    __RTC_CheckEsp
.text:0000182B                 pop     ebp
.text:0000182C                 retn    8
.text:0000182C ___@8           endp
.text:0000182C
.text:0000182C ; ---------------------------------------------------------------------------
.text:0000182F                 align 10h
.text:0000182F _text           ends
.text:0000182F
.text:00001830 ; ===========================================================================
.text:00001830
.text:00001830 ; Segment type: Pure code
.text:00001830 ; Segment permissions: Read/Execute
.text:00001830 _text           segment para public 'CODE' use32
.text:00001830                 assume cs:_text
.text:00001830                 ;org 1830h
.text:00001830 ; COMDAT (pick any)
.text:00001830                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001830
.text:00001830 ; =============== S U B R O U T I N E =======================================
.text:00001830
.text:00001830 ; Attributes: bp-based frame
.text:00001830
.text:00001830 ; int __stdcall IsEqualGUID(void *Buf1, void *Buf2)
.text:00001830                 public _IsEqualGUID@8
.text:00001830 _IsEqualGUID@8  proc near               ; CODE XREF: __(x,x)+Bp
.text:00001830
.text:00001830 Buf1            = dword ptr  8
.text:00001830 Buf2            = dword ptr  0Ch
.text:00001830
.text:00001830                 push    ebp
.text:00001831                 mov     ebp, esp
.text:00001833                 push    10h             ; Size
.text:00001835                 mov     eax, [ebp+Buf2]
.text:00001838                 push    eax             ; Buf2
.text:00001839                 mov     ecx, [ebp+Buf1]
.text:0000183C                 push    ecx             ; Buf1
.text:0000183D                 call    _memcmp
.text:00001842                 add     esp, 0Ch
.text:00001845                 neg     eax
.text:00001847                 sbb     eax, eax
.text:00001849                 add     eax, 1
.text:0000184C                 cmp     ebp, esp
.text:0000184E                 call    __RTC_CheckEsp
.text:00001853                 pop     ebp
.text:00001854                 retn    8
.text:00001854 _IsEqualGUID@8  endp
.text:00001854
.text:00001854 ; ---------------------------------------------------------------------------
.text:00001857                 align 4
.text:00001857 _text           ends
.text:00001857
.text:00001858 ; ===========================================================================
.text:00001858
.text:00001858 ; Segment type: Pure code
.text:00001858 ; Segment permissions: Read/Execute
.text:00001858 _text           segment para public 'CODE' use32
.text:00001858                 assume cs:_text
.text:00001858                 ;org 1858h
.text:00001858 ; COMDAT (pick any)
.text:00001858                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001858
.text:00001858 ; =============== S U B R O U T I N E =======================================
.text:00001858
.text:00001858 ; Attributes: bp-based frame
.text:00001858
.text:00001858 ; unsigned __int32 __stdcall CLimitedInStream::AddRef(CLimitedInStream *this)
.text:00001858                 public ?AddRef@CLimitedInStream@@UAGKXZ
.text:00001858 ?AddRef@CLimitedInStream@@UAGKXZ proc near ; DATA XREF: .rdata:00001580o
.text:00001858
.text:00001858 var_4           = dword ptr -4
.text:00001858 this            = dword ptr  8
.text:00001858
.text:00001858                 push    ebp
.text:00001859                 mov     ebp, esp
.text:0000185B                 push    ecx
.text:0000185C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001863                 mov     eax, [ebp+this]
.text:00001866                 mov     ecx, [eax+4]
.text:00001869                 add     ecx, 1
.text:0000186C                 mov     [ebp+var_4], ecx
.text:0000186F                 mov     edx, [ebp+this]
.text:00001872                 mov     eax, [ebp+var_4]
.text:00001875                 mov     [edx+4], eax
.text:00001878                 mov     eax, [ebp+var_4]
.text:0000187B                 mov     esp, ebp
.text:0000187D                 pop     ebp
.text:0000187E                 retn    4
.text:0000187E ?AddRef@CLimitedInStream@@UAGKXZ endp
.text:0000187E
.text:0000187E ; ---------------------------------------------------------------------------
.text:00001881                 align 4
.text:00001881 _text           ends
.text:00001881
.text:00001884 ; ===========================================================================
.text:00001884
.text:00001884 ; Segment type: Pure code
.text:00001884 ; Segment permissions: Read/Execute
.text:00001884 _text           segment para public 'CODE' use32
.text:00001884                 assume cs:_text
.text:00001884                 ;org 1884h
.text:00001884 ; COMDAT (pick any)
.text:00001884                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001884
.text:00001884 ; =============== S U B R O U T I N E =======================================
.text:00001884
.text:00001884 ; Attributes: bp-based frame
.text:00001884
.text:00001884 ; unsigned __int32 __stdcall CLimitedInStream::Release(CLimitedInStream *this)
.text:00001884                 public ?Release@CLimitedInStream@@UAGKXZ
.text:00001884 ?Release@CLimitedInStream@@UAGKXZ proc near ; DATA XREF: .rdata:00001584o
.text:00001884
.text:00001884 var_10          = dword ptr -10h
.text:00001884 var_C           = dword ptr -0Ch
.text:00001884 var_8           = dword ptr -8
.text:00001884 var_4           = dword ptr -4
.text:00001884 this            = dword ptr  8
.text:00001884
.text:00001884                 push    ebp
.text:00001885                 mov     ebp, esp
.text:00001887                 sub     esp, 10h
.text:0000188A                 mov     eax, 0CCCCCCCCh
.text:0000188F                 mov     [ebp+var_10], eax
.text:00001892                 mov     [ebp+var_C], eax
.text:00001895                 mov     [ebp+var_8], eax
.text:00001898                 mov     [ebp+var_4], eax
.text:0000189B                 mov     eax, [ebp+this]
.text:0000189E                 mov     ecx, [eax+4]
.text:000018A1                 sub     ecx, 1
.text:000018A4                 mov     [ebp+var_C], ecx
.text:000018A7                 mov     edx, [ebp+this]
.text:000018AA                 mov     eax, [ebp+var_C]
.text:000018AD                 mov     [edx+4], eax
.text:000018B0                 cmp     [ebp+var_C], 0
.text:000018B4                 jz      short loc_18BE
.text:000018B6                 mov     ecx, [ebp+this]
.text:000018B9                 mov     eax, [ecx+4]
.text:000018BC                 jmp     short loc_18E8
.text:000018BE ; ---------------------------------------------------------------------------
.text:000018BE
.text:000018BE loc_18BE:                               ; CODE XREF: CLimitedInStream::Release(void)+30j
.text:000018BE                 mov     edx, [ebp+this]
.text:000018C1                 mov     [ebp+var_8], edx
.text:000018C4                 mov     eax, [ebp+var_8]
.text:000018C7                 mov     [ebp+var_4], eax
.text:000018CA                 cmp     [ebp+var_4], 0
.text:000018CE                 jz      short loc_18DF
.text:000018D0                 push    1
.text:000018D2                 mov     ecx, [ebp+var_4]
.text:000018D5                 call    ??_GCLimitedInStream@@QAEPAXI@Z ; CLimitedInStream::`scalar deleting destructor'(uint)
.text:000018DA                 mov     [ebp+var_10], eax
.text:000018DD                 jmp     short loc_18E6
.text:000018DF ; ---------------------------------------------------------------------------
.text:000018DF
.text:000018DF loc_18DF:                               ; CODE XREF: CLimitedInStream::Release(void)+4Aj
.text:000018DF                 mov     [ebp+var_10], 0
.text:000018E6
.text:000018E6 loc_18E6:                               ; CODE XREF: CLimitedInStream::Release(void)+59j
.text:000018E6                 xor     eax, eax
.text:000018E8
.text:000018E8 loc_18E8:                               ; CODE XREF: CLimitedInStream::Release(void)+38j
.text:000018E8                 add     esp, 10h
.text:000018EB                 cmp     ebp, esp
.text:000018ED                 call    __RTC_CheckEsp
.text:000018F2                 mov     esp, ebp
.text:000018F4                 pop     ebp
.text:000018F5                 retn    4
.text:000018F5 ?Release@CLimitedInStream@@UAGKXZ endp
.text:000018F5
.text:000018F5 _text           ends
.text:000018F5
.text:000018F8 ; ===========================================================================
.text:000018F8
.text:000018F8 ; Segment type: Pure code
.text:000018F8 ; Segment permissions: Read/Execute
.text:000018F8 _text           segment para public 'CODE' use32
.text:000018F8                 assume cs:_text
.text:000018F8                 ;org 18F8h
.text:000018F8 ; COMDAT (pick any)
.text:000018F8                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000018F8
.text:000018F8 ; =============== S U B R O U T I N E =======================================
.text:000018F8
.text:000018F8 ; Attributes: bp-based frame
.text:000018F8
.text:000018F8 ; public: void * __thiscall CLimitedInStream::`scalar deleting destructor'(unsigned int)
.text:000018F8                 public ??_GCLimitedInStream@@QAEPAXI@Z
.text:000018F8 ??_GCLimitedInStream@@QAEPAXI@Z proc near
.text:000018F8                                         ; CODE XREF: CLimitedInStream::Release(void)+51p
.text:000018F8
.text:000018F8 var_4           = dword ptr -4
.text:000018F8 arg_0           = dword ptr  8
.text:000018F8
.text:000018F8                 push    ebp
.text:000018F9                 mov     ebp, esp
.text:000018FB                 push    ecx
.text:000018FC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001903                 mov     [ebp+var_4], ecx
.text:00001906                 mov     ecx, [ebp+var_4] ; this
.text:00001909                 call    ??1CLimitedInStream@@QAE@XZ ; CLimitedInStream::~CLimitedInStream(void)
.text:0000190E                 mov     eax, [ebp+arg_0]
.text:00001911                 and     eax, 1
.text:00001914                 jz      short loc_1922
.text:00001916                 mov     ecx, [ebp+var_4]
.text:00001919                 push    ecx             ; void *
.text:0000191A                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000191F                 add     esp, 4
.text:00001922
.text:00001922 loc_1922:                               ; CODE XREF: CLimitedInStream::`scalar deleting destructor'(uint)+1Cj
.text:00001922                 mov     eax, [ebp+var_4]
.text:00001925                 add     esp, 4
.text:00001928                 cmp     ebp, esp
.text:0000192A                 call    __RTC_CheckEsp
.text:0000192F                 mov     esp, ebp
.text:00001931                 pop     ebp
.text:00001932                 retn    4
.text:00001932 ??_GCLimitedInStream@@QAEPAXI@Z endp
.text:00001932
.text:00001932 ; ---------------------------------------------------------------------------
.text:00001935                 align 4
.text:00001935 _text           ends
.text:00001935
.text:00001938 ; ===========================================================================
.text:00001938
.text:00001938 ; Segment type: Pure code
.text:00001938 ; Segment permissions: Read/Execute
.text:00001938 _text           segment para public 'CODE' use32
.text:00001938                 assume cs:_text
.text:00001938                 ;org 1938h
.text:00001938 ; COMDAT (pick any)
.text:00001938                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001938
.text:00001938 ; =============== S U B R O U T I N E =======================================
.text:00001938
.text:00001938 ; Attributes: bp-based frame
.text:00001938
.text:00001938 ; _DWORD __thiscall CLimitedInStream::~CLimitedInStream(CLimitedInStream *__hidden this)
.text:00001938                 public ??1CLimitedInStream@@QAE@XZ
.text:00001938 ??1CLimitedInStream@@QAE@XZ proc near   ; CODE XREF: CLimitedInStream::`scalar deleting destructor'(uint)+11p
.text:00001938
.text:00001938 var_4           = dword ptr -4
.text:00001938
.text:00001938                 push    ebp
.text:00001939                 mov     ebp, esp
.text:0000193B                 push    ecx
.text:0000193C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001943                 mov     [ebp+var_4], ecx
.text:00001946                 mov     ecx, [ebp+var_4]
.text:00001949                 add     ecx, 8
.text:0000194C                 call    ??1?$CMyComPtr@UIInStream@@@@QAE@XZ ; CMyComPtr<IInStream>::~CMyComPtr<IInStream>(void)
.text:00001951                 add     esp, 4
.text:00001954                 cmp     ebp, esp
.text:00001956                 call    __RTC_CheckEsp
.text:0000195B                 mov     esp, ebp
.text:0000195D                 pop     ebp
.text:0000195E                 retn
.text:0000195E ??1CLimitedInStream@@QAE@XZ endp
.text:0000195E
.text:0000195E ; ---------------------------------------------------------------------------
.text:0000195F                 align 10h
.text:0000195F _text           ends
.text:0000195F
.text:00001960 ; ===========================================================================
.text:00001960
.text:00001960 ; Segment type: Pure code
.text:00001960 ; Segment permissions: Read/Execute
.text:00001960 _text           segment para public 'CODE' use32
.text:00001960                 assume cs:_text
.text:00001960                 ;org 1960h
.text:00001960 ; COMDAT (pick any)
.text:00001960                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001960
.text:00001960 ; =============== S U B R O U T I N E =======================================
.text:00001960
.text:00001960 ; Attributes: bp-based frame
.text:00001960
.text:00001960 ; _DWORD __thiscall IInStream::IInStream(IInStream *__hidden this)
.text:00001960                 public ??0IInStream@@QAE@XZ
.text:00001960 ??0IInStream@@QAE@XZ proc near          ; CODE XREF: CLimitedInStream::CLimitedInStream(void)+11p
.text:00001960
.text:00001960 var_4           = dword ptr -4
.text:00001960
.text:00001960                 push    ebp
.text:00001961                 mov     ebp, esp
.text:00001963                 push    ecx
.text:00001964                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000196B                 mov     [ebp+var_4], ecx
.text:0000196E                 mov     ecx, [ebp+var_4] ; this
.text:00001971                 call    ??0ISequentialInStream@@QAE@XZ ; ISequentialInStream::ISequentialInStream(void)
.text:00001976                 mov     eax, [ebp+var_4]
.text:00001979                 mov     dword ptr [eax], offset ??_7IInStream@@6B@ ; const IInStream::`vftable'
.text:0000197F                 mov     eax, [ebp+var_4]
.text:00001982                 add     esp, 4
.text:00001985                 cmp     ebp, esp
.text:00001987                 call    __RTC_CheckEsp
.text:0000198C                 mov     esp, ebp
.text:0000198E                 pop     ebp
.text:0000198F                 retn
.text:0000198F ??0IInStream@@QAE@XZ endp
.text:0000198F
.text:0000198F _text           ends
.text:0000198F
.rdata:00001990 ; ===========================================================================
.rdata:00001990
.rdata:00001990 ; Segment type: Pure data
.rdata:00001990 ; Segment permissions: Read
.rdata:00001990 _rdata          segment dword public 'DATA' use32
.rdata:00001990                 assume cs:_rdata
.rdata:00001990                 ;org 1990h
.rdata:00001990 ; COMDAT (pick largest)
.rdata:00001990                 dd offset ??_R4IInStream@@6B@ ; const IInStream::`RTTI Complete Object Locator'
.rdata:00001994                 public ??_7IInStream@@6B@
.rdata:00001994 ; const IInStream::`vftable'
.rdata:00001994 ??_7IInStream@@6B@ dd offset __purecall ; DATA XREF: IInStream::IInStream(void)+19o
.rdata:00001998                 dd offset __purecall
.rdata:0000199C                 dd offset __purecall
.rdata:000019A0                 dd offset __purecall
.rdata:000019A4                 dd offset __purecall
.rdata:000019A4 _rdata          ends
.rdata:000019A4
.rdata$r:000019A8 ; ===========================================================================
.rdata$r:000019A8
.rdata$r:000019A8 ; Segment type: Pure data
.rdata$r:000019A8 ; Segment permissions: Read
.rdata$r:000019A8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000019A8                 assume cs:_rdata$r
.rdata$r:000019A8                 ;org 19A8h
.rdata$r:000019A8 ; COMDAT (pick any)
.rdata$r:000019A8                 public ??_R4IInStream@@6B@
.rdata$r:000019A8 ; const IInStream::`RTTI Complete Object Locator'
.rdata$r:000019A8 ??_R4IInStream@@6B@ db    0             ; DATA XREF: .rdata:00001990o
.rdata$r:000019A9                 db    0
.rdata$r:000019AA                 db    0
.rdata$r:000019AB                 db    0
.rdata$r:000019AC                 db    0
.rdata$r:000019AD                 db    0
.rdata$r:000019AE                 db    0
.rdata$r:000019AF                 db    0
.rdata$r:000019B0                 db    0
.rdata$r:000019B1                 db    0
.rdata$r:000019B2                 db    0
.rdata$r:000019B3                 db    0
.rdata$r:000019B4                 dd offset ??_R0?AUIInStream@@@8 ; IInStream `RTTI Type Descriptor'
.rdata$r:000019B8                 dd offset ??_R3IInStream@@8 ; IInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:000019B8 _rdata$r        ends
.rdata$r:000019B8
.text:000019BC ; ===========================================================================
.text:000019BC
.text:000019BC ; Segment type: Pure code
.text:000019BC ; Segment permissions: Read/Execute
.text:000019BC _text           segment para public 'CODE' use32
.text:000019BC                 assume cs:_text
.text:000019BC                 ;org 19BCh
.text:000019BC ; COMDAT (pick any)
.text:000019BC                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000019BC
.text:000019BC ; =============== S U B R O U T I N E =======================================
.text:000019BC
.text:000019BC ; Attributes: bp-based frame
.text:000019BC
.text:000019BC ; _DWORD __thiscall ISequentialInStream::ISequentialInStream(ISequentialInStream *__hidden this)
.text:000019BC                 public ??0ISequentialInStream@@QAE@XZ
.text:000019BC ??0ISequentialInStream@@QAE@XZ proc near
.text:000019BC                                         ; CODE XREF: IInStream::IInStream(void)+11p
.text:000019BC
.text:000019BC var_4           = dword ptr -4
.text:000019BC
.text:000019BC                 push    ebp
.text:000019BD                 mov     ebp, esp
.text:000019BF                 push    ecx
.text:000019C0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000019C7                 mov     [ebp+var_4], ecx
.text:000019CA                 mov     ecx, [ebp+var_4]
.text:000019CD                 call    ??0IUnknown@@QAE@XZ ; IUnknown::IUnknown(void)
.text:000019D2                 mov     eax, [ebp+var_4]
.text:000019D5                 mov     dword ptr [eax], offset ??_7ISequentialInStream@@6B@ ; const ISequentialInStream::`vftable'
.text:000019DB                 mov     eax, [ebp+var_4]
.text:000019DE                 add     esp, 4
.text:000019E1                 cmp     ebp, esp
.text:000019E3                 call    __RTC_CheckEsp
.text:000019E8                 mov     esp, ebp
.text:000019EA                 pop     ebp
.text:000019EB                 retn
.text:000019EB ??0ISequentialInStream@@QAE@XZ endp
.text:000019EB
.text:000019EB _text           ends
.text:000019EB
.rdata:000019EC ; ===========================================================================
.rdata:000019EC
.rdata:000019EC ; Segment type: Pure data
.rdata:000019EC ; Segment permissions: Read
.rdata:000019EC _rdata          segment dword public 'DATA' use32
.rdata:000019EC                 assume cs:_rdata
.rdata:000019EC                 ;org 19ECh
.rdata:000019EC ; COMDAT (pick largest)
.rdata:000019EC                 dd offset ??_R4ISequentialInStream@@6B@ ; const ISequentialInStream::`RTTI Complete Object Locator'
.rdata:000019F0                 public ??_7ISequentialInStream@@6B@
.rdata:000019F0 ; const ISequentialInStream::`vftable'
.rdata:000019F0 ??_7ISequentialInStream@@6B@ dd offset __purecall
.rdata:000019F0                                         ; DATA XREF: ISequentialInStream::ISequentialInStream(void)+19o
.rdata:000019F4                 dd offset __purecall
.rdata:000019F8                 dd offset __purecall
.rdata:000019FC                 dd offset __purecall
.rdata:000019FC _rdata          ends
.rdata:000019FC
.rdata$r:00001A00 ; ===========================================================================
.rdata$r:00001A00
.rdata$r:00001A00 ; Segment type: Pure data
.rdata$r:00001A00 ; Segment permissions: Read
.rdata$r:00001A00 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001A00                 assume cs:_rdata$r
.rdata$r:00001A00                 ;org 1A00h
.rdata$r:00001A00 ; COMDAT (pick any)
.rdata$r:00001A00                 public ??_R4ISequentialInStream@@6B@
.rdata$r:00001A00 ; const ISequentialInStream::`RTTI Complete Object Locator'
.rdata$r:00001A00 ??_R4ISequentialInStream@@6B@ db    0   ; DATA XREF: .rdata:000019ECo
.rdata$r:00001A01                 db    0
.rdata$r:00001A02                 db    0
.rdata$r:00001A03                 db    0
.rdata$r:00001A04                 db    0
.rdata$r:00001A05                 db    0
.rdata$r:00001A06                 db    0
.rdata$r:00001A07                 db    0
.rdata$r:00001A08                 db    0
.rdata$r:00001A09                 db    0
.rdata$r:00001A0A                 db    0
.rdata$r:00001A0B                 db    0
.rdata$r:00001A0C                 dd offset ??_R0?AUISequentialInStream@@@8 ; ISequentialInStream `RTTI Type Descriptor'
.rdata$r:00001A10                 dd offset ??_R3ISequentialInStream@@8 ; ISequentialInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00001A10 _rdata$r        ends
.rdata$r:00001A10
.text:00001A14 ; ===========================================================================
.text:00001A14
.text:00001A14 ; Segment type: Pure code
.text:00001A14 ; Segment permissions: Read/Execute
.text:00001A14 _text           segment para public 'CODE' use32
.text:00001A14                 assume cs:_text
.text:00001A14                 ;org 1A14h
.text:00001A14 ; COMDAT (pick any)
.text:00001A14                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001A14
.text:00001A14 ; =============== S U B R O U T I N E =======================================
.text:00001A14
.text:00001A14 ; Attributes: bp-based frame
.text:00001A14
.text:00001A14 ; public: __thiscall IUnknown::IUnknown(void)
.text:00001A14                 public ??0IUnknown@@QAE@XZ
.text:00001A14 ??0IUnknown@@QAE@XZ proc near           ; CODE XREF: ISequentialInStream::ISequentialInStream(void)+11p
.text:00001A14
.text:00001A14 var_4           = dword ptr -4
.text:00001A14
.text:00001A14                 push    ebp
.text:00001A15                 mov     ebp, esp
.text:00001A17                 push    ecx
.text:00001A18                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001A1F                 mov     [ebp+var_4], ecx
.text:00001A22                 mov     eax, [ebp+var_4]
.text:00001A25                 mov     esp, ebp
.text:00001A27                 pop     ebp
.text:00001A28                 retn
.text:00001A28 ??0IUnknown@@QAE@XZ endp
.text:00001A28
.text:00001A28 ; ---------------------------------------------------------------------------
.text:00001A29                 align 4
.text:00001A29 _text           ends
.text:00001A29
.text:00001A2C ; ===========================================================================
.text:00001A2C
.text:00001A2C ; Segment type: Pure code
.text:00001A2C ; Segment permissions: Read/Execute
.text:00001A2C _text           segment para public 'CODE' use32
.text:00001A2C                 assume cs:_text
.text:00001A2C                 ;org 1A2Ch
.text:00001A2C ; COMDAT (pick any)
.text:00001A2C                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001A2C
.text:00001A2C ; =============== S U B R O U T I N E =======================================
.text:00001A2C
.text:00001A2C ; Attributes: bp-based frame
.text:00001A2C
.text:00001A2C ; __int32 __thiscall CClusterInStream::SeekToPhys(CClusterInStream *__hidden this)
.text:00001A2C                 public ?SeekToPhys@CClusterInStream@@QAEJXZ
.text:00001A2C ?SeekToPhys@CClusterInStream@@QAEJXZ proc near
.text:00001A2C                                         ; CODE XREF: CClusterInStream::Read(void *,uint,uint *)+106p
.text:00001A2C
.text:00001A2C var_8           = dword ptr -8
.text:00001A2C var_4           = dword ptr -4
.text:00001A2C
.text:00001A2C                 push    ebp
.text:00001A2D                 mov     ebp, esp
.text:00001A2F                 sub     esp, 8
.text:00001A32                 push    esi
.text:00001A33                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00001A3A                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001A41                 mov     [ebp+var_4], ecx
.text:00001A44                 mov     ecx, [ebp+var_4]
.text:00001A47                 add     ecx, 1Ch
.text:00001A4A                 call    ??C?$CMyComPtr@UIInStream@@@@QBEPAUIInStream@@XZ ; CMyComPtr<IInStream>::operator->(void)
.text:00001A4F                 mov     [ebp+var_8], eax
.text:00001A52                 mov     esi, esp
.text:00001A54                 push    0
.text:00001A56                 push    0
.text:00001A58                 mov     eax, [ebp+var_4]
.text:00001A5B                 mov     ecx, [eax+14h]
.text:00001A5E                 push    ecx
.text:00001A5F                 mov     edx, [eax+10h]
.text:00001A62                 push    edx
.text:00001A63                 mov     eax, [ebp+var_8]
.text:00001A66                 push    eax
.text:00001A67                 mov     ecx, [ebp+var_8]
.text:00001A6A                 mov     edx, [ecx]
.text:00001A6C                 mov     eax, [edx+10h]
.text:00001A6F                 call    eax
.text:00001A71                 cmp     esi, esp
.text:00001A73                 call    __RTC_CheckEsp
.text:00001A78                 pop     esi
.text:00001A79                 add     esp, 8
.text:00001A7C                 cmp     ebp, esp
.text:00001A7E                 call    __RTC_CheckEsp
.text:00001A83                 mov     esp, ebp
.text:00001A85                 pop     ebp
.text:00001A86                 retn
.text:00001A86 ?SeekToPhys@CClusterInStream@@QAEJXZ endp
.text:00001A86
.text:00001A86 ; ---------------------------------------------------------------------------
.text:00001A87                 align 4
.text:00001A87 _text           ends
.text:00001A87
.text:00001A88 ; ===========================================================================
.text:00001A88
.text:00001A88 ; Segment type: Pure code
.text:00001A88 ; Segment permissions: Read/Execute
.text:00001A88 _text           segment para public 'CODE' use32
.text:00001A88                 assume cs:_text
.text:00001A88                 ;org 1A88h
.text:00001A88 ; COMDAT (pick any)
.text:00001A88                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001A88
.text:00001A88 ; =============== S U B R O U T I N E =======================================
.text:00001A88
.text:00001A88 ; Attributes: bp-based frame
.text:00001A88
.text:00001A88 ; __int32 __thiscall CExtentsStream::SeekToPhys(CExtentsStream *__hidden this)
.text:00001A88                 public ?SeekToPhys@CExtentsStream@@AAEJXZ
.text:00001A88 ?SeekToPhys@CExtentsStream@@AAEJXZ proc near
.text:00001A88                                         ; CODE XREF: CExtentsStream::Read(void *,uint,uint *)+151p
.text:00001A88
.text:00001A88 var_8           = dword ptr -8
.text:00001A88 var_4           = dword ptr -4
.text:00001A88
.text:00001A88                 push    ebp
.text:00001A89                 mov     ebp, esp
.text:00001A8B                 sub     esp, 8
.text:00001A8E                 push    esi
.text:00001A8F                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00001A96                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001A9D                 mov     [ebp+var_4], ecx
.text:00001AA0                 mov     ecx, [ebp+var_4]
.text:00001AA3                 add     ecx, 1Ch
.text:00001AA6                 call    ??C?$CMyComPtr@UIInStream@@@@QBEPAUIInStream@@XZ ; CMyComPtr<IInStream>::operator->(void)
.text:00001AAB                 mov     [ebp+var_8], eax
.text:00001AAE                 mov     esi, esp
.text:00001AB0                 push    0
.text:00001AB2                 push    0
.text:00001AB4                 mov     eax, [ebp+var_4]
.text:00001AB7                 mov     ecx, [eax+0Ch]
.text:00001ABA                 push    ecx
.text:00001ABB                 mov     edx, [eax+8]
.text:00001ABE                 push    edx
.text:00001ABF                 mov     eax, [ebp+var_8]
.text:00001AC2                 push    eax
.text:00001AC3                 mov     ecx, [ebp+var_8]
.text:00001AC6                 mov     edx, [ecx]
.text:00001AC8                 mov     eax, [edx+10h]
.text:00001ACB                 call    eax
.text:00001ACD                 cmp     esi, esp
.text:00001ACF                 call    __RTC_CheckEsp
.text:00001AD4                 pop     esi
.text:00001AD5                 add     esp, 8
.text:00001AD8                 cmp     ebp, esp
.text:00001ADA                 call    __RTC_CheckEsp
.text:00001ADF                 mov     esp, ebp
.text:00001AE1                 pop     ebp
.text:00001AE2                 retn
.text:00001AE2 ?SeekToPhys@CExtentsStream@@AAEJXZ endp
.text:00001AE2
.text:00001AE2 ; ---------------------------------------------------------------------------
.text:00001AE3                 align 4
.text:00001AE3 _text           ends
.text:00001AE3
.text:00001AE4 ; ===========================================================================
.text:00001AE4
.text:00001AE4 ; Segment type: Pure code
.text:00001AE4 ; Segment permissions: Read/Execute
.text:00001AE4 _text           segment para public 'CODE' use32
.text:00001AE4                 assume cs:_text
.text:00001AE4                 ;org 1AE4h
.text:00001AE4 ; COMDAT (pick any)
.text:00001AE4                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001AE4
.text:00001AE4 ; =============== S U B R O U T I N E =======================================
.text:00001AE4
.text:00001AE4 ; Attributes: bp-based frame
.text:00001AE4
.text:00001AE4 ; __int32 __thiscall CLimitedCachedInStream::SeekToPhys(CLimitedCachedInStream *__hidden this)
.text:00001AE4                 public ?SeekToPhys@CLimitedCachedInStream@@AAEJXZ
.text:00001AE4 ?SeekToPhys@CLimitedCachedInStream@@AAEJXZ proc near
.text:00001AE4                                         ; CODE XREF: CLimitedCachedInStream::Read(void *,uint,uint *)+16Cp
.text:00001AE4
.text:00001AE4 var_8           = dword ptr -8
.text:00001AE4 var_4           = dword ptr -4
.text:00001AE4
.text:00001AE4                 push    ebp
.text:00001AE5                 mov     ebp, esp
.text:00001AE7                 sub     esp, 8
.text:00001AEA                 push    esi
.text:00001AEB                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00001AF2                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001AF9                 mov     [ebp+var_4], ecx
.text:00001AFC                 mov     ecx, [ebp+var_4]
.text:00001AFF                 add     ecx, 8
.text:00001B02                 call    ??C?$CMyComPtr@UIInStream@@@@QBEPAUIInStream@@XZ ; CMyComPtr<IInStream>::operator->(void)
.text:00001B07                 mov     [ebp+var_8], eax
.text:00001B0A                 mov     esi, esp
.text:00001B0C                 push    0
.text:00001B0E                 push    0
.text:00001B10                 mov     eax, [ebp+var_4]
.text:00001B13                 mov     ecx, [eax+1Ch]
.text:00001B16                 push    ecx
.text:00001B17                 mov     edx, [eax+18h]
.text:00001B1A                 push    edx
.text:00001B1B                 mov     eax, [ebp+var_8]
.text:00001B1E                 push    eax
.text:00001B1F                 mov     ecx, [ebp+var_8]
.text:00001B22                 mov     edx, [ecx]
.text:00001B24                 mov     eax, [edx+10h]
.text:00001B27                 call    eax
.text:00001B29                 cmp     esi, esp
.text:00001B2B                 call    __RTC_CheckEsp
.text:00001B30                 pop     esi
.text:00001B31                 add     esp, 8
.text:00001B34                 cmp     ebp, esp
.text:00001B36                 call    __RTC_CheckEsp
.text:00001B3B                 mov     esp, ebp
.text:00001B3D                 pop     ebp
.text:00001B3E                 retn
.text:00001B3E ?SeekToPhys@CLimitedCachedInStream@@AAEJXZ endp
.text:00001B3E
.text:00001B3E ; ---------------------------------------------------------------------------
.text:00001B3F                 align 10h
.text:00001B3F _text           ends
.text:00001B3F
.text:00001B40 ; ===========================================================================
.text:00001B40
.text:00001B40 ; Segment type: Pure code
.text:00001B40 ; Segment permissions: Read/Execute
.text:00001B40 _text           segment para public 'CODE' use32
.text:00001B40                 assume cs:_text
.text:00001B40                 ;org 1B40h
.text:00001B40 ; COMDAT (pick any)
.text:00001B40                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001B40
.text:00001B40 ; =============== S U B R O U T I N E =======================================
.text:00001B40
.text:00001B40 ; Attributes: bp-based frame
.text:00001B40
.text:00001B40 ; public: __thiscall CMyComPtr<struct ISequentialInStream>::CMyComPtr<struct ISequentialInStream>(struct ISequentialInStream *)
.text:00001B40                 public ??0?$CMyComPtr@UISequentialInStream@@@@QAE@PAUISequentialInStream@@@Z
.text:00001B40 ??0?$CMyComPtr@UISequentialInStream@@@@QAE@PAUISequentialInStream@@@Z proc near
.text:00001B40                                         ; CODE XREF: CreateLimitedInStream(IInStream *,unsigned __int64,unsigned __int64,ISequentialInStream * *)+86p
.text:00001B40
.text:00001B40 var_4           = dword ptr -4
.text:00001B40 arg_0           = dword ptr  8
.text:00001B40
.text:00001B40                 push    ebp
.text:00001B41                 mov     ebp, esp
.text:00001B43                 push    ecx
.text:00001B44                 push    esi
.text:00001B45                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001B4C                 mov     [ebp+var_4], ecx
.text:00001B4F                 mov     eax, [ebp+var_4]
.text:00001B52                 mov     ecx, [ebp+arg_0]
.text:00001B55                 mov     [eax], ecx
.text:00001B57                 cmp     [ebp+arg_0], 0
.text:00001B5B                 jz      short loc_1B74
.text:00001B5D                 mov     edx, [ebp+arg_0]
.text:00001B60                 mov     eax, [edx]
.text:00001B62                 mov     esi, esp
.text:00001B64                 mov     ecx, [ebp+arg_0]
.text:00001B67                 push    ecx
.text:00001B68                 mov     edx, [eax+4]
.text:00001B6B                 call    edx
.text:00001B6D                 cmp     esi, esp
.text:00001B6F                 call    __RTC_CheckEsp
.text:00001B74
.text:00001B74 loc_1B74:                               ; CODE XREF: CMyComPtr<ISequentialInStream>::CMyComPtr<ISequentialInStream>(ISequentialInStream *)+1Bj
.text:00001B74                 mov     eax, [ebp+var_4]
.text:00001B77                 pop     esi
.text:00001B78                 add     esp, 4
.text:00001B7B                 cmp     ebp, esp
.text:00001B7D                 call    __RTC_CheckEsp
.text:00001B82                 mov     esp, ebp
.text:00001B84                 pop     ebp
.text:00001B85                 retn    4
.text:00001B85 ??0?$CMyComPtr@UISequentialInStream@@@@QAE@PAUISequentialInStream@@@Z endp
.text:00001B85
.text:00001B85 _text           ends
.text:00001B85
.text:00001B88 ; ===========================================================================
.text:00001B88
.text:00001B88 ; Segment type: Pure code
.text:00001B88 ; Segment permissions: Read/Execute
.text:00001B88 _text           segment para public 'CODE' use32
.text:00001B88                 assume cs:_text
.text:00001B88                 ;org 1B88h
.text:00001B88 ; COMDAT (pick any)
.text:00001B88                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001B88
.text:00001B88 ; =============== S U B R O U T I N E =======================================
.text:00001B88
.text:00001B88 ; Attributes: bp-based frame
.text:00001B88
.text:00001B88 ; public: __thiscall CMyComPtr<struct ISequentialInStream>::~CMyComPtr<struct ISequentialInStream>(void)
.text:00001B88                 public ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ
.text:00001B88 ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ proc near
.text:00001B88                                         ; CODE XREF: CreateLimitedInStream(IInStream *,unsigned __int64,unsigned __int64,ISequentialInStream * *)+CFp
.text:00001B88                                         ; CreateLimitedInStream(IInStream *,unsigned __int64,unsigned __int64,ISequentialInStream * *)+FFp ...
.text:00001B88
.text:00001B88 var_4           = dword ptr -4
.text:00001B88
.text:00001B88                 push    ebp
.text:00001B89                 mov     ebp, esp
.text:00001B8B                 push    ecx
.text:00001B8C                 push    esi
.text:00001B8D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001B94                 mov     [ebp+var_4], ecx
.text:00001B97                 mov     eax, [ebp+var_4]
.text:00001B9A                 cmp     dword ptr [eax], 0
.text:00001B9D                 jz      short loc_1BBA
.text:00001B9F                 mov     ecx, [ebp+var_4]
.text:00001BA2                 mov     edx, [ecx]
.text:00001BA4                 mov     eax, [ebp+var_4]
.text:00001BA7                 mov     ecx, [eax]
.text:00001BA9                 mov     edx, [edx]
.text:00001BAB                 mov     esi, esp
.text:00001BAD                 push    ecx
.text:00001BAE                 mov     eax, [edx+8]
.text:00001BB1                 call    eax
.text:00001BB3                 cmp     esi, esp
.text:00001BB5                 call    __RTC_CheckEsp
.text:00001BBA
.text:00001BBA loc_1BBA:                               ; CODE XREF: CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)+15j
.text:00001BBA                 pop     esi
.text:00001BBB                 add     esp, 4
.text:00001BBE                 cmp     ebp, esp
.text:00001BC0                 call    __RTC_CheckEsp
.text:00001BC5                 mov     esp, ebp
.text:00001BC7                 pop     ebp
.text:00001BC8                 retn
.text:00001BC8 ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ endp
.text:00001BC8
.text:00001BC8 ; ---------------------------------------------------------------------------
.text:00001BC9                 align 4
.text:00001BC9 _text           ends
.text:00001BC9
.text:00001BCC ; ===========================================================================
.text:00001BCC
.text:00001BCC ; Segment type: Pure code
.text:00001BCC ; Segment permissions: Read/Execute
.text:00001BCC _text           segment para public 'CODE' use32
.text:00001BCC                 assume cs:_text
.text:00001BCC                 ;org 1BCCh
.text:00001BCC ; COMDAT (pick any)
.text:00001BCC                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001BCC
.text:00001BCC ; =============== S U B R O U T I N E =======================================
.text:00001BCC
.text:00001BCC ; Attributes: bp-based frame
.text:00001BCC
.text:00001BCC ; public: struct ISequentialInStream * __thiscall CMyComPtr<struct ISequentialInStream>::operator->(void)const
.text:00001BCC                 public ??C?$CMyComPtr@UISequentialInStream@@@@QBEPAUISequentialInStream@@XZ
.text:00001BCC ??C?$CMyComPtr@UISequentialInStream@@@@QBEPAUISequentialInStream@@XZ proc near
.text:00001BCC                                         ; CODE XREF: CLimitedSequentialInStream::Read(void *,uint,uint *)+5Bp
.text:00001BCC
.text:00001BCC var_4           = dword ptr -4
.text:00001BCC
.text:00001BCC                 push    ebp
.text:00001BCD                 mov     ebp, esp
.text:00001BCF                 push    ecx
.text:00001BD0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001BD7                 mov     [ebp+var_4], ecx
.text:00001BDA                 mov     eax, [ebp+var_4]
.text:00001BDD                 mov     eax, [eax]
.text:00001BDF                 mov     esp, ebp
.text:00001BE1                 pop     ebp
.text:00001BE2                 retn
.text:00001BE2 ??C?$CMyComPtr@UISequentialInStream@@@@QBEPAUISequentialInStream@@XZ endp
.text:00001BE2
.text:00001BE2 ; ---------------------------------------------------------------------------
.text:00001BE3                 align 4
.text:00001BE3 _text           ends
.text:00001BE3
.text:00001BE4 ; ===========================================================================
.text:00001BE4
.text:00001BE4 ; Segment type: Pure code
.text:00001BE4 ; Segment permissions: Read/Execute
.text:00001BE4 _text           segment para public 'CODE' use32
.text:00001BE4                 assume cs:_text
.text:00001BE4                 ;org 1BE4h
.text:00001BE4 ; COMDAT (pick any)
.text:00001BE4                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001BE4
.text:00001BE4 ; =============== S U B R O U T I N E =======================================
.text:00001BE4
.text:00001BE4 ; Attributes: bp-based frame
.text:00001BE4
.text:00001BE4 ; public: struct ISequentialInStream * __thiscall CMyComPtr<struct ISequentialInStream>::Detach(void)
.text:00001BE4                 public ?Detach@?$CMyComPtr@UISequentialInStream@@@@QAEPAUISequentialInStream@@XZ
.text:00001BE4 ?Detach@?$CMyComPtr@UISequentialInStream@@@@QAEPAUISequentialInStream@@XZ proc near
.text:00001BE4                                         ; CODE XREF: CreateLimitedInStream(IInStream *,unsigned __int64,unsigned __int64,ISequentialInStream * *)+E4p
.text:00001BE4
.text:00001BE4 var_8           = dword ptr -8
.text:00001BE4 var_4           = dword ptr -4
.text:00001BE4
.text:00001BE4                 push    ebp
.text:00001BE5                 mov     ebp, esp
.text:00001BE7                 sub     esp, 8
.text:00001BEA                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00001BF1                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001BF8                 mov     [ebp+var_4], ecx
.text:00001BFB                 mov     eax, [ebp+var_4]
.text:00001BFE                 mov     ecx, [eax]
.text:00001C00                 mov     [ebp+var_8], ecx
.text:00001C03                 mov     edx, [ebp+var_4]
.text:00001C06                 mov     dword ptr [edx], 0
.text:00001C0C                 mov     eax, [ebp+var_8]
.text:00001C0F                 mov     esp, ebp
.text:00001C11                 pop     ebp
.text:00001C12                 retn
.text:00001C12 ?Detach@?$CMyComPtr@UISequentialInStream@@@@QAEPAUISequentialInStream@@XZ endp
.text:00001C12
.text:00001C12 ; ---------------------------------------------------------------------------
.text:00001C13                 align 4
.text:00001C13 _text           ends
.text:00001C13
.text:00001C14 ; ===========================================================================
.text:00001C14
.text:00001C14 ; Segment type: Pure code
.text:00001C14 ; Segment permissions: Read/Execute
.text:00001C14 _text           segment para public 'CODE' use32
.text:00001C14                 assume cs:_text
.text:00001C14                 ;org 1C14h
.text:00001C14 ; COMDAT (pick any)
.text:00001C14                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001C14
.text:00001C14 ; =============== S U B R O U T I N E =======================================
.text:00001C14
.text:00001C14 ; Attributes: bp-based frame
.text:00001C14
.text:00001C14 ; public: __thiscall CMyComPtr<struct IInStream>::CMyComPtr<struct IInStream>(void)
.text:00001C14                 public ??0?$CMyComPtr@UIInStream@@@@QAE@XZ
.text:00001C14 ??0?$CMyComPtr@UIInStream@@@@QAE@XZ proc near
.text:00001C14                                         ; CODE XREF: CLimitedInStream::CLimitedInStream(void)+30p
.text:00001C14
.text:00001C14 var_4           = dword ptr -4
.text:00001C14
.text:00001C14                 push    ebp
.text:00001C15                 mov     ebp, esp
.text:00001C17                 push    ecx
.text:00001C18                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001C1F                 mov     [ebp+var_4], ecx
.text:00001C22                 mov     eax, [ebp+var_4]
.text:00001C25                 mov     dword ptr [eax], 0
.text:00001C2B                 mov     eax, [ebp+var_4]
.text:00001C2E                 mov     esp, ebp
.text:00001C30                 pop     ebp
.text:00001C31                 retn
.text:00001C31 ??0?$CMyComPtr@UIInStream@@@@QAE@XZ endp
.text:00001C31
.text:00001C31 ; ---------------------------------------------------------------------------
.text:00001C32                 align 4
.text:00001C32 _text           ends
.text:00001C32
.text:00001C34 ; ===========================================================================
.text:00001C34
.text:00001C34 ; Segment type: Pure code
.text:00001C34 ; Segment permissions: Read/Execute
.text:00001C34 _text           segment para public 'CODE' use32
.text:00001C34                 assume cs:_text
.text:00001C34                 ;org 1C34h
.text:00001C34 ; COMDAT (pick any)
.text:00001C34                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001C34
.text:00001C34 ; =============== S U B R O U T I N E =======================================
.text:00001C34
.text:00001C34 ; Attributes: bp-based frame
.text:00001C34
.text:00001C34 ; public: __thiscall CMyComPtr<struct IInStream>::~CMyComPtr<struct IInStream>(void)
.text:00001C34                 public ??1?$CMyComPtr@UIInStream@@@@QAE@XZ
.text:00001C34 ??1?$CMyComPtr@UIInStream@@@@QAE@XZ proc near
.text:00001C34                                         ; CODE XREF: CLimitedInStream::~CLimitedInStream(void)+14p
.text:00001C34
.text:00001C34 var_4           = dword ptr -4
.text:00001C34
.text:00001C34                 push    ebp
.text:00001C35                 mov     ebp, esp
.text:00001C37                 push    ecx
.text:00001C38                 push    esi
.text:00001C39                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001C40                 mov     [ebp+var_4], ecx
.text:00001C43                 mov     eax, [ebp+var_4]
.text:00001C46                 cmp     dword ptr [eax], 0
.text:00001C49                 jz      short loc_1C66
.text:00001C4B                 mov     ecx, [ebp+var_4]
.text:00001C4E                 mov     edx, [ecx]
.text:00001C50                 mov     eax, [ebp+var_4]
.text:00001C53                 mov     ecx, [eax]
.text:00001C55                 mov     edx, [edx]
.text:00001C57                 mov     esi, esp
.text:00001C59                 push    ecx
.text:00001C5A                 mov     eax, [edx+8]
.text:00001C5D                 call    eax
.text:00001C5F                 cmp     esi, esp
.text:00001C61                 call    __RTC_CheckEsp
.text:00001C66
.text:00001C66 loc_1C66:                               ; CODE XREF: CMyComPtr<IInStream>::~CMyComPtr<IInStream>(void)+15j
.text:00001C66                 pop     esi
.text:00001C67                 add     esp, 4
.text:00001C6A                 cmp     ebp, esp
.text:00001C6C                 call    __RTC_CheckEsp
.text:00001C71                 mov     esp, ebp
.text:00001C73                 pop     ebp
.text:00001C74                 retn
.text:00001C74 ??1?$CMyComPtr@UIInStream@@@@QAE@XZ endp
.text:00001C74
.text:00001C74 ; ---------------------------------------------------------------------------
.text:00001C75                 align 4
.text:00001C75 _text           ends
.text:00001C75
.text:00001C78 ; ===========================================================================
.text:00001C78
.text:00001C78 ; Segment type: Pure code
.text:00001C78 ; Segment permissions: Read/Execute
.text:00001C78 _text           segment para public 'CODE' use32
.text:00001C78                 assume cs:_text
.text:00001C78                 ;org 1C78h
.text:00001C78 ; COMDAT (pick any)
.text:00001C78                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001C78
.text:00001C78 ; =============== S U B R O U T I N E =======================================
.text:00001C78
.text:00001C78 ; Attributes: bp-based frame
.text:00001C78
.text:00001C78 ; public: struct IInStream * __thiscall CMyComPtr<struct IInStream>::operator->(void)const
.text:00001C78                 public ??C?$CMyComPtr@UIInStream@@@@QBEPAUIInStream@@XZ
.text:00001C78 ??C?$CMyComPtr@UIInStream@@@@QBEPAUIInStream@@XZ proc near
.text:00001C78                                         ; CODE XREF: CLimitedInStream::Read(void *,uint,uint *)+F1p
.text:00001C78                                         ; CClusterInStream::Read(void *,uint,uint *)+1E7p ...
.text:00001C78
.text:00001C78 var_4           = dword ptr -4
.text:00001C78
.text:00001C78                 push    ebp
.text:00001C79                 mov     ebp, esp
.text:00001C7B                 push    ecx
.text:00001C7C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001C83                 mov     [ebp+var_4], ecx
.text:00001C86                 mov     eax, [ebp+var_4]
.text:00001C89                 mov     eax, [eax]
.text:00001C8B                 mov     esp, ebp
.text:00001C8D                 pop     ebp
.text:00001C8E                 retn
.text:00001C8E ??C?$CMyComPtr@UIInStream@@@@QBEPAUIInStream@@XZ endp
.text:00001C8E
.text:00001C8E ; ---------------------------------------------------------------------------
.text:00001C8F                 align 10h
.text:00001C8F _text           ends
.text:00001C8F
.text:00001C90 ; ===========================================================================
.text:00001C90
.text:00001C90 ; Segment type: Pure code
.text:00001C90 ; Segment permissions: Read/Execute
.text:00001C90 _text           segment para public 'CODE' use32
.text:00001C90                 assume cs:_text
.text:00001C90                 ;org 1C90h
.text:00001C90 ; COMDAT (pick any)
.text:00001C90                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001C90
.text:00001C90 ; =============== S U B R O U T I N E =======================================
.text:00001C90
.text:00001C90 ; Attributes: bp-based frame
.text:00001C90
.text:00001C90 ; public: struct IInStream * __thiscall CMyComPtr<struct IInStream>::operator=(struct IInStream *)
.text:00001C90                 public ??4?$CMyComPtr@UIInStream@@@@QAEPAUIInStream@@PAU1@@Z
.text:00001C90 ??4?$CMyComPtr@UIInStream@@@@QAEPAUIInStream@@PAU1@@Z proc near
.text:00001C90                                         ; CODE XREF: CLimitedInStream::SetStream(IInStream *)+18p
.text:00001C90
.text:00001C90 var_4           = dword ptr -4
.text:00001C90 arg_0           = dword ptr  8
.text:00001C90
.text:00001C90                 push    ebp
.text:00001C91                 mov     ebp, esp
.text:00001C93                 push    ecx
.text:00001C94                 push    esi
.text:00001C95                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001C9C                 mov     [ebp+var_4], ecx
.text:00001C9F                 cmp     [ebp+arg_0], 0
.text:00001CA3                 jz      short loc_1CBC
.text:00001CA5                 mov     eax, [ebp+arg_0]
.text:00001CA8                 mov     ecx, [eax]
.text:00001CAA                 mov     esi, esp
.text:00001CAC                 mov     edx, [ebp+arg_0]
.text:00001CAF                 push    edx
.text:00001CB0                 mov     eax, [ecx+4]
.text:00001CB3                 call    eax
.text:00001CB5                 cmp     esi, esp
.text:00001CB7                 call    __RTC_CheckEsp
.text:00001CBC
.text:00001CBC loc_1CBC:                               ; CODE XREF: CMyComPtr<IInStream>::operator=(IInStream *)+13j
.text:00001CBC                 mov     ecx, [ebp+var_4]
.text:00001CBF                 cmp     dword ptr [ecx], 0
.text:00001CC2                 jz      short loc_1CDF
.text:00001CC4                 mov     edx, [ebp+var_4]
.text:00001CC7                 mov     eax, [edx]
.text:00001CC9                 mov     ecx, [ebp+var_4]
.text:00001CCC                 mov     edx, [ecx]
.text:00001CCE                 mov     eax, [eax]
.text:00001CD0                 mov     esi, esp
.text:00001CD2                 push    edx
.text:00001CD3                 mov     ecx, [eax+8]
.text:00001CD6                 call    ecx
.text:00001CD8                 cmp     esi, esp
.text:00001CDA                 call    __RTC_CheckEsp
.text:00001CDF
.text:00001CDF loc_1CDF:                               ; CODE XREF: CMyComPtr<IInStream>::operator=(IInStream *)+32j
.text:00001CDF                 mov     edx, [ebp+var_4]
.text:00001CE2                 mov     eax, [ebp+arg_0]
.text:00001CE5                 mov     [edx], eax
.text:00001CE7                 mov     eax, [ebp+arg_0]
.text:00001CEA                 pop     esi
.text:00001CEB                 add     esp, 4
.text:00001CEE                 cmp     ebp, esp
.text:00001CF0                 call    __RTC_CheckEsp
.text:00001CF5                 mov     esp, ebp
.text:00001CF7                 pop     ebp
.text:00001CF8                 retn    4
.text:00001CF8 ??4?$CMyComPtr@UIInStream@@@@QAEPAUIInStream@@PAU1@@Z endp
.text:00001CF8
.text:00001CF8 ; ---------------------------------------------------------------------------
.text:00001CFB                 align 4
.text:00001CFB _text           ends
.text:00001CFB
.text:00001CFC ; ===========================================================================
.text:00001CFC
.text:00001CFC ; Segment type: Pure code
.text:00001CFC ; Segment permissions: Read/Execute
.text:00001CFC _text           segment para public 'CODE' use32
.text:00001CFC                 assume cs:_text
.text:00001CFC                 ;org 1CFCh
.text:00001CFC ; COMDAT (pick any)
.text:00001CFC                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001CFC
.text:00001CFC ; =============== S U B R O U T I N E =======================================
.text:00001CFC
.text:00001CFC ; Attributes: bp-based frame
.text:00001CFC
.text:00001CFC ; public: unsigned int __thiscall CRecordVector<unsigned int>::Size(void)const
.text:00001CFC                 public ?Size@?$CRecordVector@I@@QBEIXZ
.text:00001CFC ?Size@?$CRecordVector@I@@QBEIXZ proc near
.text:00001CFC                                         ; CODE XREF: CClusterInStream::Read(void *,uint,uint *)+14Cp
.text:00001CFC
.text:00001CFC var_4           = dword ptr -4
.text:00001CFC
.text:00001CFC                 push    ebp
.text:00001CFD                 mov     ebp, esp
.text:00001CFF                 push    ecx
.text:00001D00                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001D07                 mov     [ebp+var_4], ecx
.text:00001D0A                 mov     eax, [ebp+var_4]
.text:00001D0D                 mov     eax, [eax+4]
.text:00001D10                 mov     esp, ebp
.text:00001D12                 pop     ebp
.text:00001D13                 retn
.text:00001D13 ?Size@?$CRecordVector@I@@QBEIXZ endp
.text:00001D13
.text:00001D13 _text           ends
.text:00001D13
.text:00001D14 ; ===========================================================================
.text:00001D14
.text:00001D14 ; Segment type: Pure code
.text:00001D14 ; Segment permissions: Read/Execute
.text:00001D14 _text           segment para public 'CODE' use32
.text:00001D14                 assume cs:_text
.text:00001D14                 ;org 1D14h
.text:00001D14 ; COMDAT (pick any)
.text:00001D14                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001D14
.text:00001D14 ; =============== S U B R O U T I N E =======================================
.text:00001D14
.text:00001D14 ; Attributes: bp-based frame
.text:00001D14
.text:00001D14 ; public: unsigned int & __thiscall CRecordVector<unsigned int>::operator[](unsigned int)
.text:00001D14                 public ??A?$CRecordVector@I@@QAEAAII@Z
.text:00001D14 ??A?$CRecordVector@I@@QAEAAII@Z proc near
.text:00001D14                                         ; CODE XREF: CClusterInStream::Read(void *,uint,uint *)+A6p
.text:00001D14                                         ; CClusterInStream::Read(void *,uint,uint *)+168p
.text:00001D14
.text:00001D14 var_4           = dword ptr -4
.text:00001D14 arg_0           = dword ptr  8
.text:00001D14
.text:00001D14                 push    ebp
.text:00001D15                 mov     ebp, esp
.text:00001D17                 push    ecx
.text:00001D18                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001D1F                 mov     [ebp+var_4], ecx
.text:00001D22                 mov     eax, [ebp+var_4]
.text:00001D25                 mov     ecx, [eax]
.text:00001D27                 mov     edx, [ebp+arg_0]
.text:00001D2A                 lea     eax, [ecx+edx*4]
.text:00001D2D                 mov     esp, ebp
.text:00001D2F                 pop     ebp
.text:00001D30                 retn    4
.text:00001D30 ??A?$CRecordVector@I@@QAEAAII@Z endp
.text:00001D30
.text:00001D30 ; ---------------------------------------------------------------------------
.text:00001D33                 align 4
.text:00001D33 _text           ends
.text:00001D33
.text:00001D34 ; ===========================================================================
.text:00001D34
.text:00001D34 ; Segment type: Pure code
.text:00001D34 ; Segment permissions: Read/Execute
.text:00001D34 _text           segment para public 'CODE' use32
.text:00001D34                 assume cs:_text
.text:00001D34                 ;org 1D34h
.text:00001D34 ; COMDAT (pick any)
.text:00001D34                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001D34
.text:00001D34 ; =============== S U B R O U T I N E =======================================
.text:00001D34
.text:00001D34 ; Attributes: bp-based frame
.text:00001D34
.text:00001D34 ; public: unsigned int __thiscall CRecordVector<struct CSeekExtent>::Size(void)const
.text:00001D34                 public ?Size@?$CRecordVector@UCSeekExtent@@@@QBEIXZ
.text:00001D34 ?Size@?$CRecordVector@UCSeekExtent@@@@QBEIXZ proc near
.text:00001D34                                         ; CODE XREF: CExtentsStream::Read(void *,uint,uint *)+79p
.text:00001D34
.text:00001D34 var_4           = dword ptr -4
.text:00001D34
.text:00001D34                 push    ebp
.text:00001D35                 mov     ebp, esp
.text:00001D37                 push    ecx
.text:00001D38                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001D3F                 mov     [ebp+var_4], ecx
.text:00001D42                 mov     eax, [ebp+var_4]
.text:00001D45                 mov     eax, [eax+4]
.text:00001D48                 mov     esp, ebp
.text:00001D4A                 pop     ebp
.text:00001D4B                 retn
.text:00001D4B ?Size@?$CRecordVector@UCSeekExtent@@@@QBEIXZ endp
.text:00001D4B
.text:00001D4B _text           ends
.text:00001D4B
.text:00001D4C ; ===========================================================================
.text:00001D4C
.text:00001D4C ; Segment type: Pure code
.text:00001D4C ; Segment permissions: Read/Execute
.text:00001D4C _text           segment para public 'CODE' use32
.text:00001D4C                 assume cs:_text
.text:00001D4C                 ;org 1D4Ch
.text:00001D4C ; COMDAT (pick any)
.text:00001D4C                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001D4C
.text:00001D4C ; =============== S U B R O U T I N E =======================================
.text:00001D4C
.text:00001D4C ; Attributes: bp-based frame
.text:00001D4C
.text:00001D4C ; public: struct CSeekExtent & __thiscall CRecordVector<struct CSeekExtent>::operator[](unsigned int)
.text:00001D4C                 public ??A?$CRecordVector@UCSeekExtent@@@@QAEAAUCSeekExtent@@I@Z
.text:00001D4C ??A?$CRecordVector@UCSeekExtent@@@@QAEAAUCSeekExtent@@I@Z proc near
.text:00001D4C                                         ; CODE XREF: CExtentsStream::Read(void *,uint,uint *)+A3p
.text:00001D4C                                         ; CExtentsStream::Read(void *,uint,uint *)+E9p ...
.text:00001D4C
.text:00001D4C var_4           = dword ptr -4
.text:00001D4C arg_0           = dword ptr  8
.text:00001D4C
.text:00001D4C                 push    ebp
.text:00001D4D                 mov     ebp, esp
.text:00001D4F                 push    ecx
.text:00001D50                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001D57                 mov     [ebp+var_4], ecx
.text:00001D5A                 mov     eax, [ebp+arg_0]
.text:00001D5D                 shl     eax, 4
.text:00001D60                 mov     ecx, [ebp+var_4]
.text:00001D63                 add     eax, [ecx]
.text:00001D65                 mov     esp, ebp
.text:00001D67                 pop     ebp
.text:00001D68                 retn    4
.text:00001D68 ??A?$CRecordVector@UCSeekExtent@@@@QAEAAUCSeekExtent@@I@Z endp
.text:00001D68
.text:00001D68 ; ---------------------------------------------------------------------------
.text:00001D6B                 align 4
.text:00001D6B _text           ends
.text:00001D6B
.text:00001D6C ; ===========================================================================
.text:00001D6C
.text:00001D6C ; Segment type: Pure code
.text:00001D6C ; Segment permissions: Read/Execute
.text:00001D6C _text           segment para public 'CODE' use32
.text:00001D6C                 assume cs:_text
.text:00001D6C                 ;org 1D6Ch
.text:00001D6C ; COMDAT (pick any)
.text:00001D6C                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001D6C
.text:00001D6C ; =============== S U B R O U T I N E =======================================
.text:00001D6C
.text:00001D6C ; Attributes: bp-based frame
.text:00001D6C
.text:00001D6C ; public: struct CSeekExtent & __thiscall CRecordVector<struct CSeekExtent>::Back(void)
.text:00001D6C                 public ?Back@?$CRecordVector@UCSeekExtent@@@@QAEAAUCSeekExtent@@XZ
.text:00001D6C ?Back@?$CRecordVector@UCSeekExtent@@@@QAEAAUCSeekExtent@@XZ proc near
.text:00001D6C                                         ; CODE XREF: CExtentsStream::Read(void *,uint,uint *)+2Cp
.text:00001D6C                                         ; CExtentsStream::Seek(__int64,uint,unsigned __int64 *)+44p
.text:00001D6C
.text:00001D6C var_4           = dword ptr -4
.text:00001D6C
.text:00001D6C                 push    ebp
.text:00001D6D                 mov     ebp, esp
.text:00001D6F                 push    ecx
.text:00001D70                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001D77                 mov     [ebp+var_4], ecx
.text:00001D7A                 mov     eax, [ebp+var_4]
.text:00001D7D                 mov     eax, [eax+4]
.text:00001D80                 sub     eax, 1
.text:00001D83                 shl     eax, 4
.text:00001D86                 mov     ecx, [ebp+var_4]
.text:00001D89                 add     eax, [ecx]
.text:00001D8B                 mov     esp, ebp
.text:00001D8D                 pop     ebp
.text:00001D8E                 retn
.text:00001D8E ?Back@?$CRecordVector@UCSeekExtent@@@@QAEAAUCSeekExtent@@XZ endp
.text:00001D8E
.text:00001D8E ; ---------------------------------------------------------------------------
.text:00001D8F                 align 10h
.text:00001D8F _text           ends
.text:00001D8F
.text:00001D90 ; ===========================================================================
.text:00001D90
.text:00001D90 ; Segment type: Pure code
.text:00001D90 ; Segment permissions: Read/Execute
.text:00001D90 _text           segment para public 'CODE' use32
.text:00001D90                 assume cs:_text
.text:00001D90                 ;org 1D90h
.text:00001D90 ; COMDAT (pick any)
.text:00001D90                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001D90
.text:00001D90 ; =============== S U B R O U T I N E =======================================
.text:00001D90
.text:00001D90 ; Attributes: bp-based frame
.text:00001D90
.text:00001D90 ; public: __thiscall CMyComPtr<struct ISequentialOutStream>::operator struct ISequentialOutStream *(void)const
.text:00001D90                 public ??B?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ
.text:00001D90 ??B?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ proc near
.text:00001D90                                         ; CODE XREF: CLimitedSequentialOutStream::Write(void const *,uint,uint *)+AEp
.text:00001D90
.text:00001D90 var_4           = dword ptr -4
.text:00001D90
.text:00001D90                 push    ebp
.text:00001D91                 mov     ebp, esp
.text:00001D93                 push    ecx
.text:00001D94                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001D9B                 mov     [ebp+var_4], ecx
.text:00001D9E                 mov     eax, [ebp+var_4]
.text:00001DA1                 mov     eax, [eax]
.text:00001DA3                 mov     esp, ebp
.text:00001DA5                 pop     ebp
.text:00001DA6                 retn
.text:00001DA6 ??B?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ endp
.text:00001DA6
.text:00001DA6 ; ---------------------------------------------------------------------------
.text:00001DA7                 align 4
.text:00001DA7 _text           ends
.text:00001DA7
.text:00001DA8 ; ===========================================================================
.text:00001DA8
.text:00001DA8 ; Segment type: Pure code
.text:00001DA8 ; Segment permissions: Read/Execute
.text:00001DA8 _text           segment para public 'CODE' use32
.text:00001DA8                 assume cs:_text
.text:00001DA8                 ;org 1DA8h
.text:00001DA8 ; COMDAT (pick any)
.text:00001DA8                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001DA8
.text:00001DA8 ; =============== S U B R O U T I N E =======================================
.text:00001DA8
.text:00001DA8 ; Attributes: bp-based frame
.text:00001DA8
.text:00001DA8 ; public: struct ISequentialOutStream * __thiscall CMyComPtr<struct ISequentialOutStream>::operator->(void)const
.text:00001DA8                 public ??C?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ
.text:00001DA8 ??C?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ proc near
.text:00001DA8                                         ; CODE XREF: CLimitedSequentialOutStream::Write(void const *,uint,uint *)+BDp
.text:00001DA8
.text:00001DA8 var_4           = dword ptr -4
.text:00001DA8
.text:00001DA8                 push    ebp
.text:00001DA9                 mov     ebp, esp
.text:00001DAB                 push    ecx
.text:00001DAC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001DB3                 mov     [ebp+var_4], ecx
.text:00001DB6                 mov     eax, [ebp+var_4]
.text:00001DB9                 mov     eax, [eax]
.text:00001DBB                 mov     esp, ebp
.text:00001DBD                 pop     ebp
.text:00001DBE                 retn
.text:00001DBE ??C?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ endp
.text:00001DBE
.text:00001DBE ; ---------------------------------------------------------------------------
.text:00001DBF                 align 10h
.text:00001DBF _text           ends
.text:00001DBF
.text:00001DC0 ; ===========================================================================
.text:00001DC0
.text:00001DC0 ; Segment type: Pure code
.text:00001DC0 ; Segment permissions: Read/Execute
.text:00001DC0 _text           segment para public 'CODE' use32
.text:00001DC0                 assume cs:_text
.text:00001DC0                 ;org 1DC0h
.text:00001DC0 ; COMDAT (pick any)
.text:00001DC0                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001DC0
.text:00001DC0 ; =============== S U B R O U T I N E =======================================
.text:00001DC0
.text:00001DC0 ; Attributes: bp-based frame
.text:00001DC0
.text:00001DC0 ; public: struct IOutStream * __thiscall CMyComPtr<struct IOutStream>::operator->(void)const
.text:00001DC0                 public ??C?$CMyComPtr@UIOutStream@@@@QBEPAUIOutStream@@XZ
.text:00001DC0 ??C?$CMyComPtr@UIOutStream@@@@QBEPAUIOutStream@@XZ proc near
.text:00001DC0                                         ; CODE XREF: CTailOutStream::Write(void const *,uint,uint *)+27p
.text:00001DC0                                         ; CTailOutStream::Seek(__int64,uint,unsigned __int64 *)+A7p ...
.text:00001DC0
.text:00001DC0 var_4           = dword ptr -4
.text:00001DC0
.text:00001DC0                 push    ebp
.text:00001DC1                 mov     ebp, esp
.text:00001DC3                 push    ecx
.text:00001DC4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001DCB                 mov     [ebp+var_4], ecx
.text:00001DCE                 mov     eax, [ebp+var_4]
.text:00001DD1                 mov     eax, [eax]
.text:00001DD3                 mov     esp, ebp
.text:00001DD5                 pop     ebp
.text:00001DD6                 retn
.text:00001DD6 ??C?$CMyComPtr@UIOutStream@@@@QBEPAUIOutStream@@XZ endp
.text:00001DD6
.text:00001DD6 ; ---------------------------------------------------------------------------
.text:00001DD7                 align 4
.text:00001DD7 _text           ends
.text:00001DD7
.text:00001DD8 ; ===========================================================================
.text:00001DD8
.text:00001DD8 ; Segment type: Pure code
.text:00001DD8 ; Segment permissions: Read/Execute
.text:00001DD8 _text           segment para public 'CODE' use32
.text:00001DD8                 assume cs:_text
.text:00001DD8                 ;org 1DD8h
.text:00001DD8 ; COMDAT (pick any)
.text:00001DD8                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00001DD8
.text:00001DD8 ; =============== S U B R O U T I N E =======================================
.text:00001DD8
.text:00001DD8 ; Attributes: bp-based frame
.text:00001DD8
.text:00001DD8 ; unsigned __int64 __stdcall MyMin<unsigned __int64>(unsigned __int64, unsigned __int64)
.text:00001DD8                 public ??$MyMin@_K@@YG_K_K0@Z
.text:00001DD8 ??$MyMin@_K@@YG_K_K0@Z proc near        ; CODE XREF: CLimitedSequentialInStream::Read(void *,uint,uint *)+40p
.text:00001DD8
.text:00001DD8 var_8           = dword ptr -8
.text:00001DD8 var_4           = dword ptr -4
.text:00001DD8 arg_0           = dword ptr  8
.text:00001DD8 arg_4           = dword ptr  0Ch
.text:00001DD8 arg_8           = dword ptr  10h
.text:00001DD8 arg_C           = dword ptr  14h
.text:00001DD8
.text:00001DD8                 push    ebp
.text:00001DD9                 mov     ebp, esp
.text:00001DDB                 sub     esp, 8
.text:00001DDE                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00001DE5                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001DEC                 mov     eax, [ebp+arg_4]
.text:00001DEF                 cmp     eax, [ebp+arg_C]
.text:00001DF2                 ja      short loc_1E0C
.text:00001DF4                 jb      short loc_1DFE
.text:00001DF6                 mov     ecx, [ebp+arg_0]
.text:00001DF9                 cmp     ecx, [ebp+arg_8]
.text:00001DFC                 jnb     short loc_1E0C
.text:00001DFE
.text:00001DFE loc_1DFE:                               ; CODE XREF: MyMin<unsigned __int64>(unsigned __int64,unsigned __int64)+1Cj
.text:00001DFE                 mov     edx, [ebp+arg_0]
.text:00001E01                 mov     [ebp+var_8], edx
.text:00001E04                 mov     eax, [ebp+arg_4]
.text:00001E07                 mov     [ebp+var_4], eax
.text:00001E0A                 jmp     short loc_1E18
.text:00001E0C ; ---------------------------------------------------------------------------
.text:00001E0C
.text:00001E0C loc_1E0C:                               ; CODE XREF: MyMin<unsigned __int64>(unsigned __int64,unsigned __int64)+1Aj
.text:00001E0C                                         ; MyMin<unsigned __int64>(unsigned __int64,unsigned __int64)+24j
.text:00001E0C                 mov     ecx, [ebp+arg_8]
.text:00001E0F                 mov     [ebp+var_8], ecx
.text:00001E12                 mov     edx, [ebp+arg_C]
.text:00001E15                 mov     [ebp+var_4], edx
.text:00001E18
.text:00001E18 loc_1E18:                               ; CODE XREF: MyMin<unsigned __int64>(unsigned __int64,unsigned __int64)+32j
.text:00001E18                 mov     eax, [ebp+var_8]
.text:00001E1B                 mov     edx, [ebp+var_4]
.text:00001E1E                 mov     esp, ebp
.text:00001E20                 pop     ebp
.text:00001E21                 retn    10h
.text:00001E21 ??$MyMin@_K@@YG_K_K0@Z endp
.text:00001E21
.text:00001E21 _text           ends
.text:00001E21
UNDEF:00001E30 ; ===========================================================================
UNDEF:00001E30
UNDEF:00001E30 ; Segment type: Externs
UNDEF:00001E30 ; UNDEF
UNDEF:00001E30 ; __fastcall _RTC_CheckStackVars(x, x)
UNDEF:00001E30                 extrn @_RTC_CheckStackVars@8:near
UNDEF:00001E30                                         ; CODE XREF: CLimitedSequentialInStream::Read(void *,uint,uint *)+C8p
UNDEF:00001E30                                         ; CreateLimitedInStream(IInStream *,unsigned __int64,unsigned __int64,ISequentialInStream * *)+111p ...
UNDEF:00001E34                 extrn __RTC_CheckEsp:near
UNDEF:00001E34                                         ; CODE XREF: CLimitedSequentialInStream::Read(void *,uint,uint *)+81p
UNDEF:00001E34                                         ; CLimitedSequentialInStream::Read(void *,uint,uint *)+D5p ...
UNDEF:00001E38                 extrn __RTC_Shutdown:near
UNDEF:00001E38                                         ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
UNDEF:00001E3C                 extrn __RTC_InitBase:near
UNDEF:00001E3C                                         ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
UNDEF:00001E40 ; void __cdecl operator delete(void *)
UNDEF:00001E40                 extrn ??3@YAXPAX@Z:near ; CODE XREF: __unwindfunclet$?CreateLimitedInStream@@YGJPAUIInStream@@_K1PAPAUISequentialInStream@@@Z$0+4p
UNDEF:00001E40                                         ; CLimitedInStream::`scalar deleting destructor'(uint)+22p
UNDEF:00001E44 ; void *__cdecl operator new(unsigned int)
UNDEF:00001E44                 extrn ??2@YAPAXI@Z:near ; CODE XREF: CreateLimitedInStream(IInStream *,unsigned __int64,unsigned __int64,ISequentialInStream * *)+40p
UNDEF:00001E48                 extrn ___security_cookie:near
UNDEF:00001E48                                         ; DATA XREF: CreateLimitedInStream(IInStream *,unsigned __int64,unsigned __int64,ISequentialInStream * *)+24r
UNDEF:00001E4C                 extrn ___CxxFrameHandler3:near
UNDEF:00001E4C                                         ; CODE XREF: __ehhandler$?CreateLimitedInStream@@YGJPAUIInStream@@_K1PAPAUISequentialInStream@@@Z+16j
UNDEF:00001E50 ; __fastcall __security_check_cookie(x)
UNDEF:00001E50                 extrn @__security_check_cookie@4:near
UNDEF:00001E50                                         ; CODE XREF: __ehhandler$?CreateLimitedInStream@@YGJPAUIInStream@@_K1PAPAUISequentialInStream@@@Z+Cp
UNDEF:00001E54 ; const type_info::`vftable'
UNDEF:00001E54                 extrn ??_7type_info@@6B@:near
UNDEF:00001E54                                         ; DATA XREF: .data:CLimitedInStream `RTTI Type Descriptor'o
UNDEF:00001E54                                         ; .data:IInStream `RTTI Type Descriptor'o ...
UNDEF:00001E58                 extrn _IID_IInStream:near
UNDEF:00001E58                                         ; DATA XREF: CLimitedInStream::QueryInterface(_GUID const &,void * *):loc_17D4o
UNDEF:00001E5C                 extrn _IID_ISequentialInStream:near
UNDEF:00001E5C                                         ; DATA XREF: CLimitedInStream::QueryInterface(_GUID const &,void * *):loc_17B8o
UNDEF:00001E60 ; const IID IID_IUnknown
UNDEF:00001E60                 extrn _IID_IUnknown:near
UNDEF:00001E60                                         ; DATA XREF: CLimitedInStream::QueryInterface(_GUID const &,void * *)+Co
UNDEF:00001E64 ; int __cdecl memcmp(const void *Buf1, const void *Buf2, size_t Size)
UNDEF:00001E64                 extrn _memcmp:near      ; CODE XREF: IsEqualGUID(x,x)+Dp
UNDEF:00001E68                 extrn __purecall:near   ; DATA XREF: .rdata:const IInStream::`vftable'o
UNDEF:00001E68                                         ; .rdata:00001998o ...
UNDEF:00001E6C                 extrn __allshl:near     ; CODE XREF: CClusterInStream::Read(void *,uint,uint *)+BBp
UNDEF:00001E70                 extrn __aullshr:near    ; CODE XREF: CClusterInStream::Read(void *,uint,uint *)+83p
UNDEF:00001E74 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:00001E74                 extrn _memcpy:near      ; CODE XREF: CLimitedCachedInStream::Read(void *,uint,uint *)+131p
UNDEF:00001E74
UNDEF:00001E74