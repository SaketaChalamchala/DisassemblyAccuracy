.rdata:00000000 ;
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.rdata:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.rdata:00000000 ; |                      License info: 48-3677-7074-51                      |
.rdata:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ;
.rdata:00000000 ; Input MD5   : 6919E5B6BB97A939D811136602F42D86
.rdata:00000000 ; Input CRC32 : 87B95C1D
.rdata:00000000
.rdata:00000000 ; File Name   : C:\workspace\7z1505-src\CPP\7zip\Bundles\Alone\Debug\Bench.obj
.rdata:00000000 ; Format      : COFF (X386MAGIC)
.rdata:00000000 ; includelib "uuid.lib"
.rdata:00000000 ; includelib "MSVCRTD"
.rdata:00000000 ; includelib "OLDNAMES"
.rdata:00000000
.rdata:00000000                 .686p
.rdata:00000000                 .mmx
.rdata:00000000                 .model flat
.rdata:00000000
.rdata:00000000 ; ===========================================================================
.rdata:00000000
.rdata:00000000 ; Segment type: Pure data
.rdata:00000000 ; Segment permissions: Read
.rdata:00000000 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00000000 _rdata          segment para public 'DATA' use32
.rdata:00000000                 assume cs:_rdata
.rdata:00000000 $SG70848        db 'LZMA:x1',0          ; DATA XREF: .rdata:000000DCo
.rdata:00000008 $SG70849        db 'LZMA:x5:mt1',0      ; DATA XREF: .rdata:000000F4o
.rdata:00000014 $SG70850        db 'LZMA:x5:mt2',0      ; DATA XREF: .rdata:0000010Co
.rdata:00000020 $SG70851        db  44h ; D             ; DATA XREF: .rdata:00000124o
.rdata:00000020                                         ; .text:00003E3Co
.rdata:00000021                 db  65h ; e
.rdata:00000022                 db  66h ; f
.rdata:00000023                 db  6Ch ; l
.rdata:00000024 unk_24          db  61h ; a             ; DATA XREF: .text:00007008o
.rdata:00000025 unk_25          db  74h ; t             ; DATA XREF: .rdata:$SG71700o
.rdata:00000025                                         ; .rdata:$SG71704o ...
.rdata:00000026                 db  65h ; e
.rdata:00000027                 db  3Ah ; :
.rdata:00000028 off_28          dd offset loc_3178      ; DATA XREF: .rdata:_g_Bencho
.rdata:00000028                                         ; .rdata:$SG71518o ...
.rdata:0000002C $SG70852        db 'Deflate:x5',0       ; DATA XREF: .rdata:0000013Co
.rdata:00000037                 align 4
.rdata:00000038 $SG70853        db 'Deflate:x7',0       ; DATA XREF: .rdata:00000154o
.rdata:00000038                                         ; .xdata$x:__catchsym$?EncodeThreadFunction@CEncoderInfo@@SGIPAX@Z$2o
.rdata:00000043                 align 4
.rdata:00000044 $SG70854        db 'Deflate64:x5',0     ; DATA XREF: .rdata:0000016Co
.rdata:00000044                                         ; .rdata:000000E0o ...
.rdata:00000051                 align 4
.rdata:00000054 $SG70855        db 'BZip2:x1',0         ; DATA XREF: .rdata:00000184o
.rdata:0000005D                 align 10h
.rdata:00000060 $SG70856        db  42h ; B             ; DATA XREF: .rdata:0000019Co
.rdata:00000061                 db  5Ah ; Z
.rdata:00000062                 db  69h ; i
.rdata:00000063                 db  70h ; p
.rdata:00000064 a2X5            db '2:x5',0             ; DATA XREF: .rdata:$SG71777o
.rdata:00000069                 align 4
.rdata:0000006C $SG70857        db 'BZip2:x5:mt2',0     ; DATA XREF: .rdata:000001B4o
.rdata:00000079                 align 4
.rdata:0000007C $SG70858        db 'BZip2:x7',0         ; DATA XREF: .rdata:000001CCo
.rdata:00000085                 align 4
.rdata:00000088 $SG70859        db 'PPMD:x1',0          ; DATA XREF: .rdata:000001E4o
.rdata:00000090 $SG70860        db 'PPMD:x5',0          ; DATA XREF: .rdata:000001FCo
.rdata:00000098 $SG70861        db 'Delta:4',0          ; DATA XREF: .rdata:00000214o
.rdata:000000A0 $SG70862        db 'BCJ',0              ; DATA XREF: .rdata:0000022Co
.rdata:000000A4 $SG70863        db 'AES256CBC:1',0      ; DATA XREF: .rdata:00000244o
.rdata:000000B0 $SG70864        db 'AES256CBC:2',0      ; DATA XREF: .rdata:0000025Co
.rdata:000000BC $SG70993        db ' MB,  # ',0         ; DATA XREF: PrintRequirements(IBenchPrintCallback &,char const *,unsigned __int64,char const *,uint)+53o
.rdata:000000C5                 align 4
.rdata:000000C8 _g_Bench        dd offset off_28        ; DATA XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+18DEo
.rdata:000000C8                                         ; TotalBench(unsigned __int64,uint,bool,uint,IBenchPrintCallback *,CBenchCallbackToPrint *)+5Ao
.rdata:000000CC                 db  11h
.rdata:000000CD                 db    0
.rdata:000000CE                 db    0
.rdata:000000CF                 db    0
.rdata:000000D0                 db  65h ; e
.rdata:000000D1                 db    1
.rdata:000000D2                 db    0
.rdata:000000D3                 db    0
.rdata:000000D4                 db  91h ; æ
.rdata:000000D5                 db    0
.rdata:000000D6                 db    0
.rdata:000000D7                 db    0
.rdata:000000D8                 db  14h
.rdata:000000D9                 db    0
.rdata:000000DA                 db    0
.rdata:000000DB                 db    0
.rdata:000000DC                 dd offset $SG70848      ; "LZMA:x1"
.rdata:000000E0                 dd offset $SG70854+0Ch  ; ""
.rdata:000000E4                 db  18h
.rdata:000000E5                 db    0
.rdata:000000E6                 db    0
.rdata:000000E7                 db    0
.rdata:000000E8                 db 0C4h ; -
.rdata:000000E9                 db    4
.rdata:000000EA                 db    0
.rdata:000000EB                 db    0
.rdata:000000EC                 db  91h ; æ
.rdata:000000ED                 db    0
.rdata:000000EE                 db    0
.rdata:000000EF                 db    0
.rdata:000000F0                 db  14h
.rdata:000000F1                 db    0
.rdata:000000F2                 db    0
.rdata:000000F3                 db    0
.rdata:000000F4                 dd offset $SG70849      ; "LZMA:x5:mt1"
.rdata:000000F8                 dd offset $SG70854+0Ch  ; ""
.rdata:000000FC                 db  18h
.rdata:000000FD                 db    0
.rdata:000000FE                 db    0
.rdata:000000FF                 db    0
.rdata:00000100                 db 0C4h ; -
.rdata:00000101                 db    4
.rdata:00000102                 db    0
.rdata:00000103                 db    0
.rdata:00000104                 db  91h ; æ
.rdata:00000105                 db    0
.rdata:00000106                 db    0
.rdata:00000107                 db    0
.rdata:00000108                 db  14h
.rdata:00000109                 db    0
.rdata:0000010A                 db    0
.rdata:0000010B                 db    0
.rdata:0000010C                 dd offset $SG70850      ; "LZMA:x5:mt2"
.rdata:00000110                 db  0Ah
.rdata:00000111                 db    0
.rdata:00000112                 db    0
.rdata:00000113                 db    0
.rdata:00000114                 db  10h
.rdata:00000115                 db    0
.rdata:00000116                 db    0
.rdata:00000117                 db    0
.rdata:00000118                 db  7Ch ; |
.rdata:00000119                 db    0
.rdata:0000011A                 db    0
.rdata:0000011B                 db    0
.rdata:0000011C                 db  28h ; (
.rdata:0000011D                 db    0
.rdata:0000011E                 db    0
.rdata:0000011F                 db    0
.rdata:00000120                 db  0Eh
.rdata:00000121                 db    0
.rdata:00000122                 db    0
.rdata:00000123                 db    0
.rdata:00000124                 dd offset $SG70851
.rdata:00000128                 db  14h
.rdata:00000129                 db    0
.rdata:0000012A                 db    0
.rdata:0000012B                 db    0
.rdata:0000012C                 db  10h
.rdata:0000012D                 db    0
.rdata:0000012E                 db    0
.rdata:0000012F                 db    0
.rdata:00000130                 db  78h ; x
.rdata:00000131                 db    1
.rdata:00000132                 db    0
.rdata:00000133                 db    0
.rdata:00000134                 db  28h ; (
.rdata:00000135                 db    0
.rdata:00000136                 db    0
.rdata:00000137                 db    0
.rdata:00000138                 db  0Eh
.rdata:00000139                 db    0
.rdata:0000013A                 db    0
.rdata:0000013B                 db    0
.rdata:0000013C                 dd offset $SG70852      ; "Deflate:x5"
.rdata:00000140                 db  0Ah
.rdata:00000141                 db    0
.rdata:00000142                 db    0
.rdata:00000143                 db    0
.rdata:00000144                 db  10h
.rdata:00000145                 db    0
.rdata:00000146                 db    0
.rdata:00000147                 db    0
.rdata:00000148                 db  3Ah ; :
.rdata:00000149                 db    4
.rdata:0000014A                 db    0
.rdata:0000014B                 db    0
.rdata:0000014C                 db  28h ; (
.rdata:0000014D                 db    0
.rdata:0000014E                 db    0
.rdata:0000014F                 db    0
.rdata:00000150                 db  0Eh
.rdata:00000151                 db    0
.rdata:00000152                 db    0
.rdata:00000153                 db    0
.rdata:00000154                 dd offset $SG70853      ; "Deflate:x7"
.rdata:00000158                 db  0Ah
.rdata:00000159                 db    0
.rdata:0000015A                 db    0
.rdata:0000015B                 db    0
.rdata:0000015C                 db  11h
.rdata:0000015D                 db    0
.rdata:0000015E                 db    0
.rdata:0000015F                 db    0
.rdata:00000160                 db 0A6h ; ª
.rdata:00000161                 db    1
.rdata:00000162                 db    0
.rdata:00000163                 db    0
.rdata:00000164                 db  28h ; (
.rdata:00000165                 db    0
.rdata:00000166                 db    0
.rdata:00000167                 db    0
.rdata:00000168                 db  0Eh
.rdata:00000169                 db    0
.rdata:0000016A                 db    0
.rdata:0000016B                 db    0
.rdata:0000016C                 dd offset $SG70854      ; "Deflate64:x5"
.rdata:00000170                 db  0Ah
.rdata:00000171                 db    0
.rdata:00000172                 db    0
.rdata:00000173                 db    0
.rdata:00000174                 db  0Fh
.rdata:00000175                 db    0
.rdata:00000176                 db    0
.rdata:00000177                 db    0
.rdata:00000178                 db  4Eh ; N
.rdata:00000179                 db    2
.rdata:0000017A                 db    0
.rdata:0000017B                 db    0
.rdata:0000017C                 db  45h ; E
.rdata:0000017D                 db    0
.rdata:0000017E                 db    0
.rdata:0000017F                 db    0
.rdata:00000180                 db  45h ; E
.rdata:00000181                 db    0
.rdata:00000182                 db    0
.rdata:00000183                 db    0
.rdata:00000184                 dd offset $SG70855      ; "BZip2:x1"
.rdata:00000188                 db  14h
.rdata:00000189                 db    0
.rdata:0000018A                 db    0
.rdata:0000018B                 db    0
.rdata:0000018C                 db  13h
.rdata:0000018D                 db    0
.rdata:0000018E                 db    0
.rdata:0000018F                 db    0
.rdata:00000190                 db  2Fh ; /
.rdata:00000191                 db    3
.rdata:00000192                 db    0
.rdata:00000193                 db    0
.rdata:00000194                 db  7Ah ; z
.rdata:00000195                 db    0
.rdata:00000196                 db    0
.rdata:00000197                 db    0
.rdata:00000198                 db  7Ah ; z
.rdata:00000199                 db    0
.rdata:0000019A                 db    0
.rdata:0000019B                 db    0
.rdata:0000019C                 dd offset $SG70856
.rdata:000001A0                 db  0Ah
.rdata:000001A1                 db    0
.rdata:000001A2                 db    0
.rdata:000001A3                 db    0
.rdata:000001A4                 db  13h
.rdata:000001A5                 db    0
.rdata:000001A6                 db    0
.rdata:000001A7                 db    0
.rdata:000001A8                 db  2Fh ; /
.rdata:000001A9                 db    3
.rdata:000001AA                 db    0
.rdata:000001AB                 db    0
.rdata:000001AC                 db  7Ah ; z
.rdata:000001AD                 db    0
.rdata:000001AE                 db    0
.rdata:000001AF                 db    0
.rdata:000001B0                 db  7Ah ; z
.rdata:000001B1                 db    0
.rdata:000001B2                 db    0
.rdata:000001B3                 db    0
.rdata:000001B4                 dd offset $SG70857      ; "BZip2:x5:mt2"
.rdata:000001B8                 db  0Ah
.rdata:000001B9                 db    0
.rdata:000001BA                 db    0
.rdata:000001BB                 db    0
.rdata:000001BC                 db  13h
.rdata:000001BD                 db    0
.rdata:000001BE                 db    0
.rdata:000001BF                 db    0
.rdata:000001C0                 db 0E2h ; G
.rdata:000001C1                 db    9
.rdata:000001C2                 db    0
.rdata:000001C3                 db    0
.rdata:000001C4                 db  7Ah ; z
.rdata:000001C5                 db    0
.rdata:000001C6                 db    0
.rdata:000001C7                 db    0
.rdata:000001C8                 db  7Ah ; z
.rdata:000001C9                 db    0
.rdata:000001CA                 db    0
.rdata:000001CB                 db    0
.rdata:000001CC                 dd offset $SG70858      ; "BZip2:x7"
.rdata:000001D0                 db  0Ah
.rdata:000001D1                 db    0
.rdata:000001D2                 db    0
.rdata:000001D3                 db    0
.rdata:000001D4                 db  12h
.rdata:000001D5                 db    0
.rdata:000001D6                 db    0
.rdata:000001D7                 db    0
.rdata:000001D8                 db 0F2h ; =
.rdata:000001D9                 db    3
.rdata:000001DA                 db    0
.rdata:000001DB                 db    0
.rdata:000001DC                 db    0
.rdata:000001DD                 db    0
.rdata:000001DE                 db    0
.rdata:000001DF                 db    0
.rdata:000001E0                 db  7Eh ; ~
.rdata:000001E1                 db    4
.rdata:000001E2                 db    0
.rdata:000001E3                 db    0
.rdata:000001E4                 dd offset $SG70859      ; "PPMD:x1"
.rdata:000001E8                 db  0Ah
.rdata:000001E9                 db    0
.rdata:000001EA                 db    0
.rdata:000001EB                 db    0
.rdata:000001EC                 db  16h
.rdata:000001ED                 db    0
.rdata:000001EE                 db    0
.rdata:000001EF                 db    0
.rdata:000001F0                 db  77h ; w
.rdata:000001F1                 db    6
.rdata:000001F2                 db    0
.rdata:000001F3                 db    0
.rdata:000001F4                 db    0
.rdata:000001F5                 db    0
.rdata:000001F6                 db    0
.rdata:000001F7                 db    0
.rdata:000001F8                 db  26h ; &
.rdata:000001F9                 db    7
.rdata:000001FA                 db    0
.rdata:000001FB                 db    0
.rdata:000001FC                 dd offset $SG70860      ; "PPMD:x5"
.rdata:00000200                 db    2
.rdata:00000201                 db    0
.rdata:00000202                 db    0
.rdata:00000203                 db    0
.rdata:00000204                 db    0
.rdata:00000205                 db    0
.rdata:00000206                 db    0
.rdata:00000207                 db    0
.rdata:00000208                 db    6
.rdata:00000209                 db    0
.rdata:0000020A                 db    0
.rdata:0000020B                 db    0
.rdata:0000020C                 db    0
.rdata:0000020D                 db    0
.rdata:0000020E                 db    0
.rdata:0000020F                 db    0
.rdata:00000210                 db    6
.rdata:00000211                 db    0
.rdata:00000212                 db    0
.rdata:00000213                 db    0
.rdata:00000214                 dd offset $SG70861      ; "Delta:4"
.rdata:00000218                 db    2
.rdata:00000219                 db    0
.rdata:0000021A                 db    0
.rdata:0000021B                 db    0
.rdata:0000021C                 db    0
.rdata:0000021D                 db    0
.rdata:0000021E                 db    0
.rdata:0000021F                 db    0
.rdata:00000220                 db    4
.rdata:00000221                 db    0
.rdata:00000222                 db    0
.rdata:00000223                 db    0
.rdata:00000224                 db    0
.rdata:00000225                 db    0
.rdata:00000226                 db    0
.rdata:00000227                 db    0
.rdata:00000228                 db    4
.rdata:00000229                 db    0
.rdata:0000022A                 db    0
.rdata:0000022B                 db    0
.rdata:0000022C                 dd offset $SG70862      ; "BCJ"
.rdata:00000230                 db  0Ah
.rdata:00000231                 db    0
.rdata:00000232                 db    0
.rdata:00000233                 db    0
.rdata:00000234                 db    0
.rdata:00000235                 db    0
.rdata:00000236                 db    0
.rdata:00000237                 db    0
.rdata:00000238                 db  18h
.rdata:00000239                 db    0
.rdata:0000023A                 db    0
.rdata:0000023B                 db    0
.rdata:0000023C                 db    0
.rdata:0000023D                 db    0
.rdata:0000023E                 db    0
.rdata:0000023F                 db    0
.rdata:00000240                 db  18h
.rdata:00000241                 db    0
.rdata:00000242                 db    0
.rdata:00000243                 db    0
.rdata:00000244                 dd offset $SG70863      ; "AES256CBC:1"
.rdata:00000248                 db    2
.rdata:00000249                 db    0
.rdata:0000024A                 db    0
.rdata:0000024B                 db    0
.rdata:0000024C                 db    0
.rdata:0000024D                 db    0
.rdata:0000024E                 db    0
.rdata:0000024F                 db    0
.rdata:00000250                 db    8
.rdata:00000251                 db    0
.rdata:00000252                 db    0
.rdata:00000253                 db    0
.rdata:00000254                 db    0
.rdata:00000255                 db    0
.rdata:00000256                 db    0
.rdata:00000257                 db    0
.rdata:00000258                 db    2
.rdata:00000259                 db    0
.rdata:0000025A                 db    0
.rdata:0000025B                 db    0
.rdata:0000025C                 dd offset $SG70864      ; "AES256CBC:2"
.rdata:00000260 $SG70877        db 'CRC32:1',0          ; DATA XREF: .rdata:0000029Co
.rdata:00000268 $SG70878        db 'CRC32:4',0          ; DATA XREF: .rdata:000002ACo
.rdata:00000270 $SG70879        db 'CRC32:8',0          ; DATA XREF: .rdata:000002BCo
.rdata:00000278 $SG70880        db 'CRC64',0            ; DATA XREF: .rdata:000002CCo
.rdata:0000027E                 align 10h
.rdata:00000280 $SG70881        db 'SHA256',0           ; DATA XREF: .rdata:000002DCo
.rdata:00000287                 align 4
.rdata:00000288 $SG70882        db 'SHA1',0             ; DATA XREF: .rdata:000002ECo
.rdata:0000028D                 align 10h
.rdata:00000290 _g_Hash         db    1                 ; DATA XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+90Bo
.rdata:00000290                                         ; TotalBench_Hash(unsigned __int64,uint,uint,IBenchPrintCallback *,CBenchCallbackToPrint *,CTotalBenchRes *,bool,unsigned __int64)+5Do
.rdata:00000291                 db    0
.rdata:00000292                 db    0
.rdata:00000293                 db    0
.rdata:00000294                 db  1Ch
.rdata:00000295                 db    7
.rdata:00000296                 db    0
.rdata:00000297                 db    0
.rdata:00000298                 db 0ABh ; ½
.rdata:00000299                 db 0EDh ; f
.rdata:0000029A                 db  8Fh ; Å
.rdata:0000029B                 db  8Fh ; Å
.rdata:0000029C                 dd offset $SG70877      ; "CRC32:1"
.rdata:000002A0                 db  0Ah
.rdata:000002A1                 db    0
.rdata:000002A2                 db    0
.rdata:000002A3                 db    0
.rdata:000002A4                 db  2Eh ; .
.rdata:000002A5                 db    2
.rdata:000002A6                 db    0
.rdata:000002A7                 db    0
.rdata:000002A8                 db 0ABh ; ½
.rdata:000002A9                 db 0EDh ; f
.rdata:000002AA                 db  8Fh ; Å
.rdata:000002AB                 db  8Fh ; Å
.rdata:000002AC                 dd offset $SG70878      ; "CRC32:4"
.rdata:000002B0                 db  0Ah
.rdata:000002B1                 db    0
.rdata:000002B2                 db    0
.rdata:000002B3                 db    0
.rdata:000002B4                 db  53h ; S
.rdata:000002B5                 db    1
.rdata:000002B6                 db    0
.rdata:000002B7                 db    0
.rdata:000002B8                 db 0ABh ; ½
.rdata:000002B9                 db 0EDh ; f
.rdata:000002BA                 db  8Fh ; Å
.rdata:000002BB                 db  8Fh ; Å
.rdata:000002BC                 dd offset $SG70879      ; "CRC32:8"
.rdata:000002C0                 db  0Ah
.rdata:000002C1                 db    0
.rdata:000002C2                 db    0
.rdata:000002C3                 db    0
.rdata:000002C4                 db    0
.rdata:000002C5                 db    2
.rdata:000002C6                 db    0
.rdata:000002C7                 db    0
.rdata:000002C8                 db 0CCh ; ¦
.rdata:000002C9                 db  17h
.rdata:000002CA                 db  1Ch
.rdata:000002CB                 db 0DFh ; ¯
.rdata:000002CC                 dd offset $SG70880      ; "CRC64"
.rdata:000002D0                 db  0Ah
.rdata:000002D1                 db    0
.rdata:000002D2                 db    0
.rdata:000002D3                 db    0
.rdata:000002D4                 db 0ECh ; 8
.rdata:000002D5                 db  13h
.rdata:000002D6                 db    0
.rdata:000002D7                 db    0
.rdata:000002D8                 db  2Eh ; .
.rdata:000002D9                 db 0FFh
.rdata:000002DA                 db  79h ; y
.rdata:000002DB                 db  2Dh ; -
.rdata:000002DC                 dd offset $SG70881      ; "SHA256"
.rdata:000002E0                 db  0Ah
.rdata:000002E1                 db    0
.rdata:000002E2                 db    0
.rdata:000002E3                 db    0
.rdata:000002E4                 db  24h ; $
.rdata:000002E5                 db    9
.rdata:000002E6                 db    0
.rdata:000002E7                 db    0
.rdata:000002E8                 db  2Bh ; +
.rdata:000002E9                 db  13h
.rdata:000002EA                 db  25h ; %
.rdata:000002EB                 db  4Ch ; L
.rdata:000002EC                 dd offset $SG70882      ; "SHA1"
.rdata:000002F0 $SG70992        db 'RAM ',0             ; DATA XREF: PrintRequirements(IBenchPrintCallback &,char const *,unsigned __int64,char const *,uint)+6o
.rdata:000002F5                 align 4
.rdata:000002F8 $SG71051        db '  | ',0             ; DATA XREF: .data:_kSepo
.rdata:000002FD                 align 10h
.rdata:00000300 $SG71417        db 'x86',0              ; DATA XREF: GetCpuName(AString &):loc_3C44o
.rdata:00000304 ; char _SG71508[]
.rdata:00000304 $SG71508        db 'testtime',0         ; DATA XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool):loc_3FEBo
.rdata:0000030D                 align 10h
.rdata:00000310 $SG71511        db    0                 ; DATA XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+136o
.rdata:00000311                 db    0
.rdata:00000312                 db    0
.rdata:00000313                 db    0
.rdata:00000314 ; char _SG71515[]
.rdata:00000314 $SG71515        dd offset loc_746B+2    ; DATA XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool):loc_40ADo
.rdata:00000318 ; wchar_t _SG71518
.rdata:00000318 $SG71518        dd offset off_28+2      ; DATA XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+215o
.rdata:0000031C ; wchar_t _SG71521
.rdata:0000031C $SG71521        dd offset off_28+2      ; DATA XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+27Do
.rdata:00000320 $SG71531        db 'CPU Freq:',0        ; DATA XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+465o
.rdata:0000032A                 align 4
.rdata:0000032C $SG71555        db 'CPU hardware threads:',0
.rdata:0000032C                                         ; DATA XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+6F4o
.rdata:00000342                 align 4
.rdata:00000344 $SG71556        db 'size: ',0           ; DATA XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+701o
.rdata:0000034B                 align 4
.rdata:0000034C $SG71564        db 'LZMA',0             ; DATA XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+766o
.rdata:00000351                 align 4
.rdata:00000354 ; char _SG71572[]
.rdata:00000354 $SG71572        db 'CRC',0              ; DATA XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+81Bo
.rdata:00000358 $SG71573        db 'crc32',0            ; DATA XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+832o
.rdata:0000035E                 align 10h
.rdata:00000360 $SG71594        db 'Size',0             ; DATA XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+A4Co
.rdata:00000365                 align 4
.rdata:00000368 $SG71634        db 'Avg:',0             ; DATA XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+EC7o
.rdata:0000036D                 align 10h
.rdata:00000370 ; char _SG71643[]
.rdata:00000370 $SG71643        dd offset off_28+2      ; DATA XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+FB4o
.rdata:00000374 $SG71669        db 'Benchmark threads:   ',0
.rdata:00000374                                         ; DATA XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1168o
.rdata:0000038A                 align 4
.rdata:0000038C $SG71670        db 'usage:',0           ; DATA XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1182o
.rdata:00000393                 align 4
.rdata:00000394 ; char _SG71679[]
.rdata:00000394 $SG71679        db 'Compressing',0      ; DATA XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1260o
.rdata:000003A0 ; char _SG71680[]
.rdata:000003A0 $SG71680        db 'Decompressing',0    ; DATA XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+129Ao
.rdata:000003AE                 align 10h
.rdata:000003B0 $SG71681        db 'Method',0           ; DATA XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+12D2o
.rdata:000003B7                 align 4
.rdata:000003B8 $SG71682        db 'Dict',0             ; DATA XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool):loc_51AEo
.rdata:000003BD                 align 10h
.rdata:000003C0 ; char _SG71687[]
.rdata:000003C0 $SG71687        db 'Speed',0            ; DATA XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+132Co
.rdata:000003C6                 align 4
.rdata:000003C8 ; char _SG71688[]
.rdata:000003C8 $SG71688        db 'Usage',0            ; DATA XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+133Fo
.rdata:000003CE                 align 10h
.rdata:000003D0 ; char _SG71689[]
.rdata:000003D0 $SG71689        db 'R/U',0              ; DATA XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1352o
.rdata:000003D4 ; char _SG71690[]
.rdata:000003D4 $SG71690        db 'Rating',0           ; DATA XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1365o
.rdata:000003DB                 align 4
.rdata:000003DC ; char _SG71692[]
.rdata:000003DC $SG71692        db 'E/U',0              ; DATA XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1383o
.rdata:000003E0 ; char _SG71693[]
.rdata:000003E0 $SG71693        db 'Effec',0            ; DATA XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1396o
.rdata:000003E6                 align 4
.rdata:000003E8 ; char _SG71699[]
.rdata:000003E8 $SG71699        db 'KiB/s',0            ; DATA XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+143Do
.rdata:000003EE                 align 10h
.rdata:000003F0 ; char _SG71700[]
.rdata:000003F0 $SG71700        dd offset unk_25        ; DATA XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1450o
.rdata:000003F4 ; char _SG71701[]
.rdata:000003F4 $SG71701        db 'MIPS',0             ; DATA XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1463o
.rdata:000003F9                 align 4
.rdata:000003FC ; char _SG71702[]
.rdata:000003FC $SG71702        db 'MIPS',0             ; DATA XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1476o
.rdata:00000401                 align 4
.rdata:00000404 ; char _SG71704[]
.rdata:00000404 $SG71704        dd offset unk_25        ; DATA XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1494o
.rdata:00000408 ; char _SG71705[]
.rdata:00000408 $SG71705        dd offset unk_25        ; DATA XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+14A7o
.rdata:0000040C ; char _SG71722[4]
.rdata:0000040C $SG71722        db 'CPU',0              ; DATA XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+15CDo
.rdata:00000410 ; char _SG71734[4]
.rdata:00000410 $SG71734        db 'CPU',0              ; DATA XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+17DBo
.rdata:00000414 ; char _SG71743[]
.rdata:00000414 $SG71743        db 'LZMA',0             ; DATA XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1892o
.rdata:00000419                 align 4
.rdata:0000041C ; char _SG71772[]
.rdata:0000041C $SG71772        db 'LZMA',0             ; DATA XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1AC9o
.rdata:00000421                 align 4
.rdata:00000424 $SG71777        dd offset a2X5          ; DATA XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1B00o
.rdata:00000424                                         ; "2:x5"
.rdata:00000428 ; char _SG71789[]
.rdata:00000428 $SG71789        db 'Avr:',0             ; DATA XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1D51o
.rdata:0000042D                 align 10h
.rdata:00000430 ; char _SG71790[]
.rdata:00000430 $SG71790        db 'Tot:',0             ; DATA XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1DF9o
.rdata:00000435                 align 4
.rdata:00000435 _rdata          ends
.rdata:00000435
.data:00000438 ; ===========================================================================
.data:00000438
.data:00000438 ; Segment type: Pure data
.data:00000438 ; Segment permissions: Read/Write
.data:00000438 _data           segment dword public 'DATA' use32
.data:00000438                 assume cs:_data
.data:00000438                 ;org 438h
.data:00000438                 public ?g_BenchCpuFreqTemp@@3IA
.data:00000438 ; unsigned int g_BenchCpuFreqTemp
.data:00000438 ?g_BenchCpuFreqTemp@@3IA dd 1           ; DATA XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+538r
.data:00000438                                         ; FreqBench(unsigned __int64,uint,IBenchPrintCallback *,bool,unsigned __int64 &,uint &)+2ECr ...
.data:0000043C _kSep           dd offset $SG71051      ; DATA XREF: CBenchCallbackToPrint::SetDecodeResult(CBenchInfo const &,bool)+ABr
.data:0000043C                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1273r ...
.data:0000043C _data           ends                    ; "  | "
.data:0000043C
.text:00000440 ; ===========================================================================
.text:00000440
.text:00000440 ; Segment type: Pure code
.text:00000440 ; Segment permissions: Read/Execute
.text:00000440 _text           segment para public 'CODE' use32
.text:00000440                 assume cs:_text
.text:00000440                 ;org 440h
.text:00000440                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000440
.text:00000440 ; =============== S U B R O U T I N E =======================================
.text:00000440
.text:00000440 ; Attributes: bp-based frame
.text:00000440
.text:00000440 ; __int32 __stdcall CBenchmarkInStream::Read(CBenchmarkInStream *this, void *, unsigned int, unsigned int *)
.text:00000440                 public ?Read@CBenchmarkInStream@@UAGJPAXIPAI@Z
.text:00000440 ?Read@CBenchmarkInStream@@UAGJPAXIPAI@Z proc near
.text:00000440                                         ; DATA XREF: .rdata:0000AA78o
.text:00000440
.text:00000440 var_C           = dword ptr -0Ch
.text:00000440 var_8           = dword ptr -8
.text:00000440 var_4           = dword ptr -4
.text:00000440 this            = dword ptr  8
.text:00000440 arg_4           = dword ptr  0Ch
.text:00000440 arg_8           = dword ptr  10h
.text:00000440 arg_C           = dword ptr  14h
.text:00000440
.text:00000440                 push    ebp
.text:00000441                 mov     ebp, esp
.text:00000443                 sub     esp, 0Ch
.text:00000446                 mov     [ebp+var_C], 0CCCCCCCCh
.text:0000044D                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00000454                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000045B                 mov     eax, [ebp+this]
.text:0000045E                 mov     ecx, [ebp+this]
.text:00000461                 mov     edx, [eax+10h]
.text:00000464                 sub     edx, [ecx+0Ch]
.text:00000467                 mov     [ebp+var_4], edx
.text:0000046A                 mov     [ebp+var_8], 100000h
.text:00000471                 mov     eax, [ebp+arg_8]
.text:00000474                 cmp     eax, [ebp+var_8]
.text:00000477                 jbe     short loc_47F
.text:00000479                 mov     ecx, [ebp+var_8]
.text:0000047C                 mov     [ebp+arg_8], ecx
.text:0000047F
.text:0000047F loc_47F:                                ; CODE XREF: CBenchmarkInStream::Read(void *,uint,uint *)+37j
.text:0000047F                 mov     edx, [ebp+arg_8]
.text:00000482                 cmp     edx, [ebp+var_4]
.text:00000485                 jbe     short loc_48D
.text:00000487                 mov     eax, [ebp+var_4]
.text:0000048A                 mov     [ebp+arg_8], eax
.text:0000048D
.text:0000048D loc_48D:                                ; CODE XREF: CBenchmarkInStream::Read(void *,uint,uint *)+45j
.text:0000048D                 mov     [ebp+var_C], 0
.text:00000494                 jmp     short loc_49F
.text:00000496 ; ---------------------------------------------------------------------------
.text:00000496
.text:00000496 loc_496:                                ; CODE XREF: CBenchmarkInStream::Read(void *,uint,uint *)+81j
.text:00000496                 mov     ecx, [ebp+var_C]
.text:00000499                 add     ecx, 1
.text:0000049C                 mov     [ebp+var_C], ecx
.text:0000049F
.text:0000049F loc_49F:                                ; CODE XREF: CBenchmarkInStream::Read(void *,uint,uint *)+54j
.text:0000049F                 mov     edx, [ebp+var_C]
.text:000004A2                 cmp     edx, [ebp+arg_8]
.text:000004A5                 jnb     short loc_4C3
.text:000004A7                 mov     eax, [ebp+this]
.text:000004AA                 mov     ecx, [eax+0Ch]
.text:000004AD                 add     ecx, [ebp+var_C]
.text:000004B0                 mov     edx, [ebp+this]
.text:000004B3                 mov     eax, [edx+8]
.text:000004B6                 mov     edx, [ebp+arg_4]
.text:000004B9                 add     edx, [ebp+var_C]
.text:000004BC                 mov     al, [ecx+eax]
.text:000004BF                 mov     [edx], al
.text:000004C1                 jmp     short loc_496
.text:000004C3 ; ---------------------------------------------------------------------------
.text:000004C3
.text:000004C3 loc_4C3:                                ; CODE XREF: CBenchmarkInStream::Read(void *,uint,uint *)+65j
.text:000004C3                 mov     ecx, [ebp+this]
.text:000004C6                 mov     edx, [ecx+0Ch]
.text:000004C9                 add     edx, [ebp+arg_8]
.text:000004CC                 mov     eax, [ebp+this]
.text:000004CF                 mov     [eax+0Ch], edx
.text:000004D2                 cmp     [ebp+arg_C], 0
.text:000004D6                 jz      short loc_4E0
.text:000004D8                 mov     ecx, [ebp+arg_C]
.text:000004DB                 mov     edx, [ebp+arg_8]
.text:000004DE                 mov     [ecx], edx
.text:000004E0
.text:000004E0 loc_4E0:                                ; CODE XREF: CBenchmarkInStream::Read(void *,uint,uint *)+96j
.text:000004E0                 xor     eax, eax
.text:000004E2                 mov     esp, ebp
.text:000004E4                 pop     ebp
.text:000004E5                 retn    10h
.text:000004E5 ?Read@CBenchmarkInStream@@UAGJPAXIPAI@Z endp
.text:000004E5
.text:000004E5 ; ---------------------------------------------------------------------------
.text:000004E8                 align 10h
.text:000004F0
.text:000004F0 ; =============== S U B R O U T I N E =======================================
.text:000004F0
.text:000004F0 ; Attributes: bp-based frame
.text:000004F0
.text:000004F0 ; __int32 __stdcall CBenchmarkOutStream::Write(CBenchmarkOutStream *this, const void *Src, unsigned int, unsigned int *)
.text:000004F0                 public ?Write@CBenchmarkOutStream@@UAGJPBXIPAI@Z
.text:000004F0 ?Write@CBenchmarkOutStream@@UAGJPBXIPAI@Z proc near
.text:000004F0                                         ; DATA XREF: .rdata:0000A730o
.text:000004F0
.text:000004F0 Size            = dword ptr -4
.text:000004F0 this            = dword ptr  8
.text:000004F0 Src             = dword ptr  0Ch
.text:000004F0 arg_8           = dword ptr  10h
.text:000004F0 arg_C           = dword ptr  14h
.text:000004F0
.text:000004F0                 push    ebp
.text:000004F1                 mov     ebp, esp
.text:000004F3                 push    ecx
.text:000004F4                 mov     [ebp+Size], 0CCCCCCCCh
.text:000004FB                 mov     eax, [ebp+this]
.text:000004FE                 mov     ecx, [ebp+this]
.text:00000501                 mov     edx, [eax+8]
.text:00000504                 sub     edx, [ecx+14h]
.text:00000507                 mov     [ebp+Size], edx
.text:0000050A                 mov     eax, [ebp+Size]
.text:0000050D                 cmp     eax, [ebp+arg_8]
.text:00000510                 jbe     short loc_518
.text:00000512                 mov     ecx, [ebp+arg_8]
.text:00000515                 mov     [ebp+Size], ecx
.text:00000518
.text:00000518 loc_518:                                ; CODE XREF: CBenchmarkOutStream::Write(void const *,uint,uint *)+20j
.text:00000518                 cmp     [ebp+Size], 0
.text:0000051C                 jz      short loc_578
.text:0000051E                 mov     edx, [ebp+this]
.text:00000521                 movzx   eax, byte ptr [edx+18h]
.text:00000525                 test    eax, eax
.text:00000527                 jz      short loc_546
.text:00000529                 mov     ecx, [ebp+Size]
.text:0000052C                 push    ecx             ; Size
.text:0000052D                 mov     edx, [ebp+Src]
.text:00000530                 push    edx             ; Src
.text:00000531                 mov     eax, [ebp+this]
.text:00000534                 mov     ecx, [eax+0Ch]
.text:00000537                 mov     edx, [ebp+this]
.text:0000053A                 add     ecx, [edx+14h]
.text:0000053D                 push    ecx             ; Dst
.text:0000053E                 call    _memcpy
.text:00000543                 add     esp, 0Ch
.text:00000546
.text:00000546 loc_546:                                ; CODE XREF: CBenchmarkOutStream::Write(void const *,uint,uint *)+37j
.text:00000546                 mov     eax, [ebp+this]
.text:00000549                 movzx   ecx, byte ptr [eax+19h]
.text:0000054D                 test    ecx, ecx
.text:0000054F                 jz      short loc_569
.text:00000551                 mov     edx, [ebp+Size]
.text:00000554                 push    edx
.text:00000555                 mov     edx, [ebp+Src]
.text:00000558                 mov     eax, [ebp+this]
.text:0000055B                 mov     ecx, [eax+1Ch]
.text:0000055E                 call    @CrcUpdate@12   ; CrcUpdate(x,x,x)
.text:00000563                 mov     ecx, [ebp+this]
.text:00000566                 mov     [ecx+1Ch], eax
.text:00000569
.text:00000569 loc_569:                                ; CODE XREF: CBenchmarkOutStream::Write(void const *,uint,uint *)+5Fj
.text:00000569                 mov     edx, [ebp+this]
.text:0000056C                 mov     eax, [edx+14h]
.text:0000056F                 add     eax, [ebp+Size]
.text:00000572                 mov     ecx, [ebp+this]
.text:00000575                 mov     [ecx+14h], eax
.text:00000578
.text:00000578 loc_578:                                ; CODE XREF: CBenchmarkOutStream::Write(void const *,uint,uint *)+2Cj
.text:00000578                 cmp     [ebp+arg_C], 0
.text:0000057C                 jz      short loc_586
.text:0000057E                 mov     edx, [ebp+arg_C]
.text:00000581                 mov     eax, [ebp+Size]
.text:00000584                 mov     [edx], eax
.text:00000586
.text:00000586 loc_586:                                ; CODE XREF: CBenchmarkOutStream::Write(void const *,uint,uint *)+8Cj
.text:00000586                 mov     ecx, [ebp+Size]
.text:00000589                 cmp     ecx, [ebp+arg_8]
.text:0000058C                 jz      short loc_595
.text:0000058E                 mov     eax, 80004005h
.text:00000593                 jmp     short loc_597
.text:00000595 ; ---------------------------------------------------------------------------
.text:00000595
.text:00000595 loc_595:                                ; CODE XREF: CBenchmarkOutStream::Write(void const *,uint,uint *)+9Cj
.text:00000595                 xor     eax, eax
.text:00000597
.text:00000597 loc_597:                                ; CODE XREF: CBenchmarkOutStream::Write(void const *,uint,uint *)+A3j
.text:00000597                 add     esp, 4
.text:0000059A                 cmp     ebp, esp
.text:0000059C                 call    __RTC_CheckEsp
.text:000005A1                 mov     esp, ebp
.text:000005A3                 pop     ebp
.text:000005A4                 retn    10h
.text:000005A4 ?Write@CBenchmarkOutStream@@UAGJPBXIPAI@Z endp
.text:000005A4
.text:000005A4 ; ---------------------------------------------------------------------------
.text:000005A7                 align 10h
.text:000005B0
.text:000005B0 ; =============== S U B R O U T I N E =======================================
.text:000005B0
.text:000005B0 ; Attributes: bp-based frame
.text:000005B0
.text:000005B0 ; __int32 __stdcall CCrcOutStream::Write(CCrcOutStream *this, const void *, unsigned int, unsigned int *)
.text:000005B0                 public ?Write@CCrcOutStream@@UAGJPBXIPAI@Z
.text:000005B0 ?Write@CCrcOutStream@@UAGJPBXIPAI@Z proc near ; DATA XREF: .rdata:0000A31Co
.text:000005B0
.text:000005B0 this            = dword ptr  8
.text:000005B0 arg_4           = dword ptr  0Ch
.text:000005B0 arg_8           = dword ptr  10h
.text:000005B0 arg_C           = dword ptr  14h
.text:000005B0
.text:000005B0                 push    ebp
.text:000005B1                 mov     ebp, esp
.text:000005B3                 mov     eax, [ebp+this]
.text:000005B6                 movzx   ecx, byte ptr [eax+8]
.text:000005BA                 test    ecx, ecx
.text:000005BC                 jz      short loc_5D6
.text:000005BE                 mov     edx, [ebp+arg_8]
.text:000005C1                 push    edx
.text:000005C2                 mov     edx, [ebp+arg_4]
.text:000005C5                 mov     eax, [ebp+this]
.text:000005C8                 mov     ecx, [eax+0Ch]
.text:000005CB                 call    @CrcUpdate@12   ; CrcUpdate(x,x,x)
.text:000005D0                 mov     ecx, [ebp+this]
.text:000005D3                 mov     [ecx+0Ch], eax
.text:000005D6
.text:000005D6 loc_5D6:                                ; CODE XREF: CCrcOutStream::Write(void const *,uint,uint *)+Cj
.text:000005D6                 cmp     [ebp+arg_C], 0
.text:000005DA                 jz      short loc_5E4
.text:000005DC                 mov     edx, [ebp+arg_C]
.text:000005DF                 mov     eax, [ebp+arg_8]
.text:000005E2                 mov     [edx], eax
.text:000005E4
.text:000005E4 loc_5E4:                                ; CODE XREF: CCrcOutStream::Write(void const *,uint,uint *)+2Aj
.text:000005E4                 xor     eax, eax
.text:000005E6                 cmp     ebp, esp
.text:000005E8                 call    __RTC_CheckEsp
.text:000005ED                 pop     ebp
.text:000005EE                 retn    10h
.text:000005EE ?Write@CCrcOutStream@@UAGJPBXIPAI@Z endp
.text:000005EE
.text:000005EE ; ---------------------------------------------------------------------------
.text:000005F1                 align 10h
.text:00000600
.text:00000600 ; =============== S U B R O U T I N E =======================================
.text:00000600
.text:00000600 ; Attributes: bp-based frame
.text:00000600
.text:00000600 ; unsigned __int64 __stdcall GetWinUserTime()
.text:00000600                 public ?GetWinUserTime@@YG_KXZ
.text:00000600 ?GetWinUserTime@@YG_KXZ proc near       ; CODE XREF: CUserTime::Init(void)+Ep
.text:00000600                                         ; CUserTime::GetUserTime(void)+Ep
.text:00000600
.text:00000600 var_40          = byte ptr -40h
.text:00000600 UserTime        = _FILETIME ptr -3Ch
.text:00000600 KernelTime      = _FILETIME ptr -2Ch
.text:00000600 ExitTime        = _FILETIME ptr -1Ch
.text:00000600 CreationTime    = _FILETIME ptr -0Ch
.text:00000600
.text:00000600                 push    ebp
.text:00000601                 mov     ebp, esp
.text:00000603                 sub     esp, 40h
.text:00000606                 push    esi
.text:00000607                 push    edi
.text:00000608                 lea     edi, [ebp+var_40]
.text:0000060B                 mov     ecx, 10h
.text:00000610                 mov     eax, 0CCCCCCCCh
.text:00000615                 rep stosd
.text:00000617                 mov     esi, esp
.text:00000619                 lea     eax, [ebp+UserTime]
.text:0000061C                 push    eax             ; lpUserTime
.text:0000061D                 lea     ecx, [ebp+KernelTime]
.text:00000620                 push    ecx             ; lpKernelTime
.text:00000621                 lea     edx, [ebp+ExitTime]
.text:00000624                 push    edx             ; lpExitTime
.text:00000625                 lea     eax, [ebp+CreationTime]
.text:00000628                 push    eax             ; lpCreationTime
.text:00000629                 mov     edi, esp
.text:0000062B                 call    dword ptr ds:__imp__GetCurrentProcess@0 ; GetCurrentProcess()
.text:00000631                 cmp     edi, esp
.text:00000633                 call    __RTC_CheckEsp
.text:00000638                 push    eax             ; hProcess
.text:00000639                 call    dword ptr ds:__imp__GetProcessTimes@20 ; GetProcessTimes(x,x,x,x,x)
.text:0000063F                 cmp     esi, esp
.text:00000641                 call    __RTC_CheckEsp
.text:00000646                 test    eax, eax
.text:00000648                 jz      short loc_66A
.text:0000064A                 lea     ecx, [ebp+UserTime]
.text:0000064D                 push    ecx
.text:0000064E                 call    ?GetTime64@@YG_KABU_FILETIME@@@Z ; GetTime64(_FILETIME const &)
.text:00000653                 mov     esi, eax
.text:00000655                 mov     edi, edx
.text:00000657                 lea     edx, [ebp+KernelTime]
.text:0000065A                 push    edx
.text:0000065B                 call    ?GetTime64@@YG_KABU_FILETIME@@@Z ; GetTime64(_FILETIME const &)
.text:00000660                 add     esi, eax
.text:00000662                 adc     edi, edx
.text:00000664                 mov     eax, esi
.text:00000666                 mov     edx, edi
.text:00000668                 jmp     short loc_680
.text:0000066A ; ---------------------------------------------------------------------------
.text:0000066A
.text:0000066A loc_66A:                                ; CODE XREF: GetWinUserTime(void)+48j
.text:0000066A                 mov     esi, esp
.text:0000066C                 call    dword ptr ds:__imp__GetTickCount@0 ; GetTickCount()
.text:00000672                 cmp     esi, esp
.text:00000674                 call    __RTC_CheckEsp
.text:00000679                 mov     ecx, 2710h
.text:0000067E                 mul     ecx
.text:00000680
.text:00000680 loc_680:                                ; CODE XREF: GetWinUserTime(void)+68j
.text:00000680                 push    edx
.text:00000681                 mov     ecx, ebp
.text:00000683                 push    eax
.text:00000684                 lea     edx, $LN9
.text:0000068A                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:0000068F                 pop     eax
.text:00000690                 pop     edx
.text:00000691                 pop     edi
.text:00000692                 pop     esi
.text:00000693                 add     esp, 40h
.text:00000696                 cmp     ebp, esp
.text:00000698                 call    __RTC_CheckEsp
.text:0000069D                 mov     esp, ebp
.text:0000069F                 pop     ebp
.text:000006A0                 retn
.text:000006A0 ?GetWinUserTime@@YG_KXZ endp
.text:000006A0
.text:000006A0 ; ---------------------------------------------------------------------------
.text:000006A1                 align 4
.text:000006A4 $LN9            dd 4                    ; DATA XREF: GetWinUserTime(void)+84o
.text:000006A8                 dd offset $LN8
.text:000006AC $LN8            dd 0FFFFFFF4h, 8        ; DATA XREF: .text:000006A8o
.text:000006B4                 dd offset $LN4          ; "creationTime"
.text:000006B8                 dd 0FFFFFFE4h, 8
.text:000006C0                 dd offset $LN5          ; "exitTime"
.text:000006C4                 dd 0FFFFFFD4h, 8
.text:000006CC                 dd offset $LN6          ; "kernelTime"
.text:000006D0                 dd 0FFFFFFC4h, 8
.text:000006D8                 dd offset $LN7          ; "userTime"
.text:000006DC $LN7            db 'userTime',0         ; DATA XREF: .text:000006D8o
.text:000006E5 $LN6            db 'kernelTime',0       ; DATA XREF: .text:000006CCo
.text:000006F0 $LN5            db 'exitTime',0         ; DATA XREF: .text:000006C0o
.text:000006F9 $LN4            db 'creationTime',0     ; DATA XREF: .text:000006B4o
.text:00000706                 align 10h
.text:00000710
.text:00000710 ; =============== S U B R O U T I N E =======================================
.text:00000710
.text:00000710 ; Attributes: bp-based frame
.text:00000710
.text:00000710 ; unsigned __int64 __stdcall GetTime64(struct _FILETIME const &)
.text:00000710 ?GetTime64@@YG_KABU_FILETIME@@@Z proc near
.text:00000710                                         ; CODE XREF: GetWinUserTime(void)+4Ep
.text:00000710                                         ; GetWinUserTime(void)+5Bp
.text:00000710
.text:00000710 arg_0           = dword ptr  8
.text:00000710
.text:00000710                 push    ebp
.text:00000711                 mov     ebp, esp
.text:00000713                 push    esi
.text:00000714                 mov     eax, [ebp+arg_0]
.text:00000717                 mov     eax, [eax+4]
.text:0000071A                 xor     edx, edx
.text:0000071C                 mov     cl, 20h ; ' '
.text:0000071E                 call    __allshl
.text:00000723                 mov     ecx, [ebp+arg_0]
.text:00000726                 mov     ecx, [ecx]
.text:00000728                 xor     esi, esi
.text:0000072A                 or      eax, ecx
.text:0000072C                 or      edx, esi
.text:0000072E                 pop     esi
.text:0000072F                 cmp     ebp, esp
.text:00000731                 call    __RTC_CheckEsp
.text:00000736                 pop     ebp
.text:00000737                 retn    4
.text:00000737 ?GetTime64@@YG_KABU_FILETIME@@@Z endp
.text:00000737
.text:00000737 ; ---------------------------------------------------------------------------
.text:0000073A                 align 10h
.text:00000740
.text:00000740 ; =============== S U B R O U T I N E =======================================
.text:00000740
.text:00000740 ; Attributes: bp-based frame
.text:00000740
.text:00000740 ; void __thiscall CBenchInfoCalc::SetStartTime(CBenchInfoCalc *__hidden this)
.text:00000740                 public ?SetStartTime@CBenchInfoCalc@@QAEXXZ
.text:00000740 ?SetStartTime@CBenchInfoCalc@@QAEXXZ proc near
.text:00000740                                         ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+6BBp
.text:00000740                                         ; MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+A3Dp ...
.text:00000740
.text:00000740 var_4           = dword ptr -4
.text:00000740
.text:00000740                 push    ebp
.text:00000741                 mov     ebp, esp
.text:00000743                 push    ecx
.text:00000744                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000074B                 mov     [ebp+var_4], ecx
.text:0000074E                 call    ?GetFreq@@YG_KXZ ; GetFreq(void)
.text:00000753                 mov     ecx, [ebp+var_4]
.text:00000756                 mov     [ecx+8], eax
.text:00000759                 mov     [ecx+0Ch], edx
.text:0000075C                 call    ?GetUserFreq@@YG_KXZ ; GetUserFreq(void)
.text:00000761                 mov     ecx, [ebp+var_4]
.text:00000764                 mov     [ecx+18h], eax
.text:00000767                 mov     [ecx+1Ch], edx
.text:0000076A                 call    ?GetTimeCount@@YG_KXZ ; GetTimeCount(void)
.text:0000076F                 mov     ecx, [ebp+var_4]
.text:00000772                 mov     [ecx], eax
.text:00000774                 mov     [ecx+4], edx
.text:00000777                 mov     edx, [ebp+var_4]
.text:0000077A                 mov     dword ptr [edx+10h], 0
.text:00000781                 mov     dword ptr [edx+14h], 0
.text:00000788                 mov     ecx, [ebp+var_4]
.text:0000078B                 add     ecx, 38h ; '8'  ; this
.text:0000078E                 call    ?Init@CUserTime@@QAEXXZ ; CUserTime::Init(void)
.text:00000793                 add     esp, 4
.text:00000796                 cmp     ebp, esp
.text:00000798                 call    __RTC_CheckEsp
.text:0000079D                 mov     esp, ebp
.text:0000079F                 pop     ebp
.text:000007A0                 retn
.text:000007A0 ?SetStartTime@CBenchInfoCalc@@QAEXXZ endp
.text:000007A0
.text:000007A0 ; ---------------------------------------------------------------------------
.text:000007A1                 align 10h
.text:000007B0
.text:000007B0 ; =============== S U B R O U T I N E =======================================
.text:000007B0
.text:000007B0 ; Attributes: bp-based frame
.text:000007B0
.text:000007B0 ; unsigned __int64 __stdcall GetTimeCount(void)
.text:000007B0 ?GetTimeCount@@YG_KXZ proc near         ; CODE XREF: CBenchInfoCalc::SetStartTime(void)+2Ap
.text:000007B0                                         ; CBenchInfoCalc::SetFinishTime(CBenchInfo &)+1Dp ...
.text:000007B0                 push    ebp
.text:000007B1                 mov     ebp, esp
.text:000007B3                 push    esi
.text:000007B4                 mov     esi, esp
.text:000007B6                 call    dword ptr ds:__imp__GetTickCount@0 ; GetTickCount()
.text:000007BC                 cmp     esi, esp
.text:000007BE                 call    __RTC_CheckEsp
.text:000007C3                 xor     edx, edx
.text:000007C5                 pop     esi
.text:000007C6                 cmp     ebp, esp
.text:000007C8                 call    __RTC_CheckEsp
.text:000007CD                 pop     ebp
.text:000007CE                 retn
.text:000007CE ?GetTimeCount@@YG_KXZ endp
.text:000007CE
.text:000007CE ; ---------------------------------------------------------------------------
.text:000007CF                 align 10h
.text:000007D0
.text:000007D0 ; =============== S U B R O U T I N E =======================================
.text:000007D0
.text:000007D0 ; Attributes: bp-based frame
.text:000007D0
.text:000007D0 ; unsigned __int64 __stdcall GetFreq(void)
.text:000007D0 ?GetFreq@@YG_KXZ proc near              ; CODE XREF: CBenchInfoCalc::SetStartTime(void)+Ep
.text:000007D0                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool):loc_4489p
.text:000007D0                 push    ebp
.text:000007D1                 mov     ebp, esp
.text:000007D3                 mov     eax, 3E8h
.text:000007D8                 xor     edx, edx
.text:000007DA                 pop     ebp
.text:000007DB                 retn
.text:000007DB ?GetFreq@@YG_KXZ endp
.text:000007DB
.text:000007DB ; ---------------------------------------------------------------------------
.text:000007DC                 align 10h
.text:000007E0
.text:000007E0 ; =============== S U B R O U T I N E =======================================
.text:000007E0
.text:000007E0 ; Attributes: bp-based frame
.text:000007E0
.text:000007E0 ; unsigned __int64 __stdcall GetUserFreq(void)
.text:000007E0 ?GetUserFreq@@YG_KXZ proc near          ; CODE XREF: CBenchInfoCalc::SetStartTime(void)+1Cp
.text:000007E0                 push    ebp
.text:000007E1                 mov     ebp, esp
.text:000007E3                 mov     eax, 989680h
.text:000007E8                 xor     edx, edx
.text:000007EA                 pop     ebp
.text:000007EB                 retn
.text:000007EB ?GetUserFreq@@YG_KXZ endp
.text:000007EB
.text:000007EB ; ---------------------------------------------------------------------------
.text:000007EC                 align 10h
.text:000007F0
.text:000007F0 ; =============== S U B R O U T I N E =======================================
.text:000007F0
.text:000007F0 ; Attributes: bp-based frame
.text:000007F0
.text:000007F0 ; void __thiscall CBenchInfoCalc::SetFinishTime(CBenchInfoCalc *this, struct CBenchInfo *)
.text:000007F0                 public ?SetFinishTime@CBenchInfoCalc@@QAEXAAUCBenchInfo@@@Z
.text:000007F0 ?SetFinishTime@CBenchInfoCalc@@QAEXAAUCBenchInfo@@@Z proc near
.text:000007F0                                         ; CODE XREF: CBenchProgressInfo::SetRatioInfo(unsigned __int64 const *,unsigned __int64 const *)+56p
.text:000007F0                                         ; MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+83Fp ...
.text:000007F0
.text:000007F0 var_4           = dword ptr -4
.text:000007F0 arg_0           = dword ptr  8
.text:000007F0
.text:000007F0                 push    ebp
.text:000007F1                 mov     ebp, esp
.text:000007F3                 push    ecx
.text:000007F4                 push    esi
.text:000007F5                 push    edi
.text:000007F6                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000007FD                 mov     [ebp+var_4], ecx
.text:00000800                 mov     esi, [ebp+var_4]
.text:00000803                 mov     ecx, 0Eh
.text:00000808                 mov     edi, [ebp+arg_0]
.text:0000080B                 rep movsd
.text:0000080D                 call    ?GetTimeCount@@YG_KXZ ; GetTimeCount(void)
.text:00000812                 mov     ecx, [ebp+var_4]
.text:00000815                 sub     eax, [ecx]
.text:00000817                 sbb     edx, [ecx+4]
.text:0000081A                 mov     ecx, [ebp+arg_0]
.text:0000081D                 mov     [ecx], eax
.text:0000081F                 mov     [ecx+4], edx
.text:00000822                 mov     ecx, [ebp+var_4]
.text:00000825                 add     ecx, 38h ; '8'  ; this
.text:00000828                 call    ?GetUserTime@CUserTime@@QAE_KXZ ; CUserTime::GetUserTime(void)
.text:0000082D                 mov     ecx, [ebp+arg_0]
.text:00000830                 mov     [ecx+10h], eax
.text:00000833                 mov     [ecx+14h], edx
.text:00000836                 pop     edi
.text:00000837                 pop     esi
.text:00000838                 add     esp, 4
.text:0000083B                 cmp     ebp, esp
.text:0000083D                 call    __RTC_CheckEsp
.text:00000842                 mov     esp, ebp
.text:00000844                 pop     ebp
.text:00000845                 retn    4
.text:00000845 ?SetFinishTime@CBenchInfoCalc@@QAEXAAUCBenchInfo@@@Z endp
.text:00000845
.text:00000845 ; ---------------------------------------------------------------------------
.text:00000848                 align 10h
.text:00000850
.text:00000850 ; =============== S U B R O U T I N E =======================================
.text:00000850
.text:00000850 ; Attributes: bp-based frame
.text:00000850
.text:00000850 ; __int32 __stdcall CBenchProgressInfo::SetRatioInfo(CBenchProgressInfo *this, const unsigned __int64 *, const unsigned __int64 *)
.text:00000850                 public ?SetRatioInfo@CBenchProgressInfo@@UAGJPB_K0@Z
.text:00000850 ?SetRatioInfo@CBenchProgressInfo@@UAGJPB_K0@Z proc near
.text:00000850                                         ; DATA XREF: .rdata:0000BBF4o
.text:00000850
.text:00000850 var_44          = byte ptr -44h
.text:00000850 var_40          = byte ptr -40h
.text:00000850 var_20          = dword ptr -20h
.text:00000850 var_1C          = dword ptr -1Ch
.text:00000850 var_18          = dword ptr -18h
.text:00000850 var_14          = dword ptr -14h
.text:00000850 var_4           = dword ptr -4
.text:00000850 this            = dword ptr  8
.text:00000850 arg_4           = dword ptr  0Ch
.text:00000850 arg_8           = dword ptr  10h
.text:00000850
.text:00000850                 push    ebp
.text:00000851                 mov     ebp, esp
.text:00000853                 sub     esp, 44h
.text:00000856                 push    esi
.text:00000857                 push    edi
.text:00000858                 lea     edi, [ebp+var_44]
.text:0000085B                 mov     ecx, 11h
.text:00000860                 mov     eax, 0CCCCCCCCh
.text:00000865                 rep stosd
.text:00000867                 mov     eax, [ebp+this]
.text:0000086A                 mov     ecx, [eax+48h]  ; this
.text:0000086D                 call    ?GetResult@CBenchProgressStatus@@QAEJXZ ; CBenchProgressStatus::GetResult(void)
.text:00000872                 mov     [ebp+var_4], eax
.text:00000875                 cmp     [ebp+var_4], 0
.text:00000879                 jz      short loc_883
.text:0000087B                 mov     eax, [ebp+var_4]
.text:0000087E                 jmp     loc_97B
.text:00000883 ; ---------------------------------------------------------------------------
.text:00000883
.text:00000883 loc_883:                                ; CODE XREF: CBenchProgressInfo::SetRatioInfo(unsigned __int64 const *,unsigned __int64 const *)+29j
.text:00000883                 mov     ecx, [ebp+this]
.text:00000886                 cmp     dword ptr [ecx+50h], 0
.text:0000088A                 jnz     short loc_894
.text:0000088C                 mov     eax, [ebp+var_4]
.text:0000088F                 jmp     loc_97B
.text:00000894 ; ---------------------------------------------------------------------------
.text:00000894
.text:00000894 loc_894:                                ; CODE XREF: CBenchProgressInfo::SetRatioInfo(unsigned __int64 const *,unsigned __int64 const *)+3Aj
.text:00000894                 lea     ecx, [ebp+var_40] ; this
.text:00000897                 call    ??0CBenchInfo@@QAE@XZ ; CBenchInfo::CBenchInfo(void)
.text:0000089C                 lea     edx, [ebp+var_40]
.text:0000089F                 push    edx             ; struct CBenchInfo *
.text:000008A0                 mov     ecx, [ebp+this]
.text:000008A3                 add     ecx, 8          ; this
.text:000008A6                 call    ?SetFinishTime@CBenchInfoCalc@@QAEXAAUCBenchInfo@@@Z ; CBenchInfoCalc::SetFinishTime(CBenchInfo &)
.text:000008AB                 mov     eax, [ebp+this]
.text:000008AE                 mov     ecx, [eax+48h]
.text:000008B1                 movzx   edx, byte ptr [ecx+1Ch]
.text:000008B5                 test    edx, edx
.text:000008B7                 jz      short loc_910
.text:000008B9                 mov     eax, [ebp+this]
.text:000008BC                 mov     ecx, [ebp+arg_4]
.text:000008BF                 mov     edx, [eax+28h]
.text:000008C2                 add     edx, [ecx]
.text:000008C4                 mov     eax, [eax+2Ch]
.text:000008C7                 adc     eax, [ecx+4]
.text:000008CA                 mov     [ebp+var_20], edx
.text:000008CD                 mov     [ebp+var_1C], eax
.text:000008D0                 mov     ecx, [ebp+this]
.text:000008D3                 mov     edx, [ebp+arg_8]
.text:000008D6                 mov     eax, [ecx+30h]
.text:000008D9                 add     eax, [edx]
.text:000008DB                 mov     ecx, [ecx+34h]
.text:000008DE                 adc     ecx, [edx+4]
.text:000008E1                 mov     [ebp+var_18], eax
.text:000008E4                 mov     [ebp+var_14], ecx
.text:000008E7                 mov     esi, esp
.text:000008E9                 push    0
.text:000008EB                 lea     edx, [ebp+var_40]
.text:000008EE                 push    edx
.text:000008EF                 mov     eax, [ebp+this]
.text:000008F2                 mov     ecx, [eax+50h]
.text:000008F5                 mov     edx, [ebp+this]
.text:000008F8                 mov     eax, [edx+50h]
.text:000008FB                 mov     edx, [ecx]
.text:000008FD                 mov     ecx, eax
.text:000008FF                 mov     eax, [edx+4]
.text:00000902                 call    eax
.text:00000904                 cmp     esi, esp
.text:00000906                 call    __RTC_CheckEsp
.text:0000090B                 mov     [ebp+var_4], eax
.text:0000090E                 jmp     short loc_963
.text:00000910 ; ---------------------------------------------------------------------------
.text:00000910
.text:00000910 loc_910:                                ; CODE XREF: CBenchProgressInfo::SetRatioInfo(unsigned __int64 const *,unsigned __int64 const *)+67j
.text:00000910                 mov     ecx, [ebp+this]
.text:00000913                 mov     edx, [ebp+arg_4]
.text:00000916                 mov     eax, [ecx+30h]
.text:00000919                 add     eax, [edx]
.text:0000091B                 mov     ecx, [ecx+34h]
.text:0000091E                 adc     ecx, [edx+4]
.text:00000921                 mov     [ebp+var_18], eax
.text:00000924                 mov     [ebp+var_14], ecx
.text:00000927                 mov     edx, [ebp+this]
.text:0000092A                 mov     eax, [ebp+arg_8]
.text:0000092D                 mov     ecx, [edx+28h]
.text:00000930                 add     ecx, [eax]
.text:00000932                 mov     edx, [edx+2Ch]
.text:00000935                 adc     edx, [eax+4]
.text:00000938                 mov     [ebp+var_20], ecx
.text:0000093B                 mov     [ebp+var_1C], edx
.text:0000093E                 mov     esi, esp
.text:00000940                 push    0
.text:00000942                 lea     eax, [ebp+var_40]
.text:00000945                 push    eax
.text:00000946                 mov     ecx, [ebp+this]
.text:00000949                 mov     edx, [ecx+50h]
.text:0000094C                 mov     eax, [ebp+this]
.text:0000094F                 mov     ecx, [eax+50h]
.text:00000952                 mov     edx, [edx]
.text:00000954                 mov     eax, [edx+8]
.text:00000957                 call    eax
.text:00000959                 cmp     esi, esp
.text:0000095B                 call    __RTC_CheckEsp
.text:00000960                 mov     [ebp+var_4], eax
.text:00000963
.text:00000963 loc_963:                                ; CODE XREF: CBenchProgressInfo::SetRatioInfo(unsigned __int64 const *,unsigned __int64 const *)+BEj
.text:00000963                 cmp     [ebp+var_4], 0
.text:00000967                 jz      short loc_978
.text:00000969                 mov     ecx, [ebp+var_4]
.text:0000096C                 push    ecx             ; __int32
.text:0000096D                 mov     edx, [ebp+this]
.text:00000970                 mov     ecx, [edx+48h]  ; this
.text:00000973                 call    ?SetResult@CBenchProgressStatus@@QAEXJ@Z ; CBenchProgressStatus::SetResult(long)
.text:00000978
.text:00000978 loc_978:                                ; CODE XREF: CBenchProgressInfo::SetRatioInfo(unsigned __int64 const *,unsigned __int64 const *)+117j
.text:00000978                 mov     eax, [ebp+var_4]
.text:0000097B
.text:0000097B loc_97B:                                ; CODE XREF: CBenchProgressInfo::SetRatioInfo(unsigned __int64 const *,unsigned __int64 const *)+2Ej
.text:0000097B                                         ; CBenchProgressInfo::SetRatioInfo(unsigned __int64 const *,unsigned __int64 const *)+3Fj
.text:0000097B                 push    edx
.text:0000097C                 mov     ecx, ebp
.text:0000097E                 push    eax
.text:0000097F                 lea     edx, $LN10
.text:00000985                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:0000098A                 pop     eax
.text:0000098B                 pop     edx
.text:0000098C                 pop     edi
.text:0000098D                 pop     esi
.text:0000098E                 add     esp, 44h
.text:00000991                 cmp     ebp, esp
.text:00000993                 call    __RTC_CheckEsp
.text:00000998                 mov     esp, ebp
.text:0000099A                 pop     ebp
.text:0000099B                 retn    0Ch
.text:0000099B ?SetRatioInfo@CBenchProgressInfo@@UAGJPB_K0@Z endp
.text:0000099B
.text:0000099B ; ---------------------------------------------------------------------------
.text:0000099E                 align 10h
.text:000009A0 $LN10           dd 1                    ; DATA XREF: CBenchProgressInfo::SetRatioInfo(unsigned __int64 const *,unsigned __int64 const *)+12Fo
.text:000009A4                 dd offset $LN9_0
.text:000009A8 $LN9_0          dd 0FFFFFFC0h, 38h      ; DATA XREF: .text:000009A4o
.text:000009B0                 dd offset $LN8_0        ; "info"
.text:000009B4 $LN8_0          db 'info',0             ; DATA XREF: .text:000009B0o
.text:000009B9                 align 10h
.text:000009C0
.text:000009C0 ; =============== S U B R O U T I N E =======================================
.text:000009C0
.text:000009C0 ; Attributes: bp-based frame
.text:000009C0
.text:000009C0 ; unsigned __int64 __thiscall CBenchInfo::GetUsage(CBenchInfo *__hidden this)
.text:000009C0                 public ?GetUsage@CBenchInfo@@QBE_KXZ
.text:000009C0 ?GetUsage@CBenchInfo@@QBE_KXZ proc near ; CODE XREF: PrintResults(IBenchPrintCallback *,CBenchInfo const &,uint,unsigned __int64,bool,unsigned __int64,CTotalBenchRes *)+87p
.text:000009C0
.text:000009C0 var_44          = byte ptr -44h
.text:000009C0 var_40          = dword ptr -40h
.text:000009C0 var_3C          = dword ptr -3Ch
.text:000009C0 var_30          = dword ptr -30h
.text:000009C0 var_2C          = dword ptr -2Ch
.text:000009C0 var_20          = dword ptr -20h
.text:000009C0 var_1C          = dword ptr -1Ch
.text:000009C0 var_10          = dword ptr -10h
.text:000009C0 var_C           = dword ptr -0Ch
.text:000009C0 var_4           = dword ptr -4
.text:000009C0
.text:000009C0                 push    ebp
.text:000009C1                 mov     ebp, esp
.text:000009C3                 sub     esp, 44h
.text:000009C6                 push    edi
.text:000009C7                 push    ecx
.text:000009C8                 lea     edi, [ebp+var_44]
.text:000009CB                 mov     ecx, 11h
.text:000009D0                 mov     eax, 0CCCCCCCCh
.text:000009D5                 rep stosd
.text:000009D7                 pop     ecx
.text:000009D8                 mov     [ebp+var_4], ecx
.text:000009DB                 mov     eax, [ebp+var_4]
.text:000009DE                 mov     ecx, [eax+10h]
.text:000009E1                 mov     [ebp+var_10], ecx
.text:000009E4                 mov     edx, [eax+14h]
.text:000009E7                 mov     [ebp+var_C], edx
.text:000009EA                 mov     eax, [ebp+var_4]
.text:000009ED                 mov     ecx, [eax+18h]
.text:000009F0                 mov     [ebp+var_20], ecx
.text:000009F3                 mov     edx, [eax+1Ch]
.text:000009F6                 mov     [ebp+var_1C], edx
.text:000009F9                 mov     eax, [ebp+var_4]
.text:000009FC                 mov     ecx, [eax]
.text:000009FE                 mov     [ebp+var_30], ecx
.text:00000A01                 mov     edx, [eax+4]
.text:00000A04                 mov     [ebp+var_2C], edx
.text:00000A07                 mov     eax, [ebp+var_4]
.text:00000A0A                 mov     ecx, [eax+8]
.text:00000A0D                 mov     [ebp+var_40], ecx
.text:00000A10                 mov     edx, [eax+0Ch]
.text:00000A13                 mov     [ebp+var_3C], edx
.text:00000A16                 lea     eax, [ebp+var_20]
.text:00000A19                 push    eax
.text:00000A1A                 lea     ecx, [ebp+var_10]
.text:00000A1D                 push    ecx
.text:00000A1E                 call    ?NormalizeVals@@YGXAA_K0@Z ; NormalizeVals(unsigned __int64 &,unsigned __int64 &)
.text:00000A23                 lea     edx, [ebp+var_30]
.text:00000A26                 push    edx
.text:00000A27                 lea     eax, [ebp+var_40]
.text:00000A2A                 push    eax
.text:00000A2B                 call    ?NormalizeVals@@YGXAA_K0@Z ; NormalizeVals(unsigned __int64 &,unsigned __int64 &)
.text:00000A30                 mov     ecx, [ebp+var_20]
.text:00000A33                 or      ecx, [ebp+var_1C]
.text:00000A36                 jnz     short loc_A46
.text:00000A38                 mov     [ebp+var_20], 1
.text:00000A3F                 mov     [ebp+var_1C], 0
.text:00000A46
.text:00000A46 loc_A46:                                ; CODE XREF: CBenchInfo::GetUsage(void)+76j
.text:00000A46                 mov     edx, [ebp+var_30]
.text:00000A49                 or      edx, [ebp+var_2C]
.text:00000A4C                 jnz     short loc_A5C
.text:00000A4E                 mov     [ebp+var_30], 1
.text:00000A55                 mov     [ebp+var_2C], 0
.text:00000A5C
.text:00000A5C loc_A5C:                                ; CODE XREF: CBenchInfo::GetUsage(void)+8Cj
.text:00000A5C                 mov     eax, [ebp+var_3C]
.text:00000A5F                 push    eax
.text:00000A60                 mov     ecx, [ebp+var_40]
.text:00000A63                 push    ecx
.text:00000A64                 mov     edx, [ebp+var_C]
.text:00000A67                 push    edx
.text:00000A68                 mov     eax, [ebp+var_10]
.text:00000A6B                 push    eax
.text:00000A6C                 call    __allmul
.text:00000A71                 push    0
.text:00000A73                 push    0F4240h
.text:00000A78                 push    edx
.text:00000A79                 push    eax
.text:00000A7A                 call    __allmul
.text:00000A7F                 mov     ecx, [ebp+var_1C]
.text:00000A82                 push    ecx
.text:00000A83                 mov     ecx, [ebp+var_20]
.text:00000A86                 push    ecx
.text:00000A87                 push    edx
.text:00000A88                 push    eax
.text:00000A89                 call    __aulldiv
.text:00000A8E                 mov     ecx, [ebp+var_2C]
.text:00000A91                 push    ecx
.text:00000A92                 mov     ecx, [ebp+var_30]
.text:00000A95                 push    ecx
.text:00000A96                 push    edx
.text:00000A97                 push    eax
.text:00000A98                 call    __aulldiv
.text:00000A9D                 push    edx
.text:00000A9E                 mov     ecx, ebp
.text:00000AA0                 push    eax
.text:00000AA1                 lea     edx, $LN10_0
.text:00000AA7                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00000AAC                 pop     eax
.text:00000AAD                 pop     edx
.text:00000AAE                 pop     edi
.text:00000AAF                 add     esp, 44h
.text:00000AB2                 cmp     ebp, esp
.text:00000AB4                 call    __RTC_CheckEsp
.text:00000AB9                 mov     esp, ebp
.text:00000ABB                 pop     ebp
.text:00000ABC                 retn
.text:00000ABC ?GetUsage@CBenchInfo@@QBE_KXZ endp
.text:00000ABC
.text:00000ABC ; ---------------------------------------------------------------------------
.text:00000ABD                 align 10h
.text:00000AC0 $LN10_0         dd 4                    ; DATA XREF: CBenchInfo::GetUsage(void)+E1o
.text:00000AC4                 dd offset $LN9_1
.text:00000AC8 $LN9_1          dd 0FFFFFFF0h, 8        ; DATA XREF: .text:00000AC4o
.text:00000AD0                 dd offset $LN5_2        ; "userTime"
.text:00000AD4                 dd 0FFFFFFE0h, 8
.text:00000ADC                 dd offset $LN6_2        ; "userFreq"
.text:00000AE0                 dd 0FFFFFFD0h, 8
.text:00000AE8                 dd offset $LN7_0        ; "globalTime"
.text:00000AEC                 dd 0FFFFFFC0h, 8
.text:00000AF4                 dd offset $LN8_1        ; "globalFreq"
.text:00000AF8 $LN8_1          db 'globalFreq',0       ; DATA XREF: .text:00000AF4o
.text:00000B03 $LN7_0          db 'globalTime',0       ; DATA XREF: .text:00000AE8o
.text:00000B0E $LN6_2          db 'userFreq',0         ; DATA XREF: .text:00000ADCo
.text:00000B17 $LN5_2          db 'userTime',0         ; DATA XREF: .text:00000AD0o
.text:00000B20
.text:00000B20 ; =============== S U B R O U T I N E =======================================
.text:00000B20
.text:00000B20 ; Attributes: bp-based frame
.text:00000B20
.text:00000B20 ; void __stdcall NormalizeVals(unsigned __int64 &, unsigned __int64 &)
.text:00000B20 ?NormalizeVals@@YGXAA_K0@Z proc near    ; CODE XREF: CBenchInfo::GetUsage(void)+5Ep
.text:00000B20                                         ; CBenchInfo::GetUsage(void)+6Bp ...
.text:00000B20
.text:00000B20 var_4           = dword ptr -4
.text:00000B20 arg_0           = dword ptr  8
.text:00000B20 arg_4           = dword ptr  0Ch
.text:00000B20
.text:00000B20                 push    ebp
.text:00000B21                 mov     ebp, esp
.text:00000B23                 push    ecx
.text:00000B24                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000B2B
.text:00000B2B loc_B2B:                                ; CODE XREF: NormalizeVals(unsigned __int64 &,unsigned __int64 &)+53j
.text:00000B2B                 mov     eax, [ebp+arg_0]
.text:00000B2E                 mov     [ebp+var_4], eax
.text:00000B31                 mov     ecx, [ebp+var_4]
.text:00000B34                 cmp     dword ptr [ecx+4], 0
.text:00000B38                 ja      short loc_B45
.text:00000B3A                 mov     edx, [ebp+var_4]
.text:00000B3D                 cmp     dword ptr [edx], 0F4240h
.text:00000B43                 jbe     short loc_B75
.text:00000B45
.text:00000B45 loc_B45:                                ; CODE XREF: NormalizeVals(unsigned __int64 &,unsigned __int64 &)+18j
.text:00000B45                 mov     ecx, [ebp+arg_0]
.text:00000B48                 mov     eax, [ecx]
.text:00000B4A                 mov     edx, [ecx+4]
.text:00000B4D                 mov     cl, 1
.text:00000B4F                 call    __aullshr
.text:00000B54                 mov     ecx, [ebp+arg_0]
.text:00000B57                 mov     [ecx], eax
.text:00000B59                 mov     [ecx+4], edx
.text:00000B5C                 mov     edx, [ebp+arg_4]
.text:00000B5F                 mov     eax, [edx]
.text:00000B61                 mov     edx, [edx+4]
.text:00000B64                 mov     cl, 1
.text:00000B66                 call    __aullshr
.text:00000B6B                 mov     ecx, [ebp+arg_4]
.text:00000B6E                 mov     [ecx], eax
.text:00000B70                 mov     [ecx+4], edx
.text:00000B73                 jmp     short loc_B2B
.text:00000B75 ; ---------------------------------------------------------------------------
.text:00000B75
.text:00000B75 loc_B75:                                ; CODE XREF: NormalizeVals(unsigned __int64 &,unsigned __int64 &)+23j
.text:00000B75                 add     esp, 4
.text:00000B78                 cmp     ebp, esp
.text:00000B7A                 call    __RTC_CheckEsp
.text:00000B7F                 mov     esp, ebp
.text:00000B81                 pop     ebp
.text:00000B82                 retn    8
.text:00000B82 ?NormalizeVals@@YGXAA_K0@Z endp
.text:00000B82
.text:00000B82 ; ---------------------------------------------------------------------------
.text:00000B85                 align 10h
.text:00000B90
.text:00000B90 ; =============== S U B R O U T I N E =======================================
.text:00000B90
.text:00000B90 ; Attributes: bp-based frame
.text:00000B90
.text:00000B90 ; unsigned __int64 __thiscall CBenchInfo::GetRatingPerUsage(CBenchInfo *this, unsigned __int64)
.text:00000B90                 public ?GetRatingPerUsage@CBenchInfo@@QBE_K_K@Z
.text:00000B90 ?GetRatingPerUsage@CBenchInfo@@QBE_K_K@Z proc near
.text:00000B90                                         ; CODE XREF: PrintResults(IBenchPrintCallback *,CBenchInfo const &,uint,unsigned __int64,bool,unsigned __int64,CTotalBenchRes *)+9Dp
.text:00000B90
.text:00000B90 var_44          = byte ptr -44h
.text:00000B90 var_40          = dword ptr -40h
.text:00000B90 var_3C          = dword ptr -3Ch
.text:00000B90 var_30          = dword ptr -30h
.text:00000B90 var_2C          = dword ptr -2Ch
.text:00000B90 var_20          = dword ptr -20h
.text:00000B90 var_1C          = dword ptr -1Ch
.text:00000B90 var_10          = dword ptr -10h
.text:00000B90 var_C           = dword ptr -0Ch
.text:00000B90 var_4           = dword ptr -4
.text:00000B90 arg_0           = qword ptr  8
.text:00000B90
.text:00000B90                 push    ebp
.text:00000B91                 mov     ebp, esp
.text:00000B93                 sub     esp, 44h
.text:00000B96                 push    edi
.text:00000B97                 push    ecx
.text:00000B98                 lea     edi, [ebp+var_44]
.text:00000B9B                 mov     ecx, 11h
.text:00000BA0                 mov     eax, 0CCCCCCCCh
.text:00000BA5                 rep stosd
.text:00000BA7                 pop     ecx
.text:00000BA8                 mov     [ebp+var_4], ecx
.text:00000BAB                 mov     eax, [ebp+var_4]
.text:00000BAE                 mov     ecx, [eax+10h]
.text:00000BB1                 mov     [ebp+var_10], ecx
.text:00000BB4                 mov     edx, [eax+14h]
.text:00000BB7                 mov     [ebp+var_C], edx
.text:00000BBA                 mov     eax, [ebp+var_4]
.text:00000BBD                 mov     ecx, [eax+18h]
.text:00000BC0                 mov     [ebp+var_20], ecx
.text:00000BC3                 mov     edx, [eax+1Ch]
.text:00000BC6                 mov     [ebp+var_1C], edx
.text:00000BC9                 mov     eax, [ebp+var_4]
.text:00000BCC                 mov     ecx, [eax]
.text:00000BCE                 mov     [ebp+var_30], ecx
.text:00000BD1                 mov     edx, [eax+4]
.text:00000BD4                 mov     [ebp+var_2C], edx
.text:00000BD7                 mov     eax, [ebp+var_4]
.text:00000BDA                 mov     ecx, [eax+8]
.text:00000BDD                 mov     [ebp+var_40], ecx
.text:00000BE0                 mov     edx, [eax+0Ch]
.text:00000BE3                 mov     [ebp+var_3C], edx
.text:00000BE6                 lea     eax, [ebp+var_10]
.text:00000BE9                 push    eax
.text:00000BEA                 lea     ecx, [ebp+var_20]
.text:00000BED                 push    ecx
.text:00000BEE                 call    ?NormalizeVals@@YGXAA_K0@Z ; NormalizeVals(unsigned __int64 &,unsigned __int64 &)
.text:00000BF3                 lea     edx, [ebp+var_40]
.text:00000BF6                 push    edx
.text:00000BF7                 lea     eax, [ebp+var_30]
.text:00000BFA                 push    eax
.text:00000BFB                 call    ?NormalizeVals@@YGXAA_K0@Z ; NormalizeVals(unsigned __int64 &,unsigned __int64 &)
.text:00000C00                 mov     ecx, [ebp+var_40]
.text:00000C03                 or      ecx, [ebp+var_3C]
.text:00000C06                 jnz     short loc_C16
.text:00000C08                 mov     [ebp+var_40], 1
.text:00000C0F                 mov     [ebp+var_3C], 0
.text:00000C16
.text:00000C16 loc_C16:                                ; CODE XREF: CBenchInfo::GetRatingPerUsage(unsigned __int64)+76j
.text:00000C16                 mov     edx, [ebp+var_10]
.text:00000C19                 or      edx, [ebp+var_C]
.text:00000C1C                 jnz     short loc_C2C
.text:00000C1E                 mov     [ebp+var_10], 1
.text:00000C25                 mov     [ebp+var_C], 0
.text:00000C2C
.text:00000C2C loc_C2C:                                ; CODE XREF: CBenchInfo::GetRatingPerUsage(unsigned __int64)+8Cj
.text:00000C2C                 mov     eax, [ebp+var_2C]
.text:00000C2F                 push    eax
.text:00000C30                 mov     ecx, [ebp+var_30]
.text:00000C33                 push    ecx
.text:00000C34                 mov     edx, [ebp+var_1C]
.text:00000C37                 push    edx
.text:00000C38                 mov     eax, [ebp+var_20]
.text:00000C3B                 push    eax
.text:00000C3C                 call    __allmul
.text:00000C41                 mov     ecx, [ebp+var_3C]
.text:00000C44                 push    ecx
.text:00000C45                 mov     ecx, [ebp+var_40]
.text:00000C48                 push    ecx
.text:00000C49                 push    edx
.text:00000C4A                 push    eax
.text:00000C4B                 call    __aulldiv
.text:00000C50                 mov     ecx, dword ptr [ebp+arg_0+4]
.text:00000C53                 push    ecx
.text:00000C54                 mov     ecx, dword ptr [ebp+arg_0]
.text:00000C57                 push    ecx
.text:00000C58                 push    edx
.text:00000C59                 push    eax
.text:00000C5A                 call    __allmul
.text:00000C5F                 mov     ecx, [ebp+var_C]
.text:00000C62                 push    ecx
.text:00000C63                 mov     ecx, [ebp+var_10]
.text:00000C66                 push    ecx
.text:00000C67                 push    edx
.text:00000C68                 push    eax
.text:00000C69                 call    __aulldiv
.text:00000C6E                 push    edx
.text:00000C6F                 mov     ecx, ebp
.text:00000C71                 push    eax
.text:00000C72                 lea     edx, $LN10_1
.text:00000C78                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00000C7D                 pop     eax
.text:00000C7E                 pop     edx
.text:00000C7F                 pop     edi
.text:00000C80                 add     esp, 44h
.text:00000C83                 cmp     ebp, esp
.text:00000C85                 call    __RTC_CheckEsp
.text:00000C8A                 mov     esp, ebp
.text:00000C8C                 pop     ebp
.text:00000C8D                 retn    8
.text:00000C8D ?GetRatingPerUsage@CBenchInfo@@QBE_K_K@Z endp
.text:00000C8D
.text:00000C8D ; ---------------------------------------------------------------------------
.text:00000C90 $LN10_1         dd 4                    ; DATA XREF: CBenchInfo::GetRatingPerUsage(unsigned __int64)+E2o
.text:00000C94                 dd offset $LN9_2
.text:00000C98 $LN9_2          dd 0FFFFFFF0h, 8        ; DATA XREF: .text:00000C94o
.text:00000CA0                 dd offset $LN5_3        ; "userTime"
.text:00000CA4                 dd 0FFFFFFE0h, 8
.text:00000CAC                 dd offset $LN6_3        ; "userFreq"
.text:00000CB0                 dd 0FFFFFFD0h, 8
.text:00000CB8                 dd offset $LN7_1        ; "globalTime"
.text:00000CBC                 dd 0FFFFFFC0h, 8
.text:00000CC4                 dd offset $LN8_2        ; "globalFreq"
.text:00000CC8 $LN8_2          db 'globalFreq',0       ; DATA XREF: .text:00000CC4o
.text:00000CD3 $LN7_1          db 'globalTime',0       ; DATA XREF: .text:00000CB8o
.text:00000CDE $LN6_3          db 'userFreq',0         ; DATA XREF: .text:00000CACo
.text:00000CE7 $LN5_3          db 'userTime',0         ; DATA XREF: .text:00000CA0o
.text:00000CF0
.text:00000CF0 ; =============== S U B R O U T I N E =======================================
.text:00000CF0
.text:00000CF0 ; Attributes: bp-based frame
.text:00000CF0
.text:00000CF0 ; unsigned __int64 __thiscall CBenchInfo::GetSpeed(CBenchInfo *this, unsigned __int64)
.text:00000CF0                 public ?GetSpeed@CBenchInfo@@QBE_K_K@Z
.text:00000CF0 ?GetSpeed@CBenchInfo@@QBE_K_K@Z proc near
.text:00000CF0                                         ; CODE XREF: PrintResults(IBenchPrintCallback *,CBenchInfo const &,uint,unsigned __int64,bool,unsigned __int64,CTotalBenchRes *)+3Dp
.text:00000CF0                                         ; FreqBench(unsigned __int64,uint,IBenchPrintCallback *,bool,unsigned __int64 &,uint &)+469p ...
.text:00000CF0
.text:00000CF0 var_4           = dword ptr -4
.text:00000CF0 arg_0           = qword ptr  8
.text:00000CF0
.text:00000CF0                 push    ebp
.text:00000CF1                 mov     ebp, esp
.text:00000CF3                 push    ecx
.text:00000CF4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000CFB                 mov     [ebp+var_4], ecx
.text:00000CFE                 mov     eax, [ebp+var_4]
.text:00000D01                 mov     ecx, [eax+0Ch]
.text:00000D04                 push    ecx
.text:00000D05                 mov     edx, [eax+8]
.text:00000D08                 push    edx
.text:00000D09                 mov     eax, [ebp+var_4]
.text:00000D0C                 mov     ecx, [eax+4]
.text:00000D0F                 push    ecx
.text:00000D10                 mov     edx, [eax]
.text:00000D12                 push    edx
.text:00000D13                 mov     eax, dword ptr [ebp+arg_0+4]
.text:00000D16                 push    eax
.text:00000D17                 mov     ecx, dword ptr [ebp+arg_0]
.text:00000D1A                 push    ecx
.text:00000D1B                 call    ?MyMultDiv64@@YG_K_K00@Z ; MyMultDiv64(unsigned __int64,unsigned __int64,unsigned __int64)
.text:00000D20                 add     esp, 4
.text:00000D23                 cmp     ebp, esp
.text:00000D25                 call    __RTC_CheckEsp
.text:00000D2A                 mov     esp, ebp
.text:00000D2C                 pop     ebp
.text:00000D2D                 retn    8
.text:00000D2D ?GetSpeed@CBenchInfo@@QBE_K_K@Z endp
.text:00000D2D
.text:00000D30
.text:00000D30 ; =============== S U B R O U T I N E =======================================
.text:00000D30
.text:00000D30 ; Attributes: bp-based frame
.text:00000D30
.text:00000D30 ; unsigned __int64 __stdcall MyMultDiv64(unsigned __int64, unsigned __int64, unsigned __int64)
.text:00000D30 ?MyMultDiv64@@YG_K_K00@Z proc near      ; CODE XREF: CBenchInfo::GetSpeed(unsigned __int64)+2Bp
.text:00000D30                                         ; CBenchProps::GetCompressRating(uint,unsigned __int64,unsigned __int64,unsigned __int64)+C9p ...
.text:00000D30
.text:00000D30 var_10          = dword ptr -10h
.text:00000D30 var_C           = dword ptr -0Ch
.text:00000D30 var_8           = dword ptr -8
.text:00000D30 var_4           = dword ptr -4
.text:00000D30 arg_0           = dword ptr  8
.text:00000D30 arg_4           = dword ptr  0Ch
.text:00000D30 arg_8           = dword ptr  10h
.text:00000D30 arg_C           = dword ptr  14h
.text:00000D30 arg_10          = dword ptr  18h
.text:00000D30 arg_14          = dword ptr  1Ch
.text:00000D30
.text:00000D30                 push    ebp
.text:00000D31                 mov     ebp, esp
.text:00000D33                 sub     esp, 10h
.text:00000D36                 mov     eax, 0CCCCCCCCh
.text:00000D3B                 mov     [ebp+var_10], eax
.text:00000D3E                 mov     [ebp+var_C], eax
.text:00000D41                 mov     [ebp+var_8], eax
.text:00000D44                 mov     [ebp+var_4], eax
.text:00000D47                 mov     eax, [ebp+arg_8]
.text:00000D4A                 mov     [ebp+var_C], eax
.text:00000D4D                 mov     ecx, [ebp+arg_C]
.text:00000D50                 mov     [ebp+var_8], ecx
.text:00000D53                 lea     edx, [ebp+var_C]
.text:00000D56                 push    edx
.text:00000D57                 lea     eax, [ebp+arg_10]
.text:00000D5A                 push    eax
.text:00000D5B                 call    ?NormalizeVals@@YGXAA_K0@Z ; NormalizeVals(unsigned __int64 &,unsigned __int64 &)
.text:00000D60                 mov     ecx, [ebp+var_C]
.text:00000D63                 or      ecx, [ebp+var_8]
.text:00000D66                 jnz     short loc_D76
.text:00000D68                 mov     [ebp+var_C], 1
.text:00000D6F                 mov     [ebp+var_8], 0
.text:00000D76
.text:00000D76 loc_D76:                                ; CODE XREF: MyMultDiv64(unsigned __int64,unsigned __int64,unsigned __int64)+36j
.text:00000D76                 mov     edx, [ebp+arg_14]
.text:00000D79                 push    edx
.text:00000D7A                 mov     eax, [ebp+arg_10]
.text:00000D7D                 push    eax
.text:00000D7E                 mov     ecx, [ebp+arg_4]
.text:00000D81                 push    ecx
.text:00000D82                 mov     edx, [ebp+arg_0]
.text:00000D85                 push    edx
.text:00000D86                 call    __allmul
.text:00000D8B                 mov     ecx, [ebp+var_8]
.text:00000D8E                 push    ecx
.text:00000D8F                 mov     ecx, [ebp+var_C]
.text:00000D92                 push    ecx
.text:00000D93                 push    edx
.text:00000D94                 push    eax
.text:00000D95                 call    __aulldiv
.text:00000D9A                 push    edx
.text:00000D9B                 mov     ecx, ebp
.text:00000D9D                 push    eax
.text:00000D9E                 lea     edx, $LN6_4
.text:00000DA4                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00000DA9                 pop     eax
.text:00000DAA                 pop     edx
.text:00000DAB                 add     esp, 10h
.text:00000DAE                 cmp     ebp, esp
.text:00000DB0                 call    __RTC_CheckEsp
.text:00000DB5                 mov     esp, ebp
.text:00000DB7                 pop     ebp
.text:00000DB8                 retn    18h
.text:00000DB8 ?MyMultDiv64@@YG_K_K00@Z endp
.text:00000DB8
.text:00000DB8 ; ---------------------------------------------------------------------------
.text:00000DBB                 align 4
.text:00000DBC $LN6_4          dd 1                    ; DATA XREF: MyMultDiv64(unsigned __int64,unsigned __int64,unsigned __int64)+6Eo
.text:00000DC0                 dd offset $LN5_4
.text:00000DC4 $LN5_4          dd 0FFFFFFF4h, 8        ; DATA XREF: .text:00000DC0o
.text:00000DCC                 dd offset $LN4_2        ; "elTime"
.text:00000DD0 $LN4_2          db 'elTime',0           ; DATA XREF: .text:00000DCCo
.text:00000DD7                 align 10h
.text:00000DE0
.text:00000DE0 ; =============== S U B R O U T I N E =======================================
.text:00000DE0
.text:00000DE0 ; Attributes: bp-based frame
.text:00000DE0
.text:00000DE0 ; void __thiscall CBenchProps::SetLzmaCompexity(CBenchProps *__hidden this)
.text:00000DE0                 public ?SetLzmaCompexity@CBenchProps@@QAEXXZ
.text:00000DE0 ?SetLzmaCompexity@CBenchProps@@QAEXXZ proc near
.text:00000DE0                                         ; CODE XREF: GetCompressRating(uint,unsigned __int64,unsigned __int64,unsigned __int64)+28p
.text:00000DE0                                         ; GetDecompressRating(unsigned __int64,unsigned __int64,unsigned __int64,unsigned __int64,unsigned __int64)+28p ...
.text:00000DE0
.text:00000DE0 var_4           = dword ptr -4
.text:00000DE0
.text:00000DE0                 push    ebp
.text:00000DE1                 mov     ebp, esp
.text:00000DE3                 push    ecx
.text:00000DE4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000DEB                 mov     [ebp+var_4], ecx
.text:00000DEE                 mov     eax, [ebp+var_4]
.text:00000DF1                 mov     dword ptr [eax+4], 4B0h
.text:00000DF8                 mov     ecx, [ebp+var_4]
.text:00000DFB                 mov     dword ptr [ecx+0Ch], 4
.text:00000E02                 mov     edx, [ebp+var_4]
.text:00000E05                 mov     dword ptr [edx+8], 0BEh ; '+'
.text:00000E0C                 mov     eax, [ebp+var_4]
.text:00000E0F                 mov     byte ptr [eax], 1
.text:00000E12                 mov     esp, ebp
.text:00000E14                 pop     ebp
.text:00000E15                 retn
.text:00000E15 ?SetLzmaCompexity@CBenchProps@@QAEXXZ endp
.text:00000E15
.text:00000E15 ; ---------------------------------------------------------------------------
.text:00000E16                 align 10h
.text:00000E20
.text:00000E20 ; =============== S U B R O U T I N E =======================================
.text:00000E20
.text:00000E20 ; Attributes: bp-based frame
.text:00000E20
.text:00000E20 ; unsigned __int64 __thiscall CBenchProps::GetCompressRating(CBenchProps *this, unsigned int, unsigned __int64, unsigned __int64, unsigned __int64)
.text:00000E20                 public ?GetCompressRating@CBenchProps@@QAE_KI_K00@Z
.text:00000E20 ?GetCompressRating@CBenchProps@@QAE_KI_K00@Z proc near
.text:00000E20                                         ; CODE XREF: GetCompressRating(uint,unsigned __int64,unsigned __int64,unsigned __int64)+4Cp
.text:00000E20                                         ; CBenchCallbackToPrint::SetEncodeResult(CBenchInfo const &,bool)+95p
.text:00000E20
.text:00000E20 var_1C          = dword ptr -1Ch
.text:00000E20 var_18          = dword ptr -18h
.text:00000E20 var_14          = dword ptr -14h
.text:00000E20 var_10          = dword ptr -10h
.text:00000E20 var_C           = dword ptr -0Ch
.text:00000E20 var_8           = dword ptr -8
.text:00000E20 var_4           = dword ptr -4
.text:00000E20 arg_0           = dword ptr  8
.text:00000E20 arg_4           = qword ptr  0Ch
.text:00000E20 arg_C           = qword ptr  14h
.text:00000E20 arg_14          = qword ptr  1Ch
.text:00000E20
.text:00000E20                 push    ebp
.text:00000E21                 mov     ebp, esp
.text:00000E23                 sub     esp, 1Ch
.text:00000E26                 mov     eax, 0CCCCCCCCh
.text:00000E2B                 mov     [ebp+var_1C], eax
.text:00000E2E                 mov     [ebp+var_18], eax
.text:00000E31                 mov     [ebp+var_14], eax
.text:00000E34                 mov     [ebp+var_10], eax
.text:00000E37                 mov     [ebp+var_C], eax
.text:00000E3A                 mov     [ebp+var_8], eax
.text:00000E3D                 mov     [ebp+var_4], eax
.text:00000E40                 mov     [ebp+var_4], ecx
.text:00000E43                 cmp     [ebp+arg_0], 40000h
.text:00000E4A                 jnb     short loc_E53
.text:00000E4C                 mov     [ebp+arg_0], 40000h
.text:00000E53
.text:00000E53 loc_E53:                                ; CODE XREF: CBenchProps::GetCompressRating(uint,unsigned __int64,unsigned __int64,unsigned __int64)+2Aj
.text:00000E53                 mov     eax, [ebp+var_4]
.text:00000E56                 mov     ecx, [eax+4]
.text:00000E59                 xor     edx, edx
.text:00000E5B                 mov     [ebp+var_C], ecx
.text:00000E5E                 mov     [ebp+var_8], edx
.text:00000E61                 mov     eax, [ebp+var_4]
.text:00000E64                 movzx   ecx, byte ptr [eax]
.text:00000E67                 test    ecx, ecx
.text:00000E69                 jz      short loc_EB6
.text:00000E6B                 mov     edx, [ebp+arg_0]
.text:00000E6E                 push    edx
.text:00000E6F                 call    ?GetLogSize@@YGII@Z ; GetLogSize(uint)
.text:00000E74                 sub     eax, 1200h
.text:00000E79                 xor     ecx, ecx
.text:00000E7B                 mov     [ebp+var_14], eax
.text:00000E7E                 mov     [ebp+var_10], ecx
.text:00000E81                 mov     edx, [ebp+var_10]
.text:00000E84                 push    edx
.text:00000E85                 mov     eax, [ebp+var_14]
.text:00000E88                 push    eax
.text:00000E89                 mov     ecx, [ebp+var_10]
.text:00000E8C                 push    ecx
.text:00000E8D                 mov     edx, [ebp+var_14]
.text:00000E90                 push    edx
.text:00000E91                 call    __allmul
.text:00000E96                 push    0
.text:00000E98                 push    5
.text:00000E9A                 push    edx
.text:00000E9B                 push    eax
.text:00000E9C                 call    __allmul
.text:00000EA1                 mov     cl, 10h
.text:00000EA3                 call    __aullshr
.text:00000EA8                 add     eax, 366h
.text:00000EAD                 adc     edx, 0
.text:00000EB0                 mov     [ebp+var_C], eax
.text:00000EB3                 mov     [ebp+var_8], edx
.text:00000EB6
.text:00000EB6 loc_EB6:                                ; CODE XREF: CBenchProps::GetCompressRating(uint,unsigned __int64,unsigned __int64,unsigned __int64)+49j
.text:00000EB6                 mov     eax, [ebp+var_8]
.text:00000EB9                 push    eax
.text:00000EBA                 mov     ecx, [ebp+var_C]
.text:00000EBD                 push    ecx
.text:00000EBE                 mov     edx, dword ptr [ebp+arg_14+4]
.text:00000EC1                 push    edx
.text:00000EC2                 mov     eax, dword ptr [ebp+arg_14]
.text:00000EC5                 push    eax
.text:00000EC6                 call    __allmul
.text:00000ECB                 mov     [ebp+var_1C], eax
.text:00000ECE                 mov     [ebp+var_18], edx
.text:00000ED1                 mov     ecx, dword ptr [ebp+arg_C+4]
.text:00000ED4                 push    ecx
.text:00000ED5                 mov     edx, dword ptr [ebp+arg_C]
.text:00000ED8                 push    edx
.text:00000ED9                 mov     eax, dword ptr [ebp+arg_4+4]
.text:00000EDC                 push    eax
.text:00000EDD                 mov     ecx, dword ptr [ebp+arg_4]
.text:00000EE0                 push    ecx
.text:00000EE1                 mov     edx, [ebp+var_18]
.text:00000EE4                 push    edx
.text:00000EE5                 mov     eax, [ebp+var_1C]
.text:00000EE8                 push    eax
.text:00000EE9                 call    ?MyMultDiv64@@YG_K_K00@Z ; MyMultDiv64(unsigned __int64,unsigned __int64,unsigned __int64)
.text:00000EEE                 add     esp, 1Ch
.text:00000EF1                 cmp     ebp, esp
.text:00000EF3                 call    __RTC_CheckEsp
.text:00000EF8                 mov     esp, ebp
.text:00000EFA                 pop     ebp
.text:00000EFB                 retn    1Ch
.text:00000EFB ?GetCompressRating@CBenchProps@@QAE_KI_K00@Z endp
.text:00000EFB
.text:00000EFB ; ---------------------------------------------------------------------------
.text:00000EFE                 align 10h
.text:00000F00
.text:00000F00 ; =============== S U B R O U T I N E =======================================
.text:00000F00
.text:00000F00 ; Attributes: bp-based frame
.text:00000F00
.text:00000F00 ; unsigned int __stdcall GetLogSize(unsigned int)
.text:00000F00 ?GetLogSize@@YGII@Z proc near           ; CODE XREF: CBenchProps::GetCompressRating(uint,unsigned __int64,unsigned __int64,unsigned __int64)+4Fp
.text:00000F00
.text:00000F00 var_8           = dword ptr -8
.text:00000F00 var_4           = dword ptr -4
.text:00000F00 arg_0           = dword ptr  8
.text:00000F00
.text:00000F00                 push    ebp
.text:00000F01                 mov     ebp, esp
.text:00000F03                 sub     esp, 8
.text:00000F06                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00000F0D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000F14                 mov     [ebp+var_4], 8
.text:00000F1B                 jmp     short loc_F26
.text:00000F1D ; ---------------------------------------------------------------------------
.text:00000F1D
.text:00000F1D loc_F1D:                                ; CODE XREF: GetLogSize(uint):loc_F70j
.text:00000F1D                 mov     eax, [ebp+var_4]
.text:00000F20                 add     eax, 1
.text:00000F23                 mov     [ebp+var_4], eax
.text:00000F26
.text:00000F26 loc_F26:                                ; CODE XREF: GetLogSize(uint)+1Bj
.text:00000F26                 cmp     [ebp+var_4], 20h ; ' '
.text:00000F2A                 jge     short loc_F72
.text:00000F2C                 mov     [ebp+var_8], 0
.text:00000F33                 jmp     short loc_F3E
.text:00000F35 ; ---------------------------------------------------------------------------
.text:00000F35
.text:00000F35 loc_F35:                                ; CODE XREF: GetLogSize(uint):loc_F6Ej
.text:00000F35                 mov     ecx, [ebp+var_8]
.text:00000F38                 add     ecx, 1
.text:00000F3B                 mov     [ebp+var_8], ecx
.text:00000F3E
.text:00000F3E loc_F3E:                                ; CODE XREF: GetLogSize(uint)+33j
.text:00000F3E                 cmp     [ebp+var_8], 100h
.text:00000F45                 jnb     short loc_F70
.text:00000F47                 mov     edx, 1
.text:00000F4C                 mov     ecx, [ebp+var_4]
.text:00000F4F                 shl     edx, cl
.text:00000F51                 mov     ecx, [ebp+var_4]
.text:00000F54                 sub     ecx, 8
.text:00000F57                 mov     eax, [ebp+var_8]
.text:00000F5A                 shl     eax, cl
.text:00000F5C                 add     edx, eax
.text:00000F5E                 cmp     [ebp+arg_0], edx
.text:00000F61                 ja      short loc_F6E
.text:00000F63                 mov     eax, [ebp+var_4]
.text:00000F66                 shl     eax, 8
.text:00000F69                 add     eax, [ebp+var_8]
.text:00000F6C                 jmp     short loc_F77
.text:00000F6E ; ---------------------------------------------------------------------------
.text:00000F6E
.text:00000F6E loc_F6E:                                ; CODE XREF: GetLogSize(uint)+61j
.text:00000F6E                 jmp     short loc_F35
.text:00000F70 ; ---------------------------------------------------------------------------
.text:00000F70
.text:00000F70 loc_F70:                                ; CODE XREF: GetLogSize(uint)+45j
.text:00000F70                 jmp     short loc_F1D
.text:00000F72 ; ---------------------------------------------------------------------------
.text:00000F72
.text:00000F72 loc_F72:                                ; CODE XREF: GetLogSize(uint)+2Aj
.text:00000F72                 mov     eax, 2000h
.text:00000F77
.text:00000F77 loc_F77:                                ; CODE XREF: GetLogSize(uint)+6Cj
.text:00000F77                 mov     esp, ebp
.text:00000F79                 pop     ebp
.text:00000F7A                 retn    4
.text:00000F7A ?GetLogSize@@YGII@Z endp
.text:00000F7A
.text:00000F7A ; ---------------------------------------------------------------------------
.text:00000F7D                 align 10h
.text:00000F80
.text:00000F80 ; =============== S U B R O U T I N E =======================================
.text:00000F80
.text:00000F80 ; Attributes: bp-based frame
.text:00000F80
.text:00000F80 ; unsigned __int64 __thiscall CBenchProps::GetDecompressRating(CBenchProps *this, unsigned __int64, unsigned __int64, unsigned __int64, unsigned __int64, unsigned __int64)
.text:00000F80                 public ?GetDecompressRating@CBenchProps@@QAE_K_K0000@Z
.text:00000F80 ?GetDecompressRating@CBenchProps@@QAE_K_K0000@Z proc near
.text:00000F80                                         ; CODE XREF: GetDecompressRating(unsigned __int64,unsigned __int64,unsigned __int64,unsigned __int64,unsigned __int64)+58p
.text:00000F80                                         ; CBenchCallbackToPrint::SetDecodeResult(CBenchInfo const &,bool)+93p
.text:00000F80
.text:00000F80 var_C           = dword ptr -0Ch
.text:00000F80 var_8           = dword ptr -8
.text:00000F80 var_4           = dword ptr -4
.text:00000F80 arg_0           = qword ptr  8
.text:00000F80 arg_8           = qword ptr  10h
.text:00000F80 arg_10          = qword ptr  18h
.text:00000F80 arg_18          = qword ptr  20h
.text:00000F80 arg_20          = qword ptr  28h
.text:00000F80
.text:00000F80                 push    ebp
.text:00000F81                 mov     ebp, esp
.text:00000F83                 sub     esp, 0Ch
.text:00000F86                 push    esi
.text:00000F87                 push    edi
.text:00000F88                 mov     [ebp+var_C], 0CCCCCCCCh
.text:00000F8F                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00000F96                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000F9D                 mov     [ebp+var_4], ecx
.text:00000FA0                 mov     eax, [ebp+var_4]
.text:00000FA3                 mov     ecx, [eax+8]
.text:00000FA6                 xor     edx, edx
.text:00000FA8                 push    edx
.text:00000FA9                 push    ecx
.text:00000FAA                 mov     eax, dword ptr [ebp+arg_18+4]
.text:00000FAD                 push    eax
.text:00000FAE                 mov     ecx, dword ptr [ebp+arg_18]
.text:00000FB1                 push    ecx
.text:00000FB2                 call    __allmul
.text:00000FB7                 mov     esi, eax
.text:00000FB9                 mov     edi, edx
.text:00000FBB                 mov     edx, [ebp+var_4]
.text:00000FBE                 mov     eax, [edx+0Ch]
.text:00000FC1                 xor     ecx, ecx
.text:00000FC3                 push    ecx
.text:00000FC4                 push    eax
.text:00000FC5                 mov     edx, dword ptr [ebp+arg_10+4]
.text:00000FC8                 push    edx
.text:00000FC9                 mov     eax, dword ptr [ebp+arg_10]
.text:00000FCC                 push    eax
.text:00000FCD                 call    __allmul
.text:00000FD2                 add     esi, eax
.text:00000FD4                 adc     edi, edx
.text:00000FD6                 mov     ecx, dword ptr [ebp+arg_20+4]
.text:00000FD9                 push    ecx
.text:00000FDA                 mov     edx, dword ptr [ebp+arg_20]
.text:00000FDD                 push    edx
.text:00000FDE                 push    edi
.text:00000FDF                 push    esi
.text:00000FE0                 call    __allmul
.text:00000FE5                 mov     [ebp+var_C], eax
.text:00000FE8                 mov     [ebp+var_8], edx
.text:00000FEB                 mov     eax, dword ptr [ebp+arg_8+4]
.text:00000FEE                 push    eax
.text:00000FEF                 mov     ecx, dword ptr [ebp+arg_8]
.text:00000FF2                 push    ecx
.text:00000FF3                 mov     edx, dword ptr [ebp+arg_0+4]
.text:00000FF6                 push    edx
.text:00000FF7                 mov     eax, dword ptr [ebp+arg_0]
.text:00000FFA                 push    eax
.text:00000FFB                 mov     ecx, [ebp+var_8]
.text:00000FFE                 push    ecx
.text:00000FFF                 mov     edx, [ebp+var_C]
.text:00001002                 push    edx
.text:00001003                 call    ?MyMultDiv64@@YG_K_K00@Z ; MyMultDiv64(unsigned __int64,unsigned __int64,unsigned __int64)
.text:00001008                 pop     edi
.text:00001009                 pop     esi
.text:0000100A                 add     esp, 0Ch
.text:0000100D                 cmp     ebp, esp
.text:0000100F                 call    __RTC_CheckEsp
.text:00001014                 mov     esp, ebp
.text:00001016                 pop     ebp
.text:00001017                 retn    28h
.text:00001017 ?GetDecompressRating@CBenchProps@@QAE_K_K0000@Z endp
.text:00001017
.text:00001017 ; ---------------------------------------------------------------------------
.text:0000101A                 align 10h
.text:00001020
.text:00001020 ; =============== S U B R O U T I N E =======================================
.text:00001020
.text:00001020 ; Attributes: bp-based frame
.text:00001020
.text:00001020 ; unsigned __int64 __stdcall GetCompressRating(unsigned int, unsigned __int64, unsigned __int64, unsigned __int64)
.text:00001020                 public ?GetCompressRating@@YG_KI_K00@Z
.text:00001020 ?GetCompressRating@@YG_KI_K00@Z proc near
.text:00001020
.text:00001020 var_18          = dword ptr -18h
.text:00001020 var_14          = dword ptr -14h
.text:00001020 var_10          = dword ptr -10h
.text:00001020 var_C           = dword ptr -0Ch
.text:00001020 var_8           = dword ptr -8
.text:00001020 var_4           = dword ptr -4
.text:00001020 arg_0           = dword ptr  8
.text:00001020 arg_4           = qword ptr  0Ch
.text:00001020 arg_C           = qword ptr  14h
.text:00001020 arg_14          = qword ptr  1Ch
.text:00001020
.text:00001020                 push    ebp
.text:00001021                 mov     ebp, esp
.text:00001023                 sub     esp, 18h
.text:00001026                 mov     eax, 0CCCCCCCCh
.text:0000102B                 mov     [ebp+var_18], eax
.text:0000102E                 mov     [ebp+var_14], eax
.text:00001031                 mov     [ebp+var_10], eax
.text:00001034                 mov     [ebp+var_C], eax
.text:00001037                 mov     [ebp+var_8], eax
.text:0000103A                 mov     [ebp+var_4], eax
.text:0000103D                 lea     ecx, [ebp+var_14]
.text:00001040                 call    ??0CBenchProps@@QAE@XZ ; CBenchProps::CBenchProps(void)
.text:00001045                 lea     ecx, [ebp+var_14] ; this
.text:00001048                 call    ?SetLzmaCompexity@CBenchProps@@QAEXXZ ; CBenchProps::SetLzmaCompexity(void)
.text:0000104D                 mov     eax, dword ptr [ebp+arg_14+4]
.text:00001050                 push    eax
.text:00001051                 mov     ecx, dword ptr [ebp+arg_14]
.text:00001054                 push    ecx             ; unsigned __int64
.text:00001055                 mov     edx, dword ptr [ebp+arg_C+4]
.text:00001058                 push    edx
.text:00001059                 mov     eax, dword ptr [ebp+arg_C]
.text:0000105C                 push    eax             ; unsigned __int64
.text:0000105D                 mov     ecx, dword ptr [ebp+arg_4+4]
.text:00001060                 push    ecx
.text:00001061                 mov     edx, dword ptr [ebp+arg_4]
.text:00001064                 push    edx             ; unsigned __int64
.text:00001065                 mov     eax, [ebp+arg_0]
.text:00001068                 push    eax             ; unsigned int
.text:00001069                 lea     ecx, [ebp+var_14] ; this
.text:0000106C                 call    ?GetCompressRating@CBenchProps@@QAE_KI_K00@Z ; CBenchProps::GetCompressRating(uint,unsigned __int64,unsigned __int64,unsigned __int64)
.text:00001071                 push    edx
.text:00001072                 mov     ecx, ebp
.text:00001074                 push    eax
.text:00001075                 lea     edx, $LN5_5
.text:0000107B                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00001080                 pop     eax
.text:00001081                 pop     edx
.text:00001082                 add     esp, 18h
.text:00001085                 cmp     ebp, esp
.text:00001087                 call    __RTC_CheckEsp
.text:0000108C                 mov     esp, ebp
.text:0000108E                 pop     ebp
.text:0000108F                 retn    1Ch
.text:0000108F ?GetCompressRating@@YG_KI_K00@Z endp
.text:0000108F
.text:0000108F ; ---------------------------------------------------------------------------
.text:00001092                 align 4
.text:00001094 $LN5_5          dd 1                    ; DATA XREF: GetCompressRating(uint,unsigned __int64,unsigned __int64,unsigned __int64)+55o
.text:00001098                 dd offset $LN4_3
.text:0000109C $LN4_3          dd 0FFFFFFECh, 10h      ; DATA XREF: .text:00001098o
.text:000010A4                 dd offset $LN3          ; "props"
.text:000010A8 $LN3            db 'props',0            ; DATA XREF: .text:000010A4o
.text:000010AE                 align 10h
.text:000010B0
.text:000010B0 ; =============== S U B R O U T I N E =======================================
.text:000010B0
.text:000010B0 ; Attributes: bp-based frame
.text:000010B0
.text:000010B0 ; unsigned __int64 __stdcall GetDecompressRating(unsigned __int64, unsigned __int64, unsigned __int64, unsigned __int64, unsigned __int64)
.text:000010B0                 public ?GetDecompressRating@@YG_K_K0000@Z
.text:000010B0 ?GetDecompressRating@@YG_K_K0000@Z proc near
.text:000010B0
.text:000010B0 var_18          = dword ptr -18h
.text:000010B0 var_14          = dword ptr -14h
.text:000010B0 var_10          = dword ptr -10h
.text:000010B0 var_C           = dword ptr -0Ch
.text:000010B0 var_8           = dword ptr -8
.text:000010B0 var_4           = dword ptr -4
.text:000010B0 arg_0           = qword ptr  8
.text:000010B0 arg_8           = qword ptr  10h
.text:000010B0 arg_10          = qword ptr  18h
.text:000010B0 arg_18          = qword ptr  20h
.text:000010B0 arg_20          = qword ptr  28h
.text:000010B0
.text:000010B0                 push    ebp
.text:000010B1                 mov     ebp, esp
.text:000010B3                 sub     esp, 18h
.text:000010B6                 mov     eax, 0CCCCCCCCh
.text:000010BB                 mov     [ebp+var_18], eax
.text:000010BE                 mov     [ebp+var_14], eax
.text:000010C1                 mov     [ebp+var_10], eax
.text:000010C4                 mov     [ebp+var_C], eax
.text:000010C7                 mov     [ebp+var_8], eax
.text:000010CA                 mov     [ebp+var_4], eax
.text:000010CD                 lea     ecx, [ebp+var_14]
.text:000010D0                 call    ??0CBenchProps@@QAE@XZ ; CBenchProps::CBenchProps(void)
.text:000010D5                 lea     ecx, [ebp+var_14] ; this
.text:000010D8                 call    ?SetLzmaCompexity@CBenchProps@@QAEXXZ ; CBenchProps::SetLzmaCompexity(void)
.text:000010DD                 mov     eax, dword ptr [ebp+arg_20+4]
.text:000010E0                 push    eax
.text:000010E1                 mov     ecx, dword ptr [ebp+arg_20]
.text:000010E4                 push    ecx             ; unsigned __int64
.text:000010E5                 mov     edx, dword ptr [ebp+arg_18+4]
.text:000010E8                 push    edx
.text:000010E9                 mov     eax, dword ptr [ebp+arg_18]
.text:000010EC                 push    eax             ; unsigned __int64
.text:000010ED                 mov     ecx, dword ptr [ebp+arg_10+4]
.text:000010F0                 push    ecx
.text:000010F1                 mov     edx, dword ptr [ebp+arg_10]
.text:000010F4                 push    edx             ; unsigned __int64
.text:000010F5                 mov     eax, dword ptr [ebp+arg_8+4]
.text:000010F8                 push    eax
.text:000010F9                 mov     ecx, dword ptr [ebp+arg_8]
.text:000010FC                 push    ecx             ; unsigned __int64
.text:000010FD                 mov     edx, dword ptr [ebp+arg_0+4]
.text:00001100                 push    edx
.text:00001101                 mov     eax, dword ptr [ebp+arg_0]
.text:00001104                 push    eax             ; unsigned __int64
.text:00001105                 lea     ecx, [ebp+var_14] ; this
.text:00001108                 call    ?GetDecompressRating@CBenchProps@@QAE_K_K0000@Z ; CBenchProps::GetDecompressRating(unsigned __int64,unsigned __int64,unsigned __int64,unsigned __int64,unsigned __int64)
.text:0000110D                 push    edx
.text:0000110E                 mov     ecx, ebp
.text:00001110                 push    eax
.text:00001111                 lea     edx, $LN5_6
.text:00001117                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:0000111C                 pop     eax
.text:0000111D                 pop     edx
.text:0000111E                 add     esp, 18h
.text:00001121                 cmp     ebp, esp
.text:00001123                 call    __RTC_CheckEsp
.text:00001128                 mov     esp, ebp
.text:0000112A                 pop     ebp
.text:0000112B                 retn    28h
.text:0000112B ?GetDecompressRating@@YG_K_K0000@Z endp
.text:0000112B
.text:0000112B ; ---------------------------------------------------------------------------
.text:0000112E                 align 10h
.text:00001130 $LN5_6          dd 1                    ; DATA XREF: GetDecompressRating(unsigned __int64,unsigned __int64,unsigned __int64,unsigned __int64,unsigned __int64)+61o
.text:00001134                 dd offset $LN4_4
.text:00001138 $LN4_4          dd 0FFFFFFECh, 10h      ; DATA XREF: .text:00001134o
.text:00001140                 dd offset $LN3_0        ; "props"
.text:00001144 $LN3_0          db 'props',0            ; DATA XREF: .text:00001140o
.text:0000114A                 align 10h
.text:00001150
.text:00001150 ; =============== S U B R O U T I N E =======================================
.text:00001150
.text:00001150 ; Attributes: bp-based frame
.text:00001150
.text:00001150 ; __int32 __thiscall CEncoderInfo::Init(CEncoderInfo *this, const struct COneMethodInfo *, unsigned int, unsigned int, struct CBaseRandomGenerator *)
.text:00001150                 public ?Init@CEncoderInfo@@QAEJABVCOneMethodInfo@@IIPAVCBaseRandomGenerator@@@Z
.text:00001150 ?Init@CEncoderInfo@@QAEJABVCOneMethodInfo@@IIPAVCBaseRandomGenerator@@@Z proc near
.text:00001150                                         ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+4F7p
.text:00001150
.text:00001150 var_FC          = dword ptr -0FCh
.text:00001150 var_F8          = dword ptr -0F8h
.text:00001150 var_F4          = dword ptr -0F4h
.text:00001150 var_F0          = dword ptr -0F0h
.text:00001150 var_EC          = dword ptr -0ECh
.text:00001150 var_E8          = dword ptr -0E8h
.text:00001150 var_E4          = dword ptr -0E4h
.text:00001150 var_E0          = dword ptr -0E0h
.text:00001150 var_DC          = dword ptr -0DCh
.text:00001150 var_D8          = dword ptr -0D8h
.text:00001150 var_D4          = dword ptr -0D4h
.text:00001150 var_D0          = dword ptr -0D0h
.text:00001150 var_CC          = dword ptr -0CCh
.text:00001150 var_C8          = dword ptr -0C8h
.text:00001150 var_C4          = dword ptr -0C4h
.text:00001150 var_C0          = dword ptr -0C0h
.text:00001150 var_BC          = dword ptr -0BCh
.text:00001150 var_B8          = dword ptr -0B8h
.text:00001150 var_B4          = dword ptr -0B4h
.text:00001150 var_B0          = dword ptr -0B0h
.text:00001150 var_AC          = dword ptr -0ACh
.text:00001150 var_A8          = dword ptr -0A8h
.text:00001150 var_A4          = dword ptr -0A4h
.text:00001150 var_A0          = dword ptr -0A0h
.text:00001150 var_98          = byte ptr -98h
.text:00001150 var_90          = dword ptr -90h
.text:00001150 Dst             = byte ptr -88h
.text:00001150 var_70          = byte ptr -70h
.text:00001150 var_68          = dword ptr -68h
.text:00001150 var_64          = dword ptr -64h
.text:00001150 var_5C          = byte ptr -5Ch
.text:00001150 var_54          = dword ptr -54h
.text:00001150 var_4C          = byte ptr -4Ch
.text:00001150 var_44          = dword ptr -44h
.text:00001150 var_3C          = qword ptr -3Ch
.text:00001150 var_2C          = byte ptr -2Ch
.text:00001150 var_20          = byte ptr -20h
.text:00001150 var_18          = dword ptr -18h
.text:00001150 var_14          = dword ptr -14h
.text:00001150 var_10          = dword ptr -10h
.text:00001150 var_C           = dword ptr -0Ch
.text:00001150 var_4           = dword ptr -4
.text:00001150 arg_0           = dword ptr  8
.text:00001150 arg_4           = dword ptr  0Ch
.text:00001150 arg_8           = dword ptr  10h
.text:00001150 arg_C           = dword ptr  14h
.text:00001150
.text:00001150                 push    ebp
.text:00001151                 mov     ebp, esp
.text:00001153                 push    0FFFFFFFFh
.text:00001155                 push    offset __ehhandler$?Init@CEncoderInfo@@QAEJABVCOneMethodInfo@@IIPAVCBaseRandomGenerator@@@Z
.text:0000115A                 mov     eax, large fs:0
.text:00001160                 push    eax
.text:00001161                 sub     esp, 0F0h
.text:00001167                 push    esi
.text:00001168                 push    edi
.text:00001169                 push    ecx
.text:0000116A                 lea     edi, [ebp+var_FC]
.text:00001170                 mov     ecx, 3Ch ; '<'
.text:00001175                 mov     eax, 0CCCCCCCCh
.text:0000117A                 rep stosd
.text:0000117C                 pop     ecx
.text:0000117D                 mov     eax, dword ptr ds:___security_cookie
.text:00001182                 xor     eax, ebp
.text:00001184                 mov     [ebp+var_10], eax
.text:00001187                 push    eax
.text:00001188                 lea     eax, [ebp+var_C]
.text:0000118B                 mov     large fs:0, eax
.text:00001191                 mov     [ebp+var_14], ecx
.text:00001194                 mov     eax, [ebp+arg_C]
.text:00001197                 push    eax             ; struct CBaseRandomGenerator *
.text:00001198                 mov     ecx, [ebp+var_14]
.text:0000119B                 add     ecx, 0C8h ; '+' ; this
.text:000011A1                 call    ?Set@CBenchRandomGenerator@@QAEXPAVCBaseRandomGenerator@@@Z ; CBenchRandomGenerator::Set(CBaseRandomGenerator *)
.text:000011A6                 mov     ecx, [ebp+var_14]
.text:000011A9                 mov     edx, [ebp+arg_4]
.text:000011AC                 mov     [ecx+0C0h], edx
.text:000011B2                 mov     eax, [ebp+var_14]
.text:000011B5                 mov     ecx, [eax+0C0h]
.text:000011BB                 add     ecx, 400h
.text:000011C1                 mov     [ebp+var_18], ecx
.text:000011C4                 mov     edx, [ebp+var_14]
.text:000011C7                 mov     eax, [edx+0C0h]
.text:000011CD                 push    eax             ; unsigned int
.text:000011CE                 mov     ecx, [ebp+var_14]
.text:000011D1                 add     ecx, 0C8h ; '+' ; this
.text:000011D7                 call    ?Alloc@CBenchBuffer@@QAE_NI@Z ; CBenchBuffer::Alloc(uint)
.text:000011DC                 movzx   ecx, al
.text:000011DF                 test    ecx, ecx
.text:000011E1                 jnz     short loc_11ED
.text:000011E3                 mov     eax, 8007000Eh
.text:000011E8                 jmp     loc_18D9
.text:000011ED ; ---------------------------------------------------------------------------
.text:000011ED
.text:000011ED loc_11ED:                               ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+91j
.text:000011ED                 cmp     [ebp+arg_8], 0
.text:000011F1                 jnz     short loc_1203
.text:000011F3                 mov     ecx, [ebp+var_14]
.text:000011F6                 add     ecx, 0C8h ; '+' ; this
.text:000011FC                 call    ?GenerateSimpleRandom@CBenchRandomGenerator@@QAEXXZ ; CBenchRandomGenerator::GenerateSimpleRandom(void)
.text:00001201                 jmp     short loc_1215
.text:00001203 ; ---------------------------------------------------------------------------
.text:00001203
.text:00001203 loc_1203:                               ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+A1j
.text:00001203                 mov     edx, [ebp+arg_8]
.text:00001206                 push    edx             ; unsigned int
.text:00001207                 mov     ecx, [ebp+var_14]
.text:0000120A                 add     ecx, 0C8h ; '+' ; this
.text:00001210                 call    ?Generate@CBenchRandomGenerator@@QAEXI@Z ; CBenchRandomGenerator::Generate(uint)
.text:00001215
.text:00001215 loc_1215:                               ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+B1j
.text:00001215                 mov     eax, [ebp+var_14]
.text:00001218                 mov     edx, [eax+0CCh]
.text:0000121E                 mov     ecx, [ebp+var_14]
.text:00001221                 mov     ecx, [ecx+0D0h]
.text:00001227                 call    @CrcCalc@8      ; CrcCalc(x,x)
.text:0000122C                 mov     edx, [ebp+var_14]
.text:0000122F                 mov     [edx+0BCh], eax
.text:00001235                 mov     ecx, [ebp+var_14]
.text:00001238                 add     ecx, 10h
.text:0000123B                 call    ??B?$CMyComPtr@UICompressFilter@@@@QBEPAUICompressFilter@@XZ ; CMyComPtr<ICompressFilter>::operator ICompressFilter *(void)
.text:00001240                 test    eax, eax
.text:00001242                 jz      short loc_126D
.text:00001244                 mov     eax, [ebp+var_14]
.text:00001247                 mov     ecx, [eax+0CCh]
.text:0000124D                 push    ecx             ; unsigned int
.text:0000124E                 mov     ecx, [ebp+var_14]
.text:00001251                 add     ecx, 0D8h ; '+' ; this
.text:00001257                 call    ?Alloc@CBenchBuffer@@QAE_NI@Z ; CBenchBuffer::Alloc(uint)
.text:0000125C                 movzx   edx, al
.text:0000125F                 test    edx, edx
.text:00001261                 jnz     short loc_126D
.text:00001263                 mov     eax, 8007000Eh
.text:00001268                 jmp     loc_18D9
.text:0000126D ; ---------------------------------------------------------------------------
.text:0000126D
.text:0000126D loc_126D:                               ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+F2j
.text:0000126D                                         ; CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+111j
.text:0000126D                 push    20h ; ' '       ; unsigned int
.text:0000126F                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00001274                 add     esp, 4
.text:00001277                 mov     [ebp+var_A8], eax
.text:0000127D                 mov     [ebp+var_4], 0
.text:00001284                 cmp     [ebp+var_A8], 0
.text:0000128B                 jz      short loc_12A0
.text:0000128D                 mov     ecx, [ebp+var_A8]
.text:00001293                 call    ??0CBenchmarkOutStream@@QAE@XZ ; CBenchmarkOutStream::CBenchmarkOutStream(void)
.text:00001298                 mov     [ebp+var_DC], eax
.text:0000129E                 jmp     short loc_12AA
.text:000012A0 ; ---------------------------------------------------------------------------
.text:000012A0
.text:000012A0 loc_12A0:                               ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+13Bj
.text:000012A0                 mov     [ebp+var_DC], 0
.text:000012AA
.text:000012AA loc_12AA:                               ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+14Ej
.text:000012AA                 mov     eax, [ebp+var_DC]
.text:000012B0                 mov     [ebp+var_A4], eax
.text:000012B6                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000012BD                 mov     ecx, [ebp+var_14]
.text:000012C0                 mov     edx, [ebp+var_A4]
.text:000012C6                 mov     [ecx+0ACh], edx
.text:000012CC                 mov     eax, [ebp+var_18]
.text:000012CF                 push    eax             ; unsigned int
.text:000012D0                 mov     ecx, [ebp+var_14]
.text:000012D3                 mov     ecx, [ecx+0ACh]
.text:000012D9                 add     ecx, 4          ; this
.text:000012DC                 call    ?Alloc@CBenchBuffer@@QAE_NI@Z ; CBenchBuffer::Alloc(uint)
.text:000012E1                 movzx   edx, al
.text:000012E4                 test    edx, edx
.text:000012E6                 jnz     short loc_12F2
.text:000012E8                 mov     eax, 8007000Eh
.text:000012ED                 jmp     loc_18D9
.text:000012F2 ; ---------------------------------------------------------------------------
.text:000012F2
.text:000012F2 loc_12F2:                               ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+196j
.text:000012F2                 mov     eax, [ebp+var_14]
.text:000012F5                 mov     ecx, [eax+0ACh]
.text:000012FB                 push    ecx
.text:000012FC                 mov     ecx, [ebp+var_14]
.text:000012FF                 add     ecx, 0B0h ; '¦'
.text:00001305                 call    ??4?$CMyComPtr@UISequentialOutStream@@@@QAEPAUISequentialOutStream@@PAU1@@Z ; CMyComPtr<ISequentialOutStream>::operator=(ISequentialOutStream *)
.text:0000130A                 mov     edx, [ebp+var_14]
.text:0000130D                 mov     dword ptr [edx+0E4h], 0
.text:00001317                 mov     ecx, [ebp+var_14]
.text:0000131A                 add     ecx, 0E8h ; 'F'
.text:00001320                 call    ??7?$CMyComPtr@UISequentialOutStream@@@@QBE_NXZ ; CMyComPtr<ISequentialOutStream>::operator!(void)
.text:00001325                 movzx   eax, al
.text:00001328                 test    eax, eax
.text:0000132A                 jz      short loc_13A3
.text:0000132C                 push    20h ; ' '       ; unsigned int
.text:0000132E                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00001333                 add     esp, 4
.text:00001336                 mov     [ebp+var_B0], eax
.text:0000133C                 mov     [ebp+var_4], 1
.text:00001343                 cmp     [ebp+var_B0], 0
.text:0000134A                 jz      short loc_135F
.text:0000134C                 mov     ecx, [ebp+var_B0]
.text:00001352                 call    ??0CBenchmarkOutStream@@QAE@XZ ; CBenchmarkOutStream::CBenchmarkOutStream(void)
.text:00001357                 mov     [ebp+var_E0], eax
.text:0000135D                 jmp     short loc_1369
.text:0000135F ; ---------------------------------------------------------------------------
.text:0000135F
.text:0000135F loc_135F:                               ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+1FAj
.text:0000135F                 mov     [ebp+var_E0], 0
.text:00001369
.text:00001369 loc_1369:                               ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+20Dj
.text:00001369                 mov     ecx, [ebp+var_E0]
.text:0000136F                 mov     [ebp+var_AC], ecx
.text:00001375                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000137C                 mov     edx, [ebp+var_14]
.text:0000137F                 mov     eax, [ebp+var_AC]
.text:00001385                 mov     [edx+0E4h], eax
.text:0000138B                 mov     ecx, [ebp+var_14]
.text:0000138E                 mov     edx, [ecx+0E4h]
.text:00001394                 push    edx
.text:00001395                 mov     ecx, [ebp+var_14]
.text:00001398                 add     ecx, 0E8h ; 'F'
.text:0000139E                 call    ??4?$CMyComPtr@UISequentialOutStream@@@@QAEPAUISequentialOutStream@@PAU1@@Z ; CMyComPtr<ISequentialOutStream>::operator=(ISequentialOutStream *)
.text:000013A3
.text:000013A3 loc_13A3:                               ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+1DAj
.text:000013A3                 push    5               ; unsigned int
.text:000013A5                 mov     eax, [ebp+var_14]
.text:000013A8                 mov     ecx, [eax+0E4h]
.text:000013AE                 add     ecx, 4          ; this
.text:000013B1                 call    ?Alloc@CBenchBuffer@@QAE_NI@Z ; CBenchBuffer::Alloc(uint)
.text:000013B6                 movzx   ecx, al
.text:000013B9                 test    ecx, ecx
.text:000013BB                 jnz     short loc_13C7
.text:000013BD                 mov     eax, 8007000Eh
.text:000013C2                 jmp     loc_18D9
.text:000013C7 ; ---------------------------------------------------------------------------
.text:000013C7
.text:000013C7 loc_13C7:                               ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+26Bj
.text:000013C7                 push    0               ; bool
.text:000013C9                 push    1               ; bool
.text:000013CB                 mov     edx, [ebp+var_14]
.text:000013CE                 mov     ecx, [edx+0E4h] ; this
.text:000013D4                 call    ?Init@CBenchmarkOutStream@@QAEX_N0@Z ; CBenchmarkOutStream::Init(bool,bool)
.text:000013D9                 lea     ecx, [ebp+var_20]
.text:000013DC                 call    ??0?$CMyComPtr@UIUnknown@@@@QAE@XZ ; CMyComPtr<IUnknown>::CMyComPtr<IUnknown>(void)
.text:000013E1                 mov     [ebp+var_4], 2
.text:000013E8                 mov     ecx, [ebp+var_14]
.text:000013EB                 add     ecx, 10h
.text:000013EE                 call    ??B?$CMyComPtr@UICompressFilter@@@@QBEPAUICompressFilter@@XZ ; CMyComPtr<ICompressFilter>::operator ICompressFilter *(void)
.text:000013F3                 test    eax, eax
.text:000013F5                 jz      short loc_140D
.text:000013F7                 mov     ecx, [ebp+var_14]
.text:000013FA                 add     ecx, 10h
.text:000013FD                 call    ??B?$CMyComPtr@UICompressFilter@@@@QBEPAUICompressFilter@@XZ ; CMyComPtr<ICompressFilter>::operator ICompressFilter *(void)
.text:00001402                 push    eax
.text:00001403                 lea     ecx, [ebp+var_20]
.text:00001406                 call    ??4?$CMyComPtr@UIUnknown@@@@QAEPAUIUnknown@@PAU1@@Z ; CMyComPtr<IUnknown>::operator=(IUnknown *)
.text:0000140B                 jmp     short loc_1421
.text:0000140D ; ---------------------------------------------------------------------------
.text:0000140D
.text:0000140D loc_140D:                               ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+2A5j
.text:0000140D                 mov     ecx, [ebp+var_14]
.text:00001410                 add     ecx, 0Ch
.text:00001413                 call    ??B?$CMyComPtr@UICompressCoder@@@@QBEPAUICompressCoder@@XZ ; CMyComPtr<ICompressCoder>::operator ICompressCoder *(void)
.text:00001418                 push    eax
.text:00001419                 lea     ecx, [ebp+var_20]
.text:0000141C                 call    ??4?$CMyComPtr@UIUnknown@@@@QAEPAUIUnknown@@PAU1@@Z ; CMyComPtr<IUnknown>::operator=(IUnknown *)
.text:00001421
.text:00001421 loc_1421:                               ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+2BBj
.text:00001421                 lea     ecx, [ebp+var_2C]
.text:00001424                 call    ??0?$CMyComPtr@UICompressSetCoderProperties@@@@QAE@XZ ; CMyComPtr<ICompressSetCoderProperties>::CMyComPtr<ICompressSetCoderProperties>(void)
.text:00001429                 mov     byte ptr [ebp+var_4], 3
.text:0000142D                 lea     ecx, [ebp+var_2C]
.text:00001430                 call    ??I?$CMyComPtr@UICompressSetCoderProperties@@@@QAEPAPAUICompressSetCoderProperties@@XZ ; CMyComPtr<ICompressSetCoderProperties>::operator&(void)
.text:00001435                 push    eax
.text:00001436                 push    offset _IID_ICompressSetCoderProperties
.text:0000143B                 lea     ecx, [ebp+var_20]
.text:0000143E                 call    ??$QueryInterface@UICompressSetCoderProperties@@@?$CMyComPtr@UIUnknown@@@@QBEJABU_GUID@@PAPAUICompressSetCoderProperties@@@Z ; CMyComPtr<IUnknown>::QueryInterface<ICompressSetCoderProperties>(_GUID const &,ICompressSetCoderProperties * *)
.text:00001443                 lea     ecx, [ebp+var_2C]
.text:00001446                 call    ??B?$CMyComPtr@UICompressSetCoderProperties@@@@QBEPAUICompressSetCoderProperties@@XZ ; CMyComPtr<ICompressSetCoderProperties>::operator ICompressSetCoderProperties *(void)
.text:0000144B                 test    eax, eax
.text:0000144D                 jz      short loc_14A9
.text:0000144F                 mov     eax, [ebp+arg_4]
.text:00001452                 xor     ecx, ecx
.text:00001454                 mov     dword ptr [ebp+var_3C], eax
.text:00001457                 mov     dword ptr [ebp+var_3C+4], ecx
.text:0000145A                 lea     edx, [ebp+var_3C]
.text:0000145D                 push    edx             ; unsigned __int64 *
.text:0000145E                 lea     ecx, [ebp+var_2C]
.text:00001461                 call    ??B?$CMyComPtr@UICompressSetCoderProperties@@@@QBEPAUICompressSetCoderProperties@@XZ ; CMyComPtr<ICompressSetCoderProperties>::operator ICompressSetCoderProperties *(void)
.text:00001466                 push    eax             ; struct ICompressSetCoderProperties *
.text:00001467                 mov     ecx, [ebp+arg_0] ; this
.text:0000146A                 call    ?SetCoderProps@CProps@@QBEJPAUICompressSetCoderProperties@@PB_K@Z ; CProps::SetCoderProps(ICompressSetCoderProperties *,unsigned __int64 const *)
.text:0000146F                 mov     [ebp+var_44], eax
.text:00001472                 cmp     [ebp+var_44], 0
.text:00001476                 jz      short loc_14A7
.text:00001478                 mov     eax, [ebp+var_44]
.text:0000147B                 mov     [ebp+var_B4], eax
.text:00001481                 mov     byte ptr [ebp+var_4], 2
.text:00001485                 lea     ecx, [ebp+var_2C]
.text:00001488                 call    ??1?$CMyComPtr@UICompressSetCoderProperties@@@@QAE@XZ ; CMyComPtr<ICompressSetCoderProperties>::~CMyComPtr<ICompressSetCoderProperties>(void)
.text:0000148D                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001494                 lea     ecx, [ebp+var_20]
.text:00001497                 call    ??1?$CMyComPtr@UIUnknown@@@@QAE@XZ ; CMyComPtr<IUnknown>::~CMyComPtr<IUnknown>(void)
.text:0000149C                 mov     eax, [ebp+var_B4]
.text:000014A2                 jmp     loc_18D9
.text:000014A7 ; ---------------------------------------------------------------------------
.text:000014A7
.text:000014A7 loc_14A7:                               ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+326j
.text:000014A7                 jmp     short loc_14E8
.text:000014A9 ; ---------------------------------------------------------------------------
.text:000014A9
.text:000014A9 loc_14A9:                               ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+2FDj
.text:000014A9                 mov     ecx, [ebp+arg_0] ; this
.text:000014AC                 call    ?AreThereNonOptionalProps@CProps@@QBE_NXZ ; CProps::AreThereNonOptionalProps(void)
.text:000014B1                 movzx   ecx, al
.text:000014B4                 test    ecx, ecx
.text:000014B6                 jz      short loc_14E8
.text:000014B8                 mov     [ebp+var_B8], 80070057h
.text:000014C2                 mov     byte ptr [ebp+var_4], 2
.text:000014C6                 lea     ecx, [ebp+var_2C]
.text:000014C9                 call    ??1?$CMyComPtr@UICompressSetCoderProperties@@@@QAE@XZ ; CMyComPtr<ICompressSetCoderProperties>::~CMyComPtr<ICompressSetCoderProperties>(void)
.text:000014CE                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000014D5                 lea     ecx, [ebp+var_20]
.text:000014D8                 call    ??1?$CMyComPtr@UIUnknown@@@@QAE@XZ ; CMyComPtr<IUnknown>::~CMyComPtr<IUnknown>(void)
.text:000014DD                 mov     eax, [ebp+var_B8]
.text:000014E3                 jmp     loc_18D9
.text:000014E8 ; ---------------------------------------------------------------------------
.text:000014E8
.text:000014E8 loc_14E8:                               ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *):loc_14A7j
.text:000014E8                                         ; CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+366j
.text:000014E8                 lea     ecx, [ebp+var_4C]
.text:000014EB                 call    ??0?$CMyComPtr@UICompressWriteCoderProperties@@@@QAE@XZ ; CMyComPtr<ICompressWriteCoderProperties>::CMyComPtr<ICompressWriteCoderProperties>(void)
.text:000014F0                 mov     byte ptr [ebp+var_4], 4
.text:000014F4                 lea     ecx, [ebp+var_4C]
.text:000014F7                 call    ??I?$CMyComPtr@UICompressWriteCoderProperties@@@@QAEPAPAUICompressWriteCoderProperties@@XZ ; CMyComPtr<ICompressWriteCoderProperties>::operator&(void)
.text:000014FC                 push    eax
.text:000014FD                 push    offset _IID_ICompressWriteCoderProperties
.text:00001502                 lea     ecx, [ebp+var_20]
.text:00001505                 call    ??$QueryInterface@UICompressWriteCoderProperties@@@?$CMyComPtr@UIUnknown@@@@QBEJABU_GUID@@PAPAUICompressWriteCoderProperties@@@Z ; CMyComPtr<IUnknown>::QueryInterface<ICompressWriteCoderProperties>(_GUID const &,ICompressWriteCoderProperties * *)
.text:0000150A                 lea     ecx, [ebp+var_4C]
.text:0000150D                 call    ??B?$CMyComPtr@UICompressWriteCoderProperties@@@@QBEPAUICompressWriteCoderProperties@@XZ ; CMyComPtr<ICompressWriteCoderProperties>::operator ICompressWriteCoderProperties *(void)
.text:00001512                 test    eax, eax
.text:00001514                 jz      short loc_1594
.text:00001516                 lea     ecx, [ebp+var_4C]
.text:00001519                 call    ??C?$CMyComPtr@UICompressWriteCoderProperties@@@@QBEPAUICompressWriteCoderProperties@@XZ ; CMyComPtr<ICompressWriteCoderProperties>::operator->(void)
.text:0000151E                 mov     [ebp+var_E4], eax
.text:00001524                 mov     ecx, [ebp+var_14]
.text:00001527                 add     ecx, 0E8h ; 'F'
.text:0000152D                 call    ??B?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ ; CMyComPtr<ISequentialOutStream>::operator ISequentialOutStream *(void)
.text:00001532                 mov     esi, esp
.text:00001534                 push    eax
.text:00001535                 mov     edx, [ebp+var_E4]
.text:0000153B                 push    edx
.text:0000153C                 mov     eax, [ebp+var_E4]
.text:00001542                 mov     ecx, [eax]
.text:00001544                 mov     edx, [ecx+0Ch]
.text:00001547                 call    edx
.text:00001549                 cmp     esi, esp
.text:0000154B                 call    __RTC_CheckEsp
.text:00001550                 mov     [ebp+var_54], eax
.text:00001553                 cmp     [ebp+var_54], 0
.text:00001557                 jz      short loc_1594
.text:00001559                 mov     eax, [ebp+var_54]
.text:0000155C                 mov     [ebp+var_BC], eax
.text:00001562                 mov     byte ptr [ebp+var_4], 3
.text:00001566                 lea     ecx, [ebp+var_4C]
.text:00001569                 call    ??1?$CMyComPtr@UICompressWriteCoderProperties@@@@QAE@XZ ; CMyComPtr<ICompressWriteCoderProperties>::~CMyComPtr<ICompressWriteCoderProperties>(void)
.text:0000156E                 mov     byte ptr [ebp+var_4], 2
.text:00001572                 lea     ecx, [ebp+var_2C]
.text:00001575                 call    ??1?$CMyComPtr@UICompressSetCoderProperties@@@@QAE@XZ ; CMyComPtr<ICompressSetCoderProperties>::~CMyComPtr<ICompressSetCoderProperties>(void)
.text:0000157A                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001581                 lea     ecx, [ebp+var_20]
.text:00001584                 call    ??1?$CMyComPtr@UIUnknown@@@@QAE@XZ ; CMyComPtr<IUnknown>::~CMyComPtr<IUnknown>(void)
.text:00001589                 mov     eax, [ebp+var_BC]
.text:0000158F                 jmp     loc_18D9
.text:00001594 ; ---------------------------------------------------------------------------
.text:00001594
.text:00001594 loc_1594:                               ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+3C4j
.text:00001594                                         ; CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+407j
.text:00001594                 lea     ecx, [ebp+var_5C]
.text:00001597                 call    ??0?$CMyComPtr@UICryptoSetPassword@@@@QAE@XZ ; CMyComPtr<ICryptoSetPassword>::CMyComPtr<ICryptoSetPassword>(void)
.text:0000159C                 mov     byte ptr [ebp+var_4], 5
.text:000015A0                 lea     ecx, [ebp+var_5C]
.text:000015A3                 call    ??I?$CMyComPtr@UICryptoSetPassword@@@@QAEPAPAUICryptoSetPassword@@XZ ; CMyComPtr<ICryptoSetPassword>::operator&(void)
.text:000015A8                 push    eax
.text:000015A9                 push    offset _IID_ICryptoSetPassword
.text:000015AE                 lea     ecx, [ebp+var_20]
.text:000015B1                 call    ??$QueryInterface@UICryptoSetPassword@@@?$CMyComPtr@UIUnknown@@@@QBEJABU_GUID@@PAPAUICryptoSetPassword@@@Z ; CMyComPtr<IUnknown>::QueryInterface<ICryptoSetPassword>(_GUID const &,ICryptoSetPassword * *)
.text:000015B6                 lea     ecx, [ebp+var_5C]
.text:000015B9                 call    ??B?$CMyComPtr@UICryptoSetPassword@@@@QBEPAUICryptoSetPassword@@XZ ; CMyComPtr<ICryptoSetPassword>::operator ICryptoSetPassword *(void)
.text:000015BE                 test    eax, eax
.text:000015C0                 jz      loc_1896
.text:000015C6                 lea     ecx, [ebp+var_5C]
.text:000015C9                 call    ??C?$CMyComPtr@UICryptoSetPassword@@@@QBEPAUICryptoSetPassword@@XZ ; CMyComPtr<ICryptoSetPassword>::operator->(void)
.text:000015CE                 mov     [ebp+var_E8], eax
.text:000015D4                 mov     esi, esp
.text:000015D6                 push    10h
.text:000015D8                 mov     ecx, [ebp+var_14]
.text:000015DB                 add     ecx, 64h ; 'd'
.text:000015DE                 push    ecx
.text:000015DF                 mov     edx, [ebp+var_E8]
.text:000015E5                 push    edx
.text:000015E6                 mov     eax, [ebp+var_E8]
.text:000015EC                 mov     ecx, [eax]
.text:000015EE                 mov     edx, [ecx+0Ch]
.text:000015F1                 call    edx
.text:000015F3                 cmp     esi, esp
.text:000015F5                 call    __RTC_CheckEsp
.text:000015FA                 mov     [ebp+var_64], eax
.text:000015FD                 cmp     [ebp+var_64], 0
.text:00001601                 jz      short loc_164A
.text:00001603                 mov     eax, [ebp+var_64]
.text:00001606                 mov     [ebp+var_C0], eax
.text:0000160C                 mov     byte ptr [ebp+var_4], 4
.text:00001610                 lea     ecx, [ebp+var_5C]
.text:00001613                 call    ??1?$CMyComPtr@UICryptoSetPassword@@@@QAE@XZ ; CMyComPtr<ICryptoSetPassword>::~CMyComPtr<ICryptoSetPassword>(void)
.text:00001618                 mov     byte ptr [ebp+var_4], 3
.text:0000161C                 lea     ecx, [ebp+var_4C]
.text:0000161F                 call    ??1?$CMyComPtr@UICompressWriteCoderProperties@@@@QAE@XZ ; CMyComPtr<ICompressWriteCoderProperties>::~CMyComPtr<ICompressWriteCoderProperties>(void)
.text:00001624                 mov     byte ptr [ebp+var_4], 2
.text:00001628                 lea     ecx, [ebp+var_2C]
.text:0000162B                 call    ??1?$CMyComPtr@UICompressSetCoderProperties@@@@QAE@XZ ; CMyComPtr<ICompressSetCoderProperties>::~CMyComPtr<ICompressSetCoderProperties>(void)
.text:00001630                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001637                 lea     ecx, [ebp+var_20]
.text:0000163A                 call    ??1?$CMyComPtr@UIUnknown@@@@QAE@XZ ; CMyComPtr<IUnknown>::~CMyComPtr<IUnknown>(void)
.text:0000163F                 mov     eax, [ebp+var_C0]
.text:00001645                 jmp     loc_18D9
.text:0000164A ; ---------------------------------------------------------------------------
.text:0000164A
.text:0000164A loc_164A:                               ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+4B1j
.text:0000164A                 push    14h             ; unsigned int
.text:0000164C                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00001651                 add     esp, 4
.text:00001654                 mov     [ebp+var_C8], eax
.text:0000165A                 mov     byte ptr [ebp+var_4], 6
.text:0000165E                 cmp     [ebp+var_C8], 0
.text:00001665                 jz      short loc_167A
.text:00001667                 mov     ecx, [ebp+var_C8]
.text:0000166D                 call    ??0CBenchmarkInStream@@QAE@XZ ; CBenchmarkInStream::CBenchmarkInStream(void)
.text:00001672                 mov     [ebp+var_EC], eax
.text:00001678                 jmp     short loc_1684
.text:0000167A ; ---------------------------------------------------------------------------
.text:0000167A
.text:0000167A loc_167A:                               ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+515j
.text:0000167A                 mov     [ebp+var_EC], 0
.text:00001684
.text:00001684 loc_1684:                               ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+528j
.text:00001684                 mov     ecx, [ebp+var_EC]
.text:0000168A                 mov     [ebp+var_C4], ecx
.text:00001690                 mov     byte ptr [ebp+var_4], 5
.text:00001694                 mov     edx, [ebp+var_C4]
.text:0000169A                 mov     [ebp+var_68], edx
.text:0000169D                 mov     eax, [ebp+var_68]
.text:000016A0                 push    eax
.text:000016A1                 lea     ecx, [ebp+var_70]
.text:000016A4                 call    ??0?$CMyComPtr@UISequentialInStream@@@@QAE@PAUISequentialInStream@@@Z ; CMyComPtr<ISequentialInStream>::CMyComPtr<ISequentialInStream>(ISequentialInStream *)
.text:000016A9                 mov     byte ptr [ebp+var_4], 7
.text:000016AD                 push    10h             ; Size
.text:000016AF                 push    0               ; Val
.text:000016B1                 lea     ecx, [ebp+Dst]
.text:000016B7                 push    ecx             ; Dst
.text:000016B8                 call    _memset
.text:000016BD                 add     esp, 0Ch
.text:000016C0                 push    10h             ; unsigned int
.text:000016C2                 lea     edx, [ebp+Dst]
.text:000016C8                 push    edx             ; unsigned __int8 *
.text:000016C9                 mov     ecx, [ebp+var_68] ; this
.text:000016CC                 call    ?Init@CBenchmarkInStream@@QAEXPBEI@Z ; CBenchmarkInStream::Init(uchar const *,uint)
.text:000016D1                 push    10h             ; unsigned int
.text:000016D3                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:000016D8                 add     esp, 4
.text:000016DB                 mov     [ebp+var_D0], eax
.text:000016E1                 mov     byte ptr [ebp+var_4], 8
.text:000016E5                 cmp     [ebp+var_D0], 0
.text:000016EC                 jz      short loc_1701
.text:000016EE                 mov     ecx, [ebp+var_D0]
.text:000016F4                 call    ??0CCrcOutStream@@QAE@XZ ; CCrcOutStream::CCrcOutStream(void)
.text:000016F9                 mov     [ebp+var_F0], eax
.text:000016FF                 jmp     short loc_170B
.text:00001701 ; ---------------------------------------------------------------------------
.text:00001701
.text:00001701 loc_1701:                               ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+59Cj
.text:00001701                 mov     [ebp+var_F0], 0
.text:0000170B
.text:0000170B loc_170B:                               ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+5AFj
.text:0000170B                 mov     eax, [ebp+var_F0]
.text:00001711                 mov     [ebp+var_CC], eax
.text:00001717                 mov     byte ptr [ebp+var_4], 7
.text:0000171B                 mov     ecx, [ebp+var_CC]
.text:00001721                 mov     [ebp+var_90], ecx
.text:00001727                 mov     edx, [ebp+var_90]
.text:0000172D                 push    edx
.text:0000172E                 lea     ecx, [ebp+var_98]
.text:00001734                 call    ??0?$CMyComPtr@UISequentialOutStream@@@@QAE@PAUISequentialOutStream@@@Z ; CMyComPtr<ISequentialOutStream>::CMyComPtr<ISequentialOutStream>(ISequentialOutStream *)
.text:00001739                 mov     byte ptr [ebp+var_4], 9
.text:0000173D                 mov     ecx, [ebp+var_90] ; this
.text:00001743                 call    ?Init@CCrcOutStream@@QAEXXZ ; CCrcOutStream::Init(void)
.text:00001748                 mov     ecx, [ebp+var_14]
.text:0000174B                 add     ecx, 10h
.text:0000174E                 call    ??B?$CMyComPtr@UICompressFilter@@@@QBEPAUICompressFilter@@XZ ; CMyComPtr<ICompressFilter>::operator ICompressFilter *(void)
.text:00001753                 test    eax, eax
.text:00001755                 jz      short loc_17C1
.text:00001757                 mov     ecx, [ebp+var_14]
.text:0000175A                 add     ecx, 10h
.text:0000175D                 call    ??C?$CMyComPtr@UICompressFilter@@@@QBEPAUICompressFilter@@XZ ; CMyComPtr<ICompressFilter>::operator->(void)
.text:00001762                 mov     [ebp+var_F4], eax
.text:00001768                 mov     eax, [ebp+var_F4]
.text:0000176E                 mov     ecx, [eax]
.text:00001770                 mov     esi, esp
.text:00001772                 mov     edx, [ebp+var_F4]
.text:00001778                 push    edx
.text:00001779                 mov     eax, [ecx+0Ch]
.text:0000177C                 call    eax
.text:0000177E                 cmp     esi, esp
.text:00001780                 call    __RTC_CheckEsp
.text:00001785                 mov     ecx, [ebp+var_14]
.text:00001788                 add     ecx, 10h
.text:0000178B                 call    ??C?$CMyComPtr@UICompressFilter@@@@QBEPAUICompressFilter@@XZ ; CMyComPtr<ICompressFilter>::operator->(void)
.text:00001790                 mov     [ebp+var_F8], eax
.text:00001796                 mov     esi, esp
.text:00001798                 push    10h
.text:0000179A                 lea     ecx, [ebp+Dst]
.text:000017A0                 push    ecx
.text:000017A1                 mov     edx, [ebp+var_F8]
.text:000017A7                 push    edx
.text:000017A8                 mov     eax, [ebp+var_F8]
.text:000017AE                 mov     ecx, [eax]
.text:000017B0                 mov     edx, [ecx+10h]
.text:000017B3                 call    edx
.text:000017B5                 cmp     esi, esp
.text:000017B7                 call    __RTC_CheckEsp
.text:000017BC                 jmp     loc_187B
.text:000017C1 ; ---------------------------------------------------------------------------
.text:000017C1
.text:000017C1 loc_17C1:                               ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+605j
.text:000017C1                 mov     ecx, [ebp+var_14]
.text:000017C4                 add     ecx, 0Ch
.text:000017C7                 call    ??C?$CMyComPtr@UICompressCoder@@@@QBEPAUICompressCoder@@XZ ; CMyComPtr<ICompressCoder>::operator->(void)
.text:000017CC                 mov     [ebp+var_FC], eax
.text:000017D2                 mov     esi, esp
.text:000017D4                 push    0
.text:000017D6                 push    0
.text:000017D8                 push    0
.text:000017DA                 lea     ecx, [ebp+var_98]
.text:000017E0                 call    ??B?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ ; CMyComPtr<ISequentialOutStream>::operator ISequentialOutStream *(void)
.text:000017E5                 push    eax
.text:000017E6                 lea     ecx, [ebp+var_70]
.text:000017E9                 call    ??B?$CMyComPtr@UISequentialInStream@@@@QBEPAUISequentialInStream@@XZ ; CMyComPtr<ISequentialInStream>::operator ISequentialInStream *(void)
.text:000017EE                 push    eax
.text:000017EF                 mov     eax, [ebp+var_FC]
.text:000017F5                 push    eax
.text:000017F6                 mov     ecx, [ebp+var_FC]
.text:000017FC                 mov     edx, [ecx]
.text:000017FE                 mov     eax, [edx+0Ch]
.text:00001801                 call    eax
.text:00001803                 cmp     esi, esp
.text:00001805                 call    __RTC_CheckEsp
.text:0000180A                 mov     [ebp+var_A0], eax
.text:00001810                 cmp     [ebp+var_A0], 0
.text:00001817                 jz      short loc_187B
.text:00001819                 mov     ecx, [ebp+var_A0]
.text:0000181F                 mov     [ebp+var_D4], ecx
.text:00001825                 mov     byte ptr [ebp+var_4], 7
.text:00001829                 lea     ecx, [ebp+var_98]
.text:0000182F                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00001834                 mov     byte ptr [ebp+var_4], 5
.text:00001838                 lea     ecx, [ebp+var_70]
.text:0000183B                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:00001840                 mov     byte ptr [ebp+var_4], 4
.text:00001844                 lea     ecx, [ebp+var_5C]
.text:00001847                 call    ??1?$CMyComPtr@UICryptoSetPassword@@@@QAE@XZ ; CMyComPtr<ICryptoSetPassword>::~CMyComPtr<ICryptoSetPassword>(void)
.text:0000184C                 mov     byte ptr [ebp+var_4], 3
.text:00001850                 lea     ecx, [ebp+var_4C]
.text:00001853                 call    ??1?$CMyComPtr@UICompressWriteCoderProperties@@@@QAE@XZ ; CMyComPtr<ICompressWriteCoderProperties>::~CMyComPtr<ICompressWriteCoderProperties>(void)
.text:00001858                 mov     byte ptr [ebp+var_4], 2
.text:0000185C                 lea     ecx, [ebp+var_2C]
.text:0000185F                 call    ??1?$CMyComPtr@UICompressSetCoderProperties@@@@QAE@XZ ; CMyComPtr<ICompressSetCoderProperties>::~CMyComPtr<ICompressSetCoderProperties>(void)
.text:00001864                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000186B                 lea     ecx, [ebp+var_20]
.text:0000186E                 call    ??1?$CMyComPtr@UIUnknown@@@@QAE@XZ ; CMyComPtr<IUnknown>::~CMyComPtr<IUnknown>(void)
.text:00001873                 mov     eax, [ebp+var_D4]
.text:00001879                 jmp     short loc_18D9
.text:0000187B ; ---------------------------------------------------------------------------
.text:0000187B
.text:0000187B loc_187B:                               ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+66Cj
.text:0000187B                                         ; CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+6C7j
.text:0000187B                 mov     byte ptr [ebp+var_4], 7
.text:0000187F                 lea     ecx, [ebp+var_98]
.text:00001885                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:0000188A                 mov     byte ptr [ebp+var_4], 5
.text:0000188E                 lea     ecx, [ebp+var_70]
.text:00001891                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:00001896
.text:00001896 loc_1896:                               ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+470j
.text:00001896                 mov     byte ptr [ebp+var_4], 4
.text:0000189A                 lea     ecx, [ebp+var_5C]
.text:0000189D                 call    ??1?$CMyComPtr@UICryptoSetPassword@@@@QAE@XZ ; CMyComPtr<ICryptoSetPassword>::~CMyComPtr<ICryptoSetPassword>(void)
.text:000018A2                 mov     byte ptr [ebp+var_4], 3
.text:000018A6                 lea     ecx, [ebp+var_4C]
.text:000018A9                 call    ??1?$CMyComPtr@UICompressWriteCoderProperties@@@@QAE@XZ ; CMyComPtr<ICompressWriteCoderProperties>::~CMyComPtr<ICompressWriteCoderProperties>(void)
.text:000018AE                 mov     byte ptr [ebp+var_4], 2
.text:000018B2                 lea     ecx, [ebp+var_2C]
.text:000018B5                 call    ??1?$CMyComPtr@UICompressSetCoderProperties@@@@QAE@XZ ; CMyComPtr<ICompressSetCoderProperties>::~CMyComPtr<ICompressSetCoderProperties>(void)
.text:000018BA                 mov     [ebp+var_D8], 0
.text:000018C4                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000018CB                 lea     ecx, [ebp+var_20]
.text:000018CE                 call    ??1?$CMyComPtr@UIUnknown@@@@QAE@XZ ; CMyComPtr<IUnknown>::~CMyComPtr<IUnknown>(void)
.text:000018D3                 mov     eax, [ebp+var_D8]
.text:000018D9
.text:000018D9 loc_18D9:                               ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+98j
.text:000018D9                                         ; CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+118j ...
.text:000018D9                 push    edx
.text:000018DA                 mov     ecx, ebp
.text:000018DC                 push    eax
.text:000018DD                 lea     edx, $LN52
.text:000018E3                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:000018E8                 pop     eax
.text:000018E9                 pop     edx
.text:000018EA                 mov     ecx, [ebp+var_C]
.text:000018ED                 mov     large fs:0, ecx
.text:000018F4                 pop     ecx
.text:000018F5                 pop     edi
.text:000018F6                 pop     esi
.text:000018F7                 mov     ecx, [ebp+var_10]
.text:000018FA                 xor     ecx, ebp
.text:000018FC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text:00001901                 add     esp, 0FCh
.text:00001907                 cmp     ebp, esp
.text:00001909                 call    __RTC_CheckEsp
.text:0000190E                 mov     esp, ebp
.text:00001910                 pop     ebp
.text:00001911                 retn    10h
.text:00001911 ?Init@CEncoderInfo@@QAEJABVCOneMethodInfo@@IIPAVCBaseRandomGenerator@@@Z endp
.text:00001911
.text:00001911 ; ---------------------------------------------------------------------------
.text:00001914 $LN52           dd 8                    ; DATA XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+78Do
.text:00001918                 dd offset $LN51
.text:0000191C $LN51           dd 0FFFFFFE0h, 4        ; DATA XREF: .text:00001918o
.text:00001924                 dd offset $LN42         ; "coder"
.text:00001928                 dd 0FFFFFFD4h, 4
.text:00001930                 dd offset $LN43         ; "scp"
.text:00001934                 dd 0FFFFFFC4h, 8
.text:0000193C                 dd offset $LN44         ; "reduceSize"
.text:00001940                 dd 0FFFFFFB4h, 4
.text:00001948                 dd offset $LN45         ; "writeCoderProps"
.text:0000194C                 dd 0FFFFFFA4h, 4
.text:00001954                 dd offset $LN46         ; "sp"
.text:00001958                 db 90h
.text:00001959                 db 3 dup(0FFh)
.text:0000195C                 dd 4
.text:00001960                 dd offset $LN47         ; "inStream"
.text:00001964                 dd 0FFFFFF78h, 10h
.text:0000196C                 dd offset $LN48         ; "temp"
.text:00001970                 dd 0FFFFFF68h, 4
.text:00001978                 dd offset $LN49         ; "outStream"
.text:0000197C $LN49           db 'outStream',0        ; DATA XREF: .text:00001978o
.text:00001986 $LN48           db 'temp',0             ; DATA XREF: .text:0000196Co
.text:0000198B $LN47           db 'inStream',0         ; DATA XREF: .text:00001960o
.text:00001994 $LN46           db 'sp',0               ; DATA XREF: .text:00001954o
.text:00001997 $LN45           db 'writeCoderProps',0  ; DATA XREF: .text:00001948o
.text:000019A7 $LN44           db 'reduceSize',0       ; DATA XREF: .text:0000193Co
.text:000019B2 $LN43           db 'scp',0              ; DATA XREF: .text:00001930o
.text:000019B6 $LN42           db 'coder',0            ; DATA XREF: .text:00001924o
.text:000019BC                 align 10h
.text:000019C0
.text:000019C0 ; =============== S U B R O U T I N E =======================================
.text:000019C0
.text:000019C0 ; Attributes: bp-based frame
.text:000019C0
.text:000019C0 ; __int32 __thiscall CEncoderInfo::Encode(CEncoderInfo *__hidden this)
.text:000019C0                 public ?Encode@CEncoderInfo@@QAEJXZ
.text:000019C0 ?Encode@CEncoderInfo@@QAEJXZ proc near  ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+741p
.text:000019C0                                         ; CEncoderInfo::EncodeThreadFunction(void *)+5Ep
.text:000019C0
.text:000019C0 var_D0          = dword ptr -0D0h
.text:000019C0 var_CC          = dword ptr -0CCh
.text:000019C0 var_C8          = dword ptr -0C8h
.text:000019C0 var_C4          = dword ptr -0C4h
.text:000019C0 var_C0          = dword ptr -0C0h
.text:000019C0 var_BC          = dword ptr -0BCh
.text:000019C0 var_B8          = dword ptr -0B8h
.text:000019C0 var_B4          = dword ptr -0B4h
.text:000019C0 var_B0          = dword ptr -0B0h
.text:000019C0 var_AC          = dword ptr -0ACh
.text:000019C0 var_A8          = dword ptr -0A8h
.text:000019C0 var_A4          = dword ptr -0A4h
.text:000019C0 var_A0          = dword ptr -0A0h
.text:000019C0 var_9C          = dword ptr -9Ch
.text:000019C0 var_98          = dword ptr -98h
.text:000019C0 var_94          = dword ptr -94h
.text:000019C0 var_90          = dword ptr -90h
.text:000019C0 var_8C          = dword ptr -8Ch
.text:000019C0 var_88          = dword ptr -88h
.text:000019C0 var_84          = dword ptr -84h
.text:000019C0 var_80          = dword ptr -80h
.text:000019C0 var_7C          = dword ptr -7Ch
.text:000019C0 var_78          = dword ptr -78h
.text:000019C0 var_74          = dword ptr -74h
.text:000019C0 var_70          = dword ptr -70h
.text:000019C0 var_6C          = dword ptr -6Ch
.text:000019C0 var_68          = dword ptr -68h
.text:000019C0 var_64          = dword ptr -64h
.text:000019C0 var_5E          = byte ptr -5Eh
.text:000019C0 var_5D          = byte ptr -5Dh
.text:000019C0 var_5C          = dword ptr -5Ch
.text:000019C0 var_58          = dword ptr -58h
.text:000019C0 var_54          = dword ptr -54h
.text:000019C0 var_50          = dword ptr -50h
.text:000019C0 var_4C          = dword ptr -4Ch
.text:000019C0 var_48          = dword ptr -48h
.text:000019C0 var_44          = dword ptr -44h
.text:000019C0 var_40          = dword ptr -40h
.text:000019C0 var_38          = byte ptr -38h
.text:000019C0 var_30          = dword ptr -30h
.text:000019C0 var_28          = byte ptr -28h
.text:000019C0 var_1C          = byte ptr -1Ch
.text:000019C0 var_14          = dword ptr -14h
.text:000019C0 var_10          = dword ptr -10h
.text:000019C0 var_C           = dword ptr -0Ch
.text:000019C0 var_4           = dword ptr -4
.text:000019C0
.text:000019C0                 push    ebp
.text:000019C1                 mov     ebp, esp
.text:000019C3                 push    0FFFFFFFFh
.text:000019C5                 push    offset __ehhandler$?Encode@CEncoderInfo@@QAEJXZ
.text:000019CA                 mov     eax, large fs:0
.text:000019D0                 push    eax
.text:000019D1                 sub     esp, 0C4h
.text:000019D7                 push    esi
.text:000019D8                 push    edi
.text:000019D9                 push    ecx
.text:000019DA                 lea     edi, [ebp+var_D0]
.text:000019E0                 mov     ecx, 31h ; '1'
.text:000019E5                 mov     eax, 0CCCCCCCCh
.text:000019EA                 rep stosd
.text:000019EC                 pop     ecx
.text:000019ED                 mov     eax, dword ptr ds:___security_cookie
.text:000019F2                 xor     eax, ebp
.text:000019F4                 push    eax
.text:000019F5                 lea     eax, [ebp+var_C]
.text:000019F8                 mov     large fs:0, eax
.text:000019FE                 mov     [ebp+var_10], ecx
.text:00001A01                 mov     eax, [ebp+var_10]
.text:00001A04                 mov     ecx, [eax+14h]
.text:00001A07                 add     ecx, 8
.text:00001A0A                 mov     [ebp+var_14], ecx
.text:00001A0D                 mov     edx, [ebp+var_14]
.text:00001A10                 mov     dword ptr [edx+20h], 0
.text:00001A17                 mov     dword ptr [edx+24h], 0
.text:00001A1E                 mov     eax, [ebp+var_14]
.text:00001A21                 mov     dword ptr [eax+28h], 0
.text:00001A28                 mov     dword ptr [eax+2Ch], 0
.text:00001A2F                 lea     ecx, [ebp+var_1C]
.text:00001A32                 call    ??0?$CMyComPtr@UICryptoProperties@@@@QAE@XZ ; CMyComPtr<ICryptoProperties>::CMyComPtr<ICryptoProperties>(void)
.text:00001A37                 mov     [ebp+var_4], 0
.text:00001A3E                 lea     ecx, [ebp+var_28]
.text:00001A41                 call    ??0?$CMyComPtr@UIUnknown@@@@QAE@XZ ; CMyComPtr<IUnknown>::CMyComPtr<IUnknown>(void)
.text:00001A46                 mov     byte ptr [ebp+var_4], 1
.text:00001A4A                 mov     ecx, [ebp+var_10]
.text:00001A4D                 add     ecx, 10h
.text:00001A50                 call    ??B?$CMyComPtr@UICompressFilter@@@@QBEPAUICompressFilter@@XZ ; CMyComPtr<ICompressFilter>::operator ICompressFilter *(void)
.text:00001A55                 test    eax, eax
.text:00001A57                 jz      short loc_1A6F
.text:00001A59                 mov     ecx, [ebp+var_10]
.text:00001A5C                 add     ecx, 10h
.text:00001A5F                 call    ??B?$CMyComPtr@UICompressFilter@@@@QBEPAUICompressFilter@@XZ ; CMyComPtr<ICompressFilter>::operator ICompressFilter *(void)
.text:00001A64                 push    eax
.text:00001A65                 lea     ecx, [ebp+var_28]
.text:00001A68                 call    ??4?$CMyComPtr@UIUnknown@@@@QAEPAUIUnknown@@PAU1@@Z ; CMyComPtr<IUnknown>::operator=(IUnknown *)
.text:00001A6D                 jmp     short loc_1A83
.text:00001A6F ; ---------------------------------------------------------------------------
.text:00001A6F
.text:00001A6F loc_1A6F:                               ; CODE XREF: CEncoderInfo::Encode(void)+97j
.text:00001A6F                 mov     ecx, [ebp+var_10]
.text:00001A72                 add     ecx, 0Ch
.text:00001A75                 call    ??B?$CMyComPtr@UICompressCoder@@@@QBEPAUICompressCoder@@XZ ; CMyComPtr<ICompressCoder>::operator ICompressCoder *(void)
.text:00001A7A                 push    eax
.text:00001A7B                 lea     ecx, [ebp+var_28]
.text:00001A7E                 call    ??4?$CMyComPtr@UIUnknown@@@@QAEPAUIUnknown@@PAU1@@Z ; CMyComPtr<IUnknown>::operator=(IUnknown *)
.text:00001A83
.text:00001A83 loc_1A83:                               ; CODE XREF: CEncoderInfo::Encode(void)+ADj
.text:00001A83                 lea     ecx, [ebp+var_1C]
.text:00001A86                 call    ??I?$CMyComPtr@UICryptoProperties@@@@QAEPAPAUICryptoProperties@@XZ ; CMyComPtr<ICryptoProperties>::operator&(void)
.text:00001A8B                 push    eax
.text:00001A8C                 push    offset _IID_ICryptoProperties
.text:00001A91                 lea     ecx, [ebp+var_28]
.text:00001A94                 call    ??$QueryInterface@UICryptoProperties@@@?$CMyComPtr@UIUnknown@@@@QBEJABU_GUID@@PAPAUICryptoProperties@@@Z ; CMyComPtr<IUnknown>::QueryInterface<ICryptoProperties>(_GUID const &,ICryptoProperties * *)
.text:00001A99                 push    14h             ; unsigned int
.text:00001A9B                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00001AA0                 add     esp, 4
.text:00001AA3                 mov     [ebp+var_74], eax
.text:00001AA6                 mov     byte ptr [ebp+var_4], 2
.text:00001AAA                 cmp     [ebp+var_74], 0
.text:00001AAE                 jz      short loc_1AC0
.text:00001AB0                 mov     ecx, [ebp+var_74]
.text:00001AB3                 call    ??0CBenchmarkInStream@@QAE@XZ ; CBenchmarkInStream::CBenchmarkInStream(void)
.text:00001AB8                 mov     [ebp+var_94], eax
.text:00001ABE                 jmp     short loc_1ACA
.text:00001AC0 ; ---------------------------------------------------------------------------
.text:00001AC0
.text:00001AC0 loc_1AC0:                               ; CODE XREF: CEncoderInfo::Encode(void)+EEj
.text:00001AC0                 mov     [ebp+var_94], 0
.text:00001ACA
.text:00001ACA loc_1ACA:                               ; CODE XREF: CEncoderInfo::Encode(void)+FEj
.text:00001ACA                 mov     ecx, [ebp+var_94]
.text:00001AD0                 mov     [ebp+var_70], ecx
.text:00001AD3                 mov     byte ptr [ebp+var_4], 1
.text:00001AD7                 mov     edx, [ebp+var_70]
.text:00001ADA                 mov     [ebp+var_30], edx
.text:00001ADD                 mov     eax, [ebp+var_30]
.text:00001AE0                 push    eax
.text:00001AE1                 lea     ecx, [ebp+var_38]
.text:00001AE4                 call    ??0?$CMyComPtr@UISequentialInStream@@@@QAE@PAUISequentialInStream@@@Z ; CMyComPtr<ISequentialInStream>::CMyComPtr<ISequentialInStream>(ISequentialInStream *)
.text:00001AE9                 mov     byte ptr [ebp+var_4], 3
.text:00001AED                 mov     [ebp+var_44], 0
.text:00001AF4                 mov     [ebp+var_40], 0
.text:00001AFB                 mov     [ebp+var_48], 0
.text:00001B02                 lea     ecx, [ebp+var_1C]
.text:00001B05                 call    ??B?$CMyComPtr@UICryptoProperties@@@@QBEPAUICryptoProperties@@XZ ; CMyComPtr<ICryptoProperties>::operator ICryptoProperties *(void)
.text:00001B0A                 test    eax, eax
.text:00001B0C                 jz      loc_1BF6
.text:00001B12                 lea     ecx, [ebp+var_1C]
.text:00001B15                 call    ??C?$CMyComPtr@UICryptoProperties@@@@QBEPAUICryptoProperties@@XZ ; CMyComPtr<ICryptoProperties>::operator->(void)
.text:00001B1A                 mov     [ebp+var_98], eax
.text:00001B20                 mov     esi, esp
.text:00001B22                 push    20h ; ' '
.text:00001B24                 mov     ecx, [ebp+var_10]
.text:00001B27                 add     ecx, 34h ; '4'
.text:00001B2A                 push    ecx
.text:00001B2B                 mov     edx, [ebp+var_98]
.text:00001B31                 push    edx
.text:00001B32                 mov     eax, [ebp+var_98]
.text:00001B38                 mov     ecx, [eax]
.text:00001B3A                 mov     edx, [ecx+0Ch]
.text:00001B3D                 call    edx
.text:00001B3F                 cmp     esi, esp
.text:00001B41                 call    __RTC_CheckEsp
.text:00001B46                 mov     [ebp+var_4C], eax
.text:00001B49                 cmp     [ebp+var_4C], 0
.text:00001B4D                 jz      short loc_1B84
.text:00001B4F                 mov     eax, [ebp+var_4C]
.text:00001B52                 mov     [ebp+var_78], eax
.text:00001B55                 mov     byte ptr [ebp+var_4], 1
.text:00001B59                 lea     ecx, [ebp+var_38]
.text:00001B5C                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:00001B61                 mov     byte ptr [ebp+var_4], 0
.text:00001B65                 lea     ecx, [ebp+var_28]
.text:00001B68                 call    ??1?$CMyComPtr@UIUnknown@@@@QAE@XZ ; CMyComPtr<IUnknown>::~CMyComPtr<IUnknown>(void)
.text:00001B6D                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001B74                 lea     ecx, [ebp+var_1C]
.text:00001B77                 call    ??1?$CMyComPtr@UICryptoProperties@@@@QAE@XZ ; CMyComPtr<ICryptoProperties>::~CMyComPtr<ICryptoProperties>(void)
.text:00001B7C                 mov     eax, [ebp+var_78]
.text:00001B7F                 jmp     loc_20B8
.text:00001B84 ; ---------------------------------------------------------------------------
.text:00001B84
.text:00001B84 loc_1B84:                               ; CODE XREF: CEncoderInfo::Encode(void)+18Dj
.text:00001B84                 lea     ecx, [ebp+var_1C]
.text:00001B87                 call    ??C?$CMyComPtr@UICryptoProperties@@@@QBEPAUICryptoProperties@@XZ ; CMyComPtr<ICryptoProperties>::operator->(void)
.text:00001B8C                 mov     [ebp+var_9C], eax
.text:00001B92                 mov     esi, esp
.text:00001B94                 push    10h
.text:00001B96                 mov     ecx, [ebp+var_10]
.text:00001B99                 add     ecx, 54h ; 'T'
.text:00001B9C                 push    ecx
.text:00001B9D                 mov     edx, [ebp+var_9C]
.text:00001BA3                 push    edx
.text:00001BA4                 mov     eax, [ebp+var_9C]
.text:00001BAA                 mov     ecx, [eax]
.text:00001BAC                 mov     edx, [ecx+10h]
.text:00001BAF                 call    edx
.text:00001BB1                 cmp     esi, esp
.text:00001BB3                 call    __RTC_CheckEsp
.text:00001BB8                 mov     [ebp+var_50], eax
.text:00001BBB                 cmp     [ebp+var_50], 0
.text:00001BBF                 jz      short loc_1BF6
.text:00001BC1                 mov     eax, [ebp+var_50]
.text:00001BC4                 mov     [ebp+var_7C], eax
.text:00001BC7                 mov     byte ptr [ebp+var_4], 1
.text:00001BCB                 lea     ecx, [ebp+var_38]
.text:00001BCE                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:00001BD3                 mov     byte ptr [ebp+var_4], 0
.text:00001BD7                 lea     ecx, [ebp+var_28]
.text:00001BDA                 call    ??1?$CMyComPtr@UIUnknown@@@@QAE@XZ ; CMyComPtr<IUnknown>::~CMyComPtr<IUnknown>(void)
.text:00001BDF                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001BE6                 lea     ecx, [ebp+var_1C]
.text:00001BE9                 call    ??1?$CMyComPtr@UICryptoProperties@@@@QAE@XZ ; CMyComPtr<ICryptoProperties>::~CMyComPtr<ICryptoProperties>(void)
.text:00001BEE                 mov     eax, [ebp+var_7C]
.text:00001BF1                 jmp     loc_20B8
.text:00001BF6 ; ---------------------------------------------------------------------------
.text:00001BF6
.text:00001BF6 loc_1BF6:                               ; CODE XREF: CEncoderInfo::Encode(void)+14Cj
.text:00001BF6                                         ; CEncoderInfo::Encode(void)+1FFj
.text:00001BF6                 mov     [ebp+var_58], 0
.text:00001BFD                 mov     [ebp+var_54], 0
.text:00001C04                 jmp     short loc_1C18
.text:00001C06 ; ---------------------------------------------------------------------------
.text:00001C06
.text:00001C06 loc_1C06:                               ; CODE XREF: CEncoderInfo::Encode(void)+6A6j
.text:00001C06                 mov     ecx, [ebp+var_58]
.text:00001C09                 add     ecx, 1
.text:00001C0C                 mov     edx, [ebp+var_54]
.text:00001C0F                 adc     edx, 0
.text:00001C12                 mov     [ebp+var_58], ecx
.text:00001C15                 mov     [ebp+var_54], edx
.text:00001C18
.text:00001C18 loc_1C18:                               ; CODE XREF: CEncoderInfo::Encode(void)+244j
.text:00001C18                 mov     eax, [ebp+var_10]
.text:00001C1B                 mov     [ebp+var_A0], eax
.text:00001C21                 mov     ecx, [ebp+var_A0]
.text:00001C27                 mov     edx, [ebp+var_54]
.text:00001C2A                 cmp     edx, [ecx+2Ch]
.text:00001C2D                 ja      loc_206B
.text:00001C33                 jb      short loc_1C47
.text:00001C35                 mov     eax, [ebp+var_A0]
.text:00001C3B                 mov     ecx, [ebp+var_58]
.text:00001C3E                 cmp     ecx, [eax+28h]
.text:00001C41                 jnb     loc_206B
.text:00001C47
.text:00001C47 loc_1C47:                               ; CODE XREF: CEncoderInfo::Encode(void)+273j
.text:00001C47                 mov     edx, [ebp+var_10]
.text:00001C4A                 cmp     dword ptr [edx+0B8h], 0
.text:00001C51                 jz      loc_1CF8
.text:00001C57                 mov     eax, [ebp+var_14]
.text:00001C5A                 mov     ecx, [eax+20h]
.text:00001C5D                 sub     ecx, [ebp+var_44]
.text:00001C60                 mov     edx, [eax+24h]
.text:00001C63                 sbb     edx, [ebp+var_40]
.text:00001C66                 mov     [ebp+var_A8], ecx
.text:00001C6C                 mov     [ebp+var_A4], edx
.text:00001C72                 cmp     [ebp+var_A4], 0
.text:00001C79                 ja      short loc_1C87
.text:00001C7B                 cmp     [ebp+var_A8], 100000h
.text:00001C85                 jbe     short loc_1CF8
.text:00001C87
.text:00001C87 loc_1C87:                               ; CODE XREF: CEncoderInfo::Encode(void)+2B9j
.text:00001C87                 mov     eax, [ebp+var_10]
.text:00001C8A                 mov     ecx, [eax+0B8h]
.text:00001C90                 mov     edx, [ebp+var_10]
.text:00001C93                 mov     eax, [edx+0B8h]
.text:00001C99                 mov     edx, [ecx]
.text:00001C9B                 mov     esi, esp
.text:00001C9D                 mov     ecx, eax
.text:00001C9F                 mov     eax, [edx+8]
.text:00001CA2                 call    eax
.text:00001CA4                 cmp     esi, esp
.text:00001CA6                 call    __RTC_CheckEsp
.text:00001CAB                 mov     [ebp+var_5C], eax
.text:00001CAE                 cmp     [ebp+var_5C], 0
.text:00001CB2                 jz      short loc_1CE9
.text:00001CB4                 mov     ecx, [ebp+var_5C]
.text:00001CB7                 mov     [ebp+var_80], ecx
.text:00001CBA                 mov     byte ptr [ebp+var_4], 1
.text:00001CBE                 lea     ecx, [ebp+var_38]
.text:00001CC1                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:00001CC6                 mov     byte ptr [ebp+var_4], 0
.text:00001CCA                 lea     ecx, [ebp+var_28]
.text:00001CCD                 call    ??1?$CMyComPtr@UIUnknown@@@@QAE@XZ ; CMyComPtr<IUnknown>::~CMyComPtr<IUnknown>(void)
.text:00001CD2                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001CD9                 lea     ecx, [ebp+var_1C]
.text:00001CDC                 call    ??1?$CMyComPtr@UICryptoProperties@@@@QAE@XZ ; CMyComPtr<ICryptoProperties>::~CMyComPtr<ICryptoProperties>(void)
.text:00001CE1                 mov     eax, [ebp+var_80]
.text:00001CE4                 jmp     loc_20B8
.text:00001CE9 ; ---------------------------------------------------------------------------
.text:00001CE9
.text:00001CE9 loc_1CE9:                               ; CODE XREF: CEncoderInfo::Encode(void)+2F2j
.text:00001CE9                 mov     edx, [ebp+var_14]
.text:00001CEC                 mov     eax, [edx+20h]
.text:00001CEF                 mov     [ebp+var_44], eax
.text:00001CF2                 mov     ecx, [edx+24h]
.text:00001CF5                 mov     [ebp+var_40], ecx
.text:00001CF8
.text:00001CF8 loc_1CF8:                               ; CODE XREF: CEncoderInfo::Encode(void)+291j
.text:00001CF8                                         ; CEncoderInfo::Encode(void)+2C5j
.text:00001CF8                 mov     edx, [ebp+var_10]
.text:00001CFB                 mov     eax, [edx+28h]
.text:00001CFE                 sub     eax, 1
.text:00001D01                 mov     ecx, [edx+2Ch]
.text:00001D04                 sbb     ecx, 0
.text:00001D07                 mov     [ebp+var_B0], eax
.text:00001D0D                 mov     [ebp+var_AC], ecx
.text:00001D13                 mov     edx, [ebp+var_58]
.text:00001D16                 cmp     edx, [ebp+var_B0]
.text:00001D1C                 jnz     short loc_1D35
.text:00001D1E                 mov     eax, [ebp+var_54]
.text:00001D21                 cmp     eax, [ebp+var_AC]
.text:00001D27                 jnz     short loc_1D35
.text:00001D29                 mov     [ebp+var_B4], 1
.text:00001D33                 jmp     short loc_1D3F
.text:00001D35 ; ---------------------------------------------------------------------------
.text:00001D35
.text:00001D35 loc_1D35:                               ; CODE XREF: CEncoderInfo::Encode(void)+35Cj
.text:00001D35                                         ; CEncoderInfo::Encode(void)+367j
.text:00001D35                 mov     [ebp+var_B4], 0
.text:00001D3F
.text:00001D3F loc_1D3F:                               ; CODE XREF: CEncoderInfo::Encode(void)+373j
.text:00001D3F                 mov     cl, byte ptr [ebp+var_B4]
.text:00001D45                 mov     [ebp+var_5D], cl
.text:00001D48                 movzx   edx, [ebp+var_5D]
.text:00001D4C                 test    edx, edx
.text:00001D4E                 jnz     short loc_1D81
.text:00001D50                 mov     eax, [ebp+var_58]
.text:00001D53                 and     eax, 7Fh
.text:00001D56                 mov     ecx, [ebp+var_54]
.text:00001D59                 and     ecx, 0
.text:00001D5C                 mov     [ebp+var_BC], eax
.text:00001D62                 mov     [ebp+var_B8], ecx
.text:00001D68                 mov     edx, [ebp+var_BC]
.text:00001D6E                 or      edx, [ebp+var_B8]
.text:00001D74                 jz      short loc_1D81
.text:00001D76                 mov     eax, [ebp+var_10]
.text:00001D79                 movzx   ecx, byte ptr [eax+74h]
.text:00001D7D                 test    ecx, ecx
.text:00001D7F                 jz      short loc_1DAE
.text:00001D81
.text:00001D81 loc_1D81:                               ; CODE XREF: CEncoderInfo::Encode(void)+38Ej
.text:00001D81                                         ; CEncoderInfo::Encode(void)+3B4j
.text:00001D81                 mov     edx, [ebp+var_10]
.text:00001D84                 mov     [ebp+var_C0], edx
.text:00001D8A                 mov     eax, [ebp+var_C0]
.text:00001D90                 cmp     dword ptr [eax+28h], 1
.text:00001D94                 jnz     short loc_1DA2
.text:00001D96                 mov     ecx, [ebp+var_C0]
.text:00001D9C                 cmp     dword ptr [ecx+2Ch], 0
.text:00001DA0                 jz      short loc_1DAE
.text:00001DA2
.text:00001DA2 loc_1DA2:                               ; CODE XREF: CEncoderInfo::Encode(void)+3D4j
.text:00001DA2                 mov     [ebp+var_C4], 1
.text:00001DAC                 jmp     short loc_1DB8
.text:00001DAE ; ---------------------------------------------------------------------------
.text:00001DAE
.text:00001DAE loc_1DAE:                               ; CODE XREF: CEncoderInfo::Encode(void)+3BFj
.text:00001DAE                                         ; CEncoderInfo::Encode(void)+3E0j
.text:00001DAE                 mov     [ebp+var_C4], 0
.text:00001DB8
.text:00001DB8 loc_1DB8:                               ; CODE XREF: CEncoderInfo::Encode(void)+3ECj
.text:00001DB8                 mov     dl, byte ptr [ebp+var_C4]
.text:00001DBE                 mov     [ebp+var_5E], dl
.text:00001DC1                 movzx   eax, [ebp+var_5E]
.text:00001DC5                 push    eax             ; bool
.text:00001DC6                 movzx   ecx, [ebp+var_5D]
.text:00001DCA                 push    ecx             ; bool
.text:00001DCB                 mov     edx, [ebp+var_10]
.text:00001DCE                 mov     ecx, [edx+0ACh] ; this
.text:00001DD4                 call    ?Init@CBenchmarkOutStream@@QAEX_N0@Z ; CBenchmarkOutStream::Init(bool,bool)
.text:00001DD9                 mov     ecx, [ebp+var_10]
.text:00001DDC                 add     ecx, 10h
.text:00001DDF                 call    ??B?$CMyComPtr@UICompressFilter@@@@QBEPAUICompressFilter@@XZ ; CMyComPtr<ICompressFilter>::operator ICompressFilter *(void)
.text:00001DE4                 test    eax, eax
.text:00001DE6                 jz      loc_1EF3
.text:00001DEC                 mov     eax, [ebp+var_10]
.text:00001DEF                 mov     ecx, [eax+0CCh]
.text:00001DF5                 push    ecx             ; Size
.text:00001DF6                 mov     edx, [ebp+var_10]
.text:00001DF9                 mov     eax, [edx+0D0h]
.text:00001DFF                 push    eax             ; Src
.text:00001E00                 mov     ecx, [ebp+var_10]
.text:00001E03                 mov     edx, [ecx+0E0h]
.text:00001E09                 push    edx             ; Dst
.text:00001E0A                 call    _memcpy
.text:00001E0F                 add     esp, 0Ch
.text:00001E12                 mov     ecx, [ebp+var_10]
.text:00001E15                 add     ecx, 10h
.text:00001E18                 call    ??C?$CMyComPtr@UICompressFilter@@@@QBEPAUICompressFilter@@XZ ; CMyComPtr<ICompressFilter>::operator->(void)
.text:00001E1D                 mov     [ebp+var_C8], eax
.text:00001E23                 mov     eax, [ebp+var_C8]
.text:00001E29                 mov     ecx, [eax]
.text:00001E2B                 mov     esi, esp
.text:00001E2D                 mov     edx, [ebp+var_C8]
.text:00001E33                 push    edx
.text:00001E34                 mov     eax, [ecx+0Ch]
.text:00001E37                 call    eax
.text:00001E39                 cmp     esi, esp
.text:00001E3B                 call    __RTC_CheckEsp
.text:00001E40                 mov     ecx, [ebp+var_10]
.text:00001E43                 add     ecx, 10h
.text:00001E46                 call    ??C?$CMyComPtr@UICompressFilter@@@@QBEPAUICompressFilter@@XZ ; CMyComPtr<ICompressFilter>::operator->(void)
.text:00001E4B                 mov     [ebp+var_CC], eax
.text:00001E51                 mov     esi, esp
.text:00001E53                 mov     ecx, [ebp+var_10]
.text:00001E56                 mov     edx, [ecx+0CCh]
.text:00001E5C                 push    edx
.text:00001E5D                 mov     eax, [ebp+var_10]
.text:00001E60                 mov     ecx, [eax+0E0h]
.text:00001E66                 push    ecx
.text:00001E67                 mov     edx, [ebp+var_CC]
.text:00001E6D                 push    edx
.text:00001E6E                 mov     eax, [ebp+var_CC]
.text:00001E74                 mov     ecx, [eax]
.text:00001E76                 mov     edx, [ecx+10h]
.text:00001E79                 call    edx
.text:00001E7B                 cmp     esi, esp
.text:00001E7D                 call    __RTC_CheckEsp
.text:00001E82                 mov     eax, [ebp+var_10]
.text:00001E85                 mov     ecx, [eax+0CCh]
.text:00001E8B                 push    ecx             ; unsigned int
.text:00001E8C                 mov     edx, [ebp+var_10]
.text:00001E8F                 mov     eax, [edx+0E0h]
.text:00001E95                 push    eax             ; void *
.text:00001E96                 mov     ecx, [ebp+var_10]
.text:00001E99                 add     ecx, 0B0h ; '¦'
.text:00001E9F                 call    ??B?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ ; CMyComPtr<ISequentialOutStream>::operator ISequentialOutStream *(void)
.text:00001EA4                 push    eax             ; struct ISequentialOutStream *
.text:00001EA5                 call    ?WriteStream@@YGJPAUISequentialOutStream@@PBXI@Z ; WriteStream(ISequentialOutStream *,void const *,uint)
.text:00001EAA                 mov     [ebp+var_64], eax
.text:00001EAD                 cmp     [ebp+var_64], 0
.text:00001EB1                 jz      short loc_1EEE
.text:00001EB3                 mov     ecx, [ebp+var_64]
.text:00001EB6                 mov     [ebp+var_84], ecx
.text:00001EBC                 mov     byte ptr [ebp+var_4], 1
.text:00001EC0                 lea     ecx, [ebp+var_38]
.text:00001EC3                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:00001EC8                 mov     byte ptr [ebp+var_4], 0
.text:00001ECC                 lea     ecx, [ebp+var_28]
.text:00001ECF                 call    ??1?$CMyComPtr@UIUnknown@@@@QAE@XZ ; CMyComPtr<IUnknown>::~CMyComPtr<IUnknown>(void)
.text:00001ED4                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001EDB                 lea     ecx, [ebp+var_1C]
.text:00001EDE                 call    ??1?$CMyComPtr@UICryptoProperties@@@@QAE@XZ ; CMyComPtr<ICryptoProperties>::~CMyComPtr<ICryptoProperties>(void)
.text:00001EE3                 mov     eax, [ebp+var_84]
.text:00001EE9                 jmp     loc_20B8
.text:00001EEE ; ---------------------------------------------------------------------------
.text:00001EEE
.text:00001EEE loc_1EEE:                               ; CODE XREF: CEncoderInfo::Encode(void)+4F1j
.text:00001EEE                 jmp     loc_1FA9
.text:00001EF3 ; ---------------------------------------------------------------------------
.text:00001EF3
.text:00001EF3 loc_1EF3:                               ; CODE XREF: CEncoderInfo::Encode(void)+426j
.text:00001EF3                 mov     edx, [ebp+var_10]
.text:00001EF6                 mov     eax, [edx+0CCh]
.text:00001EFC                 push    eax             ; unsigned int
.text:00001EFD                 mov     ecx, [ebp+var_10]
.text:00001F00                 mov     edx, [ecx+0D0h]
.text:00001F06                 push    edx             ; unsigned __int8 *
.text:00001F07                 mov     ecx, [ebp+var_30] ; this
.text:00001F0A                 call    ?Init@CBenchmarkInStream@@QAEXPBEI@Z ; CBenchmarkInStream::Init(uchar const *,uint)
.text:00001F0F                 mov     ecx, [ebp+var_10]
.text:00001F12                 add     ecx, 0Ch
.text:00001F15                 call    ??C?$CMyComPtr@UICompressCoder@@@@QBEPAUICompressCoder@@XZ ; CMyComPtr<ICompressCoder>::operator->(void)
.text:00001F1A                 mov     [ebp+var_D0], eax
.text:00001F20                 mov     ecx, [ebp+var_10]
.text:00001F23                 add     ecx, 1Ch
.text:00001F26                 call    ??B?$CMyComPtr@UICompressProgressInfo@@@@QBEPAUICompressProgressInfo@@XZ ; CMyComPtr<ICompressProgressInfo>::operator ICompressProgressInfo *(void)
.text:00001F2B                 mov     esi, esp
.text:00001F2D                 push    eax
.text:00001F2E                 push    0
.text:00001F30                 push    0
.text:00001F32                 mov     ecx, [ebp+var_10]
.text:00001F35                 add     ecx, 0B0h ; '¦'
.text:00001F3B                 call    ??B?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ ; CMyComPtr<ISequentialOutStream>::operator ISequentialOutStream *(void)
.text:00001F40                 push    eax
.text:00001F41                 lea     ecx, [ebp+var_38]
.text:00001F44                 call    ??B?$CMyComPtr@UISequentialInStream@@@@QBEPAUISequentialInStream@@XZ ; CMyComPtr<ISequentialInStream>::operator ISequentialInStream *(void)
.text:00001F49                 push    eax
.text:00001F4A                 mov     eax, [ebp+var_D0]
.text:00001F50                 push    eax
.text:00001F51                 mov     ecx, [ebp+var_D0]
.text:00001F57                 mov     edx, [ecx]
.text:00001F59                 mov     eax, [edx+0Ch]
.text:00001F5C                 call    eax
.text:00001F5E                 cmp     esi, esp
.text:00001F60                 call    __RTC_CheckEsp
.text:00001F65                 mov     [ebp+var_68], eax
.text:00001F68                 cmp     [ebp+var_68], 0
.text:00001F6C                 jz      short loc_1FA9
.text:00001F6E                 mov     ecx, [ebp+var_68]
.text:00001F71                 mov     [ebp+var_88], ecx
.text:00001F77                 mov     byte ptr [ebp+var_4], 1
.text:00001F7B                 lea     ecx, [ebp+var_38]
.text:00001F7E                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:00001F83                 mov     byte ptr [ebp+var_4], 0
.text:00001F87                 lea     ecx, [ebp+var_28]
.text:00001F8A                 call    ??1?$CMyComPtr@UIUnknown@@@@QAE@XZ ; CMyComPtr<IUnknown>::~CMyComPtr<IUnknown>(void)
.text:00001F8F                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001F96                 lea     ecx, [ebp+var_1C]
.text:00001F99                 call    ??1?$CMyComPtr@UICryptoProperties@@@@QAE@XZ ; CMyComPtr<ICryptoProperties>::~CMyComPtr<ICryptoProperties>(void)
.text:00001F9E                 mov     eax, [ebp+var_88]
.text:00001FA4                 jmp     loc_20B8
.text:00001FA9 ; ---------------------------------------------------------------------------
.text:00001FA9
.text:00001FA9 loc_1FA9:                               ; CODE XREF: CEncoderInfo::Encode(void):loc_1EEEj
.text:00001FA9                                         ; CEncoderInfo::Encode(void)+5ACj
.text:00001FA9                 mov     edx, [ebp+var_10]
.text:00001FAC                 mov     eax, [edx+0ACh]
.text:00001FB2                 mov     ecx, [eax+1Ch]
.text:00001FB5                 xor     ecx, 0FFFFFFFFh
.text:00001FB8                 mov     [ebp+var_6C], ecx
.text:00001FBB                 mov     edx, [ebp+var_58]
.text:00001FBE                 or      edx, [ebp+var_54]
.text:00001FC1                 jnz     short loc_1FCB
.text:00001FC3                 mov     eax, [ebp+var_6C]
.text:00001FC6                 mov     [ebp+var_48], eax
.text:00001FC9                 jmp     short loc_2017
.text:00001FCB ; ---------------------------------------------------------------------------
.text:00001FCB
.text:00001FCB loc_1FCB:                               ; CODE XREF: CEncoderInfo::Encode(void)+601j
.text:00001FCB                 movzx   ecx, [ebp+var_5E]
.text:00001FCF                 test    ecx, ecx
.text:00001FD1                 jz      short loc_2017
.text:00001FD3                 mov     edx, [ebp+var_48]
.text:00001FD6                 cmp     edx, [ebp+var_6C]
.text:00001FD9                 jz      short loc_2017
.text:00001FDB                 mov     [ebp+var_8C], 80004005h
.text:00001FE5                 mov     byte ptr [ebp+var_4], 1
.text:00001FE9                 lea     ecx, [ebp+var_38]
.text:00001FEC                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:00001FF1                 mov     byte ptr [ebp+var_4], 0
.text:00001FF5                 lea     ecx, [ebp+var_28]
.text:00001FF8                 call    ??1?$CMyComPtr@UIUnknown@@@@QAE@XZ ; CMyComPtr<IUnknown>::~CMyComPtr<IUnknown>(void)
.text:00001FFD                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00002004                 lea     ecx, [ebp+var_1C]
.text:00002007                 call    ??1?$CMyComPtr@UICryptoProperties@@@@QAE@XZ ; CMyComPtr<ICryptoProperties>::~CMyComPtr<ICryptoProperties>(void)
.text:0000200C                 mov     eax, [ebp+var_8C]
.text:00002012                 jmp     loc_20B8
.text:00002017 ; ---------------------------------------------------------------------------
.text:00002017
.text:00002017 loc_2017:                               ; CODE XREF: CEncoderInfo::Encode(void)+609j
.text:00002017                                         ; CEncoderInfo::Encode(void)+611j ...
.text:00002017                 mov     eax, [ebp+var_10]
.text:0000201A                 mov     ecx, [eax+0ACh]
.text:00002020                 mov     edx, [ebp+var_10]
.text:00002023                 mov     eax, [ecx+14h]
.text:00002026                 mov     [edx+0C4h], eax
.text:0000202C                 mov     ecx, [ebp+var_10]
.text:0000202F                 mov     edx, [ecx+0CCh]
.text:00002035                 xor     eax, eax
.text:00002037                 mov     ecx, [ebp+var_14]
.text:0000203A                 add     edx, [ecx+20h]
.text:0000203D                 adc     eax, [ecx+24h]
.text:00002040                 mov     ecx, [ebp+var_14]
.text:00002043                 mov     [ecx+20h], edx
.text:00002046                 mov     [ecx+24h], eax
.text:00002049                 mov     edx, [ebp+var_10]
.text:0000204C                 mov     eax, [edx+0C4h]
.text:00002052                 xor     ecx, ecx
.text:00002054                 mov     edx, [ebp+var_14]
.text:00002057                 add     eax, [edx+28h]
.text:0000205A                 adc     ecx, [edx+2Ch]
.text:0000205D                 mov     edx, [ebp+var_14]
.text:00002060                 mov     [edx+28h], eax
.text:00002063                 mov     [edx+2Ch], ecx
.text:00002066                 jmp     loc_1C06
.text:0000206B ; ---------------------------------------------------------------------------
.text:0000206B
.text:0000206B loc_206B:                               ; CODE XREF: CEncoderInfo::Encode(void)+26Dj
.text:0000206B                                         ; CEncoderInfo::Encode(void)+281j
.text:0000206B                 mov     ecx, [ebp+var_10]
.text:0000206E                 add     ecx, 0Ch
.text:00002071                 call    ?Release@?$CMyComPtr@UICompressCoder@@@@QAEXXZ ; CMyComPtr<ICompressCoder>::Release(void)
.text:00002076                 mov     ecx, [ebp+var_10]
.text:00002079                 add     ecx, 10h
.text:0000207C                 call    ?Release@?$CMyComPtr@UICompressFilter@@@@QAEXXZ ; CMyComPtr<ICompressFilter>::Release(void)
.text:00002081                 mov     [ebp+var_90], 0
.text:0000208B                 mov     byte ptr [ebp+var_4], 1
.text:0000208F                 lea     ecx, [ebp+var_38]
.text:00002092                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:00002097                 mov     byte ptr [ebp+var_4], 0
.text:0000209B                 lea     ecx, [ebp+var_28]
.text:0000209E                 call    ??1?$CMyComPtr@UIUnknown@@@@QAE@XZ ; CMyComPtr<IUnknown>::~CMyComPtr<IUnknown>(void)
.text:000020A3                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000020AA                 lea     ecx, [ebp+var_1C]
.text:000020AD                 call    ??1?$CMyComPtr@UICryptoProperties@@@@QAE@XZ ; CMyComPtr<ICryptoProperties>::~CMyComPtr<ICryptoProperties>(void)
.text:000020B2                 mov     eax, [ebp+var_90]
.text:000020B8
.text:000020B8 loc_20B8:                               ; CODE XREF: CEncoderInfo::Encode(void)+1BFj
.text:000020B8                                         ; CEncoderInfo::Encode(void)+231j ...
.text:000020B8                 push    edx
.text:000020B9                 mov     ecx, ebp
.text:000020BB                 push    eax
.text:000020BC                 lea     edx, $LN39
.text:000020C2                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:000020C7                 pop     eax
.text:000020C8                 pop     edx
.text:000020C9                 mov     ecx, [ebp+var_C]
.text:000020CC                 mov     large fs:0, ecx
.text:000020D3                 pop     ecx
.text:000020D4                 pop     edi
.text:000020D5                 pop     esi
.text:000020D6                 add     esp, 0D0h
.text:000020DC                 cmp     ebp, esp
.text:000020DE                 call    __RTC_CheckEsp
.text:000020E3                 mov     esp, ebp
.text:000020E5                 pop     ebp
.text:000020E6                 retn
.text:000020E6 ?Encode@CEncoderInfo@@QAEJXZ endp
.text:000020E6
.text:000020E6 ; ---------------------------------------------------------------------------
.text:000020E7                 align 4
.text:000020E8 $LN39           dd 3                    ; DATA XREF: CEncoderInfo::Encode(void)+6FCo
.text:000020EC                 dd offset $LN38
.text:000020F0 $LN38           dd 0FFFFFFE4h, 4        ; DATA XREF: .text:000020ECo
.text:000020F8                 dd offset $LN34         ; "cp"
.text:000020FC                 dd 0FFFFFFD8h, 4
.text:00002104                 dd offset $LN35         ; "coder"
.text:00002108                 dd 0FFFFFFC8h, 4
.text:00002110                 dd offset $LN36         ; "inStream"
.text:00002114 $LN36           db 'inStream',0         ; DATA XREF: .text:00002110o
.text:0000211D $LN35           db 'coder',0            ; DATA XREF: .text:00002104o
.text:00002123 $LN34           db 'cp',0               ; DATA XREF: .text:000020F8o
.text:00002126                 align 10h
.text:00002130
.text:00002130 ; =============== S U B R O U T I N E =======================================
.text:00002130
.text:00002130 ; Attributes: bp-based frame
.text:00002130
.text:00002130 ; __int32 __thiscall CEncoderInfo::Decode(CEncoderInfo *this, unsigned int)
.text:00002130                 public ?Decode@CEncoderInfo@@QAEJI@Z
.text:00002130 ?Decode@CEncoderInfo@@QAEJI@Z proc near ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+B8Cp
.text:00002130                                         ; CEncoderInfo::DecodeThreadFunction(void *)+48p
.text:00002130
.text:00002130 var_15C         = dword ptr -15Ch
.text:00002130 var_158         = dword ptr -158h
.text:00002130 var_154         = dword ptr -154h
.text:00002130 var_150         = dword ptr -150h
.text:00002130 var_14C         = dword ptr -14Ch
.text:00002130 var_148         = dword ptr -148h
.text:00002130 var_144         = dword ptr -144h
.text:00002130 var_140         = dword ptr -140h
.text:00002130 var_13C         = dword ptr -13Ch
.text:00002130 var_138         = dword ptr -138h
.text:00002130 var_134         = dword ptr -134h
.text:00002130 var_130         = dword ptr -130h
.text:00002130 var_12C         = dword ptr -12Ch
.text:00002130 var_128         = dword ptr -128h
.text:00002130 var_124         = dword ptr -124h
.text:00002130 var_120         = dword ptr -120h
.text:00002130 var_11C         = dword ptr -11Ch
.text:00002130 var_118         = dword ptr -118h
.text:00002130 var_114         = dword ptr -114h
.text:00002130 var_110         = dword ptr -110h
.text:00002130 var_10C         = dword ptr -10Ch
.text:00002130 var_108         = dword ptr -108h
.text:00002130 var_104         = dword ptr -104h
.text:00002130 var_100         = dword ptr -100h
.text:00002130 var_FC          = dword ptr -0FCh
.text:00002130 var_F8          = dword ptr -0F8h
.text:00002130 var_F4          = dword ptr -0F4h
.text:00002130 var_F0          = dword ptr -0F0h
.text:00002130 var_EC          = dword ptr -0ECh
.text:00002130 var_E8          = dword ptr -0E8h
.text:00002130 var_E4          = dword ptr -0E4h
.text:00002130 var_E0          = dword ptr -0E0h
.text:00002130 var_DC          = dword ptr -0DCh
.text:00002130 var_D8          = dword ptr -0D8h
.text:00002130 var_D4          = dword ptr -0D4h
.text:00002130 var_D0          = dword ptr -0D0h
.text:00002130 var_C8          = dword ptr -0C8h
.text:00002130 var_C4          = dword ptr -0C4h
.text:00002130 var_BC          = dword ptr -0BCh
.text:00002130 var_B8          = dword ptr -0B8h
.text:00002130 var_B4          = dword ptr -0B4h
.text:00002130 var_B0          = dword ptr -0B0h
.text:00002130 var_AC          = dword ptr -0ACh
.text:00002130 var_A8          = dword ptr -0A8h
.text:00002130 var_A4          = dword ptr -0A4h
.text:00002130 var_A0          = dword ptr -0A0h
.text:00002130 var_98          = byte ptr -98h
.text:00002130 var_90          = dword ptr -90h
.text:00002130 var_88          = byte ptr -88h
.text:00002130 var_80          = dword ptr -80h
.text:00002130 var_78          = qword ptr -78h
.text:00002130 var_68          = byte ptr -68h
.text:00002130 var_60          = dword ptr -60h
.text:00002130 var_58          = byte ptr -58h
.text:00002130 var_50          = dword ptr -50h
.text:00002130 var_48          = byte ptr -48h
.text:00002130 var_40          = dword ptr -40h
.text:00002130 var_38          = byte ptr -38h
.text:00002130 var_2C          = byte ptr -2Ch
.text:00002130 var_24          = dword ptr -24h
.text:00002130 var_1C          = byte ptr -1Ch
.text:00002130 var_14          = dword ptr -14h
.text:00002130 var_10          = dword ptr -10h
.text:00002130 var_C           = dword ptr -0Ch
.text:00002130 var_4           = dword ptr -4
.text:00002130 arg_0           = dword ptr  8
.text:00002130
.text:00002130                 push    ebp
.text:00002131                 mov     ebp, esp
.text:00002133                 push    0FFFFFFFFh
.text:00002135                 push    offset __ehhandler$?Decode@CEncoderInfo@@QAEJI@Z
.text:0000213A                 mov     eax, large fs:0
.text:00002140                 push    eax
.text:00002141                 sub     esp, 150h
.text:00002147                 push    esi
.text:00002148                 push    edi
.text:00002149                 push    ecx
.text:0000214A                 lea     edi, [ebp+var_15C]
.text:00002150                 mov     ecx, 54h ; 'T'
.text:00002155                 mov     eax, 0CCCCCCCCh
.text:0000215A                 rep stosd
.text:0000215C                 pop     ecx
.text:0000215D                 mov     eax, dword ptr ds:___security_cookie
.text:00002162                 xor     eax, ebp
.text:00002164                 push    eax
.text:00002165                 lea     eax, [ebp+var_C]
.text:00002168                 mov     large fs:0, eax
.text:0000216E                 mov     [ebp+var_10], ecx
.text:00002171                 push    14h             ; unsigned int
.text:00002173                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00002178                 add     esp, 4
.text:0000217B                 mov     [ebp+var_DC], eax
.text:00002181                 mov     [ebp+var_4], 0
.text:00002188                 cmp     [ebp+var_DC], 0
.text:0000218F                 jz      short loc_21A4
.text:00002191                 mov     ecx, [ebp+var_DC]
.text:00002197                 call    ??0CBenchmarkInStream@@QAE@XZ ; CBenchmarkInStream::CBenchmarkInStream(void)
.text:0000219C                 mov     [ebp+var_120], eax
.text:000021A2                 jmp     short loc_21AE
.text:000021A4 ; ---------------------------------------------------------------------------
.text:000021A4
.text:000021A4 loc_21A4:                               ; CODE XREF: CEncoderInfo::Decode(uint)+5Fj
.text:000021A4                 mov     [ebp+var_120], 0
.text:000021AE
.text:000021AE loc_21AE:                               ; CODE XREF: CEncoderInfo::Decode(uint)+72j
.text:000021AE                 mov     eax, [ebp+var_120]
.text:000021B4                 mov     [ebp+var_D8], eax
.text:000021BA                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000021C1                 mov     ecx, [ebp+var_D8]
.text:000021C7                 mov     [ebp+var_14], ecx
.text:000021CA                 mov     edx, [ebp+var_14]
.text:000021CD                 push    edx
.text:000021CE                 lea     ecx, [ebp+var_1C]
.text:000021D1                 call    ??0?$CMyComPtr@UISequentialInStream@@@@QAE@PAUISequentialInStream@@@Z ; CMyComPtr<ISequentialInStream>::CMyComPtr<ISequentialInStream>(ISequentialInStream *)
.text:000021D6                 mov     [ebp+var_4], 1
.text:000021DD                 mov     eax, [ebp+arg_0]
.text:000021E0                 mov     ecx, [ebp+var_10]
.text:000021E3                 lea     edx, [ecx+eax*4+98h]
.text:000021EA                 mov     [ebp+var_24], edx
.text:000021ED                 lea     ecx, [ebp+var_2C]
.text:000021F0                 call    ??0?$CMyComPtr@UIUnknown@@@@QAE@XZ ; CMyComPtr<IUnknown>::CMyComPtr<IUnknown>(void)
.text:000021F5                 mov     byte ptr [ebp+var_4], 2
.text:000021F9                 mov     ecx, [ebp+var_10]
.text:000021FC                 add     ecx, 0A0h ; 'á'
.text:00002202                 call    ??B?$CMyComPtr@UICompressFilter@@@@QBEPAUICompressFilter@@XZ ; CMyComPtr<ICompressFilter>::operator ICompressFilter *(void)
.text:00002207                 test    eax, eax
.text:00002209                 jz      short loc_225A
.text:0000220B                 cmp     [ebp+arg_0], 0
.text:0000220F                 jz      short loc_2241
.text:00002211                 mov     [ebp+var_E0], 80004005h
.text:0000221B                 mov     byte ptr [ebp+var_4], 1
.text:0000221F                 lea     ecx, [ebp+var_2C]
.text:00002222                 call    ??1?$CMyComPtr@UIUnknown@@@@QAE@XZ ; CMyComPtr<IUnknown>::~CMyComPtr<IUnknown>(void)
.text:00002227                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000222E                 lea     ecx, [ebp+var_1C]
.text:00002231                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:00002236                 mov     eax, [ebp+var_E0]
.text:0000223C                 jmp     loc_2E2E
.text:00002241 ; ---------------------------------------------------------------------------
.text:00002241
.text:00002241 loc_2241:                               ; CODE XREF: CEncoderInfo::Decode(uint)+DFj
.text:00002241                 mov     ecx, [ebp+var_10]
.text:00002244                 add     ecx, 0A0h ; 'á'
.text:0000224A                 call    ??B?$CMyComPtr@UICompressFilter@@@@QBEPAUICompressFilter@@XZ ; CMyComPtr<ICompressFilter>::operator ICompressFilter *(void)
.text:0000224F                 push    eax
.text:00002250                 lea     ecx, [ebp+var_2C]
.text:00002253                 call    ??4?$CMyComPtr@UIUnknown@@@@QAEPAUIUnknown@@PAU1@@Z ; CMyComPtr<IUnknown>::operator=(IUnknown *)
.text:00002258                 jmp     short loc_226B
.text:0000225A ; ---------------------------------------------------------------------------
.text:0000225A
.text:0000225A loc_225A:                               ; CODE XREF: CEncoderInfo::Decode(uint)+D9j
.text:0000225A                 mov     ecx, [ebp+var_24]
.text:0000225D                 call    ??B?$CMyComPtr@UICompressCoder@@@@QBEPAUICompressCoder@@XZ ; CMyComPtr<ICompressCoder>::operator ICompressCoder *(void)
.text:00002262                 push    eax
.text:00002263                 lea     ecx, [ebp+var_2C]
.text:00002266                 call    ??4?$CMyComPtr@UIUnknown@@@@QAEPAUIUnknown@@PAU1@@Z ; CMyComPtr<IUnknown>::operator=(IUnknown *)
.text:0000226B
.text:0000226B loc_226B:                               ; CODE XREF: CEncoderInfo::Decode(uint)+128j
.text:0000226B                 lea     ecx, [ebp+var_38]
.text:0000226E                 call    ??0?$CMyComPtr@UICompressSetDecoderProperties2@@@@QAE@XZ ; CMyComPtr<ICompressSetDecoderProperties2>::CMyComPtr<ICompressSetDecoderProperties2>(void)
.text:00002273                 mov     byte ptr [ebp+var_4], 3
.text:00002277                 lea     ecx, [ebp+var_38]
.text:0000227A                 call    ??I?$CMyComPtr@UICompressSetDecoderProperties2@@@@QAEPAPAUICompressSetDecoderProperties2@@XZ ; CMyComPtr<ICompressSetDecoderProperties2>::operator&(void)
.text:0000227F                 push    eax
.text:00002280                 push    offset _IID_ICompressSetDecoderProperties2
.text:00002285                 lea     ecx, [ebp+var_2C]
.text:00002288                 call    ??$QueryInterface@UICompressSetDecoderProperties2@@@?$CMyComPtr@UIUnknown@@@@QBEJABU_GUID@@PAPAUICompressSetDecoderProperties2@@@Z ; CMyComPtr<IUnknown>::QueryInterface<ICompressSetDecoderProperties2>(_GUID const &,ICompressSetDecoderProperties2 * *)
.text:0000228D                 lea     ecx, [ebp+var_38]
.text:00002290                 call    ??7?$CMyComPtr@UICompressSetDecoderProperties2@@@@QBE_NXZ ; CMyComPtr<ICompressSetDecoderProperties2>::operator!(void)
.text:00002295                 movzx   eax, al
.text:00002298                 test    eax, eax
.text:0000229A                 jz      short loc_22E7
.text:0000229C                 mov     ecx, [ebp+var_10]
.text:0000229F                 mov     edx, [ecx+0E4h]
.text:000022A5                 cmp     dword ptr [edx+14h], 0
.text:000022A9                 jz      short loc_22E7
.text:000022AB                 mov     [ebp+var_E4], 80004005h
.text:000022B5                 mov     byte ptr [ebp+var_4], 2
.text:000022B9                 lea     ecx, [ebp+var_38]
.text:000022BC                 call    ??1?$CMyComPtr@UICompressSetDecoderProperties2@@@@QAE@XZ ; CMyComPtr<ICompressSetDecoderProperties2>::~CMyComPtr<ICompressSetDecoderProperties2>(void)
.text:000022C1                 mov     byte ptr [ebp+var_4], 1
.text:000022C5                 lea     ecx, [ebp+var_2C]
.text:000022C8                 call    ??1?$CMyComPtr@UIUnknown@@@@QAE@XZ ; CMyComPtr<IUnknown>::~CMyComPtr<IUnknown>(void)
.text:000022CD                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000022D4                 lea     ecx, [ebp+var_1C]
.text:000022D7                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:000022DC                 mov     eax, [ebp+var_E4]
.text:000022E2                 jmp     loc_2E2E
.text:000022E7 ; ---------------------------------------------------------------------------
.text:000022E7
.text:000022E7 loc_22E7:                               ; CODE XREF: CEncoderInfo::Decode(uint)+16Aj
.text:000022E7                                         ; CEncoderInfo::Decode(uint)+179j
.text:000022E7                 push    10h             ; unsigned int
.text:000022E9                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:000022EE                 add     esp, 4
.text:000022F1                 mov     [ebp+var_EC], eax
.text:000022F7                 mov     byte ptr [ebp+var_4], 4
.text:000022FB                 cmp     [ebp+var_EC], 0
.text:00002302                 jz      short loc_2317
.text:00002304                 mov     ecx, [ebp+var_EC]
.text:0000230A                 call    ??0CCrcOutStream@@QAE@XZ ; CCrcOutStream::CCrcOutStream(void)
.text:0000230F                 mov     [ebp+var_124], eax
.text:00002315                 jmp     short loc_2321
.text:00002317 ; ---------------------------------------------------------------------------
.text:00002317
.text:00002317 loc_2317:                               ; CODE XREF: CEncoderInfo::Decode(uint)+1D2j
.text:00002317                 mov     [ebp+var_124], 0
.text:00002321
.text:00002321 loc_2321:                               ; CODE XREF: CEncoderInfo::Decode(uint)+1E5j
.text:00002321                 mov     eax, [ebp+var_124]
.text:00002327                 mov     [ebp+var_E8], eax
.text:0000232D                 mov     byte ptr [ebp+var_4], 3
.text:00002331                 mov     ecx, [ebp+var_E8]
.text:00002337                 mov     [ebp+var_40], ecx
.text:0000233A                 mov     edx, [ebp+var_40]
.text:0000233D                 push    edx
.text:0000233E                 lea     ecx, [ebp+var_48]
.text:00002341                 call    ??0?$CMyComPtr@UISequentialOutStream@@@@QAE@PAUISequentialOutStream@@@Z ; CMyComPtr<ISequentialOutStream>::CMyComPtr<ISequentialOutStream>(ISequentialOutStream *)
.text:00002346                 mov     byte ptr [ebp+var_4], 5
.text:0000234A                 mov     eax, [ebp+arg_0]
.text:0000234D                 mov     ecx, [ebp+var_10]
.text:00002350                 mov     edx, [ecx+eax*4+14h]
.text:00002354                 mov     [ebp+var_50], edx
.text:00002357                 mov     eax, [ebp+var_50]
.text:0000235A                 mov     dword ptr [eax+28h], 0
.text:00002361                 mov     dword ptr [eax+2Ch], 0
.text:00002368                 mov     ecx, [ebp+var_50]
.text:0000236B                 mov     dword ptr [ecx+30h], 0
.text:00002372                 mov     dword ptr [ecx+34h], 0
.text:00002379                 lea     ecx, [ebp+var_58]
.text:0000237C                 call    ??0?$CMyComPtr@UICompressSetCoderMt@@@@QAE@XZ ; CMyComPtr<ICompressSetCoderMt>::CMyComPtr<ICompressSetCoderMt>(void)
.text:00002381                 mov     byte ptr [ebp+var_4], 6
.text:00002385                 lea     ecx, [ebp+var_58]
.text:00002388                 call    ??I?$CMyComPtr@UICompressSetCoderMt@@@@QAEPAPAUICompressSetCoderMt@@XZ ; CMyComPtr<ICompressSetCoderMt>::operator&(void)
.text:0000238D                 push    eax
.text:0000238E                 push    offset _IID_ICompressSetCoderMt
.text:00002393                 lea     ecx, [ebp+var_2C]
.text:00002396                 call    ??$QueryInterface@UICompressSetCoderMt@@@?$CMyComPtr@UIUnknown@@@@QBEJABU_GUID@@PAPAUICompressSetCoderMt@@@Z ; CMyComPtr<IUnknown>::QueryInterface<ICompressSetCoderMt>(_GUID const &,ICompressSetCoderMt * *)
.text:0000239B                 lea     ecx, [ebp+var_58]
.text:0000239E                 call    ??B?$CMyComPtr@UICompressSetCoderMt@@@@QBEPAUICompressSetCoderMt@@XZ ; CMyComPtr<ICompressSetCoderMt>::operator ICompressSetCoderMt *(void)
.text:000023A3                 test    eax, eax
.text:000023A5                 jz      loc_2439
.text:000023AB                 lea     ecx, [ebp+var_58]
.text:000023AE                 call    ??C?$CMyComPtr@UICompressSetCoderMt@@@@QBEPAUICompressSetCoderMt@@XZ ; CMyComPtr<ICompressSetCoderMt>::operator->(void)
.text:000023B3                 mov     [ebp+var_128], eax
.text:000023B9                 mov     esi, esp
.text:000023BB                 mov     edx, [ebp+var_10]
.text:000023BE                 mov     eax, [edx+8]
.text:000023C1                 push    eax
.text:000023C2                 mov     ecx, [ebp+var_128]
.text:000023C8                 push    ecx
.text:000023C9                 mov     edx, [ebp+var_128]
.text:000023CF                 mov     eax, [edx]
.text:000023D1                 mov     ecx, [eax+0Ch]
.text:000023D4                 call    ecx
.text:000023D6                 cmp     esi, esp
.text:000023D8                 call    __RTC_CheckEsp
.text:000023DD                 mov     [ebp+var_60], eax
.text:000023E0                 cmp     [ebp+var_60], 0
.text:000023E4                 jz      short loc_2439
.text:000023E6                 mov     edx, [ebp+var_60]
.text:000023E9                 mov     [ebp+var_F0], edx
.text:000023EF                 mov     byte ptr [ebp+var_4], 5
.text:000023F3                 lea     ecx, [ebp+var_58]
.text:000023F6                 call    ??1?$CMyComPtr@UICompressSetCoderMt@@@@QAE@XZ ; CMyComPtr<ICompressSetCoderMt>::~CMyComPtr<ICompressSetCoderMt>(void)
.text:000023FB                 mov     byte ptr [ebp+var_4], 3
.text:000023FF                 lea     ecx, [ebp+var_48]
.text:00002402                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00002407                 mov     byte ptr [ebp+var_4], 2
.text:0000240B                 lea     ecx, [ebp+var_38]
.text:0000240E                 call    ??1?$CMyComPtr@UICompressSetDecoderProperties2@@@@QAE@XZ ; CMyComPtr<ICompressSetDecoderProperties2>::~CMyComPtr<ICompressSetDecoderProperties2>(void)
.text:00002413                 mov     byte ptr [ebp+var_4], 1
.text:00002417                 lea     ecx, [ebp+var_2C]
.text:0000241A                 call    ??1?$CMyComPtr@UIUnknown@@@@QAE@XZ ; CMyComPtr<IUnknown>::~CMyComPtr<IUnknown>(void)
.text:0000241F                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00002426                 lea     ecx, [ebp+var_1C]
.text:00002429                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:0000242E                 mov     eax, [ebp+var_F0]
.text:00002434                 jmp     loc_2E2E
.text:00002439 ; ---------------------------------------------------------------------------
.text:00002439
.text:00002439 loc_2439:                               ; CODE XREF: CEncoderInfo::Decode(uint)+275j
.text:00002439                                         ; CEncoderInfo::Decode(uint)+2B4j
.text:00002439                 mov     byte ptr [ebp+var_4], 5
.text:0000243D                 lea     ecx, [ebp+var_58]
.text:00002440                 call    ??1?$CMyComPtr@UICompressSetCoderMt@@@@QAE@XZ ; CMyComPtr<ICompressSetCoderMt>::~CMyComPtr<ICompressSetCoderMt>(void)
.text:00002445                 lea     ecx, [ebp+var_68]
.text:00002448                 call    ??0?$CMyComPtr@UICompressSetCoderProperties@@@@QAE@XZ ; CMyComPtr<ICompressSetCoderProperties>::CMyComPtr<ICompressSetCoderProperties>(void)
.text:0000244D                 mov     byte ptr [ebp+var_4], 7
.text:00002451                 lea     ecx, [ebp+var_68]
.text:00002454                 call    ??I?$CMyComPtr@UICompressSetCoderProperties@@@@QAEPAPAUICompressSetCoderProperties@@XZ ; CMyComPtr<ICompressSetCoderProperties>::operator&(void)
.text:00002459                 push    eax
.text:0000245A                 push    offset _IID_ICompressSetCoderProperties
.text:0000245F                 lea     ecx, [ebp+var_2C]
.text:00002462                 call    ??$QueryInterface@UICompressSetCoderProperties@@@?$CMyComPtr@UIUnknown@@@@QBEJABU_GUID@@PAPAUICompressSetCoderProperties@@@Z ; CMyComPtr<IUnknown>::QueryInterface<ICompressSetCoderProperties>(_GUID const &,ICompressSetCoderProperties * *)
.text:00002467                 lea     ecx, [ebp+var_68]
.text:0000246A                 call    ??B?$CMyComPtr@UICompressSetCoderProperties@@@@QBEPAUICompressSetCoderProperties@@XZ ; CMyComPtr<ICompressSetCoderProperties>::operator ICompressSetCoderProperties *(void)
.text:0000246F                 test    eax, eax
.text:00002471                 jz      loc_24FF
.text:00002477                 mov     eax, [ebp+var_10]
.text:0000247A                 mov     ecx, [eax+110h]
.text:00002480                 xor     edx, edx
.text:00002482                 mov     dword ptr [ebp+var_78], ecx
.text:00002485                 mov     dword ptr [ebp+var_78+4], edx
.text:00002488                 lea     eax, [ebp+var_78]
.text:0000248B                 push    eax             ; unsigned __int64 *
.text:0000248C                 lea     ecx, [ebp+var_68]
.text:0000248F                 call    ??B?$CMyComPtr@UICompressSetCoderProperties@@@@QBEPAUICompressSetCoderProperties@@XZ ; CMyComPtr<ICompressSetCoderProperties>::operator ICompressSetCoderProperties *(void)
.text:00002494                 push    eax             ; struct ICompressSetCoderProperties *
.text:00002495                 mov     ecx, [ebp+var_10]
.text:00002498                 add     ecx, 0ECh ; '8' ; this
.text:0000249E                 call    ?SetCoderProps@CProps@@QBEJPAUICompressSetCoderProperties@@PB_K@Z ; CProps::SetCoderProps(ICompressSetCoderProperties *,unsigned __int64 const *)
.text:000024A3                 mov     [ebp+var_80], eax
.text:000024A6                 cmp     [ebp+var_80], 0
.text:000024AA                 jz      short loc_24FF
.text:000024AC                 mov     ecx, [ebp+var_80]
.text:000024AF                 mov     [ebp+var_F4], ecx
.text:000024B5                 mov     byte ptr [ebp+var_4], 5
.text:000024B9                 lea     ecx, [ebp+var_68]
.text:000024BC                 call    ??1?$CMyComPtr@UICompressSetCoderProperties@@@@QAE@XZ ; CMyComPtr<ICompressSetCoderProperties>::~CMyComPtr<ICompressSetCoderProperties>(void)
.text:000024C1                 mov     byte ptr [ebp+var_4], 3
.text:000024C5                 lea     ecx, [ebp+var_48]
.text:000024C8                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:000024CD                 mov     byte ptr [ebp+var_4], 2
.text:000024D1                 lea     ecx, [ebp+var_38]
.text:000024D4                 call    ??1?$CMyComPtr@UICompressSetDecoderProperties2@@@@QAE@XZ ; CMyComPtr<ICompressSetDecoderProperties2>::~CMyComPtr<ICompressSetDecoderProperties2>(void)
.text:000024D9                 mov     byte ptr [ebp+var_4], 1
.text:000024DD                 lea     ecx, [ebp+var_2C]
.text:000024E0                 call    ??1?$CMyComPtr@UIUnknown@@@@QAE@XZ ; CMyComPtr<IUnknown>::~CMyComPtr<IUnknown>(void)
.text:000024E5                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000024EC                 lea     ecx, [ebp+var_1C]
.text:000024EF                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:000024F4                 mov     eax, [ebp+var_F4]
.text:000024FA                 jmp     loc_2E2E
.text:000024FF ; ---------------------------------------------------------------------------
.text:000024FF
.text:000024FF loc_24FF:                               ; CODE XREF: CEncoderInfo::Decode(uint)+341j
.text:000024FF                                         ; CEncoderInfo::Decode(uint)+37Aj
.text:000024FF                 lea     ecx, [ebp+var_88]
.text:00002505                 call    ??0?$CMyComPtr@UICryptoProperties@@@@QAE@XZ ; CMyComPtr<ICryptoProperties>::CMyComPtr<ICryptoProperties>(void)
.text:0000250A                 mov     byte ptr [ebp+var_4], 8
.text:0000250E                 lea     ecx, [ebp+var_88]
.text:00002514                 call    ??I?$CMyComPtr@UICryptoProperties@@@@QAEPAPAUICryptoProperties@@XZ ; CMyComPtr<ICryptoProperties>::operator&(void)
.text:00002519                 push    eax
.text:0000251A                 push    offset _IID_ICryptoProperties
.text:0000251F                 lea     ecx, [ebp+var_2C]
.text:00002522                 call    ??$QueryInterface@UICryptoProperties@@@?$CMyComPtr@UIUnknown@@@@QBEJABU_GUID@@PAPAUICryptoProperties@@@Z ; CMyComPtr<IUnknown>::QueryInterface<ICryptoProperties>(_GUID const &,ICryptoProperties * *)
.text:00002527                 lea     ecx, [ebp+var_38]
.text:0000252A                 call    ??B?$CMyComPtr@UICompressSetDecoderProperties2@@@@QBEPAUICompressSetDecoderProperties2@@XZ ; CMyComPtr<ICompressSetDecoderProperties2>::operator ICompressSetDecoderProperties2 *(void)
.text:0000252F                 test    eax, eax
.text:00002531                 jz      loc_25F0
.text:00002537                 lea     ecx, [ebp+var_38]
.text:0000253A                 call    ??C?$CMyComPtr@UICompressSetDecoderProperties2@@@@QBEPAUICompressSetDecoderProperties2@@XZ ; CMyComPtr<ICompressSetDecoderProperties2>::operator->(void)
.text:0000253F                 mov     [ebp+var_12C], eax
.text:00002545                 mov     edx, [ebp+var_10]
.text:00002548                 mov     eax, [edx+0E4h]
.text:0000254E                 mov     esi, esp
.text:00002550                 mov     ecx, [eax+14h]
.text:00002553                 push    ecx
.text:00002554                 mov     edx, [ebp+var_10]
.text:00002557                 mov     eax, [edx+0E4h]
.text:0000255D                 mov     ecx, [eax+0Ch]
.text:00002560                 push    ecx
.text:00002561                 mov     edx, [ebp+var_12C]
.text:00002567                 push    edx
.text:00002568                 mov     eax, [ebp+var_12C]
.text:0000256E                 mov     ecx, [eax]
.text:00002570                 mov     edx, [ecx+0Ch]
.text:00002573                 call    edx
.text:00002575                 cmp     esi, esp
.text:00002577                 call    __RTC_CheckEsp
.text:0000257C                 mov     [ebp+var_90], eax
.text:00002582                 cmp     [ebp+var_90], 0
.text:00002589                 jz      short loc_25F0
.text:0000258B                 mov     eax, [ebp+var_90]
.text:00002591                 mov     [ebp+var_F8], eax
.text:00002597                 mov     byte ptr [ebp+var_4], 7
.text:0000259B                 lea     ecx, [ebp+var_88]
.text:000025A1                 call    ??1?$CMyComPtr@UICryptoProperties@@@@QAE@XZ ; CMyComPtr<ICryptoProperties>::~CMyComPtr<ICryptoProperties>(void)
.text:000025A6                 mov     byte ptr [ebp+var_4], 5
.text:000025AA                 lea     ecx, [ebp+var_68]
.text:000025AD                 call    ??1?$CMyComPtr@UICompressSetCoderProperties@@@@QAE@XZ ; CMyComPtr<ICompressSetCoderProperties>::~CMyComPtr<ICompressSetCoderProperties>(void)
.text:000025B2                 mov     byte ptr [ebp+var_4], 3
.text:000025B6                 lea     ecx, [ebp+var_48]
.text:000025B9                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:000025BE                 mov     byte ptr [ebp+var_4], 2
.text:000025C2                 lea     ecx, [ebp+var_38]
.text:000025C5                 call    ??1?$CMyComPtr@UICompressSetDecoderProperties2@@@@QAE@XZ ; CMyComPtr<ICompressSetDecoderProperties2>::~CMyComPtr<ICompressSetDecoderProperties2>(void)
.text:000025CA                 mov     byte ptr [ebp+var_4], 1
.text:000025CE                 lea     ecx, [ebp+var_2C]
.text:000025D1                 call    ??1?$CMyComPtr@UIUnknown@@@@QAE@XZ ; CMyComPtr<IUnknown>::~CMyComPtr<IUnknown>(void)
.text:000025D6                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000025DD                 lea     ecx, [ebp+var_1C]
.text:000025E0                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:000025E5                 mov     eax, [ebp+var_F8]
.text:000025EB                 jmp     loc_2E2E
.text:000025F0 ; ---------------------------------------------------------------------------
.text:000025F0
.text:000025F0 loc_25F0:                               ; CODE XREF: CEncoderInfo::Decode(uint)+401j
.text:000025F0                                         ; CEncoderInfo::Decode(uint)+459j
.text:000025F0                 lea     ecx, [ebp+var_98]
.text:000025F6                 call    ??0?$CMyComPtr@UICryptoSetPassword@@@@QAE@XZ ; CMyComPtr<ICryptoSetPassword>::CMyComPtr<ICryptoSetPassword>(void)
.text:000025FB                 mov     byte ptr [ebp+var_4], 9
.text:000025FF                 lea     ecx, [ebp+var_98]
.text:00002605                 call    ??I?$CMyComPtr@UICryptoSetPassword@@@@QAEPAPAUICryptoSetPassword@@XZ ; CMyComPtr<ICryptoSetPassword>::operator&(void)
.text:0000260A                 push    eax
.text:0000260B                 push    offset _IID_ICryptoSetPassword
.text:00002610                 lea     ecx, [ebp+var_2C]
.text:00002613                 call    ??$QueryInterface@UICryptoSetPassword@@@?$CMyComPtr@UIUnknown@@@@QBEJABU_GUID@@PAPAUICryptoSetPassword@@@Z ; CMyComPtr<IUnknown>::QueryInterface<ICryptoSetPassword>(_GUID const &,ICryptoSetPassword * *)
.text:00002618                 lea     ecx, [ebp+var_98]
.text:0000261E                 call    ??B?$CMyComPtr@UICryptoSetPassword@@@@QBEPAUICryptoSetPassword@@XZ ; CMyComPtr<ICryptoSetPassword>::operator ICryptoSetPassword *(void)
.text:00002623                 test    eax, eax
.text:00002625                 jz      loc_26E5
.text:0000262B                 lea     ecx, [ebp+var_98]
.text:00002631                 call    ??C?$CMyComPtr@UICryptoSetPassword@@@@QBEPAUICryptoSetPassword@@XZ ; CMyComPtr<ICryptoSetPassword>::operator->(void)
.text:00002636                 mov     [ebp+var_130], eax
.text:0000263C                 mov     esi, esp
.text:0000263E                 push    10h
.text:00002640                 mov     ecx, [ebp+var_10]
.text:00002643                 add     ecx, 64h ; 'd'
.text:00002646                 push    ecx
.text:00002647                 mov     edx, [ebp+var_130]
.text:0000264D                 push    edx
.text:0000264E                 mov     eax, [ebp+var_130]
.text:00002654                 mov     ecx, [eax]
.text:00002656                 mov     edx, [ecx+0Ch]
.text:00002659                 call    edx
.text:0000265B                 cmp     esi, esp
.text:0000265D                 call    __RTC_CheckEsp
.text:00002662                 mov     [ebp+var_A0], eax
.text:00002668                 cmp     [ebp+var_A0], 0
.text:0000266F                 jz      short loc_26E5
.text:00002671                 mov     eax, [ebp+var_A0]
.text:00002677                 mov     [ebp+var_FC], eax
.text:0000267D                 mov     byte ptr [ebp+var_4], 8
.text:00002681                 lea     ecx, [ebp+var_98]
.text:00002687                 call    ??1?$CMyComPtr@UICryptoSetPassword@@@@QAE@XZ ; CMyComPtr<ICryptoSetPassword>::~CMyComPtr<ICryptoSetPassword>(void)
.text:0000268C                 mov     byte ptr [ebp+var_4], 7
.text:00002690                 lea     ecx, [ebp+var_88]
.text:00002696                 call    ??1?$CMyComPtr@UICryptoProperties@@@@QAE@XZ ; CMyComPtr<ICryptoProperties>::~CMyComPtr<ICryptoProperties>(void)
.text:0000269B                 mov     byte ptr [ebp+var_4], 5
.text:0000269F                 lea     ecx, [ebp+var_68]
.text:000026A2                 call    ??1?$CMyComPtr@UICompressSetCoderProperties@@@@QAE@XZ ; CMyComPtr<ICompressSetCoderProperties>::~CMyComPtr<ICompressSetCoderProperties>(void)
.text:000026A7                 mov     byte ptr [ebp+var_4], 3
.text:000026AB                 lea     ecx, [ebp+var_48]
.text:000026AE                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:000026B3                 mov     byte ptr [ebp+var_4], 2
.text:000026B7                 lea     ecx, [ebp+var_38]
.text:000026BA                 call    ??1?$CMyComPtr@UICompressSetDecoderProperties2@@@@QAE@XZ ; CMyComPtr<ICompressSetDecoderProperties2>::~CMyComPtr<ICompressSetDecoderProperties2>(void)
.text:000026BF                 mov     byte ptr [ebp+var_4], 1
.text:000026C3                 lea     ecx, [ebp+var_2C]
.text:000026C6                 call    ??1?$CMyComPtr@UIUnknown@@@@QAE@XZ ; CMyComPtr<IUnknown>::~CMyComPtr<IUnknown>(void)
.text:000026CB                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000026D2                 lea     ecx, [ebp+var_1C]
.text:000026D5                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:000026DA                 mov     eax, [ebp+var_FC]
.text:000026E0                 jmp     loc_2E2E
.text:000026E5 ; ---------------------------------------------------------------------------
.text:000026E5
.text:000026E5 loc_26E5:                               ; CODE XREF: CEncoderInfo::Decode(uint)+4F5j
.text:000026E5                                         ; CEncoderInfo::Decode(uint)+53Fj
.text:000026E5                 mov     byte ptr [ebp+var_4], 8
.text:000026E9                 lea     ecx, [ebp+var_98]
.text:000026EF                 call    ??1?$CMyComPtr@UICryptoSetPassword@@@@QAE@XZ ; CMyComPtr<ICryptoSetPassword>::~CMyComPtr<ICryptoSetPassword>(void)
.text:000026F4                 mov     [ebp+var_A8], 0
.text:000026FE                 mov     [ebp+var_A4], 0
.text:00002708                 lea     ecx, [ebp+var_88]
.text:0000270E                 call    ??B?$CMyComPtr@UICryptoProperties@@@@QBEPAUICryptoProperties@@XZ ; CMyComPtr<ICryptoProperties>::operator ICryptoProperties *(void)
.text:00002713                 test    eax, eax
.text:00002715                 jz      loc_2871
.text:0000271B                 lea     ecx, [ebp+var_88]
.text:00002721                 call    ??C?$CMyComPtr@UICryptoProperties@@@@QBEPAUICryptoProperties@@XZ ; CMyComPtr<ICryptoProperties>::operator->(void)
.text:00002726                 mov     [ebp+var_134], eax
.text:0000272C                 mov     esi, esp
.text:0000272E                 push    20h ; ' '
.text:00002730                 mov     ecx, [ebp+var_10]
.text:00002733                 add     ecx, 34h ; '4'
.text:00002736                 push    ecx
.text:00002737                 mov     edx, [ebp+var_134]
.text:0000273D                 push    edx
.text:0000273E                 mov     eax, [ebp+var_134]
.text:00002744                 mov     ecx, [eax]
.text:00002746                 mov     edx, [ecx+0Ch]
.text:00002749                 call    edx
.text:0000274B                 cmp     esi, esp
.text:0000274D                 call    __RTC_CheckEsp
.text:00002752                 mov     [ebp+var_AC], eax
.text:00002758                 cmp     [ebp+var_AC], 0
.text:0000275F                 jz      short loc_27C6
.text:00002761                 mov     eax, [ebp+var_AC]
.text:00002767                 mov     [ebp+var_100], eax
.text:0000276D                 mov     byte ptr [ebp+var_4], 7
.text:00002771                 lea     ecx, [ebp+var_88]
.text:00002777                 call    ??1?$CMyComPtr@UICryptoProperties@@@@QAE@XZ ; CMyComPtr<ICryptoProperties>::~CMyComPtr<ICryptoProperties>(void)
.text:0000277C                 mov     byte ptr [ebp+var_4], 5
.text:00002780                 lea     ecx, [ebp+var_68]
.text:00002783                 call    ??1?$CMyComPtr@UICompressSetCoderProperties@@@@QAE@XZ ; CMyComPtr<ICompressSetCoderProperties>::~CMyComPtr<ICompressSetCoderProperties>(void)
.text:00002788                 mov     byte ptr [ebp+var_4], 3
.text:0000278C                 lea     ecx, [ebp+var_48]
.text:0000278F                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00002794                 mov     byte ptr [ebp+var_4], 2
.text:00002798                 lea     ecx, [ebp+var_38]
.text:0000279B                 call    ??1?$CMyComPtr@UICompressSetDecoderProperties2@@@@QAE@XZ ; CMyComPtr<ICompressSetDecoderProperties2>::~CMyComPtr<ICompressSetDecoderProperties2>(void)
.text:000027A0                 mov     byte ptr [ebp+var_4], 1
.text:000027A4                 lea     ecx, [ebp+var_2C]
.text:000027A7                 call    ??1?$CMyComPtr@UIUnknown@@@@QAE@XZ ; CMyComPtr<IUnknown>::~CMyComPtr<IUnknown>(void)
.text:000027AC                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000027B3                 lea     ecx, [ebp+var_1C]
.text:000027B6                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:000027BB                 mov     eax, [ebp+var_100]
.text:000027C1                 jmp     loc_2E2E
.text:000027C6 ; ---------------------------------------------------------------------------
.text:000027C6
.text:000027C6 loc_27C6:                               ; CODE XREF: CEncoderInfo::Decode(uint)+62Fj
.text:000027C6                 lea     ecx, [ebp+var_88]
.text:000027CC                 call    ??C?$CMyComPtr@UICryptoProperties@@@@QBEPAUICryptoProperties@@XZ ; CMyComPtr<ICryptoProperties>::operator->(void)
.text:000027D1                 mov     [ebp+var_138], eax
.text:000027D7                 mov     esi, esp
.text:000027D9                 push    10h
.text:000027DB                 mov     ecx, [ebp+var_10]
.text:000027DE                 add     ecx, 54h ; 'T'
.text:000027E1                 push    ecx
.text:000027E2                 mov     edx, [ebp+var_138]
.text:000027E8                 push    edx
.text:000027E9                 mov     eax, [ebp+var_138]
.text:000027EF                 mov     ecx, [eax]
.text:000027F1                 mov     edx, [ecx+10h]
.text:000027F4                 call    edx
.text:000027F6                 cmp     esi, esp
.text:000027F8                 call    __RTC_CheckEsp
.text:000027FD                 mov     [ebp+var_B0], eax
.text:00002803                 cmp     [ebp+var_B0], 0
.text:0000280A                 jz      short loc_2871
.text:0000280C                 mov     eax, [ebp+var_B0]
.text:00002812                 mov     [ebp+var_104], eax
.text:00002818                 mov     byte ptr [ebp+var_4], 7
.text:0000281C                 lea     ecx, [ebp+var_88]
.text:00002822                 call    ??1?$CMyComPtr@UICryptoProperties@@@@QAE@XZ ; CMyComPtr<ICryptoProperties>::~CMyComPtr<ICryptoProperties>(void)
.text:00002827                 mov     byte ptr [ebp+var_4], 5
.text:0000282B                 lea     ecx, [ebp+var_68]
.text:0000282E                 call    ??1?$CMyComPtr@UICompressSetCoderProperties@@@@QAE@XZ ; CMyComPtr<ICompressSetCoderProperties>::~CMyComPtr<ICompressSetCoderProperties>(void)
.text:00002833                 mov     byte ptr [ebp+var_4], 3
.text:00002837                 lea     ecx, [ebp+var_48]
.text:0000283A                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:0000283F                 mov     byte ptr [ebp+var_4], 2
.text:00002843                 lea     ecx, [ebp+var_38]
.text:00002846                 call    ??1?$CMyComPtr@UICompressSetDecoderProperties2@@@@QAE@XZ ; CMyComPtr<ICompressSetDecoderProperties2>::~CMyComPtr<ICompressSetDecoderProperties2>(void)
.text:0000284B                 mov     byte ptr [ebp+var_4], 1
.text:0000284F                 lea     ecx, [ebp+var_2C]
.text:00002852                 call    ??1?$CMyComPtr@UIUnknown@@@@QAE@XZ ; CMyComPtr<IUnknown>::~CMyComPtr<IUnknown>(void)
.text:00002857                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000285E                 lea     ecx, [ebp+var_1C]
.text:00002861                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:00002866                 mov     eax, [ebp+var_104]
.text:0000286C                 jmp     loc_2E2E
.text:00002871 ; ---------------------------------------------------------------------------
.text:00002871
.text:00002871 loc_2871:                               ; CODE XREF: CEncoderInfo::Decode(uint)+5E5j
.text:00002871                                         ; CEncoderInfo::Decode(uint)+6DAj
.text:00002871                 mov     [ebp+var_B8], 0
.text:0000287B                 mov     [ebp+var_B4], 0
.text:00002885                 jmp     short loc_28A5
.text:00002887 ; ---------------------------------------------------------------------------
.text:00002887
.text:00002887 loc_2887:                               ; CODE XREF: CEncoderInfo::Decode(uint)+C85j
.text:00002887                 mov     ecx, [ebp+var_B8]
.text:0000288D                 add     ecx, 1
.text:00002890                 mov     edx, [ebp+var_B4]
.text:00002896                 adc     edx, 0
.text:00002899                 mov     [ebp+var_B8], ecx
.text:0000289F                 mov     [ebp+var_B4], edx
.text:000028A5
.text:000028A5 loc_28A5:                               ; CODE XREF: CEncoderInfo::Decode(uint)+755j
.text:000028A5                 mov     eax, [ebp+var_10]
.text:000028A8                 mov     [ebp+var_13C], eax
.text:000028AE                 mov     ecx, [ebp+var_13C]
.text:000028B4                 mov     edx, [ebp+var_B4]
.text:000028BA                 cmp     edx, [ecx+2Ch]
.text:000028BD                 ja      loc_2DBA
.text:000028C3                 jb      short loc_28DA
.text:000028C5                 mov     eax, [ebp+var_13C]
.text:000028CB                 mov     ecx, [ebp+var_B8]
.text:000028D1                 cmp     ecx, [eax+28h]
.text:000028D4                 jnb     loc_2DBA
.text:000028DA
.text:000028DA loc_28DA:                               ; CODE XREF: CEncoderInfo::Decode(uint)+793j
.text:000028DA                 mov     edx, [ebp+var_10]
.text:000028DD                 cmp     dword ptr [edx+0B8h], 0
.text:000028E4                 jz      loc_29D1
.text:000028EA                 mov     eax, [ebp+var_50]
.text:000028ED                 mov     ecx, [eax+28h]
.text:000028F0                 sub     ecx, [ebp+var_A8]
.text:000028F6                 mov     edx, [eax+2Ch]
.text:000028F9                 sbb     edx, [ebp+var_A4]
.text:000028FF                 mov     [ebp+var_144], ecx
.text:00002905                 mov     [ebp+var_140], edx
.text:0000290B                 cmp     [ebp+var_140], 0
.text:00002912                 ja      short loc_2924
.text:00002914                 cmp     [ebp+var_144], 100000h
.text:0000291E                 jbe     loc_29D1
.text:00002924
.text:00002924 loc_2924:                               ; CODE XREF: CEncoderInfo::Decode(uint)+7E2j
.text:00002924                 mov     eax, [ebp+var_10]
.text:00002927                 mov     ecx, [eax+0B8h]
.text:0000292D                 mov     edx, [ebp+var_10]
.text:00002930                 mov     eax, [edx+0B8h]
.text:00002936                 mov     edx, [ecx]
.text:00002938                 mov     esi, esp
.text:0000293A                 mov     ecx, eax
.text:0000293C                 mov     eax, [edx+8]
.text:0000293F                 call    eax
.text:00002941                 cmp     esi, esp
.text:00002943                 call    __RTC_CheckEsp
.text:00002948                 mov     [ebp+var_BC], eax
.text:0000294E                 cmp     [ebp+var_BC], 0
.text:00002955                 jz      short loc_29BC
.text:00002957                 mov     ecx, [ebp+var_BC]
.text:0000295D                 mov     [ebp+var_108], ecx
.text:00002963                 mov     byte ptr [ebp+var_4], 7
.text:00002967                 lea     ecx, [ebp+var_88]
.text:0000296D                 call    ??1?$CMyComPtr@UICryptoProperties@@@@QAE@XZ ; CMyComPtr<ICryptoProperties>::~CMyComPtr<ICryptoProperties>(void)
.text:00002972                 mov     byte ptr [ebp+var_4], 5
.text:00002976                 lea     ecx, [ebp+var_68]
.text:00002979                 call    ??1?$CMyComPtr@UICompressSetCoderProperties@@@@QAE@XZ ; CMyComPtr<ICompressSetCoderProperties>::~CMyComPtr<ICompressSetCoderProperties>(void)
.text:0000297E                 mov     byte ptr [ebp+var_4], 3
.text:00002982                 lea     ecx, [ebp+var_48]
.text:00002985                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:0000298A                 mov     byte ptr [ebp+var_4], 2
.text:0000298E                 lea     ecx, [ebp+var_38]
.text:00002991                 call    ??1?$CMyComPtr@UICompressSetDecoderProperties2@@@@QAE@XZ ; CMyComPtr<ICompressSetDecoderProperties2>::~CMyComPtr<ICompressSetDecoderProperties2>(void)
.text:00002996                 mov     byte ptr [ebp+var_4], 1
.text:0000299A                 lea     ecx, [ebp+var_2C]
.text:0000299D                 call    ??1?$CMyComPtr@UIUnknown@@@@QAE@XZ ; CMyComPtr<IUnknown>::~CMyComPtr<IUnknown>(void)
.text:000029A2                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000029A9                 lea     ecx, [ebp+var_1C]
.text:000029AC                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:000029B1                 mov     eax, [ebp+var_108]
.text:000029B7                 jmp     loc_2E2E
.text:000029BC ; ---------------------------------------------------------------------------
.text:000029BC
.text:000029BC loc_29BC:                               ; CODE XREF: CEncoderInfo::Decode(uint)+825j
.text:000029BC                 mov     edx, [ebp+var_50]
.text:000029BF                 mov     eax, [edx+28h]
.text:000029C2                 mov     [ebp+var_A8], eax
.text:000029C8                 mov     ecx, [edx+2Ch]
.text:000029CB                 mov     [ebp+var_A4], ecx
.text:000029D1
.text:000029D1 loc_29D1:                               ; CODE XREF: CEncoderInfo::Decode(uint)+7B4j
.text:000029D1                                         ; CEncoderInfo::Decode(uint)+7EEj
.text:000029D1                 mov     edx, [ebp+var_10]
.text:000029D4                 mov     eax, [edx+0C4h]
.text:000029DA                 push    eax             ; unsigned int
.text:000029DB                 mov     ecx, [ebp+var_10]
.text:000029DE                 mov     edx, [ecx+0ACh]
.text:000029E4                 mov     eax, [edx+0Ch]
.text:000029E7                 push    eax             ; unsigned __int8 *
.text:000029E8                 mov     ecx, [ebp+var_14] ; this
.text:000029EB                 call    ?Init@CBenchmarkInStream@@QAEXPBEI@Z ; CBenchmarkInStream::Init(uchar const *,uint)
.text:000029F0                 mov     ecx, [ebp+var_40] ; this
.text:000029F3                 call    ?Init@CCrcOutStream@@QAEXXZ ; CCrcOutStream::Init(void)
.text:000029F8                 mov     ecx, [ebp+var_10]
.text:000029FB                 mov     edx, [ecx+0C0h]
.text:00002A01                 xor     eax, eax
.text:00002A03                 mov     [ebp+var_C8], edx
.text:00002A09                 mov     [ebp+var_C4], eax
.text:00002A0F                 mov     ecx, [ebp+var_B8]
.text:00002A15                 and     ecx, 7Fh
.text:00002A18                 mov     edx, [ebp+var_B4]
.text:00002A1E                 and     edx, 0
.text:00002A21                 mov     [ebp+var_14C], ecx
.text:00002A27                 mov     [ebp+var_148], edx
.text:00002A2D                 mov     eax, [ebp+var_14C]
.text:00002A33                 or      eax, [ebp+var_148]
.text:00002A39                 jz      short loc_2A52
.text:00002A3B                 mov     ecx, [ebp+var_10]
.text:00002A3E                 movzx   edx, byte ptr [ecx+75h]
.text:00002A42                 test    edx, edx
.text:00002A44                 jnz     short loc_2A52
.text:00002A46                 mov     [ebp+var_150], 0
.text:00002A50                 jmp     short loc_2A5C
.text:00002A52 ; ---------------------------------------------------------------------------
.text:00002A52
.text:00002A52 loc_2A52:                               ; CODE XREF: CEncoderInfo::Decode(uint)+909j
.text:00002A52                                         ; CEncoderInfo::Decode(uint)+914j
.text:00002A52                 mov     [ebp+var_150], 1
.text:00002A5C
.text:00002A5C loc_2A5C:                               ; CODE XREF: CEncoderInfo::Decode(uint)+920j
.text:00002A5C                 mov     eax, [ebp+var_40]
.text:00002A5F                 mov     cl, byte ptr [ebp+var_150]
.text:00002A65                 mov     [eax+8], cl
.text:00002A68                 mov     ecx, [ebp+var_10]
.text:00002A6B                 add     ecx, 0A0h ; 'á'
.text:00002A71                 call    ??B?$CMyComPtr@UICompressFilter@@@@QBEPAUICompressFilter@@XZ ; CMyComPtr<ICompressFilter>::operator ICompressFilter *(void)
.text:00002A76                 test    eax, eax
.text:00002A78                 jz      loc_2C2F
.text:00002A7E                 mov     edx, [ebp+var_10]
.text:00002A81                 mov     eax, [ebp+var_10]
.text:00002A84                 mov     ecx, [edx+0C4h]
.text:00002A8A                 cmp     ecx, [eax+0DCh]
.text:00002A90                 jbe     short loc_2AF5
.text:00002A92                 mov     [ebp+var_10C], 80004005h
.text:00002A9C                 mov     byte ptr [ebp+var_4], 7
.text:00002AA0                 lea     ecx, [ebp+var_88]
.text:00002AA6                 call    ??1?$CMyComPtr@UICryptoProperties@@@@QAE@XZ ; CMyComPtr<ICryptoProperties>::~CMyComPtr<ICryptoProperties>(void)
.text:00002AAB                 mov     byte ptr [ebp+var_4], 5
.text:00002AAF                 lea     ecx, [ebp+var_68]
.text:00002AB2                 call    ??1?$CMyComPtr@UICompressSetCoderProperties@@@@QAE@XZ ; CMyComPtr<ICompressSetCoderProperties>::~CMyComPtr<ICompressSetCoderProperties>(void)
.text:00002AB7                 mov     byte ptr [ebp+var_4], 3
.text:00002ABB                 lea     ecx, [ebp+var_48]
.text:00002ABE                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00002AC3                 mov     byte ptr [ebp+var_4], 2
.text:00002AC7                 lea     ecx, [ebp+var_38]
.text:00002ACA                 call    ??1?$CMyComPtr@UICompressSetDecoderProperties2@@@@QAE@XZ ; CMyComPtr<ICompressSetDecoderProperties2>::~CMyComPtr<ICompressSetDecoderProperties2>(void)
.text:00002ACF                 mov     byte ptr [ebp+var_4], 1
.text:00002AD3                 lea     ecx, [ebp+var_2C]
.text:00002AD6                 call    ??1?$CMyComPtr@UIUnknown@@@@QAE@XZ ; CMyComPtr<IUnknown>::~CMyComPtr<IUnknown>(void)
.text:00002ADB                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00002AE2                 lea     ecx, [ebp+var_1C]
.text:00002AE5                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:00002AEA                 mov     eax, [ebp+var_10C]
.text:00002AF0                 jmp     loc_2E2E
.text:00002AF5 ; ---------------------------------------------------------------------------
.text:00002AF5
.text:00002AF5 loc_2AF5:                               ; CODE XREF: CEncoderInfo::Decode(uint)+960j
.text:00002AF5                 mov     edx, [ebp+var_10]
.text:00002AF8                 mov     eax, [edx+0C4h]
.text:00002AFE                 push    eax             ; Size
.text:00002AFF                 mov     ecx, [ebp+var_10]
.text:00002B02                 mov     edx, [ecx+0ACh]
.text:00002B08                 mov     eax, [edx+0Ch]
.text:00002B0B                 push    eax             ; Src
.text:00002B0C                 mov     ecx, [ebp+var_10]
.text:00002B0F                 mov     edx, [ecx+0E0h]
.text:00002B15                 push    edx             ; Dst
.text:00002B16                 call    _memcpy
.text:00002B1B                 add     esp, 0Ch
.text:00002B1E                 mov     ecx, [ebp+var_10]
.text:00002B21                 add     ecx, 0A0h ; 'á'
.text:00002B27                 call    ??C?$CMyComPtr@UICompressFilter@@@@QBEPAUICompressFilter@@XZ ; CMyComPtr<ICompressFilter>::operator->(void)
.text:00002B2C                 mov     [ebp+var_154], eax
.text:00002B32                 mov     eax, [ebp+var_154]
.text:00002B38                 mov     ecx, [eax]
.text:00002B3A                 mov     esi, esp
.text:00002B3C                 mov     edx, [ebp+var_154]
.text:00002B42                 push    edx
.text:00002B43                 mov     eax, [ecx+0Ch]
.text:00002B46                 call    eax
.text:00002B48                 cmp     esi, esp
.text:00002B4A                 call    __RTC_CheckEsp
.text:00002B4F                 mov     ecx, [ebp+var_10]
.text:00002B52                 add     ecx, 0A0h ; 'á'
.text:00002B58                 call    ??C?$CMyComPtr@UICompressFilter@@@@QBEPAUICompressFilter@@XZ ; CMyComPtr<ICompressFilter>::operator->(void)
.text:00002B5D                 mov     [ebp+var_158], eax
.text:00002B63                 mov     esi, esp
.text:00002B65                 mov     ecx, [ebp+var_10]
.text:00002B68                 mov     edx, [ecx+0C4h]
.text:00002B6E                 push    edx
.text:00002B6F                 mov     eax, [ebp+var_10]
.text:00002B72                 mov     ecx, [eax+0E0h]
.text:00002B78                 push    ecx
.text:00002B79                 mov     edx, [ebp+var_158]
.text:00002B7F                 push    edx
.text:00002B80                 mov     eax, [ebp+var_158]
.text:00002B86                 mov     ecx, [eax]
.text:00002B88                 mov     edx, [ecx+10h]
.text:00002B8B                 call    edx
.text:00002B8D                 cmp     esi, esp
.text:00002B8F                 call    __RTC_CheckEsp
.text:00002B94                 mov     eax, [ebp+var_10]
.text:00002B97                 mov     ecx, [eax+0CCh]
.text:00002B9D                 push    ecx             ; unsigned int
.text:00002B9E                 mov     edx, [ebp+var_10]
.text:00002BA1                 mov     eax, [edx+0E0h]
.text:00002BA7                 push    eax             ; void *
.text:00002BA8                 lea     ecx, [ebp+var_48]
.text:00002BAB                 call    ??B?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ ; CMyComPtr<ISequentialOutStream>::operator ISequentialOutStream *(void)
.text:00002BB0                 push    eax             ; struct ISequentialOutStream *
.text:00002BB1                 call    ?WriteStream@@YGJPAUISequentialOutStream@@PBXI@Z ; WriteStream(ISequentialOutStream *,void const *,uint)
.text:00002BB6                 mov     [ebp+var_D0], eax
.text:00002BBC                 cmp     [ebp+var_D0], 0
.text:00002BC3                 jz      short loc_2C2A
.text:00002BC5                 mov     ecx, [ebp+var_D0]
.text:00002BCB                 mov     [ebp+var_110], ecx
.text:00002BD1                 mov     byte ptr [ebp+var_4], 7
.text:00002BD5                 lea     ecx, [ebp+var_88]
.text:00002BDB                 call    ??1?$CMyComPtr@UICryptoProperties@@@@QAE@XZ ; CMyComPtr<ICryptoProperties>::~CMyComPtr<ICryptoProperties>(void)
.text:00002BE0                 mov     byte ptr [ebp+var_4], 5
.text:00002BE4                 lea     ecx, [ebp+var_68]
.text:00002BE7                 call    ??1?$CMyComPtr@UICompressSetCoderProperties@@@@QAE@XZ ; CMyComPtr<ICompressSetCoderProperties>::~CMyComPtr<ICompressSetCoderProperties>(void)
.text:00002BEC                 mov     byte ptr [ebp+var_4], 3
.text:00002BF0                 lea     ecx, [ebp+var_48]
.text:00002BF3                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00002BF8                 mov     byte ptr [ebp+var_4], 2
.text:00002BFC                 lea     ecx, [ebp+var_38]
.text:00002BFF                 call    ??1?$CMyComPtr@UICompressSetDecoderProperties2@@@@QAE@XZ ; CMyComPtr<ICompressSetDecoderProperties2>::~CMyComPtr<ICompressSetDecoderProperties2>(void)
.text:00002C04                 mov     byte ptr [ebp+var_4], 1
.text:00002C08                 lea     ecx, [ebp+var_2C]
.text:00002C0B                 call    ??1?$CMyComPtr@UIUnknown@@@@QAE@XZ ; CMyComPtr<IUnknown>::~CMyComPtr<IUnknown>(void)
.text:00002C10                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00002C17                 lea     ecx, [ebp+var_1C]
.text:00002C1A                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:00002C1F                 mov     eax, [ebp+var_110]
.text:00002C25                 jmp     loc_2E2E
.text:00002C2A ; ---------------------------------------------------------------------------
.text:00002C2A
.text:00002C2A loc_2C2A:                               ; CODE XREF: CEncoderInfo::Decode(uint)+A93j
.text:00002C2A                 jmp     loc_2CF9
.text:00002C2F ; ---------------------------------------------------------------------------
.text:00002C2F
.text:00002C2F loc_2C2F:                               ; CODE XREF: CEncoderInfo::Decode(uint)+948j
.text:00002C2F                 mov     ecx, [ebp+var_24]
.text:00002C32                 call    ??C?$CMyComPtr@UICompressCoder@@@@QBEPAUICompressCoder@@XZ ; CMyComPtr<ICompressCoder>::operator->(void)
.text:00002C37                 mov     [ebp+var_15C], eax
.text:00002C3D                 mov     edx, [ebp+arg_0]
.text:00002C40                 mov     eax, [ebp+var_10]
.text:00002C43                 lea     ecx, [eax+edx*4+1Ch]
.text:00002C47                 call    ??B?$CMyComPtr@UICompressProgressInfo@@@@QBEPAUICompressProgressInfo@@XZ ; CMyComPtr<ICompressProgressInfo>::operator ICompressProgressInfo *(void)
.text:00002C4C                 mov     esi, esp
.text:00002C4E                 push    eax
.text:00002C4F                 lea     ecx, [ebp+var_C8]
.text:00002C55                 push    ecx
.text:00002C56                 push    0
.text:00002C58                 lea     ecx, [ebp+var_48]
.text:00002C5B                 call    ??B?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ ; CMyComPtr<ISequentialOutStream>::operator ISequentialOutStream *(void)
.text:00002C60                 push    eax
.text:00002C61                 lea     ecx, [ebp+var_1C]
.text:00002C64                 call    ??B?$CMyComPtr@UISequentialInStream@@@@QBEPAUISequentialInStream@@XZ ; CMyComPtr<ISequentialInStream>::operator ISequentialInStream *(void)
.text:00002C69                 push    eax
.text:00002C6A                 mov     edx, [ebp+var_15C]
.text:00002C70                 push    edx
.text:00002C71                 mov     eax, [ebp+var_15C]
.text:00002C77                 mov     ecx, [eax]
.text:00002C79                 mov     edx, [ecx+0Ch]
.text:00002C7C                 call    edx
.text:00002C7E                 cmp     esi, esp
.text:00002C80                 call    __RTC_CheckEsp
.text:00002C85                 mov     [ebp+var_D4], eax
.text:00002C8B                 cmp     [ebp+var_D4], 0
.text:00002C92                 jz      short loc_2CF9
.text:00002C94                 mov     eax, [ebp+var_D4]
.text:00002C9A                 mov     [ebp+var_114], eax
.text:00002CA0                 mov     byte ptr [ebp+var_4], 7
.text:00002CA4                 lea     ecx, [ebp+var_88]
.text:00002CAA                 call    ??1?$CMyComPtr@UICryptoProperties@@@@QAE@XZ ; CMyComPtr<ICryptoProperties>::~CMyComPtr<ICryptoProperties>(void)
.text:00002CAF                 mov     byte ptr [ebp+var_4], 5
.text:00002CB3                 lea     ecx, [ebp+var_68]
.text:00002CB6                 call    ??1?$CMyComPtr@UICompressSetCoderProperties@@@@QAE@XZ ; CMyComPtr<ICompressSetCoderProperties>::~CMyComPtr<ICompressSetCoderProperties>(void)
.text:00002CBB                 mov     byte ptr [ebp+var_4], 3
.text:00002CBF                 lea     ecx, [ebp+var_48]
.text:00002CC2                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00002CC7                 mov     byte ptr [ebp+var_4], 2
.text:00002CCB                 lea     ecx, [ebp+var_38]
.text:00002CCE                 call    ??1?$CMyComPtr@UICompressSetDecoderProperties2@@@@QAE@XZ ; CMyComPtr<ICompressSetDecoderProperties2>::~CMyComPtr<ICompressSetDecoderProperties2>(void)
.text:00002CD3                 mov     byte ptr [ebp+var_4], 1
.text:00002CD7                 lea     ecx, [ebp+var_2C]
.text:00002CDA                 call    ??1?$CMyComPtr@UIUnknown@@@@QAE@XZ ; CMyComPtr<IUnknown>::~CMyComPtr<IUnknown>(void)
.text:00002CDF                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00002CE6                 lea     ecx, [ebp+var_1C]
.text:00002CE9                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:00002CEE                 mov     eax, [ebp+var_114]
.text:00002CF4                 jmp     loc_2E2E
.text:00002CF9 ; ---------------------------------------------------------------------------
.text:00002CF9
.text:00002CF9 loc_2CF9:                               ; CODE XREF: CEncoderInfo::Decode(uint):loc_2C2Aj
.text:00002CF9                                         ; CEncoderInfo::Decode(uint)+B62j
.text:00002CF9                 mov     ecx, [ebp+var_40]
.text:00002CFC                 movzx   edx, byte ptr [ecx+8]
.text:00002D00                 test    edx, edx
.text:00002D02                 jz      short loc_2D7B
.text:00002D04                 mov     eax, [ebp+var_40]
.text:00002D07                 mov     ecx, [eax+0Ch]
.text:00002D0A                 xor     ecx, 0FFFFFFFFh
.text:00002D0D                 mov     edx, [ebp+var_10]
.text:00002D10                 cmp     ecx, [edx+0BCh]
.text:00002D16                 jz      short loc_2D7B
.text:00002D18                 mov     [ebp+var_118], 1
.text:00002D22                 mov     byte ptr [ebp+var_4], 7
.text:00002D26                 lea     ecx, [ebp+var_88]
.text:00002D2C                 call    ??1?$CMyComPtr@UICryptoProperties@@@@QAE@XZ ; CMyComPtr<ICryptoProperties>::~CMyComPtr<ICryptoProperties>(void)
.text:00002D31                 mov     byte ptr [ebp+var_4], 5
.text:00002D35                 lea     ecx, [ebp+var_68]
.text:00002D38                 call    ??1?$CMyComPtr@UICompressSetCoderProperties@@@@QAE@XZ ; CMyComPtr<ICompressSetCoderProperties>::~CMyComPtr<ICompressSetCoderProperties>(void)
.text:00002D3D                 mov     byte ptr [ebp+var_4], 3
.text:00002D41                 lea     ecx, [ebp+var_48]
.text:00002D44                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00002D49                 mov     byte ptr [ebp+var_4], 2
.text:00002D4D                 lea     ecx, [ebp+var_38]
.text:00002D50                 call    ??1?$CMyComPtr@UICompressSetDecoderProperties2@@@@QAE@XZ ; CMyComPtr<ICompressSetDecoderProperties2>::~CMyComPtr<ICompressSetDecoderProperties2>(void)
.text:00002D55                 mov     byte ptr [ebp+var_4], 1
.text:00002D59                 lea     ecx, [ebp+var_2C]
.text:00002D5C                 call    ??1?$CMyComPtr@UIUnknown@@@@QAE@XZ ; CMyComPtr<IUnknown>::~CMyComPtr<IUnknown>(void)
.text:00002D61                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00002D68                 lea     ecx, [ebp+var_1C]
.text:00002D6B                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:00002D70                 mov     eax, [ebp+var_118]
.text:00002D76                 jmp     loc_2E2E
.text:00002D7B ; ---------------------------------------------------------------------------
.text:00002D7B
.text:00002D7B loc_2D7B:                               ; CODE XREF: CEncoderInfo::Decode(uint)+BD2j
.text:00002D7B                                         ; CEncoderInfo::Decode(uint)+BE6j
.text:00002D7B                 mov     eax, [ebp+var_10]
.text:00002D7E                 mov     ecx, [eax+0C0h]
.text:00002D84                 xor     edx, edx
.text:00002D86                 mov     eax, [ebp+var_50]
.text:00002D89                 add     ecx, [eax+28h]
.text:00002D8C                 adc     edx, [eax+2Ch]
.text:00002D8F                 mov     eax, [ebp+var_50]
.text:00002D92                 mov     [eax+28h], ecx
.text:00002D95                 mov     [eax+2Ch], edx
.text:00002D98                 mov     ecx, [ebp+var_10]
.text:00002D9B                 mov     edx, [ecx+0C4h]
.text:00002DA1                 xor     eax, eax
.text:00002DA3                 mov     ecx, [ebp+var_50]
.text:00002DA6                 add     edx, [ecx+30h]
.text:00002DA9                 adc     eax, [ecx+34h]
.text:00002DAC                 mov     ecx, [ebp+var_50]
.text:00002DAF                 mov     [ecx+30h], edx
.text:00002DB2                 mov     [ecx+34h], eax
.text:00002DB5                 jmp     loc_2887
.text:00002DBA ; ---------------------------------------------------------------------------
.text:00002DBA
.text:00002DBA loc_2DBA:                               ; CODE XREF: CEncoderInfo::Decode(uint)+78Dj
.text:00002DBA                                         ; CEncoderInfo::Decode(uint)+7A4j
.text:00002DBA                 mov     ecx, [ebp+var_24]
.text:00002DBD                 call    ?Release@?$CMyComPtr@UICompressCoder@@@@QAEXXZ ; CMyComPtr<ICompressCoder>::Release(void)
.text:00002DC2                 mov     ecx, [ebp+var_10]
.text:00002DC5                 add     ecx, 0A0h ; 'á'
.text:00002DCB                 call    ?Release@?$CMyComPtr@UICompressFilter@@@@QAEXXZ ; CMyComPtr<ICompressFilter>::Release(void)
.text:00002DD0                 mov     [ebp+var_11C], 0
.text:00002DDA                 mov     byte ptr [ebp+var_4], 7
.text:00002DDE                 lea     ecx, [ebp+var_88]
.text:00002DE4                 call    ??1?$CMyComPtr@UICryptoProperties@@@@QAE@XZ ; CMyComPtr<ICryptoProperties>::~CMyComPtr<ICryptoProperties>(void)
.text:00002DE9                 mov     byte ptr [ebp+var_4], 5
.text:00002DED                 lea     ecx, [ebp+var_68]
.text:00002DF0                 call    ??1?$CMyComPtr@UICompressSetCoderProperties@@@@QAE@XZ ; CMyComPtr<ICompressSetCoderProperties>::~CMyComPtr<ICompressSetCoderProperties>(void)
.text:00002DF5                 mov     byte ptr [ebp+var_4], 3
.text:00002DF9                 lea     ecx, [ebp+var_48]
.text:00002DFC                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00002E01                 mov     byte ptr [ebp+var_4], 2
.text:00002E05                 lea     ecx, [ebp+var_38]
.text:00002E08                 call    ??1?$CMyComPtr@UICompressSetDecoderProperties2@@@@QAE@XZ ; CMyComPtr<ICompressSetDecoderProperties2>::~CMyComPtr<ICompressSetDecoderProperties2>(void)
.text:00002E0D                 mov     byte ptr [ebp+var_4], 1
.text:00002E11                 lea     ecx, [ebp+var_2C]
.text:00002E14                 call    ??1?$CMyComPtr@UIUnknown@@@@QAE@XZ ; CMyComPtr<IUnknown>::~CMyComPtr<IUnknown>(void)
.text:00002E19                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00002E20                 lea     ecx, [ebp+var_1C]
.text:00002E23                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:00002E28                 mov     eax, [ebp+var_11C]
.text:00002E2E
.text:00002E2E loc_2E2E:                               ; CODE XREF: CEncoderInfo::Decode(uint)+10Cj
.text:00002E2E                                         ; CEncoderInfo::Decode(uint)+1B2j ...
.text:00002E2E                 push    edx
.text:00002E2F                 mov     ecx, ebp
.text:00002E31                 push    eax
.text:00002E32                 lea     edx, $LN59
.text:00002E38                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00002E3D                 pop     eax
.text:00002E3E                 pop     edx
.text:00002E3F                 mov     ecx, [ebp+var_C]
.text:00002E42                 mov     large fs:0, ecx
.text:00002E49                 pop     ecx
.text:00002E4A                 pop     edi
.text:00002E4B                 pop     esi
.text:00002E4C                 add     esp, 15Ch
.text:00002E52                 cmp     ebp, esp
.text:00002E54                 call    __RTC_CheckEsp
.text:00002E59                 mov     esp, ebp
.text:00002E5B                 pop     ebp
.text:00002E5C                 retn    4
.text:00002E5C ?Decode@CEncoderInfo@@QAEJI@Z endp
.text:00002E5C
.text:00002E5C ; ---------------------------------------------------------------------------
.text:00002E5F                 align 10h
.text:00002E60 $LN59           dd 0Ah                  ; DATA XREF: CEncoderInfo::Decode(uint)+D02o
.text:00002E64                 dd offset $LN58
.text:00002E68 $LN58           dd 0FFFFFFE4h, 4        ; DATA XREF: .text:00002E64o
.text:00002E70                 dd offset $LN47_0       ; "inStream"
.text:00002E74                 dd 0FFFFFFD4h, 4
.text:00002E7C                 dd offset $LN48_0       ; "coder"
.text:00002E80                 dd 0FFFFFFC8h, 4
.text:00002E88                 dd offset $LN49_0       ; "setDecProps"
.text:00002E8C                 dd 0FFFFFFB8h, 4
.text:00002E94                 dd offset $LN50         ; "crcOutStream"
.text:00002E98                 dd 0FFFFFFA8h, 4
.text:00002EA0                 dd offset $LN51_0       ; "setCoderMt"
.text:00002EA4                 dd 0FFFFFF98h, 4
.text:00002EAC                 dd offset $LN52_0       ; "scp"
.text:00002EB0                 db 88h, 0FFh
.text:00002EB2                 dw 0FFFFh
.text:00002EB4                 dd 8
.text:00002EB8                 dd offset $LN53         ; "reduceSize"
.text:00002EBC                 dd 0FFFFFF78h, 4
.text:00002EC4                 dd offset $LN54         ; "cp"
.text:00002EC8                 dd 0FFFFFF68h, 4
.text:00002ED0                 dd offset $LN55         ; "sp"
.text:00002ED4                 dd 0FFFFFF38h, 8
.text:00002EDC                 dd offset $LN56         ; "outSize"
.text:00002EE0 $LN56           db 'outSize',0          ; DATA XREF: .text:00002EDCo
.text:00002EE8 $LN55           db 'sp',0               ; DATA XREF: .text:00002ED0o
.text:00002EEB $LN54           db 'cp',0               ; DATA XREF: .text:00002EC4o
.text:00002EEE $LN53           db 'reduceSize',0       ; DATA XREF: .text:00002EB8o
.text:00002EF9 $LN52_0         db 'scp',0              ; DATA XREF: .text:00002EACo
.text:00002EFD $LN51_0         db 'setCoderMt',0       ; DATA XREF: .text:00002EA0o
.text:00002F08 $LN50           db 'crcOutStream',0     ; DATA XREF: .text:00002E94o
.text:00002F15 $LN49_0         db 'setDecProps',0      ; DATA XREF: .text:00002E88o
.text:00002F21 $LN48_0         db 'coder',0            ; DATA XREF: .text:00002E7Co
.text:00002F27 $LN47_0         db 'inStream',0         ; DATA XREF: .text:00002E70o
.text:00002F30
.text:00002F30 ; =============== S U B R O U T I N E =======================================
.text:00002F30
.text:00002F30 ; Attributes: bp-based frame
.text:00002F30
.text:00002F30 ; unsigned __int64 __stdcall GetBenchMemoryUsage(unsigned int, unsigned int)
.text:00002F30                 public ?GetBenchMemoryUsage@@YG_KII@Z
.text:00002F30 ?GetBenchMemoryUsage@@YG_KII@Z proc near
.text:00002F30                                         ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1119p
.text:00002F30                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+117Bp
.text:00002F30
.text:00002F30 var_10          = dword ptr -10h
.text:00002F30 var_C           = dword ptr -0Ch
.text:00002F30 var_8           = dword ptr -8
.text:00002F30 var_4           = dword ptr -4
.text:00002F30 arg_0           = dword ptr  8
.text:00002F30 arg_4           = dword ptr  0Ch
.text:00002F30
.text:00002F30                 push    ebp
.text:00002F31                 mov     ebp, esp
.text:00002F33                 sub     esp, 10h
.text:00002F36                 push    esi
.text:00002F37                 push    edi
.text:00002F38                 mov     eax, 0CCCCCCCCh
.text:00002F3D                 mov     [ebp+var_10], eax
.text:00002F40                 mov     [ebp+var_C], eax
.text:00002F43                 mov     [ebp+var_8], eax
.text:00002F46                 mov     [ebp+var_4], eax
.text:00002F49                 mov     eax, [ebp+arg_4]
.text:00002F4C                 mov     [ebp+var_4], eax
.text:00002F4F                 mov     ecx, [ebp+var_4]
.text:00002F52                 shr     ecx, 1
.text:00002F54                 mov     [ebp+var_8], ecx
.text:00002F57                 mov     edx, 1
.text:00002F5C                 cmp     edx, [ebp+arg_0]
.text:00002F5F                 sbb     eax, eax
.text:00002F61                 neg     eax
.text:00002F63                 add     eax, 1
.text:00002F66                 mov     [ebp+var_C], eax
.text:00002F69                 mov     eax, [ebp+arg_0]
.text:00002F6C                 xor     edx, edx
.text:00002F6E                 div     [ebp+var_C]
.text:00002F71                 mov     [ebp+var_10], eax
.text:00002F74                 mov     ecx, [ebp+var_4]
.text:00002F77                 add     ecx, [ebp+var_8]
.text:00002F7A                 mov     esi, ecx
.text:00002F7C                 xor     edi, edi
.text:00002F7E                 mov     edx, [ebp+arg_4]
.text:00002F81                 push    edx             ; unsigned int
.text:00002F82                 cmp     [ebp+arg_0], 1
.text:00002F86                 setnbe  al
.text:00002F89                 movzx   ecx, al
.text:00002F8C                 push    ecx             ; bool
.text:00002F8D                 call    ?GetLZMAUsage@@YG_K_NI@Z ; GetLZMAUsage(bool,uint)
.text:00002F92                 add     esi, eax
.text:00002F94                 adc     edi, edx
.text:00002F96                 add     esi, 200000h
.text:00002F9C                 adc     edi, 0
.text:00002F9F                 mov     edx, [ebp+var_10]
.text:00002FA2                 xor     eax, eax
.text:00002FA4                 push    eax
.text:00002FA5                 push    edx
.text:00002FA6                 push    edi
.text:00002FA7                 push    esi
.text:00002FA8                 call    __allmul
.text:00002FAD                 pop     edi
.text:00002FAE                 pop     esi
.text:00002FAF                 add     esp, 10h
.text:00002FB2                 cmp     ebp, esp
.text:00002FB4                 call    __RTC_CheckEsp
.text:00002FB9                 mov     esp, ebp
.text:00002FBB                 pop     ebp
.text:00002FBC                 retn    8
.text:00002FBC ?GetBenchMemoryUsage@@YG_KII@Z endp
.text:00002FBC
.text:00002FBC ; ---------------------------------------------------------------------------
.text:00002FBF                 align 10h
.text:00002FC0
.text:00002FC0 ; =============== S U B R O U T I N E =======================================
.text:00002FC0
.text:00002FC0 ; Attributes: bp-based frame
.text:00002FC0
.text:00002FC0 ; bool __stdcall CrcInternalTest()
.text:00002FC0                 public ?CrcInternalTest@@YG_NXZ
.text:00002FC0 ?CrcInternalTest@@YG_NXZ proc near      ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+3Fp
.text:00002FC0
.text:00002FC0 var_50          = byte ptr -50h
.text:00002FC0 var_4F          = byte ptr -4Fh
.text:00002FC0 var_4E          = byte ptr -4Eh
.text:00002FC0 var_4D          = byte ptr -4Dh
.text:00002FC0 var_4C          = dword ptr -4Ch
.text:00002FC0 var_44          = byte ptr -44h
.text:00002FC0 var_38          = dword ptr -38h
.text:00002FC0 var_34          = dword ptr -34h
.text:00002FC0 var_30          = dword ptr -30h
.text:00002FC0 var_2C          = dword ptr -2Ch
.text:00002FC0 var_28          = dword ptr -28h
.text:00002FC0 var_24          = dword ptr -24h
.text:00002FC0 var_1C          = byte ptr -1Ch
.text:00002FC0 var_14          = dword ptr -14h
.text:00002FC0 var_C           = dword ptr -0Ch
.text:00002FC0 var_4           = dword ptr -4
.text:00002FC0
.text:00002FC0                 push    ebp
.text:00002FC1                 mov     ebp, esp
.text:00002FC3                 push    0FFFFFFFFh
.text:00002FC5                 push    offset __ehhandler$?CrcInternalTest@@YG_NXZ
.text:00002FCA                 mov     eax, large fs:0
.text:00002FD0                 push    eax
.text:00002FD1                 sub     esp, 44h
.text:00002FD4                 push    esi
.text:00002FD5                 push    edi
.text:00002FD6                 lea     edi, [ebp+var_50]
.text:00002FD9                 mov     ecx, 11h
.text:00002FDE                 mov     eax, 0CCCCCCCCh
.text:00002FE3                 rep stosd
.text:00002FE5                 mov     eax, dword ptr ds:___security_cookie
.text:00002FEA                 xor     eax, ebp
.text:00002FEC                 push    eax
.text:00002FED                 lea     eax, [ebp+var_C]
.text:00002FF0                 mov     large fs:0, eax
.text:00002FF6                 lea     ecx, [ebp+var_1C] ; this
.text:00002FF9                 call    ??0CBenchBuffer@@QAE@XZ ; CBenchBuffer::CBenchBuffer(void)
.text:00002FFE                 mov     [ebp+var_4], 0
.text:00003005                 mov     [ebp+var_24], 100h
.text:0000300C                 mov     [ebp+var_28], 400h
.text:00003013                 mov     [ebp+var_2C], 20h ; ' '
.text:0000301A                 push    500h            ; unsigned int
.text:0000301F                 lea     ecx, [ebp+var_1C] ; this
.text:00003022                 call    ?Alloc@CBenchBuffer@@QAE_NI@Z ; CBenchBuffer::Alloc(uint)
.text:00003027                 movzx   eax, al
.text:0000302A                 test    eax, eax
.text:0000302C                 jnz     short loc_3049
.text:0000302E                 mov     [ebp+var_4D], 0
.text:00003032                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00003039                 lea     ecx, [ebp+var_1C] ; this
.text:0000303C                 call    ??1CBenchBuffer@@UAE@XZ ; CBenchBuffer::~CBenchBuffer(void)
.text:00003041                 mov     al, [ebp+var_4D]
.text:00003044                 jmp     loc_3155
.text:00003049 ; ---------------------------------------------------------------------------
.text:00003049
.text:00003049 loc_3049:                               ; CODE XREF: CrcInternalTest(void)+6Cj
.text:00003049                 mov     ecx, [ebp+var_14]
.text:0000304C                 mov     [ebp+var_30], ecx
.text:0000304F                 mov     [ebp+var_34], 0
.text:00003056                 jmp     short loc_3061
.text:00003058 ; ---------------------------------------------------------------------------
.text:00003058
.text:00003058 loc_3058:                               ; CODE XREF: CrcInternalTest(void)+B5j
.text:00003058                 mov     edx, [ebp+var_34]
.text:0000305B                 add     edx, 1
.text:0000305E                 mov     [ebp+var_34], edx
.text:00003061
.text:00003061 loc_3061:                               ; CODE XREF: CrcInternalTest(void)+96j
.text:00003061                 cmp     [ebp+var_34], 100h
.text:00003068                 jnb     short loc_3077
.text:0000306A                 mov     eax, [ebp+var_30]
.text:0000306D                 add     eax, [ebp+var_34]
.text:00003070                 mov     cl, byte ptr [ebp+var_34]
.text:00003073                 mov     [eax], cl
.text:00003075                 jmp     short loc_3058
.text:00003077 ; ---------------------------------------------------------------------------
.text:00003077
.text:00003077 loc_3077:                               ; CODE XREF: CrcInternalTest(void)+A8j
.text:00003077                 push    100h
.text:0000307C                 mov     edx, [ebp+var_30]
.text:0000307F                 push    edx
.text:00003080                 call    ?CrcCalc1@@YGIPBEI@Z ; CrcCalc1(uchar const *,uint)
.text:00003085                 mov     [ebp+var_38], eax
.text:00003088                 cmp     [ebp+var_38], 29058C73h
.text:0000308F                 jz      short loc_30AC
.text:00003091                 mov     [ebp+var_4E], 0
.text:00003095                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000309C                 lea     ecx, [ebp+var_1C] ; this
.text:0000309F                 call    ??1CBenchBuffer@@UAE@XZ ; CBenchBuffer::~CBenchBuffer(void)
.text:000030A4                 mov     al, [ebp+var_4E]
.text:000030A7                 jmp     loc_3155
.text:000030AC ; ---------------------------------------------------------------------------
.text:000030AC
.text:000030AC loc_30AC:                               ; CODE XREF: CrcInternalTest(void)+CFj
.text:000030AC                 lea     ecx, [ebp+var_44]
.text:000030AF                 call    ??0CBaseRandomGenerator@@QAE@XZ ; CBaseRandomGenerator::CBaseRandomGenerator(void)
.text:000030B4                 lea     eax, [ebp+var_44]
.text:000030B7                 push    eax             ; CBaseRandomGenerator *
.text:000030B8                 push    400h            ; int
.text:000030BD                 mov     ecx, [ebp+var_30]
.text:000030C0                 add     ecx, 100h
.text:000030C6                 push    ecx             ; int
.text:000030C7                 call    ?RandGen@@YGXPAEIAAVCBaseRandomGenerator@@@Z ; RandGen(uchar *,uint,CBaseRandomGenerator &)
.text:000030CC                 mov     [ebp+var_34], 0
.text:000030D3                 jmp     short loc_30DE
.text:000030D5 ; ---------------------------------------------------------------------------
.text:000030D5
.text:000030D5 loc_30D5:                               ; CODE XREF: CrcInternalTest(void):loc_313Dj
.text:000030D5                 mov     edx, [ebp+var_34]
.text:000030D8                 add     edx, 1
.text:000030DB                 mov     [ebp+var_34], edx
.text:000030DE
.text:000030DE loc_30DE:                               ; CODE XREF: CrcInternalTest(void)+113j
.text:000030DE                 cmp     [ebp+var_34], 4E0h
.text:000030E5                 jnb     short loc_313F
.text:000030E7                 mov     [ebp+var_4C], 0
.text:000030EE                 jmp     short loc_30F9
.text:000030F0 ; ---------------------------------------------------------------------------
.text:000030F0
.text:000030F0 loc_30F0:                               ; CODE XREF: CrcInternalTest(void):loc_313Bj
.text:000030F0                 mov     eax, [ebp+var_4C]
.text:000030F3                 add     eax, 1
.text:000030F6                 mov     [ebp+var_4C], eax
.text:000030F9
.text:000030F9 loc_30F9:                               ; CODE XREF: CrcInternalTest(void)+12Ej
.text:000030F9                 cmp     [ebp+var_4C], 20h ; ' '
.text:000030FD                 jnb     short loc_313D
.text:000030FF                 mov     ecx, [ebp+var_4C]
.text:00003102                 push    ecx
.text:00003103                 mov     edx, [ebp+var_30]
.text:00003106                 add     edx, [ebp+var_34]
.text:00003109                 push    edx
.text:0000310A                 call    ?CrcCalc1@@YGIPBEI@Z ; CrcCalc1(uchar const *,uint)
.text:0000310F                 mov     esi, eax
.text:00003111                 mov     ecx, [ebp+var_30]
.text:00003114                 add     ecx, [ebp+var_34]
.text:00003117                 mov     edx, [ebp+var_4C]
.text:0000311A                 call    @CrcCalc@8      ; CrcCalc(x,x)
.text:0000311F                 cmp     esi, eax
.text:00003121                 jz      short loc_313B
.text:00003123                 mov     [ebp+var_4F], 0
.text:00003127                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000312E                 lea     ecx, [ebp+var_1C] ; this
.text:00003131                 call    ??1CBenchBuffer@@UAE@XZ ; CBenchBuffer::~CBenchBuffer(void)
.text:00003136                 mov     al, [ebp+var_4F]
.text:00003139                 jmp     short loc_3155
.text:0000313B ; ---------------------------------------------------------------------------
.text:0000313B
.text:0000313B loc_313B:                               ; CODE XREF: CrcInternalTest(void)+161j
.text:0000313B                 jmp     short loc_30F0
.text:0000313D ; ---------------------------------------------------------------------------
.text:0000313D
.text:0000313D loc_313D:                               ; CODE XREF: CrcInternalTest(void)+13Dj
.text:0000313D                 jmp     short loc_30D5
.text:0000313F ; ---------------------------------------------------------------------------
.text:0000313F
.text:0000313F loc_313F:                               ; CODE XREF: CrcInternalTest(void)+125j
.text:0000313F                 mov     [ebp+var_50], 1
.text:00003143                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000314A                 lea     ecx, [ebp+var_1C] ; this
.text:0000314D                 call    ??1CBenchBuffer@@UAE@XZ ; CBenchBuffer::~CBenchBuffer(void)
.text:00003152                 mov     al, [ebp+var_50]
.text:00003155
.text:00003155 loc_3155:                               ; CODE XREF: CrcInternalTest(void)+84j
.text:00003155                                         ; CrcInternalTest(void)+E7j ...
.text:00003155                 push    edx
.text:00003156                 mov     ecx, ebp
.text:00003158                 push    eax
.text:00003159                 lea     edx, $LN20
.text:0000315F                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00003164                 pop     eax
.text:00003165                 pop     edx
.text:00003166                 mov     ecx, [ebp+var_C]
.text:00003169                 mov     large fs:0, ecx
.text:00003170                 pop     ecx
.text:00003171                 pop     edi
.text:00003172                 pop     esi
.text:00003173                 add     esp, 50h
.text:00003176                 cmp     ebp, esp
.text:00003178
.text:00003178 loc_3178:                               ; DATA XREF: .rdata:off_28o
.text:00003178                 call    __RTC_CheckEsp
.text:0000317D                 mov     esp, ebp
.text:0000317F                 pop     ebp
.text:00003180                 retn
.text:00003180 ?CrcInternalTest@@YG_NXZ endp ; sp-analysis failed
.text:00003180
.text:00003180 ; ---------------------------------------------------------------------------
.text:00003181                 align 4
.text:00003184 $LN20           dd 2                    ; DATA XREF: CrcInternalTest(void)+199o
.text:00003188                 dd offset $LN19
.text:0000318C $LN19           dd 0FFFFFFE4h, 0Ch      ; DATA XREF: .text:00003188o
.text:00003194                 dd offset $LN16_0       ; "buffer"
.text:00003198                 dd 0FFFFFFBCh, 8
.text:000031A0                 dd offset $LN17_0
.text:000031A4 $LN17_0         db 52h, 47h, 0          ; DATA XREF: .text:000031A0o
.text:000031A7 $LN16_0         db 'buffer',0           ; DATA XREF: .text:00003194o
.text:000031AE                 align 10h
.text:000031B0
.text:000031B0 ; =============== S U B R O U T I N E =======================================
.text:000031B0
.text:000031B0 ; Attributes: bp-based frame
.text:000031B0
.text:000031B0 ; unsigned int __stdcall CrcCalc1(unsigned char const *, unsigned int)
.text:000031B0 ?CrcCalc1@@YGIPBEI@Z proc near          ; CODE XREF: CrcInternalTest(void)+C0p
.text:000031B0                                         ; CrcInternalTest(void)+14Ap ...
.text:000031B0
.text:000031B0 var_8           = dword ptr -8
.text:000031B0 var_4           = dword ptr -4
.text:000031B0 arg_0           = dword ptr  8
.text:000031B0 arg_4           = dword ptr  0Ch
.text:000031B0
.text:000031B0                 push    ebp
.text:000031B1                 mov     ebp, esp
.text:000031B3                 sub     esp, 8
.text:000031B6                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000031BD                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000031C4                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000031CB                 mov     [ebp+var_8], 0
.text:000031D2                 jmp     short loc_31DD
.text:000031D4 ; ---------------------------------------------------------------------------
.text:000031D4
.text:000031D4 loc_31D4:                               ; CODE XREF: CrcCalc1(uchar const *,uint)+56j
.text:000031D4                 mov     eax, [ebp+var_8]
.text:000031D7                 add     eax, 1
.text:000031DA                 mov     [ebp+var_8], eax
.text:000031DD
.text:000031DD loc_31DD:                               ; CODE XREF: CrcCalc1(uchar const *,uint)+22j
.text:000031DD                 mov     ecx, [ebp+var_8]
.text:000031E0                 cmp     ecx, [ebp+arg_4]
.text:000031E3                 jnb     short loc_3208
.text:000031E5                 mov     edx, [ebp+arg_0]
.text:000031E8                 add     edx, [ebp+var_8]
.text:000031EB                 movzx   eax, byte ptr [edx]
.text:000031EE                 xor     eax, [ebp+var_4]
.text:000031F1                 and     eax, 0FFh
.text:000031F6                 mov     ecx, [ebp+var_4]
.text:000031F9                 shr     ecx, 8
.text:000031FC                 xor     ecx, dword ptr ds:_g_CrcTable[eax*4]
.text:00003203                 mov     [ebp+var_4], ecx
.text:00003206                 jmp     short loc_31D4
.text:00003208 ; ---------------------------------------------------------------------------
.text:00003208
.text:00003208 loc_3208:                               ; CODE XREF: CrcCalc1(uchar const *,uint)+33j
.text:00003208                 mov     eax, [ebp+var_4]
.text:0000320B                 xor     eax, 0FFFFFFFFh
.text:0000320E                 mov     esp, ebp
.text:00003210                 pop     ebp
.text:00003211                 retn    8
.text:00003211 ?CrcCalc1@@YGIPBEI@Z endp
.text:00003211
.text:00003211 ; ---------------------------------------------------------------------------
.text:00003214                 align 10h
.text:00003220
.text:00003220 ; =============== S U B R O U T I N E =======================================
.text:00003220
.text:00003220 ; Attributes: bp-based frame
.text:00003220
.text:00003220 ; int __stdcall RandGen(int, int, CBaseRandomGenerator *)
.text:00003220 ?RandGen@@YGXPAEIAAVCBaseRandomGenerator@@@Z proc near
.text:00003220                                         ; CODE XREF: CrcInternalTest(void)+107p
.text:00003220                                         ; RandGenCrc(uchar *,uint,CBaseRandomGenerator &)+Fp
.text:00003220
.text:00003220 var_4           = dword ptr -4
.text:00003220 arg_0           = dword ptr  8
.text:00003220 arg_4           = dword ptr  0Ch
.text:00003220 arg_8           = dword ptr  10h
.text:00003220
.text:00003220                 push    ebp
.text:00003221                 mov     ebp, esp
.text:00003223                 push    ecx
.text:00003224                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000322B                 mov     [ebp+var_4], 0
.text:00003232                 jmp     short loc_323D
.text:00003234 ; ---------------------------------------------------------------------------
.text:00003234
.text:00003234 loc_3234:                               ; CODE XREF: RandGen(uchar *,uint,CBaseRandomGenerator &)+35j
.text:00003234                 mov     eax, [ebp+var_4]
.text:00003237                 add     eax, 1
.text:0000323A                 mov     [ebp+var_4], eax
.text:0000323D
.text:0000323D loc_323D:                               ; CODE XREF: RandGen(uchar *,uint,CBaseRandomGenerator &)+12j
.text:0000323D                 mov     ecx, [ebp+var_4]
.text:00003240                 cmp     ecx, [ebp+arg_4]
.text:00003243                 jnb     short loc_3257
.text:00003245                 mov     ecx, [ebp+arg_8] ; this
.text:00003248                 call    ?GetRnd@CBaseRandomGenerator@@QAEIXZ ; CBaseRandomGenerator::GetRnd(void)
.text:0000324D                 mov     edx, [ebp+arg_0]
.text:00003250                 add     edx, [ebp+var_4]
.text:00003253                 mov     [edx], al
.text:00003255                 jmp     short loc_3234
.text:00003257 ; ---------------------------------------------------------------------------
.text:00003257
.text:00003257 loc_3257:                               ; CODE XREF: RandGen(uchar *,uint,CBaseRandomGenerator &)+23j
.text:00003257                 add     esp, 4
.text:0000325A                 cmp     ebp, esp
.text:0000325C                 call    __RTC_CheckEsp
.text:00003261                 mov     esp, ebp
.text:00003263                 pop     ebp
.text:00003264                 retn    0Ch
.text:00003264 ?RandGen@@YGXPAEIAAVCBaseRandomGenerator@@@Z endp
.text:00003264
.text:00003264 ; ---------------------------------------------------------------------------
.text:00003267                 align 10h
.text:00003270
.text:00003270 ; =============== S U B R O U T I N E =======================================
.text:00003270
.text:00003270 ; Attributes: bp-based frame
.text:00003270
.text:00003270 ; __int32 __thiscall CBenchCallbackToPrint::SetFreq(CBenchCallbackToPrint *this, bool, unsigned __int64)
.text:00003270                 public ?SetFreq@CBenchCallbackToPrint@@UAEJ_N_K@Z
.text:00003270 ?SetFreq@CBenchCallbackToPrint@@UAEJ_N_K@Z proc near
.text:00003270                                         ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+16B4p
.text:00003270                                         ; DATA XREF: .rdata:const CBenchCallbackToPrint::`vftable'o
.text:00003270
.text:00003270 var_4           = dword ptr -4
.text:00003270 arg_0           = byte ptr  8
.text:00003270 arg_4           = qword ptr  0Ch
.text:00003270
.text:00003270                 push    ebp
.text:00003271                 mov     ebp, esp
.text:00003273                 push    ecx
.text:00003274                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000327B                 mov     [ebp+var_4], ecx
.text:0000327E                 mov     eax, [ebp+var_4]
.text:00003281                 mov     cl, [ebp+arg_0]
.text:00003284                 mov     [eax+68h], cl
.text:00003287                 mov     edx, [ebp+var_4]
.text:0000328A                 mov     eax, dword ptr [ebp+arg_4]
.text:0000328D                 mov     [edx+70h], eax
.text:00003290                 mov     ecx, dword ptr [ebp+arg_4+4]
.text:00003293                 mov     [edx+74h], ecx
.text:00003296                 xor     eax, eax
.text:00003298                 mov     esp, ebp
.text:0000329A                 pop     ebp
.text:0000329B                 retn    0Ch
.text:0000329B ?SetFreq@CBenchCallbackToPrint@@UAEJ_N_K@Z endp
.text:0000329B
.text:0000329B ; ---------------------------------------------------------------------------
.text:0000329E                 align 10h
.text:000032A0
.text:000032A0 ; =============== S U B R O U T I N E =======================================
.text:000032A0
.text:000032A0 ; Attributes: bp-based frame
.text:000032A0
.text:000032A0 ; __int32 __thiscall CBenchCallbackToPrint::SetEncodeResult(CBenchCallbackToPrint *this, const struct CBenchInfo *, bool)
.text:000032A0                 public ?SetEncodeResult@CBenchCallbackToPrint@@UAEJABUCBenchInfo@@_N@Z
.text:000032A0 ?SetEncodeResult@CBenchCallbackToPrint@@UAEJABUCBenchInfo@@_N@Z proc near
.text:000032A0                                         ; DATA XREF: .rdata:0000CC28o
.text:000032A0
.text:000032A0 var_10          = qword ptr -10h
.text:000032A0 var_8           = dword ptr -8
.text:000032A0 var_4           = dword ptr -4
.text:000032A0 arg_0           = dword ptr  8
.text:000032A0 arg_4           = byte ptr  0Ch
.text:000032A0
.text:000032A0                 push    ebp
.text:000032A1                 mov     ebp, esp
.text:000032A3                 sub     esp, 10h
.text:000032A6                 push    esi
.text:000032A7                 mov     eax, 0CCCCCCCCh
.text:000032AC                 mov     dword ptr [ebp+var_10], eax
.text:000032AF                 mov     dword ptr [ebp+var_10+4], eax
.text:000032B2                 mov     [ebp+var_8], eax
.text:000032B5                 mov     [ebp+var_4], eax
.text:000032B8                 mov     [ebp+var_4], ecx
.text:000032BB                 mov     eax, [ebp+var_4]
.text:000032BE                 mov     ecx, [eax+58h]
.text:000032C1                 mov     edx, [ebp+var_4]
.text:000032C4                 mov     eax, [edx+58h]
.text:000032C7                 mov     edx, [ecx]
.text:000032C9                 mov     esi, esp
.text:000032CB                 mov     ecx, eax
.text:000032CD                 mov     eax, [edx+8]
.text:000032D0                 call    eax
.text:000032D2                 cmp     esi, esp
.text:000032D4                 call    __RTC_CheckEsp
.text:000032D9                 mov     [ebp+var_8], eax
.text:000032DC                 cmp     [ebp+var_8], 0
.text:000032E0                 jz      short loc_32EA
.text:000032E2                 mov     eax, [ebp+var_8]
.text:000032E5                 jmp     loc_33A2
.text:000032EA ; ---------------------------------------------------------------------------
.text:000032EA
.text:000032EA loc_32EA:                               ; CODE XREF: CBenchCallbackToPrint::SetEncodeResult(CBenchInfo const &,bool)+40j
.text:000032EA                 movzx   ecx, [ebp+arg_4]
.text:000032EE                 test    ecx, ecx
.text:000032F0                 jz      loc_33A0
.text:000032F6                 mov     edx, [ebp+arg_0]
.text:000032F9                 mov     eax, [ebp+arg_0]
.text:000032FC                 mov     ecx, [eax+34h]
.text:000032FF                 push    ecx
.text:00003300                 mov     eax, [eax+30h]
.text:00003303                 push    eax
.text:00003304                 mov     ecx, [edx+24h]
.text:00003307                 push    ecx
.text:00003308                 mov     edx, [edx+20h]
.text:0000330B                 push    edx
.text:0000330C                 call    __allmul
.text:00003311                 push    edx
.text:00003312                 push    eax             ; unsigned __int64
.text:00003313                 mov     eax, [ebp+arg_0]
.text:00003316                 mov     ecx, [eax+0Ch]
.text:00003319                 push    ecx
.text:0000331A                 mov     edx, [eax+8]
.text:0000331D                 push    edx             ; unsigned __int64
.text:0000331E                 mov     eax, [ebp+arg_0]
.text:00003321                 mov     ecx, [eax+4]
.text:00003324                 push    ecx
.text:00003325                 mov     edx, [eax]
.text:00003327                 push    edx             ; unsigned __int64
.text:00003328                 mov     eax, [ebp+var_4]
.text:0000332B                 mov     ecx, [eax+5Ch]
.text:0000332E                 push    ecx             ; unsigned int
.text:0000332F                 mov     ecx, [ebp+var_4]
.text:00003332                 add     ecx, 4          ; this
.text:00003335                 call    ?GetCompressRating@CBenchProps@@QAE_KI_K00@Z ; CBenchProps::GetCompressRating(uint,unsigned __int64,unsigned __int64,unsigned __int64)
.text:0000333A                 mov     dword ptr [ebp+var_10], eax
.text:0000333D                 mov     dword ptr [ebp+var_10+4], edx
.text:00003340                 mov     edx, [ebp+var_4]
.text:00003343                 add     edx, 18h
.text:00003346                 push    edx             ; int
.text:00003347                 mov     eax, [ebp+var_4]
.text:0000334A                 mov     ecx, [eax+74h]
.text:0000334D                 push    ecx             ; int
.text:0000334E                 mov     edx, [eax+70h]
.text:00003351                 push    edx             ; int
.text:00003352                 mov     eax, [ebp+var_4]
.text:00003355                 movzx   ecx, byte ptr [eax+68h]
.text:00003359                 push    ecx             ; char
.text:0000335A                 mov     edx, dword ptr [ebp+var_10+4]
.text:0000335D                 push    edx
.text:0000335E                 mov     eax, dword ptr [ebp+var_10]
.text:00003361                 push    eax             ; unsigned __int64
.text:00003362                 mov     ecx, [ebp+var_4]
.text:00003365                 mov     edx, [ecx+78h]
.text:00003368                 push    edx             ; int
.text:00003369                 mov     eax, [ebp+arg_0]
.text:0000336C                 push    eax             ; CBenchInfo *
.text:0000336D                 mov     ecx, [ebp+var_4]
.text:00003370                 mov     edx, [ecx+58h]
.text:00003373                 push    edx             ; int
.text:00003374                 call    ?PrintResults@@YGXPAUIBenchPrintCallback@@ABUCBenchInfo@@I_K_N2PAUCTotalBenchRes@@@Z ; PrintResults(IBenchPrintCallback *,CBenchInfo const &,uint,unsigned __int64,bool,unsigned __int64,CTotalBenchRes *)
.text:00003379                 mov     eax, [ebp+var_4]
.text:0000337C                 movzx   ecx, byte ptr [eax+60h]
.text:00003380                 test    ecx, ecx
.text:00003382                 jnz     short loc_33A0
.text:00003384                 mov     edx, [ebp+var_4]
.text:00003387                 mov     eax, [edx+58h]
.text:0000338A                 mov     ecx, [ebp+var_4]
.text:0000338D                 mov     ecx, [ecx+58h]
.text:00003390                 mov     edx, [eax]
.text:00003392                 mov     esi, esp
.text:00003394                 mov     eax, [edx+4]
.text:00003397                 call    eax
.text:00003399                 cmp     esi, esp
.text:0000339B                 call    __RTC_CheckEsp
.text:000033A0
.text:000033A0 loc_33A0:                               ; CODE XREF: CBenchCallbackToPrint::SetEncodeResult(CBenchInfo const &,bool)+50j
.text:000033A0                                         ; CBenchCallbackToPrint::SetEncodeResult(CBenchInfo const &,bool)+E2j
.text:000033A0                 xor     eax, eax
.text:000033A2
.text:000033A2 loc_33A2:                               ; CODE XREF: CBenchCallbackToPrint::SetEncodeResult(CBenchInfo const &,bool)+45j
.text:000033A2                 pop     esi
.text:000033A3                 add     esp, 10h
.text:000033A6                 cmp     ebp, esp
.text:000033A8                 call    __RTC_CheckEsp
.text:000033AD                 mov     esp, ebp
.text:000033AF                 pop     ebp
.text:000033B0                 retn    8
.text:000033B0 ?SetEncodeResult@CBenchCallbackToPrint@@UAEJABUCBenchInfo@@_N@Z endp
.text:000033B0
.text:000033B0 ; ---------------------------------------------------------------------------
.text:000033B3                 align 10h
.text:000033C0
.text:000033C0 ; =============== S U B R O U T I N E =======================================
.text:000033C0
.text:000033C0 ; Attributes: bp-based frame
.text:000033C0
.text:000033C0 ; int __stdcall PrintResults(int, CBenchInfo *, int, unsigned __int64, char, int, int, int)
.text:000033C0 ?PrintResults@@YGXPAUIBenchPrintCallback@@ABUCBenchInfo@@I_K_N2PAUCTotalBenchRes@@@Z proc near
.text:000033C0                                         ; CODE XREF: CBenchCallbackToPrint::SetEncodeResult(CBenchInfo const &,bool)+D4p
.text:000033C0                                         ; CBenchCallbackToPrint::SetDecodeResult(CBenchInfo const &,bool)+165p ...
.text:000033C0
.text:000033C0 var_18          = dword ptr -18h
.text:000033C0 var_14          = dword ptr -14h
.text:000033C0 var_10          = dword ptr -10h
.text:000033C0 var_C           = dword ptr -0Ch
.text:000033C0 var_8           = dword ptr -8
.text:000033C0 var_4           = dword ptr -4
.text:000033C0 arg_0           = dword ptr  8
.text:000033C0 arg_4           = dword ptr  0Ch
.text:000033C0 arg_8           = dword ptr  10h
.text:000033C0 arg_C           = qword ptr  14h
.text:000033C0 arg_14          = byte ptr  1Ch
.text:000033C0 arg_18          = dword ptr  20h
.text:000033C0 arg_1C          = dword ptr  24h
.text:000033C0 arg_20          = dword ptr  28h
.text:000033C0
.text:000033C0                 push    ebp
.text:000033C1                 mov     ebp, esp
.text:000033C3                 sub     esp, 18h
.text:000033C6                 mov     eax, 0CCCCCCCCh
.text:000033CB                 mov     [ebp+var_18], eax
.text:000033CE                 mov     [ebp+var_14], eax
.text:000033D1                 mov     [ebp+var_10], eax
.text:000033D4                 mov     [ebp+var_C], eax
.text:000033D7                 mov     [ebp+var_8], eax
.text:000033DA                 mov     [ebp+var_4], eax
.text:000033DD                 mov     eax, [ebp+arg_4]
.text:000033E0                 mov     ecx, [ebp+arg_4]
.text:000033E3                 mov     edx, [ecx+34h]
.text:000033E6                 push    edx
.text:000033E7                 mov     ecx, [ecx+30h]
.text:000033EA                 push    ecx
.text:000033EB                 mov     edx, [eax+24h]
.text:000033EE                 push    edx
.text:000033EF                 mov     eax, [eax+20h]
.text:000033F2                 push    eax
.text:000033F3                 call    __allmul
.text:000033F8                 push    edx
.text:000033F9                 push    eax             ; unsigned __int64
.text:000033FA                 mov     ecx, [ebp+arg_4] ; this
.text:000033FD                 call    ?GetSpeed@CBenchInfo@@QBE_K_K@Z ; CBenchInfo::GetSpeed(unsigned __int64)
.text:00003402                 mov     [ebp+var_8], eax
.text:00003405                 mov     [ebp+var_4], edx
.text:00003408                 cmp     [ebp+arg_0], 0
.text:0000340C                 jz      short loc_3444
.text:0000340E                 mov     ecx, [ebp+var_8]
.text:00003411                 or      ecx, [ebp+var_4]
.text:00003414                 jz      short loc_3439
.text:00003416                 push    9
.text:00003418                 push    0
.text:0000341A                 push    400h
.text:0000341F                 mov     edx, [ebp+var_4]
.text:00003422                 push    edx
.text:00003423                 mov     eax, [ebp+var_8]
.text:00003426                 push    eax
.text:00003427                 call    __aulldiv
.text:0000342C                 push    edx
.text:0000342D                 push    eax
.text:0000342E                 mov     ecx, [ebp+arg_0]
.text:00003431                 push    ecx
.text:00003432                 call    ?PrintNumber@@YGXAAUIBenchPrintCallback@@_KH@Z ; PrintNumber(IBenchPrintCallback &,unsigned __int64,int)
.text:00003437                 jmp     short loc_3444
.text:00003439 ; ---------------------------------------------------------------------------
.text:00003439
.text:00003439 loc_3439:                               ; CODE XREF: PrintResults(IBenchPrintCallback *,CBenchInfo const &,uint,unsigned __int64,bool,unsigned __int64,CTotalBenchRes *)+54j
.text:00003439                 push    0Ah             ; Size
.text:0000343B                 mov     edx, [ebp+arg_0]
.text:0000343E                 push    edx             ; int
.text:0000343F                 call    ?PrintSpaces@@YGXAAUIBenchPrintCallback@@I@Z ; PrintSpaces(IBenchPrintCallback &,uint)
.text:00003444
.text:00003444 loc_3444:                               ; CODE XREF: PrintResults(IBenchPrintCallback *,CBenchInfo const &,uint,unsigned __int64,bool,unsigned __int64,CTotalBenchRes *)+4Cj
.text:00003444                                         ; PrintResults(IBenchPrintCallback *,CBenchInfo const &,uint,unsigned __int64,bool,unsigned __int64,CTotalBenchRes *)+77j
.text:00003444                 mov     ecx, [ebp+arg_4] ; this
.text:00003447                 call    ?GetUsage@CBenchInfo@@QBE_KXZ ; CBenchInfo::GetUsage(void)
.text:0000344C                 mov     [ebp+var_10], eax
.text:0000344F                 mov     [ebp+var_C], edx
.text:00003452                 mov     eax, dword ptr [ebp+arg_C+4]
.text:00003455                 push    eax
.text:00003456                 mov     ecx, dword ptr [ebp+arg_C]
.text:00003459                 push    ecx             ; unsigned __int64
.text:0000345A                 mov     ecx, [ebp+arg_4] ; this
.text:0000345D                 call    ?GetRatingPerUsage@CBenchInfo@@QBE_K_K@Z ; CBenchInfo::GetRatingPerUsage(unsigned __int64)
.text:00003462                 mov     [ebp+var_18], eax
.text:00003465                 mov     [ebp+var_14], edx
.text:00003468                 cmp     [ebp+arg_0], 0
.text:0000346C                 jz      short loc_349C
.text:0000346E                 mov     edx, [ebp+arg_1C]
.text:00003471                 push    edx
.text:00003472                 mov     eax, [ebp+arg_18]
.text:00003475                 push    eax
.text:00003476                 movzx   ecx, [ebp+arg_14]
.text:0000347A                 push    ecx
.text:0000347B                 mov     edx, dword ptr [ebp+arg_C+4]
.text:0000347E                 push    edx
.text:0000347F                 mov     eax, dword ptr [ebp+arg_C]
.text:00003482                 push    eax
.text:00003483                 mov     ecx, [ebp+var_14]
.text:00003486                 push    ecx
.text:00003487                 mov     edx, [ebp+var_18]
.text:0000348A                 push    edx
.text:0000348B                 mov     eax, [ebp+var_C]
.text:0000348E                 push    eax
.text:0000348F                 mov     ecx, [ebp+var_10]
.text:00003492                 push    ecx
.text:00003493                 mov     edx, [ebp+arg_0]
.text:00003496                 push    edx
.text:00003497                 call    ?PrintResults@@YGXAAUIBenchPrintCallback@@_K11_N1@Z ; PrintResults(IBenchPrintCallback &,unsigned __int64,unsigned __int64,unsigned __int64,bool,unsigned __int64)
.text:0000349C
.text:0000349C loc_349C:                               ; CODE XREF: PrintResults(IBenchPrintCallback *,CBenchInfo const &,uint,unsigned __int64,bool,unsigned __int64,CTotalBenchRes *)+ACj
.text:0000349C                 cmp     [ebp+arg_20], 0
.text:000034A0                 jz      loc_352D
.text:000034A6                 mov     eax, [ebp+arg_8]
.text:000034A9                 xor     ecx, ecx
.text:000034AB                 mov     edx, [ebp+arg_20]
.text:000034AE                 add     eax, [edx]
.text:000034B0                 adc     ecx, [edx+4]
.text:000034B3                 mov     edx, [ebp+arg_20]
.text:000034B6                 mov     [edx], eax
.text:000034B8                 mov     [edx+4], ecx
.text:000034BB                 mov     eax, [ebp+arg_8]
.text:000034BE                 xor     ecx, ecx
.text:000034C0                 push    ecx
.text:000034C1                 push    eax
.text:000034C2                 mov     edx, [ebp+var_14]
.text:000034C5                 push    edx
.text:000034C6                 mov     eax, [ebp+var_18]
.text:000034C9                 push    eax
.text:000034CA                 call    __allmul
.text:000034CF                 mov     ecx, [ebp+arg_20]
.text:000034D2                 add     eax, [ecx+18h]
.text:000034D5                 adc     edx, [ecx+1Ch]
.text:000034D8                 mov     ecx, [ebp+arg_20]
.text:000034DB                 mov     [ecx+18h], eax
.text:000034DE                 mov     [ecx+1Ch], edx
.text:000034E1                 mov     edx, [ebp+arg_8]
.text:000034E4                 xor     eax, eax
.text:000034E6                 push    eax
.text:000034E7                 push    edx
.text:000034E8                 mov     ecx, dword ptr [ebp+arg_C+4]
.text:000034EB                 push    ecx
.text:000034EC                 mov     edx, dword ptr [ebp+arg_C]
.text:000034EF                 push    edx
.text:000034F0                 call    __allmul
.text:000034F5                 mov     ecx, [ebp+arg_20]
.text:000034F8                 add     eax, [ecx+8]
.text:000034FB                 adc     edx, [ecx+0Ch]
.text:000034FE                 mov     ecx, [ebp+arg_20]
.text:00003501                 mov     [ecx+8], eax
.text:00003504                 mov     [ecx+0Ch], edx
.text:00003507                 mov     edx, [ebp+arg_8]
.text:0000350A                 xor     eax, eax
.text:0000350C                 push    eax
.text:0000350D                 push    edx
.text:0000350E                 mov     ecx, [ebp+var_C]
.text:00003511                 push    ecx
.text:00003512                 mov     edx, [ebp+var_10]
.text:00003515                 push    edx
.text:00003516                 call    __allmul
.text:0000351B                 mov     ecx, [ebp+arg_20]
.text:0000351E                 add     eax, [ecx+10h]
.text:00003521                 adc     edx, [ecx+14h]
.text:00003524                 mov     ecx, [ebp+arg_20]
.text:00003527                 mov     [ecx+10h], eax
.text:0000352A                 mov     [ecx+14h], edx
.text:0000352D
.text:0000352D loc_352D:                               ; CODE XREF: PrintResults(IBenchPrintCallback *,CBenchInfo const &,uint,unsigned __int64,bool,unsigned __int64,CTotalBenchRes *)+E0j
.text:0000352D                 add     esp, 18h
.text:00003530                 cmp     ebp, esp
.text:00003532                 call    __RTC_CheckEsp
.text:00003537                 mov     esp, ebp
.text:00003539                 pop     ebp
.text:0000353A                 retn    24h
.text:0000353A ?PrintResults@@YGXPAUIBenchPrintCallback@@ABUCBenchInfo@@I_K_N2PAUCTotalBenchRes@@@Z endp
.text:0000353A
.text:0000353A ; ---------------------------------------------------------------------------
.text:0000353D                 align 10h
.text:00003540
.text:00003540 ; =============== S U B R O U T I N E =======================================
.text:00003540
.text:00003540 ; Attributes: bp-based frame
.text:00003540
.text:00003540 ; void __stdcall PrintNumber(struct IBenchPrintCallback &, unsigned __int64, int)
.text:00003540 ?PrintNumber@@YGXAAUIBenchPrintCallback@@_KH@Z proc near
.text:00003540                                         ; CODE XREF: PrintResults(IBenchPrintCallback *,CBenchInfo const &,uint,unsigned __int64,bool,unsigned __int64,CTotalBenchRes *)+72p
.text:00003540                                         ; PrintResults(IBenchPrintCallback &,unsigned __int64,unsigned __int64,unsigned __int64,bool,unsigned __int64)+38p ...
.text:00003540
.text:00003540 var_94          = dword ptr -94h
.text:00003540 Size            = dword ptr -90h
.text:00003540 Dst             = byte ptr -88h
.text:00003540 var_4           = dword ptr -4
.text:00003540 arg_0           = dword ptr  8
.text:00003540 arg_4           = qword ptr  0Ch
.text:00003540 arg_C           = dword ptr  14h
.text:00003540
.text:00003540                 push    ebp
.text:00003541                 mov     ebp, esp
.text:00003543                 sub     esp, 94h
.text:00003549                 push    esi
.text:0000354A                 push    edi
.text:0000354B                 lea     edi, [ebp+var_94]
.text:00003551                 mov     ecx, 25h ; '%'
.text:00003556                 mov     eax, 0CCCCCCCCh
.text:0000355B                 rep stosd
.text:0000355D                 mov     eax, dword ptr ds:___security_cookie
.text:00003562                 xor     eax, ebp
.text:00003564                 mov     [ebp+var_4], eax
.text:00003567                 mov     [ebp+Size], 60h ; '`'
.text:00003571                 mov     eax, [ebp+Size]
.text:00003577                 push    eax             ; Size
.text:00003578                 push    20h ; ' '       ; Val
.text:0000357A                 lea     ecx, [ebp+Dst]
.text:00003580                 push    ecx             ; Dst
.text:00003581                 call    _memset
.text:00003586                 add     esp, 0Ch
.text:00003589                 mov     edx, [ebp+Size]
.text:0000358F                 lea     eax, [ebp+edx+Dst]
.text:00003596                 push    eax             ; char *
.text:00003597                 mov     ecx, dword ptr [ebp+arg_4+4]
.text:0000359A                 push    ecx
.text:0000359B                 mov     edx, dword ptr [ebp+arg_4]
.text:0000359E                 push    edx             ; unsigned __int64
.text:0000359F                 call    ?ConvertUInt64ToString@@YGX_KPAD@Z ; ConvertUInt64ToString(unsigned __int64,char *)
.text:000035A4                 mov     eax, [ebp+Size]
.text:000035AA                 sub     eax, 1
.text:000035AD                 mov     [ebp+Size], eax
.text:000035B3                 mov     ecx, [ebp+arg_C]
.text:000035B6                 add     ecx, 1
.text:000035B9                 mov     [ebp+arg_C], ecx
.text:000035BC                 mov     edx, [ebp+Size]
.text:000035C2                 lea     eax, [ebp+edx+Dst]
.text:000035C9                 push    eax             ; Str
.text:000035CA                 call    _strlen
.text:000035CF                 add     esp, 4
.text:000035D2                 mov     [ebp+var_94], eax
.text:000035D8                 mov     ecx, [ebp+arg_C]
.text:000035DB                 cmp     ecx, [ebp+var_94]
.text:000035E1                 jle     short loc_3606
.text:000035E3                 mov     edx, [ebp+arg_C]
.text:000035E6                 sub     edx, [ebp+var_94]
.text:000035EC                 mov     eax, [ebp+Size]
.text:000035F2                 sub     eax, edx
.text:000035F4                 mov     [ebp+Size], eax
.text:000035FA                 jns     short loc_3606
.text:000035FC                 mov     [ebp+Size], 0
.text:00003606
.text:00003606 loc_3606:                               ; CODE XREF: PrintNumber(IBenchPrintCallback &,unsigned __int64,int)+A1j
.text:00003606                                         ; PrintNumber(IBenchPrintCallback &,unsigned __int64,int)+BAj
.text:00003606                 mov     ecx, [ebp+Size]
.text:0000360C                 lea     edx, [ebp+ecx+Dst]
.text:00003613                 mov     esi, esp
.text:00003615                 push    edx
.text:00003616                 mov     eax, [ebp+arg_0]
.text:00003619                 mov     edx, [eax]
.text:0000361B                 mov     ecx, [ebp+arg_0]
.text:0000361E                 mov     eax, [edx]
.text:00003620                 call    eax
.text:00003622                 cmp     esi, esp
.text:00003624                 call    __RTC_CheckEsp
.text:00003629                 push    edx
.text:0000362A                 mov     ecx, ebp
.text:0000362C                 push    eax
.text:0000362D                 lea     edx, $LN7_2
.text:00003633                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00003638                 pop     eax
.text:00003639                 pop     edx
.text:0000363A                 pop     edi
.text:0000363B                 pop     esi
.text:0000363C                 mov     ecx, [ebp+var_4]
.text:0000363F                 xor     ecx, ebp
.text:00003641                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text:00003646                 add     esp, 94h
.text:0000364C                 cmp     ebp, esp
.text:0000364E                 call    __RTC_CheckEsp
.text:00003653                 mov     esp, ebp
.text:00003655                 pop     ebp
.text:00003656                 retn    10h
.text:00003656 ?PrintNumber@@YGXAAUIBenchPrintCallback@@_KH@Z endp
.text:00003656
.text:00003656 ; ---------------------------------------------------------------------------
.text:00003659                 align 4
.text:0000365C $LN7_2          dd 1                    ; DATA XREF: PrintNumber(IBenchPrintCallback &,unsigned __int64,int)+EDo
.text:00003660                 dd offset $LN6_5
.text:00003664 $LN6_5          dd 0FFFFFF78h, 80h      ; DATA XREF: .text:00003660o
.text:0000366C                 dd offset $LN5_7
.text:00003670 $LN5_7          dd 0CCCC0073h, 3 dup(0CCCCCCCCh) ; DATA XREF: .text:0000366Co
.text:00003680
.text:00003680 ; =============== S U B R O U T I N E =======================================
.text:00003680
.text:00003680 ; Attributes: bp-based frame
.text:00003680
.text:00003680 ; int __stdcall PrintSpaces(int, size_t Size)
.text:00003680 ?PrintSpaces@@YGXAAUIBenchPrintCallback@@I@Z proc near
.text:00003680                                         ; CODE XREF: PrintResults(IBenchPrintCallback *,CBenchInfo const &,uint,unsigned __int64,bool,unsigned __int64,CTotalBenchRes *)+7Fp
.text:00003680                                         ; PrintResults(IBenchPrintCallback &,unsigned __int64,unsigned __int64,unsigned __int64,bool,unsigned __int64)+7Dp ...
.text:00003680
.text:00003680 arg_0           = dword ptr  8
.text:00003680 Size            = dword ptr  0Ch
.text:00003680
.text:00003680                 push    ebp
.text:00003681                 mov     ebp, esp
.text:00003683                 mov     eax, [ebp+Size]
.text:00003686                 push    eax             ; Size
.text:00003687                 push    20h ; ' '       ; char
.text:00003689                 mov     ecx, [ebp+arg_0]
.text:0000368C                 push    ecx             ; int
.text:0000368D                 call    ?PrintChars@@YGXAAUIBenchPrintCallback@@DI@Z ; PrintChars(IBenchPrintCallback &,char,uint)
.text:00003692                 cmp     ebp, esp
.text:00003694                 call    __RTC_CheckEsp
.text:00003699                 pop     ebp
.text:0000369A                 retn    8
.text:0000369A ?PrintSpaces@@YGXAAUIBenchPrintCallback@@I@Z endp
.text:0000369A
.text:0000369A ; ---------------------------------------------------------------------------
.text:0000369D                 align 10h
.text:000036A0
.text:000036A0 ; =============== S U B R O U T I N E =======================================
.text:000036A0
.text:000036A0 ; Attributes: bp-based frame
.text:000036A0
.text:000036A0 ; int __stdcall PrintChars(int, char, size_t Size)
.text:000036A0 ?PrintChars@@YGXAAUIBenchPrintCallback@@DI@Z proc near
.text:000036A0                                         ; CODE XREF: PrintSpaces(IBenchPrintCallback &,uint)+Dp
.text:000036A0                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1CD8p ...
.text:000036A0
.text:000036A0 var_10C         = byte ptr -10Ch
.text:000036A0 Dst             = byte ptr -108h
.text:000036A0 var_4           = dword ptr -4
.text:000036A0 arg_0           = dword ptr  8
.text:000036A0 arg_4           = byte ptr  0Ch
.text:000036A0 Size            = dword ptr  10h
.text:000036A0
.text:000036A0                 push    ebp
.text:000036A1                 mov     ebp, esp
.text:000036A3                 sub     esp, 10Ch
.text:000036A9                 push    esi
.text:000036AA                 push    edi
.text:000036AB                 lea     edi, [ebp+var_10C]
.text:000036B1                 mov     ecx, 43h ; 'C'
.text:000036B6                 mov     eax, 0CCCCCCCCh
.text:000036BB                 rep stosd
.text:000036BD                 mov     eax, dword ptr ds:___security_cookie
.text:000036C2                 xor     eax, ebp
.text:000036C4                 mov     [ebp+var_4], eax
.text:000036C7                 mov     eax, [ebp+Size]
.text:000036CA                 push    eax             ; Size
.text:000036CB                 movzx   ecx, [ebp+arg_4]
.text:000036CF                 push    ecx             ; Val
.text:000036D0                 lea     edx, [ebp+Dst]
.text:000036D6                 push    edx             ; Dst
.text:000036D7                 call    _memset
.text:000036DC                 add     esp, 0Ch
.text:000036DF                 mov     eax, [ebp+Size]
.text:000036E2                 mov     [ebp+eax+Dst], 0
.text:000036EA                 mov     esi, esp
.text:000036EC                 lea     ecx, [ebp+Dst]
.text:000036F2                 push    ecx
.text:000036F3                 mov     edx, [ebp+arg_0]
.text:000036F6                 mov     eax, [edx]
.text:000036F8                 mov     ecx, [ebp+arg_0]
.text:000036FB                 mov     edx, [eax]
.text:000036FD                 call    edx
.text:000036FF                 cmp     esi, esp
.text:00003701                 call    __RTC_CheckEsp
.text:00003706                 push    edx
.text:00003707                 mov     ecx, ebp
.text:00003709                 push    eax
.text:0000370A                 lea     edx, $LN5_8
.text:00003710                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00003715                 pop     eax
.text:00003716                 pop     edx
.text:00003717                 pop     edi
.text:00003718                 pop     esi
.text:00003719                 mov     ecx, [ebp+var_4]
.text:0000371C                 xor     ecx, ebp
.text:0000371E                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text:00003723                 add     esp, 10Ch
.text:00003729                 cmp     ebp, esp
.text:0000372B                 call    __RTC_CheckEsp
.text:00003730                 mov     esp, ebp
.text:00003732                 pop     ebp
.text:00003733                 retn    0Ch
.text:00003733 ?PrintChars@@YGXAAUIBenchPrintCallback@@DI@Z endp
.text:00003733
.text:00003733 ; ---------------------------------------------------------------------------
.text:00003736                 align 4
.text:00003738 $LN5_8          dd 1                    ; DATA XREF: PrintChars(IBenchPrintCallback &,char,uint)+6Ao
.text:0000373C                 dd offset $LN4_5
.text:00003740 $LN4_5          dd 0FFFFFEF8h, 100h     ; DATA XREF: .text:0000373Co
.text:00003748                 dd offset $LN3_1
.text:0000374C $LN3_1          dd 0CCCC0073h           ; DATA XREF: .text:00003748o
.text:00003750
.text:00003750 ; =============== S U B R O U T I N E =======================================
.text:00003750
.text:00003750 ; Attributes: bp-based frame
.text:00003750
.text:00003750 ; void __stdcall PrintResults(struct IBenchPrintCallback &, unsigned __int64, unsigned __int64, unsigned __int64, bool, unsigned __int64)
.text:00003750 ?PrintResults@@YGXAAUIBenchPrintCallback@@_K11_N1@Z proc near
.text:00003750                                         ; CODE XREF: PrintResults(IBenchPrintCallback *,CBenchInfo const &,uint,unsigned __int64,bool,unsigned __int64,CTotalBenchRes *)+D7p
.text:00003750                                         ; PrintTotals(IBenchPrintCallback &,bool,unsigned __int64,CTotalBenchRes const &)+A2p
.text:00003750
.text:00003750 var_8           = dword ptr -8
.text:00003750 var_4           = dword ptr -4
.text:00003750 arg_0           = dword ptr  8
.text:00003750 arg_4           = dword ptr  0Ch
.text:00003750 arg_8           = dword ptr  10h
.text:00003750 arg_C           = dword ptr  14h
.text:00003750 arg_10          = dword ptr  18h
.text:00003750 arg_14          = dword ptr  1Ch
.text:00003750 arg_18          = dword ptr  20h
.text:00003750 arg_1C          = byte ptr  24h
.text:00003750 arg_20          = dword ptr  28h
.text:00003750 arg_24          = dword ptr  2Ch
.text:00003750
.text:00003750                 push    ebp
.text:00003751                 mov     ebp, esp
.text:00003753                 sub     esp, 8
.text:00003756                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000375D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003764                 push    5
.text:00003766                 mov     eax, [ebp+arg_4]
.text:00003769                 add     eax, 1388h
.text:0000376E                 mov     ecx, [ebp+arg_8]
.text:00003771                 adc     ecx, 0
.text:00003774                 push    0
.text:00003776                 push    2710h
.text:0000377B                 push    ecx
.text:0000377C                 push    eax
.text:0000377D                 call    __aulldiv
.text:00003782                 push    edx
.text:00003783                 push    eax
.text:00003784                 mov     edx, [ebp+arg_0]
.text:00003787                 push    edx
.text:00003788                 call    ?PrintNumber@@YGXAAUIBenchPrintCallback@@_KH@Z ; PrintNumber(IBenchPrintCallback &,unsigned __int64,int)
.text:0000378D                 push    6
.text:0000378F                 mov     eax, [ebp+arg_10]
.text:00003792                 push    eax
.text:00003793                 mov     ecx, [ebp+arg_C]
.text:00003796                 push    ecx
.text:00003797                 mov     edx, [ebp+arg_0]
.text:0000379A                 push    edx
.text:0000379B                 call    ?PrintRating@@YGXAAUIBenchPrintCallback@@_KH@Z ; PrintRating(IBenchPrintCallback &,unsigned __int64,int)
.text:000037A0                 push    6
.text:000037A2                 mov     eax, [ebp+arg_18]
.text:000037A5                 push    eax
.text:000037A6                 mov     ecx, [ebp+arg_14]
.text:000037A9                 push    ecx
.text:000037AA                 mov     edx, [ebp+arg_0]
.text:000037AD                 push    edx
.text:000037AE                 call    ?PrintRating@@YGXAAUIBenchPrintCallback@@_KH@Z ; PrintRating(IBenchPrintCallback &,unsigned __int64,int)
.text:000037B3                 movzx   eax, [ebp+arg_1C]
.text:000037B7                 test    eax, eax
.text:000037B9                 jz      loc_3857
.text:000037BF                 mov     ecx, [ebp+arg_20]
.text:000037C2                 or      ecx, [ebp+arg_24]
.text:000037C5                 jnz     short loc_37D7
.text:000037C7                 push    0Ch             ; Size
.text:000037C9                 mov     edx, [ebp+arg_0]
.text:000037CC                 push    edx             ; int
.text:000037CD                 call    ?PrintSpaces@@YGXAAUIBenchPrintCallback@@I@Z ; PrintSpaces(IBenchPrintCallback &,uint)
.text:000037D2                 jmp     loc_3857
.text:000037D7 ; ---------------------------------------------------------------------------
.text:000037D7
.text:000037D7 loc_37D7:                               ; CODE XREF: PrintResults(IBenchPrintCallback &,unsigned __int64,unsigned __int64,unsigned __int64,bool,unsigned __int64)+75j
.text:000037D7                 mov     eax, [ebp+arg_8]
.text:000037DA                 push    eax
.text:000037DB                 mov     ecx, [ebp+arg_4]
.text:000037DE                 push    ecx
.text:000037DF                 mov     edx, [ebp+arg_24]
.text:000037E2                 push    edx
.text:000037E3                 mov     eax, [ebp+arg_20]
.text:000037E6                 push    eax
.text:000037E7                 call    __allmul
.text:000037EC                 push    0
.text:000037EE                 push    64h ; 'd'
.text:000037F0                 push    edx
.text:000037F1                 push    eax
.text:000037F2                 call    __aulldiv
.text:000037F7                 mov     [ebp+var_8], eax
.text:000037FA                 mov     [ebp+var_4], edx
.text:000037FD                 mov     ecx, [ebp+var_8]
.text:00003800                 or      ecx, [ebp+var_4]
.text:00003803                 jnz     short loc_3813
.text:00003805                 mov     [ebp+var_8], 1
.text:0000380C                 mov     [ebp+var_4], 0
.text:00003813
.text:00003813 loc_3813:                               ; CODE XREF: PrintResults(IBenchPrintCallback &,unsigned __int64,unsigned __int64,unsigned __int64,bool,unsigned __int64)+B3j
.text:00003813                 push    5
.text:00003815                 mov     edx, [ebp+var_4]
.text:00003818                 push    edx
.text:00003819                 mov     eax, [ebp+var_8]
.text:0000381C                 push    eax
.text:0000381D                 push    0
.text:0000381F                 push    2710h
.text:00003824                 mov     ecx, [ebp+arg_18]
.text:00003827                 push    ecx
.text:00003828                 mov     edx, [ebp+arg_14]
.text:0000382B                 push    edx
.text:0000382C                 call    __allmul
.text:00003831                 push    edx
.text:00003832                 push    eax
.text:00003833                 mov     eax, [ebp+arg_0]
.text:00003836                 push    eax
.text:00003837                 call    ?PrintPercents@@YGXAAUIBenchPrintCallback@@_K1H@Z ; PrintPercents(IBenchPrintCallback &,unsigned __int64,unsigned __int64,int)
.text:0000383C                 push    5
.text:0000383E                 mov     ecx, [ebp+arg_24]
.text:00003841                 push    ecx
.text:00003842                 mov     edx, [ebp+arg_20]
.text:00003845                 push    edx
.text:00003846                 mov     eax, [ebp+arg_18]
.text:00003849                 push    eax
.text:0000384A                 mov     ecx, [ebp+arg_14]
.text:0000384D                 push    ecx
.text:0000384E                 mov     edx, [ebp+arg_0]
.text:00003851                 push    edx
.text:00003852                 call    ?PrintPercents@@YGXAAUIBenchPrintCallback@@_K1H@Z ; PrintPercents(IBenchPrintCallback &,unsigned __int64,unsigned __int64,int)
.text:00003857
.text:00003857 loc_3857:                               ; CODE XREF: PrintResults(IBenchPrintCallback &,unsigned __int64,unsigned __int64,unsigned __int64,bool,unsigned __int64)+69j
.text:00003857                                         ; PrintResults(IBenchPrintCallback &,unsigned __int64,unsigned __int64,unsigned __int64,bool,unsigned __int64)+82j
.text:00003857                 add     esp, 8
.text:0000385A                 cmp     ebp, esp
.text:0000385C                 call    __RTC_CheckEsp
.text:00003861                 mov     esp, ebp
.text:00003863                 pop     ebp
.text:00003864                 retn    28h
.text:00003864 ?PrintResults@@YGXAAUIBenchPrintCallback@@_K11_N1@Z endp
.text:00003864
.text:00003864 ; ---------------------------------------------------------------------------
.text:00003867                 align 10h
.text:00003870
.text:00003870 ; =============== S U B R O U T I N E =======================================
.text:00003870
.text:00003870 ; Attributes: bp-based frame
.text:00003870
.text:00003870 ; void __stdcall PrintRating(struct IBenchPrintCallback &, unsigned __int64, int)
.text:00003870 ?PrintRating@@YGXAAUIBenchPrintCallback@@_KH@Z proc near
.text:00003870                                         ; CODE XREF: PrintResults(IBenchPrintCallback &,unsigned __int64,unsigned __int64,unsigned __int64,bool,unsigned __int64)+4Bp
.text:00003870                                         ; PrintResults(IBenchPrintCallback &,unsigned __int64,unsigned __int64,unsigned __int64,bool,unsigned __int64)+5Ep
.text:00003870
.text:00003870 arg_0           = dword ptr  8
.text:00003870 arg_4           = dword ptr  0Ch
.text:00003870 arg_8           = dword ptr  10h
.text:00003870 arg_C           = dword ptr  14h
.text:00003870
.text:00003870                 push    ebp
.text:00003871                 mov     ebp, esp
.text:00003873                 mov     eax, [ebp+arg_C]
.text:00003876                 push    eax
.text:00003877                 mov     ecx, [ebp+arg_4]
.text:0000387A                 add     ecx, 7A120h
.text:00003880                 mov     edx, [ebp+arg_8]
.text:00003883                 adc     edx, 0
.text:00003886                 push    0
.text:00003888                 push    0F4240h
.text:0000388D                 push    edx
.text:0000388E                 push    ecx
.text:0000388F                 call    __aulldiv
.text:00003894                 push    edx
.text:00003895                 push    eax
.text:00003896                 mov     eax, [ebp+arg_0]
.text:00003899                 push    eax
.text:0000389A                 call    ?PrintNumber@@YGXAAUIBenchPrintCallback@@_KH@Z ; PrintNumber(IBenchPrintCallback &,unsigned __int64,int)
.text:0000389F                 cmp     ebp, esp
.text:000038A1                 call    __RTC_CheckEsp
.text:000038A6                 pop     ebp
.text:000038A7                 retn    10h
.text:000038A7 ?PrintRating@@YGXAAUIBenchPrintCallback@@_KH@Z endp
.text:000038A7
.text:000038A7 ; ---------------------------------------------------------------------------
.text:000038AA                 align 10h
.text:000038B0
.text:000038B0 ; =============== S U B R O U T I N E =======================================
.text:000038B0
.text:000038B0 ; Attributes: bp-based frame
.text:000038B0
.text:000038B0 ; void __stdcall PrintPercents(struct IBenchPrintCallback &, unsigned __int64, unsigned __int64, int)
.text:000038B0 ?PrintPercents@@YGXAAUIBenchPrintCallback@@_K1H@Z proc near
.text:000038B0                                         ; CODE XREF: PrintResults(IBenchPrintCallback &,unsigned __int64,unsigned __int64,unsigned __int64,bool,unsigned __int64)+E7p
.text:000038B0                                         ; PrintResults(IBenchPrintCallback &,unsigned __int64,unsigned __int64,unsigned __int64,bool,unsigned __int64)+102p
.text:000038B0
.text:000038B0 arg_0           = dword ptr  8
.text:000038B0 arg_4           = dword ptr  0Ch
.text:000038B0 arg_8           = dword ptr  10h
.text:000038B0 arg_C           = dword ptr  14h
.text:000038B0 arg_10          = dword ptr  18h
.text:000038B0 arg_14          = dword ptr  1Ch
.text:000038B0
.text:000038B0                 push    ebp
.text:000038B1                 mov     ebp, esp
.text:000038B3                 push    esi
.text:000038B4                 push    edi
.text:000038B5                 mov     eax, [ebp+arg_14]
.text:000038B8                 push    eax
.text:000038B9                 push    0
.text:000038BB                 push    64h ; 'd'
.text:000038BD                 mov     ecx, [ebp+arg_8]
.text:000038C0                 push    ecx
.text:000038C1                 mov     edx, [ebp+arg_4]
.text:000038C4                 push    edx
.text:000038C5                 call    __allmul
.text:000038CA                 mov     esi, eax
.text:000038CC                 mov     edi, edx
.text:000038CE                 push    0
.text:000038D0                 push    2
.text:000038D2                 mov     eax, [ebp+arg_10]
.text:000038D5                 push    eax
.text:000038D6                 mov     ecx, [ebp+arg_C]
.text:000038D9                 push    ecx
.text:000038DA                 call    __aulldiv
.text:000038DF                 add     esi, eax
.text:000038E1                 adc     edi, edx
.text:000038E3                 mov     edx, [ebp+arg_10]
.text:000038E6                 push    edx
.text:000038E7                 mov     eax, [ebp+arg_C]
.text:000038EA                 push    eax
.text:000038EB                 push    edi
.text:000038EC                 push    esi
.text:000038ED                 call    __aulldiv
.text:000038F2                 push    edx
.text:000038F3                 push    eax
.text:000038F4                 mov     ecx, [ebp+arg_0]
.text:000038F7                 push    ecx
.text:000038F8                 call    ?PrintNumber@@YGXAAUIBenchPrintCallback@@_KH@Z ; PrintNumber(IBenchPrintCallback &,unsigned __int64,int)
.text:000038FD                 pop     edi
.text:000038FE                 pop     esi
.text:000038FF                 cmp     ebp, esp
.text:00003901                 call    __RTC_CheckEsp
.text:00003906                 pop     ebp
.text:00003907                 retn    18h
.text:00003907 ?PrintPercents@@YGXAAUIBenchPrintCallback@@_K1H@Z endp
.text:00003907
.text:00003907 ; ---------------------------------------------------------------------------
.text:0000390A                 align 10h
.text:00003910
.text:00003910 ; =============== S U B R O U T I N E =======================================
.text:00003910
.text:00003910 ; Attributes: bp-based frame
.text:00003910
.text:00003910 ; __int32 __thiscall CBenchCallbackToPrint::SetDecodeResult(CBenchCallbackToPrint *this, const struct CBenchInfo *, bool)
.text:00003910                 public ?SetDecodeResult@CBenchCallbackToPrint@@UAEJABUCBenchInfo@@_N@Z
.text:00003910 ?SetDecodeResult@CBenchCallbackToPrint@@UAEJABUCBenchInfo@@_N@Z proc near
.text:00003910                                         ; DATA XREF: .rdata:0000CC2Co
.text:00003910
.text:00003910 var_50          = byte ptr -50h
.text:00003910 var_4C          = byte ptr -4Ch
.text:00003910 var_2C          = dword ptr -2Ch
.text:00003910 var_28          = dword ptr -28h
.text:00003910 var_24          = dword ptr -24h
.text:00003910 var_20          = dword ptr -20h
.text:00003910 var_1C          = dword ptr -1Ch
.text:00003910 var_18          = dword ptr -18h
.text:00003910 var_10          = qword ptr -10h
.text:00003910 var_8           = dword ptr -8
.text:00003910 var_4           = dword ptr -4
.text:00003910 arg_0           = dword ptr  8
.text:00003910 arg_4           = byte ptr  0Ch
.text:00003910
.text:00003910                 push    ebp
.text:00003911                 mov     ebp, esp
.text:00003913                 sub     esp, 50h
.text:00003916                 push    esi
.text:00003917                 push    edi
.text:00003918                 push    ecx
.text:00003919                 lea     edi, [ebp+var_50]
.text:0000391C                 mov     ecx, 14h
.text:00003921                 mov     eax, 0CCCCCCCCh
.text:00003926                 rep stosd
.text:00003928                 pop     ecx
.text:00003929                 mov     [ebp+var_4], ecx
.text:0000392C                 mov     eax, [ebp+var_4]
.text:0000392F                 mov     ecx, [eax+58h]
.text:00003932                 mov     edx, [ebp+var_4]
.text:00003935                 mov     eax, [edx+58h]
.text:00003938                 mov     edx, [ecx]
.text:0000393A                 mov     esi, esp
.text:0000393C                 mov     ecx, eax
.text:0000393E                 mov     eax, [edx+8]
.text:00003941                 call    eax
.text:00003943                 cmp     esi, esp
.text:00003945                 call    __RTC_CheckEsp
.text:0000394A                 mov     [ebp+var_8], eax
.text:0000394D                 cmp     [ebp+var_8], 0
.text:00003951                 jz      short loc_395B
.text:00003953                 mov     eax, [ebp+var_8]
.text:00003956                 jmp     loc_3A7C
.text:0000395B ; ---------------------------------------------------------------------------
.text:0000395B
.text:0000395B loc_395B:                               ; CODE XREF: CBenchCallbackToPrint::SetDecodeResult(CBenchInfo const &,bool)+41j
.text:0000395B                 movzx   ecx, [ebp+arg_4]
.text:0000395F                 test    ecx, ecx
.text:00003961                 jz      loc_3A7A
.text:00003967                 mov     edx, [ebp+arg_0]
.text:0000396A                 mov     eax, [edx+34h]
.text:0000396D                 push    eax
.text:0000396E                 mov     ecx, [edx+30h]
.text:00003971                 push    ecx             ; unsigned __int64
.text:00003972                 mov     edx, [ebp+arg_0]
.text:00003975                 mov     eax, [edx+2Ch]
.text:00003978                 push    eax
.text:00003979                 mov     ecx, [edx+28h]
.text:0000397C                 push    ecx             ; unsigned __int64
.text:0000397D                 mov     edx, [ebp+arg_0]
.text:00003980                 mov     eax, [edx+24h]
.text:00003983                 push    eax
.text:00003984                 mov     ecx, [edx+20h]
.text:00003987                 push    ecx             ; unsigned __int64
.text:00003988                 mov     edx, [ebp+arg_0]
.text:0000398B                 mov     eax, [edx+0Ch]
.text:0000398E                 push    eax
.text:0000398F                 mov     ecx, [edx+8]
.text:00003992                 push    ecx             ; unsigned __int64
.text:00003993                 mov     edx, [ebp+arg_0]
.text:00003996                 mov     eax, [edx+4]
.text:00003999                 push    eax
.text:0000399A                 mov     ecx, [edx]
.text:0000399C                 push    ecx             ; unsigned __int64
.text:0000399D                 mov     ecx, [ebp+var_4]
.text:000039A0                 add     ecx, 4          ; this
.text:000039A3                 call    ?GetDecompressRating@CBenchProps@@QAE_K_K0000@Z ; CBenchProps::GetDecompressRating(unsigned __int64,unsigned __int64,unsigned __int64,unsigned __int64,unsigned __int64)
.text:000039A8                 mov     dword ptr [ebp+var_10], eax
.text:000039AB                 mov     dword ptr [ebp+var_10+4], edx
.text:000039AE                 mov     edx, [ebp+var_4]
.text:000039B1                 movzx   eax, byte ptr [edx+60h]
.text:000039B5                 test    eax, eax
.text:000039B7                 jz      short loc_39DD
.text:000039B9                 mov     esi, esp
.text:000039BB                 mov     ecx, ds:_kSep
.text:000039C1                 push    ecx
.text:000039C2                 mov     edx, [ebp+var_4]
.text:000039C5                 mov     eax, [edx+58h]
.text:000039C8                 mov     ecx, [ebp+var_4]
.text:000039CB                 mov     ecx, [ecx+58h]
.text:000039CE                 mov     edx, [eax]
.text:000039D0                 mov     eax, [edx]
.text:000039D2                 call    eax
.text:000039D4                 cmp     esi, esp
.text:000039D6                 call    __RTC_CheckEsp
.text:000039DB                 jmp     short loc_39F0
.text:000039DD ; ---------------------------------------------------------------------------
.text:000039DD
.text:000039DD loc_39DD:                               ; CODE XREF: CBenchCallbackToPrint::SetDecodeResult(CBenchInfo const &,bool)+A7j
.text:000039DD                 mov     ecx, [ebp+var_4]
.text:000039E0                 mov     edx, [ecx+64h]
.text:000039E3                 push    edx             ; Size
.text:000039E4                 mov     eax, [ebp+var_4]
.text:000039E7                 mov     ecx, [eax+58h]
.text:000039EA                 push    ecx             ; int
.text:000039EB                 call    ?PrintSpaces@@YGXAAUIBenchPrintCallback@@I@Z ; PrintSpaces(IBenchPrintCallback &,uint)
.text:000039F0
.text:000039F0 loc_39F0:                               ; CODE XREF: CBenchCallbackToPrint::SetDecodeResult(CBenchInfo const &,bool)+CBj
.text:000039F0                 mov     esi, [ebp+arg_0]
.text:000039F3                 mov     ecx, 0Eh
.text:000039F8                 lea     edi, [ebp+var_4C]
.text:000039FB                 rep movsd
.text:000039FD                 mov     edx, [ebp+var_18]
.text:00003A00                 push    edx
.text:00003A01                 mov     eax, [ebp+var_1C]
.text:00003A04                 push    eax
.text:00003A05                 mov     ecx, [ebp+var_28]
.text:00003A08                 push    ecx
.text:00003A09                 mov     edx, [ebp+var_2C]
.text:00003A0C                 push    edx
.text:00003A0D                 call    __allmul
.text:00003A12                 mov     [ebp+var_2C], eax
.text:00003A15                 mov     [ebp+var_28], edx
.text:00003A18                 mov     eax, [ebp+var_18]
.text:00003A1B                 push    eax
.text:00003A1C                 mov     ecx, [ebp+var_1C]
.text:00003A1F                 push    ecx
.text:00003A20                 mov     edx, [ebp+var_20]
.text:00003A23                 push    edx
.text:00003A24                 mov     eax, [ebp+var_24]
.text:00003A27                 push    eax
.text:00003A28                 call    __allmul
.text:00003A2D                 mov     [ebp+var_24], eax
.text:00003A30                 mov     [ebp+var_20], edx
.text:00003A33                 mov     [ebp+var_1C], 1
.text:00003A3A                 mov     [ebp+var_18], 0
.text:00003A41                 mov     ecx, [ebp+var_4]
.text:00003A44                 add     ecx, 38h ; '8'
.text:00003A47                 push    ecx             ; int
.text:00003A48                 mov     edx, [ebp+var_4]
.text:00003A4B                 mov     eax, [edx+74h]
.text:00003A4E                 push    eax             ; int
.text:00003A4F                 mov     ecx, [edx+70h]
.text:00003A52                 push    ecx             ; int
.text:00003A53                 mov     edx, [ebp+var_4]
.text:00003A56                 movzx   eax, byte ptr [edx+68h]
.text:00003A5A                 push    eax             ; char
.text:00003A5B                 mov     ecx, dword ptr [ebp+var_10+4]
.text:00003A5E                 push    ecx
.text:00003A5F                 mov     edx, dword ptr [ebp+var_10]
.text:00003A62                 push    edx             ; unsigned __int64
.text:00003A63                 mov     eax, [ebp+var_4]
.text:00003A66                 mov     ecx, [eax+7Ch]
.text:00003A69                 push    ecx             ; int
.text:00003A6A                 lea     edx, [ebp+var_4C]
.text:00003A6D                 push    edx             ; CBenchInfo *
.text:00003A6E                 mov     eax, [ebp+var_4]
.text:00003A71                 mov     ecx, [eax+58h]
.text:00003A74                 push    ecx             ; int
.text:00003A75                 call    ?PrintResults@@YGXPAUIBenchPrintCallback@@ABUCBenchInfo@@I_K_N2PAUCTotalBenchRes@@@Z ; PrintResults(IBenchPrintCallback *,CBenchInfo const &,uint,unsigned __int64,bool,unsigned __int64,CTotalBenchRes *)
.text:00003A7A
.text:00003A7A loc_3A7A:                               ; CODE XREF: CBenchCallbackToPrint::SetDecodeResult(CBenchInfo const &,bool)+51j
.text:00003A7A                 xor     eax, eax
.text:00003A7C
.text:00003A7C loc_3A7C:                               ; CODE XREF: CBenchCallbackToPrint::SetDecodeResult(CBenchInfo const &,bool)+46j
.text:00003A7C                 push    edx
.text:00003A7D                 mov     ecx, ebp
.text:00003A7F                 push    eax
.text:00003A80                 lea     edx, $LN9_3
.text:00003A86                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00003A8B                 pop     eax
.text:00003A8C                 pop     edx
.text:00003A8D                 pop     edi
.text:00003A8E                 pop     esi
.text:00003A8F                 add     esp, 50h
.text:00003A92                 cmp     ebp, esp
.text:00003A94                 call    __RTC_CheckEsp
.text:00003A99                 mov     esp, ebp
.text:00003A9B                 pop     ebp
.text:00003A9C                 retn    8
.text:00003A9C ?SetDecodeResult@CBenchCallbackToPrint@@UAEJABUCBenchInfo@@_N@Z endp
.text:00003A9C
.text:00003A9C ; ---------------------------------------------------------------------------
.text:00003A9F                 align 10h
.text:00003AA0 $LN9_3          dd 1                    ; DATA XREF: CBenchCallbackToPrint::SetDecodeResult(CBenchInfo const &,bool)+170o
.text:00003AA4                 dd offset $LN8_3
.text:00003AA8 $LN8_3          dd 0FFFFFFB4h, 38h      ; DATA XREF: .text:00003AA4o
.text:00003AB0                 dd offset $LN7_3        ; "info2"
.text:00003AB4 $LN7_3          db 'info2',0            ; DATA XREF: .text:00003AB0o
.text:00003ABA                 align 10h
.text:00003AC0
.text:00003AC0 ; =============== S U B R O U T I N E =======================================
.text:00003AC0
.text:00003AC0 ; Attributes: bp-based frame
.text:00003AC0
.text:00003AC0 ; void __thiscall CBenchCallbackToPrint::Print(CBenchCallbackToPrint *this, const char *)
.text:00003AC0                 public ?Print@CBenchCallbackToPrint@@QAEXPBD@Z
.text:00003AC0 ?Print@CBenchCallbackToPrint@@QAEXPBD@Z proc near
.text:00003AC0
.text:00003AC0 var_4           = dword ptr -4
.text:00003AC0 arg_0           = dword ptr  8
.text:00003AC0
.text:00003AC0                 push    ebp
.text:00003AC1                 mov     ebp, esp
.text:00003AC3                 push    ecx
.text:00003AC4                 push    esi
.text:00003AC5                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003ACC                 mov     [ebp+var_4], ecx
.text:00003ACF                 mov     esi, esp
.text:00003AD1                 mov     eax, [ebp+arg_0]
.text:00003AD4                 push    eax
.text:00003AD5                 mov     ecx, [ebp+var_4]
.text:00003AD8                 mov     edx, [ecx+58h]
.text:00003ADB                 mov     eax, [ebp+var_4]
.text:00003ADE                 mov     ecx, [eax+58h]
.text:00003AE1                 mov     edx, [edx]
.text:00003AE3                 mov     eax, [edx]
.text:00003AE5                 call    eax
.text:00003AE7                 cmp     esi, esp
.text:00003AE9                 call    __RTC_CheckEsp
.text:00003AEE                 pop     esi
.text:00003AEF                 add     esp, 4
.text:00003AF2                 cmp     ebp, esp
.text:00003AF4                 call    __RTC_CheckEsp
.text:00003AF9                 mov     esp, ebp
.text:00003AFB                 pop     ebp
.text:00003AFC                 retn    4
.text:00003AFC ?Print@CBenchCallbackToPrint@@QAEXPBD@Z endp
.text:00003AFC
.text:00003AFC ; ---------------------------------------------------------------------------
.text:00003AFF                 align 10h
.text:00003B00
.text:00003B00 ; =============== S U B R O U T I N E =======================================
.text:00003B00
.text:00003B00 ; Attributes: bp-based frame
.text:00003B00
.text:00003B00 ; void __thiscall CBenchCallbackToPrint::NewLine(CBenchCallbackToPrint *__hidden this)
.text:00003B00                 public ?NewLine@CBenchCallbackToPrint@@QAEXXZ
.text:00003B00 ?NewLine@CBenchCallbackToPrint@@QAEXXZ proc near
.text:00003B00                                         ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1662p
.text:00003B00                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1699p ...
.text:00003B00
.text:00003B00 var_4           = dword ptr -4
.text:00003B00
.text:00003B00                 push    ebp
.text:00003B01                 mov     ebp, esp
.text:00003B03                 push    ecx
.text:00003B04                 push    esi
.text:00003B05                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003B0C                 mov     [ebp+var_4], ecx
.text:00003B0F                 mov     eax, [ebp+var_4]
.text:00003B12                 mov     ecx, [eax+58h]
.text:00003B15                 mov     edx, [ebp+var_4]
.text:00003B18                 mov     eax, [edx+58h]
.text:00003B1B                 mov     edx, [ecx]
.text:00003B1D                 mov     esi, esp
.text:00003B1F                 mov     ecx, eax
.text:00003B21                 mov     eax, [edx+4]
.text:00003B24                 call    eax
.text:00003B26                 cmp     esi, esp
.text:00003B28                 call    __RTC_CheckEsp
.text:00003B2D                 pop     esi
.text:00003B2E                 add     esp, 4
.text:00003B31                 cmp     ebp, esp
.text:00003B33                 call    __RTC_CheckEsp
.text:00003B38                 mov     esp, ebp
.text:00003B3A                 pop     ebp
.text:00003B3B                 retn
.text:00003B3B ?NewLine@CBenchCallbackToPrint@@QAEXXZ endp
.text:00003B3B
.text:00003B3B ; ---------------------------------------------------------------------------
.text:00003B3C                 align 10h
.text:00003B40
.text:00003B40 ; =============== S U B R O U T I N E =======================================
.text:00003B40
.text:00003B40 ; Attributes: bp-based frame
.text:00003B40
.text:00003B40 ; void __stdcall PrintLeft(struct IBenchPrintCallback *, const char *, unsigned int)
.text:00003B40                 public ?PrintLeft@@YGXAAUIBenchPrintCallback@@PBDI@Z
.text:00003B40 ?PrintLeft@@YGXAAUIBenchPrintCallback@@PBDI@Z proc near
.text:00003B40                                         ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+12FDp
.text:00003B40                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+15D9p ...
.text:00003B40
.text:00003B40 Size            = dword ptr -4
.text:00003B40 arg_0           = dword ptr  8
.text:00003B40 arg_4           = dword ptr  0Ch
.text:00003B40 arg_8           = dword ptr  10h
.text:00003B40
.text:00003B40                 push    ebp
.text:00003B41                 mov     ebp, esp
.text:00003B43                 push    ecx
.text:00003B44                 push    esi
.text:00003B45                 mov     [ebp+Size], 0CCCCCCCCh
.text:00003B4C                 mov     esi, esp
.text:00003B4E                 mov     eax, [ebp+arg_4]
.text:00003B51                 push    eax
.text:00003B52                 mov     ecx, [ebp+arg_0]
.text:00003B55                 mov     edx, [ecx]
.text:00003B57                 mov     ecx, [ebp+arg_0]
.text:00003B5A                 mov     eax, [edx]
.text:00003B5C                 call    eax
.text:00003B5E                 cmp     esi, esp
.text:00003B60                 call    __RTC_CheckEsp
.text:00003B65                 mov     ecx, [ebp+arg_4]
.text:00003B68                 push    ecx             ; char *
.text:00003B69                 call    ?MyStringLen@@YGIPBD@Z ; MyStringLen(char const *)
.text:00003B6E                 mov     edx, [ebp+arg_8]
.text:00003B71                 sub     edx, eax
.text:00003B73                 mov     [ebp+Size], edx
.text:00003B76                 cmp     [ebp+Size], 0
.text:00003B7A                 jle     short loc_3B89
.text:00003B7C                 mov     eax, [ebp+Size]
.text:00003B7F                 push    eax             ; Size
.text:00003B80                 mov     ecx, [ebp+arg_0]
.text:00003B83                 push    ecx             ; int
.text:00003B84                 call    ?PrintSpaces@@YGXAAUIBenchPrintCallback@@I@Z ; PrintSpaces(IBenchPrintCallback &,uint)
.text:00003B89
.text:00003B89 loc_3B89:                               ; CODE XREF: PrintLeft(IBenchPrintCallback &,char const *,uint)+3Aj
.text:00003B89                 pop     esi
.text:00003B8A                 add     esp, 4
.text:00003B8D                 cmp     ebp, esp
.text:00003B8F                 call    __RTC_CheckEsp
.text:00003B94                 mov     esp, ebp
.text:00003B96                 pop     ebp
.text:00003B97                 retn    0Ch
.text:00003B97 ?PrintLeft@@YGXAAUIBenchPrintCallback@@PBDI@Z endp
.text:00003B97
.text:00003B97 ; ---------------------------------------------------------------------------
.text:00003B9A                 align 10h
.text:00003BA0
.text:00003BA0 ; =============== S U B R O U T I N E =======================================
.text:00003BA0
.text:00003BA0 ; Attributes: bp-based frame
.text:00003BA0
.text:00003BA0 ; void __stdcall PrintRight(struct IBenchPrintCallback *, const char *, unsigned int)
.text:00003BA0                 public ?PrintRight@@YGXAAUIBenchPrintCallback@@PBDI@Z
.text:00003BA0 ?PrintRight@@YGXAAUIBenchPrintCallback@@PBDI@Z proc near
.text:00003BA0                                         ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+126Cp
.text:00003BA0                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+12A6p ...
.text:00003BA0
.text:00003BA0 Size            = dword ptr -4
.text:00003BA0 arg_0           = dword ptr  8
.text:00003BA0 arg_4           = dword ptr  0Ch
.text:00003BA0 arg_8           = dword ptr  10h
.text:00003BA0
.text:00003BA0                 push    ebp
.text:00003BA1                 mov     ebp, esp
.text:00003BA3                 push    ecx
.text:00003BA4                 push    esi
.text:00003BA5                 mov     [ebp+Size], 0CCCCCCCCh
.text:00003BAC                 mov     eax, [ebp+arg_4]
.text:00003BAF                 push    eax             ; char *
.text:00003BB0                 call    ?MyStringLen@@YGIPBD@Z ; MyStringLen(char const *)
.text:00003BB5                 mov     ecx, [ebp+arg_8]
.text:00003BB8                 sub     ecx, eax
.text:00003BBA                 mov     [ebp+Size], ecx
.text:00003BBD                 cmp     [ebp+Size], 0
.text:00003BC1                 jle     short loc_3BD0
.text:00003BC3                 mov     edx, [ebp+Size]
.text:00003BC6                 push    edx             ; Size
.text:00003BC7                 mov     eax, [ebp+arg_0]
.text:00003BCA                 push    eax             ; int
.text:00003BCB                 call    ?PrintSpaces@@YGXAAUIBenchPrintCallback@@I@Z ; PrintSpaces(IBenchPrintCallback &,uint)
.text:00003BD0
.text:00003BD0 loc_3BD0:                               ; CODE XREF: PrintRight(IBenchPrintCallback &,char const *,uint)+21j
.text:00003BD0                 mov     esi, esp
.text:00003BD2                 mov     ecx, [ebp+arg_4]
.text:00003BD5                 push    ecx
.text:00003BD6                 mov     edx, [ebp+arg_0]
.text:00003BD9                 mov     eax, [edx]
.text:00003BDB                 mov     ecx, [ebp+arg_0]
.text:00003BDE                 mov     edx, [eax]
.text:00003BE0                 call    edx
.text:00003BE2                 cmp     esi, esp
.text:00003BE4                 call    __RTC_CheckEsp
.text:00003BE9                 pop     esi
.text:00003BEA                 add     esp, 4
.text:00003BED                 cmp     ebp, esp
.text:00003BEF                 call    __RTC_CheckEsp
.text:00003BF4                 mov     esp, ebp
.text:00003BF6                 pop     ebp
.text:00003BF7                 retn    0Ch
.text:00003BF7 ?PrintRight@@YGXAAUIBenchPrintCallback@@PBDI@Z endp
.text:00003BF7
.text:00003BF7 ; ---------------------------------------------------------------------------
.text:00003BFA                 align 10h
.text:00003C00
.text:00003C00 ; =============== S U B R O U T I N E =======================================
.text:00003C00
.text:00003C00 ; Attributes: bp-based frame
.text:00003C00
.text:00003C00 ; void __stdcall GetCpuName(struct AString *)
.text:00003C00                 public ?GetCpuName@@YGXAAVAString@@@Z
.text:00003C00 ?GetCpuName@@YGXAAVAString@@@Z proc near
.text:00003C00                                         ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+412p
.text:00003C00
.text:00003C00 var_2C          = byte ptr -2Ch
.text:00003C00 var_28          = dword ptr -28h
.text:00003C00 var_4           = dword ptr -4
.text:00003C00 arg_0           = dword ptr  8
.text:00003C00
.text:00003C00                 push    ebp
.text:00003C01                 mov     ebp, esp
.text:00003C03                 sub     esp, 2Ch
.text:00003C06                 push    edi
.text:00003C07                 lea     edi, [ebp+var_2C]
.text:00003C0A                 mov     ecx, 0Bh
.text:00003C0F                 mov     eax, 0CCCCCCCCh
.text:00003C14                 rep stosd
.text:00003C16                 mov     eax, dword ptr ds:___security_cookie
.text:00003C1B                 xor     eax, ebp
.text:00003C1D                 mov     [ebp+var_4], eax
.text:00003C20                 mov     ecx, [ebp+arg_0] ; this
.text:00003C23                 call    ?Empty@AString@@QAEXXZ ; AString::Empty(void)
.text:00003C28                 lea     eax, [ebp+var_28]
.text:00003C2B                 push    eax
.text:00003C2C                 call    _x86cpuid_CheckAndRead@4 ; x86cpuid_CheckAndRead(x)
.text:00003C31                 test    eax, eax
.text:00003C33                 jz      short loc_3C44
.text:00003C35                 mov     ecx, [ebp+arg_0]
.text:00003C38                 push    ecx             ; AString *
.text:00003C39                 lea     edx, [ebp+var_28]
.text:00003C3C                 push    edx             ; int
.text:00003C3D                 call    ?x86cpuid_to_String@@YGXABUCx86cpuid@@AAVAString@@@Z ; x86cpuid_to_String(Cx86cpuid const &,AString &)
.text:00003C42                 jmp     short loc_3C51
.text:00003C44 ; ---------------------------------------------------------------------------
.text:00003C44
.text:00003C44 loc_3C44:                               ; CODE XREF: GetCpuName(AString &)+33j
.text:00003C44                 push    offset $SG71417 ; "x86"
.text:00003C49                 mov     ecx, [ebp+arg_0]
.text:00003C4C                 call    ??4AString@@QAEAAV0@PBD@Z ; AString::operator=(char const *)
.text:00003C51
.text:00003C51 loc_3C51:                               ; CODE XREF: GetCpuName(AString &)+42j
.text:00003C51                 push    edx
.text:00003C52                 mov     ecx, ebp
.text:00003C54                 push    eax
.text:00003C55                 lea     edx, $LN6_6
.text:00003C5B                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00003C60                 pop     eax
.text:00003C61                 pop     edx
.text:00003C62                 pop     edi
.text:00003C63                 mov     ecx, [ebp+var_4]
.text:00003C66                 xor     ecx, ebp
.text:00003C68                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text:00003C6D                 add     esp, 2Ch
.text:00003C70                 cmp     ebp, esp
.text:00003C72                 call    __RTC_CheckEsp
.text:00003C77                 mov     esp, ebp
.text:00003C79                 pop     ebp
.text:00003C7A                 retn    4
.text:00003C7A ?GetCpuName@@YGXAAVAString@@@Z endp
.text:00003C7A
.text:00003C7A ; ---------------------------------------------------------------------------
.text:00003C7D                 align 10h
.text:00003C80 $LN6_6          dd 1                    ; DATA XREF: GetCpuName(AString &)+55o
.text:00003C84                 dd offset $LN5_9
.text:00003C88 $LN5_9          dd 0FFFFFFD8h, 20h      ; DATA XREF: .text:00003C84o
.text:00003C90                 dd offset $LN4_6        ; "cpuid"
.text:00003C94 $LN4_6          db 'cpuid',0            ; DATA XREF: .text:00003C90o
.text:00003C9A                 align 10h
.text:00003CA0
.text:00003CA0 ; =============== S U B R O U T I N E =======================================
.text:00003CA0
.text:00003CA0 ; Attributes: bp-based frame
.text:00003CA0
.text:00003CA0 ; int __stdcall x86cpuid_to_String(int, AString *)
.text:00003CA0 ?x86cpuid_to_String@@YGXABUCx86cpuid@@AAVAString@@@Z proc near
.text:00003CA0                                         ; CODE XREF: GetCpuName(AString &)+3Dp
.text:00003CA0
.text:00003CA0 var_74          = byte ptr -74h
.text:00003CA0 var_70          = byte ptr -70h
.text:00003CA0 var_4C          = dword ptr -4Ch
.text:00003CA0 var_44          = dword ptr -44h
.text:00003CA0 var_40          = dword ptr -40h
.text:00003CA0 var_3C          = dword ptr -3Ch
.text:00003CA0 var_38          = dword ptr -38h
.text:00003CA0 var_30          = dword ptr -30h
.text:00003CA0 var_2C          = dword ptr -2Ch
.text:00003CA0 var_25          = byte ptr -25h
.text:00003CA0 var_20          = byte ptr -20h
.text:00003CA0 var_1C          = byte ptr -1Ch
.text:00003CA0 var_18          = byte ptr -18h
.text:00003CA0 var_C           = dword ptr -0Ch
.text:00003CA0 var_4           = dword ptr -4
.text:00003CA0 arg_0           = dword ptr  8
.text:00003CA0 arg_4           = dword ptr  0Ch
.text:00003CA0
.text:00003CA0                 push    ebp
.text:00003CA1                 mov     ebp, esp
.text:00003CA3                 sub     esp, 74h
.text:00003CA6                 push    edi
.text:00003CA7                 lea     edi, [ebp+var_74]
.text:00003CAA                 mov     ecx, 1Dh
.text:00003CAF                 mov     eax, 0CCCCCCCCh
.text:00003CB4                 rep stosd
.text:00003CB6                 mov     eax, dword ptr ds:___security_cookie
.text:00003CBB                 xor     eax, ebp
.text:00003CBD                 mov     [ebp+var_4], eax
.text:00003CC0                 mov     ecx, [ebp+arg_4] ; this
.text:00003CC3                 call    ?Empty@AString@@QAEXXZ ; AString::Empty(void)
.text:00003CC8                 mov     [ebp+var_C], 0
.text:00003CCF                 lea     eax, [ebp+var_18]
.text:00003CD2                 push    eax
.text:00003CD3                 lea     ecx, [ebp+var_1C]
.text:00003CD6                 push    ecx
.text:00003CD7                 lea     edx, [ebp+var_20]
.text:00003CDA                 push    edx
.text:00003CDB                 lea     eax, [ebp+var_C]
.text:00003CDE                 push    eax
.text:00003CDF                 push    80000000h
.text:00003CE4                 call    _MyCPUID@20     ; MyCPUID(x,x,x,x,x)
.text:00003CE9                 cmp     [ebp+var_C], 80000004h
.text:00003CF0                 sbb     ecx, ecx
.text:00003CF2                 add     ecx, 1
.text:00003CF5                 mov     [ebp+var_25], cl
.text:00003CF8                 movzx   edx, [ebp+var_25]
.text:00003CFC                 test    edx, edx
.text:00003CFE                 jnz     short loc_3D30
.text:00003D00                 mov     [ebp+var_2C], 0
.text:00003D07                 jmp     short loc_3D12
.text:00003D09 ; ---------------------------------------------------------------------------
.text:00003D09
.text:00003D09 loc_3D09:                               ; CODE XREF: x86cpuid_to_String(Cx86cpuid const &,AString &)+8Cj
.text:00003D09                 mov     eax, [ebp+var_2C]
.text:00003D0C                 add     eax, 1
.text:00003D0F                 mov     [ebp+var_2C], eax
.text:00003D12
.text:00003D12 loc_3D12:                               ; CODE XREF: x86cpuid_to_String(Cx86cpuid const &,AString &)+67j
.text:00003D12                 cmp     [ebp+var_2C], 3
.text:00003D16                 jge     short loc_3D2E
.text:00003D18                 mov     ecx, [ebp+var_2C]
.text:00003D1B                 mov     edx, [ebp+arg_0]
.text:00003D1E                 mov     eax, [edx+ecx*4+4]
.text:00003D22                 push    eax
.text:00003D23                 mov     ecx, [ebp+arg_4]
.text:00003D26                 push    ecx
.text:00003D27                 call    ?PrintCpuChars@@YGXAAVAString@@I@Z ; PrintCpuChars(AString &,uint)
.text:00003D2C                 jmp     short loc_3D09
.text:00003D2E ; ---------------------------------------------------------------------------
.text:00003D2E
.text:00003D2E loc_3D2E:                               ; CODE XREF: x86cpuid_to_String(Cx86cpuid const &,AString &)+76j
.text:00003D2E                 jmp     short loc_3DA6
.text:00003D30 ; ---------------------------------------------------------------------------
.text:00003D30
.text:00003D30 loc_3D30:                               ; CODE XREF: x86cpuid_to_String(Cx86cpuid const &,AString &)+5Ej
.text:00003D30                 mov     [ebp+var_30], 0
.text:00003D37                 jmp     short loc_3D42
.text:00003D39 ; ---------------------------------------------------------------------------
.text:00003D39
.text:00003D39 loc_3D39:                               ; CODE XREF: x86cpuid_to_String(Cx86cpuid const &,AString &):loc_3DA4j
.text:00003D39                 mov     edx, [ebp+var_30]
.text:00003D3C                 add     edx, 1
.text:00003D3F                 mov     [ebp+var_30], edx
.text:00003D42
.text:00003D42 loc_3D42:                               ; CODE XREF: x86cpuid_to_String(Cx86cpuid const &,AString &)+97j
.text:00003D42                 cmp     [ebp+var_30], 3
.text:00003D46                 jge     short loc_3DA6
.text:00003D48                 mov     [ebp+var_44], 0
.text:00003D4F                 xor     eax, eax
.text:00003D51                 mov     [ebp+var_40], eax
.text:00003D54                 mov     [ebp+var_3C], eax
.text:00003D57                 mov     [ebp+var_38], eax
.text:00003D5A                 lea     ecx, [ebp+var_38]
.text:00003D5D                 push    ecx
.text:00003D5E                 lea     edx, [ebp+var_3C]
.text:00003D61                 push    edx
.text:00003D62                 lea     eax, [ebp+var_40]
.text:00003D65                 push    eax
.text:00003D66                 lea     ecx, [ebp+var_44]
.text:00003D69                 push    ecx
.text:00003D6A                 mov     edx, [ebp+var_30]
.text:00003D6D                 sub     edx, 7FFFFFFEh
.text:00003D73                 push    edx
.text:00003D74                 call    _MyCPUID@20     ; MyCPUID(x,x,x,x,x)
.text:00003D79                 mov     [ebp+var_4C], 0
.text:00003D80                 jmp     short loc_3D8B
.text:00003D82 ; ---------------------------------------------------------------------------
.text:00003D82
.text:00003D82 loc_3D82:                               ; CODE XREF: x86cpuid_to_String(Cx86cpuid const &,AString &)+102j
.text:00003D82                 mov     eax, [ebp+var_4C]
.text:00003D85                 add     eax, 1
.text:00003D88                 mov     [ebp+var_4C], eax
.text:00003D8B
.text:00003D8B loc_3D8B:                               ; CODE XREF: x86cpuid_to_String(Cx86cpuid const &,AString &)+E0j
.text:00003D8B                 cmp     [ebp+var_4C], 4
.text:00003D8F                 jge     short loc_3DA4
.text:00003D91                 mov     ecx, [ebp+var_4C]
.text:00003D94                 mov     edx, [ebp+ecx*4+var_44]
.text:00003D98                 push    edx
.text:00003D99                 mov     eax, [ebp+arg_4]
.text:00003D9C                 push    eax
.text:00003D9D                 call    ?PrintCpuChars@@YGXAAVAString@@I@Z ; PrintCpuChars(AString &,uint)
.text:00003DA2                 jmp     short loc_3D82
.text:00003DA4 ; ---------------------------------------------------------------------------
.text:00003DA4
.text:00003DA4 loc_3DA4:                               ; CODE XREF: x86cpuid_to_String(Cx86cpuid const &,AString &)+EFj
.text:00003DA4                 jmp     short loc_3D39
.text:00003DA6 ; ---------------------------------------------------------------------------
.text:00003DA6
.text:00003DA6 loc_3DA6:                               ; CODE XREF: x86cpuid_to_String(Cx86cpuid const &,AString &):loc_3D2Ej
.text:00003DA6                                         ; x86cpuid_to_String(Cx86cpuid const &,AString &)+A6j
.text:00003DA6                 mov     ecx, [ebp+arg_4] ; this
.text:00003DA9                 call    ?Add_Space_if_NotEmpty@AString@@QAEXXZ ; AString::Add_Space_if_NotEmpty(void)
.text:00003DAE                 lea     ecx, [ebp+var_70]
.text:00003DB1                 push    ecx             ; char *
.text:00003DB2                 mov     edx, [ebp+arg_0]
.text:00003DB5                 mov     eax, [edx+10h]
.text:00003DB8                 push    eax             ; unsigned int
.text:00003DB9                 call    ?ConvertUInt32ToHex@@YGXIPAD@Z ; ConvertUInt32ToHex(uint,char *)
.text:00003DBE                 push    28h ; '('
.text:00003DC0                 mov     ecx, [ebp+arg_4]
.text:00003DC3                 call    ??YAString@@QAEAAV0@D@Z ; AString::operator+=(char)
.text:00003DC8                 lea     ecx, [ebp+var_70]
.text:00003DCB                 push    ecx
.text:00003DCC                 mov     ecx, [ebp+arg_4]
.text:00003DCF                 call    ??YAString@@QAEAAV0@PBD@Z ; AString::operator+=(char const *)
.text:00003DD4                 push    29h ; ')'
.text:00003DD6                 mov     ecx, [ebp+arg_4]
.text:00003DD9                 call    ??YAString@@QAEAAV0@D@Z ; AString::operator+=(char)
.text:00003DDE                 push    edx
.text:00003DDF                 mov     ecx, ebp
.text:00003DE1                 push    eax
.text:00003DE2                 lea     edx, $LN19_0
.text:00003DE8                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00003DED                 pop     eax
.text:00003DEE                 pop     edx
.text:00003DEF                 pop     edi
.text:00003DF0                 mov     ecx, [ebp+var_4]
.text:00003DF3                 xor     ecx, ebp
.text:00003DF5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text:00003DFA                 add     esp, 74h
.text:00003DFD                 cmp     ebp, esp
.text:00003DFF                 call    __RTC_CheckEsp
.text:00003E04                 mov     esp, ebp
.text:00003E06                 pop     ebp
.text:00003E07                 retn    8
.text:00003E07 ?x86cpuid_to_String@@YGXABUCx86cpuid@@AAVAString@@@Z endp
.text:00003E07
.text:00003E07 ; ---------------------------------------------------------------------------
.text:00003E0A                 align 4
.text:00003E0C $LN19_0         dd 4                    ; DATA XREF: x86cpuid_to_String(Cx86cpuid const &,AString &)+142o
.text:00003E10                 dd offset $LN18_0
.text:00003E14 $LN18_0         dd 0FFFFFFF4h, 4        ; DATA XREF: .text:00003E10o
.text:00003E1C                 dd offset $LN14         ; "maxFunc2"
.text:00003E20                 dd 0FFFFFFE0h, 0Ch
.text:00003E28                 dd offset $LN15         ; "t"
.text:00003E2C                 dd 0FFFFFFBCh, 10h
.text:00003E34                 dd offset $LN16_1       ; "c"
.text:00003E38                 db 90h
.text:00003E39                 db 3 dup(0FFh)
.text:00003E3C                 dd offset $SG70851
.text:00003E40                 dd offset $LN17_1       ; "temp"
.text:00003E44 $LN17_1         db 'temp',0             ; DATA XREF: .text:00003E40o
.text:00003E49 $LN16_1         db 'c',0                ; DATA XREF: .text:00003E34o
.text:00003E4B $LN15           db 't',0                ; DATA XREF: .text:00003E28o
.text:00003E4D $LN14           db 'maxFunc2',0         ; DATA XREF: .text:00003E1Co
.text:00003E56                 align 10h
.text:00003E60
.text:00003E60 ; =============== S U B R O U T I N E =======================================
.text:00003E60
.text:00003E60 ; Attributes: bp-based frame
.text:00003E60
.text:00003E60 ; void __stdcall PrintCpuChars(class AString &, unsigned int)
.text:00003E60 ?PrintCpuChars@@YGXAAVAString@@I@Z proc near
.text:00003E60                                         ; CODE XREF: x86cpuid_to_String(Cx86cpuid const &,AString &)+87p
.text:00003E60                                         ; x86cpuid_to_String(Cx86cpuid const &,AString &)+FDp
.text:00003E60
.text:00003E60 var_8           = dword ptr -8
.text:00003E60 var_4           = dword ptr -4
.text:00003E60 arg_0           = dword ptr  8
.text:00003E60 arg_4           = dword ptr  0Ch
.text:00003E60
.text:00003E60                 push    ebp
.text:00003E61                 mov     ebp, esp
.text:00003E63                 sub     esp, 8
.text:00003E66                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00003E6D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003E74                 mov     [ebp+var_4], 0
.text:00003E7B                 jmp     short loc_3E86
.text:00003E7D ; ---------------------------------------------------------------------------
.text:00003E7D
.text:00003E7D loc_3E7D:                               ; CODE XREF: PrintCpuChars(AString &,uint)+58j
.text:00003E7D                 mov     eax, [ebp+var_4]
.text:00003E80                 add     eax, 1
.text:00003E83                 mov     [ebp+var_4], eax
.text:00003E86
.text:00003E86 loc_3E86:                               ; CODE XREF: PrintCpuChars(AString &,uint)+1Bj
.text:00003E86                 cmp     [ebp+var_4], 4
.text:00003E8A                 jge     short loc_3EBA
.text:00003E8C                 mov     ecx, [ebp+arg_4]
.text:00003E8F                 and     ecx, 0FFh
.text:00003E95                 mov     byte ptr [ebp+var_8+3], cl
.text:00003E98                 mov     edx, [ebp+arg_4]
.text:00003E9B                 shr     edx, 8
.text:00003E9E                 mov     [ebp+arg_4], edx
.text:00003EA1                 movzx   eax, byte ptr [ebp+var_8+3]
.text:00003EA5                 test    eax, eax
.text:00003EA7                 jnz     short loc_3EAB
.text:00003EA9                 jmp     short loc_3EBA
.text:00003EAB ; ---------------------------------------------------------------------------
.text:00003EAB
.text:00003EAB loc_3EAB:                               ; CODE XREF: PrintCpuChars(AString &,uint)+47j
.text:00003EAB                 movzx   ecx, byte ptr [ebp+var_8+3]
.text:00003EAF                 push    ecx
.text:00003EB0                 mov     ecx, [ebp+arg_0]
.text:00003EB3                 call    ??YAString@@QAEAAV0@D@Z ; AString::operator+=(char)
.text:00003EB8                 jmp     short loc_3E7D
.text:00003EBA ; ---------------------------------------------------------------------------
.text:00003EBA
.text:00003EBA loc_3EBA:                               ; CODE XREF: PrintCpuChars(AString &,uint)+2Aj
.text:00003EBA                                         ; PrintCpuChars(AString &,uint)+49j
.text:00003EBA                 add     esp, 8
.text:00003EBD                 cmp     ebp, esp
.text:00003EBF                 call    __RTC_CheckEsp
.text:00003EC4                 mov     esp, ebp
.text:00003EC6                 pop     ebp
.text:00003EC7                 retn    8
.text:00003EC7 ?PrintCpuChars@@YGXAAVAString@@I@Z endp
.text:00003EC7
.text:00003EC7 ; ---------------------------------------------------------------------------
.text:00003ECA                 align 10h
.text:00003ED0
.text:00003ED0 ; =============== S U B R O U T I N E =======================================
.text:00003ED0
.text:00003ED0 ; Attributes: bp-based frame
.text:00003ED0
.text:00003ED0 ; long __stdcall Bench(struct IBenchPrintCallback *, struct IBenchCallback *, class CObjectVector<struct CProperty> const &, unsigned int, bool)
.text:00003ED0                 public ?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z
.text:00003ED0 ?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z proc near
.text:00003ED0
.text:00003ED0 var_438         = dword ptr -438h
.text:00003ED0 var_434         = dword ptr -434h
.text:00003ED0 var_430         = dword ptr -430h
.text:00003ED0 var_42C         = dword ptr -42Ch
.text:00003ED0 var_428         = dword ptr -428h
.text:00003ED0 var_424         = dword ptr -424h
.text:00003ED0 var_420         = dword ptr -420h
.text:00003ED0 var_41C         = byte ptr -41Ch
.text:00003ED0 var_410         = dword ptr -410h
.text:00003ED0 var_40C         = dword ptr -40Ch
.text:00003ED0 var_408         = dword ptr -408h
.text:00003ED0 var_404         = dword ptr -404h
.text:00003ED0 var_400         = dword ptr -400h
.text:00003ED0 var_3FC         = dword ptr -3FCh
.text:00003ED0 var_3F8         = dword ptr -3F8h
.text:00003ED0 var_3F4         = dword ptr -3F4h
.text:00003ED0 var_3F0         = dword ptr -3F0h
.text:00003ED0 var_3EC         = dword ptr -3ECh
.text:00003ED0 var_3E8         = dword ptr -3E8h
.text:00003ED0 var_3E4         = dword ptr -3E4h
.text:00003ED0 var_3E0         = dword ptr -3E0h
.text:00003ED0 var_3DC         = dword ptr -3DCh
.text:00003ED0 var_3D8         = byte ptr -3D8h
.text:00003ED0 var_3C8         = byte ptr -3C8h
.text:00003ED0 var_3A4         = dword ptr -3A4h
.text:00003ED0 var_3A0         = dword ptr -3A0h
.text:00003ED0 var_39C         = qword ptr -39Ch
.text:00003ED0 var_390         = tagPROPVARIANT ptr -390h
.text:00003ED0 var_378         = dword ptr -378h
.text:00003ED0 var_36C         = byte ptr -36Ch
.text:00003ED0 var_350         = dword ptr -350h
.text:00003ED0 var_348         = byte ptr -348h
.text:00003ED0 var_334         = dword ptr -334h
.text:00003ED0 var_330         = dword ptr -330h
.text:00003ED0 var_328         = byte ptr -328h
.text:00003ED0 var_318         = dword ptr -318h
.text:00003ED0 var_314         = dword ptr -314h
.text:00003ED0 var_30D         = byte ptr -30Dh
.text:00003ED0 var_30C         = dword ptr -30Ch
.text:00003ED0 var_304         = dword ptr -304h
.text:00003ED0 var_300         = dword ptr -300h
.text:00003ED0 var_2F4         = byte ptr -2F4h
.text:00003ED0 var_2EC         = dword ptr -2ECh
.text:00003ED0 var_2E8         = dword ptr -2E8h
.text:00003ED0 var_2E4         = dword ptr -2E4h
.text:00003ED0 var_2DC         = byte ptr -2DCh
.text:00003ED0 var_2D4         = dword ptr -2D4h
.text:00003ED0 var_2D0         = dword ptr -2D0h
.text:00003ED0 var_2CC         = dword ptr -2CCh
.text:00003ED0 var_2C8         = dword ptr -2C8h
.text:00003ED0 var_2C4         = dword ptr -2C4h
.text:00003ED0 Size            = dword ptr -2C0h
.text:00003ED0 var_2B8         = qword ptr -2B8h
.text:00003ED0 var_2A9         = byte ptr -2A9h
.text:00003ED0 var_2A8         = dword ptr -2A8h
.text:00003ED0 var_2A4         = dword ptr -2A4h
.text:00003ED0 var_29C         = dword ptr -29Ch
.text:00003ED0 var_298         = byte ptr -298h
.text:00003ED0 var_294         = dword ptr -294h
.text:00003ED0 var_290         = dword ptr -290h
.text:00003ED0 var_28C         = dword ptr -28Ch
.text:00003ED0 var_284         = dword ptr -284h
.text:00003ED0 var_264         = byte ptr -264h
.text:00003ED0 var_244         = dword ptr -244h
.text:00003ED0 var_240         = dword ptr -240h
.text:00003ED0 var_23C         = byte ptr -23Ch
.text:00003ED0 var_238         = dword ptr -238h
.text:00003ED0 var_218         = dword ptr -218h
.text:00003ED0 var_214         = dword ptr -214h
.text:00003ED0 var_20E         = byte ptr -20Eh
.text:00003ED0 var_20D         = byte ptr -20Dh
.text:00003ED0 var_20C         = dword ptr -20Ch
.text:00003ED0 var_208         = dword ptr -208h
.text:00003ED0 var_200         = dword ptr -200h
.text:00003ED0 var_1FC         = dword ptr -1FCh
.text:00003ED0 var_1F4         = dword ptr -1F4h
.text:00003ED0 var_1F0         = dword ptr -1F0h
.text:00003ED0 var_1EC         = dword ptr -1ECh
.text:00003ED0 var_1E8         = dword ptr -1E8h
.text:00003ED0 var_1E0         = byte ptr -1E0h
.text:00003ED0 var_1CC         = dword ptr -1CCh
.text:00003ED0 var_1C8         = dword ptr -1C8h
.text:00003ED0 var_1C4         = dword ptr -1C4h
.text:00003ED0 var_1C0         = dword ptr -1C0h
.text:00003ED0 var_1BC         = dword ptr -1BCh
.text:00003ED0 var_1B8         = dword ptr -1B8h
.text:00003ED0 var_1B0         = dword ptr -1B0h
.text:00003ED0 var_1A8         = dword ptr -1A8h
.text:00003ED0 var_1A4         = dword ptr -1A4h
.text:00003ED0 var_1A0         = dword ptr -1A0h
.text:00003ED0 var_19C         = dword ptr -19Ch
.text:00003ED0 var_194         = byte ptr -194h
.text:00003ED0 var_180         = byte ptr -180h
.text:00003ED0 var_170         = dword ptr -170h
.text:00003ED0 var_16C         = dword ptr -16Ch
.text:00003ED0 var_168         = dword ptr -168h
.text:00003ED0 var_164         = dword ptr -164h
.text:00003ED0 var_160         = dword ptr -160h
.text:00003ED0 var_158         = qword ptr -158h
.text:00003ED0 var_148         = byte ptr -148h
.text:00003ED0 var_138         = qword ptr -138h
.text:00003ED0 var_12C         = byte ptr -12Ch
.text:00003ED0 var_115         = byte ptr -115h
.text:00003ED0 var_110         = dword ptr -110h
.text:00003ED0 var_108         = dword ptr -108h
.text:00003ED0 var_104         = dword ptr -104h
.text:00003ED0 var_100         = dword ptr -100h
.text:00003ED0 var_FC          = dword ptr -0FCh
.text:00003ED0 var_F8          = dword ptr -0F8h
.text:00003ED0 var_F4          = dword ptr -0F4h
.text:00003ED0 var_F0          = dword ptr -0F0h
.text:00003ED0 var_EC          = dword ptr -0ECh
.text:00003ED0 var_E8          = dword ptr -0E8h
.text:00003ED0 var_E4          = dword ptr -0E4h
.text:00003ED0 var_E0          = dword ptr -0E0h
.text:00003ED0 var_D8          = dword ptr -0D8h
.text:00003ED0 var_D4          = dword ptr -0D4h
.text:00003ED0 var_C8          = byte ptr -0C8h
.text:00003ED0 var_B8          = dword ptr -0B8h
.text:00003ED0 var_B4          = dword ptr -0B4h
.text:00003ED0 var_AC          = dword ptr -0ACh
.text:00003ED0 var_9C          = dword ptr -9Ch
.text:00003ED0 var_94          = byte ptr -94h
.text:00003ED0 var_80          = tagPROPVARIANT ptr -80h
.text:00003ED0 var_6C          = dword ptr -6Ch
.text:00003ED0 var_68          = dword ptr -68h
.text:00003ED0 var_60          = dword ptr -60h
.text:00003ED0 var_54          = byte ptr -54h
.text:00003ED0 var_48          = byte ptr -48h
.text:00003ED0 var_35          = byte ptr -35h
.text:00003ED0 var_30          = dword ptr -30h
.text:00003ED0 var_24          = dword ptr -24h
.text:00003ED0 var_1C          = dword ptr -1Ch
.text:00003ED0 var_18          = dword ptr -18h
.text:00003ED0 var_14          = dword ptr -14h
.text:00003ED0 var_10          = dword ptr -10h
.text:00003ED0 var_C           = dword ptr -0Ch
.text:00003ED0 var_4           = dword ptr -4
.text:00003ED0 arg_0           = dword ptr  8
.text:00003ED0 arg_4           = dword ptr  0Ch
.text:00003ED0 arg_8           = dword ptr  10h
.text:00003ED0 arg_C           = dword ptr  14h
.text:00003ED0 arg_10          = byte ptr  18h
.text:00003ED0
.text:00003ED0                 push    ebp
.text:00003ED1                 mov     ebp, esp
.text:00003ED3                 push    0FFFFFFFFh
.text:00003ED5                 push    offset __ehhandler$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z
.text:00003EDA                 mov     eax, large fs:0
.text:00003EE0                 push    eax
.text:00003EE1                 sub     esp, 42Ch
.text:00003EE7                 push    esi
.text:00003EE8                 push    edi
.text:00003EE9                 lea     edi, [ebp+var_438]
.text:00003EEF                 mov     ecx, 10Bh
.text:00003EF4                 mov     eax, 0CCCCCCCCh
.text:00003EF9                 rep stosd
.text:00003EFB                 mov     eax, dword ptr ds:___security_cookie
.text:00003F00                 xor     eax, ebp
.text:00003F02                 mov     [ebp+var_10], eax
.text:00003F05                 push    eax             ; this
.text:00003F06                 lea     eax, [ebp+var_C]
.text:00003F09                 mov     large fs:0, eax
.text:00003F0F                 call    ?CrcInternalTest@@YG_NXZ ; CrcInternalTest(void)
.text:00003F14                 movzx   eax, al
.text:00003F17                 test    eax, eax
.text:00003F19                 jnz     short loc_3F25
.text:00003F1B                 mov     eax, 1
.text:00003F20                 jmp     loc_5D6B
.text:00003F25 ; ---------------------------------------------------------------------------
.text:00003F25
.text:00003F25 loc_3F25:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+49j
.text:00003F25                 mov     [ebp+var_14], 1
.text:00003F2C                 mov     [ebp+var_1C], 20000000h
.text:00003F33                 mov     [ebp+var_18], 0
.text:00003F3A                 call    ?GetNumberOfProcessors@NSystem@NWindows@@YGIXZ ; NWindows::NSystem::GetNumberOfProcessors(void)
.text:00003F3F                 mov     [ebp+var_14], eax
.text:00003F42                 call    ?GetRamSize@NSystem@NWindows@@YG_KXZ ; NWindows::NSystem::GetRamSize(void)
.text:00003F47                 mov     [ebp+var_1C], eax
.text:00003F4A                 mov     [ebp+var_18], edx
.text:00003F4D                 mov     ecx, [ebp+var_14]
.text:00003F50                 mov     [ebp+var_24], ecx
.text:00003F53                 mov     [ebp+var_30], 4
.text:00003F5A                 mov     [ebp+var_35], 0
.text:00003F5E                 lea     ecx, [ebp+var_60]
.text:00003F61                 call    ??0COneMethodInfo@@QAE@XZ ; COneMethodInfo::COneMethodInfo(void)
.text:00003F66                 mov     [ebp+var_4], 0
.text:00003F6D                 mov     [ebp+var_68], 0
.text:00003F74                 jmp     short loc_3F7F
.text:00003F76 ; ---------------------------------------------------------------------------
.text:00003F76
.text:00003F76 loc_3F76:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1D8j
.text:00003F76                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+25Bj ...
.text:00003F76                 mov     edx, [ebp+var_68]
.text:00003F79                 add     edx, 1
.text:00003F7C                 mov     [ebp+var_68], edx
.text:00003F7F
.text:00003F7F loc_3F7F:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+A4j
.text:00003F7F                 mov     ecx, [ebp+arg_8]
.text:00003F82                 call    ?Size@?$CObjectVector@UCProperty@@@@QBEIXZ ; CObjectVector<CProperty>::Size(void)
.text:00003F87                 cmp     [ebp+var_68], eax
.text:00003F8A                 jnb     loc_42C6
.text:00003F90                 mov     eax, [ebp+var_68]
.text:00003F93                 push    eax
.text:00003F94                 mov     ecx, [ebp+arg_8]
.text:00003F97                 call    ??A?$CObjectVector@UCProperty@@@@QBEABUCProperty@@I@Z ; CObjectVector<CProperty>::operator[](uint)
.text:00003F9C                 mov     [ebp+var_6C], eax
.text:00003F9F                 lea     ecx, [ebp+var_80] ; this
.text:00003FA2                 call    ??0CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::CPropVariant(void)
.text:00003FA7                 mov     byte ptr [ebp+var_4], 1
.text:00003FAB                 mov     ecx, [ebp+var_6C]
.text:00003FAE                 push    ecx
.text:00003FAF                 lea     ecx, [ebp+var_94]
.text:00003FB5                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00003FBA                 mov     byte ptr [ebp+var_4], 2
.text:00003FBE                 lea     ecx, [ebp+var_94] ; this
.text:00003FC4                 call    ?MakeLower_Ascii@UString@@QAEXXZ ; UString::MakeLower_Ascii(void)
.text:00003FC9                 mov     ecx, [ebp+var_6C]
.text:00003FCC                 add     ecx, 0Ch        ; this
.text:00003FCF                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:00003FD4                 movzx   edx, al
.text:00003FD7                 test    edx, edx
.text:00003FD9                 jnz     short loc_3FEB
.text:00003FDB                 lea     eax, [ebp+var_80]
.text:00003FDE                 push    eax             ; int
.text:00003FDF                 mov     ecx, [ebp+var_6C]
.text:00003FE2                 add     ecx, 0Ch
.text:00003FE5                 push    ecx             ; UString *
.text:00003FE6                 call    ?ParseNumberString@@YGXABVUString@@AAVCPropVariant@NCOM@NWindows@@@Z ; ParseNumberString(UString const &,NWindows::NCOM::CPropVariant &)
.text:00003FEB
.text:00003FEB loc_3FEB:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+109j
.text:00003FEB                 push    offset $SG71508 ; "testtime"
.text:00003FF0                 lea     ecx, [ebp+var_94] ; this
.text:00003FF6                 call    ?IsEqualTo@UString@@QBE_NPBD@Z ; UString::IsEqualTo(char const *)
.text:00003FFB                 movzx   edx, al
.text:00003FFE                 test    edx, edx
.text:00004000                 jz      loc_40AD
.text:00004006                 push    offset $SG71511
.text:0000400B                 lea     ecx, [ebp+var_3D8]
.text:00004011                 call    ??0UString@@QAE@PB_W@Z ; UString::UString(wchar_t const *)
.text:00004016                 mov     byte ptr [ebp+var_4], 3
.text:0000401A                 lea     eax, [ebp+var_30]
.text:0000401D                 push    eax             ; unsigned int *
.text:0000401E                 lea     ecx, [ebp+var_80]
.text:00004021                 push    ecx             ; struct tagPROPVARIANT *
.text:00004022                 lea     edx, [ebp+var_3D8]
.text:00004028                 push    edx             ; struct UString *
.text:00004029                 call    ?ParsePropToUInt32@@YGJABVUString@@ABUtagPROPVARIANT@@AAI@Z ; ParsePropToUInt32(UString const &,tagPROPVARIANT const &,uint &)
.text:0000402E                 mov     [ebp+var_9C], eax
.text:00004034                 mov     byte ptr [ebp+var_4], 2
.text:00004038                 lea     ecx, [ebp+var_3D8] ; this
.text:0000403E                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00004043                 cmp     [ebp+var_9C], 0
.text:0000404A                 jz      short loc_408D
.text:0000404C                 mov     eax, [ebp+var_9C]
.text:00004052                 mov     [ebp+var_3DC], eax
.text:00004058                 mov     byte ptr [ebp+var_4], 1
.text:0000405C                 lea     ecx, [ebp+var_94] ; this
.text:00004062                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00004067                 mov     byte ptr [ebp+var_4], 0
.text:0000406B                 lea     ecx, [ebp+var_80] ; this
.text:0000406E                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:00004073                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000407A                 lea     ecx, [ebp+var_60] ; this
.text:0000407D                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:00004082                 mov     eax, [ebp+var_3DC]
.text:00004088                 jmp     loc_5D6B
.text:0000408D ; ---------------------------------------------------------------------------
.text:0000408D
.text:0000408D loc_408D:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+17Aj
.text:0000408D                 mov     byte ptr [ebp+var_4], 1
.text:00004091                 lea     ecx, [ebp+var_94] ; this
.text:00004097                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000409C                 mov     byte ptr [ebp+var_4], 0
.text:000040A0                 lea     ecx, [ebp+var_80] ; this
.text:000040A3                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:000040A8                 jmp     loc_3F76
.text:000040AD ; ---------------------------------------------------------------------------
.text:000040AD
.text:000040AD loc_40AD:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+130j
.text:000040AD                 push    offset $SG71515 ; char *
.text:000040B2                 lea     ecx, [ebp+var_94] ; this
.text:000040B8                 call    ?IsPrefixedBy_Ascii_NoCase@UString@@QBE_NPBD@Z ; UString::IsPrefixedBy_Ascii_NoCase(char const *)
.text:000040BD                 movzx   ecx, al
.text:000040C0                 test    ecx, ecx
.text:000040C2                 jz      loc_4243
.text:000040C8                 push    2               ; unsigned int
.text:000040CA                 lea     ecx, [ebp+var_94] ; this
.text:000040D0                 call    ?Ptr@UString@@QBEPB_WI@Z ; UString::Ptr(uint)
.text:000040D5                 push    eax
.text:000040D6                 lea     ecx, [ebp+var_AC]
.text:000040DC                 call    ??0UString@@QAE@PB_W@Z ; UString::UString(wchar_t const *)
.text:000040E1                 mov     byte ptr [ebp+var_4], 4
.text:000040E5                 push    offset $SG71518 ; Str2
.text:000040EA                 lea     edx, [ebp+var_AC]
.text:000040F0                 push    edx             ; int
.text:000040F1                 call    ??8@YG_NABVUString@@PB_W@Z ; operator==(UString const &,wchar_t const *)
.text:000040F6                 movzx   eax, al
.text:000040F9                 test    eax, eax
.text:000040FB                 jz      short loc_4130
.text:000040FD                 mov     [ebp+var_35], 1
.text:00004101                 mov     byte ptr [ebp+var_4], 2
.text:00004105                 lea     ecx, [ebp+var_AC] ; this
.text:0000410B                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00004110                 mov     byte ptr [ebp+var_4], 1
.text:00004114                 lea     ecx, [ebp+var_94] ; this
.text:0000411A                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000411F                 mov     byte ptr [ebp+var_4], 0
.text:00004123                 lea     ecx, [ebp+var_80] ; this
.text:00004126                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:0000412B                 jmp     loc_3F76
.text:00004130 ; ---------------------------------------------------------------------------
.text:00004130
.text:00004130 loc_4130:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+22Bj
.text:00004130                 lea     ecx, [ebp+var_AC] ; this
.text:00004136                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:0000413B                 movzx   ecx, al
.text:0000413E                 test    ecx, ecx
.text:00004140                 jz      short loc_419D
.text:00004142                 movzx   edx, word ptr [ebp+var_80.anonymous_0]
.text:00004146                 cmp     edx, 8
.text:00004149                 jnz     short loc_419D
.text:0000414B                 mov     esi, esp
.text:0000414D                 push    offset $SG71521 ; Str2
.text:00004152                 mov     eax, dword ptr [ebp+var_80.anonymous_0+8]
.text:00004155                 push    eax             ; Str1
.text:00004156                 call    dword ptr ds:__imp__wcscmp
.text:0000415C                 add     esp, 8
.text:0000415F                 cmp     esi, esp
.text:00004161                 call    __RTC_CheckEsp
.text:00004166                 test    eax, eax
.text:00004168                 jnz     short loc_419D
.text:0000416A                 mov     [ebp+var_35], 1
.text:0000416E                 mov     byte ptr [ebp+var_4], 2
.text:00004172                 lea     ecx, [ebp+var_AC] ; this
.text:00004178                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000417D                 mov     byte ptr [ebp+var_4], 1
.text:00004181                 lea     ecx, [ebp+var_94] ; this
.text:00004187                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000418C                 mov     byte ptr [ebp+var_4], 0
.text:00004190                 lea     ecx, [ebp+var_80] ; this
.text:00004193                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:00004198                 jmp     loc_3F76
.text:0000419D ; ---------------------------------------------------------------------------
.text:0000419D
.text:0000419D loc_419D:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+270j
.text:0000419D                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+279j ...
.text:0000419D                 lea     ecx, [ebp+var_24]
.text:000041A0                 push    ecx             ; unsigned int *
.text:000041A1                 mov     edx, [ebp+var_14]
.text:000041A4                 push    edx             ; unsigned int
.text:000041A5                 lea     eax, [ebp+var_80]
.text:000041A8                 push    eax             ; struct tagPROPVARIANT *
.text:000041A9                 lea     ecx, [ebp+var_AC]
.text:000041AF                 push    ecx             ; struct UString *
.text:000041B0                 call    ?ParseMtProp@@YGJABVUString@@ABUtagPROPVARIANT@@IAAI@Z ; ParseMtProp(UString const &,tagPROPVARIANT const &,uint,uint &)
.text:000041B5                 mov     [ebp+var_B4], eax
.text:000041BB                 cmp     [ebp+var_B4], 0
.text:000041C2                 jz      short loc_4214
.text:000041C4                 mov     edx, [ebp+var_B4]
.text:000041CA                 mov     [ebp+var_3E0], edx
.text:000041D0                 mov     byte ptr [ebp+var_4], 2
.text:000041D4                 lea     ecx, [ebp+var_AC] ; this
.text:000041DA                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000041DF                 mov     byte ptr [ebp+var_4], 1
.text:000041E3                 lea     ecx, [ebp+var_94] ; this
.text:000041E9                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000041EE                 mov     byte ptr [ebp+var_4], 0
.text:000041F2                 lea     ecx, [ebp+var_80] ; this
.text:000041F5                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:000041FA                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00004201                 lea     ecx, [ebp+var_60] ; this
.text:00004204                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:00004209                 mov     eax, [ebp+var_3E0]
.text:0000420F                 jmp     loc_5D6B
.text:00004214 ; ---------------------------------------------------------------------------
.text:00004214
.text:00004214 loc_4214:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+2F2j
.text:00004214                 mov     byte ptr [ebp+var_4], 2
.text:00004218                 lea     ecx, [ebp+var_AC] ; this
.text:0000421E                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00004223                 mov     byte ptr [ebp+var_4], 1
.text:00004227                 lea     ecx, [ebp+var_94] ; this
.text:0000422D                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00004232                 mov     byte ptr [ebp+var_4], 0
.text:00004236                 lea     ecx, [ebp+var_80] ; this
.text:00004239                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:0000423E                 jmp     loc_3F76
.text:00004243 ; ---------------------------------------------------------------------------
.text:00004243
.text:00004243 loc_4243:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1F2j
.text:00004243                 lea     eax, [ebp+var_80]
.text:00004246                 push    eax             ; struct tagPROPVARIANT *
.text:00004247                 lea     ecx, [ebp+var_94]
.text:0000424D                 push    ecx             ; struct UString *
.text:0000424E                 lea     ecx, [ebp+var_60] ; this
.text:00004251                 call    ?ParseMethodFromPROPVARIANT@COneMethodInfo@@QAEJABVUString@@ABUtagPROPVARIANT@@@Z ; COneMethodInfo::ParseMethodFromPROPVARIANT(UString const &,tagPROPVARIANT const &)
.text:00004256                 mov     [ebp+var_B8], eax
.text:0000425C                 cmp     [ebp+var_B8], 0
.text:00004263                 jz      short loc_42A6
.text:00004265                 mov     edx, [ebp+var_B8]
.text:0000426B                 mov     [ebp+var_3E4], edx
.text:00004271                 mov     byte ptr [ebp+var_4], 1
.text:00004275                 lea     ecx, [ebp+var_94] ; this
.text:0000427B                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00004280                 mov     byte ptr [ebp+var_4], 0
.text:00004284                 lea     ecx, [ebp+var_80] ; this
.text:00004287                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:0000428C                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00004293                 lea     ecx, [ebp+var_60] ; this
.text:00004296                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:0000429B                 mov     eax, [ebp+var_3E4]
.text:000042A1                 jmp     loc_5D6B
.text:000042A6 ; ---------------------------------------------------------------------------
.text:000042A6
.text:000042A6 loc_42A6:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+393j
.text:000042A6                 mov     byte ptr [ebp+var_4], 1
.text:000042AA                 lea     ecx, [ebp+var_94] ; this
.text:000042B0                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000042B5                 mov     byte ptr [ebp+var_4], 0
.text:000042B9                 lea     ecx, [ebp+var_80] ; this
.text:000042BC                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:000042C1                 jmp     loc_3F76
.text:000042C6 ; ---------------------------------------------------------------------------
.text:000042C6
.text:000042C6 loc_42C6:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+BAj
.text:000042C6                 cmp     [ebp+arg_0], 0
.text:000042CA                 jz      short loc_432D
.text:000042CC                 lea     ecx, [ebp+var_C8]
.text:000042D2                 call    ??0AString@@QAE@XZ ; AString::AString(void)
.text:000042D7                 mov     byte ptr [ebp+var_4], 5
.text:000042DB                 lea     eax, [ebp+var_C8]
.text:000042E1                 push    eax             ; struct AString *
.text:000042E2                 call    ?GetCpuName@@YGXAAVAString@@@Z ; GetCpuName(AString &)
.text:000042E7                 lea     ecx, [ebp+var_C8]
.text:000042ED                 call    ??BAString@@QBEPBDXZ ; AString::operator char const *(void)
.text:000042F2                 mov     esi, esp
.text:000042F4                 push    eax
.text:000042F5                 mov     ecx, [ebp+arg_0]
.text:000042F8                 mov     edx, [ecx]
.text:000042FA                 mov     ecx, [ebp+arg_0]
.text:000042FD                 mov     eax, [edx]
.text:000042FF                 call    eax
.text:00004301                 cmp     esi, esp
.text:00004303                 call    __RTC_CheckEsp
.text:00004308                 mov     ecx, [ebp+arg_0]
.text:0000430B                 mov     edx, [ecx]
.text:0000430D                 mov     esi, esp
.text:0000430F                 mov     ecx, [ebp+arg_0]
.text:00004312                 mov     eax, [edx+4]
.text:00004315                 call    eax
.text:00004317                 cmp     esi, esp
.text:00004319                 call    __RTC_CheckEsp
.text:0000431E                 mov     byte ptr [ebp+var_4], 0
.text:00004322                 lea     ecx, [ebp+var_C8] ; this
.text:00004328                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:0000432D
.text:0000432D loc_432D:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+3FAj
.text:0000432D                 cmp     [ebp+arg_0], 0
.text:00004331                 jz      short loc_434D
.text:00004333                 mov     esi, esp
.text:00004335                 push    offset $SG71531 ; "CPU Freq:"
.text:0000433A                 mov     ecx, [ebp+arg_0]
.text:0000433D                 mov     edx, [ecx]
.text:0000433F                 mov     ecx, [ebp+arg_0]
.text:00004342                 mov     eax, [edx]
.text:00004344                 call    eax
.text:00004346                 cmp     esi, esp
.text:00004348                 call    __RTC_CheckEsp
.text:0000434D
.text:0000434D loc_434D:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+461j
.text:0000434D                 mov     [ebp+var_D8], 0
.text:00004357                 mov     [ebp+var_D4], 4
.text:00004361                 cmp     [ebp+arg_0], 0
.text:00004365                 jz      loc_458E
.text:0000436B                 mov     [ebp+var_E4], 40h ; '@'
.text:00004375                 mov     [ebp+var_E0], 0
.text:0000437F                 mov     [ebp+var_E8], 0
.text:00004389                 jmp     short loc_439A
.text:0000438B ; ---------------------------------------------------------------------------
.text:0000438B
.text:0000438B loc_438B:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool):loc_4589j
.text:0000438B                 mov     ecx, [ebp+var_E8]
.text:00004391                 add     ecx, 1
.text:00004394                 mov     [ebp+var_E8], ecx
.text:0000439A
.text:0000439A loc_439A:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+4B9j
.text:0000439A                 cmp     [ebp+arg_0], 0
.text:0000439E                 jz      short loc_43EB
.text:000043A0                 mov     edx, [ebp+arg_0]
.text:000043A3                 mov     eax, [edx]
.text:000043A5                 mov     esi, esp
.text:000043A7                 mov     ecx, [ebp+arg_0]
.text:000043AA                 mov     edx, [eax+8]
.text:000043AD                 call    edx
.text:000043AF                 cmp     esi, esp
.text:000043B1                 call    __RTC_CheckEsp
.text:000043B6                 mov     [ebp+var_EC], eax
.text:000043BC                 cmp     [ebp+var_EC], 0
.text:000043C3                 jz      short loc_43EB
.text:000043C5                 mov     eax, [ebp+var_EC]
.text:000043CB                 mov     [ebp+var_3E8], eax
.text:000043D1                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000043D8                 lea     ecx, [ebp+var_60] ; this
.text:000043DB                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:000043E0                 mov     eax, [ebp+var_3E8]
.text:000043E6                 jmp     loc_5D6B
.text:000043EB ; ---------------------------------------------------------------------------
.text:000043EB
.text:000043EB loc_43EB:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+4CEj
.text:000043EB                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+4F3j
.text:000043EB                 call    ?GetTimeCount@@YG_KXZ ; GetTimeCount(void)
.text:000043F0                 mov     [ebp+var_F4], eax
.text:000043F6                 mov     [ebp+var_F0], edx
.text:000043FC                 mov     ecx, [ebp+var_F4]
.text:00004402                 mov     [ebp+var_F8], ecx
.text:00004408                 mov     edx, ds:?g_BenchCpuFreqTemp@@3IA ; uint g_BenchCpuFreqTemp
.text:0000440E                 push    edx
.text:0000440F                 push    0
.text:00004411                 push    0F4240h
.text:00004416                 mov     eax, [ebp+var_E0]
.text:0000441C                 push    eax
.text:0000441D                 mov     ecx, [ebp+var_E4]
.text:00004423                 push    ecx
.text:00004424                 call    __allmul
.text:00004429                 push    0
.text:0000442B                 push    80h ; 'Ç'
.text:00004430                 push    edx
.text:00004431                 push    eax
.text:00004432                 call    __aulldiv
.text:00004437                 push    eax
.text:00004438                 mov     edx, [ebp+var_F8]
.text:0000443E                 push    edx
.text:0000443F                 call    _CountCpuFreq@12 ; CountCpuFreq(x,x,x)
.text:00004444                 mov     [ebp+var_F8], eax
.text:0000444A                 call    ?GetTimeCount@@YG_KXZ ; GetTimeCount(void)
.text:0000444F                 sub     eax, [ebp+var_F4]
.text:00004455                 sbb     edx, [ebp+var_F0]
.text:0000445B                 mov     [ebp+var_F4], eax
.text:00004461                 mov     [ebp+var_F0], edx
.text:00004467                 mov     eax, [ebp+var_F4]
.text:0000446D                 or      eax, [ebp+var_F0]
.text:00004473                 jnz     short loc_4489
.text:00004475                 mov     [ebp+var_F4], 1
.text:0000447F                 mov     [ebp+var_F0], 0
.text:00004489
.text:00004489 loc_4489:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+5A3j
.text:00004489                 call    ?GetFreq@@YG_KXZ ; GetFreq(void)
.text:0000448E                 mov     [ebp+var_100], eax
.text:00004494                 mov     [ebp+var_FC], edx
.text:0000449A                 mov     ecx, [ebp+var_FC]
.text:000044A0                 push    ecx
.text:000044A1                 mov     edx, [ebp+var_100]
.text:000044A7                 push    edx
.text:000044A8                 mov     eax, [ebp+var_E0]
.text:000044AE                 push    eax
.text:000044AF                 mov     ecx, [ebp+var_E4]
.text:000044B5                 push    ecx
.text:000044B6                 call    __allmul
.text:000044BB                 mov     ecx, [ebp+var_F0]
.text:000044C1                 push    ecx
.text:000044C2                 mov     ecx, [ebp+var_F4]
.text:000044C8                 push    ecx
.text:000044C9                 push    edx
.text:000044CA                 push    eax
.text:000044CB                 call    __aulldiv
.text:000044D0                 mov     [ebp+var_108], eax
.text:000044D6                 mov     [ebp+var_104], edx
.text:000044DC                 cmp     [ebp+arg_0], 0
.text:000044E0                 jz      short loc_450C
.text:000044E2                 xor     edx, edx
.text:000044E4                 cmp     [ebp+var_F8], 0F1541213h
.text:000044EE                 setz    dl
.text:000044F1                 add     edx, 5
.text:000044F4                 push    edx
.text:000044F5                 mov     eax, [ebp+var_104]
.text:000044FB                 push    eax
.text:000044FC                 mov     ecx, [ebp+var_108]
.text:00004502                 push    ecx
.text:00004503                 mov     edx, [ebp+arg_0]
.text:00004506                 push    edx
.text:00004507                 call    ?PrintNumber@@YGXAAUIBenchPrintCallback@@_KH@Z ; PrintNumber(IBenchPrintCallback &,unsigned __int64,int)
.text:0000450C
.text:0000450C loc_450C:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+610j
.text:0000450C                 cmp     [ebp+var_E8], 3
.text:00004513                 jl      short loc_4589
.text:00004515                 lea     eax, [ebp+var_D8]
.text:0000451B                 push    eax
.text:0000451C                 push    0
.text:0000451E                 push    0F4240h
.text:00004523                 mov     ecx, [ebp+var_104]
.text:00004529                 push    ecx
.text:0000452A                 mov     edx, [ebp+var_108]
.text:00004530                 push    edx
.text:00004531                 call    __allmul
.text:00004536                 push    edx
.text:00004537                 push    eax
.text:00004538                 mov     eax, [ebp+var_30]
.text:0000453B                 push    eax
.text:0000453C                 call    ?SetComplexCommands@@YGXI_KAA_K@Z ; SetComplexCommands(uint,unsigned __int64,unsigned __int64 &)
.text:00004541                 cmp     [ebp+var_E8], 8
.text:00004548                 jge     short loc_4568
.text:0000454A                 mov     ecx, [ebp+var_F0]
.text:00004550                 cmp     ecx, [ebp+var_FC]
.text:00004556                 jb      short loc_456A
.text:00004558                 ja      short loc_4568
.text:0000455A                 mov     edx, [ebp+var_F4]
.text:00004560                 cmp     edx, [ebp+var_100]
.text:00004566                 jb      short loc_456A
.text:00004568
.text:00004568 loc_4568:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+678j
.text:00004568                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+688j
.text:00004568                 jmp     short loc_458E
.text:0000456A ; ---------------------------------------------------------------------------
.text:0000456A
.text:0000456A loc_456A:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+686j
.text:0000456A                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+696j
.text:0000456A                 mov     eax, [ebp+var_E4]
.text:00004570                 mov     edx, [ebp+var_E0]
.text:00004576                 mov     cl, 1
.text:00004578                 call    __allshl
.text:0000457D                 mov     [ebp+var_E4], eax
.text:00004583                 mov     [ebp+var_E0], edx
.text:00004589
.text:00004589 loc_4589:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+643j
.text:00004589                 jmp     loc_438B
.text:0000458E ; ---------------------------------------------------------------------------
.text:0000458E
.text:0000458E loc_458E:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+495j
.text:0000458E                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool):loc_4568j
.text:0000458E                 cmp     [ebp+arg_0], 0
.text:00004592                 jz      short loc_45DF
.text:00004594                 mov     eax, [ebp+arg_0]
.text:00004597                 mov     edx, [eax]
.text:00004599                 mov     esi, esp
.text:0000459B                 mov     ecx, [ebp+arg_0]
.text:0000459E                 mov     eax, [edx+4]
.text:000045A1                 call    eax
.text:000045A3                 cmp     esi, esp
.text:000045A5                 call    __RTC_CheckEsp
.text:000045AA                 mov     ecx, [ebp+arg_0]
.text:000045AD                 mov     edx, [ecx]
.text:000045AF                 mov     esi, esp
.text:000045B1                 mov     ecx, [ebp+arg_0]
.text:000045B4                 mov     eax, [edx+4]
.text:000045B7                 call    eax
.text:000045B9                 cmp     esi, esp
.text:000045BB                 call    __RTC_CheckEsp
.text:000045C0                 mov     ecx, [ebp+var_14]
.text:000045C3                 push    ecx
.text:000045C4                 push    offset $SG71555 ; "CPU hardware threads:"
.text:000045C9                 mov     edx, [ebp+var_18]
.text:000045CC                 push    edx
.text:000045CD                 mov     eax, [ebp+var_1C]
.text:000045D0                 push    eax
.text:000045D1                 push    offset $SG71556 ; "size: "
.text:000045D6                 mov     ecx, [ebp+arg_0]
.text:000045D9                 push    ecx
.text:000045DA                 call    ?PrintRequirements@@YGXAAUIBenchPrintCallback@@PBD_K1I@Z ; PrintRequirements(IBenchPrintCallback &,char const *,unsigned __int64,char const *,uint)
.text:000045DF
.text:000045DF loc_45DF:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+6C2j
.text:000045DF                 cmp     [ebp+var_24], 1
.text:000045E3                 jb      short loc_45EE
.text:000045E5                 cmp     [ebp+var_24], 1000h
.text:000045EC                 jbe     short loc_4612
.text:000045EE
.text:000045EE loc_45EE:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+713j
.text:000045EE                 mov     [ebp+var_3EC], 80070057h
.text:000045F8                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000045FF                 lea     ecx, [ebp+var_60] ; this
.text:00004602                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:00004607                 mov     eax, [ebp+var_3EC]
.text:0000460D                 jmp     loc_5D6B
.text:00004612 ; ---------------------------------------------------------------------------
.text:00004612
.text:00004612 loc_4612:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+71Cj
.text:00004612                 lea     edx, [ebp+var_110]
.text:00004618                 push    edx             ; unsigned int *
.text:00004619                 lea     ecx, [ebp+var_60] ; this
.text:0000461C                 call    ?Get_DicSize@CMethodProps@@QBE_NAAI@Z ; CMethodProps::Get_DicSize(uint &)
.text:00004621                 mov     [ebp+var_115], al
.text:00004627                 lea     ecx, [ebp+var_54] ; this
.text:0000462A                 call    ?IsEmpty@AString@@QBE_NXZ ; AString::IsEmpty(void)
.text:0000462F                 movzx   eax, al
.text:00004632                 test    eax, eax
.text:00004634                 jz      short loc_4643
.text:00004636                 push    offset $SG71564 ; "LZMA"
.text:0000463B                 lea     ecx, [ebp+var_54]
.text:0000463E                 call    ??4AString@@QAEAAV0@PBD@Z ; AString::operator=(char const *)
.text:00004643
.text:00004643 loc_4643:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+764j
.text:00004643                 cmp     [ebp+arg_4], 0
.text:00004647                 jz      loc_46D8
.text:0000464D                 lea     ecx, [ebp+var_12C]
.text:00004653                 call    ??0CBenchProps@@QAE@XZ ; CBenchProps::CBenchProps(void)
.text:00004658                 lea     ecx, [ebp+var_12C] ; this
.text:0000465E                 call    ?SetLzmaCompexity@CBenchProps@@QAEXXZ ; CBenchProps::SetLzmaCompexity(void)
.text:00004663                 lea     ecx, [ebp+var_60] ; this
.text:00004666                 call    ?Get_Lzma_DicSize@CMethodProps@@QBEIXZ ; CMethodProps::Get_Lzma_DicSize(void)
.text:0000466B                 mov     dword ptr [ebp+var_138+4], eax
.text:00004671                 mov     ecx, dword ptr [ebp+var_138+4]
.text:00004677                 add     ecx, 10000h
.text:0000467D                 mov     dword ptr [ebp+var_138], ecx
.text:00004683                 lea     edx, [ebp+var_12C]
.text:00004689                 push    edx             ; CBenchProps *
.text:0000468A                 mov     eax, [ebp+arg_4]
.text:0000468D                 push    eax             ; int
.text:0000468E                 mov     ecx, [ebp+arg_0]
.text:00004691                 push    ecx             ; int
.text:00004692                 push    1Eh
.text:00004694                 mov     edx, dword ptr [ebp+var_138]
.text:0000469A                 push    edx             ; unsigned __int64
.text:0000469B                 lea     eax, [ebp+var_60]
.text:0000469E                 push    eax             ; int
.text:0000469F                 mov     ecx, [ebp+var_24]
.text:000046A2                 push    ecx             ; int
.text:000046A3                 push    1               ; char
.text:000046A5                 mov     edx, [ebp+var_D4]
.text:000046AB                 push    edx             ; int
.text:000046AC                 mov     eax, [ebp+var_D8]
.text:000046B2                 push    eax             ; int
.text:000046B3                 call    ?MethodBench@@YGJ_K_NIABVCOneMethodInfo@@IIPAUIBenchPrintCallback@@PAUIBenchCallback@@PAUCBenchProps@@@Z ; MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)
.text:000046B8                 mov     [ebp+var_3F0], eax
.text:000046BE                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000046C5                 lea     ecx, [ebp+var_60] ; this
.text:000046C8                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:000046CD                 mov     eax, [ebp+var_3F0]
.text:000046D3                 jmp     loc_5D6B
.text:000046D8 ; ---------------------------------------------------------------------------
.text:000046D8
.text:000046D8 loc_46D8:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+777j
.text:000046D8                 lea     ecx, [ebp+var_54]
.text:000046DB                 push    ecx
.text:000046DC                 lea     ecx, [ebp+var_148]
.text:000046E2                 call    ??0AString@@QAE@ABV0@@Z ; AString::AString(AString const &)
.text:000046E7                 mov     byte ptr [ebp+var_4], 6
.text:000046EB                 push    offset $SG71572 ; "CRC"
.text:000046F0                 lea     ecx, [ebp+var_148] ; this
.text:000046F6                 call    ?IsEqualTo_Ascii_NoCase@AString@@QBE_NPBD@Z ; AString::IsEqualTo_Ascii_NoCase(char const *)
.text:000046FB                 movzx   edx, al
.text:000046FE                 test    edx, edx
.text:00004700                 jz      short loc_4712
.text:00004702                 push    offset $SG71573 ; "crc32"
.text:00004707                 lea     ecx, [ebp+var_148]
.text:0000470D                 call    ??4AString@@QAEAAV0@PBD@Z ; AString::operator=(char const *)
.text:00004712
.text:00004712 loc_4712:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+830j
.text:00004712                 lea     eax, [ebp+var_148]
.text:00004718                 push    eax
.text:00004719                 lea     ecx, [ebp+var_54]
.text:0000471C                 call    ??4AString@@QAEAAV0@ABV0@@Z ; AString::operator=(AString const &)
.text:00004721                 lea     ecx, [ebp+var_158]
.text:00004727                 push    ecx             ; unsigned __int64 *
.text:00004728                 lea     edx, [ebp+var_148]
.text:0000472E                 push    edx             ; struct AString *
.text:0000472F                 call    ?FindHashMethod@@YG_NABVAString@@AA_K@Z ; FindHashMethod(AString const &,unsigned __int64 &)
.text:00004734                 movzx   eax, al
.text:00004737                 test    eax, eax
.text:00004739                 jz      loc_4E7D
.text:0000473F                 cmp     [ebp+arg_0], 0
.text:00004743                 jnz     short loc_4778
.text:00004745                 mov     [ebp+var_3F4], 1
.text:0000474F                 mov     byte ptr [ebp+var_4], 0
.text:00004753                 lea     ecx, [ebp+var_148] ; this
.text:00004759                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:0000475E                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00004765                 lea     ecx, [ebp+var_60] ; this
.text:00004768                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:0000476D                 mov     eax, [ebp+var_3F4]
.text:00004773                 jmp     loc_5D6B
.text:00004778 ; ---------------------------------------------------------------------------
.text:00004778
.text:00004778 loc_4778:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+873j
.text:00004778                 mov     ecx, [ebp+arg_0]
.text:0000477B                 mov     [ebp+var_160], ecx
.text:00004781                 movzx   edx, [ebp+var_115]
.text:00004788                 test    edx, edx
.text:0000478A                 jnz     short loc_4796
.text:0000478C                 mov     [ebp+var_110], 1000000h
.text:00004796
.text:00004796 loc_4796:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+8BAj
.text:00004796                 mov     [ebp+var_164], 2710h
.text:000047A0                 mov     [ebp+var_168], 0
.text:000047AA                 mov     [ebp+var_16C], 0
.text:000047B4                 jmp     short loc_47C5
.text:000047B6 ; ---------------------------------------------------------------------------
.text:000047B6
.text:000047B6 loc_47B6:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+A29j
.text:000047B6                 mov     eax, [ebp+var_16C]
.text:000047BC                 add     eax, 1
.text:000047BF                 mov     [ebp+var_16C], eax
.text:000047C5
.text:000047C5 loc_47C5:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+8E4j
.text:000047C5                 cmp     [ebp+var_16C], 6
.text:000047CC                 jnb     loc_48FE
.text:000047D2                 mov     ecx, [ebp+var_16C]
.text:000047D8                 shl     ecx, 4
.text:000047DB                 add     ecx, offset _g_Hash
.text:000047E1                 mov     [ebp+var_170], ecx
.text:000047E7                 mov     edx, [ebp+var_170]
.text:000047ED                 mov     eax, [edx+0Ch]
.text:000047F0                 push    eax
.text:000047F1                 lea     ecx, [ebp+var_180]
.text:000047F7                 call    ??0AString@@QAE@PBD@Z ; AString::AString(char const *)
.text:000047FC                 mov     byte ptr [ebp+var_4], 7
.text:00004800                 lea     ecx, [ebp+var_194]
.text:00004806                 call    ??0AString@@QAE@XZ ; AString::AString(void)
.text:0000480B                 mov     byte ptr [ebp+var_4], 8
.text:0000480F                 push    3Ah ; ':'       ; char
.text:00004811                 lea     ecx, [ebp+var_180] ; this
.text:00004817                 call    ?Find@AString@@QBEHD@Z ; AString::Find(char)
.text:0000481C                 mov     [ebp+var_19C], eax
.text:00004822                 cmp     [ebp+var_19C], 0
.text:00004829                 jl      short loc_485E
.text:0000482B                 mov     ecx, [ebp+var_19C]
.text:00004831                 add     ecx, 1
.text:00004834                 push    ecx             ; unsigned int
.text:00004835                 lea     ecx, [ebp+var_180] ; this
.text:0000483B                 call    ?Ptr@AString@@QBEPBDI@Z ; AString::Ptr(uint)
.text:00004840                 push    eax
.text:00004841                 lea     ecx, [ebp+var_194]
.text:00004847                 call    ??4AString@@QAEAAV0@PBD@Z ; AString::operator=(char const *)
.text:0000484C                 mov     edx, [ebp+var_19C]
.text:00004852                 push    edx             ; unsigned int
.text:00004853                 lea     ecx, [ebp+var_180] ; this
.text:00004859                 call    ?DeleteFrom@AString@@QAEXI@Z ; AString::DeleteFrom(uint)
.text:0000485E
.text:0000485E loc_485E:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+959j
.text:0000485E                 lea     ecx, [ebp+var_148]
.text:00004864                 call    ??BAString@@QBEPBDXZ ; AString::operator char const *(void)
.text:00004869                 push    eax
.text:0000486A                 lea     ecx, [ebp+var_180]
.text:00004870                 call    ??BAString@@QBEPBDXZ ; AString::operator char const *(void)
.text:00004875                 push    eax
.text:00004876                 call    ?AreSameMethodNames@@YG_NPBD0@Z ; AreSameMethodNames(char const *,char const *)
.text:0000487B                 movzx   eax, al
.text:0000487E                 test    eax, eax
.text:00004880                 jz      short loc_48DB
.text:00004882                 mov     ecx, [ebp+var_170]
.text:00004888                 mov     edx, [ecx+4]
.text:0000488B                 mov     [ebp+var_164], edx
.text:00004891                 mov     eax, [ebp+var_170]
.text:00004897                 add     eax, 8
.text:0000489A                 mov     [ebp+var_168], eax
.text:000048A0                 lea     ecx, [ebp+var_194]
.text:000048A6                 call    ??BAString@@QBEPBDXZ ; AString::operator char const *(void)
.text:000048AB                 push    eax             ; char *
.text:000048AC                 lea     ecx, [ebp+var_48] ; this
.text:000048AF                 call    ?IsEqualTo_Ascii_NoCase@UString@@QBE_NPBD@Z ; UString::IsEqualTo_Ascii_NoCase(char const *)
.text:000048B4                 movzx   ecx, al
.text:000048B7                 test    ecx, ecx
.text:000048B9                 jz      short loc_48DB
.text:000048BB                 mov     byte ptr [ebp+var_4], 7
.text:000048BF                 lea     ecx, [ebp+var_194] ; this
.text:000048C5                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:000048CA                 mov     byte ptr [ebp+var_4], 6
.text:000048CE                 lea     ecx, [ebp+var_180] ; this
.text:000048D4                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:000048D9                 jmp     short loc_48FE
.text:000048DB ; ---------------------------------------------------------------------------
.text:000048DB
.text:000048DB loc_48DB:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+9B0j
.text:000048DB                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+9E9j
.text:000048DB                 mov     byte ptr [ebp+var_4], 7
.text:000048DF                 lea     ecx, [ebp+var_194] ; this
.text:000048E5                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:000048EA                 mov     byte ptr [ebp+var_4], 6
.text:000048EE                 lea     ecx, [ebp+var_180] ; this
.text:000048F4                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:000048F9                 jmp     loc_47B6
.text:000048FE ; ---------------------------------------------------------------------------
.text:000048FE
.text:000048FE loc_48FE:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+8FCj
.text:000048FE                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+A09j
.text:000048FE                 mov     edx, [ebp+var_160]
.text:00004904                 mov     eax, [edx]
.text:00004906                 mov     esi, esp
.text:00004908                 mov     ecx, [ebp+var_160]
.text:0000490E                 mov     edx, [eax+4]
.text:00004911                 call    edx
.text:00004913                 cmp     esi, esp
.text:00004915                 call    __RTC_CheckEsp
.text:0000491A                 mov     esi, esp
.text:0000491C                 push    offset $SG71594 ; "Size"
.text:00004921                 mov     eax, [ebp+var_160]
.text:00004927                 mov     edx, [eax]
.text:00004929                 mov     ecx, [ebp+var_160]
.text:0000492F                 mov     eax, [edx]
.text:00004931                 call    eax
.text:00004933                 cmp     esi, esp
.text:00004935                 call    __RTC_CheckEsp
.text:0000493A                 mov     [ebp+var_1A0], 6
.text:00004944                 mov     [ebp+var_1A4], 0
.text:0000494E
.text:0000494E loc_494E:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool):loc_4998j
.text:0000494E                 mov     ecx, [ebp+var_24]
.text:00004951                 push    ecx
.text:00004952                 mov     edx, [ebp+var_1A4]
.text:00004958                 push    edx
.text:00004959                 call    ?GetNumThreadsNext@@YGIII@Z ; GetNumThreadsNext(uint,uint)
.text:0000495E                 mov     [ebp+var_1A8], eax
.text:00004964                 push    6
.text:00004966                 mov     eax, [ebp+var_1A8]
.text:0000496C                 xor     ecx, ecx
.text:0000496E                 push    ecx
.text:0000496F                 push    eax
.text:00004970                 mov     edx, [ebp+var_160]
.text:00004976                 push    edx
.text:00004977                 call    ?PrintNumber@@YGXAAUIBenchPrintCallback@@_KH@Z ; PrintNumber(IBenchPrintCallback &,unsigned __int64,int)
.text:0000497C                 mov     eax, [ebp+var_1A4]
.text:00004982                 add     eax, 1
.text:00004985                 mov     [ebp+var_1A4], eax
.text:0000498B                 mov     ecx, [ebp+var_1A8]
.text:00004991                 cmp     ecx, [ebp+var_24]
.text:00004994                 jb      short loc_4998
.text:00004996                 jmp     short loc_499A
.text:00004998 ; ---------------------------------------------------------------------------
.text:00004998
.text:00004998 loc_4998:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+AC4j
.text:00004998                 jmp     short loc_494E
.text:0000499A ; ---------------------------------------------------------------------------
.text:0000499A
.text:0000499A loc_499A:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+AC6j
.text:0000499A                 mov     edx, [ebp+var_160]
.text:000049A0                 mov     eax, [edx]
.text:000049A2                 mov     esi, esp
.text:000049A4                 mov     ecx, [ebp+var_160]
.text:000049AA                 mov     edx, [eax+4]
.text:000049AD                 call    edx
.text:000049AF                 cmp     esi, esp
.text:000049B1                 call    __RTC_CheckEsp
.text:000049B6                 mov     eax, [ebp+var_160]
.text:000049BC                 mov     edx, [eax]
.text:000049BE                 mov     esi, esp
.text:000049C0                 mov     ecx, [ebp+var_160]
.text:000049C6                 mov     eax, [edx+4]
.text:000049C9                 call    eax
.text:000049CB                 cmp     esi, esp
.text:000049CD                 call    __RTC_CheckEsp
.text:000049D2                 mov     ecx, [ebp+var_1A4]
.text:000049D8                 push    ecx             ; unsigned int
.text:000049D9                 lea     ecx, [ebp+var_1B0] ; this
.text:000049DF                 call    ??0CTempValues@@QAE@I@Z ; CTempValues::CTempValues(uint)
.text:000049E4                 mov     byte ptr [ebp+var_4], 9
.text:000049E8                 mov     [ebp+var_1B8], 0
.text:000049F2                 jmp     short loc_4A03
.text:000049F4 ; ---------------------------------------------------------------------------
.text:000049F4
.text:000049F4 loc_49F4:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+B5Cj
.text:000049F4                 mov     edx, [ebp+var_1B8]
.text:000049FA                 add     edx, 1
.text:000049FD                 mov     [ebp+var_1B8], edx
.text:00004A03
.text:00004A03 loc_4A03:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+B22j
.text:00004A03                 mov     eax, [ebp+var_1B8]
.text:00004A09                 cmp     eax, [ebp+var_1A4]
.text:00004A0F                 jnb     short loc_4A2E
.text:00004A11                 mov     ecx, [ebp+var_1B8]
.text:00004A17                 mov     edx, [ebp+var_1B0]
.text:00004A1D                 mov     dword ptr [edx+ecx*8], 0
.text:00004A24                 mov     dword ptr [edx+ecx*8+4], 0
.text:00004A2C                 jmp     short loc_49F4
.text:00004A2E ; ---------------------------------------------------------------------------
.text:00004A2E
.text:00004A2E loc_4A2E:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+B3Fj
.text:00004A2E                 mov     [ebp+var_1C0], 0
.text:00004A38                 mov     [ebp+var_1BC], 0
.text:00004A42                 mov     [ebp+var_1C4], 0
.text:00004A4C                 jmp     short loc_4A5D
.text:00004A4E ; ---------------------------------------------------------------------------
.text:00004A4E
.text:00004A4E loc_4A4E:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool):loc_4D62j
.text:00004A4E                 mov     eax, [ebp+var_1C4]
.text:00004A54                 add     eax, 1
.text:00004A57                 mov     [ebp+var_1C4], eax
.text:00004A5D
.text:00004A5D loc_4A5D:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+B7Cj
.text:00004A5D                 mov     ecx, [ebp+var_1C4]
.text:00004A63                 cmp     ecx, [ebp+arg_C]
.text:00004A66                 jnb     loc_4D67
.text:00004A6C                 mov     [ebp+var_1C8], 0Ah
.text:00004A76                 jmp     short loc_4A87
.text:00004A78 ; ---------------------------------------------------------------------------
.text:00004A78
.text:00004A78 loc_4A78:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+E8Dj
.text:00004A78                 mov     edx, [ebp+var_1C8]
.text:00004A7E                 add     edx, 1
.text:00004A81                 mov     [ebp+var_1C8], edx
.text:00004A87
.text:00004A87 loc_4A87:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+BA6j
.text:00004A87                 cmp     [ebp+var_1C8], 20h ; ' '
.text:00004A8E                 jnb     loc_4D62
.text:00004A94                 mov     eax, 1
.text:00004A99                 mov     ecx, [ebp+var_1C8]
.text:00004A9F                 shl     eax, cl
.text:00004AA1                 mov     [ebp+var_1CC], eax
.text:00004AA7                 mov     ecx, [ebp+var_1CC]
.text:00004AAD                 cmp     ecx, [ebp+var_110]
.text:00004AB3                 jbe     short loc_4ABA
.text:00004AB5                 jmp     loc_4D62
.text:00004ABA ; ---------------------------------------------------------------------------
.text:00004ABA
.text:00004ABA loc_4ABA:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+BE3j
.text:00004ABA                 lea     edx, [ebp+var_1E0]
.text:00004AC0                 push    edx             ; char *
.text:00004AC1                 mov     eax, [ebp+var_1C8]
.text:00004AC7                 push    eax             ; unsigned int
.text:00004AC8                 call    ?ConvertUInt32ToString@@YGXIPAD@Z ; ConvertUInt32ToString(uint,char *)
.text:00004ACD                 lea     ecx, [ebp+var_1E0]
.text:00004AD3                 push    ecx             ; char *
.text:00004AD4                 call    ?MyStringLen@@YGIPBD@Z ; MyStringLen(char const *)
.text:00004AD9                 mov     [ebp+var_1E8], eax
.text:00004ADF                 mov     edx, [ebp+var_1E8]
.text:00004AE5                 mov     [ebp+edx+var_1E0], 3Ah ; ':'
.text:00004AED                 mov     eax, [ebp+var_1E8]
.text:00004AF3                 add     eax, 1
.text:00004AF6                 mov     [ebp+var_1E8], eax
.text:00004AFC                 mov     ecx, [ebp+var_1E8]
.text:00004B02                 mov     [ebp+ecx+var_1E0], 20h ; ' '
.text:00004B0A                 mov     edx, [ebp+var_1E8]
.text:00004B10                 add     edx, 1
.text:00004B13                 mov     [ebp+var_1E8], edx
.text:00004B19                 mov     eax, [ebp+var_1E8]
.text:00004B1F                 mov     [ebp+eax+var_1E0], 0
.text:00004B27                 mov     esi, esp
.text:00004B29                 lea     ecx, [ebp+var_1E0]
.text:00004B2F                 push    ecx
.text:00004B30                 mov     edx, [ebp+var_160]
.text:00004B36                 mov     eax, [edx]
.text:00004B38                 mov     ecx, [ebp+var_160]
.text:00004B3E                 mov     edx, [eax]
.text:00004B40                 call    edx
.text:00004B42                 cmp     esi, esp
.text:00004B44                 call    __RTC_CheckEsp
.text:00004B49                 mov     [ebp+var_1EC], 0
.text:00004B53                 jmp     short loc_4B64
.text:00004B55 ; ---------------------------------------------------------------------------
.text:00004B55
.text:00004B55 loc_4B55:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+E4Ej
.text:00004B55                 mov     eax, [ebp+var_1EC]
.text:00004B5B                 add     eax, 1
.text:00004B5E                 mov     [ebp+var_1EC], eax
.text:00004B64
.text:00004B64 loc_4B64:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+C83j
.text:00004B64                 mov     ecx, [ebp+var_1EC]
.text:00004B6A                 cmp     ecx, [ebp+var_1A4]
.text:00004B70                 jnb     loc_4D23
.text:00004B76                 mov     edx, [ebp+var_160]
.text:00004B7C                 mov     eax, [edx]
.text:00004B7E                 mov     esi, esp
.text:00004B80                 mov     ecx, [ebp+var_160]
.text:00004B86                 mov     edx, [eax+8]
.text:00004B89                 call    edx
.text:00004B8B                 cmp     esi, esp
.text:00004B8D                 call    __RTC_CheckEsp
.text:00004B92                 mov     [ebp+var_1F0], eax
.text:00004B98                 cmp     [ebp+var_1F0], 0
.text:00004B9F                 jz      short loc_4BE5
.text:00004BA1                 mov     eax, [ebp+var_1F0]
.text:00004BA7                 mov     [ebp+var_3F8], eax
.text:00004BAD                 mov     byte ptr [ebp+var_4], 6
.text:00004BB1                 lea     ecx, [ebp+var_1B0] ; this
.text:00004BB7                 call    ??1CTempValues@@QAE@XZ ; CTempValues::~CTempValues(void)
.text:00004BBC                 mov     byte ptr [ebp+var_4], 0
.text:00004BC0                 lea     ecx, [ebp+var_148] ; this
.text:00004BC6                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00004BCB                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00004BD2                 lea     ecx, [ebp+var_60] ; this
.text:00004BD5                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:00004BDA                 mov     eax, [ebp+var_3F8]
.text:00004BE0                 jmp     loc_5D6B
.text:00004BE5 ; ---------------------------------------------------------------------------
.text:00004BE5
.text:00004BE5 loc_4BE5:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+CCFj
.text:00004BE5                 mov     ecx, [ebp+var_24]
.text:00004BE8                 push    ecx
.text:00004BE9                 mov     edx, [ebp+var_1EC]
.text:00004BEF                 push    edx
.text:00004BF0                 call    ?GetNumThreadsNext@@YGIII@Z ; GetNumThreadsNext(uint,uint)
.text:00004BF5                 mov     [ebp+var_1F4], eax
.text:00004BFB                 mov     [ebp+var_200], 0
.text:00004C05                 mov     [ebp+var_1FC], 0
.text:00004C0F                 cmp     [ebp+var_1C8], 11h
.text:00004C16                 jnz     short loc_4C26
.text:00004C18                 mov     eax, [ebp+var_168]
.text:00004C1E                 mov     [ebp+var_42C], eax
.text:00004C24                 jmp     short loc_4C30
.text:00004C26 ; ---------------------------------------------------------------------------
.text:00004C26
.text:00004C26 loc_4C26:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+D46j
.text:00004C26                 mov     [ebp+var_42C], 0
.text:00004C30
.text:00004C30 loc_4C30:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+D54j
.text:00004C30                 push    0               ; int
.text:00004C32                 push    0               ; int
.text:00004C34                 push    0               ; char
.text:00004C36                 push    0               ; int
.text:00004C38                 push    0               ; int
.text:00004C3A                 lea     ecx, [ebp+var_60]
.text:00004C3D                 push    ecx             ; CProps *
.text:00004C3E                 mov     edx, [ebp+var_42C]
.text:00004C44                 push    edx             ; int
.text:00004C45                 push    1               ; int
.text:00004C47                 mov     eax, [ebp+var_164]
.text:00004C4D                 push    eax             ; int
.text:00004C4E                 lea     ecx, [ebp+var_200]
.text:00004C54                 push    ecx             ; int
.text:00004C55                 mov     edx, [ebp+var_1CC]
.text:00004C5B                 push    edx             ; int
.text:00004C5C                 mov     eax, [ebp+var_1F4]
.text:00004C62                 push    eax             ; int
.text:00004C63                 mov     ecx, [ebp+var_D4]
.text:00004C69                 push    ecx             ; int
.text:00004C6A                 mov     edx, [ebp+var_D8]
.text:00004C70                 push    edx             ; int
.text:00004C71                 call    ?CrcBench@@YGJ_KIIAA_KIIPBIABVCOneMethodInfo@@PAUIBenchPrintCallback@@PAUCTotalBenchRes@@_N0@Z ; CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)
.text:00004C76                 mov     [ebp+var_208], eax
.text:00004C7C                 cmp     [ebp+var_208], 0
.text:00004C83                 jz      short loc_4CC9
.text:00004C85                 mov     eax, [ebp+var_208]
.text:00004C8B                 mov     [ebp+var_3FC], eax
.text:00004C91                 mov     byte ptr [ebp+var_4], 6
.text:00004C95                 lea     ecx, [ebp+var_1B0] ; this
.text:00004C9B                 call    ??1CTempValues@@QAE@XZ ; CTempValues::~CTempValues(void)
.text:00004CA0                 mov     byte ptr [ebp+var_4], 0
.text:00004CA4                 lea     ecx, [ebp+var_148] ; this
.text:00004CAA                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00004CAF                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00004CB6                 lea     ecx, [ebp+var_60] ; this
.text:00004CB9                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:00004CBE                 mov     eax, [ebp+var_3FC]
.text:00004CC4                 jmp     loc_5D6B
.text:00004CC9 ; ---------------------------------------------------------------------------
.text:00004CC9
.text:00004CC9 loc_4CC9:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+DB3j
.text:00004CC9                 push    6
.text:00004CCB                 mov     eax, [ebp+var_200]
.text:00004CD1                 mov     edx, [ebp+var_1FC]
.text:00004CD7                 mov     cl, 14h
.text:00004CD9                 call    __aullshr
.text:00004CDE                 push    edx
.text:00004CDF                 push    eax
.text:00004CE0                 mov     ecx, [ebp+var_160]
.text:00004CE6                 push    ecx
.text:00004CE7                 call    ?PrintNumber@@YGXAAUIBenchPrintCallback@@_KH@Z ; PrintNumber(IBenchPrintCallback &,unsigned __int64,int)
.text:00004CEC                 mov     edx, [ebp+var_1EC]
.text:00004CF2                 mov     eax, [ebp+var_1B0]
.text:00004CF8                 mov     ecx, [eax+edx*8]
.text:00004CFB                 add     ecx, [ebp+var_200]
.text:00004D01                 mov     edx, [eax+edx*8+4]
.text:00004D05                 adc     edx, [ebp+var_1FC]
.text:00004D0B                 mov     eax, [ebp+var_1EC]
.text:00004D11                 mov     esi, [ebp+var_1B0]
.text:00004D17                 mov     [esi+eax*8], ecx
.text:00004D1A                 mov     [esi+eax*8+4], edx
.text:00004D1E                 jmp     loc_4B55
.text:00004D23 ; ---------------------------------------------------------------------------
.text:00004D23
.text:00004D23 loc_4D23:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+CA0j
.text:00004D23                 mov     ecx, [ebp+var_160]
.text:00004D29                 mov     edx, [ecx]
.text:00004D2B                 mov     esi, esp
.text:00004D2D                 mov     ecx, [ebp+var_160]
.text:00004D33                 mov     eax, [edx+4]
.text:00004D36                 call    eax
.text:00004D38                 cmp     esi, esp
.text:00004D3A                 call    __RTC_CheckEsp
.text:00004D3F                 mov     ecx, [ebp+var_1C0]
.text:00004D45                 add     ecx, 1
.text:00004D48                 mov     edx, [ebp+var_1BC]
.text:00004D4E                 adc     edx, 0
.text:00004D51                 mov     [ebp+var_1C0], ecx
.text:00004D57                 mov     [ebp+var_1BC], edx
.text:00004D5D                 jmp     loc_4A78
.text:00004D62 ; ---------------------------------------------------------------------------
.text:00004D62
.text:00004D62 loc_4D62:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+BBEj
.text:00004D62                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+BE5j
.text:00004D62                 jmp     loc_4A4E
.text:00004D67 ; ---------------------------------------------------------------------------
.text:00004D67
.text:00004D67 loc_4D67:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+B96j
.text:00004D67                 mov     eax, [ebp+var_1C0]
.text:00004D6D                 or      eax, [ebp+var_1BC]
.text:00004D73                 jz      loc_4E3B
.text:00004D79                 mov     ecx, [ebp+var_160]
.text:00004D7F                 mov     edx, [ecx]
.text:00004D81                 mov     esi, esp
.text:00004D83                 mov     ecx, [ebp+var_160]
.text:00004D89                 mov     eax, [edx+4]
.text:00004D8C                 call    eax
.text:00004D8E                 cmp     esi, esp
.text:00004D90                 call    __RTC_CheckEsp
.text:00004D95                 mov     esi, esp
.text:00004D97                 push    offset $SG71634 ; "Avg:"
.text:00004D9C                 mov     ecx, [ebp+var_160]
.text:00004DA2                 mov     edx, [ecx]
.text:00004DA4                 mov     ecx, [ebp+var_160]
.text:00004DAA                 mov     eax, [edx]
.text:00004DAC                 call    eax
.text:00004DAE                 cmp     esi, esp
.text:00004DB0                 call    __RTC_CheckEsp
.text:00004DB5                 mov     [ebp+var_20C], 0
.text:00004DBF                 jmp     short loc_4DD0
.text:00004DC1 ; ---------------------------------------------------------------------------
.text:00004DC1
.text:00004DC1 loc_4DC1:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+F4Dj
.text:00004DC1                 mov     ecx, [ebp+var_20C]
.text:00004DC7                 add     ecx, 1
.text:00004DCA                 mov     [ebp+var_20C], ecx
.text:00004DD0
.text:00004DD0 loc_4DD0:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+EEFj
.text:00004DD0                 mov     edx, [ebp+var_20C]
.text:00004DD6                 cmp     edx, [ebp+var_1A4]
.text:00004DDC                 jnb     short loc_4E1F
.text:00004DDE                 push    6
.text:00004DE0                 mov     eax, [ebp+var_20C]
.text:00004DE6                 mov     ecx, [ebp+var_1B0]
.text:00004DEC                 mov     edx, [ebp+var_1BC]
.text:00004DF2                 push    edx
.text:00004DF3                 mov     edx, [ebp+var_1C0]
.text:00004DF9                 push    edx
.text:00004DFA                 mov     edx, [ecx+eax*8+4]
.text:00004DFE                 push    edx
.text:00004DFF                 mov     eax, [ecx+eax*8]
.text:00004E02                 push    eax
.text:00004E03                 call    __aulldiv
.text:00004E08                 mov     cl, 14h
.text:00004E0A                 call    __aullshr
.text:00004E0F                 push    edx
.text:00004E10                 push    eax
.text:00004E11                 mov     ecx, [ebp+var_160]
.text:00004E17                 push    ecx
.text:00004E18                 call    ?PrintNumber@@YGXAAUIBenchPrintCallback@@_KH@Z ; PrintNumber(IBenchPrintCallback &,unsigned __int64,int)
.text:00004E1D                 jmp     short loc_4DC1
.text:00004E1F ; ---------------------------------------------------------------------------
.text:00004E1F
.text:00004E1F loc_4E1F:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+F0Cj
.text:00004E1F                 mov     edx, [ebp+var_160]
.text:00004E25                 mov     eax, [edx]
.text:00004E27                 mov     esi, esp
.text:00004E29                 mov     ecx, [ebp+var_160]
.text:00004E2F                 mov     edx, [eax+4]
.text:00004E32                 call    edx
.text:00004E34                 cmp     esi, esp
.text:00004E36                 call    __RTC_CheckEsp
.text:00004E3B
.text:00004E3B loc_4E3B:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+EA3j
.text:00004E3B                 mov     [ebp+var_400], 0
.text:00004E45                 mov     byte ptr [ebp+var_4], 6
.text:00004E49                 lea     ecx, [ebp+var_1B0] ; this
.text:00004E4F                 call    ??1CTempValues@@QAE@XZ ; CTempValues::~CTempValues(void)
.text:00004E54                 mov     byte ptr [ebp+var_4], 0
.text:00004E58                 lea     ecx, [ebp+var_148] ; this
.text:00004E5E                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00004E63                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00004E6A                 lea     ecx, [ebp+var_60] ; this
.text:00004E6D                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:00004E72                 mov     eax, [ebp+var_400]
.text:00004E78                 jmp     loc_5D6B
.text:00004E7D ; ---------------------------------------------------------------------------
.text:00004E7D
.text:00004E7D loc_4E7D:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+869j
.text:00004E7D                 mov     [ebp+var_20D], 0
.text:00004E84                 push    offset $SG71643 ; char *
.text:00004E89                 lea     ecx, [ebp+var_54] ; this
.text:00004E8C                 call    ?IsEqualTo_Ascii_NoCase@AString@@QBE_NPBD@Z ; AString::IsEqualTo_Ascii_NoCase(char const *)
.text:00004E91                 mov     [ebp+var_20E], al
.text:00004E97                 mov     [ebp+var_214], 0
.text:00004EA1                 jmp     short loc_4EB2
.text:00004EA3 ; ---------------------------------------------------------------------------
.text:00004EA3
.text:00004EA3 loc_4EA3:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1E68j
.text:00004EA3                 mov     eax, [ebp+var_214]
.text:00004EA9                 add     eax, 1
.text:00004EAC                 mov     [ebp+var_214], eax
.text:00004EB2
.text:00004EB2 loc_4EB2:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+FD1j
.text:00004EB2                 cmp     [ebp+var_214], 3
.text:00004EB9                 jnb     loc_5D3D
.text:00004EBF                 mov     ecx, [ebp+var_24]
.text:00004EC2                 mov     [ebp+var_218], ecx
.text:00004EC8                 movzx   edx, [ebp+var_35]
.text:00004ECC                 test    edx, edx
.text:00004ECE                 jnz     short loc_4EE0
.text:00004ED0                 cmp     [ebp+var_214], 0
.text:00004ED7                 jz      short loc_4EDE
.text:00004ED9                 jmp     loc_5D3D
.text:00004EDE ; ---------------------------------------------------------------------------
.text:00004EDE
.text:00004EDE loc_4EDE:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1007j
.text:00004EDE                 jmp     short loc_4F2E
.text:00004EE0 ; ---------------------------------------------------------------------------
.text:00004EE0
.text:00004EE0 loc_4EE0:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+FFEj
.text:00004EE0                 mov     [ebp+var_218], 1
.text:00004EEA                 cmp     [ebp+var_214], 0
.text:00004EF1                 jz      short loc_4F2E
.text:00004EF3                 cmp     [ebp+var_14], 2
.text:00004EF7                 jnb     short loc_4EFE
.text:00004EF9                 jmp     loc_5D3D
.text:00004EFE ; ---------------------------------------------------------------------------
.text:00004EFE
.text:00004EFE loc_4EFE:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1027j
.text:00004EFE                 mov     eax, [ebp+var_14]
.text:00004F01                 mov     [ebp+var_218], eax
.text:00004F07                 cmp     [ebp+var_214], 1
.text:00004F0E                 jnz     short loc_4F23
.text:00004F10                 cmp     [ebp+var_14], 4
.text:00004F14                 jb      short loc_4F21
.text:00004F16                 mov     ecx, [ebp+var_14]
.text:00004F19                 shr     ecx, 1
.text:00004F1B                 mov     [ebp+var_218], ecx
.text:00004F21
.text:00004F21 loc_4F21:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1044j
.text:00004F21                 jmp     short loc_4F2E
.text:00004F23 ; ---------------------------------------------------------------------------
.text:00004F23
.text:00004F23 loc_4F23:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+103Ej
.text:00004F23                 cmp     [ebp+var_14], 4
.text:00004F27                 jnb     short loc_4F2E
.text:00004F29                 jmp     loc_5D3D
.text:00004F2E ; ---------------------------------------------------------------------------
.text:00004F2E
.text:00004F2E loc_4F2E:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool):loc_4EDEj
.text:00004F2E                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1021j ...
.text:00004F2E                 lea     ecx, [ebp+var_29C]
.text:00004F34                 call    ??0CBenchCallbackToPrint@@QAE@XZ ; CBenchCallbackToPrint::CBenchCallbackToPrint(void)
.text:00004F39                 lea     ecx, [ebp+var_29C] ; this
.text:00004F3F                 call    ?Init@CBenchCallbackToPrint@@QAEXXZ ; CBenchCallbackToPrint::Init(void)
.text:00004F44                 mov     edx, [ebp+arg_0]
.text:00004F47                 mov     [ebp+var_244], edx
.text:00004F4D                 mov     eax, [ebp+arg_0]
.text:00004F50                 mov     [ebp+var_2A4], eax
.text:00004F56                 cmp     [ebp+var_214], 0
.text:00004F5D                 jbe     short loc_4F97
.text:00004F5F                 mov     ecx, [ebp+var_2A4]
.text:00004F65                 mov     edx, [ecx]
.text:00004F67                 mov     esi, esp
.text:00004F69                 mov     ecx, [ebp+var_2A4]
.text:00004F6F                 mov     eax, [edx+4]
.text:00004F72                 call    eax
.text:00004F74                 cmp     esi, esp
.text:00004F76                 call    __RTC_CheckEsp
.text:00004F7B                 mov     ecx, [ebp+var_2A4]
.text:00004F81                 mov     edx, [ecx]
.text:00004F83                 mov     esi, esp
.text:00004F85                 mov     ecx, [ebp+var_2A4]
.text:00004F8B                 mov     eax, [edx+4]
.text:00004F8E                 call    eax
.text:00004F90                 cmp     esi, esp
.text:00004F92                 call    __RTC_CheckEsp
.text:00004F97
.text:00004F97 loc_4F97:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+108Dj
.text:00004F97                 movzx   ecx, [ebp+var_115]
.text:00004F9E                 test    ecx, ecx
.text:00004FA0                 jnz     loc_5031
.text:00004FA6                 movzx   edx, [ebp+var_20E]
.text:00004FAD                 neg     edx
.text:00004FAF                 sbb     edx, edx
.text:00004FB1                 add     edx, 19h
.text:00004FB4                 mov     [ebp+var_2A8], edx
.text:00004FBA                 jmp     short loc_4FCB
.text:00004FBC ; ---------------------------------------------------------------------------
.text:00004FBC
.text:00004FBC loc_4FBC:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool):loc_501Cj
.text:00004FBC                 mov     eax, [ebp+var_2A8]
.text:00004FC2                 sub     eax, 1
.text:00004FC5                 mov     [ebp+var_2A8], eax
.text:00004FCB
.text:00004FCB loc_4FCB:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+10EAj
.text:00004FCB                 cmp     [ebp+var_2A8], 12h
.text:00004FD2                 jbe     short loc_501E
.text:00004FD4                 mov     edx, 1
.text:00004FD9                 mov     ecx, [ebp+var_2A8]
.text:00004FDF                 shl     edx, cl
.text:00004FE1                 push    edx             ; unsigned int
.text:00004FE2                 mov     eax, [ebp+var_218]
.text:00004FE8                 push    eax             ; unsigned int
.text:00004FE9                 call    ?GetBenchMemoryUsage@@YG_KII@Z ; GetBenchMemoryUsage(uint,uint)
.text:00004FEE                 add     eax, 800000h
.text:00004FF3                 adc     edx, 0
.text:00004FF6                 mov     [ebp+var_434], eax
.text:00004FFC                 mov     [ebp+var_430], edx
.text:00005002                 mov     ecx, [ebp+var_430]
.text:00005008                 cmp     ecx, [ebp+var_18]
.text:0000500B                 ja      short loc_501C
.text:0000500D                 jb      short loc_501A
.text:0000500F                 mov     edx, [ebp+var_434]
.text:00005015                 cmp     edx, [ebp+var_1C]
.text:00005018                 ja      short loc_501C
.text:0000501A
.text:0000501A loc_501A:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+113Dj
.text:0000501A                 jmp     short loc_501E
.text:0000501C ; ---------------------------------------------------------------------------
.text:0000501C
.text:0000501C loc_501C:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+113Bj
.text:0000501C                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1148j
.text:0000501C                 jmp     short loc_4FBC
.text:0000501E ; ---------------------------------------------------------------------------
.text:0000501E
.text:0000501E loc_501E:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1102j
.text:0000501E                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool):loc_501Aj
.text:0000501E                 mov     eax, 1
.text:00005023                 mov     ecx, [ebp+var_2A8]
.text:00005029                 shl     eax, cl
.text:0000502B                 mov     [ebp+var_110], eax
.text:00005031
.text:00005031 loc_5031:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+10D0j
.text:00005031                 mov     ecx, [ebp+var_218]
.text:00005037                 push    ecx
.text:00005038                 push    offset $SG71669 ; "Benchmark threads:   "
.text:0000503D                 mov     edx, [ebp+var_110]
.text:00005043                 push    edx             ; unsigned int
.text:00005044                 mov     eax, [ebp+var_218]
.text:0000504A                 push    eax             ; unsigned int
.text:0000504B                 call    ?GetBenchMemoryUsage@@YG_KII@Z ; GetBenchMemoryUsage(uint,uint)
.text:00005050                 push    edx
.text:00005051                 push    eax
.text:00005052                 push    offset $SG71670 ; "usage:"
.text:00005057                 mov     ecx, [ebp+var_2A4]
.text:0000505D                 push    ecx
.text:0000505E                 call    ?PrintRequirements@@YGXAAUIBenchPrintCallback@@PBD_K1I@Z ; PrintRequirements(IBenchPrintCallback &,char const *,unsigned __int64,char const *,uint)
.text:00005063                 mov     edx, [ebp+var_2A4]
.text:00005069                 mov     eax, [edx]
.text:0000506B                 mov     esi, esp
.text:0000506D                 mov     ecx, [ebp+var_2A4]
.text:00005073                 mov     edx, [eax+4]
.text:00005076                 call    edx
.text:00005078                 cmp     esi, esp
.text:0000507A                 call    __RTC_CheckEsp
.text:0000507F                 movzx   eax, [ebp+var_20E]
.text:00005086                 test    eax, eax
.text:00005088                 jz      short loc_509D
.text:0000508A                 mov     [ebp+var_238], 0Ch
.text:00005094                 mov     [ebp+var_20D], 0
.text:0000509B                 jmp     short loc_50AE
.text:0000509D ; ---------------------------------------------------------------------------
.text:0000509D
.text:0000509D loc_509D:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+11B8j
.text:0000509D                 mov     [ebp+var_238], 4
.text:000050A7                 mov     [ebp+var_20D], 1
.text:000050AE
.text:000050AE loc_50AE:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+11CBj
.text:000050AE                 mov     cl, [ebp+var_20D]
.text:000050B4                 mov     [ebp+var_23C], cl
.text:000050BA                 mov     [ebp+var_2A9], 0
.text:000050C1                 mov     dword ptr [ebp+var_2B8], 0
.text:000050CB                 mov     dword ptr [ebp+var_2B8+4], 0
.text:000050D5                 movzx   edx, [ebp+var_20E]
.text:000050DC                 test    edx, edx
.text:000050DE                 jz      short loc_50E7
.text:000050E0                 mov     [ebp+var_2A9], 1
.text:000050E7
.text:000050E7 loc_50E7:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+120Ej
.text:000050E7                 mov     [ebp+Size], 1Eh
.text:000050F1                 movzx   eax, [ebp+var_2A9]
.text:000050F8                 test    eax, eax
.text:000050FA                 jz      short loc_510B
.text:000050FC                 mov     ecx, [ebp+Size]
.text:00005102                 add     ecx, 0Ch
.text:00005105                 mov     [ebp+Size], ecx
.text:0000510B
.text:0000510B loc_510B:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+122Aj
.text:0000510B                 movzx   edx, [ebp+var_20D]
.text:00005112                 test    edx, edx
.text:00005114                 jz      short loc_517B
.text:00005116                 mov     eax, [ebp+var_238]
.text:0000511C                 push    eax             ; Size
.text:0000511D                 mov     ecx, [ebp+var_2A4]
.text:00005123                 push    ecx             ; int
.text:00005124                 call    ?PrintSpaces@@YGXAAUIBenchPrintCallback@@I@Z ; PrintSpaces(IBenchPrintCallback &,uint)
.text:00005129                 mov     edx, [ebp+Size]
.text:0000512F                 push    edx             ; unsigned int
.text:00005130                 push    offset $SG71679 ; "Compressing"
.text:00005135                 mov     eax, [ebp+var_2A4]
.text:0000513B                 push    eax             ; struct IBenchPrintCallback *
.text:0000513C                 call    ?PrintRight@@YGXAAUIBenchPrintCallback@@PBDI@Z ; PrintRight(IBenchPrintCallback &,char const *,uint)
.text:00005141                 mov     esi, esp
.text:00005143                 mov     ecx, ds:_kSep
.text:00005149                 push    ecx
.text:0000514A                 mov     edx, [ebp+var_2A4]
.text:00005150                 mov     eax, [edx]
.text:00005152                 mov     ecx, [ebp+var_2A4]
.text:00005158                 mov     edx, [eax]
.text:0000515A                 call    edx
.text:0000515C                 cmp     esi, esp
.text:0000515E                 call    __RTC_CheckEsp
.text:00005163                 mov     eax, [ebp+Size]
.text:00005169                 push    eax             ; unsigned int
.text:0000516A                 push    offset $SG71680 ; "Decompressing"
.text:0000516F                 mov     ecx, [ebp+var_2A4]
.text:00005175                 push    ecx             ; struct IBenchPrintCallback *
.text:00005176                 call    ?PrintRight@@YGXAAUIBenchPrintCallback@@PBDI@Z ; PrintRight(IBenchPrintCallback &,char const *,uint)
.text:0000517B
.text:0000517B loc_517B:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1244j
.text:0000517B                 mov     edx, [ebp+var_2A4]
.text:00005181                 mov     eax, [edx]
.text:00005183                 mov     esi, esp
.text:00005185                 mov     ecx, [ebp+var_2A4]
.text:0000518B                 mov     edx, [eax+4]
.text:0000518E                 call    edx
.text:00005190                 cmp     esi, esp
.text:00005192                 call    __RTC_CheckEsp
.text:00005197                 movzx   eax, [ebp+var_20E]
.text:0000519E                 test    eax, eax
.text:000051A0                 jz      short loc_51AE
.text:000051A2                 mov     [ebp+var_438], offset $SG71681 ; "Method"
.text:000051AC                 jmp     short loc_51B8
.text:000051AE ; ---------------------------------------------------------------------------
.text:000051AE
.text:000051AE loc_51AE:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+12D0j
.text:000051AE                 mov     [ebp+var_438], offset $SG71682 ; "Dict"
.text:000051B8
.text:000051B8 loc_51B8:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+12DCj
.text:000051B8                 mov     ecx, [ebp+var_238]
.text:000051BE                 push    ecx             ; unsigned int
.text:000051BF                 mov     edx, [ebp+var_438]
.text:000051C5                 push    edx             ; char *
.text:000051C6                 mov     eax, [ebp+var_2A4]
.text:000051CC                 push    eax             ; struct IBenchPrintCallback *
.text:000051CD                 call    ?PrintLeft@@YGXAAUIBenchPrintCallback@@PBDI@Z ; PrintLeft(IBenchPrintCallback &,char const *,uint)
.text:000051D2                 mov     [ebp+var_2C4], 0
.text:000051DC                 jmp     short loc_51ED
.text:000051DE ; ---------------------------------------------------------------------------
.text:000051DE
.text:000051DE loc_51DE:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool):loc_52AFj
.text:000051DE                 mov     ecx, [ebp+var_2C4]
.text:000051E4                 add     ecx, 1
.text:000051E7                 mov     [ebp+var_2C4], ecx
.text:000051ED
.text:000051ED loc_51ED:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+130Cj
.text:000051ED                 cmp     [ebp+var_2C4], 2
.text:000051F4                 jge     loc_52B4
.text:000051FA                 push    0Ah             ; unsigned int
.text:000051FC                 push    offset $SG71687 ; "Speed"
.text:00005201                 mov     edx, [ebp+var_2A4]
.text:00005207                 push    edx             ; struct IBenchPrintCallback *
.text:00005208                 call    ?PrintRight@@YGXAAUIBenchPrintCallback@@PBDI@Z ; PrintRight(IBenchPrintCallback &,char const *,uint)
.text:0000520D                 push    6               ; unsigned int
.text:0000520F                 push    offset $SG71688 ; "Usage"
.text:00005214                 mov     eax, [ebp+var_2A4]
.text:0000521A                 push    eax             ; struct IBenchPrintCallback *
.text:0000521B                 call    ?PrintRight@@YGXAAUIBenchPrintCallback@@PBDI@Z ; PrintRight(IBenchPrintCallback &,char const *,uint)
.text:00005220                 push    7               ; unsigned int
.text:00005222                 push    offset $SG71689 ; "R/U"
.text:00005227                 mov     ecx, [ebp+var_2A4]
.text:0000522D                 push    ecx             ; struct IBenchPrintCallback *
.text:0000522E                 call    ?PrintRight@@YGXAAUIBenchPrintCallback@@PBDI@Z ; PrintRight(IBenchPrintCallback &,char const *,uint)
.text:00005233                 push    7               ; unsigned int
.text:00005235                 push    offset $SG71690 ; "Rating"
.text:0000523A                 mov     edx, [ebp+var_2A4]
.text:00005240                 push    edx             ; struct IBenchPrintCallback *
.text:00005241                 call    ?PrintRight@@YGXAAUIBenchPrintCallback@@PBDI@Z ; PrintRight(IBenchPrintCallback &,char const *,uint)
.text:00005246                 movzx   eax, [ebp+var_2A9]
.text:0000524D                 test    eax, eax
.text:0000524F                 jz      short loc_5277
.text:00005251                 push    6               ; unsigned int
.text:00005253                 push    offset $SG71692 ; "E/U"
.text:00005258                 mov     ecx, [ebp+var_2A4]
.text:0000525E                 push    ecx             ; struct IBenchPrintCallback *
.text:0000525F                 call    ?PrintRight@@YGXAAUIBenchPrintCallback@@PBDI@Z ; PrintRight(IBenchPrintCallback &,char const *,uint)
.text:00005264                 push    6               ; unsigned int
.text:00005266                 push    offset $SG71693 ; "Effec"
.text:0000526B                 mov     edx, [ebp+var_2A4]
.text:00005271                 push    edx             ; struct IBenchPrintCallback *
.text:00005272                 call    ?PrintRight@@YGXAAUIBenchPrintCallback@@PBDI@Z ; PrintRight(IBenchPrintCallback &,char const *,uint)
.text:00005277
.text:00005277 loc_5277:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+137Fj
.text:00005277                 movzx   eax, [ebp+var_20D]
.text:0000527E                 test    eax, eax
.text:00005280                 jnz     short loc_5284
.text:00005282                 jmp     short loc_52B4
.text:00005284 ; ---------------------------------------------------------------------------
.text:00005284
.text:00005284 loc_5284:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+13B0j
.text:00005284                 cmp     [ebp+var_2C4], 0
.text:0000528B                 jnz     short loc_52AF
.text:0000528D                 mov     esi, esp
.text:0000528F                 mov     ecx, ds:_kSep
.text:00005295                 push    ecx
.text:00005296                 mov     edx, [ebp+var_2A4]
.text:0000529C                 mov     eax, [edx]
.text:0000529E                 mov     ecx, [ebp+var_2A4]
.text:000052A4                 mov     edx, [eax]
.text:000052A6                 call    edx
.text:000052A8                 cmp     esi, esp
.text:000052AA                 call    __RTC_CheckEsp
.text:000052AF
.text:000052AF loc_52AF:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+13BBj
.text:000052AF                 jmp     loc_51DE
.text:000052B4 ; ---------------------------------------------------------------------------
.text:000052B4
.text:000052B4 loc_52B4:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1324j
.text:000052B4                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+13B2j
.text:000052B4                 mov     eax, [ebp+var_2A4]
.text:000052BA                 mov     edx, [eax]
.text:000052BC                 mov     esi, esp
.text:000052BE                 mov     ecx, [ebp+var_2A4]
.text:000052C4                 mov     eax, [edx+4]
.text:000052C7                 call    eax
.text:000052C9                 cmp     esi, esp
.text:000052CB                 call    __RTC_CheckEsp
.text:000052D0                 mov     ecx, [ebp+var_238]
.text:000052D6                 push    ecx             ; Size
.text:000052D7                 mov     edx, [ebp+var_2A4]
.text:000052DD                 push    edx             ; int
.text:000052DE                 call    ?PrintSpaces@@YGXAAUIBenchPrintCallback@@I@Z ; PrintSpaces(IBenchPrintCallback &,uint)
.text:000052E3                 mov     [ebp+var_2C4], 0
.text:000052ED                 jmp     short loc_52FE
.text:000052EF ; ---------------------------------------------------------------------------
.text:000052EF
.text:000052EF loc_52EF:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool):loc_53BFj
.text:000052EF                 mov     eax, [ebp+var_2C4]
.text:000052F5                 add     eax, 1
.text:000052F8                 mov     [ebp+var_2C4], eax
.text:000052FE
.text:000052FE loc_52FE:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+141Dj
.text:000052FE                 cmp     [ebp+var_2C4], 2
.text:00005305                 jge     loc_53C4
.text:0000530B                 push    0Ah             ; unsigned int
.text:0000530D                 push    offset $SG71699 ; "KiB/s"
.text:00005312                 mov     ecx, [ebp+var_2A4]
.text:00005318                 push    ecx             ; struct IBenchPrintCallback *
.text:00005319                 call    ?PrintRight@@YGXAAUIBenchPrintCallback@@PBDI@Z ; PrintRight(IBenchPrintCallback &,char const *,uint)
.text:0000531E                 push    6               ; unsigned int
.text:00005320                 push    offset $SG71700 ; char *
.text:00005325                 mov     edx, [ebp+var_2A4]
.text:0000532B                 push    edx             ; struct IBenchPrintCallback *
.text:0000532C                 call    ?PrintRight@@YGXAAUIBenchPrintCallback@@PBDI@Z ; PrintRight(IBenchPrintCallback &,char const *,uint)
.text:00005331                 push    7               ; unsigned int
.text:00005333                 push    offset $SG71701 ; "MIPS"
.text:00005338                 mov     eax, [ebp+var_2A4]
.text:0000533E                 push    eax             ; struct IBenchPrintCallback *
.text:0000533F                 call    ?PrintRight@@YGXAAUIBenchPrintCallback@@PBDI@Z ; PrintRight(IBenchPrintCallback &,char const *,uint)
.text:00005344                 push    7               ; unsigned int
.text:00005346                 push    offset $SG71702 ; "MIPS"
.text:0000534B                 mov     ecx, [ebp+var_2A4]
.text:00005351                 push    ecx             ; struct IBenchPrintCallback *
.text:00005352                 call    ?PrintRight@@YGXAAUIBenchPrintCallback@@PBDI@Z ; PrintRight(IBenchPrintCallback &,char const *,uint)
.text:00005357                 movzx   edx, [ebp+var_2A9]
.text:0000535E                 test    edx, edx
.text:00005360                 jz      short loc_5388
.text:00005362                 push    6               ; unsigned int
.text:00005364                 push    offset $SG71704 ; char *
.text:00005369                 mov     eax, [ebp+var_2A4]
.text:0000536F                 push    eax             ; struct IBenchPrintCallback *
.text:00005370                 call    ?PrintRight@@YGXAAUIBenchPrintCallback@@PBDI@Z ; PrintRight(IBenchPrintCallback &,char const *,uint)
.text:00005375                 push    6               ; unsigned int
.text:00005377                 push    offset $SG71705 ; char *
.text:0000537C                 mov     ecx, [ebp+var_2A4]
.text:00005382                 push    ecx             ; struct IBenchPrintCallback *
.text:00005383                 call    ?PrintRight@@YGXAAUIBenchPrintCallback@@PBDI@Z ; PrintRight(IBenchPrintCallback &,char const *,uint)
.text:00005388
.text:00005388 loc_5388:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1490j
.text:00005388                 movzx   edx, [ebp+var_20D]
.text:0000538F                 test    edx, edx
.text:00005391                 jnz     short loc_5395
.text:00005393                 jmp     short loc_53C4
.text:00005395 ; ---------------------------------------------------------------------------
.text:00005395
.text:00005395 loc_5395:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+14C1j
.text:00005395                 cmp     [ebp+var_2C4], 0
.text:0000539C                 jnz     short loc_53BF
.text:0000539E                 mov     esi, esp
.text:000053A0                 mov     eax, ds:_kSep
.text:000053A5                 push    eax
.text:000053A6                 mov     ecx, [ebp+var_2A4]
.text:000053AC                 mov     edx, [ecx]
.text:000053AE                 mov     ecx, [ebp+var_2A4]
.text:000053B4                 mov     eax, [edx]
.text:000053B6                 call    eax
.text:000053B8                 cmp     esi, esp
.text:000053BA                 call    __RTC_CheckEsp
.text:000053BF
.text:000053BF loc_53BF:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+14CCj
.text:000053BF                 jmp     loc_52EF
.text:000053C4 ; ---------------------------------------------------------------------------
.text:000053C4
.text:000053C4 loc_53C4:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1435j
.text:000053C4                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+14C3j
.text:000053C4                 mov     ecx, [ebp+var_2A4]
.text:000053CA                 mov     edx, [ecx]
.text:000053CC                 mov     esi, esp
.text:000053CE                 mov     ecx, [ebp+var_2A4]
.text:000053D4                 mov     eax, [edx+4]
.text:000053D7                 call    eax
.text:000053D9                 cmp     esi, esp
.text:000053DB                 call    __RTC_CheckEsp
.text:000053E0                 mov     ecx, [ebp+var_2A4]
.text:000053E6                 mov     edx, [ecx]
.text:000053E8                 mov     esi, esp
.text:000053EA                 mov     ecx, [ebp+var_2A4]
.text:000053F0                 mov     eax, [edx+4]
.text:000053F3                 call    eax
.text:000053F5                 cmp     esi, esp
.text:000053F7                 call    __RTC_CheckEsp
.text:000053FC                 movzx   ecx, [ebp+var_20E]
.text:00005403                 test    ecx, ecx
.text:00005405                 jz      loc_575B
.text:0000540B                 movzx   edx, [ebp+var_115]
.text:00005412                 test    edx, edx
.text:00005414                 jnz     short loc_5420
.text:00005416                 mov     [ebp+var_110], 1000000h
.text:00005420
.text:00005420 loc_5420:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1544j
.text:00005420                 mov     [ebp+var_2C8], 0
.text:0000542A                 jmp     short loc_543B
.text:0000542C ; ---------------------------------------------------------------------------
.text:0000542C
.text:0000542C loc_542C:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1881j
.text:0000542C                 mov     eax, [ebp+var_2C8]
.text:00005432                 add     eax, 1
.text:00005435                 mov     [ebp+var_2C8], eax
.text:0000543B
.text:0000543B loc_543B:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+155Aj
.text:0000543B                 mov     ecx, [ebp+var_2C8]
.text:00005441                 cmp     ecx, [ebp+arg_C]
.text:00005444                 jnb     loc_5756
.text:0000544A                 cmp     [ebp+var_2C8], 0
.text:00005451                 jz      short loc_5469
.text:00005453                 mov     edx, [ebp+arg_0]
.text:00005456                 mov     eax, [edx]
.text:00005458                 mov     esi, esp
.text:0000545A                 mov     ecx, [ebp+arg_0]
.text:0000545D                 mov     edx, [eax+4]
.text:00005460                 call    edx
.text:00005462                 cmp     esi, esp
.text:00005464                 call    __RTC_CheckEsp
.text:00005469
.text:00005469 loc_5469:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1581j
.text:00005469                 mov     [ebp+var_2D4], 3
.text:00005473                 mov     [ebp+var_2D0], 0
.text:0000547D                 jmp     short loc_548E
.text:0000547F ; ---------------------------------------------------------------------------
.text:0000547F
.text:0000547F loc_547F:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool):loc_555Ej
.text:0000547F                 mov     eax, [ebp+var_2D0]
.text:00005485                 add     eax, 1
.text:00005488                 mov     [ebp+var_2D0], eax
.text:0000548E
.text:0000548E loc_548E:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+15ADj
.text:0000548E                 cmp     [ebp+var_2D0], 3
.text:00005495                 jge     loc_5563
.text:0000549B                 push    0Ch             ; unsigned int
.text:0000549D                 push    offset $SG71722 ; "CPU"
.text:000054A2                 mov     ecx, [ebp+var_2A4]
.text:000054A8                 push    ecx             ; struct IBenchPrintCallback *
.text:000054A9                 call    ?PrintLeft@@YGXAAUIBenchPrintCallback@@PBDI@Z ; PrintLeft(IBenchPrintCallback &,char const *,uint)
.text:000054AE                 lea     edx, [ebp+var_2DC]
.text:000054B4                 push    edx
.text:000054B5                 lea     eax, [ebp+var_2B8]
.text:000054BB                 push    eax
.text:000054BC                 cmp     [ebp+var_2D0], 2
.text:000054C3                 setz    cl
.text:000054C6                 movzx   edx, cl
.text:000054C9                 push    edx
.text:000054CA                 mov     eax, [ebp+arg_0]
.text:000054CD                 push    eax
.text:000054CE                 mov     ecx, [ebp+var_218]
.text:000054D4                 push    ecx
.text:000054D5                 mov     edx, [ebp+var_D4]
.text:000054DB                 push    edx
.text:000054DC                 mov     eax, [ebp+var_D8]
.text:000054E2                 push    eax
.text:000054E3                 call    ?FreqBench@@YGJ_KIPAUIBenchPrintCallback@@_NAA_KAAI@Z ; FreqBench(unsigned __int64,uint,IBenchPrintCallback *,bool,unsigned __int64 &,uint &)
.text:000054E8                 mov     [ebp+var_2E4], eax
.text:000054EE                 cmp     [ebp+var_2E4], 0
.text:000054F5                 jz      short loc_552C
.text:000054F7                 mov     ecx, [ebp+var_2E4]
.text:000054FD                 mov     [ebp+var_404], ecx
.text:00005503                 mov     byte ptr [ebp+var_4], 0
.text:00005507                 lea     ecx, [ebp+var_148] ; this
.text:0000550D                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00005512                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00005519                 lea     ecx, [ebp+var_60] ; this
.text:0000551C                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:00005521                 mov     eax, [ebp+var_404]
.text:00005527                 jmp     loc_5D6B
.text:0000552C ; ---------------------------------------------------------------------------
.text:0000552C
.text:0000552C loc_552C:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1625j
.text:0000552C                 lea     ecx, [ebp+var_29C] ; this
.text:00005532                 call    ?NewLine@CBenchCallbackToPrint@@QAEXXZ ; CBenchCallbackToPrint::NewLine(void)
.text:00005537                 cmp     [ebp+var_2D0], 2
.text:0000553E                 jnz     short loc_555E
.text:00005540                 lea     edx, [ebp+var_D8]
.text:00005546                 push    edx
.text:00005547                 mov     eax, dword ptr [ebp+var_2B8+4]
.text:0000554D                 push    eax
.text:0000554E                 mov     ecx, dword ptr [ebp+var_2B8]
.text:00005554                 push    ecx
.text:00005555                 mov     edx, [ebp+var_30]
.text:00005558                 push    edx
.text:00005559                 call    ?SetComplexCommands@@YGXI_KAA_K@Z ; SetComplexCommands(uint,unsigned __int64,unsigned __int64 &)
.text:0000555E
.text:0000555E loc_555E:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+166Ej
.text:0000555E                 jmp     loc_547F
.text:00005563 ; ---------------------------------------------------------------------------
.text:00005563
.text:00005563 loc_5563:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+15C5j
.text:00005563                 lea     ecx, [ebp+var_29C] ; this
.text:00005569                 call    ?NewLine@CBenchCallbackToPrint@@QAEXXZ ; CBenchCallbackToPrint::NewLine(void)
.text:0000556E                 mov     eax, dword ptr [ebp+var_2B8+4]
.text:00005574                 push    eax
.text:00005575                 mov     ecx, dword ptr [ebp+var_2B8]
.text:0000557B                 push    ecx             ; unsigned __int64
.text:0000557C                 push    1               ; bool
.text:0000557E                 lea     ecx, [ebp+var_29C] ; this
.text:00005584                 call    ?SetFreq@CBenchCallbackToPrint@@UAEJ_N_K@Z ; CBenchCallbackToPrint::SetFreq(bool,unsigned __int64)
.text:00005589                 lea     edx, [ebp+var_29C]
.text:0000558F                 push    edx             ; CBenchCallbackToPrint *
.text:00005590                 mov     eax, [ebp+arg_0]
.text:00005593                 push    eax             ; int
.text:00005594                 mov     ecx, [ebp+var_110]
.text:0000559A                 push    ecx             ; int
.text:0000559B                 movzx   edx, [ebp+var_115]
.text:000055A2                 push    edx             ; char
.text:000055A3                 mov     eax, [ebp+var_218]
.text:000055A9                 push    eax             ; int
.text:000055AA                 mov     ecx, [ebp+var_D4]
.text:000055B0                 push    ecx             ; int
.text:000055B1                 mov     edx, [ebp+var_D8]
.text:000055B7                 push    edx             ; int
.text:000055B8                 call    ?TotalBench@@YGJ_KI_NIPAUIBenchPrintCallback@@PAUCBenchCallbackToPrint@@@Z ; TotalBench(unsigned __int64,uint,bool,uint,IBenchPrintCallback *,CBenchCallbackToPrint *)
.text:000055BD                 mov     [ebp+var_2CC], eax
.text:000055C3                 mov     eax, [ebp+var_2CC]
.text:000055C9                 mov     [ebp+var_2E8], eax
.text:000055CF                 cmp     [ebp+var_2E8], 0
.text:000055D6                 jz      short loc_560D
.text:000055D8                 mov     ecx, [ebp+var_2E8]
.text:000055DE                 mov     [ebp+var_408], ecx
.text:000055E4                 mov     byte ptr [ebp+var_4], 0
.text:000055E8                 lea     ecx, [ebp+var_148] ; this
.text:000055EE                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:000055F3                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000055FA                 lea     ecx, [ebp+var_60] ; this
.text:000055FD                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:00005602                 mov     eax, [ebp+var_408]
.text:00005608                 jmp     loc_5D6B
.text:0000560D ; ---------------------------------------------------------------------------
.text:0000560D
.text:0000560D loc_560D:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1706j
.text:0000560D                 mov     edx, dword ptr [ebp+var_2B8+4]
.text:00005613                 push    edx             ; int
.text:00005614                 mov     eax, dword ptr [ebp+var_2B8]
.text:0000561A                 push    eax             ; int
.text:0000561B                 push    1               ; char
.text:0000561D                 lea     ecx, [ebp+var_284]
.text:00005623                 push    ecx             ; int
.text:00005624                 lea     edx, [ebp+var_29C]
.text:0000562A                 push    edx             ; CBenchCallbackToPrint *
.text:0000562B                 mov     eax, [ebp+arg_0]
.text:0000562E                 push    eax             ; int
.text:0000562F                 push    20000h          ; int
.text:00005634                 mov     ecx, [ebp+var_218]
.text:0000563A                 push    ecx             ; int
.text:0000563B                 mov     edx, [ebp+var_D4]
.text:00005641                 push    edx             ; int
.text:00005642                 mov     eax, [ebp+var_D8]
.text:00005648                 push    eax             ; int
.text:00005649                 call    ?TotalBench_Hash@@YGJ_KIIPAUIBenchPrintCallback@@PAUCBenchCallbackToPrint@@PAUCTotalBenchRes@@_N0@Z ; TotalBench_Hash(unsigned __int64,uint,uint,IBenchPrintCallback *,CBenchCallbackToPrint *,CTotalBenchRes *,bool,unsigned __int64)
.text:0000564E                 mov     [ebp+var_2CC], eax
.text:00005654                 mov     ecx, [ebp+var_2CC]
.text:0000565A                 mov     [ebp+var_2EC], ecx
.text:00005660                 cmp     [ebp+var_2EC], 0
.text:00005667                 jz      short loc_569E
.text:00005669                 mov     edx, [ebp+var_2EC]
.text:0000566F                 mov     [ebp+var_40C], edx
.text:00005675                 mov     byte ptr [ebp+var_4], 0
.text:00005679                 lea     ecx, [ebp+var_148] ; this
.text:0000567F                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00005684                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000568B                 lea     ecx, [ebp+var_60] ; this
.text:0000568E                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:00005693                 mov     eax, [ebp+var_40C]
.text:00005699                 jmp     loc_5D6B
.text:0000569E ; ---------------------------------------------------------------------------
.text:0000569E
.text:0000569E loc_569E:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1797j
.text:0000569E                 lea     ecx, [ebp+var_29C] ; this
.text:000056A4                 call    ?NewLine@CBenchCallbackToPrint@@QAEXXZ ; CBenchCallbackToPrint::NewLine(void)
.text:000056A9                 push    0Ch             ; unsigned int
.text:000056AB                 push    offset $SG71734 ; "CPU"
.text:000056B0                 mov     eax, [ebp+var_2A4]
.text:000056B6                 push    eax             ; struct IBenchPrintCallback *
.text:000056B7                 call    ?PrintLeft@@YGXAAUIBenchPrintCallback@@PBDI@Z ; PrintLeft(IBenchPrintCallback &,char const *,uint)
.text:000056BC                 mov     ecx, dword ptr [ebp+var_2B8]
.text:000056C2                 mov     [ebp+var_304], ecx
.text:000056C8                 mov     edx, dword ptr [ebp+var_2B8+4]
.text:000056CE                 mov     [ebp+var_300], edx
.text:000056D4                 lea     eax, [ebp+var_2F4]
.text:000056DA                 push    eax
.text:000056DB                 lea     ecx, [ebp+var_304]
.text:000056E1                 push    ecx
.text:000056E2                 push    0
.text:000056E4                 mov     edx, [ebp+arg_0]
.text:000056E7                 push    edx
.text:000056E8                 mov     eax, [ebp+var_218]
.text:000056EE                 push    eax
.text:000056EF                 mov     ecx, [ebp+var_D4]
.text:000056F5                 push    ecx
.text:000056F6                 mov     edx, [ebp+var_D8]
.text:000056FC                 push    edx
.text:000056FD                 call    ?FreqBench@@YGJ_KIPAUIBenchPrintCallback@@_NAA_KAAI@Z ; FreqBench(unsigned __int64,uint,IBenchPrintCallback *,bool,unsigned __int64 &,uint &)
.text:00005702                 mov     [ebp+var_30C], eax
.text:00005708                 cmp     [ebp+var_30C], 0
.text:0000570F                 jz      short loc_5746
.text:00005711                 mov     eax, [ebp+var_30C]
.text:00005717                 mov     [ebp+var_410], eax
.text:0000571D                 mov     byte ptr [ebp+var_4], 0
.text:00005721                 lea     ecx, [ebp+var_148] ; this
.text:00005727                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:0000572C                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00005733                 lea     ecx, [ebp+var_60] ; this
.text:00005736                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:0000573B                 mov     eax, [ebp+var_410]
.text:00005741                 jmp     loc_5D6B
.text:00005746 ; ---------------------------------------------------------------------------
.text:00005746
.text:00005746 loc_5746:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+183Fj
.text:00005746                 lea     ecx, [ebp+var_29C] ; this
.text:0000574C                 call    ?NewLine@CBenchCallbackToPrint@@QAEXXZ ; CBenchCallbackToPrint::NewLine(void)
.text:00005751                 jmp     loc_542C
.text:00005756 ; ---------------------------------------------------------------------------
.text:00005756
.text:00005756 loc_5756:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1574j
.text:00005756                 jmp     loc_5B92
.text:0000575B ; ---------------------------------------------------------------------------
.text:0000575B
.text:0000575B loc_575B:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1535j
.text:0000575B                 mov     [ebp+var_30D], 1
.text:00005762                 push    offset $SG71743 ; "LZMA"
.text:00005767                 lea     ecx, [ebp+var_148] ; this
.text:0000576D                 call    ?IsEqualTo_Ascii_NoCase@AString@@QBE_NPBD@Z ; AString::IsEqualTo_Ascii_NoCase(char const *)
.text:00005772                 movzx   ecx, al
.text:00005775                 test    ecx, ecx
.text:00005777                 jnz     loc_584D
.text:0000577D                 mov     [ebp+var_314], 0
.text:00005787                 jmp     short loc_5798
.text:00005789 ; ---------------------------------------------------------------------------
.text:00005789
.text:00005789 loc_5789:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1978j
.text:00005789                 mov     edx, [ebp+var_314]
.text:0000578F                 add     edx, 1
.text:00005792                 mov     [ebp+var_314], edx
.text:00005798
.text:00005798 loc_5798:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+18B7j
.text:00005798                 cmp     [ebp+var_314], 11h
.text:0000579F                 jnb     loc_584D
.text:000057A5                 mov     eax, [ebp+var_314]
.text:000057AB                 imul    eax, 18h
.text:000057AE                 add     eax, offset _g_Bench
.text:000057B3                 mov     [ebp+var_318], eax
.text:000057B9                 mov     ecx, [ebp+var_318]
.text:000057BF                 mov     edx, [ecx+14h]
.text:000057C2                 push    edx
.text:000057C3                 lea     ecx, [ebp+var_328]
.text:000057C9                 call    ??0AString@@QAE@PBD@Z ; AString::AString(char const *)
.text:000057CE                 mov     byte ptr [ebp+var_4], 0Ah
.text:000057D2                 lea     ecx, [ebp+var_148]
.text:000057D8                 call    ??BAString@@QBEPBDXZ ; AString::operator char const *(void)
.text:000057DD                 push    eax
.text:000057DE                 mov     eax, [ebp+var_318]
.text:000057E4                 mov     ecx, [eax+14h]
.text:000057E7                 push    ecx
.text:000057E8                 call    ?AreSameMethodNames@@YG_NPBD0@Z ; AreSameMethodNames(char const *,char const *)
.text:000057ED                 movzx   edx, al
.text:000057F0                 test    edx, edx
.text:000057F2                 jz      short loc_5839
.text:000057F4                 mov     eax, [ebp+var_318]
.text:000057FA                 mov     ecx, [eax+8]
.text:000057FD                 mov     [ebp+var_294], ecx
.text:00005803                 mov     edx, [ebp+var_318]
.text:00005809                 mov     eax, [edx+0Ch]
.text:0000580C                 mov     [ebp+var_290], eax
.text:00005812                 mov     ecx, [ebp+var_318]
.text:00005818                 mov     edx, [ecx+10h]
.text:0000581B                 mov     [ebp+var_28C], edx
.text:00005821                 mov     [ebp+var_30D], 0
.text:00005828                 mov     byte ptr [ebp+var_4], 6
.text:0000582C                 lea     ecx, [ebp+var_328] ; this
.text:00005832                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00005837                 jmp     short loc_584D
.text:00005839 ; ---------------------------------------------------------------------------
.text:00005839
.text:00005839 loc_5839:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1922j
.text:00005839                 mov     byte ptr [ebp+var_4], 6
.text:0000583D                 lea     ecx, [ebp+var_328] ; this
.text:00005843                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00005848                 jmp     loc_5789
.text:0000584D ; ---------------------------------------------------------------------------
.text:0000584D
.text:0000584D loc_584D:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+18A7j
.text:0000584D                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+18CFj ...
.text:0000584D                 movzx   eax, [ebp+var_30D]
.text:00005854                 test    eax, eax
.text:00005856                 jz      short loc_5863
.text:00005858                 lea     ecx, [ebp+var_298] ; this
.text:0000585E                 call    ?SetLzmaCompexity@CBenchProps@@QAEXXZ ; CBenchProps::SetLzmaCompexity(void)
.text:00005863
.text:00005863 loc_5863:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1986j
.text:00005863                 mov     [ebp+var_68], 0
.text:0000586A                 jmp     short loc_5875
.text:0000586C ; ---------------------------------------------------------------------------
.text:0000586C
.text:0000586C loc_586C:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool):loc_5B8Dj
.text:0000586C                 mov     ecx, [ebp+var_68]
.text:0000586F                 add     ecx, 1
.text:00005872                 mov     [ebp+var_68], ecx
.text:00005875
.text:00005875 loc_5875:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+199Aj
.text:00005875                 mov     edx, [ebp+var_68]
.text:00005878                 cmp     edx, [ebp+arg_C]
.text:0000587B                 jnb     loc_5B92
.text:00005881                 mov     [ebp+var_330], 16h
.text:0000588B                 cmp     [ebp+var_110], 400000h
.text:00005895                 sbb     eax, eax
.text:00005897                 and     eax, 0FFFFFFFCh
.text:0000589A                 add     eax, 16h
.text:0000589D                 mov     [ebp+var_334], eax
.text:000058A3                 movzx   ecx, [ebp+arg_10]
.text:000058A7                 test    ecx, ecx
.text:000058A9                 jnz     short loc_58B5
.text:000058AB                 mov     [ebp+var_334], 1Fh
.text:000058B5
.text:000058B5 loc_58B5:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+19D9j
.text:000058B5                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1A12j
.text:000058B5                 mov     edx, 1
.text:000058BA                 mov     ecx, [ebp+var_334]
.text:000058C0                 shl     edx, cl
.text:000058C2                 cmp     edx, [ebp+var_110]
.text:000058C8                 jbe     short loc_58E4
.text:000058CA                 cmp     [ebp+var_334], 0
.text:000058D1                 jbe     short loc_58E4
.text:000058D3                 mov     eax, [ebp+var_334]
.text:000058D9                 sub     eax, 1
.text:000058DC                 mov     [ebp+var_334], eax
.text:000058E2                 jmp     short loc_58B5
.text:000058E4 ; ---------------------------------------------------------------------------
.text:000058E4
.text:000058E4 loc_58E4:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+19F8j
.text:000058E4                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1A01j
.text:000058E4                 jmp     short loc_58F5
.text:000058E6 ; ---------------------------------------------------------------------------
.text:000058E6
.text:000058E6 loc_58E6:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1CB8j
.text:000058E6                 mov     ecx, [ebp+var_334]
.text:000058EC                 add     ecx, 1
.text:000058EF                 mov     [ebp+var_334], ecx
.text:000058F5
.text:000058F5 loc_58F5:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool):loc_58E4j
.text:000058F5                 mov     edx, 1
.text:000058FA                 mov     ecx, [ebp+var_334]
.text:00005900                 shl     edx, cl
.text:00005902                 cmp     edx, [ebp+var_110]
.text:00005908                 ja      loc_5B8D
.text:0000590E                 lea     eax, [ebp+var_348]
.text:00005914                 push    eax             ; char *
.text:00005915                 mov     ecx, [ebp+var_334]
.text:0000591B                 push    ecx             ; unsigned int
.text:0000591C                 call    ?ConvertUInt32ToString@@YGXIPAD@Z ; ConvertUInt32ToString(uint,char *)
.text:00005921                 lea     edx, [ebp+var_348]
.text:00005927                 push    edx             ; char *
.text:00005928                 call    ?MyStringLen@@YGIPBD@Z ; MyStringLen(char const *)
.text:0000592D                 mov     [ebp+var_350], eax
.text:00005933                 mov     eax, [ebp+var_350]
.text:00005939                 mov     [ebp+eax+var_348], 3Ah ; ':'
.text:00005941                 mov     ecx, [ebp+var_350]
.text:00005947                 add     ecx, 1
.text:0000594A                 mov     [ebp+var_350], ecx
.text:00005950                 mov     edx, [ebp+var_350]
.text:00005956                 mov     [ebp+edx+var_348], 0
.text:0000595E                 push    4               ; unsigned int
.text:00005960                 lea     eax, [ebp+var_348]
.text:00005966                 push    eax             ; char *
.text:00005967                 mov     ecx, [ebp+var_2A4]
.text:0000596D                 push    ecx             ; struct IBenchPrintCallback *
.text:0000596E                 call    ?PrintLeft@@YGXAAUIBenchPrintCallback@@PBDI@Z ; PrintLeft(IBenchPrintCallback &,char const *,uint)
.text:00005973                 mov     edx, 1
.text:00005978                 mov     ecx, [ebp+var_334]
.text:0000597E                 shl     edx, cl
.text:00005980                 mov     [ebp+var_240], edx
.text:00005986                 lea     eax, [ebp+var_60]
.text:00005989                 push    eax
.text:0000598A                 lea     ecx, [ebp+var_378]
.text:00005990                 call    ??0COneMethodInfo@@QAE@ABV0@@Z ; COneMethodInfo::COneMethodInfo(COneMethodInfo const &)
.text:00005995                 mov     byte ptr [ebp+var_4], 0Bh
.text:00005999                 push    offset $SG71772 ; "LZMA"
.text:0000599E                 lea     ecx, [ebp+var_36C]
.text:000059A4                 call    ??BAString@@QBEPBDXZ ; AString::operator char const *(void)
.text:000059A9                 push    eax             ; char *
.text:000059AA                 call    ?StringsAreEqualNoCase_Ascii@@YG_NPBD0@Z ; StringsAreEqualNoCase_Ascii(char const *,char const *)
.text:000059AF                 movzx   ecx, al
.text:000059B2                 test    ecx, ecx
.text:000059B4                 jz      loc_5A7D
.text:000059BA                 mov     edx, [ebp+var_334]
.text:000059C0                 push    edx             ; unsigned int
.text:000059C1                 lea     ecx, [ebp+var_390] ; this
.text:000059C7                 call    ??0CPropVariant@NCOM@NWindows@@QAE@I@Z ; NWindows::NCOM::CPropVariant::CPropVariant(uint)
.text:000059CC                 mov     byte ptr [ebp+var_4], 0Ch
.text:000059D0                 push    offset $SG71777
.text:000059D5                 lea     ecx, [ebp+var_41C]
.text:000059DB                 call    ??0UString@@QAE@PB_W@Z ; UString::UString(wchar_t const *)
.text:000059E0                 mov     byte ptr [ebp+var_4], 0Dh
.text:000059E4                 lea     eax, [ebp+var_390]
.text:000059EA                 push    eax             ; struct tagPROPVARIANT *
.text:000059EB                 lea     ecx, [ebp+var_41C]
.text:000059F1                 push    ecx             ; struct UString *
.text:000059F2                 lea     ecx, [ebp+var_378] ; this
.text:000059F8                 call    ?ParseMethodFromPROPVARIANT@COneMethodInfo@@QAEJABVUString@@ABUtagPROPVARIANT@@@Z ; COneMethodInfo::ParseMethodFromPROPVARIANT(UString const &,tagPROPVARIANT const &)
.text:000059FD                 mov     dword ptr [ebp+var_39C+4], eax
.text:00005A03                 mov     byte ptr [ebp+var_4], 0Ch
.text:00005A07                 lea     ecx, [ebp+var_41C] ; this
.text:00005A0D                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00005A12                 cmp     dword ptr [ebp+var_39C+4], 0
.text:00005A19                 jz      short loc_5A6E
.text:00005A1B                 mov     edx, dword ptr [ebp+var_39C+4]
.text:00005A21                 mov     [ebp+var_420], edx
.text:00005A27                 mov     byte ptr [ebp+var_4], 0Bh
.text:00005A2B                 lea     ecx, [ebp+var_390] ; this
.text:00005A31                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:00005A36                 mov     byte ptr [ebp+var_4], 6
.text:00005A3A                 lea     ecx, [ebp+var_378] ; this
.text:00005A40                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:00005A45                 mov     byte ptr [ebp+var_4], 0
.text:00005A49                 lea     ecx, [ebp+var_148] ; this
.text:00005A4F                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00005A54                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00005A5B                 lea     ecx, [ebp+var_60] ; this
.text:00005A5E                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:00005A63                 mov     eax, [ebp+var_420]
.text:00005A69                 jmp     loc_5D6B
.text:00005A6E ; ---------------------------------------------------------------------------
.text:00005A6E
.text:00005A6E loc_5A6E:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1B49j
.text:00005A6E                 mov     byte ptr [ebp+var_4], 0Bh
.text:00005A72                 lea     ecx, [ebp+var_390] ; this
.text:00005A78                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:00005A7D
.text:00005A7D loc_5A7D:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1AE4j
.text:00005A7D                 mov     eax, [ebp+var_240]
.text:00005A83                 mov     dword ptr [ebp+var_39C], eax
.text:00005A89                 cmp     dword ptr [ebp+var_39C], 40000h
.text:00005A93                 jb      short loc_5AA7
.text:00005A95                 mov     ecx, dword ptr [ebp+var_39C]
.text:00005A9B                 add     ecx, 10000h
.text:00005AA1                 mov     dword ptr [ebp+var_39C], ecx
.text:00005AA7
.text:00005AA7 loc_5AA7:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1BC3j
.text:00005AA7                 lea     edx, [ebp+var_298]
.text:00005AAD                 push    edx             ; CBenchProps *
.text:00005AAE                 lea     eax, [ebp+var_29C]
.text:00005AB4                 push    eax             ; int
.text:00005AB5                 mov     ecx, [ebp+arg_0]
.text:00005AB8                 push    ecx             ; int
.text:00005AB9                 push    1Eh
.text:00005ABB                 mov     edx, dword ptr [ebp+var_39C]
.text:00005AC1                 push    edx             ; unsigned __int64
.text:00005AC2                 lea     eax, [ebp+var_378]
.text:00005AC8                 push    eax             ; int
.text:00005AC9                 mov     ecx, [ebp+var_218]
.text:00005ACF                 push    ecx             ; int
.text:00005AD0                 push    1               ; char
.text:00005AD2                 mov     edx, [ebp+var_D4]
.text:00005AD8                 push    edx             ; int
.text:00005AD9                 mov     eax, [ebp+var_D8]
.text:00005ADF                 push    eax             ; int
.text:00005AE0                 call    ?MethodBench@@YGJ_K_NIABVCOneMethodInfo@@IIPAUIBenchPrintCallback@@PAUIBenchCallback@@PAUCBenchProps@@@Z ; MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)
.text:00005AE5                 mov     [ebp+var_3A0], eax
.text:00005AEB                 mov     ecx, [ebp+var_2A4]
.text:00005AF1                 mov     edx, [ecx]
.text:00005AF3                 mov     esi, esp
.text:00005AF5                 mov     ecx, [ebp+var_2A4]
.text:00005AFB                 mov     eax, [edx+4]
.text:00005AFE                 call    eax
.text:00005B00                 cmp     esi, esp
.text:00005B02                 call    __RTC_CheckEsp
.text:00005B07                 mov     ecx, [ebp+var_3A0]
.text:00005B0D                 mov     [ebp+var_3A4], ecx
.text:00005B13                 cmp     [ebp+var_3A4], 0
.text:00005B1A                 jz      short loc_5B60
.text:00005B1C                 mov     edx, [ebp+var_3A4]
.text:00005B22                 mov     [ebp+var_424], edx
.text:00005B28                 mov     byte ptr [ebp+var_4], 6
.text:00005B2C                 lea     ecx, [ebp+var_378] ; this
.text:00005B32                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:00005B37                 mov     byte ptr [ebp+var_4], 0
.text:00005B3B                 lea     ecx, [ebp+var_148] ; this
.text:00005B41                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00005B46                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00005B4D                 lea     ecx, [ebp+var_60] ; this
.text:00005B50                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:00005B55                 mov     eax, [ebp+var_424]
.text:00005B5B                 jmp     loc_5D6B
.text:00005B60 ; ---------------------------------------------------------------------------
.text:00005B60
.text:00005B60 loc_5B60:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1C4Aj
.text:00005B60                 movzx   eax, [ebp+arg_10]
.text:00005B64                 test    eax, eax
.text:00005B66                 jnz     short loc_5B79
.text:00005B68                 mov     byte ptr [ebp+var_4], 6
.text:00005B6C                 lea     ecx, [ebp+var_378] ; this
.text:00005B72                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:00005B77                 jmp     short loc_5B8D
.text:00005B79 ; ---------------------------------------------------------------------------
.text:00005B79
.text:00005B79 loc_5B79:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1C96j
.text:00005B79                 mov     byte ptr [ebp+var_4], 6
.text:00005B7D                 lea     ecx, [ebp+var_378] ; this
.text:00005B83                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:00005B88                 jmp     loc_58E6
.text:00005B8D ; ---------------------------------------------------------------------------
.text:00005B8D
.text:00005B8D loc_5B8D:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1A38j
.text:00005B8D                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1CA7j
.text:00005B8D                 jmp     loc_586C
.text:00005B92 ; ---------------------------------------------------------------------------
.text:00005B92
.text:00005B92 loc_5B92:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool):loc_5756j
.text:00005B92                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+19ABj
.text:00005B92                 mov     ecx, [ebp+var_238]
.text:00005B98                 add     ecx, [ebp+Size]
.text:00005B9E                 push    ecx             ; Size
.text:00005B9F                 push    2Dh ; '-'       ; char
.text:00005BA1                 mov     edx, [ebp+var_2A4]
.text:00005BA7                 push    edx             ; int
.text:00005BA8                 call    ?PrintChars@@YGXAAUIBenchPrintCallback@@DI@Z ; PrintChars(IBenchPrintCallback &,char,uint)
.text:00005BAD                 movzx   eax, [ebp+var_20D]
.text:00005BB4                 test    eax, eax
.text:00005BB6                 jz      short loc_5BEF
.text:00005BB8                 mov     esi, esp
.text:00005BBA                 mov     ecx, ds:_kSep
.text:00005BC0                 push    ecx
.text:00005BC1                 mov     edx, [ebp+var_2A4]
.text:00005BC7                 mov     eax, [edx]
.text:00005BC9                 mov     ecx, [ebp+var_2A4]
.text:00005BCF                 mov     edx, [eax]
.text:00005BD1                 call    edx
.text:00005BD3                 cmp     esi, esp
.text:00005BD5                 call    __RTC_CheckEsp
.text:00005BDA                 mov     eax, [ebp+Size]
.text:00005BE0                 push    eax             ; Size
.text:00005BE1                 push    2Dh ; '-'       ; char
.text:00005BE3                 mov     ecx, [ebp+var_2A4]
.text:00005BE9                 push    ecx             ; int
.text:00005BEA                 call    ?PrintChars@@YGXAAUIBenchPrintCallback@@DI@Z ; PrintChars(IBenchPrintCallback &,char,uint)
.text:00005BEF
.text:00005BEF loc_5BEF:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1CE6j
.text:00005BEF                 mov     edx, [ebp+var_2A4]
.text:00005BF5                 mov     eax, [edx]
.text:00005BF7                 mov     esi, esp
.text:00005BF9                 mov     ecx, [ebp+var_2A4]
.text:00005BFF                 mov     edx, [eax+4]
.text:00005C02                 call    edx
.text:00005C04                 cmp     esi, esp
.text:00005C06                 call    __RTC_CheckEsp
.text:00005C0B                 movzx   eax, [ebp+var_20D]
.text:00005C12                 test    eax, eax
.text:00005C14                 jz      loc_5CC2
.text:00005C1A                 mov     ecx, [ebp+var_238]
.text:00005C20                 push    ecx             ; unsigned int
.text:00005C21                 push    offset $SG71789 ; "Avr:"
.text:00005C26                 mov     edx, [ebp+var_2A4]
.text:00005C2C                 push    edx             ; struct IBenchPrintCallback *
.text:00005C2D                 call    ?PrintLeft@@YGXAAUIBenchPrintCallback@@PBDI@Z ; PrintLeft(IBenchPrintCallback &,char const *,uint)
.text:00005C32                 lea     eax, [ebp+var_284]
.text:00005C38                 push    eax
.text:00005C39                 mov     ecx, dword ptr [ebp+var_2B8+4]
.text:00005C3F                 push    ecx
.text:00005C40                 mov     edx, dword ptr [ebp+var_2B8]
.text:00005C46                 push    edx
.text:00005C47                 movzx   eax, [ebp+var_2A9]
.text:00005C4E                 push    eax
.text:00005C4F                 mov     ecx, [ebp+var_2A4]
.text:00005C55                 push    ecx
.text:00005C56                 call    ?PrintTotals@@YGXAAUIBenchPrintCallback@@_N_KABUCTotalBenchRes@@@Z ; PrintTotals(IBenchPrintCallback &,bool,unsigned __int64,CTotalBenchRes const &)
.text:00005C5B                 mov     esi, esp
.text:00005C5D                 mov     edx, ds:_kSep
.text:00005C63                 push    edx
.text:00005C64                 mov     eax, [ebp+var_2A4]
.text:00005C6A                 mov     edx, [eax]
.text:00005C6C                 mov     ecx, [ebp+var_2A4]
.text:00005C72                 mov     eax, [edx]
.text:00005C74                 call    eax
.text:00005C76                 cmp     esi, esp
.text:00005C78                 call    __RTC_CheckEsp
.text:00005C7D                 lea     ecx, [ebp+var_264]
.text:00005C83                 push    ecx
.text:00005C84                 mov     edx, dword ptr [ebp+var_2B8+4]
.text:00005C8A                 push    edx
.text:00005C8B                 mov     eax, dword ptr [ebp+var_2B8]
.text:00005C91                 push    eax
.text:00005C92                 movzx   ecx, [ebp+var_2A9]
.text:00005C99                 push    ecx
.text:00005C9A                 mov     edx, [ebp+var_2A4]
.text:00005CA0                 push    edx
.text:00005CA1                 call    ?PrintTotals@@YGXAAUIBenchPrintCallback@@_N_KABUCTotalBenchRes@@@Z ; PrintTotals(IBenchPrintCallback &,bool,unsigned __int64,CTotalBenchRes const &)
.text:00005CA6                 mov     eax, [ebp+var_2A4]
.text:00005CAC                 mov     edx, [eax]
.text:00005CAE                 mov     esi, esp
.text:00005CB0                 mov     ecx, [ebp+var_2A4]
.text:00005CB6                 mov     eax, [edx+4]
.text:00005CB9                 call    eax
.text:00005CBB                 cmp     esi, esp
.text:00005CBD                 call    __RTC_CheckEsp
.text:00005CC2
.text:00005CC2 loc_5CC2:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1D44j
.text:00005CC2                 mov     ecx, [ebp+var_238]
.text:00005CC8                 push    ecx             ; unsigned int
.text:00005CC9                 push    offset $SG71790 ; "Tot:"
.text:00005CCE                 mov     edx, [ebp+var_2A4]
.text:00005CD4                 push    edx             ; struct IBenchPrintCallback *
.text:00005CD5                 call    ?PrintLeft@@YGXAAUIBenchPrintCallback@@PBDI@Z ; PrintLeft(IBenchPrintCallback &,char const *,uint)
.text:00005CDA                 lea     eax, [ebp+var_264]
.text:00005CE0                 push    eax             ; struct CTotalBenchRes *
.text:00005CE1                 lea     ecx, [ebp+var_284]
.text:00005CE7                 push    ecx             ; struct CTotalBenchRes *
.text:00005CE8                 lea     ecx, [ebp+var_3C8] ; this
.text:00005CEE                 call    ?SetSum@CTotalBenchRes@@QAEXABU1@0@Z ; CTotalBenchRes::SetSum(CTotalBenchRes const &,CTotalBenchRes const &)
.text:00005CF3                 lea     edx, [ebp+var_3C8]
.text:00005CF9                 push    edx
.text:00005CFA                 mov     eax, dword ptr [ebp+var_2B8+4]
.text:00005D00                 push    eax
.text:00005D01                 mov     ecx, dword ptr [ebp+var_2B8]
.text:00005D07                 push    ecx
.text:00005D08                 movzx   edx, [ebp+var_2A9]
.text:00005D0F                 push    edx
.text:00005D10                 mov     eax, [ebp+var_2A4]
.text:00005D16                 push    eax
.text:00005D17                 call    ?PrintTotals@@YGXAAUIBenchPrintCallback@@_N_KABUCTotalBenchRes@@@Z ; PrintTotals(IBenchPrintCallback &,bool,unsigned __int64,CTotalBenchRes const &)
.text:00005D1C                 mov     ecx, [ebp+var_2A4]
.text:00005D22                 mov     edx, [ecx]
.text:00005D24                 mov     esi, esp
.text:00005D26                 mov     ecx, [ebp+var_2A4]
.text:00005D2C                 mov     eax, [edx+4]
.text:00005D2F                 call    eax
.text:00005D31                 cmp     esi, esp
.text:00005D33                 call    __RTC_CheckEsp
.text:00005D38                 jmp     loc_4EA3
.text:00005D3D ; ---------------------------------------------------------------------------
.text:00005D3D
.text:00005D3D loc_5D3D:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+FE9j
.text:00005D3D                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1009j ...
.text:00005D3D                 mov     [ebp+var_428], 0
.text:00005D47                 mov     byte ptr [ebp+var_4], 0
.text:00005D4B                 lea     ecx, [ebp+var_148] ; this
.text:00005D51                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00005D56                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00005D5D                 lea     ecx, [ebp+var_60] ; this
.text:00005D60                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:00005D65                 mov     eax, [ebp+var_428]
.text:00005D6B
.text:00005D6B loc_5D6B:                               ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+50j
.text:00005D6B                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1B8j ...
.text:00005D6B                 push    edx
.text:00005D6C                 mov     ecx, ebp
.text:00005D6E                 push    eax
.text:00005D6F                 lea     edx, $LN187
.text:00005D75                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00005D7A                 pop     eax
.text:00005D7B                 pop     edx
.text:00005D7C                 mov     ecx, [ebp+var_C]
.text:00005D7F                 mov     large fs:0, ecx
.text:00005D86                 pop     ecx
.text:00005D87                 pop     edi
.text:00005D88                 pop     esi
.text:00005D89                 mov     ecx, [ebp+var_10]
.text:00005D8C                 xor     ecx, ebp
.text:00005D8E                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text:00005D93                 add     esp, 438h
.text:00005D99                 cmp     ebp, esp
.text:00005D9B                 call    __RTC_CheckEsp
.text:00005DA0                 mov     esp, ebp
.text:00005DA2                 pop     ebp
.text:00005DA3                 retn    14h
.text:00005DA3 ?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z endp
.text:00005DA3
.text:00005DA3 ; ---------------------------------------------------------------------------
.text:00005DA6                 align 4
.text:00005DA8 $LN187          dd 1Bh                  ; DATA XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1E9Fo
.text:00005DAC                 dd offset $LN186
.text:00005DB0 $LN186          dd 0FFFFFFDCh, 4        ; DATA XREF: .text:00005DACo
.text:00005DB8                 dd offset $LN158        ; "numThreadsSpecified"
.text:00005DBC                 dd 0FFFFFFD0h, 4
.text:00005DC4                 dd offset $LN159        ; "testTime"
.text:00005DC8                 dd 0FFFFFFA0h, 24h
.text:00005DD0                 dd offset $LN160        ; "method"
.text:00005DD4                 dd 0FFFFFF80h, 10h
.text:00005DDC                 dd offset $LN161        ; "propVariant"
.text:00005DE0                 dd 0FFFFFF6Ch, 0Ch
.text:00005DE8                 dd offset $LN162        ; "name"
.text:00005DEC                 dd 0FFFFFF54h, 0Ch
.text:00005DF4                 dd offset $LN163        ; "s"
.text:00005DF8                 dd 0FFFFFF38h, 0Ch
.text:00005E00                 dd offset $LN164        ; "s"
.text:00005E04                 dd 0FFFFFF28h, 8
.text:00005E0C                 dd offset $LN165        ; "complexInCommands"
.text:00005E10                 dd 0FFFFFEF0h, 4
.text:00005E18                 dd offset $LN166        ; "dict"
.text:00005E1C                 dd 0FFFFFED4h, 10h
.text:00005E24                 dd offset $LN167        ; "benchProps"
.text:00005E28                 dd 0FFFFFEB8h, 0Ch
.text:00005E30                 dd offset $LN168        ; "methodName"
.text:00005E34                 dd 0FFFFFEA8h, 8
.text:00005E3C                 dd offset $LN169        ; "hashID"
.text:00005E40                 dd 0FFFFFE80h, 0Ch
.text:00005E48                 dd offset $LN170        ; "s"
.text:00005E4C                 dd 0FFFFFE6Ch, 0Ch
.text:00005E54                 dd offset $LN171        ; "hProp"
.text:00005E58                 dd 0FFFFFE50h, 4
.text:00005E60                 dd offset $LN172        ; "speedTotals"
.text:00005E64                 dd 0FFFFFE20h, 10h
.text:00005E6C                 dd offset $LN173        ; "s"
.text:00005E70                 dd 0FFFFFE00h, 8
.text:00005E78                 dd offset $LN174        ; "speed"
.text:00005E7C                 dd 0FFFFFD64h, 80h
.text:00005E84                 dd offset $LN175        ; "callback"
.text:00005E88                 dd 0FFFFFD48h, 8
.text:00005E90                 dd offset $LN176        ; "cpuFreq"
.text:00005E94                 dd 0FFFFFD24h, 4
.text:00005E9C                 dd offset $LN177        ; "resVal"
.text:00005EA0                 dd 0FFFFFD0Ch, 4
.text:00005EA8                 dd offset $LN178        ; "resVal"
.text:00005EAC                 dd 0FFFFFCFCh, 8
.text:00005EB4                 dd offset $LN179        ; "cpuFreqLastTemp"
.text:00005EB8                 dd 0FFFFFCD8h, 0Ch
.text:00005EC0                 dd offset $LN180        ; "s"
.text:00005EC4                 dd 0FFFFFCB8h, 10h
.text:00005ECC                 dd offset $LN181        ; "s"
.text:00005ED0                 dd 0FFFFFC88h, 24h
.text:00005ED8                 dd offset $LN182        ; "method2"
.text:00005EDC                 dd 0FFFFFC70h, 10h
.text:00005EE4                 dd offset $LN183        ; "propVariant"
.text:00005EE8                 dd 0FFFFFC38h, 20h
.text:00005EF0                 dd offset $LN184        ; "midRes"
.text:00005EF4 $LN184          db 'midRes',0           ; DATA XREF: .text:00005EF0o
.text:00005EFB $LN183          db 'propVariant',0      ; DATA XREF: .text:00005EE4o
.text:00005F07 $LN182          db 'method2',0          ; DATA XREF: .text:00005ED8o
.text:00005F0F $LN181          db 's',0                ; DATA XREF: .text:00005ECCo
.text:00005F11 $LN180          db 's',0                ; DATA XREF: .text:00005EC0o
.text:00005F13 $LN179          db 'cpuFreqLastTemp',0  ; DATA XREF: .text:00005EB4o
.text:00005F23 $LN178          db 'resVal',0           ; DATA XREF: .text:00005EA8o
.text:00005F2A $LN177          db 'resVal',0           ; DATA XREF: .text:00005E9Co
.text:00005F31 $LN176          db 'cpuFreq',0          ; DATA XREF: .text:00005E90o
.text:00005F39 $LN175          db 'callback',0         ; DATA XREF: .text:00005E84o
.text:00005F42 $LN174          db 'speed',0            ; DATA XREF: .text:00005E78o
.text:00005F48 $LN173          db 's',0                ; DATA XREF: .text:00005E6Co
.text:00005F4A $LN172          db 'speedTotals',0      ; DATA XREF: .text:00005E60o
.text:00005F56 $LN171          db 'hProp',0            ; DATA XREF: .text:00005E54o
.text:00005F5C $LN170          db 's',0                ; DATA XREF: .text:00005E48o
.text:00005F5E $LN169          db 'hashID',0           ; DATA XREF: .text:00005E3Co
.text:00005F65 $LN168          db 'methodName',0       ; DATA XREF: .text:00005E30o
.text:00005F70 $LN167          db 'benchProps',0       ; DATA XREF: .text:00005E24o
.text:00005F7B $LN166          db 'dict',0             ; DATA XREF: .text:00005E18o
.text:00005F80 $LN165          db 'complexInCommands',0 ; DATA XREF: .text:00005E0Co
.text:00005F92 $LN164          db 's',0                ; DATA XREF: .text:00005E00o
.text:00005F94 $LN163          db 's',0                ; DATA XREF: .text:00005DF4o
.text:00005F96 $LN162          db 'name',0             ; DATA XREF: .text:00005DE8o
.text:00005F9B $LN161          db 'propVariant',0      ; DATA XREF: .text:00005DDCo
.text:00005FA7 $LN160          db 'method',0           ; DATA XREF: .text:00005DD0o
.text:00005FAE $LN159          db 'testTime',0         ; DATA XREF: .text:00005DC4o
.text:00005FB7 $LN158          db 'numThreadsSpecified',0 ; DATA XREF: .text:00005DB8o
.text:00005FCB                 align 10h
.text:00005FD0
.text:00005FD0 ; =============== S U B R O U T I N E =======================================
.text:00005FD0
.text:00005FD0 ; Attributes: bp-based frame
.text:00005FD0
.text:00005FD0 ; void __stdcall SetComplexCommands(unsigned int, unsigned __int64, unsigned __int64 &)
.text:00005FD0 ?SetComplexCommands@@YGXI_KAA_K@Z proc near
.text:00005FD0                                         ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+66Cp
.text:00005FD0                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1689p
.text:00005FD0
.text:00005FD0 var_10          = dword ptr -10h
.text:00005FD0 var_C           = dword ptr -0Ch
.text:00005FD0 var_8           = dword ptr -8
.text:00005FD0 var_4           = dword ptr -4
.text:00005FD0 arg_0           = dword ptr  8
.text:00005FD0 arg_4           = dword ptr  0Ch
.text:00005FD0 arg_8           = dword ptr  10h
.text:00005FD0 arg_C           = dword ptr  14h
.text:00005FD0
.text:00005FD0                 push    ebp
.text:00005FD1                 mov     ebp, esp
.text:00005FD3                 sub     esp, 10h
.text:00005FD6                 mov     eax, 0CCCCCCCCh
.text:00005FDB                 mov     [ebp+var_10], eax
.text:00005FDE                 mov     [ebp+var_C], eax
.text:00005FE1                 mov     [ebp+var_8], eax
.text:00005FE4                 mov     [ebp+var_4], eax
.text:00005FE7                 mov     eax, [ebp+arg_C]
.text:00005FEA                 mov     dword ptr [eax], 0
.text:00005FF0                 mov     dword ptr [eax+4], 4
.text:00005FF7                 mov     [ebp+var_8], 1C9C380h
.text:00005FFE                 mov     [ebp+var_4], 0
.text:00006005                 mov     [ebp+var_10], 0A817C800h
.text:0000600C                 mov     [ebp+var_C], 4
.text:00006013                 cmp     [ebp+arg_8], 0
.text:00006017                 ja      short loc_6032
.text:00006019                 jb      short loc_6024
.text:0000601B                 cmp     [ebp+arg_4], 1C9C380h
.text:00006022                 jnb     short loc_6032
.text:00006024
.text:00006024 loc_6024:                               ; CODE XREF: SetComplexCommands(uint,unsigned __int64,unsigned __int64 &)+49j
.text:00006024                 mov     [ebp+arg_4], 1C9C380h
.text:0000602B                 mov     [ebp+arg_8], 0
.text:00006032
.text:00006032 loc_6032:                               ; CODE XREF: SetComplexCommands(uint,unsigned __int64,unsigned __int64 &)+47j
.text:00006032                                         ; SetComplexCommands(uint,unsigned __int64,unsigned __int64 &)+52j
.text:00006032                 cmp     [ebp+arg_8], 4
.text:00006036                 ja      short loc_607C
.text:00006038                 jb      short loc_6043
.text:0000603A                 cmp     [ebp+arg_4], 0A817C800h
.text:00006041                 jnb     short loc_607C
.text:00006043
.text:00006043 loc_6043:                               ; CODE XREF: SetComplexCommands(uint,unsigned __int64,unsigned __int64 &)+68j
.text:00006043                 cmp     [ebp+arg_0], 0
.text:00006047                 jz      short loc_6067
.text:00006049                 mov     ecx, [ebp+arg_0]
.text:0000604C                 xor     edx, edx
.text:0000604E                 mov     eax, [ebp+arg_8]
.text:00006051                 push    eax
.text:00006052                 mov     eax, [ebp+arg_4]
.text:00006055                 push    eax
.text:00006056                 push    edx
.text:00006057                 push    ecx
.text:00006058                 call    __allmul
.text:0000605D                 mov     ecx, [ebp+arg_C]
.text:00006060                 mov     [ecx], eax
.text:00006062                 mov     [ecx+4], edx
.text:00006065                 jmp     short loc_607C
.text:00006067 ; ---------------------------------------------------------------------------
.text:00006067
.text:00006067 loc_6067:                               ; CODE XREF: SetComplexCommands(uint,unsigned __int64,unsigned __int64 &)+77j
.text:00006067                 mov     eax, [ebp+arg_4]
.text:0000606A                 mov     edx, [ebp+arg_8]
.text:0000606D                 mov     cl, 2
.text:0000606F                 call    __aullshr
.text:00006074                 mov     ecx, [ebp+arg_C]
.text:00006077                 mov     [ecx], eax
.text:00006079                 mov     [ecx+4], edx
.text:0000607C
.text:0000607C loc_607C:                               ; CODE XREF: SetComplexCommands(uint,unsigned __int64,unsigned __int64 &)+66j
.text:0000607C                                         ; SetComplexCommands(uint,unsigned __int64,unsigned __int64 &)+71j ...
.text:0000607C                 add     esp, 10h
.text:0000607F                 cmp     ebp, esp
.text:00006081                 call    __RTC_CheckEsp
.text:00006086                 mov     esp, ebp
.text:00006088                 pop     ebp
.text:00006089                 retn    10h
.text:00006089 ?SetComplexCommands@@YGXI_KAA_K@Z endp
.text:00006089
.text:00006089 ; ---------------------------------------------------------------------------
.text:0000608C                 align 10h
.text:00006090
.text:00006090 ; =============== S U B R O U T I N E =======================================
.text:00006090
.text:00006090 ; Attributes: bp-based frame
.text:00006090
.text:00006090 ; int __stdcall MethodBench(int, int, char, int, int, unsigned __int64, int, int, CBenchProps *)
.text:00006090 ?MethodBench@@YGJ_K_NIABVCOneMethodInfo@@IIPAUIBenchPrintCallback@@PAUIBenchCallback@@PAUCBenchProps@@@Z proc near
.text:00006090                                         ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+7E3p
.text:00006090                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1C10p ...
.text:00006090
.text:00006090 var_204         = byte ptr -204h
.text:00006090 var_201         = byte ptr -201h
.text:00006090 var_200         = dword ptr -200h
.text:00006090 var_1FC         = dword ptr -1FCh
.text:00006090 var_1F8         = dword ptr -1F8h
.text:00006090 var_1F4         = dword ptr -1F4h
.text:00006090 var_1F0         = dword ptr -1F0h
.text:00006090 var_1EC         = dword ptr -1ECh
.text:00006090 var_1E8         = dword ptr -1E8h
.text:00006090 var_1E4         = dword ptr -1E4h
.text:00006090 var_1E0         = dword ptr -1E0h
.text:00006090 var_1DC         = dword ptr -1DCh
.text:00006090 var_1D8         = dword ptr -1D8h
.text:00006090 var_1D4         = dword ptr -1D4h
.text:00006090 var_1D0         = dword ptr -1D0h
.text:00006090 var_1CC         = dword ptr -1CCh
.text:00006090 var_1C8         = dword ptr -1C8h
.text:00006090 var_1C4         = dword ptr -1C4h
.text:00006090 var_1C0         = dword ptr -1C0h
.text:00006090 var_1BC         = dword ptr -1BCh
.text:00006090 var_1B8         = dword ptr -1B8h
.text:00006090 var_1B4         = dword ptr -1B4h
.text:00006090 var_1B0         = dword ptr -1B0h
.text:00006090 var_1AC         = dword ptr -1ACh
.text:00006090 var_1A8         = dword ptr -1A8h
.text:00006090 var_1A4         = dword ptr -1A4h
.text:00006090 var_1A0         = dword ptr -1A0h
.text:00006090 var_19C         = dword ptr -19Ch
.text:00006090 var_198         = dword ptr -198h
.text:00006090 var_194         = dword ptr -194h
.text:00006090 var_190         = dword ptr -190h
.text:00006090 var_18C         = dword ptr -18Ch
.text:00006090 var_188         = dword ptr -188h
.text:00006090 var_184         = dword ptr -184h
.text:00006090 var_180         = dword ptr -180h
.text:00006090 var_17C         = dword ptr -17Ch
.text:00006090 var_178         = dword ptr -178h
.text:00006090 var_174         = dword ptr -174h
.text:00006090 var_170         = dword ptr -170h
.text:00006090 var_16C         = dword ptr -16Ch
.text:00006090 var_168         = dword ptr -168h
.text:00006090 var_164         = dword ptr -164h
.text:00006090 var_15C         = byte ptr -15Ch
.text:00006090 var_13C         = dword ptr -13Ch
.text:00006090 var_138         = dword ptr -138h
.text:00006090 var_134         = dword ptr -134h
.text:00006090 var_130         = dword ptr -130h
.text:00006090 var_12C         = dword ptr -12Ch
.text:00006090 var_128         = dword ptr -128h
.text:00006090 var_120         = dword ptr -120h
.text:00006090 var_11C         = dword ptr -11Ch
.text:00006090 var_118         = dword ptr -118h
.text:00006090 var_114         = dword ptr -114h
.text:00006090 var_110         = dword ptr -110h
.text:00006090 var_10C         = dword ptr -10Ch
.text:00006090 var_108         = dword ptr -108h
.text:00006090 var_100         = byte ptr -100h
.text:00006090 var_E8          = dword ptr -0E8h
.text:00006090 var_E4          = byte ptr -0E4h
.text:00006090 var_DC          = dword ptr -0DCh
.text:00006090 var_D8          = dword ptr -0D8h
.text:00006090 var_D0          = byte ptr -0D0h
.text:00006090 var_C4          = dword ptr -0C4h
.text:00006090 var_C0          = dword ptr -0C0h
.text:00006090 var_B8          = byte ptr -0B8h
.text:00006090 var_A4          = dword ptr -0A4h
.text:00006090 var_A0          = dword ptr -0A0h
.text:00006090 var_98          = byte ptr -98h
.text:00006090 var_84          = dword ptr -84h
.text:00006090 var_80          = dword ptr -80h
.text:00006090 var_7C          = dword ptr -7Ch
.text:00006090 var_74          = dword ptr -74h
.text:00006090 var_6C          = dword ptr -6Ch
.text:00006090 var_61          = byte ptr -61h
.text:00006090 var_5C          = dword ptr -5Ch
.text:00006090 var_58          = dword ptr -58h
.text:00006090 var_50          = dword ptr -50h
.text:00006090 var_44          = qword ptr -44h
.text:00006090 var_34          = byte ptr -34h
.text:00006090 var_28          = byte ptr -28h
.text:00006090 var_C           = dword ptr -0Ch
.text:00006090 var_4           = dword ptr -4
.text:00006090 arg_0           = dword ptr  8
.text:00006090 arg_4           = dword ptr  0Ch
.text:00006090 arg_8           = byte ptr  10h
.text:00006090 arg_C           = dword ptr  14h
.text:00006090 arg_10          = dword ptr  18h
.text:00006090 arg_14          = qword ptr  1Ch
.text:00006090 arg_1C          = dword ptr  24h
.text:00006090 arg_20          = dword ptr  28h
.text:00006090 arg_24          = dword ptr  2Ch
.text:00006090
.text:00006090                 push    ebp
.text:00006091                 mov     ebp, esp
.text:00006093                 push    0FFFFFFFFh
.text:00006095                 push    offset __ehhandler$?MethodBench@@YGJ_K_NIABVCOneMethodInfo@@IIPAUIBenchPrintCallback@@PAUIBenchCallback@@PAUCBenchProps@@@Z
.text:0000609A                 mov     eax, large fs:0
.text:000060A0                 push    eax
.text:000060A1                 sub     esp, 1F8h
.text:000060A7                 push    esi
.text:000060A8                 push    edi
.text:000060A9                 lea     edi, [ebp+var_204]
.text:000060AF                 mov     ecx, 7Eh ; '~'
.text:000060B4                 mov     eax, 0CCCCCCCCh
.text:000060B9                 rep stosd
.text:000060BB                 mov     eax, dword ptr ds:___security_cookie
.text:000060C0                 xor     eax, ebp
.text:000060C2                 push    eax
.text:000060C3                 lea     eax, [ebp+var_C]
.text:000060C6                 mov     large fs:0, eax
.text:000060CC                 mov     eax, [ebp+arg_10]
.text:000060CF                 push    eax
.text:000060D0                 lea     ecx, [ebp+var_34]
.text:000060D3                 call    ??0COneMethodInfo@@QAE@ABV0@@Z ; COneMethodInfo::COneMethodInfo(COneMethodInfo const &)
.text:000060D8                 mov     [ebp+var_4], 0
.text:000060DF                 lea     ecx, [ebp+var_50]
.text:000060E2                 push    ecx             ; unsigned int *
.text:000060E3                 lea     edx, [ebp+var_44]
.text:000060E6                 push    edx             ; unsigned __int64 *
.text:000060E7                 lea     eax, [ebp+var_28]
.text:000060EA                 push    eax             ; struct AString *
.text:000060EB                 call    ?FindMethod@@YG_NABVAString@@AA_KAAI@Z ; FindMethod(AString const &,unsigned __int64 &,uint &)
.text:000060F0                 movzx   ecx, al
.text:000060F3                 test    ecx, ecx
.text:000060F5                 jnz     short loc_611B
.text:000060F7                 mov     [ebp+var_1AC], 80004001h
.text:00006101                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00006108                 lea     ecx, [ebp+var_34] ; this
.text:0000610B                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:00006110                 mov     eax, [ebp+var_1AC]
.text:00006116                 jmp     loc_6FC8
.text:0000611B ; ---------------------------------------------------------------------------
.text:0000611B
.text:0000611B loc_611B:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+65j
.text:0000611B                 cmp     [ebp+var_50], 1
.text:0000611F                 jz      short loc_6145
.text:00006121                 mov     [ebp+var_1B0], 80070057h
.text:0000612B                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00006132                 lea     ecx, [ebp+var_34] ; this
.text:00006135                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:0000613A                 mov     eax, [ebp+var_1B0]
.text:00006140                 jmp     loc_6FC8
.text:00006145 ; ---------------------------------------------------------------------------
.text:00006145
.text:00006145 loc_6145:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+8Fj
.text:00006145                 mov     [ebp+var_58], 1
.text:0000614C                 mov     [ebp+var_5C], 1
.text:00006153                 mov     edx, [ebp+arg_C]
.text:00006156                 mov     [ebp+var_58], edx
.text:00006159                 movzx   eax, [ebp+arg_8]
.text:0000615D                 test    eax, eax
.text:0000615F                 jz      short loc_61B2
.text:00006161                 cmp     dword ptr [ebp+var_44], 30101h
.text:00006168                 jnz     short loc_61B2
.text:0000616A                 cmp     dword ptr [ebp+var_44+4], 0
.text:0000616E                 jnz     short loc_61B2
.text:00006170                 lea     ecx, [ebp+var_61]
.text:00006173                 push    ecx             ; bool *
.text:00006174                 lea     ecx, [ebp+var_34] ; this
.text:00006177                 call    ?Get_Lzma_NumThreads@CMethodProps@@QBEIAA_N@Z ; CMethodProps::Get_Lzma_NumThreads(bool &)
.text:0000617C                 mov     [ebp+var_6C], eax
.text:0000617F                 movzx   edx, [ebp+var_61]
.text:00006183                 test    edx, edx
.text:00006185                 jnz     short loc_6197
.text:00006187                 cmp     [ebp+arg_C], 1
.text:0000618B                 jnz     short loc_6197
.text:0000618D                 push    1               ; unsigned int
.text:0000618F                 lea     ecx, [ebp+var_34] ; this
.text:00006192                 call    ?AddProp_NumThreads@CMethodProps@@QAEXI@Z ; CMethodProps::AddProp_NumThreads(uint)
.text:00006197
.text:00006197 loc_6197:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+F5j
.text:00006197                                         ; MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+FBj
.text:00006197                 cmp     [ebp+arg_C], 1
.text:0000619B                 jbe     short loc_61B2
.text:0000619D                 cmp     [ebp+var_6C], 1
.text:000061A1                 jbe     short loc_61B2
.text:000061A3                 mov     eax, [ebp+arg_C]
.text:000061A6                 shr     eax, 1
.text:000061A8                 mov     [ebp+var_58], eax
.text:000061AB                 mov     [ebp+var_5C], 2
.text:000061B2
.text:000061B2 loc_61B2:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+CFj
.text:000061B2                                         ; MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+D8j ...
.text:000061B2                 mov     ecx, [ebp+var_58]
.text:000061B5                 push    ecx             ; unsigned int
.text:000061B6                 lea     ecx, [ebp+var_74] ; this
.text:000061B9                 call    ??0CBenchEncoders@@QAE@I@Z ; CBenchEncoders::CBenchEncoders(uint)
.text:000061BE                 mov     byte ptr [ebp+var_4], 1
.text:000061C2                 mov     edx, [ebp+var_74]
.text:000061C5                 mov     [ebp+var_7C], edx
.text:000061C8                 mov     [ebp+var_80], 0
.text:000061CF                 jmp     short loc_61DA
.text:000061D1 ; ---------------------------------------------------------------------------
.text:000061D1
.text:000061D1 loc_61D1:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *):loc_64F9j
.text:000061D1                 mov     eax, [ebp+var_80]
.text:000061D4                 add     eax, 1
.text:000061D7                 mov     [ebp+var_80], eax
.text:000061DA
.text:000061DA loc_61DA:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+13Fj
.text:000061DA                 mov     ecx, [ebp+var_80]
.text:000061DD                 cmp     ecx, [ebp+var_58]
.text:000061E0                 jnb     loc_64FE
.text:000061E6                 mov     edx, [ebp+var_80]
.text:000061E9                 imul    edx, 118h
.text:000061EF                 add     edx, [ebp+var_7C]
.text:000061F2                 mov     [ebp+var_84], edx
.text:000061F8                 mov     eax, [ebp+var_80]
.text:000061FB                 neg     eax
.text:000061FD                 sbb     eax, eax
.text:000061FF                 not     eax
.text:00006201                 and     eax, [ebp+arg_20]
.text:00006204                 mov     ecx, [ebp+var_84]
.text:0000620A                 mov     [ecx+0B4h], eax
.text:00006210                 mov     edx, [ebp+var_84]
.text:00006216                 mov     eax, [ebp+arg_1C]
.text:00006219                 mov     [edx+0B8h], eax
.text:0000621F                 lea     ecx, [ebp+var_98] ; this
.text:00006225                 call    ??0CCreatedCoder@@QAE@XZ ; CCreatedCoder::CCreatedCoder(void)
.text:0000622A                 mov     byte ptr [ebp+var_4], 2
.text:0000622E                 lea     ecx, [ebp+var_98]
.text:00006234                 push    ecx
.text:00006235                 mov     edx, [ebp+var_84]
.text:0000623B                 add     edx, 10h
.text:0000623E                 push    edx
.text:0000623F                 push    1
.text:00006241                 mov     eax, dword ptr [ebp+var_44+4]
.text:00006244                 push    eax
.text:00006245                 mov     ecx, dword ptr [ebp+var_44]
.text:00006248                 push    ecx
.text:00006249                 call    ?CreateCoder@@YGJ_K_NAAV?$CMyComPtr@UICompressFilter@@@@AAUCCreatedCoder@@@Z ; CreateCoder(unsigned __int64,bool,CMyComPtr<ICompressFilter> &,CCreatedCoder &)
.text:0000624E                 mov     [ebp+var_A0], eax
.text:00006254                 cmp     [ebp+var_A0], 0
.text:0000625B                 jz      short loc_629E
.text:0000625D                 mov     edx, [ebp+var_A0]
.text:00006263                 mov     [ebp+var_1B4], edx
.text:00006269                 mov     byte ptr [ebp+var_4], 1
.text:0000626D                 lea     ecx, [ebp+var_98] ; this
.text:00006273                 call    ??1CCreatedCoder@@QAE@XZ ; CCreatedCoder::~CCreatedCoder(void)
.text:00006278                 mov     byte ptr [ebp+var_4], 0
.text:0000627C                 lea     ecx, [ebp+var_74] ; this
.text:0000627F                 call    ??1CBenchEncoders@@QAE@XZ ; CBenchEncoders::~CBenchEncoders(void)
.text:00006284                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000628B                 lea     ecx, [ebp+var_34] ; this
.text:0000628E                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:00006293                 mov     eax, [ebp+var_1B4]
.text:00006299                 jmp     loc_6FC8
.text:0000629E ; ---------------------------------------------------------------------------
.text:0000629E
.text:0000629E loc_629E:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+1CBj
.text:0000629E                 lea     eax, [ebp+var_98]
.text:000062A4                 push    eax
.text:000062A5                 mov     ecx, [ebp+var_84]
.text:000062AB                 add     ecx, 0Ch
.text:000062AE                 call    ??4?$CMyComPtr@UICompressCoder@@@@QAEPAUICompressCoder@@ABV0@@Z ; CMyComPtr<ICompressCoder>::operator=(CMyComPtr<ICompressCoder> const &)
.text:000062B3                 mov     ecx, [ebp+var_84]
.text:000062B9                 add     ecx, 0Ch
.text:000062BC                 call    ??7?$CMyComPtr@UICompressCoder@@@@QBE_NXZ ; CMyComPtr<ICompressCoder>::operator!(void)
.text:000062C1                 movzx   ecx, al
.text:000062C4                 test    ecx, ecx
.text:000062C6                 jz      short loc_631C
.text:000062C8                 mov     ecx, [ebp+var_84]
.text:000062CE                 add     ecx, 10h
.text:000062D1                 call    ??7?$CMyComPtr@UICompressFilter@@@@QBE_NXZ ; CMyComPtr<ICompressFilter>::operator!(void)
.text:000062D6                 movzx   edx, al
.text:000062D9                 test    edx, edx
.text:000062DB                 jz      short loc_631C
.text:000062DD                 mov     [ebp+var_1B8], 80004001h
.text:000062E7                 mov     byte ptr [ebp+var_4], 1
.text:000062EB                 lea     ecx, [ebp+var_98] ; this
.text:000062F1                 call    ??1CCreatedCoder@@QAE@XZ ; CCreatedCoder::~CCreatedCoder(void)
.text:000062F6                 mov     byte ptr [ebp+var_4], 0
.text:000062FA                 lea     ecx, [ebp+var_74] ; this
.text:000062FD                 call    ??1CBenchEncoders@@QAE@XZ ; CBenchEncoders::~CBenchEncoders(void)
.text:00006302                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00006309                 lea     ecx, [ebp+var_34] ; this
.text:0000630C                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:00006311                 mov     eax, [ebp+var_1B8]
.text:00006317                 jmp     loc_6FC8
.text:0000631C ; ---------------------------------------------------------------------------
.text:0000631C
.text:0000631C loc_631C:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+236j
.text:0000631C                                         ; MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+24Bj
.text:0000631C                 mov     byte ptr [ebp+var_4], 1
.text:00006320                 lea     ecx, [ebp+var_98] ; this
.text:00006326                 call    ??1CCreatedCoder@@QAE@XZ ; CCreatedCoder::~CCreatedCoder(void)
.text:0000632B                 mov     eax, [ebp+arg_24]
.text:0000632E                 mov     ecx, 1Eh
.text:00006333                 cmp     ecx, [eax+4]
.text:00006336                 sbb     edx, edx
.text:00006338                 neg     edx
.text:0000633A                 mov     eax, [ebp+var_84]
.text:00006340                 mov     [eax+74h], dl
.text:00006343                 mov     ecx, [ebp+arg_24]
.text:00006346                 mov     edx, [ecx+8]
.text:00006349                 mov     eax, [ebp+arg_24]
.text:0000634C                 add     edx, [eax+0Ch]
.text:0000634F                 mov     ecx, 1Eh
.text:00006354                 cmp     ecx, edx
.text:00006356                 sbb     edx, edx
.text:00006358                 neg     edx
.text:0000635A                 mov     eax, [ebp+var_84]
.text:00006360                 mov     [eax+75h], dl
.text:00006363                 push    10h             ; Size
.text:00006365                 push    0               ; Val
.text:00006367                 mov     ecx, [ebp+var_84]
.text:0000636D                 add     ecx, 54h ; 'T'
.text:00006370                 push    ecx             ; Dst
.text:00006371                 call    _memset
.text:00006376                 add     esp, 0Ch
.text:00006379                 push    20h ; ' '       ; Size
.text:0000637B                 push    0               ; Val
.text:0000637D                 mov     edx, [ebp+var_84]
.text:00006383                 add     edx, 34h ; '4'
.text:00006386                 push    edx             ; Dst
.text:00006387                 call    _memset
.text:0000638C                 add     esp, 0Ch
.text:0000638F                 push    10h             ; Size
.text:00006391                 push    0               ; Val
.text:00006393                 mov     eax, [ebp+var_84]
.text:00006399                 add     eax, 64h ; 'd'
.text:0000639C                 push    eax             ; Dst
.text:0000639D                 call    _memset
.text:000063A2                 add     esp, 0Ch
.text:000063A5                 mov     [ebp+var_A4], 0
.text:000063AF                 jmp     short loc_63C0
.text:000063B1 ; ---------------------------------------------------------------------------
.text:000063B1
.text:000063B1 loc_63B1:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+464j
.text:000063B1                 mov     ecx, [ebp+var_A4]
.text:000063B7                 add     ecx, 1
.text:000063BA                 mov     [ebp+var_A4], ecx
.text:000063C0
.text:000063C0 loc_63C0:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+31Fj
.text:000063C0                 mov     edx, [ebp+var_A4]
.text:000063C6                 cmp     edx, [ebp+var_5C]
.text:000063C9                 jnb     loc_64F9
.text:000063CF                 lea     ecx, [ebp+var_B8] ; this
.text:000063D5                 call    ??0CCreatedCoder@@QAE@XZ ; CCreatedCoder::CCreatedCoder(void)
.text:000063DA                 mov     byte ptr [ebp+var_4], 3
.text:000063DE                 mov     eax, [ebp+var_A4]
.text:000063E4                 mov     ecx, [ebp+var_84]
.text:000063EA                 lea     edx, [ecx+eax*4+98h]
.text:000063F1                 mov     [ebp+var_C0], edx
.text:000063F7                 lea     eax, [ebp+var_B8]
.text:000063FD                 push    eax
.text:000063FE                 mov     ecx, [ebp+var_84]
.text:00006404                 add     ecx, 0A0h ; 'á'
.text:0000640A                 push    ecx
.text:0000640B                 push    0
.text:0000640D                 mov     edx, dword ptr [ebp+var_44+4]
.text:00006410                 push    edx
.text:00006411                 mov     eax, dword ptr [ebp+var_44]
.text:00006414                 push    eax
.text:00006415                 call    ?CreateCoder@@YGJ_K_NAAV?$CMyComPtr@UICompressFilter@@@@AAUCCreatedCoder@@@Z ; CreateCoder(unsigned __int64,bool,CMyComPtr<ICompressFilter> &,CCreatedCoder &)
.text:0000641A                 mov     [ebp+var_C4], eax
.text:00006420                 cmp     [ebp+var_C4], 0
.text:00006427                 jz      short loc_646A
.text:00006429                 mov     ecx, [ebp+var_C4]
.text:0000642F                 mov     [ebp+var_1BC], ecx
.text:00006435                 mov     byte ptr [ebp+var_4], 1
.text:00006439                 lea     ecx, [ebp+var_B8] ; this
.text:0000643F                 call    ??1CCreatedCoder@@QAE@XZ ; CCreatedCoder::~CCreatedCoder(void)
.text:00006444                 mov     byte ptr [ebp+var_4], 0
.text:00006448                 lea     ecx, [ebp+var_74] ; this
.text:0000644B                 call    ??1CBenchEncoders@@QAE@XZ ; CBenchEncoders::~CBenchEncoders(void)
.text:00006450                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00006457                 lea     ecx, [ebp+var_34] ; this
.text:0000645A                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:0000645F                 mov     eax, [ebp+var_1BC]
.text:00006465                 jmp     loc_6FC8
.text:0000646A ; ---------------------------------------------------------------------------
.text:0000646A
.text:0000646A loc_646A:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+397j
.text:0000646A                 lea     edx, [ebp+var_B8]
.text:00006470                 push    edx
.text:00006471                 mov     ecx, [ebp+var_C0]
.text:00006477                 call    ??4?$CMyComPtr@UICompressCoder@@@@QAEPAUICompressCoder@@ABV0@@Z ; CMyComPtr<ICompressCoder>::operator=(CMyComPtr<ICompressCoder> const &)
.text:0000647C                 mov     ecx, [ebp+var_84]
.text:00006482                 add     ecx, 0A0h ; 'á'
.text:00006488                 call    ??7?$CMyComPtr@UICompressFilter@@@@QBE_NXZ ; CMyComPtr<ICompressFilter>::operator!(void)
.text:0000648D                 movzx   eax, al
.text:00006490                 test    eax, eax
.text:00006492                 jz      short loc_64E5
.text:00006494                 mov     ecx, [ebp+var_C0]
.text:0000649A                 call    ??7?$CMyComPtr@UICompressCoder@@@@QBE_NXZ ; CMyComPtr<ICompressCoder>::operator!(void)
.text:0000649F                 movzx   ecx, al
.text:000064A2                 test    ecx, ecx
.text:000064A4                 jz      short loc_64E5
.text:000064A6                 mov     [ebp+var_1C0], 80004001h
.text:000064B0                 mov     byte ptr [ebp+var_4], 1
.text:000064B4                 lea     ecx, [ebp+var_B8] ; this
.text:000064BA                 call    ??1CCreatedCoder@@QAE@XZ ; CCreatedCoder::~CCreatedCoder(void)
.text:000064BF                 mov     byte ptr [ebp+var_4], 0
.text:000064C3                 lea     ecx, [ebp+var_74] ; this
.text:000064C6                 call    ??1CBenchEncoders@@QAE@XZ ; CBenchEncoders::~CBenchEncoders(void)
.text:000064CB                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000064D2                 lea     ecx, [ebp+var_34] ; this
.text:000064D5                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:000064DA                 mov     eax, [ebp+var_1C0]
.text:000064E0                 jmp     loc_6FC8
.text:000064E5 ; ---------------------------------------------------------------------------
.text:000064E5
.text:000064E5 loc_64E5:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+402j
.text:000064E5                                         ; MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+414j
.text:000064E5                 mov     byte ptr [ebp+var_4], 1
.text:000064E9                 lea     ecx, [ebp+var_B8] ; this
.text:000064EF                 call    ??1CCreatedCoder@@QAE@XZ ; CCreatedCoder::~CCreatedCoder(void)
.text:000064F4                 jmp     loc_63B1
.text:000064F9 ; ---------------------------------------------------------------------------
.text:000064F9
.text:000064F9 loc_64F9:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+339j
.text:000064F9                 jmp     loc_61D1
.text:000064FE ; ---------------------------------------------------------------------------
.text:000064FE
.text:000064FE loc_64FE:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+150j
.text:000064FE                 lea     ecx, [ebp+var_D0]
.text:00006504                 call    ??0CBaseRandomGenerator@@QAE@XZ ; CBaseRandomGenerator::CBaseRandomGenerator(void)
.text:00006509                 lea     ecx, [ebp+var_D0] ; this
.text:0000650F                 call    ?Init@CBaseRandomGenerator@@QAEXXZ ; CBaseRandomGenerator::Init(void)
.text:00006514                 mov     [ebp+var_80], 0
.text:0000651B                 jmp     short loc_6526
.text:0000651D ; ---------------------------------------------------------------------------
.text:0000651D
.text:0000651D loc_651D:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *):loc_65CDj
.text:0000651D                 mov     edx, [ebp+var_80]
.text:00006520                 add     edx, 1
.text:00006523                 mov     [ebp+var_80], edx
.text:00006526
.text:00006526 loc_6526:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+48Bj
.text:00006526                 mov     eax, [ebp+var_80]
.text:00006529                 cmp     eax, [ebp+var_58]
.text:0000652C                 jnb     loc_65D2
.text:00006532                 mov     ecx, [ebp+var_80]
.text:00006535                 imul    ecx, 118h
.text:0000653B                 add     ecx, [ebp+var_7C]
.text:0000653E                 mov     [ebp+var_D8], ecx
.text:00006544                 lea     edx, [ebp+var_34]
.text:00006547                 push    edx
.text:00006548                 mov     ecx, [ebp+var_D8]
.text:0000654E                 add     ecx, 0ECh ; '8'
.text:00006554                 call    ??4COneMethodInfo@@QAEAAV0@ABV0@@Z ; COneMethodInfo::operator=(COneMethodInfo const &)
.text:00006559                 mov     eax, [ebp+var_D8]
.text:0000655F                 mov     ecx, dword ptr [ebp+arg_14]
.text:00006562                 mov     [eax+110h], ecx
.text:00006568                 lea     edx, [ebp+var_D0]
.text:0000656E                 push    edx             ; struct CBaseRandomGenerator *
.text:0000656F                 mov     eax, dword ptr [ebp+arg_14+4]
.text:00006572                 push    eax             ; unsigned int
.text:00006573                 mov     ecx, dword ptr [ebp+arg_14]
.text:00006576                 push    ecx             ; unsigned int
.text:00006577                 lea     edx, [ebp+var_34]
.text:0000657A                 push    edx             ; struct COneMethodInfo *
.text:0000657B                 mov     ecx, [ebp+var_80]
.text:0000657E                 imul    ecx, 118h
.text:00006584                 add     ecx, [ebp+var_7C] ; this
.text:00006587                 call    ?Init@CEncoderInfo@@QAEJABVCOneMethodInfo@@IIPAVCBaseRandomGenerator@@@Z ; CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)
.text:0000658C                 mov     [ebp+var_DC], eax
.text:00006592                 cmp     [ebp+var_DC], 0
.text:00006599                 jz      short loc_65CD
.text:0000659B                 mov     eax, [ebp+var_DC]
.text:000065A1                 mov     [ebp+var_1C4], eax
.text:000065A7                 mov     byte ptr [ebp+var_4], 0
.text:000065AB                 lea     ecx, [ebp+var_74] ; this
.text:000065AE                 call    ??1CBenchEncoders@@QAE@XZ ; CBenchEncoders::~CBenchEncoders(void)
.text:000065B3                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000065BA                 lea     ecx, [ebp+var_34] ; this
.text:000065BD                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:000065C2                 mov     eax, [ebp+var_1C4]
.text:000065C8                 jmp     loc_6FC8
.text:000065CD ; ---------------------------------------------------------------------------
.text:000065CD
.text:000065CD loc_65CD:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+509j
.text:000065CD                 jmp     loc_651D
.text:000065D2 ; ---------------------------------------------------------------------------
.text:000065D2
.text:000065D2 loc_65D2:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+49Cj
.text:000065D2                 lea     ecx, [ebp+var_100] ; this
.text:000065D8                 call    ??0CBenchProgressStatus@@QAE@XZ ; CBenchProgressStatus::CBenchProgressStatus(void)
.text:000065DD                 mov     byte ptr [ebp+var_4], 4
.text:000065E1                 mov     [ebp+var_E8], 0
.text:000065EB                 mov     [ebp+var_E4], 1
.text:000065F2                 mov     [ebp+var_80], 0
.text:000065F9                 jmp     short loc_6604
.text:000065FB ; ---------------------------------------------------------------------------
.text:000065FB
.text:000065FB loc_65FB:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *):loc_6826j
.text:000065FB                 mov     ecx, [ebp+var_80]
.text:000065FE                 add     ecx, 1
.text:00006601                 mov     [ebp+var_80], ecx
.text:00006604
.text:00006604 loc_6604:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+569j
.text:00006604                 mov     edx, [ebp+var_80]
.text:00006607                 cmp     edx, [ebp+var_58]
.text:0000660A                 jnb     loc_682B
.text:00006610                 mov     eax, [ebp+var_80]
.text:00006613                 imul    eax, 118h
.text:00006619                 add     eax, [ebp+var_7C]
.text:0000661C                 mov     [ebp+var_108], eax
.text:00006622                 mov     ecx, [ebp+arg_4]
.text:00006625                 push    ecx
.text:00006626                 mov     edx, [ebp+arg_0]
.text:00006629                 push    edx
.text:0000662A                 mov     eax, dword ptr [ebp+arg_14]
.text:0000662D                 xor     ecx, ecx
.text:0000662F                 push    ecx
.text:00006630                 push    eax             ; unsigned __int64
.text:00006631                 mov     ecx, [ebp+arg_24] ; this
.text:00006634                 call    ?GeComprCommands@CBenchProps@@QAE_K_K@Z ; CBenchProps::GeComprCommands(unsigned __int64)
.text:00006639                 push    edx
.text:0000663A                 push    eax
.text:0000663B                 call    ?GetNumIterations@@YG_K_K0@Z ; GetNumIterations(unsigned __int64,unsigned __int64)
.text:00006640                 mov     ecx, [ebp+var_108]
.text:00006646                 mov     [ecx+28h], eax
.text:00006649                 mov     [ecx+2Ch], edx
.text:0000664C                 mov     [ebp+var_10C], 0
.text:00006656                 jmp     short loc_6667
.text:00006658 ; ---------------------------------------------------------------------------
.text:00006658
.text:00006658 loc_6658:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+67Bj
.text:00006658                 mov     edx, [ebp+var_10C]
.text:0000665E                 add     edx, 1
.text:00006661                 mov     [ebp+var_10C], edx
.text:00006667
.text:00006667 loc_6667:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+5C6j
.text:00006667                 cmp     [ebp+var_10C], 2
.text:0000666E                 jge     loc_6710
.text:00006674                 push    58h ; 'X'       ; unsigned int
.text:00006676                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0000667B                 add     esp, 4
.text:0000667E                 mov     [ebp+var_1CC], eax
.text:00006684                 mov     byte ptr [ebp+var_4], 5
.text:00006688                 cmp     [ebp+var_1CC], 0
.text:0000668F                 jz      short loc_66A4
.text:00006691                 mov     ecx, [ebp+var_1CC]
.text:00006697                 call    ??0CBenchProgressInfo@@QAE@XZ ; CBenchProgressInfo::CBenchProgressInfo(void)
.text:0000669C                 mov     [ebp+var_1FC], eax
.text:000066A2                 jmp     short loc_66AE
.text:000066A4 ; ---------------------------------------------------------------------------
.text:000066A4
.text:000066A4 loc_66A4:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+5FFj
.text:000066A4                 mov     [ebp+var_1FC], 0
.text:000066AE
.text:000066AE loc_66AE:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+612j
.text:000066AE                 mov     eax, [ebp+var_1FC]
.text:000066B4                 mov     [ebp+var_1C8], eax
.text:000066BA                 mov     byte ptr [ebp+var_4], 4
.text:000066BE                 mov     ecx, [ebp+var_1C8]
.text:000066C4                 mov     [ebp+var_110], ecx
.text:000066CA                 mov     edx, [ebp+var_10C]
.text:000066D0                 mov     eax, [ebp+var_108]
.text:000066D6                 mov     ecx, [ebp+var_110]
.text:000066DC                 mov     [eax+edx*4+14h], ecx
.text:000066E0                 mov     edx, [ebp+var_110]
.text:000066E6                 push    edx
.text:000066E7                 mov     eax, [ebp+var_10C]
.text:000066ED                 mov     ecx, [ebp+var_108]
.text:000066F3                 lea     ecx, [ecx+eax*4+1Ch]
.text:000066F7                 call    ??4?$CMyComPtr@UICompressProgressInfo@@@@QAEPAUICompressProgressInfo@@PAU1@@Z ; CMyComPtr<ICompressProgressInfo>::operator=(ICompressProgressInfo *)
.text:000066FC                 mov     edx, [ebp+var_110]
.text:00006702                 lea     eax, [ebp+var_100]
.text:00006708                 mov     [edx+48h], eax
.text:0000670B                 jmp     loc_6658
.text:00006710 ; ---------------------------------------------------------------------------
.text:00006710
.text:00006710 loc_6710:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+5DEj
.text:00006710                 cmp     [ebp+var_80], 0
.text:00006714                 jnz     short loc_6750
.text:00006716                 mov     ecx, [ebp+var_108]
.text:0000671C                 mov     edx, [ecx+14h]
.text:0000671F                 mov     [ebp+var_114], edx
.text:00006725                 mov     eax, [ebp+var_114]
.text:0000672B                 mov     ecx, [ebp+arg_20]
.text:0000672E                 mov     [eax+50h], ecx
.text:00006731                 mov     edx, [ebp+var_58]
.text:00006734                 xor     eax, eax
.text:00006736                 mov     ecx, [ebp+var_114]
.text:0000673C                 mov     [ecx+38h], edx
.text:0000673F                 mov     [ecx+3Ch], eax
.text:00006742                 mov     ecx, [ebp+var_114]
.text:00006748                 add     ecx, 8          ; this
.text:0000674B                 call    ?SetStartTime@CBenchInfoCalc@@QAEXXZ ; CBenchInfoCalc::SetStartTime(void)
.text:00006750
.text:00006750 loc_6750:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+684j
.text:00006750                 cmp     [ebp+var_58], 1
.text:00006754                 jbe     short loc_67CB
.text:00006756                 mov     edx, [ebp+var_80]
.text:00006759                 shl     edx, 4
.text:0000675C                 imul    edx, 15h
.text:0000675F                 and     edx, 7FFh
.text:00006765                 mov     eax, [ebp+var_108]
.text:0000676B                 mov     [eax+30h], edx
.text:0000676E                 mov     ecx, [ebp+var_108] ; this
.text:00006774                 call    ?CreateEncoderThread@CEncoderInfo@@QAEJXZ ; CEncoderInfo::CreateEncoderThread(void)
.text:00006779                 mov     [ebp+var_118], eax
.text:0000677F                 cmp     [ebp+var_118], 0
.text:00006786                 jz      short loc_67C9
.text:00006788                 mov     ecx, [ebp+var_118]
.text:0000678E                 mov     [ebp+var_1D0], ecx
.text:00006794                 mov     byte ptr [ebp+var_4], 1
.text:00006798                 lea     ecx, [ebp+var_100] ; this
.text:0000679E                 call    ??1CBenchProgressStatus@@QAE@XZ ; CBenchProgressStatus::~CBenchProgressStatus(void)
.text:000067A3                 mov     byte ptr [ebp+var_4], 0
.text:000067A7                 lea     ecx, [ebp+var_74] ; this
.text:000067AA                 call    ??1CBenchEncoders@@QAE@XZ ; CBenchEncoders::~CBenchEncoders(void)
.text:000067AF                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000067B6                 lea     ecx, [ebp+var_34] ; this
.text:000067B9                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:000067BE                 mov     eax, [ebp+var_1D0]
.text:000067C4                 jmp     loc_6FC8
.text:000067C9 ; ---------------------------------------------------------------------------
.text:000067C9
.text:000067C9 loc_67C9:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+6F6j
.text:000067C9                 jmp     short loc_6826
.text:000067CB ; ---------------------------------------------------------------------------
.text:000067CB
.text:000067CB loc_67CB:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+6C4j
.text:000067CB                 mov     ecx, [ebp+var_108] ; this
.text:000067D1                 call    ?Encode@CEncoderInfo@@QAEJXZ ; CEncoderInfo::Encode(void)
.text:000067D6                 mov     [ebp+var_11C], eax
.text:000067DC                 cmp     [ebp+var_11C], 0
.text:000067E3                 jz      short loc_6826
.text:000067E5                 mov     edx, [ebp+var_11C]
.text:000067EB                 mov     [ebp+var_1D4], edx
.text:000067F1                 mov     byte ptr [ebp+var_4], 1
.text:000067F5                 lea     ecx, [ebp+var_100] ; this
.text:000067FB                 call    ??1CBenchProgressStatus@@QAE@XZ ; CBenchProgressStatus::~CBenchProgressStatus(void)
.text:00006800                 mov     byte ptr [ebp+var_4], 0
.text:00006804                 lea     ecx, [ebp+var_74] ; this
.text:00006807                 call    ??1CBenchEncoders@@QAE@XZ ; CBenchEncoders::~CBenchEncoders(void)
.text:0000680C                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00006813                 lea     ecx, [ebp+var_34] ; this
.text:00006816                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:0000681B                 mov     eax, [ebp+var_1D4]
.text:00006821                 jmp     loc_6FC8
.text:00006826 ; ---------------------------------------------------------------------------
.text:00006826
.text:00006826 loc_6826:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *):loc_67C9j
.text:00006826                                         ; MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+753j
.text:00006826                 jmp     loc_65FB
.text:0000682B ; ---------------------------------------------------------------------------
.text:0000682B
.text:0000682B loc_682B:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+57Aj
.text:0000682B                 cmp     [ebp+var_58], 1
.text:0000682F                 jbe     short loc_685E
.text:00006831                 mov     [ebp+var_80], 0
.text:00006838                 jmp     short loc_6843
.text:0000683A ; ---------------------------------------------------------------------------
.text:0000683A
.text:0000683A loc_683A:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+7CCj
.text:0000683A                 mov     eax, [ebp+var_80]
.text:0000683D                 add     eax, 1
.text:00006840                 mov     [ebp+var_80], eax
.text:00006843
.text:00006843 loc_6843:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+7A8j
.text:00006843                 mov     ecx, [ebp+var_80]
.text:00006846                 cmp     ecx, [ebp+var_58]
.text:00006849                 jnb     short loc_685E
.text:0000684B                 mov     ecx, [ebp+var_80]
.text:0000684E                 imul    ecx, 118h
.text:00006854                 add     ecx, [ebp+var_7C] ; this
.text:00006857                 call    ?Wait@CThread@NWindows@@QAEIXZ ; NWindows::CThread::Wait(void)
.text:0000685C                 jmp     short loc_683A
.text:0000685E ; ---------------------------------------------------------------------------
.text:0000685E
.text:0000685E loc_685E:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+79Fj
.text:0000685E                                         ; MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+7B9j
.text:0000685E                 mov     edx, [ebp+var_E8]
.text:00006864                 mov     [ebp+var_120], edx
.text:0000686A                 cmp     [ebp+var_120], 0
.text:00006871                 jz      short loc_68B4
.text:00006873                 mov     eax, [ebp+var_120]
.text:00006879                 mov     [ebp+var_1D8], eax
.text:0000687F                 mov     byte ptr [ebp+var_4], 1
.text:00006883                 lea     ecx, [ebp+var_100] ; this
.text:00006889                 call    ??1CBenchProgressStatus@@QAE@XZ ; CBenchProgressStatus::~CBenchProgressStatus(void)
.text:0000688E                 mov     byte ptr [ebp+var_4], 0
.text:00006892                 lea     ecx, [ebp+var_74] ; this
.text:00006895                 call    ??1CBenchEncoders@@QAE@XZ ; CBenchEncoders::~CBenchEncoders(void)
.text:0000689A                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000068A1                 lea     ecx, [ebp+var_34] ; this
.text:000068A4                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:000068A9                 mov     eax, [ebp+var_1D8]
.text:000068AF                 jmp     loc_6FC8
.text:000068B4 ; ---------------------------------------------------------------------------
.text:000068B4
.text:000068B4 loc_68B4:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+7E1j
.text:000068B4                 lea     ecx, [ebp+var_15C] ; this
.text:000068BA                 call    ??0CBenchInfo@@QAE@XZ ; CBenchInfo::CBenchInfo(void)
.text:000068BF                 lea     ecx, [ebp+var_15C]
.text:000068C5                 push    ecx             ; struct CBenchInfo *
.text:000068C6                 mov     edx, [ebp+var_7C]
.text:000068C9                 mov     ecx, [edx+14h]
.text:000068CC                 add     ecx, 8          ; this
.text:000068CF                 call    ?SetFinishTime@CBenchInfoCalc@@QAEXAAUCBenchInfo@@@Z ; CBenchInfoCalc::SetFinishTime(CBenchInfo &)
.text:000068D4                 mov     [ebp+var_13C], 0
.text:000068DE                 mov     [ebp+var_138], 0
.text:000068E8                 mov     [ebp+var_134], 0
.text:000068F2                 mov     [ebp+var_130], 0
.text:000068FC                 mov     eax, [ebp+var_7C]
.text:000068FF                 mov     ecx, [eax+28h]
.text:00006902                 mov     [ebp+var_12C], ecx
.text:00006908                 mov     edx, [eax+2Ch]
.text:0000690B                 mov     [ebp+var_128], edx
.text:00006911                 mov     [ebp+var_80], 0
.text:00006918                 jmp     short loc_6923
.text:0000691A ; ---------------------------------------------------------------------------
.text:0000691A
.text:0000691A loc_691A:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+8F9j
.text:0000691A                 mov     eax, [ebp+var_80]
.text:0000691D                 add     eax, 1
.text:00006920                 mov     [ebp+var_80], eax
.text:00006923
.text:00006923 loc_6923:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+888j
.text:00006923                 mov     ecx, [ebp+var_80]
.text:00006926                 cmp     ecx, [ebp+var_58]
.text:00006929                 jnb     short loc_698B
.text:0000692B                 mov     edx, [ebp+var_80]
.text:0000692E                 imul    edx, 118h
.text:00006934                 add     edx, [ebp+var_7C]
.text:00006937                 mov     [ebp+var_164], edx
.text:0000693D                 mov     eax, [ebp+var_164]
.text:00006943                 mov     ecx, [eax+0C0h]
.text:00006949                 xor     edx, edx
.text:0000694B                 add     ecx, [ebp+var_13C]
.text:00006951                 adc     edx, [ebp+var_138]
.text:00006957                 mov     [ebp+var_13C], ecx
.text:0000695D                 mov     [ebp+var_138], edx
.text:00006963                 mov     eax, [ebp+var_164]
.text:00006969                 mov     ecx, [eax+0C4h]
.text:0000696F                 xor     edx, edx
.text:00006971                 add     ecx, [ebp+var_134]
.text:00006977                 adc     edx, [ebp+var_130]
.text:0000697D                 mov     [ebp+var_134], ecx
.text:00006983                 mov     [ebp+var_130], edx
.text:00006989                 jmp     short loc_691A
.text:0000698B ; ---------------------------------------------------------------------------
.text:0000698B
.text:0000698B loc_698B:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+899j
.text:0000698B                 mov     esi, esp
.text:0000698D                 push    1
.text:0000698F                 lea     eax, [ebp+var_15C]
.text:00006995                 push    eax
.text:00006996                 mov     ecx, [ebp+arg_20]
.text:00006999                 mov     edx, [ecx]
.text:0000699B                 mov     ecx, [ebp+arg_20]
.text:0000699E                 mov     eax, [edx+4]
.text:000069A1                 call    eax
.text:000069A3                 cmp     esi, esp
.text:000069A5                 call    __RTC_CheckEsp
.text:000069AA                 mov     [ebp+var_168], eax
.text:000069B0                 cmp     [ebp+var_168], 0
.text:000069B7                 jz      short loc_69FA
.text:000069B9                 mov     ecx, [ebp+var_168]
.text:000069BF                 mov     [ebp+var_1DC], ecx
.text:000069C5                 mov     byte ptr [ebp+var_4], 1
.text:000069C9                 lea     ecx, [ebp+var_100] ; this
.text:000069CF                 call    ??1CBenchProgressStatus@@QAE@XZ ; CBenchProgressStatus::~CBenchProgressStatus(void)
.text:000069D4                 mov     byte ptr [ebp+var_4], 0
.text:000069D8                 lea     ecx, [ebp+var_74] ; this
.text:000069DB                 call    ??1CBenchEncoders@@QAE@XZ ; CBenchEncoders::~CBenchEncoders(void)
.text:000069E0                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000069E7                 lea     ecx, [ebp+var_34] ; this
.text:000069EA                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:000069EF                 mov     eax, [ebp+var_1DC]
.text:000069F5                 jmp     loc_6FC8
.text:000069FA ; ---------------------------------------------------------------------------
.text:000069FA
.text:000069FA loc_69FA:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+927j
.text:000069FA                 mov     [ebp+var_E8], 0
.text:00006A04                 mov     [ebp+var_E4], 0
.text:00006A0B                 mov     edx, [ebp+var_58]
.text:00006A0E                 imul    edx, [ebp+var_5C]
.text:00006A12                 mov     [ebp+var_16C], edx
.text:00006A18                 mov     [ebp+var_80], 0
.text:00006A1F                 jmp     short loc_6A2A
.text:00006A21 ; ---------------------------------------------------------------------------
.text:00006A21
.text:00006A21 loc_6A21:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *):loc_6C71j
.text:00006A21                 mov     eax, [ebp+var_80]
.text:00006A24                 add     eax, 1
.text:00006A27                 mov     [ebp+var_80], eax
.text:00006A2A
.text:00006A2A loc_6A2A:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+98Fj
.text:00006A2A                 mov     ecx, [ebp+var_80]
.text:00006A2D                 cmp     ecx, [ebp+var_58]
.text:00006A30                 jnb     loc_6C76
.text:00006A36                 mov     edx, [ebp+var_80]
.text:00006A39                 imul    edx, 118h
.text:00006A3F                 add     edx, [ebp+var_7C]
.text:00006A42                 mov     [ebp+var_170], edx
.text:00006A48                 cmp     [ebp+var_80], 0
.text:00006A4C                 jnz     loc_6AD4
.text:00006A52                 mov     eax, [ebp+arg_4]
.text:00006A55                 push    eax
.text:00006A56                 mov     ecx, [ebp+arg_0]
.text:00006A59                 push    ecx
.text:00006A5A                 mov     edx, [ebp+var_170]
.text:00006A60                 mov     eax, [edx+0C0h]
.text:00006A66                 xor     ecx, ecx
.text:00006A68                 push    ecx
.text:00006A69                 push    eax             ; unsigned __int64
.text:00006A6A                 mov     edx, [ebp+var_170]
.text:00006A70                 mov     eax, [edx+0C4h]
.text:00006A76                 xor     ecx, ecx
.text:00006A78                 push    ecx
.text:00006A79                 push    eax             ; unsigned __int64
.text:00006A7A                 mov     ecx, [ebp+arg_24] ; this
.text:00006A7D                 call    ?GeDecomprCommands@CBenchProps@@QAE_K_K0@Z ; CBenchProps::GeDecomprCommands(unsigned __int64,unsigned __int64)
.text:00006A82                 push    edx
.text:00006A83                 push    eax
.text:00006A84                 call    ?GetNumIterations@@YG_K_K0@Z ; GetNumIterations(unsigned __int64,unsigned __int64)
.text:00006A89                 mov     ecx, [ebp+var_170]
.text:00006A8F                 mov     [ecx+28h], eax
.text:00006A92                 mov     [ecx+2Ch], edx
.text:00006A95                 mov     edx, [ebp+var_170]
.text:00006A9B                 mov     eax, [edx+14h]
.text:00006A9E                 mov     [ebp+var_174], eax
.text:00006AA4                 mov     ecx, [ebp+var_174]
.text:00006AAA                 mov     edx, [ebp+arg_20]
.text:00006AAD                 mov     [ecx+50h], edx
.text:00006AB0                 mov     eax, [ebp+var_16C]
.text:00006AB6                 xor     ecx, ecx
.text:00006AB8                 mov     edx, [ebp+var_174]
.text:00006ABE                 mov     [edx+38h], eax
.text:00006AC1                 mov     [edx+3Ch], ecx
.text:00006AC4                 mov     ecx, [ebp+var_174]
.text:00006ACA                 add     ecx, 8          ; this
.text:00006ACD                 call    ?SetStartTime@CBenchInfoCalc@@QAEXXZ ; CBenchInfoCalc::SetStartTime(void)
.text:00006AD2                 jmp     short loc_6AE9
.text:00006AD4 ; ---------------------------------------------------------------------------
.text:00006AD4
.text:00006AD4 loc_6AD4:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+9BCj
.text:00006AD4                 mov     eax, [ebp+var_170]
.text:00006ADA                 mov     ecx, [ebp+var_7C]
.text:00006ADD                 mov     edx, [ecx+28h]
.text:00006AE0                 mov     [eax+28h], edx
.text:00006AE3                 mov     ecx, [ecx+2Ch]
.text:00006AE6                 mov     [eax+2Ch], ecx
.text:00006AE9
.text:00006AE9 loc_6AE9:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+A42j
.text:00006AE9                 lea     ecx, [ebp+var_34] ; this
.text:00006AEC                 call    ?Get_NumThreads@CMethodProps@@QBEHXZ ; CMethodProps::Get_NumThreads(void)
.text:00006AF1                 mov     [ebp+var_178], eax
.text:00006AF7                 cmp     [ebp+var_178], 0
.text:00006AFE                 jg      short loc_6B0C
.text:00006B00                 mov     [ebp+var_200], 1
.text:00006B0A                 jmp     short loc_6B18
.text:00006B0C ; ---------------------------------------------------------------------------
.text:00006B0C
.text:00006B0C loc_6B0C:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+A6Ej
.text:00006B0C                 mov     edx, [ebp+var_178]
.text:00006B12                 mov     [ebp+var_200], edx
.text:00006B18
.text:00006B18 loc_6B18:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+A7Aj
.text:00006B18                 mov     eax, [ebp+var_170]
.text:00006B1E                 mov     ecx, [ebp+var_200]
.text:00006B24                 mov     [eax+8], ecx
.text:00006B27                 cmp     [ebp+var_16C], 1
.text:00006B2E                 jbe     loc_6C14
.text:00006B34                 mov     [ebp+var_17C], 0
.text:00006B3E                 jmp     short loc_6B4F
.text:00006B40 ; ---------------------------------------------------------------------------
.text:00006B40
.text:00006B40 loc_6B40:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *):loc_6C0Dj
.text:00006B40                 mov     edx, [ebp+var_17C]
.text:00006B46                 add     edx, 1
.text:00006B49                 mov     [ebp+var_17C], edx
.text:00006B4F
.text:00006B4F loc_6B4F:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+AAEj
.text:00006B4F                 mov     eax, [ebp+var_17C]
.text:00006B55                 cmp     eax, [ebp+var_5C]
.text:00006B58                 jnb     loc_6C12
.text:00006B5E                 cmp     [ebp+var_80], 0
.text:00006B62                 jnz     short loc_6B76
.text:00006B64                 cmp     [ebp+var_17C], 0
.text:00006B6B                 jnz     short loc_6B76
.text:00006B6D                 mov     [ebp+var_201], 1
.text:00006B74                 jmp     short loc_6B7D
.text:00006B76 ; ---------------------------------------------------------------------------
.text:00006B76
.text:00006B76 loc_6B76:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+AD2j
.text:00006B76                                         ; MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+ADBj
.text:00006B76                 mov     [ebp+var_201], 0
.text:00006B7D
.text:00006B7D loc_6B7D:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+AE4j
.text:00006B7D                 mov     ecx, [ebp+var_80]
.text:00006B80                 imul    ecx, [ebp+var_5C]
.text:00006B84                 add     ecx, [ebp+var_17C]
.text:00006B8A                 shl     ecx, 4
.text:00006B8D                 imul    ecx, 15h
.text:00006B90                 and     ecx, 7FFh
.text:00006B96                 push    ecx             ; unsigned int
.text:00006B97                 movzx   edx, [ebp+var_201]
.text:00006B9E                 push    edx             ; bool
.text:00006B9F                 mov     eax, [ebp+var_17C]
.text:00006BA5                 push    eax             ; unsigned int
.text:00006BA6                 mov     ecx, [ebp+var_170] ; this
.text:00006BAC                 call    ?CreateDecoderThread@CEncoderInfo@@QAEJI_NI@Z ; CEncoderInfo::CreateDecoderThread(uint,bool,uint)
.text:00006BB1                 mov     [ebp+var_180], eax
.text:00006BB7                 mov     ecx, [ebp+var_180]
.text:00006BBD                 mov     [ebp+var_184], ecx
.text:00006BC3                 cmp     [ebp+var_184], 0
.text:00006BCA                 jz      short loc_6C0D
.text:00006BCC                 mov     edx, [ebp+var_184]
.text:00006BD2                 mov     [ebp+var_1E0], edx
.text:00006BD8                 mov     byte ptr [ebp+var_4], 1
.text:00006BDC                 lea     ecx, [ebp+var_100] ; this
.text:00006BE2                 call    ??1CBenchProgressStatus@@QAE@XZ ; CBenchProgressStatus::~CBenchProgressStatus(void)
.text:00006BE7                 mov     byte ptr [ebp+var_4], 0
.text:00006BEB                 lea     ecx, [ebp+var_74] ; this
.text:00006BEE                 call    ??1CBenchEncoders@@QAE@XZ ; CBenchEncoders::~CBenchEncoders(void)
.text:00006BF3                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00006BFA                 lea     ecx, [ebp+var_34] ; this
.text:00006BFD                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:00006C02                 mov     eax, [ebp+var_1E0]
.text:00006C08                 jmp     loc_6FC8
.text:00006C0D ; ---------------------------------------------------------------------------
.text:00006C0D
.text:00006C0D loc_6C0D:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+B3Aj
.text:00006C0D                 jmp     loc_6B40
.text:00006C12 ; ---------------------------------------------------------------------------
.text:00006C12
.text:00006C12 loc_6C12:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+AC8j
.text:00006C12                 jmp     short loc_6C71
.text:00006C14 ; ---------------------------------------------------------------------------
.text:00006C14
.text:00006C14 loc_6C14:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+A9Ej
.text:00006C14                 push    0               ; unsigned int
.text:00006C16                 mov     ecx, [ebp+var_170] ; this
.text:00006C1C                 call    ?Decode@CEncoderInfo@@QAEJI@Z ; CEncoderInfo::Decode(uint)
.text:00006C21                 mov     [ebp+var_188], eax
.text:00006C27                 cmp     [ebp+var_188], 0
.text:00006C2E                 jz      short loc_6C71
.text:00006C30                 mov     eax, [ebp+var_188]
.text:00006C36                 mov     [ebp+var_1E4], eax
.text:00006C3C                 mov     byte ptr [ebp+var_4], 1
.text:00006C40                 lea     ecx, [ebp+var_100] ; this
.text:00006C46                 call    ??1CBenchProgressStatus@@QAE@XZ ; CBenchProgressStatus::~CBenchProgressStatus(void)
.text:00006C4B                 mov     byte ptr [ebp+var_4], 0
.text:00006C4F                 lea     ecx, [ebp+var_74] ; this
.text:00006C52                 call    ??1CBenchEncoders@@QAE@XZ ; CBenchEncoders::~CBenchEncoders(void)
.text:00006C57                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00006C5E                 lea     ecx, [ebp+var_34] ; this
.text:00006C61                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:00006C66                 mov     eax, [ebp+var_1E4]
.text:00006C6C                 jmp     loc_6FC8
.text:00006C71 ; ---------------------------------------------------------------------------
.text:00006C71
.text:00006C71 loc_6C71:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *):loc_6C12j
.text:00006C71                                         ; MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+B9Ej
.text:00006C71                 jmp     loc_6A21
.text:00006C76 ; ---------------------------------------------------------------------------
.text:00006C76
.text:00006C76 loc_6C76:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+9A0j
.text:00006C76                 mov     [ebp+var_18C], 0
.text:00006C80                 cmp     [ebp+var_16C], 1
.text:00006C87                 jbe     loc_6D2D
.text:00006C8D                 mov     [ebp+var_80], 0
.text:00006C94                 jmp     short loc_6C9F
.text:00006C96 ; ---------------------------------------------------------------------------
.text:00006C96
.text:00006C96 loc_6C96:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *):loc_6D28j
.text:00006C96                 mov     ecx, [ebp+var_80]
.text:00006C99                 add     ecx, 1
.text:00006C9C                 mov     [ebp+var_80], ecx
.text:00006C9F
.text:00006C9F loc_6C9F:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+C04j
.text:00006C9F                 mov     edx, [ebp+var_80]
.text:00006CA2                 cmp     edx, [ebp+var_58]
.text:00006CA5                 jnb     loc_6D2D
.text:00006CAB                 mov     [ebp+var_190], 0
.text:00006CB5                 jmp     short loc_6CC6
.text:00006CB7 ; ---------------------------------------------------------------------------
.text:00006CB7
.text:00006CB7 loc_6CB7:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *):loc_6D26j
.text:00006CB7                 mov     eax, [ebp+var_190]
.text:00006CBD                 add     eax, 1
.text:00006CC0                 mov     [ebp+var_190], eax
.text:00006CC6
.text:00006CC6 loc_6CC6:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+C25j
.text:00006CC6                 mov     ecx, [ebp+var_190]
.text:00006CCC                 cmp     ecx, [ebp+var_5C]
.text:00006CCF                 jnb     short loc_6D28
.text:00006CD1                 mov     edx, [ebp+var_80]
.text:00006CD4                 imul    edx, 118h
.text:00006CDA                 add     edx, [ebp+var_7C]
.text:00006CDD                 mov     [ebp+var_194], edx
.text:00006CE3                 mov     eax, [ebp+var_190]
.text:00006CE9                 mov     ecx, [ebp+var_194]
.text:00006CEF                 lea     ecx, [ecx+eax*4] ; this
.text:00006CF2                 call    ?Wait@CThread@NWindows@@QAEIXZ ; NWindows::CThread::Wait(void)
.text:00006CF7                 mov     edx, [ebp+var_190]
.text:00006CFD                 mov     eax, [ebp+var_194]
.text:00006D03                 cmp     dword ptr [eax+edx*4+0A4h], 0
.text:00006D0B                 jz      short loc_6D26
.text:00006D0D                 mov     ecx, [ebp+var_190]
.text:00006D13                 mov     edx, [ebp+var_194]
.text:00006D19                 mov     eax, [edx+ecx*4+0A4h]
.text:00006D20                 mov     [ebp+var_18C], eax
.text:00006D26
.text:00006D26 loc_6D26:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+C7Bj
.text:00006D26                 jmp     short loc_6CB7
.text:00006D28 ; ---------------------------------------------------------------------------
.text:00006D28
.text:00006D28 loc_6D28:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+C3Fj
.text:00006D28                 jmp     loc_6C96
.text:00006D2D ; ---------------------------------------------------------------------------
.text:00006D2D
.text:00006D2D loc_6D2D:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+BF7j
.text:00006D2D                                         ; MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+C15j
.text:00006D2D                 mov     ecx, [ebp+var_18C]
.text:00006D33                 mov     [ebp+var_198], ecx
.text:00006D39                 cmp     [ebp+var_198], 0
.text:00006D40                 jz      short loc_6D83
.text:00006D42                 mov     edx, [ebp+var_198]
.text:00006D48                 mov     [ebp+var_1E8], edx
.text:00006D4E                 mov     byte ptr [ebp+var_4], 1
.text:00006D52                 lea     ecx, [ebp+var_100] ; this
.text:00006D58                 call    ??1CBenchProgressStatus@@QAE@XZ ; CBenchProgressStatus::~CBenchProgressStatus(void)
.text:00006D5D                 mov     byte ptr [ebp+var_4], 0
.text:00006D61                 lea     ecx, [ebp+var_74] ; this
.text:00006D64                 call    ??1CBenchEncoders@@QAE@XZ ; CBenchEncoders::~CBenchEncoders(void)
.text:00006D69                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00006D70                 lea     ecx, [ebp+var_34] ; this
.text:00006D73                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:00006D78                 mov     eax, [ebp+var_1E8]
.text:00006D7E                 jmp     loc_6FC8
.text:00006D83 ; ---------------------------------------------------------------------------
.text:00006D83
.text:00006D83 loc_6D83:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+CB0j
.text:00006D83                 mov     eax, [ebp+var_E8]
.text:00006D89                 mov     [ebp+var_19C], eax
.text:00006D8F                 cmp     [ebp+var_19C], 0
.text:00006D96                 jz      short loc_6DD9
.text:00006D98                 mov     ecx, [ebp+var_19C]
.text:00006D9E                 mov     [ebp+var_1EC], ecx
.text:00006DA4                 mov     byte ptr [ebp+var_4], 1
.text:00006DA8                 lea     ecx, [ebp+var_100] ; this
.text:00006DAE                 call    ??1CBenchProgressStatus@@QAE@XZ ; CBenchProgressStatus::~CBenchProgressStatus(void)
.text:00006DB3                 mov     byte ptr [ebp+var_4], 0
.text:00006DB7                 lea     ecx, [ebp+var_74] ; this
.text:00006DBA                 call    ??1CBenchEncoders@@QAE@XZ ; CBenchEncoders::~CBenchEncoders(void)
.text:00006DBF                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00006DC6                 lea     ecx, [ebp+var_34] ; this
.text:00006DC9                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:00006DCE                 mov     eax, [ebp+var_1EC]
.text:00006DD4                 jmp     loc_6FC8
.text:00006DD9 ; ---------------------------------------------------------------------------
.text:00006DD9
.text:00006DD9 loc_6DD9:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+D06j
.text:00006DD9                 lea     edx, [ebp+var_15C]
.text:00006DDF                 push    edx             ; struct CBenchInfo *
.text:00006DE0                 mov     eax, [ebp+var_7C]
.text:00006DE3                 mov     ecx, [eax+14h]
.text:00006DE6                 add     ecx, 8          ; this
.text:00006DE9                 call    ?SetFinishTime@CBenchInfoCalc@@QAEXAAUCBenchInfo@@@Z ; CBenchInfoCalc::SetFinishTime(CBenchInfo &)
.text:00006DEE                 mov     [ebp+var_13C], 0
.text:00006DF8                 mov     [ebp+var_138], 0
.text:00006E02                 mov     [ebp+var_134], 0
.text:00006E0C                 mov     [ebp+var_130], 0
.text:00006E16                 mov     ecx, [ebp+var_5C]
.text:00006E19                 xor     edx, edx
.text:00006E1B                 mov     eax, [ebp+var_7C]
.text:00006E1E                 mov     esi, [eax+2Ch]
.text:00006E21                 push    esi
.text:00006E22                 mov     eax, [eax+28h]
.text:00006E25                 push    eax
.text:00006E26                 push    edx
.text:00006E27                 push    ecx
.text:00006E28                 call    __allmul
.text:00006E2D                 mov     [ebp+var_12C], eax
.text:00006E33                 mov     [ebp+var_128], edx
.text:00006E39                 mov     [ebp+var_80], 0
.text:00006E40                 jmp     short loc_6E4B
.text:00006E42 ; ---------------------------------------------------------------------------
.text:00006E42
.text:00006E42 loc_6E42:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+E21j
.text:00006E42                 mov     ecx, [ebp+var_80]
.text:00006E45                 add     ecx, 1
.text:00006E48                 mov     [ebp+var_80], ecx
.text:00006E4B
.text:00006E4B loc_6E4B:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+DB0j
.text:00006E4B                 mov     edx, [ebp+var_80]
.text:00006E4E                 cmp     edx, [ebp+var_58]
.text:00006E51                 jnb     short loc_6EB3
.text:00006E53                 mov     eax, [ebp+var_80]
.text:00006E56                 imul    eax, 118h
.text:00006E5C                 add     eax, [ebp+var_7C]
.text:00006E5F                 mov     [ebp+var_1A0], eax
.text:00006E65                 mov     ecx, [ebp+var_1A0]
.text:00006E6B                 mov     edx, [ecx+0C0h]
.text:00006E71                 xor     eax, eax
.text:00006E73                 add     edx, [ebp+var_13C]
.text:00006E79                 adc     eax, [ebp+var_138]
.text:00006E7F                 mov     [ebp+var_13C], edx
.text:00006E85                 mov     [ebp+var_138], eax
.text:00006E8B                 mov     ecx, [ebp+var_1A0]
.text:00006E91                 mov     edx, [ecx+0C4h]
.text:00006E97                 xor     eax, eax
.text:00006E99                 add     edx, [ebp+var_134]
.text:00006E9F                 adc     eax, [ebp+var_130]
.text:00006EA5                 mov     [ebp+var_134], edx
.text:00006EAB                 mov     [ebp+var_130], eax
.text:00006EB1                 jmp     short loc_6E42
.text:00006EB3 ; ---------------------------------------------------------------------------
.text:00006EB3
.text:00006EB3 loc_6EB3:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+DC1j
.text:00006EB3                 mov     esi, esp
.text:00006EB5                 push    0
.text:00006EB7                 lea     ecx, [ebp+var_15C]
.text:00006EBD                 push    ecx
.text:00006EBE                 mov     edx, [ebp+arg_20]
.text:00006EC1                 mov     eax, [edx]
.text:00006EC3                 mov     ecx, [ebp+arg_20]
.text:00006EC6                 mov     edx, [eax+8]
.text:00006EC9                 call    edx
.text:00006ECB                 cmp     esi, esp
.text:00006ECD                 call    __RTC_CheckEsp
.text:00006ED2                 mov     [ebp+var_1A4], eax
.text:00006ED8                 cmp     [ebp+var_1A4], 0
.text:00006EDF                 jz      short loc_6F22
.text:00006EE1                 mov     eax, [ebp+var_1A4]
.text:00006EE7                 mov     [ebp+var_1F0], eax
.text:00006EED                 mov     byte ptr [ebp+var_4], 1
.text:00006EF1                 lea     ecx, [ebp+var_100] ; this
.text:00006EF7                 call    ??1CBenchProgressStatus@@QAE@XZ ; CBenchProgressStatus::~CBenchProgressStatus(void)
.text:00006EFC                 mov     byte ptr [ebp+var_4], 0
.text:00006F00                 lea     ecx, [ebp+var_74] ; this
.text:00006F03                 call    ??1CBenchEncoders@@QAE@XZ ; CBenchEncoders::~CBenchEncoders(void)
.text:00006F08                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00006F0F                 lea     ecx, [ebp+var_34] ; this
.text:00006F12                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:00006F17                 mov     eax, [ebp+var_1F0]
.text:00006F1D                 jmp     loc_6FC8
.text:00006F22 ; ---------------------------------------------------------------------------
.text:00006F22
.text:00006F22 loc_6F22:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+E4Fj
.text:00006F22                 mov     esi, esp
.text:00006F24                 push    1
.text:00006F26                 lea     ecx, [ebp+var_15C]
.text:00006F2C                 push    ecx
.text:00006F2D                 mov     edx, [ebp+arg_20]
.text:00006F30                 mov     eax, [edx]
.text:00006F32                 mov     ecx, [ebp+arg_20]
.text:00006F35                 mov     edx, [eax+8]
.text:00006F38                 call    edx
.text:00006F3A                 cmp     esi, esp
.text:00006F3C                 call    __RTC_CheckEsp
.text:00006F41                 mov     [ebp+var_1A8], eax
.text:00006F47                 cmp     [ebp+var_1A8], 0
.text:00006F4E                 jz      short loc_6F8E
.text:00006F50                 mov     eax, [ebp+var_1A8]
.text:00006F56                 mov     [ebp+var_1F4], eax
.text:00006F5C                 mov     byte ptr [ebp+var_4], 1
.text:00006F60                 lea     ecx, [ebp+var_100] ; this
.text:00006F66                 call    ??1CBenchProgressStatus@@QAE@XZ ; CBenchProgressStatus::~CBenchProgressStatus(void)
.text:00006F6B                 mov     byte ptr [ebp+var_4], 0
.text:00006F6F                 lea     ecx, [ebp+var_74] ; this
.text:00006F72                 call    ??1CBenchEncoders@@QAE@XZ ; CBenchEncoders::~CBenchEncoders(void)
.text:00006F77                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00006F7E                 lea     ecx, [ebp+var_34] ; this
.text:00006F81                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:00006F86                 mov     eax, [ebp+var_1F4]
.text:00006F8C                 jmp     short loc_6FC8
.text:00006F8E ; ---------------------------------------------------------------------------
.text:00006F8E
.text:00006F8E loc_6F8E:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+EBEj
.text:00006F8E                 mov     [ebp+var_1F8], 0
.text:00006F98                 mov     byte ptr [ebp+var_4], 1
.text:00006F9C                 lea     ecx, [ebp+var_100] ; this
.text:00006FA2                 call    ??1CBenchProgressStatus@@QAE@XZ ; CBenchProgressStatus::~CBenchProgressStatus(void)
.text:00006FA7                 mov     byte ptr [ebp+var_4], 0
.text:00006FAB                 lea     ecx, [ebp+var_74] ; this
.text:00006FAE                 call    ??1CBenchEncoders@@QAE@XZ ; CBenchEncoders::~CBenchEncoders(void)
.text:00006FB3                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00006FBA                 lea     ecx, [ebp+var_34] ; this
.text:00006FBD                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:00006FC2                 mov     eax, [ebp+var_1F8]
.text:00006FC8
.text:00006FC8 loc_6FC8:                               ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+86j
.text:00006FC8                                         ; MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+B0j ...
.text:00006FC8                 push    edx
.text:00006FC9                 mov     ecx, ebp
.text:00006FCB                 push    eax
.text:00006FCC                 lea     edx, $LN93
.text:00006FD2                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00006FD7                 pop     eax
.text:00006FD8                 pop     edx
.text:00006FD9                 mov     ecx, [ebp+var_C]
.text:00006FDC                 mov     large fs:0, ecx
.text:00006FE3                 pop     ecx
.text:00006FE4                 pop     edi
.text:00006FE5                 pop     esi
.text:00006FE6                 add     esp, 204h
.text:00006FEC                 cmp     ebp, esp
.text:00006FEE                 call    __RTC_CheckEsp
.text:00006FF3                 mov     esp, ebp
.text:00006FF5                 pop     ebp
.text:00006FF6                 retn    28h
.text:00006FF6 ?MethodBench@@YGJ_K_NIABVCOneMethodInfo@@IIPAUIBenchPrintCallback@@PAUIBenchCallback@@PAUCBenchProps@@@Z endp
.text:00006FF6
.text:00006FF6 ; ---------------------------------------------------------------------------
.text:00006FF9                 align 4
.text:00006FFC $LN93           dd 0Ah                  ; DATA XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+F3Co
.text:00007000                 dd offset $LN92
.text:00007004 $LN92           db 0CCh                 ; DATA XREF: .text:00007000o
.text:00007005                 db 3 dup(0FFh)
.text:00007008                 dd offset unk_24
.text:0000700C                 dd offset $LN81         ; "method"
.text:00007010                 dd 0FFFFFFBCh, 8
.text:00007018                 dd offset $LN82         ; "methodId"
.text:0000701C                 dd 0FFFFFFB0h, 4
.text:00007024                 dd offset $LN83         ; "numStreams"
.text:00007028                 dd 0FFFFFF9Fh, 1
.text:00007030                 dd offset $LN84         ; "fixedNumber"
.text:00007034                 dd 0FFFFFF8Ch, 4
.text:0000703C                 dd offset $LN85         ; "encodersSpec"
.text:00007040                 dd 0FFFFFF68h, 10h
.text:00007048                 dd offset $LN86         ; "cod"
.text:0000704C                 dd 0FFFFFF48h, 10h
.text:00007054                 dd offset $LN87         ; "cod"
.text:00007058                 dd 0FFFFFF30h, 8
.text:00007060                 dd offset $LN88         ; "rg"
.text:00007064                 dd 0FFFFFF00h, 20h
.text:0000706C                 dd offset $LN89         ; "status"
.text:00007070                 dd 0FFFFFEA4h, 38h
.text:00007078                 dd offset $LN90         ; "info"
.text:0000707C $LN90           db 'info',0             ; DATA XREF: .text:00007078o
.text:00007081 $LN89           db 'status',0           ; DATA XREF: .text:0000706Co
.text:00007088 $LN88           db 'rg',0               ; DATA XREF: .text:00007060o
.text:0000708B $LN87           db 'cod',0              ; DATA XREF: .text:00007054o
.text:0000708F $LN86           db 'cod',0              ; DATA XREF: .text:00007048o
.text:00007093 $LN85           db 'encodersSpec',0     ; DATA XREF: .text:0000703Co
.text:000070A0 $LN84           db 'fixedNumber',0      ; DATA XREF: .text:00007030o
.text:000070AC $LN83           db 'numStreams',0       ; DATA XREF: .text:00007024o
.text:000070B7 $LN82           db 'methodId',0         ; DATA XREF: .text:00007018o
.text:000070C0 $LN81           db 'method',0           ; DATA XREF: .text:0000700Co
.text:000070C7                 align 10h
.text:000070D0
.text:000070D0 ; =============== S U B R O U T I N E =======================================
.text:000070D0
.text:000070D0 ; Attributes: bp-based frame
.text:000070D0
.text:000070D0 ; unsigned __int64 __stdcall GetNumIterations(unsigned __int64, unsigned __int64)
.text:000070D0 ?GetNumIterations@@YG_K_K0@Z proc near  ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+5ABp
.text:000070D0                                         ; MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+9F4p
.text:000070D0
.text:000070D0 var_10          = dword ptr -10h
.text:000070D0 var_C           = dword ptr -0Ch
.text:000070D0 var_8           = dword ptr -8
.text:000070D0 var_4           = dword ptr -4
.text:000070D0 arg_0           = dword ptr  8
.text:000070D0 arg_4           = dword ptr  0Ch
.text:000070D0 arg_8           = dword ptr  10h
.text:000070D0 arg_C           = dword ptr  14h
.text:000070D0
.text:000070D0                 push    ebp
.text:000070D1                 mov     ebp, esp
.text:000070D3                 sub     esp, 10h
.text:000070D6                 mov     eax, 0CCCCCCCCh
.text:000070DB                 mov     [ebp+var_10], eax
.text:000070DE                 mov     [ebp+var_C], eax
.text:000070E1                 mov     [ebp+var_8], eax
.text:000070E4                 mov     [ebp+var_4], eax
.text:000070E7                 cmp     [ebp+arg_4], 0
.text:000070EB                 ja      short loc_7103
.text:000070ED                 jb      short loc_70F5
.text:000070EF                 cmp     [ebp+arg_0], 10h
.text:000070F3                 jnb     short loc_7103
.text:000070F5
.text:000070F5 loc_70F5:                               ; CODE XREF: GetNumIterations(unsigned __int64,unsigned __int64)+1Dj
.text:000070F5                 mov     [ebp+arg_0], 10h
.text:000070FC                 mov     [ebp+arg_4], 0
.text:00007103
.text:00007103 loc_7103:                               ; CODE XREF: GetNumIterations(unsigned __int64,unsigned __int64)+1Bj
.text:00007103                                         ; GetNumIterations(unsigned __int64,unsigned __int64)+23j
.text:00007103                 mov     eax, [ebp+arg_4]
.text:00007106                 push    eax
.text:00007107                 mov     ecx, [ebp+arg_0]
.text:0000710A                 push    ecx
.text:0000710B                 mov     edx, [ebp+arg_C]
.text:0000710E                 push    edx
.text:0000710F                 mov     eax, [ebp+arg_8]
.text:00007112                 push    eax
.text:00007113                 call    __aulldiv
.text:00007118                 mov     [ebp+var_8], eax
.text:0000711B                 mov     [ebp+var_4], edx
.text:0000711E                 mov     ecx, [ebp+var_8]
.text:00007121                 or      ecx, [ebp+var_4]
.text:00007124                 jnz     short loc_7136
.text:00007126                 mov     [ebp+var_10], 1
.text:0000712D                 mov     [ebp+var_C], 0
.text:00007134                 jmp     short loc_7142
.text:00007136 ; ---------------------------------------------------------------------------
.text:00007136
.text:00007136 loc_7136:                               ; CODE XREF: GetNumIterations(unsigned __int64,unsigned __int64)+54j
.text:00007136                 mov     edx, [ebp+var_8]
.text:00007139                 mov     [ebp+var_10], edx
.text:0000713C                 mov     eax, [ebp+var_4]
.text:0000713F                 mov     [ebp+var_C], eax
.text:00007142
.text:00007142 loc_7142:                               ; CODE XREF: GetNumIterations(unsigned __int64,unsigned __int64)+64j
.text:00007142                 mov     eax, [ebp+var_10]
.text:00007145                 mov     edx, [ebp+var_C]
.text:00007148                 add     esp, 10h
.text:0000714B                 cmp     ebp, esp
.text:0000714D                 call    __RTC_CheckEsp
.text:00007152                 mov     esp, ebp
.text:00007154                 pop     ebp
.text:00007155                 retn    10h
.text:00007155 ?GetNumIterations@@YG_K_K0@Z endp
.text:00007155
.text:00007155 ; ---------------------------------------------------------------------------
.text:00007158                 align 10h
.text:00007160
.text:00007160 ; =============== S U B R O U T I N E =======================================
.text:00007160
.text:00007160 ; Attributes: bp-based frame
.text:00007160
.text:00007160 ; __stdcall CountCpuFreq(x, x, x)
.text:00007160 _CountCpuFreq@12 proc near              ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+56Fp
.text:00007160                                         ; FreqBench(unsigned __int64,uint,IBenchPrintCallback *,bool,unsigned __int64 &,uint &)+399p ...
.text:00007160
.text:00007160 var_4           = dword ptr -4
.text:00007160 arg_0           = dword ptr  8
.text:00007160 arg_4           = dword ptr  0Ch
.text:00007160 arg_8           = dword ptr  10h
.text:00007160
.text:00007160                 push    ebp
.text:00007161                 mov     ebp, esp
.text:00007163                 push    ecx
.text:00007164                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000716B                 mov     [ebp+var_4], 0
.text:00007172                 jmp     short loc_717D
.text:00007174 ; ---------------------------------------------------------------------------
.text:00007174
.text:00007174 loc_7174:                               ; CODE XREF: CountCpuFreq(x,x,x)+4A9j
.text:00007174                 mov     eax, [ebp+var_4]
.text:00007177                 add     eax, 1
.text:0000717A                 mov     [ebp+var_4], eax
.text:0000717D
.text:0000717D loc_717D:                               ; CODE XREF: CountCpuFreq(x,x,x)+12j
.text:0000717D                 mov     ecx, [ebp+var_4]
.text:00007180                 cmp     ecx, [ebp+arg_4]
.text:00007183                 jnb     loc_760E
.text:00007189                 mov     edx, [ebp+arg_0]
.text:0000718C                 add     edx, [ebp+arg_8]
.text:0000718F                 mov     [ebp+arg_0], edx
.text:00007192                 mov     eax, [ebp+arg_0]
.text:00007195                 xor     eax, [ebp+arg_8]
.text:00007198                 mov     [ebp+arg_0], eax
.text:0000719B                 mov     ecx, [ebp+arg_0]
.text:0000719E                 add     ecx, [ebp+arg_8]
.text:000071A1                 mov     [ebp+arg_0], ecx
.text:000071A4                 mov     edx, [ebp+arg_0]
.text:000071A7                 xor     edx, [ebp+arg_8]
.text:000071AA                 mov     [ebp+arg_0], edx
.text:000071AD                 mov     eax, [ebp+arg_0]
.text:000071B0                 add     eax, [ebp+arg_8]
.text:000071B3                 mov     [ebp+arg_0], eax
.text:000071B6                 mov     ecx, [ebp+arg_0]
.text:000071B9                 xor     ecx, [ebp+arg_8]
.text:000071BC                 mov     [ebp+arg_0], ecx
.text:000071BF                 mov     edx, [ebp+arg_0]
.text:000071C2                 add     edx, [ebp+arg_8]
.text:000071C5                 mov     [ebp+arg_0], edx
.text:000071C8                 mov     eax, [ebp+arg_0]
.text:000071CB                 xor     eax, [ebp+arg_8]
.text:000071CE                 mov     [ebp+arg_0], eax
.text:000071D1                 mov     ecx, [ebp+arg_0]
.text:000071D4                 add     ecx, [ebp+arg_8]
.text:000071D7                 mov     [ebp+arg_0], ecx
.text:000071DA                 mov     edx, [ebp+arg_0]
.text:000071DD                 xor     edx, [ebp+arg_8]
.text:000071E0                 mov     [ebp+arg_0], edx
.text:000071E3                 mov     eax, [ebp+arg_0]
.text:000071E6                 add     eax, [ebp+arg_8]
.text:000071E9                 mov     [ebp+arg_0], eax
.text:000071EC                 mov     ecx, [ebp+arg_0]
.text:000071EF                 xor     ecx, [ebp+arg_8]
.text:000071F2                 mov     [ebp+arg_0], ecx
.text:000071F5                 mov     edx, [ebp+arg_0]
.text:000071F8                 add     edx, [ebp+arg_8]
.text:000071FB                 mov     [ebp+arg_0], edx
.text:000071FE                 mov     eax, [ebp+arg_0]
.text:00007201                 xor     eax, [ebp+arg_8]
.text:00007204                 mov     [ebp+arg_0], eax
.text:00007207                 mov     ecx, [ebp+arg_0]
.text:0000720A                 add     ecx, [ebp+arg_8]
.text:0000720D                 mov     [ebp+arg_0], ecx
.text:00007210                 mov     edx, [ebp+arg_0]
.text:00007213                 xor     edx, [ebp+arg_8]
.text:00007216                 mov     [ebp+arg_0], edx
.text:00007219                 mov     eax, [ebp+arg_0]
.text:0000721C                 add     eax, [ebp+arg_8]
.text:0000721F                 mov     [ebp+arg_0], eax
.text:00007222                 mov     ecx, [ebp+arg_0]
.text:00007225                 xor     ecx, [ebp+arg_8]
.text:00007228                 mov     [ebp+arg_0], ecx
.text:0000722B                 mov     edx, [ebp+arg_0]
.text:0000722E                 add     edx, [ebp+arg_8]
.text:00007231                 mov     [ebp+arg_0], edx
.text:00007234                 mov     eax, [ebp+arg_0]
.text:00007237                 xor     eax, [ebp+arg_8]
.text:0000723A                 mov     [ebp+arg_0], eax
.text:0000723D                 mov     ecx, [ebp+arg_0]
.text:00007240                 add     ecx, [ebp+arg_8]
.text:00007243                 mov     [ebp+arg_0], ecx
.text:00007246                 mov     edx, [ebp+arg_0]
.text:00007249                 xor     edx, [ebp+arg_8]
.text:0000724C                 mov     [ebp+arg_0], edx
.text:0000724F                 mov     eax, [ebp+arg_0]
.text:00007252                 add     eax, [ebp+arg_8]
.text:00007255                 mov     [ebp+arg_0], eax
.text:00007258                 mov     ecx, [ebp+arg_0]
.text:0000725B                 xor     ecx, [ebp+arg_8]
.text:0000725E                 mov     [ebp+arg_0], ecx
.text:00007261                 mov     edx, [ebp+arg_0]
.text:00007264                 add     edx, [ebp+arg_8]
.text:00007267                 mov     [ebp+arg_0], edx
.text:0000726A                 mov     eax, [ebp+arg_0]
.text:0000726D                 xor     eax, [ebp+arg_8]
.text:00007270                 mov     [ebp+arg_0], eax
.text:00007273                 mov     ecx, [ebp+arg_0]
.text:00007276                 add     ecx, [ebp+arg_8]
.text:00007279                 mov     [ebp+arg_0], ecx
.text:0000727C                 mov     edx, [ebp+arg_0]
.text:0000727F                 xor     edx, [ebp+arg_8]
.text:00007282                 mov     [ebp+arg_0], edx
.text:00007285                 mov     eax, [ebp+arg_0]
.text:00007288                 add     eax, [ebp+arg_8]
.text:0000728B                 mov     [ebp+arg_0], eax
.text:0000728E                 mov     ecx, [ebp+arg_0]
.text:00007291                 xor     ecx, [ebp+arg_8]
.text:00007294                 mov     [ebp+arg_0], ecx
.text:00007297                 mov     edx, [ebp+arg_0]
.text:0000729A                 add     edx, [ebp+arg_8]
.text:0000729D                 mov     [ebp+arg_0], edx
.text:000072A0                 mov     eax, [ebp+arg_0]
.text:000072A3                 xor     eax, [ebp+arg_8]
.text:000072A6                 mov     [ebp+arg_0], eax
.text:000072A9                 mov     ecx, [ebp+arg_0]
.text:000072AC                 add     ecx, [ebp+arg_8]
.text:000072AF                 mov     [ebp+arg_0], ecx
.text:000072B2                 mov     edx, [ebp+arg_0]
.text:000072B5                 xor     edx, [ebp+arg_8]
.text:000072B8                 mov     [ebp+arg_0], edx
.text:000072BB                 mov     eax, [ebp+arg_0]
.text:000072BE                 add     eax, [ebp+arg_8]
.text:000072C1                 mov     [ebp+arg_0], eax
.text:000072C4                 mov     ecx, [ebp+arg_0]
.text:000072C7                 xor     ecx, [ebp+arg_8]
.text:000072CA                 mov     [ebp+arg_0], ecx
.text:000072CD                 mov     edx, [ebp+arg_0]
.text:000072D0                 add     edx, [ebp+arg_8]
.text:000072D3                 mov     [ebp+arg_0], edx
.text:000072D6                 mov     eax, [ebp+arg_0]
.text:000072D9                 xor     eax, [ebp+arg_8]
.text:000072DC                 mov     [ebp+arg_0], eax
.text:000072DF                 mov     ecx, [ebp+arg_0]
.text:000072E2                 add     ecx, [ebp+arg_8]
.text:000072E5                 mov     [ebp+arg_0], ecx
.text:000072E8                 mov     edx, [ebp+arg_0]
.text:000072EB                 xor     edx, [ebp+arg_8]
.text:000072EE                 mov     [ebp+arg_0], edx
.text:000072F1                 mov     eax, [ebp+arg_0]
.text:000072F4                 add     eax, [ebp+arg_8]
.text:000072F7                 mov     [ebp+arg_0], eax
.text:000072FA                 mov     ecx, [ebp+arg_0]
.text:000072FD                 xor     ecx, [ebp+arg_8]
.text:00007300                 mov     [ebp+arg_0], ecx
.text:00007303                 mov     edx, [ebp+arg_0]
.text:00007306                 add     edx, [ebp+arg_8]
.text:00007309                 mov     [ebp+arg_0], edx
.text:0000730C                 mov     eax, [ebp+arg_0]
.text:0000730F                 xor     eax, [ebp+arg_8]
.text:00007312                 mov     [ebp+arg_0], eax
.text:00007315                 mov     ecx, [ebp+arg_0]
.text:00007318                 add     ecx, [ebp+arg_8]
.text:0000731B                 mov     [ebp+arg_0], ecx
.text:0000731E                 mov     edx, [ebp+arg_0]
.text:00007321                 xor     edx, [ebp+arg_8]
.text:00007324                 mov     [ebp+arg_0], edx
.text:00007327                 mov     eax, [ebp+arg_0]
.text:0000732A                 add     eax, [ebp+arg_8]
.text:0000732D                 mov     [ebp+arg_0], eax
.text:00007330                 mov     ecx, [ebp+arg_0]
.text:00007333                 xor     ecx, [ebp+arg_8]
.text:00007336                 mov     [ebp+arg_0], ecx
.text:00007339                 mov     edx, [ebp+arg_0]
.text:0000733C                 add     edx, [ebp+arg_8]
.text:0000733F                 mov     [ebp+arg_0], edx
.text:00007342                 mov     eax, [ebp+arg_0]
.text:00007345                 xor     eax, [ebp+arg_8]
.text:00007348                 mov     [ebp+arg_0], eax
.text:0000734B                 mov     ecx, [ebp+arg_0]
.text:0000734E                 add     ecx, [ebp+arg_8]
.text:00007351                 mov     [ebp+arg_0], ecx
.text:00007354                 mov     edx, [ebp+arg_0]
.text:00007357                 xor     edx, [ebp+arg_8]
.text:0000735A                 mov     [ebp+arg_0], edx
.text:0000735D                 mov     eax, [ebp+arg_0]
.text:00007360                 add     eax, [ebp+arg_8]
.text:00007363                 mov     [ebp+arg_0], eax
.text:00007366                 mov     ecx, [ebp+arg_0]
.text:00007369                 xor     ecx, [ebp+arg_8]
.text:0000736C                 mov     [ebp+arg_0], ecx
.text:0000736F                 mov     edx, [ebp+arg_0]
.text:00007372                 add     edx, [ebp+arg_8]
.text:00007375                 mov     [ebp+arg_0], edx
.text:00007378                 mov     eax, [ebp+arg_0]
.text:0000737B                 xor     eax, [ebp+arg_8]
.text:0000737E                 mov     [ebp+arg_0], eax
.text:00007381                 mov     ecx, [ebp+arg_0]
.text:00007384                 add     ecx, [ebp+arg_8]
.text:00007387                 mov     [ebp+arg_0], ecx
.text:0000738A                 mov     edx, [ebp+arg_0]
.text:0000738D                 xor     edx, [ebp+arg_8]
.text:00007390                 mov     [ebp+arg_0], edx
.text:00007393                 mov     eax, [ebp+arg_0]
.text:00007396                 add     eax, [ebp+arg_8]
.text:00007399                 mov     [ebp+arg_0], eax
.text:0000739C                 mov     ecx, [ebp+arg_0]
.text:0000739F                 xor     ecx, [ebp+arg_8]
.text:000073A2                 mov     [ebp+arg_0], ecx
.text:000073A5                 mov     edx, [ebp+arg_0]
.text:000073A8                 add     edx, [ebp+arg_8]
.text:000073AB                 mov     [ebp+arg_0], edx
.text:000073AE                 mov     eax, [ebp+arg_0]
.text:000073B1                 xor     eax, [ebp+arg_8]
.text:000073B4                 mov     [ebp+arg_0], eax
.text:000073B7                 mov     ecx, [ebp+arg_0]
.text:000073BA                 add     ecx, [ebp+arg_8]
.text:000073BD                 mov     [ebp+arg_0], ecx
.text:000073C0                 mov     edx, [ebp+arg_0]
.text:000073C3                 xor     edx, [ebp+arg_8]
.text:000073C6                 mov     [ebp+arg_0], edx
.text:000073C9                 mov     eax, [ebp+arg_0]
.text:000073CC                 add     eax, [ebp+arg_8]
.text:000073CF                 mov     [ebp+arg_0], eax
.text:000073D2                 mov     ecx, [ebp+arg_0]
.text:000073D5                 xor     ecx, [ebp+arg_8]
.text:000073D8                 mov     [ebp+arg_0], ecx
.text:000073DB                 mov     edx, [ebp+arg_0]
.text:000073DE                 add     edx, [ebp+arg_8]
.text:000073E1                 mov     [ebp+arg_0], edx
.text:000073E4                 mov     eax, [ebp+arg_0]
.text:000073E7                 xor     eax, [ebp+arg_8]
.text:000073EA                 mov     [ebp+arg_0], eax
.text:000073ED                 mov     ecx, [ebp+arg_0]
.text:000073F0                 add     ecx, [ebp+arg_8]
.text:000073F3                 mov     [ebp+arg_0], ecx
.text:000073F6                 mov     edx, [ebp+arg_0]
.text:000073F9                 xor     edx, [ebp+arg_8]
.text:000073FC                 mov     [ebp+arg_0], edx
.text:000073FF                 mov     eax, [ebp+arg_0]
.text:00007402                 add     eax, [ebp+arg_8]
.text:00007405                 mov     [ebp+arg_0], eax
.text:00007408                 mov     ecx, [ebp+arg_0]
.text:0000740B                 xor     ecx, [ebp+arg_8]
.text:0000740E                 mov     [ebp+arg_0], ecx
.text:00007411                 mov     edx, [ebp+arg_0]
.text:00007414                 add     edx, [ebp+arg_8]
.text:00007417                 mov     [ebp+arg_0], edx
.text:0000741A                 mov     eax, [ebp+arg_0]
.text:0000741D                 xor     eax, [ebp+arg_8]
.text:00007420                 mov     [ebp+arg_0], eax
.text:00007423                 mov     ecx, [ebp+arg_0]
.text:00007426                 add     ecx, [ebp+arg_8]
.text:00007429                 mov     [ebp+arg_0], ecx
.text:0000742C                 mov     edx, [ebp+arg_0]
.text:0000742F                 xor     edx, [ebp+arg_8]
.text:00007432                 mov     [ebp+arg_0], edx
.text:00007435                 mov     eax, [ebp+arg_0]
.text:00007438                 add     eax, [ebp+arg_8]
.text:0000743B                 mov     [ebp+arg_0], eax
.text:0000743E                 mov     ecx, [ebp+arg_0]
.text:00007441                 xor     ecx, [ebp+arg_8]
.text:00007444                 mov     [ebp+arg_0], ecx
.text:00007447                 mov     edx, [ebp+arg_0]
.text:0000744A                 add     edx, [ebp+arg_8]
.text:0000744D                 mov     [ebp+arg_0], edx
.text:00007450                 mov     eax, [ebp+arg_0]
.text:00007453                 xor     eax, [ebp+arg_8]
.text:00007456                 mov     [ebp+arg_0], eax
.text:00007459                 mov     ecx, [ebp+arg_0]
.text:0000745C                 add     ecx, [ebp+arg_8]
.text:0000745F                 mov     [ebp+arg_0], ecx
.text:00007462                 mov     edx, [ebp+arg_0]
.text:00007465                 xor     edx, [ebp+arg_8]
.text:00007468                 mov     [ebp+arg_0], edx
.text:0000746B
.text:0000746B loc_746B:                               ; DATA XREF: .rdata:$SG71515o
.text:0000746B                 mov     eax, [ebp+arg_0]
.text:0000746E                 add     eax, [ebp+arg_8]
.text:00007471                 mov     [ebp+arg_0], eax
.text:00007474                 mov     ecx, [ebp+arg_0]
.text:00007477                 xor     ecx, [ebp+arg_8]
.text:0000747A                 mov     [ebp+arg_0], ecx
.text:0000747D                 mov     edx, [ebp+arg_0]
.text:00007480                 add     edx, [ebp+arg_8]
.text:00007483                 mov     [ebp+arg_0], edx
.text:00007486                 mov     eax, [ebp+arg_0]
.text:00007489                 xor     eax, [ebp+arg_8]
.text:0000748C                 mov     [ebp+arg_0], eax
.text:0000748F                 mov     ecx, [ebp+arg_0]
.text:00007492                 add     ecx, [ebp+arg_8]
.text:00007495                 mov     [ebp+arg_0], ecx
.text:00007498                 mov     edx, [ebp+arg_0]
.text:0000749B                 xor     edx, [ebp+arg_8]
.text:0000749E                 mov     [ebp+arg_0], edx
.text:000074A1                 mov     eax, [ebp+arg_0]
.text:000074A4                 add     eax, [ebp+arg_8]
.text:000074A7                 mov     [ebp+arg_0], eax
.text:000074AA                 mov     ecx, [ebp+arg_0]
.text:000074AD                 xor     ecx, [ebp+arg_8]
.text:000074B0                 mov     [ebp+arg_0], ecx
.text:000074B3                 mov     edx, [ebp+arg_0]
.text:000074B6                 add     edx, [ebp+arg_8]
.text:000074B9                 mov     [ebp+arg_0], edx
.text:000074BC                 mov     eax, [ebp+arg_0]
.text:000074BF                 xor     eax, [ebp+arg_8]
.text:000074C2                 mov     [ebp+arg_0], eax
.text:000074C5                 mov     ecx, [ebp+arg_0]
.text:000074C8                 add     ecx, [ebp+arg_8]
.text:000074CB                 mov     [ebp+arg_0], ecx
.text:000074CE                 mov     edx, [ebp+arg_0]
.text:000074D1                 xor     edx, [ebp+arg_8]
.text:000074D4                 mov     [ebp+arg_0], edx
.text:000074D7                 mov     eax, [ebp+arg_0]
.text:000074DA                 add     eax, [ebp+arg_8]
.text:000074DD                 mov     [ebp+arg_0], eax
.text:000074E0                 mov     ecx, [ebp+arg_0]
.text:000074E3                 xor     ecx, [ebp+arg_8]
.text:000074E6                 mov     [ebp+arg_0], ecx
.text:000074E9                 mov     edx, [ebp+arg_0]
.text:000074EC                 add     edx, [ebp+arg_8]
.text:000074EF                 mov     [ebp+arg_0], edx
.text:000074F2                 mov     eax, [ebp+arg_0]
.text:000074F5                 xor     eax, [ebp+arg_8]
.text:000074F8                 mov     [ebp+arg_0], eax
.text:000074FB                 mov     ecx, [ebp+arg_0]
.text:000074FE                 add     ecx, [ebp+arg_8]
.text:00007501                 mov     [ebp+arg_0], ecx
.text:00007504                 mov     edx, [ebp+arg_0]
.text:00007507                 xor     edx, [ebp+arg_8]
.text:0000750A                 mov     [ebp+arg_0], edx
.text:0000750D                 mov     eax, [ebp+arg_0]
.text:00007510                 add     eax, [ebp+arg_8]
.text:00007513                 mov     [ebp+arg_0], eax
.text:00007516                 mov     ecx, [ebp+arg_0]
.text:00007519                 xor     ecx, [ebp+arg_8]
.text:0000751C                 mov     [ebp+arg_0], ecx
.text:0000751F                 mov     edx, [ebp+arg_0]
.text:00007522                 add     edx, [ebp+arg_8]
.text:00007525                 mov     [ebp+arg_0], edx
.text:00007528                 mov     eax, [ebp+arg_0]
.text:0000752B                 xor     eax, [ebp+arg_8]
.text:0000752E                 mov     [ebp+arg_0], eax
.text:00007531                 mov     ecx, [ebp+arg_0]
.text:00007534                 add     ecx, [ebp+arg_8]
.text:00007537                 mov     [ebp+arg_0], ecx
.text:0000753A                 mov     edx, [ebp+arg_0]
.text:0000753D                 xor     edx, [ebp+arg_8]
.text:00007540                 mov     [ebp+arg_0], edx
.text:00007543                 mov     eax, [ebp+arg_0]
.text:00007546                 add     eax, [ebp+arg_8]
.text:00007549                 mov     [ebp+arg_0], eax
.text:0000754C                 mov     ecx, [ebp+arg_0]
.text:0000754F                 xor     ecx, [ebp+arg_8]
.text:00007552                 mov     [ebp+arg_0], ecx
.text:00007555                 mov     edx, [ebp+arg_0]
.text:00007558                 add     edx, [ebp+arg_8]
.text:0000755B                 mov     [ebp+arg_0], edx
.text:0000755E                 mov     eax, [ebp+arg_0]
.text:00007561                 xor     eax, [ebp+arg_8]
.text:00007564                 mov     [ebp+arg_0], eax
.text:00007567                 mov     ecx, [ebp+arg_0]
.text:0000756A                 add     ecx, [ebp+arg_8]
.text:0000756D                 mov     [ebp+arg_0], ecx
.text:00007570                 mov     edx, [ebp+arg_0]
.text:00007573                 xor     edx, [ebp+arg_8]
.text:00007576                 mov     [ebp+arg_0], edx
.text:00007579                 mov     eax, [ebp+arg_0]
.text:0000757C                 add     eax, [ebp+arg_8]
.text:0000757F                 mov     [ebp+arg_0], eax
.text:00007582                 mov     ecx, [ebp+arg_0]
.text:00007585                 xor     ecx, [ebp+arg_8]
.text:00007588                 mov     [ebp+arg_0], ecx
.text:0000758B                 mov     edx, [ebp+arg_0]
.text:0000758E                 add     edx, [ebp+arg_8]
.text:00007591                 mov     [ebp+arg_0], edx
.text:00007594                 mov     eax, [ebp+arg_0]
.text:00007597                 xor     eax, [ebp+arg_8]
.text:0000759A                 mov     [ebp+arg_0], eax
.text:0000759D                 mov     ecx, [ebp+arg_0]
.text:000075A0                 add     ecx, [ebp+arg_8]
.text:000075A3                 mov     [ebp+arg_0], ecx
.text:000075A6                 mov     edx, [ebp+arg_0]
.text:000075A9                 xor     edx, [ebp+arg_8]
.text:000075AC                 mov     [ebp+arg_0], edx
.text:000075AF                 mov     eax, [ebp+arg_0]
.text:000075B2                 add     eax, [ebp+arg_8]
.text:000075B5                 mov     [ebp+arg_0], eax
.text:000075B8                 mov     ecx, [ebp+arg_0]
.text:000075BB                 xor     ecx, [ebp+arg_8]
.text:000075BE                 mov     [ebp+arg_0], ecx
.text:000075C1                 mov     edx, [ebp+arg_0]
.text:000075C4                 add     edx, [ebp+arg_8]
.text:000075C7                 mov     [ebp+arg_0], edx
.text:000075CA                 mov     eax, [ebp+arg_0]
.text:000075CD                 xor     eax, [ebp+arg_8]
.text:000075D0                 mov     [ebp+arg_0], eax
.text:000075D3                 mov     ecx, [ebp+arg_0]
.text:000075D6                 add     ecx, [ebp+arg_8]
.text:000075D9                 mov     [ebp+arg_0], ecx
.text:000075DC                 mov     edx, [ebp+arg_0]
.text:000075DF                 xor     edx, [ebp+arg_8]
.text:000075E2                 mov     [ebp+arg_0], edx
.text:000075E5                 mov     eax, [ebp+arg_0]
.text:000075E8                 add     eax, [ebp+arg_8]
.text:000075EB                 mov     [ebp+arg_0], eax
.text:000075EE                 mov     ecx, [ebp+arg_0]
.text:000075F1                 xor     ecx, [ebp+arg_8]
.text:000075F4                 mov     [ebp+arg_0], ecx
.text:000075F7                 mov     edx, [ebp+arg_0]
.text:000075FA                 add     edx, [ebp+arg_8]
.text:000075FD                 mov     [ebp+arg_0], edx
.text:00007600                 mov     eax, [ebp+arg_0]
.text:00007603                 xor     eax, [ebp+arg_8]
.text:00007606                 mov     [ebp+arg_0], eax
.text:00007609                 jmp     loc_7174
.text:0000760E ; ---------------------------------------------------------------------------
.text:0000760E
.text:0000760E loc_760E:                               ; CODE XREF: CountCpuFreq(x,x,x)+23j
.text:0000760E                 mov     eax, [ebp+arg_0]
.text:00007611                 mov     esp, ebp
.text:00007613                 pop     ebp
.text:00007614                 retn    0Ch
.text:00007614 _CountCpuFreq@12 endp
.text:00007614
.text:00007614 ; ---------------------------------------------------------------------------
.text:00007617                 align 10h
.text:00007620
.text:00007620 ; =============== S U B R O U T I N E =======================================
.text:00007620
.text:00007620 ; Attributes: bp-based frame
.text:00007620
.text:00007620 ; void __stdcall PrintTotals(struct IBenchPrintCallback &, bool, unsigned __int64, struct CTotalBenchRes const &)
.text:00007620 ?PrintTotals@@YGXAAUIBenchPrintCallback@@_N_KABUCTotalBenchRes@@@Z proc near
.text:00007620                                         ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1D86p
.text:00007620                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1DD1p ...
.text:00007620
.text:00007620 var_8           = dword ptr -8
.text:00007620 var_4           = dword ptr -4
.text:00007620 arg_0           = dword ptr  8
.text:00007620 arg_4           = byte ptr  0Ch
.text:00007620 arg_8           = dword ptr  10h
.text:00007620 arg_C           = dword ptr  14h
.text:00007620 arg_10          = dword ptr  18h
.text:00007620
.text:00007620                 push    ebp
.text:00007621                 mov     ebp, esp
.text:00007623                 sub     esp, 8
.text:00007626                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000762D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00007634                 push    0Ah             ; Size
.text:00007636                 mov     eax, [ebp+arg_0]
.text:00007639                 push    eax             ; int
.text:0000763A                 call    ?PrintSpaces@@YGXAAUIBenchPrintCallback@@I@Z ; PrintSpaces(IBenchPrintCallback &,uint)
.text:0000763F                 mov     ecx, [ebp+arg_10]
.text:00007642                 mov     edx, [ecx]
.text:00007644                 mov     [ebp+var_8], edx
.text:00007647                 mov     eax, [ecx+4]
.text:0000764A                 mov     [ebp+var_4], eax
.text:0000764D                 mov     ecx, [ebp+var_8]
.text:00007650                 or      ecx, [ebp+var_4]
.text:00007653                 jnz     short loc_7663
.text:00007655                 mov     [ebp+var_8], 1
.text:0000765C                 mov     [ebp+var_4], 0
.text:00007663
.text:00007663 loc_7663:                               ; CODE XREF: PrintTotals(IBenchPrintCallback &,bool,unsigned __int64,CTotalBenchRes const &)+33j
.text:00007663                 mov     edx, [ebp+arg_C]
.text:00007666                 push    edx
.text:00007667                 mov     eax, [ebp+arg_8]
.text:0000766A                 push    eax
.text:0000766B                 movzx   ecx, [ebp+arg_4]
.text:0000766F                 push    ecx
.text:00007670                 mov     edx, [ebp+arg_10]
.text:00007673                 mov     eax, [ebp+var_4]
.text:00007676                 push    eax
.text:00007677                 mov     ecx, [ebp+var_8]
.text:0000767A                 push    ecx
.text:0000767B                 mov     eax, [edx+0Ch]
.text:0000767E                 push    eax
.text:0000767F                 mov     ecx, [edx+8]
.text:00007682                 push    ecx
.text:00007683                 call    __aulldiv
.text:00007688                 push    edx
.text:00007689                 push    eax
.text:0000768A                 mov     edx, [ebp+arg_10]
.text:0000768D                 mov     eax, [ebp+var_4]
.text:00007690                 push    eax
.text:00007691                 mov     ecx, [ebp+var_8]
.text:00007694                 push    ecx
.text:00007695                 mov     eax, [edx+1Ch]
.text:00007698                 push    eax
.text:00007699                 mov     ecx, [edx+18h]
.text:0000769C                 push    ecx
.text:0000769D                 call    __aulldiv
.text:000076A2                 push    edx
.text:000076A3                 push    eax
.text:000076A4                 mov     edx, [ebp+arg_10]
.text:000076A7                 mov     eax, [ebp+var_4]
.text:000076AA                 push    eax
.text:000076AB                 mov     ecx, [ebp+var_8]
.text:000076AE                 push    ecx
.text:000076AF                 mov     eax, [edx+14h]
.text:000076B2                 push    eax
.text:000076B3                 mov     ecx, [edx+10h]
.text:000076B6                 push    ecx
.text:000076B7                 call    __aulldiv
.text:000076BC                 push    edx
.text:000076BD                 push    eax
.text:000076BE                 mov     edx, [ebp+arg_0]
.text:000076C1                 push    edx
.text:000076C2                 call    ?PrintResults@@YGXAAUIBenchPrintCallback@@_K11_N1@Z ; PrintResults(IBenchPrintCallback &,unsigned __int64,unsigned __int64,unsigned __int64,bool,unsigned __int64)
.text:000076C7                 add     esp, 8
.text:000076CA                 cmp     ebp, esp
.text:000076CC                 call    __RTC_CheckEsp
.text:000076D1                 mov     esp, ebp
.text:000076D3                 pop     ebp
.text:000076D4                 retn    14h
.text:000076D4 ?PrintTotals@@YGXAAUIBenchPrintCallback@@_N_KABUCTotalBenchRes@@@Z endp
.text:000076D4
.text:000076D4 ; ---------------------------------------------------------------------------
.text:000076D7                 align 10h
.text:000076E0
.text:000076E0 ; =============== S U B R O U T I N E =======================================
.text:000076E0
.text:000076E0 ; Attributes: bp-based frame
.text:000076E0
.text:000076E0 ; void __stdcall PrintRequirements(struct IBenchPrintCallback &, char const *, unsigned __int64, char const *, unsigned int)
.text:000076E0 ?PrintRequirements@@YGXAAUIBenchPrintCallback@@PBD_K1I@Z proc near
.text:000076E0                                         ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+70Ap
.text:000076E0                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+118Ep
.text:000076E0
.text:000076E0 arg_0           = dword ptr  8
.text:000076E0 arg_4           = dword ptr  0Ch
.text:000076E0 arg_8           = dword ptr  10h
.text:000076E0 arg_C           = dword ptr  14h
.text:000076E0 arg_10          = dword ptr  18h
.text:000076E0 arg_14          = dword ptr  1Ch
.text:000076E0
.text:000076E0                 push    ebp
.text:000076E1                 mov     ebp, esp
.text:000076E3                 push    esi
.text:000076E4                 mov     esi, esp
.text:000076E6                 push    offset $SG70992 ; "RAM "
.text:000076EB                 mov     eax, [ebp+arg_0]
.text:000076EE                 mov     edx, [eax]
.text:000076F0                 mov     ecx, [ebp+arg_0]
.text:000076F3                 mov     eax, [edx]
.text:000076F5                 call    eax
.text:000076F7                 cmp     esi, esp
.text:000076F9                 call    __RTC_CheckEsp
.text:000076FE                 mov     esi, esp
.text:00007700                 mov     ecx, [ebp+arg_4]
.text:00007703                 push    ecx
.text:00007704                 mov     edx, [ebp+arg_0]
.text:00007707                 mov     eax, [edx]
.text:00007709                 mov     ecx, [ebp+arg_0]
.text:0000770C                 mov     edx, [eax]
.text:0000770E                 call    edx
.text:00007710                 cmp     esi, esp
.text:00007712                 call    __RTC_CheckEsp
.text:00007717                 push    6
.text:00007719                 mov     eax, [ebp+arg_8]
.text:0000771C                 mov     edx, [ebp+arg_C]
.text:0000771F                 mov     cl, 14h
.text:00007721                 call    __aullshr
.text:00007726                 push    edx
.text:00007727                 push    eax
.text:00007728                 mov     eax, [ebp+arg_0]
.text:0000772B                 push    eax
.text:0000772C                 call    ?PrintNumber@@YGXAAUIBenchPrintCallback@@_KH@Z ; PrintNumber(IBenchPrintCallback &,unsigned __int64,int)
.text:00007731                 mov     esi, esp
.text:00007733                 push    offset $SG70993 ; " MB,  # "
.text:00007738                 mov     ecx, [ebp+arg_0]
.text:0000773B                 mov     edx, [ecx]
.text:0000773D                 mov     ecx, [ebp+arg_0]
.text:00007740                 mov     eax, [edx]
.text:00007742                 call    eax
.text:00007744                 cmp     esi, esp
.text:00007746                 call    __RTC_CheckEsp
.text:0000774B                 mov     esi, esp
.text:0000774D                 mov     ecx, [ebp+arg_10]
.text:00007750                 push    ecx
.text:00007751                 mov     edx, [ebp+arg_0]
.text:00007754                 mov     eax, [edx]
.text:00007756                 mov     ecx, [ebp+arg_0]
.text:00007759                 mov     edx, [eax]
.text:0000775B                 call    edx
.text:0000775D                 cmp     esi, esp
.text:0000775F                 call    __RTC_CheckEsp
.text:00007764                 push    3
.text:00007766                 mov     eax, [ebp+arg_14]
.text:00007769                 xor     ecx, ecx
.text:0000776B                 push    ecx
.text:0000776C                 push    eax
.text:0000776D                 mov     edx, [ebp+arg_0]
.text:00007770                 push    edx
.text:00007771                 call    ?PrintNumber@@YGXAAUIBenchPrintCallback@@_KH@Z ; PrintNumber(IBenchPrintCallback &,unsigned __int64,int)
.text:00007776                 mov     eax, [ebp+arg_0]
.text:00007779                 mov     edx, [eax]
.text:0000777B                 mov     esi, esp
.text:0000777D                 mov     ecx, [ebp+arg_0]
.text:00007780                 mov     eax, [edx+4]
.text:00007783                 call    eax
.text:00007785                 cmp     esi, esp
.text:00007787                 call    __RTC_CheckEsp
.text:0000778C                 pop     esi
.text:0000778D                 cmp     ebp, esp
.text:0000778F                 call    __RTC_CheckEsp
.text:00007794                 pop     ebp
.text:00007795                 retn    18h
.text:00007795 ?PrintRequirements@@YGXAAUIBenchPrintCallback@@PBD_K1I@Z endp
.text:00007795
.text:00007795 ; ---------------------------------------------------------------------------
.text:00007798                 align 10h
.text:000077A0
.text:000077A0 ; =============== S U B R O U T I N E =======================================
.text:000077A0
.text:000077A0 ; Attributes: bp-based frame
.text:000077A0
.text:000077A0 ; int __stdcall TotalBench(int, int, int, char, int, int, CBenchCallbackToPrint *)
.text:000077A0 ?TotalBench@@YGJ_KI_NIPAUIBenchPrintCallback@@PAUCBenchCallbackToPrint@@@Z proc near
.text:000077A0                                         ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+16E8p
.text:000077A0
.text:000077A0 var_84          = dword ptr -84h
.text:000077A0 var_80          = dword ptr -80h
.text:000077A0 var_7C          = dword ptr -7Ch
.text:000077A0 var_78          = dword ptr -78h
.text:000077A0 var_74          = byte ptr -74h
.text:000077A0 var_68          = dword ptr -68h
.text:000077A0 var_64          = dword ptr -64h
.text:000077A0 var_60          = qword ptr -60h
.text:000077A0 var_54          = byte ptr -54h
.text:000077A0 var_3C          = dword ptr -3Ch
.text:000077A0 var_14          = dword ptr -14h
.text:000077A0 var_10          = dword ptr -10h
.text:000077A0 var_C           = dword ptr -0Ch
.text:000077A0 var_4           = dword ptr -4
.text:000077A0 arg_0           = dword ptr  8
.text:000077A0 arg_4           = dword ptr  0Ch
.text:000077A0 arg_8           = dword ptr  10h
.text:000077A0 arg_C           = byte ptr  14h
.text:000077A0 arg_10          = dword ptr  18h
.text:000077A0 arg_14          = dword ptr  1Ch
.text:000077A0 arg_18          = dword ptr  20h
.text:000077A0
.text:000077A0                 push    ebp
.text:000077A1                 mov     ebp, esp
.text:000077A3                 push    0FFFFFFFFh
.text:000077A5                 push    offset __ehhandler$?TotalBench@@YGJ_KI_NIPAUIBenchPrintCallback@@PAUCBenchCallbackToPrint@@@Z
.text:000077AA                 mov     eax, large fs:0
.text:000077B0                 push    eax
.text:000077B1                 sub     esp, 78h
.text:000077B4                 push    edi
.text:000077B5                 lea     edi, [ebp+var_84]
.text:000077BB                 mov     ecx, 1Eh
.text:000077C0                 mov     eax, 0CCCCCCCCh
.text:000077C5                 rep stosd
.text:000077C7                 mov     eax, dword ptr ds:___security_cookie
.text:000077CC                 xor     eax, ebp
.text:000077CE                 push    eax             ; struct tagPROPVARIANT *
.text:000077CF                 lea     eax, [ebp+var_C]
.text:000077D2                 mov     large fs:0, eax
.text:000077D8                 mov     [ebp+var_10], 0
.text:000077DF                 jmp     short loc_77EA
.text:000077E1 ; ---------------------------------------------------------------------------
.text:000077E1
.text:000077E1 loc_77E1:                               ; CODE XREF: TotalBench(unsigned __int64,uint,bool,uint,IBenchPrintCallback *,CBenchCallbackToPrint *)+20Aj
.text:000077E1                 mov     eax, [ebp+var_10]
.text:000077E4                 add     eax, 1
.text:000077E7                 mov     [ebp+var_10], eax
.text:000077EA
.text:000077EA loc_77EA:                               ; CODE XREF: TotalBench(unsigned __int64,uint,bool,uint,IBenchPrintCallback *,CBenchCallbackToPrint *)+3Fj
.text:000077EA                 cmp     [ebp+var_10], 11h
.text:000077EE                 jnb     loc_79AF
.text:000077F4                 mov     ecx, [ebp+var_10]
.text:000077F7                 imul    ecx, 18h
.text:000077FA                 add     ecx, offset _g_Bench
.text:00007800                 mov     [ebp+var_14], ecx
.text:00007803                 push    0Ch             ; unsigned int
.text:00007805                 mov     edx, [ebp+var_14]
.text:00007808                 mov     eax, [edx+14h]
.text:0000780B                 push    eax             ; char *
.text:0000780C                 mov     ecx, [ebp+arg_18]
.text:0000780F                 mov     edx, [ecx+58h]
.text:00007812                 push    edx             ; struct IBenchPrintCallback *
.text:00007813                 call    ?PrintLeft@@YGXAAUIBenchPrintCallback@@PBDI@Z ; PrintLeft(IBenchPrintCallback &,char const *,uint)
.text:00007818                 mov     eax, [ebp+arg_18]
.text:0000781B                 mov     ecx, [ebp+var_14]
.text:0000781E                 mov     edx, [ecx+10h]
.text:00007821                 mov     [eax+10h], edx
.text:00007824                 mov     eax, [ebp+arg_18]
.text:00007827                 mov     ecx, [ebp+var_14]
.text:0000782A                 mov     edx, [ecx+0Ch]
.text:0000782D                 mov     [eax+0Ch], edx
.text:00007830                 mov     eax, [ebp+arg_18]
.text:00007833                 mov     ecx, [ebp+var_14]
.text:00007836                 mov     edx, [ecx+8]
.text:00007839                 mov     [eax+8], edx
.text:0000783C                 lea     ecx, [ebp+var_3C]
.text:0000783F                 call    ??0COneMethodInfo@@QAE@XZ ; COneMethodInfo::COneMethodInfo(void)
.text:00007844                 mov     [ebp+var_4], 0
.text:0000784B                 lea     ecx, [ebp+var_54] ; this
.text:0000784E                 call    ??0CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::CPropVariant(void)
.text:00007853                 mov     byte ptr [ebp+var_4], 1
.text:00007857                 mov     eax, [ebp+var_14]
.text:0000785A                 mov     ecx, [eax+14h]
.text:0000785D                 push    ecx             ; struct tagPROPVARIANT *
.text:0000785E                 lea     ecx, [ebp+var_54]
.text:00007861                 call    ??4CPropVariant@NCOM@NWindows@@QAEAAV012@PBD@Z ; NWindows::NCOM::CPropVariant::operator=(char const *)
.text:00007866                 lea     edx, [ebp+var_54]
.text:00007869                 push    edx
.text:0000786A                 lea     ecx, [ebp+var_74]
.text:0000786D                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00007872                 mov     [ebp+var_80], eax
.text:00007875                 mov     eax, [ebp+var_80]
.text:00007878                 mov     [ebp+var_84], eax
.text:0000787E                 mov     byte ptr [ebp+var_4], 2
.text:00007882                 mov     ecx, [ebp+var_84]
.text:00007888                 push    ecx             ; struct UString *
.text:00007889                 lea     ecx, [ebp+var_3C] ; this
.text:0000788C                 call    ?ParseMethodFromPROPVARIANT@COneMethodInfo@@QAEJABVUString@@ABUtagPROPVARIANT@@@Z ; COneMethodInfo::ParseMethodFromPROPVARIANT(UString const &,tagPROPVARIANT const &)
.text:00007891                 mov     dword ptr [ebp+var_60+4], eax
.text:00007894                 mov     byte ptr [ebp+var_4], 1
.text:00007898                 lea     ecx, [ebp+var_74] ; this
.text:0000789B                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000078A0                 cmp     dword ptr [ebp+var_60+4], 0
.text:000078A4                 jz      short loc_78CF
.text:000078A6                 mov     edx, dword ptr [ebp+var_60+4]
.text:000078A9                 mov     [ebp+var_78], edx
.text:000078AC                 mov     byte ptr [ebp+var_4], 0
.text:000078B0                 lea     ecx, [ebp+var_54] ; this
.text:000078B3                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:000078B8                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000078BF                 lea     ecx, [ebp+var_3C] ; this
.text:000078C2                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:000078C7                 mov     eax, [ebp+var_78]
.text:000078CA                 jmp     loc_79B1
.text:000078CF ; ---------------------------------------------------------------------------
.text:000078CF
.text:000078CF loc_78CF:                               ; CODE XREF: TotalBench(unsigned __int64,uint,bool,uint,IBenchPrintCallback *,CBenchCallbackToPrint *)+104j
.text:000078CF                 mov     eax, [ebp+arg_10]
.text:000078D2                 mov     dword ptr [ebp+var_60], eax
.text:000078D5                 movzx   ecx, [ebp+arg_C]
.text:000078D9                 test    ecx, ecx
.text:000078DB                 jnz     short loc_78ED
.text:000078DD                 mov     edx, [ebp+var_14]
.text:000078E0                 cmp     dword ptr [edx+4], 0
.text:000078E4                 jnz     short loc_78ED
.text:000078E6                 mov     dword ptr [ebp+var_60], 0C000h
.text:000078ED
.text:000078ED loc_78ED:                               ; CODE XREF: TotalBench(unsigned __int64,uint,bool,uint,IBenchPrintCallback *,CBenchCallbackToPrint *)+13Bj
.text:000078ED                                         ; TotalBench(unsigned __int64,uint,bool,uint,IBenchPrintCallback *,CBenchCallbackToPrint *)+144j
.text:000078ED                 mov     eax, [ebp+arg_18]
.text:000078F0                 mov     ecx, [ebp+var_14]
.text:000078F3                 mov     edx, [ecx]
.text:000078F5                 mov     [eax+78h], edx
.text:000078F8                 mov     eax, [ebp+arg_18]
.text:000078FB                 mov     ecx, [ebp+var_14]
.text:000078FE                 mov     edx, [ecx]
.text:00007900                 mov     [eax+7Ch], edx
.text:00007903                 mov     eax, [ebp+arg_18]
.text:00007906                 add     eax, 4
.text:00007909                 push    eax             ; CBenchProps *
.text:0000790A                 mov     ecx, [ebp+arg_18]
.text:0000790D                 push    ecx             ; int
.text:0000790E                 mov     edx, [ebp+arg_14]
.text:00007911                 push    edx             ; int
.text:00007912                 mov     eax, [ebp+var_14]
.text:00007915                 mov     ecx, [eax+4]
.text:00007918                 push    ecx
.text:00007919                 mov     edx, dword ptr [ebp+var_60]
.text:0000791C                 push    edx             ; unsigned __int64
.text:0000791D                 lea     eax, [ebp+var_3C]
.text:00007920                 push    eax             ; int
.text:00007921                 mov     ecx, [ebp+arg_8]
.text:00007924                 push    ecx             ; int
.text:00007925                 push    0               ; char
.text:00007927                 mov     edx, [ebp+arg_4]
.text:0000792A                 push    edx             ; int
.text:0000792B                 mov     eax, [ebp+arg_0]
.text:0000792E                 push    eax             ; int
.text:0000792F                 call    ?MethodBench@@YGJ_K_NIABVCOneMethodInfo@@IIPAUIBenchPrintCallback@@PAUIBenchCallback@@PAUCBenchProps@@@Z ; MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)
.text:00007934                 mov     [ebp+var_64], eax
.text:00007937                 cmp     [ebp+var_64], 80004001h
.text:0000793E                 jnz     short loc_7955
.text:00007940                 mov     ecx, [ebp+arg_18]
.text:00007943                 movzx   edx, byte ptr [ecx+60h]
.text:00007947                 test    edx, edx
.text:00007949                 jnz     short loc_7953
.text:0000794B                 mov     ecx, [ebp+arg_18] ; this
.text:0000794E                 call    ?NewLine@CBenchCallbackToPrint@@QAEXXZ ; CBenchCallbackToPrint::NewLine(void)
.text:00007953
.text:00007953 loc_7953:                               ; CODE XREF: TotalBench(unsigned __int64,uint,bool,uint,IBenchPrintCallback *,CBenchCallbackToPrint *)+1A9j
.text:00007953                 jmp     short loc_7987
.text:00007955 ; ---------------------------------------------------------------------------
.text:00007955
.text:00007955 loc_7955:                               ; CODE XREF: TotalBench(unsigned __int64,uint,bool,uint,IBenchPrintCallback *,CBenchCallbackToPrint *)+19Ej
.text:00007955                 mov     eax, [ebp+var_64]
.text:00007958                 mov     [ebp+var_68], eax
.text:0000795B                 cmp     [ebp+var_68], 0
.text:0000795F                 jz      short loc_7987
.text:00007961                 mov     ecx, [ebp+var_68]
.text:00007964                 mov     [ebp+var_7C], ecx
.text:00007967                 mov     byte ptr [ebp+var_4], 0
.text:0000796B                 lea     ecx, [ebp+var_54] ; this
.text:0000796E                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:00007973                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000797A                 lea     ecx, [ebp+var_3C] ; this
.text:0000797D                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:00007982                 mov     eax, [ebp+var_7C]
.text:00007985                 jmp     short loc_79B1
.text:00007987 ; ---------------------------------------------------------------------------
.text:00007987
.text:00007987 loc_7987:                               ; CODE XREF: TotalBench(unsigned __int64,uint,bool,uint,IBenchPrintCallback *,CBenchCallbackToPrint *):loc_7953j
.text:00007987                                         ; TotalBench(unsigned __int64,uint,bool,uint,IBenchPrintCallback *,CBenchCallbackToPrint *)+1BFj
.text:00007987                 mov     ecx, [ebp+arg_18] ; this
.text:0000798A                 call    ?NewLine@CBenchCallbackToPrint@@QAEXXZ ; CBenchCallbackToPrint::NewLine(void)
.text:0000798F                 mov     byte ptr [ebp+var_4], 0
.text:00007993                 lea     ecx, [ebp+var_54] ; this
.text:00007996                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:0000799B                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000079A2                 lea     ecx, [ebp+var_3C] ; this
.text:000079A5                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:000079AA                 jmp     loc_77E1
.text:000079AF ; ---------------------------------------------------------------------------
.text:000079AF
.text:000079AF loc_79AF:                               ; CODE XREF: TotalBench(unsigned __int64,uint,bool,uint,IBenchPrintCallback *,CBenchCallbackToPrint *)+4Ej
.text:000079AF                 xor     eax, eax
.text:000079B1
.text:000079B1 loc_79B1:                               ; CODE XREF: TotalBench(unsigned __int64,uint,bool,uint,IBenchPrintCallback *,CBenchCallbackToPrint *)+12Aj
.text:000079B1                                         ; TotalBench(unsigned __int64,uint,bool,uint,IBenchPrintCallback *,CBenchCallbackToPrint *)+1E5j
.text:000079B1                 push    edx
.text:000079B2                 mov     ecx, ebp
.text:000079B4                 push    eax
.text:000079B5                 lea     edx, $LN19_1
.text:000079BB                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:000079C0                 pop     eax
.text:000079C1                 pop     edx
.text:000079C2                 mov     ecx, [ebp+var_C]
.text:000079C5                 mov     large fs:0, ecx
.text:000079CC                 pop     ecx
.text:000079CD                 pop     edi
.text:000079CE                 add     esp, 84h
.text:000079D4                 cmp     ebp, esp
.text:000079D6                 call    __RTC_CheckEsp
.text:000079DB                 mov     esp, ebp
.text:000079DD                 pop     ebp
.text:000079DE                 retn    1Ch
.text:000079DE ?TotalBench@@YGJ_KI_NIPAUIBenchPrintCallback@@PAUCBenchCallbackToPrint@@@Z endp
.text:000079DE
.text:000079DE ; ---------------------------------------------------------------------------
.text:000079E1                 align 4
.text:000079E4 $LN19_1         dd 2                    ; DATA XREF: TotalBench(unsigned __int64,uint,bool,uint,IBenchPrintCallback *,CBenchCallbackToPrint *)+215o
.text:000079E8                 dd offset $LN18_1
.text:000079EC $LN18_1         dd 0FFFFFFC4h, 24h      ; DATA XREF: .text:000079E8o
.text:000079F4                 dd offset $LN15_0       ; "method"
.text:000079F8                 dd 0FFFFFFACh, 10h
.text:00007A00                 dd offset $LN16_2       ; "propVariant"
.text:00007A04 $LN16_2         db 'propVariant',0      ; DATA XREF: .text:00007A00o
.text:00007A10 $LN15_0         db 'method',0           ; DATA XREF: .text:000079F4o
.text:00007A17                 align 10h
.text:00007A20
.text:00007A20 ; =============== S U B R O U T I N E =======================================
.text:00007A20
.text:00007A20 ; Attributes: bp-based frame
.text:00007A20
.text:00007A20 ; long __stdcall FreqBench(unsigned __int64, unsigned int, struct IBenchPrintCallback *, bool, unsigned __int64 &, unsigned int &)
.text:00007A20 ?FreqBench@@YGJ_KIPAUIBenchPrintCallback@@_NAA_KAAI@Z proc near
.text:00007A20                                         ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1613p
.text:00007A20                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+182Dp
.text:00007A20
.text:00007A20 var_120         = dword ptr -120h
.text:00007A20 var_11C         = dword ptr -11Ch
.text:00007A20 var_118         = dword ptr -118h
.text:00007A20 var_114         = dword ptr -114h
.text:00007A20 var_110         = dword ptr -110h
.text:00007A20 var_10C         = dword ptr -10Ch
.text:00007A20 var_108         = dword ptr -108h
.text:00007A20 var_104         = dword ptr -104h
.text:00007A20 var_100         = dword ptr -100h
.text:00007A20 var_FC          = dword ptr -0FCh
.text:00007A20 var_F8          = dword ptr -0F8h
.text:00007A20 var_F4          = dword ptr -0F4h
.text:00007A20 var_F0          = dword ptr -0F0h
.text:00007A20 var_EC          = qword ptr -0ECh
.text:00007A20 var_E4          = qword ptr -0E4h
.text:00007A20 var_D8          = byte ptr -0D8h
.text:00007A20 var_B8          = dword ptr -0B8h
.text:00007A20 var_B4          = dword ptr -0B4h
.text:00007A20 var_B0          = dword ptr -0B0h
.text:00007A20 var_AC          = dword ptr -0ACh
.text:00007A20 var_A8          = dword ptr -0A8h
.text:00007A20 var_A4          = dword ptr -0A4h
.text:00007A20 var_9C          = dword ptr -9Ch
.text:00007A20 var_98          = dword ptr -98h
.text:00007A20 var_94          = dword ptr -94h
.text:00007A20 var_90          = dword ptr -90h
.text:00007A20 var_8C          = dword ptr -8Ch
.text:00007A20 var_88          = dword ptr -88h
.text:00007A20 var_84          = dword ptr -84h
.text:00007A20 var_80          = dword ptr -80h
.text:00007A20 var_7C          = dword ptr -7Ch
.text:00007A20 var_74          = dword ptr -74h
.text:00007A20 var_70          = dword ptr -70h
.text:00007A20 var_64          = byte ptr -64h
.text:00007A20 var_20          = dword ptr -20h
.text:00007A20 var_1C          = dword ptr -1Ch
.text:00007A20 var_18          = dword ptr -18h
.text:00007A20 var_14          = dword ptr -14h
.text:00007A20 var_10          = dword ptr -10h
.text:00007A20 var_C           = dword ptr -0Ch
.text:00007A20 var_4           = dword ptr -4
.text:00007A20 arg_0           = dword ptr  8
.text:00007A20 arg_4           = dword ptr  0Ch
.text:00007A20 arg_8           = dword ptr  10h
.text:00007A20 arg_C           = dword ptr  14h
.text:00007A20 arg_10          = byte ptr  18h
.text:00007A20 arg_14          = dword ptr  1Ch
.text:00007A20 arg_18          = dword ptr  20h
.text:00007A20
.text:00007A20                 push    ebp
.text:00007A21                 mov     ebp, esp
.text:00007A23                 push    0FFFFFFFFh
.text:00007A25                 push    offset __ehhandler$?FreqBench@@YGJ_KIPAUIBenchPrintCallback@@_NAA_KAAI@Z
.text:00007A2A                 mov     eax, large fs:0
.text:00007A30                 push    eax
.text:00007A31                 sub     esp, 114h
.text:00007A37                 push    esi
.text:00007A38                 push    edi
.text:00007A39                 lea     edi, [ebp+var_120]
.text:00007A3F                 mov     ecx, 45h ; 'E'
.text:00007A44                 mov     eax, 0CCCCCCCCh
.text:00007A49                 rep stosd
.text:00007A4B                 mov     eax, dword ptr ds:___security_cookie
.text:00007A50                 xor     eax, ebp
.text:00007A52                 push    eax
.text:00007A53                 lea     eax, [ebp+var_C]
.text:00007A56                 mov     large fs:0, eax
.text:00007A5C                 mov     eax, [ebp+arg_18]
.text:00007A5F                 mov     dword ptr [eax], 0
.text:00007A65                 mov     ecx, [ebp+arg_14]
.text:00007A68                 mov     dword ptr [ecx], 0
.text:00007A6E                 mov     dword ptr [ecx+4], 0
.text:00007A75                 mov     [ebp+var_10], 100000h
.text:00007A7C                 mov     [ebp+var_14], 80h ; 'Ç'
.text:00007A83                 cmp     [ebp+arg_8], 0
.text:00007A87                 jnz     short loc_7A90
.text:00007A89                 mov     [ebp+arg_8], 1
.text:00007A90
.text:00007A90 loc_7A90:                               ; CODE XREF: FreqBench(unsigned __int64,uint,IBenchPrintCallback *,bool,unsigned __int64 &,uint &)+67j
.text:00007A90                 cmp     [ebp+var_10], 0
.text:00007A94                 jnz     short loc_7AA2
.text:00007A96                 mov     [ebp+var_114], 1
.text:00007AA0                 jmp     short loc_7AAB
.text:00007AA2 ; ---------------------------------------------------------------------------
.text:00007AA2
.text:00007AA2 loc_7AA2:                               ; CODE XREF: FreqBench(unsigned __int64,uint,IBenchPrintCallback *,bool,unsigned __int64 &,uint &)+74j
.text:00007AA2                 mov     edx, [ebp+var_10]
.text:00007AA5                 mov     [ebp+var_114], edx
.text:00007AAB
.text:00007AAB loc_7AAB:                               ; CODE XREF: FreqBench(unsigned __int64,uint,IBenchPrintCallback *,bool,unsigned __int64 &,uint &)+80j
.text:00007AAB                 mov     eax, [ebp+var_114]
.text:00007AB1                 mov     [ebp+var_18], eax
.text:00007AB4                 mov     ecx, [ebp+var_14]
.text:00007AB7                 xor     edx, edx
.text:00007AB9                 push    edx
.text:00007ABA                 push    ecx
.text:00007ABB                 mov     eax, [ebp+arg_4]
.text:00007ABE                 push    eax
.text:00007ABF                 mov     ecx, [ebp+arg_0]
.text:00007AC2                 push    ecx
.text:00007AC3                 call    __aulldiv
.text:00007AC8                 mov     ecx, [ebp+var_18]
.text:00007ACB                 xor     esi, esi
.text:00007ACD                 push    esi
.text:00007ACE                 push    ecx
.text:00007ACF                 push    edx
.text:00007AD0                 push    eax
.text:00007AD1                 call    __aulldiv
.text:00007AD6                 mov     [ebp+var_20], eax
.text:00007AD9                 mov     [ebp+var_1C], edx
.text:00007ADC                 mov     edx, [ebp+var_20]
.text:00007ADF                 or      edx, [ebp+var_1C]
.text:00007AE2                 jnz     short loc_7AF2
.text:00007AE4                 mov     [ebp+var_20], 1
.text:00007AEB                 mov     [ebp+var_1C], 0
.text:00007AF2
.text:00007AF2 loc_7AF2:                               ; CODE XREF: FreqBench(unsigned __int64,uint,IBenchPrintCallback *,bool,unsigned __int64 &,uint &)+C2j
.text:00007AF2                 lea     ecx, [ebp+var_64] ; this
.text:00007AF5                 call    ??0CBenchInfoCalc@@QAE@XZ ; CBenchInfoCalc::CBenchInfoCalc(void)
.text:00007AFA                 lea     ecx, [ebp+var_74] ; this
.text:00007AFD                 call    ??0CFreqThreads@@QAE@XZ ; CFreqThreads::CFreqThreads(void)
.text:00007B02                 mov     [ebp+var_4], 0
.text:00007B09                 cmp     [ebp+arg_8], 1
.text:00007B0D                 jbe     loc_7D04
.text:00007B13                 mov     eax, [ebp+arg_8]
.text:00007B16                 mov     [ebp+var_F4], eax
.text:00007B1C                 xor     ecx, ecx
.text:00007B1E                 mov     eax, [ebp+var_F4]
.text:00007B24                 mov     edx, 20h ; ' '
.text:00007B29                 mul     edx
.text:00007B2B                 seto    cl
.text:00007B2E                 neg     ecx
.text:00007B30                 or      ecx, eax
.text:00007B32                 xor     eax, eax
.text:00007B34                 add     ecx, 4
.text:00007B37                 setb    al
.text:00007B3A                 neg     eax
.text:00007B3C                 or      eax, ecx
.text:00007B3E                 push    eax             ; unsigned int
.text:00007B3F                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00007B44                 add     esp, 4
.text:00007B47                 mov     [ebp+var_FC], eax
.text:00007B4D                 mov     byte ptr [ebp+var_4], 1
.text:00007B51                 cmp     [ebp+var_FC], 0
.text:00007B58                 jz      short loc_7B9B
.text:00007B5A                 mov     ecx, [ebp+var_FC]
.text:00007B60                 mov     edx, [ebp+var_F4]
.text:00007B66                 mov     [ecx], edx
.text:00007B68                 push    offset ??1CFreqInfo@@QAE@XZ ; CFreqInfo::~CFreqInfo(void)
.text:00007B6D                 push    offset ??0CFreqInfo@@QAE@XZ ; CFreqInfo::CFreqInfo(void)
.text:00007B72                 mov     eax, [ebp+var_F4]
.text:00007B78                 push    eax
.text:00007B79                 push    20h ; ' '
.text:00007B7B                 mov     ecx, [ebp+var_FC]
.text:00007B81                 add     ecx, 4
.text:00007B84                 push    ecx
.text:00007B85                 call    ??_L@YGXPAXIHP6EX0@Z1@Z ; `eh vector constructor iterator'(void *,uint,int,void (*)(void *),void (*)(void *))
.text:00007B8A                 mov     edx, [ebp+var_FC]
.text:00007B90                 add     edx, 4
.text:00007B93                 mov     [ebp+var_118], edx
.text:00007B99                 jmp     short loc_7BA5
.text:00007B9B ; ---------------------------------------------------------------------------
.text:00007B9B
.text:00007B9B loc_7B9B:                               ; CODE XREF: FreqBench(unsigned __int64,uint,IBenchPrintCallback *,bool,unsigned __int64 &,uint &)+138j
.text:00007B9B                 mov     [ebp+var_118], 0
.text:00007BA5
.text:00007BA5 loc_7BA5:                               ; CODE XREF: FreqBench(unsigned __int64,uint,IBenchPrintCallback *,bool,unsigned __int64 &,uint &)+179j
.text:00007BA5                 mov     eax, [ebp+var_118]
.text:00007BAB                 mov     [ebp+var_F8], eax
.text:00007BB1                 mov     byte ptr [ebp+var_4], 0
.text:00007BB5                 mov     ecx, [ebp+var_F8]
.text:00007BBB                 mov     [ebp+var_74], ecx
.text:00007BBE                 mov     [ebp+var_7C], 0
.text:00007BC5                 jmp     short loc_7BD0
.text:00007BC7 ; ---------------------------------------------------------------------------
.text:00007BC7
.text:00007BC7 loc_7BC7:                               ; CODE XREF: FreqBench(unsigned __int64,uint,IBenchPrintCallback *,bool,unsigned __int64 &,uint &)+1EFj
.text:00007BC7                 mov     edx, [ebp+var_7C]
.text:00007BCA                 add     edx, 1
.text:00007BCD                 mov     [ebp+var_7C], edx
.text:00007BD0
.text:00007BD0 loc_7BD0:                               ; CODE XREF: FreqBench(unsigned __int64,uint,IBenchPrintCallback *,bool,unsigned __int64 &,uint &)+1A5j
.text:00007BD0                 mov     eax, [ebp+var_7C]
.text:00007BD3                 cmp     eax, [ebp+arg_8]
.text:00007BD6                 jnb     short loc_7C11
.text:00007BD8                 mov     ecx, [ebp+var_7C]
.text:00007BDB                 shl     ecx, 5
.text:00007BDE                 add     ecx, [ebp+var_74]
.text:00007BE1                 mov     [ebp+var_80], ecx
.text:00007BE4                 mov     edx, [ebp+var_80]
.text:00007BE7                 mov     eax, [ebp+arg_C]
.text:00007BEA                 mov     [edx+4], eax
.text:00007BED                 mov     ecx, [ebp+var_80]
.text:00007BF0                 mov     dword ptr [ecx+8], 0
.text:00007BF7                 mov     edx, [ebp+var_80]
.text:00007BFA                 mov     eax, [ebp+var_20]
.text:00007BFD                 mov     [edx+18h], eax
.text:00007C00                 mov     ecx, [ebp+var_1C]
.text:00007C03                 mov     [edx+1Ch], ecx
.text:00007C06                 mov     edx, [ebp+var_80]
.text:00007C09                 mov     eax, [ebp+var_10]
.text:00007C0C                 mov     [edx+10h], eax
.text:00007C0F                 jmp     short loc_7BC7
.text:00007C11 ; ---------------------------------------------------------------------------
.text:00007C11
.text:00007C11 loc_7C11:                               ; CODE XREF: FreqBench(unsigned __int64,uint,IBenchPrintCallback *,bool,unsigned __int64 &,uint &)+1B6j
.text:00007C11                 lea     ecx, [ebp+var_64] ; this
.text:00007C14                 call    ?SetStartTime@CBenchInfoCalc@@QAEXXZ ; CBenchInfoCalc::SetStartTime(void)
.text:00007C19                 mov     [ebp+var_7C], 0
.text:00007C20                 jmp     short loc_7C2B
.text:00007C22 ; ---------------------------------------------------------------------------
.text:00007C22
.text:00007C22 loc_7C22:                               ; CODE XREF: FreqBench(unsigned __int64,uint,IBenchPrintCallback *,bool,unsigned __int64 &,uint &)+277j
.text:00007C22                 mov     ecx, [ebp+var_7C]
.text:00007C25                 add     ecx, 1
.text:00007C28                 mov     [ebp+var_7C], ecx
.text:00007C2B
.text:00007C2B loc_7C2B:                               ; CODE XREF: FreqBench(unsigned __int64,uint,IBenchPrintCallback *,bool,unsigned __int64 &,uint &)+200j
.text:00007C2B                 mov     edx, [ebp+var_7C]
.text:00007C2E                 cmp     edx, [ebp+arg_8]
.text:00007C31                 jnb     short loc_7C99
.text:00007C33                 mov     eax, [ebp+var_7C]
.text:00007C36                 shl     eax, 5
.text:00007C39                 add     eax, [ebp+var_74]
.text:00007C3C                 mov     [ebp+var_84], eax
.text:00007C42                 mov     ecx, [ebp+var_84]
.text:00007C48                 push    ecx             ; void *
.text:00007C49                 push    offset ?FreqThreadFunction@@YGIPAX@Z ; unsigned int (__stdcall *)(void *)
.text:00007C4E                 mov     ecx, [ebp+var_84] ; this
.text:00007C54                 call    ?Create@CThread@NWindows@@QAEIP6GIPAX@Z0@Z ; NWindows::CThread::Create(uint (*)(void *),void *)
.text:00007C59                 mov     [ebp+var_88], eax
.text:00007C5F                 cmp     [ebp+var_88], 0
.text:00007C66                 jz      short loc_7C8E
.text:00007C68                 mov     edx, [ebp+var_88]
.text:00007C6E                 mov     [ebp+var_100], edx
.text:00007C74                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00007C7B                 lea     ecx, [ebp+var_74] ; this
.text:00007C7E                 call    ??1CFreqThreads@@QAE@XZ ; CFreqThreads::~CFreqThreads(void)
.text:00007C83                 mov     eax, [ebp+var_100]
.text:00007C89                 jmp     loc_7F8A
.text:00007C8E ; ---------------------------------------------------------------------------
.text:00007C8E
.text:00007C8E loc_7C8E:                               ; CODE XREF: FreqBench(unsigned __int64,uint,IBenchPrintCallback *,bool,unsigned __int64 &,uint &)+246j
.text:00007C8E                 mov     eax, [ebp+var_70]
.text:00007C91                 add     eax, 1
.text:00007C94                 mov     [ebp+var_70], eax
.text:00007C97                 jmp     short loc_7C22
.text:00007C99 ; ---------------------------------------------------------------------------
.text:00007C99
.text:00007C99 loc_7C99:                               ; CODE XREF: FreqBench(unsigned __int64,uint,IBenchPrintCallback *,bool,unsigned __int64 &,uint &)+211j
.text:00007C99                 lea     ecx, [ebp+var_74] ; this
.text:00007C9C                 call    ?WaitAll@CFreqThreads@@QAEXXZ ; CFreqThreads::WaitAll(void)
.text:00007CA1                 mov     [ebp+var_7C], 0
.text:00007CA8                 jmp     short loc_7CB3
.text:00007CAA ; ---------------------------------------------------------------------------
.text:00007CAA
.text:00007CAA loc_7CAA:                               ; CODE XREF: FreqBench(unsigned __int64,uint,IBenchPrintCallback *,bool,unsigned __int64 &,uint &):loc_7CFDj
.text:00007CAA                 mov     ecx, [ebp+var_7C]
.text:00007CAD                 add     ecx, 1
.text:00007CB0                 mov     [ebp+var_7C], ecx
.text:00007CB3
.text:00007CB3 loc_7CB3:                               ; CODE XREF: FreqBench(unsigned __int64,uint,IBenchPrintCallback *,bool,unsigned __int64 &,uint &)+288j
.text:00007CB3                 mov     edx, [ebp+var_7C]
.text:00007CB6                 cmp     edx, [ebp+arg_8]
.text:00007CB9                 jnb     short loc_7CFF
.text:00007CBB                 mov     eax, [ebp+var_7C]
.text:00007CBE                 shl     eax, 5
.text:00007CC1                 mov     ecx, [ebp+var_74]
.text:00007CC4                 mov     edx, [ecx+eax+8]
.text:00007CC8                 mov     [ebp+var_8C], edx
.text:00007CCE                 cmp     [ebp+var_8C], 0
.text:00007CD5                 jz      short loc_7CFD
.text:00007CD7                 mov     eax, [ebp+var_8C]
.text:00007CDD                 mov     [ebp+var_104], eax
.text:00007CE3                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00007CEA                 lea     ecx, [ebp+var_74] ; this
.text:00007CED                 call    ??1CFreqThreads@@QAE@XZ ; CFreqThreads::~CFreqThreads(void)
.text:00007CF2                 mov     eax, [ebp+var_104]
.text:00007CF8                 jmp     loc_7F8A
.text:00007CFD ; ---------------------------------------------------------------------------
.text:00007CFD
.text:00007CFD loc_7CFD:                               ; CODE XREF: FreqBench(unsigned __int64,uint,IBenchPrintCallback *,bool,unsigned __int64 &,uint &)+2B5j
.text:00007CFD                 jmp     short loc_7CAA
.text:00007CFF ; ---------------------------------------------------------------------------
.text:00007CFF
.text:00007CFF loc_7CFF:                               ; CODE XREF: FreqBench(unsigned __int64,uint,IBenchPrintCallback *,bool,unsigned __int64 &,uint &)+299j
.text:00007CFF                 jmp     loc_7DD9
.text:00007D04 ; ---------------------------------------------------------------------------
.text:00007D04
.text:00007D04 loc_7D04:                               ; CODE XREF: FreqBench(unsigned __int64,uint,IBenchPrintCallback *,bool,unsigned __int64 &,uint &)+EDj
.text:00007D04                 lea     ecx, [ebp+var_64] ; this
.text:00007D07                 call    ?SetStartTime@CBenchInfoCalc@@QAEXXZ ; CBenchInfoCalc::SetStartTime(void)
.text:00007D0C                 mov     ecx, ds:?g_BenchCpuFreqTemp@@3IA ; uint g_BenchCpuFreqTemp
.text:00007D12                 mov     [ebp+var_90], ecx
.text:00007D18                 mov     edx, [ebp+var_20]
.text:00007D1B                 mov     [ebp+var_98], edx
.text:00007D21                 mov     eax, [ebp+var_1C]
.text:00007D24                 mov     [ebp+var_94], eax
.text:00007D2A                 jmp     short loc_7D4A
.text:00007D2C ; ---------------------------------------------------------------------------
.text:00007D2C
.text:00007D2C loc_7D2C:                               ; CODE XREF: FreqBench(unsigned __int64,uint,IBenchPrintCallback *,bool,unsigned __int64 &,uint &)+3A4j
.text:00007D2C                 mov     ecx, [ebp+var_98]
.text:00007D32                 sub     ecx, 1
.text:00007D35                 mov     edx, [ebp+var_94]
.text:00007D3B                 sbb     edx, 0
.text:00007D3E                 mov     [ebp+var_98], ecx
.text:00007D44                 mov     [ebp+var_94], edx
.text:00007D4A
.text:00007D4A loc_7D4A:                               ; CODE XREF: FreqBench(unsigned __int64,uint,IBenchPrintCallback *,bool,unsigned __int64 &,uint &)+30Aj
.text:00007D4A                 cmp     [ebp+var_94], 0
.text:00007D51                 ja      short loc_7D5C
.text:00007D53                 cmp     [ebp+var_98], 0
.text:00007D5A                 jbe     short loc_7DC9
.text:00007D5C
.text:00007D5C loc_7D5C:                               ; CODE XREF: FreqBench(unsigned __int64,uint,IBenchPrintCallback *,bool,unsigned __int64 &,uint &)+331j
.text:00007D5C                 mov     eax, [ebp+arg_C]
.text:00007D5F                 mov     edx, [eax]
.text:00007D61                 mov     esi, esp
.text:00007D63                 mov     ecx, [ebp+arg_C]
.text:00007D66                 mov     eax, [edx+8]
.text:00007D69                 call    eax
.text:00007D6B                 cmp     esi, esp
.text:00007D6D                 call    __RTC_CheckEsp
.text:00007D72                 mov     [ebp+var_9C], eax
.text:00007D78                 cmp     [ebp+var_9C], 0
.text:00007D7F                 jz      short loc_7DA7
.text:00007D81                 mov     ecx, [ebp+var_9C]
.text:00007D87                 mov     [ebp+var_108], ecx
.text:00007D8D                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00007D94                 lea     ecx, [ebp+var_74] ; this
.text:00007D97                 call    ??1CFreqThreads@@QAE@XZ ; CFreqThreads::~CFreqThreads(void)
.text:00007D9C                 mov     eax, [ebp+var_108]
.text:00007DA2                 jmp     loc_7F8A
.text:00007DA7 ; ---------------------------------------------------------------------------
.text:00007DA7
.text:00007DA7 loc_7DA7:                               ; CODE XREF: FreqBench(unsigned __int64,uint,IBenchPrintCallback *,bool,unsigned __int64 &,uint &)+35Fj
.text:00007DA7                 mov     edx, ds:?g_BenchCpuFreqTemp@@3IA ; uint g_BenchCpuFreqTemp
.text:00007DAD                 push    edx
.text:00007DAE                 mov     eax, [ebp+var_10]
.text:00007DB1                 push    eax
.text:00007DB2                 mov     ecx, [ebp+var_90]
.text:00007DB8                 push    ecx
.text:00007DB9                 call    _CountCpuFreq@12 ; CountCpuFreq(x,x,x)
.text:00007DBE                 mov     [ebp+var_90], eax
.text:00007DC4                 jmp     loc_7D2C
.text:00007DC9 ; ---------------------------------------------------------------------------
.text:00007DC9
.text:00007DC9 loc_7DC9:                               ; CODE XREF: FreqBench(unsigned __int64,uint,IBenchPrintCallback *,bool,unsigned __int64 &,uint &)+33Aj
.text:00007DC9                 mov     edx, [ebp+arg_18]
.text:00007DCC                 mov     eax, [edx]
.text:00007DCE                 add     eax, [ebp+var_90]
.text:00007DD4                 mov     ecx, [ebp+arg_18]
.text:00007DD7                 mov     [ecx], eax
.text:00007DD9
.text:00007DD9 loc_7DD9:                               ; CODE XREF: FreqBench(unsigned __int64,uint,IBenchPrintCallback *,bool,unsigned __int64 &,uint &):loc_7CFFj
.text:00007DD9                 lea     ecx, [ebp+var_D8] ; this
.text:00007DDF                 call    ??0CBenchInfo@@QAE@XZ ; CBenchInfo::CBenchInfo(void)
.text:00007DE4                 lea     edx, [ebp+var_D8]
.text:00007DEA                 push    edx             ; struct CBenchInfo *
.text:00007DEB                 lea     ecx, [ebp+var_64] ; this
.text:00007DEE                 call    ?SetFinishTime@CBenchInfoCalc@@QAEXAAUCBenchInfo@@@Z ; CBenchInfoCalc::SetFinishTime(CBenchInfo &)
.text:00007DF3                 mov     [ebp+var_B8], 0
.text:00007DFD                 mov     [ebp+var_B4], 0
.text:00007E07                 mov     [ebp+var_B0], 0
.text:00007E11                 mov     [ebp+var_AC], 0
.text:00007E1B                 mov     [ebp+var_A8], 1
.text:00007E25                 mov     [ebp+var_A4], 0
.text:00007E2F                 cmp     [ebp+arg_C], 0
.text:00007E33                 jz      loc_7F6B
.text:00007E39                 mov     eax, [ebp+var_10]
.text:00007E3C                 xor     ecx, ecx
.text:00007E3E                 push    ecx
.text:00007E3F                 push    eax
.text:00007E40                 mov     edx, [ebp+var_1C]
.text:00007E43                 push    edx
.text:00007E44                 mov     eax, [ebp+var_20]
.text:00007E47                 push    eax
.text:00007E48                 call    __allmul
.text:00007E4D                 mov     ecx, [ebp+arg_8]
.text:00007E50                 xor     esi, esi
.text:00007E52                 push    esi
.text:00007E53                 push    ecx
.text:00007E54                 push    edx
.text:00007E55                 push    eax
.text:00007E56                 call    __allmul
.text:00007E5B                 mov     ecx, [ebp+var_14]
.text:00007E5E                 xor     esi, esi
.text:00007E60                 push    esi
.text:00007E61                 push    ecx
.text:00007E62                 push    edx
.text:00007E63                 push    eax
.text:00007E64                 call    __allmul
.text:00007E69                 mov     dword ptr [ebp+var_E4], eax
.text:00007E6F                 mov     dword ptr [ebp+var_E4+4], edx
.text:00007E75                 mov     edx, dword ptr [ebp+var_E4+4]
.text:00007E7B                 push    edx
.text:00007E7C                 mov     eax, dword ptr [ebp+var_E4]
.text:00007E82                 push    eax             ; unsigned __int64
.text:00007E83                 lea     ecx, [ebp+var_D8] ; this
.text:00007E89                 call    ?GetSpeed@CBenchInfo@@QBE_K_K@Z ; CBenchInfo::GetSpeed(unsigned __int64)
.text:00007E8E                 mov     dword ptr [ebp+var_EC], eax
.text:00007E94                 mov     dword ptr [ebp+var_EC+4], edx
.text:00007E9A                 mov     ecx, [ebp+arg_8]
.text:00007E9D                 xor     edx, edx
.text:00007E9F                 push    edx
.text:00007EA0                 push    ecx
.text:00007EA1                 mov     eax, dword ptr [ebp+var_EC+4]
.text:00007EA7                 push    eax
.text:00007EA8                 mov     ecx, dword ptr [ebp+var_EC]
.text:00007EAE                 push    ecx
.text:00007EAF                 call    __aulldiv
.text:00007EB4                 mov     ecx, [ebp+arg_14]
.text:00007EB7                 mov     [ecx], eax
.text:00007EB9                 mov     [ecx+4], edx
.text:00007EBC                 movzx   edx, [ebp+arg_10]
.text:00007EC0                 test    edx, edx
.text:00007EC2                 jz      short loc_7EDA
.text:00007EC4                 mov     eax, [ebp+arg_14]
.text:00007EC7                 mov     ecx, [eax]
.text:00007EC9                 mov     [ebp+var_120], ecx
.text:00007ECF                 mov     edx, [eax+4]
.text:00007ED2                 mov     [ebp+var_11C], edx
.text:00007ED8                 jmp     short loc_7EEE
.text:00007EDA ; ---------------------------------------------------------------------------
.text:00007EDA
.text:00007EDA loc_7EDA:                               ; CODE XREF: FreqBench(unsigned __int64,uint,IBenchPrintCallback *,bool,unsigned __int64 &,uint &)+4A2j
.text:00007EDA                 mov     [ebp+var_120], 0
.text:00007EE4                 mov     [ebp+var_11C], 0
.text:00007EEE
.text:00007EEE loc_7EEE:                               ; CODE XREF: FreqBench(unsigned __int64,uint,IBenchPrintCallback *,bool,unsigned __int64 &,uint &)+4B8j
.text:00007EEE                 push    0               ; int
.text:00007EF0                 mov     eax, [ebp+var_11C]
.text:00007EF6                 push    eax             ; int
.text:00007EF7                 mov     ecx, [ebp+var_120]
.text:00007EFD                 push    ecx             ; int
.text:00007EFE                 movzx   edx, [ebp+arg_10]
.text:00007F02                 push    edx             ; char
.text:00007F03                 mov     eax, dword ptr [ebp+var_EC+4]
.text:00007F09                 push    eax
.text:00007F0A                 mov     ecx, dword ptr [ebp+var_EC]
.text:00007F10                 push    ecx             ; unsigned __int64
.text:00007F11                 push    0               ; int
.text:00007F13                 lea     edx, [ebp+var_D8]
.text:00007F19                 push    edx             ; CBenchInfo *
.text:00007F1A                 mov     eax, [ebp+arg_C]
.text:00007F1D                 push    eax             ; int
.text:00007F1E                 call    ?PrintResults@@YGXPAUIBenchPrintCallback@@ABUCBenchInfo@@I_K_N2PAUCTotalBenchRes@@@Z ; PrintResults(IBenchPrintCallback *,CBenchInfo const &,uint,unsigned __int64,bool,unsigned __int64,CTotalBenchRes *)
.text:00007F23                 mov     ecx, [ebp+arg_C]
.text:00007F26                 mov     edx, [ecx]
.text:00007F28                 mov     esi, esp
.text:00007F2A                 mov     ecx, [ebp+arg_C]
.text:00007F2D                 mov     eax, [edx+8]
.text:00007F30                 call    eax
.text:00007F32                 cmp     esi, esp
.text:00007F34                 call    __RTC_CheckEsp
.text:00007F39                 mov     [ebp+var_F0], eax
.text:00007F3F                 cmp     [ebp+var_F0], 0
.text:00007F46                 jz      short loc_7F6B
.text:00007F48                 mov     ecx, [ebp+var_F0]
.text:00007F4E                 mov     [ebp+var_10C], ecx
.text:00007F54                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00007F5B                 lea     ecx, [ebp+var_74] ; this
.text:00007F5E                 call    ??1CFreqThreads@@QAE@XZ ; CFreqThreads::~CFreqThreads(void)
.text:00007F63                 mov     eax, [ebp+var_10C]
.text:00007F69                 jmp     short loc_7F8A
.text:00007F6B ; ---------------------------------------------------------------------------
.text:00007F6B
.text:00007F6B loc_7F6B:                               ; CODE XREF: FreqBench(unsigned __int64,uint,IBenchPrintCallback *,bool,unsigned __int64 &,uint &)+413j
.text:00007F6B                                         ; FreqBench(unsigned __int64,uint,IBenchPrintCallback *,bool,unsigned __int64 &,uint &)+526j
.text:00007F6B                 mov     [ebp+var_110], 0
.text:00007F75                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00007F7C                 lea     ecx, [ebp+var_74] ; this
.text:00007F7F                 call    ??1CFreqThreads@@QAE@XZ ; CFreqThreads::~CFreqThreads(void)
.text:00007F84                 mov     eax, [ebp+var_110]
.text:00007F8A
.text:00007F8A loc_7F8A:                               ; CODE XREF: FreqBench(unsigned __int64,uint,IBenchPrintCallback *,bool,unsigned __int64 &,uint &)+269j
.text:00007F8A                                         ; FreqBench(unsigned __int64,uint,IBenchPrintCallback *,bool,unsigned __int64 &,uint &)+2D8j ...
.text:00007F8A                 push    edx
.text:00007F8B                 mov     ecx, ebp
.text:00007F8D                 push    eax
.text:00007F8E                 lea     edx, $LN38_0
.text:00007F94                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00007F99                 pop     eax
.text:00007F9A                 pop     edx
.text:00007F9B                 mov     ecx, [ebp+var_C]
.text:00007F9E                 mov     large fs:0, ecx
.text:00007FA5                 pop     ecx
.text:00007FA6                 pop     edi
.text:00007FA7                 pop     esi
.text:00007FA8                 add     esp, 120h
.text:00007FAE                 cmp     ebp, esp
.text:00007FB0                 call    __RTC_CheckEsp
.text:00007FB5                 mov     esp, ebp
.text:00007FB7                 pop     ebp
.text:00007FB8                 retn    1Ch
.text:00007FB8 ?FreqBench@@YGJ_KIPAUIBenchPrintCallback@@_NAA_KAAI@Z endp
.text:00007FB8
.text:00007FB8 ; ---------------------------------------------------------------------------
.text:00007FBB                 align 4
.text:00007FBC $LN38_0         dd 3                    ; DATA XREF: FreqBench(unsigned __int64,uint,IBenchPrintCallback *,bool,unsigned __int64 &,uint &)+56Eo
.text:00007FC0                 dd offset $LN37
.text:00007FC4 $LN37           dd 0FFFFFF9Ch, 40h      ; DATA XREF: .text:00007FC0o
.text:00007FCC                 dd offset $LN33         ; "progressInfoSpec"
.text:00007FD0                 dd 0FFFFFF8Ch, 8
.text:00007FD8                 dd offset $LN34_0       ; "threads"
.text:00007FDC                 dd 0FFFFFF28h, 38h
.text:00007FE4                 dd offset $LN35_0       ; "info"
.text:00007FE8 $LN35_0         db 'info',0             ; DATA XREF: .text:00007FE4o
.text:00007FED $LN34_0         db 'threads',0          ; DATA XREF: .text:00007FD8o
.text:00007FF5 $LN33           db 'progressInfoSpec',0 ; DATA XREF: .text:00007FCCo
.text:00008006                 align 10h
.text:00008010
.text:00008010 ; =============== S U B R O U T I N E =======================================
.text:00008010
.text:00008010 ; Attributes: bp-based frame
.text:00008010
.text:00008010 ; unsigned int __stdcall FreqThreadFunction(void *)
.text:00008010 ?FreqThreadFunction@@YGIPAX@Z proc near ; DATA XREF: FreqBench(unsigned __int64,uint,IBenchPrintCallback *,bool,unsigned __int64 &,uint &)+229o
.text:00008010
.text:00008010 var_10          = dword ptr -10h
.text:00008010 var_C           = dword ptr -0Ch
.text:00008010 var_8           = dword ptr -8
.text:00008010 var_4           = dword ptr -4
.text:00008010 arg_0           = dword ptr  8
.text:00008010
.text:00008010                 push    ebp
.text:00008011                 mov     ebp, esp
.text:00008013                 sub     esp, 10h
.text:00008016                 push    esi
.text:00008017                 mov     eax, 0CCCCCCCCh
.text:0000801C                 mov     [ebp+var_10], eax
.text:0000801F                 mov     [ebp+var_C], eax
.text:00008022                 mov     [ebp+var_8], eax
.text:00008025                 mov     [ebp+var_4], eax
.text:00008028                 mov     eax, [ebp+arg_0]
.text:0000802B                 mov     [ebp+var_4], eax
.text:0000802E                 mov     ecx, ds:?g_BenchCpuFreqTemp@@3IA ; uint g_BenchCpuFreqTemp
.text:00008034                 mov     [ebp+var_8], ecx
.text:00008037                 mov     edx, [ebp+var_4]
.text:0000803A                 mov     eax, [edx+18h]
.text:0000803D                 mov     [ebp+var_10], eax
.text:00008040                 mov     ecx, [edx+1Ch]
.text:00008043                 mov     [ebp+var_C], ecx
.text:00008046                 jmp     short loc_805A
.text:00008048 ; ---------------------------------------------------------------------------
.text:00008048
.text:00008048 loc_8048:                               ; CODE XREF: FreqThreadFunction(void *)+9Ej
.text:00008048                 mov     edx, [ebp+var_10]
.text:0000804B                 sub     edx, 1
.text:0000804E                 mov     eax, [ebp+var_C]
.text:00008051                 sbb     eax, 0
.text:00008054                 mov     [ebp+var_10], edx
.text:00008057                 mov     [ebp+var_C], eax
.text:0000805A
.text:0000805A loc_805A:                               ; CODE XREF: FreqThreadFunction(void *)+36j
.text:0000805A                 cmp     [ebp+var_C], 0
.text:0000805E                 ja      short loc_8066
.text:00008060                 cmp     [ebp+var_10], 0
.text:00008064                 jbe     short loc_80B0
.text:00008066
.text:00008066 loc_8066:                               ; CODE XREF: FreqThreadFunction(void *)+4Ej
.text:00008066                 mov     ecx, [ebp+var_4]
.text:00008069                 mov     edx, [ecx+4]
.text:0000806C                 mov     eax, [ebp+var_4]
.text:0000806F                 mov     ecx, [eax+4]
.text:00008072                 mov     edx, [edx]
.text:00008074                 mov     esi, esp
.text:00008076                 mov     eax, [edx+8]
.text:00008079                 call    eax
.text:0000807B                 cmp     esi, esp
.text:0000807D                 call    __RTC_CheckEsp
.text:00008082                 mov     ecx, [ebp+var_4]
.text:00008085                 mov     [ecx+8], eax
.text:00008088                 mov     edx, [ebp+var_4]
.text:0000808B                 cmp     dword ptr [edx+8], 0
.text:0000808F                 jz      short loc_8095
.text:00008091                 xor     eax, eax
.text:00008093                 jmp     short loc_80BB
.text:00008095 ; ---------------------------------------------------------------------------
.text:00008095
.text:00008095 loc_8095:                               ; CODE XREF: FreqThreadFunction(void *)+7Fj
.text:00008095                 mov     eax, ds:?g_BenchCpuFreqTemp@@3IA ; uint g_BenchCpuFreqTemp
.text:0000809A                 push    eax
.text:0000809B                 mov     ecx, [ebp+var_4]
.text:0000809E                 mov     edx, [ecx+10h]
.text:000080A1                 push    edx
.text:000080A2                 mov     eax, [ebp+var_8]
.text:000080A5                 push    eax
.text:000080A6                 call    _CountCpuFreq@12 ; CountCpuFreq(x,x,x)
.text:000080AB                 mov     [ebp+var_8], eax
.text:000080AE                 jmp     short loc_8048
.text:000080B0 ; ---------------------------------------------------------------------------
.text:000080B0
.text:000080B0 loc_80B0:                               ; CODE XREF: FreqThreadFunction(void *)+54j
.text:000080B0                 mov     ecx, [ebp+var_4]
.text:000080B3                 mov     edx, [ebp+var_8]
.text:000080B6                 mov     [ecx+0Ch], edx
.text:000080B9                 xor     eax, eax
.text:000080BB
.text:000080BB loc_80BB:                               ; CODE XREF: FreqThreadFunction(void *)+83j
.text:000080BB                 pop     esi
.text:000080BC                 add     esp, 10h
.text:000080BF                 cmp     ebp, esp
.text:000080C1                 call    __RTC_CheckEsp
.text:000080C6                 mov     esp, ebp
.text:000080C8                 pop     ebp
.text:000080C9                 retn    4
.text:000080C9 ?FreqThreadFunction@@YGIPAX@Z endp
.text:000080C9
.text:000080C9 ; ---------------------------------------------------------------------------
.text:000080CC                 align 10h
.text:000080D0
.text:000080D0 ; =============== S U B R O U T I N E =======================================
.text:000080D0
.text:000080D0 ; Attributes: bp-based frame
.text:000080D0
.text:000080D0 ; int __stdcall CrcBench(int, int, int, int, int, int, int, int, CProps *, int, int, char, int, int)
.text:000080D0 ?CrcBench@@YGJ_KIIAA_KIIPBIABVCOneMethodInfo@@PAUIBenchPrintCallback@@PAUCTotalBenchRes@@_N0@Z proc near
.text:000080D0                                         ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+DA1p
.text:000080D0                                         ; TotalBench_Hash(unsigned __int64,uint,uint,IBenchPrintCallback *,CBenchCallbackToPrint *,CTotalBenchRes *,bool,unsigned __int64)+15Bp
.text:000080D0
.text:000080D0 var_20C         = dword ptr -20Ch
.text:000080D0 var_208         = dword ptr -208h
.text:000080D0 var_204         = dword ptr -204h
.text:000080D0 var_200         = dword ptr -200h
.text:000080D0 var_1FC         = dword ptr -1FCh
.text:000080D0 var_1F8         = dword ptr -1F8h
.text:000080D0 var_1F4         = dword ptr -1F4h
.text:000080D0 var_1F0         = dword ptr -1F0h
.text:000080D0 var_1EC         = dword ptr -1ECh
.text:000080D0 var_1E8         = dword ptr -1E8h
.text:000080D0 var_1E4         = dword ptr -1E4h
.text:000080D0 var_1E0         = dword ptr -1E0h
.text:000080D0 var_1DC         = dword ptr -1DCh
.text:000080D0 var_1D8         = dword ptr -1D8h
.text:000080D0 var_1D4         = dword ptr -1D4h
.text:000080D0 var_1D0         = dword ptr -1D0h
.text:000080D0 var_1CC         = dword ptr -1CCh
.text:000080D0 var_1C8         = dword ptr -1C8h
.text:000080D0 var_1C4         = dword ptr -1C4h
.text:000080D0 var_1C0         = dword ptr -1C0h
.text:000080D0 var_1BC         = dword ptr -1BCh
.text:000080D0 var_1B8         = qword ptr -1B8h
.text:000080D0 var_1B0         = qword ptr -1B0h
.text:000080D0 var_1A8         = qword ptr -1A8h
.text:000080D0 var_1A0         = dword ptr -1A0h
.text:000080D0 var_19C         = dword ptr -19Ch
.text:000080D0 var_194         = byte ptr -194h
.text:000080D0 var_174         = dword ptr -174h
.text:000080D0 var_170         = dword ptr -170h
.text:000080D0 var_16C         = dword ptr -16Ch
.text:000080D0 var_168         = dword ptr -168h
.text:000080D0 var_164         = dword ptr -164h
.text:000080D0 var_160         = dword ptr -160h
.text:000080D0 var_158         = dword ptr -158h
.text:000080D0 var_154         = dword ptr -154h
.text:000080D0 var_14C         = qword ptr -14Ch
.text:000080D0 var_13C         = byte ptr -13Ch
.text:000080D0 var_134         = dword ptr -134h
.text:000080D0 var_12C         = byte ptr -12Ch
.text:000080D0 var_118         = byte ptr -118h
.text:000080D0 var_110         = dword ptr -110h
.text:000080D0 var_10C         = dword ptr -10Ch
.text:000080D0 var_108         = dword ptr -108h
.text:000080D0 var_104         = dword ptr -104h
.text:000080D0 var_100         = dword ptr -100h
.text:000080D0 var_F8          = qword ptr -0F8h
.text:000080D0 var_E8          = byte ptr -0E8h
.text:000080D0 var_E0          = dword ptr -0E0h
.text:000080D0 var_D8          = byte ptr -0D8h
.text:000080D0 var_C8          = dword ptr -0C8h
.text:000080D0 var_C4          = dword ptr -0C4h
.text:000080D0 var_BC          = dword ptr -0BCh
.text:000080D0 var_B8          = dword ptr -0B8h
.text:000080D0 var_AC          = byte ptr -0ACh
.text:000080D0 var_68          = dword ptr -68h
.text:000080D0 var_64          = dword ptr -64h
.text:000080D0 var_60          = dword ptr -60h
.text:000080D0 var_58          = byte ptr -58h
.text:000080D0 var_4C          = dword ptr -4Ch
.text:000080D0 var_48          = dword ptr -48h
.text:000080D0 var_40          = byte ptr -40h
.text:000080D0 var_38          = dword ptr -38h
.text:000080D0 var_2C          = qword ptr -2Ch
.text:000080D0 var_1C          = byte ptr -1Ch
.text:000080D0 var_C           = dword ptr -0Ch
.text:000080D0 var_4           = dword ptr -4
.text:000080D0 arg_0           = dword ptr  8
.text:000080D0 arg_4           = dword ptr  0Ch
.text:000080D0 arg_8           = dword ptr  10h
.text:000080D0 arg_C           = dword ptr  14h
.text:000080D0 arg_10          = dword ptr  18h
.text:000080D0 arg_14          = dword ptr  1Ch
.text:000080D0 arg_18          = dword ptr  20h
.text:000080D0 arg_1C          = dword ptr  24h
.text:000080D0 arg_20          = dword ptr  28h
.text:000080D0 arg_24          = dword ptr  2Ch
.text:000080D0 arg_28          = dword ptr  30h
.text:000080D0 arg_2C          = byte ptr  34h
.text:000080D0 arg_30          = dword ptr  38h
.text:000080D0 arg_34          = dword ptr  3Ch
.text:000080D0
.text:000080D0                 push    ebp
.text:000080D1                 mov     ebp, esp
.text:000080D3                 push    0FFFFFFFFh
.text:000080D5                 push    offset __ehhandler$?CrcBench@@YGJ_KIIAA_KIIPBIABVCOneMethodInfo@@PAUIBenchPrintCallback@@PAUCTotalBenchRes@@_N0@Z
.text:000080DA                 mov     eax, large fs:0
.text:000080E0                 push    eax
.text:000080E1                 sub     esp, 200h
.text:000080E7                 push    esi
.text:000080E8                 push    edi
.text:000080E9                 lea     edi, [ebp+var_20C]
.text:000080EF                 mov     ecx, 80h ; 'Ç'
.text:000080F4                 mov     eax, 0CCCCCCCCh
.text:000080F9                 rep stosd
.text:000080FB                 mov     eax, dword ptr ds:___security_cookie
.text:00008100                 xor     eax, ebp
.text:00008102                 push    eax
.text:00008103                 lea     eax, [ebp+var_C]
.text:00008106                 mov     large fs:0, eax
.text:0000810C                 cmp     [ebp+arg_8], 0
.text:00008110                 jnz     short loc_8119
.text:00008112                 mov     [ebp+arg_8], 1
.text:00008119
.text:00008119 loc_8119:                               ; CODE XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+40j
.text:00008119                 mov     eax, [ebp+arg_20]
.text:0000811C                 add     eax, 0Ch
.text:0000811F                 push    eax
.text:00008120                 lea     ecx, [ebp+var_1C]
.text:00008123                 call    ??0AString@@QAE@ABV0@@Z ; AString::AString(AString const &)
.text:00008128                 mov     [ebp+var_4], 0
.text:0000812F                 lea     ecx, [ebp+var_2C]
.text:00008132                 push    ecx             ; unsigned __int64 *
.text:00008133                 lea     edx, [ebp+var_1C]
.text:00008136                 push    edx             ; struct AString *
.text:00008137                 call    ?FindHashMethod@@YG_NABVAString@@AA_K@Z ; FindHashMethod(AString const &,unsigned __int64 &)
.text:0000813C                 movzx   eax, al
.text:0000813F                 test    eax, eax
.text:00008141                 jnz     short loc_8167
.text:00008143                 mov     [ebp+var_1C0], 80004001h
.text:0000814D                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00008154                 lea     ecx, [ebp+var_1C] ; this
.text:00008157                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:0000815C                 mov     eax, [ebp+var_1C0]
.text:00008162                 jmp     loc_8C93
.text:00008167 ; ---------------------------------------------------------------------------
.text:00008167
.text:00008167 loc_8167:                               ; CODE XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+71j
.text:00008167                 lea     ecx, [ebp+var_40] ; this
.text:0000816A                 call    ??0CBenchBuffer@@QAE@XZ ; CBenchBuffer::CBenchBuffer(void)
.text:0000816F                 mov     byte ptr [ebp+var_4], 1
.text:00008173                 mov     ecx, [ebp+arg_C]
.text:00008176                 imul    ecx, [ebp+arg_8]
.text:0000817A                 mov     [ebp+var_48], ecx
.text:0000817D                 mov     eax, [ebp+var_48]
.text:00008180                 xor     edx, edx
.text:00008182                 div     [ebp+arg_8]
.text:00008185                 cmp     eax, [ebp+arg_C]
.text:00008188                 jz      short loc_81BA
.text:0000818A                 mov     [ebp+var_1C4], 8007000Eh
.text:00008194                 mov     byte ptr [ebp+var_4], 0
.text:00008198                 lea     ecx, [ebp+var_40] ; this
.text:0000819B                 call    ??1CBenchBuffer@@UAE@XZ ; CBenchBuffer::~CBenchBuffer(void)
.text:000081A0                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000081A7                 lea     ecx, [ebp+var_1C] ; this
.text:000081AA                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:000081AF                 mov     eax, [ebp+var_1C4]
.text:000081B5                 jmp     loc_8C93
.text:000081BA ; ---------------------------------------------------------------------------
.text:000081BA
.text:000081BA loc_81BA:                               ; CODE XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+B8j
.text:000081BA                 mov     edx, [ebp+var_48]
.text:000081BD                 push    edx             ; unsigned int
.text:000081BE                 lea     ecx, [ebp+var_40] ; this
.text:000081C1                 call    ?Alloc@CBenchBuffer@@QAE_NI@Z ; CBenchBuffer::Alloc(uint)
.text:000081C6                 movzx   eax, al
.text:000081C9                 test    eax, eax
.text:000081CB                 jnz     short loc_81FD
.text:000081CD                 mov     [ebp+var_1C8], 8007000Eh
.text:000081D7                 mov     byte ptr [ebp+var_4], 0
.text:000081DB                 lea     ecx, [ebp+var_40] ; this
.text:000081DE                 call    ??1CBenchBuffer@@UAE@XZ ; CBenchBuffer::~CBenchBuffer(void)
.text:000081E3                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000081EA                 lea     ecx, [ebp+var_1C] ; this
.text:000081ED                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:000081F2                 mov     eax, [ebp+var_1C8]
.text:000081F8                 jmp     loc_8C93
.text:000081FD ; ---------------------------------------------------------------------------
.text:000081FD
.text:000081FD loc_81FD:                               ; CODE XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+FBj
.text:000081FD                 mov     ecx, [ebp+var_38]
.text:00008200                 mov     [ebp+var_4C], ecx
.text:00008203                 lea     ecx, [ebp+var_58]
.text:00008206                 call    ??0CBaseRandomGenerator@@QAE@XZ ; CBaseRandomGenerator::CBaseRandomGenerator(void)
.text:0000820B                 cmp     [ebp+arg_C], 0
.text:0000820F                 jnz     short loc_821D
.text:00008211                 mov     [ebp+var_204], 1
.text:0000821B                 jmp     short loc_8226
.text:0000821D ; ---------------------------------------------------------------------------
.text:0000821D
.text:0000821D loc_821D:                               ; CODE XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+13Fj
.text:0000821D                 mov     edx, [ebp+arg_C]
.text:00008220                 mov     [ebp+var_204], edx
.text:00008226
.text:00008226 loc_8226:                               ; CODE XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+14Bj
.text:00008226                 mov     eax, [ebp+var_204]
.text:0000822C                 mov     [ebp+var_60], eax
.text:0000822F                 push    0
.text:00008231                 push    100h
.text:00008236                 mov     ecx, [ebp+arg_4]
.text:00008239                 push    ecx
.text:0000823A                 mov     edx, [ebp+arg_0]
.text:0000823D                 push    edx
.text:0000823E                 call    __allmul
.text:00008243                 mov     ecx, [ebp+arg_14]
.text:00008246                 xor     esi, esi
.text:00008248                 push    esi
.text:00008249                 push    ecx
.text:0000824A                 push    edx
.text:0000824B                 push    eax
.text:0000824C                 call    __aulldiv
.text:00008251                 mov     ecx, [ebp+var_60]
.text:00008254                 xor     esi, esi
.text:00008256                 push    esi
.text:00008257                 push    ecx
.text:00008258                 push    edx
.text:00008259                 push    eax
.text:0000825A                 call    __aulldiv
.text:0000825F                 mov     [ebp+var_68], eax
.text:00008262                 mov     [ebp+var_64], edx
.text:00008265                 mov     edx, [ebp+var_68]
.text:00008268                 or      edx, [ebp+var_64]
.text:0000826B                 jnz     short loc_827B
.text:0000826D                 mov     [ebp+var_68], 1
.text:00008274                 mov     [ebp+var_64], 0
.text:0000827B
.text:0000827B loc_827B:                               ; CODE XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+19Bj
.text:0000827B                 lea     ecx, [ebp+var_AC] ; this
.text:00008281                 call    ??0CBenchInfoCalc@@QAE@XZ ; CBenchInfoCalc::CBenchInfoCalc(void)
.text:00008286                 lea     ecx, [ebp+var_BC] ; this
.text:0000828C                 call    ??0CCrcThreads@@QAE@XZ ; CCrcThreads::CCrcThreads(void)
.text:00008291                 mov     byte ptr [ebp+var_4], 2
.text:00008295                 cmp     [ebp+arg_8], 1
.text:00008299                 jbe     loc_87A9
.text:0000829F                 mov     eax, [ebp+arg_8]
.text:000082A2                 mov     [ebp+var_1CC], eax
.text:000082A8                 xor     ecx, ecx
.text:000082AA                 mov     eax, [ebp+var_1CC]
.text:000082B0                 mov     edx, 38h ; '8'
.text:000082B5                 mul     edx
.text:000082B7                 seto    cl
.text:000082BA                 neg     ecx
.text:000082BC                 or      ecx, eax
.text:000082BE                 xor     eax, eax
.text:000082C0                 add     ecx, 4
.text:000082C3                 setb    al
.text:000082C6                 neg     eax
.text:000082C8                 or      eax, ecx
.text:000082CA                 push    eax             ; unsigned int
.text:000082CB                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:000082D0                 add     esp, 4
.text:000082D3                 mov     [ebp+var_1D4], eax
.text:000082D9                 mov     byte ptr [ebp+var_4], 3
.text:000082DD                 cmp     [ebp+var_1D4], 0
.text:000082E4                 jz      short loc_8327
.text:000082E6                 mov     ecx, [ebp+var_1D4]
.text:000082EC                 mov     edx, [ebp+var_1CC]
.text:000082F2                 mov     [ecx], edx
.text:000082F4                 push    offset ??1CCrcInfo@@QAE@XZ ; CCrcInfo::~CCrcInfo(void)
.text:000082F9                 push    offset ??0CCrcInfo@@QAE@XZ ; CCrcInfo::CCrcInfo(void)
.text:000082FE                 mov     eax, [ebp+var_1CC]
.text:00008304                 push    eax
.text:00008305                 push    38h ; '8'
.text:00008307                 mov     ecx, [ebp+var_1D4]
.text:0000830D                 add     ecx, 4
.text:00008310                 push    ecx
.text:00008311                 call    ??_L@YGXPAXIHP6EX0@Z1@Z ; `eh vector constructor iterator'(void *,uint,int,void (*)(void *),void (*)(void *))
.text:00008316                 mov     edx, [ebp+var_1D4]
.text:0000831C                 add     edx, 4
.text:0000831F                 mov     [ebp+var_208], edx
.text:00008325                 jmp     short loc_8331
.text:00008327 ; ---------------------------------------------------------------------------
.text:00008327
.text:00008327 loc_8327:                               ; CODE XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+214j
.text:00008327                 mov     [ebp+var_208], 0
.text:00008331
.text:00008331 loc_8331:                               ; CODE XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+255j
.text:00008331                 mov     eax, [ebp+var_208]
.text:00008337                 mov     [ebp+var_1D0], eax
.text:0000833D                 mov     byte ptr [ebp+var_4], 2
.text:00008341                 mov     ecx, [ebp+var_1D0]
.text:00008347                 mov     [ebp+var_BC], ecx
.text:0000834D                 mov     [ebp+var_C4], 0
.text:00008357                 jmp     short loc_8368
.text:00008359 ; ---------------------------------------------------------------------------
.text:00008359
.text:00008359 loc_8359:                               ; CODE XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+574j
.text:00008359                 mov     edx, [ebp+var_C4]
.text:0000835F                 add     edx, 1
.text:00008362                 mov     [ebp+var_C4], edx
.text:00008368
.text:00008368 loc_8368:                               ; CODE XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+287j
.text:00008368                 mov     eax, [ebp+var_C4]
.text:0000836E                 cmp     eax, [ebp+arg_8]
.text:00008371                 jnb     loc_8649
.text:00008377                 mov     ecx, [ebp+var_C4]
.text:0000837D                 imul    ecx, 38h
.text:00008380                 add     ecx, [ebp+var_BC]
.text:00008386                 mov     [ebp+var_C8], ecx
.text:0000838C                 lea     ecx, [ebp+var_D8]
.text:00008392                 call    ??0AString@@QAE@XZ ; AString::AString(void)
.text:00008397                 mov     byte ptr [ebp+var_4], 4
.text:0000839B                 mov     edx, [ebp+var_C8]
.text:000083A1                 add     edx, 28h ; '('
.text:000083A4                 push    edx
.text:000083A5                 lea     eax, [ebp+var_D8]
.text:000083AB                 push    eax
.text:000083AC                 mov     ecx, dword ptr [ebp+var_2C+4]
.text:000083AF                 push    ecx
.text:000083B0                 mov     edx, dword ptr [ebp+var_2C]
.text:000083B3                 push    edx
.text:000083B4                 call    ?CreateHasher@@YGJ_KAAVAString@@AAV?$CMyComPtr@UIHasher@@@@@Z ; CreateHasher(unsigned __int64,AString &,CMyComPtr<IHasher> &)
.text:000083B9                 mov     [ebp+var_E0], eax
.text:000083BF                 cmp     [ebp+var_E0], 0
.text:000083C6                 jz      short loc_8418
.text:000083C8                 mov     eax, [ebp+var_E0]
.text:000083CE                 mov     [ebp+var_1D8], eax
.text:000083D4                 mov     byte ptr [ebp+var_4], 2
.text:000083D8                 lea     ecx, [ebp+var_D8] ; this
.text:000083DE                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:000083E3                 mov     byte ptr [ebp+var_4], 1
.text:000083E7                 lea     ecx, [ebp+var_BC] ; this
.text:000083ED                 call    ??1CCrcThreads@@QAE@XZ ; CCrcThreads::~CCrcThreads(void)
.text:000083F2                 mov     byte ptr [ebp+var_4], 0
.text:000083F6                 lea     ecx, [ebp+var_40] ; this
.text:000083F9                 call    ??1CBenchBuffer@@UAE@XZ ; CBenchBuffer::~CBenchBuffer(void)
.text:000083FE                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00008405                 lea     ecx, [ebp+var_1C] ; this
.text:00008408                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:0000840D                 mov     eax, [ebp+var_1D8]
.text:00008413                 jmp     loc_8C93
.text:00008418 ; ---------------------------------------------------------------------------
.text:00008418
.text:00008418 loc_8418:                               ; CODE XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+2F6j
.text:00008418                 mov     ecx, [ebp+var_C8]
.text:0000841E                 add     ecx, 28h ; '('
.text:00008421                 call    ??7?$CMyComPtr@UIHasher@@@@QBE_NXZ ; CMyComPtr<IHasher>::operator!(void)
.text:00008426                 movzx   ecx, al
.text:00008429                 test    ecx, ecx
.text:0000842B                 jz      short loc_847B
.text:0000842D                 mov     [ebp+var_1DC], 80004001h
.text:00008437                 mov     byte ptr [ebp+var_4], 2
.text:0000843B                 lea     ecx, [ebp+var_D8] ; this
.text:00008441                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00008446                 mov     byte ptr [ebp+var_4], 1
.text:0000844A                 lea     ecx, [ebp+var_BC] ; this
.text:00008450                 call    ??1CCrcThreads@@QAE@XZ ; CCrcThreads::~CCrcThreads(void)
.text:00008455                 mov     byte ptr [ebp+var_4], 0
.text:00008459                 lea     ecx, [ebp+var_40] ; this
.text:0000845C                 call    ??1CBenchBuffer@@UAE@XZ ; CBenchBuffer::~CBenchBuffer(void)
.text:00008461                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00008468                 lea     ecx, [ebp+var_1C] ; this
.text:0000846B                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00008470                 mov     eax, [ebp+var_1DC]
.text:00008476                 jmp     loc_8C93
.text:0000847B ; ---------------------------------------------------------------------------
.text:0000847B
.text:0000847B loc_847B:                               ; CODE XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+35Bj
.text:0000847B                 lea     ecx, [ebp+var_E8]
.text:00008481                 call    ??0?$CMyComPtr@UICompressSetCoderProperties@@@@QAE@XZ ; CMyComPtr<ICompressSetCoderProperties>::CMyComPtr<ICompressSetCoderProperties>(void)
.text:00008486                 mov     byte ptr [ebp+var_4], 5
.text:0000848A                 lea     ecx, [ebp+var_E8]
.text:00008490                 call    ??I?$CMyComPtr@UICompressSetCoderProperties@@@@QAEPAPAUICompressSetCoderProperties@@XZ ; CMyComPtr<ICompressSetCoderProperties>::operator&(void)
.text:00008495                 push    eax
.text:00008496                 push    offset _IID_ICompressSetCoderProperties
.text:0000849B                 mov     ecx, [ebp+var_C8]
.text:000084A1                 add     ecx, 28h ; '('
.text:000084A4                 call    ??$QueryInterface@UICompressSetCoderProperties@@@?$CMyComPtr@UIHasher@@@@QBEJABU_GUID@@PAPAUICompressSetCoderProperties@@@Z ; CMyComPtr<IHasher>::QueryInterface<ICompressSetCoderProperties>(_GUID const &,ICompressSetCoderProperties * *)
.text:000084A9                 lea     ecx, [ebp+var_E8]
.text:000084AF                 call    ??B?$CMyComPtr@UICompressSetCoderProperties@@@@QBEPAUICompressSetCoderProperties@@XZ ; CMyComPtr<ICompressSetCoderProperties>::operator ICompressSetCoderProperties *(void)
.text:000084B4                 test    eax, eax
.text:000084B6                 jz      loc_8559
.text:000084BC                 mov     dword ptr [ebp+var_F8], 1
.text:000084C6                 mov     dword ptr [ebp+var_F8+4], 0
.text:000084D0                 lea     edx, [ebp+var_F8]
.text:000084D6                 push    edx             ; unsigned __int64 *
.text:000084D7                 lea     ecx, [ebp+var_E8]
.text:000084DD                 call    ??B?$CMyComPtr@UICompressSetCoderProperties@@@@QBEPAUICompressSetCoderProperties@@XZ ; CMyComPtr<ICompressSetCoderProperties>::operator ICompressSetCoderProperties *(void)
.text:000084E2                 push    eax             ; struct ICompressSetCoderProperties *
.text:000084E3                 mov     ecx, [ebp+arg_20] ; this
.text:000084E6                 call    ?SetCoderProps@CProps@@QBEJPAUICompressSetCoderProperties@@PB_K@Z ; CProps::SetCoderProps(ICompressSetCoderProperties *,unsigned __int64 const *)
.text:000084EB                 mov     [ebp+var_100], eax
.text:000084F1                 cmp     [ebp+var_100], 0
.text:000084F8                 jz      short loc_8559
.text:000084FA                 mov     eax, [ebp+var_100]
.text:00008500                 mov     [ebp+var_1E0], eax
.text:00008506                 mov     byte ptr [ebp+var_4], 4
.text:0000850A                 lea     ecx, [ebp+var_E8]
.text:00008510                 call    ??1?$CMyComPtr@UICompressSetCoderProperties@@@@QAE@XZ ; CMyComPtr<ICompressSetCoderProperties>::~CMyComPtr<ICompressSetCoderProperties>(void)
.text:00008515                 mov     byte ptr [ebp+var_4], 2
.text:00008519                 lea     ecx, [ebp+var_D8] ; this
.text:0000851F                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00008524                 mov     byte ptr [ebp+var_4], 1
.text:00008528                 lea     ecx, [ebp+var_BC] ; this
.text:0000852E                 call    ??1CCrcThreads@@QAE@XZ ; CCrcThreads::~CCrcThreads(void)
.text:00008533                 mov     byte ptr [ebp+var_4], 0
.text:00008537                 lea     ecx, [ebp+var_40] ; this
.text:0000853A                 call    ??1CBenchBuffer@@UAE@XZ ; CBenchBuffer::~CBenchBuffer(void)
.text:0000853F                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00008546                 lea     ecx, [ebp+var_1C] ; this
.text:00008549                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:0000854E                 mov     eax, [ebp+var_1E0]
.text:00008554                 jmp     loc_8C93
.text:00008559 ; ---------------------------------------------------------------------------
.text:00008559
.text:00008559 loc_8559:                               ; CODE XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+3E6j
.text:00008559                                         ; CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+428j
.text:00008559                 mov     ecx, [ebp+arg_C]
.text:0000855C                 imul    ecx, [ebp+var_C4]
.text:00008563                 add     ecx, [ebp+var_4C]
.text:00008566                 mov     [ebp+var_104], ecx
.text:0000856C                 mov     edx, [ebp+var_C8]
.text:00008572                 mov     eax, [ebp+arg_24]
.text:00008575                 mov     [edx+4], eax
.text:00008578                 mov     ecx, [ebp+var_C8]
.text:0000857E                 mov     edx, [ebp+var_104]
.text:00008584                 mov     [ecx+0Ch], edx
.text:00008587                 mov     eax, [ebp+var_C8]
.text:0000858D                 mov     ecx, [ebp+var_68]
.text:00008590                 mov     [eax+18h], ecx
.text:00008593                 mov     edx, [ebp+var_64]
.text:00008596                 mov     [eax+1Ch], edx
.text:00008599                 mov     eax, [ebp+var_C8]
.text:0000859F                 mov     ecx, [ebp+arg_C]
.text:000085A2                 mov     [eax+10h], ecx
.text:000085A5                 lea     edx, [ebp+var_58]
.text:000085A8                 push    edx             ; CBaseRandomGenerator *
.text:000085A9                 mov     eax, [ebp+arg_C]
.text:000085AC                 push    eax             ; int
.text:000085AD                 mov     ecx, [ebp+var_104]
.text:000085B3                 push    ecx             ; int
.text:000085B4                 call    ?RandGenCrc@@YGIPAEIAAVCBaseRandomGenerator@@@Z ; RandGenCrc(uchar *,uint,CBaseRandomGenerator &)
.text:000085B9                 mov     edx, [ebp+var_C8]
.text:000085BF                 mov     byte ptr [edx+20h], 0
.text:000085C3                 cmp     [ebp+arg_1C], 0
.text:000085C7                 jz      short loc_860B
.text:000085C9                 mov     eax, [ebp+var_C8]
.text:000085CF                 mov     ecx, [ebp+arg_1C]
.text:000085D2                 mov     edx, [ecx]
.text:000085D4                 mov     [eax+24h], edx
.text:000085D7                 cmp     [ebp+arg_1C], 0
.text:000085DB                 jz      short loc_85F2
.text:000085DD                 cmp     [ebp+var_C4], 0
.text:000085E4                 jnz     short loc_85F2
.text:000085E6                 mov     [ebp+var_20C], 1
.text:000085F0                 jmp     short loc_85FC
.text:000085F2 ; ---------------------------------------------------------------------------
.text:000085F2
.text:000085F2 loc_85F2:                               ; CODE XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+50Bj
.text:000085F2                                         ; CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+514j
.text:000085F2                 mov     [ebp+var_20C], 0
.text:000085FC
.text:000085FC loc_85FC:                               ; CODE XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+520j
.text:000085FC                 mov     eax, [ebp+var_C8]
.text:00008602                 mov     cl, byte ptr [ebp+var_20C]
.text:00008608                 mov     [eax+20h], cl
.text:0000860B
.text:0000860B loc_860B:                               ; CODE XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+4F7j
.text:0000860B                 mov     edx, [ebp+var_C4]
.text:00008611                 shl     edx, 4
.text:00008614                 imul    edx, 15h
.text:00008617                 and     edx, 7FFh
.text:0000861D                 mov     eax, [ebp+var_C8]
.text:00008623                 mov     [eax+30h], edx
.text:00008626                 mov     byte ptr [ebp+var_4], 4
.text:0000862A                 lea     ecx, [ebp+var_E8]
.text:00008630                 call    ??1?$CMyComPtr@UICompressSetCoderProperties@@@@QAE@XZ ; CMyComPtr<ICompressSetCoderProperties>::~CMyComPtr<ICompressSetCoderProperties>(void)
.text:00008635                 mov     byte ptr [ebp+var_4], 2
.text:00008639                 lea     ecx, [ebp+var_D8] ; this
.text:0000863F                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00008644                 jmp     loc_8359
.text:00008649 ; ---------------------------------------------------------------------------
.text:00008649
.text:00008649 loc_8649:                               ; CODE XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+2A1j
.text:00008649                 lea     ecx, [ebp+var_AC] ; this
.text:0000864F                 call    ?SetStartTime@CBenchInfoCalc@@QAEXXZ ; CBenchInfoCalc::SetStartTime(void)
.text:00008654                 mov     [ebp+var_C4], 0
.text:0000865E                 jmp     short loc_866F
.text:00008660 ; ---------------------------------------------------------------------------
.text:00008660
.text:00008660 loc_8660:                               ; CODE XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+639j
.text:00008660                 mov     ecx, [ebp+var_C4]
.text:00008666                 add     ecx, 1
.text:00008669                 mov     [ebp+var_C4], ecx
.text:0000866F
.text:0000866F loc_866F:                               ; CODE XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+58Ej
.text:0000866F                 mov     edx, [ebp+var_C4]
.text:00008675                 cmp     edx, [ebp+arg_8]
.text:00008678                 jnb     loc_870E
.text:0000867E                 mov     eax, [ebp+var_C4]
.text:00008684                 imul    eax, 38h
.text:00008687                 add     eax, [ebp+var_BC]
.text:0000868D                 mov     [ebp+var_108], eax
.text:00008693                 mov     ecx, [ebp+var_108]
.text:00008699                 push    ecx             ; void *
.text:0000869A                 push    offset ?CrcThreadFunction@@YGIPAX@Z ; unsigned int (__stdcall *)(void *)
.text:0000869F                 mov     ecx, [ebp+var_108] ; this
.text:000086A5                 call    ?Create@CThread@NWindows@@QAEIP6GIPAX@Z0@Z ; NWindows::CThread::Create(uint (*)(void *),void *)
.text:000086AA                 mov     [ebp+var_10C], eax
.text:000086B0                 cmp     [ebp+var_10C], 0
.text:000086B7                 jz      short loc_86FA
.text:000086B9                 mov     edx, [ebp+var_10C]
.text:000086BF                 mov     [ebp+var_1E4], edx
.text:000086C5                 mov     byte ptr [ebp+var_4], 1
.text:000086C9                 lea     ecx, [ebp+var_BC] ; this
.text:000086CF                 call    ??1CCrcThreads@@QAE@XZ ; CCrcThreads::~CCrcThreads(void)
.text:000086D4                 mov     byte ptr [ebp+var_4], 0
.text:000086D8                 lea     ecx, [ebp+var_40] ; this
.text:000086DB                 call    ??1CBenchBuffer@@UAE@XZ ; CBenchBuffer::~CBenchBuffer(void)
.text:000086E0                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000086E7                 lea     ecx, [ebp+var_1C] ; this
.text:000086EA                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:000086EF                 mov     eax, [ebp+var_1E4]
.text:000086F5                 jmp     loc_8C93
.text:000086FA ; ---------------------------------------------------------------------------
.text:000086FA
.text:000086FA loc_86FA:                               ; CODE XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+5E7j
.text:000086FA                 mov     eax, [ebp+var_B8]
.text:00008700                 add     eax, 1
.text:00008703                 mov     [ebp+var_B8], eax
.text:00008709                 jmp     loc_8660
.text:0000870E ; ---------------------------------------------------------------------------
.text:0000870E
.text:0000870E loc_870E:                               ; CODE XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+5A8j
.text:0000870E                 lea     ecx, [ebp+var_BC] ; this
.text:00008714                 call    ?WaitAll@CCrcThreads@@QAEXXZ ; CCrcThreads::WaitAll(void)
.text:00008719                 mov     [ebp+var_C4], 0
.text:00008723                 jmp     short loc_8734
.text:00008725 ; ---------------------------------------------------------------------------
.text:00008725
.text:00008725 loc_8725:                               ; CODE XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64):loc_87A2j
.text:00008725                 mov     ecx, [ebp+var_C4]
.text:0000872B                 add     ecx, 1
.text:0000872E                 mov     [ebp+var_C4], ecx
.text:00008734
.text:00008734 loc_8734:                               ; CODE XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+653j
.text:00008734                 mov     edx, [ebp+var_C4]
.text:0000873A                 cmp     edx, [ebp+arg_8]
.text:0000873D                 jnb     short loc_87A4
.text:0000873F                 mov     eax, [ebp+var_C4]
.text:00008745                 imul    eax, 38h
.text:00008748                 mov     ecx, [ebp+var_BC]
.text:0000874E                 mov     edx, [ecx+eax+2Ch]
.text:00008752                 mov     [ebp+var_110], edx
.text:00008758                 cmp     [ebp+var_110], 0
.text:0000875F                 jz      short loc_87A2
.text:00008761                 mov     eax, [ebp+var_110]
.text:00008767                 mov     [ebp+var_1E8], eax
.text:0000876D                 mov     byte ptr [ebp+var_4], 1
.text:00008771                 lea     ecx, [ebp+var_BC] ; this
.text:00008777                 call    ??1CCrcThreads@@QAE@XZ ; CCrcThreads::~CCrcThreads(void)
.text:0000877C                 mov     byte ptr [ebp+var_4], 0
.text:00008780                 lea     ecx, [ebp+var_40] ; this
.text:00008783                 call    ??1CBenchBuffer@@UAE@XZ ; CBenchBuffer::~CBenchBuffer(void)
.text:00008788                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000878F                 lea     ecx, [ebp+var_1C] ; this
.text:00008792                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00008797                 mov     eax, [ebp+var_1E8]
.text:0000879D                 jmp     loc_8C93
.text:000087A2 ; ---------------------------------------------------------------------------
.text:000087A2
.text:000087A2 loc_87A2:                               ; CODE XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+68Fj
.text:000087A2                 jmp     short loc_8725
.text:000087A4 ; ---------------------------------------------------------------------------
.text:000087A4
.text:000087A4 loc_87A4:                               ; CODE XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+66Dj
.text:000087A4                 jmp     loc_8A98
.text:000087A9 ; ---------------------------------------------------------------------------
.text:000087A9
.text:000087A9 loc_87A9:                               ; CODE XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+1C9j
.text:000087A9                 lea     ecx, [ebp+var_58]
.text:000087AC                 push    ecx             ; CBaseRandomGenerator *
.text:000087AD                 mov     edx, [ebp+arg_C]
.text:000087B0                 push    edx             ; int
.text:000087B1                 mov     eax, [ebp+var_4C]
.text:000087B4                 push    eax             ; int
.text:000087B5                 call    ?RandGenCrc@@YGIPAEIAAVCBaseRandomGenerator@@@Z ; RandGenCrc(uchar *,uint,CBaseRandomGenerator &)
.text:000087BA                 lea     ecx, [ebp+var_AC] ; this
.text:000087C0                 call    ?SetStartTime@CBenchInfoCalc@@QAEXXZ ; CBenchInfoCalc::SetStartTime(void)
.text:000087C5                 lea     ecx, [ebp+var_118]
.text:000087CB                 call    ??0?$CMyComPtr@UIHasher@@@@QAE@XZ ; CMyComPtr<IHasher>::CMyComPtr<IHasher>(void)
.text:000087D0                 mov     byte ptr [ebp+var_4], 6
.text:000087D4                 lea     ecx, [ebp+var_12C]
.text:000087DA                 call    ??0AString@@QAE@XZ ; AString::AString(void)
.text:000087DF                 mov     byte ptr [ebp+var_4], 7
.text:000087E3                 lea     ecx, [ebp+var_118]
.text:000087E9                 push    ecx
.text:000087EA                 lea     edx, [ebp+var_12C]
.text:000087F0                 push    edx
.text:000087F1                 mov     eax, dword ptr [ebp+var_2C+4]
.text:000087F4                 push    eax
.text:000087F5                 mov     ecx, dword ptr [ebp+var_2C]
.text:000087F8                 push    ecx
.text:000087F9                 call    ?CreateHasher@@YGJ_KAAVAString@@AAV?$CMyComPtr@UIHasher@@@@@Z ; CreateHasher(unsigned __int64,AString &,CMyComPtr<IHasher> &)
.text:000087FE                 mov     [ebp+var_134], eax
.text:00008804                 cmp     [ebp+var_134], 0
.text:0000880B                 jz      short loc_886C
.text:0000880D                 mov     edx, [ebp+var_134]
.text:00008813                 mov     [ebp+var_1EC], edx
.text:00008819                 mov     byte ptr [ebp+var_4], 6
.text:0000881D                 lea     ecx, [ebp+var_12C] ; this
.text:00008823                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00008828                 mov     byte ptr [ebp+var_4], 2
.text:0000882C                 lea     ecx, [ebp+var_118]
.text:00008832                 call    ??1?$CMyComPtr@UIHasher@@@@QAE@XZ ; CMyComPtr<IHasher>::~CMyComPtr<IHasher>(void)
.text:00008837                 mov     byte ptr [ebp+var_4], 1
.text:0000883B                 lea     ecx, [ebp+var_BC] ; this
.text:00008841                 call    ??1CCrcThreads@@QAE@XZ ; CCrcThreads::~CCrcThreads(void)
.text:00008846                 mov     byte ptr [ebp+var_4], 0
.text:0000884A                 lea     ecx, [ebp+var_40] ; this
.text:0000884D                 call    ??1CBenchBuffer@@UAE@XZ ; CBenchBuffer::~CBenchBuffer(void)
.text:00008852                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00008859                 lea     ecx, [ebp+var_1C] ; this
.text:0000885C                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00008861                 mov     eax, [ebp+var_1EC]
.text:00008867                 jmp     loc_8C93
.text:0000886C ; ---------------------------------------------------------------------------
.text:0000886C
.text:0000886C loc_886C:                               ; CODE XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+73Bj
.text:0000886C                 lea     ecx, [ebp+var_118]
.text:00008872                 call    ??7?$CMyComPtr@UIHasher@@@@QBE_NXZ ; CMyComPtr<IHasher>::operator!(void)
.text:00008877                 movzx   eax, al
.text:0000887A                 test    eax, eax
.text:0000887C                 jz      short loc_88DB
.text:0000887E                 mov     [ebp+var_1F0], 80004001h
.text:00008888                 mov     byte ptr [ebp+var_4], 6
.text:0000888C                 lea     ecx, [ebp+var_12C] ; this
.text:00008892                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00008897                 mov     byte ptr [ebp+var_4], 2
.text:0000889B                 lea     ecx, [ebp+var_118]
.text:000088A1                 call    ??1?$CMyComPtr@UIHasher@@@@QAE@XZ ; CMyComPtr<IHasher>::~CMyComPtr<IHasher>(void)
.text:000088A6                 mov     byte ptr [ebp+var_4], 1
.text:000088AA                 lea     ecx, [ebp+var_BC] ; this
.text:000088B0                 call    ??1CCrcThreads@@QAE@XZ ; CCrcThreads::~CCrcThreads(void)
.text:000088B5                 mov     byte ptr [ebp+var_4], 0
.text:000088B9                 lea     ecx, [ebp+var_40] ; this
.text:000088BC                 call    ??1CBenchBuffer@@UAE@XZ ; CBenchBuffer::~CBenchBuffer(void)
.text:000088C1                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000088C8                 lea     ecx, [ebp+var_1C] ; this
.text:000088CB                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:000088D0                 mov     eax, [ebp+var_1F0]
.text:000088D6                 jmp     loc_8C93
.text:000088DB ; ---------------------------------------------------------------------------
.text:000088DB
.text:000088DB loc_88DB:                               ; CODE XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+7ACj
.text:000088DB                 lea     ecx, [ebp+var_13C]
.text:000088E1                 call    ??0?$CMyComPtr@UICompressSetCoderProperties@@@@QAE@XZ ; CMyComPtr<ICompressSetCoderProperties>::CMyComPtr<ICompressSetCoderProperties>(void)
.text:000088E6                 mov     byte ptr [ebp+var_4], 8
.text:000088EA                 lea     ecx, [ebp+var_13C]
.text:000088F0                 call    ??I?$CMyComPtr@UICompressSetCoderProperties@@@@QAEPAPAUICompressSetCoderProperties@@XZ ; CMyComPtr<ICompressSetCoderProperties>::operator&(void)
.text:000088F5                 push    eax
.text:000088F6                 push    offset _IID_ICompressSetCoderProperties
.text:000088FB                 lea     ecx, [ebp+var_118]
.text:00008901                 call    ??$QueryInterface@UICompressSetCoderProperties@@@?$CMyComPtr@UIHasher@@@@QBEJABU_GUID@@PAPAUICompressSetCoderProperties@@@Z ; CMyComPtr<IHasher>::QueryInterface<ICompressSetCoderProperties>(_GUID const &,ICompressSetCoderProperties * *)
.text:00008906                 lea     ecx, [ebp+var_13C]
.text:0000890C                 call    ??B?$CMyComPtr@UICompressSetCoderProperties@@@@QBEPAUICompressSetCoderProperties@@XZ ; CMyComPtr<ICompressSetCoderProperties>::operator ICompressSetCoderProperties *(void)
.text:00008911                 test    eax, eax
.text:00008913                 jz      loc_89C5
.text:00008919                 mov     dword ptr [ebp+var_14C], 1
.text:00008923                 mov     dword ptr [ebp+var_14C+4], 0
.text:0000892D                 lea     ecx, [ebp+var_14C]
.text:00008933                 push    ecx             ; unsigned __int64 *
.text:00008934                 lea     ecx, [ebp+var_13C]
.text:0000893A                 call    ??B?$CMyComPtr@UICompressSetCoderProperties@@@@QBEPAUICompressSetCoderProperties@@XZ ; CMyComPtr<ICompressSetCoderProperties>::operator ICompressSetCoderProperties *(void)
.text:0000893F                 push    eax             ; struct ICompressSetCoderProperties *
.text:00008940                 mov     ecx, [ebp+arg_20] ; this
.text:00008943                 call    ?SetCoderProps@CProps@@QBEJPAUICompressSetCoderProperties@@PB_K@Z ; CProps::SetCoderProps(ICompressSetCoderProperties *,unsigned __int64 const *)
.text:00008948                 mov     [ebp+var_154], eax
.text:0000894E                 cmp     [ebp+var_154], 0
.text:00008955                 jz      short loc_89C5
.text:00008957                 mov     edx, [ebp+var_154]
.text:0000895D                 mov     [ebp+var_1F4], edx
.text:00008963                 mov     byte ptr [ebp+var_4], 7
.text:00008967                 lea     ecx, [ebp+var_13C]
.text:0000896D                 call    ??1?$CMyComPtr@UICompressSetCoderProperties@@@@QAE@XZ ; CMyComPtr<ICompressSetCoderProperties>::~CMyComPtr<ICompressSetCoderProperties>(void)
.text:00008972                 mov     byte ptr [ebp+var_4], 6
.text:00008976                 lea     ecx, [ebp+var_12C] ; this
.text:0000897C                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00008981                 mov     byte ptr [ebp+var_4], 2
.text:00008985                 lea     ecx, [ebp+var_118]
.text:0000898B                 call    ??1?$CMyComPtr@UIHasher@@@@QAE@XZ ; CMyComPtr<IHasher>::~CMyComPtr<IHasher>(void)
.text:00008990                 mov     byte ptr [ebp+var_4], 1
.text:00008994                 lea     ecx, [ebp+var_BC] ; this
.text:0000899A                 call    ??1CCrcThreads@@QAE@XZ ; CCrcThreads::~CCrcThreads(void)
.text:0000899F                 mov     byte ptr [ebp+var_4], 0
.text:000089A3                 lea     ecx, [ebp+var_40] ; this
.text:000089A6                 call    ??1CBenchBuffer@@UAE@XZ ; CBenchBuffer::~CBenchBuffer(void)
.text:000089AB                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000089B2                 lea     ecx, [ebp+var_1C] ; this
.text:000089B5                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:000089BA                 mov     eax, [ebp+var_1F4]
.text:000089C0                 jmp     loc_8C93
.text:000089C5 ; ---------------------------------------------------------------------------
.text:000089C5
.text:000089C5 loc_89C5:                               ; CODE XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+843j
.text:000089C5                                         ; CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+885j
.text:000089C5                 mov     eax, [ebp+arg_24]
.text:000089C8                 push    eax
.text:000089C9                 lea     ecx, [ebp+var_118]
.text:000089CF                 call    ??B?$CMyComPtr@UIHasher@@@@QBEPAUIHasher@@XZ ; CMyComPtr<IHasher>::operator IHasher *(void)
.text:000089D4                 push    eax
.text:000089D5                 mov     ecx, [ebp+arg_1C]
.text:000089D8                 push    ecx
.text:000089D9                 mov     edx, [ebp+var_64]
.text:000089DC                 push    edx
.text:000089DD                 mov     eax, [ebp+var_68]
.text:000089E0                 push    eax
.text:000089E1                 mov     ecx, [ebp+arg_C]
.text:000089E4                 push    ecx
.text:000089E5                 mov     edx, [ebp+var_4C]
.text:000089E8                 push    edx
.text:000089E9                 call    ?CrcBig@@YGJPBXI_KPBIPAUIHasher@@PAUIBenchPrintCallback@@@Z ; CrcBig(void const *,uint,unsigned __int64,uint const *,IHasher *,IBenchPrintCallback *)
.text:000089EE                 mov     [ebp+var_158], eax
.text:000089F4                 cmp     [ebp+var_158], 0
.text:000089FB                 jz      short loc_8A6B
.text:000089FD                 mov     eax, [ebp+var_158]
.text:00008A03                 mov     [ebp+var_1F8], eax
.text:00008A09                 mov     byte ptr [ebp+var_4], 7
.text:00008A0D                 lea     ecx, [ebp+var_13C]
.text:00008A13                 call    ??1?$CMyComPtr@UICompressSetCoderProperties@@@@QAE@XZ ; CMyComPtr<ICompressSetCoderProperties>::~CMyComPtr<ICompressSetCoderProperties>(void)
.text:00008A18                 mov     byte ptr [ebp+var_4], 6
.text:00008A1C                 lea     ecx, [ebp+var_12C] ; this
.text:00008A22                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00008A27                 mov     byte ptr [ebp+var_4], 2
.text:00008A2B                 lea     ecx, [ebp+var_118]
.text:00008A31                 call    ??1?$CMyComPtr@UIHasher@@@@QAE@XZ ; CMyComPtr<IHasher>::~CMyComPtr<IHasher>(void)
.text:00008A36                 mov     byte ptr [ebp+var_4], 1
.text:00008A3A                 lea     ecx, [ebp+var_BC] ; this
.text:00008A40                 call    ??1CCrcThreads@@QAE@XZ ; CCrcThreads::~CCrcThreads(void)
.text:00008A45                 mov     byte ptr [ebp+var_4], 0
.text:00008A49                 lea     ecx, [ebp+var_40] ; this
.text:00008A4C                 call    ??1CBenchBuffer@@UAE@XZ ; CBenchBuffer::~CBenchBuffer(void)
.text:00008A51                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00008A58                 lea     ecx, [ebp+var_1C] ; this
.text:00008A5B                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00008A60                 mov     eax, [ebp+var_1F8]
.text:00008A66                 jmp     loc_8C93
.text:00008A6B ; ---------------------------------------------------------------------------
.text:00008A6B
.text:00008A6B loc_8A6B:                               ; CODE XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+92Bj
.text:00008A6B                 mov     byte ptr [ebp+var_4], 7
.text:00008A6F                 lea     ecx, [ebp+var_13C]
.text:00008A75                 call    ??1?$CMyComPtr@UICompressSetCoderProperties@@@@QAE@XZ ; CMyComPtr<ICompressSetCoderProperties>::~CMyComPtr<ICompressSetCoderProperties>(void)
.text:00008A7A                 mov     byte ptr [ebp+var_4], 6
.text:00008A7E                 lea     ecx, [ebp+var_12C] ; this
.text:00008A84                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00008A89                 mov     byte ptr [ebp+var_4], 2
.text:00008A8D                 lea     ecx, [ebp+var_118]
.text:00008A93                 call    ??1?$CMyComPtr@UIHasher@@@@QAE@XZ ; CMyComPtr<IHasher>::~CMyComPtr<IHasher>(void)
.text:00008A98
.text:00008A98 loc_8A98:                               ; CODE XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64):loc_87A4j
.text:00008A98                 lea     ecx, [ebp+var_194] ; this
.text:00008A9E                 call    ??0CBenchInfo@@QAE@XZ ; CBenchInfo::CBenchInfo(void)
.text:00008AA3                 lea     ecx, [ebp+var_194]
.text:00008AA9                 push    ecx             ; struct CBenchInfo *
.text:00008AAA                 lea     ecx, [ebp+var_AC] ; this
.text:00008AB0                 call    ?SetFinishTime@CBenchInfoCalc@@QAEXAAUCBenchInfo@@@Z ; CBenchInfoCalc::SetFinishTime(CBenchInfo &)
.text:00008AB5                 mov     edx, [ebp+arg_C]
.text:00008AB8                 xor     eax, eax
.text:00008ABA                 push    eax
.text:00008ABB                 push    edx
.text:00008ABC                 mov     ecx, [ebp+var_64]
.text:00008ABF                 push    ecx
.text:00008AC0                 mov     edx, [ebp+var_68]
.text:00008AC3                 push    edx
.text:00008AC4                 call    __allmul
.text:00008AC9                 mov     [ebp+var_1A0], eax
.text:00008ACF                 mov     [ebp+var_19C], edx
.text:00008AD5                 mov     eax, [ebp+arg_8]
.text:00008AD8                 xor     ecx, ecx
.text:00008ADA                 push    ecx
.text:00008ADB                 push    eax
.text:00008ADC                 mov     edx, [ebp+var_19C]
.text:00008AE2                 push    edx
.text:00008AE3                 mov     eax, [ebp+var_1A0]
.text:00008AE9                 push    eax
.text:00008AEA                 call    __allmul
.text:00008AEF                 mov     dword ptr [ebp+var_1A8], eax
.text:00008AF5                 mov     dword ptr [ebp+var_1A8+4], edx
.text:00008AFB                 mov     ecx, dword ptr [ebp+var_1A8]
.text:00008B01                 mov     [ebp+var_174], ecx
.text:00008B07                 mov     edx, dword ptr [ebp+var_1A8+4]
.text:00008B0D                 mov     [ebp+var_170], edx
.text:00008B13                 mov     eax, dword ptr [ebp+var_1A8]
.text:00008B19                 mov     [ebp+var_16C], eax
.text:00008B1F                 mov     ecx, dword ptr [ebp+var_1A8+4]
.text:00008B25                 mov     [ebp+var_168], ecx
.text:00008B2B                 mov     [ebp+var_164], 1
.text:00008B35                 mov     [ebp+var_160], 0
.text:00008B3F                 cmp     [ebp+arg_24], 0
.text:00008B43                 jz      loc_8C38
.text:00008B49                 mov     edx, [ebp+arg_14]
.text:00008B4C                 xor     eax, eax
.text:00008B4E                 push    eax
.text:00008B4F                 push    edx
.text:00008B50                 mov     ecx, dword ptr [ebp+var_1A8+4]
.text:00008B56                 push    ecx
.text:00008B57                 mov     edx, dword ptr [ebp+var_1A8]
.text:00008B5D                 push    edx
.text:00008B5E                 call    __allmul
.text:00008B63                 push    0
.text:00008B65                 push    100h
.text:00008B6A                 push    edx
.text:00008B6B                 push    eax
.text:00008B6C                 call    __aulldiv
.text:00008B71                 mov     dword ptr [ebp+var_1B0], eax
.text:00008B77                 mov     dword ptr [ebp+var_1B0+4], edx
.text:00008B7D                 mov     eax, dword ptr [ebp+var_1B0+4]
.text:00008B83                 push    eax
.text:00008B84                 mov     ecx, dword ptr [ebp+var_1B0]
.text:00008B8A                 push    ecx             ; unsigned __int64
.text:00008B8B                 lea     ecx, [ebp+var_194] ; this
.text:00008B91                 call    ?GetSpeed@CBenchInfo@@QBE_K_K@Z ; CBenchInfo::GetSpeed(unsigned __int64)
.text:00008B96                 mov     dword ptr [ebp+var_1B8], eax
.text:00008B9C                 mov     dword ptr [ebp+var_1B8+4], edx
.text:00008BA2                 mov     edx, [ebp+arg_28]
.text:00008BA5                 push    edx             ; int
.text:00008BA6                 mov     eax, [ebp+arg_34]
.text:00008BA9                 push    eax             ; int
.text:00008BAA                 mov     ecx, [ebp+arg_30]
.text:00008BAD                 push    ecx             ; int
.text:00008BAE                 movzx   edx, [ebp+arg_2C]
.text:00008BB2                 push    edx             ; char
.text:00008BB3                 mov     eax, dword ptr [ebp+var_1B8+4]
.text:00008BB9                 push    eax
.text:00008BBA                 mov     ecx, dword ptr [ebp+var_1B8]
.text:00008BC0                 push    ecx             ; unsigned __int64
.text:00008BC1                 mov     edx, [ebp+arg_18]
.text:00008BC4                 push    edx             ; int
.text:00008BC5                 lea     eax, [ebp+var_194]
.text:00008BCB                 push    eax             ; CBenchInfo *
.text:00008BCC                 mov     ecx, [ebp+arg_24]
.text:00008BCF                 push    ecx             ; int
.text:00008BD0                 call    ?PrintResults@@YGXPAUIBenchPrintCallback@@ABUCBenchInfo@@I_K_N2PAUCTotalBenchRes@@@Z ; PrintResults(IBenchPrintCallback *,CBenchInfo const &,uint,unsigned __int64,bool,unsigned __int64,CTotalBenchRes *)
.text:00008BD5                 mov     edx, [ebp+arg_24]
.text:00008BD8                 mov     eax, [edx]
.text:00008BDA                 mov     esi, esp
.text:00008BDC                 mov     ecx, [ebp+arg_24]
.text:00008BDF                 mov     edx, [eax+8]
.text:00008BE2                 call    edx
.text:00008BE4                 cmp     esi, esp
.text:00008BE6                 call    __RTC_CheckEsp
.text:00008BEB                 mov     [ebp+var_1BC], eax
.text:00008BF1                 cmp     [ebp+var_1BC], 0
.text:00008BF8                 jz      short loc_8C38
.text:00008BFA                 mov     eax, [ebp+var_1BC]
.text:00008C00                 mov     [ebp+var_1FC], eax
.text:00008C06                 mov     byte ptr [ebp+var_4], 1
.text:00008C0A                 lea     ecx, [ebp+var_BC] ; this
.text:00008C10                 call    ??1CCrcThreads@@QAE@XZ ; CCrcThreads::~CCrcThreads(void)
.text:00008C15                 mov     byte ptr [ebp+var_4], 0
.text:00008C19                 lea     ecx, [ebp+var_40] ; this
.text:00008C1C                 call    ??1CBenchBuffer@@UAE@XZ ; CBenchBuffer::~CBenchBuffer(void)
.text:00008C21                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00008C28                 lea     ecx, [ebp+var_1C] ; this
.text:00008C2B                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00008C30                 mov     eax, [ebp+var_1FC]
.text:00008C36                 jmp     short loc_8C93
.text:00008C38 ; ---------------------------------------------------------------------------
.text:00008C38
.text:00008C38 loc_8C38:                               ; CODE XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+A73j
.text:00008C38                                         ; CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+B28j
.text:00008C38                 mov     ecx, dword ptr [ebp+var_1A8+4]
.text:00008C3E                 push    ecx
.text:00008C3F                 mov     edx, dword ptr [ebp+var_1A8]
.text:00008C45                 push    edx             ; unsigned __int64
.text:00008C46                 lea     ecx, [ebp+var_194] ; this
.text:00008C4C                 call    ?GetSpeed@CBenchInfo@@QBE_K_K@Z ; CBenchInfo::GetSpeed(unsigned __int64)
.text:00008C51                 mov     ecx, [ebp+arg_10]
.text:00008C54                 mov     [ecx], eax
.text:00008C56                 mov     [ecx+4], edx
.text:00008C59                 mov     [ebp+var_200], 0
.text:00008C63                 mov     byte ptr [ebp+var_4], 1
.text:00008C67                 lea     ecx, [ebp+var_BC] ; this
.text:00008C6D                 call    ??1CCrcThreads@@QAE@XZ ; CCrcThreads::~CCrcThreads(void)
.text:00008C72                 mov     byte ptr [ebp+var_4], 0
.text:00008C76                 lea     ecx, [ebp+var_40] ; this
.text:00008C79                 call    ??1CBenchBuffer@@UAE@XZ ; CBenchBuffer::~CBenchBuffer(void)
.text:00008C7E                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00008C85                 lea     ecx, [ebp+var_1C] ; this
.text:00008C88                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00008C8D                 mov     eax, [ebp+var_200]
.text:00008C93
.text:00008C93 loc_8C93:                               ; CODE XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+92j
.text:00008C93                                         ; CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+E5j ...
.text:00008C93                 push    edx
.text:00008C94                 mov     ecx, ebp
.text:00008C96                 push    eax
.text:00008C97                 lea     edx, $LN64
.text:00008C9D                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00008CA2                 pop     eax
.text:00008CA3                 pop     edx
.text:00008CA4                 mov     ecx, [ebp+var_C]
.text:00008CA7                 mov     large fs:0, ecx
.text:00008CAE                 pop     ecx
.text:00008CAF                 pop     edi
.text:00008CB0                 pop     esi
.text:00008CB1                 add     esp, 20Ch
.text:00008CB7                 cmp     ebp, esp
.text:00008CB9                 call    __RTC_CheckEsp
.text:00008CBE                 mov     esp, ebp
.text:00008CC0                 pop     ebp
.text:00008CC1                 retn    38h
.text:00008CC1 ?CrcBench@@YGJ_KIIAA_KIIPBIABVCOneMethodInfo@@PAUIBenchPrintCallback@@PAUCTotalBenchRes@@_N0@Z endp
.text:00008CC1
.text:00008CC1 ; ---------------------------------------------------------------------------
.text:00008CC4 $LN64           dd 0Eh                  ; DATA XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+BC7o
.text:00008CC8                 dd offset $LN63
.text:00008CCC $LN63           dd 0FFFFFFE4h, 0Ch      ; DATA XREF: .text:00008CC8o
.text:00008CD4                 dd offset $LN48_1       ; "methodName"
.text:00008CD8                 dd 0FFFFFFD4h, 8
.text:00008CE0                 dd offset $LN49_1       ; "hashID"
.text:00008CE4                 dd 0FFFFFFC0h, 0Ch
.text:00008CEC                 dd offset $LN50_0       ; "buffer"
.text:00008CF0                 dd 0FFFFFFA8h, 8
.text:00008CF8                 dd offset $LN51_1       ; "RG"
.text:00008CFC                 dd 0FFFFFF54h, 40h
.text:00008D04                 dd offset $LN52_1       ; "progressInfoSpec"
.text:00008D08                 dd 0FFFFFF44h, 8
.text:00008D10                 dd offset $LN53_0       ; "threads"
.text:00008D14                 dd 0FFFFFF28h, 0Ch
.text:00008D1C                 dd offset $LN54_0       ; "name"
.text:00008D20                 dd 0FFFFFF18h, 4
.text:00008D28                 dd offset $LN55_0       ; "scp"
.text:00008D2C                 db 8, 0FFh
.text:00008D2E                 dw 0FFFFh
.text:00008D30                 dd 8
.text:00008D34                 dd offset $LN56_0       ; "reduceSize"
.text:00008D38                 dd 0FFFFFEE8h, 4
.text:00008D40                 dd offset $LN57         ; "hasher"
.text:00008D44                 dd 0FFFFFED4h, 0Ch
.text:00008D4C                 dd offset $LN58_0       ; "name"
.text:00008D50                 dd 0FFFFFEC4h, 4
.text:00008D58                 dd offset $LN59_0       ; "scp"
.text:00008D5C                 dd 0FFFFFEB4h, 8
.text:00008D64                 dd offset $LN60         ; "reduceSize"
.text:00008D68                 dd 0FFFFFE6Ch, 38h
.text:00008D70                 dd offset $LN61         ; "info"
.text:00008D74 $LN61           db 'info',0             ; DATA XREF: .text:00008D70o
.text:00008D79 $LN60           db 'reduceSize',0       ; DATA XREF: .text:00008D64o
.text:00008D84 $LN59_0         db 'scp',0              ; DATA XREF: .text:00008D58o
.text:00008D88 $LN58_0         db 'name',0             ; DATA XREF: .text:00008D4Co
.text:00008D8D $LN57           db 'hasher',0           ; DATA XREF: .text:00008D40o
.text:00008D94 $LN56_0         db 'reduceSize',0       ; DATA XREF: .text:00008D34o
.text:00008D9F $LN55_0         db 'scp',0              ; DATA XREF: .text:00008D28o
.text:00008DA3 $LN54_0         db 'name',0             ; DATA XREF: .text:00008D1Co
.text:00008DA8 $LN53_0         db 'threads',0          ; DATA XREF: .text:00008D10o
.text:00008DB0 $LN52_1         db 'progressInfoSpec',0 ; DATA XREF: .text:00008D04o
.text:00008DC1 $LN51_1         db 'RG',0               ; DATA XREF: .text:00008CF8o
.text:00008DC4 $LN50_0         db 'buffer',0           ; DATA XREF: .text:00008CECo
.text:00008DCB $LN49_1         db 'hashID',0           ; DATA XREF: .text:00008CE0o
.text:00008DD2 $LN48_1         db 'methodName',0       ; DATA XREF: .text:00008CD4o
.text:00008DDD                 align 10h
.text:00008DE0
.text:00008DE0 ; =============== S U B R O U T I N E =======================================
.text:00008DE0
.text:00008DE0 ; Attributes: bp-based frame
.text:00008DE0
.text:00008DE0 ; long __stdcall CrcBig(void const *, unsigned int, unsigned __int64, unsigned int const *, struct IHasher *, struct IBenchPrintCallback *)
.text:00008DE0 ?CrcBig@@YGJPBXI_KPBIPAUIHasher@@PAUIBenchPrintCallback@@@Z proc near
.text:00008DE0                                         ; CODE XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+919p
.text:00008DE0                                         ; CrcThreadFunction(void *)+83p
.text:00008DE0
.text:00008DE0 var_6C          = dword ptr -6Ch
.text:00008DE0 var_68          = dword ptr -68h
.text:00008DE0 var_64          = dword ptr -64h
.text:00008DE0 var_60          = dword ptr -60h
.text:00008DE0 var_5C          = dword ptr -5Ch
.text:00008DE0 var_58          = dword ptr -58h
.text:00008DE0 var_54          = dword ptr -54h
.text:00008DE0 var_50          = dword ptr -50h
.text:00008DE0 var_48          = dword ptr -48h
.text:00008DE0 var_4           = dword ptr -4
.text:00008DE0 arg_0           = dword ptr  8
.text:00008DE0 arg_4           = dword ptr  0Ch
.text:00008DE0 arg_8           = dword ptr  10h
.text:00008DE0 arg_C           = dword ptr  14h
.text:00008DE0 arg_10          = dword ptr  18h
.text:00008DE0 arg_14          = dword ptr  1Ch
.text:00008DE0 arg_18          = dword ptr  20h
.text:00008DE0
.text:00008DE0                 push    ebp
.text:00008DE1                 mov     ebp, esp
.text:00008DE3                 sub     esp, 6Ch
.text:00008DE6                 push    esi
.text:00008DE7                 push    edi
.text:00008DE8                 lea     edi, [ebp+var_6C]
.text:00008DEB                 mov     ecx, 1Bh
.text:00008DF0                 mov     eax, 0CCCCCCCCh
.text:00008DF5                 rep stosd
.text:00008DF7                 mov     eax, dword ptr ds:___security_cookie
.text:00008DFC                 xor     eax, ebp
.text:00008DFE                 mov     [ebp+var_4], eax
.text:00008E01                 mov     [ebp+var_54], 0
.text:00008E08                 mov     [ebp+var_50], 0
.text:00008E0F                 jmp     short loc_8E23
.text:00008E11 ; ---------------------------------------------------------------------------
.text:00008E11
.text:00008E11 loc_8E11:                               ; CODE XREF: CrcBig(void const *,uint,unsigned __int64,uint const *,IHasher *,IBenchPrintCallback *)+59j
.text:00008E11                 mov     eax, [ebp+var_54]
.text:00008E14                 add     eax, 1
.text:00008E17                 mov     ecx, [ebp+var_50]
.text:00008E1A                 adc     ecx, 0
.text:00008E1D                 mov     [ebp+var_54], eax
.text:00008E20                 mov     [ebp+var_50], ecx
.text:00008E23
.text:00008E23 loc_8E23:                               ; CODE XREF: CrcBig(void const *,uint,unsigned __int64,uint const *,IHasher *,IBenchPrintCallback *)+2Fj
.text:00008E23                 cmp     [ebp+var_50], 0
.text:00008E27                 ja      short loc_8E3B
.text:00008E29                 jb      short loc_8E31
.text:00008E2B                 cmp     [ebp+var_54], 40h ; '@'
.text:00008E2F                 jnb     short loc_8E3B
.text:00008E31
.text:00008E31 loc_8E31:                               ; CODE XREF: CrcBig(void const *,uint,unsigned __int64,uint const *,IHasher *,IBenchPrintCallback *)+49j
.text:00008E31                 mov     edx, [ebp+var_54]
.text:00008E34                 mov     byte ptr [ebp+edx+var_48], 0
.text:00008E39                 jmp     short loc_8E11
.text:00008E3B ; ---------------------------------------------------------------------------
.text:00008E3B
.text:00008E3B loc_8E3B:                               ; CODE XREF: CrcBig(void const *,uint,unsigned __int64,uint const *,IHasher *,IBenchPrintCallback *)+47j
.text:00008E3B                                         ; CrcBig(void const *,uint,unsigned __int64,uint const *,IHasher *,IBenchPrintCallback *)+4Fj
.text:00008E3B                 mov     [ebp+var_54], 0
.text:00008E42                 mov     [ebp+var_50], 0
.text:00008E49                 jmp     short loc_8E5D
.text:00008E4B ; ---------------------------------------------------------------------------
.text:00008E4B
.text:00008E4B loc_8E4B:                               ; CODE XREF: CrcBig(void const *,uint,unsigned __int64,uint const *,IHasher *,IBenchPrintCallback *):loc_8F80j
.text:00008E4B                 mov     eax, [ebp+var_54]
.text:00008E4E                 add     eax, 1
.text:00008E51                 mov     ecx, [ebp+var_50]
.text:00008E54                 adc     ecx, 0
.text:00008E57                 mov     [ebp+var_54], eax
.text:00008E5A                 mov     [ebp+var_50], ecx
.text:00008E5D
.text:00008E5D loc_8E5D:                               ; CODE XREF: CrcBig(void const *,uint,unsigned __int64,uint const *,IHasher *,IBenchPrintCallback *)+69j
.text:00008E5D                 mov     edx, [ebp+var_50]
.text:00008E60                 cmp     edx, [ebp+arg_C]
.text:00008E63                 ja      loc_8F85
.text:00008E69                 jb      short loc_8E77
.text:00008E6B                 mov     eax, [ebp+var_54]
.text:00008E6E                 cmp     eax, [ebp+arg_8]
.text:00008E71                 jnb     loc_8F85
.text:00008E77
.text:00008E77 loc_8E77:                               ; CODE XREF: CrcBig(void const *,uint,unsigned __int64,uint const *,IHasher *,IBenchPrintCallback *)+89j
.text:00008E77                 cmp     [ebp+arg_18], 0
.text:00008E7B                 jz      short loc_8EC1
.text:00008E7D                 mov     ecx, [ebp+var_54]
.text:00008E80                 and     ecx, 0FFh
.text:00008E86                 mov     edx, [ebp+var_50]
.text:00008E89                 and     edx, 0
.text:00008E8C                 mov     [ebp+var_6C], ecx
.text:00008E8F                 mov     [ebp+var_68], edx
.text:00008E92                 mov     eax, [ebp+var_6C]
.text:00008E95                 or      eax, [ebp+var_68]
.text:00008E98                 jnz     short loc_8EC1
.text:00008E9A                 mov     ecx, [ebp+arg_18]
.text:00008E9D                 mov     edx, [ecx]
.text:00008E9F                 mov     esi, esp
.text:00008EA1                 mov     ecx, [ebp+arg_18]
.text:00008EA4                 mov     eax, [edx+8]
.text:00008EA7                 call    eax
.text:00008EA9                 cmp     esi, esp
.text:00008EAB                 call    __RTC_CheckEsp
.text:00008EB0                 mov     [ebp+var_58], eax
.text:00008EB3                 cmp     [ebp+var_58], 0
.text:00008EB7                 jz      short loc_8EC1
.text:00008EB9                 mov     eax, [ebp+var_58]
.text:00008EBC                 jmp     loc_8F87
.text:00008EC1 ; ---------------------------------------------------------------------------
.text:00008EC1
.text:00008EC1 loc_8EC1:                               ; CODE XREF: CrcBig(void const *,uint,unsigned __int64,uint const *,IHasher *,IBenchPrintCallback *)+9Bj
.text:00008EC1                                         ; CrcBig(void const *,uint,unsigned __int64,uint const *,IHasher *,IBenchPrintCallback *)+B8j ...
.text:00008EC1                 mov     ecx, [ebp+arg_14]
.text:00008EC4                 mov     edx, [ecx]
.text:00008EC6                 mov     esi, esp
.text:00008EC8                 mov     eax, [ebp+arg_14]
.text:00008ECB                 push    eax
.text:00008ECC                 mov     ecx, [edx+0Ch]
.text:00008ECF                 call    ecx
.text:00008ED1                 cmp     esi, esp
.text:00008ED3                 call    __RTC_CheckEsp
.text:00008ED8                 mov     esi, esp
.text:00008EDA                 mov     edx, [ebp+arg_4]
.text:00008EDD                 push    edx
.text:00008EDE                 mov     eax, [ebp+arg_0]
.text:00008EE1                 push    eax
.text:00008EE2                 mov     ecx, [ebp+arg_14]
.text:00008EE5                 mov     edx, [ecx]
.text:00008EE7                 mov     eax, [ebp+arg_14]
.text:00008EEA                 push    eax
.text:00008EEB                 mov     ecx, [edx+10h]
.text:00008EEE                 call    ecx
.text:00008EF0                 cmp     esi, esp
.text:00008EF2                 call    __RTC_CheckEsp
.text:00008EF7                 mov     esi, esp
.text:00008EF9                 lea     edx, [ebp+var_48]
.text:00008EFC                 push    edx
.text:00008EFD                 mov     eax, [ebp+arg_14]
.text:00008F00                 mov     ecx, [eax]
.text:00008F02                 mov     edx, [ebp+arg_14]
.text:00008F05                 push    edx
.text:00008F06                 mov     eax, [ecx+14h]
.text:00008F09                 call    eax
.text:00008F0B                 cmp     esi, esp
.text:00008F0D                 call    __RTC_CheckEsp
.text:00008F12                 mov     ecx, [ebp+arg_14]
.text:00008F15                 mov     edx, [ecx]
.text:00008F17                 mov     esi, esp
.text:00008F19                 mov     eax, [ebp+arg_14]
.text:00008F1C                 push    eax
.text:00008F1D                 mov     ecx, [edx+18h]
.text:00008F20                 call    ecx
.text:00008F22                 cmp     esi, esp
.text:00008F24                 call    __RTC_CheckEsp
.text:00008F29                 mov     [ebp+var_5C], eax
.text:00008F2C                 cmp     [ebp+var_5C], 40h ; '@'
.text:00008F30                 jbe     short loc_8F39
.text:00008F32                 mov     eax, 1
.text:00008F37                 jmp     short loc_8F87
.text:00008F39 ; ---------------------------------------------------------------------------
.text:00008F39
.text:00008F39 loc_8F39:                               ; CODE XREF: CrcBig(void const *,uint,unsigned __int64,uint const *,IHasher *,IBenchPrintCallback *)+150j
.text:00008F39                 mov     [ebp+var_60], 0
.text:00008F40                 mov     [ebp+var_64], 0
.text:00008F47                 jmp     short loc_8F52
.text:00008F49 ; ---------------------------------------------------------------------------
.text:00008F49
.text:00008F49 loc_8F49:                               ; CODE XREF: CrcBig(void const *,uint,unsigned __int64,uint const *,IHasher *,IBenchPrintCallback *)+187j
.text:00008F49                 mov     edx, [ebp+var_64]
.text:00008F4C                 add     edx, 4
.text:00008F4F                 mov     [ebp+var_64], edx
.text:00008F52
.text:00008F52 loc_8F52:                               ; CODE XREF: CrcBig(void const *,uint,unsigned __int64,uint const *,IHasher *,IBenchPrintCallback *)+167j
.text:00008F52                 mov     eax, [ebp+var_64]
.text:00008F55                 cmp     eax, [ebp+var_5C]
.text:00008F58                 jnb     short loc_8F69
.text:00008F5A                 mov     ecx, [ebp+var_64]
.text:00008F5D                 mov     edx, [ebp+var_60]
.text:00008F60                 xor     edx, [ebp+ecx+var_48]
.text:00008F64                 mov     [ebp+var_60], edx
.text:00008F67                 jmp     short loc_8F49
.text:00008F69 ; ---------------------------------------------------------------------------
.text:00008F69
.text:00008F69 loc_8F69:                               ; CODE XREF: CrcBig(void const *,uint,unsigned __int64,uint const *,IHasher *,IBenchPrintCallback *)+178j
.text:00008F69                 cmp     [ebp+arg_10], 0
.text:00008F6D                 jz      short loc_8F80
.text:00008F6F                 mov     eax, [ebp+arg_10]
.text:00008F72                 mov     ecx, [ebp+var_60]
.text:00008F75                 cmp     ecx, [eax]
.text:00008F77                 jz      short loc_8F80
.text:00008F79                 mov     eax, 1
.text:00008F7E                 jmp     short loc_8F87
.text:00008F80 ; ---------------------------------------------------------------------------
.text:00008F80
.text:00008F80 loc_8F80:                               ; CODE XREF: CrcBig(void const *,uint,unsigned __int64,uint const *,IHasher *,IBenchPrintCallback *)+18Dj
.text:00008F80                                         ; CrcBig(void const *,uint,unsigned __int64,uint const *,IHasher *,IBenchPrintCallback *)+197j
.text:00008F80                 jmp     loc_8E4B
.text:00008F85 ; ---------------------------------------------------------------------------
.text:00008F85
.text:00008F85 loc_8F85:                               ; CODE XREF: CrcBig(void const *,uint,unsigned __int64,uint const *,IHasher *,IBenchPrintCallback *)+83j
.text:00008F85                                         ; CrcBig(void const *,uint,unsigned __int64,uint const *,IHasher *,IBenchPrintCallback *)+91j
.text:00008F85                 xor     eax, eax
.text:00008F87
.text:00008F87 loc_8F87:                               ; CODE XREF: CrcBig(void const *,uint,unsigned __int64,uint const *,IHasher *,IBenchPrintCallback *)+DCj
.text:00008F87                                         ; CrcBig(void const *,uint,unsigned __int64,uint const *,IHasher *,IBenchPrintCallback *)+157j ...
.text:00008F87                 push    edx
.text:00008F88                 mov     ecx, ebp
.text:00008F8A                 push    eax
.text:00008F8B                 lea     edx, $LN20_0
.text:00008F91                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00008F96                 pop     eax
.text:00008F97                 pop     edx
.text:00008F98                 pop     edi
.text:00008F99                 pop     esi
.text:00008F9A                 mov     ecx, [ebp+var_4]
.text:00008F9D                 xor     ecx, ebp
.text:00008F9F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text:00008FA4                 add     esp, 6Ch
.text:00008FA7                 cmp     ebp, esp
.text:00008FA9                 call    __RTC_CheckEsp
.text:00008FAE                 mov     esp, ebp
.text:00008FB0                 pop     ebp
.text:00008FB1                 retn    1Ch
.text:00008FB1 ?CrcBig@@YGJPBXI_KPBIPAUIHasher@@PAUIBenchPrintCallback@@@Z endp
.text:00008FB1
.text:00008FB1 ; ---------------------------------------------------------------------------
.text:00008FB4 $LN20_0         dd 1                    ; DATA XREF: CrcBig(void const *,uint,unsigned __int64,uint const *,IHasher *,IBenchPrintCallback *)+1ABo
.text:00008FB8                 dd offset $LN19_2
.text:00008FBC $LN19_2         dd 0FFFFFFB8h, 40h      ; DATA XREF: .text:00008FB8o
.text:00008FC4                 dd offset $LN18_2       ; "hash"
.text:00008FC8 $LN18_2         db 'hash',0             ; DATA XREF: .text:00008FC4o
.text:00008FCD                 align 10h
.text:00008FD0
.text:00008FD0 ; =============== S U B R O U T I N E =======================================
.text:00008FD0
.text:00008FD0 ; Attributes: bp-based frame
.text:00008FD0
.text:00008FD0 ; unsigned int __stdcall CrcThreadFunction(void *)
.text:00008FD0 ?CrcThreadFunction@@YGIPAX@Z proc near  ; DATA XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+5CAo
.text:00008FD0
.text:00008FD0 var_C           = dword ptr -0Ch
.text:00008FD0 var_8           = dword ptr -8
.text:00008FD0 var_4           = dword ptr -4
.text:00008FD0 arg_0           = dword ptr  8
.text:00008FD0
.text:00008FD0                 push    ebp
.text:00008FD1                 mov     ebp, esp
.text:00008FD3                 sub     esp, 0Ch
.text:00008FD6                 mov     [ebp+var_C], 0CCCCCCCCh
.text:00008FDD                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00008FE4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00008FEB                 mov     eax, dword ptr ds:___security_cookie
.text:00008FF0                 xor     eax, ebp
.text:00008FF2                 mov     [ebp+var_4], eax
.text:00008FF5                 mov     eax, [ebp+arg_0]
.text:00008FF8                 mov     [ebp+var_8], eax
.text:00008FFB                 mov     ecx, [ebp+var_8]
.text:00008FFE                 mov     eax, [ecx+30h]
.text:00009001                 call    __alloca_probe_16
.text:00009006                 mov     edx, [ebp+var_8]
.text:00009009                 movzx   eax, byte ptr [edx+20h]
.text:0000900D                 test    eax, eax
.text:0000900F                 jz      short loc_901C
.text:00009011                 mov     ecx, [ebp+var_8]
.text:00009014                 add     ecx, 24h ; '$'
.text:00009017                 mov     [ebp+var_C], ecx
.text:0000901A                 jmp     short loc_9023
.text:0000901C ; ---------------------------------------------------------------------------
.text:0000901C
.text:0000901C loc_901C:                               ; CODE XREF: CrcThreadFunction(void *)+3Fj
.text:0000901C                 mov     [ebp+var_C], 0
.text:00009023
.text:00009023 loc_9023:                               ; CODE XREF: CrcThreadFunction(void *)+4Aj
.text:00009023                 mov     edx, [ebp+var_8]
.text:00009026                 mov     eax, [edx+4]
.text:00009029                 push    eax
.text:0000902A                 mov     ecx, [ebp+var_8]
.text:0000902D                 add     ecx, 28h ; '('
.text:00009030                 call    ??B?$CMyComPtr@UIHasher@@@@QBEPAUIHasher@@XZ ; CMyComPtr<IHasher>::operator IHasher *(void)
.text:00009035                 push    eax
.text:00009036                 mov     ecx, [ebp+var_C]
.text:00009039                 push    ecx
.text:0000903A                 mov     edx, [ebp+var_8]
.text:0000903D                 mov     eax, [edx+1Ch]
.text:00009040                 push    eax
.text:00009041                 mov     ecx, [edx+18h]
.text:00009044                 push    ecx
.text:00009045                 mov     edx, [ebp+var_8]
.text:00009048                 mov     eax, [edx+10h]
.text:0000904B                 push    eax
.text:0000904C                 mov     ecx, [ebp+var_8]
.text:0000904F                 mov     edx, [ecx+0Ch]
.text:00009052                 push    edx
.text:00009053                 call    ?CrcBig@@YGJPBXI_KPBIPAUIHasher@@PAUIBenchPrintCallback@@@Z ; CrcBig(void const *,uint,unsigned __int64,uint const *,IHasher *,IBenchPrintCallback *)
.text:00009058                 mov     ecx, [ebp+var_8]
.text:0000905B                 mov     [ecx+2Ch], eax
.text:0000905E                 xor     eax, eax
.text:00009060                 lea     esp, [ebp-0Ch]
.text:00009063                 mov     ecx, [ebp+var_4]
.text:00009066                 xor     ecx, ebp
.text:00009068                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text:0000906D                 mov     esp, ebp
.text:0000906F                 pop     ebp
.text:00009070                 retn    4
.text:00009070 ?CrcThreadFunction@@YGIPAX@Z endp
.text:00009070
.text:00009070 ; ---------------------------------------------------------------------------
.text:00009073                 align 10h
.text:00009080
.text:00009080 ; =============== S U B R O U T I N E =======================================
.text:00009080
.text:00009080 ; Attributes: bp-based frame
.text:00009080
.text:00009080 ; int __stdcall RandGenCrc(int, int, CBaseRandomGenerator *)
.text:00009080 ?RandGenCrc@@YGIPAEIAAVCBaseRandomGenerator@@@Z proc near
.text:00009080                                         ; CODE XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+4E4p
.text:00009080                                         ; CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+6E5p
.text:00009080
.text:00009080 arg_0           = dword ptr  8
.text:00009080 arg_4           = dword ptr  0Ch
.text:00009080 arg_8           = dword ptr  10h
.text:00009080
.text:00009080                 push    ebp
.text:00009081                 mov     ebp, esp
.text:00009083                 mov     eax, [ebp+arg_8]
.text:00009086                 push    eax             ; CBaseRandomGenerator *
.text:00009087                 mov     ecx, [ebp+arg_4]
.text:0000908A                 push    ecx             ; int
.text:0000908B                 mov     edx, [ebp+arg_0]
.text:0000908E                 push    edx             ; int
.text:0000908F                 call    ?RandGen@@YGXPAEIAAVCBaseRandomGenerator@@@Z ; RandGen(uchar *,uint,CBaseRandomGenerator &)
.text:00009094                 mov     eax, [ebp+arg_4]
.text:00009097                 push    eax
.text:00009098                 mov     ecx, [ebp+arg_0]
.text:0000909B                 push    ecx
.text:0000909C                 call    ?CrcCalc1@@YGIPBEI@Z ; CrcCalc1(uchar const *,uint)
.text:000090A1                 cmp     ebp, esp
.text:000090A3                 call    __RTC_CheckEsp
.text:000090A8                 pop     ebp
.text:000090A9                 retn    0Ch
.text:000090A9 ?RandGenCrc@@YGIPAEIAAVCBaseRandomGenerator@@@Z endp
.text:000090A9
.text:000090A9 ; ---------------------------------------------------------------------------
.text:000090AC                 align 10h
.text:000090B0
.text:000090B0 ; =============== S U B R O U T I N E =======================================
.text:000090B0
.text:000090B0 ; Attributes: bp-based frame
.text:000090B0
.text:000090B0 ; int __stdcall TotalBench_Hash(int, int, int, int, int, CBenchCallbackToPrint *, int, char, int, int)
.text:000090B0 ?TotalBench_Hash@@YGJ_KIIPAUIBenchPrintCallback@@PAUCBenchCallbackToPrint@@PAUCTotalBenchRes@@_N0@Z proc near
.text:000090B0                                         ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1779p
.text:000090B0
.text:000090B0 var_90          = dword ptr -90h
.text:000090B0 var_8C          = dword ptr -8Ch
.text:000090B0 var_88          = dword ptr -88h
.text:000090B0 var_84          = dword ptr -84h
.text:000090B0 var_80          = byte ptr -80h
.text:000090B0 var_74          = dword ptr -74h
.text:000090B0 var_70          = dword ptr -70h
.text:000090B0 var_68          = dword ptr -68h
.text:000090B0 var_5C          = dword ptr -5Ch
.text:000090B0 var_54          = byte ptr -54h
.text:000090B0 var_3C          = byte ptr -3Ch
.text:000090B0 var_14          = dword ptr -14h
.text:000090B0 var_10          = dword ptr -10h
.text:000090B0 var_C           = dword ptr -0Ch
.text:000090B0 var_4           = dword ptr -4
.text:000090B0 arg_0           = dword ptr  8
.text:000090B0 arg_4           = dword ptr  0Ch
.text:000090B0 arg_8           = dword ptr  10h
.text:000090B0 arg_C           = dword ptr  14h
.text:000090B0 arg_10          = dword ptr  18h
.text:000090B0 arg_14          = dword ptr  1Ch
.text:000090B0 arg_18          = dword ptr  20h
.text:000090B0 arg_1C          = byte ptr  24h
.text:000090B0 arg_20          = dword ptr  28h
.text:000090B0 arg_24          = dword ptr  2Ch
.text:000090B0
.text:000090B0                 push    ebp
.text:000090B1                 mov     ebp, esp
.text:000090B3                 push    0FFFFFFFFh
.text:000090B5                 push    offset __ehhandler$?TotalBench_Hash@@YGJ_KIIPAUIBenchPrintCallback@@PAUCBenchCallbackToPrint@@PAUCTotalBenchRes@@_N0@Z
.text:000090BA                 mov     eax, large fs:0
.text:000090C0                 push    eax
.text:000090C1                 sub     esp, 84h
.text:000090C7                 push    edi
.text:000090C8                 lea     edi, [ebp+var_90]
.text:000090CE                 mov     ecx, 21h ; '!'
.text:000090D3                 mov     eax, 0CCCCCCCCh
.text:000090D8                 rep stosd
.text:000090DA                 mov     eax, dword ptr ds:___security_cookie
.text:000090DF                 xor     eax, ebp
.text:000090E1                 push    eax             ; struct tagPROPVARIANT *
.text:000090E2                 lea     eax, [ebp+var_C]
.text:000090E5                 mov     large fs:0, eax
.text:000090EB                 mov     [ebp+var_10], 0
.text:000090F2                 jmp     short loc_90FD
.text:000090F4 ; ---------------------------------------------------------------------------
.text:000090F4
.text:000090F4 loc_90F4:                               ; CODE XREF: TotalBench_Hash(unsigned __int64,uint,uint,IBenchPrintCallback *,CBenchCallbackToPrint *,CTotalBenchRes *,bool,unsigned __int64)+1C9j
.text:000090F4                 mov     eax, [ebp+var_10]
.text:000090F7                 add     eax, 1
.text:000090FA                 mov     [ebp+var_10], eax
.text:000090FD
.text:000090FD loc_90FD:                               ; CODE XREF: TotalBench_Hash(unsigned __int64,uint,uint,IBenchPrintCallback *,CBenchCallbackToPrint *,CTotalBenchRes *,bool,unsigned __int64)+42j
.text:000090FD                 cmp     [ebp+var_10], 6
.text:00009101                 jnb     loc_927E
.text:00009107                 mov     ecx, [ebp+var_10]
.text:0000910A                 shl     ecx, 4
.text:0000910D                 add     ecx, offset _g_Hash
.text:00009113                 mov     [ebp+var_14], ecx
.text:00009116                 push    0Ch             ; unsigned int
.text:00009118                 mov     edx, [ebp+var_14]
.text:0000911B                 mov     eax, [edx+0Ch]
.text:0000911E                 push    eax             ; char *
.text:0000911F                 mov     ecx, [ebp+arg_14]
.text:00009122                 mov     edx, [ecx+58h]
.text:00009125                 push    edx             ; struct IBenchPrintCallback *
.text:00009126                 call    ?PrintLeft@@YGXAAUIBenchPrintCallback@@PBDI@Z ; PrintLeft(IBenchPrintCallback &,char const *,uint)
.text:0000912B                 lea     ecx, [ebp+var_3C]
.text:0000912E                 call    ??0COneMethodInfo@@QAE@XZ ; COneMethodInfo::COneMethodInfo(void)
.text:00009133                 mov     [ebp+var_4], 0
.text:0000913A                 lea     ecx, [ebp+var_54] ; this
.text:0000913D                 call    ??0CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::CPropVariant(void)
.text:00009142                 mov     byte ptr [ebp+var_4], 1
.text:00009146                 mov     eax, [ebp+var_14]
.text:00009149                 mov     ecx, [eax+0Ch]
.text:0000914C                 push    ecx             ; struct tagPROPVARIANT *
.text:0000914D                 lea     ecx, [ebp+var_54]
.text:00009150                 call    ??4CPropVariant@NCOM@NWindows@@QAEAAV012@PBD@Z ; NWindows::NCOM::CPropVariant::operator=(char const *)
.text:00009155                 lea     edx, [ebp+var_54]
.text:00009158                 push    edx
.text:00009159                 lea     ecx, [ebp+var_80]
.text:0000915C                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00009161                 mov     [ebp+var_8C], eax
.text:00009167                 mov     eax, [ebp+var_8C]
.text:0000916D                 mov     [ebp+var_90], eax
.text:00009173                 mov     byte ptr [ebp+var_4], 2
.text:00009177                 mov     ecx, [ebp+var_90]
.text:0000917D                 push    ecx             ; struct UString *
.text:0000917E                 lea     ecx, [ebp+var_3C] ; this
.text:00009181                 call    ?ParseMethodFromPROPVARIANT@COneMethodInfo@@QAEJABVUString@@ABUtagPROPVARIANT@@@Z ; COneMethodInfo::ParseMethodFromPROPVARIANT(UString const &,tagPROPVARIANT const &)
.text:00009186                 mov     [ebp+var_5C], eax
.text:00009189                 mov     byte ptr [ebp+var_4], 1
.text:0000918D                 lea     ecx, [ebp+var_80] ; this
.text:00009190                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00009195                 cmp     [ebp+var_5C], 0
.text:00009199                 jz      short loc_91CA
.text:0000919B                 mov     edx, [ebp+var_5C]
.text:0000919E                 mov     [ebp+var_84], edx
.text:000091A4                 mov     byte ptr [ebp+var_4], 0
.text:000091A8                 lea     ecx, [ebp+var_54] ; this
.text:000091AB                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:000091B0                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000091B7                 lea     ecx, [ebp+var_3C] ; this
.text:000091BA                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:000091BF                 mov     eax, [ebp+var_84]
.text:000091C5                 jmp     loc_9280
.text:000091CA ; ---------------------------------------------------------------------------
.text:000091CA
.text:000091CA loc_91CA:                               ; CODE XREF: TotalBench_Hash(unsigned __int64,uint,uint,IBenchPrintCallback *,CBenchCallbackToPrint *,CTotalBenchRes *,bool,unsigned __int64)+E9j
.text:000091CA                 mov     eax, [ebp+arg_24]
.text:000091CD                 push    eax             ; int
.text:000091CE                 mov     ecx, [ebp+arg_20]
.text:000091D1                 push    ecx             ; int
.text:000091D2                 movzx   edx, [ebp+arg_1C]
.text:000091D6                 push    edx             ; char
.text:000091D7                 mov     eax, [ebp+arg_18]
.text:000091DA                 push    eax             ; int
.text:000091DB                 mov     ecx, [ebp+arg_10]
.text:000091DE                 push    ecx             ; int
.text:000091DF                 lea     edx, [ebp+var_3C]
.text:000091E2                 push    edx             ; CProps *
.text:000091E3                 mov     eax, [ebp+var_14]
.text:000091E6                 add     eax, 8
.text:000091E9                 push    eax             ; int
.text:000091EA                 mov     ecx, [ebp+var_14]
.text:000091ED                 mov     edx, [ecx]
.text:000091EF                 push    edx             ; int
.text:000091F0                 mov     eax, [ebp+var_14]
.text:000091F3                 mov     ecx, [eax+4]
.text:000091F6                 push    ecx             ; int
.text:000091F7                 lea     edx, [ebp+var_68]
.text:000091FA                 push    edx             ; int
.text:000091FB                 mov     eax, [ebp+arg_C]
.text:000091FE                 push    eax             ; int
.text:000091FF                 mov     ecx, [ebp+arg_8]
.text:00009202                 push    ecx             ; int
.text:00009203                 mov     edx, [ebp+arg_4]
.text:00009206                 push    edx             ; int
.text:00009207                 mov     eax, [ebp+arg_0]
.text:0000920A                 push    eax             ; int
.text:0000920B                 call    ?CrcBench@@YGJ_KIIAA_KIIPBIABVCOneMethodInfo@@PAUIBenchPrintCallback@@PAUCTotalBenchRes@@_N0@Z ; CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)
.text:00009210                 mov     [ebp+var_70], eax
.text:00009213                 cmp     [ebp+var_70], 80004001h
.text:0000921A                 jnz     short loc_921E
.text:0000921C                 jmp     short loc_9256
.text:0000921E ; ---------------------------------------------------------------------------
.text:0000921E
.text:0000921E loc_921E:                               ; CODE XREF: TotalBench_Hash(unsigned __int64,uint,uint,IBenchPrintCallback *,CBenchCallbackToPrint *,CTotalBenchRes *,bool,unsigned __int64)+16Aj
.text:0000921E                 mov     ecx, [ebp+var_70]
.text:00009221                 mov     [ebp+var_74], ecx
.text:00009224                 cmp     [ebp+var_74], 0
.text:00009228                 jz      short loc_9256
.text:0000922A                 mov     edx, [ebp+var_74]
.text:0000922D                 mov     [ebp+var_88], edx
.text:00009233                 mov     byte ptr [ebp+var_4], 0
.text:00009237                 lea     ecx, [ebp+var_54] ; this
.text:0000923A                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:0000923F                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00009246                 lea     ecx, [ebp+var_3C] ; this
.text:00009249                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:0000924E                 mov     eax, [ebp+var_88]
.text:00009254                 jmp     short loc_9280
.text:00009256 ; ---------------------------------------------------------------------------
.text:00009256
.text:00009256 loc_9256:                               ; CODE XREF: TotalBench_Hash(unsigned __int64,uint,uint,IBenchPrintCallback *,CBenchCallbackToPrint *,CTotalBenchRes *,bool,unsigned __int64)+16Cj
.text:00009256                                         ; TotalBench_Hash(unsigned __int64,uint,uint,IBenchPrintCallback *,CBenchCallbackToPrint *,CTotalBenchRes *,bool,unsigned __int64)+178j
.text:00009256                 mov     ecx, [ebp+arg_14] ; this
.text:00009259                 call    ?NewLine@CBenchCallbackToPrint@@QAEXXZ ; CBenchCallbackToPrint::NewLine(void)
.text:0000925E                 mov     byte ptr [ebp+var_4], 0
.text:00009262                 lea     ecx, [ebp+var_54] ; this
.text:00009265                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:0000926A                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00009271                 lea     ecx, [ebp+var_3C] ; this
.text:00009274                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:00009279                 jmp     loc_90F4
.text:0000927E ; ---------------------------------------------------------------------------
.text:0000927E
.text:0000927E loc_927E:                               ; CODE XREF: TotalBench_Hash(unsigned __int64,uint,uint,IBenchPrintCallback *,CBenchCallbackToPrint *,CTotalBenchRes *,bool,unsigned __int64)+51j
.text:0000927E                 xor     eax, eax
.text:00009280
.text:00009280 loc_9280:                               ; CODE XREF: TotalBench_Hash(unsigned __int64,uint,uint,IBenchPrintCallback *,CBenchCallbackToPrint *,CTotalBenchRes *,bool,unsigned __int64)+115j
.text:00009280                                         ; TotalBench_Hash(unsigned __int64,uint,uint,IBenchPrintCallback *,CBenchCallbackToPrint *,CTotalBenchRes *,bool,unsigned __int64)+1A4j
.text:00009280                 push    edx
.text:00009281                 mov     ecx, ebp
.text:00009283                 push    eax
.text:00009284                 lea     edx, $LN18_3
.text:0000928A                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:0000928F                 pop     eax
.text:00009290                 pop     edx
.text:00009291                 mov     ecx, [ebp+var_C]
.text:00009294                 mov     large fs:0, ecx
.text:0000929B                 pop     ecx
.text:0000929C                 pop     edi
.text:0000929D                 add     esp, 90h
.text:000092A3                 cmp     ebp, esp
.text:000092A5                 call    __RTC_CheckEsp
.text:000092AA                 mov     esp, ebp
.text:000092AC                 pop     ebp
.text:000092AD                 retn    28h
.text:000092AD ?TotalBench_Hash@@YGJ_KIIPAUIBenchPrintCallback@@PAUCBenchCallbackToPrint@@PAUCTotalBenchRes@@_N0@Z endp
.text:000092AD
.text:000092AD ; ---------------------------------------------------------------------------
.text:000092B0 $LN18_3         dd 3                    ; DATA XREF: TotalBench_Hash(unsigned __int64,uint,uint,IBenchPrintCallback *,CBenchCallbackToPrint *,CTotalBenchRes *,bool,unsigned __int64)+1D4o
.text:000092B4                 dd offset $LN17_2
.text:000092B8 $LN17_2         dd 0FFFFFFC4h, 24h      ; DATA XREF: .text:000092B4o
.text:000092C0                 dd offset $LN13         ; "method"
.text:000092C4                 dd 0FFFFFFACh, 10h
.text:000092CC                 dd offset $LN14_0       ; "propVariant"
.text:000092D0                 dd 0FFFFFF98h, 8
.text:000092D8                 dd offset $LN15_1       ; "speed"
.text:000092DC $LN15_1         db 'speed',0            ; DATA XREF: .text:000092D8o
.text:000092E2 $LN14_0         db 'propVariant',0      ; DATA XREF: .text:000092CCo
.text:000092EE $LN13           db 'method',0           ; DATA XREF: .text:000092C0o
.text:000092F5                 align 10h
.text:00009300
.text:00009300 ; =============== S U B R O U T I N E =======================================
.text:00009300
.text:00009300 ; Attributes: bp-based frame
.text:00009300
.text:00009300 ; int __stdcall ParseNumberString(UString *, int)
.text:00009300 ?ParseNumberString@@YGXABVUString@@AAVCPropVariant@NCOM@NWindows@@@Z proc near
.text:00009300                                         ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+116p
.text:00009300
.text:00009300 var_14          = dword ptr -14h
.text:00009300 var_10          = dword ptr -10h
.text:00009300 var_C           = dword ptr -0Ch
.text:00009300 var_8           = dword ptr -8
.text:00009300 var_4           = dword ptr -4
.text:00009300 arg_0           = dword ptr  8
.text:00009300 arg_4           = dword ptr  0Ch
.text:00009300
.text:00009300                 push    ebp
.text:00009301                 mov     ebp, esp
.text:00009303                 sub     esp, 14h
.text:00009306                 mov     eax, 0CCCCCCCCh
.text:0000930B                 mov     [ebp+var_14], eax
.text:0000930E                 mov     [ebp+var_10], eax
.text:00009311                 mov     [ebp+var_C], eax
.text:00009314                 mov     [ebp+var_8], eax
.text:00009317                 mov     [ebp+var_4], eax
.text:0000931A                 lea     eax, [ebp+var_8]
.text:0000931D                 push    eax             ; wchar_t **
.text:0000931E                 mov     ecx, [ebp+arg_0]
.text:00009321                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00009326                 push    eax             ; wchar_t *
.text:00009327                 call    ?ConvertStringToUInt64@@YG_KPB_WPAPB_W@Z ; ConvertStringToUInt64(wchar_t const *,wchar_t const * *)
.text:0000932C                 mov     [ebp+var_14], eax
.text:0000932F                 mov     [ebp+var_10], edx
.text:00009332                 mov     ecx, [ebp+var_8]
.text:00009335                 movzx   edx, word ptr [ecx]
.text:00009338                 test    edx, edx
.text:0000933A                 jnz     short loc_934B
.text:0000933C                 mov     ecx, [ebp+arg_0] ; this
.text:0000933F                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:00009344                 movzx   eax, al
.text:00009347                 test    eax, eax
.text:00009349                 jz      short loc_9359
.text:0000934B
.text:0000934B loc_934B:                               ; CODE XREF: ParseNumberString(UString const &,NWindows::NCOM::CPropVariant &)+3Aj
.text:0000934B                 mov     ecx, [ebp+arg_0]
.text:0000934E                 push    ecx
.text:0000934F                 mov     ecx, [ebp+arg_4]
.text:00009352                 call    ??4CPropVariant@NCOM@NWindows@@QAEAAV012@ABVUString@@@Z ; NWindows::NCOM::CPropVariant::operator=(UString const &)
.text:00009357                 jmp     short loc_9385
.text:00009359 ; ---------------------------------------------------------------------------
.text:00009359
.text:00009359 loc_9359:                               ; CODE XREF: ParseNumberString(UString const &,NWindows::NCOM::CPropVariant &)+49j
.text:00009359                 cmp     [ebp+var_10], 0
.text:0000935D                 ja      short loc_9375
.text:0000935F                 jb      short loc_9367
.text:00009361                 cmp     [ebp+var_14], 0FFFFFFFFh
.text:00009365                 ja      short loc_9375
.text:00009367
.text:00009367 loc_9367:                               ; CODE XREF: ParseNumberString(UString const &,NWindows::NCOM::CPropVariant &)+5Fj
.text:00009367                 mov     edx, [ebp+var_14]
.text:0000936A                 push    edx
.text:0000936B                 mov     ecx, [ebp+arg_4]
.text:0000936E                 call    ??4CPropVariant@NCOM@NWindows@@QAEAAV012@I@Z ; NWindows::NCOM::CPropVariant::operator=(uint)
.text:00009373                 jmp     short loc_9385
.text:00009375 ; ---------------------------------------------------------------------------
.text:00009375
.text:00009375 loc_9375:                               ; CODE XREF: ParseNumberString(UString const &,NWindows::NCOM::CPropVariant &)+5Dj
.text:00009375                                         ; ParseNumberString(UString const &,NWindows::NCOM::CPropVariant &)+65j
.text:00009375                 mov     eax, [ebp+var_10]
.text:00009378                 push    eax
.text:00009379                 mov     ecx, [ebp+var_14]
.text:0000937C                 push    ecx
.text:0000937D                 mov     ecx, [ebp+arg_4]
.text:00009380                 call    ??4CPropVariant@NCOM@NWindows@@QAEAAV012@_K@Z ; NWindows::NCOM::CPropVariant::operator=(unsigned __int64)
.text:00009385
.text:00009385 loc_9385:                               ; CODE XREF: ParseNumberString(UString const &,NWindows::NCOM::CPropVariant &)+57j
.text:00009385                                         ; ParseNumberString(UString const &,NWindows::NCOM::CPropVariant &)+73j
.text:00009385                 push    edx
.text:00009386                 mov     ecx, ebp
.text:00009388                 push    eax
.text:00009389                 lea     edx, $LN11
.text:0000938F                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00009394                 pop     eax
.text:00009395                 pop     edx
.text:00009396                 add     esp, 14h
.text:00009399                 cmp     ebp, esp
.text:0000939B                 call    __RTC_CheckEsp
.text:000093A0                 mov     esp, ebp
.text:000093A2                 pop     ebp
.text:000093A3                 retn    8
.text:000093A3 ?ParseNumberString@@YGXABVUString@@AAVCPropVariant@NCOM@NWindows@@@Z endp
.text:000093A3
.text:000093A3 ; ---------------------------------------------------------------------------
.text:000093A6                 align 4
.text:000093A8 $LN11           dd 1                    ; DATA XREF: ParseNumberString(UString const &,NWindows::NCOM::CPropVariant &)+89o
.text:000093AC                 dd offset $LN10_2
.text:000093B0 $LN10_2         dd 0FFFFFFF8h, 4        ; DATA XREF: .text:000093ACo
.text:000093B8                 dd offset $LN9_4
.text:000093BC $LN9_4          dd 646E65h              ; DATA XREF: .text:000093B8o
.text:000093C0
.text:000093C0 ; =============== S U B R O U T I N E =======================================
.text:000093C0
.text:000093C0 ; Attributes: bp-based frame
.text:000093C0
.text:000093C0 ; unsigned int __stdcall GetNumThreadsNext(unsigned int, unsigned int)
.text:000093C0 ?GetNumThreadsNext@@YGIII@Z proc near   ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+A89p
.text:000093C0                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+D20p
.text:000093C0
.text:000093C0 var_8           = dword ptr -8
.text:000093C0 var_4           = dword ptr -4
.text:000093C0 arg_0           = dword ptr  8
.text:000093C0 arg_4           = dword ptr  0Ch
.text:000093C0
.text:000093C0                 push    ebp
.text:000093C1                 mov     ebp, esp
.text:000093C3                 sub     esp, 8
.text:000093C6                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000093CD                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000093D4                 cmp     [ebp+arg_0], 2
.text:000093D8                 jnb     short loc_93E2
.text:000093DA                 mov     eax, [ebp+arg_0]
.text:000093DD                 add     eax, 1
.text:000093E0                 jmp     short loc_9417
.text:000093E2 ; ---------------------------------------------------------------------------
.text:000093E2
.text:000093E2 loc_93E2:                               ; CODE XREF: GetNumThreadsNext(uint,uint)+18j
.text:000093E2                 mov     eax, [ebp+arg_0]
.text:000093E5                 sub     eax, 1
.text:000093E8                 mov     [ebp+arg_0], eax
.text:000093EB                 mov     edx, [ebp+arg_0]
.text:000093EE                 and     edx, 1
.text:000093F1                 add     edx, 2
.text:000093F4                 mov     ecx, [ebp+arg_0]
.text:000093F7                 shr     ecx, 1
.text:000093F9                 shl     edx, cl
.text:000093FB                 mov     [ebp+var_4], edx
.text:000093FE                 mov     eax, [ebp+var_4]
.text:00009401                 cmp     eax, [ebp+arg_4]
.text:00009404                 ja      short loc_940E
.text:00009406                 mov     ecx, [ebp+var_4]
.text:00009409                 mov     [ebp+var_8], ecx
.text:0000940C                 jmp     short loc_9414
.text:0000940E ; ---------------------------------------------------------------------------
.text:0000940E
.text:0000940E loc_940E:                               ; CODE XREF: GetNumThreadsNext(uint,uint)+44j
.text:0000940E                 mov     edx, [ebp+arg_4]
.text:00009411                 mov     [ebp+var_8], edx
.text:00009414
.text:00009414 loc_9414:                               ; CODE XREF: GetNumThreadsNext(uint,uint)+4Cj
.text:00009414                 mov     eax, [ebp+var_8]
.text:00009417
.text:00009417 loc_9417:                               ; CODE XREF: GetNumThreadsNext(uint,uint)+20j
.text:00009417                 mov     esp, ebp
.text:00009419                 pop     ebp
.text:0000941A                 retn    8
.text:0000941A ?GetNumThreadsNext@@YGIII@Z endp
.text:0000941A
.text:0000941A ; ---------------------------------------------------------------------------
.text:0000941D                 align 10h
.text:00009420
.text:00009420 ; =============== S U B R O U T I N E =======================================
.text:00009420
.text:00009420 ; Attributes: bp-based frame
.text:00009420
.text:00009420 ; bool __stdcall AreSameMethodNames(char const *, char const *)
.text:00009420 ?AreSameMethodNames@@YG_NPBD0@Z proc near
.text:00009420                                         ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+9A6p
.text:00009420                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1918p
.text:00009420
.text:00009420 var_4           = dword ptr -4
.text:00009420 arg_0           = dword ptr  8
.text:00009420 arg_4           = dword ptr  0Ch
.text:00009420
.text:00009420                 push    ebp
.text:00009421                 mov     ebp, esp
.text:00009423                 push    ecx
.text:00009424                 push    esi
.text:00009425                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000942C
.text:0000942C loc_942C:                               ; CODE XREF: AreSameMethodNames(char const *,char const *):loc_947Cj
.text:0000942C                 mov     eax, [ebp+arg_4]
.text:0000942F                 mov     cl, [eax]
.text:00009431                 mov     byte ptr [ebp+var_4+3], cl
.text:00009434                 mov     edx, [ebp+arg_4]
.text:00009437                 add     edx, 1
.text:0000943A                 mov     [ebp+arg_4], edx
.text:0000943D                 movsx   eax, byte ptr [ebp+var_4+3]
.text:00009441                 test    eax, eax
.text:00009443                 jnz     short loc_9449
.text:00009445                 mov     al, 1
.text:00009447                 jmp     short loc_947E
.text:00009449 ; ---------------------------------------------------------------------------
.text:00009449
.text:00009449 loc_9449:                               ; CODE XREF: AreSameMethodNames(char const *,char const *)+23j
.text:00009449                 mov     ecx, [ebp+arg_0]
.text:0000944C                 mov     dl, [ecx]
.text:0000944E                 mov     byte ptr [ebp+var_4+2], dl
.text:00009451                 mov     eax, [ebp+arg_0]
.text:00009454                 add     eax, 1
.text:00009457                 mov     [ebp+arg_0], eax
.text:0000945A                 movzx   ecx, byte ptr [ebp+var_4+2]
.text:0000945E                 push    ecx             ; char
.text:0000945F                 call    ?MyCharLower_Ascii@@YGDD@Z ; MyCharLower_Ascii(char)
.text:00009464                 movsx   esi, al
.text:00009467                 movzx   edx, byte ptr [ebp+var_4+3]
.text:0000946B                 push    edx             ; char
.text:0000946C                 call    ?MyCharLower_Ascii@@YGDD@Z ; MyCharLower_Ascii(char)
.text:00009471                 movsx   eax, al
.text:00009474                 cmp     esi, eax
.text:00009476                 jz      short loc_947C
.text:00009478                 xor     al, al
.text:0000947A                 jmp     short loc_947E
.text:0000947C ; ---------------------------------------------------------------------------
.text:0000947C
.text:0000947C loc_947C:                               ; CODE XREF: AreSameMethodNames(char const *,char const *)+56j
.text:0000947C                 jmp     short loc_942C
.text:0000947E ; ---------------------------------------------------------------------------
.text:0000947E
.text:0000947E loc_947E:                               ; CODE XREF: AreSameMethodNames(char const *,char const *)+27j
.text:0000947E                                         ; AreSameMethodNames(char const *,char const *)+5Aj
.text:0000947E                 pop     esi
.text:0000947F                 add     esp, 4
.text:00009482                 cmp     ebp, esp
.text:00009484                 call    __RTC_CheckEsp
.text:00009489                 mov     esp, ebp
.text:0000948B                 pop     ebp
.text:0000948C                 retn    8
.text:0000948C ?AreSameMethodNames@@YG_NPBD0@Z endp
.text:0000948C
.text:0000948C ; ---------------------------------------------------------------------------
.text:0000948F                 align 10h
.text:0000948F _text           ends
.text:0000948F
.rtc$TMZ:00009490 ; ===========================================================================
.rtc$TMZ:00009490
.rtc$TMZ:00009490 ; Segment type: Pure data
.rtc$TMZ:00009490 ; Segment permissions: Read
.rtc$TMZ:00009490 _rtc$TMZ        segment dword public 'DATA' use32
.rtc$TMZ:00009490                 assume cs:_rtc$TMZ
.rtc$TMZ:00009490                 ;org 9490h
.rtc$TMZ:00009490 ; COMDAT (pick any)
.rtc$TMZ:00009490 __RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
.rtc$TMZ:00009490 _rtc$TMZ        ends
.rtc$TMZ:00009490
.rtc$IMZ:00009494 ; ===========================================================================
.rtc$IMZ:00009494
.rtc$IMZ:00009494 ; Segment type: Pure data
.rtc$IMZ:00009494 ; Segment permissions: Read
.rtc$IMZ:00009494 _rtc$IMZ        segment dword public 'DATA' use32
.rtc$IMZ:00009494                 assume cs:_rtc$IMZ
.rtc$IMZ:00009494                 ;org 9494h
.rtc$IMZ:00009494 ; COMDAT (pick any)
.rtc$IMZ:00009494 __RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
.rtc$IMZ:00009494 _rtc$IMZ        ends
.rtc$IMZ:00009494
.text:00009498 ; ===========================================================================
.text:00009498
.text:00009498 ; Segment type: Pure code
.text:00009498 ; Segment permissions: Read/Execute
.text:00009498 _text           segment para public 'CODE' use32
.text:00009498                 assume cs:_text
.text:00009498                 ;org 9498h
.text:00009498 ; COMDAT (pick any)
.text:00009498                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009498
.text:00009498 ; =============== S U B R O U T I N E =======================================
.text:00009498
.text:00009498 ; Attributes: bp-based frame
.text:00009498
.text:00009498 ; void __thiscall CUserTime::Init(CUserTime *__hidden this)
.text:00009498                 public ?Init@CUserTime@@QAEXXZ
.text:00009498 ?Init@CUserTime@@QAEXXZ proc near       ; CODE XREF: CBenchInfoCalc::SetStartTime(void)+4Ep
.text:00009498
.text:00009498 var_4           = dword ptr -4
.text:00009498
.text:00009498                 push    ebp
.text:00009499                 mov     ebp, esp
.text:0000949B                 push    ecx
.text:0000949C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000094A3                 mov     [ebp+var_4], ecx
.text:000094A6                 call    ?GetWinUserTime@@YG_KXZ ; GetWinUserTime(void)
.text:000094AB                 mov     ecx, [ebp+var_4]
.text:000094AE                 mov     [ecx], eax
.text:000094B0                 mov     [ecx+4], edx
.text:000094B3                 add     esp, 4
.text:000094B6                 cmp     ebp, esp
.text:000094B8                 call    __RTC_CheckEsp
.text:000094BD                 mov     esp, ebp
.text:000094BF                 pop     ebp
.text:000094C0                 retn
.text:000094C0 ?Init@CUserTime@@QAEXXZ endp
.text:000094C0
.text:000094C0 ; ---------------------------------------------------------------------------
.text:000094C1                 align 4
.text:000094C1 _text           ends
.text:000094C1
.text:000094C4 ; ===========================================================================
.text:000094C4
.text:000094C4 ; Segment type: Pure code
.text:000094C4 ; Segment permissions: Read/Execute
.text:000094C4 _text           segment para public 'CODE' use32
.text:000094C4                 assume cs:_text
.text:000094C4                 ;org 94C4h
.text:000094C4 ; COMDAT (pick any)
.text:000094C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000094C4
.text:000094C4 ; =============== S U B R O U T I N E =======================================
.text:000094C4
.text:000094C4 ; Attributes: bp-based frame
.text:000094C4
.text:000094C4 ; unsigned __int64 __thiscall CUserTime::GetUserTime(CUserTime *__hidden this)
.text:000094C4                 public ?GetUserTime@CUserTime@@QAE_KXZ
.text:000094C4 ?GetUserTime@CUserTime@@QAE_KXZ proc near
.text:000094C4                                         ; CODE XREF: CBenchInfoCalc::SetFinishTime(CBenchInfo &)+38p
.text:000094C4
.text:000094C4 var_4           = dword ptr -4
.text:000094C4
.text:000094C4                 push    ebp
.text:000094C5                 mov     ebp, esp
.text:000094C7                 push    ecx
.text:000094C8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000094CF                 mov     [ebp+var_4], ecx
.text:000094D2                 call    ?GetWinUserTime@@YG_KXZ ; GetWinUserTime(void)
.text:000094D7                 mov     ecx, [ebp+var_4]
.text:000094DA                 sub     eax, [ecx]
.text:000094DC                 sbb     edx, [ecx+4]
.text:000094DF                 add     esp, 4
.text:000094E2                 cmp     ebp, esp
.text:000094E4                 call    __RTC_CheckEsp
.text:000094E9                 mov     esp, ebp
.text:000094EB                 pop     ebp
.text:000094EC                 retn
.text:000094EC ?GetUserTime@CUserTime@@QAE_KXZ endp
.text:000094EC
.text:000094EC ; ---------------------------------------------------------------------------
.text:000094ED                 align 10h
.text:000094ED _text           ends
.text:000094ED
.text:000094F0 ; ===========================================================================
.text:000094F0
.text:000094F0 ; Segment type: Pure code
.text:000094F0 ; Segment permissions: Read/Execute
.text:000094F0 _text           segment para public 'CODE' use32
.text:000094F0                 assume cs:_text
.text:000094F0                 ;org 94F0h
.text:000094F0 ; COMDAT (pick any)
.text:000094F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000094F0
.text:000094F0 ; =============== S U B R O U T I N E =======================================
.text:000094F0
.text:000094F0 ; Attributes: bp-based frame
.text:000094F0
.text:000094F0 ; _DWORD __thiscall CBenchInfo::CBenchInfo(CBenchInfo *__hidden this)
.text:000094F0                 public ??0CBenchInfo@@QAE@XZ
.text:000094F0 ??0CBenchInfo@@QAE@XZ proc near         ; CODE XREF: CBenchProgressInfo::SetRatioInfo(unsigned __int64 const *,unsigned __int64 const *)+47p
.text:000094F0                                         ; MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+82Ap ...
.text:000094F0
.text:000094F0 var_4           = dword ptr -4
.text:000094F0
.text:000094F0                 push    ebp
.text:000094F1                 mov     ebp, esp
.text:000094F3                 push    ecx
.text:000094F4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000094FB                 mov     [ebp+var_4], ecx
.text:000094FE                 mov     eax, [ebp+var_4]
.text:00009501                 mov     dword ptr [eax+30h], 0
.text:00009508                 mov     dword ptr [eax+34h], 0
.text:0000950F                 mov     eax, [ebp+var_4]
.text:00009512                 mov     esp, ebp
.text:00009514                 pop     ebp
.text:00009515                 retn
.text:00009515 ??0CBenchInfo@@QAE@XZ endp
.text:00009515
.text:00009515 ; ---------------------------------------------------------------------------
.text:00009516                 align 4
.text:00009516 _text           ends
.text:00009516
.text:00009518 ; ===========================================================================
.text:00009518
.text:00009518 ; Segment type: Pure code
.text:00009518 ; Segment permissions: Read/Execute
.text:00009518 _text           segment para public 'CODE' use32
.text:00009518                 assume cs:_text
.text:00009518                 ;org 9518h
.text:00009518 ; COMDAT (pick any)
.text:00009518                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009518
.text:00009518 ; =============== S U B R O U T I N E =======================================
.text:00009518
.text:00009518 ; Attributes: bp-based frame
.text:00009518
.text:00009518 ; void __thiscall CBenchProgressStatus::SetResult(CBenchProgressStatus *this, __int32)
.text:00009518                 public ?SetResult@CBenchProgressStatus@@QAEXJ@Z
.text:00009518 ?SetResult@CBenchProgressStatus@@QAEXJ@Z proc near
.text:00009518                                         ; CODE XREF: CBenchProgressInfo::SetRatioInfo(unsigned __int64 const *,unsigned __int64 const *)+123p
.text:00009518                                         ; CEncoderInfo::EncodeThreadFunction(void *)+A8p
.text:00009518
.text:00009518 var_10          = dword ptr -10h
.text:00009518 var_C           = dword ptr -0Ch
.text:00009518 var_8           = dword ptr -8
.text:00009518 var_4           = dword ptr -4
.text:00009518 arg_0           = dword ptr  8
.text:00009518
.text:00009518                 push    ebp
.text:00009519                 mov     ebp, esp
.text:0000951B                 sub     esp, 10h
.text:0000951E                 mov     eax, 0CCCCCCCCh
.text:00009523                 mov     [ebp+var_10], eax
.text:00009526                 mov     [ebp+var_C], eax
.text:00009529                 mov     [ebp+var_8], eax
.text:0000952C                 mov     [ebp+var_4], eax
.text:0000952F                 mov     [ebp+var_4], ecx
.text:00009532                 mov     eax, [ebp+var_4]
.text:00009535                 push    eax             ; struct NWindows::NSynchronization::CCriticalSection *
.text:00009536                 lea     ecx, [ebp+var_C] ; this
.text:00009539                 call    ??0CCriticalSectionLock@NSynchronization@NWindows@@QAE@AAVCCriticalSection@12@@Z ; NWindows::NSynchronization::CCriticalSectionLock::CCriticalSectionLock(NWindows::NSynchronization::CCriticalSection &)
.text:0000953E                 mov     ecx, [ebp+var_4]
.text:00009541                 mov     edx, [ebp+arg_0]
.text:00009544                 mov     [ecx+18h], edx
.text:00009547                 lea     ecx, [ebp+var_C] ; this
.text:0000954A                 call    ??1CCriticalSectionLock@NSynchronization@NWindows@@QAE@XZ ; NWindows::NSynchronization::CCriticalSectionLock::~CCriticalSectionLock(void)
.text:0000954F                 push    edx
.text:00009550                 mov     ecx, ebp
.text:00009552                 push    eax
.text:00009553                 lea     edx, $LN6_0
.text:00009559                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:0000955E                 pop     eax
.text:0000955F                 pop     edx
.text:00009560                 add     esp, 10h
.text:00009563                 cmp     ebp, esp
.text:00009565                 call    __RTC_CheckEsp
.text:0000956A                 mov     esp, ebp
.text:0000956C                 pop     ebp
.text:0000956D                 retn    4
.text:0000956D ?SetResult@CBenchProgressStatus@@QAEXJ@Z endp
.text:0000956D
.text:0000956D ; ---------------------------------------------------------------------------
.text:00009570 $LN6_0          dd 1                    ; DATA XREF: CBenchProgressStatus::SetResult(long)+3Bo
.text:00009574                 dd offset $LN5_0
.text:00009578 $LN5_0          dd 0FFFFFFF4h, 4        ; DATA XREF: .text:00009574o
.text:00009580                 dd offset $LN4_0        ; "lock"
.text:00009584 $LN4_0          db 'lock',0             ; DATA XREF: .text:00009580o
.text:00009589                 align 4
.text:00009589 _text           ends
.text:00009589
.text:0000958C ; ===========================================================================
.text:0000958C
.text:0000958C ; Segment type: Pure code
.text:0000958C ; Segment permissions: Read/Execute
.text:0000958C _text           segment para public 'CODE' use32
.text:0000958C                 assume cs:_text
.text:0000958C                 ;org 958Ch
.text:0000958C ; COMDAT (pick any)
.text:0000958C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000958C
.text:0000958C ; =============== S U B R O U T I N E =======================================
.text:0000958C
.text:0000958C ; Attributes: bp-based frame
.text:0000958C
.text:0000958C ; _DWORD __thiscall NWindows::NSynchronization::CCriticalSectionLock::CCriticalSectionLock(NWindows::NSynchronization::CCriticalSectionLock *this, struct NWindows::NSynchronization::CCriticalSection *)
.text:0000958C                 public ??0CCriticalSectionLock@NSynchronization@NWindows@@QAE@AAVCCriticalSection@12@@Z
.text:0000958C ??0CCriticalSectionLock@NSynchronization@NWindows@@QAE@AAVCCriticalSection@12@@Z proc near
.text:0000958C                                         ; CODE XREF: CBenchProgressStatus::SetResult(long)+21p
.text:0000958C                                         ; CBenchProgressStatus::GetResult(void)+24p
.text:0000958C
.text:0000958C var_4           = dword ptr -4
.text:0000958C arg_0           = dword ptr  8
.text:0000958C
.text:0000958C                 push    ebp
.text:0000958D                 mov     ebp, esp
.text:0000958F                 push    ecx
.text:00009590                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00009597                 mov     [ebp+var_4], ecx
.text:0000959A                 mov     eax, [ebp+var_4]
.text:0000959D                 mov     ecx, [ebp+arg_0]
.text:000095A0                 mov     [eax], ecx
.text:000095A2                 mov     edx, [ebp+var_4]
.text:000095A5                 mov     ecx, [edx]      ; this
.text:000095A7                 call    ?Enter@CCriticalSection@NSynchronization@NWindows@@QAEXXZ ; NWindows::NSynchronization::CCriticalSection::Enter(void)
.text:000095AC                 mov     eax, [ebp+var_4]
.text:000095AF                 add     esp, 4
.text:000095B2                 cmp     ebp, esp
.text:000095B4                 call    __RTC_CheckEsp
.text:000095B9                 mov     esp, ebp
.text:000095BB                 pop     ebp
.text:000095BC                 retn    4
.text:000095BC ??0CCriticalSectionLock@NSynchronization@NWindows@@QAE@AAVCCriticalSection@12@@Z endp
.text:000095BC
.text:000095BC ; ---------------------------------------------------------------------------
.text:000095BF                 align 10h
.text:000095BF _text           ends
.text:000095BF
.text:000095C0 ; ===========================================================================
.text:000095C0
.text:000095C0 ; Segment type: Pure code
.text:000095C0 ; Segment permissions: Read/Execute
.text:000095C0 _text           segment para public 'CODE' use32
.text:000095C0                 assume cs:_text
.text:000095C0                 ;org 95C0h
.text:000095C0 ; COMDAT (pick any)
.text:000095C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000095C0
.text:000095C0 ; =============== S U B R O U T I N E =======================================
.text:000095C0
.text:000095C0 ; Attributes: bp-based frame
.text:000095C0
.text:000095C0 ; void __thiscall NWindows::NSynchronization::CCriticalSection::Enter(NWindows::NSynchronization::CCriticalSection *__hidden this)
.text:000095C0                 public ?Enter@CCriticalSection@NSynchronization@NWindows@@QAEXXZ
.text:000095C0 ?Enter@CCriticalSection@NSynchronization@NWindows@@QAEXXZ proc near
.text:000095C0                                         ; CODE XREF: NWindows::NSynchronization::CCriticalSectionLock::CCriticalSectionLock(NWindows::NSynchronization::CCriticalSection &)+1Bp
.text:000095C0
.text:000095C0 lpCriticalSection= dword ptr -4
.text:000095C0
.text:000095C0                 push    ebp
.text:000095C1                 mov     ebp, esp
.text:000095C3                 push    ecx
.text:000095C4                 push    esi
.text:000095C5                 mov     [ebp+lpCriticalSection], 0CCCCCCCCh
.text:000095CC                 mov     [ebp+lpCriticalSection], ecx
.text:000095CF                 mov     esi, esp
.text:000095D1                 mov     eax, [ebp+lpCriticalSection]
.text:000095D4                 push    eax             ; lpCriticalSection
.text:000095D5                 call    dword ptr ds:__imp__EnterCriticalSection@4 ; EnterCriticalSection(x)
.text:000095DB                 cmp     esi, esp
.text:000095DD                 call    __RTC_CheckEsp
.text:000095E2                 pop     esi
.text:000095E3                 add     esp, 4
.text:000095E6                 cmp     ebp, esp
.text:000095E8                 call    __RTC_CheckEsp
.text:000095ED                 mov     esp, ebp
.text:000095EF                 pop     ebp
.text:000095F0                 retn
.text:000095F0 ?Enter@CCriticalSection@NSynchronization@NWindows@@QAEXXZ endp
.text:000095F0
.text:000095F0 ; ---------------------------------------------------------------------------
.text:000095F1                 align 4
.text:000095F1 _text           ends
.text:000095F1
.text:000095F4 ; ===========================================================================
.text:000095F4
.text:000095F4 ; Segment type: Pure code
.text:000095F4 ; Segment permissions: Read/Execute
.text:000095F4 _text           segment para public 'CODE' use32
.text:000095F4                 assume cs:_text
.text:000095F4                 ;org 95F4h
.text:000095F4 ; COMDAT (pick any)
.text:000095F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000095F4
.text:000095F4 ; =============== S U B R O U T I N E =======================================
.text:000095F4
.text:000095F4 ; Attributes: bp-based frame
.text:000095F4
.text:000095F4 ; _DWORD __thiscall NWindows::NSynchronization::CCriticalSectionLock::~CCriticalSectionLock(NWindows::NSynchronization::CCriticalSectionLock *__hidden this)
.text:000095F4                 public ??1CCriticalSectionLock@NSynchronization@NWindows@@QAE@XZ
.text:000095F4 ??1CCriticalSectionLock@NSynchronization@NWindows@@QAE@XZ proc near
.text:000095F4                                         ; CODE XREF: CBenchProgressStatus::SetResult(long)+32p
.text:000095F4                                         ; CBenchProgressStatus::GetResult(void)+35p
.text:000095F4
.text:000095F4 var_4           = dword ptr -4
.text:000095F4
.text:000095F4                 push    ebp
.text:000095F5                 mov     ebp, esp
.text:000095F7                 push    ecx
.text:000095F8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000095FF                 mov     [ebp+var_4], ecx
.text:00009602                 mov     ecx, [ebp+var_4] ; this
.text:00009605                 call    ?Unlock@CCriticalSectionLock@NSynchronization@NWindows@@AAEXXZ ; NWindows::NSynchronization::CCriticalSectionLock::Unlock(void)
.text:0000960A                 add     esp, 4
.text:0000960D                 cmp     ebp, esp
.text:0000960F                 call    __RTC_CheckEsp
.text:00009614                 mov     esp, ebp
.text:00009616                 pop     ebp
.text:00009617                 retn
.text:00009617 ??1CCriticalSectionLock@NSynchronization@NWindows@@QAE@XZ endp
.text:00009617
.text:00009617 _text           ends
.text:00009617
.text:00009618 ; ===========================================================================
.text:00009618
.text:00009618 ; Segment type: Pure code
.text:00009618 ; Segment permissions: Read/Execute
.text:00009618 _text           segment para public 'CODE' use32
.text:00009618                 assume cs:_text
.text:00009618                 ;org 9618h
.text:00009618 ; COMDAT (pick any)
.text:00009618                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009618
.text:00009618 ; =============== S U B R O U T I N E =======================================
.text:00009618
.text:00009618 ; Attributes: bp-based frame
.text:00009618
.text:00009618 ; void __thiscall NWindows::NSynchronization::CCriticalSectionLock::Unlock(NWindows::NSynchronization::CCriticalSectionLock *__hidden this)
.text:00009618                 public ?Unlock@CCriticalSectionLock@NSynchronization@NWindows@@AAEXXZ
.text:00009618 ?Unlock@CCriticalSectionLock@NSynchronization@NWindows@@AAEXXZ proc near
.text:00009618                                         ; CODE XREF: NWindows::NSynchronization::CCriticalSectionLock::~CCriticalSectionLock(void)+11p
.text:00009618
.text:00009618 var_4           = dword ptr -4
.text:00009618
.text:00009618                 push    ebp
.text:00009619                 mov     ebp, esp
.text:0000961B                 push    ecx
.text:0000961C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00009623                 mov     [ebp+var_4], ecx
.text:00009626                 mov     eax, [ebp+var_4]
.text:00009629                 mov     ecx, [eax]      ; this
.text:0000962B                 call    ?Leave@CCriticalSection@NSynchronization@NWindows@@QAEXXZ ; NWindows::NSynchronization::CCriticalSection::Leave(void)
.text:00009630                 add     esp, 4
.text:00009633                 cmp     ebp, esp
.text:00009635                 call    __RTC_CheckEsp
.text:0000963A                 mov     esp, ebp
.text:0000963C                 pop     ebp
.text:0000963D                 retn
.text:0000963D ?Unlock@CCriticalSectionLock@NSynchronization@NWindows@@AAEXXZ endp
.text:0000963D
.text:0000963D ; ---------------------------------------------------------------------------
.text:0000963E                 align 10h
.text:0000963E _text           ends
.text:0000963E
.text:00009640 ; ===========================================================================
.text:00009640
.text:00009640 ; Segment type: Pure code
.text:00009640 ; Segment permissions: Read/Execute
.text:00009640 _text           segment para public 'CODE' use32
.text:00009640                 assume cs:_text
.text:00009640                 ;org 9640h
.text:00009640 ; COMDAT (pick any)
.text:00009640                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009640
.text:00009640 ; =============== S U B R O U T I N E =======================================
.text:00009640
.text:00009640 ; Attributes: bp-based frame
.text:00009640
.text:00009640 ; void __thiscall NWindows::NSynchronization::CCriticalSection::Leave(NWindows::NSynchronization::CCriticalSection *__hidden this)
.text:00009640                 public ?Leave@CCriticalSection@NSynchronization@NWindows@@QAEXXZ
.text:00009640 ?Leave@CCriticalSection@NSynchronization@NWindows@@QAEXXZ proc near
.text:00009640                                         ; CODE XREF: NWindows::NSynchronization::CCriticalSectionLock::Unlock(void)+13p
.text:00009640
.text:00009640 lpCriticalSection= dword ptr -4
.text:00009640
.text:00009640                 push    ebp
.text:00009641                 mov     ebp, esp
.text:00009643                 push    ecx
.text:00009644                 push    esi
.text:00009645                 mov     [ebp+lpCriticalSection], 0CCCCCCCCh
.text:0000964C                 mov     [ebp+lpCriticalSection], ecx
.text:0000964F                 mov     esi, esp
.text:00009651                 mov     eax, [ebp+lpCriticalSection]
.text:00009654                 push    eax             ; lpCriticalSection
.text:00009655                 call    dword ptr ds:__imp__LeaveCriticalSection@4 ; LeaveCriticalSection(x)
.text:0000965B                 cmp     esi, esp
.text:0000965D                 call    __RTC_CheckEsp
.text:00009662                 pop     esi
.text:00009663                 add     esp, 4
.text:00009666                 cmp     ebp, esp
.text:00009668                 call    __RTC_CheckEsp
.text:0000966D                 mov     esp, ebp
.text:0000966F                 pop     ebp
.text:00009670                 retn
.text:00009670 ?Leave@CCriticalSection@NSynchronization@NWindows@@QAEXXZ endp
.text:00009670
.text:00009670 ; ---------------------------------------------------------------------------
.text:00009671                 align 4
.text:00009671 _text           ends
.text:00009671
.text:00009674 ; ===========================================================================
.text:00009674
.text:00009674 ; Segment type: Pure code
.text:00009674 ; Segment permissions: Read/Execute
.text:00009674 _text           segment para public 'CODE' use32
.text:00009674                 assume cs:_text
.text:00009674                 ;org 9674h
.text:00009674 ; COMDAT (pick any)
.text:00009674                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009674
.text:00009674 ; =============== S U B R O U T I N E =======================================
.text:00009674
.text:00009674 ; Attributes: bp-based frame
.text:00009674
.text:00009674 ; __int32 __thiscall CBenchProgressStatus::GetResult(CBenchProgressStatus *__hidden this)
.text:00009674                 public ?GetResult@CBenchProgressStatus@@QAEJXZ
.text:00009674 ?GetResult@CBenchProgressStatus@@QAEJXZ proc near
.text:00009674                                         ; CODE XREF: CBenchProgressInfo::SetRatioInfo(unsigned __int64 const *,unsigned __int64 const *)+1Dp
.text:00009674
.text:00009674 var_14          = dword ptr -14h
.text:00009674 var_10          = dword ptr -10h
.text:00009674 var_C           = dword ptr -0Ch
.text:00009674 var_8           = dword ptr -8
.text:00009674 var_4           = dword ptr -4
.text:00009674
.text:00009674                 push    ebp
.text:00009675                 mov     ebp, esp
.text:00009677                 sub     esp, 14h
.text:0000967A                 mov     eax, 0CCCCCCCCh
.text:0000967F                 mov     [ebp+var_14], eax
.text:00009682                 mov     [ebp+var_10], eax
.text:00009685                 mov     [ebp+var_C], eax
.text:00009688                 mov     [ebp+var_8], eax
.text:0000968B                 mov     [ebp+var_4], eax
.text:0000968E                 mov     [ebp+var_4], ecx
.text:00009691                 mov     eax, [ebp+var_4]
.text:00009694                 push    eax             ; struct NWindows::NSynchronization::CCriticalSection *
.text:00009695                 lea     ecx, [ebp+var_C] ; this
.text:00009698                 call    ??0CCriticalSectionLock@NSynchronization@NWindows@@QAE@AAVCCriticalSection@12@@Z ; NWindows::NSynchronization::CCriticalSectionLock::CCriticalSectionLock(NWindows::NSynchronization::CCriticalSection &)
.text:0000969D                 mov     ecx, [ebp+var_4]
.text:000096A0                 mov     edx, [ecx+18h]
.text:000096A3                 mov     [ebp+var_14], edx
.text:000096A6                 lea     ecx, [ebp+var_C] ; this
.text:000096A9                 call    ??1CCriticalSectionLock@NSynchronization@NWindows@@QAE@XZ ; NWindows::NSynchronization::CCriticalSectionLock::~CCriticalSectionLock(void)
.text:000096AE                 mov     eax, [ebp+var_14]
.text:000096B1                 push    edx
.text:000096B2                 mov     ecx, ebp
.text:000096B4                 push    eax
.text:000096B5                 lea     edx, $LN6_1
.text:000096BB                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:000096C0                 pop     eax
.text:000096C1                 pop     edx
.text:000096C2                 add     esp, 14h
.text:000096C5                 cmp     ebp, esp
.text:000096C7                 call    __RTC_CheckEsp
.text:000096CC                 mov     esp, ebp
.text:000096CE                 pop     ebp
.text:000096CF                 retn
.text:000096CF ?GetResult@CBenchProgressStatus@@QAEJXZ endp
.text:000096CF
.text:000096CF ; ---------------------------------------------------------------------------
.text:000096D0 $LN6_1          dd 1                    ; DATA XREF: CBenchProgressStatus::GetResult(void)+41o
.text:000096D4                 dd offset $LN5_1
.text:000096D8 $LN5_1          dd 0FFFFFFF4h, 4        ; DATA XREF: .text:000096D4o
.text:000096E0                 dd offset $LN4_1        ; "lock"
.text:000096E4 $LN4_1          db 'lock',0             ; DATA XREF: .text:000096E0o
.text:000096E9                 align 4
.text:000096E9 _text           ends
.text:000096E9
.text:000096EC ; ===========================================================================
.text:000096EC
.text:000096EC ; Segment type: Pure code
.text:000096EC ; Segment permissions: Read/Execute
.text:000096EC _text           segment para public 'CODE' use32
.text:000096EC                 assume cs:_text
.text:000096EC                 ;org 96ECh
.text:000096EC ; COMDAT (pick any)
.text:000096EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000096EC
.text:000096EC ; =============== S U B R O U T I N E =======================================
.text:000096EC
.text:000096EC ; Attributes: bp-based frame
.text:000096EC
.text:000096EC ; public: __thiscall CBenchProps::CBenchProps(void)
.text:000096EC                 public ??0CBenchProps@@QAE@XZ
.text:000096EC ??0CBenchProps@@QAE@XZ proc near        ; CODE XREF: GetCompressRating(uint,unsigned __int64,unsigned __int64,unsigned __int64)+20p
.text:000096EC                                         ; GetDecompressRating(unsigned __int64,unsigned __int64,unsigned __int64,unsigned __int64,unsigned __int64)+20p ...
.text:000096EC
.text:000096EC var_4           = dword ptr -4
.text:000096EC
.text:000096EC                 push    ebp
.text:000096ED                 mov     ebp, esp
.text:000096EF                 push    ecx
.text:000096F0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000096F7                 mov     [ebp+var_4], ecx
.text:000096FA                 mov     eax, [ebp+var_4]
.text:000096FD                 mov     byte ptr [eax], 0
.text:00009700                 mov     eax, [ebp+var_4]
.text:00009703                 mov     esp, ebp
.text:00009705                 pop     ebp
.text:00009706                 retn
.text:00009706 ??0CBenchProps@@QAE@XZ endp
.text:00009706
.text:00009706 ; ---------------------------------------------------------------------------
.text:00009707                 align 4
.text:00009707 _text           ends
.text:00009707
.text$x:00009708 ; ===========================================================================
.text$x:00009708
.text$x:00009708 ; Segment type: Pure code
.text$x:00009708 ; Segment permissions: Read/Execute
.text$x:00009708 _text$x         segment para public 'CODE' use32
.text$x:00009708                 assume cs:_text$x
.text$x:00009708                 ;org 9708h
.text$x:00009708                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00009708
.text$x:00009708 ; =============== S U B R O U T I N E =======================================
.text$x:00009708
.text$x:00009708
.text$x:00009708 __unwindfunclet$?Init@CEncoderInfo@@QAEJABVCOneMethodInfo@@IIPAVCBaseRandomGenerator@@@Z$0 proc near
.text$x:00009708                                         ; DATA XREF: .xdata$x:00009ADCo
.text$x:00009708                 mov     eax, [ebp-0A8h]
.text$x:0000970E                 push    eax             ; void *
.text$x:0000970F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00009714                 pop     ecx
.text$x:00009715                 retn
.text$x:00009715 __unwindfunclet$?Init@CEncoderInfo@@QAEJABVCOneMethodInfo@@IIPAVCBaseRandomGenerator@@@Z$0 endp
.text$x:00009715
.text$x:00009716
.text$x:00009716 ; =============== S U B R O U T I N E =======================================
.text$x:00009716
.text$x:00009716
.text$x:00009716 __unwindfunclet$?Init@CEncoderInfo@@QAEJABVCOneMethodInfo@@IIPAVCBaseRandomGenerator@@@Z$1 proc near
.text$x:00009716                                         ; DATA XREF: .xdata$x:00009AE4o
.text$x:00009716                 mov     eax, [ebp-0B0h]
.text$x:0000971C                 push    eax             ; void *
.text$x:0000971D                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00009722                 pop     ecx
.text$x:00009723                 retn
.text$x:00009723 __unwindfunclet$?Init@CEncoderInfo@@QAEJABVCOneMethodInfo@@IIPAVCBaseRandomGenerator@@@Z$1 endp
.text$x:00009723
.text$x:00009724
.text$x:00009724 ; =============== S U B R O U T I N E =======================================
.text$x:00009724
.text$x:00009724
.text$x:00009724 __unwindfunclet$?Init@CEncoderInfo@@QAEJABVCOneMethodInfo@@IIPAVCBaseRandomGenerator@@@Z$2 proc near
.text$x:00009724                                         ; DATA XREF: .xdata$x:00009AECo
.text$x:00009724                 lea     ecx, [ebp-20h]
.text$x:00009727                 jmp     ??1?$CMyComPtr@UIUnknown@@@@QAE@XZ ; CMyComPtr<IUnknown>::~CMyComPtr<IUnknown>(void)
.text$x:00009727 __unwindfunclet$?Init@CEncoderInfo@@QAEJABVCOneMethodInfo@@IIPAVCBaseRandomGenerator@@@Z$2 endp
.text$x:00009727
.text$x:0000972C
.text$x:0000972C ; =============== S U B R O U T I N E =======================================
.text$x:0000972C
.text$x:0000972C
.text$x:0000972C __unwindfunclet$?Init@CEncoderInfo@@QAEJABVCOneMethodInfo@@IIPAVCBaseRandomGenerator@@@Z$3 proc near
.text$x:0000972C                                         ; DATA XREF: .xdata$x:00009AF4o
.text$x:0000972C                 lea     ecx, [ebp-2Ch]
.text$x:0000972F                 jmp     ??1?$CMyComPtr@UICompressSetCoderProperties@@@@QAE@XZ ; CMyComPtr<ICompressSetCoderProperties>::~CMyComPtr<ICompressSetCoderProperties>(void)
.text$x:0000972F __unwindfunclet$?Init@CEncoderInfo@@QAEJABVCOneMethodInfo@@IIPAVCBaseRandomGenerator@@@Z$3 endp
.text$x:0000972F
.text$x:00009734
.text$x:00009734 ; =============== S U B R O U T I N E =======================================
.text$x:00009734
.text$x:00009734
.text$x:00009734 __unwindfunclet$?Init@CEncoderInfo@@QAEJABVCOneMethodInfo@@IIPAVCBaseRandomGenerator@@@Z$4 proc near
.text$x:00009734                                         ; DATA XREF: .xdata$x:00009AFCo
.text$x:00009734                 lea     ecx, [ebp-4Ch]
.text$x:00009737                 jmp     ??1?$CMyComPtr@UICompressWriteCoderProperties@@@@QAE@XZ ; CMyComPtr<ICompressWriteCoderProperties>::~CMyComPtr<ICompressWriteCoderProperties>(void)
.text$x:00009737 __unwindfunclet$?Init@CEncoderInfo@@QAEJABVCOneMethodInfo@@IIPAVCBaseRandomGenerator@@@Z$4 endp
.text$x:00009737
.text$x:0000973C
.text$x:0000973C ; =============== S U B R O U T I N E =======================================
.text$x:0000973C
.text$x:0000973C
.text$x:0000973C __unwindfunclet$?Init@CEncoderInfo@@QAEJABVCOneMethodInfo@@IIPAVCBaseRandomGenerator@@@Z$5 proc near
.text$x:0000973C                                         ; DATA XREF: .xdata$x:00009B04o
.text$x:0000973C                 lea     ecx, [ebp-5Ch]
.text$x:0000973F                 jmp     ??1?$CMyComPtr@UICryptoSetPassword@@@@QAE@XZ ; CMyComPtr<ICryptoSetPassword>::~CMyComPtr<ICryptoSetPassword>(void)
.text$x:0000973F __unwindfunclet$?Init@CEncoderInfo@@QAEJABVCOneMethodInfo@@IIPAVCBaseRandomGenerator@@@Z$5 endp
.text$x:0000973F
.text$x:00009744
.text$x:00009744 ; =============== S U B R O U T I N E =======================================
.text$x:00009744
.text$x:00009744
.text$x:00009744 __unwindfunclet$?Init@CEncoderInfo@@QAEJABVCOneMethodInfo@@IIPAVCBaseRandomGenerator@@@Z$6 proc near
.text$x:00009744                                         ; DATA XREF: .xdata$x:00009B0Co
.text$x:00009744                 mov     eax, [ebp-0C8h]
.text$x:0000974A                 push    eax             ; void *
.text$x:0000974B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00009750                 pop     ecx
.text$x:00009751                 retn
.text$x:00009751 __unwindfunclet$?Init@CEncoderInfo@@QAEJABVCOneMethodInfo@@IIPAVCBaseRandomGenerator@@@Z$6 endp
.text$x:00009751
.text$x:00009752
.text$x:00009752 ; =============== S U B R O U T I N E =======================================
.text$x:00009752
.text$x:00009752
.text$x:00009752 __unwindfunclet$?Init@CEncoderInfo@@QAEJABVCOneMethodInfo@@IIPAVCBaseRandomGenerator@@@Z$7 proc near
.text$x:00009752                                         ; DATA XREF: .xdata$x:00009B14o
.text$x:00009752                 lea     ecx, [ebp-70h]
.text$x:00009755                 jmp     ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text$x:00009755 __unwindfunclet$?Init@CEncoderInfo@@QAEJABVCOneMethodInfo@@IIPAVCBaseRandomGenerator@@@Z$7 endp
.text$x:00009755
.text$x:0000975A
.text$x:0000975A ; =============== S U B R O U T I N E =======================================
.text$x:0000975A
.text$x:0000975A
.text$x:0000975A __unwindfunclet$?Init@CEncoderInfo@@QAEJABVCOneMethodInfo@@IIPAVCBaseRandomGenerator@@@Z$8 proc near
.text$x:0000975A                                         ; DATA XREF: .xdata$x:00009B1Co
.text$x:0000975A                 mov     eax, [ebp-0D0h]
.text$x:00009760                 push    eax             ; void *
.text$x:00009761                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00009766                 pop     ecx
.text$x:00009767                 retn
.text$x:00009767 __unwindfunclet$?Init@CEncoderInfo@@QAEJABVCOneMethodInfo@@IIPAVCBaseRandomGenerator@@@Z$8 endp
.text$x:00009767
.text$x:00009768
.text$x:00009768 ; =============== S U B R O U T I N E =======================================
.text$x:00009768
.text$x:00009768
.text$x:00009768 __unwindfunclet$?Init@CEncoderInfo@@QAEJABVCOneMethodInfo@@IIPAVCBaseRandomGenerator@@@Z$9 proc near
.text$x:00009768                                         ; DATA XREF: .xdata$x:00009B24o
.text$x:00009768                 lea     ecx, [ebp-98h]
.text$x:0000976E                 jmp     ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text$x:0000976E __unwindfunclet$?Init@CEncoderInfo@@QAEJABVCOneMethodInfo@@IIPAVCBaseRandomGenerator@@@Z$9 endp
.text$x:0000976E
.text$x:00009773
.text$x:00009773 ; =============== S U B R O U T I N E =======================================
.text$x:00009773
.text$x:00009773
.text$x:00009773 __ehhandler$?Init@CEncoderInfo@@QAEJABVCOneMethodInfo@@IIPAVCBaseRandomGenerator@@@Z proc near
.text$x:00009773                                         ; DATA XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+5o
.text$x:00009773
.text$x:00009773 arg_4           = dword ptr  8
.text$x:00009773
.text$x:00009773                 mov     edx, [esp+arg_4]
.text$x:00009777                 lea     eax, [edx+0Ch]
.text$x:0000977A                 mov     ecx, [edx-0FCh]
.text$x:00009780                 xor     ecx, eax
.text$x:00009782                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009787                 mov     ecx, [edx-4]
.text$x:0000978A                 xor     ecx, eax
.text$x:0000978C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009791                 mov     eax, offset __ehfuncinfo$?Init@CEncoderInfo@@QAEJABVCOneMethodInfo@@IIPAVCBaseRandomGenerator@@@Z
.text$x:00009796                 jmp     ___CxxFrameHandler3
.text$x:00009796 __ehhandler$?Init@CEncoderInfo@@QAEJABVCOneMethodInfo@@IIPAVCBaseRandomGenerator@@@Z endp
.text$x:00009796
.text$x:0000979B
.text$x:0000979B ; =============== S U B R O U T I N E =======================================
.text$x:0000979B
.text$x:0000979B
.text$x:0000979B __unwindfunclet$?Encode@CEncoderInfo@@QAEJXZ$0 proc near
.text$x:0000979B                                         ; DATA XREF: .xdata$x:00009B2Co
.text$x:0000979B                 lea     ecx, [ebp-1Ch]
.text$x:0000979E                 jmp     ??1?$CMyComPtr@UICryptoProperties@@@@QAE@XZ ; CMyComPtr<ICryptoProperties>::~CMyComPtr<ICryptoProperties>(void)
.text$x:0000979E __unwindfunclet$?Encode@CEncoderInfo@@QAEJXZ$0 endp
.text$x:0000979E
.text$x:000097A3
.text$x:000097A3 ; =============== S U B R O U T I N E =======================================
.text$x:000097A3
.text$x:000097A3
.text$x:000097A3 __unwindfunclet$?Encode@CEncoderInfo@@QAEJXZ$1 proc near
.text$x:000097A3                                         ; DATA XREF: .xdata$x:00009B34o
.text$x:000097A3                 lea     ecx, [ebp-28h]
.text$x:000097A6                 jmp     ??1?$CMyComPtr@UIUnknown@@@@QAE@XZ ; CMyComPtr<IUnknown>::~CMyComPtr<IUnknown>(void)
.text$x:000097A6 __unwindfunclet$?Encode@CEncoderInfo@@QAEJXZ$1 endp
.text$x:000097A6
.text$x:000097AB
.text$x:000097AB ; =============== S U B R O U T I N E =======================================
.text$x:000097AB
.text$x:000097AB
.text$x:000097AB __unwindfunclet$?Encode@CEncoderInfo@@QAEJXZ$2 proc near
.text$x:000097AB                                         ; DATA XREF: .xdata$x:00009B3Co
.text$x:000097AB                 mov     eax, [ebp-74h]
.text$x:000097AE                 push    eax             ; void *
.text$x:000097AF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:000097B4                 pop     ecx
.text$x:000097B5                 retn
.text$x:000097B5 __unwindfunclet$?Encode@CEncoderInfo@@QAEJXZ$2 endp
.text$x:000097B5
.text$x:000097B6
.text$x:000097B6 ; =============== S U B R O U T I N E =======================================
.text$x:000097B6
.text$x:000097B6
.text$x:000097B6 __unwindfunclet$?Encode@CEncoderInfo@@QAEJXZ$3 proc near
.text$x:000097B6                                         ; DATA XREF: .xdata$x:00009B44o
.text$x:000097B6                 lea     ecx, [ebp-38h]
.text$x:000097B9                 jmp     ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text$x:000097B9 __unwindfunclet$?Encode@CEncoderInfo@@QAEJXZ$3 endp
.text$x:000097B9
.text$x:000097BE
.text$x:000097BE ; =============== S U B R O U T I N E =======================================
.text$x:000097BE
.text$x:000097BE
.text$x:000097BE __ehhandler$?Encode@CEncoderInfo@@QAEJXZ proc near
.text$x:000097BE                                         ; DATA XREF: CEncoderInfo::Encode(void)+5o
.text$x:000097BE
.text$x:000097BE arg_4           = dword ptr  8
.text$x:000097BE
.text$x:000097BE                 mov     edx, [esp+arg_4]
.text$x:000097C2                 lea     eax, [edx+0Ch]
.text$x:000097C5                 mov     ecx, [edx-0D0h]
.text$x:000097CB                 xor     ecx, eax
.text$x:000097CD                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000097D2                 mov     eax, offset __ehfuncinfo$?Encode@CEncoderInfo@@QAEJXZ
.text$x:000097D7                 jmp     ___CxxFrameHandler3
.text$x:000097D7 __ehhandler$?Encode@CEncoderInfo@@QAEJXZ endp
.text$x:000097D7
.text$x:000097DC
.text$x:000097DC ; =============== S U B R O U T I N E =======================================
.text$x:000097DC
.text$x:000097DC
.text$x:000097DC __unwindfunclet$?Decode@CEncoderInfo@@QAEJI@Z$0 proc near
.text$x:000097DC                                         ; DATA XREF: .xdata$x:00009B94o
.text$x:000097DC                 mov     eax, [ebp-0DCh]
.text$x:000097E2                 push    eax             ; void *
.text$x:000097E3                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:000097E8                 pop     ecx
.text$x:000097E9                 retn
.text$x:000097E9 __unwindfunclet$?Decode@CEncoderInfo@@QAEJI@Z$0 endp
.text$x:000097E9
.text$x:000097EA
.text$x:000097EA ; =============== S U B R O U T I N E =======================================
.text$x:000097EA
.text$x:000097EA
.text$x:000097EA __unwindfunclet$?Decode@CEncoderInfo@@QAEJI@Z$1 proc near
.text$x:000097EA                                         ; DATA XREF: .xdata$x:00009B9Co
.text$x:000097EA                 lea     ecx, [ebp-1Ch]
.text$x:000097ED                 jmp     ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text$x:000097ED __unwindfunclet$?Decode@CEncoderInfo@@QAEJI@Z$1 endp
.text$x:000097ED
.text$x:000097F2
.text$x:000097F2 ; =============== S U B R O U T I N E =======================================
.text$x:000097F2
.text$x:000097F2
.text$x:000097F2 __unwindfunclet$?Decode@CEncoderInfo@@QAEJI@Z$2 proc near
.text$x:000097F2                                         ; DATA XREF: .xdata$x:00009BA4o
.text$x:000097F2                 lea     ecx, [ebp-2Ch]
.text$x:000097F5                 jmp     ??1?$CMyComPtr@UIUnknown@@@@QAE@XZ ; CMyComPtr<IUnknown>::~CMyComPtr<IUnknown>(void)
.text$x:000097F5 __unwindfunclet$?Decode@CEncoderInfo@@QAEJI@Z$2 endp
.text$x:000097F5
.text$x:000097FA
.text$x:000097FA ; =============== S U B R O U T I N E =======================================
.text$x:000097FA
.text$x:000097FA
.text$x:000097FA __unwindfunclet$?Decode@CEncoderInfo@@QAEJI@Z$3 proc near
.text$x:000097FA                                         ; DATA XREF: .xdata$x:00009BACo
.text$x:000097FA                 lea     ecx, [ebp-38h]
.text$x:000097FD                 jmp     ??1?$CMyComPtr@UICompressSetDecoderProperties2@@@@QAE@XZ ; CMyComPtr<ICompressSetDecoderProperties2>::~CMyComPtr<ICompressSetDecoderProperties2>(void)
.text$x:000097FD __unwindfunclet$?Decode@CEncoderInfo@@QAEJI@Z$3 endp
.text$x:000097FD
.text$x:00009802
.text$x:00009802 ; =============== S U B R O U T I N E =======================================
.text$x:00009802
.text$x:00009802
.text$x:00009802 __unwindfunclet$?Decode@CEncoderInfo@@QAEJI@Z$4 proc near
.text$x:00009802                                         ; DATA XREF: .xdata$x:00009BB4o
.text$x:00009802                 mov     eax, [ebp-0ECh]
.text$x:00009808                 push    eax             ; void *
.text$x:00009809                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:0000980E                 pop     ecx
.text$x:0000980F                 retn
.text$x:0000980F __unwindfunclet$?Decode@CEncoderInfo@@QAEJI@Z$4 endp
.text$x:0000980F
.text$x:00009810
.text$x:00009810 ; =============== S U B R O U T I N E =======================================
.text$x:00009810
.text$x:00009810
.text$x:00009810 __unwindfunclet$?Decode@CEncoderInfo@@QAEJI@Z$5 proc near
.text$x:00009810                                         ; DATA XREF: .xdata$x:00009BBCo
.text$x:00009810                 lea     ecx, [ebp-48h]
.text$x:00009813                 jmp     ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text$x:00009813 __unwindfunclet$?Decode@CEncoderInfo@@QAEJI@Z$5 endp
.text$x:00009813
.text$x:00009818
.text$x:00009818 ; =============== S U B R O U T I N E =======================================
.text$x:00009818
.text$x:00009818
.text$x:00009818 __unwindfunclet$?Decode@CEncoderInfo@@QAEJI@Z$6 proc near
.text$x:00009818                                         ; DATA XREF: .xdata$x:00009BC4o
.text$x:00009818                 lea     ecx, [ebp-58h]
.text$x:0000981B                 jmp     ??1?$CMyComPtr@UICompressSetCoderMt@@@@QAE@XZ ; CMyComPtr<ICompressSetCoderMt>::~CMyComPtr<ICompressSetCoderMt>(void)
.text$x:0000981B __unwindfunclet$?Decode@CEncoderInfo@@QAEJI@Z$6 endp
.text$x:0000981B
.text$x:00009820
.text$x:00009820 ; =============== S U B R O U T I N E =======================================
.text$x:00009820
.text$x:00009820
.text$x:00009820 __unwindfunclet$?Decode@CEncoderInfo@@QAEJI@Z$7 proc near
.text$x:00009820                                         ; DATA XREF: .xdata$x:00009BCCo
.text$x:00009820                 lea     ecx, [ebp-68h]
.text$x:00009823                 jmp     ??1?$CMyComPtr@UICompressSetCoderProperties@@@@QAE@XZ ; CMyComPtr<ICompressSetCoderProperties>::~CMyComPtr<ICompressSetCoderProperties>(void)
.text$x:00009823 __unwindfunclet$?Decode@CEncoderInfo@@QAEJI@Z$7 endp
.text$x:00009823
.text$x:00009828
.text$x:00009828 ; =============== S U B R O U T I N E =======================================
.text$x:00009828
.text$x:00009828
.text$x:00009828 __unwindfunclet$?Decode@CEncoderInfo@@QAEJI@Z$8 proc near
.text$x:00009828                                         ; DATA XREF: .xdata$x:00009BD4o
.text$x:00009828                 lea     ecx, [ebp-88h]
.text$x:0000982E                 jmp     ??1?$CMyComPtr@UICryptoProperties@@@@QAE@XZ ; CMyComPtr<ICryptoProperties>::~CMyComPtr<ICryptoProperties>(void)
.text$x:0000982E __unwindfunclet$?Decode@CEncoderInfo@@QAEJI@Z$8 endp
.text$x:0000982E
.text$x:00009833
.text$x:00009833 ; =============== S U B R O U T I N E =======================================
.text$x:00009833
.text$x:00009833
.text$x:00009833 __unwindfunclet$?Decode@CEncoderInfo@@QAEJI@Z$9 proc near
.text$x:00009833                                         ; DATA XREF: .xdata$x:00009BDCo
.text$x:00009833                 lea     ecx, [ebp-98h]
.text$x:00009839                 jmp     ??1?$CMyComPtr@UICryptoSetPassword@@@@QAE@XZ ; CMyComPtr<ICryptoSetPassword>::~CMyComPtr<ICryptoSetPassword>(void)
.text$x:00009839 __unwindfunclet$?Decode@CEncoderInfo@@QAEJI@Z$9 endp
.text$x:00009839
.text$x:0000983E
.text$x:0000983E ; =============== S U B R O U T I N E =======================================
.text$x:0000983E
.text$x:0000983E
.text$x:0000983E __ehhandler$?Decode@CEncoderInfo@@QAEJI@Z proc near
.text$x:0000983E                                         ; DATA XREF: CEncoderInfo::Decode(uint)+5o
.text$x:0000983E
.text$x:0000983E arg_4           = dword ptr  8
.text$x:0000983E
.text$x:0000983E                 mov     edx, [esp+arg_4]
.text$x:00009842                 lea     eax, [edx+0Ch]
.text$x:00009845                 mov     ecx, [edx-15Ch]
.text$x:0000984B                 xor     ecx, eax
.text$x:0000984D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009852                 mov     eax, offset __ehfuncinfo$?Decode@CEncoderInfo@@QAEJI@Z
.text$x:00009857                 jmp     ___CxxFrameHandler3
.text$x:00009857 __ehhandler$?Decode@CEncoderInfo@@QAEJI@Z endp
.text$x:00009857
.text$x:0000985C
.text$x:0000985C ; =============== S U B R O U T I N E =======================================
.text$x:0000985C
.text$x:0000985C
.text$x:0000985C __unwindfunclet$?CrcInternalTest@@YG_NXZ$0 proc near
.text$x:0000985C                                         ; DATA XREF: .xdata$x:00009BE4o
.text$x:0000985C                 lea     ecx, [ebp-1Ch]  ; this
.text$x:0000985F                 jmp     ??1CBenchBuffer@@UAE@XZ ; CBenchBuffer::~CBenchBuffer(void)
.text$x:0000985F __unwindfunclet$?CrcInternalTest@@YG_NXZ$0 endp
.text$x:0000985F
.text$x:00009864
.text$x:00009864 ; =============== S U B R O U T I N E =======================================
.text$x:00009864
.text$x:00009864
.text$x:00009864 __ehhandler$?CrcInternalTest@@YG_NXZ proc near
.text$x:00009864                                         ; DATA XREF: CrcInternalTest(void)+5o
.text$x:00009864
.text$x:00009864 arg_4           = dword ptr  8
.text$x:00009864
.text$x:00009864                 mov     edx, [esp+arg_4]
.text$x:00009868                 lea     eax, [edx+0Ch]
.text$x:0000986B                 mov     ecx, [edx-50h]
.text$x:0000986E                 xor     ecx, eax
.text$x:00009870                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009875                 mov     eax, offset __ehfuncinfo$?CrcInternalTest@@YG_NXZ
.text$x:0000987A                 jmp     ___CxxFrameHandler3
.text$x:0000987A __ehhandler$?CrcInternalTest@@YG_NXZ endp
.text$x:0000987A
.text$x:0000987F
.text$x:0000987F ; =============== S U B R O U T I N E =======================================
.text$x:0000987F
.text$x:0000987F
.text$x:0000987F __unwindfunclet$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z$0 proc near
.text$x:0000987F                                         ; DATA XREF: .xdata$x:00009C34o
.text$x:0000987F                 lea     ecx, [ebp-60h]  ; this
.text$x:00009882                 jmp     ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text$x:00009882 __unwindfunclet$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z$0 endp
.text$x:00009882
.text$x:00009887
.text$x:00009887 ; =============== S U B R O U T I N E =======================================
.text$x:00009887
.text$x:00009887
.text$x:00009887 __unwindfunclet$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z$1 proc near
.text$x:00009887                                         ; DATA XREF: .xdata$x:00009C3Co
.text$x:00009887                 lea     ecx, [ebp-80h]  ; this
.text$x:0000988A                 jmp     ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text$x:0000988A __unwindfunclet$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z$1 endp
.text$x:0000988A
.text$x:0000988F
.text$x:0000988F ; =============== S U B R O U T I N E =======================================
.text$x:0000988F
.text$x:0000988F
.text$x:0000988F __unwindfunclet$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z$2 proc near
.text$x:0000988F                                         ; DATA XREF: .xdata$x:00009C44o
.text$x:0000988F                 lea     ecx, [ebp-94h]  ; this
.text$x:00009895                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00009895 __unwindfunclet$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z$2 endp
.text$x:00009895
.text$x:0000989A
.text$x:0000989A ; =============== S U B R O U T I N E =======================================
.text$x:0000989A
.text$x:0000989A
.text$x:0000989A __unwindfunclet$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z$3 proc near
.text$x:0000989A                                         ; DATA XREF: .xdata$x:00009C4Co
.text$x:0000989A                 lea     ecx, [ebp-3D8h] ; this
.text$x:000098A0                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000098A0 __unwindfunclet$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z$3 endp
.text$x:000098A0
.text$x:000098A5
.text$x:000098A5 ; =============== S U B R O U T I N E =======================================
.text$x:000098A5
.text$x:000098A5
.text$x:000098A5 __unwindfunclet$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z$4 proc near
.text$x:000098A5                                         ; DATA XREF: .xdata$x:00009C54o
.text$x:000098A5                 lea     ecx, [ebp-0ACh] ; this
.text$x:000098AB                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000098AB __unwindfunclet$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z$4 endp
.text$x:000098AB
.text$x:000098B0
.text$x:000098B0 ; =============== S U B R O U T I N E =======================================
.text$x:000098B0
.text$x:000098B0
.text$x:000098B0 __unwindfunclet$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z$5 proc near
.text$x:000098B0                                         ; DATA XREF: .xdata$x:00009C5Co
.text$x:000098B0                 lea     ecx, [ebp-0C8h] ; this
.text$x:000098B6                 jmp     ??1AString@@QAE@XZ ; AString::~AString(void)
.text$x:000098B6 __unwindfunclet$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z$5 endp
.text$x:000098B6
.text$x:000098BB
.text$x:000098BB ; =============== S U B R O U T I N E =======================================
.text$x:000098BB
.text$x:000098BB
.text$x:000098BB __unwindfunclet$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z$6 proc near
.text$x:000098BB                                         ; DATA XREF: .xdata$x:00009C64o
.text$x:000098BB                 lea     ecx, [ebp-148h] ; this
.text$x:000098C1                 jmp     ??1AString@@QAE@XZ ; AString::~AString(void)
.text$x:000098C1 __unwindfunclet$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z$6 endp
.text$x:000098C1
.text$x:000098C6
.text$x:000098C6 ; =============== S U B R O U T I N E =======================================
.text$x:000098C6
.text$x:000098C6
.text$x:000098C6 __unwindfunclet$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z$7 proc near
.text$x:000098C6                                         ; DATA XREF: .xdata$x:00009C6Co
.text$x:000098C6                 lea     ecx, [ebp-180h] ; this
.text$x:000098CC                 jmp     ??1AString@@QAE@XZ ; AString::~AString(void)
.text$x:000098CC __unwindfunclet$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z$7 endp
.text$x:000098CC
.text$x:000098D1
.text$x:000098D1 ; =============== S U B R O U T I N E =======================================
.text$x:000098D1
.text$x:000098D1
.text$x:000098D1 __unwindfunclet$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z$8 proc near
.text$x:000098D1                                         ; DATA XREF: .xdata$x:00009C74o
.text$x:000098D1                 lea     ecx, [ebp-194h] ; this
.text$x:000098D7                 jmp     ??1AString@@QAE@XZ ; AString::~AString(void)
.text$x:000098D7 __unwindfunclet$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z$8 endp
.text$x:000098D7
.text$x:000098DC
.text$x:000098DC ; =============== S U B R O U T I N E =======================================
.text$x:000098DC
.text$x:000098DC
.text$x:000098DC __unwindfunclet$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z$9 proc near
.text$x:000098DC                                         ; DATA XREF: .xdata$x:00009C7Co
.text$x:000098DC                 lea     ecx, [ebp-1B0h] ; this
.text$x:000098E2                 jmp     ??1CTempValues@@QAE@XZ ; CTempValues::~CTempValues(void)
.text$x:000098E2 __unwindfunclet$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z$9 endp
.text$x:000098E2
.text$x:000098E7
.text$x:000098E7 ; =============== S U B R O U T I N E =======================================
.text$x:000098E7
.text$x:000098E7
.text$x:000098E7 __unwindfunclet$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z$10 proc near
.text$x:000098E7                                         ; DATA XREF: .xdata$x:00009C84o
.text$x:000098E7                 lea     ecx, [ebp-328h] ; this
.text$x:000098ED                 jmp     ??1AString@@QAE@XZ ; AString::~AString(void)
.text$x:000098ED __unwindfunclet$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z$10 endp
.text$x:000098ED
.text$x:000098F2
.text$x:000098F2 ; =============== S U B R O U T I N E =======================================
.text$x:000098F2
.text$x:000098F2
.text$x:000098F2 __unwindfunclet$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z$11 proc near
.text$x:000098F2                                         ; DATA XREF: .xdata$x:00009C8Co
.text$x:000098F2                 lea     ecx, [ebp-378h] ; this
.text$x:000098F8                 jmp     ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text$x:000098F8 __unwindfunclet$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z$11 endp
.text$x:000098F8
.text$x:000098FD
.text$x:000098FD ; =============== S U B R O U T I N E =======================================
.text$x:000098FD
.text$x:000098FD
.text$x:000098FD __unwindfunclet$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z$12 proc near
.text$x:000098FD                                         ; DATA XREF: .xdata$x:00009C94o
.text$x:000098FD                 lea     ecx, [ebp-390h] ; this
.text$x:00009903                 jmp     ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text$x:00009903 __unwindfunclet$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z$12 endp
.text$x:00009903
.text$x:00009908
.text$x:00009908 ; =============== S U B R O U T I N E =======================================
.text$x:00009908
.text$x:00009908
.text$x:00009908 __unwindfunclet$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z$13 proc near
.text$x:00009908                                         ; DATA XREF: .xdata$x:00009C9Co
.text$x:00009908                 lea     ecx, [ebp-41Ch] ; this
.text$x:0000990E                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:0000990E __unwindfunclet$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z$13 endp
.text$x:0000990E
.text$x:00009913
.text$x:00009913 ; =============== S U B R O U T I N E =======================================
.text$x:00009913
.text$x:00009913
.text$x:00009913 __ehhandler$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z proc near
.text$x:00009913                                         ; DATA XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+5o
.text$x:00009913
.text$x:00009913 arg_4           = dword ptr  8
.text$x:00009913
.text$x:00009913                 mov     edx, [esp+arg_4]
.text$x:00009917                 lea     eax, [edx+0Ch]
.text$x:0000991A                 mov     ecx, [edx-438h]
.text$x:00009920                 xor     ecx, eax
.text$x:00009922                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009927                 mov     ecx, [edx-4]
.text$x:0000992A                 xor     ecx, eax
.text$x:0000992C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009931                 mov     eax, offset __ehfuncinfo$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z
.text$x:00009936                 jmp     ___CxxFrameHandler3
.text$x:00009936 __ehhandler$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z endp
.text$x:00009936
.text$x:0000993B
.text$x:0000993B ; =============== S U B R O U T I N E =======================================
.text$x:0000993B
.text$x:0000993B
.text$x:0000993B __unwindfunclet$?MethodBench@@YGJ_K_NIABVCOneMethodInfo@@IIPAUIBenchPrintCallback@@PAUIBenchCallback@@PAUCBenchProps@@@Z$0 proc near
.text$x:0000993B                                         ; DATA XREF: .xdata$x:00009CC8o
.text$x:0000993B                 lea     ecx, [ebp-34h]  ; this
.text$x:0000993E                 jmp     ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text$x:0000993E __unwindfunclet$?MethodBench@@YGJ_K_NIABVCOneMethodInfo@@IIPAUIBenchPrintCallback@@PAUIBenchCallback@@PAUCBenchProps@@@Z$0 endp
.text$x:0000993E
.text$x:00009943
.text$x:00009943 ; =============== S U B R O U T I N E =======================================
.text$x:00009943
.text$x:00009943
.text$x:00009943 __unwindfunclet$?MethodBench@@YGJ_K_NIABVCOneMethodInfo@@IIPAUIBenchPrintCallback@@PAUIBenchCallback@@PAUCBenchProps@@@Z$1 proc near
.text$x:00009943                                         ; DATA XREF: .xdata$x:00009CD0o
.text$x:00009943                 lea     ecx, [ebp-74h]  ; this
.text$x:00009946                 jmp     ??1CBenchEncoders@@QAE@XZ ; CBenchEncoders::~CBenchEncoders(void)
.text$x:00009946 __unwindfunclet$?MethodBench@@YGJ_K_NIABVCOneMethodInfo@@IIPAUIBenchPrintCallback@@PAUIBenchCallback@@PAUCBenchProps@@@Z$1 endp
.text$x:00009946
.text$x:0000994B
.text$x:0000994B ; =============== S U B R O U T I N E =======================================
.text$x:0000994B
.text$x:0000994B
.text$x:0000994B __unwindfunclet$?MethodBench@@YGJ_K_NIABVCOneMethodInfo@@IIPAUIBenchPrintCallback@@PAUIBenchCallback@@PAUCBenchProps@@@Z$2 proc near
.text$x:0000994B                                         ; DATA XREF: .xdata$x:00009CD8o
.text$x:0000994B                 lea     ecx, [ebp-98h]  ; this
.text$x:00009951                 jmp     ??1CCreatedCoder@@QAE@XZ ; CCreatedCoder::~CCreatedCoder(void)
.text$x:00009951 __unwindfunclet$?MethodBench@@YGJ_K_NIABVCOneMethodInfo@@IIPAUIBenchPrintCallback@@PAUIBenchCallback@@PAUCBenchProps@@@Z$2 endp
.text$x:00009951
.text$x:00009956
.text$x:00009956 ; =============== S U B R O U T I N E =======================================
.text$x:00009956
.text$x:00009956
.text$x:00009956 __unwindfunclet$?MethodBench@@YGJ_K_NIABVCOneMethodInfo@@IIPAUIBenchPrintCallback@@PAUIBenchCallback@@PAUCBenchProps@@@Z$3 proc near
.text$x:00009956                                         ; DATA XREF: .xdata$x:00009CE0o
.text$x:00009956                 lea     ecx, [ebp-0B8h] ; this
.text$x:0000995C                 jmp     ??1CCreatedCoder@@QAE@XZ ; CCreatedCoder::~CCreatedCoder(void)
.text$x:0000995C __unwindfunclet$?MethodBench@@YGJ_K_NIABVCOneMethodInfo@@IIPAUIBenchPrintCallback@@PAUIBenchCallback@@PAUCBenchProps@@@Z$3 endp
.text$x:0000995C
.text$x:00009961
.text$x:00009961 ; =============== S U B R O U T I N E =======================================
.text$x:00009961
.text$x:00009961
.text$x:00009961 __unwindfunclet$?MethodBench@@YGJ_K_NIABVCOneMethodInfo@@IIPAUIBenchPrintCallback@@PAUIBenchCallback@@PAUCBenchProps@@@Z$4 proc near
.text$x:00009961                                         ; DATA XREF: .xdata$x:00009CE8o
.text$x:00009961                 lea     ecx, [ebp-100h] ; this
.text$x:00009967                 jmp     ??1CBenchProgressStatus@@QAE@XZ ; CBenchProgressStatus::~CBenchProgressStatus(void)
.text$x:00009967 __unwindfunclet$?MethodBench@@YGJ_K_NIABVCOneMethodInfo@@IIPAUIBenchPrintCallback@@PAUIBenchCallback@@PAUCBenchProps@@@Z$4 endp
.text$x:00009967
.text$x:0000996C
.text$x:0000996C ; =============== S U B R O U T I N E =======================================
.text$x:0000996C
.text$x:0000996C
.text$x:0000996C __unwindfunclet$?MethodBench@@YGJ_K_NIABVCOneMethodInfo@@IIPAUIBenchPrintCallback@@PAUIBenchCallback@@PAUCBenchProps@@@Z$5 proc near
.text$x:0000996C                                         ; DATA XREF: .xdata$x:00009CF0o
.text$x:0000996C                 mov     eax, [ebp-1CCh]
.text$x:00009972                 push    eax             ; void *
.text$x:00009973                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00009978                 pop     ecx
.text$x:00009979                 retn
.text$x:00009979 __unwindfunclet$?MethodBench@@YGJ_K_NIABVCOneMethodInfo@@IIPAUIBenchPrintCallback@@PAUIBenchCallback@@PAUCBenchProps@@@Z$5 endp
.text$x:00009979
.text$x:0000997A
.text$x:0000997A ; =============== S U B R O U T I N E =======================================
.text$x:0000997A
.text$x:0000997A
.text$x:0000997A __ehhandler$?MethodBench@@YGJ_K_NIABVCOneMethodInfo@@IIPAUIBenchPrintCallback@@PAUIBenchCallback@@PAUCBenchProps@@@Z proc near
.text$x:0000997A                                         ; DATA XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+5o
.text$x:0000997A
.text$x:0000997A arg_4           = dword ptr  8
.text$x:0000997A
.text$x:0000997A                 mov     edx, [esp+arg_4]
.text$x:0000997E                 lea     eax, [edx+0Ch]
.text$x:00009981                 mov     ecx, [edx-204h]
.text$x:00009987                 xor     ecx, eax
.text$x:00009989                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000998E                 mov     eax, offset __ehfuncinfo$?MethodBench@@YGJ_K_NIABVCOneMethodInfo@@IIPAUIBenchPrintCallback@@PAUIBenchCallback@@PAUCBenchProps@@@Z
.text$x:00009993                 jmp     ___CxxFrameHandler3
.text$x:00009993 __ehhandler$?MethodBench@@YGJ_K_NIABVCOneMethodInfo@@IIPAUIBenchPrintCallback@@PAUIBenchCallback@@PAUCBenchProps@@@Z endp
.text$x:00009993
.text$x:00009998
.text$x:00009998 ; =============== S U B R O U T I N E =======================================
.text$x:00009998
.text$x:00009998
.text$x:00009998 __unwindfunclet$?TotalBench@@YGJ_KI_NIPAUIBenchPrintCallback@@PAUCBenchCallbackToPrint@@@Z$0 proc near
.text$x:00009998                                         ; DATA XREF: .xdata$x:00009CF8o
.text$x:00009998                 lea     ecx, [ebp-3Ch]  ; this
.text$x:0000999B                 jmp     ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text$x:0000999B __unwindfunclet$?TotalBench@@YGJ_KI_NIPAUIBenchPrintCallback@@PAUCBenchCallbackToPrint@@@Z$0 endp
.text$x:0000999B
.text$x:000099A0
.text$x:000099A0 ; =============== S U B R O U T I N E =======================================
.text$x:000099A0
.text$x:000099A0
.text$x:000099A0 __unwindfunclet$?TotalBench@@YGJ_KI_NIPAUIBenchPrintCallback@@PAUCBenchCallbackToPrint@@@Z$1 proc near
.text$x:000099A0                                         ; DATA XREF: .xdata$x:00009D00o
.text$x:000099A0                 lea     ecx, [ebp-54h]  ; this
.text$x:000099A3                 jmp     ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text$x:000099A3 __unwindfunclet$?TotalBench@@YGJ_KI_NIPAUIBenchPrintCallback@@PAUCBenchCallbackToPrint@@@Z$1 endp
.text$x:000099A3
.text$x:000099A8
.text$x:000099A8 ; =============== S U B R O U T I N E =======================================
.text$x:000099A8
.text$x:000099A8
.text$x:000099A8 __unwindfunclet$?TotalBench@@YGJ_KI_NIPAUIBenchPrintCallback@@PAUCBenchCallbackToPrint@@@Z$2 proc near
.text$x:000099A8                                         ; DATA XREF: .xdata$x:00009D08o
.text$x:000099A8                 lea     ecx, [ebp-74h]  ; this
.text$x:000099AB                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000099AB __unwindfunclet$?TotalBench@@YGJ_KI_NIPAUIBenchPrintCallback@@PAUCBenchCallbackToPrint@@@Z$2 endp
.text$x:000099AB
.text$x:000099B0
.text$x:000099B0 ; =============== S U B R O U T I N E =======================================
.text$x:000099B0
.text$x:000099B0
.text$x:000099B0 __ehhandler$?TotalBench@@YGJ_KI_NIPAUIBenchPrintCallback@@PAUCBenchCallbackToPrint@@@Z proc near
.text$x:000099B0                                         ; DATA XREF: TotalBench(unsigned __int64,uint,bool,uint,IBenchPrintCallback *,CBenchCallbackToPrint *)+5o
.text$x:000099B0
.text$x:000099B0 arg_4           = dword ptr  8
.text$x:000099B0
.text$x:000099B0                 mov     edx, [esp+arg_4]
.text$x:000099B4                 lea     eax, [edx+0Ch]
.text$x:000099B7                 mov     ecx, [edx-80h]
.text$x:000099BA                 xor     ecx, eax
.text$x:000099BC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000099C1                 mov     eax, offset __ehfuncinfo$?TotalBench@@YGJ_KI_NIPAUIBenchPrintCallback@@PAUCBenchCallbackToPrint@@@Z
.text$x:000099C6                 jmp     ___CxxFrameHandler3
.text$x:000099C6 __ehhandler$?TotalBench@@YGJ_KI_NIPAUIBenchPrintCallback@@PAUCBenchCallbackToPrint@@@Z endp
.text$x:000099C6
.text$x:000099CB
.text$x:000099CB ; =============== S U B R O U T I N E =======================================
.text$x:000099CB
.text$x:000099CB
.text$x:000099CB __unwindfunclet$?FreqBench@@YGJ_KIPAUIBenchPrintCallback@@_NAA_KAAI@Z$0 proc near
.text$x:000099CB                                         ; DATA XREF: .xdata$x:00009D34o
.text$x:000099CB                 lea     ecx, [ebp-74h]  ; this
.text$x:000099CE                 jmp     ??1CFreqThreads@@QAE@XZ ; CFreqThreads::~CFreqThreads(void)
.text$x:000099CE __unwindfunclet$?FreqBench@@YGJ_KIPAUIBenchPrintCallback@@_NAA_KAAI@Z$0 endp
.text$x:000099CE
.text$x:000099D3
.text$x:000099D3 ; =============== S U B R O U T I N E =======================================
.text$x:000099D3
.text$x:000099D3
.text$x:000099D3 __unwindfunclet$?FreqBench@@YGJ_KIPAUIBenchPrintCallback@@_NAA_KAAI@Z$1 proc near
.text$x:000099D3                                         ; DATA XREF: .xdata$x:00009D3Co
.text$x:000099D3                 mov     eax, [ebp-0FCh]
.text$x:000099D9                 push    eax             ; void *
.text$x:000099DA                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:000099DF                 pop     ecx
.text$x:000099E0                 retn
.text$x:000099E0 __unwindfunclet$?FreqBench@@YGJ_KIPAUIBenchPrintCallback@@_NAA_KAAI@Z$1 endp
.text$x:000099E0
.text$x:000099E1
.text$x:000099E1 ; =============== S U B R O U T I N E =======================================
.text$x:000099E1
.text$x:000099E1
.text$x:000099E1 __ehhandler$?FreqBench@@YGJ_KIPAUIBenchPrintCallback@@_NAA_KAAI@Z proc near
.text$x:000099E1                                         ; DATA XREF: FreqBench(unsigned __int64,uint,IBenchPrintCallback *,bool,unsigned __int64 &,uint &)+5o
.text$x:000099E1
.text$x:000099E1 arg_4           = dword ptr  8
.text$x:000099E1
.text$x:000099E1                 mov     edx, [esp+arg_4]
.text$x:000099E5                 lea     eax, [edx+0Ch]
.text$x:000099E8                 mov     ecx, [edx-120h]
.text$x:000099EE                 xor     ecx, eax
.text$x:000099F0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000099F5                 mov     eax, offset __ehfuncinfo$?FreqBench@@YGJ_KIPAUIBenchPrintCallback@@_NAA_KAAI@Z
.text$x:000099FA                 jmp     ___CxxFrameHandler3
.text$x:000099FA __ehhandler$?FreqBench@@YGJ_KIPAUIBenchPrintCallback@@_NAA_KAAI@Z endp
.text$x:000099FA
.text$x:000099FF
.text$x:000099FF ; =============== S U B R O U T I N E =======================================
.text$x:000099FF
.text$x:000099FF
.text$x:000099FF __unwindfunclet$?CrcBench@@YGJ_KIIAA_KIIPBIABVCOneMethodInfo@@PAUIBenchPrintCallback@@PAUCTotalBenchRes@@_N0@Z$0 proc near
.text$x:000099FF                                         ; DATA XREF: .xdata$x:00009D8Co
.text$x:000099FF                 lea     ecx, [ebp-1Ch]  ; this
.text$x:00009A02                 jmp     ??1AString@@QAE@XZ ; AString::~AString(void)
.text$x:00009A02 __unwindfunclet$?CrcBench@@YGJ_KIIAA_KIIPBIABVCOneMethodInfo@@PAUIBenchPrintCallback@@PAUCTotalBenchRes@@_N0@Z$0 endp
.text$x:00009A02
.text$x:00009A07
.text$x:00009A07 ; =============== S U B R O U T I N E =======================================
.text$x:00009A07
.text$x:00009A07
.text$x:00009A07 __unwindfunclet$?CrcBench@@YGJ_KIIAA_KIIPBIABVCOneMethodInfo@@PAUIBenchPrintCallback@@PAUCTotalBenchRes@@_N0@Z$1 proc near
.text$x:00009A07                                         ; DATA XREF: .xdata$x:00009D94o
.text$x:00009A07                 lea     ecx, [ebp-40h]  ; this
.text$x:00009A0A                 jmp     ??1CBenchBuffer@@UAE@XZ ; CBenchBuffer::~CBenchBuffer(void)
.text$x:00009A0A __unwindfunclet$?CrcBench@@YGJ_KIIAA_KIIPBIABVCOneMethodInfo@@PAUIBenchPrintCallback@@PAUCTotalBenchRes@@_N0@Z$1 endp
.text$x:00009A0A
.text$x:00009A0F
.text$x:00009A0F ; =============== S U B R O U T I N E =======================================
.text$x:00009A0F
.text$x:00009A0F
.text$x:00009A0F __unwindfunclet$?CrcBench@@YGJ_KIIAA_KIIPBIABVCOneMethodInfo@@PAUIBenchPrintCallback@@PAUCTotalBenchRes@@_N0@Z$2 proc near
.text$x:00009A0F                                         ; DATA XREF: .xdata$x:00009D9Co
.text$x:00009A0F                 lea     ecx, [ebp-0BCh] ; this
.text$x:00009A15                 jmp     ??1CCrcThreads@@QAE@XZ ; CCrcThreads::~CCrcThreads(void)
.text$x:00009A15 __unwindfunclet$?CrcBench@@YGJ_KIIAA_KIIPBIABVCOneMethodInfo@@PAUIBenchPrintCallback@@PAUCTotalBenchRes@@_N0@Z$2 endp
.text$x:00009A15
.text$x:00009A1A
.text$x:00009A1A ; =============== S U B R O U T I N E =======================================
.text$x:00009A1A
.text$x:00009A1A
.text$x:00009A1A __unwindfunclet$?CrcBench@@YGJ_KIIAA_KIIPBIABVCOneMethodInfo@@PAUIBenchPrintCallback@@PAUCTotalBenchRes@@_N0@Z$3 proc near
.text$x:00009A1A                                         ; DATA XREF: .xdata$x:00009DA4o
.text$x:00009A1A                 mov     eax, [ebp-1D4h]
.text$x:00009A20                 push    eax             ; void *
.text$x:00009A21                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00009A26                 pop     ecx
.text$x:00009A27                 retn
.text$x:00009A27 __unwindfunclet$?CrcBench@@YGJ_KIIAA_KIIPBIABVCOneMethodInfo@@PAUIBenchPrintCallback@@PAUCTotalBenchRes@@_N0@Z$3 endp
.text$x:00009A27
.text$x:00009A28
.text$x:00009A28 ; =============== S U B R O U T I N E =======================================
.text$x:00009A28
.text$x:00009A28
.text$x:00009A28 __unwindfunclet$?CrcBench@@YGJ_KIIAA_KIIPBIABVCOneMethodInfo@@PAUIBenchPrintCallback@@PAUCTotalBenchRes@@_N0@Z$4 proc near
.text$x:00009A28                                         ; DATA XREF: .xdata$x:00009DACo
.text$x:00009A28                 lea     ecx, [ebp-0D8h] ; this
.text$x:00009A2E                 jmp     ??1AString@@QAE@XZ ; AString::~AString(void)
.text$x:00009A2E __unwindfunclet$?CrcBench@@YGJ_KIIAA_KIIPBIABVCOneMethodInfo@@PAUIBenchPrintCallback@@PAUCTotalBenchRes@@_N0@Z$4 endp
.text$x:00009A2E
.text$x:00009A33
.text$x:00009A33 ; =============== S U B R O U T I N E =======================================
.text$x:00009A33
.text$x:00009A33
.text$x:00009A33 __unwindfunclet$?CrcBench@@YGJ_KIIAA_KIIPBIABVCOneMethodInfo@@PAUIBenchPrintCallback@@PAUCTotalBenchRes@@_N0@Z$5 proc near
.text$x:00009A33                                         ; DATA XREF: .xdata$x:00009DB4o
.text$x:00009A33                 lea     ecx, [ebp-0E8h]
.text$x:00009A39                 jmp     ??1?$CMyComPtr@UICompressSetCoderProperties@@@@QAE@XZ ; CMyComPtr<ICompressSetCoderProperties>::~CMyComPtr<ICompressSetCoderProperties>(void)
.text$x:00009A39 __unwindfunclet$?CrcBench@@YGJ_KIIAA_KIIPBIABVCOneMethodInfo@@PAUIBenchPrintCallback@@PAUCTotalBenchRes@@_N0@Z$5 endp
.text$x:00009A39
.text$x:00009A3E
.text$x:00009A3E ; =============== S U B R O U T I N E =======================================
.text$x:00009A3E
.text$x:00009A3E
.text$x:00009A3E __unwindfunclet$?CrcBench@@YGJ_KIIAA_KIIPBIABVCOneMethodInfo@@PAUIBenchPrintCallback@@PAUCTotalBenchRes@@_N0@Z$6 proc near
.text$x:00009A3E                                         ; DATA XREF: .xdata$x:00009DBCo
.text$x:00009A3E                 lea     ecx, [ebp-118h]
.text$x:00009A44                 jmp     ??1?$CMyComPtr@UIHasher@@@@QAE@XZ ; CMyComPtr<IHasher>::~CMyComPtr<IHasher>(void)
.text$x:00009A44 __unwindfunclet$?CrcBench@@YGJ_KIIAA_KIIPBIABVCOneMethodInfo@@PAUIBenchPrintCallback@@PAUCTotalBenchRes@@_N0@Z$6 endp
.text$x:00009A44
.text$x:00009A49
.text$x:00009A49 ; =============== S U B R O U T I N E =======================================
.text$x:00009A49
.text$x:00009A49
.text$x:00009A49 __unwindfunclet$?CrcBench@@YGJ_KIIAA_KIIPBIABVCOneMethodInfo@@PAUIBenchPrintCallback@@PAUCTotalBenchRes@@_N0@Z$7 proc near
.text$x:00009A49                                         ; DATA XREF: .xdata$x:00009DC4o
.text$x:00009A49                 lea     ecx, [ebp-12Ch] ; this
.text$x:00009A4F                 jmp     ??1AString@@QAE@XZ ; AString::~AString(void)
.text$x:00009A4F __unwindfunclet$?CrcBench@@YGJ_KIIAA_KIIPBIABVCOneMethodInfo@@PAUIBenchPrintCallback@@PAUCTotalBenchRes@@_N0@Z$7 endp
.text$x:00009A4F
.text$x:00009A54
.text$x:00009A54 ; =============== S U B R O U T I N E =======================================
.text$x:00009A54
.text$x:00009A54
.text$x:00009A54 __unwindfunclet$?CrcBench@@YGJ_KIIAA_KIIPBIABVCOneMethodInfo@@PAUIBenchPrintCallback@@PAUCTotalBenchRes@@_N0@Z$8 proc near
.text$x:00009A54                                         ; DATA XREF: .xdata$x:00009DCCo
.text$x:00009A54                 lea     ecx, [ebp-13Ch]
.text$x:00009A5A                 jmp     ??1?$CMyComPtr@UICompressSetCoderProperties@@@@QAE@XZ ; CMyComPtr<ICompressSetCoderProperties>::~CMyComPtr<ICompressSetCoderProperties>(void)
.text$x:00009A5A __unwindfunclet$?CrcBench@@YGJ_KIIAA_KIIPBIABVCOneMethodInfo@@PAUIBenchPrintCallback@@PAUCTotalBenchRes@@_N0@Z$8 endp
.text$x:00009A5A
.text$x:00009A5F
.text$x:00009A5F ; =============== S U B R O U T I N E =======================================
.text$x:00009A5F
.text$x:00009A5F
.text$x:00009A5F __ehhandler$?CrcBench@@YGJ_KIIAA_KIIPBIABVCOneMethodInfo@@PAUIBenchPrintCallback@@PAUCTotalBenchRes@@_N0@Z proc near
.text$x:00009A5F                                         ; DATA XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+5o
.text$x:00009A5F
.text$x:00009A5F arg_4           = dword ptr  8
.text$x:00009A5F
.text$x:00009A5F                 mov     edx, [esp+arg_4]
.text$x:00009A63                 lea     eax, [edx+0Ch]
.text$x:00009A66                 mov     ecx, [edx-20Ch]
.text$x:00009A6C                 xor     ecx, eax
.text$x:00009A6E                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009A73                 mov     eax, offset __ehfuncinfo$?CrcBench@@YGJ_KIIAA_KIIPBIABVCOneMethodInfo@@PAUIBenchPrintCallback@@PAUCTotalBenchRes@@_N0@Z
.text$x:00009A78                 jmp     ___CxxFrameHandler3
.text$x:00009A78 __ehhandler$?CrcBench@@YGJ_KIIAA_KIIPBIABVCOneMethodInfo@@PAUIBenchPrintCallback@@PAUCTotalBenchRes@@_N0@Z endp
.text$x:00009A78
.text$x:00009A7D
.text$x:00009A7D ; =============== S U B R O U T I N E =======================================
.text$x:00009A7D
.text$x:00009A7D
.text$x:00009A7D __unwindfunclet$?TotalBench_Hash@@YGJ_KIIPAUIBenchPrintCallback@@PAUCBenchCallbackToPrint@@PAUCTotalBenchRes@@_N0@Z$0 proc near
.text$x:00009A7D                                         ; DATA XREF: .xdata$x:00009DD4o
.text$x:00009A7D                 lea     ecx, [ebp-3Ch]  ; this
.text$x:00009A80                 jmp     ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text$x:00009A80 __unwindfunclet$?TotalBench_Hash@@YGJ_KIIPAUIBenchPrintCallback@@PAUCBenchCallbackToPrint@@PAUCTotalBenchRes@@_N0@Z$0 endp
.text$x:00009A80
.text$x:00009A85
.text$x:00009A85 ; =============== S U B R O U T I N E =======================================
.text$x:00009A85
.text$x:00009A85
.text$x:00009A85 __unwindfunclet$?TotalBench_Hash@@YGJ_KIIPAUIBenchPrintCallback@@PAUCBenchCallbackToPrint@@PAUCTotalBenchRes@@_N0@Z$1 proc near
.text$x:00009A85                                         ; DATA XREF: .xdata$x:00009DDCo
.text$x:00009A85                 lea     ecx, [ebp-54h]  ; this
.text$x:00009A88                 jmp     ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text$x:00009A88 __unwindfunclet$?TotalBench_Hash@@YGJ_KIIPAUIBenchPrintCallback@@PAUCBenchCallbackToPrint@@PAUCTotalBenchRes@@_N0@Z$1 endp
.text$x:00009A88
.text$x:00009A8D
.text$x:00009A8D ; =============== S U B R O U T I N E =======================================
.text$x:00009A8D
.text$x:00009A8D
.text$x:00009A8D __unwindfunclet$?TotalBench_Hash@@YGJ_KIIPAUIBenchPrintCallback@@PAUCBenchCallbackToPrint@@PAUCTotalBenchRes@@_N0@Z$2 proc near
.text$x:00009A8D                                         ; DATA XREF: .xdata$x:00009DE4o
.text$x:00009A8D                 lea     ecx, [ebp-80h]  ; this
.text$x:00009A90                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00009A90 __unwindfunclet$?TotalBench_Hash@@YGJ_KIIPAUIBenchPrintCallback@@PAUCBenchCallbackToPrint@@PAUCTotalBenchRes@@_N0@Z$2 endp
.text$x:00009A90
.text$x:00009A95
.text$x:00009A95 ; =============== S U B R O U T I N E =======================================
.text$x:00009A95
.text$x:00009A95
.text$x:00009A95 __ehhandler$?TotalBench_Hash@@YGJ_KIIPAUIBenchPrintCallback@@PAUCBenchCallbackToPrint@@PAUCTotalBenchRes@@_N0@Z proc near
.text$x:00009A95                                         ; DATA XREF: TotalBench_Hash(unsigned __int64,uint,uint,IBenchPrintCallback *,CBenchCallbackToPrint *,CTotalBenchRes *,bool,unsigned __int64)+5o
.text$x:00009A95
.text$x:00009A95 arg_4           = dword ptr  8
.text$x:00009A95
.text$x:00009A95                 mov     edx, [esp+arg_4]
.text$x:00009A99                 lea     eax, [edx+0Ch]
.text$x:00009A9C                 mov     ecx, [edx-8Ch]
.text$x:00009AA2                 xor     ecx, eax
.text$x:00009AA4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009AA9                 mov     eax, offset __ehfuncinfo$?TotalBench_Hash@@YGJ_KIIPAUIBenchPrintCallback@@PAUCBenchCallbackToPrint@@PAUCTotalBenchRes@@_N0@Z
.text$x:00009AAE                 jmp     ___CxxFrameHandler3
.text$x:00009AAE __ehhandler$?TotalBench_Hash@@YGJ_KIIPAUIBenchPrintCallback@@PAUCBenchCallbackToPrint@@PAUCTotalBenchRes@@_N0@Z endp
.text$x:00009AAE
.text$x:00009AAE ; ---------------------------------------------------------------------------
.text$x:00009AB3                 align 4
.text$x:00009AB3 _text$x         ends
.text$x:00009AB3
.xdata$x:00009AB4 ; ===========================================================================
.xdata$x:00009AB4
.xdata$x:00009AB4 ; Segment type: Pure data
.xdata$x:00009AB4 ; Segment permissions: Read
.xdata$x:00009AB4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009AB4                 assume cs:_xdata$x
.xdata$x:00009AB4                 ;org 9AB4h
.xdata$x:00009AB4 __ehfuncinfo$?Init@CEncoderInfo@@QAEJABVCOneMethodInfo@@IIPAVCBaseRandomGenerator@@@Z db  22h ; "
.xdata$x:00009AB4                                         ; DATA XREF: __ehhandler$?Init@CEncoderInfo@@QAEJABVCOneMethodInfo@@IIPAVCBaseRandomGenerator@@@Z+1Eo
.xdata$x:00009AB5                 db    5
.xdata$x:00009AB6                 db  93h ; ô
.xdata$x:00009AB7                 db  19h
.xdata$x:00009AB8                 db  0Ah
.xdata$x:00009AB9                 db    0
.xdata$x:00009ABA                 db    0
.xdata$x:00009ABB                 db    0
.xdata$x:00009ABC                 dd offset __unwindtable$?Init@CEncoderInfo@@QAEJABVCOneMethodInfo@@IIPAVCBaseRandomGenerator@@@Z
.xdata$x:00009AC0                 db    0
.xdata$x:00009AC1                 db    0
.xdata$x:00009AC2                 db    0
.xdata$x:00009AC3                 db    0
.xdata$x:00009AC4                 db    0
.xdata$x:00009AC5                 db    0
.xdata$x:00009AC6                 db    0
.xdata$x:00009AC7                 db    0
.xdata$x:00009AC8                 db    0
.xdata$x:00009AC9                 db    0
.xdata$x:00009ACA                 db    0
.xdata$x:00009ACB                 db    0
.xdata$x:00009ACC                 db    0
.xdata$x:00009ACD                 db    0
.xdata$x:00009ACE                 db    0
.xdata$x:00009ACF                 db    0
.xdata$x:00009AD0                 db    0
.xdata$x:00009AD1                 db    0
.xdata$x:00009AD2                 db    0
.xdata$x:00009AD3                 db    0
.xdata$x:00009AD4                 db    1
.xdata$x:00009AD5                 db    0
.xdata$x:00009AD6                 db    0
.xdata$x:00009AD7                 db    0
.xdata$x:00009AD8 __unwindtable$?Init@CEncoderInfo@@QAEJABVCOneMethodInfo@@IIPAVCBaseRandomGenerator@@@Z db 0FFh
.xdata$x:00009AD8                                         ; DATA XREF: .xdata$x:00009ABCo
.xdata$x:00009AD9                 db 0FFh
.xdata$x:00009ADA                 db 0FFh
.xdata$x:00009ADB                 db 0FFh
.xdata$x:00009ADC                 dd offset __unwindfunclet$?Init@CEncoderInfo@@QAEJABVCOneMethodInfo@@IIPAVCBaseRandomGenerator@@@Z$0
.xdata$x:00009AE0                 db 0FFh
.xdata$x:00009AE1                 db 0FFh
.xdata$x:00009AE2                 db 0FFh
.xdata$x:00009AE3                 db 0FFh
.xdata$x:00009AE4                 dd offset __unwindfunclet$?Init@CEncoderInfo@@QAEJABVCOneMethodInfo@@IIPAVCBaseRandomGenerator@@@Z$1
.xdata$x:00009AE8                 db 0FFh
.xdata$x:00009AE9                 db 0FFh
.xdata$x:00009AEA                 db 0FFh
.xdata$x:00009AEB                 db 0FFh
.xdata$x:00009AEC                 dd offset __unwindfunclet$?Init@CEncoderInfo@@QAEJABVCOneMethodInfo@@IIPAVCBaseRandomGenerator@@@Z$2
.xdata$x:00009AF0                 db    2
.xdata$x:00009AF1                 db    0
.xdata$x:00009AF2                 db    0
.xdata$x:00009AF3                 db    0
.xdata$x:00009AF4                 dd offset __unwindfunclet$?Init@CEncoderInfo@@QAEJABVCOneMethodInfo@@IIPAVCBaseRandomGenerator@@@Z$3
.xdata$x:00009AF8                 db    3
.xdata$x:00009AF9                 db    0
.xdata$x:00009AFA                 db    0
.xdata$x:00009AFB                 db    0
.xdata$x:00009AFC                 dd offset __unwindfunclet$?Init@CEncoderInfo@@QAEJABVCOneMethodInfo@@IIPAVCBaseRandomGenerator@@@Z$4
.xdata$x:00009B00                 db    4
.xdata$x:00009B01                 db    0
.xdata$x:00009B02                 db    0
.xdata$x:00009B03                 db    0
.xdata$x:00009B04                 dd offset __unwindfunclet$?Init@CEncoderInfo@@QAEJABVCOneMethodInfo@@IIPAVCBaseRandomGenerator@@@Z$5
.xdata$x:00009B08                 db    5
.xdata$x:00009B09                 db    0
.xdata$x:00009B0A                 db    0
.xdata$x:00009B0B                 db    0
.xdata$x:00009B0C                 dd offset __unwindfunclet$?Init@CEncoderInfo@@QAEJABVCOneMethodInfo@@IIPAVCBaseRandomGenerator@@@Z$6
.xdata$x:00009B10                 db    5
.xdata$x:00009B11                 db    0
.xdata$x:00009B12                 db    0
.xdata$x:00009B13                 db    0
.xdata$x:00009B14                 dd offset __unwindfunclet$?Init@CEncoderInfo@@QAEJABVCOneMethodInfo@@IIPAVCBaseRandomGenerator@@@Z$7
.xdata$x:00009B18                 db    7
.xdata$x:00009B19                 db    0
.xdata$x:00009B1A                 db    0
.xdata$x:00009B1B                 db    0
.xdata$x:00009B1C                 dd offset __unwindfunclet$?Init@CEncoderInfo@@QAEJABVCOneMethodInfo@@IIPAVCBaseRandomGenerator@@@Z$8
.xdata$x:00009B20                 db    7
.xdata$x:00009B21                 db    0
.xdata$x:00009B22                 db    0
.xdata$x:00009B23                 db    0
.xdata$x:00009B24                 dd offset __unwindfunclet$?Init@CEncoderInfo@@QAEJABVCOneMethodInfo@@IIPAVCBaseRandomGenerator@@@Z$9
.xdata$x:00009B28 __unwindtable$?Encode@CEncoderInfo@@QAEJXZ db 0FFh
.xdata$x:00009B28                                         ; DATA XREF: .xdata$x:00009B50o
.xdata$x:00009B29                 db 0FFh
.xdata$x:00009B2A                 db 0FFh
.xdata$x:00009B2B                 db 0FFh
.xdata$x:00009B2C                 dd offset __unwindfunclet$?Encode@CEncoderInfo@@QAEJXZ$0
.xdata$x:00009B30                 db    0
.xdata$x:00009B31                 db    0
.xdata$x:00009B32                 db    0
.xdata$x:00009B33                 db    0
.xdata$x:00009B34                 dd offset __unwindfunclet$?Encode@CEncoderInfo@@QAEJXZ$1
.xdata$x:00009B38                 db    1
.xdata$x:00009B39                 db    0
.xdata$x:00009B3A                 db    0
.xdata$x:00009B3B                 db    0
.xdata$x:00009B3C                 dd offset __unwindfunclet$?Encode@CEncoderInfo@@QAEJXZ$2
.xdata$x:00009B40                 db    1
.xdata$x:00009B41                 db    0
.xdata$x:00009B42                 db    0
.xdata$x:00009B43                 db    0
.xdata$x:00009B44                 dd offset __unwindfunclet$?Encode@CEncoderInfo@@QAEJXZ$3
.xdata$x:00009B48 __ehfuncinfo$?Encode@CEncoderInfo@@QAEJXZ db  22h ; "
.xdata$x:00009B48                                         ; DATA XREF: __ehhandler$?Encode@CEncoderInfo@@QAEJXZ+14o
.xdata$x:00009B49                 db    5
.xdata$x:00009B4A                 db  93h ; ô
.xdata$x:00009B4B                 db  19h
.xdata$x:00009B4C                 db    4
.xdata$x:00009B4D                 db    0
.xdata$x:00009B4E                 db    0
.xdata$x:00009B4F                 db    0
.xdata$x:00009B50                 dd offset __unwindtable$?Encode@CEncoderInfo@@QAEJXZ
.xdata$x:00009B54                 db    0
.xdata$x:00009B55                 db    0
.xdata$x:00009B56                 db    0
.xdata$x:00009B57                 db    0
.xdata$x:00009B58                 db    0
.xdata$x:00009B59                 db    0
.xdata$x:00009B5A                 db    0
.xdata$x:00009B5B                 db    0
.xdata$x:00009B5C                 db    0
.xdata$x:00009B5D                 db    0
.xdata$x:00009B5E                 db    0
.xdata$x:00009B5F                 db    0
.xdata$x:00009B60                 db    0
.xdata$x:00009B61                 db    0
.xdata$x:00009B62                 db    0
.xdata$x:00009B63                 db    0
.xdata$x:00009B64                 db    0
.xdata$x:00009B65                 db    0
.xdata$x:00009B66                 db    0
.xdata$x:00009B67                 db    0
.xdata$x:00009B68                 db    1
.xdata$x:00009B69                 db    0
.xdata$x:00009B6A                 db    0
.xdata$x:00009B6B                 db    0
.xdata$x:00009B6C __ehfuncinfo$?Decode@CEncoderInfo@@QAEJI@Z db  22h ; "
.xdata$x:00009B6C                                         ; DATA XREF: __ehhandler$?Decode@CEncoderInfo@@QAEJI@Z+14o
.xdata$x:00009B6D                 db    5
.xdata$x:00009B6E                 db  93h ; ô
.xdata$x:00009B6F                 db  19h
.xdata$x:00009B70                 db  0Ah
.xdata$x:00009B71                 db    0
.xdata$x:00009B72                 db    0
.xdata$x:00009B73                 db    0
.xdata$x:00009B74                 dd offset __unwindtable$?Decode@CEncoderInfo@@QAEJI@Z
.xdata$x:00009B78                 db    0
.xdata$x:00009B79                 db    0
.xdata$x:00009B7A                 db    0
.xdata$x:00009B7B                 db    0
.xdata$x:00009B7C                 db    0
.xdata$x:00009B7D                 db    0
.xdata$x:00009B7E                 db    0
.xdata$x:00009B7F                 db    0
.xdata$x:00009B80                 db    0
.xdata$x:00009B81                 db    0
.xdata$x:00009B82                 db    0
.xdata$x:00009B83                 db    0
.xdata$x:00009B84                 db    0
.xdata$x:00009B85                 db    0
.xdata$x:00009B86                 db    0
.xdata$x:00009B87                 db    0
.xdata$x:00009B88                 db    0
.xdata$x:00009B89                 db    0
.xdata$x:00009B8A                 db    0
.xdata$x:00009B8B                 db    0
.xdata$x:00009B8C                 db    1
.xdata$x:00009B8D                 db    0
.xdata$x:00009B8E                 db    0
.xdata$x:00009B8F                 db    0
.xdata$x:00009B90 __unwindtable$?Decode@CEncoderInfo@@QAEJI@Z db 0FFh
.xdata$x:00009B90                                         ; DATA XREF: .xdata$x:00009B74o
.xdata$x:00009B91                 db 0FFh
.xdata$x:00009B92                 db 0FFh
.xdata$x:00009B93                 db 0FFh
.xdata$x:00009B94                 dd offset __unwindfunclet$?Decode@CEncoderInfo@@QAEJI@Z$0
.xdata$x:00009B98                 db 0FFh
.xdata$x:00009B99                 db 0FFh
.xdata$x:00009B9A                 db 0FFh
.xdata$x:00009B9B                 db 0FFh
.xdata$x:00009B9C                 dd offset __unwindfunclet$?Decode@CEncoderInfo@@QAEJI@Z$1
.xdata$x:00009BA0                 db    1
.xdata$x:00009BA1                 db    0
.xdata$x:00009BA2                 db    0
.xdata$x:00009BA3                 db    0
.xdata$x:00009BA4                 dd offset __unwindfunclet$?Decode@CEncoderInfo@@QAEJI@Z$2
.xdata$x:00009BA8                 db    2
.xdata$x:00009BA9                 db    0
.xdata$x:00009BAA                 db    0
.xdata$x:00009BAB                 db    0
.xdata$x:00009BAC                 dd offset __unwindfunclet$?Decode@CEncoderInfo@@QAEJI@Z$3
.xdata$x:00009BB0                 db    3
.xdata$x:00009BB1                 db    0
.xdata$x:00009BB2                 db    0
.xdata$x:00009BB3                 db    0
.xdata$x:00009BB4                 dd offset __unwindfunclet$?Decode@CEncoderInfo@@QAEJI@Z$4
.xdata$x:00009BB8                 db    3
.xdata$x:00009BB9                 db    0
.xdata$x:00009BBA                 db    0
.xdata$x:00009BBB                 db    0
.xdata$x:00009BBC                 dd offset __unwindfunclet$?Decode@CEncoderInfo@@QAEJI@Z$5
.xdata$x:00009BC0                 db    5
.xdata$x:00009BC1                 db    0
.xdata$x:00009BC2                 db    0
.xdata$x:00009BC3                 db    0
.xdata$x:00009BC4                 dd offset __unwindfunclet$?Decode@CEncoderInfo@@QAEJI@Z$6
.xdata$x:00009BC8                 db    5
.xdata$x:00009BC9                 db    0
.xdata$x:00009BCA                 db    0
.xdata$x:00009BCB                 db    0
.xdata$x:00009BCC                 dd offset __unwindfunclet$?Decode@CEncoderInfo@@QAEJI@Z$7
.xdata$x:00009BD0                 db    7
.xdata$x:00009BD1                 db    0
.xdata$x:00009BD2                 db    0
.xdata$x:00009BD3                 db    0
.xdata$x:00009BD4                 dd offset __unwindfunclet$?Decode@CEncoderInfo@@QAEJI@Z$8
.xdata$x:00009BD8                 db    8
.xdata$x:00009BD9                 db    0
.xdata$x:00009BDA                 db    0
.xdata$x:00009BDB                 db    0
.xdata$x:00009BDC                 dd offset __unwindfunclet$?Decode@CEncoderInfo@@QAEJI@Z$9
.xdata$x:00009BE0 __unwindtable$?CrcInternalTest@@YG_NXZ db 0FFh
.xdata$x:00009BE0                                         ; DATA XREF: .xdata$x:00009BF0o
.xdata$x:00009BE1                 db 0FFh
.xdata$x:00009BE2                 db 0FFh
.xdata$x:00009BE3                 db 0FFh
.xdata$x:00009BE4                 dd offset __unwindfunclet$?CrcInternalTest@@YG_NXZ$0
.xdata$x:00009BE8 __ehfuncinfo$?CrcInternalTest@@YG_NXZ db  22h ; "
.xdata$x:00009BE8                                         ; DATA XREF: __ehhandler$?CrcInternalTest@@YG_NXZ+11o
.xdata$x:00009BE9                 db    5
.xdata$x:00009BEA                 db  93h ; ô
.xdata$x:00009BEB                 db  19h
.xdata$x:00009BEC                 db    1
.xdata$x:00009BED                 db    0
.xdata$x:00009BEE                 db    0
.xdata$x:00009BEF                 db    0
.xdata$x:00009BF0                 dd offset __unwindtable$?CrcInternalTest@@YG_NXZ
.xdata$x:00009BF4                 db    0
.xdata$x:00009BF5                 db    0
.xdata$x:00009BF6                 db    0
.xdata$x:00009BF7                 db    0
.xdata$x:00009BF8                 db    0
.xdata$x:00009BF9                 db    0
.xdata$x:00009BFA                 db    0
.xdata$x:00009BFB                 db    0
.xdata$x:00009BFC                 db    0
.xdata$x:00009BFD                 db    0
.xdata$x:00009BFE                 db    0
.xdata$x:00009BFF                 db    0
.xdata$x:00009C00                 db    0
.xdata$x:00009C01                 db    0
.xdata$x:00009C02                 db    0
.xdata$x:00009C03                 db    0
.xdata$x:00009C04                 db    0
.xdata$x:00009C05                 db    0
.xdata$x:00009C06                 db    0
.xdata$x:00009C07                 db    0
.xdata$x:00009C08                 db    1
.xdata$x:00009C09                 db    0
.xdata$x:00009C0A                 db    0
.xdata$x:00009C0B                 db    0
.xdata$x:00009C0C __ehfuncinfo$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z db  22h ; "
.xdata$x:00009C0C                                         ; DATA XREF: __ehhandler$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z+1Eo
.xdata$x:00009C0D                 db    5
.xdata$x:00009C0E                 db  93h ; ô
.xdata$x:00009C0F                 db  19h
.xdata$x:00009C10                 db  0Eh
.xdata$x:00009C11                 db    0
.xdata$x:00009C12                 db    0
.xdata$x:00009C13                 db    0
.xdata$x:00009C14                 dd offset __unwindtable$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z
.xdata$x:00009C18                 db    0
.xdata$x:00009C19                 db    0
.xdata$x:00009C1A                 db    0
.xdata$x:00009C1B                 db    0
.xdata$x:00009C1C                 db    0
.xdata$x:00009C1D                 db    0
.xdata$x:00009C1E                 db    0
.xdata$x:00009C1F                 db    0
.xdata$x:00009C20                 db    0
.xdata$x:00009C21                 db    0
.xdata$x:00009C22                 db    0
.xdata$x:00009C23                 db    0
.xdata$x:00009C24                 db    0
.xdata$x:00009C25                 db    0
.xdata$x:00009C26                 db    0
.xdata$x:00009C27                 db    0
.xdata$x:00009C28                 db    0
.xdata$x:00009C29                 db    0
.xdata$x:00009C2A                 db    0
.xdata$x:00009C2B                 db    0
.xdata$x:00009C2C                 db    1
.xdata$x:00009C2D                 db    0
.xdata$x:00009C2E                 db    0
.xdata$x:00009C2F                 db    0
.xdata$x:00009C30 __unwindtable$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z db 0FFh
.xdata$x:00009C30                                         ; DATA XREF: .xdata$x:00009C14o
.xdata$x:00009C31                 db 0FFh
.xdata$x:00009C32                 db 0FFh
.xdata$x:00009C33                 db 0FFh
.xdata$x:00009C34                 dd offset __unwindfunclet$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z$0
.xdata$x:00009C38                 db    0
.xdata$x:00009C39                 db    0
.xdata$x:00009C3A                 db    0
.xdata$x:00009C3B                 db    0
.xdata$x:00009C3C                 dd offset __unwindfunclet$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z$1
.xdata$x:00009C40                 db    1
.xdata$x:00009C41                 db    0
.xdata$x:00009C42                 db    0
.xdata$x:00009C43                 db    0
.xdata$x:00009C44                 dd offset __unwindfunclet$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z$2
.xdata$x:00009C48                 db    2
.xdata$x:00009C49                 db    0
.xdata$x:00009C4A                 db    0
.xdata$x:00009C4B                 db    0
.xdata$x:00009C4C                 dd offset __unwindfunclet$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z$3
.xdata$x:00009C50                 db    2
.xdata$x:00009C51                 db    0
.xdata$x:00009C52                 db    0
.xdata$x:00009C53                 db    0
.xdata$x:00009C54                 dd offset __unwindfunclet$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z$4
.xdata$x:00009C58                 db    0
.xdata$x:00009C59                 db    0
.xdata$x:00009C5A                 db    0
.xdata$x:00009C5B                 db    0
.xdata$x:00009C5C                 dd offset __unwindfunclet$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z$5
.xdata$x:00009C60                 db    0
.xdata$x:00009C61                 db    0
.xdata$x:00009C62                 db    0
.xdata$x:00009C63                 db    0
.xdata$x:00009C64                 dd offset __unwindfunclet$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z$6
.xdata$x:00009C68                 db    6
.xdata$x:00009C69                 db    0
.xdata$x:00009C6A                 db    0
.xdata$x:00009C6B                 db    0
.xdata$x:00009C6C                 dd offset __unwindfunclet$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z$7
.xdata$x:00009C70                 db    7
.xdata$x:00009C71                 db    0
.xdata$x:00009C72                 db    0
.xdata$x:00009C73                 db    0
.xdata$x:00009C74                 dd offset __unwindfunclet$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z$8
.xdata$x:00009C78                 db    6
.xdata$x:00009C79                 db    0
.xdata$x:00009C7A                 db    0
.xdata$x:00009C7B                 db    0
.xdata$x:00009C7C                 dd offset __unwindfunclet$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z$9
.xdata$x:00009C80                 db    6
.xdata$x:00009C81                 db    0
.xdata$x:00009C82                 db    0
.xdata$x:00009C83                 db    0
.xdata$x:00009C84                 dd offset __unwindfunclet$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z$10
.xdata$x:00009C88                 db    6
.xdata$x:00009C89                 db    0
.xdata$x:00009C8A                 db    0
.xdata$x:00009C8B                 db    0
.xdata$x:00009C8C                 dd offset __unwindfunclet$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z$11
.xdata$x:00009C90                 db  0Bh
.xdata$x:00009C91                 db    0
.xdata$x:00009C92                 db    0
.xdata$x:00009C93                 db    0
.xdata$x:00009C94                 dd offset __unwindfunclet$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z$12
.xdata$x:00009C98                 db  0Ch
.xdata$x:00009C99                 db    0
.xdata$x:00009C9A                 db    0
.xdata$x:00009C9B                 db    0
.xdata$x:00009C9C                 dd offset __unwindfunclet$?Bench@@YGJPAUIBenchPrintCallback@@PAUIBenchCallback@@ABV?$CObjectVector@UCProperty@@@@I_N@Z$13
.xdata$x:00009CA0 __ehfuncinfo$?MethodBench@@YGJ_K_NIABVCOneMethodInfo@@IIPAUIBenchPrintCallback@@PAUIBenchCallback@@PAUCBenchProps@@@Z db  22h ; "
.xdata$x:00009CA0                                         ; DATA XREF: __ehhandler$?MethodBench@@YGJ_K_NIABVCOneMethodInfo@@IIPAUIBenchPrintCallback@@PAUIBenchCallback@@PAUCBenchProps@@@Z+14o
.xdata$x:00009CA1                 db    5
.xdata$x:00009CA2                 db  93h ; ô
.xdata$x:00009CA3                 db  19h
.xdata$x:00009CA4                 db    6
.xdata$x:00009CA5                 db    0
.xdata$x:00009CA6                 db    0
.xdata$x:00009CA7                 db    0
.xdata$x:00009CA8                 dd offset __unwindtable$?MethodBench@@YGJ_K_NIABVCOneMethodInfo@@IIPAUIBenchPrintCallback@@PAUIBenchCallback@@PAUCBenchProps@@@Z
.xdata$x:00009CAC                 align 20h
.xdata$x:00009CC0                 db    1
.xdata$x:00009CC1                 db    0
.xdata$x:00009CC2                 db    0
.xdata$x:00009CC3                 db    0
.xdata$x:00009CC4 __unwindtable$?MethodBench@@YGJ_K_NIABVCOneMethodInfo@@IIPAUIBenchPrintCallback@@PAUIBenchCallback@@PAUCBenchProps@@@Z db 0FFh
.xdata$x:00009CC4                                         ; DATA XREF: .xdata$x:00009CA8o
.xdata$x:00009CC5                 db 0FFh
.xdata$x:00009CC6                 db 0FFh
.xdata$x:00009CC7                 db 0FFh
.xdata$x:00009CC8                 dd offset __unwindfunclet$?MethodBench@@YGJ_K_NIABVCOneMethodInfo@@IIPAUIBenchPrintCallback@@PAUIBenchCallback@@PAUCBenchProps@@@Z$0
.xdata$x:00009CCC                 align 10h
.xdata$x:00009CD0                 dd offset __unwindfunclet$?MethodBench@@YGJ_K_NIABVCOneMethodInfo@@IIPAUIBenchPrintCallback@@PAUIBenchCallback@@PAUCBenchProps@@@Z$1
.xdata$x:00009CD4                 db    1
.xdata$x:00009CD5                 db    0
.xdata$x:00009CD6                 db    0
.xdata$x:00009CD7                 db    0
.xdata$x:00009CD8                 dd offset __unwindfunclet$?MethodBench@@YGJ_K_NIABVCOneMethodInfo@@IIPAUIBenchPrintCallback@@PAUIBenchCallback@@PAUCBenchProps@@@Z$2
.xdata$x:00009CDC                 db    1
.xdata$x:00009CDD                 db    0
.xdata$x:00009CDE                 db    0
.xdata$x:00009CDF                 db    0
.xdata$x:00009CE0                 dd offset __unwindfunclet$?MethodBench@@YGJ_K_NIABVCOneMethodInfo@@IIPAUIBenchPrintCallback@@PAUIBenchCallback@@PAUCBenchProps@@@Z$3
.xdata$x:00009CE4                 db    1
.xdata$x:00009CE5                 db    0
.xdata$x:00009CE6                 db    0
.xdata$x:00009CE7                 db    0
.xdata$x:00009CE8                 dd offset __unwindfunclet$?MethodBench@@YGJ_K_NIABVCOneMethodInfo@@IIPAUIBenchPrintCallback@@PAUIBenchCallback@@PAUCBenchProps@@@Z$4
.xdata$x:00009CEC                 db    4
.xdata$x:00009CED                 db    0
.xdata$x:00009CEE                 db    0
.xdata$x:00009CEF                 db    0
.xdata$x:00009CF0                 dd offset __unwindfunclet$?MethodBench@@YGJ_K_NIABVCOneMethodInfo@@IIPAUIBenchPrintCallback@@PAUIBenchCallback@@PAUCBenchProps@@@Z$5
.xdata$x:00009CF4 __unwindtable$?TotalBench@@YGJ_KI_NIPAUIBenchPrintCallback@@PAUCBenchCallbackToPrint@@@Z db 0FFh
.xdata$x:00009CF4                                         ; DATA XREF: .xdata$x:00009D14o
.xdata$x:00009CF5                 db 0FFh
.xdata$x:00009CF6                 db 0FFh
.xdata$x:00009CF7                 db 0FFh
.xdata$x:00009CF8                 dd offset __unwindfunclet$?TotalBench@@YGJ_KI_NIPAUIBenchPrintCallback@@PAUCBenchCallbackToPrint@@@Z$0
.xdata$x:00009CFC                 align 10h
.xdata$x:00009D00                 dd offset __unwindfunclet$?TotalBench@@YGJ_KI_NIPAUIBenchPrintCallback@@PAUCBenchCallbackToPrint@@@Z$1
.xdata$x:00009D04                 db    1
.xdata$x:00009D05                 db    0
.xdata$x:00009D06                 db    0
.xdata$x:00009D07                 db    0
.xdata$x:00009D08                 dd offset __unwindfunclet$?TotalBench@@YGJ_KI_NIPAUIBenchPrintCallback@@PAUCBenchCallbackToPrint@@@Z$2
.xdata$x:00009D0C __ehfuncinfo$?TotalBench@@YGJ_KI_NIPAUIBenchPrintCallback@@PAUCBenchCallbackToPrint@@@Z db  22h ; "
.xdata$x:00009D0C                                         ; DATA XREF: __ehhandler$?TotalBench@@YGJ_KI_NIPAUIBenchPrintCallback@@PAUCBenchCallbackToPrint@@@Z+11o
.xdata$x:00009D0D                 db    5
.xdata$x:00009D0E                 db  93h ; ô
.xdata$x:00009D0F                 db  19h
.xdata$x:00009D10                 db    3
.xdata$x:00009D11                 db    0
.xdata$x:00009D12                 db    0
.xdata$x:00009D13                 db    0
.xdata$x:00009D14                 dd offset __unwindtable$?TotalBench@@YGJ_KI_NIPAUIBenchPrintCallback@@PAUCBenchCallbackToPrint@@@Z
.xdata$x:00009D18                 db    0
.xdata$x:00009D19                 db    0
.xdata$x:00009D1A                 db    0
.xdata$x:00009D1B                 db    0
.xdata$x:00009D1C                 db    0
.xdata$x:00009D1D                 db    0
.xdata$x:00009D1E                 db    0
.xdata$x:00009D1F                 db    0
.xdata$x:00009D20                 db    0
.xdata$x:00009D21                 db    0
.xdata$x:00009D22                 db    0
.xdata$x:00009D23                 db    0
.xdata$x:00009D24                 db    0
.xdata$x:00009D25                 db    0
.xdata$x:00009D26                 db    0
.xdata$x:00009D27                 db    0
.xdata$x:00009D28                 db    0
.xdata$x:00009D29                 db    0
.xdata$x:00009D2A                 db    0
.xdata$x:00009D2B                 db    0
.xdata$x:00009D2C                 db    1
.xdata$x:00009D2D                 db    0
.xdata$x:00009D2E                 db    0
.xdata$x:00009D2F                 db    0
.xdata$x:00009D30 __unwindtable$?FreqBench@@YGJ_KIPAUIBenchPrintCallback@@_NAA_KAAI@Z db 0FFh
.xdata$x:00009D30                                         ; DATA XREF: .xdata$x:00009D48o
.xdata$x:00009D31                 db 0FFh
.xdata$x:00009D32                 db 0FFh
.xdata$x:00009D33                 db 0FFh
.xdata$x:00009D34                 dd offset __unwindfunclet$?FreqBench@@YGJ_KIPAUIBenchPrintCallback@@_NAA_KAAI@Z$0
.xdata$x:00009D38                 db    0
.xdata$x:00009D39                 db    0
.xdata$x:00009D3A                 db    0
.xdata$x:00009D3B                 db    0
.xdata$x:00009D3C                 dd offset __unwindfunclet$?FreqBench@@YGJ_KIPAUIBenchPrintCallback@@_NAA_KAAI@Z$1
.xdata$x:00009D40 __ehfuncinfo$?FreqBench@@YGJ_KIPAUIBenchPrintCallback@@_NAA_KAAI@Z db  22h ; "
.xdata$x:00009D40                                         ; DATA XREF: __ehhandler$?FreqBench@@YGJ_KIPAUIBenchPrintCallback@@_NAA_KAAI@Z+14o
.xdata$x:00009D41                 db    5
.xdata$x:00009D42                 db  93h ; ô
.xdata$x:00009D43                 db  19h
.xdata$x:00009D44                 db    2
.xdata$x:00009D45                 db    0
.xdata$x:00009D46                 db    0
.xdata$x:00009D47                 db    0
.xdata$x:00009D48                 dd offset __unwindtable$?FreqBench@@YGJ_KIPAUIBenchPrintCallback@@_NAA_KAAI@Z
.xdata$x:00009D4C                 align 20h
.xdata$x:00009D60                 db    1
.xdata$x:00009D61                 db    0
.xdata$x:00009D62                 db    0
.xdata$x:00009D63                 db    0
.xdata$x:00009D64 __ehfuncinfo$?CrcBench@@YGJ_KIIAA_KIIPBIABVCOneMethodInfo@@PAUIBenchPrintCallback@@PAUCTotalBenchRes@@_N0@Z db  22h ; "
.xdata$x:00009D64                                         ; DATA XREF: __ehhandler$?CrcBench@@YGJ_KIIAA_KIIPBIABVCOneMethodInfo@@PAUIBenchPrintCallback@@PAUCTotalBenchRes@@_N0@Z+14o
.xdata$x:00009D65                 db    5
.xdata$x:00009D66                 db  93h ; ô
.xdata$x:00009D67                 db  19h
.xdata$x:00009D68                 db    9
.xdata$x:00009D69                 db    0
.xdata$x:00009D6A                 db    0
.xdata$x:00009D6B                 db    0
.xdata$x:00009D6C                 dd offset __unwindtable$?CrcBench@@YGJ_KIIAA_KIIPBIABVCOneMethodInfo@@PAUIBenchPrintCallback@@PAUCTotalBenchRes@@_N0@Z
.xdata$x:00009D70                 db    0
.xdata$x:00009D71                 db    0
.xdata$x:00009D72                 db    0
.xdata$x:00009D73                 db    0
.xdata$x:00009D74                 db    0
.xdata$x:00009D75                 db    0
.xdata$x:00009D76                 db    0
.xdata$x:00009D77                 db    0
.xdata$x:00009D78                 db    0
.xdata$x:00009D79                 db    0
.xdata$x:00009D7A                 db    0
.xdata$x:00009D7B                 db    0
.xdata$x:00009D7C                 db    0
.xdata$x:00009D7D                 db    0
.xdata$x:00009D7E                 db    0
.xdata$x:00009D7F                 db    0
.xdata$x:00009D80                 db    0
.xdata$x:00009D81                 db    0
.xdata$x:00009D82                 db    0
.xdata$x:00009D83                 db    0
.xdata$x:00009D84                 db    1
.xdata$x:00009D85                 db    0
.xdata$x:00009D86                 db    0
.xdata$x:00009D87                 db    0
.xdata$x:00009D88 __unwindtable$?CrcBench@@YGJ_KIIAA_KIIPBIABVCOneMethodInfo@@PAUIBenchPrintCallback@@PAUCTotalBenchRes@@_N0@Z db 0FFh
.xdata$x:00009D88                                         ; DATA XREF: .xdata$x:00009D6Co
.xdata$x:00009D89                 db 0FFh
.xdata$x:00009D8A                 db 0FFh
.xdata$x:00009D8B                 db 0FFh
.xdata$x:00009D8C                 dd offset __unwindfunclet$?CrcBench@@YGJ_KIIAA_KIIPBIABVCOneMethodInfo@@PAUIBenchPrintCallback@@PAUCTotalBenchRes@@_N0@Z$0
.xdata$x:00009D90                 db    0
.xdata$x:00009D91                 db    0
.xdata$x:00009D92                 db    0
.xdata$x:00009D93                 db    0
.xdata$x:00009D94                 dd offset __unwindfunclet$?CrcBench@@YGJ_KIIAA_KIIPBIABVCOneMethodInfo@@PAUIBenchPrintCallback@@PAUCTotalBenchRes@@_N0@Z$1
.xdata$x:00009D98                 db    1
.xdata$x:00009D99                 db    0
.xdata$x:00009D9A                 db    0
.xdata$x:00009D9B                 db    0
.xdata$x:00009D9C                 dd offset __unwindfunclet$?CrcBench@@YGJ_KIIAA_KIIPBIABVCOneMethodInfo@@PAUIBenchPrintCallback@@PAUCTotalBenchRes@@_N0@Z$2
.xdata$x:00009DA0                 db    2
.xdata$x:00009DA1                 db    0
.xdata$x:00009DA2                 db    0
.xdata$x:00009DA3                 db    0
.xdata$x:00009DA4                 dd offset __unwindfunclet$?CrcBench@@YGJ_KIIAA_KIIPBIABVCOneMethodInfo@@PAUIBenchPrintCallback@@PAUCTotalBenchRes@@_N0@Z$3
.xdata$x:00009DA8                 db    2
.xdata$x:00009DA9                 db    0
.xdata$x:00009DAA                 db    0
.xdata$x:00009DAB                 db    0
.xdata$x:00009DAC                 dd offset __unwindfunclet$?CrcBench@@YGJ_KIIAA_KIIPBIABVCOneMethodInfo@@PAUIBenchPrintCallback@@PAUCTotalBenchRes@@_N0@Z$4
.xdata$x:00009DB0                 db    4
.xdata$x:00009DB1                 db    0
.xdata$x:00009DB2                 db    0
.xdata$x:00009DB3                 db    0
.xdata$x:00009DB4                 dd offset __unwindfunclet$?CrcBench@@YGJ_KIIAA_KIIPBIABVCOneMethodInfo@@PAUIBenchPrintCallback@@PAUCTotalBenchRes@@_N0@Z$5
.xdata$x:00009DB8                 db    2
.xdata$x:00009DB9                 db    0
.xdata$x:00009DBA                 db    0
.xdata$x:00009DBB                 db    0
.xdata$x:00009DBC                 dd offset __unwindfunclet$?CrcBench@@YGJ_KIIAA_KIIPBIABVCOneMethodInfo@@PAUIBenchPrintCallback@@PAUCTotalBenchRes@@_N0@Z$6
.xdata$x:00009DC0                 db    6
.xdata$x:00009DC1                 db    0
.xdata$x:00009DC2                 db    0
.xdata$x:00009DC3                 db    0
.xdata$x:00009DC4                 dd offset __unwindfunclet$?CrcBench@@YGJ_KIIAA_KIIPBIABVCOneMethodInfo@@PAUIBenchPrintCallback@@PAUCTotalBenchRes@@_N0@Z$7
.xdata$x:00009DC8                 db    7
.xdata$x:00009DC9                 db    0
.xdata$x:00009DCA                 db    0
.xdata$x:00009DCB                 db    0
.xdata$x:00009DCC                 dd offset __unwindfunclet$?CrcBench@@YGJ_KIIAA_KIIPBIABVCOneMethodInfo@@PAUIBenchPrintCallback@@PAUCTotalBenchRes@@_N0@Z$8
.xdata$x:00009DD0 __unwindtable$?TotalBench_Hash@@YGJ_KIIPAUIBenchPrintCallback@@PAUCBenchCallbackToPrint@@PAUCTotalBenchRes@@_N0@Z db 0FFh
.xdata$x:00009DD0                                         ; DATA XREF: .xdata$x:00009DF0o
.xdata$x:00009DD1                 db 0FFh
.xdata$x:00009DD2                 db 0FFh
.xdata$x:00009DD3                 db 0FFh
.xdata$x:00009DD4                 dd offset __unwindfunclet$?TotalBench_Hash@@YGJ_KIIPAUIBenchPrintCallback@@PAUCBenchCallbackToPrint@@PAUCTotalBenchRes@@_N0@Z$0
.xdata$x:00009DD8                 db    0
.xdata$x:00009DD9                 db    0
.xdata$x:00009DDA                 db    0
.xdata$x:00009DDB                 db    0
.xdata$x:00009DDC                 dd offset __unwindfunclet$?TotalBench_Hash@@YGJ_KIIPAUIBenchPrintCallback@@PAUCBenchCallbackToPrint@@PAUCTotalBenchRes@@_N0@Z$1
.xdata$x:00009DE0                 db    1
.xdata$x:00009DE1                 db    0
.xdata$x:00009DE2                 db    0
.xdata$x:00009DE3                 db    0
.xdata$x:00009DE4                 dd offset __unwindfunclet$?TotalBench_Hash@@YGJ_KIIPAUIBenchPrintCallback@@PAUCBenchCallbackToPrint@@PAUCTotalBenchRes@@_N0@Z$2
.xdata$x:00009DE8 __ehfuncinfo$?TotalBench_Hash@@YGJ_KIIPAUIBenchPrintCallback@@PAUCBenchCallbackToPrint@@PAUCTotalBenchRes@@_N0@Z db  22h ; "
.xdata$x:00009DE8                                         ; DATA XREF: __ehhandler$?TotalBench_Hash@@YGJ_KIIPAUIBenchPrintCallback@@PAUCBenchCallbackToPrint@@PAUCTotalBenchRes@@_N0@Z+14o
.xdata$x:00009DE9                 db    5
.xdata$x:00009DEA                 db  93h ; ô
.xdata$x:00009DEB                 db  19h
.xdata$x:00009DEC                 db    3
.xdata$x:00009DED                 db    0
.xdata$x:00009DEE                 db    0
.xdata$x:00009DEF                 db    0
.xdata$x:00009DF0                 dd offset __unwindtable$?TotalBench_Hash@@YGJ_KIIPAUIBenchPrintCallback@@PAUCBenchCallbackToPrint@@PAUCTotalBenchRes@@_N0@Z
.xdata$x:00009DF4                 db    0
.xdata$x:00009DF5                 db    0
.xdata$x:00009DF6                 db    0
.xdata$x:00009DF7                 db    0
.xdata$x:00009DF8                 db    0
.xdata$x:00009DF9                 db    0
.xdata$x:00009DFA                 db    0
.xdata$x:00009DFB                 db    0
.xdata$x:00009DFC                 db    0
.xdata$x:00009DFD                 db    0
.xdata$x:00009DFE                 db    0
.xdata$x:00009DFF                 db    0
.xdata$x:00009E00                 db    0
.xdata$x:00009E01                 db    0
.xdata$x:00009E02                 db    0
.xdata$x:00009E03                 db    0
.xdata$x:00009E04                 db    0
.xdata$x:00009E05                 db    0
.xdata$x:00009E06                 db    0
.xdata$x:00009E07                 db    0
.xdata$x:00009E08                 db    1
.xdata$x:00009E09                 db    0
.xdata$x:00009E0A                 db    0
.xdata$x:00009E0B                 db    0
.xdata$x:00009E0B _xdata$x        ends
.xdata$x:00009E0B
.text:00009E0C ; ===========================================================================
.text:00009E0C
.text:00009E0C ; Segment type: Pure code
.text:00009E0C ; Segment permissions: Read/Execute
.text:00009E0C _text           segment para public 'CODE' use32
.text:00009E0C                 assume cs:_text
.text:00009E0C                 ;org 9E0Ch
.text:00009E0C ; COMDAT (pick any)
.text:00009E0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009E0C
.text:00009E0C ; =============== S U B R O U T I N E =======================================
.text:00009E0C
.text:00009E0C ; Attributes: bp-based frame
.text:00009E0C
.text:00009E0C ; bool __thiscall CProps::AreThereNonOptionalProps(CProps *__hidden this)
.text:00009E0C                 public ?AreThereNonOptionalProps@CProps@@QBE_NXZ
.text:00009E0C ?AreThereNonOptionalProps@CProps@@QBE_NXZ proc near
.text:00009E0C                                         ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+35Cp
.text:00009E0C
.text:00009E0C var_8           = dword ptr -8
.text:00009E0C var_4           = dword ptr -4
.text:00009E0C
.text:00009E0C                 push    ebp
.text:00009E0D                 mov     ebp, esp
.text:00009E0F                 sub     esp, 8
.text:00009E12                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00009E19                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00009E20                 mov     [ebp+var_4], ecx
.text:00009E23                 mov     [ebp+var_8], 0
.text:00009E2A                 jmp     short loc_9E35
.text:00009E2C ; ---------------------------------------------------------------------------
.text:00009E2C
.text:00009E2C loc_9E2C:                               ; CODE XREF: CProps::AreThereNonOptionalProps(void):loc_9E5Aj
.text:00009E2C                 mov     eax, [ebp+var_8]
.text:00009E2F                 add     eax, 1
.text:00009E32                 mov     [ebp+var_8], eax
.text:00009E35
.text:00009E35 loc_9E35:                               ; CODE XREF: CProps::AreThereNonOptionalProps(void)+1Ej
.text:00009E35                 mov     ecx, [ebp+var_4]
.text:00009E38                 call    ?Size@?$CObjectVector@UCProp@@@@QBEIXZ ; CObjectVector<CProp>::Size(void)
.text:00009E3D                 cmp     [ebp+var_8], eax
.text:00009E40                 jnb     short loc_9E5C
.text:00009E42                 mov     ecx, [ebp+var_8]
.text:00009E45                 push    ecx
.text:00009E46                 mov     ecx, [ebp+var_4]
.text:00009E49                 call    ??A?$CObjectVector@UCProp@@@@QBEABUCProp@@I@Z ; CObjectVector<CProp>::operator[](uint)
.text:00009E4E                 movzx   edx, byte ptr [eax+4]
.text:00009E52                 test    edx, edx
.text:00009E54                 jnz     short loc_9E5A
.text:00009E56                 mov     al, 1
.text:00009E58                 jmp     short loc_9E5E
.text:00009E5A ; ---------------------------------------------------------------------------
.text:00009E5A
.text:00009E5A loc_9E5A:                               ; CODE XREF: CProps::AreThereNonOptionalProps(void)+48j
.text:00009E5A                 jmp     short loc_9E2C
.text:00009E5C ; ---------------------------------------------------------------------------
.text:00009E5C
.text:00009E5C loc_9E5C:                               ; CODE XREF: CProps::AreThereNonOptionalProps(void)+34j
.text:00009E5C                 xor     al, al
.text:00009E5E
.text:00009E5E loc_9E5E:                               ; CODE XREF: CProps::AreThereNonOptionalProps(void)+4Cj
.text:00009E5E                 add     esp, 8
.text:00009E61                 cmp     ebp, esp
.text:00009E63                 call    __RTC_CheckEsp
.text:00009E68                 mov     esp, ebp
.text:00009E6A                 pop     ebp
.text:00009E6B                 retn
.text:00009E6B ?AreThereNonOptionalProps@CProps@@QBE_NXZ endp
.text:00009E6B
.text:00009E6B _text           ends
.text:00009E6B
.text:00009E6C ; ===========================================================================
.text:00009E6C
.text:00009E6C ; Segment type: Pure code
.text:00009E6C ; Segment permissions: Read/Execute
.text:00009E6C _text           segment para public 'CODE' use32
.text:00009E6C                 assume cs:_text
.text:00009E6C                 ;org 9E6Ch
.text:00009E6C ; COMDAT (pick any)
.text:00009E6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009E6C
.text:00009E6C ; =============== S U B R O U T I N E =======================================
.text:00009E6C
.text:00009E6C ; Attributes: bp-based frame
.text:00009E6C
.text:00009E6C ; bool __thiscall CBenchBuffer::Alloc(CBenchBuffer *this, unsigned int)
.text:00009E6C                 public ?Alloc@CBenchBuffer@@QAE_NI@Z
.text:00009E6C ?Alloc@CBenchBuffer@@QAE_NI@Z proc near ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+87p
.text:00009E6C                                         ; CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+107p ...
.text:00009E6C
.text:00009E6C var_8           = dword ptr -8
.text:00009E6C var_4           = dword ptr -4
.text:00009E6C arg_0           = dword ptr  8
.text:00009E6C
.text:00009E6C                 push    ebp
.text:00009E6D                 mov     ebp, esp
.text:00009E6F                 sub     esp, 8
.text:00009E72                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00009E79                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00009E80                 mov     [ebp+var_4], ecx
.text:00009E83                 mov     eax, [ebp+var_4]
.text:00009E86                 cmp     dword ptr [eax+8], 0
.text:00009E8A                 jz      short loc_9E9B
.text:00009E8C                 mov     ecx, [ebp+var_4]
.text:00009E8F                 mov     edx, [ecx+4]
.text:00009E92                 cmp     edx, [ebp+arg_0]
.text:00009E95                 jnz     short loc_9E9B
.text:00009E97                 mov     al, 1
.text:00009E99                 jmp     short loc_9EDD
.text:00009E9B ; ---------------------------------------------------------------------------
.text:00009E9B
.text:00009E9B loc_9E9B:                               ; CODE XREF: CBenchBuffer::Alloc(uint)+1Ej
.text:00009E9B                                         ; CBenchBuffer::Alloc(uint)+29j
.text:00009E9B                 mov     ecx, [ebp+var_4] ; this
.text:00009E9E                 call    ?Free@CBenchBuffer@@QAEXXZ ; CBenchBuffer::Free(void)
.text:00009EA3                 mov     eax, [ebp+arg_0]
.text:00009EA6                 push    eax
.text:00009EA7                 call    _MidAlloc@4     ; MidAlloc(x)
.text:00009EAC                 mov     ecx, [ebp+var_4]
.text:00009EAF                 mov     [ecx+8], eax
.text:00009EB2                 mov     edx, [ebp+var_4]
.text:00009EB5                 mov     eax, [ebp+arg_0]
.text:00009EB8                 mov     [edx+4], eax
.text:00009EBB                 mov     ecx, [ebp+var_4]
.text:00009EBE                 cmp     dword ptr [ecx+8], 0
.text:00009EC2                 jnz     short loc_9ED3
.text:00009EC4                 cmp     [ebp+arg_0], 0
.text:00009EC8                 jz      short loc_9ED3
.text:00009ECA                 mov     [ebp+var_8], 0
.text:00009ED1                 jmp     short loc_9EDA
.text:00009ED3 ; ---------------------------------------------------------------------------
.text:00009ED3
.text:00009ED3 loc_9ED3:                               ; CODE XREF: CBenchBuffer::Alloc(uint)+56j
.text:00009ED3                                         ; CBenchBuffer::Alloc(uint)+5Cj
.text:00009ED3                 mov     [ebp+var_8], 1
.text:00009EDA
.text:00009EDA loc_9EDA:                               ; CODE XREF: CBenchBuffer::Alloc(uint)+65j
.text:00009EDA                 mov     al, byte ptr [ebp+var_8]
.text:00009EDD
.text:00009EDD loc_9EDD:                               ; CODE XREF: CBenchBuffer::Alloc(uint)+2Dj
.text:00009EDD                 add     esp, 8
.text:00009EE0                 cmp     ebp, esp
.text:00009EE2                 call    __RTC_CheckEsp
.text:00009EE7                 mov     esp, ebp
.text:00009EE9                 pop     ebp
.text:00009EEA                 retn    4
.text:00009EEA ?Alloc@CBenchBuffer@@QAE_NI@Z endp
.text:00009EEA
.text:00009EEA ; ---------------------------------------------------------------------------
.text:00009EED                 align 10h
.text:00009EED _text           ends
.text:00009EED
.text:00009EF0 ; ===========================================================================
.text:00009EF0
.text:00009EF0 ; Segment type: Pure code
.text:00009EF0 ; Segment permissions: Read/Execute
.text:00009EF0 _text           segment para public 'CODE' use32
.text:00009EF0                 assume cs:_text
.text:00009EF0                 ;org 9EF0h
.text:00009EF0 ; COMDAT (pick any)
.text:00009EF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009EF0
.text:00009EF0 ; =============== S U B R O U T I N E =======================================
.text:00009EF0
.text:00009EF0 ; Attributes: bp-based frame
.text:00009EF0
.text:00009EF0 ; void __thiscall CBenchBuffer::Free(CBenchBuffer *__hidden this)
.text:00009EF0                 public ?Free@CBenchBuffer@@QAEXXZ
.text:00009EF0 ?Free@CBenchBuffer@@QAEXXZ proc near    ; CODE XREF: CBenchBuffer::Alloc(uint)+32p
.text:00009EF0                                         ; CBenchBuffer::~CBenchBuffer(void)+1Ap
.text:00009EF0
.text:00009EF0 var_4           = dword ptr -4
.text:00009EF0
.text:00009EF0                 push    ebp
.text:00009EF1                 mov     ebp, esp
.text:00009EF3                 push    ecx
.text:00009EF4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00009EFB                 mov     [ebp+var_4], ecx
.text:00009EFE                 mov     eax, [ebp+var_4]
.text:00009F01                 mov     ecx, [eax+8]
.text:00009F04                 push    ecx
.text:00009F05                 call    _MidFree@4      ; MidFree(x)
.text:00009F0A                 mov     edx, [ebp+var_4]
.text:00009F0D                 mov     dword ptr [edx+8], 0
.text:00009F14                 add     esp, 4
.text:00009F17                 cmp     ebp, esp
.text:00009F19                 call    __RTC_CheckEsp
.text:00009F1E                 mov     esp, ebp
.text:00009F20                 pop     ebp
.text:00009F21                 retn
.text:00009F21 ?Free@CBenchBuffer@@QAEXXZ endp
.text:00009F21
.text:00009F21 ; ---------------------------------------------------------------------------
.text:00009F22                 align 4
.text:00009F22 _text           ends
.text:00009F22
.text:00009F24 ; ===========================================================================
.text:00009F24
.text:00009F24 ; Segment type: Pure code
.text:00009F24 ; Segment permissions: Read/Execute
.text:00009F24 _text           segment para public 'CODE' use32
.text:00009F24                 assume cs:_text
.text:00009F24                 ;org 9F24h
.text:00009F24 ; COMDAT (pick any)
.text:00009F24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009F24
.text:00009F24 ; =============== S U B R O U T I N E =======================================
.text:00009F24
.text:00009F24 ; Attributes: bp-based frame
.text:00009F24
.text:00009F24 ; void __thiscall CBenchRandomGenerator::Set(CBenchRandomGenerator *this, struct CBaseRandomGenerator *)
.text:00009F24                 public ?Set@CBenchRandomGenerator@@QAEXPAVCBaseRandomGenerator@@@Z
.text:00009F24 ?Set@CBenchRandomGenerator@@QAEXPAVCBaseRandomGenerator@@@Z proc near
.text:00009F24                                         ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+51p
.text:00009F24
.text:00009F24 var_4           = dword ptr -4
.text:00009F24 arg_0           = dword ptr  8
.text:00009F24
.text:00009F24                 push    ebp
.text:00009F25                 mov     ebp, esp
.text:00009F27                 push    ecx
.text:00009F28                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00009F2F                 mov     [ebp+var_4], ecx
.text:00009F32                 mov     eax, [ebp+var_4]
.text:00009F35                 mov     ecx, [ebp+arg_0]
.text:00009F38                 mov     [eax+0Ch], ecx
.text:00009F3B                 mov     esp, ebp
.text:00009F3D                 pop     ebp
.text:00009F3E                 retn    4
.text:00009F3E ?Set@CBenchRandomGenerator@@QAEXPAVCBaseRandomGenerator@@@Z endp
.text:00009F3E
.text:00009F3E ; ---------------------------------------------------------------------------
.text:00009F41                 align 4
.text:00009F41 _text           ends
.text:00009F41
.text:00009F44 ; ===========================================================================
.text:00009F44
.text:00009F44 ; Segment type: Pure code
.text:00009F44 ; Segment permissions: Read/Execute
.text:00009F44 _text           segment para public 'CODE' use32
.text:00009F44                 assume cs:_text
.text:00009F44                 ;org 9F44h
.text:00009F44 ; COMDAT (pick any)
.text:00009F44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009F44
.text:00009F44 ; =============== S U B R O U T I N E =======================================
.text:00009F44
.text:00009F44 ; Attributes: bp-based frame
.text:00009F44
.text:00009F44 ; void __thiscall CBenchRandomGenerator::GenerateSimpleRandom(CBenchRandomGenerator *__hidden this)
.text:00009F44                 public ?GenerateSimpleRandom@CBenchRandomGenerator@@QAEXXZ
.text:00009F44 ?GenerateSimpleRandom@CBenchRandomGenerator@@QAEXXZ proc near
.text:00009F44                                         ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+ACp
.text:00009F44
.text:00009F44 var_8           = dword ptr -8
.text:00009F44 var_4           = dword ptr -4
.text:00009F44
.text:00009F44                 push    ebp
.text:00009F45                 mov     ebp, esp
.text:00009F47                 sub     esp, 8
.text:00009F4A                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00009F51                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00009F58                 mov     [ebp+var_4], ecx
.text:00009F5B                 mov     [ebp+var_8], 0
.text:00009F62                 jmp     short loc_9F6D
.text:00009F64 ; ---------------------------------------------------------------------------
.text:00009F64
.text:00009F64 loc_9F64:                               ; CODE XREF: CBenchRandomGenerator::GenerateSimpleRandom(void)+4Bj
.text:00009F64                 mov     eax, [ebp+var_8]
.text:00009F67                 add     eax, 1
.text:00009F6A                 mov     [ebp+var_8], eax
.text:00009F6D
.text:00009F6D loc_9F6D:                               ; CODE XREF: CBenchRandomGenerator::GenerateSimpleRandom(void)+1Ej
.text:00009F6D                 mov     ecx, [ebp+var_4]
.text:00009F70                 mov     edx, [ebp+var_8]
.text:00009F73                 cmp     edx, [ecx+4]
.text:00009F76                 jnb     short loc_9F91
.text:00009F78                 mov     eax, [ebp+var_4]
.text:00009F7B                 mov     ecx, [eax+0Ch]  ; this
.text:00009F7E                 call    ?GetRnd@CBaseRandomGenerator@@QAEIXZ ; CBaseRandomGenerator::GetRnd(void)
.text:00009F83                 mov     ecx, [ebp+var_4]
.text:00009F86                 mov     edx, [ecx+8]
.text:00009F89                 mov     ecx, [ebp+var_8]
.text:00009F8C                 mov     [edx+ecx], al
.text:00009F8F                 jmp     short loc_9F64
.text:00009F91 ; ---------------------------------------------------------------------------
.text:00009F91
.text:00009F91 loc_9F91:                               ; CODE XREF: CBenchRandomGenerator::GenerateSimpleRandom(void)+32j
.text:00009F91                 add     esp, 8
.text:00009F94                 cmp     ebp, esp
.text:00009F96                 call    __RTC_CheckEsp
.text:00009F9B                 mov     esp, ebp
.text:00009F9D                 pop     ebp
.text:00009F9E                 retn
.text:00009F9E ?GenerateSimpleRandom@CBenchRandomGenerator@@QAEXXZ endp
.text:00009F9E
.text:00009F9E ; ---------------------------------------------------------------------------
.text:00009F9F                 align 10h
.text:00009F9F _text           ends
.text:00009F9F
.text:00009FA0 ; ===========================================================================
.text:00009FA0
.text:00009FA0 ; Segment type: Pure code
.text:00009FA0 ; Segment permissions: Read/Execute
.text:00009FA0 _text           segment para public 'CODE' use32
.text:00009FA0                 assume cs:_text
.text:00009FA0                 ;org 9FA0h
.text:00009FA0 ; COMDAT (pick any)
.text:00009FA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009FA0
.text:00009FA0 ; =============== S U B R O U T I N E =======================================
.text:00009FA0
.text:00009FA0 ; Attributes: bp-based frame
.text:00009FA0
.text:00009FA0 ; unsigned int __thiscall CBaseRandomGenerator::GetRnd(CBaseRandomGenerator *__hidden this)
.text:00009FA0                 public ?GetRnd@CBaseRandomGenerator@@QAEIXZ
.text:00009FA0 ?GetRnd@CBaseRandomGenerator@@QAEIXZ proc near
.text:00009FA0                                         ; CODE XREF: RandGen(uchar *,uint,CBaseRandomGenerator &)+28p
.text:00009FA0                                         ; CBenchRandomGenerator::GenerateSimpleRandom(void)+3Ap ...
.text:00009FA0
.text:00009FA0 var_8           = dword ptr -8
.text:00009FA0 var_4           = dword ptr -4
.text:00009FA0
.text:00009FA0                 push    ebp
.text:00009FA1                 mov     ebp, esp
.text:00009FA3                 sub     esp, 8
.text:00009FA6                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00009FAD                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00009FB4                 mov     [ebp+var_4], ecx
.text:00009FB7                 mov     eax, [ebp+var_4]
.text:00009FBA                 mov     ecx, [eax]
.text:00009FBC                 and     ecx, 0FFFFh
.text:00009FC2                 imul    ecx, 9069h
.text:00009FC8                 mov     edx, [ebp+var_4]
.text:00009FCB                 mov     eax, [edx]
.text:00009FCD                 shr     eax, 10h
.text:00009FD0                 add     ecx, eax
.text:00009FD2                 mov     edx, [ebp+var_4]
.text:00009FD5                 mov     [edx], ecx
.text:00009FD7                 mov     eax, [ebp+var_4]
.text:00009FDA                 mov     ecx, [eax+4]
.text:00009FDD                 and     ecx, 0FFFFh
.text:00009FE3                 imul    ecx, 4650h
.text:00009FE9                 mov     edx, [ebp+var_4]
.text:00009FEC                 mov     eax, [edx+4]
.text:00009FEF                 shr     eax, 10h
.text:00009FF2                 add     ecx, eax
.text:00009FF4                 mov     [ebp+var_8], ecx
.text:00009FF7                 mov     ecx, [ebp+var_4]
.text:00009FFA                 mov     edx, [ebp+var_8]
.text:00009FFD                 mov     [ecx+4], edx
.text:0000A000                 mov     eax, [ebp+var_4]
.text:0000A003                 mov     eax, [eax]
.text:0000A005                 shl     eax, 10h
.text:0000A008                 add     eax, [ebp+var_8]
.text:0000A00B                 mov     esp, ebp
.text:0000A00D                 pop     ebp
.text:0000A00E                 retn
.text:0000A00E ?GetRnd@CBaseRandomGenerator@@QAEIXZ endp
.text:0000A00E
.text:0000A00E ; ---------------------------------------------------------------------------
.text:0000A00F                 align 10h
.text:0000A00F _text           ends
.text:0000A00F
.text:0000A010 ; ===========================================================================
.text:0000A010
.text:0000A010 ; Segment type: Pure code
.text:0000A010 ; Segment permissions: Read/Execute
.text:0000A010 _text           segment para public 'CODE' use32
.text:0000A010                 assume cs:_text
.text:0000A010                 ;org 0A010h
.text:0000A010 ; COMDAT (pick any)
.text:0000A010                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A010
.text:0000A010 ; =============== S U B R O U T I N E =======================================
.text:0000A010
.text:0000A010 ; Attributes: bp-based frame
.text:0000A010
.text:0000A010 ; void __thiscall CBenchRandomGenerator::Generate(CBenchRandomGenerator *this, unsigned int)
.text:0000A010                 public ?Generate@CBenchRandomGenerator@@QAEXI@Z
.text:0000A010 ?Generate@CBenchRandomGenerator@@QAEXI@Z proc near
.text:0000A010                                         ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+C0p
.text:0000A010
.text:0000A010 var_24          = dword ptr -24h
.text:0000A010 var_20          = dword ptr -20h
.text:0000A010 var_1C          = dword ptr -1Ch
.text:0000A010 var_18          = dword ptr -18h
.text:0000A010 var_14          = dword ptr -14h
.text:0000A010 var_10          = dword ptr -10h
.text:0000A010 var_C           = dword ptr -0Ch
.text:0000A010 var_8           = dword ptr -8
.text:0000A010 var_4           = dword ptr -4
.text:0000A010 arg_0           = dword ptr  8
.text:0000A010
.text:0000A010                 push    ebp
.text:0000A011                 mov     ebp, esp
.text:0000A013                 sub     esp, 24h
.text:0000A016                 push    esi
.text:0000A017                 mov     eax, 0CCCCCCCCh
.text:0000A01C                 mov     [ebp+var_24], eax
.text:0000A01F                 mov     [ebp+var_20], eax
.text:0000A022                 mov     [ebp+var_1C], eax
.text:0000A025                 mov     [ebp+var_18], eax
.text:0000A028                 mov     [ebp+var_14], eax
.text:0000A02B                 mov     [ebp+var_10], eax
.text:0000A02E                 mov     [ebp+var_C], eax
.text:0000A031                 mov     [ebp+var_8], eax
.text:0000A034                 mov     [ebp+var_4], eax
.text:0000A037                 mov     [ebp+var_4], ecx
.text:0000A03A                 mov     [ebp+var_8], 0
.text:0000A041                 mov     [ebp+var_C], 1
.text:0000A048
.text:0000A048 loc_A048:                               ; CODE XREF: CBenchRandomGenerator::Generate(uint):loc_A18Aj
.text:0000A048                 mov     eax, [ebp+var_4]
.text:0000A04B                 mov     ecx, [ebp+var_8]
.text:0000A04E                 cmp     ecx, [eax+4]
.text:0000A051                 jnb     loc_A18F
.text:0000A057                 mov     edx, [ebp+var_4]
.text:0000A05A                 mov     ecx, [edx+0Ch]  ; this
.text:0000A05D                 call    ?GetRnd@CBaseRandomGenerator@@QAEIXZ ; CBaseRandomGenerator::GetRnd(void)
.text:0000A062                 mov     [ebp+var_14], eax
.text:0000A065                 mov     eax, [ebp+var_14]
.text:0000A068                 shr     eax, 1
.text:0000A06A                 mov     [ebp+var_14], eax
.text:0000A06D                 push    1               ; unsigned int
.text:0000A06F                 lea     ecx, [ebp+var_14]
.text:0000A072                 push    ecx             ; unsigned int *
.text:0000A073                 mov     ecx, [ebp+var_4] ; this
.text:0000A076                 call    ?GetVal@CBenchRandomGenerator@@QAEIAAII@Z ; CBenchRandomGenerator::GetVal(uint &,uint)
.text:0000A07B                 test    eax, eax
.text:0000A07D                 jz      short loc_A088
.text:0000A07F                 cmp     [ebp+var_8], 400h
.text:0000A086                 jnb     short loc_A0AB
.text:0000A088
.text:0000A088 loc_A088:                               ; CODE XREF: CBenchRandomGenerator::Generate(uint)+6Dj
.text:0000A088                 mov     edx, [ebp+var_14]
.text:0000A08B                 and     edx, 0FFh
.text:0000A091                 mov     eax, [ebp+var_4]
.text:0000A094                 mov     ecx, [eax+8]
.text:0000A097                 mov     eax, [ebp+var_8]
.text:0000A09A                 mov     [ecx+eax], dl
.text:0000A09D                 mov     ecx, [ebp+var_8]
.text:0000A0A0                 add     ecx, 1
.text:0000A0A3                 mov     [ebp+var_8], ecx
.text:0000A0A6                 jmp     loc_A18A
.text:0000A0AB ; ---------------------------------------------------------------------------
.text:0000A0AB
.text:0000A0AB loc_A0AB:                               ; CODE XREF: CBenchRandomGenerator::Generate(uint)+76j
.text:0000A0AB                 lea     edx, [ebp+var_14]
.text:0000A0AE                 push    edx             ; unsigned int *
.text:0000A0AF                 mov     ecx, [ebp+var_4] ; this
.text:0000A0B2                 call    ?GetLen@CBenchRandomGenerator@@QAEIAAI@Z ; CBenchRandomGenerator::GetLen(uint &)
.text:0000A0B7                 add     eax, 1
.text:0000A0BA                 mov     [ebp+var_1C], eax
.text:0000A0BD                 push    3               ; unsigned int
.text:0000A0BF                 lea     eax, [ebp+var_14]
.text:0000A0C2                 push    eax             ; unsigned int *
.text:0000A0C3                 mov     ecx, [ebp+var_4] ; this
.text:0000A0C6                 call    ?GetVal@CBenchRandomGenerator@@QAEIAAII@Z ; CBenchRandomGenerator::GetVal(uint &,uint)
.text:0000A0CB                 test    eax, eax
.text:0000A0CD                 jz      short loc_A13F
.text:0000A0CF                 lea     ecx, [ebp+var_14]
.text:0000A0D2                 push    ecx             ; unsigned int *
.text:0000A0D3                 mov     ecx, [ebp+var_4] ; this
.text:0000A0D6                 call    ?GetLen@CBenchRandomGenerator@@QAEIAAI@Z ; CBenchRandomGenerator::GetLen(uint &)
.text:0000A0DB                 add     eax, [ebp+var_1C]
.text:0000A0DE                 mov     [ebp+var_1C], eax
.text:0000A0E1
.text:0000A0E1 loc_A0E1:                               ; CODE XREF: CBenchRandomGenerator::Generate(uint)+124j
.text:0000A0E1                 push    5               ; unsigned int
.text:0000A0E3                 lea     edx, [ebp+var_14]
.text:0000A0E6                 push    edx             ; unsigned int *
.text:0000A0E7                 mov     ecx, [ebp+var_4] ; this
.text:0000A0EA                 call    ?GetVal@CBenchRandomGenerator@@QAEIAAII@Z ; CBenchRandomGenerator::GetVal(uint &,uint)
.text:0000A0EF                 add     eax, 6
.text:0000A0F2                 mov     [ebp+var_20], eax
.text:0000A0F5                 mov     eax, [ebp+var_4]
.text:0000A0F8                 mov     ecx, [eax+0Ch]  ; this
.text:0000A0FB                 call    ?GetRnd@CBaseRandomGenerator@@QAEIXZ ; CBaseRandomGenerator::GetRnd(void)
.text:0000A100                 mov     [ebp+var_14], eax
.text:0000A103                 mov     ecx, [ebp+var_20]
.text:0000A106                 cmp     ecx, [ebp+arg_0]
.text:0000A109                 jbe     short loc_A10D
.text:0000A10B                 jmp     short loc_A12E
.text:0000A10D ; ---------------------------------------------------------------------------
.text:0000A10D
.text:0000A10D loc_A10D:                               ; CODE XREF: CBenchRandomGenerator::Generate(uint)+F9j
.text:0000A10D                 mov     edx, [ebp+var_20]
.text:0000A110                 push    edx             ; unsigned int
.text:0000A111                 lea     eax, [ebp+var_14]
.text:0000A114                 push    eax             ; unsigned int *
.text:0000A115                 mov     ecx, [ebp+var_4] ; this
.text:0000A118                 call    ?GetVal@CBenchRandomGenerator@@QAEIAAII@Z ; CBenchRandomGenerator::GetVal(uint &,uint)
.text:0000A11D                 mov     [ebp+var_C], eax
.text:0000A120                 mov     ecx, [ebp+var_4]
.text:0000A123                 mov     ecx, [ecx+0Ch]  ; this
.text:0000A126                 call    ?GetRnd@CBaseRandomGenerator@@QAEIXZ ; CBaseRandomGenerator::GetRnd(void)
.text:0000A12B                 mov     [ebp+var_14], eax
.text:0000A12E
.text:0000A12E loc_A12E:                               ; CODE XREF: CBenchRandomGenerator::Generate(uint)+FBj
.text:0000A12E                 mov     edx, [ebp+var_C]
.text:0000A131                 cmp     edx, [ebp+var_8]
.text:0000A134                 jnb     short loc_A0E1
.text:0000A136                 mov     eax, [ebp+var_C]
.text:0000A139                 add     eax, 1
.text:0000A13C                 mov     [ebp+var_C], eax
.text:0000A13F
.text:0000A13F loc_A13F:                               ; CODE XREF: CBenchRandomGenerator::Generate(uint)+BDj
.text:0000A13F                 mov     [ebp+var_24], 0
.text:0000A146                 jmp     short loc_A15A
.text:0000A148 ; ---------------------------------------------------------------------------
.text:0000A148
.text:0000A148 loc_A148:                               ; CODE XREF: CBenchRandomGenerator::Generate(uint)+178j
.text:0000A148                 mov     ecx, [ebp+var_24]
.text:0000A14B                 add     ecx, 1
.text:0000A14E                 mov     [ebp+var_24], ecx
.text:0000A151                 mov     edx, [ebp+var_8]
.text:0000A154                 add     edx, 1
.text:0000A157                 mov     [ebp+var_8], edx
.text:0000A15A
.text:0000A15A loc_A15A:                               ; CODE XREF: CBenchRandomGenerator::Generate(uint)+136j
.text:0000A15A                 mov     eax, [ebp+var_24]
.text:0000A15D                 cmp     eax, [ebp+var_1C]
.text:0000A160                 jnb     short loc_A18A
.text:0000A162                 mov     ecx, [ebp+var_4]
.text:0000A165                 mov     edx, [ebp+var_8]
.text:0000A168                 cmp     edx, [ecx+4]
.text:0000A16B                 jnb     short loc_A18A
.text:0000A16D                 mov     eax, [ebp+var_8]
.text:0000A170                 sub     eax, [ebp+var_C]
.text:0000A173                 mov     ecx, [ebp+var_4]
.text:0000A176                 mov     edx, [ecx+8]
.text:0000A179                 mov     ecx, [ebp+var_4]
.text:0000A17C                 mov     ecx, [ecx+8]
.text:0000A17F                 mov     esi, [ebp+var_8]
.text:0000A182                 mov     dl, [eax+edx]
.text:0000A185                 mov     [ecx+esi], dl
.text:0000A188                 jmp     short loc_A148
.text:0000A18A ; ---------------------------------------------------------------------------
.text:0000A18A
.text:0000A18A loc_A18A:                               ; CODE XREF: CBenchRandomGenerator::Generate(uint)+96j
.text:0000A18A                                         ; CBenchRandomGenerator::Generate(uint)+150j ...
.text:0000A18A                 jmp     loc_A048
.text:0000A18F ; ---------------------------------------------------------------------------
.text:0000A18F
.text:0000A18F loc_A18F:                               ; CODE XREF: CBenchRandomGenerator::Generate(uint)+41j
.text:0000A18F                 push    edx
.text:0000A190                 mov     ecx, ebp
.text:0000A192                 push    eax
.text:0000A193                 lea     edx, $LN18
.text:0000A199                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:0000A19E                 pop     eax
.text:0000A19F                 pop     edx
.text:0000A1A0                 pop     esi
.text:0000A1A1                 add     esp, 24h
.text:0000A1A4                 cmp     ebp, esp
.text:0000A1A6                 call    __RTC_CheckEsp
.text:0000A1AB                 mov     esp, ebp
.text:0000A1AD                 pop     ebp
.text:0000A1AE                 retn    4
.text:0000A1AE ?Generate@CBenchRandomGenerator@@QAEXI@Z endp
.text:0000A1AE
.text:0000A1AE ; ---------------------------------------------------------------------------
.text:0000A1B1                 align 4
.text:0000A1B4 $LN18           dd 1                    ; DATA XREF: CBenchRandomGenerator::Generate(uint)+183o
.text:0000A1B8                 dd offset $LN17
.text:0000A1BC $LN17           dd 0FFFFFFECh, 4        ; DATA XREF: .text:0000A1B8o
.text:0000A1C4                 dd offset $LN16
.text:0000A1C8 $LN16           dd 736572h              ; DATA XREF: .text:0000A1C4o
.text:0000A1C8 _text           ends
.text:0000A1C8
.text:0000A1CC ; ===========================================================================
.text:0000A1CC
.text:0000A1CC ; Segment type: Pure code
.text:0000A1CC ; Segment permissions: Read/Execute
.text:0000A1CC _text           segment para public 'CODE' use32
.text:0000A1CC                 assume cs:_text
.text:0000A1CC                 ;org 0A1CCh
.text:0000A1CC ; COMDAT (pick any)
.text:0000A1CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A1CC
.text:0000A1CC ; =============== S U B R O U T I N E =======================================
.text:0000A1CC
.text:0000A1CC ; Attributes: bp-based frame
.text:0000A1CC
.text:0000A1CC ; unsigned int __thiscall CBenchRandomGenerator::GetVal(CBenchRandomGenerator *this, unsigned int *, unsigned int)
.text:0000A1CC                 public ?GetVal@CBenchRandomGenerator@@QAEIAAII@Z
.text:0000A1CC ?GetVal@CBenchRandomGenerator@@QAEIAAII@Z proc near
.text:0000A1CC                                         ; CODE XREF: CBenchRandomGenerator::Generate(uint)+66p
.text:0000A1CC                                         ; CBenchRandomGenerator::Generate(uint)+B6p ...
.text:0000A1CC
.text:0000A1CC var_8           = dword ptr -8
.text:0000A1CC var_4           = dword ptr -4
.text:0000A1CC arg_0           = dword ptr  8
.text:0000A1CC arg_4           = dword ptr  0Ch
.text:0000A1CC
.text:0000A1CC                 push    ebp
.text:0000A1CD                 mov     ebp, esp
.text:0000A1CF                 sub     esp, 8
.text:0000A1D2                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000A1D9                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A1E0                 mov     [ebp+var_4], ecx
.text:0000A1E3                 mov     eax, 1
.text:0000A1E8                 mov     ecx, [ebp+arg_4]
.text:0000A1EB                 shl     eax, cl
.text:0000A1ED                 sub     eax, 1
.text:0000A1F0                 mov     ecx, [ebp+arg_0]
.text:0000A1F3                 and     eax, [ecx]
.text:0000A1F5                 mov     [ebp+var_8], eax
.text:0000A1F8                 mov     edx, [ebp+arg_0]
.text:0000A1FB                 mov     eax, [edx]
.text:0000A1FD                 mov     ecx, [ebp+arg_4]
.text:0000A200                 shr     eax, cl
.text:0000A202                 mov     ecx, [ebp+arg_0]
.text:0000A205                 mov     [ecx], eax
.text:0000A207                 mov     eax, [ebp+var_8]
.text:0000A20A                 mov     esp, ebp
.text:0000A20C                 pop     ebp
.text:0000A20D                 retn    8
.text:0000A20D ?GetVal@CBenchRandomGenerator@@QAEIAAII@Z endp
.text:0000A20D
.text:0000A20D _text           ends
.text:0000A20D
.text:0000A210 ; ===========================================================================
.text:0000A210
.text:0000A210 ; Segment type: Pure code
.text:0000A210 ; Segment permissions: Read/Execute
.text:0000A210 _text           segment para public 'CODE' use32
.text:0000A210                 assume cs:_text
.text:0000A210                 ;org 0A210h
.text:0000A210 ; COMDAT (pick any)
.text:0000A210                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A210
.text:0000A210 ; =============== S U B R O U T I N E =======================================
.text:0000A210
.text:0000A210 ; Attributes: bp-based frame
.text:0000A210
.text:0000A210 ; unsigned int __thiscall CBenchRandomGenerator::GetLen(CBenchRandomGenerator *this, unsigned int *)
.text:0000A210                 public ?GetLen@CBenchRandomGenerator@@QAEIAAI@Z
.text:0000A210 ?GetLen@CBenchRandomGenerator@@QAEIAAI@Z proc near
.text:0000A210                                         ; CODE XREF: CBenchRandomGenerator::Generate(uint)+A2p
.text:0000A210                                         ; CBenchRandomGenerator::Generate(uint)+C6p
.text:0000A210
.text:0000A210 var_8           = dword ptr -8
.text:0000A210 var_4           = dword ptr -4
.text:0000A210 arg_0           = dword ptr  8
.text:0000A210
.text:0000A210                 push    ebp
.text:0000A211                 mov     ebp, esp
.text:0000A213                 sub     esp, 8
.text:0000A216                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000A21D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A224                 mov     [ebp+var_4], ecx
.text:0000A227                 push    2               ; unsigned int
.text:0000A229                 mov     eax, [ebp+arg_0]
.text:0000A22C                 push    eax             ; unsigned int *
.text:0000A22D                 mov     ecx, [ebp+var_4] ; this
.text:0000A230                 call    ?GetVal@CBenchRandomGenerator@@QAEIAAII@Z ; CBenchRandomGenerator::GetVal(uint &,uint)
.text:0000A235                 mov     [ebp+var_8], eax
.text:0000A238                 mov     ecx, [ebp+var_8]
.text:0000A23B                 add     ecx, 1
.text:0000A23E                 push    ecx             ; unsigned int
.text:0000A23F                 mov     edx, [ebp+arg_0]
.text:0000A242                 push    edx             ; unsigned int *
.text:0000A243                 mov     ecx, [ebp+var_4] ; this
.text:0000A246                 call    ?GetVal@CBenchRandomGenerator@@QAEIAAII@Z ; CBenchRandomGenerator::GetVal(uint &,uint)
.text:0000A24B                 add     esp, 8
.text:0000A24E                 cmp     ebp, esp
.text:0000A250                 call    __RTC_CheckEsp
.text:0000A255                 mov     esp, ebp
.text:0000A257                 pop     ebp
.text:0000A258                 retn    4
.text:0000A258 ?GetLen@CBenchRandomGenerator@@QAEIAAI@Z endp
.text:0000A258
.text:0000A258 ; ---------------------------------------------------------------------------
.text:0000A25B                 align 4
.text:0000A25B _text           ends
.text:0000A25B
.text:0000A25C ; ===========================================================================
.text:0000A25C
.text:0000A25C ; Segment type: Pure code
.text:0000A25C ; Segment permissions: Read/Execute
.text:0000A25C _text           segment para public 'CODE' use32
.text:0000A25C                 assume cs:_text
.text:0000A25C                 ;org 0A25Ch
.text:0000A25C ; COMDAT (pick any)
.text:0000A25C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A25C
.text:0000A25C ; =============== S U B R O U T I N E =======================================
.text:0000A25C
.text:0000A25C ; Attributes: bp-based frame
.text:0000A25C
.text:0000A25C ; void __thiscall CBenchmarkInStream::Init(CBenchmarkInStream *this, const unsigned __int8 *, unsigned int)
.text:0000A25C                 public ?Init@CBenchmarkInStream@@QAEXPBEI@Z
.text:0000A25C ?Init@CBenchmarkInStream@@QAEXPBEI@Z proc near
.text:0000A25C                                         ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+57Cp
.text:0000A25C                                         ; CEncoderInfo::Encode(void)+54Ap ...
.text:0000A25C
.text:0000A25C var_4           = dword ptr -4
.text:0000A25C arg_0           = dword ptr  8
.text:0000A25C arg_4           = dword ptr  0Ch
.text:0000A25C
.text:0000A25C                 push    ebp
.text:0000A25D                 mov     ebp, esp
.text:0000A25F                 push    ecx
.text:0000A260                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A267                 mov     [ebp+var_4], ecx
.text:0000A26A                 mov     eax, [ebp+var_4]
.text:0000A26D                 mov     ecx, [ebp+arg_0]
.text:0000A270                 mov     [eax+8], ecx
.text:0000A273                 mov     edx, [ebp+var_4]
.text:0000A276                 mov     eax, [ebp+arg_4]
.text:0000A279                 mov     [edx+10h], eax
.text:0000A27C                 mov     ecx, [ebp+var_4]
.text:0000A27F                 mov     dword ptr [ecx+0Ch], 0
.text:0000A286                 mov     esp, ebp
.text:0000A288                 pop     ebp
.text:0000A289                 retn    8
.text:0000A289 ?Init@CBenchmarkInStream@@QAEXPBEI@Z endp
.text:0000A289
.text:0000A289 _text           ends
.text:0000A289
.text:0000A28C ; ===========================================================================
.text:0000A28C
.text:0000A28C ; Segment type: Pure code
.text:0000A28C ; Segment permissions: Read/Execute
.text:0000A28C _text           segment para public 'CODE' use32
.text:0000A28C                 assume cs:_text
.text:0000A28C                 ;org 0A28Ch
.text:0000A28C ; COMDAT (pick any)
.text:0000A28C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A28C
.text:0000A28C ; =============== S U B R O U T I N E =======================================
.text:0000A28C
.text:0000A28C ; Attributes: bp-based frame
.text:0000A28C
.text:0000A28C ; void __thiscall CBenchmarkOutStream::Init(CBenchmarkOutStream *this, bool, bool)
.text:0000A28C                 public ?Init@CBenchmarkOutStream@@QAEX_N0@Z
.text:0000A28C ?Init@CBenchmarkOutStream@@QAEX_N0@Z proc near
.text:0000A28C                                         ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+284p
.text:0000A28C                                         ; CEncoderInfo::Encode(void)+414p
.text:0000A28C
.text:0000A28C var_4           = dword ptr -4
.text:0000A28C arg_0           = byte ptr  8
.text:0000A28C arg_4           = byte ptr  0Ch
.text:0000A28C
.text:0000A28C                 push    ebp
.text:0000A28D                 mov     ebp, esp
.text:0000A28F                 push    ecx
.text:0000A290                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A297                 mov     [ebp+var_4], ecx
.text:0000A29A                 mov     eax, [ebp+var_4]
.text:0000A29D                 mov     dword ptr [eax+1Ch], 0FFFFFFFFh
.text:0000A2A4                 mov     ecx, [ebp+var_4]
.text:0000A2A7                 mov     dl, [ebp+arg_0]
.text:0000A2AA                 mov     [ecx+18h], dl
.text:0000A2AD                 mov     eax, [ebp+var_4]
.text:0000A2B0                 mov     cl, [ebp+arg_4]
.text:0000A2B3                 mov     [eax+19h], cl
.text:0000A2B6                 mov     edx, [ebp+var_4]
.text:0000A2B9                 mov     dword ptr [edx+14h], 0
.text:0000A2C0                 mov     esp, ebp
.text:0000A2C2                 pop     ebp
.text:0000A2C3                 retn    8
.text:0000A2C3 ?Init@CBenchmarkOutStream@@QAEX_N0@Z endp
.text:0000A2C3
.text:0000A2C3 ; ---------------------------------------------------------------------------
.text:0000A2C6                 align 4
.text:0000A2C6 _text           ends
.text:0000A2C6
.text:0000A2C8 ; ===========================================================================
.text:0000A2C8
.text:0000A2C8 ; Segment type: Pure code
.text:0000A2C8 ; Segment permissions: Read/Execute
.text:0000A2C8 _text           segment para public 'CODE' use32
.text:0000A2C8                 assume cs:_text
.text:0000A2C8                 ;org 0A2C8h
.text:0000A2C8 ; COMDAT (pick any)
.text:0000A2C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A2C8
.text:0000A2C8 ; =============== S U B R O U T I N E =======================================
.text:0000A2C8
.text:0000A2C8 ; Attributes: bp-based frame
.text:0000A2C8
.text:0000A2C8 ; public: __thiscall CCrcOutStream::CCrcOutStream(void)
.text:0000A2C8                 public ??0CCrcOutStream@@QAE@XZ
.text:0000A2C8 ??0CCrcOutStream@@QAE@XZ proc near      ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+5A4p
.text:0000A2C8                                         ; CEncoderInfo::Decode(uint)+1DAp
.text:0000A2C8
.text:0000A2C8 var_4           = dword ptr -4
.text:0000A2C8
.text:0000A2C8                 push    ebp
.text:0000A2C9                 mov     ebp, esp
.text:0000A2CB                 push    ecx
.text:0000A2CC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A2D3                 mov     [ebp+var_4], ecx
.text:0000A2D6                 mov     ecx, [ebp+var_4] ; this
.text:0000A2D9                 call    ??0ISequentialOutStream@@QAE@XZ ; ISequentialOutStream::ISequentialOutStream(void)
.text:0000A2DE                 mov     ecx, [ebp+var_4]
.text:0000A2E1                 add     ecx, 4          ; this
.text:0000A2E4                 call    ??0CMyUnknownImp@@QAE@XZ ; CMyUnknownImp::CMyUnknownImp(void)
.text:0000A2E9                 mov     eax, [ebp+var_4]
.text:0000A2EC                 mov     dword ptr [eax], offset ??_7CCrcOutStream@@6B@ ; const CCrcOutStream::`vftable'
.text:0000A2F2                 mov     ecx, [ebp+var_4]
.text:0000A2F5                 mov     byte ptr [ecx+8], 1
.text:0000A2F9                 mov     eax, [ebp+var_4]
.text:0000A2FC                 add     esp, 4
.text:0000A2FF                 cmp     ebp, esp
.text:0000A301                 call    __RTC_CheckEsp
.text:0000A306                 mov     esp, ebp
.text:0000A308                 pop     ebp
.text:0000A309                 retn
.text:0000A309 ??0CCrcOutStream@@QAE@XZ endp
.text:0000A309
.text:0000A309 ; ---------------------------------------------------------------------------
.text:0000A30A                 align 4
.text:0000A30A _text           ends
.text:0000A30A
.rdata:0000A30C ; ===========================================================================
.rdata:0000A30C
.rdata:0000A30C ; Segment type: Pure data
.rdata:0000A30C ; Segment permissions: Read
.rdata:0000A30C _rdata          segment dword public 'DATA' use32
.rdata:0000A30C                 assume cs:_rdata
.rdata:0000A30C                 ;org 0A30Ch
.rdata:0000A30C ; COMDAT (pick largest)
.rdata:0000A30C                 dd offset ??_R4CCrcOutStream@@6B@ ; const CCrcOutStream::`RTTI Complete Object Locator'
.rdata:0000A310                 public ??_7CCrcOutStream@@6B@
.rdata:0000A310 ; const CCrcOutStream::`vftable'
.rdata:0000A310 ??_7CCrcOutStream@@6B@ dd offset ?QueryInterface@CCrcOutStream@@UAGJABU_GUID@@PAPAX@Z
.rdata:0000A310                                         ; DATA XREF: CCrcOutStream::CCrcOutStream(void)+24o
.rdata:0000A310                                         ; CCrcOutStream::QueryInterface(_GUID const &,void * *)
.rdata:0000A314                 dd offset ?AddRef@CCrcOutStream@@UAGKXZ ; CCrcOutStream::AddRef(void)
.rdata:0000A318                 dd offset ?Release@CCrcOutStream@@UAGKXZ ; CCrcOutStream::Release(void)
.rdata:0000A31C                 dd offset ?Write@CCrcOutStream@@UAGJPBXIPAI@Z ; CCrcOutStream::Write(void const *,uint,uint *)
.rdata:0000A31C _rdata          ends
.rdata:0000A31C
.rdata$r:0000A320 ; ===========================================================================
.rdata$r:0000A320
.rdata$r:0000A320 ; Segment type: Pure data
.rdata$r:0000A320 ; Segment permissions: Read
.rdata$r:0000A320 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A320                 assume cs:_rdata$r
.rdata$r:0000A320                 ;org 0A320h
.rdata$r:0000A320 ; COMDAT (pick any)
.rdata$r:0000A320                 public ??_R4CCrcOutStream@@6B@
.rdata$r:0000A320 ; const CCrcOutStream::`RTTI Complete Object Locator'
.rdata$r:0000A320 ??_R4CCrcOutStream@@6B@ db    0         ; DATA XREF: .rdata:0000A30Co
.rdata$r:0000A321                 db    0
.rdata$r:0000A322                 db    0
.rdata$r:0000A323                 db    0
.rdata$r:0000A324                 db    0
.rdata$r:0000A325                 db    0
.rdata$r:0000A326                 db    0
.rdata$r:0000A327                 db    0
.rdata$r:0000A328                 db    0
.rdata$r:0000A329                 db    0
.rdata$r:0000A32A                 db    0
.rdata$r:0000A32B                 db    0
.rdata$r:0000A32C                 dd offset ??_R0?AVCCrcOutStream@@@8 ; CCrcOutStream `RTTI Type Descriptor'
.rdata$r:0000A330                 dd offset ??_R3CCrcOutStream@@8 ; CCrcOutStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000A330 _rdata$r        ends
.rdata$r:0000A330
.data:0000A334 ; ===========================================================================
.data:0000A334
.data:0000A334 ; Segment type: Pure data
.data:0000A334 ; Segment permissions: Read/Write
.data:0000A334 _data           segment dword public 'DATA' use32
.data:0000A334                 assume cs:_data
.data:0000A334                 ;org 0A334h
.data:0000A334 ; COMDAT (pick any)
.data:0000A334                 public ??_R0?AVCCrcOutStream@@@8
.data:0000A334 ; class CCrcOutStream `RTTI Type Descriptor'
.data:0000A334 ??_R0?AVCCrcOutStream@@@8 dd offset ??_7type_info@@6B@
.data:0000A334                                         ; DATA XREF: .rdata$r:0000A32Co
.data:0000A334                                         ; .rdata$r:CCrcOutStream::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:0000A334                                         ; const type_info::`vftable'
.data:0000A338                 db    0
.data:0000A339                 db    0
.data:0000A33A                 db    0
.data:0000A33B                 db    0
.data:0000A33C                 db  2Eh ; .
.data:0000A33D                 db  3Fh ; ?
.data:0000A33E                 db  41h ; A
.data:0000A33F                 db  56h ; V
.data:0000A340                 db  43h ; C
.data:0000A341                 db  43h ; C
.data:0000A342                 db  72h ; r
.data:0000A343                 db  63h ; c
.data:0000A344                 db  4Fh ; O
.data:0000A345                 db  75h ; u
.data:0000A346                 db  74h ; t
.data:0000A347                 db  53h ; S
.data:0000A348                 db  74h ; t
.data:0000A349                 db  72h ; r
.data:0000A34A                 db  65h ; e
.data:0000A34B                 db  61h ; a
.data:0000A34C                 db  6Dh ; m
.data:0000A34D                 db  40h ; @
.data:0000A34E                 db  40h ; @
.data:0000A34F                 db    0
.data:0000A34F _data           ends
.data:0000A34F
.rdata$r:0000A350 ; ===========================================================================
.rdata$r:0000A350
.rdata$r:0000A350 ; Segment type: Pure data
.rdata$r:0000A350 ; Segment permissions: Read
.rdata$r:0000A350 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A350                 assume cs:_rdata$r
.rdata$r:0000A350                 ;org 0A350h
.rdata$r:0000A350 ; COMDAT (pick any)
.rdata$r:0000A350                 public ??_R3CCrcOutStream@@8
.rdata$r:0000A350 ; CCrcOutStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000A350 ??_R3CCrcOutStream@@8 db    0           ; DATA XREF: .rdata$r:0000A330o
.rdata$r:0000A350                                         ; .rdata$r:0000A38Co
.rdata$r:0000A351                 db    0
.rdata$r:0000A352                 db    0
.rdata$r:0000A353                 db    0
.rdata$r:0000A354                 db    1
.rdata$r:0000A355                 db    0
.rdata$r:0000A356                 db    0
.rdata$r:0000A357                 db    0
.rdata$r:0000A358                 db    4
.rdata$r:0000A359                 db    0
.rdata$r:0000A35A                 db    0
.rdata$r:0000A35B                 db    0
.rdata$r:0000A35C                 dd offset ??_R2CCrcOutStream@@8 ; CCrcOutStream::`RTTI Base Class Array'
.rdata$r:0000A35C _rdata$r        ends
.rdata$r:0000A35C
.rdata$r:0000A360 ; ===========================================================================
.rdata$r:0000A360
.rdata$r:0000A360 ; Segment type: Pure data
.rdata$r:0000A360 ; Segment permissions: Read
.rdata$r:0000A360 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A360                 assume cs:_rdata$r
.rdata$r:0000A360                 ;org 0A360h
.rdata$r:0000A360 ; COMDAT (pick any)
.rdata$r:0000A360                 public ??_R2CCrcOutStream@@8
.rdata$r:0000A360 ; CCrcOutStream::`RTTI Base Class Array'
.rdata$r:0000A360 ??_R2CCrcOutStream@@8 dd offset ??_R1A@?0A@EA@CCrcOutStream@@8
.rdata$r:0000A360                                         ; DATA XREF: .rdata$r:0000A35Co
.rdata$r:0000A360                                         ; CCrcOutStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000A364                 dd offset ??_R1A@?0A@EA@ISequentialOutStream@@8 ; ISequentialOutStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000A368                 dd offset ??_R1A@?0A@EA@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000A36C                 dd offset ??_R13?0A@EA@CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Base Class Descriptor at (4,-1,0,64)'
.rdata$r:0000A370                 db    0
.rdata$r:0000A371                 align 4
.rdata$r:0000A371 _rdata$r        ends
.rdata$r:0000A371
.rdata$r:0000A374 ; ===========================================================================
.rdata$r:0000A374
.rdata$r:0000A374 ; Segment type: Pure data
.rdata$r:0000A374 ; Segment permissions: Read
.rdata$r:0000A374 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A374                 assume cs:_rdata$r
.rdata$r:0000A374                 ;org 0A374h
.rdata$r:0000A374 ; COMDAT (pick any)
.rdata$r:0000A374                 public ??_R1A@?0A@EA@CCrcOutStream@@8
.rdata$r:0000A374 ; CCrcOutStream::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000A374 ??_R1A@?0A@EA@CCrcOutStream@@8 dd offset ??_R0?AVCCrcOutStream@@@8
.rdata$r:0000A374                                         ; DATA XREF: .rdata$r:CCrcOutStream::`RTTI Base Class Array'o
.rdata$r:0000A374                                         ; CCrcOutStream `RTTI Type Descriptor'
.rdata$r:0000A378                 db    3
.rdata$r:0000A379                 db    0
.rdata$r:0000A37A                 db    0
.rdata$r:0000A37B                 db    0
.rdata$r:0000A37C                 db    0
.rdata$r:0000A37D                 db    0
.rdata$r:0000A37E                 db    0
.rdata$r:0000A37F                 db    0
.rdata$r:0000A380                 db 0FFh
.rdata$r:0000A381                 db 0FFh
.rdata$r:0000A382                 db 0FFh
.rdata$r:0000A383                 db 0FFh
.rdata$r:0000A384                 db    0
.rdata$r:0000A385                 db    0
.rdata$r:0000A386                 db    0
.rdata$r:0000A387                 db    0
.rdata$r:0000A388                 db  40h ; @
.rdata$r:0000A389                 db    0
.rdata$r:0000A38A                 db    0
.rdata$r:0000A38B                 db    0
.rdata$r:0000A38C                 dd offset ??_R3CCrcOutStream@@8 ; CCrcOutStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000A38C _rdata$r        ends
.rdata$r:0000A38C
.rdata$r:0000A390 ; ===========================================================================
.rdata$r:0000A390
.rdata$r:0000A390 ; Segment type: Pure data
.rdata$r:0000A390 ; Segment permissions: Read
.rdata$r:0000A390 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A390                 assume cs:_rdata$r
.rdata$r:0000A390                 ;org 0A390h
.rdata$r:0000A390 ; COMDAT (pick any)
.rdata$r:0000A390                 public ??_R1A@?0A@EA@ISequentialOutStream@@8
.rdata$r:0000A390 ; ISequentialOutStream::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000A390 ??_R1A@?0A@EA@ISequentialOutStream@@8 dd offset ??_R0?AUISequentialOutStream@@@8
.rdata$r:0000A390                                         ; DATA XREF: .rdata$r:0000A364o
.rdata$r:0000A390                                         ; .rdata$r:ISequentialOutStream::`RTTI Base Class Array'o ...
.rdata$r:0000A390                                         ; ISequentialOutStream `RTTI Type Descriptor'
.rdata$r:0000A394                 db    1
.rdata$r:0000A395                 db    0
.rdata$r:0000A396                 db    0
.rdata$r:0000A397                 db    0
.rdata$r:0000A398                 db    0
.rdata$r:0000A399                 db    0
.rdata$r:0000A39A                 db    0
.rdata$r:0000A39B                 db    0
.rdata$r:0000A39C                 db 0FFh
.rdata$r:0000A39D                 db 0FFh
.rdata$r:0000A39E                 db 0FFh
.rdata$r:0000A39F                 db 0FFh
.rdata$r:0000A3A0                 db    0
.rdata$r:0000A3A1                 db    0
.rdata$r:0000A3A2                 db    0
.rdata$r:0000A3A3                 db    0
.rdata$r:0000A3A4                 db  40h ; @
.rdata$r:0000A3A5                 db    0
.rdata$r:0000A3A6                 db    0
.rdata$r:0000A3A7                 db    0
.rdata$r:0000A3A8                 dd offset ??_R3ISequentialOutStream@@8 ; ISequentialOutStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000A3A8 _rdata$r        ends
.rdata$r:0000A3A8
.data:0000A3AC ; ===========================================================================
.data:0000A3AC
.data:0000A3AC ; Segment type: Pure data
.data:0000A3AC ; Segment permissions: Read/Write
.data:0000A3AC _data           segment dword public 'DATA' use32
.data:0000A3AC                 assume cs:_data
.data:0000A3AC                 ;org 0A3ACh
.data:0000A3AC ; COMDAT (pick any)
.data:0000A3AC                 public ??_R0?AUISequentialOutStream@@@8
.data:0000A3AC ; struct ISequentialOutStream `RTTI Type Descriptor'
.data:0000A3AC ??_R0?AUISequentialOutStream@@@8 dd offset ??_7type_info@@6B@
.data:0000A3AC                                         ; DATA XREF: .rdata$r:ISequentialOutStream::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:0000A3AC                                         ; .rdata$r:0000A648o
.data:0000A3AC                                         ; const type_info::`vftable'
.data:0000A3B0                 db    0
.data:0000A3B1                 db    0
.data:0000A3B2                 db    0
.data:0000A3B3                 db    0
.data:0000A3B4                 db  2Eh ; .
.data:0000A3B5                 db  3Fh ; ?
.data:0000A3B6                 db  41h ; A
.data:0000A3B7                 db  55h ; U
.data:0000A3B8                 db  49h ; I
.data:0000A3B9                 db  53h ; S
.data:0000A3BA                 db  65h ; e
.data:0000A3BB                 db  71h ; q
.data:0000A3BC                 db  75h ; u
.data:0000A3BD                 db  65h ; e
.data:0000A3BE                 db  6Eh ; n
.data:0000A3BF                 db  74h ; t
.data:0000A3C0                 db  69h ; i
.data:0000A3C1                 db  61h ; a
.data:0000A3C2                 db  6Ch ; l
.data:0000A3C3                 db  4Fh ; O
.data:0000A3C4                 db  75h ; u
.data:0000A3C5                 db  74h ; t
.data:0000A3C6                 db  53h ; S
.data:0000A3C7                 db  74h ; t
.data:0000A3C8                 db  72h ; r
.data:0000A3C9                 db  65h ; e
.data:0000A3CA                 db  61h ; a
.data:0000A3CB                 db  6Dh ; m
.data:0000A3CC                 db  40h ; @
.data:0000A3CD                 db  40h ; @
.data:0000A3CE                 db    0
.data:0000A3CF                 align 10h
.data:0000A3CF _data           ends
.data:0000A3CF
.rdata$r:0000A3D0 ; ===========================================================================
.rdata$r:0000A3D0
.rdata$r:0000A3D0 ; Segment type: Pure data
.rdata$r:0000A3D0 ; Segment permissions: Read
.rdata$r:0000A3D0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A3D0                 assume cs:_rdata$r
.rdata$r:0000A3D0                 ;org 0A3D0h
.rdata$r:0000A3D0 ; COMDAT (pick any)
.rdata$r:0000A3D0                 public ??_R3ISequentialOutStream@@8
.rdata$r:0000A3D0 ; ISequentialOutStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000A3D0 ??_R3ISequentialOutStream@@8 db    0    ; DATA XREF: .rdata$r:0000A3A8o
.rdata$r:0000A3D0                                         ; .rdata$r:0000A64Co
.rdata$r:0000A3D1                 db    0
.rdata$r:0000A3D2                 db    0
.rdata$r:0000A3D3                 db    0
.rdata$r:0000A3D4                 db    0
.rdata$r:0000A3D5                 db    0
.rdata$r:0000A3D6                 db    0
.rdata$r:0000A3D7                 db    0
.rdata$r:0000A3D8                 db    2
.rdata$r:0000A3D9                 db    0
.rdata$r:0000A3DA                 db    0
.rdata$r:0000A3DB                 db    0
.rdata$r:0000A3DC                 dd offset ??_R2ISequentialOutStream@@8 ; ISequentialOutStream::`RTTI Base Class Array'
.rdata$r:0000A3DC _rdata$r        ends
.rdata$r:0000A3DC
.rdata$r:0000A3E0 ; ===========================================================================
.rdata$r:0000A3E0
.rdata$r:0000A3E0 ; Segment type: Pure data
.rdata$r:0000A3E0 ; Segment permissions: Read
.rdata$r:0000A3E0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A3E0                 assume cs:_rdata$r
.rdata$r:0000A3E0                 ;org 0A3E0h
.rdata$r:0000A3E0 ; COMDAT (pick any)
.rdata$r:0000A3E0                 public ??_R2ISequentialOutStream@@8
.rdata$r:0000A3E0 ; ISequentialOutStream::`RTTI Base Class Array'
.rdata$r:0000A3E0 ??_R2ISequentialOutStream@@8 dd offset ??_R1A@?0A@EA@ISequentialOutStream@@8
.rdata$r:0000A3E0                                         ; DATA XREF: .rdata$r:0000A3DCo
.rdata$r:0000A3E0                                         ; ISequentialOutStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000A3E4                 dd offset ??_R1A@?0A@EA@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000A3E8                 db    0
.rdata$r:0000A3E9                 align 4
.rdata$r:0000A3E9 _rdata$r        ends
.rdata$r:0000A3E9
.rdata$r:0000A3EC ; ===========================================================================
.rdata$r:0000A3EC
.rdata$r:0000A3EC ; Segment type: Pure data
.rdata$r:0000A3EC ; Segment permissions: Read
.rdata$r:0000A3EC _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A3EC                 assume cs:_rdata$r
.rdata$r:0000A3EC                 ;org 0A3ECh
.rdata$r:0000A3EC ; COMDAT (pick any)
.rdata$r:0000A3EC                 public ??_R1A@?0A@EA@IUnknown@@8
.rdata$r:0000A3EC ; IUnknown::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000A3EC ??_R1A@?0A@EA@IUnknown@@8 dd offset ??_R0?AUIUnknown@@@8
.rdata$r:0000A3EC                                         ; DATA XREF: .rdata$r:0000A368o
.rdata$r:0000A3EC                                         ; .rdata$r:0000A3E4o ...
.rdata$r:0000A3EC                                         ; IUnknown `RTTI Type Descriptor'
.rdata$r:0000A3F0                 db    0
.rdata$r:0000A3F1                 db    0
.rdata$r:0000A3F2                 db    0
.rdata$r:0000A3F3                 db    0
.rdata$r:0000A3F4                 db    0
.rdata$r:0000A3F5                 db    0
.rdata$r:0000A3F6                 db    0
.rdata$r:0000A3F7                 db    0
.rdata$r:0000A3F8                 db 0FFh
.rdata$r:0000A3F9                 db 0FFh
.rdata$r:0000A3FA                 db 0FFh
.rdata$r:0000A3FB                 db 0FFh
.rdata$r:0000A3FC                 db    0
.rdata$r:0000A3FD                 db    0
.rdata$r:0000A3FE                 db    0
.rdata$r:0000A3FF                 db    0
.rdata$r:0000A400                 db  40h ; @
.rdata$r:0000A401                 db    0
.rdata$r:0000A402                 db    0
.rdata$r:0000A403                 db    0
.rdata$r:0000A404                 dd offset ??_R3IUnknown@@8 ; IUnknown::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000A404 _rdata$r        ends
.rdata$r:0000A404
.data:0000A408 ; ===========================================================================
.data:0000A408
.data:0000A408 ; Segment type: Pure data
.data:0000A408 ; Segment permissions: Read/Write
.data:0000A408 _data           segment dword public 'DATA' use32
.data:0000A408                 assume cs:_data
.data:0000A408                 ;org 0A408h
.data:0000A408 ; COMDAT (pick any)
.data:0000A408                 public ??_R0?AUIUnknown@@@8
.data:0000A408 ; struct IUnknown `RTTI Type Descriptor'
.data:0000A408 ??_R0?AUIUnknown@@@8 dd offset ??_7type_info@@6B@
.data:0000A408                                         ; DATA XREF: .rdata$r:IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:0000A408                                         ; const type_info::`vftable'
.data:0000A40C                 align 10h
.data:0000A410 a_?auiunknown@@ db '.?AUIUnknown@@',0
.data:0000A41F                 align 10h
.data:0000A41F _data           ends
.data:0000A41F
.rdata$r:0000A420 ; ===========================================================================
.rdata$r:0000A420
.rdata$r:0000A420 ; Segment type: Pure data
.rdata$r:0000A420 ; Segment permissions: Read
.rdata$r:0000A420 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A420                 assume cs:_rdata$r
.rdata$r:0000A420                 ;org 0A420h
.rdata$r:0000A420 ; COMDAT (pick any)
.rdata$r:0000A420                 public ??_R3IUnknown@@8
.rdata$r:0000A420 ; IUnknown::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000A420 ??_R3IUnknown@@8 db    0                ; DATA XREF: .rdata$r:0000A404o
.rdata$r:0000A421                 db    0
.rdata$r:0000A422                 db    0
.rdata$r:0000A423                 db    0
.rdata$r:0000A424                 db    0
.rdata$r:0000A425                 db    0
.rdata$r:0000A426                 db    0
.rdata$r:0000A427                 db    0
.rdata$r:0000A428                 db    1
.rdata$r:0000A429                 db    0
.rdata$r:0000A42A                 db    0
.rdata$r:0000A42B                 db    0
.rdata$r:0000A42C                 dd offset ??_R2IUnknown@@8 ; IUnknown::`RTTI Base Class Array'
.rdata$r:0000A42C _rdata$r        ends
.rdata$r:0000A42C
.rdata$r:0000A430 ; ===========================================================================
.rdata$r:0000A430
.rdata$r:0000A430 ; Segment type: Pure data
.rdata$r:0000A430 ; Segment permissions: Read
.rdata$r:0000A430 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A430                 assume cs:_rdata$r
.rdata$r:0000A430                 ;org 0A430h
.rdata$r:0000A430 ; COMDAT (pick any)
.rdata$r:0000A430                 public ??_R2IUnknown@@8
.rdata$r:0000A430 ; IUnknown::`RTTI Base Class Array'
.rdata$r:0000A430 ??_R2IUnknown@@8 dd offset ??_R1A@?0A@EA@IUnknown@@8
.rdata$r:0000A430                                         ; DATA XREF: .rdata$r:0000A42Co
.rdata$r:0000A430                                         ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000A434                 db    0
.rdata$r:0000A435                 align 4
.rdata$r:0000A435 _rdata$r        ends
.rdata$r:0000A435
.rdata$r:0000A438 ; ===========================================================================
.rdata$r:0000A438
.rdata$r:0000A438 ; Segment type: Pure data
.rdata$r:0000A438 ; Segment permissions: Read
.rdata$r:0000A438 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A438                 assume cs:_rdata$r
.rdata$r:0000A438                 ;org 0A438h
.rdata$r:0000A438 ; COMDAT (pick any)
.rdata$r:0000A438                 public ??_R13?0A@EA@CMyUnknownImp@@8
.rdata$r:0000A438 ; CMyUnknownImp::`RTTI Base Class Descriptor at (4, -1, 0, 64)'
.rdata$r:0000A438 ??_R13?0A@EA@CMyUnknownImp@@8 dd offset ??_R0?AVCMyUnknownImp@@@8
.rdata$r:0000A438                                         ; DATA XREF: .rdata$r:0000A36Co
.rdata$r:0000A438                                         ; .rdata$r:0000AAD0o ...
.rdata$r:0000A438                                         ; CMyUnknownImp `RTTI Type Descriptor'
.rdata$r:0000A43C                 align 10h
.rdata$r:0000A440                 db    4
.rdata$r:0000A441                 db    0
.rdata$r:0000A442                 db    0
.rdata$r:0000A443                 db    0
.rdata$r:0000A444                 db 0FFh
.rdata$r:0000A445                 db 0FFh
.rdata$r:0000A446                 db 0FFh
.rdata$r:0000A447                 db 0FFh
.rdata$r:0000A448                 db    0
.rdata$r:0000A449                 db    0
.rdata$r:0000A44A                 db    0
.rdata$r:0000A44B                 db    0
.rdata$r:0000A44C                 db  40h ; @
.rdata$r:0000A44D                 db    0
.rdata$r:0000A44E                 db    0
.rdata$r:0000A44F                 db    0
.rdata$r:0000A450                 dd offset ??_R3CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000A450 _rdata$r        ends
.rdata$r:0000A450
.data:0000A454 ; ===========================================================================
.data:0000A454
.data:0000A454 ; Segment type: Pure data
.data:0000A454 ; Segment permissions: Read/Write
.data:0000A454 _data           segment dword public 'DATA' use32
.data:0000A454                 assume cs:_data
.data:0000A454                 ;org 0A454h
.data:0000A454 ; COMDAT (pick any)
.data:0000A454                 public ??_R0?AVCMyUnknownImp@@@8
.data:0000A454 ; class CMyUnknownImp `RTTI Type Descriptor'
.data:0000A454 ??_R0?AVCMyUnknownImp@@@8 dd offset ??_7type_info@@6B@
.data:0000A454                                         ; DATA XREF: .rdata$r:CMyUnknownImp::`RTTI Base Class Descriptor at (4,-1,0,64)'o
.data:0000A454                                         ; .rdata$r:CMyUnknownImp::`RTTI Base Class Descriptor at (0,-1,0,64)'o ...
.data:0000A454                                         ; const type_info::`vftable'
.data:0000A458                 db    0
.data:0000A459                 db    0
.data:0000A45A                 db    0
.data:0000A45B                 db    0
.data:0000A45C                 db  2Eh ; .
.data:0000A45D                 db  3Fh ; ?
.data:0000A45E                 db  41h ; A
.data:0000A45F                 db  56h ; V
.data:0000A460                 db  43h ; C
.data:0000A461                 db  4Dh ; M
.data:0000A462                 db  79h ; y
.data:0000A463                 db  55h ; U
.data:0000A464                 db  6Eh ; n
.data:0000A465                 db  6Bh ; k
.data:0000A466                 db  6Eh ; n
.data:0000A467                 db  6Fh ; o
.data:0000A468                 db  77h ; w
.data:0000A469                 db  6Eh ; n
.data:0000A46A                 db  49h ; I
.data:0000A46B                 db  6Dh ; m
.data:0000A46C                 db  70h ; p
.data:0000A46D                 db  40h ; @
.data:0000A46E                 db  40h ; @
.data:0000A46F                 db    0
.data:0000A46F _data           ends
.data:0000A46F
.rdata$r:0000A470 ; ===========================================================================
.rdata$r:0000A470
.rdata$r:0000A470 ; Segment type: Pure data
.rdata$r:0000A470 ; Segment permissions: Read
.rdata$r:0000A470 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A470                 assume cs:_rdata$r
.rdata$r:0000A470                 ;org 0A470h
.rdata$r:0000A470 ; COMDAT (pick any)
.rdata$r:0000A470                 public ??_R3CMyUnknownImp@@8
.rdata$r:0000A470 ; CMyUnknownImp::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000A470 ??_R3CMyUnknownImp@@8 db    0           ; DATA XREF: .rdata$r:0000A450o
.rdata$r:0000A470                                         ; .rdata$r:0000A4A0o ...
.rdata$r:0000A471                 db    0
.rdata$r:0000A472                 db    0
.rdata$r:0000A473                 db    0
.rdata$r:0000A474                 db    0
.rdata$r:0000A475                 db    0
.rdata$r:0000A476                 db    0
.rdata$r:0000A477                 db    0
.rdata$r:0000A478                 db    1
.rdata$r:0000A479                 db    0
.rdata$r:0000A47A                 db    0
.rdata$r:0000A47B                 db    0
.rdata$r:0000A47C                 dd offset ??_R2CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Base Class Array'
.rdata$r:0000A47C _rdata$r        ends
.rdata$r:0000A47C
.rdata$r:0000A480 ; ===========================================================================
.rdata$r:0000A480
.rdata$r:0000A480 ; Segment type: Pure data
.rdata$r:0000A480 ; Segment permissions: Read
.rdata$r:0000A480 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A480                 assume cs:_rdata$r
.rdata$r:0000A480                 ;org 0A480h
.rdata$r:0000A480 ; COMDAT (pick any)
.rdata$r:0000A480                 public ??_R2CMyUnknownImp@@8
.rdata$r:0000A480 ; CMyUnknownImp::`RTTI Base Class Array'
.rdata$r:0000A480 ??_R2CMyUnknownImp@@8 dd offset ??_R1A@?0A@EA@CMyUnknownImp@@8
.rdata$r:0000A480                                         ; DATA XREF: .rdata$r:0000A47Co
.rdata$r:0000A480                                         ; CMyUnknownImp::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000A484                 db    0
.rdata$r:0000A485                 align 4
.rdata$r:0000A485 _rdata$r        ends
.rdata$r:0000A485
.rdata$r:0000A488 ; ===========================================================================
.rdata$r:0000A488
.rdata$r:0000A488 ; Segment type: Pure data
.rdata$r:0000A488 ; Segment permissions: Read
.rdata$r:0000A488 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A488                 assume cs:_rdata$r
.rdata$r:0000A488                 ;org 0A488h
.rdata$r:0000A488 ; COMDAT (pick any)
.rdata$r:0000A488                 public ??_R1A@?0A@EA@CMyUnknownImp@@8
.rdata$r:0000A488 ; CMyUnknownImp::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000A488 ??_R1A@?0A@EA@CMyUnknownImp@@8 dd offset ??_R0?AVCMyUnknownImp@@@8
.rdata$r:0000A488                                         ; DATA XREF: .rdata$r:CMyUnknownImp::`RTTI Base Class Array'o
.rdata$r:0000A488                                         ; CMyUnknownImp `RTTI Type Descriptor'
.rdata$r:0000A48C                 db    0
.rdata$r:0000A48D                 db    0
.rdata$r:0000A48E                 db    0
.rdata$r:0000A48F                 db    0
.rdata$r:0000A490                 db    0
.rdata$r:0000A491                 db    0
.rdata$r:0000A492                 db    0
.rdata$r:0000A493                 db    0
.rdata$r:0000A494                 db 0FFh
.rdata$r:0000A495                 db 0FFh
.rdata$r:0000A496                 db 0FFh
.rdata$r:0000A497                 db 0FFh
.rdata$r:0000A498                 db    0
.rdata$r:0000A499                 db    0
.rdata$r:0000A49A                 db    0
.rdata$r:0000A49B                 db    0
.rdata$r:0000A49C                 db  40h ; @
.rdata$r:0000A49D                 db    0
.rdata$r:0000A49E                 db    0
.rdata$r:0000A49F                 db    0
.rdata$r:0000A4A0                 dd offset ??_R3CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000A4A0 _rdata$r        ends
.rdata$r:0000A4A0
.text:0000A4A4 ; ===========================================================================
.text:0000A4A4
.text:0000A4A4 ; Segment type: Pure code
.text:0000A4A4 ; Segment permissions: Read/Execute
.text:0000A4A4 _text           segment para public 'CODE' use32
.text:0000A4A4                 assume cs:_text
.text:0000A4A4                 ;org 0A4A4h
.text:0000A4A4 ; COMDAT (pick any)
.text:0000A4A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A4A4
.text:0000A4A4 ; =============== S U B R O U T I N E =======================================
.text:0000A4A4
.text:0000A4A4 ; Attributes: bp-based frame
.text:0000A4A4
.text:0000A4A4 ; _DWORD __thiscall CMyUnknownImp::CMyUnknownImp(CMyUnknownImp *__hidden this)
.text:0000A4A4                 public ??0CMyUnknownImp@@QAE@XZ
.text:0000A4A4 ??0CMyUnknownImp@@QAE@XZ proc near      ; CODE XREF: CCrcOutStream::CCrcOutStream(void)+1Cp
.text:0000A4A4                                         ; CBenchmarkOutStream::CBenchmarkOutStream(void)+4Dp ...
.text:0000A4A4
.text:0000A4A4 var_4           = dword ptr -4
.text:0000A4A4
.text:0000A4A4                 push    ebp
.text:0000A4A5                 mov     ebp, esp
.text:0000A4A7                 push    ecx
.text:0000A4A8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A4AF                 mov     [ebp+var_4], ecx
.text:0000A4B2                 mov     eax, [ebp+var_4]
.text:0000A4B5                 mov     dword ptr [eax], 0
.text:0000A4BB                 mov     eax, [ebp+var_4]
.text:0000A4BE                 mov     esp, ebp
.text:0000A4C0                 pop     ebp
.text:0000A4C1                 retn
.text:0000A4C1 ??0CMyUnknownImp@@QAE@XZ endp
.text:0000A4C1
.text:0000A4C1 ; ---------------------------------------------------------------------------
.text:0000A4C2                 align 4
.text:0000A4C2 _text           ends
.text:0000A4C2
.text:0000A4C4 ; ===========================================================================
.text:0000A4C4
.text:0000A4C4 ; Segment type: Pure code
.text:0000A4C4 ; Segment permissions: Read/Execute
.text:0000A4C4 _text           segment para public 'CODE' use32
.text:0000A4C4                 assume cs:_text
.text:0000A4C4                 ;org 0A4C4h
.text:0000A4C4 ; COMDAT (pick any)
.text:0000A4C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A4C4
.text:0000A4C4 ; =============== S U B R O U T I N E =======================================
.text:0000A4C4
.text:0000A4C4 ; Attributes: bp-based frame
.text:0000A4C4
.text:0000A4C4 ; __int32 __stdcall CCrcOutStream::QueryInterface(CCrcOutStream *this, const struct _GUID *Buf1, void **)
.text:0000A4C4                 public ?QueryInterface@CCrcOutStream@@UAGJABU_GUID@@PAPAX@Z
.text:0000A4C4 ?QueryInterface@CCrcOutStream@@UAGJABU_GUID@@PAPAX@Z proc near
.text:0000A4C4                                         ; DATA XREF: .rdata:const CCrcOutStream::`vftable'o
.text:0000A4C4
.text:0000A4C4 this            = dword ptr  8
.text:0000A4C4 Buf1            = dword ptr  0Ch
.text:0000A4C4 arg_8           = dword ptr  10h
.text:0000A4C4
.text:0000A4C4                 push    ebp
.text:0000A4C5                 mov     ebp, esp
.text:0000A4C7                 mov     eax, [ebp+arg_8]
.text:0000A4CA                 mov     dword ptr [eax], 0
.text:0000A4D0                 push    offset _IID_IUnknown ; Buf2
.text:0000A4D5                 mov     ecx, [ebp+Buf1]
.text:0000A4D8                 push    ecx             ; Buf1
.text:0000A4D9                 call    ___@8           ; __(x,x)
.text:0000A4DE                 test    eax, eax
.text:0000A4E0                 jz      short loc_A4EC
.text:0000A4E2                 mov     edx, [ebp+arg_8]
.text:0000A4E5                 mov     eax, [ebp+this]
.text:0000A4E8                 mov     [edx], eax
.text:0000A4EA                 jmp     short loc_A4F3
.text:0000A4EC ; ---------------------------------------------------------------------------
.text:0000A4EC
.text:0000A4EC loc_A4EC:                               ; CODE XREF: CCrcOutStream::QueryInterface(_GUID const &,void * *)+1Cj
.text:0000A4EC                 mov     eax, 80004002h
.text:0000A4F1                 jmp     short loc_A504
.text:0000A4F3 ; ---------------------------------------------------------------------------
.text:0000A4F3
.text:0000A4F3 loc_A4F3:                               ; CODE XREF: CCrcOutStream::QueryInterface(_GUID const &,void * *)+26j
.text:0000A4F3                 mov     ecx, [ebp+this]
.text:0000A4F6                 mov     edx, [ecx+4]
.text:0000A4F9                 add     edx, 1
.text:0000A4FC                 mov     eax, [ebp+this]
.text:0000A4FF                 mov     [eax+4], edx
.text:0000A502                 xor     eax, eax
.text:0000A504
.text:0000A504 loc_A504:                               ; CODE XREF: CCrcOutStream::QueryInterface(_GUID const &,void * *)+2Dj
.text:0000A504                 cmp     ebp, esp
.text:0000A506                 call    __RTC_CheckEsp
.text:0000A50B                 pop     ebp
.text:0000A50C                 retn    0Ch
.text:0000A50C ?QueryInterface@CCrcOutStream@@UAGJABU_GUID@@PAPAX@Z endp
.text:0000A50C
.text:0000A50C ; ---------------------------------------------------------------------------
.text:0000A50F                 align 10h
.text:0000A50F _text           ends
.text:0000A50F
.text:0000A510 ; ===========================================================================
.text:0000A510
.text:0000A510 ; Segment type: Pure code
.text:0000A510 ; Segment permissions: Read/Execute
.text:0000A510 _text           segment para public 'CODE' use32
.text:0000A510                 assume cs:_text
.text:0000A510                 ;org 0A510h
.text:0000A510 ; COMDAT (pick any)
.text:0000A510                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A510
.text:0000A510 ; =============== S U B R O U T I N E =======================================
.text:0000A510
.text:0000A510 ; Attributes: bp-based frame
.text:0000A510
.text:0000A510 ; int __stdcall __(void *Buf1, void *Buf2)
.text:0000A510                 public ___@8
.text:0000A510 ___@8           proc near               ; CODE XREF: CCrcOutStream::QueryInterface(_GUID const &,void * *)+15p
.text:0000A510                                         ; CBenchmarkOutStream::QueryInterface(_GUID const &,void * *)+15p ...
.text:0000A510
.text:0000A510 Buf1            = dword ptr  8
.text:0000A510 Buf2            = dword ptr  0Ch
.text:0000A510
.text:0000A510                 push    ebp
.text:0000A511                 mov     ebp, esp
.text:0000A513                 mov     eax, [ebp+Buf2]
.text:0000A516                 push    eax             ; Buf2
.text:0000A517                 mov     ecx, [ebp+Buf1]
.text:0000A51A                 push    ecx             ; Buf1
.text:0000A51B                 call    _IsEqualGUID@8  ; IsEqualGUID(x,x)
.text:0000A520                 cmp     ebp, esp
.text:0000A522                 call    __RTC_CheckEsp
.text:0000A527                 pop     ebp
.text:0000A528                 retn    8
.text:0000A528 ___@8           endp
.text:0000A528
.text:0000A528 ; ---------------------------------------------------------------------------
.text:0000A52B                 align 4
.text:0000A52B _text           ends
.text:0000A52B
.text:0000A52C ; ===========================================================================
.text:0000A52C
.text:0000A52C ; Segment type: Pure code
.text:0000A52C ; Segment permissions: Read/Execute
.text:0000A52C _text           segment para public 'CODE' use32
.text:0000A52C                 assume cs:_text
.text:0000A52C                 ;org 0A52Ch
.text:0000A52C ; COMDAT (pick any)
.text:0000A52C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A52C
.text:0000A52C ; =============== S U B R O U T I N E =======================================
.text:0000A52C
.text:0000A52C ; Attributes: bp-based frame
.text:0000A52C
.text:0000A52C ; int __stdcall IsEqualGUID(void *Buf1, void *Buf2)
.text:0000A52C                 public _IsEqualGUID@8
.text:0000A52C _IsEqualGUID@8  proc near               ; CODE XREF: __(x,x)+Bp
.text:0000A52C
.text:0000A52C Buf1            = dword ptr  8
.text:0000A52C Buf2            = dword ptr  0Ch
.text:0000A52C
.text:0000A52C                 push    ebp
.text:0000A52D                 mov     ebp, esp
.text:0000A52F                 push    10h             ; Size
.text:0000A531                 mov     eax, [ebp+Buf2]
.text:0000A534                 push    eax             ; Buf2
.text:0000A535                 mov     ecx, [ebp+Buf1]
.text:0000A538                 push    ecx             ; Buf1
.text:0000A539                 call    _memcmp
.text:0000A53E                 add     esp, 0Ch
.text:0000A541                 neg     eax
.text:0000A543                 sbb     eax, eax
.text:0000A545                 add     eax, 1
.text:0000A548                 cmp     ebp, esp
.text:0000A54A                 call    __RTC_CheckEsp
.text:0000A54F                 pop     ebp
.text:0000A550                 retn    8
.text:0000A550 _IsEqualGUID@8  endp
.text:0000A550
.text:0000A550 ; ---------------------------------------------------------------------------
.text:0000A553                 align 4
.text:0000A553 _text           ends
.text:0000A553
.text:0000A554 ; ===========================================================================
.text:0000A554
.text:0000A554 ; Segment type: Pure code
.text:0000A554 ; Segment permissions: Read/Execute
.text:0000A554 _text           segment para public 'CODE' use32
.text:0000A554                 assume cs:_text
.text:0000A554                 ;org 0A554h
.text:0000A554 ; COMDAT (pick any)
.text:0000A554                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A554
.text:0000A554 ; =============== S U B R O U T I N E =======================================
.text:0000A554
.text:0000A554 ; Attributes: bp-based frame
.text:0000A554
.text:0000A554 ; unsigned __int32 __stdcall CCrcOutStream::AddRef(CCrcOutStream *this)
.text:0000A554                 public ?AddRef@CCrcOutStream@@UAGKXZ
.text:0000A554 ?AddRef@CCrcOutStream@@UAGKXZ proc near ; DATA XREF: .rdata:0000A314o
.text:0000A554
.text:0000A554 var_4           = dword ptr -4
.text:0000A554 this            = dword ptr  8
.text:0000A554
.text:0000A554                 push    ebp
.text:0000A555                 mov     ebp, esp
.text:0000A557                 push    ecx
.text:0000A558                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A55F                 mov     eax, [ebp+this]
.text:0000A562                 mov     ecx, [eax+4]
.text:0000A565                 add     ecx, 1
.text:0000A568                 mov     [ebp+var_4], ecx
.text:0000A56B                 mov     edx, [ebp+this]
.text:0000A56E                 mov     eax, [ebp+var_4]
.text:0000A571                 mov     [edx+4], eax
.text:0000A574                 mov     eax, [ebp+var_4]
.text:0000A577                 mov     esp, ebp
.text:0000A579                 pop     ebp
.text:0000A57A                 retn    4
.text:0000A57A ?AddRef@CCrcOutStream@@UAGKXZ endp
.text:0000A57A
.text:0000A57A ; ---------------------------------------------------------------------------
.text:0000A57D                 align 10h
.text:0000A57D _text           ends
.text:0000A57D
.text:0000A580 ; ===========================================================================
.text:0000A580
.text:0000A580 ; Segment type: Pure code
.text:0000A580 ; Segment permissions: Read/Execute
.text:0000A580 _text           segment para public 'CODE' use32
.text:0000A580                 assume cs:_text
.text:0000A580                 ;org 0A580h
.text:0000A580 ; COMDAT (pick any)
.text:0000A580                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A580
.text:0000A580 ; =============== S U B R O U T I N E =======================================
.text:0000A580
.text:0000A580 ; Attributes: bp-based frame
.text:0000A580
.text:0000A580 ; unsigned __int32 __stdcall CCrcOutStream::Release(CCrcOutStream *this)
.text:0000A580                 public ?Release@CCrcOutStream@@UAGKXZ
.text:0000A580 ?Release@CCrcOutStream@@UAGKXZ proc near ; DATA XREF: .rdata:0000A318o
.text:0000A580
.text:0000A580 var_8           = dword ptr -8
.text:0000A580 var_4           = dword ptr -4
.text:0000A580 this            = dword ptr  8
.text:0000A580
.text:0000A580                 push    ebp
.text:0000A581                 mov     ebp, esp
.text:0000A583                 sub     esp, 8
.text:0000A586                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000A58D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A594                 mov     eax, [ebp+this]
.text:0000A597                 mov     ecx, [eax+4]
.text:0000A59A                 sub     ecx, 1
.text:0000A59D                 mov     [ebp+var_8], ecx
.text:0000A5A0                 mov     edx, [ebp+this]
.text:0000A5A3                 mov     eax, [ebp+var_8]
.text:0000A5A6                 mov     [edx+4], eax
.text:0000A5A9                 cmp     [ebp+var_8], 0
.text:0000A5AD                 jz      short loc_A5B7
.text:0000A5AF                 mov     ecx, [ebp+this]
.text:0000A5B2                 mov     eax, [ecx+4]
.text:0000A5B5                 jmp     short loc_A5CB
.text:0000A5B7 ; ---------------------------------------------------------------------------
.text:0000A5B7
.text:0000A5B7 loc_A5B7:                               ; CODE XREF: CCrcOutStream::Release(void)+2Dj
.text:0000A5B7                 mov     edx, [ebp+this]
.text:0000A5BA                 mov     [ebp+var_4], edx
.text:0000A5BD                 mov     eax, [ebp+var_4]
.text:0000A5C0                 push    eax             ; void *
.text:0000A5C1                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000A5C6                 add     esp, 4
.text:0000A5C9                 xor     eax, eax
.text:0000A5CB
.text:0000A5CB loc_A5CB:                               ; CODE XREF: CCrcOutStream::Release(void)+35j
.text:0000A5CB                 add     esp, 8
.text:0000A5CE                 cmp     ebp, esp
.text:0000A5D0                 call    __RTC_CheckEsp
.text:0000A5D5                 mov     esp, ebp
.text:0000A5D7                 pop     ebp
.text:0000A5D8                 retn    4
.text:0000A5D8 ?Release@CCrcOutStream@@UAGKXZ endp
.text:0000A5D8
.text:0000A5D8 ; ---------------------------------------------------------------------------
.text:0000A5DB                 align 4
.text:0000A5DB _text           ends
.text:0000A5DB
.text:0000A5DC ; ===========================================================================
.text:0000A5DC
.text:0000A5DC ; Segment type: Pure code
.text:0000A5DC ; Segment permissions: Read/Execute
.text:0000A5DC _text           segment para public 'CODE' use32
.text:0000A5DC                 assume cs:_text
.text:0000A5DC                 ;org 0A5DCh
.text:0000A5DC ; COMDAT (pick any)
.text:0000A5DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A5DC
.text:0000A5DC ; =============== S U B R O U T I N E =======================================
.text:0000A5DC
.text:0000A5DC ; Attributes: bp-based frame
.text:0000A5DC
.text:0000A5DC ; void __thiscall CCrcOutStream::Init(CCrcOutStream *__hidden this)
.text:0000A5DC                 public ?Init@CCrcOutStream@@QAEXXZ
.text:0000A5DC ?Init@CCrcOutStream@@QAEXXZ proc near   ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+5F3p
.text:0000A5DC                                         ; CEncoderInfo::Decode(uint)+8C3p
.text:0000A5DC
.text:0000A5DC var_4           = dword ptr -4
.text:0000A5DC
.text:0000A5DC                 push    ebp
.text:0000A5DD                 mov     ebp, esp
.text:0000A5DF                 push    ecx
.text:0000A5E0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A5E7                 mov     [ebp+var_4], ecx
.text:0000A5EA                 mov     eax, [ebp+var_4]
.text:0000A5ED                 mov     dword ptr [eax+0Ch], 0FFFFFFFFh
.text:0000A5F4                 mov     esp, ebp
.text:0000A5F6                 pop     ebp
.text:0000A5F7                 retn
.text:0000A5F7 ?Init@CCrcOutStream@@QAEXXZ endp
.text:0000A5F7
.text:0000A5F7 _text           ends
.text:0000A5F7
.text:0000A5F8 ; ===========================================================================
.text:0000A5F8
.text:0000A5F8 ; Segment type: Pure code
.text:0000A5F8 ; Segment permissions: Read/Execute
.text:0000A5F8 _text           segment para public 'CODE' use32
.text:0000A5F8                 assume cs:_text
.text:0000A5F8                 ;org 0A5F8h
.text:0000A5F8 ; COMDAT (pick any)
.text:0000A5F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A5F8
.text:0000A5F8 ; =============== S U B R O U T I N E =======================================
.text:0000A5F8
.text:0000A5F8 ; Attributes: bp-based frame
.text:0000A5F8
.text:0000A5F8 ; _DWORD __thiscall ISequentialOutStream::ISequentialOutStream(ISequentialOutStream *__hidden this)
.text:0000A5F8                 public ??0ISequentialOutStream@@QAE@XZ
.text:0000A5F8 ??0ISequentialOutStream@@QAE@XZ proc near
.text:0000A5F8                                         ; CODE XREF: CCrcOutStream::CCrcOutStream(void)+11p
.text:0000A5F8                                         ; CBenchmarkOutStream::CBenchmarkOutStream(void)+30p
.text:0000A5F8
.text:0000A5F8 var_4           = dword ptr -4
.text:0000A5F8
.text:0000A5F8                 push    ebp
.text:0000A5F9                 mov     ebp, esp
.text:0000A5FB                 push    ecx
.text:0000A5FC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A603                 mov     [ebp+var_4], ecx
.text:0000A606                 mov     ecx, [ebp+var_4]
.text:0000A609                 call    ??0IUnknown@@QAE@XZ ; IUnknown::IUnknown(void)
.text:0000A60E                 mov     eax, [ebp+var_4]
.text:0000A611                 mov     dword ptr [eax], offset ??_7ISequentialOutStream@@6B@ ; const ISequentialOutStream::`vftable'
.text:0000A617                 mov     eax, [ebp+var_4]
.text:0000A61A                 add     esp, 4
.text:0000A61D                 cmp     ebp, esp
.text:0000A61F                 call    __RTC_CheckEsp
.text:0000A624                 mov     esp, ebp
.text:0000A626                 pop     ebp
.text:0000A627                 retn
.text:0000A627 ??0ISequentialOutStream@@QAE@XZ endp
.text:0000A627
.text:0000A627 _text           ends
.text:0000A627
.rdata:0000A628 ; ===========================================================================
.rdata:0000A628
.rdata:0000A628 ; Segment type: Pure data
.rdata:0000A628 ; Segment permissions: Read
.rdata:0000A628 _rdata          segment dword public 'DATA' use32
.rdata:0000A628                 assume cs:_rdata
.rdata:0000A628                 ;org 0A628h
.rdata:0000A628 ; COMDAT (pick largest)
.rdata:0000A628                 dd offset ??_R4ISequentialOutStream@@6B@ ; const ISequentialOutStream::`RTTI Complete Object Locator'
.rdata:0000A62C                 public ??_7ISequentialOutStream@@6B@
.rdata:0000A62C ; const ISequentialOutStream::`vftable'
.rdata:0000A62C ??_7ISequentialOutStream@@6B@ dd offset __purecall
.rdata:0000A62C                                         ; DATA XREF: ISequentialOutStream::ISequentialOutStream(void)+19o
.rdata:0000A630                 dd offset __purecall
.rdata:0000A634                 dd offset __purecall
.rdata:0000A638                 dd offset __purecall
.rdata:0000A638 _rdata          ends
.rdata:0000A638
.rdata$r:0000A63C ; ===========================================================================
.rdata$r:0000A63C
.rdata$r:0000A63C ; Segment type: Pure data
.rdata$r:0000A63C ; Segment permissions: Read
.rdata$r:0000A63C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A63C                 assume cs:_rdata$r
.rdata$r:0000A63C                 ;org 0A63Ch
.rdata$r:0000A63C ; COMDAT (pick any)
.rdata$r:0000A63C                 public ??_R4ISequentialOutStream@@6B@
.rdata$r:0000A63C ; const ISequentialOutStream::`RTTI Complete Object Locator'
.rdata$r:0000A63C ??_R4ISequentialOutStream@@6B@ db    0  ; DATA XREF: .rdata:0000A628o
.rdata$r:0000A63D                 db    0
.rdata$r:0000A63E                 db    0
.rdata$r:0000A63F                 db    0
.rdata$r:0000A640                 db    0
.rdata$r:0000A641                 db    0
.rdata$r:0000A642                 db    0
.rdata$r:0000A643                 db    0
.rdata$r:0000A644                 db    0
.rdata$r:0000A645                 db    0
.rdata$r:0000A646                 db    0
.rdata$r:0000A647                 db    0
.rdata$r:0000A648                 dd offset ??_R0?AUISequentialOutStream@@@8 ; ISequentialOutStream `RTTI Type Descriptor'
.rdata$r:0000A64C                 dd offset ??_R3ISequentialOutStream@@8 ; ISequentialOutStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000A64C _rdata$r        ends
.rdata$r:0000A64C
.text:0000A650 ; ===========================================================================
.text:0000A650
.text:0000A650 ; Segment type: Pure code
.text:0000A650 ; Segment permissions: Read/Execute
.text:0000A650 _text           segment para public 'CODE' use32
.text:0000A650                 assume cs:_text
.text:0000A650                 ;org 0A650h
.text:0000A650 ; COMDAT (pick any)
.text:0000A650                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A650
.text:0000A650 ; =============== S U B R O U T I N E =======================================
.text:0000A650
.text:0000A650 ; Attributes: bp-based frame
.text:0000A650
.text:0000A650 ; public: __thiscall IUnknown::IUnknown(void)
.text:0000A650                 public ??0IUnknown@@QAE@XZ
.text:0000A650 ??0IUnknown@@QAE@XZ proc near           ; CODE XREF: ISequentialOutStream::ISequentialOutStream(void)+11p
.text:0000A650                                         ; ISequentialInStream::ISequentialInStream(void)+11p ...
.text:0000A650
.text:0000A650 var_4           = dword ptr -4
.text:0000A650
.text:0000A650                 push    ebp
.text:0000A651                 mov     ebp, esp
.text:0000A653                 push    ecx
.text:0000A654                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A65B                 mov     [ebp+var_4], ecx
.text:0000A65E                 mov     eax, [ebp+var_4]
.text:0000A661                 mov     esp, ebp
.text:0000A663                 pop     ebp
.text:0000A664                 retn
.text:0000A664 ??0IUnknown@@QAE@XZ endp
.text:0000A664
.text:0000A664 ; ---------------------------------------------------------------------------
.text:0000A665                 align 4
.text:0000A665 _text           ends
.text:0000A665
.text:0000A668 ; ===========================================================================
.text:0000A668
.text:0000A668 ; Segment type: Pure code
.text:0000A668 ; Segment permissions: Read/Execute
.text:0000A668 _text           segment para public 'CODE' use32
.text:0000A668                 assume cs:_text
.text:0000A668                 ;org 0A668h
.text:0000A668 ; COMDAT (pick any)
.text:0000A668                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A668
.text:0000A668 ; =============== S U B R O U T I N E =======================================
.text:0000A668
.text:0000A668 ; Attributes: bp-based frame
.text:0000A668
.text:0000A668 ; public: __thiscall CBenchmarkOutStream::CBenchmarkOutStream(void)
.text:0000A668                 public ??0CBenchmarkOutStream@@QAE@XZ
.text:0000A668 ??0CBenchmarkOutStream@@QAE@XZ proc near
.text:0000A668                                         ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+143p
.text:0000A668                                         ; CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+202p
.text:0000A668
.text:0000A668 var_10          = dword ptr -10h
.text:0000A668 var_C           = dword ptr -0Ch
.text:0000A668 var_4           = dword ptr -4
.text:0000A668
.text:0000A668                 push    ebp
.text:0000A669                 mov     ebp, esp
.text:0000A66B                 push    0FFFFFFFFh
.text:0000A66D                 push    offset __ehhandler$??0CBenchmarkOutStream@@QAE@XZ
.text:0000A672                 mov     eax, large fs:0
.text:0000A678                 push    eax
.text:0000A679                 push    ecx
.text:0000A67A                 mov     [ebp+var_10], 0CCCCCCCCh
.text:0000A681                 mov     eax, dword ptr ds:___security_cookie
.text:0000A686                 xor     eax, ebp
.text:0000A688                 push    eax
.text:0000A689                 lea     eax, [ebp+var_C]
.text:0000A68C                 mov     large fs:0, eax
.text:0000A692                 mov     [ebp+var_10], ecx
.text:0000A695                 mov     ecx, [ebp+var_10] ; this
.text:0000A698                 call    ??0ISequentialOutStream@@QAE@XZ ; ISequentialOutStream::ISequentialOutStream(void)
.text:0000A69D                 mov     ecx, [ebp+var_10]
.text:0000A6A0                 add     ecx, 4          ; this
.text:0000A6A3                 call    ??0CBenchBuffer@@QAE@XZ ; CBenchBuffer::CBenchBuffer(void)
.text:0000A6A8                 mov     [ebp+var_4], 0
.text:0000A6AF                 mov     ecx, [ebp+var_10]
.text:0000A6B2                 add     ecx, 10h        ; this
.text:0000A6B5                 call    ??0CMyUnknownImp@@QAE@XZ ; CMyUnknownImp::CMyUnknownImp(void)
.text:0000A6BA                 mov     eax, [ebp+var_10]
.text:0000A6BD                 mov     dword ptr [eax], offset ??_7CBenchmarkOutStream@@6BISequentialOutStream@@@ ; const CBenchmarkOutStream::`vftable'{for `ISequentialOutStream'}
.text:0000A6C3                 mov     ecx, [ebp+var_10]
.text:0000A6C6                 mov     dword ptr [ecx+4], offset ??_7CBenchmarkOutStream@@6BCBenchBuffer@@@ ; const CBenchmarkOutStream::`vftable'{for `CBenchBuffer'}
.text:0000A6CD                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000A6D4                 mov     eax, [ebp+var_10]
.text:0000A6D7                 mov     ecx, [ebp+var_C]
.text:0000A6DA                 mov     large fs:0, ecx
.text:0000A6E1                 pop     ecx
.text:0000A6E2                 add     esp, 10h
.text:0000A6E5                 cmp     ebp, esp
.text:0000A6E7                 call    __RTC_CheckEsp
.text:0000A6EC                 mov     esp, ebp
.text:0000A6EE                 pop     ebp
.text:0000A6EF                 retn
.text:0000A6EF ??0CBenchmarkOutStream@@QAE@XZ endp
.text:0000A6EF
.text:0000A6EF _text           ends
.text:0000A6EF
.text$x:0000A6F0 ; ===========================================================================
.text$x:0000A6F0
.text$x:0000A6F0 ; Segment type: Pure code
.text$x:0000A6F0 ; Segment permissions: Read/Execute
.text$x:0000A6F0 _text$x         segment para public 'CODE' use32
.text$x:0000A6F0                 assume cs:_text$x
.text$x:0000A6F0                 ;org 0A6F0h
.text$x:0000A6F0 ; COMDAT (pick associative to section at A668)
.text$x:0000A6F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000A6F0
.text$x:0000A6F0 ; =============== S U B R O U T I N E =======================================
.text$x:0000A6F0
.text$x:0000A6F0
.text$x:0000A6F0 __unwindfunclet$??0CBenchmarkOutStream@@QAE@XZ$0 proc near
.text$x:0000A6F0                                         ; DATA XREF: .xdata$x:0000A738o
.text$x:0000A6F0                 mov     ecx, [ebp-10h]
.text$x:0000A6F3                 add     ecx, 4          ; this
.text$x:0000A6F6                 jmp     ??1CBenchBuffer@@UAE@XZ ; CBenchBuffer::~CBenchBuffer(void)
.text$x:0000A6F6 __unwindfunclet$??0CBenchmarkOutStream@@QAE@XZ$0 endp
.text$x:0000A6F6
.text$x:0000A6FB
.text$x:0000A6FB ; =============== S U B R O U T I N E =======================================
.text$x:0000A6FB
.text$x:0000A6FB
.text$x:0000A6FB __ehhandler$??0CBenchmarkOutStream@@QAE@XZ proc near
.text$x:0000A6FB                                         ; DATA XREF: CBenchmarkOutStream::CBenchmarkOutStream(void)+5o
.text$x:0000A6FB
.text$x:0000A6FB arg_4           = dword ptr  8
.text$x:0000A6FB
.text$x:0000A6FB                 mov     edx, [esp+arg_4]
.text$x:0000A6FF                 lea     eax, [edx+0Ch]
.text$x:0000A702                 mov     ecx, [edx-8]
.text$x:0000A705                 xor     ecx, eax
.text$x:0000A707                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000A70C                 mov     eax, offset __ehfuncinfo$??0CBenchmarkOutStream@@QAE@XZ
.text$x:0000A711                 jmp     ___CxxFrameHandler3
.text$x:0000A711 __ehhandler$??0CBenchmarkOutStream@@QAE@XZ endp
.text$x:0000A711
.text$x:0000A711 ; ---------------------------------------------------------------------------
.text$x:0000A716                 align 4
.text$x:0000A716 _text$x         ends
.text$x:0000A716
.rdata:0000A718 ; ===========================================================================
.rdata:0000A718
.rdata:0000A718 ; Segment type: Pure data
.rdata:0000A718 ; Segment permissions: Read
.rdata:0000A718 _rdata          segment dword public 'DATA' use32
.rdata:0000A718                 assume cs:_rdata
.rdata:0000A718                 ;org 0A718h
.rdata:0000A718 ; COMDAT (pick largest)
.rdata:0000A718                 dd offset ??_R4CBenchmarkOutStream@@6BCBenchBuffer@@@ ; const CBenchmarkOutStream::`RTTI Complete Object Locator'{for `CBenchBuffer'}
.rdata:0000A71C                 public ??_7CBenchmarkOutStream@@6BCBenchBuffer@@@
.rdata:0000A71C ; const CBenchmarkOutStream::`vftable'{for `CBenchBuffer'}
.rdata:0000A71C ??_7CBenchmarkOutStream@@6BCBenchBuffer@@@ dd offset ??_ECBenchmarkOutStream@@W3AEPAXI@Z
.rdata:0000A71C                                         ; DATA XREF: CBenchmarkOutStream::CBenchmarkOutStream(void)+5Eo
.rdata:0000A71C _rdata          ends                    ; [thunk]:CBenchmarkOutStream::`vector deleting destructor'`adjustor{4}' (uint)
.rdata:0000A71C
.rdata:0000A720 ; ===========================================================================
.rdata:0000A720
.rdata:0000A720 ; Segment type: Pure data
.rdata:0000A720 ; Segment permissions: Read
.rdata:0000A720 _rdata          segment dword public 'DATA' use32
.rdata:0000A720                 assume cs:_rdata
.rdata:0000A720                 ;org 0A720h
.rdata:0000A720 ; COMDAT (pick largest)
.rdata:0000A720                 dd offset ??_R4CBenchmarkOutStream@@6BISequentialOutStream@@@ ; const CBenchmarkOutStream::`RTTI Complete Object Locator'{for `ISequentialOutStream'}
.rdata:0000A724                 public ??_7CBenchmarkOutStream@@6BISequentialOutStream@@@
.rdata:0000A724 ; const CBenchmarkOutStream::`vftable'{for `ISequentialOutStream'}
.rdata:0000A724 ??_7CBenchmarkOutStream@@6BISequentialOutStream@@@ dd offset ?QueryInterface@CBenchmarkOutStream@@UAGJABU_GUID@@PAPAX@Z
.rdata:0000A724                                         ; DATA XREF: CBenchmarkOutStream::CBenchmarkOutStream(void)+55o
.rdata:0000A724                                         ; CBenchmarkOutStream::QueryInterface(_GUID const &,void * *)
.rdata:0000A728                 dd offset ?AddRef@CBenchmarkOutStream@@UAGKXZ ; CBenchmarkOutStream::AddRef(void)
.rdata:0000A72C                 dd offset ?Release@CBenchmarkOutStream@@UAGKXZ ; CBenchmarkOutStream::Release(void)
.rdata:0000A730                 dd offset ?Write@CBenchmarkOutStream@@UAGJPBXIPAI@Z ; CBenchmarkOutStream::Write(void const *,uint,uint *)
.rdata:0000A730 _rdata          ends
.rdata:0000A730
.xdata$x:0000A734 ; ===========================================================================
.xdata$x:0000A734
.xdata$x:0000A734 ; Segment type: Pure data
.xdata$x:0000A734 ; Segment permissions: Read
.xdata$x:0000A734 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A734                 assume cs:_xdata$x
.xdata$x:0000A734                 ;org 0A734h
.xdata$x:0000A734 ; COMDAT (pick associative to section at A668)
.xdata$x:0000A734 __unwindtable$??0CBenchmarkOutStream@@QAE@XZ db 0FFh
.xdata$x:0000A734                                         ; DATA XREF: .xdata$x:0000A744o
.xdata$x:0000A735                 db 0FFh
.xdata$x:0000A736                 db 0FFh
.xdata$x:0000A737                 db 0FFh
.xdata$x:0000A738                 dd offset __unwindfunclet$??0CBenchmarkOutStream@@QAE@XZ$0
.xdata$x:0000A73C __ehfuncinfo$??0CBenchmarkOutStream@@QAE@XZ db  22h ; "
.xdata$x:0000A73C                                         ; DATA XREF: __ehhandler$??0CBenchmarkOutStream@@QAE@XZ+11o
.xdata$x:0000A73D                 db    5
.xdata$x:0000A73E                 db  93h ; ô
.xdata$x:0000A73F                 db  19h
.xdata$x:0000A740                 db    1
.xdata$x:0000A741                 db    0
.xdata$x:0000A742                 db    0
.xdata$x:0000A743                 db    0
.xdata$x:0000A744                 dd offset __unwindtable$??0CBenchmarkOutStream@@QAE@XZ
.xdata$x:0000A748                 db    0
.xdata$x:0000A749                 db    0
.xdata$x:0000A74A                 db    0
.xdata$x:0000A74B                 db    0
.xdata$x:0000A74C                 db    0
.xdata$x:0000A74D                 db    0
.xdata$x:0000A74E                 db    0
.xdata$x:0000A74F                 db    0
.xdata$x:0000A750                 db    0
.xdata$x:0000A751                 db    0
.xdata$x:0000A752                 db    0
.xdata$x:0000A753                 db    0
.xdata$x:0000A754                 db    0
.xdata$x:0000A755                 db    0
.xdata$x:0000A756                 db    0
.xdata$x:0000A757                 db    0
.xdata$x:0000A758                 db    0
.xdata$x:0000A759                 db    0
.xdata$x:0000A75A                 db    0
.xdata$x:0000A75B                 db    0
.xdata$x:0000A75C                 db    1
.xdata$x:0000A75D                 db    0
.xdata$x:0000A75E                 db    0
.xdata$x:0000A75F                 db    0
.xdata$x:0000A75F _xdata$x        ends
.xdata$x:0000A75F
.rdata$r:0000A760 ; ===========================================================================
.rdata$r:0000A760
.rdata$r:0000A760 ; Segment type: Pure data
.rdata$r:0000A760 ; Segment permissions: Read
.rdata$r:0000A760 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A760                 assume cs:_rdata$r
.rdata$r:0000A760                 ;org 0A760h
.rdata$r:0000A760 ; COMDAT (pick any)
.rdata$r:0000A760                 public ??_R4CBenchmarkOutStream@@6BISequentialOutStream@@@
.rdata$r:0000A760 ; const CBenchmarkOutStream::`RTTI Complete Object Locator'{for `ISequentialOutStream'}
.rdata$r:0000A760 ??_R4CBenchmarkOutStream@@6BISequentialOutStream@@@ db    0
.rdata$r:0000A760                                         ; DATA XREF: .rdata:0000A720o
.rdata$r:0000A761                 db    0
.rdata$r:0000A762                 db    0
.rdata$r:0000A763                 db    0
.rdata$r:0000A764                 db    0
.rdata$r:0000A765                 db    0
.rdata$r:0000A766                 db    0
.rdata$r:0000A767                 db    0
.rdata$r:0000A768                 db    0
.rdata$r:0000A769                 db    0
.rdata$r:0000A76A                 db    0
.rdata$r:0000A76B                 db    0
.rdata$r:0000A76C                 dd offset ??_R0?AVCBenchmarkOutStream@@@8 ; CBenchmarkOutStream `RTTI Type Descriptor'
.rdata$r:0000A770                 dd offset ??_R3CBenchmarkOutStream@@8 ; CBenchmarkOutStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000A770 _rdata$r        ends
.rdata$r:0000A770
.data:0000A774 ; ===========================================================================
.data:0000A774
.data:0000A774 ; Segment type: Pure data
.data:0000A774 ; Segment permissions: Read/Write
.data:0000A774 _data           segment dword public 'DATA' use32
.data:0000A774                 assume cs:_data
.data:0000A774                 ;org 0A774h
.data:0000A774 ; COMDAT (pick any)
.data:0000A774                 public ??_R0?AVCBenchmarkOutStream@@@8
.data:0000A774 ; class CBenchmarkOutStream `RTTI Type Descriptor'
.data:0000A774 ??_R0?AVCBenchmarkOutStream@@@8 dd offset ??_7type_info@@6B@
.data:0000A774                                         ; DATA XREF: .rdata$r:0000A76Co
.data:0000A774                                         ; .rdata$r:CBenchmarkOutStream::`RTTI Base Class Descriptor at (0,-1,0,64)'o ...
.data:0000A774                                         ; const type_info::`vftable'
.data:0000A778                 db    0
.data:0000A779                 db    0
.data:0000A77A                 db    0
.data:0000A77B                 db    0
.data:0000A77C                 db  2Eh ; .
.data:0000A77D                 db  3Fh ; ?
.data:0000A77E                 db  41h ; A
.data:0000A77F                 db  56h ; V
.data:0000A780                 db  43h ; C
.data:0000A781                 db  42h ; B
.data:0000A782                 db  65h ; e
.data:0000A783                 db  6Eh ; n
.data:0000A784                 db  63h ; c
.data:0000A785                 db  68h ; h
.data:0000A786                 db  6Dh ; m
.data:0000A787                 db  61h ; a
.data:0000A788                 db  72h ; r
.data:0000A789                 db  6Bh ; k
.data:0000A78A                 db  4Fh ; O
.data:0000A78B                 db  75h ; u
.data:0000A78C                 db  74h ; t
.data:0000A78D                 db  53h ; S
.data:0000A78E                 db  74h ; t
.data:0000A78F                 db  72h ; r
.data:0000A790                 db  65h ; e
.data:0000A791                 db  61h ; a
.data:0000A792                 db  6Dh ; m
.data:0000A793                 db  40h ; @
.data:0000A794                 db  40h ; @
.data:0000A795                 db    0
.data:0000A796                 align 4
.data:0000A796 _data           ends
.data:0000A796
.rdata$r:0000A798 ; ===========================================================================
.rdata$r:0000A798
.rdata$r:0000A798 ; Segment type: Pure data
.rdata$r:0000A798 ; Segment permissions: Read
.rdata$r:0000A798 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A798                 assume cs:_rdata$r
.rdata$r:0000A798                 ;org 0A798h
.rdata$r:0000A798 ; COMDAT (pick any)
.rdata$r:0000A798                 public ??_R3CBenchmarkOutStream@@8
.rdata$r:0000A798 ; CBenchmarkOutStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000A798 ??_R3CBenchmarkOutStream@@8 db    0     ; DATA XREF: .rdata$r:0000A770o
.rdata$r:0000A798                                         ; .rdata$r:0000A7D8o ...
.rdata$r:0000A799                 db    0
.rdata$r:0000A79A                 db    0
.rdata$r:0000A79B                 db    0
.rdata$r:0000A79C                 db    1
.rdata$r:0000A79D                 db    0
.rdata$r:0000A79E                 db    0
.rdata$r:0000A79F                 db    0
.rdata$r:0000A7A0                 db    5
.rdata$r:0000A7A1                 db    0
.rdata$r:0000A7A2                 db    0
.rdata$r:0000A7A3                 db    0
.rdata$r:0000A7A4                 dd offset ??_R2CBenchmarkOutStream@@8 ; CBenchmarkOutStream::`RTTI Base Class Array'
.rdata$r:0000A7A4 _rdata$r        ends
.rdata$r:0000A7A4
.rdata$r:0000A7A8 ; ===========================================================================
.rdata$r:0000A7A8
.rdata$r:0000A7A8 ; Segment type: Pure data
.rdata$r:0000A7A8 ; Segment permissions: Read
.rdata$r:0000A7A8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A7A8                 assume cs:_rdata$r
.rdata$r:0000A7A8                 ;org 0A7A8h
.rdata$r:0000A7A8 ; COMDAT (pick any)
.rdata$r:0000A7A8                 public ??_R2CBenchmarkOutStream@@8
.rdata$r:0000A7A8 ; CBenchmarkOutStream::`RTTI Base Class Array'
.rdata$r:0000A7A8 ??_R2CBenchmarkOutStream@@8 dd offset ??_R1A@?0A@EA@CBenchmarkOutStream@@8
.rdata$r:0000A7A8                                         ; DATA XREF: .rdata$r:0000A7A4o
.rdata$r:0000A7A8                                         ; CBenchmarkOutStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000A7AC                 dd offset ??_R1A@?0A@EA@ISequentialOutStream@@8 ; ISequentialOutStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000A7B0                 dd offset ??_R1A@?0A@EA@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000A7B4                 dd offset ??_R13?0A@EA@CBenchBuffer@@8 ; CBenchBuffer::`RTTI Base Class Descriptor at (4,-1,0,64)'
.rdata$r:0000A7B8                 dd offset ??_R1BA@?0A@EA@CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Base Class Descriptor at (16,-1,0,64)'
.rdata$r:0000A7BC                 db    0
.rdata$r:0000A7BD                 align 10h
.rdata$r:0000A7BD _rdata$r        ends
.rdata$r:0000A7BD
.rdata$r:0000A7C0 ; ===========================================================================
.rdata$r:0000A7C0
.rdata$r:0000A7C0 ; Segment type: Pure data
.rdata$r:0000A7C0 ; Segment permissions: Read
.rdata$r:0000A7C0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A7C0                 assume cs:_rdata$r
.rdata$r:0000A7C0                 ;org 0A7C0h
.rdata$r:0000A7C0 ; COMDAT (pick any)
.rdata$r:0000A7C0                 public ??_R1A@?0A@EA@CBenchmarkOutStream@@8
.rdata$r:0000A7C0 ; CBenchmarkOutStream::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000A7C0 ??_R1A@?0A@EA@CBenchmarkOutStream@@8 dd offset ??_R0?AVCBenchmarkOutStream@@@8
.rdata$r:0000A7C0                                         ; DATA XREF: .rdata$r:CBenchmarkOutStream::`RTTI Base Class Array'o
.rdata$r:0000A7C0                                         ; CBenchmarkOutStream `RTTI Type Descriptor'
.rdata$r:0000A7C4                 db    4
.rdata$r:0000A7C5                 db    0
.rdata$r:0000A7C6                 db    0
.rdata$r:0000A7C7                 db    0
.rdata$r:0000A7C8                 db    0
.rdata$r:0000A7C9                 db    0
.rdata$r:0000A7CA                 db    0
.rdata$r:0000A7CB                 db    0
.rdata$r:0000A7CC                 db 0FFh
.rdata$r:0000A7CD                 db 0FFh
.rdata$r:0000A7CE                 db 0FFh
.rdata$r:0000A7CF                 db 0FFh
.rdata$r:0000A7D0                 db    0
.rdata$r:0000A7D1                 db    0
.rdata$r:0000A7D2                 db    0
.rdata$r:0000A7D3                 db    0
.rdata$r:0000A7D4                 db  40h ; @
.rdata$r:0000A7D5                 db    0
.rdata$r:0000A7D6                 db    0
.rdata$r:0000A7D7                 db    0
.rdata$r:0000A7D8                 dd offset ??_R3CBenchmarkOutStream@@8 ; CBenchmarkOutStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000A7D8 _rdata$r        ends
.rdata$r:0000A7D8
.rdata$r:0000A7DC ; ===========================================================================
.rdata$r:0000A7DC
.rdata$r:0000A7DC ; Segment type: Pure data
.rdata$r:0000A7DC ; Segment permissions: Read
.rdata$r:0000A7DC _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A7DC                 assume cs:_rdata$r
.rdata$r:0000A7DC                 ;org 0A7DCh
.rdata$r:0000A7DC ; COMDAT (pick any)
.rdata$r:0000A7DC                 public ??_R13?0A@EA@CBenchBuffer@@8
.rdata$r:0000A7DC ; CBenchBuffer::`RTTI Base Class Descriptor at (4, -1, 0, 64)'
.rdata$r:0000A7DC ??_R13?0A@EA@CBenchBuffer@@8 dd offset ??_R0?AVCBenchBuffer@@@8
.rdata$r:0000A7DC                                         ; DATA XREF: .rdata$r:0000A7B4o
.rdata$r:0000A7DC                                         ; CBenchBuffer `RTTI Type Descriptor'
.rdata$r:0000A7E0                 db    0
.rdata$r:0000A7E1                 db    0
.rdata$r:0000A7E2                 db    0
.rdata$r:0000A7E3                 db    0
.rdata$r:0000A7E4                 db    4
.rdata$r:0000A7E5                 db    0
.rdata$r:0000A7E6                 db    0
.rdata$r:0000A7E7                 db    0
.rdata$r:0000A7E8                 db 0FFh
.rdata$r:0000A7E9                 db 0FFh
.rdata$r:0000A7EA                 db 0FFh
.rdata$r:0000A7EB                 db 0FFh
.rdata$r:0000A7EC                 db    0
.rdata$r:0000A7ED                 db    0
.rdata$r:0000A7EE                 db    0
.rdata$r:0000A7EF                 db    0
.rdata$r:0000A7F0                 db  40h ; @
.rdata$r:0000A7F1                 db    0
.rdata$r:0000A7F2                 db    0
.rdata$r:0000A7F3                 db    0
.rdata$r:0000A7F4                 dd offset ??_R3CBenchBuffer@@8 ; CBenchBuffer::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000A7F4 _rdata$r        ends
.rdata$r:0000A7F4
.data:0000A7F8 ; ===========================================================================
.data:0000A7F8
.data:0000A7F8 ; Segment type: Pure data
.data:0000A7F8 ; Segment permissions: Read/Write
.data:0000A7F8 _data           segment dword public 'DATA' use32
.data:0000A7F8                 assume cs:_data
.data:0000A7F8                 ;org 0A7F8h
.data:0000A7F8 ; COMDAT (pick any)
.data:0000A7F8                 public ??_R0?AVCBenchBuffer@@@8
.data:0000A7F8 ; class CBenchBuffer `RTTI Type Descriptor'
.data:0000A7F8 ??_R0?AVCBenchBuffer@@@8 dd offset ??_7type_info@@6B@
.data:0000A7F8                                         ; DATA XREF: .rdata$r:CBenchBuffer::`RTTI Base Class Descriptor at (4,-1,0,64)'o
.data:0000A7F8                                         ; .rdata$r:CBenchBuffer::`RTTI Base Class Descriptor at (0,-1,0,64)'o ...
.data:0000A7F8                                         ; const type_info::`vftable'
.data:0000A7FC                 align 10h
.data:0000A800 a_?avcbenchbuff db '.?AVCBenchBuffer@@',0
.data:0000A813                 align 4
.data:0000A813 _data           ends
.data:0000A813
.rdata$r:0000A814 ; ===========================================================================
.rdata$r:0000A814
.rdata$r:0000A814 ; Segment type: Pure data
.rdata$r:0000A814 ; Segment permissions: Read
.rdata$r:0000A814 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A814                 assume cs:_rdata$r
.rdata$r:0000A814                 ;org 0A814h
.rdata$r:0000A814 ; COMDAT (pick any)
.rdata$r:0000A814                 public ??_R3CBenchBuffer@@8
.rdata$r:0000A814 ; CBenchBuffer::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000A814 ??_R3CBenchBuffer@@8 db    0            ; DATA XREF: .rdata$r:0000A7F4o
.rdata$r:0000A814                                         ; .rdata$r:0000A844o ...
.rdata$r:0000A815                 db    0
.rdata$r:0000A816                 db    0
.rdata$r:0000A817                 db    0
.rdata$r:0000A818                 db    0
.rdata$r:0000A819                 db    0
.rdata$r:0000A81A                 db    0
.rdata$r:0000A81B                 db    0
.rdata$r:0000A81C                 db    1
.rdata$r:0000A81D                 db    0
.rdata$r:0000A81E                 db    0
.rdata$r:0000A81F                 db    0
.rdata$r:0000A820                 dd offset ??_R2CBenchBuffer@@8 ; CBenchBuffer::`RTTI Base Class Array'
.rdata$r:0000A820 _rdata$r        ends
.rdata$r:0000A820
.rdata$r:0000A824 ; ===========================================================================
.rdata$r:0000A824
.rdata$r:0000A824 ; Segment type: Pure data
.rdata$r:0000A824 ; Segment permissions: Read
.rdata$r:0000A824 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A824                 assume cs:_rdata$r
.rdata$r:0000A824                 ;org 0A824h
.rdata$r:0000A824 ; COMDAT (pick any)
.rdata$r:0000A824                 public ??_R2CBenchBuffer@@8
.rdata$r:0000A824 ; CBenchBuffer::`RTTI Base Class Array'
.rdata$r:0000A824 ??_R2CBenchBuffer@@8 dd offset ??_R1A@?0A@EA@CBenchBuffer@@8
.rdata$r:0000A824                                         ; DATA XREF: .rdata$r:0000A820o
.rdata$r:0000A824                                         ; CBenchBuffer::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000A828                 db    0
.rdata$r:0000A829                 align 4
.rdata$r:0000A829 _rdata$r        ends
.rdata$r:0000A829
.rdata$r:0000A82C ; ===========================================================================
.rdata$r:0000A82C
.rdata$r:0000A82C ; Segment type: Pure data
.rdata$r:0000A82C ; Segment permissions: Read
.rdata$r:0000A82C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A82C                 assume cs:_rdata$r
.rdata$r:0000A82C                 ;org 0A82Ch
.rdata$r:0000A82C ; COMDAT (pick any)
.rdata$r:0000A82C                 public ??_R1A@?0A@EA@CBenchBuffer@@8
.rdata$r:0000A82C ; CBenchBuffer::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000A82C ??_R1A@?0A@EA@CBenchBuffer@@8 dd offset ??_R0?AVCBenchBuffer@@@8
.rdata$r:0000A82C                                         ; DATA XREF: .rdata$r:CBenchBuffer::`RTTI Base Class Array'o
.rdata$r:0000A82C                                         ; .rdata$r:0000C64Co
.rdata$r:0000A82C                                         ; CBenchBuffer `RTTI Type Descriptor'
.rdata$r:0000A830                 db    0
.rdata$r:0000A831                 db    0
.rdata$r:0000A832                 db    0
.rdata$r:0000A833                 db    0
.rdata$r:0000A834                 db    0
.rdata$r:0000A835                 db    0
.rdata$r:0000A836                 db    0
.rdata$r:0000A837                 db    0
.rdata$r:0000A838                 db 0FFh
.rdata$r:0000A839                 db 0FFh
.rdata$r:0000A83A                 db 0FFh
.rdata$r:0000A83B                 db 0FFh
.rdata$r:0000A83C                 db    0
.rdata$r:0000A83D                 db    0
.rdata$r:0000A83E                 db    0
.rdata$r:0000A83F                 db    0
.rdata$r:0000A840                 db  40h ; @
.rdata$r:0000A841                 db    0
.rdata$r:0000A842                 db    0
.rdata$r:0000A843                 db    0
.rdata$r:0000A844                 dd offset ??_R3CBenchBuffer@@8 ; CBenchBuffer::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000A844 _rdata$r        ends
.rdata$r:0000A844
.rdata$r:0000A848 ; ===========================================================================
.rdata$r:0000A848
.rdata$r:0000A848 ; Segment type: Pure data
.rdata$r:0000A848 ; Segment permissions: Read
.rdata$r:0000A848 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A848                 assume cs:_rdata$r
.rdata$r:0000A848                 ;org 0A848h
.rdata$r:0000A848 ; COMDAT (pick any)
.rdata$r:0000A848                 public ??_R1BA@?0A@EA@CMyUnknownImp@@8
.rdata$r:0000A848 ; CMyUnknownImp::`RTTI Base Class Descriptor at (16, -1, 0, 64)'
.rdata$r:0000A848 ??_R1BA@?0A@EA@CMyUnknownImp@@8 dd offset ??_R0?AVCMyUnknownImp@@@8
.rdata$r:0000A848                                         ; DATA XREF: .rdata$r:0000A7B8o
.rdata$r:0000A848                                         ; CMyUnknownImp `RTTI Type Descriptor'
.rdata$r:0000A84C                 align 10h
.rdata$r:0000A850                 db  10h
.rdata$r:0000A851                 db    0
.rdata$r:0000A852                 db    0
.rdata$r:0000A853                 db    0
.rdata$r:0000A854                 db 0FFh
.rdata$r:0000A855                 db 0FFh
.rdata$r:0000A856                 db 0FFh
.rdata$r:0000A857                 db 0FFh
.rdata$r:0000A858                 db    0
.rdata$r:0000A859                 db    0
.rdata$r:0000A85A                 db    0
.rdata$r:0000A85B                 db    0
.rdata$r:0000A85C                 db  40h ; @
.rdata$r:0000A85D                 db    0
.rdata$r:0000A85E                 db    0
.rdata$r:0000A85F                 db    0
.rdata$r:0000A860                 dd offset ??_R3CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000A860 _rdata$r        ends
.rdata$r:0000A860
.rdata$r:0000A864 ; ===========================================================================
.rdata$r:0000A864
.rdata$r:0000A864 ; Segment type: Pure data
.rdata$r:0000A864 ; Segment permissions: Read
.rdata$r:0000A864 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A864                 assume cs:_rdata$r
.rdata$r:0000A864                 ;org 0A864h
.rdata$r:0000A864 ; COMDAT (pick any)
.rdata$r:0000A864                 public ??_R4CBenchmarkOutStream@@6BCBenchBuffer@@@
.rdata$r:0000A864 ; const CBenchmarkOutStream::`RTTI Complete Object Locator'{for `CBenchBuffer'}
.rdata$r:0000A864 ??_R4CBenchmarkOutStream@@6BCBenchBuffer@@@ db    0
.rdata$r:0000A864                                         ; DATA XREF: .rdata:0000A718o
.rdata$r:0000A865                 db    0
.rdata$r:0000A866                 db    0
.rdata$r:0000A867                 db    0
.rdata$r:0000A868                 db    4
.rdata$r:0000A869                 db    0
.rdata$r:0000A86A                 db    0
.rdata$r:0000A86B                 db    0
.rdata$r:0000A86C                 db    0
.rdata$r:0000A86D                 db    0
.rdata$r:0000A86E                 db    0
.rdata$r:0000A86F                 db    0
.rdata$r:0000A870                 dd offset ??_R0?AVCBenchmarkOutStream@@@8 ; CBenchmarkOutStream `RTTI Type Descriptor'
.rdata$r:0000A874                 dd offset ??_R3CBenchmarkOutStream@@8 ; CBenchmarkOutStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000A874 _rdata$r        ends
.rdata$r:0000A874
.text:0000A878 ; ===========================================================================
.text:0000A878
.text:0000A878 ; Segment type: Pure code
.text:0000A878 ; Segment permissions: Read/Execute
.text:0000A878 _text           segment para public 'CODE' use32
.text:0000A878                 assume cs:_text
.text:0000A878                 ;org 0A878h
.text:0000A878 ; COMDAT (pick any)
.text:0000A878                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A878
.text:0000A878 ; =============== S U B R O U T I N E =======================================
.text:0000A878
.text:0000A878 ; Attributes: bp-based frame
.text:0000A878
.text:0000A878 ; _DWORD __thiscall CBenchBuffer::CBenchBuffer(CBenchBuffer *__hidden this)
.text:0000A878                 public ??0CBenchBuffer@@QAE@XZ
.text:0000A878 ??0CBenchBuffer@@QAE@XZ proc near       ; CODE XREF: CrcInternalTest(void)+39p
.text:0000A878                                         ; CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+9Ap ...
.text:0000A878
.text:0000A878 var_4           = dword ptr -4
.text:0000A878
.text:0000A878                 push    ebp
.text:0000A879                 mov     ebp, esp
.text:0000A87B                 push    ecx
.text:0000A87C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A883                 mov     [ebp+var_4], ecx
.text:0000A886                 mov     eax, [ebp+var_4]
.text:0000A889                 mov     dword ptr [eax], offset ??_7CBenchBuffer@@6B@ ; const CBenchBuffer::`vftable'
.text:0000A88F                 mov     ecx, [ebp+var_4]
.text:0000A892                 mov     dword ptr [ecx+8], 0
.text:0000A899                 mov     eax, [ebp+var_4]
.text:0000A89C                 mov     esp, ebp
.text:0000A89E                 pop     ebp
.text:0000A89F                 retn
.text:0000A89F ??0CBenchBuffer@@QAE@XZ endp
.text:0000A89F
.text:0000A89F _text           ends
.text:0000A89F
.rdata:0000A8A0 ; ===========================================================================
.rdata:0000A8A0
.rdata:0000A8A0 ; Segment type: Pure data
.rdata:0000A8A0 ; Segment permissions: Read
.rdata:0000A8A0 _rdata          segment dword public 'DATA' use32
.rdata:0000A8A0                 assume cs:_rdata
.rdata:0000A8A0                 ;org 0A8A0h
.rdata:0000A8A0 ; COMDAT (pick largest)
.rdata:0000A8A0                 dd offset ??_R4CBenchBuffer@@6B@ ; const CBenchBuffer::`RTTI Complete Object Locator'
.rdata:0000A8A4                 public ??_7CBenchBuffer@@6B@
.rdata:0000A8A4 ; const CBenchBuffer::`vftable'
.rdata:0000A8A4 ??_7CBenchBuffer@@6B@ dd offset ??_ECBenchBuffer@@UAEPAXI@Z
.rdata:0000A8A4                                         ; DATA XREF: CBenchBuffer::CBenchBuffer(void)+11o
.rdata:0000A8A4                                         ; CBenchBuffer::~CBenchBuffer(void)+11o
.rdata:0000A8A4 _rdata          ends                    ; CBenchBuffer::`vector deleting destructor'(uint)
.rdata:0000A8A4
.rdata$r:0000A8A8 ; ===========================================================================
.rdata$r:0000A8A8
.rdata$r:0000A8A8 ; Segment type: Pure data
.rdata$r:0000A8A8 ; Segment permissions: Read
.rdata$r:0000A8A8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A8A8                 assume cs:_rdata$r
.rdata$r:0000A8A8                 ;org 0A8A8h
.rdata$r:0000A8A8 ; COMDAT (pick any)
.rdata$r:0000A8A8                 public ??_R4CBenchBuffer@@6B@
.rdata$r:0000A8A8 ; const CBenchBuffer::`RTTI Complete Object Locator'
.rdata$r:0000A8A8 ??_R4CBenchBuffer@@6B@ db    0          ; DATA XREF: .rdata:0000A8A0o
.rdata$r:0000A8A9                 db    0
.rdata$r:0000A8AA                 db    0
.rdata$r:0000A8AB                 db    0
.rdata$r:0000A8AC                 db    0
.rdata$r:0000A8AD                 db    0
.rdata$r:0000A8AE                 db    0
.rdata$r:0000A8AF                 db    0
.rdata$r:0000A8B0                 db    0
.rdata$r:0000A8B1                 db    0
.rdata$r:0000A8B2                 db    0
.rdata$r:0000A8B3                 db    0
.rdata$r:0000A8B4                 dd offset ??_R0?AVCBenchBuffer@@@8 ; CBenchBuffer `RTTI Type Descriptor'
.rdata$r:0000A8B8                 dd offset ??_R3CBenchBuffer@@8 ; CBenchBuffer::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000A8B8 _rdata$r        ends
.rdata$r:0000A8B8
.text:0000A8BC ; ===========================================================================
.text:0000A8BC
.text:0000A8BC ; Segment type: Pure code
.text:0000A8BC ; Segment permissions: Read/Execute
.text:0000A8BC _text           segment para public 'CODE' use32
.text:0000A8BC                 assume cs:_text
.text:0000A8BC                 ;org 0A8BCh
.text:0000A8BC ; COMDAT (pick any)
.text:0000A8BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A8BC
.text:0000A8BC ; =============== S U B R O U T I N E =======================================
.text:0000A8BC
.text:0000A8BC ; Attributes: bp-based frame
.text:0000A8BC
.text:0000A8BC ; _DWORD __thiscall CBenchBuffer::~CBenchBuffer(CBenchBuffer *__hidden this)
.text:0000A8BC                 public ??1CBenchBuffer@@UAE@XZ
.text:0000A8BC ??1CBenchBuffer@@UAE@XZ proc near       ; CODE XREF: CrcInternalTest(void)+7Cp
.text:0000A8BC                                         ; CrcInternalTest(void)+DFp ...
.text:0000A8BC
.text:0000A8BC var_4           = dword ptr -4
.text:0000A8BC
.text:0000A8BC                 push    ebp
.text:0000A8BD                 mov     ebp, esp
.text:0000A8BF                 push    ecx
.text:0000A8C0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A8C7                 mov     [ebp+var_4], ecx
.text:0000A8CA                 mov     eax, [ebp+var_4]
.text:0000A8CD                 mov     dword ptr [eax], offset ??_7CBenchBuffer@@6B@ ; const CBenchBuffer::`vftable'
.text:0000A8D3                 mov     ecx, [ebp+var_4] ; this
.text:0000A8D6                 call    ?Free@CBenchBuffer@@QAEXXZ ; CBenchBuffer::Free(void)
.text:0000A8DB                 add     esp, 4
.text:0000A8DE                 cmp     ebp, esp
.text:0000A8E0                 call    __RTC_CheckEsp
.text:0000A8E5                 mov     esp, ebp
.text:0000A8E7                 pop     ebp
.text:0000A8E8                 retn
.text:0000A8E8 ??1CBenchBuffer@@UAE@XZ endp
.text:0000A8E8
.text:0000A8E8 ; ---------------------------------------------------------------------------
.text:0000A8E9                 align 4
.text:0000A8E9 _text           ends
.text:0000A8E9
.text:0000A8EC ; ===========================================================================
.text:0000A8EC
.text:0000A8EC ; Segment type: Pure code
.text:0000A8EC ; Segment permissions: Read/Execute
.text:0000A8EC _text           segment para public 'CODE' use32
.text:0000A8EC                 assume cs:_text
.text:0000A8EC                 ;org 0A8ECh
.text:0000A8EC ; COMDAT (pick any)
.text:0000A8EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A8EC
.text:0000A8EC ; =============== S U B R O U T I N E =======================================
.text:0000A8EC
.text:0000A8EC ; Attributes: bp-based frame
.text:0000A8EC
.text:0000A8EC ; public: virtual void * __thiscall CBenchBuffer::`scalar deleting destructor'(unsigned int)
.text:0000A8EC                 public ??_GCBenchBuffer@@UAEPAXI@Z
.text:0000A8EC ??_GCBenchBuffer@@UAEPAXI@Z proc near
.text:0000A8EC
.text:0000A8EC var_4           = dword ptr -4
.text:0000A8EC arg_0           = dword ptr  8
.text:0000A8EC
.text:0000A8EC                 push    ebp
.text:0000A8ED                 mov     ebp, esp
.text:0000A8EF                 push    ecx
.text:0000A8F0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A8F7                 mov     [ebp+var_4], ecx
.text:0000A8FA                 mov     ecx, [ebp+var_4] ; this
.text:0000A8FD                 call    ??1CBenchBuffer@@UAE@XZ ; CBenchBuffer::~CBenchBuffer(void)
.text:0000A902                 mov     eax, [ebp+arg_0]
.text:0000A905                 and     eax, 1
.text:0000A908                 jz      short loc_A916
.text:0000A90A                 mov     ecx, [ebp+var_4]
.text:0000A90D                 push    ecx             ; void *
.text:0000A90E                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000A913                 add     esp, 4
.text:0000A916
.text:0000A916 loc_A916:                               ; CODE XREF: CBenchBuffer::`scalar deleting destructor'(uint)+1Cj
.text:0000A916                 mov     eax, [ebp+var_4]
.text:0000A919                 add     esp, 4
.text:0000A91C                 cmp     ebp, esp
.text:0000A91E                 call    __RTC_CheckEsp
.text:0000A923                 mov     esp, ebp
.text:0000A925                 pop     ebp
.text:0000A926                 retn    4
.text:0000A926 ??_GCBenchBuffer@@UAEPAXI@Z endp
.text:0000A926
.text:0000A926 ; ---------------------------------------------------------------------------
.text:0000A929                 align 4
.text:0000A929 _text           ends
.text:0000A929
.text:0000A92C ; ===========================================================================
.text:0000A92C
.text:0000A92C ; Segment type: Pure code
.text:0000A92C ; Segment permissions: Read/Execute
.text:0000A92C _text           segment para public 'CODE' use32
.text:0000A92C                 assume cs:_text
.text:0000A92C                 ;org 0A92Ch
.text:0000A92C ; COMDAT (pick any)
.text:0000A92C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A92C
.text:0000A92C ; =============== S U B R O U T I N E =======================================
.text:0000A92C
.text:0000A92C ; Attributes: bp-based frame
.text:0000A92C
.text:0000A92C ; __int32 __stdcall CBenchmarkOutStream::QueryInterface(CBenchmarkOutStream *this, const struct _GUID *Buf1, void **)
.text:0000A92C                 public ?QueryInterface@CBenchmarkOutStream@@UAGJABU_GUID@@PAPAX@Z
.text:0000A92C ?QueryInterface@CBenchmarkOutStream@@UAGJABU_GUID@@PAPAX@Z proc near
.text:0000A92C                                         ; DATA XREF: .rdata:const CBenchmarkOutStream::`vftable'{for `ISequentialOutStream'}o
.text:0000A92C
.text:0000A92C this            = dword ptr  8
.text:0000A92C Buf1            = dword ptr  0Ch
.text:0000A92C arg_8           = dword ptr  10h
.text:0000A92C
.text:0000A92C                 push    ebp
.text:0000A92D                 mov     ebp, esp
.text:0000A92F                 mov     eax, [ebp+arg_8]
.text:0000A932                 mov     dword ptr [eax], 0
.text:0000A938                 push    offset _IID_IUnknown ; Buf2
.text:0000A93D                 mov     ecx, [ebp+Buf1]
.text:0000A940                 push    ecx             ; Buf1
.text:0000A941                 call    ___@8           ; __(x,x)
.text:0000A946                 test    eax, eax
.text:0000A948                 jz      short loc_A954
.text:0000A94A                 mov     edx, [ebp+arg_8]
.text:0000A94D                 mov     eax, [ebp+this]
.text:0000A950                 mov     [edx], eax
.text:0000A952                 jmp     short loc_A95B
.text:0000A954 ; ---------------------------------------------------------------------------
.text:0000A954
.text:0000A954 loc_A954:                               ; CODE XREF: CBenchmarkOutStream::QueryInterface(_GUID const &,void * *)+1Cj
.text:0000A954                 mov     eax, 80004002h
.text:0000A959                 jmp     short loc_A96C
.text:0000A95B ; ---------------------------------------------------------------------------
.text:0000A95B
.text:0000A95B loc_A95B:                               ; CODE XREF: CBenchmarkOutStream::QueryInterface(_GUID const &,void * *)+26j
.text:0000A95B                 mov     ecx, [ebp+this]
.text:0000A95E                 mov     edx, [ecx+10h]
.text:0000A961                 add     edx, 1
.text:0000A964                 mov     eax, [ebp+this]
.text:0000A967                 mov     [eax+10h], edx
.text:0000A96A                 xor     eax, eax
.text:0000A96C
.text:0000A96C loc_A96C:                               ; CODE XREF: CBenchmarkOutStream::QueryInterface(_GUID const &,void * *)+2Dj
.text:0000A96C                 cmp     ebp, esp
.text:0000A96E                 call    __RTC_CheckEsp
.text:0000A973                 pop     ebp
.text:0000A974                 retn    0Ch
.text:0000A974 ?QueryInterface@CBenchmarkOutStream@@UAGJABU_GUID@@PAPAX@Z endp
.text:0000A974
.text:0000A974 ; ---------------------------------------------------------------------------
.text:0000A977                 align 4
.text:0000A977 _text           ends
.text:0000A977
.text:0000A978 ; ===========================================================================
.text:0000A978
.text:0000A978 ; Segment type: Pure code
.text:0000A978 ; Segment permissions: Read/Execute
.text:0000A978 _text           segment para public 'CODE' use32
.text:0000A978                 assume cs:_text
.text:0000A978                 ;org 0A978h
.text:0000A978 ; COMDAT (pick any)
.text:0000A978                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A978
.text:0000A978 ; =============== S U B R O U T I N E =======================================
.text:0000A978
.text:0000A978 ; Attributes: bp-based frame
.text:0000A978
.text:0000A978 ; unsigned __int32 __stdcall CBenchmarkOutStream::AddRef(CBenchmarkOutStream *this)
.text:0000A978                 public ?AddRef@CBenchmarkOutStream@@UAGKXZ
.text:0000A978 ?AddRef@CBenchmarkOutStream@@UAGKXZ proc near ; DATA XREF: .rdata:0000A728o
.text:0000A978
.text:0000A978 var_4           = dword ptr -4
.text:0000A978 this            = dword ptr  8
.text:0000A978
.text:0000A978                 push    ebp
.text:0000A979                 mov     ebp, esp
.text:0000A97B                 push    ecx
.text:0000A97C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A983                 mov     eax, [ebp+this]
.text:0000A986                 mov     ecx, [eax+10h]
.text:0000A989                 add     ecx, 1
.text:0000A98C                 mov     [ebp+var_4], ecx
.text:0000A98F                 mov     edx, [ebp+this]
.text:0000A992                 mov     eax, [ebp+var_4]
.text:0000A995                 mov     [edx+10h], eax
.text:0000A998                 mov     eax, [ebp+var_4]
.text:0000A99B                 mov     esp, ebp
.text:0000A99D                 pop     ebp
.text:0000A99E                 retn    4
.text:0000A99E ?AddRef@CBenchmarkOutStream@@UAGKXZ endp
.text:0000A99E
.text:0000A99E ; ---------------------------------------------------------------------------
.text:0000A9A1                 align 4
.text:0000A9A1 _text           ends
.text:0000A9A1
.text:0000A9A4 ; ===========================================================================
.text:0000A9A4
.text:0000A9A4 ; Segment type: Pure code
.text:0000A9A4 ; Segment permissions: Read/Execute
.text:0000A9A4 _text           segment para public 'CODE' use32
.text:0000A9A4                 assume cs:_text
.text:0000A9A4                 ;org 0A9A4h
.text:0000A9A4 ; COMDAT (pick any)
.text:0000A9A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A9A4
.text:0000A9A4 ; =============== S U B R O U T I N E =======================================
.text:0000A9A4
.text:0000A9A4 ; Attributes: bp-based frame
.text:0000A9A4
.text:0000A9A4 ; unsigned __int32 __stdcall CBenchmarkOutStream::Release(CBenchmarkOutStream *this)
.text:0000A9A4                 public ?Release@CBenchmarkOutStream@@UAGKXZ
.text:0000A9A4 ?Release@CBenchmarkOutStream@@UAGKXZ proc near ; DATA XREF: .rdata:0000A72Co
.text:0000A9A4
.text:0000A9A4 var_10          = dword ptr -10h
.text:0000A9A4 var_C           = dword ptr -0Ch
.text:0000A9A4 var_8           = dword ptr -8
.text:0000A9A4 var_4           = dword ptr -4
.text:0000A9A4 this            = dword ptr  8
.text:0000A9A4
.text:0000A9A4                 push    ebp
.text:0000A9A5                 mov     ebp, esp
.text:0000A9A7                 sub     esp, 10h
.text:0000A9AA                 push    esi
.text:0000A9AB                 mov     eax, 0CCCCCCCCh
.text:0000A9B0                 mov     [ebp+var_10], eax
.text:0000A9B3                 mov     [ebp+var_C], eax
.text:0000A9B6                 mov     [ebp+var_8], eax
.text:0000A9B9                 mov     [ebp+var_4], eax
.text:0000A9BC                 mov     eax, [ebp+this]
.text:0000A9BF                 mov     ecx, [eax+10h]
.text:0000A9C2                 sub     ecx, 1
.text:0000A9C5                 mov     [ebp+var_C], ecx
.text:0000A9C8                 mov     edx, [ebp+this]
.text:0000A9CB                 mov     eax, [ebp+var_C]
.text:0000A9CE                 mov     [edx+10h], eax
.text:0000A9D1                 cmp     [ebp+var_C], 0
.text:0000A9D5                 jz      short loc_A9DF
.text:0000A9D7                 mov     ecx, [ebp+this]
.text:0000A9DA                 mov     eax, [ecx+10h]
.text:0000A9DD                 jmp     short loc_AA1A
.text:0000A9DF ; ---------------------------------------------------------------------------
.text:0000A9DF
.text:0000A9DF loc_A9DF:                               ; CODE XREF: CBenchmarkOutStream::Release(void)+31j
.text:0000A9DF                 mov     edx, [ebp+this]
.text:0000A9E2                 mov     [ebp+var_8], edx
.text:0000A9E5                 mov     eax, [ebp+var_8]
.text:0000A9E8                 mov     [ebp+var_4], eax
.text:0000A9EB                 cmp     [ebp+var_4], 0
.text:0000A9EF                 jz      short loc_AA11
.text:0000A9F1                 mov     esi, esp
.text:0000A9F3                 push    1
.text:0000A9F5                 mov     ecx, [ebp+var_4]
.text:0000A9F8                 add     ecx, 4
.text:0000A9FB                 mov     edx, [ebp+var_4]
.text:0000A9FE                 mov     eax, [edx+4]
.text:0000AA01                 mov     edx, [eax]
.text:0000AA03                 call    edx
.text:0000AA05                 cmp     esi, esp
.text:0000AA07                 call    __RTC_CheckEsp
.text:0000AA0C                 mov     [ebp+var_10], eax
.text:0000AA0F                 jmp     short loc_AA18
.text:0000AA11 ; ---------------------------------------------------------------------------
.text:0000AA11
.text:0000AA11 loc_AA11:                               ; CODE XREF: CBenchmarkOutStream::Release(void)+4Bj
.text:0000AA11                 mov     [ebp+var_10], 0
.text:0000AA18
.text:0000AA18 loc_AA18:                               ; CODE XREF: CBenchmarkOutStream::Release(void)+6Bj
.text:0000AA18                 xor     eax, eax
.text:0000AA1A
.text:0000AA1A loc_AA1A:                               ; CODE XREF: CBenchmarkOutStream::Release(void)+39j
.text:0000AA1A                 pop     esi
.text:0000AA1B                 add     esp, 10h
.text:0000AA1E                 cmp     ebp, esp
.text:0000AA20                 call    __RTC_CheckEsp
.text:0000AA25                 mov     esp, ebp
.text:0000AA27                 pop     ebp
.text:0000AA28                 retn    4
.text:0000AA28 ?Release@CBenchmarkOutStream@@UAGKXZ endp
.text:0000AA28
.text:0000AA28 ; ---------------------------------------------------------------------------
.text:0000AA2B                 align 4
.text:0000AA2B _text           ends
.text:0000AA2B
.text:0000AA2C ; ===========================================================================
.text:0000AA2C
.text:0000AA2C ; Segment type: Pure code
.text:0000AA2C ; Segment permissions: Read/Execute
.text:0000AA2C _text           segment para public 'CODE' use32
.text:0000AA2C                 assume cs:_text
.text:0000AA2C                 ;org 0AA2Ch
.text:0000AA2C ; COMDAT (pick any)
.text:0000AA2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000AA2C
.text:0000AA2C ; =============== S U B R O U T I N E =======================================
.text:0000AA2C
.text:0000AA2C ; Attributes: bp-based frame
.text:0000AA2C
.text:0000AA2C ; public: __thiscall CBenchmarkInStream::CBenchmarkInStream(void)
.text:0000AA2C                 public ??0CBenchmarkInStream@@QAE@XZ
.text:0000AA2C ??0CBenchmarkInStream@@QAE@XZ proc near ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+51Dp
.text:0000AA2C                                         ; CEncoderInfo::Encode(void)+F3p ...
.text:0000AA2C
.text:0000AA2C var_4           = dword ptr -4
.text:0000AA2C
.text:0000AA2C                 push    ebp
.text:0000AA2D                 mov     ebp, esp
.text:0000AA2F                 push    ecx
.text:0000AA30                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000AA37                 mov     [ebp+var_4], ecx
.text:0000AA3A                 mov     ecx, [ebp+var_4] ; this
.text:0000AA3D                 call    ??0ISequentialInStream@@QAE@XZ ; ISequentialInStream::ISequentialInStream(void)
.text:0000AA42                 mov     ecx, [ebp+var_4]
.text:0000AA45                 add     ecx, 4          ; this
.text:0000AA48                 call    ??0CMyUnknownImp@@QAE@XZ ; CMyUnknownImp::CMyUnknownImp(void)
.text:0000AA4D                 mov     eax, [ebp+var_4]
.text:0000AA50                 mov     dword ptr [eax], offset ??_7CBenchmarkInStream@@6B@ ; const CBenchmarkInStream::`vftable'
.text:0000AA56                 mov     eax, [ebp+var_4]
.text:0000AA59                 add     esp, 4
.text:0000AA5C                 cmp     ebp, esp
.text:0000AA5E                 call    __RTC_CheckEsp
.text:0000AA63                 mov     esp, ebp
.text:0000AA65                 pop     ebp
.text:0000AA66                 retn
.text:0000AA66 ??0CBenchmarkInStream@@QAE@XZ endp
.text:0000AA66
.text:0000AA66 ; ---------------------------------------------------------------------------
.text:0000AA67                 align 4
.text:0000AA67 _text           ends
.text:0000AA67
.rdata:0000AA68 ; ===========================================================================
.rdata:0000AA68
.rdata:0000AA68 ; Segment type: Pure data
.rdata:0000AA68 ; Segment permissions: Read
.rdata:0000AA68 _rdata          segment dword public 'DATA' use32
.rdata:0000AA68                 assume cs:_rdata
.rdata:0000AA68                 ;org 0AA68h
.rdata:0000AA68 ; COMDAT (pick largest)
.rdata:0000AA68                 dd offset ??_R4CBenchmarkInStream@@6B@ ; const CBenchmarkInStream::`RTTI Complete Object Locator'
.rdata:0000AA6C                 public ??_7CBenchmarkInStream@@6B@
.rdata:0000AA6C ; const CBenchmarkInStream::`vftable'
.rdata:0000AA6C ??_7CBenchmarkInStream@@6B@ dd offset ?QueryInterface@CBenchmarkInStream@@UAGJABU_GUID@@PAPAX@Z
.rdata:0000AA6C                                         ; DATA XREF: CBenchmarkInStream::CBenchmarkInStream(void)+24o
.rdata:0000AA6C                                         ; CBenchmarkInStream::QueryInterface(_GUID const &,void * *)
.rdata:0000AA70                 dd offset ?AddRef@CBenchmarkInStream@@UAGKXZ ; CBenchmarkInStream::AddRef(void)
.rdata:0000AA74                 dd offset ?Release@CBenchmarkInStream@@UAGKXZ ; CBenchmarkInStream::Release(void)
.rdata:0000AA78                 dd offset ?Read@CBenchmarkInStream@@UAGJPAXIPAI@Z ; CBenchmarkInStream::Read(void *,uint,uint *)
.rdata:0000AA78 _rdata          ends
.rdata:0000AA78
.rdata$r:0000AA7C ; ===========================================================================
.rdata$r:0000AA7C
.rdata$r:0000AA7C ; Segment type: Pure data
.rdata$r:0000AA7C ; Segment permissions: Read
.rdata$r:0000AA7C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000AA7C                 assume cs:_rdata$r
.rdata$r:0000AA7C                 ;org 0AA7Ch
.rdata$r:0000AA7C ; COMDAT (pick any)
.rdata$r:0000AA7C                 public ??_R4CBenchmarkInStream@@6B@
.rdata$r:0000AA7C ; const CBenchmarkInStream::`RTTI Complete Object Locator'
.rdata$r:0000AA7C ??_R4CBenchmarkInStream@@6B@ db    0    ; DATA XREF: .rdata:0000AA68o
.rdata$r:0000AA7D                 db    0
.rdata$r:0000AA7E                 db    0
.rdata$r:0000AA7F                 db    0
.rdata$r:0000AA80                 db    0
.rdata$r:0000AA81                 db    0
.rdata$r:0000AA82                 db    0
.rdata$r:0000AA83                 db    0
.rdata$r:0000AA84                 db    0
.rdata$r:0000AA85                 db    0
.rdata$r:0000AA86                 db    0
.rdata$r:0000AA87                 db    0
.rdata$r:0000AA88                 dd offset ??_R0?AVCBenchmarkInStream@@@8 ; CBenchmarkInStream `RTTI Type Descriptor'
.rdata$r:0000AA8C                 dd offset ??_R3CBenchmarkInStream@@8 ; CBenchmarkInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000AA8C _rdata$r        ends
.rdata$r:0000AA8C
.data:0000AA90 ; ===========================================================================
.data:0000AA90
.data:0000AA90 ; Segment type: Pure data
.data:0000AA90 ; Segment permissions: Read/Write
.data:0000AA90 _data           segment dword public 'DATA' use32
.data:0000AA90                 assume cs:_data
.data:0000AA90                 ;org 0AA90h
.data:0000AA90 ; COMDAT (pick any)
.data:0000AA90                 public ??_R0?AVCBenchmarkInStream@@@8
.data:0000AA90 ; class CBenchmarkInStream `RTTI Type Descriptor'
.data:0000AA90 ??_R0?AVCBenchmarkInStream@@@8 dd offset ??_7type_info@@6B@
.data:0000AA90                                         ; DATA XREF: .rdata$r:0000AA88o
.data:0000AA90                                         ; .rdata$r:CBenchmarkInStream::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:0000AA90                                         ; const type_info::`vftable'
.data:0000AA94                 align 8
.data:0000AA98 a_?avcbenchmark db '.?AVCBenchmarkInStream@@',0
.data:0000AAB1                 align 4
.data:0000AAB1 _data           ends
.data:0000AAB1
.rdata$r:0000AAB4 ; ===========================================================================
.rdata$r:0000AAB4
.rdata$r:0000AAB4 ; Segment type: Pure data
.rdata$r:0000AAB4 ; Segment permissions: Read
.rdata$r:0000AAB4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000AAB4                 assume cs:_rdata$r
.rdata$r:0000AAB4                 ;org 0AAB4h
.rdata$r:0000AAB4 ; COMDAT (pick any)
.rdata$r:0000AAB4                 public ??_R3CBenchmarkInStream@@8
.rdata$r:0000AAB4 ; CBenchmarkInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000AAB4 ??_R3CBenchmarkInStream@@8 db    0      ; DATA XREF: .rdata$r:0000AA8Co
.rdata$r:0000AAB4                                         ; .rdata$r:0000AAF0o
.rdata$r:0000AAB5                 db    0
.rdata$r:0000AAB6                 db    0
.rdata$r:0000AAB7                 db    0
.rdata$r:0000AAB8                 db    1
.rdata$r:0000AAB9                 db    0
.rdata$r:0000AABA                 db    0
.rdata$r:0000AABB                 db    0
.rdata$r:0000AABC                 db    4
.rdata$r:0000AABD                 db    0
.rdata$r:0000AABE                 db    0
.rdata$r:0000AABF                 db    0
.rdata$r:0000AAC0                 dd offset ??_R2CBenchmarkInStream@@8 ; CBenchmarkInStream::`RTTI Base Class Array'
.rdata$r:0000AAC0 _rdata$r        ends
.rdata$r:0000AAC0
.rdata$r:0000AAC4 ; ===========================================================================
.rdata$r:0000AAC4
.rdata$r:0000AAC4 ; Segment type: Pure data
.rdata$r:0000AAC4 ; Segment permissions: Read
.rdata$r:0000AAC4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000AAC4                 assume cs:_rdata$r
.rdata$r:0000AAC4                 ;org 0AAC4h
.rdata$r:0000AAC4 ; COMDAT (pick any)
.rdata$r:0000AAC4                 public ??_R2CBenchmarkInStream@@8
.rdata$r:0000AAC4 ; CBenchmarkInStream::`RTTI Base Class Array'
.rdata$r:0000AAC4 ??_R2CBenchmarkInStream@@8 dd offset ??_R1A@?0A@EA@CBenchmarkInStream@@8
.rdata$r:0000AAC4                                         ; DATA XREF: .rdata$r:0000AAC0o
.rdata$r:0000AAC4                                         ; CBenchmarkInStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000AAC8                 dd offset ??_R1A@?0A@EA@ISequentialInStream@@8 ; ISequentialInStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000AACC                 dd offset ??_R1A@?0A@EA@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000AAD0                 dd offset ??_R13?0A@EA@CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Base Class Descriptor at (4,-1,0,64)'
.rdata$r:0000AAD4                 db    0
.rdata$r:0000AAD5                 align 4
.rdata$r:0000AAD5 _rdata$r        ends
.rdata$r:0000AAD5
.rdata$r:0000AAD8 ; ===========================================================================
.rdata$r:0000AAD8
.rdata$r:0000AAD8 ; Segment type: Pure data
.rdata$r:0000AAD8 ; Segment permissions: Read
.rdata$r:0000AAD8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000AAD8                 assume cs:_rdata$r
.rdata$r:0000AAD8                 ;org 0AAD8h
.rdata$r:0000AAD8 ; COMDAT (pick any)
.rdata$r:0000AAD8                 public ??_R1A@?0A@EA@CBenchmarkInStream@@8
.rdata$r:0000AAD8 ; CBenchmarkInStream::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000AAD8 ??_R1A@?0A@EA@CBenchmarkInStream@@8 dd offset ??_R0?AVCBenchmarkInStream@@@8
.rdata$r:0000AAD8                                         ; DATA XREF: .rdata$r:CBenchmarkInStream::`RTTI Base Class Array'o
.rdata$r:0000AAD8                                         ; CBenchmarkInStream `RTTI Type Descriptor'
.rdata$r:0000AADC                 db    3
.rdata$r:0000AADD                 db    0
.rdata$r:0000AADE                 db    0
.rdata$r:0000AADF                 db    0
.rdata$r:0000AAE0                 db    0
.rdata$r:0000AAE1                 db    0
.rdata$r:0000AAE2                 db    0
.rdata$r:0000AAE3                 db    0
.rdata$r:0000AAE4                 db 0FFh
.rdata$r:0000AAE5                 db 0FFh
.rdata$r:0000AAE6                 db 0FFh
.rdata$r:0000AAE7                 db 0FFh
.rdata$r:0000AAE8                 db    0
.rdata$r:0000AAE9                 db    0
.rdata$r:0000AAEA                 db    0
.rdata$r:0000AAEB                 db    0
.rdata$r:0000AAEC                 db  40h ; @
.rdata$r:0000AAED                 db    0
.rdata$r:0000AAEE                 db    0
.rdata$r:0000AAEF                 db    0
.rdata$r:0000AAF0                 dd offset ??_R3CBenchmarkInStream@@8 ; CBenchmarkInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000AAF0 _rdata$r        ends
.rdata$r:0000AAF0
.rdata$r:0000AAF4 ; ===========================================================================
.rdata$r:0000AAF4
.rdata$r:0000AAF4 ; Segment type: Pure data
.rdata$r:0000AAF4 ; Segment permissions: Read
.rdata$r:0000AAF4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000AAF4                 assume cs:_rdata$r
.rdata$r:0000AAF4                 ;org 0AAF4h
.rdata$r:0000AAF4 ; COMDAT (pick any)
.rdata$r:0000AAF4                 public ??_R1A@?0A@EA@ISequentialInStream@@8
.rdata$r:0000AAF4 ; ISequentialInStream::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000AAF4 ??_R1A@?0A@EA@ISequentialInStream@@8 dd offset ??_R0?AUISequentialInStream@@@8
.rdata$r:0000AAF4                                         ; DATA XREF: .rdata$r:0000AAC8o
.rdata$r:0000AAF4                                         ; .rdata$r:ISequentialInStream::`RTTI Base Class Array'o
.rdata$r:0000AAF4                                         ; ISequentialInStream `RTTI Type Descriptor'
.rdata$r:0000AAF8                 db    1
.rdata$r:0000AAF9                 db    0
.rdata$r:0000AAFA                 db    0
.rdata$r:0000AAFB                 db    0
.rdata$r:0000AAFC                 db    0
.rdata$r:0000AAFD                 db    0
.rdata$r:0000AAFE                 db    0
.rdata$r:0000AAFF                 db    0
.rdata$r:0000AB00                 db 0FFh
.rdata$r:0000AB01                 db 0FFh
.rdata$r:0000AB02                 db 0FFh
.rdata$r:0000AB03                 db 0FFh
.rdata$r:0000AB04                 db    0
.rdata$r:0000AB05                 db    0
.rdata$r:0000AB06                 db    0
.rdata$r:0000AB07                 db    0
.rdata$r:0000AB08                 db  40h ; @
.rdata$r:0000AB09                 db    0
.rdata$r:0000AB0A                 db    0
.rdata$r:0000AB0B                 db    0
.rdata$r:0000AB0C                 dd offset ??_R3ISequentialInStream@@8 ; ISequentialInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000AB0C _rdata$r        ends
.rdata$r:0000AB0C
.data:0000AB10 ; ===========================================================================
.data:0000AB10
.data:0000AB10 ; Segment type: Pure data
.data:0000AB10 ; Segment permissions: Read/Write
.data:0000AB10 _data           segment dword public 'DATA' use32
.data:0000AB10                 assume cs:_data
.data:0000AB10                 ;org 0AB10h
.data:0000AB10 ; COMDAT (pick any)
.data:0000AB10                 public ??_R0?AUISequentialInStream@@@8
.data:0000AB10 ; struct ISequentialInStream `RTTI Type Descriptor'
.data:0000AB10 ??_R0?AUISequentialInStream@@@8 dd offset ??_7type_info@@6B@
.data:0000AB10                                         ; DATA XREF: .rdata$r:ISequentialInStream::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:0000AB10                                         ; .rdata$r:0000AC74o
.data:0000AB10                                         ; const type_info::`vftable'
.data:0000AB14                 align 8
.data:0000AB18 a_?auisequentia db '.?AUISequentialInStream@@',0
.data:0000AB32                 align 4
.data:0000AB32 _data           ends
.data:0000AB32
.rdata$r:0000AB34 ; ===========================================================================
.rdata$r:0000AB34
.rdata$r:0000AB34 ; Segment type: Pure data
.rdata$r:0000AB34 ; Segment permissions: Read
.rdata$r:0000AB34 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000AB34                 assume cs:_rdata$r
.rdata$r:0000AB34                 ;org 0AB34h
.rdata$r:0000AB34 ; COMDAT (pick any)
.rdata$r:0000AB34                 public ??_R3ISequentialInStream@@8
.rdata$r:0000AB34 ; ISequentialInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000AB34 ??_R3ISequentialInStream@@8 db    0     ; DATA XREF: .rdata$r:0000AB0Co
.rdata$r:0000AB34                                         ; .rdata$r:0000AC78o
.rdata$r:0000AB35                 db    0
.rdata$r:0000AB36                 db    0
.rdata$r:0000AB37                 db    0
.rdata$r:0000AB38                 db    0
.rdata$r:0000AB39                 db    0
.rdata$r:0000AB3A                 db    0
.rdata$r:0000AB3B                 db    0
.rdata$r:0000AB3C                 db    2
.rdata$r:0000AB3D                 db    0
.rdata$r:0000AB3E                 db    0
.rdata$r:0000AB3F                 db    0
.rdata$r:0000AB40                 dd offset ??_R2ISequentialInStream@@8 ; ISequentialInStream::`RTTI Base Class Array'
.rdata$r:0000AB40 _rdata$r        ends
.rdata$r:0000AB40
.rdata$r:0000AB44 ; ===========================================================================
.rdata$r:0000AB44
.rdata$r:0000AB44 ; Segment type: Pure data
.rdata$r:0000AB44 ; Segment permissions: Read
.rdata$r:0000AB44 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000AB44                 assume cs:_rdata$r
.rdata$r:0000AB44                 ;org 0AB44h
.rdata$r:0000AB44 ; COMDAT (pick any)
.rdata$r:0000AB44                 public ??_R2ISequentialInStream@@8
.rdata$r:0000AB44 ; ISequentialInStream::`RTTI Base Class Array'
.rdata$r:0000AB44 ??_R2ISequentialInStream@@8 dd offset ??_R1A@?0A@EA@ISequentialInStream@@8
.rdata$r:0000AB44                                         ; DATA XREF: .rdata$r:0000AB40o
.rdata$r:0000AB44                                         ; ISequentialInStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000AB48                 dd offset ??_R1A@?0A@EA@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000AB4C                 db    0
.rdata$r:0000AB4D                 align 10h
.rdata$r:0000AB4D _rdata$r        ends
.rdata$r:0000AB4D
.text:0000AB50 ; ===========================================================================
.text:0000AB50
.text:0000AB50 ; Segment type: Pure code
.text:0000AB50 ; Segment permissions: Read/Execute
.text:0000AB50 _text           segment para public 'CODE' use32
.text:0000AB50                 assume cs:_text
.text:0000AB50                 ;org 0AB50h
.text:0000AB50 ; COMDAT (pick any)
.text:0000AB50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000AB50
.text:0000AB50 ; =============== S U B R O U T I N E =======================================
.text:0000AB50
.text:0000AB50 ; Attributes: bp-based frame
.text:0000AB50
.text:0000AB50 ; __int32 __stdcall CBenchmarkInStream::QueryInterface(CBenchmarkInStream *this, const struct _GUID *Buf1, void **)
.text:0000AB50                 public ?QueryInterface@CBenchmarkInStream@@UAGJABU_GUID@@PAPAX@Z
.text:0000AB50 ?QueryInterface@CBenchmarkInStream@@UAGJABU_GUID@@PAPAX@Z proc near
.text:0000AB50                                         ; DATA XREF: .rdata:const CBenchmarkInStream::`vftable'o
.text:0000AB50
.text:0000AB50 this            = dword ptr  8
.text:0000AB50 Buf1            = dword ptr  0Ch
.text:0000AB50 arg_8           = dword ptr  10h
.text:0000AB50
.text:0000AB50                 push    ebp
.text:0000AB51                 mov     ebp, esp
.text:0000AB53                 mov     eax, [ebp+arg_8]
.text:0000AB56                 mov     dword ptr [eax], 0
.text:0000AB5C                 push    offset _IID_IUnknown ; Buf2
.text:0000AB61                 mov     ecx, [ebp+Buf1]
.text:0000AB64                 push    ecx             ; Buf1
.text:0000AB65                 call    ___@8           ; __(x,x)
.text:0000AB6A                 test    eax, eax
.text:0000AB6C                 jz      short loc_AB78
.text:0000AB6E                 mov     edx, [ebp+arg_8]
.text:0000AB71                 mov     eax, [ebp+this]
.text:0000AB74                 mov     [edx], eax
.text:0000AB76                 jmp     short loc_AB7F
.text:0000AB78 ; ---------------------------------------------------------------------------
.text:0000AB78
.text:0000AB78 loc_AB78:                               ; CODE XREF: CBenchmarkInStream::QueryInterface(_GUID const &,void * *)+1Cj
.text:0000AB78                 mov     eax, 80004002h
.text:0000AB7D                 jmp     short loc_AB90
.text:0000AB7F ; ---------------------------------------------------------------------------
.text:0000AB7F
.text:0000AB7F loc_AB7F:                               ; CODE XREF: CBenchmarkInStream::QueryInterface(_GUID const &,void * *)+26j
.text:0000AB7F                 mov     ecx, [ebp+this]
.text:0000AB82                 mov     edx, [ecx+4]
.text:0000AB85                 add     edx, 1
.text:0000AB88                 mov     eax, [ebp+this]
.text:0000AB8B                 mov     [eax+4], edx
.text:0000AB8E                 xor     eax, eax
.text:0000AB90
.text:0000AB90 loc_AB90:                               ; CODE XREF: CBenchmarkInStream::QueryInterface(_GUID const &,void * *)+2Dj
.text:0000AB90                 cmp     ebp, esp
.text:0000AB92                 call    __RTC_CheckEsp
.text:0000AB97                 pop     ebp
.text:0000AB98                 retn    0Ch
.text:0000AB98 ?QueryInterface@CBenchmarkInStream@@UAGJABU_GUID@@PAPAX@Z endp
.text:0000AB98
.text:0000AB98 ; ---------------------------------------------------------------------------
.text:0000AB9B                 align 4
.text:0000AB9B _text           ends
.text:0000AB9B
.text:0000AB9C ; ===========================================================================
.text:0000AB9C
.text:0000AB9C ; Segment type: Pure code
.text:0000AB9C ; Segment permissions: Read/Execute
.text:0000AB9C _text           segment para public 'CODE' use32
.text:0000AB9C                 assume cs:_text
.text:0000AB9C                 ;org 0AB9Ch
.text:0000AB9C ; COMDAT (pick any)
.text:0000AB9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000AB9C
.text:0000AB9C ; =============== S U B R O U T I N E =======================================
.text:0000AB9C
.text:0000AB9C ; Attributes: bp-based frame
.text:0000AB9C
.text:0000AB9C ; unsigned __int32 __stdcall CBenchmarkInStream::AddRef(CBenchmarkInStream *this)
.text:0000AB9C                 public ?AddRef@CBenchmarkInStream@@UAGKXZ
.text:0000AB9C ?AddRef@CBenchmarkInStream@@UAGKXZ proc near ; DATA XREF: .rdata:0000AA70o
.text:0000AB9C
.text:0000AB9C var_4           = dword ptr -4
.text:0000AB9C this            = dword ptr  8
.text:0000AB9C
.text:0000AB9C                 push    ebp
.text:0000AB9D                 mov     ebp, esp
.text:0000AB9F                 push    ecx
.text:0000ABA0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000ABA7                 mov     eax, [ebp+this]
.text:0000ABAA                 mov     ecx, [eax+4]
.text:0000ABAD                 add     ecx, 1
.text:0000ABB0                 mov     [ebp+var_4], ecx
.text:0000ABB3                 mov     edx, [ebp+this]
.text:0000ABB6                 mov     eax, [ebp+var_4]
.text:0000ABB9                 mov     [edx+4], eax
.text:0000ABBC                 mov     eax, [ebp+var_4]
.text:0000ABBF                 mov     esp, ebp
.text:0000ABC1                 pop     ebp
.text:0000ABC2                 retn    4
.text:0000ABC2 ?AddRef@CBenchmarkInStream@@UAGKXZ endp
.text:0000ABC2
.text:0000ABC2 ; ---------------------------------------------------------------------------
.text:0000ABC5                 align 4
.text:0000ABC5 _text           ends
.text:0000ABC5
.text:0000ABC8 ; ===========================================================================
.text:0000ABC8
.text:0000ABC8 ; Segment type: Pure code
.text:0000ABC8 ; Segment permissions: Read/Execute
.text:0000ABC8 _text           segment para public 'CODE' use32
.text:0000ABC8                 assume cs:_text
.text:0000ABC8                 ;org 0ABC8h
.text:0000ABC8 ; COMDAT (pick any)
.text:0000ABC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000ABC8
.text:0000ABC8 ; =============== S U B R O U T I N E =======================================
.text:0000ABC8
.text:0000ABC8 ; Attributes: bp-based frame
.text:0000ABC8
.text:0000ABC8 ; unsigned __int32 __stdcall CBenchmarkInStream::Release(CBenchmarkInStream *this)
.text:0000ABC8                 public ?Release@CBenchmarkInStream@@UAGKXZ
.text:0000ABC8 ?Release@CBenchmarkInStream@@UAGKXZ proc near ; DATA XREF: .rdata:0000AA74o
.text:0000ABC8
.text:0000ABC8 var_8           = dword ptr -8
.text:0000ABC8 var_4           = dword ptr -4
.text:0000ABC8 this            = dword ptr  8
.text:0000ABC8
.text:0000ABC8                 push    ebp
.text:0000ABC9                 mov     ebp, esp
.text:0000ABCB                 sub     esp, 8
.text:0000ABCE                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000ABD5                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000ABDC                 mov     eax, [ebp+this]
.text:0000ABDF                 mov     ecx, [eax+4]
.text:0000ABE2                 sub     ecx, 1
.text:0000ABE5                 mov     [ebp+var_8], ecx
.text:0000ABE8                 mov     edx, [ebp+this]
.text:0000ABEB                 mov     eax, [ebp+var_8]
.text:0000ABEE                 mov     [edx+4], eax
.text:0000ABF1                 cmp     [ebp+var_8], 0
.text:0000ABF5                 jz      short loc_ABFF
.text:0000ABF7                 mov     ecx, [ebp+this]
.text:0000ABFA                 mov     eax, [ecx+4]
.text:0000ABFD                 jmp     short loc_AC13
.text:0000ABFF ; ---------------------------------------------------------------------------
.text:0000ABFF
.text:0000ABFF loc_ABFF:                               ; CODE XREF: CBenchmarkInStream::Release(void)+2Dj
.text:0000ABFF                 mov     edx, [ebp+this]
.text:0000AC02                 mov     [ebp+var_4], edx
.text:0000AC05                 mov     eax, [ebp+var_4]
.text:0000AC08                 push    eax             ; void *
.text:0000AC09                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000AC0E                 add     esp, 4
.text:0000AC11                 xor     eax, eax
.text:0000AC13
.text:0000AC13 loc_AC13:                               ; CODE XREF: CBenchmarkInStream::Release(void)+35j
.text:0000AC13                 add     esp, 8
.text:0000AC16                 cmp     ebp, esp
.text:0000AC18                 call    __RTC_CheckEsp
.text:0000AC1D                 mov     esp, ebp
.text:0000AC1F                 pop     ebp
.text:0000AC20                 retn    4
.text:0000AC20 ?Release@CBenchmarkInStream@@UAGKXZ endp
.text:0000AC20
.text:0000AC20 ; ---------------------------------------------------------------------------
.text:0000AC23                 align 4
.text:0000AC23 _text           ends
.text:0000AC23
.text:0000AC24 ; ===========================================================================
.text:0000AC24
.text:0000AC24 ; Segment type: Pure code
.text:0000AC24 ; Segment permissions: Read/Execute
.text:0000AC24 _text           segment para public 'CODE' use32
.text:0000AC24                 assume cs:_text
.text:0000AC24                 ;org 0AC24h
.text:0000AC24 ; COMDAT (pick any)
.text:0000AC24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000AC24
.text:0000AC24 ; =============== S U B R O U T I N E =======================================
.text:0000AC24
.text:0000AC24 ; Attributes: bp-based frame
.text:0000AC24
.text:0000AC24 ; _DWORD __thiscall ISequentialInStream::ISequentialInStream(ISequentialInStream *__hidden this)
.text:0000AC24                 public ??0ISequentialInStream@@QAE@XZ
.text:0000AC24 ??0ISequentialInStream@@QAE@XZ proc near
.text:0000AC24                                         ; CODE XREF: CBenchmarkInStream::CBenchmarkInStream(void)+11p
.text:0000AC24
.text:0000AC24 var_4           = dword ptr -4
.text:0000AC24
.text:0000AC24                 push    ebp
.text:0000AC25                 mov     ebp, esp
.text:0000AC27                 push    ecx
.text:0000AC28                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000AC2F                 mov     [ebp+var_4], ecx
.text:0000AC32                 mov     ecx, [ebp+var_4]
.text:0000AC35                 call    ??0IUnknown@@QAE@XZ ; IUnknown::IUnknown(void)
.text:0000AC3A                 mov     eax, [ebp+var_4]
.text:0000AC3D                 mov     dword ptr [eax], offset ??_7ISequentialInStream@@6B@ ; const ISequentialInStream::`vftable'
.text:0000AC43                 mov     eax, [ebp+var_4]
.text:0000AC46                 add     esp, 4
.text:0000AC49                 cmp     ebp, esp
.text:0000AC4B                 call    __RTC_CheckEsp
.text:0000AC50                 mov     esp, ebp
.text:0000AC52                 pop     ebp
.text:0000AC53                 retn
.text:0000AC53 ??0ISequentialInStream@@QAE@XZ endp
.text:0000AC53
.text:0000AC53 _text           ends
.text:0000AC53
.rdata:0000AC54 ; ===========================================================================
.rdata:0000AC54
.rdata:0000AC54 ; Segment type: Pure data
.rdata:0000AC54 ; Segment permissions: Read
.rdata:0000AC54 _rdata          segment dword public 'DATA' use32
.rdata:0000AC54                 assume cs:_rdata
.rdata:0000AC54                 ;org 0AC54h
.rdata:0000AC54 ; COMDAT (pick largest)
.rdata:0000AC54                 dd offset ??_R4ISequentialInStream@@6B@ ; const ISequentialInStream::`RTTI Complete Object Locator'
.rdata:0000AC58                 public ??_7ISequentialInStream@@6B@
.rdata:0000AC58 ; const ISequentialInStream::`vftable'
.rdata:0000AC58 ??_7ISequentialInStream@@6B@ dd offset __purecall
.rdata:0000AC58                                         ; DATA XREF: ISequentialInStream::ISequentialInStream(void)+19o
.rdata:0000AC5C                 dd offset __purecall
.rdata:0000AC60                 dd offset __purecall
.rdata:0000AC64                 dd offset __purecall
.rdata:0000AC64 _rdata          ends
.rdata:0000AC64
.rdata$r:0000AC68 ; ===========================================================================
.rdata$r:0000AC68
.rdata$r:0000AC68 ; Segment type: Pure data
.rdata$r:0000AC68 ; Segment permissions: Read
.rdata$r:0000AC68 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000AC68                 assume cs:_rdata$r
.rdata$r:0000AC68                 ;org 0AC68h
.rdata$r:0000AC68 ; COMDAT (pick any)
.rdata$r:0000AC68                 public ??_R4ISequentialInStream@@6B@
.rdata$r:0000AC68 ; const ISequentialInStream::`RTTI Complete Object Locator'
.rdata$r:0000AC68 ??_R4ISequentialInStream@@6B@ db    0   ; DATA XREF: .rdata:0000AC54o
.rdata$r:0000AC69                 db    0
.rdata$r:0000AC6A                 db    0
.rdata$r:0000AC6B                 db    0
.rdata$r:0000AC6C                 db    0
.rdata$r:0000AC6D                 db    0
.rdata$r:0000AC6E                 db    0
.rdata$r:0000AC6F                 db    0
.rdata$r:0000AC70                 db    0
.rdata$r:0000AC71                 db    0
.rdata$r:0000AC72                 db    0
.rdata$r:0000AC73                 db    0
.rdata$r:0000AC74                 dd offset ??_R0?AUISequentialInStream@@@8 ; ISequentialInStream `RTTI Type Descriptor'
.rdata$r:0000AC78                 dd offset ??_R3ISequentialInStream@@8 ; ISequentialInStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000AC78 _rdata$r        ends
.rdata$r:0000AC78
.text:0000AC7C ; ===========================================================================
.text:0000AC7C
.text:0000AC7C ; Segment type: Pure code
.text:0000AC7C ; Segment permissions: Read/Execute
.text:0000AC7C _text           segment para public 'CODE' use32
.text:0000AC7C                 assume cs:_text
.text:0000AC7C                 ;org 0AC7Ch
.text:0000AC7C ; COMDAT (pick any)
.text:0000AC7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000AC7C
.text:0000AC7C ; =============== S U B R O U T I N E =======================================
.text:0000AC7C
.text:0000AC7C ; Attributes: bp-based frame
.text:0000AC7C
.text:0000AC7C ; public: void * __thiscall CEncoderInfo::`vector deleting destructor'(unsigned int)
.text:0000AC7C                 public ??_ECEncoderInfo@@QAEPAXI@Z
.text:0000AC7C ??_ECEncoderInfo@@QAEPAXI@Z proc near   ; CODE XREF: CBenchEncoders::~CBenchEncoders(void)+33p
.text:0000AC7C
.text:0000AC7C var_4           = dword ptr -4
.text:0000AC7C arg_0           = dword ptr  8
.text:0000AC7C
.text:0000AC7C                 push    ebp
.text:0000AC7D                 mov     ebp, esp
.text:0000AC7F                 push    ecx
.text:0000AC80                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000AC87                 mov     [ebp+var_4], ecx
.text:0000AC8A                 mov     eax, [ebp+arg_0]
.text:0000AC8D                 and     eax, 2
.text:0000AC90                 jz      short loc_ACCB
.text:0000AC92                 push    offset ??1CEncoderInfo@@QAE@XZ ; CEncoderInfo::~CEncoderInfo(void)
.text:0000AC97                 mov     ecx, [ebp+var_4]
.text:0000AC9A                 mov     edx, [ecx-4]
.text:0000AC9D                 push    edx
.text:0000AC9E                 push    118h
.text:0000ACA3                 mov     eax, [ebp+var_4]
.text:0000ACA6                 push    eax
.text:0000ACA7                 call    ??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
.text:0000ACAC                 mov     ecx, [ebp+arg_0]
.text:0000ACAF                 and     ecx, 1
.text:0000ACB2                 jz      short loc_ACC3
.text:0000ACB4                 mov     edx, [ebp+var_4]
.text:0000ACB7                 sub     edx, 4
.text:0000ACBA                 push    edx             ; void *
.text:0000ACBB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000ACC0                 add     esp, 4
.text:0000ACC3
.text:0000ACC3 loc_ACC3:                               ; CODE XREF: CEncoderInfo::`vector deleting destructor'(uint)+36j
.text:0000ACC3                 mov     eax, [ebp+var_4]
.text:0000ACC6                 sub     eax, 4
.text:0000ACC9                 jmp     short loc_ACEA
.text:0000ACCB ; ---------------------------------------------------------------------------
.text:0000ACCB
.text:0000ACCB loc_ACCB:                               ; CODE XREF: CEncoderInfo::`vector deleting destructor'(uint)+14j
.text:0000ACCB                 mov     ecx, [ebp+var_4] ; this
.text:0000ACCE                 call    ??1CEncoderInfo@@QAE@XZ ; CEncoderInfo::~CEncoderInfo(void)
.text:0000ACD3                 mov     eax, [ebp+arg_0]
.text:0000ACD6                 and     eax, 1
.text:0000ACD9                 jz      short loc_ACE7
.text:0000ACDB                 mov     ecx, [ebp+var_4]
.text:0000ACDE                 push    ecx             ; void *
.text:0000ACDF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000ACE4                 add     esp, 4
.text:0000ACE7
.text:0000ACE7 loc_ACE7:                               ; CODE XREF: CEncoderInfo::`vector deleting destructor'(uint)+5Dj
.text:0000ACE7                 mov     eax, [ebp+var_4]
.text:0000ACEA
.text:0000ACEA loc_ACEA:                               ; CODE XREF: CEncoderInfo::`vector deleting destructor'(uint)+4Dj
.text:0000ACEA                 add     esp, 4
.text:0000ACED                 cmp     ebp, esp
.text:0000ACEF                 call    __RTC_CheckEsp
.text:0000ACF4                 mov     esp, ebp
.text:0000ACF6                 pop     ebp
.text:0000ACF7                 retn    4
.text:0000ACF7 ??_ECEncoderInfo@@QAEPAXI@Z endp
.text:0000ACF7
.text:0000ACF7 ; ---------------------------------------------------------------------------
.text:0000ACFA                 align 4
.text:0000ACFA _text           ends
.text:0000ACFA
.text:0000ACFC ; ===========================================================================
.text:0000ACFC
.text:0000ACFC ; Segment type: Pure code
.text:0000ACFC ; Segment permissions: Read/Execute
.text:0000ACFC _text           segment para public 'CODE' use32
.text:0000ACFC                 assume cs:_text
.text:0000ACFC                 ;org 0ACFCh
.text:0000ACFC ; COMDAT (pick any)
.text:0000ACFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000ACFC
.text:0000ACFC ; =============== S U B R O U T I N E =======================================
.text:0000ACFC
.text:0000ACFC ; Attributes: bp-based frame
.text:0000ACFC
.text:0000ACFC ; _DWORD __thiscall CEncoderInfo::~CEncoderInfo(CEncoderInfo *__hidden this)
.text:0000ACFC                 public ??1CEncoderInfo@@QAE@XZ
.text:0000ACFC ??1CEncoderInfo@@QAE@XZ proc near       ; CODE XREF: CEncoderInfo::`vector deleting destructor'(uint)+52p
.text:0000ACFC                                         ; DATA XREF: CEncoderInfo::`vector deleting destructor'(uint)+16o ...
.text:0000ACFC
.text:0000ACFC var_10          = dword ptr -10h
.text:0000ACFC var_C           = dword ptr -0Ch
.text:0000ACFC var_4           = dword ptr -4
.text:0000ACFC
.text:0000ACFC                 push    ebp
.text:0000ACFD                 mov     ebp, esp
.text:0000ACFF                 push    0FFFFFFFFh
.text:0000AD01                 push    offset __ehhandler$??1CEncoderInfo@@QAE@XZ
.text:0000AD06                 mov     eax, large fs:0
.text:0000AD0C                 push    eax
.text:0000AD0D                 push    ecx
.text:0000AD0E                 mov     [ebp+var_10], 0CCCCCCCCh
.text:0000AD15                 mov     eax, dword ptr ds:___security_cookie
.text:0000AD1A                 xor     eax, ebp
.text:0000AD1C                 push    eax
.text:0000AD1D                 lea     eax, [ebp+var_C]
.text:0000AD20                 mov     large fs:0, eax
.text:0000AD26                 mov     [ebp+var_10], ecx
.text:0000AD29                 mov     [ebp+var_4], 9
.text:0000AD30                 mov     ecx, [ebp+var_10]
.text:0000AD33                 add     ecx, 0ECh ; '8' ; this
.text:0000AD39                 call    ??1COneMethodInfo@@QAE@XZ ; COneMethodInfo::~COneMethodInfo(void)
.text:0000AD3E                 mov     byte ptr [ebp+var_4], 8
.text:0000AD42                 mov     ecx, [ebp+var_10]
.text:0000AD45                 add     ecx, 0E8h ; 'F'
.text:0000AD4B                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:0000AD50                 mov     byte ptr [ebp+var_4], 7
.text:0000AD54                 mov     ecx, [ebp+var_10]
.text:0000AD57                 add     ecx, 0D8h ; '+' ; this
.text:0000AD5D                 call    ??1CBenchBuffer@@UAE@XZ ; CBenchBuffer::~CBenchBuffer(void)
.text:0000AD62                 mov     byte ptr [ebp+var_4], 6
.text:0000AD66                 mov     ecx, [ebp+var_10]
.text:0000AD69                 add     ecx, 0C8h ; '+' ; this
.text:0000AD6F                 call    ??1CBenchRandomGenerator@@UAE@XZ ; CBenchRandomGenerator::~CBenchRandomGenerator(void)
.text:0000AD74                 mov     byte ptr [ebp+var_4], 5
.text:0000AD78                 mov     ecx, [ebp+var_10]
.text:0000AD7B                 add     ecx, 0B0h ; '¦'
.text:0000AD81                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:0000AD86                 mov     byte ptr [ebp+var_4], 4
.text:0000AD8A                 mov     ecx, [ebp+var_10]
.text:0000AD8D                 add     ecx, 0A0h ; 'á'
.text:0000AD93                 call    ??1?$CMyComPtr@UICompressFilter@@@@QAE@XZ ; CMyComPtr<ICompressFilter>::~CMyComPtr<ICompressFilter>(void)
.text:0000AD98                 mov     byte ptr [ebp+var_4], 3
.text:0000AD9C                 push    offset ??1?$CMyComPtr@UICompressCoder@@@@QAE@XZ ; CMyComPtr<ICompressCoder>::~CMyComPtr<ICompressCoder>(void)
.text:0000ADA1                 push    2
.text:0000ADA3                 push    4
.text:0000ADA5                 mov     eax, [ebp+var_10]
.text:0000ADA8                 add     eax, 98h ; 'ÿ'
.text:0000ADAD                 push    eax
.text:0000ADAE                 call    ??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
.text:0000ADB3                 mov     byte ptr [ebp+var_4], 2
.text:0000ADB7                 push    offset ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ ; CMyComPtr<ICompressProgressInfo>::~CMyComPtr<ICompressProgressInfo>(void)
.text:0000ADBC                 push    2
.text:0000ADBE                 push    4
.text:0000ADC0                 mov     ecx, [ebp+var_10]
.text:0000ADC3                 add     ecx, 1Ch
.text:0000ADC6                 push    ecx
.text:0000ADC7                 call    ??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
.text:0000ADCC                 mov     byte ptr [ebp+var_4], 1
.text:0000ADD0                 mov     ecx, [ebp+var_10]
.text:0000ADD3                 add     ecx, 10h
.text:0000ADD6                 call    ??1?$CMyComPtr@UICompressFilter@@@@QAE@XZ ; CMyComPtr<ICompressFilter>::~CMyComPtr<ICompressFilter>(void)
.text:0000ADDB                 mov     byte ptr [ebp+var_4], 0
.text:0000ADDF                 mov     ecx, [ebp+var_10]
.text:0000ADE2                 add     ecx, 0Ch
.text:0000ADE5                 call    ??1?$CMyComPtr@UICompressCoder@@@@QAE@XZ ; CMyComPtr<ICompressCoder>::~CMyComPtr<ICompressCoder>(void)
.text:0000ADEA                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000ADF1                 push    offset ??1CThread@NWindows@@QAE@XZ ; NWindows::CThread::~CThread(void)
.text:0000ADF6                 push    2
.text:0000ADF8                 push    4
.text:0000ADFA                 mov     edx, [ebp+var_10]
.text:0000ADFD                 push    edx
.text:0000ADFE                 call    ??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
.text:0000AE03                 mov     ecx, [ebp+var_C]
.text:0000AE06                 mov     large fs:0, ecx
.text:0000AE0D                 pop     ecx
.text:0000AE0E                 add     esp, 10h
.text:0000AE11                 cmp     ebp, esp
.text:0000AE13                 call    __RTC_CheckEsp
.text:0000AE18                 mov     esp, ebp
.text:0000AE1A                 pop     ebp
.text:0000AE1B                 retn
.text:0000AE1B ??1CEncoderInfo@@QAE@XZ endp
.text:0000AE1B
.text:0000AE1B _text           ends
.text:0000AE1B
.text$x:0000AE1C ; ===========================================================================
.text$x:0000AE1C
.text$x:0000AE1C ; Segment type: Pure code
.text$x:0000AE1C ; Segment permissions: Read/Execute
.text$x:0000AE1C _text$x         segment para public 'CODE' use32
.text$x:0000AE1C                 assume cs:_text$x
.text$x:0000AE1C                 ;org 0AE1Ch
.text$x:0000AE1C ; COMDAT (pick associative to section at ACFC)
.text$x:0000AE1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000AE1C
.text$x:0000AE1C ; =============== S U B R O U T I N E =======================================
.text$x:0000AE1C
.text$x:0000AE1C
.text$x:0000AE1C __unwindfunclet$??1CEncoderInfo@@QAE@XZ$0 proc near
.text$x:0000AE1C                                         ; DATA XREF: .xdata$x:0000AEFCo
.text$x:0000AE1C                 push    offset ??1CThread@NWindows@@QAE@XZ ; NWindows::CThread::~CThread(void)
.text$x:0000AE21                 push    2
.text$x:0000AE23                 push    4
.text$x:0000AE25                 mov     eax, [ebp-10h]
.text$x:0000AE28                 push    eax
.text$x:0000AE29                 call    ??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
.text$x:0000AE2E                 retn
.text$x:0000AE2E __unwindfunclet$??1CEncoderInfo@@QAE@XZ$0 endp
.text$x:0000AE2E
.text$x:0000AE2F
.text$x:0000AE2F ; =============== S U B R O U T I N E =======================================
.text$x:0000AE2F
.text$x:0000AE2F
.text$x:0000AE2F __unwindfunclet$??1CEncoderInfo@@QAE@XZ$1 proc near
.text$x:0000AE2F                                         ; DATA XREF: .xdata$x:0000AF04o
.text$x:0000AE2F                 mov     ecx, [ebp-10h]
.text$x:0000AE32                 add     ecx, 0Ch
.text$x:0000AE35                 jmp     ??1?$CMyComPtr@UICompressCoder@@@@QAE@XZ ; CMyComPtr<ICompressCoder>::~CMyComPtr<ICompressCoder>(void)
.text$x:0000AE35 __unwindfunclet$??1CEncoderInfo@@QAE@XZ$1 endp
.text$x:0000AE35
.text$x:0000AE3A
.text$x:0000AE3A ; =============== S U B R O U T I N E =======================================
.text$x:0000AE3A
.text$x:0000AE3A
.text$x:0000AE3A __unwindfunclet$??1CEncoderInfo@@QAE@XZ$2 proc near
.text$x:0000AE3A                                         ; DATA XREF: .xdata$x:0000AF0Co
.text$x:0000AE3A                 mov     ecx, [ebp-10h]
.text$x:0000AE3D                 add     ecx, 10h
.text$x:0000AE40                 jmp     ??1?$CMyComPtr@UICompressFilter@@@@QAE@XZ ; CMyComPtr<ICompressFilter>::~CMyComPtr<ICompressFilter>(void)
.text$x:0000AE40 __unwindfunclet$??1CEncoderInfo@@QAE@XZ$2 endp
.text$x:0000AE40
.text$x:0000AE45
.text$x:0000AE45 ; =============== S U B R O U T I N E =======================================
.text$x:0000AE45
.text$x:0000AE45
.text$x:0000AE45 __unwindfunclet$??1CEncoderInfo@@QAE@XZ$3 proc near
.text$x:0000AE45                                         ; DATA XREF: .xdata$x:0000AF14o
.text$x:0000AE45                 push    offset ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ ; CMyComPtr<ICompressProgressInfo>::~CMyComPtr<ICompressProgressInfo>(void)
.text$x:0000AE4A                 push    2
.text$x:0000AE4C                 push    4
.text$x:0000AE4E                 mov     eax, [ebp-10h]
.text$x:0000AE51                 add     eax, 1Ch
.text$x:0000AE54                 push    eax
.text$x:0000AE55                 call    ??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
.text$x:0000AE5A                 retn
.text$x:0000AE5A __unwindfunclet$??1CEncoderInfo@@QAE@XZ$3 endp
.text$x:0000AE5A
.text$x:0000AE5B
.text$x:0000AE5B ; =============== S U B R O U T I N E =======================================
.text$x:0000AE5B
.text$x:0000AE5B
.text$x:0000AE5B __unwindfunclet$??1CEncoderInfo@@QAE@XZ$4 proc near
.text$x:0000AE5B                                         ; DATA XREF: .xdata$x:0000AF1Co
.text$x:0000AE5B                 push    offset ??1?$CMyComPtr@UICompressCoder@@@@QAE@XZ ; CMyComPtr<ICompressCoder>::~CMyComPtr<ICompressCoder>(void)
.text$x:0000AE60                 push    2
.text$x:0000AE62                 push    4
.text$x:0000AE64                 mov     eax, [ebp-10h]
.text$x:0000AE67                 add     eax, 98h ; 'ÿ'
.text$x:0000AE6C                 push    eax
.text$x:0000AE6D                 call    ??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
.text$x:0000AE72                 retn
.text$x:0000AE72 __unwindfunclet$??1CEncoderInfo@@QAE@XZ$4 endp
.text$x:0000AE72
.text$x:0000AE73
.text$x:0000AE73 ; =============== S U B R O U T I N E =======================================
.text$x:0000AE73
.text$x:0000AE73
.text$x:0000AE73 __unwindfunclet$??1CEncoderInfo@@QAE@XZ$5 proc near
.text$x:0000AE73                                         ; DATA XREF: .xdata$x:0000AF24o
.text$x:0000AE73                 mov     ecx, [ebp-10h]
.text$x:0000AE76                 add     ecx, 0A0h ; 'á'
.text$x:0000AE7C                 jmp     ??1?$CMyComPtr@UICompressFilter@@@@QAE@XZ ; CMyComPtr<ICompressFilter>::~CMyComPtr<ICompressFilter>(void)
.text$x:0000AE7C __unwindfunclet$??1CEncoderInfo@@QAE@XZ$5 endp
.text$x:0000AE7C
.text$x:0000AE81
.text$x:0000AE81 ; =============== S U B R O U T I N E =======================================
.text$x:0000AE81
.text$x:0000AE81
.text$x:0000AE81 __unwindfunclet$??1CEncoderInfo@@QAE@XZ$6 proc near
.text$x:0000AE81                                         ; DATA XREF: .xdata$x:0000AF2Co
.text$x:0000AE81                 mov     ecx, [ebp-10h]
.text$x:0000AE84                 add     ecx, 0B0h ; '¦'
.text$x:0000AE8A                 jmp     ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text$x:0000AE8A __unwindfunclet$??1CEncoderInfo@@QAE@XZ$6 endp
.text$x:0000AE8A
.text$x:0000AE8F
.text$x:0000AE8F ; =============== S U B R O U T I N E =======================================
.text$x:0000AE8F
.text$x:0000AE8F
.text$x:0000AE8F __unwindfunclet$??1CEncoderInfo@@QAE@XZ$7 proc near
.text$x:0000AE8F                                         ; DATA XREF: .xdata$x:0000AF34o
.text$x:0000AE8F                 mov     ecx, [ebp-10h]
.text$x:0000AE92                 add     ecx, 0C8h ; '+' ; this
.text$x:0000AE98                 jmp     ??1CBenchRandomGenerator@@UAE@XZ ; CBenchRandomGenerator::~CBenchRandomGenerator(void)
.text$x:0000AE98 __unwindfunclet$??1CEncoderInfo@@QAE@XZ$7 endp
.text$x:0000AE98
.text$x:0000AE9D
.text$x:0000AE9D ; =============== S U B R O U T I N E =======================================
.text$x:0000AE9D
.text$x:0000AE9D
.text$x:0000AE9D __unwindfunclet$??1CEncoderInfo@@QAE@XZ$8 proc near
.text$x:0000AE9D                                         ; DATA XREF: .xdata$x:0000AF3Co
.text$x:0000AE9D                 mov     ecx, [ebp-10h]
.text$x:0000AEA0                 add     ecx, 0D8h ; '+' ; this
.text$x:0000AEA6                 jmp     ??1CBenchBuffer@@UAE@XZ ; CBenchBuffer::~CBenchBuffer(void)
.text$x:0000AEA6 __unwindfunclet$??1CEncoderInfo@@QAE@XZ$8 endp
.text$x:0000AEA6
.text$x:0000AEAB
.text$x:0000AEAB ; =============== S U B R O U T I N E =======================================
.text$x:0000AEAB
.text$x:0000AEAB
.text$x:0000AEAB __unwindfunclet$??1CEncoderInfo@@QAE@XZ$9 proc near
.text$x:0000AEAB                                         ; DATA XREF: .xdata$x:0000AF44o
.text$x:0000AEAB                 mov     ecx, [ebp-10h]
.text$x:0000AEAE                 add     ecx, 0E8h ; 'F'
.text$x:0000AEB4                 jmp     ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text$x:0000AEB4 __unwindfunclet$??1CEncoderInfo@@QAE@XZ$9 endp
.text$x:0000AEB4
.text$x:0000AEB9
.text$x:0000AEB9 ; =============== S U B R O U T I N E =======================================
.text$x:0000AEB9
.text$x:0000AEB9
.text$x:0000AEB9 __ehhandler$??1CEncoderInfo@@QAE@XZ proc near
.text$x:0000AEB9                                         ; DATA XREF: CEncoderInfo::~CEncoderInfo(void)+5o
.text$x:0000AEB9
.text$x:0000AEB9 arg_4           = dword ptr  8
.text$x:0000AEB9
.text$x:0000AEB9                 mov     edx, [esp+arg_4]
.text$x:0000AEBD                 lea     eax, [edx+0Ch]
.text$x:0000AEC0                 mov     ecx, [edx-8]
.text$x:0000AEC3                 xor     ecx, eax
.text$x:0000AEC5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000AECA                 mov     eax, offset __ehfuncinfo$??1CEncoderInfo@@QAE@XZ
.text$x:0000AECF                 jmp     ___CxxFrameHandler3
.text$x:0000AECF __ehhandler$??1CEncoderInfo@@QAE@XZ endp
.text$x:0000AECF
.text$x:0000AECF _text$x         ends
.text$x:0000AECF
.xdata$x:0000AED4 ; ===========================================================================
.xdata$x:0000AED4
.xdata$x:0000AED4 ; Segment type: Pure data
.xdata$x:0000AED4 ; Segment permissions: Read
.xdata$x:0000AED4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000AED4                 assume cs:_xdata$x
.xdata$x:0000AED4                 ;org 0AED4h
.xdata$x:0000AED4 ; COMDAT (pick associative to section at ACFC)
.xdata$x:0000AED4 __ehfuncinfo$??1CEncoderInfo@@QAE@XZ db  22h ; "
.xdata$x:0000AED4                                         ; DATA XREF: __ehhandler$??1CEncoderInfo@@QAE@XZ+11o
.xdata$x:0000AED5                 db    5
.xdata$x:0000AED6                 db  93h ; ô
.xdata$x:0000AED7                 db  19h
.xdata$x:0000AED8                 db  0Ah
.xdata$x:0000AED9                 db    0
.xdata$x:0000AEDA                 db    0
.xdata$x:0000AEDB                 db    0
.xdata$x:0000AEDC                 dd offset __unwindtable$??1CEncoderInfo@@QAE@XZ
.xdata$x:0000AEE0                 db    0
.xdata$x:0000AEE1                 db    0
.xdata$x:0000AEE2                 db    0
.xdata$x:0000AEE3                 db    0
.xdata$x:0000AEE4                 db    0
.xdata$x:0000AEE5                 db    0
.xdata$x:0000AEE6                 db    0
.xdata$x:0000AEE7                 db    0
.xdata$x:0000AEE8                 db    0
.xdata$x:0000AEE9                 db    0
.xdata$x:0000AEEA                 db    0
.xdata$x:0000AEEB                 db    0
.xdata$x:0000AEEC                 db    0
.xdata$x:0000AEED                 db    0
.xdata$x:0000AEEE                 db    0
.xdata$x:0000AEEF                 db    0
.xdata$x:0000AEF0                 db    0
.xdata$x:0000AEF1                 db    0
.xdata$x:0000AEF2                 db    0
.xdata$x:0000AEF3                 db    0
.xdata$x:0000AEF4                 db    1
.xdata$x:0000AEF5                 db    0
.xdata$x:0000AEF6                 db    0
.xdata$x:0000AEF7                 db    0
.xdata$x:0000AEF8 __unwindtable$??1CEncoderInfo@@QAE@XZ db 0FFh
.xdata$x:0000AEF8                                         ; DATA XREF: .xdata$x:0000AEDCo
.xdata$x:0000AEF9                 db 0FFh
.xdata$x:0000AEFA                 db 0FFh
.xdata$x:0000AEFB                 db 0FFh
.xdata$x:0000AEFC                 dd offset __unwindfunclet$??1CEncoderInfo@@QAE@XZ$0
.xdata$x:0000AF00                 db    0
.xdata$x:0000AF01                 db    0
.xdata$x:0000AF02                 db    0
.xdata$x:0000AF03                 db    0
.xdata$x:0000AF04                 dd offset __unwindfunclet$??1CEncoderInfo@@QAE@XZ$1
.xdata$x:0000AF08                 db    1
.xdata$x:0000AF09                 db    0
.xdata$x:0000AF0A                 db    0
.xdata$x:0000AF0B                 db    0
.xdata$x:0000AF0C                 dd offset __unwindfunclet$??1CEncoderInfo@@QAE@XZ$2
.xdata$x:0000AF10                 db    2
.xdata$x:0000AF11                 db    0
.xdata$x:0000AF12                 db    0
.xdata$x:0000AF13                 db    0
.xdata$x:0000AF14                 dd offset __unwindfunclet$??1CEncoderInfo@@QAE@XZ$3
.xdata$x:0000AF18                 db    3
.xdata$x:0000AF19                 db    0
.xdata$x:0000AF1A                 db    0
.xdata$x:0000AF1B                 db    0
.xdata$x:0000AF1C                 dd offset __unwindfunclet$??1CEncoderInfo@@QAE@XZ$4
.xdata$x:0000AF20                 db    4
.xdata$x:0000AF21                 db    0
.xdata$x:0000AF22                 db    0
.xdata$x:0000AF23                 db    0
.xdata$x:0000AF24                 dd offset __unwindfunclet$??1CEncoderInfo@@QAE@XZ$5
.xdata$x:0000AF28                 db    5
.xdata$x:0000AF29                 db    0
.xdata$x:0000AF2A                 db    0
.xdata$x:0000AF2B                 db    0
.xdata$x:0000AF2C                 dd offset __unwindfunclet$??1CEncoderInfo@@QAE@XZ$6
.xdata$x:0000AF30                 db    6
.xdata$x:0000AF31                 db    0
.xdata$x:0000AF32                 db    0
.xdata$x:0000AF33                 db    0
.xdata$x:0000AF34                 dd offset __unwindfunclet$??1CEncoderInfo@@QAE@XZ$7
.xdata$x:0000AF38                 db    7
.xdata$x:0000AF39                 db    0
.xdata$x:0000AF3A                 db    0
.xdata$x:0000AF3B                 db    0
.xdata$x:0000AF3C                 dd offset __unwindfunclet$??1CEncoderInfo@@QAE@XZ$8
.xdata$x:0000AF40                 db    8
.xdata$x:0000AF41                 db    0
.xdata$x:0000AF42                 db    0
.xdata$x:0000AF43                 db    0
.xdata$x:0000AF44                 dd offset __unwindfunclet$??1CEncoderInfo@@QAE@XZ$9
.xdata$x:0000AF44 _xdata$x        ends
.xdata$x:0000AF44
.text:0000AF48 ; ===========================================================================
.text:0000AF48
.text:0000AF48 ; Segment type: Pure code
.text:0000AF48 ; Segment permissions: Read/Execute
.text:0000AF48 _text           segment para public 'CODE' use32
.text:0000AF48                 assume cs:_text
.text:0000AF48                 ;org 0AF48h
.text:0000AF48 ; COMDAT (pick any)
.text:0000AF48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000AF48
.text:0000AF48 ; =============== S U B R O U T I N E =======================================
.text:0000AF48
.text:0000AF48 ; Attributes: bp-based frame
.text:0000AF48
.text:0000AF48 ; _DWORD __thiscall NWindows::CThread::~CThread(NWindows::CThread *__hidden this)
.text:0000AF48                 public ??1CThread@NWindows@@QAE@XZ
.text:0000AF48 ??1CThread@NWindows@@QAE@XZ proc near   ; CODE XREF: CFreqInfo::~CFreqInfo(void)+11p
.text:0000AF48                                         ; CCrcInfo::~CCrcInfo(void)+49p ...
.text:0000AF48
.text:0000AF48 var_4           = dword ptr -4
.text:0000AF48
.text:0000AF48                 push    ebp
.text:0000AF49                 mov     ebp, esp
.text:0000AF4B                 push    ecx
.text:0000AF4C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000AF53                 mov     [ebp+var_4], ecx
.text:0000AF56                 mov     ecx, [ebp+var_4] ; this
.text:0000AF59                 call    ?Close@CThread@NWindows@@QAEIXZ ; NWindows::CThread::Close(void)
.text:0000AF5E                 add     esp, 4
.text:0000AF61                 cmp     ebp, esp
.text:0000AF63                 call    __RTC_CheckEsp
.text:0000AF68                 mov     esp, ebp
.text:0000AF6A                 pop     ebp
.text:0000AF6B                 retn
.text:0000AF6B ??1CThread@NWindows@@QAE@XZ endp
.text:0000AF6B
.text:0000AF6B _text           ends
.text:0000AF6B
.text:0000AF6C ; ===========================================================================
.text:0000AF6C
.text:0000AF6C ; Segment type: Pure code
.text:0000AF6C ; Segment permissions: Read/Execute
.text:0000AF6C _text           segment para public 'CODE' use32
.text:0000AF6C                 assume cs:_text
.text:0000AF6C                 ;org 0AF6Ch
.text:0000AF6C ; COMDAT (pick any)
.text:0000AF6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000AF6C
.text:0000AF6C ; =============== S U B R O U T I N E =======================================
.text:0000AF6C
.text:0000AF6C ; Attributes: bp-based frame
.text:0000AF6C
.text:0000AF6C ; unsigned int __thiscall NWindows::CThread::Close(NWindows::CThread *__hidden this)
.text:0000AF6C                 public ?Close@CThread@NWindows@@QAEIXZ
.text:0000AF6C ?Close@CThread@NWindows@@QAEIXZ proc near
.text:0000AF6C                                         ; CODE XREF: NWindows::CThread::~CThread(void)+11p
.text:0000AF6C                                         ; CFreqInfo::Wait(void)+19p ...
.text:0000AF6C
.text:0000AF6C var_4           = dword ptr -4
.text:0000AF6C
.text:0000AF6C                 push    ebp
.text:0000AF6D                 mov     ebp, esp
.text:0000AF6F                 push    ecx
.text:0000AF70                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000AF77                 mov     [ebp+var_4], ecx
.text:0000AF7A                 mov     eax, [ebp+var_4]
.text:0000AF7D                 push    eax
.text:0000AF7E                 call    _HandlePtr_Close@4 ; HandlePtr_Close(x)
.text:0000AF83                 add     esp, 4
.text:0000AF86                 cmp     ebp, esp
.text:0000AF88                 call    __RTC_CheckEsp
.text:0000AF8D                 mov     esp, ebp
.text:0000AF8F                 pop     ebp
.text:0000AF90                 retn
.text:0000AF90 ?Close@CThread@NWindows@@QAEIXZ endp
.text:0000AF90
.text:0000AF90 ; ---------------------------------------------------------------------------
.text:0000AF91                 align 4
.text:0000AF91 _text           ends
.text:0000AF91
.text:0000AF94 ; ===========================================================================
.text:0000AF94
.text:0000AF94 ; Segment type: Pure code
.text:0000AF94 ; Segment permissions: Read/Execute
.text:0000AF94 _text           segment para public 'CODE' use32
.text:0000AF94                 assume cs:_text
.text:0000AF94                 ;org 0AF94h
.text:0000AF94 ; COMDAT (pick any)
.text:0000AF94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000AF94
.text:0000AF94 ; =============== S U B R O U T I N E =======================================
.text:0000AF94
.text:0000AF94 ; Attributes: bp-based frame
.text:0000AF94
.text:0000AF94 ; _DWORD __thiscall CBenchRandomGenerator::~CBenchRandomGenerator(CBenchRandomGenerator *__hidden this)
.text:0000AF94                 public ??1CBenchRandomGenerator@@UAE@XZ
.text:0000AF94 ??1CBenchRandomGenerator@@UAE@XZ proc near
.text:0000AF94                                         ; CODE XREF: CEncoderInfo::~CEncoderInfo(void)+73p
.text:0000AF94                                         ; __unwindfunclet$??1CEncoderInfo@@QAE@XZ$7+9j ...
.text:0000AF94
.text:0000AF94 var_4           = dword ptr -4
.text:0000AF94
.text:0000AF94                 push    ebp
.text:0000AF95                 mov     ebp, esp
.text:0000AF97                 push    ecx
.text:0000AF98                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000AF9F                 mov     [ebp+var_4], ecx
.text:0000AFA2                 mov     ecx, [ebp+var_4] ; this
.text:0000AFA5                 call    ??1CBenchBuffer@@UAE@XZ ; CBenchBuffer::~CBenchBuffer(void)
.text:0000AFAA                 add     esp, 4
.text:0000AFAD                 cmp     ebp, esp
.text:0000AFAF                 call    __RTC_CheckEsp
.text:0000AFB4                 mov     esp, ebp
.text:0000AFB6                 pop     ebp
.text:0000AFB7                 retn
.text:0000AFB7 ??1CBenchRandomGenerator@@UAE@XZ endp
.text:0000AFB7
.text:0000AFB7 _text           ends
.text:0000AFB7
.text:0000AFB8 ; ===========================================================================
.text:0000AFB8
.text:0000AFB8 ; Segment type: Pure code
.text:0000AFB8 ; Segment permissions: Read/Execute
.text:0000AFB8 _text           segment para public 'CODE' use32
.text:0000AFB8                 assume cs:_text
.text:0000AFB8                 ;org 0AFB8h
.text:0000AFB8 ; COMDAT (pick any)
.text:0000AFB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000AFB8
.text:0000AFB8 ; =============== S U B R O U T I N E =======================================
.text:0000AFB8
.text:0000AFB8 ; Attributes: bp-based frame
.text:0000AFB8
.text:0000AFB8 ; _DWORD __thiscall COneMethodInfo::~COneMethodInfo(COneMethodInfo *__hidden this)
.text:0000AFB8                 public ??1COneMethodInfo@@QAE@XZ
.text:0000AFB8 ??1COneMethodInfo@@QAE@XZ proc near     ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1ADp
.text:0000AFB8                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+334p ...
.text:0000AFB8
.text:0000AFB8 var_10          = dword ptr -10h
.text:0000AFB8 var_C           = dword ptr -0Ch
.text:0000AFB8 var_4           = dword ptr -4
.text:0000AFB8
.text:0000AFB8                 push    ebp
.text:0000AFB9                 mov     ebp, esp
.text:0000AFBB                 push    0FFFFFFFFh
.text:0000AFBD                 push    offset __ehhandler$??1COneMethodInfo@@QAE@XZ
.text:0000AFC2                 mov     eax, large fs:0
.text:0000AFC8                 push    eax
.text:0000AFC9                 push    ecx
.text:0000AFCA                 mov     [ebp+var_10], 0CCCCCCCCh
.text:0000AFD1                 mov     eax, dword ptr ds:___security_cookie
.text:0000AFD6                 xor     eax, ebp
.text:0000AFD8                 push    eax
.text:0000AFD9                 lea     eax, [ebp+var_C]
.text:0000AFDC                 mov     large fs:0, eax
.text:0000AFE2                 mov     [ebp+var_10], ecx
.text:0000AFE5                 mov     [ebp+var_4], 1
.text:0000AFEC                 mov     ecx, [ebp+var_10]
.text:0000AFEF                 add     ecx, 18h        ; this
.text:0000AFF2                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000AFF7                 mov     byte ptr [ebp+var_4], 0
.text:0000AFFB                 mov     ecx, [ebp+var_10]
.text:0000AFFE                 add     ecx, 0Ch        ; this
.text:0000B001                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:0000B006                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000B00D                 mov     ecx, [ebp+var_10] ; this
.text:0000B010                 call    ??1CMethodProps@@QAE@XZ ; CMethodProps::~CMethodProps(void)
.text:0000B015                 mov     ecx, [ebp+var_C]
.text:0000B018                 mov     large fs:0, ecx
.text:0000B01F                 pop     ecx
.text:0000B020                 add     esp, 10h
.text:0000B023                 cmp     ebp, esp
.text:0000B025                 call    __RTC_CheckEsp
.text:0000B02A                 mov     esp, ebp
.text:0000B02C                 pop     ebp
.text:0000B02D                 retn
.text:0000B02D ??1COneMethodInfo@@QAE@XZ endp
.text:0000B02D
.text:0000B02D ; ---------------------------------------------------------------------------
.text:0000B02E                 align 10h
.text:0000B02E _text           ends
.text:0000B02E
.text$x:0000B030 ; ===========================================================================
.text$x:0000B030
.text$x:0000B030 ; Segment type: Pure code
.text$x:0000B030 ; Segment permissions: Read/Execute
.text$x:0000B030 _text$x         segment para public 'CODE' use32
.text$x:0000B030                 assume cs:_text$x
.text$x:0000B030                 ;org 0B030h
.text$x:0000B030 ; COMDAT (pick associative to section at AFB8)
.text$x:0000B030                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000B030
.text$x:0000B030 ; =============== S U B R O U T I N E =======================================
.text$x:0000B030
.text$x:0000B030
.text$x:0000B030 __unwindfunclet$??1COneMethodInfo@@QAE@XZ$0 proc near
.text$x:0000B030                                         ; DATA XREF: .xdata$x:0000B064o
.text$x:0000B030                 mov     ecx, [ebp-10h]  ; this
.text$x:0000B033                 jmp     ??1CMethodProps@@QAE@XZ ; CMethodProps::~CMethodProps(void)
.text$x:0000B033 __unwindfunclet$??1COneMethodInfo@@QAE@XZ$0 endp
.text$x:0000B033
.text$x:0000B038
.text$x:0000B038 ; =============== S U B R O U T I N E =======================================
.text$x:0000B038
.text$x:0000B038
.text$x:0000B038 __unwindfunclet$??1COneMethodInfo@@QAE@XZ$1 proc near
.text$x:0000B038                                         ; DATA XREF: .xdata$x:0000B06Co
.text$x:0000B038                 mov     ecx, [ebp-10h]
.text$x:0000B03B                 add     ecx, 0Ch        ; this
.text$x:0000B03E                 jmp     ??1AString@@QAE@XZ ; AString::~AString(void)
.text$x:0000B03E __unwindfunclet$??1COneMethodInfo@@QAE@XZ$1 endp
.text$x:0000B03E
.text$x:0000B043
.text$x:0000B043 ; =============== S U B R O U T I N E =======================================
.text$x:0000B043
.text$x:0000B043
.text$x:0000B043 __ehhandler$??1COneMethodInfo@@QAE@XZ proc near
.text$x:0000B043                                         ; DATA XREF: COneMethodInfo::~COneMethodInfo(void)+5o
.text$x:0000B043
.text$x:0000B043 arg_4           = dword ptr  8
.text$x:0000B043
.text$x:0000B043                 mov     edx, [esp+arg_4]
.text$x:0000B047                 lea     eax, [edx+0Ch]
.text$x:0000B04A                 mov     ecx, [edx-8]
.text$x:0000B04D                 xor     ecx, eax
.text$x:0000B04F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B054                 mov     eax, offset __ehfuncinfo$??1COneMethodInfo@@QAE@XZ
.text$x:0000B059                 jmp     ___CxxFrameHandler3
.text$x:0000B059 __ehhandler$??1COneMethodInfo@@QAE@XZ endp
.text$x:0000B059
.text$x:0000B059 ; ---------------------------------------------------------------------------
.text$x:0000B05E                 align 10h
.text$x:0000B05E _text$x         ends
.text$x:0000B05E
.xdata$x:0000B060 ; ===========================================================================
.xdata$x:0000B060
.xdata$x:0000B060 ; Segment type: Pure data
.xdata$x:0000B060 ; Segment permissions: Read
.xdata$x:0000B060 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000B060                 assume cs:_xdata$x
.xdata$x:0000B060                 ;org 0B060h
.xdata$x:0000B060 ; COMDAT (pick associative to section at AFB8)
.xdata$x:0000B060 __unwindtable$??1COneMethodInfo@@QAE@XZ db 0FFh
.xdata$x:0000B060                                         ; DATA XREF: .xdata$x:0000B078o
.xdata$x:0000B061                 db 0FFh
.xdata$x:0000B062                 db 0FFh
.xdata$x:0000B063                 db 0FFh
.xdata$x:0000B064                 dd offset __unwindfunclet$??1COneMethodInfo@@QAE@XZ$0
.xdata$x:0000B068                 db    0
.xdata$x:0000B069                 db    0
.xdata$x:0000B06A                 db    0
.xdata$x:0000B06B                 db    0
.xdata$x:0000B06C                 dd offset __unwindfunclet$??1COneMethodInfo@@QAE@XZ$1
.xdata$x:0000B070 __ehfuncinfo$??1COneMethodInfo@@QAE@XZ db  22h ; "
.xdata$x:0000B070                                         ; DATA XREF: __ehhandler$??1COneMethodInfo@@QAE@XZ+11o
.xdata$x:0000B071                 db    5
.xdata$x:0000B072                 db  93h ; ô
.xdata$x:0000B073                 db  19h
.xdata$x:0000B074                 db    2
.xdata$x:0000B075                 db    0
.xdata$x:0000B076                 db    0
.xdata$x:0000B077                 db    0
.xdata$x:0000B078                 dd offset __unwindtable$??1COneMethodInfo@@QAE@XZ
.xdata$x:0000B07C                 db    0
.xdata$x:0000B07D                 db    0
.xdata$x:0000B07E                 db    0
.xdata$x:0000B07F                 db    0
.xdata$x:0000B080                 db    0
.xdata$x:0000B081                 db    0
.xdata$x:0000B082                 db    0
.xdata$x:0000B083                 db    0
.xdata$x:0000B084                 db    0
.xdata$x:0000B085                 db    0
.xdata$x:0000B086                 db    0
.xdata$x:0000B087                 db    0
.xdata$x:0000B088                 db    0
.xdata$x:0000B089                 db    0
.xdata$x:0000B08A                 db    0
.xdata$x:0000B08B                 db    0
.xdata$x:0000B08C                 db    0
.xdata$x:0000B08D                 db    0
.xdata$x:0000B08E                 db    0
.xdata$x:0000B08F                 db    0
.xdata$x:0000B090                 db    1
.xdata$x:0000B091                 db    0
.xdata$x:0000B092                 db    0
.xdata$x:0000B093                 db    0
.xdata$x:0000B093 _xdata$x        ends
.xdata$x:0000B093
.text:0000B094 ; ===========================================================================
.text:0000B094
.text:0000B094 ; Segment type: Pure code
.text:0000B094 ; Segment permissions: Read/Execute
.text:0000B094 _text           segment para public 'CODE' use32
.text:0000B094                 assume cs:_text
.text:0000B094                 ;org 0B094h
.text:0000B094 ; COMDAT (pick any)
.text:0000B094                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B094
.text:0000B094 ; =============== S U B R O U T I N E =======================================
.text:0000B094
.text:0000B094 ; Attributes: bp-based frame
.text:0000B094
.text:0000B094 ; _DWORD __thiscall AString::~AString(AString *__hidden this)
.text:0000B094                 public ??1AString@@QAE@XZ
.text:0000B094 ??1AString@@QAE@XZ proc near            ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+458p
.text:0000B094                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+889p ...
.text:0000B094
.text:0000B094 var_8           = dword ptr -8
.text:0000B094 var_4           = dword ptr -4
.text:0000B094
.text:0000B094                 push    ebp
.text:0000B095                 mov     ebp, esp
.text:0000B097                 sub     esp, 8
.text:0000B09A                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000B0A1                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B0A8                 mov     [ebp+var_4], ecx
.text:0000B0AB                 mov     eax, [ebp+var_4]
.text:0000B0AE                 mov     ecx, [eax]
.text:0000B0B0                 mov     [ebp+var_8], ecx
.text:0000B0B3                 mov     edx, [ebp+var_8]
.text:0000B0B6                 push    edx             ; void *
.text:0000B0B7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000B0BC                 add     esp, 4
.text:0000B0BF                 add     esp, 8
.text:0000B0C2                 cmp     ebp, esp
.text:0000B0C4                 call    __RTC_CheckEsp
.text:0000B0C9                 mov     esp, ebp
.text:0000B0CB                 pop     ebp
.text:0000B0CC                 retn
.text:0000B0CC ??1AString@@QAE@XZ endp
.text:0000B0CC
.text:0000B0CC ; ---------------------------------------------------------------------------
.text:0000B0CD                 align 10h
.text:0000B0CD _text           ends
.text:0000B0CD
.text:0000B0D0 ; ===========================================================================
.text:0000B0D0
.text:0000B0D0 ; Segment type: Pure code
.text:0000B0D0 ; Segment permissions: Read/Execute
.text:0000B0D0 _text           segment para public 'CODE' use32
.text:0000B0D0                 assume cs:_text
.text:0000B0D0                 ;org 0B0D0h
.text:0000B0D0 ; COMDAT (pick any)
.text:0000B0D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B0D0
.text:0000B0D0 ; =============== S U B R O U T I N E =======================================
.text:0000B0D0
.text:0000B0D0 ; Attributes: bp-based frame
.text:0000B0D0
.text:0000B0D0 ; _DWORD __thiscall UString::~UString(UString *__hidden this)
.text:0000B0D0                 public ??1UString@@QAE@XZ
.text:0000B0D0 ??1UString@@QAE@XZ proc near            ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+16Ep
.text:0000B0D0                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+192p ...
.text:0000B0D0
.text:0000B0D0 var_8           = dword ptr -8
.text:0000B0D0 var_4           = dword ptr -4
.text:0000B0D0
.text:0000B0D0                 push    ebp
.text:0000B0D1                 mov     ebp, esp
.text:0000B0D3                 sub     esp, 8
.text:0000B0D6                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000B0DD                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B0E4                 mov     [ebp+var_4], ecx
.text:0000B0E7                 mov     eax, [ebp+var_4]
.text:0000B0EA                 mov     ecx, [eax]
.text:0000B0EC                 mov     [ebp+var_8], ecx
.text:0000B0EF                 mov     edx, [ebp+var_8]
.text:0000B0F2                 push    edx             ; void *
.text:0000B0F3                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000B0F8                 add     esp, 4
.text:0000B0FB                 add     esp, 8
.text:0000B0FE                 cmp     ebp, esp
.text:0000B100                 call    __RTC_CheckEsp
.text:0000B105                 mov     esp, ebp
.text:0000B107                 pop     ebp
.text:0000B108                 retn
.text:0000B108 ??1UString@@QAE@XZ endp
.text:0000B108
.text:0000B108 ; ---------------------------------------------------------------------------
.text:0000B109                 align 4
.text:0000B109 _text           ends
.text:0000B109
.text:0000B10C ; ===========================================================================
.text:0000B10C
.text:0000B10C ; Segment type: Pure code
.text:0000B10C ; Segment permissions: Read/Execute
.text:0000B10C _text           segment para public 'CODE' use32
.text:0000B10C                 assume cs:_text
.text:0000B10C                 ;org 0B10Ch
.text:0000B10C ; COMDAT (pick any)
.text:0000B10C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B10C
.text:0000B10C ; =============== S U B R O U T I N E =======================================
.text:0000B10C
.text:0000B10C ; Attributes: bp-based frame
.text:0000B10C
.text:0000B10C ; _DWORD __thiscall CMethodProps::~CMethodProps(CMethodProps *__hidden this)
.text:0000B10C                 public ??1CMethodProps@@QAE@XZ
.text:0000B10C ??1CMethodProps@@QAE@XZ proc near       ; CODE XREF: COneMethodInfo::~COneMethodInfo(void)+58p
.text:0000B10C                                         ; __unwindfunclet$??1COneMethodInfo@@QAE@XZ$0+3j ...
.text:0000B10C
.text:0000B10C var_4           = dword ptr -4
.text:0000B10C
.text:0000B10C                 push    ebp
.text:0000B10D                 mov     ebp, esp
.text:0000B10F                 push    ecx
.text:0000B110                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B117                 mov     [ebp+var_4], ecx
.text:0000B11A                 mov     ecx, [ebp+var_4] ; this
.text:0000B11D                 call    ??1CProps@@QAE@XZ ; CProps::~CProps(void)
.text:0000B122                 add     esp, 4
.text:0000B125                 cmp     ebp, esp
.text:0000B127                 call    __RTC_CheckEsp
.text:0000B12C                 mov     esp, ebp
.text:0000B12E                 pop     ebp
.text:0000B12F                 retn
.text:0000B12F ??1CMethodProps@@QAE@XZ endp
.text:0000B12F
.text:0000B12F _text           ends
.text:0000B12F
.text:0000B130 ; ===========================================================================
.text:0000B130
.text:0000B130 ; Segment type: Pure code
.text:0000B130 ; Segment permissions: Read/Execute
.text:0000B130 _text           segment para public 'CODE' use32
.text:0000B130                 assume cs:_text
.text:0000B130                 ;org 0B130h
.text:0000B130 ; COMDAT (pick any)
.text:0000B130                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B130
.text:0000B130 ; =============== S U B R O U T I N E =======================================
.text:0000B130
.text:0000B130 ; Attributes: bp-based frame
.text:0000B130
.text:0000B130 ; _DWORD __thiscall CProps::~CProps(CProps *__hidden this)
.text:0000B130                 public ??1CProps@@QAE@XZ
.text:0000B130 ??1CProps@@QAE@XZ proc near             ; CODE XREF: CMethodProps::~CMethodProps(void)+11p
.text:0000B130
.text:0000B130 var_4           = dword ptr -4
.text:0000B130
.text:0000B130                 push    ebp
.text:0000B131                 mov     ebp, esp
.text:0000B133                 push    ecx
.text:0000B134                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B13B                 mov     [ebp+var_4], ecx
.text:0000B13E                 mov     ecx, [ebp+var_4]
.text:0000B141                 call    ??1?$CObjectVector@UCProp@@@@QAE@XZ ; CObjectVector<CProp>::~CObjectVector<CProp>(void)
.text:0000B146                 add     esp, 4
.text:0000B149                 cmp     ebp, esp
.text:0000B14B                 call    __RTC_CheckEsp
.text:0000B150                 mov     esp, ebp
.text:0000B152                 pop     ebp
.text:0000B153                 retn
.text:0000B153 ??1CProps@@QAE@XZ endp
.text:0000B153
.text:0000B153 _text           ends
.text:0000B153
.text:0000B154 ; ===========================================================================
.text:0000B154
.text:0000B154 ; Segment type: Pure code
.text:0000B154 ; Segment permissions: Read/Execute
.text:0000B154 _text           segment para public 'CODE' use32
.text:0000B154                 assume cs:_text
.text:0000B154                 ;org 0B154h
.text:0000B154 ; COMDAT (pick any)
.text:0000B154                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B154
.text:0000B154 ; =============== S U B R O U T I N E =======================================
.text:0000B154
.text:0000B154 ; Attributes: bp-based frame
.text:0000B154
.text:0000B154 ; unsigned __int64 __stdcall GetLZMAUsage(bool, unsigned int)
.text:0000B154                 public ?GetLZMAUsage@@YG_K_NI@Z
.text:0000B154 ?GetLZMAUsage@@YG_K_NI@Z proc near      ; CODE XREF: GetBenchMemoryUsage(uint,uint)+5Dp
.text:0000B154
.text:0000B154 var_4           = dword ptr -4
.text:0000B154 arg_0           = byte ptr  8
.text:0000B154 arg_4           = dword ptr  0Ch
.text:0000B154
.text:0000B154                 push    ebp
.text:0000B155                 mov     ebp, esp
.text:0000B157                 push    ecx
.text:0000B158                 push    esi
.text:0000B159                 push    edi
.text:0000B15A                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B161                 mov     eax, [ebp+arg_4]
.text:0000B164                 sub     eax, 1
.text:0000B167                 mov     [ebp+var_4], eax
.text:0000B16A                 mov     ecx, [ebp+var_4]
.text:0000B16D                 shr     ecx, 1
.text:0000B16F                 or      ecx, [ebp+var_4]
.text:0000B172                 mov     [ebp+var_4], ecx
.text:0000B175                 mov     edx, [ebp+var_4]
.text:0000B178                 shr     edx, 2
.text:0000B17B                 or      edx, [ebp+var_4]
.text:0000B17E                 mov     [ebp+var_4], edx
.text:0000B181                 mov     eax, [ebp+var_4]
.text:0000B184                 shr     eax, 4
.text:0000B187                 or      eax, [ebp+var_4]
.text:0000B18A                 mov     [ebp+var_4], eax
.text:0000B18D                 mov     ecx, [ebp+var_4]
.text:0000B190                 shr     ecx, 8
.text:0000B193                 or      ecx, [ebp+var_4]
.text:0000B196                 mov     [ebp+var_4], ecx
.text:0000B199                 mov     edx, [ebp+var_4]
.text:0000B19C                 shr     edx, 1
.text:0000B19E                 mov     [ebp+var_4], edx
.text:0000B1A1                 mov     eax, [ebp+var_4]
.text:0000B1A4                 or      eax, 0FFFFh
.text:0000B1A9                 mov     [ebp+var_4], eax
.text:0000B1AC                 cmp     [ebp+var_4], 1000000h
.text:0000B1B3                 jbe     short loc_B1BD
.text:0000B1B5                 mov     ecx, [ebp+var_4]
.text:0000B1B8                 shr     ecx, 1
.text:0000B1BA                 mov     [ebp+var_4], ecx
.text:0000B1BD
.text:0000B1BD loc_B1BD:                               ; CODE XREF: GetLZMAUsage(bool,uint)+5Fj
.text:0000B1BD                 mov     edx, [ebp+var_4]
.text:0000B1C0                 add     edx, 1
.text:0000B1C3                 mov     [ebp+var_4], edx
.text:0000B1C6                 mov     eax, [ebp+var_4]
.text:0000B1C9                 add     eax, 10000h
.text:0000B1CE                 mov     ecx, eax
.text:0000B1D0                 xor     esi, esi
.text:0000B1D2                 mov     eax, [ebp+arg_4]
.text:0000B1D5                 mov     edx, 2
.text:0000B1DA                 mul     edx
.text:0000B1DC                 add     ecx, eax
.text:0000B1DE                 adc     esi, edx
.text:0000B1E0                 push    0
.text:0000B1E2                 push    4
.text:0000B1E4                 push    esi
.text:0000B1E5                 push    ecx
.text:0000B1E6                 call    __allmul
.text:0000B1EB                 mov     esi, eax
.text:0000B1ED                 mov     edi, edx
.text:0000B1EF                 mov     eax, [ebp+arg_4]
.text:0000B1F2                 mov     ecx, 3
.text:0000B1F7                 mul     ecx
.text:0000B1F9                 push    0
.text:0000B1FB                 push    2
.text:0000B1FD                 push    edx
.text:0000B1FE                 push    eax
.text:0000B1FF                 call    __aulldiv
.text:0000B204                 add     esi, eax
.text:0000B206                 adc     edi, edx
.text:0000B208                 add     esi, 100000h
.text:0000B20E                 adc     edi, 0
.text:0000B211                 movzx   eax, [ebp+arg_0]
.text:0000B215                 neg     eax
.text:0000B217                 sbb     eax, eax
.text:0000B219                 and     eax, 600000h
.text:0000B21E                 cdq
.text:0000B21F                 add     esi, eax
.text:0000B221                 adc     edi, edx
.text:0000B223                 mov     eax, esi
.text:0000B225                 mov     edx, edi
.text:0000B227                 pop     edi
.text:0000B228                 pop     esi
.text:0000B229                 add     esp, 4
.text:0000B22C                 cmp     ebp, esp
.text:0000B22E                 call    __RTC_CheckEsp
.text:0000B233                 mov     esp, ebp
.text:0000B235                 pop     ebp
.text:0000B236                 retn    8
.text:0000B236 ?GetLZMAUsage@@YG_K_NI@Z endp
.text:0000B236
.text:0000B236 ; ---------------------------------------------------------------------------
.text:0000B239                 align 4
.text:0000B239 _text           ends
.text:0000B239
.text:0000B23C ; ===========================================================================
.text:0000B23C
.text:0000B23C ; Segment type: Pure code
.text:0000B23C ; Segment permissions: Read/Execute
.text:0000B23C _text           segment para public 'CODE' use32
.text:0000B23C                 assume cs:_text
.text:0000B23C                 ;org 0B23Ch
.text:0000B23C ; COMDAT (pick any)
.text:0000B23C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B23C
.text:0000B23C ; =============== S U B R O U T I N E =======================================
.text:0000B23C
.text:0000B23C ; Attributes: bp-based frame
.text:0000B23C
.text:0000B23C ; public: void * __thiscall CFreqInfo::`vector deleting destructor'(unsigned int)
.text:0000B23C                 public ??_ECFreqInfo@@QAEPAXI@Z
.text:0000B23C ??_ECFreqInfo@@QAEPAXI@Z proc near      ; CODE XREF: CFreqThreads::~CFreqThreads(void)+3Bp
.text:0000B23C
.text:0000B23C var_4           = dword ptr -4
.text:0000B23C arg_0           = dword ptr  8
.text:0000B23C
.text:0000B23C                 push    ebp
.text:0000B23D                 mov     ebp, esp
.text:0000B23F                 push    ecx
.text:0000B240                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B247                 mov     [ebp+var_4], ecx
.text:0000B24A                 mov     eax, [ebp+arg_0]
.text:0000B24D                 and     eax, 2
.text:0000B250                 jz      short loc_B288
.text:0000B252                 push    offset ??1CFreqInfo@@QAE@XZ ; CFreqInfo::~CFreqInfo(void)
.text:0000B257                 mov     ecx, [ebp+var_4]
.text:0000B25A                 mov     edx, [ecx-4]
.text:0000B25D                 push    edx
.text:0000B25E                 push    20h ; ' '
.text:0000B260                 mov     eax, [ebp+var_4]
.text:0000B263                 push    eax
.text:0000B264                 call    ??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
.text:0000B269                 mov     ecx, [ebp+arg_0]
.text:0000B26C                 and     ecx, 1
.text:0000B26F                 jz      short loc_B280
.text:0000B271                 mov     edx, [ebp+var_4]
.text:0000B274                 sub     edx, 4
.text:0000B277                 push    edx             ; void *
.text:0000B278                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000B27D                 add     esp, 4
.text:0000B280
.text:0000B280 loc_B280:                               ; CODE XREF: CFreqInfo::`vector deleting destructor'(uint)+33j
.text:0000B280                 mov     eax, [ebp+var_4]
.text:0000B283                 sub     eax, 4
.text:0000B286                 jmp     short loc_B2A7
.text:0000B288 ; ---------------------------------------------------------------------------
.text:0000B288
.text:0000B288 loc_B288:                               ; CODE XREF: CFreqInfo::`vector deleting destructor'(uint)+14j
.text:0000B288                 mov     ecx, [ebp+var_4] ; this
.text:0000B28B                 call    ??1CFreqInfo@@QAE@XZ ; CFreqInfo::~CFreqInfo(void)
.text:0000B290                 mov     eax, [ebp+arg_0]
.text:0000B293                 and     eax, 1
.text:0000B296                 jz      short loc_B2A4
.text:0000B298                 mov     ecx, [ebp+var_4]
.text:0000B29B                 push    ecx             ; void *
.text:0000B29C                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000B2A1                 add     esp, 4
.text:0000B2A4
.text:0000B2A4 loc_B2A4:                               ; CODE XREF: CFreqInfo::`vector deleting destructor'(uint)+5Aj
.text:0000B2A4                 mov     eax, [ebp+var_4]
.text:0000B2A7
.text:0000B2A7 loc_B2A7:                               ; CODE XREF: CFreqInfo::`vector deleting destructor'(uint)+4Aj
.text:0000B2A7                 add     esp, 4
.text:0000B2AA                 cmp     ebp, esp
.text:0000B2AC                 call    __RTC_CheckEsp
.text:0000B2B1                 mov     esp, ebp
.text:0000B2B3                 pop     ebp
.text:0000B2B4                 retn    4
.text:0000B2B4 ??_ECFreqInfo@@QAEPAXI@Z endp
.text:0000B2B4
.text:0000B2B4 ; ---------------------------------------------------------------------------
.text:0000B2B7                 align 4
.text:0000B2B7 _text           ends
.text:0000B2B7
.text:0000B2B8 ; ===========================================================================
.text:0000B2B8
.text:0000B2B8 ; Segment type: Pure code
.text:0000B2B8 ; Segment permissions: Read/Execute
.text:0000B2B8 _text           segment para public 'CODE' use32
.text:0000B2B8                 assume cs:_text
.text:0000B2B8                 ;org 0B2B8h
.text:0000B2B8 ; COMDAT (pick any)
.text:0000B2B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B2B8
.text:0000B2B8 ; =============== S U B R O U T I N E =======================================
.text:0000B2B8
.text:0000B2B8 ; Attributes: bp-based frame
.text:0000B2B8
.text:0000B2B8 ; _DWORD __thiscall CFreqInfo::~CFreqInfo(CFreqInfo *__hidden this)
.text:0000B2B8                 public ??1CFreqInfo@@QAE@XZ
.text:0000B2B8 ??1CFreqInfo@@QAE@XZ proc near          ; CODE XREF: CFreqInfo::`vector deleting destructor'(uint)+4Fp
.text:0000B2B8                                         ; DATA XREF: FreqBench(unsigned __int64,uint,IBenchPrintCallback *,bool,unsigned __int64 &,uint &)+148o ...
.text:0000B2B8
.text:0000B2B8 var_4           = dword ptr -4
.text:0000B2B8
.text:0000B2B8                 push    ebp
.text:0000B2B9                 mov     ebp, esp
.text:0000B2BB                 push    ecx
.text:0000B2BC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B2C3                 mov     [ebp+var_4], ecx
.text:0000B2C6                 mov     ecx, [ebp+var_4] ; this
.text:0000B2C9                 call    ??1CThread@NWindows@@QAE@XZ ; NWindows::CThread::~CThread(void)
.text:0000B2CE                 add     esp, 4
.text:0000B2D1                 cmp     ebp, esp
.text:0000B2D3                 call    __RTC_CheckEsp
.text:0000B2D8                 mov     esp, ebp
.text:0000B2DA                 pop     ebp
.text:0000B2DB                 retn
.text:0000B2DB ??1CFreqInfo@@QAE@XZ endp
.text:0000B2DB
.text:0000B2DB _text           ends
.text:0000B2DB
.text:0000B2DC ; ===========================================================================
.text:0000B2DC
.text:0000B2DC ; Segment type: Pure code
.text:0000B2DC ; Segment permissions: Read/Execute
.text:0000B2DC _text           segment para public 'CODE' use32
.text:0000B2DC                 assume cs:_text
.text:0000B2DC                 ;org 0B2DCh
.text:0000B2DC ; COMDAT (pick any)
.text:0000B2DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B2DC
.text:0000B2DC ; =============== S U B R O U T I N E =======================================
.text:0000B2DC
.text:0000B2DC ; Attributes: bp-based frame
.text:0000B2DC
.text:0000B2DC ; public: void * __thiscall CCrcInfo::`vector deleting destructor'(unsigned int)
.text:0000B2DC                 public ??_ECCrcInfo@@QAEPAXI@Z
.text:0000B2DC ??_ECCrcInfo@@QAEPAXI@Z proc near       ; CODE XREF: CCrcThreads::~CCrcThreads(void)+3Bp
.text:0000B2DC
.text:0000B2DC var_4           = dword ptr -4
.text:0000B2DC arg_0           = dword ptr  8
.text:0000B2DC
.text:0000B2DC                 push    ebp
.text:0000B2DD                 mov     ebp, esp
.text:0000B2DF                 push    ecx
.text:0000B2E0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B2E7                 mov     [ebp+var_4], ecx
.text:0000B2EA                 mov     eax, [ebp+arg_0]
.text:0000B2ED                 and     eax, 2
.text:0000B2F0                 jz      short loc_B328
.text:0000B2F2                 push    offset ??1CCrcInfo@@QAE@XZ ; CCrcInfo::~CCrcInfo(void)
.text:0000B2F7                 mov     ecx, [ebp+var_4]
.text:0000B2FA                 mov     edx, [ecx-4]
.text:0000B2FD                 push    edx
.text:0000B2FE                 push    38h ; '8'
.text:0000B300                 mov     eax, [ebp+var_4]
.text:0000B303                 push    eax
.text:0000B304                 call    ??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
.text:0000B309                 mov     ecx, [ebp+arg_0]
.text:0000B30C                 and     ecx, 1
.text:0000B30F                 jz      short loc_B320
.text:0000B311                 mov     edx, [ebp+var_4]
.text:0000B314                 sub     edx, 4
.text:0000B317                 push    edx             ; void *
.text:0000B318                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000B31D                 add     esp, 4
.text:0000B320
.text:0000B320 loc_B320:                               ; CODE XREF: CCrcInfo::`vector deleting destructor'(uint)+33j
.text:0000B320                 mov     eax, [ebp+var_4]
.text:0000B323                 sub     eax, 4
.text:0000B326                 jmp     short loc_B347
.text:0000B328 ; ---------------------------------------------------------------------------
.text:0000B328
.text:0000B328 loc_B328:                               ; CODE XREF: CCrcInfo::`vector deleting destructor'(uint)+14j
.text:0000B328                 mov     ecx, [ebp+var_4] ; this
.text:0000B32B                 call    ??1CCrcInfo@@QAE@XZ ; CCrcInfo::~CCrcInfo(void)
.text:0000B330                 mov     eax, [ebp+arg_0]
.text:0000B333                 and     eax, 1
.text:0000B336                 jz      short loc_B344
.text:0000B338                 mov     ecx, [ebp+var_4]
.text:0000B33B                 push    ecx             ; void *
.text:0000B33C                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000B341                 add     esp, 4
.text:0000B344
.text:0000B344 loc_B344:                               ; CODE XREF: CCrcInfo::`vector deleting destructor'(uint)+5Aj
.text:0000B344                 mov     eax, [ebp+var_4]
.text:0000B347
.text:0000B347 loc_B347:                               ; CODE XREF: CCrcInfo::`vector deleting destructor'(uint)+4Aj
.text:0000B347                 add     esp, 4
.text:0000B34A                 cmp     ebp, esp
.text:0000B34C                 call    __RTC_CheckEsp
.text:0000B351                 mov     esp, ebp
.text:0000B353                 pop     ebp
.text:0000B354                 retn    4
.text:0000B354 ??_ECCrcInfo@@QAEPAXI@Z endp
.text:0000B354
.text:0000B354 ; ---------------------------------------------------------------------------
.text:0000B357                 align 4
.text:0000B357 _text           ends
.text:0000B357
.text:0000B358 ; ===========================================================================
.text:0000B358
.text:0000B358 ; Segment type: Pure code
.text:0000B358 ; Segment permissions: Read/Execute
.text:0000B358 _text           segment para public 'CODE' use32
.text:0000B358                 assume cs:_text
.text:0000B358                 ;org 0B358h
.text:0000B358 ; COMDAT (pick any)
.text:0000B358                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B358
.text:0000B358 ; =============== S U B R O U T I N E =======================================
.text:0000B358
.text:0000B358 ; Attributes: bp-based frame
.text:0000B358
.text:0000B358 ; _DWORD __thiscall CCrcInfo::~CCrcInfo(CCrcInfo *__hidden this)
.text:0000B358                 public ??1CCrcInfo@@QAE@XZ
.text:0000B358 ??1CCrcInfo@@QAE@XZ proc near           ; CODE XREF: CCrcInfo::`vector deleting destructor'(uint)+4Fp
.text:0000B358                                         ; DATA XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+224o ...
.text:0000B358
.text:0000B358 var_10          = dword ptr -10h
.text:0000B358 var_C           = dword ptr -0Ch
.text:0000B358 var_4           = dword ptr -4
.text:0000B358
.text:0000B358                 push    ebp
.text:0000B359                 mov     ebp, esp
.text:0000B35B                 push    0FFFFFFFFh
.text:0000B35D                 push    offset __ehhandler$??1CCrcInfo@@QAE@XZ
.text:0000B362                 mov     eax, large fs:0
.text:0000B368                 push    eax
.text:0000B369                 push    ecx
.text:0000B36A                 mov     [ebp+var_10], 0CCCCCCCCh
.text:0000B371                 mov     eax, dword ptr ds:___security_cookie
.text:0000B376                 xor     eax, ebp
.text:0000B378                 push    eax
.text:0000B379                 lea     eax, [ebp+var_C]
.text:0000B37C                 mov     large fs:0, eax
.text:0000B382                 mov     [ebp+var_10], ecx
.text:0000B385                 mov     [ebp+var_4], 0
.text:0000B38C                 mov     ecx, [ebp+var_10]
.text:0000B38F                 add     ecx, 28h ; '('
.text:0000B392                 call    ??1?$CMyComPtr@UIHasher@@@@QAE@XZ ; CMyComPtr<IHasher>::~CMyComPtr<IHasher>(void)
.text:0000B397                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000B39E                 mov     ecx, [ebp+var_10] ; this
.text:0000B3A1                 call    ??1CThread@NWindows@@QAE@XZ ; NWindows::CThread::~CThread(void)
.text:0000B3A6                 mov     ecx, [ebp+var_C]
.text:0000B3A9                 mov     large fs:0, ecx
.text:0000B3B0                 pop     ecx
.text:0000B3B1                 add     esp, 10h
.text:0000B3B4                 cmp     ebp, esp
.text:0000B3B6                 call    __RTC_CheckEsp
.text:0000B3BB                 mov     esp, ebp
.text:0000B3BD                 pop     ebp
.text:0000B3BE                 retn
.text:0000B3BE ??1CCrcInfo@@QAE@XZ endp
.text:0000B3BE
.text:0000B3BE ; ---------------------------------------------------------------------------
.text:0000B3BF                 align 10h
.text:0000B3BF _text           ends
.text:0000B3BF
.text$x:0000B3C0 ; ===========================================================================
.text$x:0000B3C0
.text$x:0000B3C0 ; Segment type: Pure code
.text$x:0000B3C0 ; Segment permissions: Read/Execute
.text$x:0000B3C0 _text$x         segment para public 'CODE' use32
.text$x:0000B3C0                 assume cs:_text$x
.text$x:0000B3C0                 ;org 0B3C0h
.text$x:0000B3C0 ; COMDAT (pick associative to section at B358)
.text$x:0000B3C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000B3C0
.text$x:0000B3C0 ; =============== S U B R O U T I N E =======================================
.text$x:0000B3C0
.text$x:0000B3C0
.text$x:0000B3C0 __unwindfunclet$??1CCrcInfo@@QAE@XZ$0 proc near
.text$x:0000B3C0                                         ; DATA XREF: .xdata$x:0000B3E8o
.text$x:0000B3C0                 mov     ecx, [ebp-10h]  ; this
.text$x:0000B3C3                 jmp     ??1CThread@NWindows@@QAE@XZ ; NWindows::CThread::~CThread(void)
.text$x:0000B3C3 __unwindfunclet$??1CCrcInfo@@QAE@XZ$0 endp
.text$x:0000B3C3
.text$x:0000B3C8
.text$x:0000B3C8 ; =============== S U B R O U T I N E =======================================
.text$x:0000B3C8
.text$x:0000B3C8
.text$x:0000B3C8 __ehhandler$??1CCrcInfo@@QAE@XZ proc near
.text$x:0000B3C8                                         ; DATA XREF: CCrcInfo::~CCrcInfo(void)+5o
.text$x:0000B3C8
.text$x:0000B3C8 arg_4           = dword ptr  8
.text$x:0000B3C8
.text$x:0000B3C8                 mov     edx, [esp+arg_4]
.text$x:0000B3CC                 lea     eax, [edx+0Ch]
.text$x:0000B3CF                 mov     ecx, [edx-8]
.text$x:0000B3D2                 xor     ecx, eax
.text$x:0000B3D4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B3D9                 mov     eax, offset __ehfuncinfo$??1CCrcInfo@@QAE@XZ
.text$x:0000B3DE                 jmp     ___CxxFrameHandler3
.text$x:0000B3DE __ehhandler$??1CCrcInfo@@QAE@XZ endp
.text$x:0000B3DE
.text$x:0000B3DE ; ---------------------------------------------------------------------------
.text$x:0000B3E3                 align 4
.text$x:0000B3E3 _text$x         ends
.text$x:0000B3E3
.xdata$x:0000B3E4 ; ===========================================================================
.xdata$x:0000B3E4
.xdata$x:0000B3E4 ; Segment type: Pure data
.xdata$x:0000B3E4 ; Segment permissions: Read
.xdata$x:0000B3E4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000B3E4                 assume cs:_xdata$x
.xdata$x:0000B3E4                 ;org 0B3E4h
.xdata$x:0000B3E4 ; COMDAT (pick associative to section at B358)
.xdata$x:0000B3E4 __unwindtable$??1CCrcInfo@@QAE@XZ db 0FFh ; DATA XREF: .xdata$x:0000B3F4o
.xdata$x:0000B3E5                 db 0FFh
.xdata$x:0000B3E6                 db 0FFh
.xdata$x:0000B3E7                 db 0FFh
.xdata$x:0000B3E8                 dd offset __unwindfunclet$??1CCrcInfo@@QAE@XZ$0
.xdata$x:0000B3EC __ehfuncinfo$??1CCrcInfo@@QAE@XZ db  22h ; "
.xdata$x:0000B3EC                                         ; DATA XREF: __ehhandler$??1CCrcInfo@@QAE@XZ+11o
.xdata$x:0000B3ED                 db    5
.xdata$x:0000B3EE                 db  93h ; ô
.xdata$x:0000B3EF                 db  19h
.xdata$x:0000B3F0                 db    1
.xdata$x:0000B3F1                 db    0
.xdata$x:0000B3F2                 db    0
.xdata$x:0000B3F3                 db    0
.xdata$x:0000B3F4                 dd offset __unwindtable$??1CCrcInfo@@QAE@XZ
.xdata$x:0000B3F8                 db    0
.xdata$x:0000B3F9                 db    0
.xdata$x:0000B3FA                 db    0
.xdata$x:0000B3FB                 db    0
.xdata$x:0000B3FC                 db    0
.xdata$x:0000B3FD                 db    0
.xdata$x:0000B3FE                 db    0
.xdata$x:0000B3FF                 db    0
.xdata$x:0000B400                 db    0
.xdata$x:0000B401                 db    0
.xdata$x:0000B402                 db    0
.xdata$x:0000B403                 db    0
.xdata$x:0000B404                 db    0
.xdata$x:0000B405                 db    0
.xdata$x:0000B406                 db    0
.xdata$x:0000B407                 db    0
.xdata$x:0000B408                 db    0
.xdata$x:0000B409                 db    0
.xdata$x:0000B40A                 db    0
.xdata$x:0000B40B                 db    0
.xdata$x:0000B40C                 db    1
.xdata$x:0000B40D                 db    0
.xdata$x:0000B40E                 db    0
.xdata$x:0000B40F                 db    0
.xdata$x:0000B40F _xdata$x        ends
.xdata$x:0000B40F
.text:0000B410 ; ===========================================================================
.text:0000B410
.text:0000B410 ; Segment type: Pure code
.text:0000B410 ; Segment permissions: Read/Execute
.text:0000B410 _text           segment para public 'CODE' use32
.text:0000B410                 assume cs:_text
.text:0000B410                 ;org 0B410h
.text:0000B410 ; COMDAT (pick any)
.text:0000B410                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B410
.text:0000B410 ; =============== S U B R O U T I N E =======================================
.text:0000B410
.text:0000B410 ; Attributes: bp-based frame
.text:0000B410
.text:0000B410 ; public: __thiscall CBaseRandomGenerator::CBaseRandomGenerator(void)
.text:0000B410                 public ??0CBaseRandomGenerator@@QAE@XZ
.text:0000B410 ??0CBaseRandomGenerator@@QAE@XZ proc near
.text:0000B410                                         ; CODE XREF: CrcInternalTest(void)+EFp
.text:0000B410                                         ; MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+474p ...
.text:0000B410
.text:0000B410 var_4           = dword ptr -4
.text:0000B410
.text:0000B410                 push    ebp
.text:0000B411                 mov     ebp, esp
.text:0000B413                 push    ecx
.text:0000B414                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B41B                 mov     [ebp+var_4], ecx
.text:0000B41E                 mov     ecx, [ebp+var_4] ; this
.text:0000B421                 call    ?Init@CBaseRandomGenerator@@QAEXXZ ; CBaseRandomGenerator::Init(void)
.text:0000B426                 mov     eax, [ebp+var_4]
.text:0000B429                 add     esp, 4
.text:0000B42C                 cmp     ebp, esp
.text:0000B42E                 call    __RTC_CheckEsp
.text:0000B433                 mov     esp, ebp
.text:0000B435                 pop     ebp
.text:0000B436                 retn
.text:0000B436 ??0CBaseRandomGenerator@@QAE@XZ endp
.text:0000B436
.text:0000B436 ; ---------------------------------------------------------------------------
.text:0000B437                 align 4
.text:0000B437 _text           ends
.text:0000B437
.text:0000B438 ; ===========================================================================
.text:0000B438
.text:0000B438 ; Segment type: Pure code
.text:0000B438 ; Segment permissions: Read/Execute
.text:0000B438 _text           segment para public 'CODE' use32
.text:0000B438                 assume cs:_text
.text:0000B438                 ;org 0B438h
.text:0000B438 ; COMDAT (pick any)
.text:0000B438                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B438
.text:0000B438 ; =============== S U B R O U T I N E =======================================
.text:0000B438
.text:0000B438 ; Attributes: bp-based frame
.text:0000B438
.text:0000B438 ; void __thiscall CBaseRandomGenerator::Init(CBaseRandomGenerator *__hidden this)
.text:0000B438                 public ?Init@CBaseRandomGenerator@@QAEXXZ
.text:0000B438 ?Init@CBaseRandomGenerator@@QAEXXZ proc near
.text:0000B438                                         ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+47Fp
.text:0000B438                                         ; CBaseRandomGenerator::CBaseRandomGenerator(void)+11p
.text:0000B438
.text:0000B438 var_4           = dword ptr -4
.text:0000B438
.text:0000B438                 push    ebp
.text:0000B439                 mov     ebp, esp
.text:0000B43B                 push    ecx
.text:0000B43C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B443                 mov     [ebp+var_4], ecx
.text:0000B446                 mov     eax, [ebp+var_4]
.text:0000B449                 mov     dword ptr [eax], 159A55E5h
.text:0000B44F                 mov     ecx, [ebp+var_4]
.text:0000B452                 mov     dword ptr [ecx+4], 1F123BB5h
.text:0000B459                 mov     esp, ebp
.text:0000B45B                 pop     ebp
.text:0000B45C                 retn
.text:0000B45C ?Init@CBaseRandomGenerator@@QAEXXZ endp
.text:0000B45C
.text:0000B45C ; ---------------------------------------------------------------------------
.text:0000B45D                 align 10h
.text:0000B45D _text           ends
.text:0000B45D
.text:0000B460 ; ===========================================================================
.text:0000B460
.text:0000B460 ; Segment type: Pure code
.text:0000B460 ; Segment permissions: Read/Execute
.text:0000B460 _text           segment para public 'CODE' use32
.text:0000B460                 assume cs:_text
.text:0000B460                 ;org 0B460h
.text:0000B460 ; COMDAT (pick any)
.text:0000B460                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B460
.text:0000B460 ; =============== S U B R O U T I N E =======================================
.text:0000B460
.text:0000B460 ; Attributes: bp-based frame
.text:0000B460
.text:0000B460 ; unsigned int __stdcall MyStringLen(const char *)
.text:0000B460                 public ?MyStringLen@@YGIPBD@Z
.text:0000B460 ?MyStringLen@@YGIPBD@Z proc near        ; CODE XREF: PrintLeft(IBenchPrintCallback &,char const *,uint)+29p
.text:0000B460                                         ; PrintRight(IBenchPrintCallback &,char const *,uint)+10p ...
.text:0000B460
.text:0000B460 var_4           = dword ptr -4
.text:0000B460 arg_0           = dword ptr  8
.text:0000B460
.text:0000B460                 push    ebp
.text:0000B461                 mov     ebp, esp
.text:0000B463                 push    ecx
.text:0000B464                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B46B                 mov     [ebp+var_4], 0
.text:0000B472                 jmp     short loc_B47D
.text:0000B474 ; ---------------------------------------------------------------------------
.text:0000B474
.text:0000B474 loc_B474:                               ; CODE XREF: MyStringLen(char const *)+2Aj
.text:0000B474                 mov     eax, [ebp+var_4]
.text:0000B477                 add     eax, 1
.text:0000B47A                 mov     [ebp+var_4], eax
.text:0000B47D
.text:0000B47D loc_B47D:                               ; CODE XREF: MyStringLen(char const *)+12j
.text:0000B47D                 mov     ecx, [ebp+arg_0]
.text:0000B480                 add     ecx, [ebp+var_4]
.text:0000B483                 movsx   edx, byte ptr [ecx]
.text:0000B486                 test    edx, edx
.text:0000B488                 jz      short loc_B48C
.text:0000B48A                 jmp     short loc_B474
.text:0000B48C ; ---------------------------------------------------------------------------
.text:0000B48C
.text:0000B48C loc_B48C:                               ; CODE XREF: MyStringLen(char const *)+28j
.text:0000B48C                 mov     eax, [ebp+var_4]
.text:0000B48F                 mov     esp, ebp
.text:0000B491                 pop     ebp
.text:0000B492                 retn    4
.text:0000B492 ?MyStringLen@@YGIPBD@Z endp
.text:0000B492
.text:0000B492 ; ---------------------------------------------------------------------------
.text:0000B495                 align 4
.text:0000B495 _text           ends
.text:0000B495
.text:0000B498 ; ===========================================================================
.text:0000B498
.text:0000B498 ; Segment type: Pure code
.text:0000B498 ; Segment permissions: Read/Execute
.text:0000B498 _text           segment para public 'CODE' use32
.text:0000B498                 assume cs:_text
.text:0000B498                 ;org 0B498h
.text:0000B498 ; COMDAT (pick any)
.text:0000B498                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B498
.text:0000B498 ; =============== S U B R O U T I N E =======================================
.text:0000B498
.text:0000B498 ; Attributes: bp-based frame
.text:0000B498
.text:0000B498 ; void __thiscall AString::Empty(AString *__hidden this)
.text:0000B498                 public ?Empty@AString@@QAEXXZ
.text:0000B498 ?Empty@AString@@QAEXXZ proc near        ; CODE XREF: GetCpuName(AString &)+23p
.text:0000B498                                         ; x86cpuid_to_String(Cx86cpuid const &,AString &)+23p
.text:0000B498
.text:0000B498 var_4           = dword ptr -4
.text:0000B498
.text:0000B498                 push    ebp
.text:0000B499                 mov     ebp, esp
.text:0000B49B                 push    ecx
.text:0000B49C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B4A3                 mov     [ebp+var_4], ecx
.text:0000B4A6                 mov     eax, [ebp+var_4]
.text:0000B4A9                 mov     dword ptr [eax+4], 0
.text:0000B4B0                 mov     ecx, [ebp+var_4]
.text:0000B4B3                 mov     edx, [ecx]
.text:0000B4B5                 mov     byte ptr [edx], 0
.text:0000B4B8                 mov     esp, ebp
.text:0000B4BA                 pop     ebp
.text:0000B4BB                 retn
.text:0000B4BB ?Empty@AString@@QAEXXZ endp
.text:0000B4BB
.text:0000B4BB _text           ends
.text:0000B4BB
.text:0000B4BC ; ===========================================================================
.text:0000B4BC
.text:0000B4BC ; Segment type: Pure code
.text:0000B4BC ; Segment permissions: Read/Execute
.text:0000B4BC _text           segment para public 'CODE' use32
.text:0000B4BC                 assume cs:_text
.text:0000B4BC                 ;org 0B4BCh
.text:0000B4BC ; COMDAT (pick any)
.text:0000B4BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B4BC
.text:0000B4BC ; =============== S U B R O U T I N E =======================================
.text:0000B4BC
.text:0000B4BC ; Attributes: bp-based frame
.text:0000B4BC
.text:0000B4BC ; public: class AString & __thiscall AString::operator+=(char)
.text:0000B4BC                 public ??YAString@@QAEAAV0@D@Z
.text:0000B4BC ??YAString@@QAEAAV0@D@Z proc near       ; CODE XREF: x86cpuid_to_String(Cx86cpuid const &,AString &)+123p
.text:0000B4BC                                         ; x86cpuid_to_String(Cx86cpuid const &,AString &)+139p ...
.text:0000B4BC
.text:0000B4BC var_C           = dword ptr -0Ch
.text:0000B4BC var_8           = dword ptr -8
.text:0000B4BC var_4           = dword ptr -4
.text:0000B4BC arg_0           = byte ptr  8
.text:0000B4BC
.text:0000B4BC                 push    ebp
.text:0000B4BD                 mov     ebp, esp
.text:0000B4BF                 sub     esp, 0Ch
.text:0000B4C2                 mov     [ebp+var_C], 0CCCCCCCCh
.text:0000B4C9                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000B4D0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B4D7                 mov     [ebp+var_4], ecx
.text:0000B4DA                 mov     eax, [ebp+var_4]
.text:0000B4DD                 mov     ecx, [ebp+var_4]
.text:0000B4E0                 mov     edx, [eax+8]
.text:0000B4E3                 cmp     edx, [ecx+4]
.text:0000B4E6                 jnz     short loc_B4F0
.text:0000B4E8                 mov     ecx, [ebp+var_4] ; this
.text:0000B4EB                 call    ?Grow_1@AString@@AAEXXZ ; AString::Grow_1(void)
.text:0000B4F0
.text:0000B4F0 loc_B4F0:                               ; CODE XREF: AString::operator+=(char)+2Aj
.text:0000B4F0                 mov     eax, [ebp+var_4]
.text:0000B4F3                 mov     ecx, [eax+4]
.text:0000B4F6                 mov     [ebp+var_8], ecx
.text:0000B4F9                 mov     edx, [ebp+var_4]
.text:0000B4FC                 mov     eax, [edx]
.text:0000B4FE                 mov     [ebp+var_C], eax
.text:0000B501                 mov     ecx, [ebp+var_C]
.text:0000B504                 add     ecx, [ebp+var_8]
.text:0000B507                 mov     dl, [ebp+arg_0]
.text:0000B50A                 mov     [ecx], dl
.text:0000B50C                 mov     eax, [ebp+var_8]
.text:0000B50F                 add     eax, 1
.text:0000B512                 mov     [ebp+var_8], eax
.text:0000B515                 mov     ecx, [ebp+var_C]
.text:0000B518                 add     ecx, [ebp+var_8]
.text:0000B51B                 mov     byte ptr [ecx], 0
.text:0000B51E                 mov     edx, [ebp+var_4]
.text:0000B521                 mov     eax, [ebp+var_8]
.text:0000B524                 mov     [edx+4], eax
.text:0000B527                 mov     eax, [ebp+var_4]
.text:0000B52A                 add     esp, 0Ch
.text:0000B52D                 cmp     ebp, esp
.text:0000B52F                 call    __RTC_CheckEsp
.text:0000B534                 mov     esp, ebp
.text:0000B536                 pop     ebp
.text:0000B537                 retn    4
.text:0000B537 ??YAString@@QAEAAV0@D@Z endp
.text:0000B537
.text:0000B537 ; ---------------------------------------------------------------------------
.text:0000B53A                 align 4
.text:0000B53A _text           ends
.text:0000B53A
.text:0000B53C ; ===========================================================================
.text:0000B53C
.text:0000B53C ; Segment type: Pure code
.text:0000B53C ; Segment permissions: Read/Execute
.text:0000B53C _text           segment para public 'CODE' use32
.text:0000B53C                 assume cs:_text
.text:0000B53C                 ;org 0B53Ch
.text:0000B53C ; COMDAT (pick any)
.text:0000B53C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B53C
.text:0000B53C ; =============== S U B R O U T I N E =======================================
.text:0000B53C
.text:0000B53C ; Attributes: bp-based frame
.text:0000B53C
.text:0000B53C ; bool __thiscall AString::IsEmpty(AString *__hidden this)
.text:0000B53C                 public ?IsEmpty@AString@@QBE_NXZ
.text:0000B53C ?IsEmpty@AString@@QBE_NXZ proc near     ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+75Ap
.text:0000B53C
.text:0000B53C var_4           = dword ptr -4
.text:0000B53C
.text:0000B53C                 push    ebp
.text:0000B53D                 mov     ebp, esp
.text:0000B53F                 push    ecx
.text:0000B540                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B547                 mov     [ebp+var_4], ecx
.text:0000B54A                 mov     eax, [ebp+var_4]
.text:0000B54D                 xor     ecx, ecx
.text:0000B54F                 cmp     dword ptr [eax+4], 0
.text:0000B553                 setz    cl
.text:0000B556                 mov     al, cl
.text:0000B558                 mov     esp, ebp
.text:0000B55A                 pop     ebp
.text:0000B55B                 retn
.text:0000B55B ?IsEmpty@AString@@QBE_NXZ endp
.text:0000B55B
.text:0000B55B _text           ends
.text:0000B55B
.text:0000B55C ; ===========================================================================
.text:0000B55C
.text:0000B55C ; Segment type: Pure code
.text:0000B55C ; Segment permissions: Read/Execute
.text:0000B55C _text           segment para public 'CODE' use32
.text:0000B55C                 assume cs:_text
.text:0000B55C                 ;org 0B55Ch
.text:0000B55C ; COMDAT (pick any)
.text:0000B55C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B55C
.text:0000B55C ; =============== S U B R O U T I N E =======================================
.text:0000B55C
.text:0000B55C ; Attributes: bp-based frame
.text:0000B55C
.text:0000B55C ; public: __thiscall AString::operator char const *(void)const
.text:0000B55C                 public ??BAString@@QBEPBDXZ
.text:0000B55C ??BAString@@QBEPBDXZ proc near          ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+41Dp
.text:0000B55C                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+994p ...
.text:0000B55C
.text:0000B55C var_4           = dword ptr -4
.text:0000B55C
.text:0000B55C                 push    ebp
.text:0000B55D                 mov     ebp, esp
.text:0000B55F                 push    ecx
.text:0000B560                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B567                 mov     [ebp+var_4], ecx
.text:0000B56A                 mov     eax, [ebp+var_4]
.text:0000B56D                 mov     eax, [eax]
.text:0000B56F                 mov     esp, ebp
.text:0000B571                 pop     ebp
.text:0000B572                 retn
.text:0000B572 ??BAString@@QBEPBDXZ endp
.text:0000B572
.text:0000B572 ; ---------------------------------------------------------------------------
.text:0000B573                 align 4
.text:0000B573 _text           ends
.text:0000B573
.text:0000B574 ; ===========================================================================
.text:0000B574
.text:0000B574 ; Segment type: Pure code
.text:0000B574 ; Segment permissions: Read/Execute
.text:0000B574 _text           segment para public 'CODE' use32
.text:0000B574                 assume cs:_text
.text:0000B574                 ;org 0B574h
.text:0000B574 ; COMDAT (pick any)
.text:0000B574                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B574
.text:0000B574 ; =============== S U B R O U T I N E =======================================
.text:0000B574
.text:0000B574 ; Attributes: bp-based frame
.text:0000B574
.text:0000B574 ; const char *__thiscall AString::Ptr(AString *this, unsigned int)
.text:0000B574                 public ?Ptr@AString@@QBEPBDI@Z
.text:0000B574 ?Ptr@AString@@QBEPBDI@Z proc near       ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+96Bp
.text:0000B574
.text:0000B574 var_4           = dword ptr -4
.text:0000B574 arg_0           = dword ptr  8
.text:0000B574
.text:0000B574                 push    ebp
.text:0000B575                 mov     ebp, esp
.text:0000B577                 push    ecx
.text:0000B578                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B57F                 mov     [ebp+var_4], ecx
.text:0000B582                 mov     eax, [ebp+var_4]
.text:0000B585                 mov     eax, [eax]
.text:0000B587                 add     eax, [ebp+arg_0]
.text:0000B58A                 mov     esp, ebp
.text:0000B58C                 pop     ebp
.text:0000B58D                 retn    4
.text:0000B58D ?Ptr@AString@@QBEPBDI@Z endp
.text:0000B58D
.text:0000B58D _text           ends
.text:0000B58D
.text:0000B590 ; ===========================================================================
.text:0000B590
.text:0000B590 ; Segment type: Pure code
.text:0000B590 ; Segment permissions: Read/Execute
.text:0000B590 _text           segment para public 'CODE' use32
.text:0000B590                 assume cs:_text
.text:0000B590                 ;org 0B590h
.text:0000B590 ; COMDAT (pick any)
.text:0000B590                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B590
.text:0000B590 ; =============== S U B R O U T I N E =======================================
.text:0000B590
.text:0000B590 ; Attributes: bp-based frame
.text:0000B590
.text:0000B590 ; bool __thiscall AString::IsEqualTo_Ascii_NoCase(AString *this, const char *)
.text:0000B590                 public ?IsEqualTo_Ascii_NoCase@AString@@QBE_NPBD@Z
.text:0000B590 ?IsEqualTo_Ascii_NoCase@AString@@QBE_NPBD@Z proc near
.text:0000B590                                         ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+826p
.text:0000B590                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+FBCp ...
.text:0000B590
.text:0000B590 var_4           = dword ptr -4
.text:0000B590 arg_0           = dword ptr  8
.text:0000B590
.text:0000B590                 push    ebp
.text:0000B591                 mov     ebp, esp
.text:0000B593                 push    ecx
.text:0000B594                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B59B                 mov     [ebp+var_4], ecx
.text:0000B59E                 mov     eax, [ebp+arg_0]
.text:0000B5A1                 push    eax             ; char *
.text:0000B5A2                 mov     ecx, [ebp+var_4]
.text:0000B5A5                 mov     edx, [ecx]
.text:0000B5A7                 push    edx             ; char *
.text:0000B5A8                 call    ?StringsAreEqualNoCase_Ascii@@YG_NPBD0@Z ; StringsAreEqualNoCase_Ascii(char const *,char const *)
.text:0000B5AD                 add     esp, 4
.text:0000B5B0                 cmp     ebp, esp
.text:0000B5B2                 call    __RTC_CheckEsp
.text:0000B5B7                 mov     esp, ebp
.text:0000B5B9                 pop     ebp
.text:0000B5BA                 retn    4
.text:0000B5BA ?IsEqualTo_Ascii_NoCase@AString@@QBE_NPBD@Z endp
.text:0000B5BA
.text:0000B5BA ; ---------------------------------------------------------------------------
.text:0000B5BD                 align 10h
.text:0000B5BD _text           ends
.text:0000B5BD
.text:0000B5C0 ; ===========================================================================
.text:0000B5C0
.text:0000B5C0 ; Segment type: Pure code
.text:0000B5C0 ; Segment permissions: Read/Execute
.text:0000B5C0 _text           segment para public 'CODE' use32
.text:0000B5C0                 assume cs:_text
.text:0000B5C0                 ;org 0B5C0h
.text:0000B5C0 ; COMDAT (pick any)
.text:0000B5C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B5C0
.text:0000B5C0 ; =============== S U B R O U T I N E =======================================
.text:0000B5C0
.text:0000B5C0 ; Attributes: bp-based frame
.text:0000B5C0
.text:0000B5C0 ; int __thiscall AString::Find(AString *this, char)
.text:0000B5C0                 public ?Find@AString@@QBEHD@Z
.text:0000B5C0 ?Find@AString@@QBEHD@Z proc near        ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+947p
.text:0000B5C0
.text:0000B5C0 var_4           = dword ptr -4
.text:0000B5C0 arg_0           = byte ptr  8
.text:0000B5C0
.text:0000B5C0                 push    ebp
.text:0000B5C1                 mov     ebp, esp
.text:0000B5C3                 push    ecx
.text:0000B5C4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B5CB                 mov     [ebp+var_4], ecx
.text:0000B5CE                 movzx   eax, [ebp+arg_0]
.text:0000B5D2                 push    eax             ; char
.text:0000B5D3                 mov     ecx, [ebp+var_4]
.text:0000B5D6                 mov     edx, [ecx]
.text:0000B5D8                 push    edx             ; char *
.text:0000B5D9                 call    ?FindCharPosInString@@YGHPBDD@Z ; FindCharPosInString(char const *,char)
.text:0000B5DE                 add     esp, 4
.text:0000B5E1                 cmp     ebp, esp
.text:0000B5E3                 call    __RTC_CheckEsp
.text:0000B5E8                 mov     esp, ebp
.text:0000B5EA                 pop     ebp
.text:0000B5EB                 retn    4
.text:0000B5EB ?Find@AString@@QBEHD@Z endp
.text:0000B5EB
.text:0000B5EB ; ---------------------------------------------------------------------------
.text:0000B5EE                 align 10h
.text:0000B5EE _text           ends
.text:0000B5EE
.text:0000B5F0 ; ===========================================================================
.text:0000B5F0
.text:0000B5F0 ; Segment type: Pure code
.text:0000B5F0 ; Segment permissions: Read/Execute
.text:0000B5F0 _text           segment para public 'CODE' use32
.text:0000B5F0                 assume cs:_text
.text:0000B5F0                 ;org 0B5F0h
.text:0000B5F0 ; COMDAT (pick any)
.text:0000B5F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B5F0
.text:0000B5F0 ; =============== S U B R O U T I N E =======================================
.text:0000B5F0
.text:0000B5F0 ; Attributes: bp-based frame
.text:0000B5F0
.text:0000B5F0 ; void __thiscall AString::DeleteFrom(AString *this, unsigned int)
.text:0000B5F0                 public ?DeleteFrom@AString@@QAEXI@Z
.text:0000B5F0 ?DeleteFrom@AString@@QAEXI@Z proc near  ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+989p
.text:0000B5F0
.text:0000B5F0 var_4           = dword ptr -4
.text:0000B5F0 arg_0           = dword ptr  8
.text:0000B5F0
.text:0000B5F0                 push    ebp
.text:0000B5F1                 mov     ebp, esp
.text:0000B5F3                 push    ecx
.text:0000B5F4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B5FB                 mov     [ebp+var_4], ecx
.text:0000B5FE                 mov     eax, [ebp+var_4]
.text:0000B601                 mov     ecx, [ebp+arg_0]
.text:0000B604                 cmp     ecx, [eax+4]
.text:0000B607                 jnb     short loc_B61E
.text:0000B609                 mov     edx, [ebp+var_4]
.text:0000B60C                 mov     eax, [ebp+arg_0]
.text:0000B60F                 mov     [edx+4], eax
.text:0000B612                 mov     ecx, [ebp+var_4]
.text:0000B615                 mov     edx, [ecx]
.text:0000B617                 mov     eax, [ebp+arg_0]
.text:0000B61A                 mov     byte ptr [edx+eax], 0
.text:0000B61E
.text:0000B61E loc_B61E:                               ; CODE XREF: AString::DeleteFrom(uint)+17j
.text:0000B61E                 mov     esp, ebp
.text:0000B620                 pop     ebp
.text:0000B621                 retn    4
.text:0000B621 ?DeleteFrom@AString@@QAEXI@Z endp
.text:0000B621
.text:0000B621 _text           ends
.text:0000B621
.text:0000B624 ; ===========================================================================
.text:0000B624
.text:0000B624 ; Segment type: Pure code
.text:0000B624 ; Segment permissions: Read/Execute
.text:0000B624 _text           segment para public 'CODE' use32
.text:0000B624                 assume cs:_text
.text:0000B624                 ;org 0B624h
.text:0000B624 ; COMDAT (pick any)
.text:0000B624                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B624
.text:0000B624 ; =============== S U B R O U T I N E =======================================
.text:0000B624
.text:0000B624 ; Attributes: bp-based frame
.text:0000B624
.text:0000B624 ; bool __thiscall UString::IsEmpty(UString *__hidden this)
.text:0000B624                 public ?IsEmpty@UString@@QBE_NXZ
.text:0000B624 ?IsEmpty@UString@@QBE_NXZ proc near     ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+FFp
.text:0000B624                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+266p ...
.text:0000B624
.text:0000B624 var_4           = dword ptr -4
.text:0000B624
.text:0000B624                 push    ebp
.text:0000B625                 mov     ebp, esp
.text:0000B627                 push    ecx
.text:0000B628                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B62F                 mov     [ebp+var_4], ecx
.text:0000B632                 mov     eax, [ebp+var_4]
.text:0000B635                 xor     ecx, ecx
.text:0000B637                 cmp     dword ptr [eax+4], 0
.text:0000B63B                 setz    cl
.text:0000B63E                 mov     al, cl
.text:0000B640                 mov     esp, ebp
.text:0000B642                 pop     ebp
.text:0000B643                 retn
.text:0000B643 ?IsEmpty@UString@@QBE_NXZ endp
.text:0000B643
.text:0000B643 _text           ends
.text:0000B643
.text:0000B644 ; ===========================================================================
.text:0000B644
.text:0000B644 ; Segment type: Pure code
.text:0000B644 ; Segment permissions: Read/Execute
.text:0000B644 _text           segment para public 'CODE' use32
.text:0000B644                 assume cs:_text
.text:0000B644                 ;org 0B644h
.text:0000B644 ; COMDAT (pick any)
.text:0000B644                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B644
.text:0000B644 ; =============== S U B R O U T I N E =======================================
.text:0000B644
.text:0000B644 ; Attributes: bp-based frame
.text:0000B644
.text:0000B644 ; const wchar_t *__thiscall UString::Ptr(UString *this, unsigned int)
.text:0000B644                 public ?Ptr@UString@@QBEPB_WI@Z
.text:0000B644 ?Ptr@UString@@QBEPB_WI@Z proc near      ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+200p
.text:0000B644
.text:0000B644 var_4           = dword ptr -4
.text:0000B644 arg_0           = dword ptr  8
.text:0000B644
.text:0000B644                 push    ebp
.text:0000B645                 mov     ebp, esp
.text:0000B647                 push    ecx
.text:0000B648                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B64F                 mov     [ebp+var_4], ecx
.text:0000B652                 mov     eax, [ebp+var_4]
.text:0000B655                 mov     ecx, [eax]
.text:0000B657                 mov     edx, [ebp+arg_0]
.text:0000B65A                 lea     eax, [ecx+edx*2]
.text:0000B65D                 mov     esp, ebp
.text:0000B65F                 pop     ebp
.text:0000B660                 retn    4
.text:0000B660 ?Ptr@UString@@QBEPB_WI@Z endp
.text:0000B660
.text:0000B660 ; ---------------------------------------------------------------------------
.text:0000B663                 align 4
.text:0000B663 _text           ends
.text:0000B663
.text:0000B664 ; ===========================================================================
.text:0000B664
.text:0000B664 ; Segment type: Pure code
.text:0000B664 ; Segment permissions: Read/Execute
.text:0000B664 _text           segment para public 'CODE' use32
.text:0000B664                 assume cs:_text
.text:0000B664                 ;org 0B664h
.text:0000B664 ; COMDAT (pick any)
.text:0000B664                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B664
.text:0000B664 ; =============== S U B R O U T I N E =======================================
.text:0000B664
.text:0000B664 ; Attributes: bp-based frame
.text:0000B664
.text:0000B664 ; void __thiscall UString::MakeLower_Ascii(UString *__hidden this)
.text:0000B664                 public ?MakeLower_Ascii@UString@@QAEXXZ
.text:0000B664 ?MakeLower_Ascii@UString@@QAEXXZ proc near
.text:0000B664                                         ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+F4p
.text:0000B664
.text:0000B664 var_4           = dword ptr -4
.text:0000B664
.text:0000B664                 push    ebp
.text:0000B665                 mov     ebp, esp
.text:0000B667                 push    ecx
.text:0000B668                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B66F                 mov     [ebp+var_4], ecx
.text:0000B672                 mov     eax, [ebp+var_4]
.text:0000B675                 mov     ecx, [eax]
.text:0000B677                 push    ecx             ; wchar_t *
.text:0000B678                 call    ?MyStringLower_Ascii@@YGXPA_W@Z ; MyStringLower_Ascii(wchar_t *)
.text:0000B67D                 add     esp, 4
.text:0000B680                 cmp     ebp, esp
.text:0000B682                 call    __RTC_CheckEsp
.text:0000B687                 mov     esp, ebp
.text:0000B689                 pop     ebp
.text:0000B68A                 retn
.text:0000B68A ?MakeLower_Ascii@UString@@QAEXXZ endp
.text:0000B68A
.text:0000B68A ; ---------------------------------------------------------------------------
.text:0000B68B                 align 4
.text:0000B68B _text           ends
.text:0000B68B
.text:0000B68C ; ===========================================================================
.text:0000B68C
.text:0000B68C ; Segment type: Pure code
.text:0000B68C ; Segment permissions: Read/Execute
.text:0000B68C _text           segment para public 'CODE' use32
.text:0000B68C                 assume cs:_text
.text:0000B68C                 ;org 0B68Ch
.text:0000B68C ; COMDAT (pick any)
.text:0000B68C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B68C
.text:0000B68C ; =============== S U B R O U T I N E =======================================
.text:0000B68C
.text:0000B68C ; Attributes: bp-based frame
.text:0000B68C
.text:0000B68C ; bool __thiscall UString::IsEqualTo(UString *this, const char *)
.text:0000B68C                 public ?IsEqualTo@UString@@QBE_NPBD@Z
.text:0000B68C ?IsEqualTo@UString@@QBE_NPBD@Z proc near
.text:0000B68C                                         ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+126p
.text:0000B68C
.text:0000B68C var_4           = dword ptr -4
.text:0000B68C arg_0           = dword ptr  8
.text:0000B68C
.text:0000B68C                 push    ebp
.text:0000B68D                 mov     ebp, esp
.text:0000B68F                 push    ecx
.text:0000B690                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B697                 mov     [ebp+var_4], ecx
.text:0000B69A                 mov     eax, [ebp+arg_0]
.text:0000B69D                 push    eax             ; char *
.text:0000B69E                 mov     ecx, [ebp+var_4]
.text:0000B6A1                 mov     edx, [ecx]
.text:0000B6A3                 push    edx             ; wchar_t *
.text:0000B6A4                 call    ?StringsAreEqual_Ascii@@YG_NPB_WPBD@Z ; StringsAreEqual_Ascii(wchar_t const *,char const *)
.text:0000B6A9                 add     esp, 4
.text:0000B6AC                 cmp     ebp, esp
.text:0000B6AE                 call    __RTC_CheckEsp
.text:0000B6B3                 mov     esp, ebp
.text:0000B6B5                 pop     ebp
.text:0000B6B6                 retn    4
.text:0000B6B6 ?IsEqualTo@UString@@QBE_NPBD@Z endp
.text:0000B6B6
.text:0000B6B6 ; ---------------------------------------------------------------------------
.text:0000B6B9                 align 4
.text:0000B6B9 _text           ends
.text:0000B6B9
.text:0000B6BC ; ===========================================================================
.text:0000B6BC
.text:0000B6BC ; Segment type: Pure code
.text:0000B6BC ; Segment permissions: Read/Execute
.text:0000B6BC _text           segment para public 'CODE' use32
.text:0000B6BC                 assume cs:_text
.text:0000B6BC                 ;org 0B6BCh
.text:0000B6BC ; COMDAT (pick any)
.text:0000B6BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B6BC
.text:0000B6BC ; =============== S U B R O U T I N E =======================================
.text:0000B6BC
.text:0000B6BC ; Attributes: bp-based frame
.text:0000B6BC
.text:0000B6BC ; bool __thiscall UString::IsEqualTo_Ascii_NoCase(UString *this, const char *)
.text:0000B6BC                 public ?IsEqualTo_Ascii_NoCase@UString@@QBE_NPBD@Z
.text:0000B6BC ?IsEqualTo_Ascii_NoCase@UString@@QBE_NPBD@Z proc near
.text:0000B6BC                                         ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+9DFp
.text:0000B6BC
.text:0000B6BC var_4           = dword ptr -4
.text:0000B6BC arg_0           = dword ptr  8
.text:0000B6BC
.text:0000B6BC                 push    ebp
.text:0000B6BD                 mov     ebp, esp
.text:0000B6BF                 push    ecx
.text:0000B6C0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B6C7                 mov     [ebp+var_4], ecx
.text:0000B6CA                 mov     eax, [ebp+arg_0]
.text:0000B6CD                 push    eax             ; char *
.text:0000B6CE                 mov     ecx, [ebp+var_4]
.text:0000B6D1                 mov     edx, [ecx]
.text:0000B6D3                 push    edx             ; wchar_t *
.text:0000B6D4                 call    ?StringsAreEqualNoCase_Ascii@@YG_NPB_WPBD@Z ; StringsAreEqualNoCase_Ascii(wchar_t const *,char const *)
.text:0000B6D9                 add     esp, 4
.text:0000B6DC                 cmp     ebp, esp
.text:0000B6DE                 call    __RTC_CheckEsp
.text:0000B6E3                 mov     esp, ebp
.text:0000B6E5                 pop     ebp
.text:0000B6E6                 retn    4
.text:0000B6E6 ?IsEqualTo_Ascii_NoCase@UString@@QBE_NPBD@Z endp
.text:0000B6E6
.text:0000B6E6 ; ---------------------------------------------------------------------------
.text:0000B6E9                 align 4
.text:0000B6E9 _text           ends
.text:0000B6E9
.text:0000B6EC ; ===========================================================================
.text:0000B6EC
.text:0000B6EC ; Segment type: Pure code
.text:0000B6EC ; Segment permissions: Read/Execute
.text:0000B6EC _text           segment para public 'CODE' use32
.text:0000B6EC                 assume cs:_text
.text:0000B6EC                 ;org 0B6ECh
.text:0000B6EC ; COMDAT (pick any)
.text:0000B6EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B6EC
.text:0000B6EC ; =============== S U B R O U T I N E =======================================
.text:0000B6EC
.text:0000B6EC ; Attributes: bp-based frame
.text:0000B6EC
.text:0000B6EC ; int __stdcall operator==(int, wchar_t *Str2)
.text:0000B6EC                 public ??8@YG_NABVUString@@PB_W@Z
.text:0000B6EC ??8@YG_NABVUString@@PB_W@Z proc near    ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+221p
.text:0000B6EC
.text:0000B6EC arg_0           = dword ptr  8
.text:0000B6EC Str2            = dword ptr  0Ch
.text:0000B6EC
.text:0000B6EC                 push    ebp
.text:0000B6ED                 mov     ebp, esp
.text:0000B6EF                 push    esi
.text:0000B6F0                 mov     esi, esp
.text:0000B6F2                 mov     eax, [ebp+Str2]
.text:0000B6F5                 push    eax             ; Str2
.text:0000B6F6                 mov     ecx, [ebp+arg_0]
.text:0000B6F9                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:0000B6FE                 push    eax             ; Str1
.text:0000B6FF                 call    dword ptr ds:__imp__wcscmp
.text:0000B705                 add     esp, 8
.text:0000B708                 cmp     esi, esp
.text:0000B70A                 call    __RTC_CheckEsp
.text:0000B70F                 neg     eax
.text:0000B711                 sbb     eax, eax
.text:0000B713                 add     eax, 1
.text:0000B716                 pop     esi
.text:0000B717                 cmp     ebp, esp
.text:0000B719                 call    __RTC_CheckEsp
.text:0000B71E                 pop     ebp
.text:0000B71F                 retn    8
.text:0000B71F ??8@YG_NABVUString@@PB_W@Z endp
.text:0000B71F
.text:0000B71F ; ---------------------------------------------------------------------------
.text:0000B722                 align 4
.text:0000B722 _text           ends
.text:0000B722
.text:0000B724 ; ===========================================================================
.text:0000B724
.text:0000B724 ; Segment type: Pure code
.text:0000B724 ; Segment permissions: Read/Execute
.text:0000B724 _text           segment para public 'CODE' use32
.text:0000B724                 assume cs:_text
.text:0000B724                 ;org 0B724h
.text:0000B724 ; COMDAT (pick any)
.text:0000B724                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B724
.text:0000B724 ; =============== S U B R O U T I N E =======================================
.text:0000B724
.text:0000B724 ; Attributes: bp-based frame
.text:0000B724
.text:0000B724 ; public: __thiscall UString::operator wchar_t const *(void)const
.text:0000B724                 public ??BUString@@QBEPB_WXZ
.text:0000B724 ??BUString@@QBEPB_WXZ proc near         ; CODE XREF: ParseNumberString(UString const &,NWindows::NCOM::CPropVariant &)+21p
.text:0000B724                                         ; operator==(UString const &,wchar_t const *)+Dp
.text:0000B724
.text:0000B724 var_4           = dword ptr -4
.text:0000B724
.text:0000B724                 push    ebp
.text:0000B725                 mov     ebp, esp
.text:0000B727                 push    ecx
.text:0000B728                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B72F                 mov     [ebp+var_4], ecx
.text:0000B732                 mov     eax, [ebp+var_4]
.text:0000B735                 mov     eax, [eax]
.text:0000B737                 mov     esp, ebp
.text:0000B739                 pop     ebp
.text:0000B73A                 retn
.text:0000B73A ??BUString@@QBEPB_WXZ endp
.text:0000B73A
.text:0000B73A ; ---------------------------------------------------------------------------
.text:0000B73B                 align 4
.text:0000B73B _text           ends
.text:0000B73B
.text:0000B73C ; ===========================================================================
.text:0000B73C
.text:0000B73C ; Segment type: Pure code
.text:0000B73C ; Segment permissions: Read/Execute
.text:0000B73C _text           segment para public 'CODE' use32
.text:0000B73C                 assume cs:_text
.text:0000B73C                 ;org 0B73Ch
.text:0000B73C ; COMDAT (pick any)
.text:0000B73C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B73C
.text:0000B73C ; =============== S U B R O U T I N E =======================================
.text:0000B73C
.text:0000B73C ; Attributes: bp-based frame
.text:0000B73C
.text:0000B73C ; _DWORD __thiscall NWindows::NCOM::CPropVariant::CPropVariant(NWindows::NCOM::CPropVariant *__hidden this)
.text:0000B73C                 public ??0CPropVariant@NCOM@NWindows@@QAE@XZ
.text:0000B73C ??0CPropVariant@NCOM@NWindows@@QAE@XZ proc near
.text:0000B73C                                         ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+D2p
.text:0000B73C                                         ; TotalBench(unsigned __int64,uint,bool,uint,IBenchPrintCallback *,CBenchCallbackToPrint *)+AEp ...
.text:0000B73C
.text:0000B73C var_4           = dword ptr -4
.text:0000B73C
.text:0000B73C                 push    ebp
.text:0000B73D                 mov     ebp, esp
.text:0000B73F                 push    ecx
.text:0000B740                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B747                 mov     [ebp+var_4], ecx
.text:0000B74A                 xor     eax, eax
.text:0000B74C                 mov     ecx, [ebp+var_4]
.text:0000B74F                 mov     [ecx], ax
.text:0000B752                 xor     edx, edx
.text:0000B754                 mov     eax, [ebp+var_4]
.text:0000B757                 mov     [eax+2], dx
.text:0000B75B                 mov     ecx, [ebp+var_4]
.text:0000B75E                 mov     dword ptr [ecx+8], 0
.text:0000B765                 mov     eax, [ebp+var_4]
.text:0000B768                 mov     esp, ebp
.text:0000B76A                 pop     ebp
.text:0000B76B                 retn
.text:0000B76B ??0CPropVariant@NCOM@NWindows@@QAE@XZ endp
.text:0000B76B
.text:0000B76B _text           ends
.text:0000B76B
.text:0000B76C ; ===========================================================================
.text:0000B76C
.text:0000B76C ; Segment type: Pure code
.text:0000B76C ; Segment permissions: Read/Execute
.text:0000B76C _text           segment para public 'CODE' use32
.text:0000B76C                 assume cs:_text
.text:0000B76C                 ;org 0B76Ch
.text:0000B76C ; COMDAT (pick any)
.text:0000B76C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B76C
.text:0000B76C ; =============== S U B R O U T I N E =======================================
.text:0000B76C
.text:0000B76C ; Attributes: bp-based frame
.text:0000B76C
.text:0000B76C ; _DWORD __thiscall NWindows::NCOM::CPropVariant::~CPropVariant(NWindows::NCOM::CPropVariant *__hidden this)
.text:0000B76C                 public ??1CPropVariant@NCOM@NWindows@@QAE@XZ
.text:0000B76C ??1CPropVariant@NCOM@NWindows@@QAE@XZ proc near
.text:0000B76C                                         ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+19Ep
.text:0000B76C                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1D3p ...
.text:0000B76C
.text:0000B76C var_4           = dword ptr -4
.text:0000B76C
.text:0000B76C                 push    ebp
.text:0000B76D                 mov     ebp, esp
.text:0000B76F                 push    ecx
.text:0000B770                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B777                 mov     [ebp+var_4], ecx
.text:0000B77A                 mov     ecx, [ebp+var_4] ; this
.text:0000B77D                 call    ?Clear@CPropVariant@NCOM@NWindows@@QAEJXZ ; NWindows::NCOM::CPropVariant::Clear(void)
.text:0000B782                 add     esp, 4
.text:0000B785                 cmp     ebp, esp
.text:0000B787                 call    __RTC_CheckEsp
.text:0000B78C                 mov     esp, ebp
.text:0000B78E                 pop     ebp
.text:0000B78F                 retn
.text:0000B78F ??1CPropVariant@NCOM@NWindows@@QAE@XZ endp
.text:0000B78F
.text:0000B78F _text           ends
.text:0000B78F
.text:0000B790 ; ===========================================================================
.text:0000B790
.text:0000B790 ; Segment type: Pure code
.text:0000B790 ; Segment permissions: Read/Execute
.text:0000B790 _text           segment para public 'CODE' use32
.text:0000B790                 assume cs:_text
.text:0000B790                 ;org 0B790h
.text:0000B790 ; COMDAT (pick any)
.text:0000B790                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B790
.text:0000B790 ; =============== S U B R O U T I N E =======================================
.text:0000B790
.text:0000B790 ; Attributes: bp-based frame
.text:0000B790
.text:0000B790 ; _DWORD __thiscall NWindows::NCOM::CPropVariant::CPropVariant(NWindows::NCOM::CPropVariant *this, unsigned int)
.text:0000B790                 public ??0CPropVariant@NCOM@NWindows@@QAE@I@Z
.text:0000B790 ??0CPropVariant@NCOM@NWindows@@QAE@I@Z proc near
.text:0000B790                                         ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1AF7p
.text:0000B790
.text:0000B790 var_4           = dword ptr -4
.text:0000B790 arg_0           = dword ptr  8
.text:0000B790
.text:0000B790                 push    ebp
.text:0000B791                 mov     ebp, esp
.text:0000B793                 push    ecx
.text:0000B794                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B79B                 mov     [ebp+var_4], ecx
.text:0000B79E                 mov     eax, 13h
.text:0000B7A3                 mov     ecx, [ebp+var_4]
.text:0000B7A6                 mov     [ecx], ax
.text:0000B7A9                 xor     edx, edx
.text:0000B7AB                 mov     eax, [ebp+var_4]
.text:0000B7AE                 mov     [eax+2], dx
.text:0000B7B2                 mov     ecx, [ebp+var_4]
.text:0000B7B5                 mov     edx, [ebp+arg_0]
.text:0000B7B8                 mov     [ecx+8], edx
.text:0000B7BB                 mov     eax, [ebp+var_4]
.text:0000B7BE                 mov     esp, ebp
.text:0000B7C0                 pop     ebp
.text:0000B7C1                 retn    4
.text:0000B7C1 ??0CPropVariant@NCOM@NWindows@@QAE@I@Z endp
.text:0000B7C1
.text:0000B7C1 _text           ends
.text:0000B7C1
.text:0000B7C4 ; ===========================================================================
.text:0000B7C4
.text:0000B7C4 ; Segment type: Pure code
.text:0000B7C4 ; Segment permissions: Read/Execute
.text:0000B7C4 _text           segment para public 'CODE' use32
.text:0000B7C4                 assume cs:_text
.text:0000B7C4                 ;org 0B7C4h
.text:0000B7C4 ; COMDAT (pick any)
.text:0000B7C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B7C4
.text:0000B7C4 ; =============== S U B R O U T I N E =======================================
.text:0000B7C4
.text:0000B7C4 ; Attributes: bp-based frame
.text:0000B7C4
.text:0000B7C4 ; bool __thiscall CMethodProps::Get_DicSize(CMethodProps *this, unsigned int *)
.text:0000B7C4                 public ?Get_DicSize@CMethodProps@@QBE_NAAI@Z
.text:0000B7C4 ?Get_DicSize@CMethodProps@@QBE_NAAI@Z proc near
.text:0000B7C4                                         ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+74Cp
.text:0000B7C4
.text:0000B7C4 var_8           = dword ptr -8
.text:0000B7C4 var_4           = dword ptr -4
.text:0000B7C4 arg_0           = dword ptr  8
.text:0000B7C4
.text:0000B7C4                 push    ebp
.text:0000B7C5                 mov     ebp, esp
.text:0000B7C7                 sub     esp, 8
.text:0000B7CA                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000B7D1                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B7D8                 mov     [ebp+var_4], ecx
.text:0000B7DB                 mov     eax, [ebp+arg_0]
.text:0000B7DE                 mov     dword ptr [eax], 0
.text:0000B7E4                 push    1               ; unsigned __int32
.text:0000B7E6                 mov     ecx, [ebp+var_4] ; this
.text:0000B7E9                 call    ?FindProp@CMethodProps@@QBEHK@Z ; CMethodProps::FindProp(ulong)
.text:0000B7EE                 mov     [ebp+var_8], eax
.text:0000B7F1                 cmp     [ebp+var_8], 0
.text:0000B7F5                 jl      short loc_B824
.text:0000B7F7                 mov     ecx, [ebp+var_8]
.text:0000B7FA                 push    ecx
.text:0000B7FB                 mov     ecx, [ebp+var_4]
.text:0000B7FE                 call    ??A?$CObjectVector@UCProp@@@@QBEABUCProp@@I@Z ; CObjectVector<CProp>::operator[](uint)
.text:0000B803                 movzx   edx, word ptr [eax+8]
.text:0000B807                 cmp     edx, 13h
.text:0000B80A                 jnz     short loc_B824
.text:0000B80C                 mov     eax, [ebp+var_8]
.text:0000B80F                 push    eax
.text:0000B810                 mov     ecx, [ebp+var_4]
.text:0000B813                 call    ??A?$CObjectVector@UCProp@@@@QBEABUCProp@@I@Z ; CObjectVector<CProp>::operator[](uint)
.text:0000B818                 mov     ecx, [ebp+arg_0]
.text:0000B81B                 mov     edx, [eax+10h]
.text:0000B81E                 mov     [ecx], edx
.text:0000B820                 mov     al, 1
.text:0000B822                 jmp     short loc_B826
.text:0000B824 ; ---------------------------------------------------------------------------
.text:0000B824
.text:0000B824 loc_B824:                               ; CODE XREF: CMethodProps::Get_DicSize(uint &)+31j
.text:0000B824                                         ; CMethodProps::Get_DicSize(uint &)+46j
.text:0000B824                 xor     al, al
.text:0000B826
.text:0000B826 loc_B826:                               ; CODE XREF: CMethodProps::Get_DicSize(uint &)+5Ej
.text:0000B826                 add     esp, 8
.text:0000B829                 cmp     ebp, esp
.text:0000B82B                 call    __RTC_CheckEsp
.text:0000B830                 mov     esp, ebp
.text:0000B832                 pop     ebp
.text:0000B833                 retn    4
.text:0000B833 ?Get_DicSize@CMethodProps@@QBE_NAAI@Z endp
.text:0000B833
.text:0000B833 ; ---------------------------------------------------------------------------
.text:0000B836                 align 4
.text:0000B836 _text           ends
.text:0000B836
.text:0000B838 ; ===========================================================================
.text:0000B838
.text:0000B838 ; Segment type: Pure code
.text:0000B838 ; Segment permissions: Read/Execute
.text:0000B838 _text           segment para public 'CODE' use32
.text:0000B838                 assume cs:_text
.text:0000B838                 ;org 0B838h
.text:0000B838 ; COMDAT (pick any)
.text:0000B838                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B838
.text:0000B838 ; =============== S U B R O U T I N E =======================================
.text:0000B838
.text:0000B838 ; Attributes: bp-based frame
.text:0000B838
.text:0000B838 ; unsigned int __thiscall CMethodProps::Get_Lzma_DicSize(CMethodProps *__hidden this)
.text:0000B838                 public ?Get_Lzma_DicSize@CMethodProps@@QBEIXZ
.text:0000B838 ?Get_Lzma_DicSize@CMethodProps@@QBEIXZ proc near
.text:0000B838                                         ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+796p
.text:0000B838
.text:0000B838 var_10          = dword ptr -10h
.text:0000B838 var_C           = dword ptr -0Ch
.text:0000B838 var_8           = dword ptr -8
.text:0000B838 var_4           = dword ptr -4
.text:0000B838
.text:0000B838                 push    ebp
.text:0000B839                 mov     ebp, esp
.text:0000B83B                 sub     esp, 10h
.text:0000B83E                 mov     eax, 0CCCCCCCCh
.text:0000B843                 mov     [ebp+var_10], eax
.text:0000B846                 mov     [ebp+var_C], eax
.text:0000B849                 mov     [ebp+var_8], eax
.text:0000B84C                 mov     [ebp+var_4], eax
.text:0000B84F                 mov     [ebp+var_4], ecx
.text:0000B852                 push    1               ; unsigned __int32
.text:0000B854                 mov     ecx, [ebp+var_4] ; this
.text:0000B857                 call    ?FindProp@CMethodProps@@QBEHK@Z ; CMethodProps::FindProp(ulong)
.text:0000B85C                 mov     [ebp+var_8], eax
.text:0000B85F                 cmp     [ebp+var_8], 0
.text:0000B863                 jl      short loc_B88B
.text:0000B865                 mov     eax, [ebp+var_8]
.text:0000B868                 push    eax
.text:0000B869                 mov     ecx, [ebp+var_4]
.text:0000B86C                 call    ??A?$CObjectVector@UCProp@@@@QBEABUCProp@@I@Z ; CObjectVector<CProp>::operator[](uint)
.text:0000B871                 movzx   ecx, word ptr [eax+8]
.text:0000B875                 cmp     ecx, 13h
.text:0000B878                 jnz     short loc_B88B
.text:0000B87A                 mov     edx, [ebp+var_8]
.text:0000B87D                 push    edx
.text:0000B87E                 mov     ecx, [ebp+var_4]
.text:0000B881                 call    ??A?$CObjectVector@UCProp@@@@QBEABUCProp@@I@Z ; CObjectVector<CProp>::operator[](uint)
.text:0000B886                 mov     eax, [eax+10h]
.text:0000B889                 jmp     short loc_B8C9
.text:0000B88B ; ---------------------------------------------------------------------------
.text:0000B88B
.text:0000B88B loc_B88B:                               ; CODE XREF: CMethodProps::Get_Lzma_DicSize(void)+2Bj
.text:0000B88B                                         ; CMethodProps::Get_Lzma_DicSize(void)+40j
.text:0000B88B                 mov     ecx, [ebp+var_4] ; this
.text:0000B88E                 call    ?GetLevel@CMethodProps@@QBEHXZ ; CMethodProps::GetLevel(void)
.text:0000B893                 mov     [ebp+var_C], eax
.text:0000B896                 cmp     [ebp+var_C], 5
.text:0000B89A                 jg      short loc_B8AF
.text:0000B89C                 mov     eax, [ebp+var_C]
.text:0000B89F                 lea     ecx, [eax+eax+0Eh]
.text:0000B8A3                 mov     edx, 1
.text:0000B8A8                 shl     edx, cl
.text:0000B8AA                 mov     [ebp+var_10], edx
.text:0000B8AD                 jmp     short loc_B8C6
.text:0000B8AF ; ---------------------------------------------------------------------------
.text:0000B8AF
.text:0000B8AF loc_B8AF:                               ; CODE XREF: CMethodProps::Get_Lzma_DicSize(void)+62j
.text:0000B8AF                 mov     eax, [ebp+var_C]
.text:0000B8B2                 sub     eax, 6
.text:0000B8B5                 neg     eax
.text:0000B8B7                 sbb     eax, eax
.text:0000B8B9                 and     eax, 2000000h
.text:0000B8BE                 add     eax, 2000000h
.text:0000B8C3                 mov     [ebp+var_10], eax
.text:0000B8C6
.text:0000B8C6 loc_B8C6:                               ; CODE XREF: CMethodProps::Get_Lzma_DicSize(void)+75j
.text:0000B8C6                 mov     eax, [ebp+var_10]
.text:0000B8C9
.text:0000B8C9 loc_B8C9:                               ; CODE XREF: CMethodProps::Get_Lzma_DicSize(void)+51j
.text:0000B8C9                 add     esp, 10h
.text:0000B8CC                 cmp     ebp, esp
.text:0000B8CE                 call    __RTC_CheckEsp
.text:0000B8D3                 mov     esp, ebp
.text:0000B8D5                 pop     ebp
.text:0000B8D6                 retn
.text:0000B8D6 ?Get_Lzma_DicSize@CMethodProps@@QBEIXZ endp
.text:0000B8D6
.text:0000B8D6 ; ---------------------------------------------------------------------------
.text:0000B8D7                 align 4
.text:0000B8D7 _text           ends
.text:0000B8D7
.text:0000B8D8 ; ===========================================================================
.text:0000B8D8
.text:0000B8D8 ; Segment type: Pure code
.text:0000B8D8 ; Segment permissions: Read/Execute
.text:0000B8D8 _text           segment para public 'CODE' use32
.text:0000B8D8                 assume cs:_text
.text:0000B8D8                 ;org 0B8D8h
.text:0000B8D8 ; COMDAT (pick any)
.text:0000B8D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B8D8
.text:0000B8D8 ; =============== S U B R O U T I N E =======================================
.text:0000B8D8
.text:0000B8D8 ; Attributes: bp-based frame
.text:0000B8D8
.text:0000B8D8 ; public: __thiscall COneMethodInfo::COneMethodInfo(void)
.text:0000B8D8                 public ??0COneMethodInfo@@QAE@XZ
.text:0000B8D8 ??0COneMethodInfo@@QAE@XZ proc near     ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+91p
.text:0000B8D8                                         ; TotalBench(unsigned __int64,uint,bool,uint,IBenchPrintCallback *,CBenchCallbackToPrint *)+9Fp ...
.text:0000B8D8
.text:0000B8D8 var_10          = dword ptr -10h
.text:0000B8D8 var_C           = dword ptr -0Ch
.text:0000B8D8 var_4           = dword ptr -4
.text:0000B8D8
.text:0000B8D8                 push    ebp
.text:0000B8D9                 mov     ebp, esp
.text:0000B8DB                 push    0FFFFFFFFh
.text:0000B8DD                 push    offset __ehhandler$??0COneMethodInfo@@QAE@XZ
.text:0000B8E2                 mov     eax, large fs:0
.text:0000B8E8                 push    eax
.text:0000B8E9                 push    ecx
.text:0000B8EA                 mov     [ebp+var_10], 0CCCCCCCCh
.text:0000B8F1                 mov     eax, dword ptr ds:___security_cookie
.text:0000B8F6                 xor     eax, ebp
.text:0000B8F8                 push    eax
.text:0000B8F9                 lea     eax, [ebp+var_C]
.text:0000B8FC                 mov     large fs:0, eax
.text:0000B902                 mov     [ebp+var_10], ecx
.text:0000B905                 mov     ecx, [ebp+var_10]
.text:0000B908                 call    ??0CMethodProps@@QAE@XZ ; CMethodProps::CMethodProps(void)
.text:0000B90D                 mov     [ebp+var_4], 0
.text:0000B914                 mov     ecx, [ebp+var_10]
.text:0000B917                 add     ecx, 0Ch
.text:0000B91A                 call    ??0AString@@QAE@XZ ; AString::AString(void)
.text:0000B91F                 mov     byte ptr [ebp+var_4], 1
.text:0000B923                 mov     ecx, [ebp+var_10]
.text:0000B926                 add     ecx, 18h
.text:0000B929                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:0000B92E                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000B935                 mov     eax, [ebp+var_10]
.text:0000B938                 mov     ecx, [ebp+var_C]
.text:0000B93B                 mov     large fs:0, ecx
.text:0000B942                 pop     ecx
.text:0000B943                 add     esp, 10h
.text:0000B946                 cmp     ebp, esp
.text:0000B948                 call    __RTC_CheckEsp
.text:0000B94D                 mov     esp, ebp
.text:0000B94F                 pop     ebp
.text:0000B950                 retn
.text:0000B950 ??0COneMethodInfo@@QAE@XZ endp
.text:0000B950
.text:0000B950 ; ---------------------------------------------------------------------------
.text:0000B951                 align 4
.text:0000B951 _text           ends
.text:0000B951
.text$x:0000B954 ; ===========================================================================
.text$x:0000B954
.text$x:0000B954 ; Segment type: Pure code
.text$x:0000B954 ; Segment permissions: Read/Execute
.text$x:0000B954 _text$x         segment para public 'CODE' use32
.text$x:0000B954                 assume cs:_text$x
.text$x:0000B954                 ;org 0B954h
.text$x:0000B954 ; COMDAT (pick associative to section at B8D8)
.text$x:0000B954                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000B954
.text$x:0000B954 ; =============== S U B R O U T I N E =======================================
.text$x:0000B954
.text$x:0000B954
.text$x:0000B954 __unwindfunclet$??0COneMethodInfo@@QAE@XZ$0 proc near
.text$x:0000B954                                         ; DATA XREF: .xdata$x:0000B988o
.text$x:0000B954                 mov     ecx, [ebp-10h]  ; this
.text$x:0000B957                 jmp     ??1CMethodProps@@QAE@XZ ; CMethodProps::~CMethodProps(void)
.text$x:0000B957 __unwindfunclet$??0COneMethodInfo@@QAE@XZ$0 endp
.text$x:0000B957
.text$x:0000B95C
.text$x:0000B95C ; =============== S U B R O U T I N E =======================================
.text$x:0000B95C
.text$x:0000B95C
.text$x:0000B95C __unwindfunclet$??0COneMethodInfo@@QAE@XZ$1 proc near
.text$x:0000B95C                                         ; DATA XREF: .xdata$x:0000B990o
.text$x:0000B95C                 mov     ecx, [ebp-10h]
.text$x:0000B95F                 add     ecx, 0Ch        ; this
.text$x:0000B962                 jmp     ??1AString@@QAE@XZ ; AString::~AString(void)
.text$x:0000B962 __unwindfunclet$??0COneMethodInfo@@QAE@XZ$1 endp
.text$x:0000B962
.text$x:0000B967
.text$x:0000B967 ; =============== S U B R O U T I N E =======================================
.text$x:0000B967
.text$x:0000B967
.text$x:0000B967 __ehhandler$??0COneMethodInfo@@QAE@XZ proc near
.text$x:0000B967                                         ; DATA XREF: COneMethodInfo::COneMethodInfo(void)+5o
.text$x:0000B967
.text$x:0000B967 arg_4           = dword ptr  8
.text$x:0000B967
.text$x:0000B967                 mov     edx, [esp+arg_4]
.text$x:0000B96B                 lea     eax, [edx+0Ch]
.text$x:0000B96E                 mov     ecx, [edx-8]
.text$x:0000B971                 xor     ecx, eax
.text$x:0000B973                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B978                 mov     eax, offset __ehfuncinfo$??0COneMethodInfo@@QAE@XZ
.text$x:0000B97D                 jmp     ___CxxFrameHandler3
.text$x:0000B97D __ehhandler$??0COneMethodInfo@@QAE@XZ endp
.text$x:0000B97D
.text$x:0000B97D ; ---------------------------------------------------------------------------
.text$x:0000B982                 align 4
.text$x:0000B982 _text$x         ends
.text$x:0000B982
.xdata$x:0000B984 ; ===========================================================================
.xdata$x:0000B984
.xdata$x:0000B984 ; Segment type: Pure data
.xdata$x:0000B984 ; Segment permissions: Read
.xdata$x:0000B984 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000B984                 assume cs:_xdata$x
.xdata$x:0000B984                 ;org 0B984h
.xdata$x:0000B984 ; COMDAT (pick associative to section at B8D8)
.xdata$x:0000B984 __unwindtable$??0COneMethodInfo@@QAE@XZ db 0FFh
.xdata$x:0000B984                                         ; DATA XREF: .xdata$x:0000B99Co
.xdata$x:0000B985                 db 0FFh
.xdata$x:0000B986                 db 0FFh
.xdata$x:0000B987                 db 0FFh
.xdata$x:0000B988                 dd offset __unwindfunclet$??0COneMethodInfo@@QAE@XZ$0
.xdata$x:0000B98C                 align 10h
.xdata$x:0000B990                 dd offset __unwindfunclet$??0COneMethodInfo@@QAE@XZ$1
.xdata$x:0000B994 __ehfuncinfo$??0COneMethodInfo@@QAE@XZ db  22h ; "
.xdata$x:0000B994                                         ; DATA XREF: __ehhandler$??0COneMethodInfo@@QAE@XZ+11o
.xdata$x:0000B995                 db    5
.xdata$x:0000B996                 db  93h ; ô
.xdata$x:0000B997                 db  19h
.xdata$x:0000B998                 db    2
.xdata$x:0000B999                 db    0
.xdata$x:0000B99A                 db    0
.xdata$x:0000B99B                 db    0
.xdata$x:0000B99C                 dd offset __unwindtable$??0COneMethodInfo@@QAE@XZ
.xdata$x:0000B9A0                 db    0
.xdata$x:0000B9A1                 db    0
.xdata$x:0000B9A2                 db    0
.xdata$x:0000B9A3                 db    0
.xdata$x:0000B9A4                 db    0
.xdata$x:0000B9A5                 db    0
.xdata$x:0000B9A6                 db    0
.xdata$x:0000B9A7                 db    0
.xdata$x:0000B9A8                 db    0
.xdata$x:0000B9A9                 db    0
.xdata$x:0000B9AA                 db    0
.xdata$x:0000B9AB                 db    0
.xdata$x:0000B9AC                 db    0
.xdata$x:0000B9AD                 db    0
.xdata$x:0000B9AE                 db    0
.xdata$x:0000B9AF                 db    0
.xdata$x:0000B9B0                 db    0
.xdata$x:0000B9B1                 db    0
.xdata$x:0000B9B2                 db    0
.xdata$x:0000B9B3                 db    0
.xdata$x:0000B9B4                 db    1
.xdata$x:0000B9B5                 db    0
.xdata$x:0000B9B6                 db    0
.xdata$x:0000B9B7                 db    0
.xdata$x:0000B9B7 _xdata$x        ends
.xdata$x:0000B9B7
.text:0000B9B8 ; ===========================================================================
.text:0000B9B8
.text:0000B9B8 ; Segment type: Pure code
.text:0000B9B8 ; Segment permissions: Read/Execute
.text:0000B9B8 _text           segment para public 'CODE' use32
.text:0000B9B8                 assume cs:_text
.text:0000B9B8                 ;org 0B9B8h
.text:0000B9B8 ; COMDAT (pick any)
.text:0000B9B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B9B8
.text:0000B9B8 ; =============== S U B R O U T I N E =======================================
.text:0000B9B8
.text:0000B9B8 ; Attributes: bp-based frame
.text:0000B9B8
.text:0000B9B8 ; public: __thiscall CMethodProps::CMethodProps(void)
.text:0000B9B8                 public ??0CMethodProps@@QAE@XZ
.text:0000B9B8 ??0CMethodProps@@QAE@XZ proc near       ; CODE XREF: COneMethodInfo::COneMethodInfo(void)+30p
.text:0000B9B8
.text:0000B9B8 var_4           = dword ptr -4
.text:0000B9B8
.text:0000B9B8                 push    ebp
.text:0000B9B9                 mov     ebp, esp
.text:0000B9BB                 push    ecx
.text:0000B9BC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B9C3                 mov     [ebp+var_4], ecx
.text:0000B9C6                 mov     ecx, [ebp+var_4]
.text:0000B9C9                 call    ??0CProps@@QAE@XZ ; CProps::CProps(void)
.text:0000B9CE                 mov     eax, [ebp+var_4]
.text:0000B9D1                 add     esp, 4
.text:0000B9D4                 cmp     ebp, esp
.text:0000B9D6                 call    __RTC_CheckEsp
.text:0000B9DB                 mov     esp, ebp
.text:0000B9DD                 pop     ebp
.text:0000B9DE                 retn
.text:0000B9DE ??0CMethodProps@@QAE@XZ endp
.text:0000B9DE
.text:0000B9DE ; ---------------------------------------------------------------------------
.text:0000B9DF                 align 10h
.text:0000B9DF _text           ends
.text:0000B9DF
.text:0000B9E0 ; ===========================================================================
.text:0000B9E0
.text:0000B9E0 ; Segment type: Pure code
.text:0000B9E0 ; Segment permissions: Read/Execute
.text:0000B9E0 _text           segment para public 'CODE' use32
.text:0000B9E0                 assume cs:_text
.text:0000B9E0                 ;org 0B9E0h
.text:0000B9E0 ; COMDAT (pick any)
.text:0000B9E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B9E0
.text:0000B9E0 ; =============== S U B R O U T I N E =======================================
.text:0000B9E0
.text:0000B9E0 ; Attributes: bp-based frame
.text:0000B9E0
.text:0000B9E0 ; public: __thiscall CProps::CProps(void)
.text:0000B9E0                 public ??0CProps@@QAE@XZ
.text:0000B9E0 ??0CProps@@QAE@XZ proc near             ; CODE XREF: CMethodProps::CMethodProps(void)+11p
.text:0000B9E0
.text:0000B9E0 var_4           = dword ptr -4
.text:0000B9E0
.text:0000B9E0                 push    ebp
.text:0000B9E1                 mov     ebp, esp
.text:0000B9E3                 push    ecx
.text:0000B9E4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B9EB                 mov     [ebp+var_4], ecx
.text:0000B9EE                 mov     ecx, [ebp+var_4]
.text:0000B9F1                 call    ??0?$CObjectVector@UCProp@@@@QAE@XZ ; CObjectVector<CProp>::CObjectVector<CProp>(void)
.text:0000B9F6                 mov     eax, [ebp+var_4]
.text:0000B9F9                 add     esp, 4
.text:0000B9FC                 cmp     ebp, esp
.text:0000B9FE                 call    __RTC_CheckEsp
.text:0000BA03                 mov     esp, ebp
.text:0000BA05                 pop     ebp
.text:0000BA06                 retn
.text:0000BA06 ??0CProps@@QAE@XZ endp
.text:0000BA06
.text:0000BA06 ; ---------------------------------------------------------------------------
.text:0000BA07                 align 4
.text:0000BA07 _text           ends
.text:0000BA07
.text:0000BA08 ; ===========================================================================
.text:0000BA08
.text:0000BA08 ; Segment type: Pure code
.text:0000BA08 ; Segment permissions: Read/Execute
.text:0000BA08 _text           segment para public 'CODE' use32
.text:0000BA08                 assume cs:_text
.text:0000BA08                 ;org 0BA08h
.text:0000BA08 ; COMDAT (pick any)
.text:0000BA08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BA08
.text:0000BA08 ; =============== S U B R O U T I N E =======================================
.text:0000BA08
.text:0000BA08 ; Attributes: bp-based frame
.text:0000BA08
.text:0000BA08 ; unsigned int __thiscall NWindows::CThread::Wait(NWindows::CThread *__hidden this)
.text:0000BA08                 public ?Wait@CThread@NWindows@@QAEIXZ
.text:0000BA08 ?Wait@CThread@NWindows@@QAEIXZ proc near
.text:0000BA08                                         ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+7C7p
.text:0000BA08                                         ; MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+C62p ...
.text:0000BA08
.text:0000BA08 var_4           = dword ptr -4
.text:0000BA08
.text:0000BA08                 push    ebp
.text:0000BA09                 mov     ebp, esp
.text:0000BA0B                 push    ecx
.text:0000BA0C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000BA13                 mov     [ebp+var_4], ecx
.text:0000BA16                 mov     eax, [ebp+var_4]
.text:0000BA19                 mov     ecx, [eax]
.text:0000BA1B                 push    ecx
.text:0000BA1C                 call    _Handle_WaitObject@4 ; Handle_WaitObject(x)
.text:0000BA21                 add     esp, 4
.text:0000BA24                 cmp     ebp, esp
.text:0000BA26                 call    __RTC_CheckEsp
.text:0000BA2B                 mov     esp, ebp
.text:0000BA2D                 pop     ebp
.text:0000BA2E                 retn
.text:0000BA2E ?Wait@CThread@NWindows@@QAEIXZ endp
.text:0000BA2E
.text:0000BA2E ; ---------------------------------------------------------------------------
.text:0000BA2F                 align 10h
.text:0000BA2F _text           ends
.text:0000BA2F
.text:0000BA30 ; ===========================================================================
.text:0000BA30
.text:0000BA30 ; Segment type: Pure code
.text:0000BA30 ; Segment permissions: Read/Execute
.text:0000BA30 _text           segment para public 'CODE' use32
.text:0000BA30                 assume cs:_text
.text:0000BA30                 ;org 0BA30h
.text:0000BA30 ; COMDAT (pick any)
.text:0000BA30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BA30
.text:0000BA30 ; =============== S U B R O U T I N E =======================================
.text:0000BA30
.text:0000BA30 ; Attributes: bp-based frame
.text:0000BA30
.text:0000BA30 ; int __thiscall CMethodProps::Get_NumThreads(CMethodProps *__hidden this)
.text:0000BA30                 public ?Get_NumThreads@CMethodProps@@QBEHXZ
.text:0000BA30 ?Get_NumThreads@CMethodProps@@QBEHXZ proc near
.text:0000BA30                                         ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+A5Cp
.text:0000BA30                                         ; CMethodProps::Get_Lzma_NumThreads(bool &)+20p
.text:0000BA30
.text:0000BA30 var_8           = dword ptr -8
.text:0000BA30 var_4           = dword ptr -4
.text:0000BA30
.text:0000BA30                 push    ebp
.text:0000BA31                 mov     ebp, esp
.text:0000BA33                 sub     esp, 8
.text:0000BA36                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000BA3D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000BA44                 mov     [ebp+var_4], ecx
.text:0000BA47                 push    0Dh             ; unsigned __int32
.text:0000BA49                 mov     ecx, [ebp+var_4] ; this
.text:0000BA4C                 call    ?FindProp@CMethodProps@@QBEHK@Z ; CMethodProps::FindProp(ulong)
.text:0000BA51                 mov     [ebp+var_8], eax
.text:0000BA54                 cmp     [ebp+var_8], 0
.text:0000BA58                 jl      short loc_BA80
.text:0000BA5A                 mov     eax, [ebp+var_8]
.text:0000BA5D                 push    eax
.text:0000BA5E                 mov     ecx, [ebp+var_4]
.text:0000BA61                 call    ??A?$CObjectVector@UCProp@@@@QBEABUCProp@@I@Z ; CObjectVector<CProp>::operator[](uint)
.text:0000BA66                 movzx   ecx, word ptr [eax+8]
.text:0000BA6A                 cmp     ecx, 13h
.text:0000BA6D                 jnz     short loc_BA80
.text:0000BA6F                 mov     edx, [ebp+var_8]
.text:0000BA72                 push    edx
.text:0000BA73                 mov     ecx, [ebp+var_4]
.text:0000BA76                 call    ??A?$CObjectVector@UCProp@@@@QBEABUCProp@@I@Z ; CObjectVector<CProp>::operator[](uint)
.text:0000BA7B                 mov     eax, [eax+10h]
.text:0000BA7E                 jmp     short loc_BA83
.text:0000BA80 ; ---------------------------------------------------------------------------
.text:0000BA80
.text:0000BA80 loc_BA80:                               ; CODE XREF: CMethodProps::Get_NumThreads(void)+28j
.text:0000BA80                                         ; CMethodProps::Get_NumThreads(void)+3Dj
.text:0000BA80                 or      eax, 0FFFFFFFFh
.text:0000BA83
.text:0000BA83 loc_BA83:                               ; CODE XREF: CMethodProps::Get_NumThreads(void)+4Ej
.text:0000BA83                 add     esp, 8
.text:0000BA86                 cmp     ebp, esp
.text:0000BA88                 call    __RTC_CheckEsp
.text:0000BA8D                 mov     esp, ebp
.text:0000BA8F                 pop     ebp
.text:0000BA90                 retn
.text:0000BA90 ?Get_NumThreads@CMethodProps@@QBEHXZ endp
.text:0000BA90
.text:0000BA90 ; ---------------------------------------------------------------------------
.text:0000BA91                 align 4
.text:0000BA91 _text           ends
.text:0000BA91
.text:0000BA94 ; ===========================================================================
.text:0000BA94
.text:0000BA94 ; Segment type: Pure code
.text:0000BA94 ; Segment permissions: Read/Execute
.text:0000BA94 _text           segment para public 'CODE' use32
.text:0000BA94                 assume cs:_text
.text:0000BA94                 ;org 0BA94h
.text:0000BA94 ; COMDAT (pick any)
.text:0000BA94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BA94
.text:0000BA94 ; =============== S U B R O U T I N E =======================================
.text:0000BA94
.text:0000BA94 ; Attributes: bp-based frame
.text:0000BA94
.text:0000BA94 ; unsigned int __thiscall CMethodProps::Get_Lzma_NumThreads(CMethodProps *this, bool *)
.text:0000BA94                 public ?Get_Lzma_NumThreads@CMethodProps@@QBEIAA_N@Z
.text:0000BA94 ?Get_Lzma_NumThreads@CMethodProps@@QBEIAA_N@Z proc near
.text:0000BA94                                         ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+E7p
.text:0000BA94
.text:0000BA94 var_8           = dword ptr -8
.text:0000BA94 var_4           = dword ptr -4
.text:0000BA94 arg_0           = dword ptr  8
.text:0000BA94
.text:0000BA94                 push    ebp
.text:0000BA95                 mov     ebp, esp
.text:0000BA97                 sub     esp, 8
.text:0000BA9A                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000BAA1                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000BAA8                 mov     [ebp+var_4], ecx
.text:0000BAAB                 mov     eax, [ebp+arg_0]
.text:0000BAAE                 mov     byte ptr [eax], 0
.text:0000BAB1                 mov     ecx, [ebp+var_4] ; this
.text:0000BAB4                 call    ?Get_NumThreads@CMethodProps@@QBEHXZ ; CMethodProps::Get_NumThreads(void)
.text:0000BAB9                 mov     [ebp+var_8], eax
.text:0000BABC                 cmp     [ebp+var_8], 0
.text:0000BAC0                 jl      short loc_BAD6
.text:0000BAC2                 mov     ecx, [ebp+arg_0]
.text:0000BAC5                 mov     byte ptr [ecx], 1
.text:0000BAC8                 xor     eax, eax
.text:0000BACA                 cmp     [ebp+var_8], 2
.text:0000BACE                 setnl   al
.text:0000BAD1                 add     eax, 1
.text:0000BAD4                 jmp     short loc_BAE7
.text:0000BAD6 ; ---------------------------------------------------------------------------
.text:0000BAD6
.text:0000BAD6 loc_BAD6:                               ; CODE XREF: CMethodProps::Get_Lzma_NumThreads(bool &)+2Cj
.text:0000BAD6                 mov     ecx, [ebp+var_4] ; this
.text:0000BAD9                 call    ?Get_Lzma_Algo@CMethodProps@@QBEIXZ ; CMethodProps::Get_Lzma_Algo(void)
.text:0000BADE                 neg     eax
.text:0000BAE0                 sbb     eax, eax
.text:0000BAE2                 neg     eax
.text:0000BAE4                 add     eax, 1
.text:0000BAE7
.text:0000BAE7 loc_BAE7:                               ; CODE XREF: CMethodProps::Get_Lzma_NumThreads(bool &)+40j
.text:0000BAE7                 add     esp, 8
.text:0000BAEA                 cmp     ebp, esp
.text:0000BAEC                 call    __RTC_CheckEsp
.text:0000BAF1                 mov     esp, ebp
.text:0000BAF3                 pop     ebp
.text:0000BAF4                 retn    4
.text:0000BAF4 ?Get_Lzma_NumThreads@CMethodProps@@QBEIAA_N@Z endp
.text:0000BAF4
.text:0000BAF4 ; ---------------------------------------------------------------------------
.text:0000BAF7                 align 4
.text:0000BAF7 _text           ends
.text:0000BAF7
.text:0000BAF8 ; ===========================================================================
.text:0000BAF8
.text:0000BAF8 ; Segment type: Pure code
.text:0000BAF8 ; Segment permissions: Read/Execute
.text:0000BAF8 _text           segment para public 'CODE' use32
.text:0000BAF8                 assume cs:_text
.text:0000BAF8                 ;org 0BAF8h
.text:0000BAF8 ; COMDAT (pick any)
.text:0000BAF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BAF8
.text:0000BAF8 ; =============== S U B R O U T I N E =======================================
.text:0000BAF8
.text:0000BAF8 ; Attributes: bp-based frame
.text:0000BAF8
.text:0000BAF8 ; unsigned int __thiscall CMethodProps::Get_Lzma_Algo(CMethodProps *__hidden this)
.text:0000BAF8                 public ?Get_Lzma_Algo@CMethodProps@@QBEIXZ
.text:0000BAF8 ?Get_Lzma_Algo@CMethodProps@@QBEIXZ proc near
.text:0000BAF8                                         ; CODE XREF: CMethodProps::Get_Lzma_NumThreads(bool &)+45p
.text:0000BAF8
.text:0000BAF8 var_8           = dword ptr -8
.text:0000BAF8 var_4           = dword ptr -4
.text:0000BAF8
.text:0000BAF8                 push    ebp
.text:0000BAF9                 mov     ebp, esp
.text:0000BAFB                 sub     esp, 8
.text:0000BAFE                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000BB05                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000BB0C                 mov     [ebp+var_4], ecx
.text:0000BB0F                 push    0Ch             ; unsigned __int32
.text:0000BB11                 mov     ecx, [ebp+var_4] ; this
.text:0000BB14                 call    ?FindProp@CMethodProps@@QBEHK@Z ; CMethodProps::FindProp(ulong)
.text:0000BB19                 mov     [ebp+var_8], eax
.text:0000BB1C                 cmp     [ebp+var_8], 0
.text:0000BB20                 jl      short loc_BB48
.text:0000BB22                 mov     eax, [ebp+var_8]
.text:0000BB25                 push    eax
.text:0000BB26                 mov     ecx, [ebp+var_4]
.text:0000BB29                 call    ??A?$CObjectVector@UCProp@@@@QBEABUCProp@@I@Z ; CObjectVector<CProp>::operator[](uint)
.text:0000BB2E                 movzx   ecx, word ptr [eax+8]
.text:0000BB32                 cmp     ecx, 13h
.text:0000BB35                 jnz     short loc_BB48
.text:0000BB37                 mov     edx, [ebp+var_8]
.text:0000BB3A                 push    edx
.text:0000BB3B                 mov     ecx, [ebp+var_4]
.text:0000BB3E                 call    ??A?$CObjectVector@UCProp@@@@QBEABUCProp@@I@Z ; CObjectVector<CProp>::operator[](uint)
.text:0000BB43                 mov     eax, [eax+10h]
.text:0000BB46                 jmp     short loc_BB5A
.text:0000BB48 ; ---------------------------------------------------------------------------
.text:0000BB48
.text:0000BB48 loc_BB48:                               ; CODE XREF: CMethodProps::Get_Lzma_Algo(void)+28j
.text:0000BB48                                         ; CMethodProps::Get_Lzma_Algo(void)+3Dj
.text:0000BB48                 mov     ecx, [ebp+var_4] ; this
.text:0000BB4B                 call    ?GetLevel@CMethodProps@@QBEHXZ ; CMethodProps::GetLevel(void)
.text:0000BB50                 xor     ecx, ecx
.text:0000BB52                 cmp     eax, 5
.text:0000BB55                 setnl   cl
.text:0000BB58                 mov     eax, ecx
.text:0000BB5A
.text:0000BB5A loc_BB5A:                               ; CODE XREF: CMethodProps::Get_Lzma_Algo(void)+4Ej
.text:0000BB5A                 add     esp, 8
.text:0000BB5D                 cmp     ebp, esp
.text:0000BB5F                 call    __RTC_CheckEsp
.text:0000BB64                 mov     esp, ebp
.text:0000BB66                 pop     ebp
.text:0000BB67                 retn
.text:0000BB67 ?Get_Lzma_Algo@CMethodProps@@QBEIXZ endp
.text:0000BB67
.text:0000BB67 _text           ends
.text:0000BB67
.text:0000BB68 ; ===========================================================================
.text:0000BB68
.text:0000BB68 ; Segment type: Pure code
.text:0000BB68 ; Segment permissions: Read/Execute
.text:0000BB68 _text           segment para public 'CODE' use32
.text:0000BB68                 assume cs:_text
.text:0000BB68                 ;org 0BB68h
.text:0000BB68 ; COMDAT (pick any)
.text:0000BB68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BB68
.text:0000BB68 ; =============== S U B R O U T I N E =======================================
.text:0000BB68
.text:0000BB68 ; Attributes: bp-based frame
.text:0000BB68
.text:0000BB68 ; void __thiscall CMethodProps::AddProp_NumThreads(CMethodProps *this, unsigned int)
.text:0000BB68                 public ?AddProp_NumThreads@CMethodProps@@QAEXI@Z
.text:0000BB68 ?AddProp_NumThreads@CMethodProps@@QAEXI@Z proc near
.text:0000BB68                                         ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+102p
.text:0000BB68
.text:0000BB68 var_4           = dword ptr -4
.text:0000BB68 arg_0           = dword ptr  8
.text:0000BB68
.text:0000BB68                 push    ebp
.text:0000BB69                 mov     ebp, esp
.text:0000BB6B                 push    ecx
.text:0000BB6C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000BB73                 mov     [ebp+var_4], ecx
.text:0000BB76                 mov     eax, [ebp+arg_0]
.text:0000BB79                 push    eax             ; unsigned int
.text:0000BB7A                 push    0Dh             ; unsigned __int32
.text:0000BB7C                 mov     ecx, [ebp+var_4] ; this
.text:0000BB7F                 call    ?AddProp32@CProps@@QAEXKI@Z ; CProps::AddProp32(ulong,uint)
.text:0000BB84                 add     esp, 4
.text:0000BB87                 cmp     ebp, esp
.text:0000BB89                 call    __RTC_CheckEsp
.text:0000BB8E                 mov     esp, ebp
.text:0000BB90                 pop     ebp
.text:0000BB91                 retn    4
.text:0000BB91 ?AddProp_NumThreads@CMethodProps@@QAEXI@Z endp
.text:0000BB91
.text:0000BB91 _text           ends
.text:0000BB91
.text:0000BB94 ; ===========================================================================
.text:0000BB94
.text:0000BB94 ; Segment type: Pure code
.text:0000BB94 ; Segment permissions: Read/Execute
.text:0000BB94 _text           segment para public 'CODE' use32
.text:0000BB94                 assume cs:_text
.text:0000BB94                 ;org 0BB94h
.text:0000BB94 ; COMDAT (pick any)
.text:0000BB94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BB94
.text:0000BB94 ; =============== S U B R O U T I N E =======================================
.text:0000BB94
.text:0000BB94 ; Attributes: bp-based frame
.text:0000BB94
.text:0000BB94 ; public: __thiscall CBenchProgressInfo::CBenchProgressInfo(void)
.text:0000BB94                 public ??0CBenchProgressInfo@@QAE@XZ
.text:0000BB94 ??0CBenchProgressInfo@@QAE@XZ proc near ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+607p
.text:0000BB94
.text:0000BB94 var_4           = dword ptr -4
.text:0000BB94
.text:0000BB94                 push    ebp
.text:0000BB95                 mov     ebp, esp
.text:0000BB97                 push    ecx
.text:0000BB98                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000BB9F                 mov     [ebp+var_4], ecx
.text:0000BBA2                 mov     ecx, [ebp+var_4] ; this
.text:0000BBA5                 call    ??0ICompressProgressInfo@@QAE@XZ ; ICompressProgressInfo::ICompressProgressInfo(void)
.text:0000BBAA                 mov     ecx, [ebp+var_4]
.text:0000BBAD                 add     ecx, 4          ; this
.text:0000BBB0                 call    ??0CMyUnknownImp@@QAE@XZ ; CMyUnknownImp::CMyUnknownImp(void)
.text:0000BBB5                 mov     ecx, [ebp+var_4]
.text:0000BBB8                 add     ecx, 8          ; this
.text:0000BBBB                 call    ??0CBenchInfoCalc@@QAE@XZ ; CBenchInfoCalc::CBenchInfoCalc(void)
.text:0000BBC0                 mov     eax, [ebp+var_4]
.text:0000BBC3                 mov     dword ptr [eax], offset ??_7CBenchProgressInfo@@6B@ ; const CBenchProgressInfo::`vftable'
.text:0000BBC9                 mov     ecx, [ebp+var_4]
.text:0000BBCC                 mov     dword ptr [ecx+50h], 0
.text:0000BBD3                 mov     eax, [ebp+var_4]
.text:0000BBD6                 add     esp, 4
.text:0000BBD9                 cmp     ebp, esp
.text:0000BBDB                 call    __RTC_CheckEsp
.text:0000BBE0                 mov     esp, ebp
.text:0000BBE2                 pop     ebp
.text:0000BBE3                 retn
.text:0000BBE3 ??0CBenchProgressInfo@@QAE@XZ endp
.text:0000BBE3
.text:0000BBE3 _text           ends
.text:0000BBE3
.rdata:0000BBE4 ; ===========================================================================
.rdata:0000BBE4
.rdata:0000BBE4 ; Segment type: Pure data
.rdata:0000BBE4 ; Segment permissions: Read
.rdata:0000BBE4 _rdata          segment dword public 'DATA' use32
.rdata:0000BBE4                 assume cs:_rdata
.rdata:0000BBE4                 ;org 0BBE4h
.rdata:0000BBE4 ; COMDAT (pick largest)
.rdata:0000BBE4                 dd offset ??_R4CBenchProgressInfo@@6B@ ; const CBenchProgressInfo::`RTTI Complete Object Locator'
.rdata:0000BBE8                 public ??_7CBenchProgressInfo@@6B@
.rdata:0000BBE8 ; const CBenchProgressInfo::`vftable'
.rdata:0000BBE8 ??_7CBenchProgressInfo@@6B@ dd offset ?QueryInterface@CBenchProgressInfo@@UAGJABU_GUID@@PAPAX@Z
.rdata:0000BBE8                                         ; DATA XREF: CBenchProgressInfo::CBenchProgressInfo(void)+2Fo
.rdata:0000BBE8                                         ; CBenchProgressInfo::QueryInterface(_GUID const &,void * *)
.rdata:0000BBEC                 dd offset ?AddRef@CBenchProgressInfo@@UAGKXZ ; CBenchProgressInfo::AddRef(void)
.rdata:0000BBF0                 dd offset ?Release@CBenchProgressInfo@@UAGKXZ ; CBenchProgressInfo::Release(void)
.rdata:0000BBF4                 dd offset ?SetRatioInfo@CBenchProgressInfo@@UAGJPB_K0@Z ; CBenchProgressInfo::SetRatioInfo(unsigned __int64 const *,unsigned __int64 const *)
.rdata:0000BBF4 _rdata          ends
.rdata:0000BBF4
.rdata$r:0000BBF8 ; ===========================================================================
.rdata$r:0000BBF8
.rdata$r:0000BBF8 ; Segment type: Pure data
.rdata$r:0000BBF8 ; Segment permissions: Read
.rdata$r:0000BBF8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000BBF8                 assume cs:_rdata$r
.rdata$r:0000BBF8                 ;org 0BBF8h
.rdata$r:0000BBF8 ; COMDAT (pick any)
.rdata$r:0000BBF8                 public ??_R4CBenchProgressInfo@@6B@
.rdata$r:0000BBF8 ; const CBenchProgressInfo::`RTTI Complete Object Locator'
.rdata$r:0000BBF8 ??_R4CBenchProgressInfo@@6B@ db    0    ; DATA XREF: .rdata:0000BBE4o
.rdata$r:0000BBF9                 db    0
.rdata$r:0000BBFA                 db    0
.rdata$r:0000BBFB                 db    0
.rdata$r:0000BBFC                 db    0
.rdata$r:0000BBFD                 db    0
.rdata$r:0000BBFE                 db    0
.rdata$r:0000BBFF                 db    0
.rdata$r:0000BC00                 db    0
.rdata$r:0000BC01                 db    0
.rdata$r:0000BC02                 db    0
.rdata$r:0000BC03                 db    0
.rdata$r:0000BC04                 dd offset ??_R0?AVCBenchProgressInfo@@@8 ; CBenchProgressInfo `RTTI Type Descriptor'
.rdata$r:0000BC08                 dd offset ??_R3CBenchProgressInfo@@8 ; CBenchProgressInfo::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000BC08 _rdata$r        ends
.rdata$r:0000BC08
.data:0000BC0C ; ===========================================================================
.data:0000BC0C
.data:0000BC0C ; Segment type: Pure data
.data:0000BC0C ; Segment permissions: Read/Write
.data:0000BC0C _data           segment dword public 'DATA' use32
.data:0000BC0C                 assume cs:_data
.data:0000BC0C                 ;org 0BC0Ch
.data:0000BC0C ; COMDAT (pick any)
.data:0000BC0C                 public ??_R0?AVCBenchProgressInfo@@@8
.data:0000BC0C ; class CBenchProgressInfo `RTTI Type Descriptor'
.data:0000BC0C ??_R0?AVCBenchProgressInfo@@@8 dd offset ??_7type_info@@6B@
.data:0000BC0C                                         ; DATA XREF: .rdata$r:0000BC04o
.data:0000BC0C                                         ; .rdata$r:CBenchProgressInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:0000BC0C                                         ; const type_info::`vftable'
.data:0000BC10                 db    0
.data:0000BC11                 db    0
.data:0000BC12                 db    0
.data:0000BC13                 db    0
.data:0000BC14                 db  2Eh ; .
.data:0000BC15                 db  3Fh ; ?
.data:0000BC16                 db  41h ; A
.data:0000BC17                 db  56h ; V
.data:0000BC18                 db  43h ; C
.data:0000BC19                 db  42h ; B
.data:0000BC1A                 db  65h ; e
.data:0000BC1B                 db  6Eh ; n
.data:0000BC1C                 db  63h ; c
.data:0000BC1D                 db  68h ; h
.data:0000BC1E                 db  50h ; P
.data:0000BC1F                 db  72h ; r
.data:0000BC20                 db  6Fh ; o
.data:0000BC21                 db  67h ; g
.data:0000BC22                 db  72h ; r
.data:0000BC23                 db  65h ; e
.data:0000BC24                 db  73h ; s
.data:0000BC25                 db  73h ; s
.data:0000BC26                 db  49h ; I
.data:0000BC27                 db  6Eh ; n
.data:0000BC28                 db  66h ; f
.data:0000BC29                 db  6Fh ; o
.data:0000BC2A                 db  40h ; @
.data:0000BC2B                 db  40h ; @
.data:0000BC2C                 db    0
.data:0000BC2D                 align 10h
.data:0000BC2D _data           ends
.data:0000BC2D
.rdata$r:0000BC30 ; ===========================================================================
.rdata$r:0000BC30
.rdata$r:0000BC30 ; Segment type: Pure data
.rdata$r:0000BC30 ; Segment permissions: Read
.rdata$r:0000BC30 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000BC30                 assume cs:_rdata$r
.rdata$r:0000BC30                 ;org 0BC30h
.rdata$r:0000BC30 ; COMDAT (pick any)
.rdata$r:0000BC30                 public ??_R3CBenchProgressInfo@@8
.rdata$r:0000BC30 ; CBenchProgressInfo::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000BC30 ??_R3CBenchProgressInfo@@8 db    0      ; DATA XREF: .rdata$r:0000BC08o
.rdata$r:0000BC30                                         ; .rdata$r:0000BC70o
.rdata$r:0000BC31                 db    0
.rdata$r:0000BC32                 db    0
.rdata$r:0000BC33                 db    0
.rdata$r:0000BC34                 db    1
.rdata$r:0000BC35                 db    0
.rdata$r:0000BC36                 db    0
.rdata$r:0000BC37                 db    0
.rdata$r:0000BC38                 db    5
.rdata$r:0000BC39                 db    0
.rdata$r:0000BC3A                 db    0
.rdata$r:0000BC3B                 db    0
.rdata$r:0000BC3C                 dd offset ??_R2CBenchProgressInfo@@8 ; CBenchProgressInfo::`RTTI Base Class Array'
.rdata$r:0000BC3C _rdata$r        ends
.rdata$r:0000BC3C
.rdata$r:0000BC40 ; ===========================================================================
.rdata$r:0000BC40
.rdata$r:0000BC40 ; Segment type: Pure data
.rdata$r:0000BC40 ; Segment permissions: Read
.rdata$r:0000BC40 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000BC40                 assume cs:_rdata$r
.rdata$r:0000BC40                 ;org 0BC40h
.rdata$r:0000BC40 ; COMDAT (pick any)
.rdata$r:0000BC40                 public ??_R2CBenchProgressInfo@@8
.rdata$r:0000BC40 ; CBenchProgressInfo::`RTTI Base Class Array'
.rdata$r:0000BC40 ??_R2CBenchProgressInfo@@8 dd offset ??_R1A@?0A@EA@CBenchProgressInfo@@8
.rdata$r:0000BC40                                         ; DATA XREF: .rdata$r:0000BC3Co
.rdata$r:0000BC40                                         ; CBenchProgressInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000BC44                 dd offset ??_R1A@?0A@EA@ICompressProgressInfo@@8 ; ICompressProgressInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000BC48                 dd offset ??_R1A@?0A@EA@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000BC4C                 dd offset ??_R13?0A@EA@CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Base Class Descriptor at (4,-1,0,64)'
.rdata$r:0000BC50                 dd offset ??_R17?0A@EA@CBenchInfoCalc@@8 ; CBenchInfoCalc::`RTTI Base Class Descriptor at (8,-1,0,64)'
.rdata$r:0000BC54                 db    0
.rdata$r:0000BC55                 align 4
.rdata$r:0000BC55 _rdata$r        ends
.rdata$r:0000BC55
.rdata$r:0000BC58 ; ===========================================================================
.rdata$r:0000BC58
.rdata$r:0000BC58 ; Segment type: Pure data
.rdata$r:0000BC58 ; Segment permissions: Read
.rdata$r:0000BC58 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000BC58                 assume cs:_rdata$r
.rdata$r:0000BC58                 ;org 0BC58h
.rdata$r:0000BC58 ; COMDAT (pick any)
.rdata$r:0000BC58                 public ??_R1A@?0A@EA@CBenchProgressInfo@@8
.rdata$r:0000BC58 ; CBenchProgressInfo::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000BC58 ??_R1A@?0A@EA@CBenchProgressInfo@@8 dd offset ??_R0?AVCBenchProgressInfo@@@8
.rdata$r:0000BC58                                         ; DATA XREF: .rdata$r:CBenchProgressInfo::`RTTI Base Class Array'o
.rdata$r:0000BC58                                         ; CBenchProgressInfo `RTTI Type Descriptor'
.rdata$r:0000BC5C                 db    4
.rdata$r:0000BC5D                 db    0
.rdata$r:0000BC5E                 db    0
.rdata$r:0000BC5F                 db    0
.rdata$r:0000BC60                 db    0
.rdata$r:0000BC61                 db    0
.rdata$r:0000BC62                 db    0
.rdata$r:0000BC63                 db    0
.rdata$r:0000BC64                 db 0FFh
.rdata$r:0000BC65                 db 0FFh
.rdata$r:0000BC66                 db 0FFh
.rdata$r:0000BC67                 db 0FFh
.rdata$r:0000BC68                 db    0
.rdata$r:0000BC69                 db    0
.rdata$r:0000BC6A                 db    0
.rdata$r:0000BC6B                 db    0
.rdata$r:0000BC6C                 db  40h ; @
.rdata$r:0000BC6D                 db    0
.rdata$r:0000BC6E                 db    0
.rdata$r:0000BC6F                 db    0
.rdata$r:0000BC70                 dd offset ??_R3CBenchProgressInfo@@8 ; CBenchProgressInfo::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000BC70 _rdata$r        ends
.rdata$r:0000BC70
.rdata$r:0000BC74 ; ===========================================================================
.rdata$r:0000BC74
.rdata$r:0000BC74 ; Segment type: Pure data
.rdata$r:0000BC74 ; Segment permissions: Read
.rdata$r:0000BC74 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000BC74                 assume cs:_rdata$r
.rdata$r:0000BC74                 ;org 0BC74h
.rdata$r:0000BC74 ; COMDAT (pick any)
.rdata$r:0000BC74                 public ??_R1A@?0A@EA@ICompressProgressInfo@@8
.rdata$r:0000BC74 ; ICompressProgressInfo::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000BC74 ??_R1A@?0A@EA@ICompressProgressInfo@@8 dd offset ??_R0?AUICompressProgressInfo@@@8
.rdata$r:0000BC74                                         ; DATA XREF: .rdata$r:0000BC44o
.rdata$r:0000BC74                                         ; .rdata$r:ICompressProgressInfo::`RTTI Base Class Array'o
.rdata$r:0000BC74                                         ; ICompressProgressInfo `RTTI Type Descriptor'
.rdata$r:0000BC78                 db    1
.rdata$r:0000BC79                 db    0
.rdata$r:0000BC7A                 db    0
.rdata$r:0000BC7B                 db    0
.rdata$r:0000BC7C                 db    0
.rdata$r:0000BC7D                 db    0
.rdata$r:0000BC7E                 db    0
.rdata$r:0000BC7F                 db    0
.rdata$r:0000BC80                 db 0FFh
.rdata$r:0000BC81                 db 0FFh
.rdata$r:0000BC82                 db 0FFh
.rdata$r:0000BC83                 db 0FFh
.rdata$r:0000BC84                 db    0
.rdata$r:0000BC85                 db    0
.rdata$r:0000BC86                 db    0
.rdata$r:0000BC87                 db    0
.rdata$r:0000BC88                 db  40h ; @
.rdata$r:0000BC89                 db    0
.rdata$r:0000BC8A                 db    0
.rdata$r:0000BC8B                 db    0
.rdata$r:0000BC8C                 dd offset ??_R3ICompressProgressInfo@@8 ; ICompressProgressInfo::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000BC8C _rdata$r        ends
.rdata$r:0000BC8C
.data:0000BC90 ; ===========================================================================
.data:0000BC90
.data:0000BC90 ; Segment type: Pure data
.data:0000BC90 ; Segment permissions: Read/Write
.data:0000BC90 _data           segment dword public 'DATA' use32
.data:0000BC90                 assume cs:_data
.data:0000BC90                 ;org 0BC90h
.data:0000BC90 ; COMDAT (pick any)
.data:0000BC90                 public ??_R0?AUICompressProgressInfo@@@8
.data:0000BC90 ; struct ICompressProgressInfo `RTTI Type Descriptor'
.data:0000BC90 ??_R0?AUICompressProgressInfo@@@8 dd offset ??_7type_info@@6B@
.data:0000BC90                                         ; DATA XREF: .rdata$r:ICompressProgressInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:0000BC90                                         ; .rdata$r:0000BE64o
.data:0000BC90                                         ; const type_info::`vftable'
.data:0000BC94                 align 8
.data:0000BC98 a_?auicompressp db '.?AUICompressProgressInfo@@',0
.data:0000BC98 _data           ends
.data:0000BC98
.rdata$r:0000BCB4 ; ===========================================================================
.rdata$r:0000BCB4
.rdata$r:0000BCB4 ; Segment type: Pure data
.rdata$r:0000BCB4 ; Segment permissions: Read
.rdata$r:0000BCB4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000BCB4                 assume cs:_rdata$r
.rdata$r:0000BCB4                 ;org 0BCB4h
.rdata$r:0000BCB4 ; COMDAT (pick any)
.rdata$r:0000BCB4                 public ??_R3ICompressProgressInfo@@8
.rdata$r:0000BCB4 ; ICompressProgressInfo::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000BCB4 ??_R3ICompressProgressInfo@@8 db    0   ; DATA XREF: .rdata$r:0000BC8Co
.rdata$r:0000BCB4                                         ; .rdata$r:0000BE68o
.rdata$r:0000BCB5                 db    0
.rdata$r:0000BCB6                 db    0
.rdata$r:0000BCB7                 db    0
.rdata$r:0000BCB8                 db    0
.rdata$r:0000BCB9                 db    0
.rdata$r:0000BCBA                 db    0
.rdata$r:0000BCBB                 db    0
.rdata$r:0000BCBC                 db    2
.rdata$r:0000BCBD                 db    0
.rdata$r:0000BCBE                 db    0
.rdata$r:0000BCBF                 db    0
.rdata$r:0000BCC0                 dd offset ??_R2ICompressProgressInfo@@8 ; ICompressProgressInfo::`RTTI Base Class Array'
.rdata$r:0000BCC0 _rdata$r        ends
.rdata$r:0000BCC0
.rdata$r:0000BCC4 ; ===========================================================================
.rdata$r:0000BCC4
.rdata$r:0000BCC4 ; Segment type: Pure data
.rdata$r:0000BCC4 ; Segment permissions: Read
.rdata$r:0000BCC4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000BCC4                 assume cs:_rdata$r
.rdata$r:0000BCC4                 ;org 0BCC4h
.rdata$r:0000BCC4 ; COMDAT (pick any)
.rdata$r:0000BCC4                 public ??_R2ICompressProgressInfo@@8
.rdata$r:0000BCC4 ; ICompressProgressInfo::`RTTI Base Class Array'
.rdata$r:0000BCC4 ??_R2ICompressProgressInfo@@8 dd offset ??_R1A@?0A@EA@ICompressProgressInfo@@8
.rdata$r:0000BCC4                                         ; DATA XREF: .rdata$r:0000BCC0o
.rdata$r:0000BCC4                                         ; ICompressProgressInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000BCC8                 dd offset ??_R1A@?0A@EA@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000BCCC                 db    0
.rdata$r:0000BCCD                 align 10h
.rdata$r:0000BCCD _rdata$r        ends
.rdata$r:0000BCCD
.rdata$r:0000BCD0 ; ===========================================================================
.rdata$r:0000BCD0
.rdata$r:0000BCD0 ; Segment type: Pure data
.rdata$r:0000BCD0 ; Segment permissions: Read
.rdata$r:0000BCD0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000BCD0                 assume cs:_rdata$r
.rdata$r:0000BCD0                 ;org 0BCD0h
.rdata$r:0000BCD0 ; COMDAT (pick any)
.rdata$r:0000BCD0                 public ??_R17?0A@EA@CBenchInfoCalc@@8
.rdata$r:0000BCD0 ; CBenchInfoCalc::`RTTI Base Class Descriptor at (8, -1, 0, 64)'
.rdata$r:0000BCD0 ??_R17?0A@EA@CBenchInfoCalc@@8 dd offset ??_R0?AUCBenchInfoCalc@@@8
.rdata$r:0000BCD0                                         ; DATA XREF: .rdata$r:0000BC50o
.rdata$r:0000BCD0                                         ; CBenchInfoCalc `RTTI Type Descriptor'
.rdata$r:0000BCD4                 align 8
.rdata$r:0000BCD8                 db    8
.rdata$r:0000BCD9                 db    0
.rdata$r:0000BCDA                 db    0
.rdata$r:0000BCDB                 db    0
.rdata$r:0000BCDC                 db 0FFh
.rdata$r:0000BCDD                 db 0FFh
.rdata$r:0000BCDE                 db 0FFh
.rdata$r:0000BCDF                 db 0FFh
.rdata$r:0000BCE0                 db    0
.rdata$r:0000BCE1                 db    0
.rdata$r:0000BCE2                 db    0
.rdata$r:0000BCE3                 db    0
.rdata$r:0000BCE4                 db  40h ; @
.rdata$r:0000BCE5                 db    0
.rdata$r:0000BCE6                 db    0
.rdata$r:0000BCE7                 db    0
.rdata$r:0000BCE8                 dd offset ??_R3CBenchInfoCalc@@8 ; CBenchInfoCalc::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000BCE8 _rdata$r        ends
.rdata$r:0000BCE8
.data:0000BCEC ; ===========================================================================
.data:0000BCEC
.data:0000BCEC ; Segment type: Pure data
.data:0000BCEC ; Segment permissions: Read/Write
.data:0000BCEC _data           segment dword public 'DATA' use32
.data:0000BCEC                 assume cs:_data
.data:0000BCEC                 ;org 0BCECh
.data:0000BCEC ; COMDAT (pick any)
.data:0000BCEC                 public ??_R0?AUCBenchInfoCalc@@@8
.data:0000BCEC ; struct CBenchInfoCalc `RTTI Type Descriptor'
.data:0000BCEC ??_R0?AUCBenchInfoCalc@@@8 dd offset ??_7type_info@@6B@
.data:0000BCEC                                         ; DATA XREF: .rdata$r:CBenchInfoCalc::`RTTI Base Class Descriptor at (8,-1,0,64)'o
.data:0000BCEC                                         ; .rdata$r:CBenchInfoCalc::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:0000BCEC                                         ; const type_info::`vftable'
.data:0000BCF0                 db    0
.data:0000BCF1                 db    0
.data:0000BCF2                 db    0
.data:0000BCF3                 db    0
.data:0000BCF4                 db  2Eh ; .
.data:0000BCF5                 db  3Fh ; ?
.data:0000BCF6                 db  41h ; A
.data:0000BCF7                 db  55h ; U
.data:0000BCF8                 db  43h ; C
.data:0000BCF9                 db  42h ; B
.data:0000BCFA                 db  65h ; e
.data:0000BCFB                 db  6Eh ; n
.data:0000BCFC                 db  63h ; c
.data:0000BCFD                 db  68h ; h
.data:0000BCFE                 db  49h ; I
.data:0000BCFF                 db  6Eh ; n
.data:0000BD00                 db  66h ; f
.data:0000BD01                 db  6Fh ; o
.data:0000BD02                 db  43h ; C
.data:0000BD03                 db  61h ; a
.data:0000BD04                 db  6Ch ; l
.data:0000BD05                 db  63h ; c
.data:0000BD06                 db  40h ; @
.data:0000BD07                 db  40h ; @
.data:0000BD08                 db    0
.data:0000BD09                 align 4
.data:0000BD09 _data           ends
.data:0000BD09
.rdata$r:0000BD0C ; ===========================================================================
.rdata$r:0000BD0C
.rdata$r:0000BD0C ; Segment type: Pure data
.rdata$r:0000BD0C ; Segment permissions: Read
.rdata$r:0000BD0C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000BD0C                 assume cs:_rdata$r
.rdata$r:0000BD0C                 ;org 0BD0Ch
.rdata$r:0000BD0C ; COMDAT (pick any)
.rdata$r:0000BD0C                 public ??_R3CBenchInfoCalc@@8
.rdata$r:0000BD0C ; CBenchInfoCalc::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000BD0C ??_R3CBenchInfoCalc@@8 db    0          ; DATA XREF: .rdata$r:0000BCE8o
.rdata$r:0000BD0C                                         ; .rdata$r:0000BD3Co
.rdata$r:0000BD0D                 db    0
.rdata$r:0000BD0E                 db    0
.rdata$r:0000BD0F                 db    0
.rdata$r:0000BD10                 db    0
.rdata$r:0000BD11                 db    0
.rdata$r:0000BD12                 db    0
.rdata$r:0000BD13                 db    0
.rdata$r:0000BD14                 db    1
.rdata$r:0000BD15                 db    0
.rdata$r:0000BD16                 db    0
.rdata$r:0000BD17                 db    0
.rdata$r:0000BD18                 dd offset ??_R2CBenchInfoCalc@@8 ; CBenchInfoCalc::`RTTI Base Class Array'
.rdata$r:0000BD18 _rdata$r        ends
.rdata$r:0000BD18
.rdata$r:0000BD1C ; ===========================================================================
.rdata$r:0000BD1C
.rdata$r:0000BD1C ; Segment type: Pure data
.rdata$r:0000BD1C ; Segment permissions: Read
.rdata$r:0000BD1C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000BD1C                 assume cs:_rdata$r
.rdata$r:0000BD1C                 ;org 0BD1Ch
.rdata$r:0000BD1C ; COMDAT (pick any)
.rdata$r:0000BD1C                 public ??_R2CBenchInfoCalc@@8
.rdata$r:0000BD1C ; CBenchInfoCalc::`RTTI Base Class Array'
.rdata$r:0000BD1C ??_R2CBenchInfoCalc@@8 dd offset ??_R1A@?0A@EA@CBenchInfoCalc@@8
.rdata$r:0000BD1C                                         ; DATA XREF: .rdata$r:0000BD18o
.rdata$r:0000BD1C                                         ; CBenchInfoCalc::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000BD20                 db    0
.rdata$r:0000BD21                 align 4
.rdata$r:0000BD21 _rdata$r        ends
.rdata$r:0000BD21
.rdata$r:0000BD24 ; ===========================================================================
.rdata$r:0000BD24
.rdata$r:0000BD24 ; Segment type: Pure data
.rdata$r:0000BD24 ; Segment permissions: Read
.rdata$r:0000BD24 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000BD24                 assume cs:_rdata$r
.rdata$r:0000BD24                 ;org 0BD24h
.rdata$r:0000BD24 ; COMDAT (pick any)
.rdata$r:0000BD24                 public ??_R1A@?0A@EA@CBenchInfoCalc@@8
.rdata$r:0000BD24 ; CBenchInfoCalc::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000BD24 ??_R1A@?0A@EA@CBenchInfoCalc@@8 dd offset ??_R0?AUCBenchInfoCalc@@@8
.rdata$r:0000BD24                                         ; DATA XREF: .rdata$r:CBenchInfoCalc::`RTTI Base Class Array'o
.rdata$r:0000BD24                                         ; CBenchInfoCalc `RTTI Type Descriptor'
.rdata$r:0000BD28                 align 10h
.rdata$r:0000BD30                 db 0FFh
.rdata$r:0000BD31                 db 0FFh
.rdata$r:0000BD32                 db 0FFh
.rdata$r:0000BD33                 db 0FFh
.rdata$r:0000BD34                 db    0
.rdata$r:0000BD35                 db    0
.rdata$r:0000BD36                 db    0
.rdata$r:0000BD37                 db    0
.rdata$r:0000BD38                 db  40h ; @
.rdata$r:0000BD39                 db    0
.rdata$r:0000BD3A                 db    0
.rdata$r:0000BD3B                 db    0
.rdata$r:0000BD3C                 dd offset ??_R3CBenchInfoCalc@@8 ; CBenchInfoCalc::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000BD3C _rdata$r        ends
.rdata$r:0000BD3C
.text:0000BD40 ; ===========================================================================
.text:0000BD40
.text:0000BD40 ; Segment type: Pure code
.text:0000BD40 ; Segment permissions: Read/Execute
.text:0000BD40 _text           segment para public 'CODE' use32
.text:0000BD40                 assume cs:_text
.text:0000BD40                 ;org 0BD40h
.text:0000BD40 ; COMDAT (pick any)
.text:0000BD40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BD40
.text:0000BD40 ; =============== S U B R O U T I N E =======================================
.text:0000BD40
.text:0000BD40 ; Attributes: bp-based frame
.text:0000BD40
.text:0000BD40 ; __int32 __stdcall CBenchProgressInfo::QueryInterface(CBenchProgressInfo *this, const struct _GUID *Buf1, void **)
.text:0000BD40                 public ?QueryInterface@CBenchProgressInfo@@UAGJABU_GUID@@PAPAX@Z
.text:0000BD40 ?QueryInterface@CBenchProgressInfo@@UAGJABU_GUID@@PAPAX@Z proc near
.text:0000BD40                                         ; DATA XREF: .rdata:const CBenchProgressInfo::`vftable'o
.text:0000BD40
.text:0000BD40 this            = dword ptr  8
.text:0000BD40 Buf1            = dword ptr  0Ch
.text:0000BD40 arg_8           = dword ptr  10h
.text:0000BD40
.text:0000BD40                 push    ebp
.text:0000BD41                 mov     ebp, esp
.text:0000BD43                 mov     eax, [ebp+arg_8]
.text:0000BD46                 mov     dword ptr [eax], 0
.text:0000BD4C                 push    offset _IID_IUnknown ; Buf2
.text:0000BD51                 mov     ecx, [ebp+Buf1]
.text:0000BD54                 push    ecx             ; Buf1
.text:0000BD55                 call    ___@8           ; __(x,x)
.text:0000BD5A                 test    eax, eax
.text:0000BD5C                 jz      short loc_BD68
.text:0000BD5E                 mov     edx, [ebp+arg_8]
.text:0000BD61                 mov     eax, [ebp+this]
.text:0000BD64                 mov     [edx], eax
.text:0000BD66                 jmp     short loc_BD6F
.text:0000BD68 ; ---------------------------------------------------------------------------
.text:0000BD68
.text:0000BD68 loc_BD68:                               ; CODE XREF: CBenchProgressInfo::QueryInterface(_GUID const &,void * *)+1Cj
.text:0000BD68                 mov     eax, 80004002h
.text:0000BD6D                 jmp     short loc_BD80
.text:0000BD6F ; ---------------------------------------------------------------------------
.text:0000BD6F
.text:0000BD6F loc_BD6F:                               ; CODE XREF: CBenchProgressInfo::QueryInterface(_GUID const &,void * *)+26j
.text:0000BD6F                 mov     ecx, [ebp+this]
.text:0000BD72                 mov     edx, [ecx+4]
.text:0000BD75                 add     edx, 1
.text:0000BD78                 mov     eax, [ebp+this]
.text:0000BD7B                 mov     [eax+4], edx
.text:0000BD7E                 xor     eax, eax
.text:0000BD80
.text:0000BD80 loc_BD80:                               ; CODE XREF: CBenchProgressInfo::QueryInterface(_GUID const &,void * *)+2Dj
.text:0000BD80                 cmp     ebp, esp
.text:0000BD82                 call    __RTC_CheckEsp
.text:0000BD87                 pop     ebp
.text:0000BD88                 retn    0Ch
.text:0000BD88 ?QueryInterface@CBenchProgressInfo@@UAGJABU_GUID@@PAPAX@Z endp
.text:0000BD88
.text:0000BD88 ; ---------------------------------------------------------------------------
.text:0000BD8B                 align 4
.text:0000BD8B _text           ends
.text:0000BD8B
.text:0000BD8C ; ===========================================================================
.text:0000BD8C
.text:0000BD8C ; Segment type: Pure code
.text:0000BD8C ; Segment permissions: Read/Execute
.text:0000BD8C _text           segment para public 'CODE' use32
.text:0000BD8C                 assume cs:_text
.text:0000BD8C                 ;org 0BD8Ch
.text:0000BD8C ; COMDAT (pick any)
.text:0000BD8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BD8C
.text:0000BD8C ; =============== S U B R O U T I N E =======================================
.text:0000BD8C
.text:0000BD8C ; Attributes: bp-based frame
.text:0000BD8C
.text:0000BD8C ; unsigned __int32 __stdcall CBenchProgressInfo::AddRef(CBenchProgressInfo *this)
.text:0000BD8C                 public ?AddRef@CBenchProgressInfo@@UAGKXZ
.text:0000BD8C ?AddRef@CBenchProgressInfo@@UAGKXZ proc near ; DATA XREF: .rdata:0000BBECo
.text:0000BD8C
.text:0000BD8C var_4           = dword ptr -4
.text:0000BD8C this            = dword ptr  8
.text:0000BD8C
.text:0000BD8C                 push    ebp
.text:0000BD8D                 mov     ebp, esp
.text:0000BD8F                 push    ecx
.text:0000BD90                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000BD97                 mov     eax, [ebp+this]
.text:0000BD9A                 mov     ecx, [eax+4]
.text:0000BD9D                 add     ecx, 1
.text:0000BDA0                 mov     [ebp+var_4], ecx
.text:0000BDA3                 mov     edx, [ebp+this]
.text:0000BDA6                 mov     eax, [ebp+var_4]
.text:0000BDA9                 mov     [edx+4], eax
.text:0000BDAC                 mov     eax, [ebp+var_4]
.text:0000BDAF                 mov     esp, ebp
.text:0000BDB1                 pop     ebp
.text:0000BDB2                 retn    4
.text:0000BDB2 ?AddRef@CBenchProgressInfo@@UAGKXZ endp
.text:0000BDB2
.text:0000BDB2 ; ---------------------------------------------------------------------------
.text:0000BDB5                 align 4
.text:0000BDB5 _text           ends
.text:0000BDB5
.text:0000BDB8 ; ===========================================================================
.text:0000BDB8
.text:0000BDB8 ; Segment type: Pure code
.text:0000BDB8 ; Segment permissions: Read/Execute
.text:0000BDB8 _text           segment para public 'CODE' use32
.text:0000BDB8                 assume cs:_text
.text:0000BDB8                 ;org 0BDB8h
.text:0000BDB8 ; COMDAT (pick any)
.text:0000BDB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BDB8
.text:0000BDB8 ; =============== S U B R O U T I N E =======================================
.text:0000BDB8
.text:0000BDB8 ; Attributes: bp-based frame
.text:0000BDB8
.text:0000BDB8 ; unsigned __int32 __stdcall CBenchProgressInfo::Release(CBenchProgressInfo *this)
.text:0000BDB8                 public ?Release@CBenchProgressInfo@@UAGKXZ
.text:0000BDB8 ?Release@CBenchProgressInfo@@UAGKXZ proc near ; DATA XREF: .rdata:0000BBF0o
.text:0000BDB8
.text:0000BDB8 var_8           = dword ptr -8
.text:0000BDB8 var_4           = dword ptr -4
.text:0000BDB8 this            = dword ptr  8
.text:0000BDB8
.text:0000BDB8                 push    ebp
.text:0000BDB9                 mov     ebp, esp
.text:0000BDBB                 sub     esp, 8
.text:0000BDBE                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000BDC5                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000BDCC                 mov     eax, [ebp+this]
.text:0000BDCF                 mov     ecx, [eax+4]
.text:0000BDD2                 sub     ecx, 1
.text:0000BDD5                 mov     [ebp+var_8], ecx
.text:0000BDD8                 mov     edx, [ebp+this]
.text:0000BDDB                 mov     eax, [ebp+var_8]
.text:0000BDDE                 mov     [edx+4], eax
.text:0000BDE1                 cmp     [ebp+var_8], 0
.text:0000BDE5                 jz      short loc_BDEF
.text:0000BDE7                 mov     ecx, [ebp+this]
.text:0000BDEA                 mov     eax, [ecx+4]
.text:0000BDED                 jmp     short loc_BE03
.text:0000BDEF ; ---------------------------------------------------------------------------
.text:0000BDEF
.text:0000BDEF loc_BDEF:                               ; CODE XREF: CBenchProgressInfo::Release(void)+2Dj
.text:0000BDEF                 mov     edx, [ebp+this]
.text:0000BDF2                 mov     [ebp+var_4], edx
.text:0000BDF5                 mov     eax, [ebp+var_4]
.text:0000BDF8                 push    eax             ; void *
.text:0000BDF9                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000BDFE                 add     esp, 4
.text:0000BE01                 xor     eax, eax
.text:0000BE03
.text:0000BE03 loc_BE03:                               ; CODE XREF: CBenchProgressInfo::Release(void)+35j
.text:0000BE03                 add     esp, 8
.text:0000BE06                 cmp     ebp, esp
.text:0000BE08                 call    __RTC_CheckEsp
.text:0000BE0D                 mov     esp, ebp
.text:0000BE0F                 pop     ebp
.text:0000BE10                 retn    4
.text:0000BE10 ?Release@CBenchProgressInfo@@UAGKXZ endp
.text:0000BE10
.text:0000BE10 ; ---------------------------------------------------------------------------
.text:0000BE13                 align 4
.text:0000BE13 _text           ends
.text:0000BE13
.text:0000BE14 ; ===========================================================================
.text:0000BE14
.text:0000BE14 ; Segment type: Pure code
.text:0000BE14 ; Segment permissions: Read/Execute
.text:0000BE14 _text           segment para public 'CODE' use32
.text:0000BE14                 assume cs:_text
.text:0000BE14                 ;org 0BE14h
.text:0000BE14 ; COMDAT (pick any)
.text:0000BE14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BE14
.text:0000BE14 ; =============== S U B R O U T I N E =======================================
.text:0000BE14
.text:0000BE14 ; Attributes: bp-based frame
.text:0000BE14
.text:0000BE14 ; _DWORD __thiscall ICompressProgressInfo::ICompressProgressInfo(ICompressProgressInfo *__hidden this)
.text:0000BE14                 public ??0ICompressProgressInfo@@QAE@XZ
.text:0000BE14 ??0ICompressProgressInfo@@QAE@XZ proc near
.text:0000BE14                                         ; CODE XREF: CBenchProgressInfo::CBenchProgressInfo(void)+11p
.text:0000BE14
.text:0000BE14 var_4           = dword ptr -4
.text:0000BE14
.text:0000BE14                 push    ebp
.text:0000BE15                 mov     ebp, esp
.text:0000BE17                 push    ecx
.text:0000BE18                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000BE1F                 mov     [ebp+var_4], ecx
.text:0000BE22                 mov     ecx, [ebp+var_4]
.text:0000BE25                 call    ??0IUnknown@@QAE@XZ ; IUnknown::IUnknown(void)
.text:0000BE2A                 mov     eax, [ebp+var_4]
.text:0000BE2D                 mov     dword ptr [eax], offset ??_7ICompressProgressInfo@@6B@ ; const ICompressProgressInfo::`vftable'
.text:0000BE33                 mov     eax, [ebp+var_4]
.text:0000BE36                 add     esp, 4
.text:0000BE39                 cmp     ebp, esp
.text:0000BE3B                 call    __RTC_CheckEsp
.text:0000BE40                 mov     esp, ebp
.text:0000BE42                 pop     ebp
.text:0000BE43                 retn
.text:0000BE43 ??0ICompressProgressInfo@@QAE@XZ endp
.text:0000BE43
.text:0000BE43 _text           ends
.text:0000BE43
.rdata:0000BE44 ; ===========================================================================
.rdata:0000BE44
.rdata:0000BE44 ; Segment type: Pure data
.rdata:0000BE44 ; Segment permissions: Read
.rdata:0000BE44 _rdata          segment dword public 'DATA' use32
.rdata:0000BE44                 assume cs:_rdata
.rdata:0000BE44                 ;org 0BE44h
.rdata:0000BE44 ; COMDAT (pick largest)
.rdata:0000BE44                 dd offset ??_R4ICompressProgressInfo@@6B@ ; const ICompressProgressInfo::`RTTI Complete Object Locator'
.rdata:0000BE48                 public ??_7ICompressProgressInfo@@6B@
.rdata:0000BE48 ; const ICompressProgressInfo::`vftable'
.rdata:0000BE48 ??_7ICompressProgressInfo@@6B@ dd offset __purecall
.rdata:0000BE48                                         ; DATA XREF: ICompressProgressInfo::ICompressProgressInfo(void)+19o
.rdata:0000BE4C                 dd offset __purecall
.rdata:0000BE50                 dd offset __purecall
.rdata:0000BE54                 dd offset __purecall
.rdata:0000BE54 _rdata          ends
.rdata:0000BE54
.rdata$r:0000BE58 ; ===========================================================================
.rdata$r:0000BE58
.rdata$r:0000BE58 ; Segment type: Pure data
.rdata$r:0000BE58 ; Segment permissions: Read
.rdata$r:0000BE58 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000BE58                 assume cs:_rdata$r
.rdata$r:0000BE58                 ;org 0BE58h
.rdata$r:0000BE58 ; COMDAT (pick any)
.rdata$r:0000BE58                 public ??_R4ICompressProgressInfo@@6B@
.rdata$r:0000BE58 ; const ICompressProgressInfo::`RTTI Complete Object Locator'
.rdata$r:0000BE58 ??_R4ICompressProgressInfo@@6B@ db    0 ; DATA XREF: .rdata:0000BE44o
.rdata$r:0000BE59                 db    0
.rdata$r:0000BE5A                 db    0
.rdata$r:0000BE5B                 db    0
.rdata$r:0000BE5C                 db    0
.rdata$r:0000BE5D                 db    0
.rdata$r:0000BE5E                 db    0
.rdata$r:0000BE5F                 db    0
.rdata$r:0000BE60                 db    0
.rdata$r:0000BE61                 db    0
.rdata$r:0000BE62                 db    0
.rdata$r:0000BE63                 db    0
.rdata$r:0000BE64                 dd offset ??_R0?AUICompressProgressInfo@@@8 ; ICompressProgressInfo `RTTI Type Descriptor'
.rdata$r:0000BE68                 dd offset ??_R3ICompressProgressInfo@@8 ; ICompressProgressInfo::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000BE68 _rdata$r        ends
.rdata$r:0000BE68
.text:0000BE6C ; ===========================================================================
.text:0000BE6C
.text:0000BE6C ; Segment type: Pure code
.text:0000BE6C ; Segment permissions: Read/Execute
.text:0000BE6C _text           segment para public 'CODE' use32
.text:0000BE6C                 assume cs:_text
.text:0000BE6C                 ;org 0BE6Ch
.text:0000BE6C ; COMDAT (pick any)
.text:0000BE6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BE6C
.text:0000BE6C ; =============== S U B R O U T I N E =======================================
.text:0000BE6C
.text:0000BE6C ; Attributes: bp-based frame
.text:0000BE6C
.text:0000BE6C ; _DWORD __thiscall CBenchInfoCalc::CBenchInfoCalc(CBenchInfoCalc *__hidden this)
.text:0000BE6C                 public ??0CBenchInfoCalc@@QAE@XZ
.text:0000BE6C ??0CBenchInfoCalc@@QAE@XZ proc near     ; CODE XREF: FreqBench(unsigned __int64,uint,IBenchPrintCallback *,bool,unsigned __int64 &,uint &)+D5p
.text:0000BE6C                                         ; CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+1B1p ...
.text:0000BE6C
.text:0000BE6C var_4           = dword ptr -4
.text:0000BE6C
.text:0000BE6C                 push    ebp
.text:0000BE6D                 mov     ebp, esp
.text:0000BE6F                 push    ecx
.text:0000BE70                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000BE77                 mov     [ebp+var_4], ecx
.text:0000BE7A                 mov     ecx, [ebp+var_4] ; this
.text:0000BE7D                 call    ??0CBenchInfo@@QAE@XZ ; CBenchInfo::CBenchInfo(void)
.text:0000BE82                 mov     eax, [ebp+var_4]
.text:0000BE85                 add     esp, 4
.text:0000BE88                 cmp     ebp, esp
.text:0000BE8A                 call    __RTC_CheckEsp
.text:0000BE8F                 mov     esp, ebp
.text:0000BE91                 pop     ebp
.text:0000BE92                 retn
.text:0000BE92 ??0CBenchInfoCalc@@QAE@XZ endp
.text:0000BE92
.text:0000BE92 ; ---------------------------------------------------------------------------
.text:0000BE93                 align 4
.text:0000BE93 _text           ends
.text:0000BE93
.text:0000BE94 ; ===========================================================================
.text:0000BE94
.text:0000BE94 ; Segment type: Pure code
.text:0000BE94 ; Segment permissions: Read/Execute
.text:0000BE94 _text           segment para public 'CODE' use32
.text:0000BE94                 assume cs:_text
.text:0000BE94                 ;org 0BE94h
.text:0000BE94 ; COMDAT (pick any)
.text:0000BE94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BE94
.text:0000BE94 ; =============== S U B R O U T I N E =======================================
.text:0000BE94
.text:0000BE94 ; Attributes: bp-based frame
.text:0000BE94
.text:0000BE94 ; unsigned __int64 __thiscall CBenchProps::GeComprCommands(CBenchProps *this, unsigned __int64)
.text:0000BE94                 public ?GeComprCommands@CBenchProps@@QAE_K_K@Z
.text:0000BE94 ?GeComprCommands@CBenchProps@@QAE_K_K@Z proc near
.text:0000BE94                                         ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+5A4p
.text:0000BE94
.text:0000BE94 var_4           = dword ptr -4
.text:0000BE94 arg_0           = qword ptr  8
.text:0000BE94
.text:0000BE94                 push    ebp
.text:0000BE95                 mov     ebp, esp
.text:0000BE97                 push    ecx
.text:0000BE98                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000BE9F                 mov     [ebp+var_4], ecx
.text:0000BEA2                 mov     eax, [ebp+var_4]
.text:0000BEA5                 mov     ecx, [eax+4]
.text:0000BEA8                 xor     edx, edx
.text:0000BEAA                 push    edx
.text:0000BEAB                 push    ecx
.text:0000BEAC                 mov     eax, dword ptr [ebp+arg_0+4]
.text:0000BEAF                 push    eax
.text:0000BEB0                 mov     ecx, dword ptr [ebp+arg_0]
.text:0000BEB3                 push    ecx
.text:0000BEB4                 call    __allmul
.text:0000BEB9                 add     esp, 4
.text:0000BEBC                 cmp     ebp, esp
.text:0000BEBE                 call    __RTC_CheckEsp
.text:0000BEC3                 mov     esp, ebp
.text:0000BEC5                 pop     ebp
.text:0000BEC6                 retn    8
.text:0000BEC6 ?GeComprCommands@CBenchProps@@QAE_K_K@Z endp
.text:0000BEC6
.text:0000BEC6 ; ---------------------------------------------------------------------------
.text:0000BEC9                 align 4
.text:0000BEC9 _text           ends
.text:0000BEC9
.text:0000BECC ; ===========================================================================
.text:0000BECC
.text:0000BECC ; Segment type: Pure code
.text:0000BECC ; Segment permissions: Read/Execute
.text:0000BECC _text           segment para public 'CODE' use32
.text:0000BECC                 assume cs:_text
.text:0000BECC                 ;org 0BECCh
.text:0000BECC ; COMDAT (pick any)
.text:0000BECC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BECC
.text:0000BECC ; =============== S U B R O U T I N E =======================================
.text:0000BECC
.text:0000BECC ; Attributes: bp-based frame
.text:0000BECC
.text:0000BECC ; unsigned __int64 __thiscall CBenchProps::GeDecomprCommands(CBenchProps *this, unsigned __int64, unsigned __int64)
.text:0000BECC                 public ?GeDecomprCommands@CBenchProps@@QAE_K_K0@Z
.text:0000BECC ?GeDecomprCommands@CBenchProps@@QAE_K_K0@Z proc near
.text:0000BECC                                         ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+9EDp
.text:0000BECC
.text:0000BECC var_4           = dword ptr -4
.text:0000BECC arg_0           = qword ptr  8
.text:0000BECC arg_8           = qword ptr  10h
.text:0000BECC
.text:0000BECC                 push    ebp
.text:0000BECD                 mov     ebp, esp
.text:0000BECF                 push    ecx
.text:0000BED0                 push    esi
.text:0000BED1                 push    edi
.text:0000BED2                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000BED9                 mov     [ebp+var_4], ecx
.text:0000BEDC                 mov     eax, [ebp+var_4]
.text:0000BEDF                 mov     ecx, [eax+8]
.text:0000BEE2                 xor     edx, edx
.text:0000BEE4                 push    edx
.text:0000BEE5                 push    ecx
.text:0000BEE6                 mov     eax, dword ptr [ebp+arg_0+4]
.text:0000BEE9                 push    eax
.text:0000BEEA                 mov     ecx, dword ptr [ebp+arg_0]
.text:0000BEED                 push    ecx
.text:0000BEEE                 call    __allmul
.text:0000BEF3                 mov     esi, eax
.text:0000BEF5                 mov     edi, edx
.text:0000BEF7                 mov     edx, [ebp+var_4]
.text:0000BEFA                 mov     eax, [edx+0Ch]
.text:0000BEFD                 xor     ecx, ecx
.text:0000BEFF                 push    ecx
.text:0000BF00                 push    eax
.text:0000BF01                 mov     edx, dword ptr [ebp+arg_8+4]
.text:0000BF04                 push    edx
.text:0000BF05                 mov     eax, dword ptr [ebp+arg_8]
.text:0000BF08                 push    eax
.text:0000BF09                 call    __allmul
.text:0000BF0E                 add     esi, eax
.text:0000BF10                 adc     edi, edx
.text:0000BF12                 mov     eax, esi
.text:0000BF14                 mov     edx, edi
.text:0000BF16                 pop     edi
.text:0000BF17                 pop     esi
.text:0000BF18                 add     esp, 4
.text:0000BF1B                 cmp     ebp, esp
.text:0000BF1D                 call    __RTC_CheckEsp
.text:0000BF22                 mov     esp, ebp
.text:0000BF24                 pop     ebp
.text:0000BF25                 retn    10h
.text:0000BF25 ?GeDecomprCommands@CBenchProps@@QAE_K_K0@Z endp
.text:0000BF25
.text:0000BF25 _text           ends
.text:0000BF25
.text:0000BF28 ; ===========================================================================
.text:0000BF28
.text:0000BF28 ; Segment type: Pure code
.text:0000BF28 ; Segment permissions: Read/Execute
.text:0000BF28 _text           segment para public 'CODE' use32
.text:0000BF28                 assume cs:_text
.text:0000BF28                 ;org 0BF28h
.text:0000BF28 ; COMDAT (pick any)
.text:0000BF28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BF28
.text:0000BF28 ; =============== S U B R O U T I N E =======================================
.text:0000BF28
.text:0000BF28 ; Attributes: bp-based frame
.text:0000BF28
.text:0000BF28 ; __int32 __thiscall CEncoderInfo::CreateEncoderThread(CEncoderInfo *__hidden this)
.text:0000BF28                 public ?CreateEncoderThread@CEncoderInfo@@QAEJXZ
.text:0000BF28 ?CreateEncoderThread@CEncoderInfo@@QAEJXZ proc near
.text:0000BF28                                         ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+6E4p
.text:0000BF28
.text:0000BF28 var_4           = dword ptr -4
.text:0000BF28
.text:0000BF28                 push    ebp
.text:0000BF29                 mov     ebp, esp
.text:0000BF2B                 push    ecx
.text:0000BF2C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000BF33                 mov     [ebp+var_4], ecx
.text:0000BF36                 mov     eax, [ebp+var_4]
.text:0000BF39                 push    eax             ; void *
.text:0000BF3A                 push    offset ?EncodeThreadFunction@CEncoderInfo@@SGIPAX@Z ; unsigned int (__stdcall *)(void *)
.text:0000BF3F                 mov     ecx, [ebp+var_4] ; this
.text:0000BF42                 call    ?Create@CThread@NWindows@@QAEIP6GIPAX@Z0@Z ; NWindows::CThread::Create(uint (*)(void *),void *)
.text:0000BF47                 add     esp, 4
.text:0000BF4A                 cmp     ebp, esp
.text:0000BF4C                 call    __RTC_CheckEsp
.text:0000BF51                 mov     esp, ebp
.text:0000BF53                 pop     ebp
.text:0000BF54                 retn
.text:0000BF54 ?CreateEncoderThread@CEncoderInfo@@QAEJXZ endp
.text:0000BF54
.text:0000BF54 ; ---------------------------------------------------------------------------
.text:0000BF55                 align 4
.text:0000BF55 _text           ends
.text:0000BF55
.text:0000BF58 ; ===========================================================================
.text:0000BF58
.text:0000BF58 ; Segment type: Pure code
.text:0000BF58 ; Segment permissions: Read/Execute
.text:0000BF58 _text           segment para public 'CODE' use32
.text:0000BF58                 assume cs:_text
.text:0000BF58                 ;org 0BF58h
.text:0000BF58 ; COMDAT (pick any)
.text:0000BF58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BF58
.text:0000BF58 ; =============== S U B R O U T I N E =======================================
.text:0000BF58
.text:0000BF58 ; Attributes: bp-based frame
.text:0000BF58
.text:0000BF58 ; unsigned int __thiscall NWindows::CThread::Create(NWindows::CThread *this, unsigned int (__stdcall *)(void *), void *)
.text:0000BF58                 public ?Create@CThread@NWindows@@QAEIP6GIPAX@Z0@Z
.text:0000BF58 ?Create@CThread@NWindows@@QAEIP6GIPAX@Z0@Z proc near
.text:0000BF58                                         ; CODE XREF: FreqBench(unsigned __int64,uint,IBenchPrintCallback *,bool,unsigned __int64 &,uint &)+234p
.text:0000BF58                                         ; CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+5D5p ...
.text:0000BF58
.text:0000BF58 var_4           = dword ptr -4
.text:0000BF58 arg_0           = dword ptr  8
.text:0000BF58 arg_4           = dword ptr  0Ch
.text:0000BF58
.text:0000BF58                 push    ebp
.text:0000BF59                 mov     ebp, esp
.text:0000BF5B                 push    ecx
.text:0000BF5C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000BF63                 mov     [ebp+var_4], ecx
.text:0000BF66                 mov     eax, [ebp+arg_4]
.text:0000BF69                 push    eax
.text:0000BF6A                 mov     ecx, [ebp+arg_0]
.text:0000BF6D                 push    ecx
.text:0000BF6E                 mov     edx, [ebp+var_4]
.text:0000BF71                 push    edx
.text:0000BF72                 call    _Thread_Create@12 ; Thread_Create(x,x,x)
.text:0000BF77                 add     esp, 4
.text:0000BF7A                 cmp     ebp, esp
.text:0000BF7C                 call    __RTC_CheckEsp
.text:0000BF81                 mov     esp, ebp
.text:0000BF83                 pop     ebp
.text:0000BF84                 retn    8
.text:0000BF84 ?Create@CThread@NWindows@@QAEIP6GIPAX@Z0@Z endp
.text:0000BF84
.text:0000BF84 ; ---------------------------------------------------------------------------
.text:0000BF87                 align 4
.text:0000BF87 _text           ends
.text:0000BF87
.text:0000BF88 ; ===========================================================================
.text:0000BF88
.text:0000BF88 ; Segment type: Pure code
.text:0000BF88 ; Segment permissions: Read/Execute
.text:0000BF88 _text           segment para public 'CODE' use32
.text:0000BF88                 assume cs:_text
.text:0000BF88                 ;org 0BF88h
.text:0000BF88 ; COMDAT (pick any)
.text:0000BF88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BF88
.text:0000BF88 ; =============== S U B R O U T I N E =======================================
.text:0000BF88
.text:0000BF88 ; Attributes: bp-based frame
.text:0000BF88
.text:0000BF88 ; unsigned int __stdcall CEncoderInfo::EncodeThreadFunction(void *)
.text:0000BF88                 public ?EncodeThreadFunction@CEncoderInfo@@SGIPAX@Z
.text:0000BF88 ?EncodeThreadFunction@CEncoderInfo@@SGIPAX@Z proc near
.text:0000BF88                                         ; DATA XREF: CEncoderInfo::CreateEncoderThread(void)+12o
.text:0000BF88
.text:0000BF88 var_20          = dword ptr -20h
.text:0000BF88 var_1C          = dword ptr -1Ch
.text:0000BF88 var_18          = dword ptr -18h
.text:0000BF88 var_14          = dword ptr -14h
.text:0000BF88 var_10          = dword ptr -10h
.text:0000BF88 var_C           = dword ptr -0Ch
.text:0000BF88 var_4           = dword ptr -4
.text:0000BF88 arg_0           = dword ptr  8
.text:0000BF88
.text:0000BF88 ; FUNCTION CHUNK AT .text:0000C016 SIZE 00000042 BYTES
.text:0000BF88
.text:0000BF88                 push    ebp
.text:0000BF89                 mov     ebp, esp
.text:0000BF8B                 push    0FFFFFFFFh
.text:0000BF8D                 push    offset __ehhandler$?EncodeThreadFunction@CEncoderInfo@@SGIPAX@Z
.text:0000BF92                 mov     eax, large fs:0
.text:0000BF98                 push    eax
.text:0000BF99                 push    ecx
.text:0000BF9A                 sub     esp, 10h
.text:0000BF9D                 push    ebx
.text:0000BF9E                 push    esi
.text:0000BF9F                 push    edi
.text:0000BFA0                 mov     eax, 0CCCCCCCCh
.text:0000BFA5                 mov     [ebp+var_20], eax
.text:0000BFA8                 mov     [ebp+var_1C], eax
.text:0000BFAB                 mov     [ebp+var_18], eax
.text:0000BFAE                 mov     [ebp+var_14], eax
.text:0000BFB1                 mov     eax, dword ptr ds:___security_cookie
.text:0000BFB6                 xor     eax, ebp
.text:0000BFB8                 mov     [ebp+var_14], eax
.text:0000BFBB                 push    eax
.text:0000BFBC                 lea     eax, [ebp+var_C]
.text:0000BFBF                 mov     large fs:0, eax
.text:0000BFC5                 mov     [ebp+var_10], esp
.text:0000BFC8                 mov     eax, [ebp+arg_0]
.text:0000BFCB                 mov     [ebp+var_1C], eax
.text:0000BFCE                 mov     [ebp+var_4], 0
.text:0000BFD5                 mov     ecx, [ebp+var_1C]
.text:0000BFD8                 mov     eax, [ecx+30h]
.text:0000BFDB                 call    __alloca_probe_16
.text:0000BFE0                 mov     [ebp+var_10], esp
.text:0000BFE3                 mov     ecx, [ebp+var_1C] ; this
.text:0000BFE6                 call    ?Encode@CEncoderInfo@@QAEJXZ ; CEncoderInfo::Encode(void)
.text:0000BFEB                 mov     [ebp+var_20], eax
.text:0000BFEE                 mov     edx, [ebp+var_20]
.text:0000BFF1                 mov     [ebp+var_18], edx
.text:0000BFF4                 mov     eax, [ebp+var_1C]
.text:0000BFF7                 mov     ecx, [ebp+var_18]
.text:0000BFFA                 mov     [eax+0A4h], ecx
.text:0000C000                 jmp     short loc_C016
.text:0000C000 ?EncodeThreadFunction@CEncoderInfo@@SGIPAX@Z endp
.text:0000C000
.text:0000C002
.text:0000C002 ; =============== S U B R O U T I N E =======================================
.text:0000C002
.text:0000C002
.text:0000C002 __catch$?EncodeThreadFunction@CEncoderInfo@@SGIPAX@Z$0 proc near
.text:0000C002                                         ; DATA XREF: .xdata$x:0000C08Co
.text:0000C002                 mov     dword ptr [ebp-18h], 80004005h
.text:0000C009                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text:0000C010                 mov     eax, offset __tryend$?EncodeThreadFunction@CEncoderInfo@@SGIPAX@Z$1
.text:0000C015                 retn
.text:0000C015 __catch$?EncodeThreadFunction@CEncoderInfo@@SGIPAX@Z$0 endp
.text:0000C015
.text:0000C016 ; ---------------------------------------------------------------------------
.text:0000C016 ; START OF FUNCTION CHUNK FOR ?EncodeThreadFunction@CEncoderInfo@@SGIPAX@Z
.text:0000C016
.text:0000C016 loc_C016:                               ; CODE XREF: CEncoderInfo::EncodeThreadFunction(void *)+78j
.text:0000C016                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000C01D
.text:0000C01D __tryend$?EncodeThreadFunction@CEncoderInfo@@SGIPAX@Z$1:
.text:0000C01D                                         ; DATA XREF: __catch$?EncodeThreadFunction@CEncoderInfo@@SGIPAX@Z$0+Eo
.text:0000C01D                 cmp     [ebp+var_18], 0
.text:0000C021                 jz      short loc_C035
.text:0000C023                 mov     edx, [ebp+var_18]
.text:0000C026                 push    edx             ; __int32
.text:0000C027                 mov     eax, [ebp+var_1C]
.text:0000C02A                 mov     ecx, [eax+14h]
.text:0000C02D                 mov     ecx, [ecx+48h]  ; this
.text:0000C030                 call    ?SetResult@CBenchProgressStatus@@QAEXJ@Z ; CBenchProgressStatus::SetResult(long)
.text:0000C035
.text:0000C035 loc_C035:                               ; CODE XREF: CEncoderInfo::EncodeThreadFunction(void *)+99j
.text:0000C035                 xor     eax, eax
.text:0000C037                 lea     esp, [ebp-30h]
.text:0000C03A                 mov     ecx, [ebp+var_C]
.text:0000C03D                 mov     large fs:0, ecx
.text:0000C044                 pop     ecx
.text:0000C045                 pop     edi
.text:0000C046                 pop     esi
.text:0000C047                 pop     ebx
.text:0000C048                 mov     ecx, [ebp+var_14]
.text:0000C04B                 xor     ecx, ebp
.text:0000C04D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text:0000C052                 mov     esp, ebp
.text:0000C054                 pop     ebp
.text:0000C055                 retn    4
.text:0000C055 ; END OF FUNCTION CHUNK FOR ?EncodeThreadFunction@CEncoderInfo@@SGIPAX@Z
.text:0000C055 _text           ends
.text:0000C055
.text$x:0000C058 ; ===========================================================================
.text$x:0000C058
.text$x:0000C058 ; Segment type: Pure code
.text$x:0000C058 ; Segment permissions: Read/Execute
.text$x:0000C058 _text$x         segment para public 'CODE' use32
.text$x:0000C058                 assume cs:_text$x
.text$x:0000C058                 ;org 0C058h
.text$x:0000C058 ; COMDAT (pick associative to section at BF88)
.text$x:0000C058                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000C058
.text$x:0000C058 ; =============== S U B R O U T I N E =======================================
.text$x:0000C058
.text$x:0000C058
.text$x:0000C058 __ehhandler$?EncodeThreadFunction@CEncoderInfo@@SGIPAX@Z proc near
.text$x:0000C058                                         ; DATA XREF: CEncoderInfo::EncodeThreadFunction(void *)+5o
.text$x:0000C058
.text$x:0000C058 arg_4           = dword ptr  8
.text$x:0000C058
.text$x:0000C058                 mov     edx, [esp+arg_4]
.text$x:0000C05C                 lea     eax, [edx+0Ch]
.text$x:0000C05F                 mov     ecx, [edx-24h]
.text$x:0000C062                 xor     ecx, eax
.text$x:0000C064                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000C069                 mov     ecx, [edx-8]
.text$x:0000C06C                 xor     ecx, eax
.text$x:0000C06E                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000C073                 mov     eax, offset __ehfuncinfo$?EncodeThreadFunction@CEncoderInfo@@SGIPAX@Z
.text$x:0000C078                 jmp     ___CxxFrameHandler3
.text$x:0000C078 __ehhandler$?EncodeThreadFunction@CEncoderInfo@@SGIPAX@Z endp
.text$x:0000C078
.text$x:0000C078 ; ---------------------------------------------------------------------------
.text$x:0000C07D                 align 10h
.text$x:0000C07D _text$x         ends
.text$x:0000C07D
.xdata$x:0000C080 ; ===========================================================================
.xdata$x:0000C080
.xdata$x:0000C080 ; Segment type: Pure data
.xdata$x:0000C080 ; Segment permissions: Read
.xdata$x:0000C080 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C080                 assume cs:_xdata$x
.xdata$x:0000C080                 ;org 0C080h
.xdata$x:0000C080 ; COMDAT (pick associative to section at BF88)
.xdata$x:0000C080 __catchsym$?EncodeThreadFunction@CEncoderInfo@@SGIPAX@Z$2 dd offset $SG70853+8
.xdata$x:0000C080                                         ; DATA XREF: .xdata$x:0000C0B0o
.xdata$x:0000C080                                         ; "x7"
.xdata$x:0000C084                 db    0
.xdata$x:0000C085                 db    0
.xdata$x:0000C086                 db    0
.xdata$x:0000C087                 db    0
.xdata$x:0000C088                 db    0
.xdata$x:0000C089                 db    0
.xdata$x:0000C08A                 db    0
.xdata$x:0000C08B                 db    0
.xdata$x:0000C08C                 dd offset __catch$?EncodeThreadFunction@CEncoderInfo@@SGIPAX@Z$0
.xdata$x:0000C090 __unwindtable$?EncodeThreadFunction@CEncoderInfo@@SGIPAX@Z db 0FFh
.xdata$x:0000C090                                         ; DATA XREF: .xdata$x:0000C0BCo
.xdata$x:0000C091                 db 0FFh
.xdata$x:0000C092                 db 0FFh
.xdata$x:0000C093                 db 0FFh
.xdata$x:0000C094                 db    0
.xdata$x:0000C095                 db    0
.xdata$x:0000C096                 db    0
.xdata$x:0000C097                 db    0
.xdata$x:0000C098                 db 0FFh
.xdata$x:0000C099                 db 0FFh
.xdata$x:0000C09A                 db 0FFh
.xdata$x:0000C09B                 db 0FFh
.xdata$x:0000C09C                 db    0
.xdata$x:0000C09D                 db    0
.xdata$x:0000C09E                 db    0
.xdata$x:0000C09F                 db    0
.xdata$x:0000C0A0 __tryblocktable$?EncodeThreadFunction@CEncoderInfo@@SGIPAX@Z db    0
.xdata$x:0000C0A0                                         ; DATA XREF: .xdata$x:0000C0C4o
.xdata$x:0000C0A1                 db    0
.xdata$x:0000C0A2                 db    0
.xdata$x:0000C0A3                 db    0
.xdata$x:0000C0A4                 db    0
.xdata$x:0000C0A5                 db    0
.xdata$x:0000C0A6                 db    0
.xdata$x:0000C0A7                 db    0
.xdata$x:0000C0A8                 db    1
.xdata$x:0000C0A9                 db    0
.xdata$x:0000C0AA                 db    0
.xdata$x:0000C0AB                 db    0
.xdata$x:0000C0AC                 db    1
.xdata$x:0000C0AD                 db    0
.xdata$x:0000C0AE                 db    0
.xdata$x:0000C0AF                 db    0
.xdata$x:0000C0B0                 dd offset __catchsym$?EncodeThreadFunction@CEncoderInfo@@SGIPAX@Z$2
.xdata$x:0000C0B4 __ehfuncinfo$?EncodeThreadFunction@CEncoderInfo@@SGIPAX@Z db  22h ; "
.xdata$x:0000C0B4                                         ; DATA XREF: __ehhandler$?EncodeThreadFunction@CEncoderInfo@@SGIPAX@Z+1Bo
.xdata$x:0000C0B5                 db    5
.xdata$x:0000C0B6                 db  93h ; ô
.xdata$x:0000C0B7                 db  19h
.xdata$x:0000C0B8                 db    2
.xdata$x:0000C0B9                 db    0
.xdata$x:0000C0BA                 db    0
.xdata$x:0000C0BB                 db    0
.xdata$x:0000C0BC                 dd offset __unwindtable$?EncodeThreadFunction@CEncoderInfo@@SGIPAX@Z
.xdata$x:0000C0C0                 db    1
.xdata$x:0000C0C1                 db    0
.xdata$x:0000C0C2                 db    0
.xdata$x:0000C0C3                 db    0
.xdata$x:0000C0C4                 dd offset __tryblocktable$?EncodeThreadFunction@CEncoderInfo@@SGIPAX@Z
.xdata$x:0000C0C8                 db    0
.xdata$x:0000C0C9                 db    0
.xdata$x:0000C0CA                 db    0
.xdata$x:0000C0CB                 db    0
.xdata$x:0000C0CC                 db    0
.xdata$x:0000C0CD                 db    0
.xdata$x:0000C0CE                 db    0
.xdata$x:0000C0CF                 db    0
.xdata$x:0000C0D0                 db    0
.xdata$x:0000C0D1                 db    0
.xdata$x:0000C0D2                 db    0
.xdata$x:0000C0D3                 db    0
.xdata$x:0000C0D4                 db    1
.xdata$x:0000C0D5                 db    0
.xdata$x:0000C0D6                 db    0
.xdata$x:0000C0D7                 db    0
.xdata$x:0000C0D7 _xdata$x        ends
.xdata$x:0000C0D7
.text:0000C0D8 ; ===========================================================================
.text:0000C0D8
.text:0000C0D8 ; Segment type: Pure code
.text:0000C0D8 ; Segment permissions: Read/Execute
.text:0000C0D8 _text           segment para public 'CODE' use32
.text:0000C0D8                 assume cs:_text
.text:0000C0D8                 ;org 0C0D8h
.text:0000C0D8 ; COMDAT (pick any)
.text:0000C0D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000C0D8
.text:0000C0D8 ; =============== S U B R O U T I N E =======================================
.text:0000C0D8
.text:0000C0D8 ; Attributes: bp-based frame
.text:0000C0D8
.text:0000C0D8 ; __int32 __thiscall CEncoderInfo::CreateDecoderThread(CEncoderInfo *this, unsigned int, bool, unsigned int)
.text:0000C0D8                 public ?CreateDecoderThread@CEncoderInfo@@QAEJI_NI@Z
.text:0000C0D8 ?CreateDecoderThread@CEncoderInfo@@QAEJI_NI@Z proc near
.text:0000C0D8                                         ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+B1Cp
.text:0000C0D8
.text:0000C0D8 var_8           = dword ptr -8
.text:0000C0D8 var_4           = dword ptr -4
.text:0000C0D8 arg_0           = dword ptr  8
.text:0000C0D8 arg_4           = byte ptr  0Ch
.text:0000C0D8 arg_8           = dword ptr  10h
.text:0000C0D8
.text:0000C0D8                 push    ebp
.text:0000C0D9                 mov     ebp, esp
.text:0000C0DB                 sub     esp, 8
.text:0000C0DE                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000C0E5                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000C0EC                 mov     [ebp+var_4], ecx
.text:0000C0EF                 mov     eax, [ebp+arg_0]
.text:0000C0F2                 shl     eax, 4
.text:0000C0F5                 mov     ecx, [ebp+var_4]
.text:0000C0F8                 lea     edx, [ecx+eax+78h]
.text:0000C0FC                 mov     [ebp+var_8], edx
.text:0000C0FF                 mov     eax, [ebp+var_8]
.text:0000C102                 mov     ecx, [ebp+arg_0]
.text:0000C105                 mov     [eax+4], ecx
.text:0000C108                 mov     edx, [ebp+var_8]
.text:0000C10B                 mov     eax, [ebp+var_4]
.text:0000C10E                 mov     [edx], eax
.text:0000C110                 mov     ecx, [ebp+var_8]
.text:0000C113                 mov     edx, [ebp+arg_8]
.text:0000C116                 mov     [ecx+0Ch], edx
.text:0000C119                 mov     eax, [ebp+var_8]
.text:0000C11C                 mov     cl, [ebp+arg_4]
.text:0000C11F                 mov     [eax+8], cl
.text:0000C122                 mov     edx, [ebp+var_8]
.text:0000C125                 push    edx             ; void *
.text:0000C126                 push    offset ?DecodeThreadFunction@CEncoderInfo@@SGIPAX@Z ; unsigned int (__stdcall *)(void *)
.text:0000C12B                 mov     eax, [ebp+arg_0]
.text:0000C12E                 mov     ecx, [ebp+var_4]
.text:0000C131                 lea     ecx, [ecx+eax*4] ; this
.text:0000C134                 call    ?Create@CThread@NWindows@@QAEIP6GIPAX@Z0@Z ; NWindows::CThread::Create(uint (*)(void *),void *)
.text:0000C139                 add     esp, 8
.text:0000C13C                 cmp     ebp, esp
.text:0000C13E                 call    __RTC_CheckEsp
.text:0000C143                 mov     esp, ebp
.text:0000C145                 pop     ebp
.text:0000C146                 retn    0Ch
.text:0000C146 ?CreateDecoderThread@CEncoderInfo@@QAEJI_NI@Z endp
.text:0000C146
.text:0000C146 ; ---------------------------------------------------------------------------
.text:0000C149                 align 4
.text:0000C149 _text           ends
.text:0000C149
.text:0000C14C ; ===========================================================================
.text:0000C14C
.text:0000C14C ; Segment type: Pure code
.text:0000C14C ; Segment permissions: Read/Execute
.text:0000C14C _text           segment para public 'CODE' use32
.text:0000C14C                 assume cs:_text
.text:0000C14C                 ;org 0C14Ch
.text:0000C14C ; COMDAT (pick any)
.text:0000C14C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000C14C
.text:0000C14C ; =============== S U B R O U T I N E =======================================
.text:0000C14C
.text:0000C14C ; Attributes: bp-based frame
.text:0000C14C
.text:0000C14C ; unsigned int __stdcall CEncoderInfo::DecodeThreadFunction(void *)
.text:0000C14C                 public ?DecodeThreadFunction@CEncoderInfo@@SGIPAX@Z
.text:0000C14C ?DecodeThreadFunction@CEncoderInfo@@SGIPAX@Z proc near
.text:0000C14C                                         ; DATA XREF: CEncoderInfo::CreateDecoderThread(uint,bool,uint)+4Eo
.text:0000C14C
.text:0000C14C var_C           = dword ptr -0Ch
.text:0000C14C var_8           = dword ptr -8
.text:0000C14C var_4           = dword ptr -4
.text:0000C14C arg_0           = dword ptr  8
.text:0000C14C
.text:0000C14C                 push    ebp
.text:0000C14D                 mov     ebp, esp
.text:0000C14F                 sub     esp, 0Ch
.text:0000C152                 mov     [ebp+var_C], 0CCCCCCCCh
.text:0000C159                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000C160                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000C167                 mov     eax, dword ptr ds:___security_cookie
.text:0000C16C                 xor     eax, ebp
.text:0000C16E                 mov     [ebp+var_4], eax
.text:0000C171                 mov     eax, [ebp+arg_0]
.text:0000C174                 mov     [ebp+var_8], eax
.text:0000C177                 mov     ecx, [ebp+var_8]
.text:0000C17A                 mov     eax, [ecx+0Ch]
.text:0000C17D                 call    __alloca_probe_16
.text:0000C182                 mov     edx, [ebp+var_8]
.text:0000C185                 mov     eax, [edx]
.text:0000C187                 mov     [ebp+var_C], eax
.text:0000C18A                 mov     ecx, [ebp+var_8]
.text:0000C18D                 mov     edx, [ecx+4]
.text:0000C190                 push    edx             ; unsigned int
.text:0000C191                 mov     ecx, [ebp+var_C] ; this
.text:0000C194                 call    ?Decode@CEncoderInfo@@QAEJI@Z ; CEncoderInfo::Decode(uint)
.text:0000C199                 mov     ecx, [ebp+var_8]
.text:0000C19C                 mov     edx, [ecx+4]
.text:0000C19F                 mov     ecx, [ebp+var_C]
.text:0000C1A2                 mov     [ecx+edx*4+0A4h], eax
.text:0000C1A9                 xor     eax, eax
.text:0000C1AB                 lea     esp, [ebp-0Ch]
.text:0000C1AE                 mov     ecx, [ebp+var_4]
.text:0000C1B1                 xor     ecx, ebp
.text:0000C1B3                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text:0000C1B8                 mov     esp, ebp
.text:0000C1BA                 pop     ebp
.text:0000C1BB                 retn    4
.text:0000C1BB ?DecodeThreadFunction@CEncoderInfo@@SGIPAX@Z endp
.text:0000C1BB
.text:0000C1BB ; ---------------------------------------------------------------------------
.text:0000C1BE                 align 10h
.text:0000C1BE _text           ends
.text:0000C1BE
.text:0000C1C0 ; ===========================================================================
.text:0000C1C0
.text:0000C1C0 ; Segment type: Pure code
.text:0000C1C0 ; Segment permissions: Read/Execute
.text:0000C1C0 _text           segment para public 'CODE' use32
.text:0000C1C0                 assume cs:_text
.text:0000C1C0                 ;org 0C1C0h
.text:0000C1C0 ; COMDAT (pick any)
.text:0000C1C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000C1C0
.text:0000C1C0 ; =============== S U B R O U T I N E =======================================
.text:0000C1C0
.text:0000C1C0 ; Attributes: bp-based frame
.text:0000C1C0
.text:0000C1C0 ; _DWORD __thiscall CBenchEncoders::CBenchEncoders(CBenchEncoders *this, unsigned int)
.text:0000C1C0                 public ??0CBenchEncoders@@QAE@I@Z
.text:0000C1C0 ??0CBenchEncoders@@QAE@I@Z proc near    ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+129p
.text:0000C1C0
.text:0000C1C0 var_20          = dword ptr -20h
.text:0000C1C0 var_1C          = dword ptr -1Ch
.text:0000C1C0 var_18          = dword ptr -18h
.text:0000C1C0 var_14          = dword ptr -14h
.text:0000C1C0 var_10          = dword ptr -10h
.text:0000C1C0 var_C           = dword ptr -0Ch
.text:0000C1C0 var_4           = dword ptr -4
.text:0000C1C0 arg_0           = dword ptr  8
.text:0000C1C0
.text:0000C1C0                 push    ebp
.text:0000C1C1                 mov     ebp, esp
.text:0000C1C3                 push    0FFFFFFFFh
.text:0000C1C5                 push    offset __ehhandler$??0CBenchEncoders@@QAE@I@Z
.text:0000C1CA                 mov     eax, large fs:0
.text:0000C1D0                 push    eax
.text:0000C1D1                 sub     esp, 14h
.text:0000C1D4                 mov     eax, 0CCCCCCCCh
.text:0000C1D9                 mov     [ebp+var_20], eax
.text:0000C1DC                 mov     [ebp+var_1C], eax
.text:0000C1DF                 mov     [ebp+var_18], eax
.text:0000C1E2                 mov     [ebp+var_14], eax
.text:0000C1E5                 mov     [ebp+var_10], eax
.text:0000C1E8                 mov     eax, dword ptr ds:___security_cookie
.text:0000C1ED                 xor     eax, ebp
.text:0000C1EF                 push    eax
.text:0000C1F0                 lea     eax, [ebp+var_C]
.text:0000C1F3                 mov     large fs:0, eax
.text:0000C1F9                 mov     [ebp+var_10], ecx
.text:0000C1FC                 mov     eax, [ebp+var_10]
.text:0000C1FF                 mov     dword ptr [eax], 0
.text:0000C205                 mov     ecx, [ebp+arg_0]
.text:0000C208                 mov     [ebp+var_14], ecx
.text:0000C20B                 xor     ecx, ecx
.text:0000C20D                 mov     eax, [ebp+var_14]
.text:0000C210                 mov     edx, 118h
.text:0000C215                 mul     edx
.text:0000C217                 seto    cl
.text:0000C21A                 neg     ecx
.text:0000C21C                 or      ecx, eax
.text:0000C21E                 xor     eax, eax
.text:0000C220                 add     ecx, 4
.text:0000C223                 setb    al
.text:0000C226                 neg     eax
.text:0000C228                 or      eax, ecx
.text:0000C22A                 push    eax             ; unsigned int
.text:0000C22B                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0000C230                 add     esp, 4
.text:0000C233                 mov     [ebp+var_1C], eax
.text:0000C236                 mov     [ebp+var_4], 0
.text:0000C23D                 cmp     [ebp+var_1C], 0
.text:0000C241                 jz      short loc_C275
.text:0000C243                 mov     ecx, [ebp+var_1C]
.text:0000C246                 mov     edx, [ebp+var_14]
.text:0000C249                 mov     [ecx], edx
.text:0000C24B                 push    offset ??1CEncoderInfo@@QAE@XZ ; CEncoderInfo::~CEncoderInfo(void)
.text:0000C250                 push    offset ??0CEncoderInfo@@QAE@XZ ; CEncoderInfo::CEncoderInfo(void)
.text:0000C255                 mov     eax, [ebp+var_14]
.text:0000C258                 push    eax
.text:0000C259                 push    118h
.text:0000C25E                 mov     ecx, [ebp+var_1C]
.text:0000C261                 add     ecx, 4
.text:0000C264                 push    ecx
.text:0000C265                 call    ??_L@YGXPAXIHP6EX0@Z1@Z ; `eh vector constructor iterator'(void *,uint,int,void (*)(void *),void (*)(void *))
.text:0000C26A                 mov     edx, [ebp+var_1C]
.text:0000C26D                 add     edx, 4
.text:0000C270                 mov     [ebp+var_20], edx
.text:0000C273                 jmp     short loc_C27C
.text:0000C275 ; ---------------------------------------------------------------------------
.text:0000C275
.text:0000C275 loc_C275:                               ; CODE XREF: CBenchEncoders::CBenchEncoders(uint)+81j
.text:0000C275                 mov     [ebp+var_20], 0
.text:0000C27C
.text:0000C27C loc_C27C:                               ; CODE XREF: CBenchEncoders::CBenchEncoders(uint)+B3j
.text:0000C27C                 mov     eax, [ebp+var_20]
.text:0000C27F                 mov     [ebp+var_18], eax
.text:0000C282                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000C289                 mov     ecx, [ebp+var_10]
.text:0000C28C                 mov     edx, [ebp+var_18]
.text:0000C28F                 mov     [ecx], edx
.text:0000C291                 mov     eax, [ebp+var_10]
.text:0000C294                 mov     ecx, [ebp+var_C]
.text:0000C297                 mov     large fs:0, ecx
.text:0000C29E                 pop     ecx
.text:0000C29F                 add     esp, 20h
.text:0000C2A2                 cmp     ebp, esp
.text:0000C2A4                 call    __RTC_CheckEsp
.text:0000C2A9                 mov     esp, ebp
.text:0000C2AB                 pop     ebp
.text:0000C2AC                 retn    4
.text:0000C2AC ??0CBenchEncoders@@QAE@I@Z endp
.text:0000C2AC
.text:0000C2AC ; ---------------------------------------------------------------------------
.text:0000C2AF                 align 10h
.text:0000C2AF _text           ends
.text:0000C2AF
.text$x:0000C2B0 ; ===========================================================================
.text$x:0000C2B0
.text$x:0000C2B0 ; Segment type: Pure code
.text$x:0000C2B0 ; Segment permissions: Read/Execute
.text$x:0000C2B0 _text$x         segment para public 'CODE' use32
.text$x:0000C2B0                 assume cs:_text$x
.text$x:0000C2B0                 ;org 0C2B0h
.text$x:0000C2B0 ; COMDAT (pick associative to section at C1C0)
.text$x:0000C2B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000C2B0
.text$x:0000C2B0 ; =============== S U B R O U T I N E =======================================
.text$x:0000C2B0
.text$x:0000C2B0
.text$x:0000C2B0 __unwindfunclet$??0CBenchEncoders@@QAE@I@Z$0 proc near
.text$x:0000C2B0                                         ; DATA XREF: .xdata$x:0000C2DCo
.text$x:0000C2B0                 mov     eax, [ebp-1Ch]
.text$x:0000C2B3                 push    eax             ; void *
.text$x:0000C2B4                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:0000C2B9                 pop     ecx
.text$x:0000C2BA                 retn
.text$x:0000C2BA __unwindfunclet$??0CBenchEncoders@@QAE@I@Z$0 endp
.text$x:0000C2BA
.text$x:0000C2BB
.text$x:0000C2BB ; =============== S U B R O U T I N E =======================================
.text$x:0000C2BB
.text$x:0000C2BB
.text$x:0000C2BB __ehhandler$??0CBenchEncoders@@QAE@I@Z proc near
.text$x:0000C2BB                                         ; DATA XREF: CBenchEncoders::CBenchEncoders(uint)+5o
.text$x:0000C2BB
.text$x:0000C2BB arg_4           = dword ptr  8
.text$x:0000C2BB
.text$x:0000C2BB                 mov     edx, [esp+arg_4]
.text$x:0000C2BF                 lea     eax, [edx+0Ch]
.text$x:0000C2C2                 mov     ecx, [edx-18h]
.text$x:0000C2C5                 xor     ecx, eax
.text$x:0000C2C7                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000C2CC                 mov     eax, offset __ehfuncinfo$??0CBenchEncoders@@QAE@I@Z
.text$x:0000C2D1                 jmp     ___CxxFrameHandler3
.text$x:0000C2D1 __ehhandler$??0CBenchEncoders@@QAE@I@Z endp
.text$x:0000C2D1
.text$x:0000C2D1 ; ---------------------------------------------------------------------------
.text$x:0000C2D6                 align 4
.text$x:0000C2D6 _text$x         ends
.text$x:0000C2D6
.xdata$x:0000C2D8 ; ===========================================================================
.xdata$x:0000C2D8
.xdata$x:0000C2D8 ; Segment type: Pure data
.xdata$x:0000C2D8 ; Segment permissions: Read
.xdata$x:0000C2D8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C2D8                 assume cs:_xdata$x
.xdata$x:0000C2D8                 ;org 0C2D8h
.xdata$x:0000C2D8 ; COMDAT (pick associative to section at C1C0)
.xdata$x:0000C2D8 __unwindtable$??0CBenchEncoders@@QAE@I@Z db 0FFh
.xdata$x:0000C2D8                                         ; DATA XREF: .xdata$x:0000C2E8o
.xdata$x:0000C2D9                 db 0FFh
.xdata$x:0000C2DA                 db 0FFh
.xdata$x:0000C2DB                 db 0FFh
.xdata$x:0000C2DC                 dd offset __unwindfunclet$??0CBenchEncoders@@QAE@I@Z$0
.xdata$x:0000C2E0 __ehfuncinfo$??0CBenchEncoders@@QAE@I@Z db  22h ; "
.xdata$x:0000C2E0                                         ; DATA XREF: __ehhandler$??0CBenchEncoders@@QAE@I@Z+11o
.xdata$x:0000C2E1                 db    5
.xdata$x:0000C2E2                 db  93h ; ô
.xdata$x:0000C2E3                 db  19h
.xdata$x:0000C2E4                 db    1
.xdata$x:0000C2E5                 db    0
.xdata$x:0000C2E6                 db    0
.xdata$x:0000C2E7                 db    0
.xdata$x:0000C2E8                 dd offset __unwindtable$??0CBenchEncoders@@QAE@I@Z
.xdata$x:0000C2EC                 align 20h
.xdata$x:0000C300                 db    1
.xdata$x:0000C301                 db    0
.xdata$x:0000C302                 db    0
.xdata$x:0000C303                 db    0
.xdata$x:0000C303 _xdata$x        ends
.xdata$x:0000C303
.text:0000C304 ; ===========================================================================
.text:0000C304
.text:0000C304 ; Segment type: Pure code
.text:0000C304 ; Segment permissions: Read/Execute
.text:0000C304 _text           segment para public 'CODE' use32
.text:0000C304                 assume cs:_text
.text:0000C304                 ;org 0C304h
.text:0000C304 ; COMDAT (pick any)
.text:0000C304                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000C304
.text:0000C304 ; =============== S U B R O U T I N E =======================================
.text:0000C304
.text:0000C304 ; Attributes: bp-based frame
.text:0000C304
.text:0000C304 ; public: __thiscall CEncoderInfo::CEncoderInfo(void)
.text:0000C304                 public ??0CEncoderInfo@@QAE@XZ
.text:0000C304 ??0CEncoderInfo@@QAE@XZ proc near       ; DATA XREF: CBenchEncoders::CBenchEncoders(uint)+90o
.text:0000C304
.text:0000C304 var_10          = dword ptr -10h
.text:0000C304 var_C           = dword ptr -0Ch
.text:0000C304 var_4           = dword ptr -4
.text:0000C304
.text:0000C304                 push    ebp
.text:0000C305                 mov     ebp, esp
.text:0000C307                 push    0FFFFFFFFh
.text:0000C309                 push    offset __ehhandler$??0CEncoderInfo@@QAE@XZ
.text:0000C30E                 mov     eax, large fs:0
.text:0000C314                 push    eax
.text:0000C315                 push    ecx
.text:0000C316                 mov     [ebp+var_10], 0CCCCCCCCh
.text:0000C31D                 mov     eax, dword ptr ds:___security_cookie
.text:0000C322                 xor     eax, ebp
.text:0000C324                 push    eax
.text:0000C325                 lea     eax, [ebp+var_C]
.text:0000C328                 mov     large fs:0, eax
.text:0000C32E                 mov     [ebp+var_10], ecx
.text:0000C331                 push    offset ??1CThread@NWindows@@QAE@XZ ; NWindows::CThread::~CThread(void)
.text:0000C336                 push    offset ??0CThread@NWindows@@QAE@XZ ; NWindows::CThread::CThread(void)
.text:0000C33B                 push    2
.text:0000C33D                 push    4
.text:0000C33F                 mov     eax, [ebp+var_10]
.text:0000C342                 push    eax
.text:0000C343                 call    ??_L@YGXPAXIHP6EX0@Z1@Z ; `eh vector constructor iterator'(void *,uint,int,void (*)(void *),void (*)(void *))
.text:0000C348                 mov     [ebp+var_4], 0
.text:0000C34F                 mov     ecx, [ebp+var_10]
.text:0000C352                 add     ecx, 0Ch
.text:0000C355                 call    ??0?$CMyComPtr@UICompressCoder@@@@QAE@XZ ; CMyComPtr<ICompressCoder>::CMyComPtr<ICompressCoder>(void)
.text:0000C35A                 mov     byte ptr [ebp+var_4], 1
.text:0000C35E                 mov     ecx, [ebp+var_10]
.text:0000C361                 add     ecx, 10h
.text:0000C364                 call    ??0?$CMyComPtr@UICompressFilter@@@@QAE@XZ ; CMyComPtr<ICompressFilter>::CMyComPtr<ICompressFilter>(void)
.text:0000C369                 mov     byte ptr [ebp+var_4], 2
.text:0000C36D                 push    offset ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ ; CMyComPtr<ICompressProgressInfo>::~CMyComPtr<ICompressProgressInfo>(void)
.text:0000C372                 push    offset ??0?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ ; CMyComPtr<ICompressProgressInfo>::CMyComPtr<ICompressProgressInfo>(void)
.text:0000C377                 push    2
.text:0000C379                 push    4
.text:0000C37B                 mov     ecx, [ebp+var_10]
.text:0000C37E                 add     ecx, 1Ch
.text:0000C381                 push    ecx
.text:0000C382                 call    ??_L@YGXPAXIHP6EX0@Z1@Z ; `eh vector constructor iterator'(void *,uint,int,void (*)(void *),void (*)(void *))
.text:0000C387                 mov     byte ptr [ebp+var_4], 3
.text:0000C38B                 mov     edx, [ebp+var_10]
.text:0000C38E                 mov     byte ptr [edx+74h], 1
.text:0000C392                 mov     eax, [ebp+var_10]
.text:0000C395                 mov     byte ptr [eax+75h], 1
.text:0000C399                 push    offset ??1?$CMyComPtr@UICompressCoder@@@@QAE@XZ ; CMyComPtr<ICompressCoder>::~CMyComPtr<ICompressCoder>(void)
.text:0000C39E                 push    offset ??0?$CMyComPtr@UICompressCoder@@@@QAE@XZ ; CMyComPtr<ICompressCoder>::CMyComPtr<ICompressCoder>(void)
.text:0000C3A3                 push    2
.text:0000C3A5                 push    4
.text:0000C3A7                 mov     ecx, [ebp+var_10]
.text:0000C3AA                 add     ecx, 98h ; 'ÿ'
.text:0000C3B0                 push    ecx
.text:0000C3B1                 call    ??_L@YGXPAXIHP6EX0@Z1@Z ; `eh vector constructor iterator'(void *,uint,int,void (*)(void *),void (*)(void *))
.text:0000C3B6                 mov     byte ptr [ebp+var_4], 4
.text:0000C3BA                 mov     ecx, [ebp+var_10]
.text:0000C3BD                 add     ecx, 0A0h ; 'á'
.text:0000C3C3                 call    ??0?$CMyComPtr@UICompressFilter@@@@QAE@XZ ; CMyComPtr<ICompressFilter>::CMyComPtr<ICompressFilter>(void)
.text:0000C3C8                 mov     byte ptr [ebp+var_4], 5
.text:0000C3CC                 mov     edx, [ebp+var_10]
.text:0000C3CF                 mov     dword ptr [edx+0ACh], 0
.text:0000C3D9                 mov     ecx, [ebp+var_10]
.text:0000C3DC                 add     ecx, 0B0h ; '¦'
.text:0000C3E2                 call    ??0?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::CMyComPtr<ISequentialOutStream>(void)
.text:0000C3E7                 mov     byte ptr [ebp+var_4], 6
.text:0000C3EB                 mov     eax, [ebp+var_10]
.text:0000C3EE                 mov     dword ptr [eax+0B4h], 0
.text:0000C3F8                 mov     ecx, [ebp+var_10]
.text:0000C3FB                 mov     dword ptr [ecx+0B8h], 0
.text:0000C405                 mov     ecx, [ebp+var_10]
.text:0000C408                 add     ecx, 0C8h ; '+'
.text:0000C40E                 call    ??0CBenchRandomGenerator@@QAE@XZ ; CBenchRandomGenerator::CBenchRandomGenerator(void)
.text:0000C413                 mov     byte ptr [ebp+var_4], 7
.text:0000C417                 mov     ecx, [ebp+var_10]
.text:0000C41A                 add     ecx, 0D8h ; '+' ; this
.text:0000C420                 call    ??0CBenchBuffer@@QAE@XZ ; CBenchBuffer::CBenchBuffer(void)
.text:0000C425                 mov     byte ptr [ebp+var_4], 8
.text:0000C429                 mov     edx, [ebp+var_10]
.text:0000C42C                 mov     dword ptr [edx+0E4h], 0
.text:0000C436                 mov     ecx, [ebp+var_10]
.text:0000C439                 add     ecx, 0E8h ; 'F'
.text:0000C43F                 call    ??0?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::CMyComPtr<ISequentialOutStream>(void)
.text:0000C444                 mov     byte ptr [ebp+var_4], 9
.text:0000C448                 mov     ecx, [ebp+var_10]
.text:0000C44B                 add     ecx, 0ECh ; '8'
.text:0000C451                 call    ??0COneMethodInfo@@QAE@XZ ; COneMethodInfo::COneMethodInfo(void)
.text:0000C456                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000C45D                 mov     eax, [ebp+var_10]
.text:0000C460                 mov     ecx, [ebp+var_C]
.text:0000C463                 mov     large fs:0, ecx
.text:0000C46A                 pop     ecx
.text:0000C46B                 add     esp, 10h
.text:0000C46E                 cmp     ebp, esp
.text:0000C470                 call    __RTC_CheckEsp
.text:0000C475                 mov     esp, ebp
.text:0000C477                 pop     ebp
.text:0000C478                 retn
.text:0000C478 ??0CEncoderInfo@@QAE@XZ endp
.text:0000C478
.text:0000C478 ; ---------------------------------------------------------------------------
.text:0000C479                 align 4
.text:0000C479 _text           ends
.text:0000C479
.text$x:0000C47C ; ===========================================================================
.text$x:0000C47C
.text$x:0000C47C ; Segment type: Pure code
.text$x:0000C47C ; Segment permissions: Read/Execute
.text$x:0000C47C _text$x         segment para public 'CODE' use32
.text$x:0000C47C                 assume cs:_text$x
.text$x:0000C47C                 ;org 0C47Ch
.text$x:0000C47C ; COMDAT (pick associative to section at C304)
.text$x:0000C47C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000C47C
.text$x:0000C47C ; =============== S U B R O U T I N E =======================================
.text$x:0000C47C
.text$x:0000C47C
.text$x:0000C47C __unwindfunclet$??0CEncoderInfo@@QAE@XZ$0 proc near
.text$x:0000C47C                                         ; DATA XREF: .xdata$x:0000C55Co
.text$x:0000C47C                 push    offset ??1CThread@NWindows@@QAE@XZ ; NWindows::CThread::~CThread(void)
.text$x:0000C481                 push    2
.text$x:0000C483                 push    4
.text$x:0000C485                 mov     eax, [ebp-10h]
.text$x:0000C488                 push    eax
.text$x:0000C489                 call    ??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
.text$x:0000C48E                 retn
.text$x:0000C48E __unwindfunclet$??0CEncoderInfo@@QAE@XZ$0 endp
.text$x:0000C48E
.text$x:0000C48F
.text$x:0000C48F ; =============== S U B R O U T I N E =======================================
.text$x:0000C48F
.text$x:0000C48F
.text$x:0000C48F __unwindfunclet$??0CEncoderInfo@@QAE@XZ$1 proc near
.text$x:0000C48F                                         ; DATA XREF: .xdata$x:0000C564o
.text$x:0000C48F                 mov     ecx, [ebp-10h]
.text$x:0000C492                 add     ecx, 0Ch
.text$x:0000C495                 jmp     ??1?$CMyComPtr@UICompressCoder@@@@QAE@XZ ; CMyComPtr<ICompressCoder>::~CMyComPtr<ICompressCoder>(void)
.text$x:0000C495 __unwindfunclet$??0CEncoderInfo@@QAE@XZ$1 endp
.text$x:0000C495
.text$x:0000C49A
.text$x:0000C49A ; =============== S U B R O U T I N E =======================================
.text$x:0000C49A
.text$x:0000C49A
.text$x:0000C49A __unwindfunclet$??0CEncoderInfo@@QAE@XZ$2 proc near
.text$x:0000C49A                                         ; DATA XREF: .xdata$x:0000C56Co
.text$x:0000C49A                 mov     ecx, [ebp-10h]
.text$x:0000C49D                 add     ecx, 10h
.text$x:0000C4A0                 jmp     ??1?$CMyComPtr@UICompressFilter@@@@QAE@XZ ; CMyComPtr<ICompressFilter>::~CMyComPtr<ICompressFilter>(void)
.text$x:0000C4A0 __unwindfunclet$??0CEncoderInfo@@QAE@XZ$2 endp
.text$x:0000C4A0
.text$x:0000C4A5
.text$x:0000C4A5 ; =============== S U B R O U T I N E =======================================
.text$x:0000C4A5
.text$x:0000C4A5
.text$x:0000C4A5 __unwindfunclet$??0CEncoderInfo@@QAE@XZ$3 proc near
.text$x:0000C4A5                                         ; DATA XREF: .xdata$x:0000C574o
.text$x:0000C4A5                 push    offset ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ ; CMyComPtr<ICompressProgressInfo>::~CMyComPtr<ICompressProgressInfo>(void)
.text$x:0000C4AA                 push    2
.text$x:0000C4AC                 push    4
.text$x:0000C4AE                 mov     eax, [ebp-10h]
.text$x:0000C4B1                 add     eax, 1Ch
.text$x:0000C4B4                 push    eax
.text$x:0000C4B5                 call    ??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
.text$x:0000C4BA                 retn
.text$x:0000C4BA __unwindfunclet$??0CEncoderInfo@@QAE@XZ$3 endp
.text$x:0000C4BA
.text$x:0000C4BB
.text$x:0000C4BB ; =============== S U B R O U T I N E =======================================
.text$x:0000C4BB
.text$x:0000C4BB
.text$x:0000C4BB __unwindfunclet$??0CEncoderInfo@@QAE@XZ$4 proc near
.text$x:0000C4BB                                         ; DATA XREF: .xdata$x:0000C57Co
.text$x:0000C4BB                 push    offset ??1?$CMyComPtr@UICompressCoder@@@@QAE@XZ ; CMyComPtr<ICompressCoder>::~CMyComPtr<ICompressCoder>(void)
.text$x:0000C4C0                 push    2
.text$x:0000C4C2                 push    4
.text$x:0000C4C4                 mov     eax, [ebp-10h]
.text$x:0000C4C7                 add     eax, 98h ; 'ÿ'
.text$x:0000C4CC                 push    eax
.text$x:0000C4CD                 call    ??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
.text$x:0000C4D2                 retn
.text$x:0000C4D2 __unwindfunclet$??0CEncoderInfo@@QAE@XZ$4 endp
.text$x:0000C4D2
.text$x:0000C4D3
.text$x:0000C4D3 ; =============== S U B R O U T I N E =======================================
.text$x:0000C4D3
.text$x:0000C4D3
.text$x:0000C4D3 __unwindfunclet$??0CEncoderInfo@@QAE@XZ$5 proc near
.text$x:0000C4D3                                         ; DATA XREF: .xdata$x:0000C584o
.text$x:0000C4D3                 mov     ecx, [ebp-10h]
.text$x:0000C4D6                 add     ecx, 0A0h ; 'á'
.text$x:0000C4DC                 jmp     ??1?$CMyComPtr@UICompressFilter@@@@QAE@XZ ; CMyComPtr<ICompressFilter>::~CMyComPtr<ICompressFilter>(void)
.text$x:0000C4DC __unwindfunclet$??0CEncoderInfo@@QAE@XZ$5 endp
.text$x:0000C4DC
.text$x:0000C4E1
.text$x:0000C4E1 ; =============== S U B R O U T I N E =======================================
.text$x:0000C4E1
.text$x:0000C4E1
.text$x:0000C4E1 __unwindfunclet$??0CEncoderInfo@@QAE@XZ$6 proc near
.text$x:0000C4E1                                         ; DATA XREF: .xdata$x:0000C58Co
.text$x:0000C4E1                 mov     ecx, [ebp-10h]
.text$x:0000C4E4                 add     ecx, 0B0h ; '¦'
.text$x:0000C4EA                 jmp     ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text$x:0000C4EA __unwindfunclet$??0CEncoderInfo@@QAE@XZ$6 endp
.text$x:0000C4EA
.text$x:0000C4EF
.text$x:0000C4EF ; =============== S U B R O U T I N E =======================================
.text$x:0000C4EF
.text$x:0000C4EF
.text$x:0000C4EF __unwindfunclet$??0CEncoderInfo@@QAE@XZ$7 proc near
.text$x:0000C4EF                                         ; DATA XREF: .xdata$x:0000C594o
.text$x:0000C4EF                 mov     ecx, [ebp-10h]
.text$x:0000C4F2                 add     ecx, 0C8h ; '+' ; this
.text$x:0000C4F8                 jmp     ??1CBenchRandomGenerator@@UAE@XZ ; CBenchRandomGenerator::~CBenchRandomGenerator(void)
.text$x:0000C4F8 __unwindfunclet$??0CEncoderInfo@@QAE@XZ$7 endp
.text$x:0000C4F8
.text$x:0000C4FD
.text$x:0000C4FD ; =============== S U B R O U T I N E =======================================
.text$x:0000C4FD
.text$x:0000C4FD
.text$x:0000C4FD __unwindfunclet$??0CEncoderInfo@@QAE@XZ$8 proc near
.text$x:0000C4FD                                         ; DATA XREF: .xdata$x:0000C59Co
.text$x:0000C4FD                 mov     ecx, [ebp-10h]
.text$x:0000C500                 add     ecx, 0D8h ; '+' ; this
.text$x:0000C506                 jmp     ??1CBenchBuffer@@UAE@XZ ; CBenchBuffer::~CBenchBuffer(void)
.text$x:0000C506 __unwindfunclet$??0CEncoderInfo@@QAE@XZ$8 endp
.text$x:0000C506
.text$x:0000C50B
.text$x:0000C50B ; =============== S U B R O U T I N E =======================================
.text$x:0000C50B
.text$x:0000C50B
.text$x:0000C50B __unwindfunclet$??0CEncoderInfo@@QAE@XZ$9 proc near
.text$x:0000C50B                                         ; DATA XREF: .xdata$x:0000C5A4o
.text$x:0000C50B                 mov     ecx, [ebp-10h]
.text$x:0000C50E                 add     ecx, 0E8h ; 'F'
.text$x:0000C514                 jmp     ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text$x:0000C514 __unwindfunclet$??0CEncoderInfo@@QAE@XZ$9 endp
.text$x:0000C514
.text$x:0000C519
.text$x:0000C519 ; =============== S U B R O U T I N E =======================================
.text$x:0000C519
.text$x:0000C519
.text$x:0000C519 __ehhandler$??0CEncoderInfo@@QAE@XZ proc near
.text$x:0000C519                                         ; DATA XREF: CEncoderInfo::CEncoderInfo(void)+5o
.text$x:0000C519
.text$x:0000C519 arg_4           = dword ptr  8
.text$x:0000C519
.text$x:0000C519                 mov     edx, [esp+arg_4]
.text$x:0000C51D                 lea     eax, [edx+0Ch]
.text$x:0000C520                 mov     ecx, [edx-8]
.text$x:0000C523                 xor     ecx, eax
.text$x:0000C525                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000C52A                 mov     eax, offset __ehfuncinfo$??0CEncoderInfo@@QAE@XZ
.text$x:0000C52F                 jmp     ___CxxFrameHandler3
.text$x:0000C52F __ehhandler$??0CEncoderInfo@@QAE@XZ endp
.text$x:0000C52F
.text$x:0000C52F _text$x         ends
.text$x:0000C52F
.xdata$x:0000C534 ; ===========================================================================
.xdata$x:0000C534
.xdata$x:0000C534 ; Segment type: Pure data
.xdata$x:0000C534 ; Segment permissions: Read
.xdata$x:0000C534 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C534                 assume cs:_xdata$x
.xdata$x:0000C534                 ;org 0C534h
.xdata$x:0000C534 ; COMDAT (pick associative to section at C304)
.xdata$x:0000C534 __ehfuncinfo$??0CEncoderInfo@@QAE@XZ db  22h ; "
.xdata$x:0000C534                                         ; DATA XREF: __ehhandler$??0CEncoderInfo@@QAE@XZ+11o
.xdata$x:0000C535                 db    5
.xdata$x:0000C536                 db  93h ; ô
.xdata$x:0000C537                 db  19h
.xdata$x:0000C538                 db  0Ah
.xdata$x:0000C539                 db    0
.xdata$x:0000C53A                 db    0
.xdata$x:0000C53B                 db    0
.xdata$x:0000C53C                 dd offset __unwindtable$??0CEncoderInfo@@QAE@XZ
.xdata$x:0000C540                 db    0
.xdata$x:0000C541                 db    0
.xdata$x:0000C542                 db    0
.xdata$x:0000C543                 db    0
.xdata$x:0000C544                 db    0
.xdata$x:0000C545                 db    0
.xdata$x:0000C546                 db    0
.xdata$x:0000C547                 db    0
.xdata$x:0000C548                 db    0
.xdata$x:0000C549                 db    0
.xdata$x:0000C54A                 db    0
.xdata$x:0000C54B                 db    0
.xdata$x:0000C54C                 db    0
.xdata$x:0000C54D                 db    0
.xdata$x:0000C54E                 db    0
.xdata$x:0000C54F                 db    0
.xdata$x:0000C550                 db    0
.xdata$x:0000C551                 db    0
.xdata$x:0000C552                 db    0
.xdata$x:0000C553                 db    0
.xdata$x:0000C554                 db    1
.xdata$x:0000C555                 db    0
.xdata$x:0000C556                 db    0
.xdata$x:0000C557                 db    0
.xdata$x:0000C558 __unwindtable$??0CEncoderInfo@@QAE@XZ db 0FFh
.xdata$x:0000C558                                         ; DATA XREF: .xdata$x:0000C53Co
.xdata$x:0000C559                 db 0FFh
.xdata$x:0000C55A                 db 0FFh
.xdata$x:0000C55B                 db 0FFh
.xdata$x:0000C55C                 dd offset __unwindfunclet$??0CEncoderInfo@@QAE@XZ$0
.xdata$x:0000C560                 db    0
.xdata$x:0000C561                 db    0
.xdata$x:0000C562                 db    0
.xdata$x:0000C563                 db    0
.xdata$x:0000C564                 dd offset __unwindfunclet$??0CEncoderInfo@@QAE@XZ$1
.xdata$x:0000C568                 db    1
.xdata$x:0000C569                 db    0
.xdata$x:0000C56A                 db    0
.xdata$x:0000C56B                 db    0
.xdata$x:0000C56C                 dd offset __unwindfunclet$??0CEncoderInfo@@QAE@XZ$2
.xdata$x:0000C570                 db    2
.xdata$x:0000C571                 db    0
.xdata$x:0000C572                 db    0
.xdata$x:0000C573                 db    0
.xdata$x:0000C574                 dd offset __unwindfunclet$??0CEncoderInfo@@QAE@XZ$3
.xdata$x:0000C578                 db    3
.xdata$x:0000C579                 db    0
.xdata$x:0000C57A                 db    0
.xdata$x:0000C57B                 db    0
.xdata$x:0000C57C                 dd offset __unwindfunclet$??0CEncoderInfo@@QAE@XZ$4
.xdata$x:0000C580                 db    4
.xdata$x:0000C581                 db    0
.xdata$x:0000C582                 db    0
.xdata$x:0000C583                 db    0
.xdata$x:0000C584                 dd offset __unwindfunclet$??0CEncoderInfo@@QAE@XZ$5
.xdata$x:0000C588                 db    5
.xdata$x:0000C589                 db    0
.xdata$x:0000C58A                 db    0
.xdata$x:0000C58B                 db    0
.xdata$x:0000C58C                 dd offset __unwindfunclet$??0CEncoderInfo@@QAE@XZ$6
.xdata$x:0000C590                 db    6
.xdata$x:0000C591                 db    0
.xdata$x:0000C592                 db    0
.xdata$x:0000C593                 db    0
.xdata$x:0000C594                 dd offset __unwindfunclet$??0CEncoderInfo@@QAE@XZ$7
.xdata$x:0000C598                 db    7
.xdata$x:0000C599                 db    0
.xdata$x:0000C59A                 db    0
.xdata$x:0000C59B                 db    0
.xdata$x:0000C59C                 dd offset __unwindfunclet$??0CEncoderInfo@@QAE@XZ$8
.xdata$x:0000C5A0                 db    8
.xdata$x:0000C5A1                 db    0
.xdata$x:0000C5A2                 db    0
.xdata$x:0000C5A3                 db    0
.xdata$x:0000C5A4                 dd offset __unwindfunclet$??0CEncoderInfo@@QAE@XZ$9
.xdata$x:0000C5A4 _xdata$x        ends
.xdata$x:0000C5A4
.text:0000C5A8 ; ===========================================================================
.text:0000C5A8
.text:0000C5A8 ; Segment type: Pure code
.text:0000C5A8 ; Segment permissions: Read/Execute
.text:0000C5A8 _text           segment para public 'CODE' use32
.text:0000C5A8                 assume cs:_text
.text:0000C5A8                 ;org 0C5A8h
.text:0000C5A8 ; COMDAT (pick any)
.text:0000C5A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000C5A8
.text:0000C5A8 ; =============== S U B R O U T I N E =======================================
.text:0000C5A8
.text:0000C5A8 ; Attributes: bp-based frame
.text:0000C5A8
.text:0000C5A8 ; _DWORD __thiscall NWindows::CThread::CThread(NWindows::CThread *__hidden this)
.text:0000C5A8                 public ??0CThread@NWindows@@QAE@XZ
.text:0000C5A8 ??0CThread@NWindows@@QAE@XZ proc near   ; CODE XREF: CFreqInfo::CFreqInfo(void)+11p
.text:0000C5A8                                         ; CCrcInfo::CCrcInfo(void)+30p
.text:0000C5A8                                         ; DATA XREF: ...
.text:0000C5A8
.text:0000C5A8 var_4           = dword ptr -4
.text:0000C5A8
.text:0000C5A8                 push    ebp
.text:0000C5A9                 mov     ebp, esp
.text:0000C5AB                 push    ecx
.text:0000C5AC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000C5B3                 mov     [ebp+var_4], ecx
.text:0000C5B6                 mov     eax, [ebp+var_4]
.text:0000C5B9                 mov     dword ptr [eax], 0
.text:0000C5BF                 mov     eax, [ebp+var_4]
.text:0000C5C2                 mov     esp, ebp
.text:0000C5C4                 pop     ebp
.text:0000C5C5                 retn
.text:0000C5C5 ??0CThread@NWindows@@QAE@XZ endp
.text:0000C5C5
.text:0000C5C5 ; ---------------------------------------------------------------------------
.text:0000C5C6                 align 4
.text:0000C5C6 _text           ends
.text:0000C5C6
.text:0000C5C8 ; ===========================================================================
.text:0000C5C8
.text:0000C5C8 ; Segment type: Pure code
.text:0000C5C8 ; Segment permissions: Read/Execute
.text:0000C5C8 _text           segment para public 'CODE' use32
.text:0000C5C8                 assume cs:_text
.text:0000C5C8                 ;org 0C5C8h
.text:0000C5C8 ; COMDAT (pick any)
.text:0000C5C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000C5C8
.text:0000C5C8 ; =============== S U B R O U T I N E =======================================
.text:0000C5C8
.text:0000C5C8 ; Attributes: bp-based frame
.text:0000C5C8
.text:0000C5C8 ; public: __thiscall CBenchRandomGenerator::CBenchRandomGenerator(void)
.text:0000C5C8                 public ??0CBenchRandomGenerator@@QAE@XZ
.text:0000C5C8 ??0CBenchRandomGenerator@@QAE@XZ proc near
.text:0000C5C8                                         ; CODE XREF: CEncoderInfo::CEncoderInfo(void)+10Ap
.text:0000C5C8
.text:0000C5C8 var_4           = dword ptr -4
.text:0000C5C8
.text:0000C5C8                 push    ebp
.text:0000C5C9                 mov     ebp, esp
.text:0000C5CB                 push    ecx
.text:0000C5CC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000C5D3                 mov     [ebp+var_4], ecx
.text:0000C5D6                 mov     ecx, [ebp+var_4] ; this
.text:0000C5D9                 call    ??0CBenchBuffer@@QAE@XZ ; CBenchBuffer::CBenchBuffer(void)
.text:0000C5DE                 mov     eax, [ebp+var_4]
.text:0000C5E1                 mov     dword ptr [eax], offset ??_7CBenchRandomGenerator@@6B@ ; const CBenchRandomGenerator::`vftable'
.text:0000C5E7                 mov     eax, [ebp+var_4]
.text:0000C5EA                 add     esp, 4
.text:0000C5ED                 cmp     ebp, esp
.text:0000C5EF                 call    __RTC_CheckEsp
.text:0000C5F4                 mov     esp, ebp
.text:0000C5F6                 pop     ebp
.text:0000C5F7                 retn
.text:0000C5F7 ??0CBenchRandomGenerator@@QAE@XZ endp
.text:0000C5F7
.text:0000C5F7 _text           ends
.text:0000C5F7
.rdata:0000C5F8 ; ===========================================================================
.rdata:0000C5F8
.rdata:0000C5F8 ; Segment type: Pure data
.rdata:0000C5F8 ; Segment permissions: Read
.rdata:0000C5F8 _rdata          segment dword public 'DATA' use32
.rdata:0000C5F8                 assume cs:_rdata
.rdata:0000C5F8                 ;org 0C5F8h
.rdata:0000C5F8 ; COMDAT (pick largest)
.rdata:0000C5F8                 dd offset ??_R4CBenchRandomGenerator@@6B@ ; const CBenchRandomGenerator::`RTTI Complete Object Locator'
.rdata:0000C5FC                 public ??_7CBenchRandomGenerator@@6B@
.rdata:0000C5FC ; const CBenchRandomGenerator::`vftable'
.rdata:0000C5FC ??_7CBenchRandomGenerator@@6B@ dd offset ??_ECBenchRandomGenerator@@UAEPAXI@Z
.rdata:0000C5FC                                         ; DATA XREF: CBenchRandomGenerator::CBenchRandomGenerator(void)+19o
.rdata:0000C5FC _rdata          ends                    ; CBenchRandomGenerator::`vector deleting destructor'(uint)
.rdata:0000C5FC
.rdata$r:0000C600 ; ===========================================================================
.rdata$r:0000C600
.rdata$r:0000C600 ; Segment type: Pure data
.rdata$r:0000C600 ; Segment permissions: Read
.rdata$r:0000C600 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000C600                 assume cs:_rdata$r
.rdata$r:0000C600                 ;org 0C600h
.rdata$r:0000C600 ; COMDAT (pick any)
.rdata$r:0000C600                 public ??_R4CBenchRandomGenerator@@6B@
.rdata$r:0000C600 ; const CBenchRandomGenerator::`RTTI Complete Object Locator'
.rdata$r:0000C600 ??_R4CBenchRandomGenerator@@6B@ db    0 ; DATA XREF: .rdata:0000C5F8o
.rdata$r:0000C601                 db    0
.rdata$r:0000C602                 db    0
.rdata$r:0000C603                 db    0
.rdata$r:0000C604                 db    0
.rdata$r:0000C605                 db    0
.rdata$r:0000C606                 db    0
.rdata$r:0000C607                 db    0
.rdata$r:0000C608                 db    0
.rdata$r:0000C609                 db    0
.rdata$r:0000C60A                 db    0
.rdata$r:0000C60B                 db    0
.rdata$r:0000C60C                 dd offset ??_R0?AVCBenchRandomGenerator@@@8 ; CBenchRandomGenerator `RTTI Type Descriptor'
.rdata$r:0000C610                 dd offset ??_R3CBenchRandomGenerator@@8 ; CBenchRandomGenerator::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000C610 _rdata$r        ends
.rdata$r:0000C610
.data:0000C614 ; ===========================================================================
.data:0000C614
.data:0000C614 ; Segment type: Pure data
.data:0000C614 ; Segment permissions: Read/Write
.data:0000C614 _data           segment dword public 'DATA' use32
.data:0000C614                 assume cs:_data
.data:0000C614                 ;org 0C614h
.data:0000C614 ; COMDAT (pick any)
.data:0000C614                 public ??_R0?AVCBenchRandomGenerator@@@8
.data:0000C614 ; class CBenchRandomGenerator `RTTI Type Descriptor'
.data:0000C614 ??_R0?AVCBenchRandomGenerator@@@8 dd offset ??_7type_info@@6B@
.data:0000C614                                         ; DATA XREF: .rdata$r:0000C60Co
.data:0000C614                                         ; .rdata$r:CBenchRandomGenerator::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:0000C614                                         ; const type_info::`vftable'
.data:0000C618                 db    0
.data:0000C619                 db    0
.data:0000C61A                 db    0
.data:0000C61B                 db    0
.data:0000C61C                 db  2Eh ; .
.data:0000C61D                 db  3Fh ; ?
.data:0000C61E                 db  41h ; A
.data:0000C61F                 db  56h ; V
.data:0000C620                 db  43h ; C
.data:0000C621                 db  42h ; B
.data:0000C622                 db  65h ; e
.data:0000C623                 db  6Eh ; n
.data:0000C624                 db  63h ; c
.data:0000C625                 db  68h ; h
.data:0000C626                 db  52h ; R
.data:0000C627                 db  61h ; a
.data:0000C628                 db  6Eh ; n
.data:0000C629                 db  64h ; d
.data:0000C62A                 db  6Fh ; o
.data:0000C62B                 db  6Dh ; m
.data:0000C62C                 db  47h ; G
.data:0000C62D                 db  65h ; e
.data:0000C62E                 db  6Eh ; n
.data:0000C62F                 db  65h ; e
.data:0000C630                 db  72h ; r
.data:0000C631                 db  61h ; a
.data:0000C632                 db  74h ; t
.data:0000C633                 db  6Fh ; o
.data:0000C634                 db  72h ; r
.data:0000C635                 db  40h ; @
.data:0000C636                 db  40h ; @
.data:0000C637                 db    0
.data:0000C637 _data           ends
.data:0000C637
.rdata$r:0000C638 ; ===========================================================================
.rdata$r:0000C638
.rdata$r:0000C638 ; Segment type: Pure data
.rdata$r:0000C638 ; Segment permissions: Read
.rdata$r:0000C638 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000C638                 assume cs:_rdata$r
.rdata$r:0000C638                 ;org 0C638h
.rdata$r:0000C638 ; COMDAT (pick any)
.rdata$r:0000C638                 public ??_R3CBenchRandomGenerator@@8
.rdata$r:0000C638 ; CBenchRandomGenerator::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000C638 ??_R3CBenchRandomGenerator@@8 db    0   ; DATA XREF: .rdata$r:0000C610o
.rdata$r:0000C638                                         ; .rdata$r:0000C66Co
.rdata$r:0000C639                 db    0
.rdata$r:0000C63A                 db    0
.rdata$r:0000C63B                 db    0
.rdata$r:0000C63C                 db    0
.rdata$r:0000C63D                 db    0
.rdata$r:0000C63E                 db    0
.rdata$r:0000C63F                 db    0
.rdata$r:0000C640                 db    2
.rdata$r:0000C641                 db    0
.rdata$r:0000C642                 db    0
.rdata$r:0000C643                 db    0
.rdata$r:0000C644                 dd offset ??_R2CBenchRandomGenerator@@8 ; CBenchRandomGenerator::`RTTI Base Class Array'
.rdata$r:0000C644 _rdata$r        ends
.rdata$r:0000C644
.rdata$r:0000C648 ; ===========================================================================
.rdata$r:0000C648
.rdata$r:0000C648 ; Segment type: Pure data
.rdata$r:0000C648 ; Segment permissions: Read
.rdata$r:0000C648 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000C648                 assume cs:_rdata$r
.rdata$r:0000C648                 ;org 0C648h
.rdata$r:0000C648 ; COMDAT (pick any)
.rdata$r:0000C648                 public ??_R2CBenchRandomGenerator@@8
.rdata$r:0000C648 ; CBenchRandomGenerator::`RTTI Base Class Array'
.rdata$r:0000C648 ??_R2CBenchRandomGenerator@@8 dd offset ??_R1A@?0A@EA@CBenchRandomGenerator@@8
.rdata$r:0000C648                                         ; DATA XREF: .rdata$r:0000C644o
.rdata$r:0000C648                                         ; CBenchRandomGenerator::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000C64C                 dd offset ??_R1A@?0A@EA@CBenchBuffer@@8 ; CBenchBuffer::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000C650                 db    0
.rdata$r:0000C651                 align 4
.rdata$r:0000C651 _rdata$r        ends
.rdata$r:0000C651
.rdata$r:0000C654 ; ===========================================================================
.rdata$r:0000C654
.rdata$r:0000C654 ; Segment type: Pure data
.rdata$r:0000C654 ; Segment permissions: Read
.rdata$r:0000C654 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000C654                 assume cs:_rdata$r
.rdata$r:0000C654                 ;org 0C654h
.rdata$r:0000C654 ; COMDAT (pick any)
.rdata$r:0000C654                 public ??_R1A@?0A@EA@CBenchRandomGenerator@@8
.rdata$r:0000C654 ; CBenchRandomGenerator::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000C654 ??_R1A@?0A@EA@CBenchRandomGenerator@@8 dd offset ??_R0?AVCBenchRandomGenerator@@@8
.rdata$r:0000C654                                         ; DATA XREF: .rdata$r:CBenchRandomGenerator::`RTTI Base Class Array'o
.rdata$r:0000C654                                         ; CBenchRandomGenerator `RTTI Type Descriptor'
.rdata$r:0000C658                 db    1
.rdata$r:0000C659                 db    0
.rdata$r:0000C65A                 db    0
.rdata$r:0000C65B                 db    0
.rdata$r:0000C65C                 db    0
.rdata$r:0000C65D                 db    0
.rdata$r:0000C65E                 db    0
.rdata$r:0000C65F                 db    0
.rdata$r:0000C660                 db 0FFh
.rdata$r:0000C661                 db 0FFh
.rdata$r:0000C662                 db 0FFh
.rdata$r:0000C663                 db 0FFh
.rdata$r:0000C664                 db    0
.rdata$r:0000C665                 db    0
.rdata$r:0000C666                 db    0
.rdata$r:0000C667                 db    0
.rdata$r:0000C668                 db  40h ; @
.rdata$r:0000C669                 db    0
.rdata$r:0000C66A                 db    0
.rdata$r:0000C66B                 db    0
.rdata$r:0000C66C                 dd offset ??_R3CBenchRandomGenerator@@8 ; CBenchRandomGenerator::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000C66C _rdata$r        ends
.rdata$r:0000C66C
.text:0000C670 ; ===========================================================================
.text:0000C670
.text:0000C670 ; Segment type: Pure code
.text:0000C670 ; Segment permissions: Read/Execute
.text:0000C670 _text           segment para public 'CODE' use32
.text:0000C670                 assume cs:_text
.text:0000C670                 ;org 0C670h
.text:0000C670 ; COMDAT (pick any)
.text:0000C670                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000C670
.text:0000C670 ; =============== S U B R O U T I N E =======================================
.text:0000C670
.text:0000C670 ; Attributes: bp-based frame
.text:0000C670
.text:0000C670 ; public: virtual void * __thiscall CBenchRandomGenerator::`scalar deleting destructor'(unsigned int)
.text:0000C670                 public ??_GCBenchRandomGenerator@@UAEPAXI@Z
.text:0000C670 ??_GCBenchRandomGenerator@@UAEPAXI@Z proc near
.text:0000C670
.text:0000C670 var_4           = dword ptr -4
.text:0000C670 arg_0           = dword ptr  8
.text:0000C670
.text:0000C670                 push    ebp
.text:0000C671                 mov     ebp, esp
.text:0000C673                 push    ecx
.text:0000C674                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000C67B                 mov     [ebp+var_4], ecx
.text:0000C67E                 mov     ecx, [ebp+var_4] ; this
.text:0000C681                 call    ??1CBenchRandomGenerator@@UAE@XZ ; CBenchRandomGenerator::~CBenchRandomGenerator(void)
.text:0000C686                 mov     eax, [ebp+arg_0]
.text:0000C689                 and     eax, 1
.text:0000C68C                 jz      short loc_C69A
.text:0000C68E                 mov     ecx, [ebp+var_4]
.text:0000C691                 push    ecx             ; void *
.text:0000C692                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000C697                 add     esp, 4
.text:0000C69A
.text:0000C69A loc_C69A:                               ; CODE XREF: CBenchRandomGenerator::`scalar deleting destructor'(uint)+1Cj
.text:0000C69A                 mov     eax, [ebp+var_4]
.text:0000C69D                 add     esp, 4
.text:0000C6A0                 cmp     ebp, esp
.text:0000C6A2                 call    __RTC_CheckEsp
.text:0000C6A7                 mov     esp, ebp
.text:0000C6A9                 pop     ebp
.text:0000C6AA                 retn    4
.text:0000C6AA ??_GCBenchRandomGenerator@@UAEPAXI@Z endp
.text:0000C6AA
.text:0000C6AA ; ---------------------------------------------------------------------------
.text:0000C6AD                 align 10h
.text:0000C6AD _text           ends
.text:0000C6AD
.text:0000C6B0 ; ===========================================================================
.text:0000C6B0
.text:0000C6B0 ; Segment type: Pure code
.text:0000C6B0 ; Segment permissions: Read/Execute
.text:0000C6B0 _text           segment para public 'CODE' use32
.text:0000C6B0                 assume cs:_text
.text:0000C6B0                 ;org 0C6B0h
.text:0000C6B0 ; COMDAT (pick any)
.text:0000C6B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000C6B0
.text:0000C6B0 ; =============== S U B R O U T I N E =======================================
.text:0000C6B0
.text:0000C6B0 ; Attributes: bp-based frame
.text:0000C6B0
.text:0000C6B0 ; _DWORD __thiscall CBenchEncoders::~CBenchEncoders(CBenchEncoders *__hidden this)
.text:0000C6B0                 public ??1CBenchEncoders@@QAE@XZ
.text:0000C6B0 ??1CBenchEncoders@@QAE@XZ proc near     ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+1EFp
.text:0000C6B0                                         ; MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+26Dp ...
.text:0000C6B0
.text:0000C6B0 var_10          = dword ptr -10h
.text:0000C6B0 var_C           = dword ptr -0Ch
.text:0000C6B0 var_8           = dword ptr -8
.text:0000C6B0 var_4           = dword ptr -4
.text:0000C6B0
.text:0000C6B0                 push    ebp
.text:0000C6B1                 mov     ebp, esp
.text:0000C6B3                 sub     esp, 10h
.text:0000C6B6                 mov     eax, 0CCCCCCCCh
.text:0000C6BB                 mov     [ebp+var_10], eax
.text:0000C6BE                 mov     [ebp+var_C], eax
.text:0000C6C1                 mov     [ebp+var_8], eax
.text:0000C6C4                 mov     [ebp+var_4], eax
.text:0000C6C7                 mov     [ebp+var_4], ecx
.text:0000C6CA                 mov     eax, [ebp+var_4]
.text:0000C6CD                 mov     ecx, [eax]
.text:0000C6CF                 mov     [ebp+var_C], ecx
.text:0000C6D2                 mov     edx, [ebp+var_C]
.text:0000C6D5                 mov     [ebp+var_8], edx
.text:0000C6D8                 cmp     [ebp+var_8], 0
.text:0000C6DC                 jz      short loc_C6ED
.text:0000C6DE                 push    3
.text:0000C6E0                 mov     ecx, [ebp+var_8]
.text:0000C6E3                 call    ??_ECEncoderInfo@@QAEPAXI@Z ; CEncoderInfo::`vector deleting destructor'(uint)
.text:0000C6E8                 mov     [ebp+var_10], eax
.text:0000C6EB                 jmp     short loc_C6F4
.text:0000C6ED ; ---------------------------------------------------------------------------
.text:0000C6ED
.text:0000C6ED loc_C6ED:                               ; CODE XREF: CBenchEncoders::~CBenchEncoders(void)+2Cj
.text:0000C6ED                 mov     [ebp+var_10], 0
.text:0000C6F4
.text:0000C6F4 loc_C6F4:                               ; CODE XREF: CBenchEncoders::~CBenchEncoders(void)+3Bj
.text:0000C6F4                 add     esp, 10h
.text:0000C6F7                 cmp     ebp, esp
.text:0000C6F9                 call    __RTC_CheckEsp
.text:0000C6FE                 mov     esp, ebp
.text:0000C700                 pop     ebp
.text:0000C701                 retn
.text:0000C701 ??1CBenchEncoders@@QAE@XZ endp
.text:0000C701
.text:0000C701 ; ---------------------------------------------------------------------------
.text:0000C702                 align 4
.text:0000C702 _text           ends
.text:0000C702
.text:0000C704 ; ===========================================================================
.text:0000C704
.text:0000C704 ; Segment type: Pure code
.text:0000C704 ; Segment permissions: Read/Execute
.text:0000C704 _text           segment para public 'CODE' use32
.text:0000C704                 assume cs:_text
.text:0000C704                 ;org 0C704h
.text:0000C704 ; COMDAT (pick any)
.text:0000C704                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000C704
.text:0000C704 ; =============== S U B R O U T I N E =======================================
.text:0000C704
.text:0000C704 ; Attributes: bp-based frame
.text:0000C704
.text:0000C704 ; public: __thiscall COneMethodInfo::COneMethodInfo(class COneMethodInfo const &)
.text:0000C704                 public ??0COneMethodInfo@@QAE@ABV0@@Z
.text:0000C704 ??0COneMethodInfo@@QAE@ABV0@@Z proc near
.text:0000C704                                         ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1AC0p
.text:0000C704                                         ; MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+43p
.text:0000C704
.text:0000C704 var_10          = dword ptr -10h
.text:0000C704 var_C           = dword ptr -0Ch
.text:0000C704 var_4           = dword ptr -4
.text:0000C704 arg_0           = dword ptr  8
.text:0000C704
.text:0000C704                 push    ebp
.text:0000C705                 mov     ebp, esp
.text:0000C707                 push    0FFFFFFFFh
.text:0000C709                 push    offset __ehhandler$??0COneMethodInfo@@QAE@ABV0@@Z
.text:0000C70E                 mov     eax, large fs:0
.text:0000C714                 push    eax
.text:0000C715                 push    ecx
.text:0000C716                 mov     [ebp+var_10], 0CCCCCCCCh
.text:0000C71D                 mov     eax, dword ptr ds:___security_cookie
.text:0000C722                 xor     eax, ebp
.text:0000C724                 push    eax
.text:0000C725                 lea     eax, [ebp+var_C]
.text:0000C728                 mov     large fs:0, eax
.text:0000C72E                 mov     [ebp+var_10], ecx
.text:0000C731                 mov     eax, [ebp+arg_0]
.text:0000C734                 push    eax
.text:0000C735                 mov     ecx, [ebp+var_10]
.text:0000C738                 call    ??0CMethodProps@@QAE@ABV0@@Z ; CMethodProps::CMethodProps(CMethodProps const &)
.text:0000C73D                 mov     [ebp+var_4], 0
.text:0000C744                 mov     ecx, [ebp+arg_0]
.text:0000C747                 add     ecx, 0Ch
.text:0000C74A                 push    ecx
.text:0000C74B                 mov     ecx, [ebp+var_10]
.text:0000C74E                 add     ecx, 0Ch
.text:0000C751                 call    ??0AString@@QAE@ABV0@@Z ; AString::AString(AString const &)
.text:0000C756                 mov     byte ptr [ebp+var_4], 1
.text:0000C75A                 mov     edx, [ebp+arg_0]
.text:0000C75D                 add     edx, 18h
.text:0000C760                 push    edx
.text:0000C761                 mov     ecx, [ebp+var_10]
.text:0000C764                 add     ecx, 18h
.text:0000C767                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:0000C76C                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000C773                 mov     eax, [ebp+var_10]
.text:0000C776                 mov     ecx, [ebp+var_C]
.text:0000C779                 mov     large fs:0, ecx
.text:0000C780                 pop     ecx
.text:0000C781                 add     esp, 10h
.text:0000C784                 cmp     ebp, esp
.text:0000C786                 call    __RTC_CheckEsp
.text:0000C78B                 mov     esp, ebp
.text:0000C78D                 pop     ebp
.text:0000C78E                 retn    4
.text:0000C78E ??0COneMethodInfo@@QAE@ABV0@@Z endp
.text:0000C78E
.text:0000C78E ; ---------------------------------------------------------------------------
.text:0000C791                 align 4
.text:0000C791 _text           ends
.text:0000C791
.text$x:0000C794 ; ===========================================================================
.text$x:0000C794
.text$x:0000C794 ; Segment type: Pure code
.text$x:0000C794 ; Segment permissions: Read/Execute
.text$x:0000C794 _text$x         segment para public 'CODE' use32
.text$x:0000C794                 assume cs:_text$x
.text$x:0000C794                 ;org 0C794h
.text$x:0000C794 ; COMDAT (pick associative to section at C704)
.text$x:0000C794                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000C794
.text$x:0000C794 ; =============== S U B R O U T I N E =======================================
.text$x:0000C794
.text$x:0000C794
.text$x:0000C794 __unwindfunclet$??0COneMethodInfo@@QAE@ABV0@@Z$0 proc near
.text$x:0000C794                                         ; DATA XREF: .xdata$x:0000C7C8o
.text$x:0000C794                 mov     ecx, [ebp-10h]  ; this
.text$x:0000C797                 jmp     ??1CMethodProps@@QAE@XZ ; CMethodProps::~CMethodProps(void)
.text$x:0000C797 __unwindfunclet$??0COneMethodInfo@@QAE@ABV0@@Z$0 endp
.text$x:0000C797
.text$x:0000C79C
.text$x:0000C79C ; =============== S U B R O U T I N E =======================================
.text$x:0000C79C
.text$x:0000C79C
.text$x:0000C79C __unwindfunclet$??0COneMethodInfo@@QAE@ABV0@@Z$1 proc near
.text$x:0000C79C                                         ; DATA XREF: .xdata$x:0000C7D0o
.text$x:0000C79C                 mov     ecx, [ebp-10h]
.text$x:0000C79F                 add     ecx, 0Ch        ; this
.text$x:0000C7A2                 jmp     ??1AString@@QAE@XZ ; AString::~AString(void)
.text$x:0000C7A2 __unwindfunclet$??0COneMethodInfo@@QAE@ABV0@@Z$1 endp
.text$x:0000C7A2
.text$x:0000C7A7
.text$x:0000C7A7 ; =============== S U B R O U T I N E =======================================
.text$x:0000C7A7
.text$x:0000C7A7
.text$x:0000C7A7 __ehhandler$??0COneMethodInfo@@QAE@ABV0@@Z proc near
.text$x:0000C7A7                                         ; DATA XREF: COneMethodInfo::COneMethodInfo(COneMethodInfo const &)+5o
.text$x:0000C7A7
.text$x:0000C7A7 arg_4           = dword ptr  8
.text$x:0000C7A7
.text$x:0000C7A7                 mov     edx, [esp+arg_4]
.text$x:0000C7AB                 lea     eax, [edx+0Ch]
.text$x:0000C7AE                 mov     ecx, [edx-8]
.text$x:0000C7B1                 xor     ecx, eax
.text$x:0000C7B3                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000C7B8                 mov     eax, offset __ehfuncinfo$??0COneMethodInfo@@QAE@ABV0@@Z
.text$x:0000C7BD                 jmp     ___CxxFrameHandler3
.text$x:0000C7BD __ehhandler$??0COneMethodInfo@@QAE@ABV0@@Z endp
.text$x:0000C7BD
.text$x:0000C7BD ; ---------------------------------------------------------------------------
.text$x:0000C7C2                 align 4
.text$x:0000C7C2 _text$x         ends
.text$x:0000C7C2
.xdata$x:0000C7C4 ; ===========================================================================
.xdata$x:0000C7C4
.xdata$x:0000C7C4 ; Segment type: Pure data
.xdata$x:0000C7C4 ; Segment permissions: Read
.xdata$x:0000C7C4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C7C4                 assume cs:_xdata$x
.xdata$x:0000C7C4                 ;org 0C7C4h
.xdata$x:0000C7C4 ; COMDAT (pick associative to section at C704)
.xdata$x:0000C7C4 __unwindtable$??0COneMethodInfo@@QAE@ABV0@@Z db 0FFh
.xdata$x:0000C7C4                                         ; DATA XREF: .xdata$x:0000C7DCo
.xdata$x:0000C7C5                 db 0FFh
.xdata$x:0000C7C6                 db 0FFh
.xdata$x:0000C7C7                 db 0FFh
.xdata$x:0000C7C8                 dd offset __unwindfunclet$??0COneMethodInfo@@QAE@ABV0@@Z$0
.xdata$x:0000C7CC                 align 10h
.xdata$x:0000C7D0                 dd offset __unwindfunclet$??0COneMethodInfo@@QAE@ABV0@@Z$1
.xdata$x:0000C7D4 __ehfuncinfo$??0COneMethodInfo@@QAE@ABV0@@Z db  22h ; "
.xdata$x:0000C7D4                                         ; DATA XREF: __ehhandler$??0COneMethodInfo@@QAE@ABV0@@Z+11o
.xdata$x:0000C7D5                 db    5
.xdata$x:0000C7D6                 db  93h ; ô
.xdata$x:0000C7D7                 db  19h
.xdata$x:0000C7D8                 db    2
.xdata$x:0000C7D9                 db    0
.xdata$x:0000C7DA                 db    0
.xdata$x:0000C7DB                 db    0
.xdata$x:0000C7DC                 dd offset __unwindtable$??0COneMethodInfo@@QAE@ABV0@@Z
.xdata$x:0000C7E0                 db    0
.xdata$x:0000C7E1                 db    0
.xdata$x:0000C7E2                 db    0
.xdata$x:0000C7E3                 db    0
.xdata$x:0000C7E4                 db    0
.xdata$x:0000C7E5                 db    0
.xdata$x:0000C7E6                 db    0
.xdata$x:0000C7E7                 db    0
.xdata$x:0000C7E8                 db    0
.xdata$x:0000C7E9                 db    0
.xdata$x:0000C7EA                 db    0
.xdata$x:0000C7EB                 db    0
.xdata$x:0000C7EC                 db    0
.xdata$x:0000C7ED                 db    0
.xdata$x:0000C7EE                 db    0
.xdata$x:0000C7EF                 db    0
.xdata$x:0000C7F0                 db    0
.xdata$x:0000C7F1                 db    0
.xdata$x:0000C7F2                 db    0
.xdata$x:0000C7F3                 db    0
.xdata$x:0000C7F4                 db    1
.xdata$x:0000C7F5                 db    0
.xdata$x:0000C7F6                 db    0
.xdata$x:0000C7F7                 db    0
.xdata$x:0000C7F7 _xdata$x        ends
.xdata$x:0000C7F7
.text:0000C7F8 ; ===========================================================================
.text:0000C7F8
.text:0000C7F8 ; Segment type: Pure code
.text:0000C7F8 ; Segment permissions: Read/Execute
.text:0000C7F8 _text           segment para public 'CODE' use32
.text:0000C7F8                 assume cs:_text
.text:0000C7F8                 ;org 0C7F8h
.text:0000C7F8 ; COMDAT (pick any)
.text:0000C7F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000C7F8
.text:0000C7F8 ; =============== S U B R O U T I N E =======================================
.text:0000C7F8
.text:0000C7F8 ; Attributes: bp-based frame
.text:0000C7F8
.text:0000C7F8 ; _DWORD __thiscall CCreatedCoder::CCreatedCoder(CCreatedCoder *__hidden this)
.text:0000C7F8                 public ??0CCreatedCoder@@QAE@XZ
.text:0000C7F8 ??0CCreatedCoder@@QAE@XZ proc near      ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+195p
.text:0000C7F8                                         ; MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+345p
.text:0000C7F8
.text:0000C7F8 var_10          = dword ptr -10h
.text:0000C7F8 var_C           = dword ptr -0Ch
.text:0000C7F8 var_4           = dword ptr -4
.text:0000C7F8
.text:0000C7F8                 push    ebp
.text:0000C7F9                 mov     ebp, esp
.text:0000C7FB                 push    0FFFFFFFFh
.text:0000C7FD                 push    offset __ehhandler$??0CCreatedCoder@@QAE@XZ
.text:0000C802                 mov     eax, large fs:0
.text:0000C808                 push    eax
.text:0000C809                 push    ecx
.text:0000C80A                 mov     [ebp+var_10], 0CCCCCCCCh
.text:0000C811                 mov     eax, dword ptr ds:___security_cookie
.text:0000C816                 xor     eax, ebp
.text:0000C818                 push    eax
.text:0000C819                 lea     eax, [ebp+var_C]
.text:0000C81C                 mov     large fs:0, eax
.text:0000C822                 mov     [ebp+var_10], ecx
.text:0000C825                 mov     ecx, [ebp+var_10]
.text:0000C828                 call    ??0?$CMyComPtr@UICompressCoder@@@@QAE@XZ ; CMyComPtr<ICompressCoder>::CMyComPtr<ICompressCoder>(void)
.text:0000C82D                 mov     [ebp+var_4], 0
.text:0000C834                 mov     ecx, [ebp+var_10]
.text:0000C837                 add     ecx, 4
.text:0000C83A                 call    ??0?$CMyComPtr@UICompressCoder2@@@@QAE@XZ ; CMyComPtr<ICompressCoder2>::CMyComPtr<ICompressCoder2>(void)
.text:0000C83F                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000C846                 mov     eax, [ebp+var_10]
.text:0000C849                 mov     ecx, [ebp+var_C]
.text:0000C84C                 mov     large fs:0, ecx
.text:0000C853                 pop     ecx
.text:0000C854                 add     esp, 10h
.text:0000C857                 cmp     ebp, esp
.text:0000C859                 call    __RTC_CheckEsp
.text:0000C85E                 mov     esp, ebp
.text:0000C860                 pop     ebp
.text:0000C861                 retn
.text:0000C861 ??0CCreatedCoder@@QAE@XZ endp
.text:0000C861
.text:0000C861 ; ---------------------------------------------------------------------------
.text:0000C862                 align 4
.text:0000C862 _text           ends
.text:0000C862
.text$x:0000C864 ; ===========================================================================
.text$x:0000C864
.text$x:0000C864 ; Segment type: Pure code
.text$x:0000C864 ; Segment permissions: Read/Execute
.text$x:0000C864 _text$x         segment para public 'CODE' use32
.text$x:0000C864                 assume cs:_text$x
.text$x:0000C864                 ;org 0C864h
.text$x:0000C864 ; COMDAT (pick associative to section at C7F8)
.text$x:0000C864                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000C864
.text$x:0000C864 ; =============== S U B R O U T I N E =======================================
.text$x:0000C864
.text$x:0000C864
.text$x:0000C864 __unwindfunclet$??0CCreatedCoder@@QAE@XZ$0 proc near
.text$x:0000C864                                         ; DATA XREF: .xdata$x:0000C88Co
.text$x:0000C864                 mov     ecx, [ebp-10h]
.text$x:0000C867                 jmp     ??1?$CMyComPtr@UICompressCoder@@@@QAE@XZ ; CMyComPtr<ICompressCoder>::~CMyComPtr<ICompressCoder>(void)
.text$x:0000C867 __unwindfunclet$??0CCreatedCoder@@QAE@XZ$0 endp
.text$x:0000C867
.text$x:0000C86C
.text$x:0000C86C ; =============== S U B R O U T I N E =======================================
.text$x:0000C86C
.text$x:0000C86C
.text$x:0000C86C __ehhandler$??0CCreatedCoder@@QAE@XZ proc near
.text$x:0000C86C                                         ; DATA XREF: CCreatedCoder::CCreatedCoder(void)+5o
.text$x:0000C86C
.text$x:0000C86C arg_4           = dword ptr  8
.text$x:0000C86C
.text$x:0000C86C                 mov     edx, [esp+arg_4]
.text$x:0000C870                 lea     eax, [edx+0Ch]
.text$x:0000C873                 mov     ecx, [edx-8]
.text$x:0000C876                 xor     ecx, eax
.text$x:0000C878                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000C87D                 mov     eax, offset __ehfuncinfo$??0CCreatedCoder@@QAE@XZ
.text$x:0000C882                 jmp     ___CxxFrameHandler3
.text$x:0000C882 __ehhandler$??0CCreatedCoder@@QAE@XZ endp
.text$x:0000C882
.text$x:0000C882 ; ---------------------------------------------------------------------------
.text$x:0000C887                 align 4
.text$x:0000C887 _text$x         ends
.text$x:0000C887
.xdata$x:0000C888 ; ===========================================================================
.xdata$x:0000C888
.xdata$x:0000C888 ; Segment type: Pure data
.xdata$x:0000C888 ; Segment permissions: Read
.xdata$x:0000C888 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C888                 assume cs:_xdata$x
.xdata$x:0000C888                 ;org 0C888h
.xdata$x:0000C888 ; COMDAT (pick associative to section at C7F8)
.xdata$x:0000C888 __unwindtable$??0CCreatedCoder@@QAE@XZ db 0FFh
.xdata$x:0000C888                                         ; DATA XREF: .xdata$x:0000C898o
.xdata$x:0000C889                 db 0FFh
.xdata$x:0000C88A                 db 0FFh
.xdata$x:0000C88B                 db 0FFh
.xdata$x:0000C88C                 dd offset __unwindfunclet$??0CCreatedCoder@@QAE@XZ$0
.xdata$x:0000C890 __ehfuncinfo$??0CCreatedCoder@@QAE@XZ db  22h ; "
.xdata$x:0000C890                                         ; DATA XREF: __ehhandler$??0CCreatedCoder@@QAE@XZ+11o
.xdata$x:0000C891                 db    5
.xdata$x:0000C892                 db  93h ; ô
.xdata$x:0000C893                 db  19h
.xdata$x:0000C894                 db    1
.xdata$x:0000C895                 db    0
.xdata$x:0000C896                 db    0
.xdata$x:0000C897                 db    0
.xdata$x:0000C898                 dd offset __unwindtable$??0CCreatedCoder@@QAE@XZ
.xdata$x:0000C89C                 db    0
.xdata$x:0000C89D                 db    0
.xdata$x:0000C89E                 db    0
.xdata$x:0000C89F                 db    0
.xdata$x:0000C8A0                 db    0
.xdata$x:0000C8A1                 db    0
.xdata$x:0000C8A2                 db    0
.xdata$x:0000C8A3                 db    0
.xdata$x:0000C8A4                 db    0
.xdata$x:0000C8A5                 db    0
.xdata$x:0000C8A6                 db    0
.xdata$x:0000C8A7                 db    0
.xdata$x:0000C8A8                 db    0
.xdata$x:0000C8A9                 db    0
.xdata$x:0000C8AA                 db    0
.xdata$x:0000C8AB                 db    0
.xdata$x:0000C8AC                 db    0
.xdata$x:0000C8AD                 db    0
.xdata$x:0000C8AE                 db    0
.xdata$x:0000C8AF                 db    0
.xdata$x:0000C8B0                 db    1
.xdata$x:0000C8B1                 db    0
.xdata$x:0000C8B2                 db    0
.xdata$x:0000C8B3                 db    0
.xdata$x:0000C8B3 _xdata$x        ends
.xdata$x:0000C8B3
.text:0000C8B4 ; ===========================================================================
.text:0000C8B4
.text:0000C8B4 ; Segment type: Pure code
.text:0000C8B4 ; Segment permissions: Read/Execute
.text:0000C8B4 _text           segment para public 'CODE' use32
.text:0000C8B4                 assume cs:_text
.text:0000C8B4                 ;org 0C8B4h
.text:0000C8B4 ; COMDAT (pick any)
.text:0000C8B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000C8B4
.text:0000C8B4 ; =============== S U B R O U T I N E =======================================
.text:0000C8B4
.text:0000C8B4 ; Attributes: bp-based frame
.text:0000C8B4
.text:0000C8B4 ; _DWORD __thiscall CCreatedCoder::~CCreatedCoder(CCreatedCoder *__hidden this)
.text:0000C8B4                 public ??1CCreatedCoder@@QAE@XZ
.text:0000C8B4 ??1CCreatedCoder@@QAE@XZ proc near      ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+1E3p
.text:0000C8B4                                         ; MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+261p ...
.text:0000C8B4
.text:0000C8B4 var_10          = dword ptr -10h
.text:0000C8B4 var_C           = dword ptr -0Ch
.text:0000C8B4 var_4           = dword ptr -4
.text:0000C8B4
.text:0000C8B4                 push    ebp
.text:0000C8B5                 mov     ebp, esp
.text:0000C8B7                 push    0FFFFFFFFh
.text:0000C8B9                 push    offset __ehhandler$??1CCreatedCoder@@QAE@XZ
.text:0000C8BE                 mov     eax, large fs:0
.text:0000C8C4                 push    eax
.text:0000C8C5                 push    ecx
.text:0000C8C6                 mov     [ebp+var_10], 0CCCCCCCCh
.text:0000C8CD                 mov     eax, dword ptr ds:___security_cookie
.text:0000C8D2                 xor     eax, ebp
.text:0000C8D4                 push    eax
.text:0000C8D5                 lea     eax, [ebp+var_C]
.text:0000C8D8                 mov     large fs:0, eax
.text:0000C8DE                 mov     [ebp+var_10], ecx
.text:0000C8E1                 mov     [ebp+var_4], 0
.text:0000C8E8                 mov     ecx, [ebp+var_10]
.text:0000C8EB                 add     ecx, 4
.text:0000C8EE                 call    ??1?$CMyComPtr@UICompressCoder2@@@@QAE@XZ ; CMyComPtr<ICompressCoder2>::~CMyComPtr<ICompressCoder2>(void)
.text:0000C8F3                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000C8FA                 mov     ecx, [ebp+var_10]
.text:0000C8FD                 call    ??1?$CMyComPtr@UICompressCoder@@@@QAE@XZ ; CMyComPtr<ICompressCoder>::~CMyComPtr<ICompressCoder>(void)
.text:0000C902                 mov     ecx, [ebp+var_C]
.text:0000C905                 mov     large fs:0, ecx
.text:0000C90C                 pop     ecx
.text:0000C90D                 add     esp, 10h
.text:0000C910                 cmp     ebp, esp
.text:0000C912                 call    __RTC_CheckEsp
.text:0000C917                 mov     esp, ebp
.text:0000C919                 pop     ebp
.text:0000C91A                 retn
.text:0000C91A ??1CCreatedCoder@@QAE@XZ endp
.text:0000C91A
.text:0000C91A ; ---------------------------------------------------------------------------
.text:0000C91B                 align 4
.text:0000C91B _text           ends
.text:0000C91B
.text$x:0000C91C ; ===========================================================================
.text$x:0000C91C
.text$x:0000C91C ; Segment type: Pure code
.text$x:0000C91C ; Segment permissions: Read/Execute
.text$x:0000C91C _text$x         segment para public 'CODE' use32
.text$x:0000C91C                 assume cs:_text$x
.text$x:0000C91C                 ;org 0C91Ch
.text$x:0000C91C ; COMDAT (pick associative to section at C8B4)
.text$x:0000C91C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000C91C
.text$x:0000C91C ; =============== S U B R O U T I N E =======================================
.text$x:0000C91C
.text$x:0000C91C
.text$x:0000C91C __unwindfunclet$??1CCreatedCoder@@QAE@XZ$0 proc near
.text$x:0000C91C                                         ; DATA XREF: .xdata$x:0000C944o
.text$x:0000C91C                 mov     ecx, [ebp-10h]
.text$x:0000C91F                 jmp     ??1?$CMyComPtr@UICompressCoder@@@@QAE@XZ ; CMyComPtr<ICompressCoder>::~CMyComPtr<ICompressCoder>(void)
.text$x:0000C91F __unwindfunclet$??1CCreatedCoder@@QAE@XZ$0 endp
.text$x:0000C91F
.text$x:0000C924
.text$x:0000C924 ; =============== S U B R O U T I N E =======================================
.text$x:0000C924
.text$x:0000C924
.text$x:0000C924 __ehhandler$??1CCreatedCoder@@QAE@XZ proc near
.text$x:0000C924                                         ; DATA XREF: CCreatedCoder::~CCreatedCoder(void)+5o
.text$x:0000C924
.text$x:0000C924 arg_4           = dword ptr  8
.text$x:0000C924
.text$x:0000C924                 mov     edx, [esp+arg_4]
.text$x:0000C928                 lea     eax, [edx+0Ch]
.text$x:0000C92B                 mov     ecx, [edx-8]
.text$x:0000C92E                 xor     ecx, eax
.text$x:0000C930                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000C935                 mov     eax, offset __ehfuncinfo$??1CCreatedCoder@@QAE@XZ
.text$x:0000C93A                 jmp     ___CxxFrameHandler3
.text$x:0000C93A __ehhandler$??1CCreatedCoder@@QAE@XZ endp
.text$x:0000C93A
.text$x:0000C93A ; ---------------------------------------------------------------------------
.text$x:0000C93F                 align 10h
.text$x:0000C93F _text$x         ends
.text$x:0000C93F
.xdata$x:0000C940 ; ===========================================================================
.xdata$x:0000C940
.xdata$x:0000C940 ; Segment type: Pure data
.xdata$x:0000C940 ; Segment permissions: Read
.xdata$x:0000C940 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C940                 assume cs:_xdata$x
.xdata$x:0000C940                 ;org 0C940h
.xdata$x:0000C940 ; COMDAT (pick associative to section at C8B4)
.xdata$x:0000C940 __unwindtable$??1CCreatedCoder@@QAE@XZ db 0FFh
.xdata$x:0000C940                                         ; DATA XREF: .xdata$x:0000C950o
.xdata$x:0000C941                 db 0FFh
.xdata$x:0000C942                 db 0FFh
.xdata$x:0000C943                 db 0FFh
.xdata$x:0000C944                 dd offset __unwindfunclet$??1CCreatedCoder@@QAE@XZ$0
.xdata$x:0000C948 __ehfuncinfo$??1CCreatedCoder@@QAE@XZ db  22h ; "
.xdata$x:0000C948                                         ; DATA XREF: __ehhandler$??1CCreatedCoder@@QAE@XZ+11o
.xdata$x:0000C949                 db    5
.xdata$x:0000C94A                 db  93h ; ô
.xdata$x:0000C94B                 db  19h
.xdata$x:0000C94C                 db    1
.xdata$x:0000C94D                 db    0
.xdata$x:0000C94E                 db    0
.xdata$x:0000C94F                 db    0
.xdata$x:0000C950                 dd offset __unwindtable$??1CCreatedCoder@@QAE@XZ
.xdata$x:0000C954                 db    0
.xdata$x:0000C955                 db    0
.xdata$x:0000C956                 db    0
.xdata$x:0000C957                 db    0
.xdata$x:0000C958                 db    0
.xdata$x:0000C959                 db    0
.xdata$x:0000C95A                 db    0
.xdata$x:0000C95B                 db    0
.xdata$x:0000C95C                 db    0
.xdata$x:0000C95D                 db    0
.xdata$x:0000C95E                 db    0
.xdata$x:0000C95F                 db    0
.xdata$x:0000C960                 db    0
.xdata$x:0000C961                 db    0
.xdata$x:0000C962                 db    0
.xdata$x:0000C963                 db    0
.xdata$x:0000C964                 db    0
.xdata$x:0000C965                 db    0
.xdata$x:0000C966                 db    0
.xdata$x:0000C967                 db    0
.xdata$x:0000C968                 db    1
.xdata$x:0000C969                 db    0
.xdata$x:0000C96A                 db    0
.xdata$x:0000C96B                 db    0
.xdata$x:0000C96B _xdata$x        ends
.xdata$x:0000C96B
.text:0000C96C ; ===========================================================================
.text:0000C96C
.text:0000C96C ; Segment type: Pure code
.text:0000C96C ; Segment permissions: Read/Execute
.text:0000C96C _text           segment para public 'CODE' use32
.text:0000C96C                 assume cs:_text
.text:0000C96C                 ;org 0C96Ch
.text:0000C96C ; COMDAT (pick any)
.text:0000C96C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000C96C
.text:0000C96C ; =============== S U B R O U T I N E =======================================
.text:0000C96C
.text:0000C96C ; Attributes: bp-based frame
.text:0000C96C
.text:0000C96C ; public: class COneMethodInfo & __thiscall COneMethodInfo::operator=(class COneMethodInfo const &)
.text:0000C96C                 public ??4COneMethodInfo@@QAEAAV0@ABV0@@Z
.text:0000C96C ??4COneMethodInfo@@QAEAAV0@ABV0@@Z proc near
.text:0000C96C                                         ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+4C4p
.text:0000C96C
.text:0000C96C var_4           = dword ptr -4
.text:0000C96C arg_0           = dword ptr  8
.text:0000C96C
.text:0000C96C                 push    ebp
.text:0000C96D                 mov     ebp, esp
.text:0000C96F                 push    ecx
.text:0000C970                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000C977                 mov     [ebp+var_4], ecx
.text:0000C97A                 mov     eax, [ebp+arg_0]
.text:0000C97D                 push    eax
.text:0000C97E                 mov     ecx, [ebp+var_4]
.text:0000C981                 call    ??4CMethodProps@@QAEAAV0@ABV0@@Z ; CMethodProps::operator=(CMethodProps const &)
.text:0000C986                 mov     ecx, [ebp+arg_0]
.text:0000C989                 add     ecx, 0Ch
.text:0000C98C                 push    ecx
.text:0000C98D                 mov     ecx, [ebp+var_4]
.text:0000C990                 add     ecx, 0Ch
.text:0000C993                 call    ??4AString@@QAEAAV0@ABV0@@Z ; AString::operator=(AString const &)
.text:0000C998                 mov     edx, [ebp+arg_0]
.text:0000C99B                 add     edx, 18h
.text:0000C99E                 push    edx
.text:0000C99F                 mov     ecx, [ebp+var_4]
.text:0000C9A2                 add     ecx, 18h
.text:0000C9A5                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:0000C9AA                 mov     eax, [ebp+var_4]
.text:0000C9AD                 add     esp, 4
.text:0000C9B0                 cmp     ebp, esp
.text:0000C9B2                 call    __RTC_CheckEsp
.text:0000C9B7                 mov     esp, ebp
.text:0000C9B9                 pop     ebp
.text:0000C9BA                 retn    4
.text:0000C9BA ??4COneMethodInfo@@QAEAAV0@ABV0@@Z endp
.text:0000C9BA
.text:0000C9BA ; ---------------------------------------------------------------------------
.text:0000C9BD                 align 10h
.text:0000C9BD _text           ends
.text:0000C9BD
.text:0000C9C0 ; ===========================================================================
.text:0000C9C0
.text:0000C9C0 ; Segment type: Pure code
.text:0000C9C0 ; Segment permissions: Read/Execute
.text:0000C9C0 _text           segment para public 'CODE' use32
.text:0000C9C0                 assume cs:_text
.text:0000C9C0                 ;org 0C9C0h
.text:0000C9C0 ; COMDAT (pick any)
.text:0000C9C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000C9C0
.text:0000C9C0 ; =============== S U B R O U T I N E =======================================
.text:0000C9C0
.text:0000C9C0 ; Attributes: bp-based frame
.text:0000C9C0
.text:0000C9C0 ; _DWORD __thiscall CBenchProgressStatus::CBenchProgressStatus(CBenchProgressStatus *__hidden this)
.text:0000C9C0                 public ??0CBenchProgressStatus@@QAE@XZ
.text:0000C9C0 ??0CBenchProgressStatus@@QAE@XZ proc near
.text:0000C9C0                                         ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+548p
.text:0000C9C0
.text:0000C9C0 var_4           = dword ptr -4
.text:0000C9C0
.text:0000C9C0                 push    ebp
.text:0000C9C1                 mov     ebp, esp
.text:0000C9C3                 push    ecx
.text:0000C9C4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000C9CB                 mov     [ebp+var_4], ecx
.text:0000C9CE                 mov     ecx, [ebp+var_4] ; this
.text:0000C9D1                 call    ??0CCriticalSection@NSynchronization@NWindows@@QAE@XZ ; NWindows::NSynchronization::CCriticalSection::CCriticalSection(void)
.text:0000C9D6                 mov     eax, [ebp+var_4]
.text:0000C9D9                 add     esp, 4
.text:0000C9DC                 cmp     ebp, esp
.text:0000C9DE                 call    __RTC_CheckEsp
.text:0000C9E3                 mov     esp, ebp
.text:0000C9E5                 pop     ebp
.text:0000C9E6                 retn
.text:0000C9E6 ??0CBenchProgressStatus@@QAE@XZ endp
.text:0000C9E6
.text:0000C9E6 ; ---------------------------------------------------------------------------
.text:0000C9E7                 align 4
.text:0000C9E7 _text           ends
.text:0000C9E7
.text:0000C9E8 ; ===========================================================================
.text:0000C9E8
.text:0000C9E8 ; Segment type: Pure code
.text:0000C9E8 ; Segment permissions: Read/Execute
.text:0000C9E8 _text           segment para public 'CODE' use32
.text:0000C9E8                 assume cs:_text
.text:0000C9E8                 ;org 0C9E8h
.text:0000C9E8 ; COMDAT (pick any)
.text:0000C9E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000C9E8
.text:0000C9E8 ; =============== S U B R O U T I N E =======================================
.text:0000C9E8
.text:0000C9E8 ; Attributes: bp-based frame
.text:0000C9E8
.text:0000C9E8 ; _DWORD __thiscall NWindows::NSynchronization::CCriticalSection::CCriticalSection(NWindows::NSynchronization::CCriticalSection *__hidden this)
.text:0000C9E8                 public ??0CCriticalSection@NSynchronization@NWindows@@QAE@XZ
.text:0000C9E8 ??0CCriticalSection@NSynchronization@NWindows@@QAE@XZ proc near
.text:0000C9E8                                         ; CODE XREF: CBenchProgressStatus::CBenchProgressStatus(void)+11p
.text:0000C9E8
.text:0000C9E8 var_4           = dword ptr -4
.text:0000C9E8
.text:0000C9E8                 push    ebp
.text:0000C9E9                 mov     ebp, esp
.text:0000C9EB                 push    ecx
.text:0000C9EC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000C9F3                 mov     [ebp+var_4], ecx
.text:0000C9F6                 mov     eax, [ebp+var_4]
.text:0000C9F9                 push    eax
.text:0000C9FA                 call    _CriticalSection_Init@4 ; CriticalSection_Init(x)
.text:0000C9FF                 mov     eax, [ebp+var_4]
.text:0000CA02                 add     esp, 4
.text:0000CA05                 cmp     ebp, esp
.text:0000CA07                 call    __RTC_CheckEsp
.text:0000CA0C                 mov     esp, ebp
.text:0000CA0E                 pop     ebp
.text:0000CA0F                 retn
.text:0000CA0F ??0CCriticalSection@NSynchronization@NWindows@@QAE@XZ endp
.text:0000CA0F
.text:0000CA0F _text           ends
.text:0000CA0F
.text:0000CA10 ; ===========================================================================
.text:0000CA10
.text:0000CA10 ; Segment type: Pure code
.text:0000CA10 ; Segment permissions: Read/Execute
.text:0000CA10 _text           segment para public 'CODE' use32
.text:0000CA10                 assume cs:_text
.text:0000CA10                 ;org 0CA10h
.text:0000CA10 ; COMDAT (pick any)
.text:0000CA10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000CA10
.text:0000CA10 ; =============== S U B R O U T I N E =======================================
.text:0000CA10
.text:0000CA10 ; Attributes: bp-based frame
.text:0000CA10
.text:0000CA10 ; _DWORD __thiscall CBenchProgressStatus::~CBenchProgressStatus(CBenchProgressStatus *__hidden this)
.text:0000CA10                 public ??1CBenchProgressStatus@@QAE@XZ
.text:0000CA10 ??1CBenchProgressStatus@@QAE@XZ proc near
.text:0000CA10                                         ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+70Ep
.text:0000CA10                                         ; MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+76Bp ...
.text:0000CA10
.text:0000CA10 var_4           = dword ptr -4
.text:0000CA10
.text:0000CA10                 push    ebp
.text:0000CA11                 mov     ebp, esp
.text:0000CA13                 push    ecx
.text:0000CA14                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000CA1B                 mov     [ebp+var_4], ecx
.text:0000CA1E                 mov     ecx, [ebp+var_4] ; this
.text:0000CA21                 call    ??1CCriticalSection@NSynchronization@NWindows@@QAE@XZ ; NWindows::NSynchronization::CCriticalSection::~CCriticalSection(void)
.text:0000CA26                 add     esp, 4
.text:0000CA29                 cmp     ebp, esp
.text:0000CA2B                 call    __RTC_CheckEsp
.text:0000CA30                 mov     esp, ebp
.text:0000CA32                 pop     ebp
.text:0000CA33                 retn
.text:0000CA33 ??1CBenchProgressStatus@@QAE@XZ endp
.text:0000CA33
.text:0000CA33 _text           ends
.text:0000CA33
.text:0000CA34 ; ===========================================================================
.text:0000CA34
.text:0000CA34 ; Segment type: Pure code
.text:0000CA34 ; Segment permissions: Read/Execute
.text:0000CA34 _text           segment para public 'CODE' use32
.text:0000CA34                 assume cs:_text
.text:0000CA34                 ;org 0CA34h
.text:0000CA34 ; COMDAT (pick any)
.text:0000CA34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000CA34
.text:0000CA34 ; =============== S U B R O U T I N E =======================================
.text:0000CA34
.text:0000CA34 ; Attributes: bp-based frame
.text:0000CA34
.text:0000CA34 ; _DWORD __thiscall NWindows::NSynchronization::CCriticalSection::~CCriticalSection(NWindows::NSynchronization::CCriticalSection *__hidden this)
.text:0000CA34                 public ??1CCriticalSection@NSynchronization@NWindows@@QAE@XZ
.text:0000CA34 ??1CCriticalSection@NSynchronization@NWindows@@QAE@XZ proc near
.text:0000CA34                                         ; CODE XREF: CBenchProgressStatus::~CBenchProgressStatus(void)+11p
.text:0000CA34
.text:0000CA34 lpCriticalSection= dword ptr -4
.text:0000CA34
.text:0000CA34                 push    ebp
.text:0000CA35                 mov     ebp, esp
.text:0000CA37                 push    ecx
.text:0000CA38                 push    esi
.text:0000CA39                 mov     [ebp+lpCriticalSection], 0CCCCCCCCh
.text:0000CA40                 mov     [ebp+lpCriticalSection], ecx
.text:0000CA43                 mov     esi, esp
.text:0000CA45                 mov     eax, [ebp+lpCriticalSection]
.text:0000CA48                 push    eax             ; lpCriticalSection
.text:0000CA49                 call    dword ptr ds:__imp__DeleteCriticalSection@4 ; DeleteCriticalSection(x)
.text:0000CA4F                 cmp     esi, esp
.text:0000CA51                 call    __RTC_CheckEsp
.text:0000CA56                 pop     esi
.text:0000CA57                 add     esp, 4
.text:0000CA5A                 cmp     ebp, esp
.text:0000CA5C                 call    __RTC_CheckEsp
.text:0000CA61                 mov     esp, ebp
.text:0000CA63                 pop     ebp
.text:0000CA64                 retn
.text:0000CA64 ??1CCriticalSection@NSynchronization@NWindows@@QAE@XZ endp
.text:0000CA64
.text:0000CA64 ; ---------------------------------------------------------------------------
.text:0000CA65                 align 4
.text:0000CA65 _text           ends
.text:0000CA65
.text:0000CA68 ; ===========================================================================
.text:0000CA68
.text:0000CA68 ; Segment type: Pure code
.text:0000CA68 ; Segment permissions: Read/Execute
.text:0000CA68 _text           segment para public 'CODE' use32
.text:0000CA68                 assume cs:_text
.text:0000CA68                 ;org 0CA68h
.text:0000CA68 ; COMDAT (pick any)
.text:0000CA68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000CA68
.text:0000CA68 ; =============== S U B R O U T I N E =======================================
.text:0000CA68
.text:0000CA68 ; Attributes: bp-based frame
.text:0000CA68
.text:0000CA68 ; public: __thiscall CMethodProps::CMethodProps(class CMethodProps const &)
.text:0000CA68                 public ??0CMethodProps@@QAE@ABV0@@Z
.text:0000CA68 ??0CMethodProps@@QAE@ABV0@@Z proc near  ; CODE XREF: COneMethodInfo::COneMethodInfo(COneMethodInfo const &)+34p
.text:0000CA68
.text:0000CA68 var_4           = dword ptr -4
.text:0000CA68 arg_0           = dword ptr  8
.text:0000CA68
.text:0000CA68                 push    ebp
.text:0000CA69                 mov     ebp, esp
.text:0000CA6B                 push    ecx
.text:0000CA6C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000CA73                 mov     [ebp+var_4], ecx
.text:0000CA76                 mov     eax, [ebp+arg_0]
.text:0000CA79                 push    eax
.text:0000CA7A                 mov     ecx, [ebp+var_4]
.text:0000CA7D                 call    ??0CProps@@QAE@ABU0@@Z ; CProps::CProps(CProps const &)
.text:0000CA82                 mov     eax, [ebp+var_4]
.text:0000CA85                 add     esp, 4
.text:0000CA88                 cmp     ebp, esp
.text:0000CA8A                 call    __RTC_CheckEsp
.text:0000CA8F                 mov     esp, ebp
.text:0000CA91                 pop     ebp
.text:0000CA92                 retn    4
.text:0000CA92 ??0CMethodProps@@QAE@ABV0@@Z endp
.text:0000CA92
.text:0000CA92 ; ---------------------------------------------------------------------------
.text:0000CA95                 align 4
.text:0000CA95 _text           ends
.text:0000CA95
.text:0000CA98 ; ===========================================================================
.text:0000CA98
.text:0000CA98 ; Segment type: Pure code
.text:0000CA98 ; Segment permissions: Read/Execute
.text:0000CA98 _text           segment para public 'CODE' use32
.text:0000CA98                 assume cs:_text
.text:0000CA98                 ;org 0CA98h
.text:0000CA98 ; COMDAT (pick any)
.text:0000CA98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000CA98
.text:0000CA98 ; =============== S U B R O U T I N E =======================================
.text:0000CA98
.text:0000CA98 ; Attributes: bp-based frame
.text:0000CA98
.text:0000CA98 ; public: class CMethodProps & __thiscall CMethodProps::operator=(class CMethodProps const &)
.text:0000CA98                 public ??4CMethodProps@@QAEAAV0@ABV0@@Z
.text:0000CA98 ??4CMethodProps@@QAEAAV0@ABV0@@Z proc near
.text:0000CA98                                         ; CODE XREF: COneMethodInfo::operator=(COneMethodInfo const &)+15p
.text:0000CA98
.text:0000CA98 var_4           = dword ptr -4
.text:0000CA98 arg_0           = dword ptr  8
.text:0000CA98
.text:0000CA98                 push    ebp
.text:0000CA99                 mov     ebp, esp
.text:0000CA9B                 push    ecx
.text:0000CA9C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000CAA3                 mov     [ebp+var_4], ecx
.text:0000CAA6                 mov     eax, [ebp+arg_0]
.text:0000CAA9                 push    eax
.text:0000CAAA                 mov     ecx, [ebp+var_4]
.text:0000CAAD                 call    ??4CProps@@QAEAAU0@ABU0@@Z ; CProps::operator=(CProps const &)
.text:0000CAB2                 mov     eax, [ebp+var_4]
.text:0000CAB5                 add     esp, 4
.text:0000CAB8                 cmp     ebp, esp
.text:0000CABA                 call    __RTC_CheckEsp
.text:0000CABF                 mov     esp, ebp
.text:0000CAC1                 pop     ebp
.text:0000CAC2                 retn    4
.text:0000CAC2 ??4CMethodProps@@QAEAAV0@ABV0@@Z endp
.text:0000CAC2
.text:0000CAC2 ; ---------------------------------------------------------------------------
.text:0000CAC5                 align 4
.text:0000CAC5 _text           ends
.text:0000CAC5
.text:0000CAC8 ; ===========================================================================
.text:0000CAC8
.text:0000CAC8 ; Segment type: Pure code
.text:0000CAC8 ; Segment permissions: Read/Execute
.text:0000CAC8 _text           segment para public 'CODE' use32
.text:0000CAC8                 assume cs:_text
.text:0000CAC8                 ;org 0CAC8h
.text:0000CAC8 ; COMDAT (pick any)
.text:0000CAC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000CAC8
.text:0000CAC8 ; =============== S U B R O U T I N E =======================================
.text:0000CAC8
.text:0000CAC8 ; Attributes: bp-based frame
.text:0000CAC8
.text:0000CAC8 ; public: __thiscall CProps::CProps(struct CProps const &)
.text:0000CAC8                 public ??0CProps@@QAE@ABU0@@Z
.text:0000CAC8 ??0CProps@@QAE@ABU0@@Z proc near        ; CODE XREF: CMethodProps::CMethodProps(CMethodProps const &)+15p
.text:0000CAC8
.text:0000CAC8 var_4           = dword ptr -4
.text:0000CAC8 arg_0           = dword ptr  8
.text:0000CAC8
.text:0000CAC8                 push    ebp
.text:0000CAC9                 mov     ebp, esp
.text:0000CACB                 push    ecx
.text:0000CACC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000CAD3                 mov     [ebp+var_4], ecx
.text:0000CAD6                 mov     eax, [ebp+arg_0]
.text:0000CAD9                 push    eax
.text:0000CADA                 mov     ecx, [ebp+var_4]
.text:0000CADD                 call    ??0?$CObjectVector@UCProp@@@@QAE@ABV0@@Z ; CObjectVector<CProp>::CObjectVector<CProp>(CObjectVector<CProp> const &)
.text:0000CAE2                 mov     eax, [ebp+var_4]
.text:0000CAE5                 add     esp, 4
.text:0000CAE8                 cmp     ebp, esp
.text:0000CAEA                 call    __RTC_CheckEsp
.text:0000CAEF                 mov     esp, ebp
.text:0000CAF1                 pop     ebp
.text:0000CAF2                 retn    4
.text:0000CAF2 ??0CProps@@QAE@ABU0@@Z endp
.text:0000CAF2
.text:0000CAF2 ; ---------------------------------------------------------------------------
.text:0000CAF5                 align 4
.text:0000CAF5 _text           ends
.text:0000CAF5
.text:0000CAF8 ; ===========================================================================
.text:0000CAF8
.text:0000CAF8 ; Segment type: Pure code
.text:0000CAF8 ; Segment permissions: Read/Execute
.text:0000CAF8 _text           segment para public 'CODE' use32
.text:0000CAF8                 assume cs:_text
.text:0000CAF8                 ;org 0CAF8h
.text:0000CAF8 ; COMDAT (pick any)
.text:0000CAF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000CAF8
.text:0000CAF8 ; =============== S U B R O U T I N E =======================================
.text:0000CAF8
.text:0000CAF8 ; Attributes: bp-based frame
.text:0000CAF8
.text:0000CAF8 ; public: struct CProps & __thiscall CProps::operator=(struct CProps const &)
.text:0000CAF8                 public ??4CProps@@QAEAAU0@ABU0@@Z
.text:0000CAF8 ??4CProps@@QAEAAU0@ABU0@@Z proc near    ; CODE XREF: CMethodProps::operator=(CMethodProps const &)+15p
.text:0000CAF8
.text:0000CAF8 var_4           = dword ptr -4
.text:0000CAF8 arg_0           = dword ptr  8
.text:0000CAF8
.text:0000CAF8                 push    ebp
.text:0000CAF9                 mov     ebp, esp
.text:0000CAFB                 push    ecx
.text:0000CAFC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000CB03                 mov     [ebp+var_4], ecx
.text:0000CB06                 mov     eax, [ebp+arg_0]
.text:0000CB09                 push    eax
.text:0000CB0A                 mov     ecx, [ebp+var_4]
.text:0000CB0D                 call    ??4?$CObjectVector@UCProp@@@@QAEAAV0@ABV0@@Z ; CObjectVector<CProp>::operator=(CObjectVector<CProp> const &)
.text:0000CB12                 mov     eax, [ebp+var_4]
.text:0000CB15                 add     esp, 4
.text:0000CB18                 cmp     ebp, esp
.text:0000CB1A                 call    __RTC_CheckEsp
.text:0000CB1F                 mov     esp, ebp
.text:0000CB21                 pop     ebp
.text:0000CB22                 retn    4
.text:0000CB22 ??4CProps@@QAEAAU0@ABU0@@Z endp
.text:0000CB22
.text:0000CB22 ; ---------------------------------------------------------------------------
.text:0000CB25                 align 4
.text:0000CB25 _text           ends
.text:0000CB25
.text:0000CB28 ; ===========================================================================
.text:0000CB28
.text:0000CB28 ; Segment type: Pure code
.text:0000CB28 ; Segment permissions: Read/Execute
.text:0000CB28 _text           segment para public 'CODE' use32
.text:0000CB28                 assume cs:_text
.text:0000CB28                 ;org 0CB28h
.text:0000CB28 ; COMDAT (pick any)
.text:0000CB28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000CB28
.text:0000CB28 ; =============== S U B R O U T I N E =======================================
.text:0000CB28
.text:0000CB28 ; Attributes: bp-based frame
.text:0000CB28
.text:0000CB28 ; void __thiscall CTotalBenchRes::SetSum(CTotalBenchRes *this, const struct CTotalBenchRes *, const struct CTotalBenchRes *)
.text:0000CB28                 public ?SetSum@CTotalBenchRes@@QAEXABU1@0@Z
.text:0000CB28 ?SetSum@CTotalBenchRes@@QAEXABU1@0@Z proc near
.text:0000CB28                                         ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1E1Ep
.text:0000CB28
.text:0000CB28 var_4           = dword ptr -4
.text:0000CB28 arg_0           = dword ptr  8
.text:0000CB28 arg_4           = dword ptr  0Ch
.text:0000CB28
.text:0000CB28                 push    ebp
.text:0000CB29                 mov     ebp, esp
.text:0000CB2B                 push    ecx
.text:0000CB2C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000CB33                 mov     [ebp+var_4], ecx
.text:0000CB36                 mov     eax, [ebp+arg_0]
.text:0000CB39                 mov     ecx, [ebp+arg_4]
.text:0000CB3C                 mov     edx, [eax+8]
.text:0000CB3F                 add     edx, [ecx+8]
.text:0000CB42                 mov     eax, [eax+0Ch]
.text:0000CB45                 adc     eax, [ecx+0Ch]
.text:0000CB48                 mov     ecx, [ebp+var_4]
.text:0000CB4B                 mov     [ecx+8], edx
.text:0000CB4E                 mov     [ecx+0Ch], eax
.text:0000CB51                 mov     edx, [ebp+arg_0]
.text:0000CB54                 mov     eax, [ebp+arg_4]
.text:0000CB57                 mov     ecx, [edx+10h]
.text:0000CB5A                 add     ecx, [eax+10h]
.text:0000CB5D                 mov     edx, [edx+14h]
.text:0000CB60                 adc     edx, [eax+14h]
.text:0000CB63                 mov     eax, [ebp+var_4]
.text:0000CB66                 mov     [eax+10h], ecx
.text:0000CB69                 mov     [eax+14h], edx
.text:0000CB6C                 mov     ecx, [ebp+arg_0]
.text:0000CB6F                 mov     edx, [ebp+arg_4]
.text:0000CB72                 mov     eax, [ecx+18h]
.text:0000CB75                 add     eax, [edx+18h]
.text:0000CB78                 mov     ecx, [ecx+1Ch]
.text:0000CB7B                 adc     ecx, [edx+1Ch]
.text:0000CB7E                 mov     edx, [ebp+var_4]
.text:0000CB81                 mov     [edx+18h], eax
.text:0000CB84                 mov     [edx+1Ch], ecx
.text:0000CB87                 mov     eax, [ebp+arg_0]
.text:0000CB8A                 mov     ecx, [ebp+arg_4]
.text:0000CB8D                 mov     edx, [eax]
.text:0000CB8F                 add     edx, [ecx]
.text:0000CB91                 mov     eax, [eax+4]
.text:0000CB94                 adc     eax, [ecx+4]
.text:0000CB97                 mov     ecx, [ebp+var_4]
.text:0000CB9A                 mov     [ecx], edx
.text:0000CB9C                 mov     [ecx+4], eax
.text:0000CB9F                 mov     esp, ebp
.text:0000CBA1                 pop     ebp
.text:0000CBA2                 retn    8
.text:0000CBA2 ?SetSum@CTotalBenchRes@@QAEXABU1@0@Z endp
.text:0000CBA2
.text:0000CBA2 ; ---------------------------------------------------------------------------
.text:0000CBA5                 align 4
.text:0000CBA5 _text           ends
.text:0000CBA5
.text:0000CBA8 ; ===========================================================================
.text:0000CBA8
.text:0000CBA8 ; Segment type: Pure code
.text:0000CBA8 ; Segment permissions: Read/Execute
.text:0000CBA8 _text           segment para public 'CODE' use32
.text:0000CBA8                 assume cs:_text
.text:0000CBA8                 ;org 0CBA8h
.text:0000CBA8 ; COMDAT (pick any)
.text:0000CBA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000CBA8
.text:0000CBA8 ; =============== S U B R O U T I N E =======================================
.text:0000CBA8
.text:0000CBA8 ; Attributes: bp-based frame
.text:0000CBA8
.text:0000CBA8 ; public: __thiscall CBenchCallbackToPrint::CBenchCallbackToPrint(void)
.text:0000CBA8                 public ??0CBenchCallbackToPrint@@QAE@XZ
.text:0000CBA8 ??0CBenchCallbackToPrint@@QAE@XZ proc near
.text:0000CBA8                                         ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1064p
.text:0000CBA8
.text:0000CBA8 var_4           = dword ptr -4
.text:0000CBA8
.text:0000CBA8                 push    ebp
.text:0000CBA9                 mov     ebp, esp
.text:0000CBAB                 push    ecx
.text:0000CBAC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000CBB3                 mov     [ebp+var_4], ecx
.text:0000CBB6                 mov     ecx, [ebp+var_4] ; this
.text:0000CBB9                 call    ??0IBenchCallback@@QAE@XZ ; IBenchCallback::IBenchCallback(void)
.text:0000CBBE                 mov     eax, [ebp+var_4]
.text:0000CBC1                 mov     dword ptr [eax], offset ??_7CBenchCallbackToPrint@@6B@ ; const CBenchCallbackToPrint::`vftable'
.text:0000CBC7                 mov     ecx, [ebp+var_4]
.text:0000CBCA                 add     ecx, 4
.text:0000CBCD                 call    ??0CBenchProps@@QAE@XZ ; CBenchProps::CBenchProps(void)
.text:0000CBD2                 mov     ecx, [ebp+var_4]
.text:0000CBD5                 mov     byte ptr [ecx+60h], 0
.text:0000CBD9                 mov     edx, [ebp+var_4]
.text:0000CBDC                 mov     dword ptr [edx+64h], 0
.text:0000CBE3                 mov     eax, [ebp+var_4]
.text:0000CBE6                 mov     byte ptr [eax+68h], 0
.text:0000CBEA                 mov     ecx, [ebp+var_4]
.text:0000CBED                 mov     dword ptr [ecx+70h], 0
.text:0000CBF4                 mov     dword ptr [ecx+74h], 0
.text:0000CBFB                 mov     edx, [ebp+var_4]
.text:0000CBFE                 mov     dword ptr [edx+78h], 1
.text:0000CC05                 mov     eax, [ebp+var_4]
.text:0000CC08                 mov     dword ptr [eax+7Ch], 1
.text:0000CC0F                 mov     eax, [ebp+var_4]
.text:0000CC12                 add     esp, 4
.text:0000CC15                 cmp     ebp, esp
.text:0000CC17                 call    __RTC_CheckEsp
.text:0000CC1C                 mov     esp, ebp
.text:0000CC1E                 pop     ebp
.text:0000CC1F                 retn
.text:0000CC1F ??0CBenchCallbackToPrint@@QAE@XZ endp
.text:0000CC1F
.text:0000CC1F _text           ends
.text:0000CC1F
.rdata:0000CC20 ; ===========================================================================
.rdata:0000CC20
.rdata:0000CC20 ; Segment type: Pure data
.rdata:0000CC20 ; Segment permissions: Read
.rdata:0000CC20 _rdata          segment dword public 'DATA' use32
.rdata:0000CC20                 assume cs:_rdata
.rdata:0000CC20                 ;org 0CC20h
.rdata:0000CC20 ; COMDAT (pick largest)
.rdata:0000CC20                 dd offset ??_R4CBenchCallbackToPrint@@6B@ ; const CBenchCallbackToPrint::`RTTI Complete Object Locator'
.rdata:0000CC24                 public ??_7CBenchCallbackToPrint@@6B@
.rdata:0000CC24 ; const CBenchCallbackToPrint::`vftable'
.rdata:0000CC24 ??_7CBenchCallbackToPrint@@6B@ dd offset ?SetFreq@CBenchCallbackToPrint@@UAEJ_N_K@Z
.rdata:0000CC24                                         ; DATA XREF: CBenchCallbackToPrint::CBenchCallbackToPrint(void)+19o
.rdata:0000CC24                                         ; CBenchCallbackToPrint::SetFreq(bool,unsigned __int64)
.rdata:0000CC28                 dd offset ?SetEncodeResult@CBenchCallbackToPrint@@UAEJABUCBenchInfo@@_N@Z ; CBenchCallbackToPrint::SetEncodeResult(CBenchInfo const &,bool)
.rdata:0000CC2C                 dd offset ?SetDecodeResult@CBenchCallbackToPrint@@UAEJABUCBenchInfo@@_N@Z ; CBenchCallbackToPrint::SetDecodeResult(CBenchInfo const &,bool)
.rdata:0000CC2C _rdata          ends
.rdata:0000CC2C
.rdata$r:0000CC30 ; ===========================================================================
.rdata$r:0000CC30
.rdata$r:0000CC30 ; Segment type: Pure data
.rdata$r:0000CC30 ; Segment permissions: Read
.rdata$r:0000CC30 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000CC30                 assume cs:_rdata$r
.rdata$r:0000CC30                 ;org 0CC30h
.rdata$r:0000CC30 ; COMDAT (pick any)
.rdata$r:0000CC30                 public ??_R4CBenchCallbackToPrint@@6B@
.rdata$r:0000CC30 ; const CBenchCallbackToPrint::`RTTI Complete Object Locator'
.rdata$r:0000CC30 ??_R4CBenchCallbackToPrint@@6B@ db    0 ; DATA XREF: .rdata:0000CC20o
.rdata$r:0000CC31                 db    0
.rdata$r:0000CC32                 db    0
.rdata$r:0000CC33                 db    0
.rdata$r:0000CC34                 db    0
.rdata$r:0000CC35                 db    0
.rdata$r:0000CC36                 db    0
.rdata$r:0000CC37                 db    0
.rdata$r:0000CC38                 db    0
.rdata$r:0000CC39                 db    0
.rdata$r:0000CC3A                 db    0
.rdata$r:0000CC3B                 db    0
.rdata$r:0000CC3C                 dd offset ??_R0?AUCBenchCallbackToPrint@@@8 ; CBenchCallbackToPrint `RTTI Type Descriptor'
.rdata$r:0000CC40                 dd offset ??_R3CBenchCallbackToPrint@@8 ; CBenchCallbackToPrint::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000CC40 _rdata$r        ends
.rdata$r:0000CC40
.data:0000CC44 ; ===========================================================================
.data:0000CC44
.data:0000CC44 ; Segment type: Pure data
.data:0000CC44 ; Segment permissions: Read/Write
.data:0000CC44 _data           segment dword public 'DATA' use32
.data:0000CC44                 assume cs:_data
.data:0000CC44                 ;org 0CC44h
.data:0000CC44 ; COMDAT (pick any)
.data:0000CC44                 public ??_R0?AUCBenchCallbackToPrint@@@8
.data:0000CC44 ; struct CBenchCallbackToPrint `RTTI Type Descriptor'
.data:0000CC44 ??_R0?AUCBenchCallbackToPrint@@@8 dd offset ??_7type_info@@6B@
.data:0000CC44                                         ; DATA XREF: .rdata$r:0000CC3Co
.data:0000CC44                                         ; .rdata$r:CBenchCallbackToPrint::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:0000CC44                                         ; const type_info::`vftable'
.data:0000CC48                 db    0
.data:0000CC49                 db    0
.data:0000CC4A                 db    0
.data:0000CC4B                 db    0
.data:0000CC4C                 db  2Eh ; .
.data:0000CC4D                 db  3Fh ; ?
.data:0000CC4E                 db  41h ; A
.data:0000CC4F                 db  55h ; U
.data:0000CC50                 db  43h ; C
.data:0000CC51                 db  42h ; B
.data:0000CC52                 db  65h ; e
.data:0000CC53                 db  6Eh ; n
.data:0000CC54                 db  63h ; c
.data:0000CC55                 db  68h ; h
.data:0000CC56                 db  43h ; C
.data:0000CC57                 db  61h ; a
.data:0000CC58                 db  6Ch ; l
.data:0000CC59                 db  6Ch ; l
.data:0000CC5A                 db  62h ; b
.data:0000CC5B                 db  61h ; a
.data:0000CC5C                 db  63h ; c
.data:0000CC5D                 db  6Bh ; k
.data:0000CC5E                 db  54h ; T
.data:0000CC5F                 db  6Fh ; o
.data:0000CC60                 db  50h ; P
.data:0000CC61                 db  72h ; r
.data:0000CC62                 db  69h ; i
.data:0000CC63                 db  6Eh ; n
.data:0000CC64                 db  74h ; t
.data:0000CC65                 db  40h ; @
.data:0000CC66                 db  40h ; @
.data:0000CC67                 db    0
.data:0000CC67 _data           ends
.data:0000CC67
.rdata$r:0000CC68 ; ===========================================================================
.rdata$r:0000CC68
.rdata$r:0000CC68 ; Segment type: Pure data
.rdata$r:0000CC68 ; Segment permissions: Read
.rdata$r:0000CC68 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000CC68                 assume cs:_rdata$r
.rdata$r:0000CC68                 ;org 0CC68h
.rdata$r:0000CC68 ; COMDAT (pick any)
.rdata$r:0000CC68                 public ??_R3CBenchCallbackToPrint@@8
.rdata$r:0000CC68 ; CBenchCallbackToPrint::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000CC68 ??_R3CBenchCallbackToPrint@@8 db    0   ; DATA XREF: .rdata$r:0000CC40o
.rdata$r:0000CC68                                         ; .rdata$r:0000CC9Co
.rdata$r:0000CC69                 db    0
.rdata$r:0000CC6A                 db    0
.rdata$r:0000CC6B                 db    0
.rdata$r:0000CC6C                 db    0
.rdata$r:0000CC6D                 db    0
.rdata$r:0000CC6E                 db    0
.rdata$r:0000CC6F                 db    0
.rdata$r:0000CC70                 db    2
.rdata$r:0000CC71                 db    0
.rdata$r:0000CC72                 db    0
.rdata$r:0000CC73                 db    0
.rdata$r:0000CC74                 dd offset ??_R2CBenchCallbackToPrint@@8 ; CBenchCallbackToPrint::`RTTI Base Class Array'
.rdata$r:0000CC74 _rdata$r        ends
.rdata$r:0000CC74
.rdata$r:0000CC78 ; ===========================================================================
.rdata$r:0000CC78
.rdata$r:0000CC78 ; Segment type: Pure data
.rdata$r:0000CC78 ; Segment permissions: Read
.rdata$r:0000CC78 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000CC78                 assume cs:_rdata$r
.rdata$r:0000CC78                 ;org 0CC78h
.rdata$r:0000CC78 ; COMDAT (pick any)
.rdata$r:0000CC78                 public ??_R2CBenchCallbackToPrint@@8
.rdata$r:0000CC78 ; CBenchCallbackToPrint::`RTTI Base Class Array'
.rdata$r:0000CC78 ??_R2CBenchCallbackToPrint@@8 dd offset ??_R1A@?0A@EA@CBenchCallbackToPrint@@8
.rdata$r:0000CC78                                         ; DATA XREF: .rdata$r:0000CC74o
.rdata$r:0000CC78                                         ; CBenchCallbackToPrint::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000CC7C                 dd offset ??_R1A@?0A@EA@IBenchCallback@@8 ; IBenchCallback::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000CC80                 db    0
.rdata$r:0000CC81                 align 4
.rdata$r:0000CC81 _rdata$r        ends
.rdata$r:0000CC81
.rdata$r:0000CC84 ; ===========================================================================
.rdata$r:0000CC84
.rdata$r:0000CC84 ; Segment type: Pure data
.rdata$r:0000CC84 ; Segment permissions: Read
.rdata$r:0000CC84 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000CC84                 assume cs:_rdata$r
.rdata$r:0000CC84                 ;org 0CC84h
.rdata$r:0000CC84 ; COMDAT (pick any)
.rdata$r:0000CC84                 public ??_R1A@?0A@EA@CBenchCallbackToPrint@@8
.rdata$r:0000CC84 ; CBenchCallbackToPrint::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000CC84 ??_R1A@?0A@EA@CBenchCallbackToPrint@@8 dd offset ??_R0?AUCBenchCallbackToPrint@@@8
.rdata$r:0000CC84                                         ; DATA XREF: .rdata$r:CBenchCallbackToPrint::`RTTI Base Class Array'o
.rdata$r:0000CC84                                         ; CBenchCallbackToPrint `RTTI Type Descriptor'
.rdata$r:0000CC88                 db    1
.rdata$r:0000CC89                 db    0
.rdata$r:0000CC8A                 db    0
.rdata$r:0000CC8B                 db    0
.rdata$r:0000CC8C                 db    0
.rdata$r:0000CC8D                 db    0
.rdata$r:0000CC8E                 db    0
.rdata$r:0000CC8F                 db    0
.rdata$r:0000CC90                 db 0FFh
.rdata$r:0000CC91                 db 0FFh
.rdata$r:0000CC92                 db 0FFh
.rdata$r:0000CC93                 db 0FFh
.rdata$r:0000CC94                 db    0
.rdata$r:0000CC95                 db    0
.rdata$r:0000CC96                 db    0
.rdata$r:0000CC97                 db    0
.rdata$r:0000CC98                 db  40h ; @
.rdata$r:0000CC99                 db    0
.rdata$r:0000CC9A                 db    0
.rdata$r:0000CC9B                 db    0
.rdata$r:0000CC9C                 dd offset ??_R3CBenchCallbackToPrint@@8 ; CBenchCallbackToPrint::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000CC9C _rdata$r        ends
.rdata$r:0000CC9C
.rdata$r:0000CCA0 ; ===========================================================================
.rdata$r:0000CCA0
.rdata$r:0000CCA0 ; Segment type: Pure data
.rdata$r:0000CCA0 ; Segment permissions: Read
.rdata$r:0000CCA0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000CCA0                 assume cs:_rdata$r
.rdata$r:0000CCA0                 ;org 0CCA0h
.rdata$r:0000CCA0 ; COMDAT (pick any)
.rdata$r:0000CCA0                 public ??_R1A@?0A@EA@IBenchCallback@@8
.rdata$r:0000CCA0 ; IBenchCallback::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000CCA0 ??_R1A@?0A@EA@IBenchCallback@@8 dd offset ??_R0?AUIBenchCallback@@@8
.rdata$r:0000CCA0                                         ; DATA XREF: .rdata$r:0000CC7Co
.rdata$r:0000CCA0                                         ; .rdata$r:IBenchCallback::`RTTI Base Class Array'o
.rdata$r:0000CCA0                                         ; IBenchCallback `RTTI Type Descriptor'
.rdata$r:0000CCA4                 db    0
.rdata$r:0000CCA5                 db    0
.rdata$r:0000CCA6                 db    0
.rdata$r:0000CCA7                 db    0
.rdata$r:0000CCA8                 db    0
.rdata$r:0000CCA9                 db    0
.rdata$r:0000CCAA                 db    0
.rdata$r:0000CCAB                 db    0
.rdata$r:0000CCAC                 db 0FFh
.rdata$r:0000CCAD                 db 0FFh
.rdata$r:0000CCAE                 db 0FFh
.rdata$r:0000CCAF                 db 0FFh
.rdata$r:0000CCB0                 db    0
.rdata$r:0000CCB1                 db    0
.rdata$r:0000CCB2                 db    0
.rdata$r:0000CCB3                 db    0
.rdata$r:0000CCB4                 db  40h ; @
.rdata$r:0000CCB5                 db    0
.rdata$r:0000CCB6                 db    0
.rdata$r:0000CCB7                 db    0
.rdata$r:0000CCB8                 dd offset ??_R3IBenchCallback@@8 ; IBenchCallback::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000CCB8 _rdata$r        ends
.rdata$r:0000CCB8
.data:0000CCBC ; ===========================================================================
.data:0000CCBC
.data:0000CCBC ; Segment type: Pure data
.data:0000CCBC ; Segment permissions: Read/Write
.data:0000CCBC _data           segment dword public 'DATA' use32
.data:0000CCBC                 assume cs:_data
.data:0000CCBC                 ;org 0CCBCh
.data:0000CCBC ; COMDAT (pick any)
.data:0000CCBC                 public ??_R0?AUIBenchCallback@@@8
.data:0000CCBC ; struct IBenchCallback `RTTI Type Descriptor'
.data:0000CCBC ??_R0?AUIBenchCallback@@@8 dd offset ??_7type_info@@6B@
.data:0000CCBC                                         ; DATA XREF: .rdata$r:IBenchCallback::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:0000CCBC                                         ; .rdata$r:0000CDBCo
.data:0000CCBC                                         ; const type_info::`vftable'
.data:0000CCC0                 db    0
.data:0000CCC1                 db    0
.data:0000CCC2                 db    0
.data:0000CCC3                 db    0
.data:0000CCC4                 db  2Eh ; .
.data:0000CCC5                 db  3Fh ; ?
.data:0000CCC6                 db  41h ; A
.data:0000CCC7                 db  55h ; U
.data:0000CCC8                 db  49h ; I
.data:0000CCC9                 db  42h ; B
.data:0000CCCA                 db  65h ; e
.data:0000CCCB                 db  6Eh ; n
.data:0000CCCC                 db  63h ; c
.data:0000CCCD                 db  68h ; h
.data:0000CCCE                 db  43h ; C
.data:0000CCCF                 db  61h ; a
.data:0000CCD0                 db  6Ch ; l
.data:0000CCD1                 db  6Ch ; l
.data:0000CCD2                 db  62h ; b
.data:0000CCD3                 db  61h ; a
.data:0000CCD4                 db  63h ; c
.data:0000CCD5                 db  6Bh ; k
.data:0000CCD6                 db  40h ; @
.data:0000CCD7                 db  40h ; @
.data:0000CCD8                 db    0
.data:0000CCD9                 align 4
.data:0000CCD9 _data           ends
.data:0000CCD9
.rdata$r:0000CCDC ; ===========================================================================
.rdata$r:0000CCDC
.rdata$r:0000CCDC ; Segment type: Pure data
.rdata$r:0000CCDC ; Segment permissions: Read
.rdata$r:0000CCDC _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000CCDC                 assume cs:_rdata$r
.rdata$r:0000CCDC                 ;org 0CCDCh
.rdata$r:0000CCDC ; COMDAT (pick any)
.rdata$r:0000CCDC                 public ??_R3IBenchCallback@@8
.rdata$r:0000CCDC ; IBenchCallback::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000CCDC ??_R3IBenchCallback@@8 db    0          ; DATA XREF: .rdata$r:0000CCB8o
.rdata$r:0000CCDC                                         ; .rdata$r:0000CDC0o
.rdata$r:0000CCDD                 db    0
.rdata$r:0000CCDE                 db    0
.rdata$r:0000CCDF                 db    0
.rdata$r:0000CCE0                 db    0
.rdata$r:0000CCE1                 db    0
.rdata$r:0000CCE2                 db    0
.rdata$r:0000CCE3                 db    0
.rdata$r:0000CCE4                 db    1
.rdata$r:0000CCE5                 db    0
.rdata$r:0000CCE6                 db    0
.rdata$r:0000CCE7                 db    0
.rdata$r:0000CCE8                 dd offset ??_R2IBenchCallback@@8 ; IBenchCallback::`RTTI Base Class Array'
.rdata$r:0000CCE8 _rdata$r        ends
.rdata$r:0000CCE8
.rdata$r:0000CCEC ; ===========================================================================
.rdata$r:0000CCEC
.rdata$r:0000CCEC ; Segment type: Pure data
.rdata$r:0000CCEC ; Segment permissions: Read
.rdata$r:0000CCEC _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000CCEC                 assume cs:_rdata$r
.rdata$r:0000CCEC                 ;org 0CCECh
.rdata$r:0000CCEC ; COMDAT (pick any)
.rdata$r:0000CCEC                 public ??_R2IBenchCallback@@8
.rdata$r:0000CCEC ; IBenchCallback::`RTTI Base Class Array'
.rdata$r:0000CCEC ??_R2IBenchCallback@@8 dd offset ??_R1A@?0A@EA@IBenchCallback@@8
.rdata$r:0000CCEC                                         ; DATA XREF: .rdata$r:0000CCE8o
.rdata$r:0000CCEC                                         ; IBenchCallback::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000CCF0                 db    0
.rdata$r:0000CCF1                 align 4
.rdata$r:0000CCF1 _rdata$r        ends
.rdata$r:0000CCF1
.text:0000CCF4 ; ===========================================================================
.text:0000CCF4
.text:0000CCF4 ; Segment type: Pure code
.text:0000CCF4 ; Segment permissions: Read/Execute
.text:0000CCF4 _text           segment para public 'CODE' use32
.text:0000CCF4                 assume cs:_text
.text:0000CCF4                 ;org 0CCF4h
.text:0000CCF4 ; COMDAT (pick any)
.text:0000CCF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000CCF4
.text:0000CCF4 ; =============== S U B R O U T I N E =======================================
.text:0000CCF4
.text:0000CCF4 ; Attributes: bp-based frame
.text:0000CCF4
.text:0000CCF4 ; void __thiscall CBenchCallbackToPrint::Init(CBenchCallbackToPrint *__hidden this)
.text:0000CCF4                 public ?Init@CBenchCallbackToPrint@@QAEXXZ
.text:0000CCF4 ?Init@CBenchCallbackToPrint@@QAEXXZ proc near
.text:0000CCF4                                         ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+106Fp
.text:0000CCF4
.text:0000CCF4 var_4           = dword ptr -4
.text:0000CCF4
.text:0000CCF4                 push    ebp
.text:0000CCF5                 mov     ebp, esp
.text:0000CCF7                 push    ecx
.text:0000CCF8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000CCFF                 mov     [ebp+var_4], ecx
.text:0000CD02                 mov     ecx, [ebp+var_4]
.text:0000CD05                 add     ecx, 18h        ; this
.text:0000CD08                 call    ?Init@CTotalBenchRes@@QAEXXZ ; CTotalBenchRes::Init(void)
.text:0000CD0D                 mov     ecx, [ebp+var_4]
.text:0000CD10                 add     ecx, 38h ; '8'  ; this
.text:0000CD13                 call    ?Init@CTotalBenchRes@@QAEXXZ ; CTotalBenchRes::Init(void)
.text:0000CD18                 add     esp, 4
.text:0000CD1B                 cmp     ebp, esp
.text:0000CD1D                 call    __RTC_CheckEsp
.text:0000CD22                 mov     esp, ebp
.text:0000CD24                 pop     ebp
.text:0000CD25                 retn
.text:0000CD25 ?Init@CBenchCallbackToPrint@@QAEXXZ endp
.text:0000CD25
.text:0000CD25 ; ---------------------------------------------------------------------------
.text:0000CD26                 align 4
.text:0000CD26 _text           ends
.text:0000CD26
.text:0000CD28 ; ===========================================================================
.text:0000CD28
.text:0000CD28 ; Segment type: Pure code
.text:0000CD28 ; Segment permissions: Read/Execute
.text:0000CD28 _text           segment para public 'CODE' use32
.text:0000CD28                 assume cs:_text
.text:0000CD28                 ;org 0CD28h
.text:0000CD28 ; COMDAT (pick any)
.text:0000CD28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000CD28
.text:0000CD28 ; =============== S U B R O U T I N E =======================================
.text:0000CD28
.text:0000CD28 ; Attributes: bp-based frame
.text:0000CD28
.text:0000CD28 ; void __thiscall CTotalBenchRes::Init(CTotalBenchRes *__hidden this)
.text:0000CD28                 public ?Init@CTotalBenchRes@@QAEXXZ
.text:0000CD28 ?Init@CTotalBenchRes@@QAEXXZ proc near  ; CODE XREF: CBenchCallbackToPrint::Init(void)+14p
.text:0000CD28                                         ; CBenchCallbackToPrint::Init(void)+1Fp
.text:0000CD28
.text:0000CD28 var_4           = dword ptr -4
.text:0000CD28
.text:0000CD28                 push    ebp
.text:0000CD29                 mov     ebp, esp
.text:0000CD2B                 push    ecx
.text:0000CD2C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000CD33                 mov     [ebp+var_4], ecx
.text:0000CD36                 mov     eax, [ebp+var_4]
.text:0000CD39                 mov     dword ptr [eax], 0
.text:0000CD3F                 mov     dword ptr [eax+4], 0
.text:0000CD46                 mov     ecx, [ebp+var_4]
.text:0000CD49                 mov     dword ptr [ecx+8], 0
.text:0000CD50                 mov     dword ptr [ecx+0Ch], 0
.text:0000CD57                 mov     edx, [ebp+var_4]
.text:0000CD5A                 mov     dword ptr [edx+10h], 0
.text:0000CD61                 mov     dword ptr [edx+14h], 0
.text:0000CD68                 mov     eax, [ebp+var_4]
.text:0000CD6B                 mov     dword ptr [eax+18h], 0
.text:0000CD72                 mov     dword ptr [eax+1Ch], 0
.text:0000CD79                 mov     esp, ebp
.text:0000CD7B                 pop     ebp
.text:0000CD7C                 retn
.text:0000CD7C ?Init@CTotalBenchRes@@QAEXXZ endp
.text:0000CD7C
.text:0000CD7C ; ---------------------------------------------------------------------------
.text:0000CD7D                 align 10h
.text:0000CD7D _text           ends
.text:0000CD7D
.text:0000CD80 ; ===========================================================================
.text:0000CD80
.text:0000CD80 ; Segment type: Pure code
.text:0000CD80 ; Segment permissions: Read/Execute
.text:0000CD80 _text           segment para public 'CODE' use32
.text:0000CD80                 assume cs:_text
.text:0000CD80                 ;org 0CD80h
.text:0000CD80 ; COMDAT (pick any)
.text:0000CD80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000CD80
.text:0000CD80 ; =============== S U B R O U T I N E =======================================
.text:0000CD80
.text:0000CD80 ; Attributes: bp-based frame
.text:0000CD80
.text:0000CD80 ; _DWORD __thiscall IBenchCallback::IBenchCallback(IBenchCallback *__hidden this)
.text:0000CD80                 public ??0IBenchCallback@@QAE@XZ
.text:0000CD80 ??0IBenchCallback@@QAE@XZ proc near     ; CODE XREF: CBenchCallbackToPrint::CBenchCallbackToPrint(void)+11p
.text:0000CD80
.text:0000CD80 var_4           = dword ptr -4
.text:0000CD80
.text:0000CD80                 push    ebp
.text:0000CD81                 mov     ebp, esp
.text:0000CD83                 push    ecx
.text:0000CD84                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000CD8B                 mov     [ebp+var_4], ecx
.text:0000CD8E                 mov     eax, [ebp+var_4]
.text:0000CD91                 mov     dword ptr [eax], offset ??_7IBenchCallback@@6B@ ; const IBenchCallback::`vftable'
.text:0000CD97                 mov     eax, [ebp+var_4]
.text:0000CD9A                 mov     esp, ebp
.text:0000CD9C                 pop     ebp
.text:0000CD9D                 retn
.text:0000CD9D ??0IBenchCallback@@QAE@XZ endp
.text:0000CD9D
.text:0000CD9D ; ---------------------------------------------------------------------------
.text:0000CD9E                 align 10h
.text:0000CD9E _text           ends
.text:0000CD9E
.rdata:0000CDA0 ; ===========================================================================
.rdata:0000CDA0
.rdata:0000CDA0 ; Segment type: Pure data
.rdata:0000CDA0 ; Segment permissions: Read
.rdata:0000CDA0 _rdata          segment dword public 'DATA' use32
.rdata:0000CDA0                 assume cs:_rdata
.rdata:0000CDA0                 ;org 0CDA0h
.rdata:0000CDA0 ; COMDAT (pick largest)
.rdata:0000CDA0                 dd offset ??_R4IBenchCallback@@6B@ ; const IBenchCallback::`RTTI Complete Object Locator'
.rdata:0000CDA4                 public ??_7IBenchCallback@@6B@
.rdata:0000CDA4 ; const IBenchCallback::`vftable'
.rdata:0000CDA4 ??_7IBenchCallback@@6B@ dd offset __purecall
.rdata:0000CDA4                                         ; DATA XREF: IBenchCallback::IBenchCallback(void)+11o
.rdata:0000CDA8                 dd offset __purecall
.rdata:0000CDAC                 dd offset __purecall
.rdata:0000CDAC _rdata          ends
.rdata:0000CDAC
.rdata$r:0000CDB0 ; ===========================================================================
.rdata$r:0000CDB0
.rdata$r:0000CDB0 ; Segment type: Pure data
.rdata$r:0000CDB0 ; Segment permissions: Read
.rdata$r:0000CDB0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000CDB0                 assume cs:_rdata$r
.rdata$r:0000CDB0                 ;org 0CDB0h
.rdata$r:0000CDB0 ; COMDAT (pick any)
.rdata$r:0000CDB0                 public ??_R4IBenchCallback@@6B@
.rdata$r:0000CDB0 ; const IBenchCallback::`RTTI Complete Object Locator'
.rdata$r:0000CDB0 ??_R4IBenchCallback@@6B@ db    0        ; DATA XREF: .rdata:0000CDA0o
.rdata$r:0000CDB1                 db    0
.rdata$r:0000CDB2                 db    0
.rdata$r:0000CDB3                 db    0
.rdata$r:0000CDB4                 db    0
.rdata$r:0000CDB5                 db    0
.rdata$r:0000CDB6                 db    0
.rdata$r:0000CDB7                 db    0
.rdata$r:0000CDB8                 db    0
.rdata$r:0000CDB9                 db    0
.rdata$r:0000CDBA                 db    0
.rdata$r:0000CDBB                 db    0
.rdata$r:0000CDBC                 dd offset ??_R0?AUIBenchCallback@@@8 ; IBenchCallback `RTTI Type Descriptor'
.rdata$r:0000CDC0                 dd offset ??_R3IBenchCallback@@8 ; IBenchCallback::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000CDC0 _rdata$r        ends
.rdata$r:0000CDC0
.text:0000CDC4 ; ===========================================================================
.text:0000CDC4
.text:0000CDC4 ; Segment type: Pure code
.text:0000CDC4 ; Segment permissions: Read/Execute
.text:0000CDC4 _text           segment para public 'CODE' use32
.text:0000CDC4                 assume cs:_text
.text:0000CDC4                 ;org 0CDC4h
.text:0000CDC4 ; COMDAT (pick any)
.text:0000CDC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000CDC4
.text:0000CDC4 ; =============== S U B R O U T I N E =======================================
.text:0000CDC4
.text:0000CDC4 ; Attributes: bp-based frame
.text:0000CDC4
.text:0000CDC4 ; _DWORD __thiscall CFreqThreads::CFreqThreads(CFreqThreads *__hidden this)
.text:0000CDC4                 public ??0CFreqThreads@@QAE@XZ
.text:0000CDC4 ??0CFreqThreads@@QAE@XZ proc near       ; CODE XREF: FreqBench(unsigned __int64,uint,IBenchPrintCallback *,bool,unsigned __int64 &,uint &)+DDp
.text:0000CDC4
.text:0000CDC4 var_4           = dword ptr -4
.text:0000CDC4
.text:0000CDC4                 push    ebp
.text:0000CDC5                 mov     ebp, esp
.text:0000CDC7                 push    ecx
.text:0000CDC8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000CDCF                 mov     [ebp+var_4], ecx
.text:0000CDD2                 mov     eax, [ebp+var_4]
.text:0000CDD5                 mov     dword ptr [eax], 0
.text:0000CDDB                 mov     ecx, [ebp+var_4]
.text:0000CDDE                 mov     dword ptr [ecx+4], 0
.text:0000CDE5                 mov     eax, [ebp+var_4]
.text:0000CDE8                 mov     esp, ebp
.text:0000CDEA                 pop     ebp
.text:0000CDEB                 retn
.text:0000CDEB ??0CFreqThreads@@QAE@XZ endp
.text:0000CDEB
.text:0000CDEB _text           ends
.text:0000CDEB
.text:0000CDEC ; ===========================================================================
.text:0000CDEC
.text:0000CDEC ; Segment type: Pure code
.text:0000CDEC ; Segment permissions: Read/Execute
.text:0000CDEC _text           segment para public 'CODE' use32
.text:0000CDEC                 assume cs:_text
.text:0000CDEC                 ;org 0CDECh
.text:0000CDEC ; COMDAT (pick any)
.text:0000CDEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000CDEC
.text:0000CDEC ; =============== S U B R O U T I N E =======================================
.text:0000CDEC
.text:0000CDEC ; Attributes: bp-based frame
.text:0000CDEC
.text:0000CDEC ; void __thiscall CFreqThreads::WaitAll(CFreqThreads *__hidden this)
.text:0000CDEC                 public ?WaitAll@CFreqThreads@@QAEXXZ
.text:0000CDEC ?WaitAll@CFreqThreads@@QAEXXZ proc near ; CODE XREF: FreqBench(unsigned __int64,uint,IBenchPrintCallback *,bool,unsigned __int64 &,uint &)+27Cp
.text:0000CDEC                                         ; CFreqThreads::~CFreqThreads(void)+1Dp
.text:0000CDEC
.text:0000CDEC var_8           = dword ptr -8
.text:0000CDEC var_4           = dword ptr -4
.text:0000CDEC
.text:0000CDEC                 push    ebp
.text:0000CDED                 mov     ebp, esp
.text:0000CDEF                 sub     esp, 8
.text:0000CDF2                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000CDF9                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000CE00                 mov     [ebp+var_4], ecx
.text:0000CE03                 mov     [ebp+var_8], 0
.text:0000CE0A                 jmp     short loc_CE15
.text:0000CE0C ; ---------------------------------------------------------------------------
.text:0000CE0C
.text:0000CE0C loc_CE0C:                               ; CODE XREF: CFreqThreads::WaitAll(void)+44j
.text:0000CE0C                 mov     eax, [ebp+var_8]
.text:0000CE0F                 add     eax, 1
.text:0000CE12                 mov     [ebp+var_8], eax
.text:0000CE15
.text:0000CE15 loc_CE15:                               ; CODE XREF: CFreqThreads::WaitAll(void)+1Ej
.text:0000CE15                 mov     ecx, [ebp+var_4]
.text:0000CE18                 mov     edx, [ebp+var_8]
.text:0000CE1B                 cmp     edx, [ecx+4]
.text:0000CE1E                 jnb     short loc_CE32
.text:0000CE20                 mov     ecx, [ebp+var_8]
.text:0000CE23                 shl     ecx, 5
.text:0000CE26                 mov     eax, [ebp+var_4]
.text:0000CE29                 add     ecx, [eax]      ; this
.text:0000CE2B                 call    ?Wait@CFreqInfo@@QAEXXZ ; CFreqInfo::Wait(void)
.text:0000CE30                 jmp     short loc_CE0C
.text:0000CE32 ; ---------------------------------------------------------------------------
.text:0000CE32
.text:0000CE32 loc_CE32:                               ; CODE XREF: CFreqThreads::WaitAll(void)+32j
.text:0000CE32                 mov     ecx, [ebp+var_4]
.text:0000CE35                 mov     dword ptr [ecx+4], 0
.text:0000CE3C                 add     esp, 8
.text:0000CE3F                 cmp     ebp, esp
.text:0000CE41                 call    __RTC_CheckEsp
.text:0000CE46                 mov     esp, ebp
.text:0000CE48                 pop     ebp
.text:0000CE49                 retn
.text:0000CE49 ?WaitAll@CFreqThreads@@QAEXXZ endp
.text:0000CE49
.text:0000CE49 ; ---------------------------------------------------------------------------
.text:0000CE4A                 align 4
.text:0000CE4A _text           ends
.text:0000CE4A
.text:0000CE4C ; ===========================================================================
.text:0000CE4C
.text:0000CE4C ; Segment type: Pure code
.text:0000CE4C ; Segment permissions: Read/Execute
.text:0000CE4C _text           segment para public 'CODE' use32
.text:0000CE4C                 assume cs:_text
.text:0000CE4C                 ;org 0CE4Ch
.text:0000CE4C ; COMDAT (pick any)
.text:0000CE4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000CE4C
.text:0000CE4C ; =============== S U B R O U T I N E =======================================
.text:0000CE4C
.text:0000CE4C ; Attributes: bp-based frame
.text:0000CE4C
.text:0000CE4C ; void __thiscall CFreqInfo::Wait(CFreqInfo *__hidden this)
.text:0000CE4C                 public ?Wait@CFreqInfo@@QAEXXZ
.text:0000CE4C ?Wait@CFreqInfo@@QAEXXZ proc near       ; CODE XREF: CFreqThreads::WaitAll(void)+3Fp
.text:0000CE4C
.text:0000CE4C var_4           = dword ptr -4
.text:0000CE4C
.text:0000CE4C                 push    ebp
.text:0000CE4D                 mov     ebp, esp
.text:0000CE4F                 push    ecx
.text:0000CE50                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000CE57                 mov     [ebp+var_4], ecx
.text:0000CE5A                 mov     ecx, [ebp+var_4] ; this
.text:0000CE5D                 call    ?Wait@CThread@NWindows@@QAEIXZ ; NWindows::CThread::Wait(void)
.text:0000CE62                 mov     ecx, [ebp+var_4] ; this
.text:0000CE65                 call    ?Close@CThread@NWindows@@QAEIXZ ; NWindows::CThread::Close(void)
.text:0000CE6A                 add     esp, 4
.text:0000CE6D                 cmp     ebp, esp
.text:0000CE6F                 call    __RTC_CheckEsp
.text:0000CE74                 mov     esp, ebp
.text:0000CE76                 pop     ebp
.text:0000CE77                 retn
.text:0000CE77 ?Wait@CFreqInfo@@QAEXXZ endp
.text:0000CE77
.text:0000CE77 _text           ends
.text:0000CE77
.text:0000CE78 ; ===========================================================================
.text:0000CE78
.text:0000CE78 ; Segment type: Pure code
.text:0000CE78 ; Segment permissions: Read/Execute
.text:0000CE78 _text           segment para public 'CODE' use32
.text:0000CE78                 assume cs:_text
.text:0000CE78                 ;org 0CE78h
.text:0000CE78 ; COMDAT (pick any)
.text:0000CE78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000CE78
.text:0000CE78 ; =============== S U B R O U T I N E =======================================
.text:0000CE78
.text:0000CE78 ; Attributes: bp-based frame
.text:0000CE78
.text:0000CE78 ; _DWORD __thiscall CFreqThreads::~CFreqThreads(CFreqThreads *__hidden this)
.text:0000CE78                 public ??1CFreqThreads@@QAE@XZ
.text:0000CE78 ??1CFreqThreads@@QAE@XZ proc near       ; CODE XREF: FreqBench(unsigned __int64,uint,IBenchPrintCallback *,bool,unsigned __int64 &,uint &)+25Ep
.text:0000CE78                                         ; FreqBench(unsigned __int64,uint,IBenchPrintCallback *,bool,unsigned __int64 &,uint &)+2CDp ...
.text:0000CE78
.text:0000CE78 var_10          = dword ptr -10h
.text:0000CE78 var_C           = dword ptr -0Ch
.text:0000CE78 var_8           = dword ptr -8
.text:0000CE78 var_4           = dword ptr -4
.text:0000CE78
.text:0000CE78                 push    ebp
.text:0000CE79                 mov     ebp, esp
.text:0000CE7B                 sub     esp, 10h
.text:0000CE7E                 mov     eax, 0CCCCCCCCh
.text:0000CE83                 mov     [ebp+var_10], eax
.text:0000CE86                 mov     [ebp+var_C], eax
.text:0000CE89                 mov     [ebp+var_8], eax
.text:0000CE8C                 mov     [ebp+var_4], eax
.text:0000CE8F                 mov     [ebp+var_4], ecx
.text:0000CE92                 mov     ecx, [ebp+var_4] ; this
.text:0000CE95                 call    ?WaitAll@CFreqThreads@@QAEXXZ ; CFreqThreads::WaitAll(void)
.text:0000CE9A                 mov     eax, [ebp+var_4]
.text:0000CE9D                 mov     ecx, [eax]
.text:0000CE9F                 mov     [ebp+var_C], ecx
.text:0000CEA2                 mov     edx, [ebp+var_C]
.text:0000CEA5                 mov     [ebp+var_8], edx
.text:0000CEA8                 cmp     [ebp+var_8], 0
.text:0000CEAC                 jz      short loc_CEBD
.text:0000CEAE                 push    3
.text:0000CEB0                 mov     ecx, [ebp+var_8]
.text:0000CEB3                 call    ??_ECFreqInfo@@QAEPAXI@Z ; CFreqInfo::`vector deleting destructor'(uint)
.text:0000CEB8                 mov     [ebp+var_10], eax
.text:0000CEBB                 jmp     short loc_CEC4
.text:0000CEBD ; ---------------------------------------------------------------------------
.text:0000CEBD
.text:0000CEBD loc_CEBD:                               ; CODE XREF: CFreqThreads::~CFreqThreads(void)+34j
.text:0000CEBD                 mov     [ebp+var_10], 0
.text:0000CEC4
.text:0000CEC4 loc_CEC4:                               ; CODE XREF: CFreqThreads::~CFreqThreads(void)+43j
.text:0000CEC4                 add     esp, 10h
.text:0000CEC7                 cmp     ebp, esp
.text:0000CEC9                 call    __RTC_CheckEsp
.text:0000CECE                 mov     esp, ebp
.text:0000CED0                 pop     ebp
.text:0000CED1                 retn
.text:0000CED1 ??1CFreqThreads@@QAE@XZ endp
.text:0000CED1
.text:0000CED1 ; ---------------------------------------------------------------------------
.text:0000CED2                 align 4
.text:0000CED2 _text           ends
.text:0000CED2
.text:0000CED4 ; ===========================================================================
.text:0000CED4
.text:0000CED4 ; Segment type: Pure code
.text:0000CED4 ; Segment permissions: Read/Execute
.text:0000CED4 _text           segment para public 'CODE' use32
.text:0000CED4                 assume cs:_text
.text:0000CED4                 ;org 0CED4h
.text:0000CED4 ; COMDAT (pick any)
.text:0000CED4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000CED4
.text:0000CED4 ; =============== S U B R O U T I N E =======================================
.text:0000CED4
.text:0000CED4 ; Attributes: bp-based frame
.text:0000CED4
.text:0000CED4 ; public: __thiscall CFreqInfo::CFreqInfo(void)
.text:0000CED4                 public ??0CFreqInfo@@QAE@XZ
.text:0000CED4 ??0CFreqInfo@@QAE@XZ proc near          ; DATA XREF: FreqBench(unsigned __int64,uint,IBenchPrintCallback *,bool,unsigned __int64 &,uint &)+14Do
.text:0000CED4
.text:0000CED4 var_4           = dword ptr -4
.text:0000CED4
.text:0000CED4                 push    ebp
.text:0000CED5                 mov     ebp, esp
.text:0000CED7                 push    ecx
.text:0000CED8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000CEDF                 mov     [ebp+var_4], ecx
.text:0000CEE2                 mov     ecx, [ebp+var_4] ; this
.text:0000CEE5                 call    ??0CThread@NWindows@@QAE@XZ ; NWindows::CThread::CThread(void)
.text:0000CEEA                 mov     eax, [ebp+var_4]
.text:0000CEED                 add     esp, 4
.text:0000CEF0                 cmp     ebp, esp
.text:0000CEF2                 call    __RTC_CheckEsp
.text:0000CEF7                 mov     esp, ebp
.text:0000CEF9                 pop     ebp
.text:0000CEFA                 retn
.text:0000CEFA ??0CFreqInfo@@QAE@XZ endp
.text:0000CEFA
.text:0000CEFA ; ---------------------------------------------------------------------------
.text:0000CEFB                 align 4
.text:0000CEFB _text           ends
.text:0000CEFB
.text:0000CEFC ; ===========================================================================
.text:0000CEFC
.text:0000CEFC ; Segment type: Pure code
.text:0000CEFC ; Segment permissions: Read/Execute
.text:0000CEFC _text           segment para public 'CODE' use32
.text:0000CEFC                 assume cs:_text
.text:0000CEFC                 ;org 0CEFCh
.text:0000CEFC ; COMDAT (pick any)
.text:0000CEFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000CEFC
.text:0000CEFC ; =============== S U B R O U T I N E =======================================
.text:0000CEFC
.text:0000CEFC ; Attributes: bp-based frame
.text:0000CEFC
.text:0000CEFC ; _DWORD __thiscall CCrcThreads::CCrcThreads(CCrcThreads *__hidden this)
.text:0000CEFC                 public ??0CCrcThreads@@QAE@XZ
.text:0000CEFC ??0CCrcThreads@@QAE@XZ proc near        ; CODE XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+1BCp
.text:0000CEFC
.text:0000CEFC var_4           = dword ptr -4
.text:0000CEFC
.text:0000CEFC                 push    ebp
.text:0000CEFD                 mov     ebp, esp
.text:0000CEFF                 push    ecx
.text:0000CF00                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000CF07                 mov     [ebp+var_4], ecx
.text:0000CF0A                 mov     eax, [ebp+var_4]
.text:0000CF0D                 mov     dword ptr [eax], 0
.text:0000CF13                 mov     ecx, [ebp+var_4]
.text:0000CF16                 mov     dword ptr [ecx+4], 0
.text:0000CF1D                 mov     eax, [ebp+var_4]
.text:0000CF20                 mov     esp, ebp
.text:0000CF22                 pop     ebp
.text:0000CF23                 retn
.text:0000CF23 ??0CCrcThreads@@QAE@XZ endp
.text:0000CF23
.text:0000CF23 _text           ends
.text:0000CF23
.text:0000CF24 ; ===========================================================================
.text:0000CF24
.text:0000CF24 ; Segment type: Pure code
.text:0000CF24 ; Segment permissions: Read/Execute
.text:0000CF24 _text           segment para public 'CODE' use32
.text:0000CF24                 assume cs:_text
.text:0000CF24                 ;org 0CF24h
.text:0000CF24 ; COMDAT (pick any)
.text:0000CF24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000CF24
.text:0000CF24 ; =============== S U B R O U T I N E =======================================
.text:0000CF24
.text:0000CF24 ; Attributes: bp-based frame
.text:0000CF24
.text:0000CF24 ; void __thiscall CCrcThreads::WaitAll(CCrcThreads *__hidden this)
.text:0000CF24                 public ?WaitAll@CCrcThreads@@QAEXXZ
.text:0000CF24 ?WaitAll@CCrcThreads@@QAEXXZ proc near  ; CODE XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+644p
.text:0000CF24                                         ; CCrcThreads::~CCrcThreads(void)+1Dp
.text:0000CF24
.text:0000CF24 var_8           = dword ptr -8
.text:0000CF24 var_4           = dword ptr -4
.text:0000CF24
.text:0000CF24                 push    ebp
.text:0000CF25                 mov     ebp, esp
.text:0000CF27                 sub     esp, 8
.text:0000CF2A                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000CF31                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000CF38                 mov     [ebp+var_4], ecx
.text:0000CF3B                 mov     [ebp+var_8], 0
.text:0000CF42                 jmp     short loc_CF4D
.text:0000CF44 ; ---------------------------------------------------------------------------
.text:0000CF44
.text:0000CF44 loc_CF44:                               ; CODE XREF: CCrcThreads::WaitAll(void)+44j
.text:0000CF44                 mov     eax, [ebp+var_8]
.text:0000CF47                 add     eax, 1
.text:0000CF4A                 mov     [ebp+var_8], eax
.text:0000CF4D
.text:0000CF4D loc_CF4D:                               ; CODE XREF: CCrcThreads::WaitAll(void)+1Ej
.text:0000CF4D                 mov     ecx, [ebp+var_4]
.text:0000CF50                 mov     edx, [ebp+var_8]
.text:0000CF53                 cmp     edx, [ecx+4]
.text:0000CF56                 jnb     short loc_CF6A
.text:0000CF58                 mov     ecx, [ebp+var_8]
.text:0000CF5B                 imul    ecx, 38h
.text:0000CF5E                 mov     eax, [ebp+var_4]
.text:0000CF61                 add     ecx, [eax]      ; this
.text:0000CF63                 call    ?Wait@CCrcInfo@@QAEXXZ ; CCrcInfo::Wait(void)
.text:0000CF68                 jmp     short loc_CF44
.text:0000CF6A ; ---------------------------------------------------------------------------
.text:0000CF6A
.text:0000CF6A loc_CF6A:                               ; CODE XREF: CCrcThreads::WaitAll(void)+32j
.text:0000CF6A                 mov     ecx, [ebp+var_4]
.text:0000CF6D                 mov     dword ptr [ecx+4], 0
.text:0000CF74                 add     esp, 8
.text:0000CF77                 cmp     ebp, esp
.text:0000CF79                 call    __RTC_CheckEsp
.text:0000CF7E                 mov     esp, ebp
.text:0000CF80                 pop     ebp
.text:0000CF81                 retn
.text:0000CF81 ?WaitAll@CCrcThreads@@QAEXXZ endp
.text:0000CF81
.text:0000CF81 ; ---------------------------------------------------------------------------
.text:0000CF82                 align 4
.text:0000CF82 _text           ends
.text:0000CF82
.text:0000CF84 ; ===========================================================================
.text:0000CF84
.text:0000CF84 ; Segment type: Pure code
.text:0000CF84 ; Segment permissions: Read/Execute
.text:0000CF84 _text           segment para public 'CODE' use32
.text:0000CF84                 assume cs:_text
.text:0000CF84                 ;org 0CF84h
.text:0000CF84 ; COMDAT (pick any)
.text:0000CF84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000CF84
.text:0000CF84 ; =============== S U B R O U T I N E =======================================
.text:0000CF84
.text:0000CF84 ; Attributes: bp-based frame
.text:0000CF84
.text:0000CF84 ; void __thiscall CCrcInfo::Wait(CCrcInfo *__hidden this)
.text:0000CF84                 public ?Wait@CCrcInfo@@QAEXXZ
.text:0000CF84 ?Wait@CCrcInfo@@QAEXXZ proc near        ; CODE XREF: CCrcThreads::WaitAll(void)+3Fp
.text:0000CF84
.text:0000CF84 var_4           = dword ptr -4
.text:0000CF84
.text:0000CF84                 push    ebp
.text:0000CF85                 mov     ebp, esp
.text:0000CF87                 push    ecx
.text:0000CF88                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000CF8F                 mov     [ebp+var_4], ecx
.text:0000CF92                 mov     ecx, [ebp+var_4] ; this
.text:0000CF95                 call    ?Wait@CThread@NWindows@@QAEIXZ ; NWindows::CThread::Wait(void)
.text:0000CF9A                 mov     ecx, [ebp+var_4] ; this
.text:0000CF9D                 call    ?Close@CThread@NWindows@@QAEIXZ ; NWindows::CThread::Close(void)
.text:0000CFA2                 add     esp, 4
.text:0000CFA5                 cmp     ebp, esp
.text:0000CFA7                 call    __RTC_CheckEsp
.text:0000CFAC                 mov     esp, ebp
.text:0000CFAE                 pop     ebp
.text:0000CFAF                 retn
.text:0000CFAF ?Wait@CCrcInfo@@QAEXXZ endp
.text:0000CFAF
.text:0000CFAF _text           ends
.text:0000CFAF
.text:0000CFB0 ; ===========================================================================
.text:0000CFB0
.text:0000CFB0 ; Segment type: Pure code
.text:0000CFB0 ; Segment permissions: Read/Execute
.text:0000CFB0 _text           segment para public 'CODE' use32
.text:0000CFB0                 assume cs:_text
.text:0000CFB0                 ;org 0CFB0h
.text:0000CFB0 ; COMDAT (pick any)
.text:0000CFB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000CFB0
.text:0000CFB0 ; =============== S U B R O U T I N E =======================================
.text:0000CFB0
.text:0000CFB0 ; Attributes: bp-based frame
.text:0000CFB0
.text:0000CFB0 ; _DWORD __thiscall CCrcThreads::~CCrcThreads(CCrcThreads *__hidden this)
.text:0000CFB0                 public ??1CCrcThreads@@QAE@XZ
.text:0000CFB0 ??1CCrcThreads@@QAE@XZ proc near        ; CODE XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+31Dp
.text:0000CFB0                                         ; CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+380p ...
.text:0000CFB0
.text:0000CFB0 var_10          = dword ptr -10h
.text:0000CFB0 var_C           = dword ptr -0Ch
.text:0000CFB0 var_8           = dword ptr -8
.text:0000CFB0 var_4           = dword ptr -4
.text:0000CFB0
.text:0000CFB0                 push    ebp
.text:0000CFB1                 mov     ebp, esp
.text:0000CFB3                 sub     esp, 10h
.text:0000CFB6                 mov     eax, 0CCCCCCCCh
.text:0000CFBB                 mov     [ebp+var_10], eax
.text:0000CFBE                 mov     [ebp+var_C], eax
.text:0000CFC1                 mov     [ebp+var_8], eax
.text:0000CFC4                 mov     [ebp+var_4], eax
.text:0000CFC7                 mov     [ebp+var_4], ecx
.text:0000CFCA                 mov     ecx, [ebp+var_4] ; this
.text:0000CFCD                 call    ?WaitAll@CCrcThreads@@QAEXXZ ; CCrcThreads::WaitAll(void)
.text:0000CFD2                 mov     eax, [ebp+var_4]
.text:0000CFD5                 mov     ecx, [eax]
.text:0000CFD7                 mov     [ebp+var_C], ecx
.text:0000CFDA                 mov     edx, [ebp+var_C]
.text:0000CFDD                 mov     [ebp+var_8], edx
.text:0000CFE0                 cmp     [ebp+var_8], 0
.text:0000CFE4                 jz      short loc_CFF5
.text:0000CFE6                 push    3
.text:0000CFE8                 mov     ecx, [ebp+var_8]
.text:0000CFEB                 call    ??_ECCrcInfo@@QAEPAXI@Z ; CCrcInfo::`vector deleting destructor'(uint)
.text:0000CFF0                 mov     [ebp+var_10], eax
.text:0000CFF3                 jmp     short loc_CFFC
.text:0000CFF5 ; ---------------------------------------------------------------------------
.text:0000CFF5
.text:0000CFF5 loc_CFF5:                               ; CODE XREF: CCrcThreads::~CCrcThreads(void)+34j
.text:0000CFF5                 mov     [ebp+var_10], 0
.text:0000CFFC
.text:0000CFFC loc_CFFC:                               ; CODE XREF: CCrcThreads::~CCrcThreads(void)+43j
.text:0000CFFC                 add     esp, 10h
.text:0000CFFF                 cmp     ebp, esp
.text:0000D001                 call    __RTC_CheckEsp
.text:0000D006                 mov     esp, ebp
.text:0000D008                 pop     ebp
.text:0000D009                 retn
.text:0000D009 ??1CCrcThreads@@QAE@XZ endp
.text:0000D009
.text:0000D009 ; ---------------------------------------------------------------------------
.text:0000D00A                 align 4
.text:0000D00A _text           ends
.text:0000D00A
.text:0000D00C ; ===========================================================================
.text:0000D00C
.text:0000D00C ; Segment type: Pure code
.text:0000D00C ; Segment permissions: Read/Execute
.text:0000D00C _text           segment para public 'CODE' use32
.text:0000D00C                 assume cs:_text
.text:0000D00C                 ;org 0D00Ch
.text:0000D00C ; COMDAT (pick any)
.text:0000D00C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000D00C
.text:0000D00C ; =============== S U B R O U T I N E =======================================
.text:0000D00C
.text:0000D00C ; Attributes: bp-based frame
.text:0000D00C
.text:0000D00C ; public: __thiscall CCrcInfo::CCrcInfo(void)
.text:0000D00C                 public ??0CCrcInfo@@QAE@XZ
.text:0000D00C ??0CCrcInfo@@QAE@XZ proc near           ; DATA XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+229o
.text:0000D00C
.text:0000D00C var_10          = dword ptr -10h
.text:0000D00C var_C           = dword ptr -0Ch
.text:0000D00C var_4           = dword ptr -4
.text:0000D00C
.text:0000D00C                 push    ebp
.text:0000D00D                 mov     ebp, esp
.text:0000D00F                 push    0FFFFFFFFh
.text:0000D011                 push    offset __ehhandler$??0CCrcInfo@@QAE@XZ
.text:0000D016                 mov     eax, large fs:0
.text:0000D01C                 push    eax
.text:0000D01D                 push    ecx
.text:0000D01E                 mov     [ebp+var_10], 0CCCCCCCCh
.text:0000D025                 mov     eax, dword ptr ds:___security_cookie
.text:0000D02A                 xor     eax, ebp
.text:0000D02C                 push    eax
.text:0000D02D                 lea     eax, [ebp+var_C]
.text:0000D030                 mov     large fs:0, eax
.text:0000D036                 mov     [ebp+var_10], ecx
.text:0000D039                 mov     ecx, [ebp+var_10] ; this
.text:0000D03C                 call    ??0CThread@NWindows@@QAE@XZ ; NWindows::CThread::CThread(void)
.text:0000D041                 mov     [ebp+var_4], 0
.text:0000D048                 mov     ecx, [ebp+var_10]
.text:0000D04B                 add     ecx, 28h ; '('
.text:0000D04E                 call    ??0?$CMyComPtr@UIHasher@@@@QAE@XZ ; CMyComPtr<IHasher>::CMyComPtr<IHasher>(void)
.text:0000D053                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000D05A                 mov     eax, [ebp+var_10]
.text:0000D05D                 mov     ecx, [ebp+var_C]
.text:0000D060                 mov     large fs:0, ecx
.text:0000D067                 pop     ecx
.text:0000D068                 add     esp, 10h
.text:0000D06B                 cmp     ebp, esp
.text:0000D06D                 call    __RTC_CheckEsp
.text:0000D072                 mov     esp, ebp
.text:0000D074                 pop     ebp
.text:0000D075                 retn
.text:0000D075 ??0CCrcInfo@@QAE@XZ endp
.text:0000D075
.text:0000D075 ; ---------------------------------------------------------------------------
.text:0000D076                 align 4
.text:0000D076 _text           ends
.text:0000D076
.text$x:0000D078 ; ===========================================================================
.text$x:0000D078
.text$x:0000D078 ; Segment type: Pure code
.text$x:0000D078 ; Segment permissions: Read/Execute
.text$x:0000D078 _text$x         segment para public 'CODE' use32
.text$x:0000D078                 assume cs:_text$x
.text$x:0000D078                 ;org 0D078h
.text$x:0000D078 ; COMDAT (pick associative to section at D00C)
.text$x:0000D078                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000D078
.text$x:0000D078 ; =============== S U B R O U T I N E =======================================
.text$x:0000D078
.text$x:0000D078
.text$x:0000D078 __unwindfunclet$??0CCrcInfo@@QAE@XZ$0 proc near
.text$x:0000D078                                         ; DATA XREF: .xdata$x:0000D0A0o
.text$x:0000D078                 mov     ecx, [ebp-10h]  ; this
.text$x:0000D07B                 jmp     ??1CThread@NWindows@@QAE@XZ ; NWindows::CThread::~CThread(void)
.text$x:0000D07B __unwindfunclet$??0CCrcInfo@@QAE@XZ$0 endp
.text$x:0000D07B
.text$x:0000D080
.text$x:0000D080 ; =============== S U B R O U T I N E =======================================
.text$x:0000D080
.text$x:0000D080
.text$x:0000D080 __ehhandler$??0CCrcInfo@@QAE@XZ proc near
.text$x:0000D080                                         ; DATA XREF: CCrcInfo::CCrcInfo(void)+5o
.text$x:0000D080
.text$x:0000D080 arg_4           = dword ptr  8
.text$x:0000D080
.text$x:0000D080                 mov     edx, [esp+arg_4]
.text$x:0000D084                 lea     eax, [edx+0Ch]
.text$x:0000D087                 mov     ecx, [edx-8]
.text$x:0000D08A                 xor     ecx, eax
.text$x:0000D08C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000D091                 mov     eax, offset __ehfuncinfo$??0CCrcInfo@@QAE@XZ
.text$x:0000D096                 jmp     ___CxxFrameHandler3
.text$x:0000D096 __ehhandler$??0CCrcInfo@@QAE@XZ endp
.text$x:0000D096
.text$x:0000D096 ; ---------------------------------------------------------------------------
.text$x:0000D09B                 align 4
.text$x:0000D09B _text$x         ends
.text$x:0000D09B
.xdata$x:0000D09C ; ===========================================================================
.xdata$x:0000D09C
.xdata$x:0000D09C ; Segment type: Pure data
.xdata$x:0000D09C ; Segment permissions: Read
.xdata$x:0000D09C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D09C                 assume cs:_xdata$x
.xdata$x:0000D09C                 ;org 0D09Ch
.xdata$x:0000D09C ; COMDAT (pick associative to section at D00C)
.xdata$x:0000D09C __unwindtable$??0CCrcInfo@@QAE@XZ db 0FFh ; DATA XREF: .xdata$x:0000D0ACo
.xdata$x:0000D09D                 db 0FFh
.xdata$x:0000D09E                 db 0FFh
.xdata$x:0000D09F                 db 0FFh
.xdata$x:0000D0A0                 dd offset __unwindfunclet$??0CCrcInfo@@QAE@XZ$0
.xdata$x:0000D0A4 __ehfuncinfo$??0CCrcInfo@@QAE@XZ db  22h ; "
.xdata$x:0000D0A4                                         ; DATA XREF: __ehhandler$??0CCrcInfo@@QAE@XZ+11o
.xdata$x:0000D0A5                 db    5
.xdata$x:0000D0A6                 db  93h ; ô
.xdata$x:0000D0A7                 db  19h
.xdata$x:0000D0A8                 db    1
.xdata$x:0000D0A9                 db    0
.xdata$x:0000D0AA                 db    0
.xdata$x:0000D0AB                 db    0
.xdata$x:0000D0AC                 dd offset __unwindtable$??0CCrcInfo@@QAE@XZ
.xdata$x:0000D0B0                 db    0
.xdata$x:0000D0B1                 db    0
.xdata$x:0000D0B2                 db    0
.xdata$x:0000D0B3                 db    0
.xdata$x:0000D0B4                 db    0
.xdata$x:0000D0B5                 db    0
.xdata$x:0000D0B6                 db    0
.xdata$x:0000D0B7                 db    0
.xdata$x:0000D0B8                 db    0
.xdata$x:0000D0B9                 db    0
.xdata$x:0000D0BA                 db    0
.xdata$x:0000D0BB                 db    0
.xdata$x:0000D0BC                 db    0
.xdata$x:0000D0BD                 db    0
.xdata$x:0000D0BE                 db    0
.xdata$x:0000D0BF                 db    0
.xdata$x:0000D0C0                 db    0
.xdata$x:0000D0C1                 db    0
.xdata$x:0000D0C2                 db    0
.xdata$x:0000D0C3                 db    0
.xdata$x:0000D0C4                 db    1
.xdata$x:0000D0C5                 db    0
.xdata$x:0000D0C6                 db    0
.xdata$x:0000D0C7                 db    0
.xdata$x:0000D0C7 _xdata$x        ends
.xdata$x:0000D0C7
.text:0000D0C8 ; ===========================================================================
.text:0000D0C8
.text:0000D0C8 ; Segment type: Pure code
.text:0000D0C8 ; Segment permissions: Read/Execute
.text:0000D0C8 _text           segment para public 'CODE' use32
.text:0000D0C8                 assume cs:_text
.text:0000D0C8                 ;org 0D0C8h
.text:0000D0C8 ; COMDAT (pick any)
.text:0000D0C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000D0C8
.text:0000D0C8 ; =============== S U B R O U T I N E =======================================
.text:0000D0C8
.text:0000D0C8 ; Attributes: bp-based frame
.text:0000D0C8
.text:0000D0C8 ; _DWORD __thiscall CTempValues::CTempValues(CTempValues *this, unsigned int)
.text:0000D0C8                 public ??0CTempValues@@QAE@I@Z
.text:0000D0C8 ??0CTempValues@@QAE@I@Z proc near       ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+B0Fp
.text:0000D0C8
.text:0000D0C8 var_8           = dword ptr -8
.text:0000D0C8 var_4           = dword ptr -4
.text:0000D0C8 arg_0           = dword ptr  8
.text:0000D0C8
.text:0000D0C8                 push    ebp
.text:0000D0C9                 mov     ebp, esp
.text:0000D0CB                 sub     esp, 8
.text:0000D0CE                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000D0D5                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000D0DC                 mov     [ebp+var_4], ecx
.text:0000D0DF                 xor     ecx, ecx
.text:0000D0E1                 mov     eax, [ebp+arg_0]
.text:0000D0E4                 mov     edx, 8
.text:0000D0E9                 mul     edx
.text:0000D0EB                 seto    cl
.text:0000D0EE                 neg     ecx
.text:0000D0F0                 or      ecx, eax
.text:0000D0F2                 push    ecx             ; unsigned int
.text:0000D0F3                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0000D0F8                 add     esp, 4
.text:0000D0FB                 mov     [ebp+var_8], eax
.text:0000D0FE                 mov     eax, [ebp+var_4]
.text:0000D101                 mov     ecx, [ebp+var_8]
.text:0000D104                 mov     [eax], ecx
.text:0000D106                 mov     eax, [ebp+var_4]
.text:0000D109                 add     esp, 8
.text:0000D10C                 cmp     ebp, esp
.text:0000D10E                 call    __RTC_CheckEsp
.text:0000D113                 mov     esp, ebp
.text:0000D115                 pop     ebp
.text:0000D116                 retn    4
.text:0000D116 ??0CTempValues@@QAE@I@Z endp
.text:0000D116
.text:0000D116 ; ---------------------------------------------------------------------------
.text:0000D119                 align 4
.text:0000D119 _text           ends
.text:0000D119
.text:0000D11C ; ===========================================================================
.text:0000D11C
.text:0000D11C ; Segment type: Pure code
.text:0000D11C ; Segment permissions: Read/Execute
.text:0000D11C _text           segment para public 'CODE' use32
.text:0000D11C                 assume cs:_text
.text:0000D11C                 ;org 0D11Ch
.text:0000D11C ; COMDAT (pick any)
.text:0000D11C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000D11C
.text:0000D11C ; =============== S U B R O U T I N E =======================================
.text:0000D11C
.text:0000D11C ; Attributes: bp-based frame
.text:0000D11C
.text:0000D11C ; _DWORD __thiscall CTempValues::~CTempValues(CTempValues *__hidden this)
.text:0000D11C                 public ??1CTempValues@@QAE@XZ
.text:0000D11C ??1CTempValues@@QAE@XZ proc near        ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+CE7p
.text:0000D11C                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+DCBp ...
.text:0000D11C
.text:0000D11C var_8           = dword ptr -8
.text:0000D11C var_4           = dword ptr -4
.text:0000D11C
.text:0000D11C                 push    ebp
.text:0000D11D                 mov     ebp, esp
.text:0000D11F                 sub     esp, 8
.text:0000D122                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000D129                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000D130                 mov     [ebp+var_4], ecx
.text:0000D133                 mov     eax, [ebp+var_4]
.text:0000D136                 mov     ecx, [eax]
.text:0000D138                 mov     [ebp+var_8], ecx
.text:0000D13B                 mov     edx, [ebp+var_8]
.text:0000D13E                 push    edx             ; void *
.text:0000D13F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000D144                 add     esp, 4
.text:0000D147                 add     esp, 8
.text:0000D14A                 cmp     ebp, esp
.text:0000D14C                 call    __RTC_CheckEsp
.text:0000D151                 mov     esp, ebp
.text:0000D153                 pop     ebp
.text:0000D154                 retn
.text:0000D154 ??1CTempValues@@QAE@XZ endp
.text:0000D154
.text:0000D154 ; ---------------------------------------------------------------------------
.text:0000D155                 align 4
.text:0000D155 _text           ends
.text:0000D155
.text:0000D158 ; ===========================================================================
.text:0000D158
.text:0000D158 ; Segment type: Pure code
.text:0000D158 ; Segment permissions: Read/Execute
.text:0000D158 _text           segment para public 'CODE' use32
.text:0000D158                 assume cs:_text
.text:0000D158                 ;org 0D158h
.text:0000D158 ; COMDAT (pick any)
.text:0000D158                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000D158
.text:0000D158 ; =============== S U B R O U T I N E =======================================
.text:0000D158
.text:0000D158 ; Attributes: bp-based frame
.text:0000D158
.text:0000D158 ; char __stdcall MyCharLower_Ascii(char)
.text:0000D158                 public ?MyCharLower_Ascii@@YGDD@Z
.text:0000D158 ?MyCharLower_Ascii@@YGDD@Z proc near    ; CODE XREF: AreSameMethodNames(char const *,char const *)+3Fp
.text:0000D158                                         ; AreSameMethodNames(char const *,char const *)+4Cp
.text:0000D158
.text:0000D158 arg_0           = byte ptr  8
.text:0000D158
.text:0000D158                 push    ebp
.text:0000D159                 mov     ebp, esp
.text:0000D15B                 movsx   eax, [ebp+arg_0]
.text:0000D15F                 cmp     eax, 41h ; 'A'
.text:0000D162                 jl      short loc_D176
.text:0000D164                 movsx   ecx, [ebp+arg_0]
.text:0000D168                 cmp     ecx, 5Ah ; 'Z'
.text:0000D16B                 jg      short loc_D176
.text:0000D16D                 movzx   eax, [ebp+arg_0]
.text:0000D171                 add     eax, 20h ; ' '
.text:0000D174                 jmp     short loc_D179
.text:0000D176 ; ---------------------------------------------------------------------------
.text:0000D176
.text:0000D176 loc_D176:                               ; CODE XREF: MyCharLower_Ascii(char)+Aj
.text:0000D176                                         ; MyCharLower_Ascii(char)+13j
.text:0000D176                 mov     al, [ebp+arg_0]
.text:0000D179
.text:0000D179 loc_D179:                               ; CODE XREF: MyCharLower_Ascii(char)+1Cj
.text:0000D179                 pop     ebp
.text:0000D17A                 retn    4
.text:0000D17A ?MyCharLower_Ascii@@YGDD@Z endp
.text:0000D17A
.text:0000D17A ; ---------------------------------------------------------------------------
.text:0000D17D                 align 10h
.text:0000D17D _text           ends
.text:0000D17D
.text:0000D180 ; ===========================================================================
.text:0000D180
.text:0000D180 ; Segment type: Pure code
.text:0000D180 ; Segment permissions: Read/Execute
.text:0000D180 _text           segment para public 'CODE' use32
.text:0000D180                 assume cs:_text
.text:0000D180                 ;org 0D180h
.text:0000D180 ; COMDAT (pick any)
.text:0000D180                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000D180
.text:0000D180 ; =============== S U B R O U T I N E =======================================
.text:0000D180
.text:0000D180 ; Attributes: bp-based frame
.text:0000D180
.text:0000D180 ; public: unsigned int __thiscall CObjectVector<struct CProp>::Size(void)const
.text:0000D180                 public ?Size@?$CObjectVector@UCProp@@@@QBEIXZ
.text:0000D180 ?Size@?$CObjectVector@UCProp@@@@QBEIXZ proc near
.text:0000D180                                         ; CODE XREF: CProps::AreThereNonOptionalProps(void)+2Cp
.text:0000D180                                         ; CObjectVector<CProp>::CObjectVector<CProp>(CObjectVector<CProp> const &)+51p ...
.text:0000D180
.text:0000D180 var_4           = dword ptr -4
.text:0000D180
.text:0000D180                 push    ebp
.text:0000D181                 mov     ebp, esp
.text:0000D183                 push    ecx
.text:0000D184                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000D18B                 mov     [ebp+var_4], ecx
.text:0000D18E                 mov     ecx, [ebp+var_4]
.text:0000D191                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:0000D196                 add     esp, 4
.text:0000D199                 cmp     ebp, esp
.text:0000D19B                 call    __RTC_CheckEsp
.text:0000D1A0                 mov     esp, ebp
.text:0000D1A2                 pop     ebp
.text:0000D1A3                 retn
.text:0000D1A3 ?Size@?$CObjectVector@UCProp@@@@QBEIXZ endp
.text:0000D1A3
.text:0000D1A3 _text           ends
.text:0000D1A3
.text:0000D1A4 ; ===========================================================================
.text:0000D1A4
.text:0000D1A4 ; Segment type: Pure code
.text:0000D1A4 ; Segment permissions: Read/Execute
.text:0000D1A4 _text           segment para public 'CODE' use32
.text:0000D1A4                 assume cs:_text
.text:0000D1A4                 ;org 0D1A4h
.text:0000D1A4 ; COMDAT (pick any)
.text:0000D1A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000D1A4
.text:0000D1A4 ; =============== S U B R O U T I N E =======================================
.text:0000D1A4
.text:0000D1A4 ; Attributes: bp-based frame
.text:0000D1A4
.text:0000D1A4 ; public: __thiscall CObjectVector<struct CProp>::CObjectVector<struct CProp>(void)
.text:0000D1A4                 public ??0?$CObjectVector@UCProp@@@@QAE@XZ
.text:0000D1A4 ??0?$CObjectVector@UCProp@@@@QAE@XZ proc near
.text:0000D1A4                                         ; CODE XREF: CProps::CProps(void)+11p
.text:0000D1A4
.text:0000D1A4 var_4           = dword ptr -4
.text:0000D1A4
.text:0000D1A4                 push    ebp
.text:0000D1A5                 mov     ebp, esp
.text:0000D1A7                 push    ecx
.text:0000D1A8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000D1AF                 mov     [ebp+var_4], ecx
.text:0000D1B2                 mov     ecx, [ebp+var_4]
.text:0000D1B5                 call    ??0?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::CRecordVector<void *>(void)
.text:0000D1BA                 mov     eax, [ebp+var_4]
.text:0000D1BD                 add     esp, 4
.text:0000D1C0                 cmp     ebp, esp
.text:0000D1C2                 call    __RTC_CheckEsp
.text:0000D1C7                 mov     esp, ebp
.text:0000D1C9                 pop     ebp
.text:0000D1CA                 retn
.text:0000D1CA ??0?$CObjectVector@UCProp@@@@QAE@XZ endp
.text:0000D1CA
.text:0000D1CA ; ---------------------------------------------------------------------------
.text:0000D1CB                 align 4
.text:0000D1CB _text           ends
.text:0000D1CB
.text:0000D1CC ; ===========================================================================
.text:0000D1CC
.text:0000D1CC ; Segment type: Pure code
.text:0000D1CC ; Segment permissions: Read/Execute
.text:0000D1CC _text           segment para public 'CODE' use32
.text:0000D1CC                 assume cs:_text
.text:0000D1CC                 ;org 0D1CCh
.text:0000D1CC ; COMDAT (pick any)
.text:0000D1CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000D1CC
.text:0000D1CC ; =============== S U B R O U T I N E =======================================
.text:0000D1CC
.text:0000D1CC ; Attributes: bp-based frame
.text:0000D1CC
.text:0000D1CC ; public: __thiscall CObjectVector<struct CProp>::CObjectVector<struct CProp>(class CObjectVector<struct CProp> const &)
.text:0000D1CC                 public ??0?$CObjectVector@UCProp@@@@QAE@ABV0@@Z
.text:0000D1CC ??0?$CObjectVector@UCProp@@@@QAE@ABV0@@Z proc near
.text:0000D1CC                                         ; CODE XREF: CProps::CProps(CProps const &)+15p
.text:0000D1CC
.text:0000D1CC var_24          = dword ptr -24h
.text:0000D1CC var_20          = dword ptr -20h
.text:0000D1CC var_1C          = dword ptr -1Ch
.text:0000D1CC var_18          = dword ptr -18h
.text:0000D1CC var_14          = dword ptr -14h
.text:0000D1CC var_10          = dword ptr -10h
.text:0000D1CC var_C           = dword ptr -0Ch
.text:0000D1CC var_4           = dword ptr -4
.text:0000D1CC arg_0           = dword ptr  8
.text:0000D1CC
.text:0000D1CC                 push    ebp
.text:0000D1CD                 mov     ebp, esp
.text:0000D1CF                 push    0FFFFFFFFh
.text:0000D1D1                 push    offset __ehhandler$??0?$CObjectVector@UCProp@@@@QAE@ABV0@@Z
.text:0000D1D6                 mov     eax, large fs:0
.text:0000D1DC                 push    eax
.text:0000D1DD                 sub     esp, 18h
.text:0000D1E0                 mov     eax, 0CCCCCCCCh
.text:0000D1E5                 mov     [ebp+var_24], eax
.text:0000D1E8                 mov     [ebp+var_20], eax
.text:0000D1EB                 mov     [ebp+var_1C], eax
.text:0000D1EE                 mov     [ebp+var_18], eax
.text:0000D1F1                 mov     [ebp+var_14], eax
.text:0000D1F4                 mov     [ebp+var_10], eax
.text:0000D1F7                 mov     eax, dword ptr ds:___security_cookie
.text:0000D1FC                 xor     eax, ebp
.text:0000D1FE                 push    eax
.text:0000D1FF                 lea     eax, [ebp+var_C]
.text:0000D202                 mov     large fs:0, eax
.text:0000D208                 mov     [ebp+var_10], ecx
.text:0000D20B                 mov     ecx, [ebp+var_10]
.text:0000D20E                 call    ??0?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::CRecordVector<void *>(void)
.text:0000D213                 mov     [ebp+var_4], 0
.text:0000D21A                 mov     ecx, [ebp+arg_0]
.text:0000D21D                 call    ?Size@?$CObjectVector@UCProp@@@@QBEIXZ ; CObjectVector<CProp>::Size(void)
.text:0000D222                 mov     [ebp+var_14], eax
.text:0000D225                 mov     eax, [ebp+var_14]
.text:0000D228                 push    eax
.text:0000D229                 mov     ecx, [ebp+var_10]
.text:0000D22C                 call    ?ConstructReserve@?$CRecordVector@PAX@@QAEXI@Z ; CRecordVector<void *>::ConstructReserve(uint)
.text:0000D231                 mov     [ebp+var_18], 0
.text:0000D238                 jmp     short loc_D243
.text:0000D23A ; ---------------------------------------------------------------------------
.text:0000D23A
.text:0000D23A loc_D23A:                               ; CODE XREF: CObjectVector<CProp>::CObjectVector<CProp>(CObjectVector<CProp> const &)+CDj
.text:0000D23A                 mov     ecx, [ebp+var_18]
.text:0000D23D                 add     ecx, 1
.text:0000D240                 mov     [ebp+var_18], ecx
.text:0000D243
.text:0000D243 loc_D243:                               ; CODE XREF: CObjectVector<CProp>::CObjectVector<CProp>(CObjectVector<CProp> const &)+6Cj
.text:0000D243                 mov     edx, [ebp+var_18]
.text:0000D246                 cmp     edx, [ebp+var_14]
.text:0000D249                 jnb     short loc_D29B
.text:0000D24B                 push    18h             ; unsigned int
.text:0000D24D                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0000D252                 add     esp, 4
.text:0000D255                 mov     [ebp+var_20], eax
.text:0000D258                 mov     byte ptr [ebp+var_4], 1
.text:0000D25C                 cmp     [ebp+var_20], 0
.text:0000D260                 jz      short loc_D27C
.text:0000D262                 mov     eax, [ebp+var_18]
.text:0000D265                 push    eax
.text:0000D266                 mov     ecx, [ebp+arg_0]
.text:0000D269                 call    ??A?$CObjectVector@UCProp@@@@QBEABUCProp@@I@Z ; CObjectVector<CProp>::operator[](uint)
.text:0000D26E                 push    eax             ; struct CProp *
.text:0000D26F                 mov     ecx, [ebp+var_20] ; this
.text:0000D272                 call    ??0CProp@@QAE@ABU0@@Z ; CProp::CProp(CProp const &)
.text:0000D277                 mov     [ebp+var_24], eax
.text:0000D27A                 jmp     short loc_D283
.text:0000D27C ; ---------------------------------------------------------------------------
.text:0000D27C
.text:0000D27C loc_D27C:                               ; CODE XREF: CObjectVector<CProp>::CObjectVector<CProp>(CObjectVector<CProp> const &)+94j
.text:0000D27C                 mov     [ebp+var_24], 0
.text:0000D283
.text:0000D283 loc_D283:                               ; CODE XREF: CObjectVector<CProp>::CObjectVector<CProp>(CObjectVector<CProp> const &)+AEj
.text:0000D283                 mov     ecx, [ebp+var_24]
.text:0000D286                 mov     [ebp+var_1C], ecx
.text:0000D289                 mov     byte ptr [ebp+var_4], 0
.text:0000D28D                 mov     edx, [ebp+var_1C]
.text:0000D290                 push    edx
.text:0000D291                 mov     ecx, [ebp+var_10]
.text:0000D294                 call    ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z ; CRecordVector<void *>::AddInReserved(void * const)
.text:0000D299                 jmp     short loc_D23A
.text:0000D29B ; ---------------------------------------------------------------------------
.text:0000D29B
.text:0000D29B loc_D29B:                               ; CODE XREF: CObjectVector<CProp>::CObjectVector<CProp>(CObjectVector<CProp> const &)+7Dj
.text:0000D29B                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000D2A2                 mov     eax, [ebp+var_10]
.text:0000D2A5                 mov     ecx, [ebp+var_C]
.text:0000D2A8                 mov     large fs:0, ecx
.text:0000D2AF                 pop     ecx
.text:0000D2B0                 add     esp, 24h
.text:0000D2B3                 cmp     ebp, esp
.text:0000D2B5                 call    __RTC_CheckEsp
.text:0000D2BA                 mov     esp, ebp
.text:0000D2BC                 pop     ebp
.text:0000D2BD                 retn    4
.text:0000D2BD ??0?$CObjectVector@UCProp@@@@QAE@ABV0@@Z endp
.text:0000D2BD
.text:0000D2BD _text           ends
.text:0000D2BD
.text$x:0000D2C0 ; ===========================================================================
.text$x:0000D2C0
.text$x:0000D2C0 ; Segment type: Pure code
.text$x:0000D2C0 ; Segment permissions: Read/Execute
.text$x:0000D2C0 _text$x         segment para public 'CODE' use32
.text$x:0000D2C0                 assume cs:_text$x
.text$x:0000D2C0                 ;org 0D2C0h
.text$x:0000D2C0 ; COMDAT (pick associative to section at D1CC)
.text$x:0000D2C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000D2C0
.text$x:0000D2C0 ; =============== S U B R O U T I N E =======================================
.text$x:0000D2C0
.text$x:0000D2C0
.text$x:0000D2C0 __unwindfunclet$??0?$CObjectVector@UCProp@@@@QAE@ABV0@@Z$0 proc near
.text$x:0000D2C0                                         ; DATA XREF: .xdata$x:0000D2F4o
.text$x:0000D2C0                 mov     ecx, [ebp-10h]
.text$x:0000D2C3                 jmp     ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text$x:0000D2C3 __unwindfunclet$??0?$CObjectVector@UCProp@@@@QAE@ABV0@@Z$0 endp
.text$x:0000D2C3
.text$x:0000D2C8
.text$x:0000D2C8 ; =============== S U B R O U T I N E =======================================
.text$x:0000D2C8
.text$x:0000D2C8
.text$x:0000D2C8 __unwindfunclet$??0?$CObjectVector@UCProp@@@@QAE@ABV0@@Z$1 proc near
.text$x:0000D2C8                                         ; DATA XREF: .xdata$x:0000D2FCo
.text$x:0000D2C8                 mov     eax, [ebp-20h]
.text$x:0000D2CB                 push    eax             ; void *
.text$x:0000D2CC                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:0000D2D1                 pop     ecx
.text$x:0000D2D2                 retn
.text$x:0000D2D2 __unwindfunclet$??0?$CObjectVector@UCProp@@@@QAE@ABV0@@Z$1 endp
.text$x:0000D2D2
.text$x:0000D2D3
.text$x:0000D2D3 ; =============== S U B R O U T I N E =======================================
.text$x:0000D2D3
.text$x:0000D2D3
.text$x:0000D2D3 __ehhandler$??0?$CObjectVector@UCProp@@@@QAE@ABV0@@Z proc near
.text$x:0000D2D3                                         ; DATA XREF: CObjectVector<CProp>::CObjectVector<CProp>(CObjectVector<CProp> const &)+5o
.text$x:0000D2D3
.text$x:0000D2D3 arg_4           = dword ptr  8
.text$x:0000D2D3
.text$x:0000D2D3                 mov     edx, [esp+arg_4]
.text$x:0000D2D7                 lea     eax, [edx+0Ch]
.text$x:0000D2DA                 mov     ecx, [edx-1Ch]
.text$x:0000D2DD                 xor     ecx, eax
.text$x:0000D2DF                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000D2E4                 mov     eax, offset __ehfuncinfo$??0?$CObjectVector@UCProp@@@@QAE@ABV0@@Z
.text$x:0000D2E9                 jmp     ___CxxFrameHandler3
.text$x:0000D2E9 __ehhandler$??0?$CObjectVector@UCProp@@@@QAE@ABV0@@Z endp
.text$x:0000D2E9
.text$x:0000D2E9 ; ---------------------------------------------------------------------------
.text$x:0000D2EE                 align 10h
.text$x:0000D2EE _text$x         ends
.text$x:0000D2EE
.xdata$x:0000D2F0 ; ===========================================================================
.xdata$x:0000D2F0
.xdata$x:0000D2F0 ; Segment type: Pure data
.xdata$x:0000D2F0 ; Segment permissions: Read
.xdata$x:0000D2F0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D2F0                 assume cs:_xdata$x
.xdata$x:0000D2F0                 ;org 0D2F0h
.xdata$x:0000D2F0 ; COMDAT (pick associative to section at D1CC)
.xdata$x:0000D2F0 __unwindtable$??0?$CObjectVector@UCProp@@@@QAE@ABV0@@Z db 0FFh
.xdata$x:0000D2F0                                         ; DATA XREF: .xdata$x:0000D308o
.xdata$x:0000D2F1                 db 0FFh
.xdata$x:0000D2F2                 db 0FFh
.xdata$x:0000D2F3                 db 0FFh
.xdata$x:0000D2F4                 dd offset __unwindfunclet$??0?$CObjectVector@UCProp@@@@QAE@ABV0@@Z$0
.xdata$x:0000D2F8                 db    0
.xdata$x:0000D2F9                 db    0
.xdata$x:0000D2FA                 db    0
.xdata$x:0000D2FB                 db    0
.xdata$x:0000D2FC                 dd offset __unwindfunclet$??0?$CObjectVector@UCProp@@@@QAE@ABV0@@Z$1
.xdata$x:0000D300 __ehfuncinfo$??0?$CObjectVector@UCProp@@@@QAE@ABV0@@Z db  22h ; "
.xdata$x:0000D300                                         ; DATA XREF: __ehhandler$??0?$CObjectVector@UCProp@@@@QAE@ABV0@@Z+11o
.xdata$x:0000D301                 db    5
.xdata$x:0000D302                 db  93h ; ô
.xdata$x:0000D303                 db  19h
.xdata$x:0000D304                 db    2
.xdata$x:0000D305                 db    0
.xdata$x:0000D306                 db    0
.xdata$x:0000D307                 db    0
.xdata$x:0000D308                 dd offset __unwindtable$??0?$CObjectVector@UCProp@@@@QAE@ABV0@@Z
.xdata$x:0000D30C                 align 20h
.xdata$x:0000D320                 db    1
.xdata$x:0000D321                 db    0
.xdata$x:0000D322                 db    0
.xdata$x:0000D323                 db    0
.xdata$x:0000D323 _xdata$x        ends
.xdata$x:0000D323
.text:0000D324 ; ===========================================================================
.text:0000D324
.text:0000D324 ; Segment type: Pure code
.text:0000D324 ; Segment permissions: Read/Execute
.text:0000D324 _text           segment para public 'CODE' use32
.text:0000D324                 assume cs:_text
.text:0000D324                 ;org 0D324h
.text:0000D324 ; COMDAT (pick any)
.text:0000D324                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000D324
.text:0000D324 ; =============== S U B R O U T I N E =======================================
.text:0000D324
.text:0000D324 ; Attributes: bp-based frame
.text:0000D324
.text:0000D324 ; public: class CObjectVector<struct CProp> & __thiscall CObjectVector<struct CProp>::operator=(class CObjectVector<struct CProp> const &)
.text:0000D324                 public ??4?$CObjectVector@UCProp@@@@QAEAAV0@ABV0@@Z
.text:0000D324 ??4?$CObjectVector@UCProp@@@@QAEAAV0@ABV0@@Z proc near
.text:0000D324                                         ; CODE XREF: CProps::operator=(CProps const &)+15p
.text:0000D324
.text:0000D324 var_24          = dword ptr -24h
.text:0000D324 var_20          = dword ptr -20h
.text:0000D324 var_1C          = dword ptr -1Ch
.text:0000D324 var_18          = dword ptr -18h
.text:0000D324 var_14          = dword ptr -14h
.text:0000D324 var_10          = dword ptr -10h
.text:0000D324 var_C           = dword ptr -0Ch
.text:0000D324 var_4           = dword ptr -4
.text:0000D324 arg_0           = dword ptr  8
.text:0000D324
.text:0000D324                 push    ebp
.text:0000D325                 mov     ebp, esp
.text:0000D327                 push    0FFFFFFFFh
.text:0000D329                 push    offset __ehhandler$??4?$CObjectVector@UCProp@@@@QAEAAV0@ABV0@@Z
.text:0000D32E                 mov     eax, large fs:0
.text:0000D334                 push    eax
.text:0000D335                 sub     esp, 18h
.text:0000D338                 mov     eax, 0CCCCCCCCh
.text:0000D33D                 mov     [ebp+var_24], eax
.text:0000D340                 mov     [ebp+var_20], eax
.text:0000D343                 mov     [ebp+var_1C], eax
.text:0000D346                 mov     [ebp+var_18], eax
.text:0000D349                 mov     [ebp+var_14], eax
.text:0000D34C                 mov     [ebp+var_10], eax
.text:0000D34F                 mov     eax, dword ptr ds:___security_cookie
.text:0000D354                 xor     eax, ebp
.text:0000D356                 push    eax
.text:0000D357                 lea     eax, [ebp+var_C]
.text:0000D35A                 mov     large fs:0, eax
.text:0000D360                 mov     [ebp+var_10], ecx
.text:0000D363                 mov     eax, [ebp+arg_0]
.text:0000D366                 cmp     eax, [ebp+var_10]
.text:0000D369                 jnz     short loc_D373
.text:0000D36B                 mov     eax, [ebp+var_10]
.text:0000D36E                 jmp     loc_D405
.text:0000D373 ; ---------------------------------------------------------------------------
.text:0000D373
.text:0000D373 loc_D373:                               ; CODE XREF: CObjectVector<CProp>::operator=(CObjectVector<CProp> const &)+45j
.text:0000D373                 mov     ecx, [ebp+var_10]
.text:0000D376                 call    ?Clear@?$CObjectVector@UCProp@@@@QAEXXZ ; CObjectVector<CProp>::Clear(void)
.text:0000D37B                 mov     ecx, [ebp+arg_0]
.text:0000D37E                 call    ?Size@?$CObjectVector@UCProp@@@@QBEIXZ ; CObjectVector<CProp>::Size(void)
.text:0000D383                 mov     [ebp+var_14], eax
.text:0000D386                 mov     ecx, [ebp+var_14]
.text:0000D389                 push    ecx
.text:0000D38A                 mov     ecx, [ebp+var_10]
.text:0000D38D                 call    ?Reserve@?$CRecordVector@PAX@@QAEXI@Z ; CRecordVector<void *>::Reserve(uint)
.text:0000D392                 mov     [ebp+var_18], 0
.text:0000D399                 jmp     short loc_D3A4
.text:0000D39B ; ---------------------------------------------------------------------------
.text:0000D39B
.text:0000D39B loc_D39B:                               ; CODE XREF: CObjectVector<CProp>::operator=(CObjectVector<CProp> const &)+DCj
.text:0000D39B                 mov     edx, [ebp+var_18]
.text:0000D39E                 add     edx, 1
.text:0000D3A1                 mov     [ebp+var_18], edx
.text:0000D3A4
.text:0000D3A4 loc_D3A4:                               ; CODE XREF: CObjectVector<CProp>::operator=(CObjectVector<CProp> const &)+75j
.text:0000D3A4                 mov     eax, [ebp+var_18]
.text:0000D3A7                 cmp     eax, [ebp+var_14]
.text:0000D3AA                 jnb     short loc_D402
.text:0000D3AC                 push    18h             ; unsigned int
.text:0000D3AE                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0000D3B3                 add     esp, 4
.text:0000D3B6                 mov     [ebp+var_20], eax
.text:0000D3B9                 mov     [ebp+var_4], 0
.text:0000D3C0                 cmp     [ebp+var_20], 0
.text:0000D3C4                 jz      short loc_D3E0
.text:0000D3C6                 mov     ecx, [ebp+var_18]
.text:0000D3C9                 push    ecx
.text:0000D3CA                 mov     ecx, [ebp+arg_0]
.text:0000D3CD                 call    ??A?$CObjectVector@UCProp@@@@QBEABUCProp@@I@Z ; CObjectVector<CProp>::operator[](uint)
.text:0000D3D2                 push    eax             ; struct CProp *
.text:0000D3D3                 mov     ecx, [ebp+var_20] ; this
.text:0000D3D6                 call    ??0CProp@@QAE@ABU0@@Z ; CProp::CProp(CProp const &)
.text:0000D3DB                 mov     [ebp+var_24], eax
.text:0000D3DE                 jmp     short loc_D3E7
.text:0000D3E0 ; ---------------------------------------------------------------------------
.text:0000D3E0
.text:0000D3E0 loc_D3E0:                               ; CODE XREF: CObjectVector<CProp>::operator=(CObjectVector<CProp> const &)+A0j
.text:0000D3E0                 mov     [ebp+var_24], 0
.text:0000D3E7
.text:0000D3E7 loc_D3E7:                               ; CODE XREF: CObjectVector<CProp>::operator=(CObjectVector<CProp> const &)+BAj
.text:0000D3E7                 mov     edx, [ebp+var_24]
.text:0000D3EA                 mov     [ebp+var_1C], edx
.text:0000D3ED                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000D3F4                 mov     eax, [ebp+var_1C]
.text:0000D3F7                 push    eax
.text:0000D3F8                 mov     ecx, [ebp+var_10]
.text:0000D3FB                 call    ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z ; CRecordVector<void *>::AddInReserved(void * const)
.text:0000D400                 jmp     short loc_D39B
.text:0000D402 ; ---------------------------------------------------------------------------
.text:0000D402
.text:0000D402 loc_D402:                               ; CODE XREF: CObjectVector<CProp>::operator=(CObjectVector<CProp> const &)+86j
.text:0000D402                 mov     eax, [ebp+var_10]
.text:0000D405
.text:0000D405 loc_D405:                               ; CODE XREF: CObjectVector<CProp>::operator=(CObjectVector<CProp> const &)+4Aj
.text:0000D405                 mov     ecx, [ebp+var_C]
.text:0000D408                 mov     large fs:0, ecx
.text:0000D40F                 pop     ecx
.text:0000D410                 add     esp, 24h
.text:0000D413                 cmp     ebp, esp
.text:0000D415                 call    __RTC_CheckEsp
.text:0000D41A                 mov     esp, ebp
.text:0000D41C                 pop     ebp
.text:0000D41D                 retn    4
.text:0000D41D ??4?$CObjectVector@UCProp@@@@QAEAAV0@ABV0@@Z endp
.text:0000D41D
.text:0000D41D _text           ends
.text:0000D41D
.text$x:0000D420 ; ===========================================================================
.text$x:0000D420
.text$x:0000D420 ; Segment type: Pure code
.text$x:0000D420 ; Segment permissions: Read/Execute
.text$x:0000D420 _text$x         segment para public 'CODE' use32
.text$x:0000D420                 assume cs:_text$x
.text$x:0000D420                 ;org 0D420h
.text$x:0000D420 ; COMDAT (pick associative to section at D324)
.text$x:0000D420                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000D420
.text$x:0000D420 ; =============== S U B R O U T I N E =======================================
.text$x:0000D420
.text$x:0000D420
.text$x:0000D420 __unwindfunclet$??4?$CObjectVector@UCProp@@@@QAEAAV0@ABV0@@Z$0 proc near
.text$x:0000D420                                         ; DATA XREF: .xdata$x:0000D44Co
.text$x:0000D420                 mov     eax, [ebp-20h]
.text$x:0000D423                 push    eax             ; void *
.text$x:0000D424                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:0000D429                 pop     ecx
.text$x:0000D42A                 retn
.text$x:0000D42A __unwindfunclet$??4?$CObjectVector@UCProp@@@@QAEAAV0@ABV0@@Z$0 endp
.text$x:0000D42A
.text$x:0000D42B
.text$x:0000D42B ; =============== S U B R O U T I N E =======================================
.text$x:0000D42B
.text$x:0000D42B
.text$x:0000D42B __ehhandler$??4?$CObjectVector@UCProp@@@@QAEAAV0@ABV0@@Z proc near
.text$x:0000D42B                                         ; DATA XREF: CObjectVector<CProp>::operator=(CObjectVector<CProp> const &)+5o
.text$x:0000D42B
.text$x:0000D42B arg_4           = dword ptr  8
.text$x:0000D42B
.text$x:0000D42B                 mov     edx, [esp+arg_4]
.text$x:0000D42F                 lea     eax, [edx+0Ch]
.text$x:0000D432                 mov     ecx, [edx-1Ch]
.text$x:0000D435                 xor     ecx, eax
.text$x:0000D437                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000D43C                 mov     eax, offset __ehfuncinfo$??4?$CObjectVector@UCProp@@@@QAEAAV0@ABV0@@Z
.text$x:0000D441                 jmp     ___CxxFrameHandler3
.text$x:0000D441 __ehhandler$??4?$CObjectVector@UCProp@@@@QAEAAV0@ABV0@@Z endp
.text$x:0000D441
.text$x:0000D441 ; ---------------------------------------------------------------------------
.text$x:0000D446                 align 4
.text$x:0000D446 _text$x         ends
.text$x:0000D446
.xdata$x:0000D448 ; ===========================================================================
.xdata$x:0000D448
.xdata$x:0000D448 ; Segment type: Pure data
.xdata$x:0000D448 ; Segment permissions: Read
.xdata$x:0000D448 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D448                 assume cs:_xdata$x
.xdata$x:0000D448                 ;org 0D448h
.xdata$x:0000D448 ; COMDAT (pick associative to section at D324)
.xdata$x:0000D448 __unwindtable$??4?$CObjectVector@UCProp@@@@QAEAAV0@ABV0@@Z db 0FFh
.xdata$x:0000D448                                         ; DATA XREF: .xdata$x:0000D458o
.xdata$x:0000D449                 db 0FFh
.xdata$x:0000D44A                 db 0FFh
.xdata$x:0000D44B                 db 0FFh
.xdata$x:0000D44C                 dd offset __unwindfunclet$??4?$CObjectVector@UCProp@@@@QAEAAV0@ABV0@@Z$0
.xdata$x:0000D450 __ehfuncinfo$??4?$CObjectVector@UCProp@@@@QAEAAV0@ABV0@@Z db  22h ; "
.xdata$x:0000D450                                         ; DATA XREF: __ehhandler$??4?$CObjectVector@UCProp@@@@QAEAAV0@ABV0@@Z+11o
.xdata$x:0000D451                 db    5
.xdata$x:0000D452                 db  93h ; ô
.xdata$x:0000D453                 db  19h
.xdata$x:0000D454                 db    1
.xdata$x:0000D455                 db    0
.xdata$x:0000D456                 db    0
.xdata$x:0000D457                 db    0
.xdata$x:0000D458                 dd offset __unwindtable$??4?$CObjectVector@UCProp@@@@QAEAAV0@ABV0@@Z
.xdata$x:0000D45C                 db    0
.xdata$x:0000D45D                 db    0
.xdata$x:0000D45E                 db    0
.xdata$x:0000D45F                 db    0
.xdata$x:0000D460                 db    0
.xdata$x:0000D461                 db    0
.xdata$x:0000D462                 db    0
.xdata$x:0000D463                 db    0
.xdata$x:0000D464                 db    0
.xdata$x:0000D465                 db    0
.xdata$x:0000D466                 db    0
.xdata$x:0000D467                 db    0
.xdata$x:0000D468                 db    0
.xdata$x:0000D469                 db    0
.xdata$x:0000D46A                 db    0
.xdata$x:0000D46B                 db    0
.xdata$x:0000D46C                 db    0
.xdata$x:0000D46D                 db    0
.xdata$x:0000D46E                 db    0
.xdata$x:0000D46F                 db    0
.xdata$x:0000D470                 db    1
.xdata$x:0000D471                 db    0
.xdata$x:0000D472                 db    0
.xdata$x:0000D473                 db    0
.xdata$x:0000D473 _xdata$x        ends
.xdata$x:0000D473
.text:0000D474 ; ===========================================================================
.text:0000D474
.text:0000D474 ; Segment type: Pure code
.text:0000D474 ; Segment permissions: Read/Execute
.text:0000D474 _text           segment para public 'CODE' use32
.text:0000D474                 assume cs:_text
.text:0000D474                 ;org 0D474h
.text:0000D474 ; COMDAT (pick any)
.text:0000D474                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000D474
.text:0000D474 ; =============== S U B R O U T I N E =======================================
.text:0000D474
.text:0000D474 ; Attributes: bp-based frame
.text:0000D474
.text:0000D474 ; public: struct CProp const & __thiscall CObjectVector<struct CProp>::operator[](unsigned int)const
.text:0000D474                 public ??A?$CObjectVector@UCProp@@@@QBEABUCProp@@I@Z
.text:0000D474 ??A?$CObjectVector@UCProp@@@@QBEABUCProp@@I@Z proc near
.text:0000D474                                         ; CODE XREF: CProps::AreThereNonOptionalProps(void)+3Dp
.text:0000D474                                         ; CMethodProps::Get_DicSize(uint &)+3Ap ...
.text:0000D474
.text:0000D474 var_4           = dword ptr -4
.text:0000D474 arg_0           = dword ptr  8
.text:0000D474
.text:0000D474                 push    ebp
.text:0000D475                 mov     ebp, esp
.text:0000D477                 push    ecx
.text:0000D478                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000D47F                 mov     [ebp+var_4], ecx
.text:0000D482                 mov     eax, [ebp+arg_0]
.text:0000D485                 push    eax
.text:0000D486                 mov     ecx, [ebp+var_4]
.text:0000D489                 call    ??A?$CRecordVector@PAX@@QBEABQAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:0000D48E                 mov     eax, [eax]
.text:0000D490                 add     esp, 4
.text:0000D493                 cmp     ebp, esp
.text:0000D495                 call    __RTC_CheckEsp
.text:0000D49A                 mov     esp, ebp
.text:0000D49C                 pop     ebp
.text:0000D49D                 retn    4
.text:0000D49D ??A?$CObjectVector@UCProp@@@@QBEABUCProp@@I@Z endp
.text:0000D49D
.text:0000D49D _text           ends
.text:0000D49D
.text:0000D4A0 ; ===========================================================================
.text:0000D4A0
.text:0000D4A0 ; Segment type: Pure code
.text:0000D4A0 ; Segment permissions: Read/Execute
.text:0000D4A0 _text           segment para public 'CODE' use32
.text:0000D4A0                 assume cs:_text
.text:0000D4A0                 ;org 0D4A0h
.text:0000D4A0 ; COMDAT (pick any)
.text:0000D4A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000D4A0
.text:0000D4A0 ; =============== S U B R O U T I N E =======================================
.text:0000D4A0
.text:0000D4A0 ; Attributes: bp-based frame
.text:0000D4A0
.text:0000D4A0 ; public: __thiscall CObjectVector<struct CProp>::~CObjectVector<struct CProp>(void)
.text:0000D4A0                 public ??1?$CObjectVector@UCProp@@@@QAE@XZ
.text:0000D4A0 ??1?$CObjectVector@UCProp@@@@QAE@XZ proc near
.text:0000D4A0                                         ; CODE XREF: CProps::~CProps(void)+11p
.text:0000D4A0
.text:0000D4A0 var_20          = dword ptr -20h
.text:0000D4A0 var_1C          = dword ptr -1Ch
.text:0000D4A0 var_18          = dword ptr -18h
.text:0000D4A0 var_14          = dword ptr -14h
.text:0000D4A0 var_10          = dword ptr -10h
.text:0000D4A0 var_C           = dword ptr -0Ch
.text:0000D4A0 var_4           = dword ptr -4
.text:0000D4A0
.text:0000D4A0                 push    ebp
.text:0000D4A1                 mov     ebp, esp
.text:0000D4A3                 push    0FFFFFFFFh
.text:0000D4A5                 push    offset __ehhandler$??1?$CObjectVector@UCProp@@@@QAE@XZ
.text:0000D4AA                 mov     eax, large fs:0
.text:0000D4B0                 push    eax
.text:0000D4B1                 sub     esp, 14h
.text:0000D4B4                 mov     eax, 0CCCCCCCCh
.text:0000D4B9                 mov     [ebp+var_20], eax
.text:0000D4BC                 mov     [ebp+var_1C], eax
.text:0000D4BF                 mov     [ebp+var_18], eax
.text:0000D4C2                 mov     [ebp+var_14], eax
.text:0000D4C5                 mov     [ebp+var_10], eax
.text:0000D4C8                 mov     eax, dword ptr ds:___security_cookie
.text:0000D4CD                 xor     eax, ebp
.text:0000D4CF                 push    eax
.text:0000D4D0                 lea     eax, [ebp+var_C]
.text:0000D4D3                 mov     large fs:0, eax
.text:0000D4D9                 mov     [ebp+var_10], ecx
.text:0000D4DC                 mov     [ebp+var_4], 0
.text:0000D4E3                 mov     ecx, [ebp+var_10]
.text:0000D4E6                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:0000D4EB                 mov     [ebp+var_14], eax
.text:0000D4EE
.text:0000D4EE loc_D4EE:                               ; CODE XREF: CObjectVector<CProp>::~CObjectVector<CProp>(void):loc_D530j
.text:0000D4EE                 cmp     [ebp+var_14], 0
.text:0000D4F2                 jz      short loc_D532
.text:0000D4F4                 mov     eax, [ebp+var_14]
.text:0000D4F7                 sub     eax, 1
.text:0000D4FA                 mov     [ebp+var_14], eax
.text:0000D4FD                 mov     ecx, [ebp+var_14]
.text:0000D500                 push    ecx
.text:0000D501                 mov     ecx, [ebp+var_10]
.text:0000D504                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:0000D509                 mov     edx, [eax]
.text:0000D50B                 mov     [ebp+var_1C], edx
.text:0000D50E                 mov     eax, [ebp+var_1C]
.text:0000D511                 mov     [ebp+var_18], eax
.text:0000D514                 cmp     [ebp+var_18], 0
.text:0000D518                 jz      short loc_D529
.text:0000D51A                 push    1
.text:0000D51C                 mov     ecx, [ebp+var_18]
.text:0000D51F                 call    ??_GCProp@@QAEPAXI@Z ; CProp::`scalar deleting destructor'(uint)
.text:0000D524                 mov     [ebp+var_20], eax
.text:0000D527                 jmp     short loc_D530
.text:0000D529 ; ---------------------------------------------------------------------------
.text:0000D529
.text:0000D529 loc_D529:                               ; CODE XREF: CObjectVector<CProp>::~CObjectVector<CProp>(void)+78j
.text:0000D529                 mov     [ebp+var_20], 0
.text:0000D530
.text:0000D530 loc_D530:                               ; CODE XREF: CObjectVector<CProp>::~CObjectVector<CProp>(void)+87j
.text:0000D530                 jmp     short loc_D4EE
.text:0000D532 ; ---------------------------------------------------------------------------
.text:0000D532
.text:0000D532 loc_D532:                               ; CODE XREF: CObjectVector<CProp>::~CObjectVector<CProp>(void)+52j
.text:0000D532                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000D539                 mov     ecx, [ebp+var_10]
.text:0000D53C                 call    ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text:0000D541                 mov     ecx, [ebp+var_C]
.text:0000D544                 mov     large fs:0, ecx
.text:0000D54B                 pop     ecx
.text:0000D54C                 add     esp, 20h
.text:0000D54F                 cmp     ebp, esp
.text:0000D551                 call    __RTC_CheckEsp
.text:0000D556                 mov     esp, ebp
.text:0000D558                 pop     ebp
.text:0000D559                 retn
.text:0000D559 ??1?$CObjectVector@UCProp@@@@QAE@XZ endp
.text:0000D559
.text:0000D559 ; ---------------------------------------------------------------------------
.text:0000D55A                 align 4
.text:0000D55A _text           ends
.text:0000D55A
.text$x:0000D55C ; ===========================================================================
.text$x:0000D55C
.text$x:0000D55C ; Segment type: Pure code
.text$x:0000D55C ; Segment permissions: Read/Execute
.text$x:0000D55C _text$x         segment para public 'CODE' use32
.text$x:0000D55C                 assume cs:_text$x
.text$x:0000D55C                 ;org 0D55Ch
.text$x:0000D55C ; COMDAT (pick associative to section at D4A0)
.text$x:0000D55C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000D55C
.text$x:0000D55C ; =============== S U B R O U T I N E =======================================
.text$x:0000D55C
.text$x:0000D55C
.text$x:0000D55C __unwindfunclet$??1?$CObjectVector@UCProp@@@@QAE@XZ$0 proc near
.text$x:0000D55C                                         ; DATA XREF: .xdata$x:0000D584o
.text$x:0000D55C                 mov     ecx, [ebp-10h]
.text$x:0000D55F                 jmp     ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text$x:0000D55F __unwindfunclet$??1?$CObjectVector@UCProp@@@@QAE@XZ$0 endp
.text$x:0000D55F
.text$x:0000D564
.text$x:0000D564 ; =============== S U B R O U T I N E =======================================
.text$x:0000D564
.text$x:0000D564
.text$x:0000D564 __ehhandler$??1?$CObjectVector@UCProp@@@@QAE@XZ proc near
.text$x:0000D564                                         ; DATA XREF: CObjectVector<CProp>::~CObjectVector<CProp>(void)+5o
.text$x:0000D564
.text$x:0000D564 arg_4           = dword ptr  8
.text$x:0000D564
.text$x:0000D564                 mov     edx, [esp+arg_4]
.text$x:0000D568                 lea     eax, [edx+0Ch]
.text$x:0000D56B                 mov     ecx, [edx-18h]
.text$x:0000D56E                 xor     ecx, eax
.text$x:0000D570                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000D575                 mov     eax, offset __ehfuncinfo$??1?$CObjectVector@UCProp@@@@QAE@XZ
.text$x:0000D57A                 jmp     ___CxxFrameHandler3
.text$x:0000D57A __ehhandler$??1?$CObjectVector@UCProp@@@@QAE@XZ endp
.text$x:0000D57A
.text$x:0000D57A ; ---------------------------------------------------------------------------
.text$x:0000D57F                 align 10h
.text$x:0000D57F _text$x         ends
.text$x:0000D57F
.xdata$x:0000D580 ; ===========================================================================
.xdata$x:0000D580
.xdata$x:0000D580 ; Segment type: Pure data
.xdata$x:0000D580 ; Segment permissions: Read
.xdata$x:0000D580 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D580                 assume cs:_xdata$x
.xdata$x:0000D580                 ;org 0D580h
.xdata$x:0000D580 ; COMDAT (pick associative to section at D4A0)
.xdata$x:0000D580 __unwindtable$??1?$CObjectVector@UCProp@@@@QAE@XZ db 0FFh
.xdata$x:0000D580                                         ; DATA XREF: .xdata$x:0000D590o
.xdata$x:0000D581                 db 0FFh
.xdata$x:0000D582                 db 0FFh
.xdata$x:0000D583                 db 0FFh
.xdata$x:0000D584                 dd offset __unwindfunclet$??1?$CObjectVector@UCProp@@@@QAE@XZ$0
.xdata$x:0000D588 __ehfuncinfo$??1?$CObjectVector@UCProp@@@@QAE@XZ db  22h ; "
.xdata$x:0000D588                                         ; DATA XREF: __ehhandler$??1?$CObjectVector@UCProp@@@@QAE@XZ+11o
.xdata$x:0000D589                 db    5
.xdata$x:0000D58A                 db  93h ; ô
.xdata$x:0000D58B                 db  19h
.xdata$x:0000D58C                 db    1
.xdata$x:0000D58D                 db    0
.xdata$x:0000D58E                 db    0
.xdata$x:0000D58F                 db    0
.xdata$x:0000D590                 dd offset __unwindtable$??1?$CObjectVector@UCProp@@@@QAE@XZ
.xdata$x:0000D594                 db    0
.xdata$x:0000D595                 db    0
.xdata$x:0000D596                 db    0
.xdata$x:0000D597                 db    0
.xdata$x:0000D598                 db    0
.xdata$x:0000D599                 db    0
.xdata$x:0000D59A                 db    0
.xdata$x:0000D59B                 db    0
.xdata$x:0000D59C                 db    0
.xdata$x:0000D59D                 db    0
.xdata$x:0000D59E                 db    0
.xdata$x:0000D59F                 db    0
.xdata$x:0000D5A0                 db    0
.xdata$x:0000D5A1                 db    0
.xdata$x:0000D5A2                 db    0
.xdata$x:0000D5A3                 db    0
.xdata$x:0000D5A4                 db    0
.xdata$x:0000D5A5                 db    0
.xdata$x:0000D5A6                 db    0
.xdata$x:0000D5A7                 db    0
.xdata$x:0000D5A8                 db    1
.xdata$x:0000D5A9                 db    0
.xdata$x:0000D5AA                 db    0
.xdata$x:0000D5AB                 db    0
.xdata$x:0000D5AB _xdata$x        ends
.xdata$x:0000D5AB
.text:0000D5AC ; ===========================================================================
.text:0000D5AC
.text:0000D5AC ; Segment type: Pure code
.text:0000D5AC ; Segment permissions: Read/Execute
.text:0000D5AC _text           segment para public 'CODE' use32
.text:0000D5AC                 assume cs:_text
.text:0000D5AC                 ;org 0D5ACh
.text:0000D5AC ; COMDAT (pick any)
.text:0000D5AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000D5AC
.text:0000D5AC ; =============== S U B R O U T I N E =======================================
.text:0000D5AC
.text:0000D5AC ; Attributes: bp-based frame
.text:0000D5AC
.text:0000D5AC ; public: void __thiscall CObjectVector<struct CProp>::Clear(void)
.text:0000D5AC                 public ?Clear@?$CObjectVector@UCProp@@@@QAEXXZ
.text:0000D5AC ?Clear@?$CObjectVector@UCProp@@@@QAEXXZ proc near
.text:0000D5AC                                         ; CODE XREF: CObjectVector<CProp>::operator=(CObjectVector<CProp> const &)+52p
.text:0000D5AC
.text:0000D5AC var_14          = dword ptr -14h
.text:0000D5AC var_10          = dword ptr -10h
.text:0000D5AC var_C           = dword ptr -0Ch
.text:0000D5AC var_8           = dword ptr -8
.text:0000D5AC var_4           = dword ptr -4
.text:0000D5AC
.text:0000D5AC                 push    ebp
.text:0000D5AD                 mov     ebp, esp
.text:0000D5AF                 sub     esp, 14h
.text:0000D5B2                 mov     eax, 0CCCCCCCCh
.text:0000D5B7                 mov     [ebp+var_14], eax
.text:0000D5BA                 mov     [ebp+var_10], eax
.text:0000D5BD                 mov     [ebp+var_C], eax
.text:0000D5C0                 mov     [ebp+var_8], eax
.text:0000D5C3                 mov     [ebp+var_4], eax
.text:0000D5C6                 mov     [ebp+var_4], ecx
.text:0000D5C9                 mov     ecx, [ebp+var_4]
.text:0000D5CC                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:0000D5D1                 mov     [ebp+var_8], eax
.text:0000D5D4
.text:0000D5D4 loc_D5D4:                               ; CODE XREF: CObjectVector<CProp>::Clear(void):loc_D616j
.text:0000D5D4                 cmp     [ebp+var_8], 0
.text:0000D5D8                 jz      short loc_D618
.text:0000D5DA                 mov     eax, [ebp+var_8]
.text:0000D5DD                 sub     eax, 1
.text:0000D5E0                 mov     [ebp+var_8], eax
.text:0000D5E3                 mov     ecx, [ebp+var_8]
.text:0000D5E6                 push    ecx
.text:0000D5E7                 mov     ecx, [ebp+var_4]
.text:0000D5EA                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:0000D5EF                 mov     edx, [eax]
.text:0000D5F1                 mov     [ebp+var_10], edx
.text:0000D5F4                 mov     eax, [ebp+var_10]
.text:0000D5F7                 mov     [ebp+var_C], eax
.text:0000D5FA                 cmp     [ebp+var_C], 0
.text:0000D5FE                 jz      short loc_D60F
.text:0000D600                 push    1
.text:0000D602                 mov     ecx, [ebp+var_C]
.text:0000D605                 call    ??_GCProp@@QAEPAXI@Z ; CProp::`scalar deleting destructor'(uint)
.text:0000D60A                 mov     [ebp+var_14], eax
.text:0000D60D                 jmp     short loc_D616
.text:0000D60F ; ---------------------------------------------------------------------------
.text:0000D60F
.text:0000D60F loc_D60F:                               ; CODE XREF: CObjectVector<CProp>::Clear(void)+52j
.text:0000D60F                 mov     [ebp+var_14], 0
.text:0000D616
.text:0000D616 loc_D616:                               ; CODE XREF: CObjectVector<CProp>::Clear(void)+61j
.text:0000D616                 jmp     short loc_D5D4
.text:0000D618 ; ---------------------------------------------------------------------------
.text:0000D618
.text:0000D618 loc_D618:                               ; CODE XREF: CObjectVector<CProp>::Clear(void)+2Cj
.text:0000D618                 mov     ecx, [ebp+var_4]
.text:0000D61B                 call    ?Clear@?$CRecordVector@PAX@@QAEXXZ ; CRecordVector<void *>::Clear(void)
.text:0000D620                 add     esp, 14h
.text:0000D623                 cmp     ebp, esp
.text:0000D625                 call    __RTC_CheckEsp
.text:0000D62A                 mov     esp, ebp
.text:0000D62C                 pop     ebp
.text:0000D62D                 retn
.text:0000D62D ?Clear@?$CObjectVector@UCProp@@@@QAEXXZ endp
.text:0000D62D
.text:0000D62D ; ---------------------------------------------------------------------------
.text:0000D62E                 align 10h
.text:0000D62E _text           ends
.text:0000D62E
.text:0000D630 ; ===========================================================================
.text:0000D630
.text:0000D630 ; Segment type: Pure code
.text:0000D630 ; Segment permissions: Read/Execute
.text:0000D630 _text           segment para public 'CODE' use32
.text:0000D630                 assume cs:_text
.text:0000D630                 ;org 0D630h
.text:0000D630 ; COMDAT (pick any)
.text:0000D630                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000D630
.text:0000D630 ; =============== S U B R O U T I N E =======================================
.text:0000D630
.text:0000D630 ; Attributes: bp-based frame
.text:0000D630
.text:0000D630 ; public: __thiscall CMyComPtr<struct ICompressCoder>::CMyComPtr<struct ICompressCoder>(void)
.text:0000D630                 public ??0?$CMyComPtr@UICompressCoder@@@@QAE@XZ
.text:0000D630 ??0?$CMyComPtr@UICompressCoder@@@@QAE@XZ proc near
.text:0000D630                                         ; CODE XREF: CEncoderInfo::CEncoderInfo(void)+51p
.text:0000D630                                         ; CCreatedCoder::CCreatedCoder(void)+30p
.text:0000D630                                         ; DATA XREF: ...
.text:0000D630
.text:0000D630 var_4           = dword ptr -4
.text:0000D630
.text:0000D630                 push    ebp
.text:0000D631                 mov     ebp, esp
.text:0000D633                 push    ecx
.text:0000D634                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000D63B                 mov     [ebp+var_4], ecx
.text:0000D63E                 mov     eax, [ebp+var_4]
.text:0000D641                 mov     dword ptr [eax], 0
.text:0000D647                 mov     eax, [ebp+var_4]
.text:0000D64A                 mov     esp, ebp
.text:0000D64C                 pop     ebp
.text:0000D64D                 retn
.text:0000D64D ??0?$CMyComPtr@UICompressCoder@@@@QAE@XZ endp
.text:0000D64D
.text:0000D64D ; ---------------------------------------------------------------------------
.text:0000D64E                 align 10h
.text:0000D64E _text           ends
.text:0000D64E
.text:0000D650 ; ===========================================================================
.text:0000D650
.text:0000D650 ; Segment type: Pure code
.text:0000D650 ; Segment permissions: Read/Execute
.text:0000D650 _text           segment para public 'CODE' use32
.text:0000D650                 assume cs:_text
.text:0000D650                 ;org 0D650h
.text:0000D650 ; COMDAT (pick any)
.text:0000D650                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000D650
.text:0000D650 ; =============== S U B R O U T I N E =======================================
.text:0000D650
.text:0000D650 ; Attributes: bp-based frame
.text:0000D650
.text:0000D650 ; public: __thiscall CMyComPtr<struct ICompressCoder>::~CMyComPtr<struct ICompressCoder>(void)
.text:0000D650                 public ??1?$CMyComPtr@UICompressCoder@@@@QAE@XZ
.text:0000D650 ??1?$CMyComPtr@UICompressCoder@@@@QAE@XZ proc near
.text:0000D650                                         ; CODE XREF: CEncoderInfo::~CEncoderInfo(void)+E9p
.text:0000D650                                         ; __unwindfunclet$??1CEncoderInfo@@QAE@XZ$1+6j ...
.text:0000D650
.text:0000D650 var_4           = dword ptr -4
.text:0000D650
.text:0000D650                 push    ebp
.text:0000D651                 mov     ebp, esp
.text:0000D653                 push    ecx
.text:0000D654                 push    esi
.text:0000D655                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000D65C                 mov     [ebp+var_4], ecx
.text:0000D65F                 mov     eax, [ebp+var_4]
.text:0000D662                 cmp     dword ptr [eax], 0
.text:0000D665                 jz      short loc_D682
.text:0000D667                 mov     ecx, [ebp+var_4]
.text:0000D66A                 mov     edx, [ecx]
.text:0000D66C                 mov     eax, [ebp+var_4]
.text:0000D66F                 mov     ecx, [eax]
.text:0000D671                 mov     edx, [edx]
.text:0000D673                 mov     esi, esp
.text:0000D675                 push    ecx
.text:0000D676                 mov     eax, [edx+8]
.text:0000D679                 call    eax
.text:0000D67B                 cmp     esi, esp
.text:0000D67D                 call    __RTC_CheckEsp
.text:0000D682
.text:0000D682 loc_D682:                               ; CODE XREF: CMyComPtr<ICompressCoder>::~CMyComPtr<ICompressCoder>(void)+15j
.text:0000D682                 pop     esi
.text:0000D683                 add     esp, 4
.text:0000D686                 cmp     ebp, esp
.text:0000D688                 call    __RTC_CheckEsp
.text:0000D68D                 mov     esp, ebp
.text:0000D68F                 pop     ebp
.text:0000D690                 retn
.text:0000D690 ??1?$CMyComPtr@UICompressCoder@@@@QAE@XZ endp
.text:0000D690
.text:0000D690 ; ---------------------------------------------------------------------------
.text:0000D691                 align 4
.text:0000D691 _text           ends
.text:0000D691
.text:0000D694 ; ===========================================================================
.text:0000D694
.text:0000D694 ; Segment type: Pure code
.text:0000D694 ; Segment permissions: Read/Execute
.text:0000D694 _text           segment para public 'CODE' use32
.text:0000D694                 assume cs:_text
.text:0000D694                 ;org 0D694h
.text:0000D694 ; COMDAT (pick any)
.text:0000D694                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000D694
.text:0000D694 ; =============== S U B R O U T I N E =======================================
.text:0000D694
.text:0000D694 ; Attributes: bp-based frame
.text:0000D694
.text:0000D694 ; public: void __thiscall CMyComPtr<struct ICompressCoder>::Release(void)
.text:0000D694                 public ?Release@?$CMyComPtr@UICompressCoder@@@@QAEXXZ
.text:0000D694 ?Release@?$CMyComPtr@UICompressCoder@@@@QAEXXZ proc near
.text:0000D694                                         ; CODE XREF: CEncoderInfo::Encode(void)+6B1p
.text:0000D694                                         ; CEncoderInfo::Decode(uint)+C8Dp
.text:0000D694
.text:0000D694 var_4           = dword ptr -4
.text:0000D694
.text:0000D694                 push    ebp
.text:0000D695                 mov     ebp, esp
.text:0000D697                 push    ecx
.text:0000D698                 push    esi
.text:0000D699                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000D6A0                 mov     [ebp+var_4], ecx
.text:0000D6A3                 mov     eax, [ebp+var_4]
.text:0000D6A6                 cmp     dword ptr [eax], 0
.text:0000D6A9                 jz      short loc_D6CF
.text:0000D6AB                 mov     ecx, [ebp+var_4]
.text:0000D6AE                 mov     edx, [ecx]
.text:0000D6B0                 mov     eax, [ebp+var_4]
.text:0000D6B3                 mov     ecx, [eax]
.text:0000D6B5                 mov     edx, [edx]
.text:0000D6B7                 mov     esi, esp
.text:0000D6B9                 push    ecx
.text:0000D6BA                 mov     eax, [edx+8]
.text:0000D6BD                 call    eax
.text:0000D6BF                 cmp     esi, esp
.text:0000D6C1                 call    __RTC_CheckEsp
.text:0000D6C6                 mov     ecx, [ebp+var_4]
.text:0000D6C9                 mov     dword ptr [ecx], 0
.text:0000D6CF
.text:0000D6CF loc_D6CF:                               ; CODE XREF: CMyComPtr<ICompressCoder>::Release(void)+15j
.text:0000D6CF                 pop     esi
.text:0000D6D0                 add     esp, 4
.text:0000D6D3                 cmp     ebp, esp
.text:0000D6D5                 call    __RTC_CheckEsp
.text:0000D6DA                 mov     esp, ebp
.text:0000D6DC                 pop     ebp
.text:0000D6DD                 retn
.text:0000D6DD ?Release@?$CMyComPtr@UICompressCoder@@@@QAEXXZ endp
.text:0000D6DD
.text:0000D6DD ; ---------------------------------------------------------------------------
.text:0000D6DE                 align 10h
.text:0000D6DE _text           ends
.text:0000D6DE
.text:0000D6E0 ; ===========================================================================
.text:0000D6E0
.text:0000D6E0 ; Segment type: Pure code
.text:0000D6E0 ; Segment permissions: Read/Execute
.text:0000D6E0 _text           segment para public 'CODE' use32
.text:0000D6E0                 assume cs:_text
.text:0000D6E0                 ;org 0D6E0h
.text:0000D6E0 ; COMDAT (pick any)
.text:0000D6E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000D6E0
.text:0000D6E0 ; =============== S U B R O U T I N E =======================================
.text:0000D6E0
.text:0000D6E0 ; Attributes: bp-based frame
.text:0000D6E0
.text:0000D6E0 ; public: __thiscall CMyComPtr<struct ICompressCoder>::operator struct ICompressCoder *(void)const
.text:0000D6E0                 public ??B?$CMyComPtr@UICompressCoder@@@@QBEPAUICompressCoder@@XZ
.text:0000D6E0 ??B?$CMyComPtr@UICompressCoder@@@@QBEPAUICompressCoder@@XZ proc near
.text:0000D6E0                                         ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+2C3p
.text:0000D6E0                                         ; CEncoderInfo::Encode(void)+B5p ...
.text:0000D6E0
.text:0000D6E0 var_4           = dword ptr -4
.text:0000D6E0
.text:0000D6E0                 push    ebp
.text:0000D6E1                 mov     ebp, esp
.text:0000D6E3                 push    ecx
.text:0000D6E4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000D6EB                 mov     [ebp+var_4], ecx
.text:0000D6EE                 mov     eax, [ebp+var_4]
.text:0000D6F1                 mov     eax, [eax]
.text:0000D6F3                 mov     esp, ebp
.text:0000D6F5                 pop     ebp
.text:0000D6F6                 retn
.text:0000D6F6 ??B?$CMyComPtr@UICompressCoder@@@@QBEPAUICompressCoder@@XZ endp
.text:0000D6F6
.text:0000D6F6 ; ---------------------------------------------------------------------------
.text:0000D6F7                 align 4
.text:0000D6F7 _text           ends
.text:0000D6F7
.text:0000D6F8 ; ===========================================================================
.text:0000D6F8
.text:0000D6F8 ; Segment type: Pure code
.text:0000D6F8 ; Segment permissions: Read/Execute
.text:0000D6F8 _text           segment para public 'CODE' use32
.text:0000D6F8                 assume cs:_text
.text:0000D6F8                 ;org 0D6F8h
.text:0000D6F8 ; COMDAT (pick any)
.text:0000D6F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000D6F8
.text:0000D6F8 ; =============== S U B R O U T I N E =======================================
.text:0000D6F8
.text:0000D6F8 ; Attributes: bp-based frame
.text:0000D6F8
.text:0000D6F8 ; public: struct ICompressCoder * __thiscall CMyComPtr<struct ICompressCoder>::operator->(void)const
.text:0000D6F8                 public ??C?$CMyComPtr@UICompressCoder@@@@QBEPAUICompressCoder@@XZ
.text:0000D6F8 ??C?$CMyComPtr@UICompressCoder@@@@QBEPAUICompressCoder@@XZ proc near
.text:0000D6F8                                         ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+677p
.text:0000D6F8                                         ; CEncoderInfo::Encode(void)+555p ...
.text:0000D6F8
.text:0000D6F8 var_4           = dword ptr -4
.text:0000D6F8
.text:0000D6F8                 push    ebp
.text:0000D6F9                 mov     ebp, esp
.text:0000D6FB                 push    ecx
.text:0000D6FC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000D703                 mov     [ebp+var_4], ecx
.text:0000D706                 mov     eax, [ebp+var_4]
.text:0000D709                 mov     eax, [eax]
.text:0000D70B                 mov     esp, ebp
.text:0000D70D                 pop     ebp
.text:0000D70E                 retn
.text:0000D70E ??C?$CMyComPtr@UICompressCoder@@@@QBEPAUICompressCoder@@XZ endp
.text:0000D70E
.text:0000D70E ; ---------------------------------------------------------------------------
.text:0000D70F                 align 10h
.text:0000D70F _text           ends
.text:0000D70F
.text:0000D710 ; ===========================================================================
.text:0000D710
.text:0000D710 ; Segment type: Pure code
.text:0000D710 ; Segment permissions: Read/Execute
.text:0000D710 _text           segment para public 'CODE' use32
.text:0000D710                 assume cs:_text
.text:0000D710                 ;org 0D710h
.text:0000D710 ; COMDAT (pick any)
.text:0000D710                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000D710
.text:0000D710 ; =============== S U B R O U T I N E =======================================
.text:0000D710
.text:0000D710 ; Attributes: bp-based frame
.text:0000D710
.text:0000D710 ; public: struct ICompressCoder * __thiscall CMyComPtr<struct ICompressCoder>::operator=(class CMyComPtr<struct ICompressCoder> const &)
.text:0000D710                 public ??4?$CMyComPtr@UICompressCoder@@@@QAEPAUICompressCoder@@ABV0@@Z
.text:0000D710 ??4?$CMyComPtr@UICompressCoder@@@@QAEPAUICompressCoder@@ABV0@@Z proc near
.text:0000D710                                         ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+21Ep
.text:0000D710                                         ; MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+3E7p
.text:0000D710
.text:0000D710 var_4           = dword ptr -4
.text:0000D710 arg_0           = dword ptr  8
.text:0000D710
.text:0000D710                 push    ebp
.text:0000D711                 mov     ebp, esp
.text:0000D713                 push    ecx
.text:0000D714                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000D71B                 mov     [ebp+var_4], ecx
.text:0000D71E                 mov     eax, [ebp+arg_0]
.text:0000D721                 mov     ecx, [eax]
.text:0000D723                 push    ecx
.text:0000D724                 mov     ecx, [ebp+var_4]
.text:0000D727                 call    ??4?$CMyComPtr@UICompressCoder@@@@QAEPAUICompressCoder@@PAU1@@Z ; CMyComPtr<ICompressCoder>::operator=(ICompressCoder *)
.text:0000D72C                 add     esp, 4
.text:0000D72F                 cmp     ebp, esp
.text:0000D731                 call    __RTC_CheckEsp
.text:0000D736                 mov     esp, ebp
.text:0000D738                 pop     ebp
.text:0000D739                 retn    4
.text:0000D739 ??4?$CMyComPtr@UICompressCoder@@@@QAEPAUICompressCoder@@ABV0@@Z endp
.text:0000D739
.text:0000D739 _text           ends
.text:0000D739
.text:0000D73C ; ===========================================================================
.text:0000D73C
.text:0000D73C ; Segment type: Pure code
.text:0000D73C ; Segment permissions: Read/Execute
.text:0000D73C _text           segment para public 'CODE' use32
.text:0000D73C                 assume cs:_text
.text:0000D73C                 ;org 0D73Ch
.text:0000D73C ; COMDAT (pick any)
.text:0000D73C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000D73C
.text:0000D73C ; =============== S U B R O U T I N E =======================================
.text:0000D73C
.text:0000D73C ; Attributes: bp-based frame
.text:0000D73C
.text:0000D73C ; public: bool __thiscall CMyComPtr<struct ICompressCoder>::operator!(void)const
.text:0000D73C                 public ??7?$CMyComPtr@UICompressCoder@@@@QBE_NXZ
.text:0000D73C ??7?$CMyComPtr@UICompressCoder@@@@QBE_NXZ proc near
.text:0000D73C                                         ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+22Cp
.text:0000D73C                                         ; MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+40Ap
.text:0000D73C
.text:0000D73C var_4           = dword ptr -4
.text:0000D73C
.text:0000D73C                 push    ebp
.text:0000D73D                 mov     ebp, esp
.text:0000D73F                 push    ecx
.text:0000D740                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000D747                 mov     [ebp+var_4], ecx
.text:0000D74A                 mov     eax, [ebp+var_4]
.text:0000D74D                 xor     ecx, ecx
.text:0000D74F                 cmp     dword ptr [eax], 0
.text:0000D752                 setz    cl
.text:0000D755                 mov     al, cl
.text:0000D757                 mov     esp, ebp
.text:0000D759                 pop     ebp
.text:0000D75A                 retn
.text:0000D75A ??7?$CMyComPtr@UICompressCoder@@@@QBE_NXZ endp
.text:0000D75A
.text:0000D75A ; ---------------------------------------------------------------------------
.text:0000D75B                 align 4
.text:0000D75B _text           ends
.text:0000D75B
.text:0000D75C ; ===========================================================================
.text:0000D75C
.text:0000D75C ; Segment type: Pure code
.text:0000D75C ; Segment permissions: Read/Execute
.text:0000D75C _text           segment para public 'CODE' use32
.text:0000D75C                 assume cs:_text
.text:0000D75C                 ;org 0D75Ch
.text:0000D75C ; COMDAT (pick any)
.text:0000D75C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000D75C
.text:0000D75C ; =============== S U B R O U T I N E =======================================
.text:0000D75C
.text:0000D75C ; Attributes: bp-based frame
.text:0000D75C
.text:0000D75C ; public: __thiscall CMyComPtr<struct ICompressCoder2>::CMyComPtr<struct ICompressCoder2>(void)
.text:0000D75C                 public ??0?$CMyComPtr@UICompressCoder2@@@@QAE@XZ
.text:0000D75C ??0?$CMyComPtr@UICompressCoder2@@@@QAE@XZ proc near
.text:0000D75C                                         ; CODE XREF: CCreatedCoder::CCreatedCoder(void)+42p
.text:0000D75C
.text:0000D75C var_4           = dword ptr -4
.text:0000D75C
.text:0000D75C                 push    ebp
.text:0000D75D                 mov     ebp, esp
.text:0000D75F                 push    ecx
.text:0000D760                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000D767                 mov     [ebp+var_4], ecx
.text:0000D76A                 mov     eax, [ebp+var_4]
.text:0000D76D                 mov     dword ptr [eax], 0
.text:0000D773                 mov     eax, [ebp+var_4]
.text:0000D776                 mov     esp, ebp
.text:0000D778                 pop     ebp
.text:0000D779                 retn
.text:0000D779 ??0?$CMyComPtr@UICompressCoder2@@@@QAE@XZ endp
.text:0000D779
.text:0000D779 ; ---------------------------------------------------------------------------
.text:0000D77A                 align 4
.text:0000D77A _text           ends
.text:0000D77A
.text:0000D77C ; ===========================================================================
.text:0000D77C
.text:0000D77C ; Segment type: Pure code
.text:0000D77C ; Segment permissions: Read/Execute
.text:0000D77C _text           segment para public 'CODE' use32
.text:0000D77C                 assume cs:_text
.text:0000D77C                 ;org 0D77Ch
.text:0000D77C ; COMDAT (pick any)
.text:0000D77C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000D77C
.text:0000D77C ; =============== S U B R O U T I N E =======================================
.text:0000D77C
.text:0000D77C ; Attributes: bp-based frame
.text:0000D77C
.text:0000D77C ; public: __thiscall CMyComPtr<struct ICompressCoder2>::~CMyComPtr<struct ICompressCoder2>(void)
.text:0000D77C                 public ??1?$CMyComPtr@UICompressCoder2@@@@QAE@XZ
.text:0000D77C ??1?$CMyComPtr@UICompressCoder2@@@@QAE@XZ proc near
.text:0000D77C                                         ; CODE XREF: CCreatedCoder::~CCreatedCoder(void)+3Ap
.text:0000D77C
.text:0000D77C var_4           = dword ptr -4
.text:0000D77C
.text:0000D77C                 push    ebp
.text:0000D77D                 mov     ebp, esp
.text:0000D77F                 push    ecx
.text:0000D780                 push    esi
.text:0000D781                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000D788                 mov     [ebp+var_4], ecx
.text:0000D78B                 mov     eax, [ebp+var_4]
.text:0000D78E                 cmp     dword ptr [eax], 0
.text:0000D791                 jz      short loc_D7AE
.text:0000D793                 mov     ecx, [ebp+var_4]
.text:0000D796                 mov     edx, [ecx]
.text:0000D798                 mov     eax, [ebp+var_4]
.text:0000D79B                 mov     ecx, [eax]
.text:0000D79D                 mov     edx, [edx]
.text:0000D79F                 mov     esi, esp
.text:0000D7A1                 push    ecx
.text:0000D7A2                 mov     eax, [edx+8]
.text:0000D7A5                 call    eax
.text:0000D7A7                 cmp     esi, esp
.text:0000D7A9                 call    __RTC_CheckEsp
.text:0000D7AE
.text:0000D7AE loc_D7AE:                               ; CODE XREF: CMyComPtr<ICompressCoder2>::~CMyComPtr<ICompressCoder2>(void)+15j
.text:0000D7AE                 pop     esi
.text:0000D7AF                 add     esp, 4
.text:0000D7B2                 cmp     ebp, esp
.text:0000D7B4                 call    __RTC_CheckEsp
.text:0000D7B9                 mov     esp, ebp
.text:0000D7BB                 pop     ebp
.text:0000D7BC                 retn
.text:0000D7BC ??1?$CMyComPtr@UICompressCoder2@@@@QAE@XZ endp
.text:0000D7BC
.text:0000D7BC ; ---------------------------------------------------------------------------
.text:0000D7BD                 align 10h
.text:0000D7BD _text           ends
.text:0000D7BD
.text:0000D7C0 ; ===========================================================================
.text:0000D7C0
.text:0000D7C0 ; Segment type: Pure code
.text:0000D7C0 ; Segment permissions: Read/Execute
.text:0000D7C0 _text           segment para public 'CODE' use32
.text:0000D7C0                 assume cs:_text
.text:0000D7C0                 ;org 0D7C0h
.text:0000D7C0 ; COMDAT (pick any)
.text:0000D7C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000D7C0
.text:0000D7C0 ; =============== S U B R O U T I N E =======================================
.text:0000D7C0
.text:0000D7C0 ; Attributes: bp-based frame
.text:0000D7C0
.text:0000D7C0 ; public: __thiscall CMyComPtr<struct ICompressFilter>::CMyComPtr<struct ICompressFilter>(void)
.text:0000D7C0                 public ??0?$CMyComPtr@UICompressFilter@@@@QAE@XZ
.text:0000D7C0 ??0?$CMyComPtr@UICompressFilter@@@@QAE@XZ proc near
.text:0000D7C0                                         ; CODE XREF: CEncoderInfo::CEncoderInfo(void)+60p
.text:0000D7C0                                         ; CEncoderInfo::CEncoderInfo(void)+BFp
.text:0000D7C0
.text:0000D7C0 var_4           = dword ptr -4
.text:0000D7C0
.text:0000D7C0                 push    ebp
.text:0000D7C1                 mov     ebp, esp
.text:0000D7C3                 push    ecx
.text:0000D7C4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000D7CB                 mov     [ebp+var_4], ecx
.text:0000D7CE                 mov     eax, [ebp+var_4]
.text:0000D7D1                 mov     dword ptr [eax], 0
.text:0000D7D7                 mov     eax, [ebp+var_4]
.text:0000D7DA                 mov     esp, ebp
.text:0000D7DC                 pop     ebp
.text:0000D7DD                 retn
.text:0000D7DD ??0?$CMyComPtr@UICompressFilter@@@@QAE@XZ endp
.text:0000D7DD
.text:0000D7DD ; ---------------------------------------------------------------------------
.text:0000D7DE                 align 10h
.text:0000D7DE _text           ends
.text:0000D7DE
.text:0000D7E0 ; ===========================================================================
.text:0000D7E0
.text:0000D7E0 ; Segment type: Pure code
.text:0000D7E0 ; Segment permissions: Read/Execute
.text:0000D7E0 _text           segment para public 'CODE' use32
.text:0000D7E0                 assume cs:_text
.text:0000D7E0                 ;org 0D7E0h
.text:0000D7E0 ; COMDAT (pick any)
.text:0000D7E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000D7E0
.text:0000D7E0 ; =============== S U B R O U T I N E =======================================
.text:0000D7E0
.text:0000D7E0 ; Attributes: bp-based frame
.text:0000D7E0
.text:0000D7E0 ; public: __thiscall CMyComPtr<struct ICompressFilter>::~CMyComPtr<struct ICompressFilter>(void)
.text:0000D7E0                 public ??1?$CMyComPtr@UICompressFilter@@@@QAE@XZ
.text:0000D7E0 ??1?$CMyComPtr@UICompressFilter@@@@QAE@XZ proc near
.text:0000D7E0                                         ; CODE XREF: CEncoderInfo::~CEncoderInfo(void)+97p
.text:0000D7E0                                         ; CEncoderInfo::~CEncoderInfo(void)+DAp ...
.text:0000D7E0
.text:0000D7E0 var_4           = dword ptr -4
.text:0000D7E0
.text:0000D7E0                 push    ebp
.text:0000D7E1                 mov     ebp, esp
.text:0000D7E3                 push    ecx
.text:0000D7E4                 push    esi
.text:0000D7E5                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000D7EC                 mov     [ebp+var_4], ecx
.text:0000D7EF                 mov     eax, [ebp+var_4]
.text:0000D7F2                 cmp     dword ptr [eax], 0
.text:0000D7F5                 jz      short loc_D812
.text:0000D7F7                 mov     ecx, [ebp+var_4]
.text:0000D7FA                 mov     edx, [ecx]
.text:0000D7FC                 mov     eax, [ebp+var_4]
.text:0000D7FF                 mov     ecx, [eax]
.text:0000D801                 mov     edx, [edx]
.text:0000D803                 mov     esi, esp
.text:0000D805                 push    ecx
.text:0000D806                 mov     eax, [edx+8]
.text:0000D809                 call    eax
.text:0000D80B                 cmp     esi, esp
.text:0000D80D                 call    __RTC_CheckEsp
.text:0000D812
.text:0000D812 loc_D812:                               ; CODE XREF: CMyComPtr<ICompressFilter>::~CMyComPtr<ICompressFilter>(void)+15j
.text:0000D812                 pop     esi
.text:0000D813                 add     esp, 4
.text:0000D816                 cmp     ebp, esp
.text:0000D818                 call    __RTC_CheckEsp
.text:0000D81D                 mov     esp, ebp
.text:0000D81F                 pop     ebp
.text:0000D820                 retn
.text:0000D820 ??1?$CMyComPtr@UICompressFilter@@@@QAE@XZ endp
.text:0000D820
.text:0000D820 ; ---------------------------------------------------------------------------
.text:0000D821                 align 4
.text:0000D821 _text           ends
.text:0000D821
.text:0000D824 ; ===========================================================================
.text:0000D824
.text:0000D824 ; Segment type: Pure code
.text:0000D824 ; Segment permissions: Read/Execute
.text:0000D824 _text           segment para public 'CODE' use32
.text:0000D824                 assume cs:_text
.text:0000D824                 ;org 0D824h
.text:0000D824 ; COMDAT (pick any)
.text:0000D824                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000D824
.text:0000D824 ; =============== S U B R O U T I N E =======================================
.text:0000D824
.text:0000D824 ; Attributes: bp-based frame
.text:0000D824
.text:0000D824 ; public: void __thiscall CMyComPtr<struct ICompressFilter>::Release(void)
.text:0000D824                 public ?Release@?$CMyComPtr@UICompressFilter@@@@QAEXXZ
.text:0000D824 ?Release@?$CMyComPtr@UICompressFilter@@@@QAEXXZ proc near
.text:0000D824                                         ; CODE XREF: CEncoderInfo::Encode(void)+6BCp
.text:0000D824                                         ; CEncoderInfo::Decode(uint)+C9Bp
.text:0000D824
.text:0000D824 var_4           = dword ptr -4
.text:0000D824
.text:0000D824                 push    ebp
.text:0000D825                 mov     ebp, esp
.text:0000D827                 push    ecx
.text:0000D828                 push    esi
.text:0000D829                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000D830                 mov     [ebp+var_4], ecx
.text:0000D833                 mov     eax, [ebp+var_4]
.text:0000D836                 cmp     dword ptr [eax], 0
.text:0000D839                 jz      short loc_D85F
.text:0000D83B                 mov     ecx, [ebp+var_4]
.text:0000D83E                 mov     edx, [ecx]
.text:0000D840                 mov     eax, [ebp+var_4]
.text:0000D843                 mov     ecx, [eax]
.text:0000D845                 mov     edx, [edx]
.text:0000D847                 mov     esi, esp
.text:0000D849                 push    ecx
.text:0000D84A                 mov     eax, [edx+8]
.text:0000D84D                 call    eax
.text:0000D84F                 cmp     esi, esp
.text:0000D851                 call    __RTC_CheckEsp
.text:0000D856                 mov     ecx, [ebp+var_4]
.text:0000D859                 mov     dword ptr [ecx], 0
.text:0000D85F
.text:0000D85F loc_D85F:                               ; CODE XREF: CMyComPtr<ICompressFilter>::Release(void)+15j
.text:0000D85F                 pop     esi
.text:0000D860                 add     esp, 4
.text:0000D863                 cmp     ebp, esp
.text:0000D865                 call    __RTC_CheckEsp
.text:0000D86A                 mov     esp, ebp
.text:0000D86C                 pop     ebp
.text:0000D86D                 retn
.text:0000D86D ?Release@?$CMyComPtr@UICompressFilter@@@@QAEXXZ endp
.text:0000D86D
.text:0000D86D ; ---------------------------------------------------------------------------
.text:0000D86E                 align 10h
.text:0000D86E _text           ends
.text:0000D86E
.text:0000D870 ; ===========================================================================
.text:0000D870
.text:0000D870 ; Segment type: Pure code
.text:0000D870 ; Segment permissions: Read/Execute
.text:0000D870 _text           segment para public 'CODE' use32
.text:0000D870                 assume cs:_text
.text:0000D870                 ;org 0D870h
.text:0000D870 ; COMDAT (pick any)
.text:0000D870                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000D870
.text:0000D870 ; =============== S U B R O U T I N E =======================================
.text:0000D870
.text:0000D870 ; Attributes: bp-based frame
.text:0000D870
.text:0000D870 ; public: __thiscall CMyComPtr<struct ICompressFilter>::operator struct ICompressFilter *(void)const
.text:0000D870                 public ??B?$CMyComPtr@UICompressFilter@@@@QBEPAUICompressFilter@@XZ
.text:0000D870 ??B?$CMyComPtr@UICompressFilter@@@@QBEPAUICompressFilter@@XZ proc near
.text:0000D870                                         ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+EBp
.text:0000D870                                         ; CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+29Ep ...
.text:0000D870
.text:0000D870 var_4           = dword ptr -4
.text:0000D870
.text:0000D870                 push    ebp
.text:0000D871                 mov     ebp, esp
.text:0000D873                 push    ecx
.text:0000D874                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000D87B                 mov     [ebp+var_4], ecx
.text:0000D87E                 mov     eax, [ebp+var_4]
.text:0000D881                 mov     eax, [eax]
.text:0000D883                 mov     esp, ebp
.text:0000D885                 pop     ebp
.text:0000D886                 retn
.text:0000D886 ??B?$CMyComPtr@UICompressFilter@@@@QBEPAUICompressFilter@@XZ endp
.text:0000D886
.text:0000D886 ; ---------------------------------------------------------------------------
.text:0000D887                 align 4
.text:0000D887 _text           ends
.text:0000D887
.text:0000D888 ; ===========================================================================
.text:0000D888
.text:0000D888 ; Segment type: Pure code
.text:0000D888 ; Segment permissions: Read/Execute
.text:0000D888 _text           segment para public 'CODE' use32
.text:0000D888                 assume cs:_text
.text:0000D888                 ;org 0D888h
.text:0000D888 ; COMDAT (pick any)
.text:0000D888                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000D888
.text:0000D888 ; =============== S U B R O U T I N E =======================================
.text:0000D888
.text:0000D888 ; Attributes: bp-based frame
.text:0000D888
.text:0000D888 ; public: struct ICompressFilter * __thiscall CMyComPtr<struct ICompressFilter>::operator->(void)const
.text:0000D888                 public ??C?$CMyComPtr@UICompressFilter@@@@QBEPAUICompressFilter@@XZ
.text:0000D888 ??C?$CMyComPtr@UICompressFilter@@@@QBEPAUICompressFilter@@XZ proc near
.text:0000D888                                         ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+60Dp
.text:0000D888                                         ; CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+63Bp ...
.text:0000D888
.text:0000D888 var_4           = dword ptr -4
.text:0000D888
.text:0000D888                 push    ebp
.text:0000D889                 mov     ebp, esp
.text:0000D88B                 push    ecx
.text:0000D88C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000D893                 mov     [ebp+var_4], ecx
.text:0000D896                 mov     eax, [ebp+var_4]
.text:0000D899                 mov     eax, [eax]
.text:0000D89B                 mov     esp, ebp
.text:0000D89D                 pop     ebp
.text:0000D89E                 retn
.text:0000D89E ??C?$CMyComPtr@UICompressFilter@@@@QBEPAUICompressFilter@@XZ endp
.text:0000D89E
.text:0000D89E ; ---------------------------------------------------------------------------
.text:0000D89F                 align 10h
.text:0000D89F _text           ends
.text:0000D89F
.text:0000D8A0 ; ===========================================================================
.text:0000D8A0
.text:0000D8A0 ; Segment type: Pure code
.text:0000D8A0 ; Segment permissions: Read/Execute
.text:0000D8A0 _text           segment para public 'CODE' use32
.text:0000D8A0                 assume cs:_text
.text:0000D8A0                 ;org 0D8A0h
.text:0000D8A0 ; COMDAT (pick any)
.text:0000D8A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000D8A0
.text:0000D8A0 ; =============== S U B R O U T I N E =======================================
.text:0000D8A0
.text:0000D8A0 ; Attributes: bp-based frame
.text:0000D8A0
.text:0000D8A0 ; public: bool __thiscall CMyComPtr<struct ICompressFilter>::operator!(void)const
.text:0000D8A0                 public ??7?$CMyComPtr@UICompressFilter@@@@QBE_NXZ
.text:0000D8A0 ??7?$CMyComPtr@UICompressFilter@@@@QBE_NXZ proc near
.text:0000D8A0                                         ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+241p
.text:0000D8A0                                         ; MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+3F8p
.text:0000D8A0
.text:0000D8A0 var_4           = dword ptr -4
.text:0000D8A0
.text:0000D8A0                 push    ebp
.text:0000D8A1                 mov     ebp, esp
.text:0000D8A3                 push    ecx
.text:0000D8A4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000D8AB                 mov     [ebp+var_4], ecx
.text:0000D8AE                 mov     eax, [ebp+var_4]
.text:0000D8B1                 xor     ecx, ecx
.text:0000D8B3                 cmp     dword ptr [eax], 0
.text:0000D8B6                 setz    cl
.text:0000D8B9                 mov     al, cl
.text:0000D8BB                 mov     esp, ebp
.text:0000D8BD                 pop     ebp
.text:0000D8BE                 retn
.text:0000D8BE ??7?$CMyComPtr@UICompressFilter@@@@QBE_NXZ endp
.text:0000D8BE
.text:0000D8BE ; ---------------------------------------------------------------------------
.text:0000D8BF                 align 10h
.text:0000D8BF _text           ends
.text:0000D8BF
.text:0000D8C0 ; ===========================================================================
.text:0000D8C0
.text:0000D8C0 ; Segment type: Pure code
.text:0000D8C0 ; Segment permissions: Read/Execute
.text:0000D8C0 _text           segment para public 'CODE' use32
.text:0000D8C0                 assume cs:_text
.text:0000D8C0                 ;org 0D8C0h
.text:0000D8C0 ; COMDAT (pick any)
.text:0000D8C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000D8C0
.text:0000D8C0 ; =============== S U B R O U T I N E =======================================
.text:0000D8C0
.text:0000D8C0 ; Attributes: bp-based frame
.text:0000D8C0
.text:0000D8C0 ; public: __thiscall CMyComPtr<struct ICompressProgressInfo>::CMyComPtr<struct ICompressProgressInfo>(void)
.text:0000D8C0                 public ??0?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ
.text:0000D8C0 ??0?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ proc near
.text:0000D8C0                                         ; DATA XREF: CEncoderInfo::CEncoderInfo(void)+6Eo
.text:0000D8C0
.text:0000D8C0 var_4           = dword ptr -4
.text:0000D8C0
.text:0000D8C0                 push    ebp
.text:0000D8C1                 mov     ebp, esp
.text:0000D8C3                 push    ecx
.text:0000D8C4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000D8CB                 mov     [ebp+var_4], ecx
.text:0000D8CE                 mov     eax, [ebp+var_4]
.text:0000D8D1                 mov     dword ptr [eax], 0
.text:0000D8D7                 mov     eax, [ebp+var_4]
.text:0000D8DA                 mov     esp, ebp
.text:0000D8DC                 pop     ebp
.text:0000D8DD                 retn
.text:0000D8DD ??0?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ endp
.text:0000D8DD
.text:0000D8DD ; ---------------------------------------------------------------------------
.text:0000D8DE                 align 10h
.text:0000D8DE _text           ends
.text:0000D8DE
.text:0000D8E0 ; ===========================================================================
.text:0000D8E0
.text:0000D8E0 ; Segment type: Pure code
.text:0000D8E0 ; Segment permissions: Read/Execute
.text:0000D8E0 _text           segment para public 'CODE' use32
.text:0000D8E0                 assume cs:_text
.text:0000D8E0                 ;org 0D8E0h
.text:0000D8E0 ; COMDAT (pick any)
.text:0000D8E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000D8E0
.text:0000D8E0 ; =============== S U B R O U T I N E =======================================
.text:0000D8E0
.text:0000D8E0 ; Attributes: bp-based frame
.text:0000D8E0
.text:0000D8E0 ; public: __thiscall CMyComPtr<struct ICompressProgressInfo>::~CMyComPtr<struct ICompressProgressInfo>(void)
.text:0000D8E0                 public ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ
.text:0000D8E0 ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ proc near
.text:0000D8E0                                         ; DATA XREF: CEncoderInfo::~CEncoderInfo(void)+BBo
.text:0000D8E0                                         ; __unwindfunclet$??1CEncoderInfo@@QAE@XZ$3o ...
.text:0000D8E0
.text:0000D8E0 var_4           = dword ptr -4
.text:0000D8E0
.text:0000D8E0                 push    ebp
.text:0000D8E1                 mov     ebp, esp
.text:0000D8E3                 push    ecx
.text:0000D8E4                 push    esi
.text:0000D8E5                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000D8EC                 mov     [ebp+var_4], ecx
.text:0000D8EF                 mov     eax, [ebp+var_4]
.text:0000D8F2                 cmp     dword ptr [eax], 0
.text:0000D8F5                 jz      short loc_D912
.text:0000D8F7                 mov     ecx, [ebp+var_4]
.text:0000D8FA                 mov     edx, [ecx]
.text:0000D8FC                 mov     eax, [ebp+var_4]
.text:0000D8FF                 mov     ecx, [eax]
.text:0000D901                 mov     edx, [edx]
.text:0000D903                 mov     esi, esp
.text:0000D905                 push    ecx
.text:0000D906                 mov     eax, [edx+8]
.text:0000D909                 call    eax
.text:0000D90B                 cmp     esi, esp
.text:0000D90D                 call    __RTC_CheckEsp
.text:0000D912
.text:0000D912 loc_D912:                               ; CODE XREF: CMyComPtr<ICompressProgressInfo>::~CMyComPtr<ICompressProgressInfo>(void)+15j
.text:0000D912                 pop     esi
.text:0000D913                 add     esp, 4
.text:0000D916                 cmp     ebp, esp
.text:0000D918                 call    __RTC_CheckEsp
.text:0000D91D                 mov     esp, ebp
.text:0000D91F                 pop     ebp
.text:0000D920                 retn
.text:0000D920 ??1?$CMyComPtr@UICompressProgressInfo@@@@QAE@XZ endp
.text:0000D920
.text:0000D920 ; ---------------------------------------------------------------------------
.text:0000D921                 align 4
.text:0000D921 _text           ends
.text:0000D921
.text:0000D924 ; ===========================================================================
.text:0000D924
.text:0000D924 ; Segment type: Pure code
.text:0000D924 ; Segment permissions: Read/Execute
.text:0000D924 _text           segment para public 'CODE' use32
.text:0000D924                 assume cs:_text
.text:0000D924                 ;org 0D924h
.text:0000D924 ; COMDAT (pick any)
.text:0000D924                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000D924
.text:0000D924 ; =============== S U B R O U T I N E =======================================
.text:0000D924
.text:0000D924 ; Attributes: bp-based frame
.text:0000D924
.text:0000D924 ; public: __thiscall CMyComPtr<struct ICompressProgressInfo>::operator struct ICompressProgressInfo *(void)const
.text:0000D924                 public ??B?$CMyComPtr@UICompressProgressInfo@@@@QBEPAUICompressProgressInfo@@XZ
.text:0000D924 ??B?$CMyComPtr@UICompressProgressInfo@@@@QBEPAUICompressProgressInfo@@XZ proc near
.text:0000D924                                         ; CODE XREF: CEncoderInfo::Encode(void)+566p
.text:0000D924                                         ; CEncoderInfo::Decode(uint)+B17p
.text:0000D924
.text:0000D924 var_4           = dword ptr -4
.text:0000D924
.text:0000D924                 push    ebp
.text:0000D925                 mov     ebp, esp
.text:0000D927                 push    ecx
.text:0000D928                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000D92F                 mov     [ebp+var_4], ecx
.text:0000D932                 mov     eax, [ebp+var_4]
.text:0000D935                 mov     eax, [eax]
.text:0000D937                 mov     esp, ebp
.text:0000D939                 pop     ebp
.text:0000D93A                 retn
.text:0000D93A ??B?$CMyComPtr@UICompressProgressInfo@@@@QBEPAUICompressProgressInfo@@XZ endp
.text:0000D93A
.text:0000D93A ; ---------------------------------------------------------------------------
.text:0000D93B                 align 4
.text:0000D93B _text           ends
.text:0000D93B
.text:0000D93C ; ===========================================================================
.text:0000D93C
.text:0000D93C ; Segment type: Pure code
.text:0000D93C ; Segment permissions: Read/Execute
.text:0000D93C _text           segment para public 'CODE' use32
.text:0000D93C                 assume cs:_text
.text:0000D93C                 ;org 0D93Ch
.text:0000D93C ; COMDAT (pick any)
.text:0000D93C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000D93C
.text:0000D93C ; =============== S U B R O U T I N E =======================================
.text:0000D93C
.text:0000D93C ; Attributes: bp-based frame
.text:0000D93C
.text:0000D93C ; public: struct ICompressProgressInfo * __thiscall CMyComPtr<struct ICompressProgressInfo>::operator=(struct ICompressProgressInfo *)
.text:0000D93C                 public ??4?$CMyComPtr@UICompressProgressInfo@@@@QAEPAUICompressProgressInfo@@PAU1@@Z
.text:0000D93C ??4?$CMyComPtr@UICompressProgressInfo@@@@QAEPAUICompressProgressInfo@@PAU1@@Z proc near
.text:0000D93C                                         ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+667p
.text:0000D93C
.text:0000D93C var_4           = dword ptr -4
.text:0000D93C arg_0           = dword ptr  8
.text:0000D93C
.text:0000D93C                 push    ebp
.text:0000D93D                 mov     ebp, esp
.text:0000D93F                 push    ecx
.text:0000D940                 push    esi
.text:0000D941                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000D948                 mov     [ebp+var_4], ecx
.text:0000D94B                 cmp     [ebp+arg_0], 0
.text:0000D94F                 jz      short loc_D968
.text:0000D951                 mov     eax, [ebp+arg_0]
.text:0000D954                 mov     ecx, [eax]
.text:0000D956                 mov     esi, esp
.text:0000D958                 mov     edx, [ebp+arg_0]
.text:0000D95B                 push    edx
.text:0000D95C                 mov     eax, [ecx+4]
.text:0000D95F                 call    eax
.text:0000D961                 cmp     esi, esp
.text:0000D963                 call    __RTC_CheckEsp
.text:0000D968
.text:0000D968 loc_D968:                               ; CODE XREF: CMyComPtr<ICompressProgressInfo>::operator=(ICompressProgressInfo *)+13j
.text:0000D968                 mov     ecx, [ebp+var_4]
.text:0000D96B                 cmp     dword ptr [ecx], 0
.text:0000D96E                 jz      short loc_D98B
.text:0000D970                 mov     edx, [ebp+var_4]
.text:0000D973                 mov     eax, [edx]
.text:0000D975                 mov     ecx, [ebp+var_4]
.text:0000D978                 mov     edx, [ecx]
.text:0000D97A                 mov     eax, [eax]
.text:0000D97C                 mov     esi, esp
.text:0000D97E                 push    edx
.text:0000D97F                 mov     ecx, [eax+8]
.text:0000D982                 call    ecx
.text:0000D984                 cmp     esi, esp
.text:0000D986                 call    __RTC_CheckEsp
.text:0000D98B
.text:0000D98B loc_D98B:                               ; CODE XREF: CMyComPtr<ICompressProgressInfo>::operator=(ICompressProgressInfo *)+32j
.text:0000D98B                 mov     edx, [ebp+var_4]
.text:0000D98E                 mov     eax, [ebp+arg_0]
.text:0000D991                 mov     [edx], eax
.text:0000D993                 mov     eax, [ebp+arg_0]
.text:0000D996                 pop     esi
.text:0000D997                 add     esp, 4
.text:0000D99A                 cmp     ebp, esp
.text:0000D99C                 call    __RTC_CheckEsp
.text:0000D9A1                 mov     esp, ebp
.text:0000D9A3                 pop     ebp
.text:0000D9A4                 retn    4
.text:0000D9A4 ??4?$CMyComPtr@UICompressProgressInfo@@@@QAEPAUICompressProgressInfo@@PAU1@@Z endp
.text:0000D9A4
.text:0000D9A4 ; ---------------------------------------------------------------------------
.text:0000D9A7                 align 4
.text:0000D9A7 _text           ends
.text:0000D9A7
.text:0000D9A8 ; ===========================================================================
.text:0000D9A8
.text:0000D9A8 ; Segment type: Pure code
.text:0000D9A8 ; Segment permissions: Read/Execute
.text:0000D9A8 _text           segment para public 'CODE' use32
.text:0000D9A8                 assume cs:_text
.text:0000D9A8                 ;org 0D9A8h
.text:0000D9A8 ; COMDAT (pick any)
.text:0000D9A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000D9A8
.text:0000D9A8 ; =============== S U B R O U T I N E =======================================
.text:0000D9A8
.text:0000D9A8 ; Attributes: bp-based frame
.text:0000D9A8
.text:0000D9A8 ; public: __thiscall CMyComPtr<struct ISequentialOutStream>::CMyComPtr<struct ISequentialOutStream>(void)
.text:0000D9A8                 public ??0?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ
.text:0000D9A8 ??0?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ proc near
.text:0000D9A8                                         ; CODE XREF: CEncoderInfo::CEncoderInfo(void)+DEp
.text:0000D9A8                                         ; CEncoderInfo::CEncoderInfo(void)+13Bp
.text:0000D9A8
.text:0000D9A8 var_4           = dword ptr -4
.text:0000D9A8
.text:0000D9A8                 push    ebp
.text:0000D9A9                 mov     ebp, esp
.text:0000D9AB                 push    ecx
.text:0000D9AC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000D9B3                 mov     [ebp+var_4], ecx
.text:0000D9B6                 mov     eax, [ebp+var_4]
.text:0000D9B9                 mov     dword ptr [eax], 0
.text:0000D9BF                 mov     eax, [ebp+var_4]
.text:0000D9C2                 mov     esp, ebp
.text:0000D9C4                 pop     ebp
.text:0000D9C5                 retn
.text:0000D9C5 ??0?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ endp
.text:0000D9C5
.text:0000D9C5 ; ---------------------------------------------------------------------------
.text:0000D9C6                 align 4
.text:0000D9C6 _text           ends
.text:0000D9C6
.text:0000D9C8 ; ===========================================================================
.text:0000D9C8
.text:0000D9C8 ; Segment type: Pure code
.text:0000D9C8 ; Segment permissions: Read/Execute
.text:0000D9C8 _text           segment para public 'CODE' use32
.text:0000D9C8                 assume cs:_text
.text:0000D9C8                 ;org 0D9C8h
.text:0000D9C8 ; COMDAT (pick any)
.text:0000D9C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000D9C8
.text:0000D9C8 ; =============== S U B R O U T I N E =======================================
.text:0000D9C8
.text:0000D9C8 ; Attributes: bp-based frame
.text:0000D9C8
.text:0000D9C8 ; public: __thiscall CMyComPtr<struct ISequentialOutStream>::CMyComPtr<struct ISequentialOutStream>(struct ISequentialOutStream *)
.text:0000D9C8                 public ??0?$CMyComPtr@UISequentialOutStream@@@@QAE@PAUISequentialOutStream@@@Z
.text:0000D9C8 ??0?$CMyComPtr@UISequentialOutStream@@@@QAE@PAUISequentialOutStream@@@Z proc near
.text:0000D9C8                                         ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+5E4p
.text:0000D9C8                                         ; CEncoderInfo::Decode(uint)+211p
.text:0000D9C8
.text:0000D9C8 var_4           = dword ptr -4
.text:0000D9C8 arg_0           = dword ptr  8
.text:0000D9C8
.text:0000D9C8                 push    ebp
.text:0000D9C9                 mov     ebp, esp
.text:0000D9CB                 push    ecx
.text:0000D9CC                 push    esi
.text:0000D9CD                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000D9D4                 mov     [ebp+var_4], ecx
.text:0000D9D7                 mov     eax, [ebp+var_4]
.text:0000D9DA                 mov     ecx, [ebp+arg_0]
.text:0000D9DD                 mov     [eax], ecx
.text:0000D9DF                 cmp     [ebp+arg_0], 0
.text:0000D9E3                 jz      short loc_D9FC
.text:0000D9E5                 mov     edx, [ebp+arg_0]
.text:0000D9E8                 mov     eax, [edx]
.text:0000D9EA                 mov     esi, esp
.text:0000D9EC                 mov     ecx, [ebp+arg_0]
.text:0000D9EF                 push    ecx
.text:0000D9F0                 mov     edx, [eax+4]
.text:0000D9F3                 call    edx
.text:0000D9F5                 cmp     esi, esp
.text:0000D9F7                 call    __RTC_CheckEsp
.text:0000D9FC
.text:0000D9FC loc_D9FC:                               ; CODE XREF: CMyComPtr<ISequentialOutStream>::CMyComPtr<ISequentialOutStream>(ISequentialOutStream *)+1Bj
.text:0000D9FC                 mov     eax, [ebp+var_4]
.text:0000D9FF                 pop     esi
.text:0000DA00                 add     esp, 4
.text:0000DA03                 cmp     ebp, esp
.text:0000DA05                 call    __RTC_CheckEsp
.text:0000DA0A                 mov     esp, ebp
.text:0000DA0C                 pop     ebp
.text:0000DA0D                 retn    4
.text:0000DA0D ??0?$CMyComPtr@UISequentialOutStream@@@@QAE@PAUISequentialOutStream@@@Z endp
.text:0000DA0D
.text:0000DA0D _text           ends
.text:0000DA0D
.text:0000DA10 ; ===========================================================================
.text:0000DA10
.text:0000DA10 ; Segment type: Pure code
.text:0000DA10 ; Segment permissions: Read/Execute
.text:0000DA10 _text           segment para public 'CODE' use32
.text:0000DA10                 assume cs:_text
.text:0000DA10                 ;org 0DA10h
.text:0000DA10 ; COMDAT (pick any)
.text:0000DA10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000DA10
.text:0000DA10 ; =============== S U B R O U T I N E =======================================
.text:0000DA10
.text:0000DA10 ; Attributes: bp-based frame
.text:0000DA10
.text:0000DA10 ; public: __thiscall CMyComPtr<struct ISequentialOutStream>::~CMyComPtr<struct ISequentialOutStream>(void)
.text:0000DA10                 public ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ
.text:0000DA10 ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ proc near
.text:0000DA10                                         ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+6DFp
.text:0000DA10                                         ; CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+735p ...
.text:0000DA10
.text:0000DA10 var_4           = dword ptr -4
.text:0000DA10
.text:0000DA10                 push    ebp
.text:0000DA11                 mov     ebp, esp
.text:0000DA13                 push    ecx
.text:0000DA14                 push    esi
.text:0000DA15                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000DA1C                 mov     [ebp+var_4], ecx
.text:0000DA1F                 mov     eax, [ebp+var_4]
.text:0000DA22                 cmp     dword ptr [eax], 0
.text:0000DA25                 jz      short loc_DA42
.text:0000DA27                 mov     ecx, [ebp+var_4]
.text:0000DA2A                 mov     edx, [ecx]
.text:0000DA2C                 mov     eax, [ebp+var_4]
.text:0000DA2F                 mov     ecx, [eax]
.text:0000DA31                 mov     edx, [edx]
.text:0000DA33                 mov     esi, esp
.text:0000DA35                 push    ecx
.text:0000DA36                 mov     eax, [edx+8]
.text:0000DA39                 call    eax
.text:0000DA3B                 cmp     esi, esp
.text:0000DA3D                 call    __RTC_CheckEsp
.text:0000DA42
.text:0000DA42 loc_DA42:                               ; CODE XREF: CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)+15j
.text:0000DA42                 pop     esi
.text:0000DA43                 add     esp, 4
.text:0000DA46                 cmp     ebp, esp
.text:0000DA48                 call    __RTC_CheckEsp
.text:0000DA4D                 mov     esp, ebp
.text:0000DA4F                 pop     ebp
.text:0000DA50                 retn
.text:0000DA50 ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ endp
.text:0000DA50
.text:0000DA50 ; ---------------------------------------------------------------------------
.text:0000DA51                 align 4
.text:0000DA51 _text           ends
.text:0000DA51
.text:0000DA54 ; ===========================================================================
.text:0000DA54
.text:0000DA54 ; Segment type: Pure code
.text:0000DA54 ; Segment permissions: Read/Execute
.text:0000DA54 _text           segment para public 'CODE' use32
.text:0000DA54                 assume cs:_text
.text:0000DA54                 ;org 0DA54h
.text:0000DA54 ; COMDAT (pick any)
.text:0000DA54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000DA54
.text:0000DA54 ; =============== S U B R O U T I N E =======================================
.text:0000DA54
.text:0000DA54 ; Attributes: bp-based frame
.text:0000DA54
.text:0000DA54 ; public: __thiscall CMyComPtr<struct ISequentialOutStream>::operator struct ISequentialOutStream *(void)const
.text:0000DA54                 public ??B?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ
.text:0000DA54 ??B?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ proc near
.text:0000DA54                                         ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+3DDp
.text:0000DA54                                         ; CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+690p ...
.text:0000DA54
.text:0000DA54 var_4           = dword ptr -4
.text:0000DA54
.text:0000DA54                 push    ebp
.text:0000DA55                 mov     ebp, esp
.text:0000DA57                 push    ecx
.text:0000DA58                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000DA5F                 mov     [ebp+var_4], ecx
.text:0000DA62                 mov     eax, [ebp+var_4]
.text:0000DA65                 mov     eax, [eax]
.text:0000DA67                 mov     esp, ebp
.text:0000DA69                 pop     ebp
.text:0000DA6A                 retn
.text:0000DA6A ??B?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ endp
.text:0000DA6A
.text:0000DA6A ; ---------------------------------------------------------------------------
.text:0000DA6B                 align 4
.text:0000DA6B _text           ends
.text:0000DA6B
.text:0000DA6C ; ===========================================================================
.text:0000DA6C
.text:0000DA6C ; Segment type: Pure code
.text:0000DA6C ; Segment permissions: Read/Execute
.text:0000DA6C _text           segment para public 'CODE' use32
.text:0000DA6C                 assume cs:_text
.text:0000DA6C                 ;org 0DA6Ch
.text:0000DA6C ; COMDAT (pick any)
.text:0000DA6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000DA6C
.text:0000DA6C ; =============== S U B R O U T I N E =======================================
.text:0000DA6C
.text:0000DA6C ; Attributes: bp-based frame
.text:0000DA6C
.text:0000DA6C ; public: struct ISequentialOutStream * __thiscall CMyComPtr<struct ISequentialOutStream>::operator=(struct ISequentialOutStream *)
.text:0000DA6C                 public ??4?$CMyComPtr@UISequentialOutStream@@@@QAEPAUISequentialOutStream@@PAU1@@Z
.text:0000DA6C ??4?$CMyComPtr@UISequentialOutStream@@@@QAEPAUISequentialOutStream@@PAU1@@Z proc near
.text:0000DA6C                                         ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+1B5p
.text:0000DA6C                                         ; CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+24Ep
.text:0000DA6C
.text:0000DA6C var_4           = dword ptr -4
.text:0000DA6C arg_0           = dword ptr  8
.text:0000DA6C
.text:0000DA6C                 push    ebp
.text:0000DA6D                 mov     ebp, esp
.text:0000DA6F                 push    ecx
.text:0000DA70                 push    esi
.text:0000DA71                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000DA78                 mov     [ebp+var_4], ecx
.text:0000DA7B                 cmp     [ebp+arg_0], 0
.text:0000DA7F                 jz      short loc_DA98
.text:0000DA81                 mov     eax, [ebp+arg_0]
.text:0000DA84                 mov     ecx, [eax]
.text:0000DA86                 mov     esi, esp
.text:0000DA88                 mov     edx, [ebp+arg_0]
.text:0000DA8B                 push    edx
.text:0000DA8C                 mov     eax, [ecx+4]
.text:0000DA8F                 call    eax
.text:0000DA91                 cmp     esi, esp
.text:0000DA93                 call    __RTC_CheckEsp
.text:0000DA98
.text:0000DA98 loc_DA98:                               ; CODE XREF: CMyComPtr<ISequentialOutStream>::operator=(ISequentialOutStream *)+13j
.text:0000DA98                 mov     ecx, [ebp+var_4]
.text:0000DA9B                 cmp     dword ptr [ecx], 0
.text:0000DA9E                 jz      short loc_DABB
.text:0000DAA0                 mov     edx, [ebp+var_4]
.text:0000DAA3                 mov     eax, [edx]
.text:0000DAA5                 mov     ecx, [ebp+var_4]
.text:0000DAA8                 mov     edx, [ecx]
.text:0000DAAA                 mov     eax, [eax]
.text:0000DAAC                 mov     esi, esp
.text:0000DAAE                 push    edx
.text:0000DAAF                 mov     ecx, [eax+8]
.text:0000DAB2                 call    ecx
.text:0000DAB4                 cmp     esi, esp
.text:0000DAB6                 call    __RTC_CheckEsp
.text:0000DABB
.text:0000DABB loc_DABB:                               ; CODE XREF: CMyComPtr<ISequentialOutStream>::operator=(ISequentialOutStream *)+32j
.text:0000DABB                 mov     edx, [ebp+var_4]
.text:0000DABE                 mov     eax, [ebp+arg_0]
.text:0000DAC1                 mov     [edx], eax
.text:0000DAC3                 mov     eax, [ebp+arg_0]
.text:0000DAC6                 pop     esi
.text:0000DAC7                 add     esp, 4
.text:0000DACA                 cmp     ebp, esp
.text:0000DACC                 call    __RTC_CheckEsp
.text:0000DAD1                 mov     esp, ebp
.text:0000DAD3                 pop     ebp
.text:0000DAD4                 retn    4
.text:0000DAD4 ??4?$CMyComPtr@UISequentialOutStream@@@@QAEPAUISequentialOutStream@@PAU1@@Z endp
.text:0000DAD4
.text:0000DAD4 ; ---------------------------------------------------------------------------
.text:0000DAD7                 align 4
.text:0000DAD7 _text           ends
.text:0000DAD7
.text:0000DAD8 ; ===========================================================================
.text:0000DAD8
.text:0000DAD8 ; Segment type: Pure code
.text:0000DAD8 ; Segment permissions: Read/Execute
.text:0000DAD8 _text           segment para public 'CODE' use32
.text:0000DAD8                 assume cs:_text
.text:0000DAD8                 ;org 0DAD8h
.text:0000DAD8 ; COMDAT (pick any)
.text:0000DAD8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000DAD8
.text:0000DAD8 ; =============== S U B R O U T I N E =======================================
.text:0000DAD8
.text:0000DAD8 ; Attributes: bp-based frame
.text:0000DAD8
.text:0000DAD8 ; public: bool __thiscall CMyComPtr<struct ISequentialOutStream>::operator!(void)const
.text:0000DAD8                 public ??7?$CMyComPtr@UISequentialOutStream@@@@QBE_NXZ
.text:0000DAD8 ??7?$CMyComPtr@UISequentialOutStream@@@@QBE_NXZ proc near
.text:0000DAD8                                         ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+1D0p
.text:0000DAD8
.text:0000DAD8 var_4           = dword ptr -4
.text:0000DAD8
.text:0000DAD8                 push    ebp
.text:0000DAD9                 mov     ebp, esp
.text:0000DADB                 push    ecx
.text:0000DADC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000DAE3                 mov     [ebp+var_4], ecx
.text:0000DAE6                 mov     eax, [ebp+var_4]
.text:0000DAE9                 xor     ecx, ecx
.text:0000DAEB                 cmp     dword ptr [eax], 0
.text:0000DAEE                 setz    cl
.text:0000DAF1                 mov     al, cl
.text:0000DAF3                 mov     esp, ebp
.text:0000DAF5                 pop     ebp
.text:0000DAF6                 retn
.text:0000DAF6 ??7?$CMyComPtr@UISequentialOutStream@@@@QBE_NXZ endp
.text:0000DAF6
.text:0000DAF6 ; ---------------------------------------------------------------------------
.text:0000DAF7                 align 4
.text:0000DAF7 _text           ends
.text:0000DAF7
.text:0000DAF8 ; ===========================================================================
.text:0000DAF8
.text:0000DAF8 ; Segment type: Pure code
.text:0000DAF8 ; Segment permissions: Read/Execute
.text:0000DAF8 _text           segment para public 'CODE' use32
.text:0000DAF8                 assume cs:_text
.text:0000DAF8                 ;org 0DAF8h
.text:0000DAF8 ; COMDAT (pick any)
.text:0000DAF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000DAF8
.text:0000DAF8 ; =============== S U B R O U T I N E =======================================
.text:0000DAF8
.text:0000DAF8 ; Attributes: bp-based frame
.text:0000DAF8
.text:0000DAF8 ; public: __thiscall CMyComPtr<struct IUnknown>::CMyComPtr<struct IUnknown>(void)
.text:0000DAF8                 public ??0?$CMyComPtr@UIUnknown@@@@QAE@XZ
.text:0000DAF8 ??0?$CMyComPtr@UIUnknown@@@@QAE@XZ proc near
.text:0000DAF8                                         ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+28Cp
.text:0000DAF8                                         ; CEncoderInfo::Encode(void)+81p ...
.text:0000DAF8
.text:0000DAF8 var_4           = dword ptr -4
.text:0000DAF8
.text:0000DAF8                 push    ebp
.text:0000DAF9                 mov     ebp, esp
.text:0000DAFB                 push    ecx
.text:0000DAFC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000DB03                 mov     [ebp+var_4], ecx
.text:0000DB06                 mov     eax, [ebp+var_4]
.text:0000DB09                 mov     dword ptr [eax], 0
.text:0000DB0F                 mov     eax, [ebp+var_4]
.text:0000DB12                 mov     esp, ebp
.text:0000DB14                 pop     ebp
.text:0000DB15                 retn
.text:0000DB15 ??0?$CMyComPtr@UIUnknown@@@@QAE@XZ endp
.text:0000DB15
.text:0000DB15 ; ---------------------------------------------------------------------------
.text:0000DB16                 align 4
.text:0000DB16 _text           ends
.text:0000DB16
.text:0000DB18 ; ===========================================================================
.text:0000DB18
.text:0000DB18 ; Segment type: Pure code
.text:0000DB18 ; Segment permissions: Read/Execute
.text:0000DB18 _text           segment para public 'CODE' use32
.text:0000DB18                 assume cs:_text
.text:0000DB18                 ;org 0DB18h
.text:0000DB18 ; COMDAT (pick any)
.text:0000DB18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000DB18
.text:0000DB18 ; =============== S U B R O U T I N E =======================================
.text:0000DB18
.text:0000DB18 ; Attributes: bp-based frame
.text:0000DB18
.text:0000DB18 ; public: __thiscall CMyComPtr<struct IUnknown>::~CMyComPtr<struct IUnknown>(void)
.text:0000DB18                 public ??1?$CMyComPtr@UIUnknown@@@@QAE@XZ
.text:0000DB18 ??1?$CMyComPtr@UIUnknown@@@@QAE@XZ proc near
.text:0000DB18                                         ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+347p
.text:0000DB18                                         ; CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+388p ...
.text:0000DB18
.text:0000DB18 var_4           = dword ptr -4
.text:0000DB18
.text:0000DB18                 push    ebp
.text:0000DB19                 mov     ebp, esp
.text:0000DB1B                 push    ecx
.text:0000DB1C                 push    esi
.text:0000DB1D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000DB24                 mov     [ebp+var_4], ecx
.text:0000DB27                 mov     eax, [ebp+var_4]
.text:0000DB2A                 cmp     dword ptr [eax], 0
.text:0000DB2D                 jz      short loc_DB4A
.text:0000DB2F                 mov     ecx, [ebp+var_4]
.text:0000DB32                 mov     edx, [ecx]
.text:0000DB34                 mov     eax, [ebp+var_4]
.text:0000DB37                 mov     ecx, [eax]
.text:0000DB39                 mov     edx, [edx]
.text:0000DB3B                 mov     esi, esp
.text:0000DB3D                 push    ecx
.text:0000DB3E                 mov     eax, [edx+8]
.text:0000DB41                 call    eax
.text:0000DB43                 cmp     esi, esp
.text:0000DB45                 call    __RTC_CheckEsp
.text:0000DB4A
.text:0000DB4A loc_DB4A:                               ; CODE XREF: CMyComPtr<IUnknown>::~CMyComPtr<IUnknown>(void)+15j
.text:0000DB4A                 pop     esi
.text:0000DB4B                 add     esp, 4
.text:0000DB4E                 cmp     ebp, esp
.text:0000DB50                 call    __RTC_CheckEsp
.text:0000DB55                 mov     esp, ebp
.text:0000DB57                 pop     ebp
.text:0000DB58                 retn
.text:0000DB58 ??1?$CMyComPtr@UIUnknown@@@@QAE@XZ endp
.text:0000DB58
.text:0000DB58 ; ---------------------------------------------------------------------------
.text:0000DB59                 align 4
.text:0000DB59 _text           ends
.text:0000DB59
.text:0000DB5C ; ===========================================================================
.text:0000DB5C
.text:0000DB5C ; Segment type: Pure code
.text:0000DB5C ; Segment permissions: Read/Execute
.text:0000DB5C _text           segment para public 'CODE' use32
.text:0000DB5C                 assume cs:_text
.text:0000DB5C                 ;org 0DB5Ch
.text:0000DB5C ; COMDAT (pick any)
.text:0000DB5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000DB5C
.text:0000DB5C ; =============== S U B R O U T I N E =======================================
.text:0000DB5C
.text:0000DB5C ; Attributes: bp-based frame
.text:0000DB5C
.text:0000DB5C ; public: struct IUnknown * __thiscall CMyComPtr<struct IUnknown>::operator=(struct IUnknown *)
.text:0000DB5C                 public ??4?$CMyComPtr@UIUnknown@@@@QAEPAUIUnknown@@PAU1@@Z
.text:0000DB5C ??4?$CMyComPtr@UIUnknown@@@@QAEPAUIUnknown@@PAU1@@Z proc near
.text:0000DB5C                                         ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+2B6p
.text:0000DB5C                                         ; CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+2CCp ...
.text:0000DB5C
.text:0000DB5C var_4           = dword ptr -4
.text:0000DB5C arg_0           = dword ptr  8
.text:0000DB5C
.text:0000DB5C                 push    ebp
.text:0000DB5D                 mov     ebp, esp
.text:0000DB5F                 push    ecx
.text:0000DB60                 push    esi
.text:0000DB61                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000DB68                 mov     [ebp+var_4], ecx
.text:0000DB6B                 cmp     [ebp+arg_0], 0
.text:0000DB6F                 jz      short loc_DB88
.text:0000DB71                 mov     eax, [ebp+arg_0]
.text:0000DB74                 mov     ecx, [eax]
.text:0000DB76                 mov     esi, esp
.text:0000DB78                 mov     edx, [ebp+arg_0]
.text:0000DB7B                 push    edx
.text:0000DB7C                 mov     eax, [ecx+4]
.text:0000DB7F                 call    eax
.text:0000DB81                 cmp     esi, esp
.text:0000DB83                 call    __RTC_CheckEsp
.text:0000DB88
.text:0000DB88 loc_DB88:                               ; CODE XREF: CMyComPtr<IUnknown>::operator=(IUnknown *)+13j
.text:0000DB88                 mov     ecx, [ebp+var_4]
.text:0000DB8B                 cmp     dword ptr [ecx], 0
.text:0000DB8E                 jz      short loc_DBAB
.text:0000DB90                 mov     edx, [ebp+var_4]
.text:0000DB93                 mov     eax, [edx]
.text:0000DB95                 mov     ecx, [ebp+var_4]
.text:0000DB98                 mov     edx, [ecx]
.text:0000DB9A                 mov     eax, [eax]
.text:0000DB9C                 mov     esi, esp
.text:0000DB9E                 push    edx
.text:0000DB9F                 mov     ecx, [eax+8]
.text:0000DBA2                 call    ecx
.text:0000DBA4                 cmp     esi, esp
.text:0000DBA6                 call    __RTC_CheckEsp
.text:0000DBAB
.text:0000DBAB loc_DBAB:                               ; CODE XREF: CMyComPtr<IUnknown>::operator=(IUnknown *)+32j
.text:0000DBAB                 mov     edx, [ebp+var_4]
.text:0000DBAE                 mov     eax, [ebp+arg_0]
.text:0000DBB1                 mov     [edx], eax
.text:0000DBB3                 mov     eax, [ebp+arg_0]
.text:0000DBB6                 pop     esi
.text:0000DBB7                 add     esp, 4
.text:0000DBBA                 cmp     ebp, esp
.text:0000DBBC                 call    __RTC_CheckEsp
.text:0000DBC1                 mov     esp, ebp
.text:0000DBC3                 pop     ebp
.text:0000DBC4                 retn    4
.text:0000DBC4 ??4?$CMyComPtr@UIUnknown@@@@QAEPAUIUnknown@@PAU1@@Z endp
.text:0000DBC4
.text:0000DBC4 ; ---------------------------------------------------------------------------
.text:0000DBC7                 align 4
.text:0000DBC7 _text           ends
.text:0000DBC7
.text:0000DBC8 ; ===========================================================================
.text:0000DBC8
.text:0000DBC8 ; Segment type: Pure code
.text:0000DBC8 ; Segment permissions: Read/Execute
.text:0000DBC8 _text           segment para public 'CODE' use32
.text:0000DBC8                 assume cs:_text
.text:0000DBC8                 ;org 0DBC8h
.text:0000DBC8 ; COMDAT (pick any)
.text:0000DBC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000DBC8
.text:0000DBC8 ; =============== S U B R O U T I N E =======================================
.text:0000DBC8
.text:0000DBC8 ; Attributes: bp-based frame
.text:0000DBC8
.text:0000DBC8 ; public: __thiscall CMyComPtr<struct ICompressSetCoderProperties>::CMyComPtr<struct ICompressSetCoderProperties>(void)
.text:0000DBC8                 public ??0?$CMyComPtr@UICompressSetCoderProperties@@@@QAE@XZ
.text:0000DBC8 ??0?$CMyComPtr@UICompressSetCoderProperties@@@@QAE@XZ proc near
.text:0000DBC8                                         ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+2D4p
.text:0000DBC8                                         ; CEncoderInfo::Decode(uint)+318p ...
.text:0000DBC8
.text:0000DBC8 var_4           = dword ptr -4
.text:0000DBC8
.text:0000DBC8                 push    ebp
.text:0000DBC9                 mov     ebp, esp
.text:0000DBCB                 push    ecx
.text:0000DBCC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000DBD3                 mov     [ebp+var_4], ecx
.text:0000DBD6                 mov     eax, [ebp+var_4]
.text:0000DBD9                 mov     dword ptr [eax], 0
.text:0000DBDF                 mov     eax, [ebp+var_4]
.text:0000DBE2                 mov     esp, ebp
.text:0000DBE4                 pop     ebp
.text:0000DBE5                 retn
.text:0000DBE5 ??0?$CMyComPtr@UICompressSetCoderProperties@@@@QAE@XZ endp
.text:0000DBE5
.text:0000DBE5 ; ---------------------------------------------------------------------------
.text:0000DBE6                 align 4
.text:0000DBE6 _text           ends
.text:0000DBE6
.text:0000DBE8 ; ===========================================================================
.text:0000DBE8
.text:0000DBE8 ; Segment type: Pure code
.text:0000DBE8 ; Segment permissions: Read/Execute
.text:0000DBE8 _text           segment para public 'CODE' use32
.text:0000DBE8                 assume cs:_text
.text:0000DBE8                 ;org 0DBE8h
.text:0000DBE8 ; COMDAT (pick any)
.text:0000DBE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000DBE8
.text:0000DBE8 ; =============== S U B R O U T I N E =======================================
.text:0000DBE8
.text:0000DBE8 ; Attributes: bp-based frame
.text:0000DBE8
.text:0000DBE8 ; public: __thiscall CMyComPtr<struct ICompressSetCoderProperties>::~CMyComPtr<struct ICompressSetCoderProperties>(void)
.text:0000DBE8                 public ??1?$CMyComPtr@UICompressSetCoderProperties@@@@QAE@XZ
.text:0000DBE8 ??1?$CMyComPtr@UICompressSetCoderProperties@@@@QAE@XZ proc near
.text:0000DBE8                                         ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+338p
.text:0000DBE8                                         ; CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+379p ...
.text:0000DBE8
.text:0000DBE8 var_4           = dword ptr -4
.text:0000DBE8
.text:0000DBE8                 push    ebp
.text:0000DBE9                 mov     ebp, esp
.text:0000DBEB                 push    ecx
.text:0000DBEC                 push    esi
.text:0000DBED                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000DBF4                 mov     [ebp+var_4], ecx
.text:0000DBF7                 mov     eax, [ebp+var_4]
.text:0000DBFA                 cmp     dword ptr [eax], 0
.text:0000DBFD                 jz      short loc_DC1A
.text:0000DBFF                 mov     ecx, [ebp+var_4]
.text:0000DC02                 mov     edx, [ecx]
.text:0000DC04                 mov     eax, [ebp+var_4]
.text:0000DC07                 mov     ecx, [eax]
.text:0000DC09                 mov     edx, [edx]
.text:0000DC0B                 mov     esi, esp
.text:0000DC0D                 push    ecx
.text:0000DC0E                 mov     eax, [edx+8]
.text:0000DC11                 call    eax
.text:0000DC13                 cmp     esi, esp
.text:0000DC15                 call    __RTC_CheckEsp
.text:0000DC1A
.text:0000DC1A loc_DC1A:                               ; CODE XREF: CMyComPtr<ICompressSetCoderProperties>::~CMyComPtr<ICompressSetCoderProperties>(void)+15j
.text:0000DC1A                 pop     esi
.text:0000DC1B                 add     esp, 4
.text:0000DC1E                 cmp     ebp, esp
.text:0000DC20                 call    __RTC_CheckEsp
.text:0000DC25                 mov     esp, ebp
.text:0000DC27                 pop     ebp
.text:0000DC28                 retn
.text:0000DC28 ??1?$CMyComPtr@UICompressSetCoderProperties@@@@QAE@XZ endp
.text:0000DC28
.text:0000DC28 ; ---------------------------------------------------------------------------
.text:0000DC29                 align 4
.text:0000DC29 _text           ends
.text:0000DC29
.text:0000DC2C ; ===========================================================================
.text:0000DC2C
.text:0000DC2C ; Segment type: Pure code
.text:0000DC2C ; Segment permissions: Read/Execute
.text:0000DC2C _text           segment para public 'CODE' use32
.text:0000DC2C                 assume cs:_text
.text:0000DC2C                 ;org 0DC2Ch
.text:0000DC2C ; COMDAT (pick any)
.text:0000DC2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000DC2C
.text:0000DC2C ; =============== S U B R O U T I N E =======================================
.text:0000DC2C
.text:0000DC2C ; Attributes: bp-based frame
.text:0000DC2C
.text:0000DC2C ; public: __thiscall CMyComPtr<struct ICompressSetCoderProperties>::operator struct ICompressSetCoderProperties *(void)const
.text:0000DC2C                 public ??B?$CMyComPtr@UICompressSetCoderProperties@@@@QBEPAUICompressSetCoderProperties@@XZ
.text:0000DC2C ??B?$CMyComPtr@UICompressSetCoderProperties@@@@QBEPAUICompressSetCoderProperties@@XZ proc near
.text:0000DC2C                                         ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+2F6p
.text:0000DC2C                                         ; CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+311p ...
.text:0000DC2C
.text:0000DC2C var_4           = dword ptr -4
.text:0000DC2C
.text:0000DC2C                 push    ebp
.text:0000DC2D                 mov     ebp, esp
.text:0000DC2F                 push    ecx
.text:0000DC30                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000DC37                 mov     [ebp+var_4], ecx
.text:0000DC3A                 mov     eax, [ebp+var_4]
.text:0000DC3D                 mov     eax, [eax]
.text:0000DC3F                 mov     esp, ebp
.text:0000DC41                 pop     ebp
.text:0000DC42                 retn
.text:0000DC42 ??B?$CMyComPtr@UICompressSetCoderProperties@@@@QBEPAUICompressSetCoderProperties@@XZ endp
.text:0000DC42
.text:0000DC42 ; ---------------------------------------------------------------------------
.text:0000DC43                 align 4
.text:0000DC43 _text           ends
.text:0000DC43
.text:0000DC44 ; ===========================================================================
.text:0000DC44
.text:0000DC44 ; Segment type: Pure code
.text:0000DC44 ; Segment permissions: Read/Execute
.text:0000DC44 _text           segment para public 'CODE' use32
.text:0000DC44                 assume cs:_text
.text:0000DC44                 ;org 0DC44h
.text:0000DC44 ; COMDAT (pick any)
.text:0000DC44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000DC44
.text:0000DC44 ; =============== S U B R O U T I N E =======================================
.text:0000DC44
.text:0000DC44 ; Attributes: bp-based frame
.text:0000DC44
.text:0000DC44 ; public: struct ICompressSetCoderProperties * * __thiscall CMyComPtr<struct ICompressSetCoderProperties>::operator&(void)
.text:0000DC44                 public ??I?$CMyComPtr@UICompressSetCoderProperties@@@@QAEPAPAUICompressSetCoderProperties@@XZ
.text:0000DC44 ??I?$CMyComPtr@UICompressSetCoderProperties@@@@QAEPAPAUICompressSetCoderProperties@@XZ proc near
.text:0000DC44                                         ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+2E0p
.text:0000DC44                                         ; CEncoderInfo::Decode(uint)+324p ...
.text:0000DC44
.text:0000DC44 var_4           = dword ptr -4
.text:0000DC44
.text:0000DC44                 push    ebp
.text:0000DC45                 mov     ebp, esp
.text:0000DC47                 push    ecx
.text:0000DC48                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000DC4F                 mov     [ebp+var_4], ecx
.text:0000DC52                 mov     eax, [ebp+var_4]
.text:0000DC55                 mov     esp, ebp
.text:0000DC57                 pop     ebp
.text:0000DC58                 retn
.text:0000DC58 ??I?$CMyComPtr@UICompressSetCoderProperties@@@@QAEPAPAUICompressSetCoderProperties@@XZ endp
.text:0000DC58
.text:0000DC58 ; ---------------------------------------------------------------------------
.text:0000DC59                 align 4
.text:0000DC59 _text           ends
.text:0000DC59
.text:0000DC5C ; ===========================================================================
.text:0000DC5C
.text:0000DC5C ; Segment type: Pure code
.text:0000DC5C ; Segment permissions: Read/Execute
.text:0000DC5C _text           segment para public 'CODE' use32
.text:0000DC5C                 assume cs:_text
.text:0000DC5C                 ;org 0DC5Ch
.text:0000DC5C ; COMDAT (pick any)
.text:0000DC5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000DC5C
.text:0000DC5C ; =============== S U B R O U T I N E =======================================
.text:0000DC5C
.text:0000DC5C ; Attributes: bp-based frame
.text:0000DC5C
.text:0000DC5C ; public: __thiscall CMyComPtr<struct ICompressWriteCoderProperties>::CMyComPtr<struct ICompressWriteCoderProperties>(void)
.text:0000DC5C                 public ??0?$CMyComPtr@UICompressWriteCoderProperties@@@@QAE@XZ
.text:0000DC5C ??0?$CMyComPtr@UICompressWriteCoderProperties@@@@QAE@XZ proc near
.text:0000DC5C                                         ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+39Bp
.text:0000DC5C
.text:0000DC5C var_4           = dword ptr -4
.text:0000DC5C
.text:0000DC5C                 push    ebp
.text:0000DC5D                 mov     ebp, esp
.text:0000DC5F                 push    ecx
.text:0000DC60                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000DC67                 mov     [ebp+var_4], ecx
.text:0000DC6A                 mov     eax, [ebp+var_4]
.text:0000DC6D                 mov     dword ptr [eax], 0
.text:0000DC73                 mov     eax, [ebp+var_4]
.text:0000DC76                 mov     esp, ebp
.text:0000DC78                 pop     ebp
.text:0000DC79                 retn
.text:0000DC79 ??0?$CMyComPtr@UICompressWriteCoderProperties@@@@QAE@XZ endp
.text:0000DC79
.text:0000DC79 ; ---------------------------------------------------------------------------
.text:0000DC7A                 align 4
.text:0000DC7A _text           ends
.text:0000DC7A
.text:0000DC7C ; ===========================================================================
.text:0000DC7C
.text:0000DC7C ; Segment type: Pure code
.text:0000DC7C ; Segment permissions: Read/Execute
.text:0000DC7C _text           segment para public 'CODE' use32
.text:0000DC7C                 assume cs:_text
.text:0000DC7C                 ;org 0DC7Ch
.text:0000DC7C ; COMDAT (pick any)
.text:0000DC7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000DC7C
.text:0000DC7C ; =============== S U B R O U T I N E =======================================
.text:0000DC7C
.text:0000DC7C ; Attributes: bp-based frame
.text:0000DC7C
.text:0000DC7C ; public: __thiscall CMyComPtr<struct ICompressWriteCoderProperties>::~CMyComPtr<struct ICompressWriteCoderProperties>(void)
.text:0000DC7C                 public ??1?$CMyComPtr@UICompressWriteCoderProperties@@@@QAE@XZ
.text:0000DC7C ??1?$CMyComPtr@UICompressWriteCoderProperties@@@@QAE@XZ proc near
.text:0000DC7C                                         ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+419p
.text:0000DC7C                                         ; CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+4CFp ...
.text:0000DC7C
.text:0000DC7C var_4           = dword ptr -4
.text:0000DC7C
.text:0000DC7C                 push    ebp
.text:0000DC7D                 mov     ebp, esp
.text:0000DC7F                 push    ecx
.text:0000DC80                 push    esi
.text:0000DC81                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000DC88                 mov     [ebp+var_4], ecx
.text:0000DC8B                 mov     eax, [ebp+var_4]
.text:0000DC8E                 cmp     dword ptr [eax], 0
.text:0000DC91                 jz      short loc_DCAE
.text:0000DC93                 mov     ecx, [ebp+var_4]
.text:0000DC96                 mov     edx, [ecx]
.text:0000DC98                 mov     eax, [ebp+var_4]
.text:0000DC9B                 mov     ecx, [eax]
.text:0000DC9D                 mov     edx, [edx]
.text:0000DC9F                 mov     esi, esp
.text:0000DCA1                 push    ecx
.text:0000DCA2                 mov     eax, [edx+8]
.text:0000DCA5                 call    eax
.text:0000DCA7                 cmp     esi, esp
.text:0000DCA9                 call    __RTC_CheckEsp
.text:0000DCAE
.text:0000DCAE loc_DCAE:                               ; CODE XREF: CMyComPtr<ICompressWriteCoderProperties>::~CMyComPtr<ICompressWriteCoderProperties>(void)+15j
.text:0000DCAE                 pop     esi
.text:0000DCAF                 add     esp, 4
.text:0000DCB2                 cmp     ebp, esp
.text:0000DCB4                 call    __RTC_CheckEsp
.text:0000DCB9                 mov     esp, ebp
.text:0000DCBB                 pop     ebp
.text:0000DCBC                 retn
.text:0000DCBC ??1?$CMyComPtr@UICompressWriteCoderProperties@@@@QAE@XZ endp
.text:0000DCBC
.text:0000DCBC ; ---------------------------------------------------------------------------
.text:0000DCBD                 align 10h
.text:0000DCBD _text           ends
.text:0000DCBD
.text:0000DCC0 ; ===========================================================================
.text:0000DCC0
.text:0000DCC0 ; Segment type: Pure code
.text:0000DCC0 ; Segment permissions: Read/Execute
.text:0000DCC0 _text           segment para public 'CODE' use32
.text:0000DCC0                 assume cs:_text
.text:0000DCC0                 ;org 0DCC0h
.text:0000DCC0 ; COMDAT (pick any)
.text:0000DCC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000DCC0
.text:0000DCC0 ; =============== S U B R O U T I N E =======================================
.text:0000DCC0
.text:0000DCC0 ; Attributes: bp-based frame
.text:0000DCC0
.text:0000DCC0 ; public: __thiscall CMyComPtr<struct ICompressWriteCoderProperties>::operator struct ICompressWriteCoderProperties *(void)const
.text:0000DCC0                 public ??B?$CMyComPtr@UICompressWriteCoderProperties@@@@QBEPAUICompressWriteCoderProperties@@XZ
.text:0000DCC0 ??B?$CMyComPtr@UICompressWriteCoderProperties@@@@QBEPAUICompressWriteCoderProperties@@XZ proc near
.text:0000DCC0                                         ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+3BDp
.text:0000DCC0
.text:0000DCC0 var_4           = dword ptr -4
.text:0000DCC0
.text:0000DCC0                 push    ebp
.text:0000DCC1                 mov     ebp, esp
.text:0000DCC3                 push    ecx
.text:0000DCC4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000DCCB                 mov     [ebp+var_4], ecx
.text:0000DCCE                 mov     eax, [ebp+var_4]
.text:0000DCD1                 mov     eax, [eax]
.text:0000DCD3                 mov     esp, ebp
.text:0000DCD5                 pop     ebp
.text:0000DCD6                 retn
.text:0000DCD6 ??B?$CMyComPtr@UICompressWriteCoderProperties@@@@QBEPAUICompressWriteCoderProperties@@XZ endp
.text:0000DCD6
.text:0000DCD6 ; ---------------------------------------------------------------------------
.text:0000DCD7                 align 4
.text:0000DCD7 _text           ends
.text:0000DCD7
.text:0000DCD8 ; ===========================================================================
.text:0000DCD8
.text:0000DCD8 ; Segment type: Pure code
.text:0000DCD8 ; Segment permissions: Read/Execute
.text:0000DCD8 _text           segment para public 'CODE' use32
.text:0000DCD8                 assume cs:_text
.text:0000DCD8                 ;org 0DCD8h
.text:0000DCD8 ; COMDAT (pick any)
.text:0000DCD8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000DCD8
.text:0000DCD8 ; =============== S U B R O U T I N E =======================================
.text:0000DCD8
.text:0000DCD8 ; Attributes: bp-based frame
.text:0000DCD8
.text:0000DCD8 ; public: struct ICompressWriteCoderProperties * * __thiscall CMyComPtr<struct ICompressWriteCoderProperties>::operator&(void)
.text:0000DCD8                 public ??I?$CMyComPtr@UICompressWriteCoderProperties@@@@QAEPAPAUICompressWriteCoderProperties@@XZ
.text:0000DCD8 ??I?$CMyComPtr@UICompressWriteCoderProperties@@@@QAEPAPAUICompressWriteCoderProperties@@XZ proc near
.text:0000DCD8                                         ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+3A7p
.text:0000DCD8
.text:0000DCD8 var_4           = dword ptr -4
.text:0000DCD8
.text:0000DCD8                 push    ebp
.text:0000DCD9                 mov     ebp, esp
.text:0000DCDB                 push    ecx
.text:0000DCDC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000DCE3                 mov     [ebp+var_4], ecx
.text:0000DCE6                 mov     eax, [ebp+var_4]
.text:0000DCE9                 mov     esp, ebp
.text:0000DCEB                 pop     ebp
.text:0000DCEC                 retn
.text:0000DCEC ??I?$CMyComPtr@UICompressWriteCoderProperties@@@@QAEPAPAUICompressWriteCoderProperties@@XZ endp
.text:0000DCEC
.text:0000DCEC ; ---------------------------------------------------------------------------
.text:0000DCED                 align 10h
.text:0000DCED _text           ends
.text:0000DCED
.text:0000DCF0 ; ===========================================================================
.text:0000DCF0
.text:0000DCF0 ; Segment type: Pure code
.text:0000DCF0 ; Segment permissions: Read/Execute
.text:0000DCF0 _text           segment para public 'CODE' use32
.text:0000DCF0                 assume cs:_text
.text:0000DCF0                 ;org 0DCF0h
.text:0000DCF0 ; COMDAT (pick any)
.text:0000DCF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000DCF0
.text:0000DCF0 ; =============== S U B R O U T I N E =======================================
.text:0000DCF0
.text:0000DCF0 ; Attributes: bp-based frame
.text:0000DCF0
.text:0000DCF0 ; public: struct ICompressWriteCoderProperties * __thiscall CMyComPtr<struct ICompressWriteCoderProperties>::operator->(void)const
.text:0000DCF0                 public ??C?$CMyComPtr@UICompressWriteCoderProperties@@@@QBEPAUICompressWriteCoderProperties@@XZ
.text:0000DCF0 ??C?$CMyComPtr@UICompressWriteCoderProperties@@@@QBEPAUICompressWriteCoderProperties@@XZ proc near
.text:0000DCF0                                         ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+3C9p
.text:0000DCF0
.text:0000DCF0 var_4           = dword ptr -4
.text:0000DCF0
.text:0000DCF0                 push    ebp
.text:0000DCF1                 mov     ebp, esp
.text:0000DCF3                 push    ecx
.text:0000DCF4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000DCFB                 mov     [ebp+var_4], ecx
.text:0000DCFE                 mov     eax, [ebp+var_4]
.text:0000DD01                 mov     eax, [eax]
.text:0000DD03                 mov     esp, ebp
.text:0000DD05                 pop     ebp
.text:0000DD06                 retn
.text:0000DD06 ??C?$CMyComPtr@UICompressWriteCoderProperties@@@@QBEPAUICompressWriteCoderProperties@@XZ endp
.text:0000DD06
.text:0000DD06 ; ---------------------------------------------------------------------------
.text:0000DD07                 align 4
.text:0000DD07 _text           ends
.text:0000DD07
.text:0000DD08 ; ===========================================================================
.text:0000DD08
.text:0000DD08 ; Segment type: Pure code
.text:0000DD08 ; Segment permissions: Read/Execute
.text:0000DD08 _text           segment para public 'CODE' use32
.text:0000DD08                 assume cs:_text
.text:0000DD08                 ;org 0DD08h
.text:0000DD08 ; COMDAT (pick any)
.text:0000DD08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000DD08
.text:0000DD08 ; =============== S U B R O U T I N E =======================================
.text:0000DD08
.text:0000DD08 ; Attributes: bp-based frame
.text:0000DD08
.text:0000DD08 ; public: __thiscall CMyComPtr<struct ICryptoSetPassword>::CMyComPtr<struct ICryptoSetPassword>(void)
.text:0000DD08                 public ??0?$CMyComPtr@UICryptoSetPassword@@@@QAE@XZ
.text:0000DD08 ??0?$CMyComPtr@UICryptoSetPassword@@@@QAE@XZ proc near
.text:0000DD08                                         ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+447p
.text:0000DD08                                         ; CEncoderInfo::Decode(uint)+4C6p
.text:0000DD08
.text:0000DD08 var_4           = dword ptr -4
.text:0000DD08
.text:0000DD08                 push    ebp
.text:0000DD09                 mov     ebp, esp
.text:0000DD0B                 push    ecx
.text:0000DD0C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000DD13                 mov     [ebp+var_4], ecx
.text:0000DD16                 mov     eax, [ebp+var_4]
.text:0000DD19                 mov     dword ptr [eax], 0
.text:0000DD1F                 mov     eax, [ebp+var_4]
.text:0000DD22                 mov     esp, ebp
.text:0000DD24                 pop     ebp
.text:0000DD25                 retn
.text:0000DD25 ??0?$CMyComPtr@UICryptoSetPassword@@@@QAE@XZ endp
.text:0000DD25
.text:0000DD25 ; ---------------------------------------------------------------------------
.text:0000DD26                 align 4
.text:0000DD26 _text           ends
.text:0000DD26
.text:0000DD28 ; ===========================================================================
.text:0000DD28
.text:0000DD28 ; Segment type: Pure code
.text:0000DD28 ; Segment permissions: Read/Execute
.text:0000DD28 _text           segment para public 'CODE' use32
.text:0000DD28                 assume cs:_text
.text:0000DD28                 ;org 0DD28h
.text:0000DD28 ; COMDAT (pick any)
.text:0000DD28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000DD28
.text:0000DD28 ; =============== S U B R O U T I N E =======================================
.text:0000DD28
.text:0000DD28 ; Attributes: bp-based frame
.text:0000DD28
.text:0000DD28 ; public: __thiscall CMyComPtr<struct ICryptoSetPassword>::~CMyComPtr<struct ICryptoSetPassword>(void)
.text:0000DD28                 public ??1?$CMyComPtr@UICryptoSetPassword@@@@QAE@XZ
.text:0000DD28 ??1?$CMyComPtr@UICryptoSetPassword@@@@QAE@XZ proc near
.text:0000DD28                                         ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+4C3p
.text:0000DD28                                         ; CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+6F7p ...
.text:0000DD28
.text:0000DD28 var_4           = dword ptr -4
.text:0000DD28
.text:0000DD28                 push    ebp
.text:0000DD29                 mov     ebp, esp
.text:0000DD2B                 push    ecx
.text:0000DD2C                 push    esi
.text:0000DD2D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000DD34                 mov     [ebp+var_4], ecx
.text:0000DD37                 mov     eax, [ebp+var_4]
.text:0000DD3A                 cmp     dword ptr [eax], 0
.text:0000DD3D                 jz      short loc_DD5A
.text:0000DD3F                 mov     ecx, [ebp+var_4]
.text:0000DD42                 mov     edx, [ecx]
.text:0000DD44                 mov     eax, [ebp+var_4]
.text:0000DD47                 mov     ecx, [eax]
.text:0000DD49                 mov     edx, [edx]
.text:0000DD4B                 mov     esi, esp
.text:0000DD4D                 push    ecx
.text:0000DD4E                 mov     eax, [edx+8]
.text:0000DD51                 call    eax
.text:0000DD53                 cmp     esi, esp
.text:0000DD55                 call    __RTC_CheckEsp
.text:0000DD5A
.text:0000DD5A loc_DD5A:                               ; CODE XREF: CMyComPtr<ICryptoSetPassword>::~CMyComPtr<ICryptoSetPassword>(void)+15j
.text:0000DD5A                 pop     esi
.text:0000DD5B                 add     esp, 4
.text:0000DD5E                 cmp     ebp, esp
.text:0000DD60                 call    __RTC_CheckEsp
.text:0000DD65                 mov     esp, ebp
.text:0000DD67                 pop     ebp
.text:0000DD68                 retn
.text:0000DD68 ??1?$CMyComPtr@UICryptoSetPassword@@@@QAE@XZ endp
.text:0000DD68
.text:0000DD68 ; ---------------------------------------------------------------------------
.text:0000DD69                 align 4
.text:0000DD69 _text           ends
.text:0000DD69
.text:0000DD6C ; ===========================================================================
.text:0000DD6C
.text:0000DD6C ; Segment type: Pure code
.text:0000DD6C ; Segment permissions: Read/Execute
.text:0000DD6C _text           segment para public 'CODE' use32
.text:0000DD6C                 assume cs:_text
.text:0000DD6C                 ;org 0DD6Ch
.text:0000DD6C ; COMDAT (pick any)
.text:0000DD6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000DD6C
.text:0000DD6C ; =============== S U B R O U T I N E =======================================
.text:0000DD6C
.text:0000DD6C ; Attributes: bp-based frame
.text:0000DD6C
.text:0000DD6C ; public: __thiscall CMyComPtr<struct ICryptoSetPassword>::operator struct ICryptoSetPassword *(void)const
.text:0000DD6C                 public ??B?$CMyComPtr@UICryptoSetPassword@@@@QBEPAUICryptoSetPassword@@XZ
.text:0000DD6C ??B?$CMyComPtr@UICryptoSetPassword@@@@QBEPAUICryptoSetPassword@@XZ proc near
.text:0000DD6C                                         ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+469p
.text:0000DD6C                                         ; CEncoderInfo::Decode(uint)+4EEp
.text:0000DD6C
.text:0000DD6C var_4           = dword ptr -4
.text:0000DD6C
.text:0000DD6C                 push    ebp
.text:0000DD6D                 mov     ebp, esp
.text:0000DD6F                 push    ecx
.text:0000DD70                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000DD77                 mov     [ebp+var_4], ecx
.text:0000DD7A                 mov     eax, [ebp+var_4]
.text:0000DD7D                 mov     eax, [eax]
.text:0000DD7F                 mov     esp, ebp
.text:0000DD81                 pop     ebp
.text:0000DD82                 retn
.text:0000DD82 ??B?$CMyComPtr@UICryptoSetPassword@@@@QBEPAUICryptoSetPassword@@XZ endp
.text:0000DD82
.text:0000DD82 ; ---------------------------------------------------------------------------
.text:0000DD83                 align 4
.text:0000DD83 _text           ends
.text:0000DD83
.text:0000DD84 ; ===========================================================================
.text:0000DD84
.text:0000DD84 ; Segment type: Pure code
.text:0000DD84 ; Segment permissions: Read/Execute
.text:0000DD84 _text           segment para public 'CODE' use32
.text:0000DD84                 assume cs:_text
.text:0000DD84                 ;org 0DD84h
.text:0000DD84 ; COMDAT (pick any)
.text:0000DD84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000DD84
.text:0000DD84 ; =============== S U B R O U T I N E =======================================
.text:0000DD84
.text:0000DD84 ; Attributes: bp-based frame
.text:0000DD84
.text:0000DD84 ; public: struct ICryptoSetPassword * * __thiscall CMyComPtr<struct ICryptoSetPassword>::operator&(void)
.text:0000DD84                 public ??I?$CMyComPtr@UICryptoSetPassword@@@@QAEPAPAUICryptoSetPassword@@XZ
.text:0000DD84 ??I?$CMyComPtr@UICryptoSetPassword@@@@QAEPAPAUICryptoSetPassword@@XZ proc near
.text:0000DD84                                         ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+453p
.text:0000DD84                                         ; CEncoderInfo::Decode(uint)+4D5p
.text:0000DD84
.text:0000DD84 var_4           = dword ptr -4
.text:0000DD84
.text:0000DD84                 push    ebp
.text:0000DD85                 mov     ebp, esp
.text:0000DD87                 push    ecx
.text:0000DD88                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000DD8F                 mov     [ebp+var_4], ecx
.text:0000DD92                 mov     eax, [ebp+var_4]
.text:0000DD95                 mov     esp, ebp
.text:0000DD97                 pop     ebp
.text:0000DD98                 retn
.text:0000DD98 ??I?$CMyComPtr@UICryptoSetPassword@@@@QAEPAPAUICryptoSetPassword@@XZ endp
.text:0000DD98
.text:0000DD98 ; ---------------------------------------------------------------------------
.text:0000DD99                 align 4
.text:0000DD99 _text           ends
.text:0000DD99
.text:0000DD9C ; ===========================================================================
.text:0000DD9C
.text:0000DD9C ; Segment type: Pure code
.text:0000DD9C ; Segment permissions: Read/Execute
.text:0000DD9C _text           segment para public 'CODE' use32
.text:0000DD9C                 assume cs:_text
.text:0000DD9C                 ;org 0DD9Ch
.text:0000DD9C ; COMDAT (pick any)
.text:0000DD9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000DD9C
.text:0000DD9C ; =============== S U B R O U T I N E =======================================
.text:0000DD9C
.text:0000DD9C ; Attributes: bp-based frame
.text:0000DD9C
.text:0000DD9C ; public: struct ICryptoSetPassword * __thiscall CMyComPtr<struct ICryptoSetPassword>::operator->(void)const
.text:0000DD9C                 public ??C?$CMyComPtr@UICryptoSetPassword@@@@QBEPAUICryptoSetPassword@@XZ
.text:0000DD9C ??C?$CMyComPtr@UICryptoSetPassword@@@@QBEPAUICryptoSetPassword@@XZ proc near
.text:0000DD9C                                         ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+479p
.text:0000DD9C                                         ; CEncoderInfo::Decode(uint)+501p
.text:0000DD9C
.text:0000DD9C var_4           = dword ptr -4
.text:0000DD9C
.text:0000DD9C                 push    ebp
.text:0000DD9D                 mov     ebp, esp
.text:0000DD9F                 push    ecx
.text:0000DDA0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000DDA7                 mov     [ebp+var_4], ecx
.text:0000DDAA                 mov     eax, [ebp+var_4]
.text:0000DDAD                 mov     eax, [eax]
.text:0000DDAF                 mov     esp, ebp
.text:0000DDB1                 pop     ebp
.text:0000DDB2                 retn
.text:0000DDB2 ??C?$CMyComPtr@UICryptoSetPassword@@@@QBEPAUICryptoSetPassword@@XZ endp
.text:0000DDB2
.text:0000DDB2 ; ---------------------------------------------------------------------------
.text:0000DDB3                 align 4
.text:0000DDB3 _text           ends
.text:0000DDB3
.text:0000DDB4 ; ===========================================================================
.text:0000DDB4
.text:0000DDB4 ; Segment type: Pure code
.text:0000DDB4 ; Segment permissions: Read/Execute
.text:0000DDB4 _text           segment para public 'CODE' use32
.text:0000DDB4                 assume cs:_text
.text:0000DDB4                 ;org 0DDB4h
.text:0000DDB4 ; COMDAT (pick any)
.text:0000DDB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000DDB4
.text:0000DDB4 ; =============== S U B R O U T I N E =======================================
.text:0000DDB4
.text:0000DDB4 ; Attributes: bp-based frame
.text:0000DDB4
.text:0000DDB4 ; public: __thiscall CMyComPtr<struct ISequentialInStream>::CMyComPtr<struct ISequentialInStream>(struct ISequentialInStream *)
.text:0000DDB4                 public ??0?$CMyComPtr@UISequentialInStream@@@@QAE@PAUISequentialInStream@@@Z
.text:0000DDB4 ??0?$CMyComPtr@UISequentialInStream@@@@QAE@PAUISequentialInStream@@@Z proc near
.text:0000DDB4                                         ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+554p
.text:0000DDB4                                         ; CEncoderInfo::Encode(void)+124p ...
.text:0000DDB4
.text:0000DDB4 var_4           = dword ptr -4
.text:0000DDB4 arg_0           = dword ptr  8
.text:0000DDB4
.text:0000DDB4                 push    ebp
.text:0000DDB5                 mov     ebp, esp
.text:0000DDB7                 push    ecx
.text:0000DDB8                 push    esi
.text:0000DDB9                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000DDC0                 mov     [ebp+var_4], ecx
.text:0000DDC3                 mov     eax, [ebp+var_4]
.text:0000DDC6                 mov     ecx, [ebp+arg_0]
.text:0000DDC9                 mov     [eax], ecx
.text:0000DDCB                 cmp     [ebp+arg_0], 0
.text:0000DDCF                 jz      short loc_DDE8
.text:0000DDD1                 mov     edx, [ebp+arg_0]
.text:0000DDD4                 mov     eax, [edx]
.text:0000DDD6                 mov     esi, esp
.text:0000DDD8                 mov     ecx, [ebp+arg_0]
.text:0000DDDB                 push    ecx
.text:0000DDDC                 mov     edx, [eax+4]
.text:0000DDDF                 call    edx
.text:0000DDE1                 cmp     esi, esp
.text:0000DDE3                 call    __RTC_CheckEsp
.text:0000DDE8
.text:0000DDE8 loc_DDE8:                               ; CODE XREF: CMyComPtr<ISequentialInStream>::CMyComPtr<ISequentialInStream>(ISequentialInStream *)+1Bj
.text:0000DDE8                 mov     eax, [ebp+var_4]
.text:0000DDEB                 pop     esi
.text:0000DDEC                 add     esp, 4
.text:0000DDEF                 cmp     ebp, esp
.text:0000DDF1                 call    __RTC_CheckEsp
.text:0000DDF6                 mov     esp, ebp
.text:0000DDF8                 pop     ebp
.text:0000DDF9                 retn    4
.text:0000DDF9 ??0?$CMyComPtr@UISequentialInStream@@@@QAE@PAUISequentialInStream@@@Z endp
.text:0000DDF9
.text:0000DDF9 _text           ends
.text:0000DDF9
.text:0000DDFC ; ===========================================================================
.text:0000DDFC
.text:0000DDFC ; Segment type: Pure code
.text:0000DDFC ; Segment permissions: Read/Execute
.text:0000DDFC _text           segment para public 'CODE' use32
.text:0000DDFC                 assume cs:_text
.text:0000DDFC                 ;org 0DDFCh
.text:0000DDFC ; COMDAT (pick any)
.text:0000DDFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000DDFC
.text:0000DDFC ; =============== S U B R O U T I N E =======================================
.text:0000DDFC
.text:0000DDFC ; Attributes: bp-based frame
.text:0000DDFC
.text:0000DDFC ; public: __thiscall CMyComPtr<struct ISequentialInStream>::~CMyComPtr<struct ISequentialInStream>(void)
.text:0000DDFC                 public ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ
.text:0000DDFC ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ proc near
.text:0000DDFC                                         ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+6EBp
.text:0000DDFC                                         ; CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+741p ...
.text:0000DDFC
.text:0000DDFC var_4           = dword ptr -4
.text:0000DDFC
.text:0000DDFC                 push    ebp
.text:0000DDFD                 mov     ebp, esp
.text:0000DDFF                 push    ecx
.text:0000DE00                 push    esi
.text:0000DE01                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000DE08                 mov     [ebp+var_4], ecx
.text:0000DE0B                 mov     eax, [ebp+var_4]
.text:0000DE0E                 cmp     dword ptr [eax], 0
.text:0000DE11                 jz      short loc_DE2E
.text:0000DE13                 mov     ecx, [ebp+var_4]
.text:0000DE16                 mov     edx, [ecx]
.text:0000DE18                 mov     eax, [ebp+var_4]
.text:0000DE1B                 mov     ecx, [eax]
.text:0000DE1D                 mov     edx, [edx]
.text:0000DE1F                 mov     esi, esp
.text:0000DE21                 push    ecx
.text:0000DE22                 mov     eax, [edx+8]
.text:0000DE25                 call    eax
.text:0000DE27                 cmp     esi, esp
.text:0000DE29                 call    __RTC_CheckEsp
.text:0000DE2E
.text:0000DE2E loc_DE2E:                               ; CODE XREF: CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)+15j
.text:0000DE2E                 pop     esi
.text:0000DE2F                 add     esp, 4
.text:0000DE32                 cmp     ebp, esp
.text:0000DE34                 call    __RTC_CheckEsp
.text:0000DE39                 mov     esp, ebp
.text:0000DE3B                 pop     ebp
.text:0000DE3C                 retn
.text:0000DE3C ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ endp
.text:0000DE3C
.text:0000DE3C ; ---------------------------------------------------------------------------
.text:0000DE3D                 align 10h
.text:0000DE3D _text           ends
.text:0000DE3D
.text:0000DE40 ; ===========================================================================
.text:0000DE40
.text:0000DE40 ; Segment type: Pure code
.text:0000DE40 ; Segment permissions: Read/Execute
.text:0000DE40 _text           segment para public 'CODE' use32
.text:0000DE40                 assume cs:_text
.text:0000DE40                 ;org 0DE40h
.text:0000DE40 ; COMDAT (pick any)
.text:0000DE40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000DE40
.text:0000DE40 ; =============== S U B R O U T I N E =======================================
.text:0000DE40
.text:0000DE40 ; Attributes: bp-based frame
.text:0000DE40
.text:0000DE40 ; public: __thiscall CMyComPtr<struct ISequentialInStream>::operator struct ISequentialInStream *(void)const
.text:0000DE40                 public ??B?$CMyComPtr@UISequentialInStream@@@@QBEPAUISequentialInStream@@XZ
.text:0000DE40 ??B?$CMyComPtr@UISequentialInStream@@@@QBEPAUISequentialInStream@@XZ proc near
.text:0000DE40                                         ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+699p
.text:0000DE40                                         ; CEncoderInfo::Encode(void)+584p ...
.text:0000DE40
.text:0000DE40 var_4           = dword ptr -4
.text:0000DE40
.text:0000DE40                 push    ebp
.text:0000DE41                 mov     ebp, esp
.text:0000DE43                 push    ecx
.text:0000DE44                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000DE4B                 mov     [ebp+var_4], ecx
.text:0000DE4E                 mov     eax, [ebp+var_4]
.text:0000DE51                 mov     eax, [eax]
.text:0000DE53                 mov     esp, ebp
.text:0000DE55                 pop     ebp
.text:0000DE56                 retn
.text:0000DE56 ??B?$CMyComPtr@UISequentialInStream@@@@QBEPAUISequentialInStream@@XZ endp
.text:0000DE56
.text:0000DE56 ; ---------------------------------------------------------------------------
.text:0000DE57                 align 4
.text:0000DE57 _text           ends
.text:0000DE57
.text:0000DE58 ; ===========================================================================
.text:0000DE58
.text:0000DE58 ; Segment type: Pure code
.text:0000DE58 ; Segment permissions: Read/Execute
.text:0000DE58 _text           segment para public 'CODE' use32
.text:0000DE58                 assume cs:_text
.text:0000DE58                 ;org 0DE58h
.text:0000DE58 ; COMDAT (pick any)
.text:0000DE58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000DE58
.text:0000DE58 ; =============== S U B R O U T I N E =======================================
.text:0000DE58
.text:0000DE58 ; Attributes: bp-based frame
.text:0000DE58
.text:0000DE58 ; public: __thiscall CMyComPtr<struct ICryptoProperties>::CMyComPtr<struct ICryptoProperties>(void)
.text:0000DE58                 public ??0?$CMyComPtr@UICryptoProperties@@@@QAE@XZ
.text:0000DE58 ??0?$CMyComPtr@UICryptoProperties@@@@QAE@XZ proc near
.text:0000DE58                                         ; CODE XREF: CEncoderInfo::Encode(void)+72p
.text:0000DE58                                         ; CEncoderInfo::Decode(uint)+3D5p
.text:0000DE58
.text:0000DE58 var_4           = dword ptr -4
.text:0000DE58
.text:0000DE58                 push    ebp
.text:0000DE59                 mov     ebp, esp
.text:0000DE5B                 push    ecx
.text:0000DE5C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000DE63                 mov     [ebp+var_4], ecx
.text:0000DE66                 mov     eax, [ebp+var_4]
.text:0000DE69                 mov     dword ptr [eax], 0
.text:0000DE6F                 mov     eax, [ebp+var_4]
.text:0000DE72                 mov     esp, ebp
.text:0000DE74                 pop     ebp
.text:0000DE75                 retn
.text:0000DE75 ??0?$CMyComPtr@UICryptoProperties@@@@QAE@XZ endp
.text:0000DE75
.text:0000DE75 ; ---------------------------------------------------------------------------
.text:0000DE76                 align 4
.text:0000DE76 _text           ends
.text:0000DE76
.text:0000DE78 ; ===========================================================================
.text:0000DE78
.text:0000DE78 ; Segment type: Pure code
.text:0000DE78 ; Segment permissions: Read/Execute
.text:0000DE78 _text           segment para public 'CODE' use32
.text:0000DE78                 assume cs:_text
.text:0000DE78                 ;org 0DE78h
.text:0000DE78 ; COMDAT (pick any)
.text:0000DE78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000DE78
.text:0000DE78 ; =============== S U B R O U T I N E =======================================
.text:0000DE78
.text:0000DE78 ; Attributes: bp-based frame
.text:0000DE78
.text:0000DE78 ; public: __thiscall CMyComPtr<struct ICryptoProperties>::~CMyComPtr<struct ICryptoProperties>(void)
.text:0000DE78                 public ??1?$CMyComPtr@UICryptoProperties@@@@QAE@XZ
.text:0000DE78 ??1?$CMyComPtr@UICryptoProperties@@@@QAE@XZ proc near
.text:0000DE78                                         ; CODE XREF: CEncoderInfo::Encode(void)+1B7p
.text:0000DE78                                         ; CEncoderInfo::Encode(void)+229p ...
.text:0000DE78
.text:0000DE78 var_4           = dword ptr -4
.text:0000DE78
.text:0000DE78                 push    ebp
.text:0000DE79                 mov     ebp, esp
.text:0000DE7B                 push    ecx
.text:0000DE7C                 push    esi
.text:0000DE7D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000DE84                 mov     [ebp+var_4], ecx
.text:0000DE87                 mov     eax, [ebp+var_4]
.text:0000DE8A                 cmp     dword ptr [eax], 0
.text:0000DE8D                 jz      short loc_DEAA
.text:0000DE8F                 mov     ecx, [ebp+var_4]
.text:0000DE92                 mov     edx, [ecx]
.text:0000DE94                 mov     eax, [ebp+var_4]
.text:0000DE97                 mov     ecx, [eax]
.text:0000DE99                 mov     edx, [edx]
.text:0000DE9B                 mov     esi, esp
.text:0000DE9D                 push    ecx
.text:0000DE9E                 mov     eax, [edx+8]
.text:0000DEA1                 call    eax
.text:0000DEA3                 cmp     esi, esp
.text:0000DEA5                 call    __RTC_CheckEsp
.text:0000DEAA
.text:0000DEAA loc_DEAA:                               ; CODE XREF: CMyComPtr<ICryptoProperties>::~CMyComPtr<ICryptoProperties>(void)+15j
.text:0000DEAA                 pop     esi
.text:0000DEAB                 add     esp, 4
.text:0000DEAE                 cmp     ebp, esp
.text:0000DEB0                 call    __RTC_CheckEsp
.text:0000DEB5                 mov     esp, ebp
.text:0000DEB7                 pop     ebp
.text:0000DEB8                 retn
.text:0000DEB8 ??1?$CMyComPtr@UICryptoProperties@@@@QAE@XZ endp
.text:0000DEB8
.text:0000DEB8 ; ---------------------------------------------------------------------------
.text:0000DEB9                 align 4
.text:0000DEB9 _text           ends
.text:0000DEB9
.text:0000DEBC ; ===========================================================================
.text:0000DEBC
.text:0000DEBC ; Segment type: Pure code
.text:0000DEBC ; Segment permissions: Read/Execute
.text:0000DEBC _text           segment para public 'CODE' use32
.text:0000DEBC                 assume cs:_text
.text:0000DEBC                 ;org 0DEBCh
.text:0000DEBC ; COMDAT (pick any)
.text:0000DEBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000DEBC
.text:0000DEBC ; =============== S U B R O U T I N E =======================================
.text:0000DEBC
.text:0000DEBC ; Attributes: bp-based frame
.text:0000DEBC
.text:0000DEBC ; public: __thiscall CMyComPtr<struct ICryptoProperties>::operator struct ICryptoProperties *(void)const
.text:0000DEBC                 public ??B?$CMyComPtr@UICryptoProperties@@@@QBEPAUICryptoProperties@@XZ
.text:0000DEBC ??B?$CMyComPtr@UICryptoProperties@@@@QBEPAUICryptoProperties@@XZ proc near
.text:0000DEBC                                         ; CODE XREF: CEncoderInfo::Encode(void)+145p
.text:0000DEBC                                         ; CEncoderInfo::Decode(uint)+5DEp
.text:0000DEBC
.text:0000DEBC var_4           = dword ptr -4
.text:0000DEBC
.text:0000DEBC                 push    ebp
.text:0000DEBD                 mov     ebp, esp
.text:0000DEBF                 push    ecx
.text:0000DEC0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000DEC7                 mov     [ebp+var_4], ecx
.text:0000DECA                 mov     eax, [ebp+var_4]
.text:0000DECD                 mov     eax, [eax]
.text:0000DECF                 mov     esp, ebp
.text:0000DED1                 pop     ebp
.text:0000DED2                 retn
.text:0000DED2 ??B?$CMyComPtr@UICryptoProperties@@@@QBEPAUICryptoProperties@@XZ endp
.text:0000DED2
.text:0000DED2 ; ---------------------------------------------------------------------------
.text:0000DED3                 align 4
.text:0000DED3 _text           ends
.text:0000DED3
.text:0000DED4 ; ===========================================================================
.text:0000DED4
.text:0000DED4 ; Segment type: Pure code
.text:0000DED4 ; Segment permissions: Read/Execute
.text:0000DED4 _text           segment para public 'CODE' use32
.text:0000DED4                 assume cs:_text
.text:0000DED4                 ;org 0DED4h
.text:0000DED4 ; COMDAT (pick any)
.text:0000DED4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000DED4
.text:0000DED4 ; =============== S U B R O U T I N E =======================================
.text:0000DED4
.text:0000DED4 ; Attributes: bp-based frame
.text:0000DED4
.text:0000DED4 ; public: struct ICryptoProperties * * __thiscall CMyComPtr<struct ICryptoProperties>::operator&(void)
.text:0000DED4                 public ??I?$CMyComPtr@UICryptoProperties@@@@QAEPAPAUICryptoProperties@@XZ
.text:0000DED4 ??I?$CMyComPtr@UICryptoProperties@@@@QAEPAPAUICryptoProperties@@XZ proc near
.text:0000DED4                                         ; CODE XREF: CEncoderInfo::Encode(void)+C6p
.text:0000DED4                                         ; CEncoderInfo::Decode(uint)+3E4p
.text:0000DED4
.text:0000DED4 var_4           = dword ptr -4
.text:0000DED4
.text:0000DED4                 push    ebp
.text:0000DED5                 mov     ebp, esp
.text:0000DED7                 push    ecx
.text:0000DED8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000DEDF                 mov     [ebp+var_4], ecx
.text:0000DEE2                 mov     eax, [ebp+var_4]
.text:0000DEE5                 mov     esp, ebp
.text:0000DEE7                 pop     ebp
.text:0000DEE8                 retn
.text:0000DEE8 ??I?$CMyComPtr@UICryptoProperties@@@@QAEPAPAUICryptoProperties@@XZ endp
.text:0000DEE8
.text:0000DEE8 ; ---------------------------------------------------------------------------
.text:0000DEE9                 align 4
.text:0000DEE9 _text           ends
.text:0000DEE9
.text:0000DEEC ; ===========================================================================
.text:0000DEEC
.text:0000DEEC ; Segment type: Pure code
.text:0000DEEC ; Segment permissions: Read/Execute
.text:0000DEEC _text           segment para public 'CODE' use32
.text:0000DEEC                 assume cs:_text
.text:0000DEEC                 ;org 0DEECh
.text:0000DEEC ; COMDAT (pick any)
.text:0000DEEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000DEEC
.text:0000DEEC ; =============== S U B R O U T I N E =======================================
.text:0000DEEC
.text:0000DEEC ; Attributes: bp-based frame
.text:0000DEEC
.text:0000DEEC ; public: struct ICryptoProperties * __thiscall CMyComPtr<struct ICryptoProperties>::operator->(void)const
.text:0000DEEC                 public ??C?$CMyComPtr@UICryptoProperties@@@@QBEPAUICryptoProperties@@XZ
.text:0000DEEC ??C?$CMyComPtr@UICryptoProperties@@@@QBEPAUICryptoProperties@@XZ proc near
.text:0000DEEC                                         ; CODE XREF: CEncoderInfo::Encode(void)+155p
.text:0000DEEC                                         ; CEncoderInfo::Encode(void)+1C7p ...
.text:0000DEEC
.text:0000DEEC var_4           = dword ptr -4
.text:0000DEEC
.text:0000DEEC                 push    ebp
.text:0000DEED                 mov     ebp, esp
.text:0000DEEF                 push    ecx
.text:0000DEF0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000DEF7                 mov     [ebp+var_4], ecx
.text:0000DEFA                 mov     eax, [ebp+var_4]
.text:0000DEFD                 mov     eax, [eax]
.text:0000DEFF                 mov     esp, ebp
.text:0000DF01                 pop     ebp
.text:0000DF02                 retn
.text:0000DF02 ??C?$CMyComPtr@UICryptoProperties@@@@QBEPAUICryptoProperties@@XZ endp
.text:0000DF02
.text:0000DF02 ; ---------------------------------------------------------------------------
.text:0000DF03                 align 4
.text:0000DF03 _text           ends
.text:0000DF03
.text:0000DF04 ; ===========================================================================
.text:0000DF04
.text:0000DF04 ; Segment type: Pure code
.text:0000DF04 ; Segment permissions: Read/Execute
.text:0000DF04 _text           segment para public 'CODE' use32
.text:0000DF04                 assume cs:_text
.text:0000DF04                 ;org 0DF04h
.text:0000DF04 ; COMDAT (pick any)
.text:0000DF04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000DF04
.text:0000DF04 ; =============== S U B R O U T I N E =======================================
.text:0000DF04
.text:0000DF04 ; Attributes: bp-based frame
.text:0000DF04
.text:0000DF04 ; public: __thiscall CMyComPtr<struct ICompressSetDecoderProperties2>::CMyComPtr<struct ICompressSetDecoderProperties2>(void)
.text:0000DF04                 public ??0?$CMyComPtr@UICompressSetDecoderProperties2@@@@QAE@XZ
.text:0000DF04 ??0?$CMyComPtr@UICompressSetDecoderProperties2@@@@QAE@XZ proc near
.text:0000DF04                                         ; CODE XREF: CEncoderInfo::Decode(uint)+13Ep
.text:0000DF04
.text:0000DF04 var_4           = dword ptr -4
.text:0000DF04
.text:0000DF04                 push    ebp
.text:0000DF05                 mov     ebp, esp
.text:0000DF07                 push    ecx
.text:0000DF08                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000DF0F                 mov     [ebp+var_4], ecx
.text:0000DF12                 mov     eax, [ebp+var_4]
.text:0000DF15                 mov     dword ptr [eax], 0
.text:0000DF1B                 mov     eax, [ebp+var_4]
.text:0000DF1E                 mov     esp, ebp
.text:0000DF20                 pop     ebp
.text:0000DF21                 retn
.text:0000DF21 ??0?$CMyComPtr@UICompressSetDecoderProperties2@@@@QAE@XZ endp
.text:0000DF21
.text:0000DF21 ; ---------------------------------------------------------------------------
.text:0000DF22                 align 4
.text:0000DF22 _text           ends
.text:0000DF22
.text:0000DF24 ; ===========================================================================
.text:0000DF24
.text:0000DF24 ; Segment type: Pure code
.text:0000DF24 ; Segment permissions: Read/Execute
.text:0000DF24 _text           segment para public 'CODE' use32
.text:0000DF24                 assume cs:_text
.text:0000DF24                 ;org 0DF24h
.text:0000DF24 ; COMDAT (pick any)
.text:0000DF24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000DF24
.text:0000DF24 ; =============== S U B R O U T I N E =======================================
.text:0000DF24
.text:0000DF24 ; Attributes: bp-based frame
.text:0000DF24
.text:0000DF24 ; public: __thiscall CMyComPtr<struct ICompressSetDecoderProperties2>::~CMyComPtr<struct ICompressSetDecoderProperties2>(void)
.text:0000DF24                 public ??1?$CMyComPtr@UICompressSetDecoderProperties2@@@@QAE@XZ
.text:0000DF24 ??1?$CMyComPtr@UICompressSetDecoderProperties2@@@@QAE@XZ proc near
.text:0000DF24                                         ; CODE XREF: CEncoderInfo::Decode(uint)+18Cp
.text:0000DF24                                         ; CEncoderInfo::Decode(uint)+2DEp ...
.text:0000DF24
.text:0000DF24 var_4           = dword ptr -4
.text:0000DF24
.text:0000DF24                 push    ebp
.text:0000DF25                 mov     ebp, esp
.text:0000DF27                 push    ecx
.text:0000DF28                 push    esi
.text:0000DF29                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000DF30                 mov     [ebp+var_4], ecx
.text:0000DF33                 mov     eax, [ebp+var_4]
.text:0000DF36                 cmp     dword ptr [eax], 0
.text:0000DF39                 jz      short loc_DF56
.text:0000DF3B                 mov     ecx, [ebp+var_4]
.text:0000DF3E                 mov     edx, [ecx]
.text:0000DF40                 mov     eax, [ebp+var_4]
.text:0000DF43                 mov     ecx, [eax]
.text:0000DF45                 mov     edx, [edx]
.text:0000DF47                 mov     esi, esp
.text:0000DF49                 push    ecx
.text:0000DF4A                 mov     eax, [edx+8]
.text:0000DF4D                 call    eax
.text:0000DF4F                 cmp     esi, esp
.text:0000DF51                 call    __RTC_CheckEsp
.text:0000DF56
.text:0000DF56 loc_DF56:                               ; CODE XREF: CMyComPtr<ICompressSetDecoderProperties2>::~CMyComPtr<ICompressSetDecoderProperties2>(void)+15j
.text:0000DF56                 pop     esi
.text:0000DF57                 add     esp, 4
.text:0000DF5A                 cmp     ebp, esp
.text:0000DF5C                 call    __RTC_CheckEsp
.text:0000DF61                 mov     esp, ebp
.text:0000DF63                 pop     ebp
.text:0000DF64                 retn
.text:0000DF64 ??1?$CMyComPtr@UICompressSetDecoderProperties2@@@@QAE@XZ endp
.text:0000DF64
.text:0000DF64 ; ---------------------------------------------------------------------------
.text:0000DF65                 align 4
.text:0000DF65 _text           ends
.text:0000DF65
.text:0000DF68 ; ===========================================================================
.text:0000DF68
.text:0000DF68 ; Segment type: Pure code
.text:0000DF68 ; Segment permissions: Read/Execute
.text:0000DF68 _text           segment para public 'CODE' use32
.text:0000DF68                 assume cs:_text
.text:0000DF68                 ;org 0DF68h
.text:0000DF68 ; COMDAT (pick any)
.text:0000DF68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000DF68
.text:0000DF68 ; =============== S U B R O U T I N E =======================================
.text:0000DF68
.text:0000DF68 ; Attributes: bp-based frame
.text:0000DF68
.text:0000DF68 ; public: __thiscall CMyComPtr<struct ICompressSetDecoderProperties2>::operator struct ICompressSetDecoderProperties2 *(void)const
.text:0000DF68                 public ??B?$CMyComPtr@UICompressSetDecoderProperties2@@@@QBEPAUICompressSetDecoderProperties2@@XZ
.text:0000DF68 ??B?$CMyComPtr@UICompressSetDecoderProperties2@@@@QBEPAUICompressSetDecoderProperties2@@XZ proc near
.text:0000DF68                                         ; CODE XREF: CEncoderInfo::Decode(uint)+3FAp
.text:0000DF68
.text:0000DF68 var_4           = dword ptr -4
.text:0000DF68
.text:0000DF68                 push    ebp
.text:0000DF69                 mov     ebp, esp
.text:0000DF6B                 push    ecx
.text:0000DF6C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000DF73                 mov     [ebp+var_4], ecx
.text:0000DF76                 mov     eax, [ebp+var_4]
.text:0000DF79                 mov     eax, [eax]
.text:0000DF7B                 mov     esp, ebp
.text:0000DF7D                 pop     ebp
.text:0000DF7E                 retn
.text:0000DF7E ??B?$CMyComPtr@UICompressSetDecoderProperties2@@@@QBEPAUICompressSetDecoderProperties2@@XZ endp
.text:0000DF7E
.text:0000DF7E ; ---------------------------------------------------------------------------
.text:0000DF7F                 align 10h
.text:0000DF7F _text           ends
.text:0000DF7F
.text:0000DF80 ; ===========================================================================
.text:0000DF80
.text:0000DF80 ; Segment type: Pure code
.text:0000DF80 ; Segment permissions: Read/Execute
.text:0000DF80 _text           segment para public 'CODE' use32
.text:0000DF80                 assume cs:_text
.text:0000DF80                 ;org 0DF80h
.text:0000DF80 ; COMDAT (pick any)
.text:0000DF80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000DF80
.text:0000DF80 ; =============== S U B R O U T I N E =======================================
.text:0000DF80
.text:0000DF80 ; Attributes: bp-based frame
.text:0000DF80
.text:0000DF80 ; public: struct ICompressSetDecoderProperties2 * * __thiscall CMyComPtr<struct ICompressSetDecoderProperties2>::operator&(void)
.text:0000DF80                 public ??I?$CMyComPtr@UICompressSetDecoderProperties2@@@@QAEPAPAUICompressSetDecoderProperties2@@XZ
.text:0000DF80 ??I?$CMyComPtr@UICompressSetDecoderProperties2@@@@QAEPAPAUICompressSetDecoderProperties2@@XZ proc near
.text:0000DF80                                         ; CODE XREF: CEncoderInfo::Decode(uint)+14Ap
.text:0000DF80
.text:0000DF80 var_4           = dword ptr -4
.text:0000DF80
.text:0000DF80                 push    ebp
.text:0000DF81                 mov     ebp, esp
.text:0000DF83                 push    ecx
.text:0000DF84                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000DF8B                 mov     [ebp+var_4], ecx
.text:0000DF8E                 mov     eax, [ebp+var_4]
.text:0000DF91                 mov     esp, ebp
.text:0000DF93                 pop     ebp
.text:0000DF94                 retn
.text:0000DF94 ??I?$CMyComPtr@UICompressSetDecoderProperties2@@@@QAEPAPAUICompressSetDecoderProperties2@@XZ endp
.text:0000DF94
.text:0000DF94 ; ---------------------------------------------------------------------------
.text:0000DF95                 align 4
.text:0000DF95 _text           ends
.text:0000DF95
.text:0000DF98 ; ===========================================================================
.text:0000DF98
.text:0000DF98 ; Segment type: Pure code
.text:0000DF98 ; Segment permissions: Read/Execute
.text:0000DF98 _text           segment para public 'CODE' use32
.text:0000DF98                 assume cs:_text
.text:0000DF98                 ;org 0DF98h
.text:0000DF98 ; COMDAT (pick any)
.text:0000DF98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000DF98
.text:0000DF98 ; =============== S U B R O U T I N E =======================================
.text:0000DF98
.text:0000DF98 ; Attributes: bp-based frame
.text:0000DF98
.text:0000DF98 ; public: struct ICompressSetDecoderProperties2 * __thiscall CMyComPtr<struct ICompressSetDecoderProperties2>::operator->(void)const
.text:0000DF98                 public ??C?$CMyComPtr@UICompressSetDecoderProperties2@@@@QBEPAUICompressSetDecoderProperties2@@XZ
.text:0000DF98 ??C?$CMyComPtr@UICompressSetDecoderProperties2@@@@QBEPAUICompressSetDecoderProperties2@@XZ proc near
.text:0000DF98                                         ; CODE XREF: CEncoderInfo::Decode(uint)+40Ap
.text:0000DF98
.text:0000DF98 var_4           = dword ptr -4
.text:0000DF98
.text:0000DF98                 push    ebp
.text:0000DF99                 mov     ebp, esp
.text:0000DF9B                 push    ecx
.text:0000DF9C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000DFA3                 mov     [ebp+var_4], ecx
.text:0000DFA6                 mov     eax, [ebp+var_4]
.text:0000DFA9                 mov     eax, [eax]
.text:0000DFAB                 mov     esp, ebp
.text:0000DFAD                 pop     ebp
.text:0000DFAE                 retn
.text:0000DFAE ??C?$CMyComPtr@UICompressSetDecoderProperties2@@@@QBEPAUICompressSetDecoderProperties2@@XZ endp
.text:0000DFAE
.text:0000DFAE ; ---------------------------------------------------------------------------
.text:0000DFAF                 align 10h
.text:0000DFAF _text           ends
.text:0000DFAF
.text:0000DFB0 ; ===========================================================================
.text:0000DFB0
.text:0000DFB0 ; Segment type: Pure code
.text:0000DFB0 ; Segment permissions: Read/Execute
.text:0000DFB0 _text           segment para public 'CODE' use32
.text:0000DFB0                 assume cs:_text
.text:0000DFB0                 ;org 0DFB0h
.text:0000DFB0 ; COMDAT (pick any)
.text:0000DFB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000DFB0
.text:0000DFB0 ; =============== S U B R O U T I N E =======================================
.text:0000DFB0
.text:0000DFB0 ; Attributes: bp-based frame
.text:0000DFB0
.text:0000DFB0 ; public: bool __thiscall CMyComPtr<struct ICompressSetDecoderProperties2>::operator!(void)const
.text:0000DFB0                 public ??7?$CMyComPtr@UICompressSetDecoderProperties2@@@@QBE_NXZ
.text:0000DFB0 ??7?$CMyComPtr@UICompressSetDecoderProperties2@@@@QBE_NXZ proc near
.text:0000DFB0                                         ; CODE XREF: CEncoderInfo::Decode(uint)+160p
.text:0000DFB0
.text:0000DFB0 var_4           = dword ptr -4
.text:0000DFB0
.text:0000DFB0                 push    ebp
.text:0000DFB1                 mov     ebp, esp
.text:0000DFB3                 push    ecx
.text:0000DFB4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000DFBB                 mov     [ebp+var_4], ecx
.text:0000DFBE                 mov     eax, [ebp+var_4]
.text:0000DFC1                 xor     ecx, ecx
.text:0000DFC3                 cmp     dword ptr [eax], 0
.text:0000DFC6                 setz    cl
.text:0000DFC9                 mov     al, cl
.text:0000DFCB                 mov     esp, ebp
.text:0000DFCD                 pop     ebp
.text:0000DFCE                 retn
.text:0000DFCE ??7?$CMyComPtr@UICompressSetDecoderProperties2@@@@QBE_NXZ endp
.text:0000DFCE
.text:0000DFCE ; ---------------------------------------------------------------------------
.text:0000DFCF                 align 10h
.text:0000DFCF _text           ends
.text:0000DFCF
.text:0000DFD0 ; ===========================================================================
.text:0000DFD0
.text:0000DFD0 ; Segment type: Pure code
.text:0000DFD0 ; Segment permissions: Read/Execute
.text:0000DFD0 _text           segment para public 'CODE' use32
.text:0000DFD0                 assume cs:_text
.text:0000DFD0                 ;org 0DFD0h
.text:0000DFD0 ; COMDAT (pick any)
.text:0000DFD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000DFD0
.text:0000DFD0 ; =============== S U B R O U T I N E =======================================
.text:0000DFD0
.text:0000DFD0 ; Attributes: bp-based frame
.text:0000DFD0
.text:0000DFD0 ; public: __thiscall CMyComPtr<struct ICompressSetCoderMt>::CMyComPtr<struct ICompressSetCoderMt>(void)
.text:0000DFD0                 public ??0?$CMyComPtr@UICompressSetCoderMt@@@@QAE@XZ
.text:0000DFD0 ??0?$CMyComPtr@UICompressSetCoderMt@@@@QAE@XZ proc near
.text:0000DFD0                                         ; CODE XREF: CEncoderInfo::Decode(uint)+24Cp
.text:0000DFD0
.text:0000DFD0 var_4           = dword ptr -4
.text:0000DFD0
.text:0000DFD0                 push    ebp
.text:0000DFD1                 mov     ebp, esp
.text:0000DFD3                 push    ecx
.text:0000DFD4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000DFDB                 mov     [ebp+var_4], ecx
.text:0000DFDE                 mov     eax, [ebp+var_4]
.text:0000DFE1                 mov     dword ptr [eax], 0
.text:0000DFE7                 mov     eax, [ebp+var_4]
.text:0000DFEA                 mov     esp, ebp
.text:0000DFEC                 pop     ebp
.text:0000DFED                 retn
.text:0000DFED ??0?$CMyComPtr@UICompressSetCoderMt@@@@QAE@XZ endp
.text:0000DFED
.text:0000DFED ; ---------------------------------------------------------------------------
.text:0000DFEE                 align 10h
.text:0000DFEE _text           ends
.text:0000DFEE
.text:0000DFF0 ; ===========================================================================
.text:0000DFF0
.text:0000DFF0 ; Segment type: Pure code
.text:0000DFF0 ; Segment permissions: Read/Execute
.text:0000DFF0 _text           segment para public 'CODE' use32
.text:0000DFF0                 assume cs:_text
.text:0000DFF0                 ;org 0DFF0h
.text:0000DFF0 ; COMDAT (pick any)
.text:0000DFF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000DFF0
.text:0000DFF0 ; =============== S U B R O U T I N E =======================================
.text:0000DFF0
.text:0000DFF0 ; Attributes: bp-based frame
.text:0000DFF0
.text:0000DFF0 ; public: __thiscall CMyComPtr<struct ICompressSetCoderMt>::~CMyComPtr<struct ICompressSetCoderMt>(void)
.text:0000DFF0                 public ??1?$CMyComPtr@UICompressSetCoderMt@@@@QAE@XZ
.text:0000DFF0 ??1?$CMyComPtr@UICompressSetCoderMt@@@@QAE@XZ proc near
.text:0000DFF0                                         ; CODE XREF: CEncoderInfo::Decode(uint)+2C6p
.text:0000DFF0                                         ; CEncoderInfo::Decode(uint)+310p ...
.text:0000DFF0
.text:0000DFF0 var_4           = dword ptr -4
.text:0000DFF0
.text:0000DFF0                 push    ebp
.text:0000DFF1                 mov     ebp, esp
.text:0000DFF3                 push    ecx
.text:0000DFF4                 push    esi
.text:0000DFF5                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000DFFC                 mov     [ebp+var_4], ecx
.text:0000DFFF                 mov     eax, [ebp+var_4]
.text:0000E002                 cmp     dword ptr [eax], 0
.text:0000E005                 jz      short loc_E022
.text:0000E007                 mov     ecx, [ebp+var_4]
.text:0000E00A                 mov     edx, [ecx]
.text:0000E00C                 mov     eax, [ebp+var_4]
.text:0000E00F                 mov     ecx, [eax]
.text:0000E011                 mov     edx, [edx]
.text:0000E013                 mov     esi, esp
.text:0000E015                 push    ecx
.text:0000E016                 mov     eax, [edx+8]
.text:0000E019                 call    eax
.text:0000E01B                 cmp     esi, esp
.text:0000E01D                 call    __RTC_CheckEsp
.text:0000E022
.text:0000E022 loc_E022:                               ; CODE XREF: CMyComPtr<ICompressSetCoderMt>::~CMyComPtr<ICompressSetCoderMt>(void)+15j
.text:0000E022                 pop     esi
.text:0000E023                 add     esp, 4
.text:0000E026                 cmp     ebp, esp
.text:0000E028                 call    __RTC_CheckEsp
.text:0000E02D                 mov     esp, ebp
.text:0000E02F                 pop     ebp
.text:0000E030                 retn
.text:0000E030 ??1?$CMyComPtr@UICompressSetCoderMt@@@@QAE@XZ endp
.text:0000E030
.text:0000E030 ; ---------------------------------------------------------------------------
.text:0000E031                 align 4
.text:0000E031 _text           ends
.text:0000E031
.text:0000E034 ; ===========================================================================
.text:0000E034
.text:0000E034 ; Segment type: Pure code
.text:0000E034 ; Segment permissions: Read/Execute
.text:0000E034 _text           segment para public 'CODE' use32
.text:0000E034                 assume cs:_text
.text:0000E034                 ;org 0E034h
.text:0000E034 ; COMDAT (pick any)
.text:0000E034                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000E034
.text:0000E034 ; =============== S U B R O U T I N E =======================================
.text:0000E034
.text:0000E034 ; Attributes: bp-based frame
.text:0000E034
.text:0000E034 ; public: __thiscall CMyComPtr<struct ICompressSetCoderMt>::operator struct ICompressSetCoderMt *(void)const
.text:0000E034                 public ??B?$CMyComPtr@UICompressSetCoderMt@@@@QBEPAUICompressSetCoderMt@@XZ
.text:0000E034 ??B?$CMyComPtr@UICompressSetCoderMt@@@@QBEPAUICompressSetCoderMt@@XZ proc near
.text:0000E034                                         ; CODE XREF: CEncoderInfo::Decode(uint)+26Ep
.text:0000E034
.text:0000E034 var_4           = dword ptr -4
.text:0000E034
.text:0000E034                 push    ebp
.text:0000E035                 mov     ebp, esp
.text:0000E037                 push    ecx
.text:0000E038                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000E03F                 mov     [ebp+var_4], ecx
.text:0000E042                 mov     eax, [ebp+var_4]
.text:0000E045                 mov     eax, [eax]
.text:0000E047                 mov     esp, ebp
.text:0000E049                 pop     ebp
.text:0000E04A                 retn
.text:0000E04A ??B?$CMyComPtr@UICompressSetCoderMt@@@@QBEPAUICompressSetCoderMt@@XZ endp
.text:0000E04A
.text:0000E04A ; ---------------------------------------------------------------------------
.text:0000E04B                 align 4
.text:0000E04B _text           ends
.text:0000E04B
.text:0000E04C ; ===========================================================================
.text:0000E04C
.text:0000E04C ; Segment type: Pure code
.text:0000E04C ; Segment permissions: Read/Execute
.text:0000E04C _text           segment para public 'CODE' use32
.text:0000E04C                 assume cs:_text
.text:0000E04C                 ;org 0E04Ch
.text:0000E04C ; COMDAT (pick any)
.text:0000E04C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000E04C
.text:0000E04C ; =============== S U B R O U T I N E =======================================
.text:0000E04C
.text:0000E04C ; Attributes: bp-based frame
.text:0000E04C
.text:0000E04C ; public: struct ICompressSetCoderMt * * __thiscall CMyComPtr<struct ICompressSetCoderMt>::operator&(void)
.text:0000E04C                 public ??I?$CMyComPtr@UICompressSetCoderMt@@@@QAEPAPAUICompressSetCoderMt@@XZ
.text:0000E04C ??I?$CMyComPtr@UICompressSetCoderMt@@@@QAEPAPAUICompressSetCoderMt@@XZ proc near
.text:0000E04C                                         ; CODE XREF: CEncoderInfo::Decode(uint)+258p
.text:0000E04C
.text:0000E04C var_4           = dword ptr -4
.text:0000E04C
.text:0000E04C                 push    ebp
.text:0000E04D                 mov     ebp, esp
.text:0000E04F                 push    ecx
.text:0000E050                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000E057                 mov     [ebp+var_4], ecx
.text:0000E05A                 mov     eax, [ebp+var_4]
.text:0000E05D                 mov     esp, ebp
.text:0000E05F                 pop     ebp
.text:0000E060                 retn
.text:0000E060 ??I?$CMyComPtr@UICompressSetCoderMt@@@@QAEPAPAUICompressSetCoderMt@@XZ endp
.text:0000E060
.text:0000E060 ; ---------------------------------------------------------------------------
.text:0000E061                 align 4
.text:0000E061 _text           ends
.text:0000E061
.text:0000E064 ; ===========================================================================
.text:0000E064
.text:0000E064 ; Segment type: Pure code
.text:0000E064 ; Segment permissions: Read/Execute
.text:0000E064 _text           segment para public 'CODE' use32
.text:0000E064                 assume cs:_text
.text:0000E064                 ;org 0E064h
.text:0000E064 ; COMDAT (pick any)
.text:0000E064                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000E064
.text:0000E064 ; =============== S U B R O U T I N E =======================================
.text:0000E064
.text:0000E064 ; Attributes: bp-based frame
.text:0000E064
.text:0000E064 ; public: struct ICompressSetCoderMt * __thiscall CMyComPtr<struct ICompressSetCoderMt>::operator->(void)const
.text:0000E064                 public ??C?$CMyComPtr@UICompressSetCoderMt@@@@QBEPAUICompressSetCoderMt@@XZ
.text:0000E064 ??C?$CMyComPtr@UICompressSetCoderMt@@@@QBEPAUICompressSetCoderMt@@XZ proc near
.text:0000E064                                         ; CODE XREF: CEncoderInfo::Decode(uint)+27Ep
.text:0000E064
.text:0000E064 var_4           = dword ptr -4
.text:0000E064
.text:0000E064                 push    ebp
.text:0000E065                 mov     ebp, esp
.text:0000E067                 push    ecx
.text:0000E068                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000E06F                 mov     [ebp+var_4], ecx
.text:0000E072                 mov     eax, [ebp+var_4]
.text:0000E075                 mov     eax, [eax]
.text:0000E077                 mov     esp, ebp
.text:0000E079                 pop     ebp
.text:0000E07A                 retn
.text:0000E07A ??C?$CMyComPtr@UICompressSetCoderMt@@@@QBEPAUICompressSetCoderMt@@XZ endp
.text:0000E07A
.text:0000E07A ; ---------------------------------------------------------------------------
.text:0000E07B                 align 4
.text:0000E07B _text           ends
.text:0000E07B
.text:0000E07C ; ===========================================================================
.text:0000E07C
.text:0000E07C ; Segment type: Pure code
.text:0000E07C ; Segment permissions: Read/Execute
.text:0000E07C _text           segment para public 'CODE' use32
.text:0000E07C                 assume cs:_text
.text:0000E07C                 ;org 0E07Ch
.text:0000E07C ; COMDAT (pick any)
.text:0000E07C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000E07C
.text:0000E07C ; =============== S U B R O U T I N E =======================================
.text:0000E07C
.text:0000E07C ; Attributes: bp-based frame
.text:0000E07C
.text:0000E07C ; public: __thiscall CMyComPtr<struct IHasher>::CMyComPtr<struct IHasher>(void)
.text:0000E07C                 public ??0?$CMyComPtr@UIHasher@@@@QAE@XZ
.text:0000E07C ??0?$CMyComPtr@UIHasher@@@@QAE@XZ proc near
.text:0000E07C                                         ; CODE XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+6FBp
.text:0000E07C                                         ; CCrcInfo::CCrcInfo(void)+42p
.text:0000E07C
.text:0000E07C var_4           = dword ptr -4
.text:0000E07C
.text:0000E07C                 push    ebp
.text:0000E07D                 mov     ebp, esp
.text:0000E07F                 push    ecx
.text:0000E080                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000E087                 mov     [ebp+var_4], ecx
.text:0000E08A                 mov     eax, [ebp+var_4]
.text:0000E08D                 mov     dword ptr [eax], 0
.text:0000E093                 mov     eax, [ebp+var_4]
.text:0000E096                 mov     esp, ebp
.text:0000E098                 pop     ebp
.text:0000E099                 retn
.text:0000E099 ??0?$CMyComPtr@UIHasher@@@@QAE@XZ endp
.text:0000E099
.text:0000E099 ; ---------------------------------------------------------------------------
.text:0000E09A                 align 4
.text:0000E09A _text           ends
.text:0000E09A
.text:0000E09C ; ===========================================================================
.text:0000E09C
.text:0000E09C ; Segment type: Pure code
.text:0000E09C ; Segment permissions: Read/Execute
.text:0000E09C _text           segment para public 'CODE' use32
.text:0000E09C                 assume cs:_text
.text:0000E09C                 ;org 0E09Ch
.text:0000E09C ; COMDAT (pick any)
.text:0000E09C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000E09C
.text:0000E09C ; =============== S U B R O U T I N E =======================================
.text:0000E09C
.text:0000E09C ; Attributes: bp-based frame
.text:0000E09C
.text:0000E09C ; public: __thiscall CMyComPtr<struct IHasher>::~CMyComPtr<struct IHasher>(void)
.text:0000E09C                 public ??1?$CMyComPtr@UIHasher@@@@QAE@XZ
.text:0000E09C ??1?$CMyComPtr@UIHasher@@@@QAE@XZ proc near
.text:0000E09C                                         ; CODE XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+762p
.text:0000E09C                                         ; CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+7D1p ...
.text:0000E09C
.text:0000E09C var_4           = dword ptr -4
.text:0000E09C
.text:0000E09C                 push    ebp
.text:0000E09D                 mov     ebp, esp
.text:0000E09F                 push    ecx
.text:0000E0A0                 push    esi
.text:0000E0A1                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000E0A8                 mov     [ebp+var_4], ecx
.text:0000E0AB                 mov     eax, [ebp+var_4]
.text:0000E0AE                 cmp     dword ptr [eax], 0
.text:0000E0B1                 jz      short loc_E0CE
.text:0000E0B3                 mov     ecx, [ebp+var_4]
.text:0000E0B6                 mov     edx, [ecx]
.text:0000E0B8                 mov     eax, [ebp+var_4]
.text:0000E0BB                 mov     ecx, [eax]
.text:0000E0BD                 mov     edx, [edx]
.text:0000E0BF                 mov     esi, esp
.text:0000E0C1                 push    ecx
.text:0000E0C2                 mov     eax, [edx+8]
.text:0000E0C5                 call    eax
.text:0000E0C7                 cmp     esi, esp
.text:0000E0C9                 call    __RTC_CheckEsp
.text:0000E0CE
.text:0000E0CE loc_E0CE:                               ; CODE XREF: CMyComPtr<IHasher>::~CMyComPtr<IHasher>(void)+15j
.text:0000E0CE                 pop     esi
.text:0000E0CF                 add     esp, 4
.text:0000E0D2                 cmp     ebp, esp
.text:0000E0D4                 call    __RTC_CheckEsp
.text:0000E0D9                 mov     esp, ebp
.text:0000E0DB                 pop     ebp
.text:0000E0DC                 retn
.text:0000E0DC ??1?$CMyComPtr@UIHasher@@@@QAE@XZ endp
.text:0000E0DC
.text:0000E0DC ; ---------------------------------------------------------------------------
.text:0000E0DD                 align 10h
.text:0000E0DD _text           ends
.text:0000E0DD
.text:0000E0E0 ; ===========================================================================
.text:0000E0E0
.text:0000E0E0 ; Segment type: Pure code
.text:0000E0E0 ; Segment permissions: Read/Execute
.text:0000E0E0 _text           segment para public 'CODE' use32
.text:0000E0E0                 assume cs:_text
.text:0000E0E0                 ;org 0E0E0h
.text:0000E0E0 ; COMDAT (pick any)
.text:0000E0E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000E0E0
.text:0000E0E0 ; =============== S U B R O U T I N E =======================================
.text:0000E0E0
.text:0000E0E0 ; Attributes: bp-based frame
.text:0000E0E0
.text:0000E0E0 ; public: __thiscall CMyComPtr<struct IHasher>::operator struct IHasher *(void)const
.text:0000E0E0                 public ??B?$CMyComPtr@UIHasher@@@@QBEPAUIHasher@@XZ
.text:0000E0E0 ??B?$CMyComPtr@UIHasher@@@@QBEPAUIHasher@@XZ proc near
.text:0000E0E0                                         ; CODE XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+8FFp
.text:0000E0E0                                         ; CrcThreadFunction(void *)+60p
.text:0000E0E0
.text:0000E0E0 var_4           = dword ptr -4
.text:0000E0E0
.text:0000E0E0                 push    ebp
.text:0000E0E1                 mov     ebp, esp
.text:0000E0E3                 push    ecx
.text:0000E0E4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000E0EB                 mov     [ebp+var_4], ecx
.text:0000E0EE                 mov     eax, [ebp+var_4]
.text:0000E0F1                 mov     eax, [eax]
.text:0000E0F3                 mov     esp, ebp
.text:0000E0F5                 pop     ebp
.text:0000E0F6                 retn
.text:0000E0F6 ??B?$CMyComPtr@UIHasher@@@@QBEPAUIHasher@@XZ endp
.text:0000E0F6
.text:0000E0F6 ; ---------------------------------------------------------------------------
.text:0000E0F7                 align 4
.text:0000E0F7 _text           ends
.text:0000E0F7
.text:0000E0F8 ; ===========================================================================
.text:0000E0F8
.text:0000E0F8 ; Segment type: Pure code
.text:0000E0F8 ; Segment permissions: Read/Execute
.text:0000E0F8 _text           segment para public 'CODE' use32
.text:0000E0F8                 assume cs:_text
.text:0000E0F8                 ;org 0E0F8h
.text:0000E0F8 ; COMDAT (pick any)
.text:0000E0F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000E0F8
.text:0000E0F8 ; =============== S U B R O U T I N E =======================================
.text:0000E0F8
.text:0000E0F8 ; Attributes: bp-based frame
.text:0000E0F8
.text:0000E0F8 ; public: bool __thiscall CMyComPtr<struct IHasher>::operator!(void)const
.text:0000E0F8                 public ??7?$CMyComPtr@UIHasher@@@@QBE_NXZ
.text:0000E0F8 ??7?$CMyComPtr@UIHasher@@@@QBE_NXZ proc near
.text:0000E0F8                                         ; CODE XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+351p
.text:0000E0F8                                         ; CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+7A2p
.text:0000E0F8
.text:0000E0F8 var_4           = dword ptr -4
.text:0000E0F8
.text:0000E0F8                 push    ebp
.text:0000E0F9                 mov     ebp, esp
.text:0000E0FB                 push    ecx
.text:0000E0FC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000E103                 mov     [ebp+var_4], ecx
.text:0000E106                 mov     eax, [ebp+var_4]
.text:0000E109                 xor     ecx, ecx
.text:0000E10B                 cmp     dword ptr [eax], 0
.text:0000E10E                 setz    cl
.text:0000E111                 mov     al, cl
.text:0000E113                 mov     esp, ebp
.text:0000E115                 pop     ebp
.text:0000E116                 retn
.text:0000E116 ??7?$CMyComPtr@UIHasher@@@@QBE_NXZ endp
.text:0000E116
.text:0000E116 ; ---------------------------------------------------------------------------
.text:0000E117                 align 4
.text:0000E117 _text           ends
.text:0000E117
.text:0000E118 ; ===========================================================================
.text:0000E118
.text:0000E118 ; Segment type: Pure code
.text:0000E118 ; Segment permissions: Read/Execute
.text:0000E118 _text           segment para public 'CODE' use32
.text:0000E118                 assume cs:_text
.text:0000E118                 ;org 0E118h
.text:0000E118 ; COMDAT (pick any)
.text:0000E118                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000E118
.text:0000E118 ; =============== S U B R O U T I N E =======================================
.text:0000E118
.text:0000E118 ; Attributes: bp-based frame
.text:0000E118
.text:0000E118 ; public: unsigned int __thiscall CObjectVector<struct CProperty>::Size(void)const
.text:0000E118                 public ?Size@?$CObjectVector@UCProperty@@@@QBEIXZ
.text:0000E118 ?Size@?$CObjectVector@UCProperty@@@@QBEIXZ proc near
.text:0000E118                                         ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+B2p
.text:0000E118
.text:0000E118 var_4           = dword ptr -4
.text:0000E118
.text:0000E118                 push    ebp
.text:0000E119                 mov     ebp, esp
.text:0000E11B                 push    ecx
.text:0000E11C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000E123                 mov     [ebp+var_4], ecx
.text:0000E126                 mov     ecx, [ebp+var_4]
.text:0000E129                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:0000E12E                 add     esp, 4
.text:0000E131                 cmp     ebp, esp
.text:0000E133                 call    __RTC_CheckEsp
.text:0000E138                 mov     esp, ebp
.text:0000E13A                 pop     ebp
.text:0000E13B                 retn
.text:0000E13B ?Size@?$CObjectVector@UCProperty@@@@QBEIXZ endp
.text:0000E13B
.text:0000E13B _text           ends
.text:0000E13B
.text:0000E13C ; ===========================================================================
.text:0000E13C
.text:0000E13C ; Segment type: Pure code
.text:0000E13C ; Segment permissions: Read/Execute
.text:0000E13C _text           segment para public 'CODE' use32
.text:0000E13C                 assume cs:_text
.text:0000E13C                 ;org 0E13Ch
.text:0000E13C ; COMDAT (pick any)
.text:0000E13C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000E13C
.text:0000E13C ; =============== S U B R O U T I N E =======================================
.text:0000E13C
.text:0000E13C ; Attributes: bp-based frame
.text:0000E13C
.text:0000E13C ; public: struct CProperty const & __thiscall CObjectVector<struct CProperty>::operator[](unsigned int)const
.text:0000E13C                 public ??A?$CObjectVector@UCProperty@@@@QBEABUCProperty@@I@Z
.text:0000E13C ??A?$CObjectVector@UCProperty@@@@QBEABUCProperty@@I@Z proc near
.text:0000E13C                                         ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+C7p
.text:0000E13C
.text:0000E13C var_4           = dword ptr -4
.text:0000E13C arg_0           = dword ptr  8
.text:0000E13C
.text:0000E13C                 push    ebp
.text:0000E13D                 mov     ebp, esp
.text:0000E13F                 push    ecx
.text:0000E140                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000E147                 mov     [ebp+var_4], ecx
.text:0000E14A                 mov     eax, [ebp+arg_0]
.text:0000E14D                 push    eax
.text:0000E14E                 mov     ecx, [ebp+var_4]
.text:0000E151                 call    ??A?$CRecordVector@PAX@@QBEABQAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:0000E156                 mov     eax, [eax]
.text:0000E158                 add     esp, 4
.text:0000E15B                 cmp     ebp, esp
.text:0000E15D                 call    __RTC_CheckEsp
.text:0000E162                 mov     esp, ebp
.text:0000E164                 pop     ebp
.text:0000E165                 retn    4
.text:0000E165 ??A?$CObjectVector@UCProperty@@@@QBEABUCProperty@@I@Z endp
.text:0000E165
.text:0000E165 _text           ends
.text:0000E165
.text:0000E168 ; ===========================================================================
.text:0000E168
.text:0000E168 ; Segment type: Pure code
.text:0000E168 ; Segment permissions: Read/Execute
.text:0000E168 _text           segment para public 'CODE' use32
.text:0000E168                 assume cs:_text
.text:0000E168                 ;org 0E168h
.text:0000E168 ; COMDAT (pick any)
.text:0000E168                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000E168
.text:0000E168 ; =============== S U B R O U T I N E =======================================
.text:0000E168
.text:0000E168 ; Attributes: bp-based frame
.text:0000E168
.text:0000E168 ; _DWORD __thiscall CProp::CProp(CProp *this, const struct CProp *)
.text:0000E168                 public ??0CProp@@QAE@ABU0@@Z
.text:0000E168 ??0CProp@@QAE@ABU0@@Z proc near         ; CODE XREF: CObjectVector<CProp>::CObjectVector<CProp>(CObjectVector<CProp> const &)+A6p
.text:0000E168                                         ; CObjectVector<CProp>::operator=(CObjectVector<CProp> const &)+B2p
.text:0000E168
.text:0000E168 var_4           = dword ptr -4
.text:0000E168 arg_0           = dword ptr  8
.text:0000E168
.text:0000E168                 push    ebp
.text:0000E169                 mov     ebp, esp
.text:0000E16B                 push    ecx
.text:0000E16C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000E173                 mov     [ebp+var_4], ecx
.text:0000E176                 mov     eax, [ebp+var_4]
.text:0000E179                 mov     ecx, [ebp+arg_0]
.text:0000E17C                 mov     edx, [ecx]
.text:0000E17E                 mov     [eax], edx
.text:0000E180                 mov     eax, [ebp+var_4]
.text:0000E183                 mov     ecx, [ebp+arg_0]
.text:0000E186                 mov     dl, [ecx+4]
.text:0000E189                 mov     [eax+4], dl
.text:0000E18C                 mov     eax, [ebp+arg_0]
.text:0000E18F                 add     eax, 8
.text:0000E192                 push    eax             ; struct NWindows::NCOM::CPropVariant *
.text:0000E193                 mov     ecx, [ebp+var_4]
.text:0000E196                 add     ecx, 8          ; this
.text:0000E199                 call    ??0CPropVariant@NCOM@NWindows@@QAE@ABV012@@Z ; NWindows::NCOM::CPropVariant::CPropVariant(NWindows::NCOM::CPropVariant const &)
.text:0000E19E                 mov     eax, [ebp+var_4]
.text:0000E1A1                 add     esp, 4
.text:0000E1A4                 cmp     ebp, esp
.text:0000E1A6                 call    __RTC_CheckEsp
.text:0000E1AB                 mov     esp, ebp
.text:0000E1AD                 pop     ebp
.text:0000E1AE                 retn    4
.text:0000E1AE ??0CProp@@QAE@ABU0@@Z endp
.text:0000E1AE
.text:0000E1AE ; ---------------------------------------------------------------------------
.text:0000E1B1                 align 4
.text:0000E1B1 _text           ends
.text:0000E1B1
.text:0000E1B4 ; ===========================================================================
.text:0000E1B4
.text:0000E1B4 ; Segment type: Pure code
.text:0000E1B4 ; Segment permissions: Read/Execute
.text:0000E1B4 _text           segment para public 'CODE' use32
.text:0000E1B4                 assume cs:_text
.text:0000E1B4                 ;org 0E1B4h
.text:0000E1B4 ; COMDAT (pick any)
.text:0000E1B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000E1B4
.text:0000E1B4 ; =============== S U B R O U T I N E =======================================
.text:0000E1B4
.text:0000E1B4 ; Attributes: bp-based frame
.text:0000E1B4
.text:0000E1B4 ; public: void * __thiscall CProp::`scalar deleting destructor'(unsigned int)
.text:0000E1B4                 public ??_GCProp@@QAEPAXI@Z
.text:0000E1B4 ??_GCProp@@QAEPAXI@Z proc near          ; CODE XREF: CObjectVector<CProp>::~CObjectVector<CProp>(void)+7Fp
.text:0000E1B4                                         ; CObjectVector<CProp>::Clear(void)+59p
.text:0000E1B4
.text:0000E1B4 var_4           = dword ptr -4
.text:0000E1B4 arg_0           = dword ptr  8
.text:0000E1B4
.text:0000E1B4                 push    ebp
.text:0000E1B5                 mov     ebp, esp
.text:0000E1B7                 push    ecx
.text:0000E1B8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000E1BF                 mov     [ebp+var_4], ecx
.text:0000E1C2                 mov     ecx, [ebp+var_4] ; this
.text:0000E1C5                 call    ??1CProp@@QAE@XZ ; CProp::~CProp(void)
.text:0000E1CA                 mov     eax, [ebp+arg_0]
.text:0000E1CD                 and     eax, 1
.text:0000E1D0                 jz      short loc_E1DE
.text:0000E1D2                 mov     ecx, [ebp+var_4]
.text:0000E1D5                 push    ecx             ; void *
.text:0000E1D6                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000E1DB                 add     esp, 4
.text:0000E1DE
.text:0000E1DE loc_E1DE:                               ; CODE XREF: CProp::`scalar deleting destructor'(uint)+1Cj
.text:0000E1DE                 mov     eax, [ebp+var_4]
.text:0000E1E1                 add     esp, 4
.text:0000E1E4                 cmp     ebp, esp
.text:0000E1E6                 call    __RTC_CheckEsp
.text:0000E1EB                 mov     esp, ebp
.text:0000E1ED                 pop     ebp
.text:0000E1EE                 retn    4
.text:0000E1EE ??_GCProp@@QAEPAXI@Z endp
.text:0000E1EE
.text:0000E1EE ; ---------------------------------------------------------------------------
.text:0000E1F1                 align 4
.text:0000E1F1 _text           ends
.text:0000E1F1
.text:0000E1F4 ; ===========================================================================
.text:0000E1F4
.text:0000E1F4 ; Segment type: Pure code
.text:0000E1F4 ; Segment permissions: Read/Execute
.text:0000E1F4 _text           segment para public 'CODE' use32
.text:0000E1F4                 assume cs:_text
.text:0000E1F4                 ;org 0E1F4h
.text:0000E1F4 ; COMDAT (pick any)
.text:0000E1F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000E1F4
.text:0000E1F4 ; =============== S U B R O U T I N E =======================================
.text:0000E1F4
.text:0000E1F4 ; Attributes: bp-based frame
.text:0000E1F4
.text:0000E1F4 ; _DWORD __thiscall CProp::~CProp(CProp *__hidden this)
.text:0000E1F4                 public ??1CProp@@QAE@XZ
.text:0000E1F4 ??1CProp@@QAE@XZ proc near              ; CODE XREF: CProp::`scalar deleting destructor'(uint)+11p
.text:0000E1F4
.text:0000E1F4 var_4           = dword ptr -4
.text:0000E1F4
.text:0000E1F4                 push    ebp
.text:0000E1F5                 mov     ebp, esp
.text:0000E1F7                 push    ecx
.text:0000E1F8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000E1FF                 mov     [ebp+var_4], ecx
.text:0000E202                 mov     ecx, [ebp+var_4]
.text:0000E205                 add     ecx, 8          ; this
.text:0000E208                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:0000E20D                 add     esp, 4
.text:0000E210                 cmp     ebp, esp
.text:0000E212                 call    __RTC_CheckEsp
.text:0000E217                 mov     esp, ebp
.text:0000E219                 pop     ebp
.text:0000E21A                 retn
.text:0000E21A ??1CProp@@QAE@XZ endp
.text:0000E21A
.text:0000E21A ; ---------------------------------------------------------------------------
.text:0000E21B                 align 4
.text:0000E21B _text           ends
.text:0000E21B
.text:0000E21C ; ===========================================================================
.text:0000E21C
.text:0000E21C ; Segment type: Pure code
.text:0000E21C ; Segment permissions: Read/Execute
.text:0000E21C _text           segment para public 'CODE' use32
.text:0000E21C                 assume cs:_text
.text:0000E21C                 ;org 0E21Ch
.text:0000E21C ; COMDAT (pick any)
.text:0000E21C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000E21C
.text:0000E21C ; =============== S U B R O U T I N E =======================================
.text:0000E21C
.text:0000E21C ; Attributes: bp-based frame
.text:0000E21C
.text:0000E21C ; public: __thiscall CRecordVector<void *>::CRecordVector<void *>(void)
.text:0000E21C                 public ??0?$CRecordVector@PAX@@QAE@XZ
.text:0000E21C ??0?$CRecordVector@PAX@@QAE@XZ proc near
.text:0000E21C                                         ; CODE XREF: CObjectVector<CProp>::CObjectVector<CProp>(void)+11p
.text:0000E21C                                         ; CObjectVector<CProp>::CObjectVector<CProp>(CObjectVector<CProp> const &)+42p
.text:0000E21C
.text:0000E21C var_4           = dword ptr -4
.text:0000E21C
.text:0000E21C                 push    ebp
.text:0000E21D                 mov     ebp, esp
.text:0000E21F                 push    ecx
.text:0000E220                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000E227                 mov     [ebp+var_4], ecx
.text:0000E22A                 mov     eax, [ebp+var_4]
.text:0000E22D                 mov     dword ptr [eax], 0
.text:0000E233                 mov     ecx, [ebp+var_4]
.text:0000E236                 mov     dword ptr [ecx+4], 0
.text:0000E23D                 mov     edx, [ebp+var_4]
.text:0000E240                 mov     dword ptr [edx+8], 0
.text:0000E247                 mov     eax, [ebp+var_4]
.text:0000E24A                 mov     esp, ebp
.text:0000E24C                 pop     ebp
.text:0000E24D                 retn
.text:0000E24D ??0?$CRecordVector@PAX@@QAE@XZ endp
.text:0000E24D
.text:0000E24D ; ---------------------------------------------------------------------------
.text:0000E24E                 align 10h
.text:0000E24E _text           ends
.text:0000E24E
.text:0000E250 ; ===========================================================================
.text:0000E250
.text:0000E250 ; Segment type: Pure code
.text:0000E250 ; Segment permissions: Read/Execute
.text:0000E250 _text           segment para public 'CODE' use32
.text:0000E250                 assume cs:_text
.text:0000E250                 ;org 0E250h
.text:0000E250 ; COMDAT (pick any)
.text:0000E250                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000E250
.text:0000E250 ; =============== S U B R O U T I N E =======================================
.text:0000E250
.text:0000E250 ; Attributes: bp-based frame
.text:0000E250
.text:0000E250 ; public: unsigned int __thiscall CRecordVector<void *>::Size(void)const
.text:0000E250                 public ?Size@?$CRecordVector@PAX@@QBEIXZ
.text:0000E250 ?Size@?$CRecordVector@PAX@@QBEIXZ proc near
.text:0000E250                                         ; CODE XREF: CObjectVector<CProp>::Size(void)+11p
.text:0000E250                                         ; CObjectVector<CProp>::~CObjectVector<CProp>(void)+46p ...
.text:0000E250
.text:0000E250 var_4           = dword ptr -4
.text:0000E250
.text:0000E250                 push    ebp
.text:0000E251                 mov     ebp, esp
.text:0000E253                 push    ecx
.text:0000E254                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000E25B                 mov     [ebp+var_4], ecx
.text:0000E25E                 mov     eax, [ebp+var_4]
.text:0000E261                 mov     eax, [eax+4]
.text:0000E264                 mov     esp, ebp
.text:0000E266                 pop     ebp
.text:0000E267                 retn
.text:0000E267 ?Size@?$CRecordVector@PAX@@QBEIXZ endp
.text:0000E267
.text:0000E267 _text           ends
.text:0000E267
.text:0000E268 ; ===========================================================================
.text:0000E268
.text:0000E268 ; Segment type: Pure code
.text:0000E268 ; Segment permissions: Read/Execute
.text:0000E268 _text           segment para public 'CODE' use32
.text:0000E268                 assume cs:_text
.text:0000E268                 ;org 0E268h
.text:0000E268 ; COMDAT (pick any)
.text:0000E268                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000E268
.text:0000E268 ; =============== S U B R O U T I N E =======================================
.text:0000E268
.text:0000E268 ; Attributes: bp-based frame
.text:0000E268
.text:0000E268 ; public: void __thiscall CRecordVector<void *>::ConstructReserve(unsigned int)
.text:0000E268                 public ?ConstructReserve@?$CRecordVector@PAX@@QAEXI@Z
.text:0000E268 ?ConstructReserve@?$CRecordVector@PAX@@QAEXI@Z proc near
.text:0000E268                                         ; CODE XREF: CObjectVector<CProp>::CObjectVector<CProp>(CObjectVector<CProp> const &)+60p
.text:0000E268
.text:0000E268 var_8           = dword ptr -8
.text:0000E268 var_4           = dword ptr -4
.text:0000E268 arg_0           = dword ptr  8
.text:0000E268
.text:0000E268                 push    ebp
.text:0000E269                 mov     ebp, esp
.text:0000E26B                 sub     esp, 8
.text:0000E26E                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000E275                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000E27C                 mov     [ebp+var_4], ecx
.text:0000E27F                 cmp     [ebp+arg_0], 0
.text:0000E283                 jz      short loc_E2B5
.text:0000E285                 xor     ecx, ecx
.text:0000E287                 mov     eax, [ebp+arg_0]
.text:0000E28A                 mov     edx, 4
.text:0000E28F                 mul     edx
.text:0000E291                 seto    cl
.text:0000E294                 neg     ecx
.text:0000E296                 or      ecx, eax
.text:0000E298                 push    ecx             ; unsigned int
.text:0000E299                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0000E29E                 add     esp, 4
.text:0000E2A1                 mov     [ebp+var_8], eax
.text:0000E2A4                 mov     eax, [ebp+var_4]
.text:0000E2A7                 mov     ecx, [ebp+var_8]
.text:0000E2AA                 mov     [eax], ecx
.text:0000E2AC                 mov     edx, [ebp+var_4]
.text:0000E2AF                 mov     eax, [ebp+arg_0]
.text:0000E2B2                 mov     [edx+8], eax
.text:0000E2B5
.text:0000E2B5 loc_E2B5:                               ; CODE XREF: CRecordVector<void *>::ConstructReserve(uint)+1Bj
.text:0000E2B5                 add     esp, 8
.text:0000E2B8                 cmp     ebp, esp
.text:0000E2BA                 call    __RTC_CheckEsp
.text:0000E2BF                 mov     esp, ebp
.text:0000E2C1                 pop     ebp
.text:0000E2C2                 retn    4
.text:0000E2C2 ?ConstructReserve@?$CRecordVector@PAX@@QAEXI@Z endp
.text:0000E2C2
.text:0000E2C2 ; ---------------------------------------------------------------------------
.text:0000E2C5                 align 4
.text:0000E2C5 _text           ends
.text:0000E2C5
.text:0000E2C8 ; ===========================================================================
.text:0000E2C8
.text:0000E2C8 ; Segment type: Pure code
.text:0000E2C8 ; Segment permissions: Read/Execute
.text:0000E2C8 _text           segment para public 'CODE' use32
.text:0000E2C8                 assume cs:_text
.text:0000E2C8                 ;org 0E2C8h
.text:0000E2C8 ; COMDAT (pick any)
.text:0000E2C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000E2C8
.text:0000E2C8 ; =============== S U B R O U T I N E =======================================
.text:0000E2C8
.text:0000E2C8 ; Attributes: bp-based frame
.text:0000E2C8
.text:0000E2C8 ; public: void __thiscall CRecordVector<void *>::Reserve(unsigned int)
.text:0000E2C8                 public ?Reserve@?$CRecordVector@PAX@@QAEXI@Z
.text:0000E2C8 ?Reserve@?$CRecordVector@PAX@@QAEXI@Z proc near
.text:0000E2C8                                         ; CODE XREF: CObjectVector<CProp>::operator=(CObjectVector<CProp> const &)+69p
.text:0000E2C8
.text:0000E2C8 var_10          = dword ptr -10h
.text:0000E2C8 var_C           = dword ptr -0Ch
.text:0000E2C8 Dst             = dword ptr -8
.text:0000E2C8 var_4           = dword ptr -4
.text:0000E2C8 arg_0           = dword ptr  8
.text:0000E2C8
.text:0000E2C8                 push    ebp
.text:0000E2C9                 mov     ebp, esp
.text:0000E2CB                 sub     esp, 10h
.text:0000E2CE                 mov     eax, 0CCCCCCCCh
.text:0000E2D3                 mov     [ebp+var_10], eax
.text:0000E2D6                 mov     [ebp+var_C], eax
.text:0000E2D9                 mov     [ebp+Dst], eax
.text:0000E2DC                 mov     [ebp+var_4], eax
.text:0000E2DF                 mov     [ebp+var_4], ecx
.text:0000E2E2                 mov     eax, [ebp+var_4]
.text:0000E2E5                 mov     ecx, [ebp+arg_0]
.text:0000E2E8                 cmp     ecx, [eax+8]
.text:0000E2EB                 jbe     short loc_E35C
.text:0000E2ED                 xor     ecx, ecx
.text:0000E2EF                 mov     eax, [ebp+arg_0]
.text:0000E2F2                 mov     edx, 4
.text:0000E2F7                 mul     edx
.text:0000E2F9                 seto    cl
.text:0000E2FC                 neg     ecx
.text:0000E2FE                 or      ecx, eax
.text:0000E300                 push    ecx             ; unsigned int
.text:0000E301                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0000E306                 add     esp, 4
.text:0000E309                 mov     [ebp+var_C], eax
.text:0000E30C                 mov     eax, [ebp+var_C]
.text:0000E30F                 mov     [ebp+Dst], eax
.text:0000E312                 mov     ecx, [ebp+var_4]
.text:0000E315                 cmp     dword ptr [ecx+4], 0
.text:0000E319                 jz      short loc_E337
.text:0000E31B                 mov     edx, [ebp+var_4]
.text:0000E31E                 mov     eax, [edx+4]
.text:0000E321                 shl     eax, 2
.text:0000E324                 push    eax             ; Size
.text:0000E325                 mov     ecx, [ebp+var_4]
.text:0000E328                 mov     edx, [ecx]
.text:0000E32A                 push    edx             ; Src
.text:0000E32B                 mov     eax, [ebp+Dst]
.text:0000E32E                 push    eax             ; Dst
.text:0000E32F                 call    _memcpy
.text:0000E334                 add     esp, 0Ch
.text:0000E337
.text:0000E337 loc_E337:                               ; CODE XREF: CRecordVector<void *>::Reserve(uint)+51j
.text:0000E337                 mov     ecx, [ebp+var_4]
.text:0000E33A                 mov     edx, [ecx]
.text:0000E33C                 mov     [ebp+var_10], edx
.text:0000E33F                 mov     eax, [ebp+var_10]
.text:0000E342                 push    eax             ; void *
.text:0000E343                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000E348                 add     esp, 4
.text:0000E34B                 mov     ecx, [ebp+var_4]
.text:0000E34E                 mov     edx, [ebp+Dst]
.text:0000E351                 mov     [ecx], edx
.text:0000E353                 mov     eax, [ebp+var_4]
.text:0000E356                 mov     ecx, [ebp+arg_0]
.text:0000E359                 mov     [eax+8], ecx
.text:0000E35C
.text:0000E35C loc_E35C:                               ; CODE XREF: CRecordVector<void *>::Reserve(uint)+23j
.text:0000E35C                 add     esp, 10h
.text:0000E35F                 cmp     ebp, esp
.text:0000E361                 call    __RTC_CheckEsp
.text:0000E366                 mov     esp, ebp
.text:0000E368                 pop     ebp
.text:0000E369                 retn    4
.text:0000E369 ?Reserve@?$CRecordVector@PAX@@QAEXI@Z endp
.text:0000E369
.text:0000E369 _text           ends
.text:0000E369
.text:0000E36C ; ===========================================================================
.text:0000E36C
.text:0000E36C ; Segment type: Pure code
.text:0000E36C ; Segment permissions: Read/Execute
.text:0000E36C _text           segment para public 'CODE' use32
.text:0000E36C                 assume cs:_text
.text:0000E36C                 ;org 0E36Ch
.text:0000E36C ; COMDAT (pick any)
.text:0000E36C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000E36C
.text:0000E36C ; =============== S U B R O U T I N E =======================================
.text:0000E36C
.text:0000E36C ; Attributes: bp-based frame
.text:0000E36C
.text:0000E36C ; public: __thiscall CRecordVector<void *>::~CRecordVector<void *>(void)
.text:0000E36C                 public ??1?$CRecordVector@PAX@@QAE@XZ
.text:0000E36C ??1?$CRecordVector@PAX@@QAE@XZ proc near
.text:0000E36C                                         ; CODE XREF: __unwindfunclet$??0?$CObjectVector@UCProp@@@@QAE@ABV0@@Z$0+3j
.text:0000E36C                                         ; CObjectVector<CProp>::~CObjectVector<CProp>(void)+9Cp ...
.text:0000E36C
.text:0000E36C var_8           = dword ptr -8
.text:0000E36C var_4           = dword ptr -4
.text:0000E36C
.text:0000E36C                 push    ebp
.text:0000E36D                 mov     ebp, esp
.text:0000E36F                 sub     esp, 8
.text:0000E372                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000E379                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000E380                 mov     [ebp+var_4], ecx
.text:0000E383                 mov     eax, [ebp+var_4]
.text:0000E386                 mov     ecx, [eax]
.text:0000E388                 mov     [ebp+var_8], ecx
.text:0000E38B                 mov     edx, [ebp+var_8]
.text:0000E38E                 push    edx             ; void *
.text:0000E38F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000E394                 add     esp, 4
.text:0000E397                 add     esp, 8
.text:0000E39A                 cmp     ebp, esp
.text:0000E39C                 call    __RTC_CheckEsp
.text:0000E3A1                 mov     esp, ebp
.text:0000E3A3                 pop     ebp
.text:0000E3A4                 retn
.text:0000E3A4 ??1?$CRecordVector@PAX@@QAE@XZ endp
.text:0000E3A4
.text:0000E3A4 ; ---------------------------------------------------------------------------
.text:0000E3A5                 align 4
.text:0000E3A5 _text           ends
.text:0000E3A5
.text:0000E3A8 ; ===========================================================================
.text:0000E3A8
.text:0000E3A8 ; Segment type: Pure code
.text:0000E3A8 ; Segment permissions: Read/Execute
.text:0000E3A8 _text           segment para public 'CODE' use32
.text:0000E3A8                 assume cs:_text
.text:0000E3A8                 ;org 0E3A8h
.text:0000E3A8 ; COMDAT (pick any)
.text:0000E3A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000E3A8
.text:0000E3A8 ; =============== S U B R O U T I N E =======================================
.text:0000E3A8
.text:0000E3A8 ; Attributes: bp-based frame
.text:0000E3A8
.text:0000E3A8 ; public: void __thiscall CRecordVector<void *>::Clear(void)
.text:0000E3A8                 public ?Clear@?$CRecordVector@PAX@@QAEXXZ
.text:0000E3A8 ?Clear@?$CRecordVector@PAX@@QAEXXZ proc near
.text:0000E3A8                                         ; CODE XREF: CObjectVector<CProp>::Clear(void)+6Fp
.text:0000E3A8
.text:0000E3A8 var_4           = dword ptr -4
.text:0000E3A8
.text:0000E3A8                 push    ebp
.text:0000E3A9                 mov     ebp, esp
.text:0000E3AB                 push    ecx
.text:0000E3AC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000E3B3                 mov     [ebp+var_4], ecx
.text:0000E3B6                 mov     eax, [ebp+var_4]
.text:0000E3B9                 mov     dword ptr [eax+4], 0
.text:0000E3C0                 mov     esp, ebp
.text:0000E3C2                 pop     ebp
.text:0000E3C3                 retn
.text:0000E3C3 ?Clear@?$CRecordVector@PAX@@QAEXXZ endp
.text:0000E3C3
.text:0000E3C3 _text           ends
.text:0000E3C3
.text:0000E3C4 ; ===========================================================================
.text:0000E3C4
.text:0000E3C4 ; Segment type: Pure code
.text:0000E3C4 ; Segment permissions: Read/Execute
.text:0000E3C4 _text           segment para public 'CODE' use32
.text:0000E3C4                 assume cs:_text
.text:0000E3C4                 ;org 0E3C4h
.text:0000E3C4 ; COMDAT (pick any)
.text:0000E3C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000E3C4
.text:0000E3C4 ; =============== S U B R O U T I N E =======================================
.text:0000E3C4
.text:0000E3C4 ; Attributes: bp-based frame
.text:0000E3C4
.text:0000E3C4 ; public: void __thiscall CRecordVector<void *>::AddInReserved(void * const)
.text:0000E3C4                 public ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z
.text:0000E3C4 ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z proc near
.text:0000E3C4                                         ; CODE XREF: CObjectVector<CProp>::CObjectVector<CProp>(CObjectVector<CProp> const &)+C8p
.text:0000E3C4                                         ; CObjectVector<CProp>::operator=(CObjectVector<CProp> const &)+D7p
.text:0000E3C4
.text:0000E3C4 var_4           = dword ptr -4
.text:0000E3C4 arg_0           = dword ptr  8
.text:0000E3C4
.text:0000E3C4                 push    ebp
.text:0000E3C5                 mov     ebp, esp
.text:0000E3C7                 push    ecx
.text:0000E3C8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000E3CF                 mov     [ebp+var_4], ecx
.text:0000E3D2                 mov     eax, [ebp+var_4]
.text:0000E3D5                 mov     ecx, [eax+4]
.text:0000E3D8                 mov     edx, [ebp+var_4]
.text:0000E3DB                 mov     eax, [edx]
.text:0000E3DD                 mov     edx, [ebp+arg_0]
.text:0000E3E0                 mov     [eax+ecx*4], edx
.text:0000E3E3                 mov     eax, [ebp+var_4]
.text:0000E3E6                 mov     ecx, [eax+4]
.text:0000E3E9                 add     ecx, 1
.text:0000E3EC                 mov     edx, [ebp+var_4]
.text:0000E3EF                 mov     [edx+4], ecx
.text:0000E3F2                 mov     esp, ebp
.text:0000E3F4                 pop     ebp
.text:0000E3F5                 retn    4
.text:0000E3F5 ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z endp
.text:0000E3F5
.text:0000E3F5 _text           ends
.text:0000E3F5
.text:0000E3F8 ; ===========================================================================
.text:0000E3F8
.text:0000E3F8 ; Segment type: Pure code
.text:0000E3F8 ; Segment permissions: Read/Execute
.text:0000E3F8 _text           segment para public 'CODE' use32
.text:0000E3F8                 assume cs:_text
.text:0000E3F8                 ;org 0E3F8h
.text:0000E3F8 ; COMDAT (pick any)
.text:0000E3F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000E3F8
.text:0000E3F8 ; =============== S U B R O U T I N E =======================================
.text:0000E3F8
.text:0000E3F8 ; Attributes: bp-based frame
.text:0000E3F8
.text:0000E3F8 ; public: void * const & __thiscall CRecordVector<void *>::operator[](unsigned int)const
.text:0000E3F8                 public ??A?$CRecordVector@PAX@@QBEABQAXI@Z
.text:0000E3F8 ??A?$CRecordVector@PAX@@QBEABQAXI@Z proc near
.text:0000E3F8                                         ; CODE XREF: CObjectVector<CProp>::operator[](uint)+15p
.text:0000E3F8                                         ; CObjectVector<CProperty>::operator[](uint)+15p
.text:0000E3F8
.text:0000E3F8 var_4           = dword ptr -4
.text:0000E3F8 arg_0           = dword ptr  8
.text:0000E3F8
.text:0000E3F8                 push    ebp
.text:0000E3F9                 mov     ebp, esp
.text:0000E3FB                 push    ecx
.text:0000E3FC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000E403                 mov     [ebp+var_4], ecx
.text:0000E406                 mov     eax, [ebp+var_4]
.text:0000E409                 mov     ecx, [eax]
.text:0000E40B                 mov     edx, [ebp+arg_0]
.text:0000E40E                 lea     eax, [ecx+edx*4]
.text:0000E411                 mov     esp, ebp
.text:0000E413                 pop     ebp
.text:0000E414                 retn    4
.text:0000E414 ??A?$CRecordVector@PAX@@QBEABQAXI@Z endp
.text:0000E414
.text:0000E414 ; ---------------------------------------------------------------------------
.text:0000E417                 align 4
.text:0000E417 _text           ends
.text:0000E417
.text:0000E418 ; ===========================================================================
.text:0000E418
.text:0000E418 ; Segment type: Pure code
.text:0000E418 ; Segment permissions: Read/Execute
.text:0000E418 _text           segment para public 'CODE' use32
.text:0000E418                 assume cs:_text
.text:0000E418                 ;org 0E418h
.text:0000E418 ; COMDAT (pick any)
.text:0000E418                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000E418
.text:0000E418 ; =============== S U B R O U T I N E =======================================
.text:0000E418
.text:0000E418 ; Attributes: bp-based frame
.text:0000E418
.text:0000E418 ; public: void * & __thiscall CRecordVector<void *>::operator[](unsigned int)
.text:0000E418                 public ??A?$CRecordVector@PAX@@QAEAAPAXI@Z
.text:0000E418 ??A?$CRecordVector@PAX@@QAEAAPAXI@Z proc near
.text:0000E418                                         ; CODE XREF: CObjectVector<CProp>::~CObjectVector<CProp>(void)+64p
.text:0000E418                                         ; CObjectVector<CProp>::Clear(void)+3Ep
.text:0000E418
.text:0000E418 var_4           = dword ptr -4
.text:0000E418 arg_0           = dword ptr  8
.text:0000E418
.text:0000E418                 push    ebp
.text:0000E419                 mov     ebp, esp
.text:0000E41B                 push    ecx
.text:0000E41C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000E423                 mov     [ebp+var_4], ecx
.text:0000E426                 mov     eax, [ebp+var_4]
.text:0000E429                 mov     ecx, [eax]
.text:0000E42B                 mov     edx, [ebp+arg_0]
.text:0000E42E                 lea     eax, [ecx+edx*4]
.text:0000E431                 mov     esp, ebp
.text:0000E433                 pop     ebp
.text:0000E434                 retn    4
.text:0000E434 ??A?$CRecordVector@PAX@@QAEAAPAXI@Z endp
.text:0000E434
.text:0000E434 ; ---------------------------------------------------------------------------
.text:0000E437                 align 4
.text:0000E437 _text           ends
.text:0000E437
.text:0000E438 ; ===========================================================================
.text:0000E438
.text:0000E438 ; Segment type: Pure code
.text:0000E438 ; Segment permissions: Read/Execute
.text:0000E438 _text           segment para public 'CODE' use32
.text:0000E438                 assume cs:_text
.text:0000E438                 ;org 0E438h
.text:0000E438 ; COMDAT (pick any)
.text:0000E438                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000E438
.text:0000E438 ; =============== S U B R O U T I N E =======================================
.text:0000E438
.text:0000E438 ; Attributes: bp-based frame
.text:0000E438
.text:0000E438 ; public: struct ICompressCoder * __thiscall CMyComPtr<struct ICompressCoder>::operator=(struct ICompressCoder *)
.text:0000E438                 public ??4?$CMyComPtr@UICompressCoder@@@@QAEPAUICompressCoder@@PAU1@@Z
.text:0000E438 ??4?$CMyComPtr@UICompressCoder@@@@QAEPAUICompressCoder@@PAU1@@Z proc near
.text:0000E438                                         ; CODE XREF: CMyComPtr<ICompressCoder>::operator=(CMyComPtr<ICompressCoder> const &)+17p
.text:0000E438
.text:0000E438 var_4           = dword ptr -4
.text:0000E438 arg_0           = dword ptr  8
.text:0000E438
.text:0000E438                 push    ebp
.text:0000E439                 mov     ebp, esp
.text:0000E43B                 push    ecx
.text:0000E43C                 push    esi
.text:0000E43D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000E444                 mov     [ebp+var_4], ecx
.text:0000E447                 cmp     [ebp+arg_0], 0
.text:0000E44B                 jz      short loc_E464
.text:0000E44D                 mov     eax, [ebp+arg_0]
.text:0000E450                 mov     ecx, [eax]
.text:0000E452                 mov     esi, esp
.text:0000E454                 mov     edx, [ebp+arg_0]
.text:0000E457                 push    edx
.text:0000E458                 mov     eax, [ecx+4]
.text:0000E45B                 call    eax
.text:0000E45D                 cmp     esi, esp
.text:0000E45F                 call    __RTC_CheckEsp
.text:0000E464
.text:0000E464 loc_E464:                               ; CODE XREF: CMyComPtr<ICompressCoder>::operator=(ICompressCoder *)+13j
.text:0000E464                 mov     ecx, [ebp+var_4]
.text:0000E467                 cmp     dword ptr [ecx], 0
.text:0000E46A                 jz      short loc_E487
.text:0000E46C                 mov     edx, [ebp+var_4]
.text:0000E46F                 mov     eax, [edx]
.text:0000E471                 mov     ecx, [ebp+var_4]
.text:0000E474                 mov     edx, [ecx]
.text:0000E476                 mov     eax, [eax]
.text:0000E478                 mov     esi, esp
.text:0000E47A                 push    edx
.text:0000E47B                 mov     ecx, [eax+8]
.text:0000E47E                 call    ecx
.text:0000E480                 cmp     esi, esp
.text:0000E482                 call    __RTC_CheckEsp
.text:0000E487
.text:0000E487 loc_E487:                               ; CODE XREF: CMyComPtr<ICompressCoder>::operator=(ICompressCoder *)+32j
.text:0000E487                 mov     edx, [ebp+var_4]
.text:0000E48A                 mov     eax, [ebp+arg_0]
.text:0000E48D                 mov     [edx], eax
.text:0000E48F                 mov     eax, [ebp+arg_0]
.text:0000E492                 pop     esi
.text:0000E493                 add     esp, 4
.text:0000E496                 cmp     ebp, esp
.text:0000E498                 call    __RTC_CheckEsp
.text:0000E49D                 mov     esp, ebp
.text:0000E49F                 pop     ebp
.text:0000E4A0                 retn    4
.text:0000E4A0 ??4?$CMyComPtr@UICompressCoder@@@@QAEPAUICompressCoder@@PAU1@@Z endp
.text:0000E4A0
.text:0000E4A0 ; ---------------------------------------------------------------------------
.text:0000E4A3                 align 4
.text:0000E4A3 _text           ends
.text:0000E4A3
.text:0000E4A4 ; ===========================================================================
.text:0000E4A4
.text:0000E4A4 ; Segment type: Pure code
.text:0000E4A4 ; Segment permissions: Read/Execute
.text:0000E4A4 _text           segment para public 'CODE' use32
.text:0000E4A4                 assume cs:_text
.text:0000E4A4                 ;org 0E4A4h
.text:0000E4A4 ; COMDAT (pick any)
.text:0000E4A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000E4A4
.text:0000E4A4 ; =============== S U B R O U T I N E =======================================
.text:0000E4A4
.text:0000E4A4 ; Attributes: bp-based frame
.text:0000E4A4
.text:0000E4A4 ; public: long __thiscall CMyComPtr<struct IUnknown>::QueryInterface<struct ICompressSetCoderProperties>(struct _GUID const &, struct ICompressSetCoderProperties * *)const
.text:0000E4A4                 public ??$QueryInterface@UICompressSetCoderProperties@@@?$CMyComPtr@UIUnknown@@@@QBEJABU_GUID@@PAPAUICompressSetCoderProperties@@@Z
.text:0000E4A4 ??$QueryInterface@UICompressSetCoderProperties@@@?$CMyComPtr@UIUnknown@@@@QBEJABU_GUID@@PAPAUICompressSetCoderProperties@@@Z proc near
.text:0000E4A4                                         ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+2EEp
.text:0000E4A4                                         ; CEncoderInfo::Decode(uint)+332p
.text:0000E4A4
.text:0000E4A4 var_4           = dword ptr -4
.text:0000E4A4 arg_0           = dword ptr  8
.text:0000E4A4 arg_4           = dword ptr  0Ch
.text:0000E4A4
.text:0000E4A4                 push    ebp
.text:0000E4A5                 mov     ebp, esp
.text:0000E4A7                 push    ecx
.text:0000E4A8                 push    esi
.text:0000E4A9                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000E4B0                 mov     [ebp+var_4], ecx
.text:0000E4B3                 mov     esi, esp
.text:0000E4B5                 mov     eax, [ebp+arg_4]
.text:0000E4B8                 push    eax
.text:0000E4B9                 mov     ecx, [ebp+arg_0]
.text:0000E4BC                 push    ecx
.text:0000E4BD                 mov     edx, [ebp+var_4]
.text:0000E4C0                 mov     eax, [edx]
.text:0000E4C2                 mov     ecx, [ebp+var_4]
.text:0000E4C5                 mov     edx, [ecx]
.text:0000E4C7                 mov     eax, [eax]
.text:0000E4C9                 push    edx
.text:0000E4CA                 mov     ecx, [eax]
.text:0000E4CC                 call    ecx
.text:0000E4CE                 cmp     esi, esp
.text:0000E4D0                 call    __RTC_CheckEsp
.text:0000E4D5                 pop     esi
.text:0000E4D6                 add     esp, 4
.text:0000E4D9                 cmp     ebp, esp
.text:0000E4DB                 call    __RTC_CheckEsp
.text:0000E4E0                 mov     esp, ebp
.text:0000E4E2                 pop     ebp
.text:0000E4E3                 retn    8
.text:0000E4E3 ??$QueryInterface@UICompressSetCoderProperties@@@?$CMyComPtr@UIUnknown@@@@QBEJABU_GUID@@PAPAUICompressSetCoderProperties@@@Z endp
.text:0000E4E3
.text:0000E4E3 ; ---------------------------------------------------------------------------
.text:0000E4E6                 align 4
.text:0000E4E6 _text           ends
.text:0000E4E6
.text:0000E4E8 ; ===========================================================================
.text:0000E4E8
.text:0000E4E8 ; Segment type: Pure code
.text:0000E4E8 ; Segment permissions: Read/Execute
.text:0000E4E8 _text           segment para public 'CODE' use32
.text:0000E4E8                 assume cs:_text
.text:0000E4E8                 ;org 0E4E8h
.text:0000E4E8 ; COMDAT (pick any)
.text:0000E4E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000E4E8
.text:0000E4E8 ; =============== S U B R O U T I N E =======================================
.text:0000E4E8
.text:0000E4E8 ; Attributes: bp-based frame
.text:0000E4E8
.text:0000E4E8 ; public: long __thiscall CMyComPtr<struct IUnknown>::QueryInterface<struct ICompressWriteCoderProperties>(struct _GUID const &, struct ICompressWriteCoderProperties * *)const
.text:0000E4E8                 public ??$QueryInterface@UICompressWriteCoderProperties@@@?$CMyComPtr@UIUnknown@@@@QBEJABU_GUID@@PAPAUICompressWriteCoderProperties@@@Z
.text:0000E4E8 ??$QueryInterface@UICompressWriteCoderProperties@@@?$CMyComPtr@UIUnknown@@@@QBEJABU_GUID@@PAPAUICompressWriteCoderProperties@@@Z proc near
.text:0000E4E8                                         ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+3B5p
.text:0000E4E8
.text:0000E4E8 var_4           = dword ptr -4
.text:0000E4E8 arg_0           = dword ptr  8
.text:0000E4E8 arg_4           = dword ptr  0Ch
.text:0000E4E8
.text:0000E4E8                 push    ebp
.text:0000E4E9                 mov     ebp, esp
.text:0000E4EB                 push    ecx
.text:0000E4EC                 push    esi
.text:0000E4ED                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000E4F4                 mov     [ebp+var_4], ecx
.text:0000E4F7                 mov     esi, esp
.text:0000E4F9                 mov     eax, [ebp+arg_4]
.text:0000E4FC                 push    eax
.text:0000E4FD                 mov     ecx, [ebp+arg_0]
.text:0000E500                 push    ecx
.text:0000E501                 mov     edx, [ebp+var_4]
.text:0000E504                 mov     eax, [edx]
.text:0000E506                 mov     ecx, [ebp+var_4]
.text:0000E509                 mov     edx, [ecx]
.text:0000E50B                 mov     eax, [eax]
.text:0000E50D                 push    edx
.text:0000E50E                 mov     ecx, [eax]
.text:0000E510                 call    ecx
.text:0000E512                 cmp     esi, esp
.text:0000E514                 call    __RTC_CheckEsp
.text:0000E519                 pop     esi
.text:0000E51A                 add     esp, 4
.text:0000E51D                 cmp     ebp, esp
.text:0000E51F                 call    __RTC_CheckEsp
.text:0000E524                 mov     esp, ebp
.text:0000E526                 pop     ebp
.text:0000E527                 retn    8
.text:0000E527 ??$QueryInterface@UICompressWriteCoderProperties@@@?$CMyComPtr@UIUnknown@@@@QBEJABU_GUID@@PAPAUICompressWriteCoderProperties@@@Z endp
.text:0000E527
.text:0000E527 ; ---------------------------------------------------------------------------
.text:0000E52A                 align 4
.text:0000E52A _text           ends
.text:0000E52A
.text:0000E52C ; ===========================================================================
.text:0000E52C
.text:0000E52C ; Segment type: Pure code
.text:0000E52C ; Segment permissions: Read/Execute
.text:0000E52C _text           segment para public 'CODE' use32
.text:0000E52C                 assume cs:_text
.text:0000E52C                 ;org 0E52Ch
.text:0000E52C ; COMDAT (pick any)
.text:0000E52C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000E52C
.text:0000E52C ; =============== S U B R O U T I N E =======================================
.text:0000E52C
.text:0000E52C ; Attributes: bp-based frame
.text:0000E52C
.text:0000E52C ; public: long __thiscall CMyComPtr<struct IUnknown>::QueryInterface<struct ICryptoSetPassword>(struct _GUID const &, struct ICryptoSetPassword * *)const
.text:0000E52C                 public ??$QueryInterface@UICryptoSetPassword@@@?$CMyComPtr@UIUnknown@@@@QBEJABU_GUID@@PAPAUICryptoSetPassword@@@Z
.text:0000E52C ??$QueryInterface@UICryptoSetPassword@@@?$CMyComPtr@UIUnknown@@@@QBEJABU_GUID@@PAPAUICryptoSetPassword@@@Z proc near
.text:0000E52C                                         ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+461p
.text:0000E52C                                         ; CEncoderInfo::Decode(uint)+4E3p
.text:0000E52C
.text:0000E52C var_4           = dword ptr -4
.text:0000E52C arg_0           = dword ptr  8
.text:0000E52C arg_4           = dword ptr  0Ch
.text:0000E52C
.text:0000E52C                 push    ebp
.text:0000E52D                 mov     ebp, esp
.text:0000E52F                 push    ecx
.text:0000E530                 push    esi
.text:0000E531                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000E538                 mov     [ebp+var_4], ecx
.text:0000E53B                 mov     esi, esp
.text:0000E53D                 mov     eax, [ebp+arg_4]
.text:0000E540                 push    eax
.text:0000E541                 mov     ecx, [ebp+arg_0]
.text:0000E544                 push    ecx
.text:0000E545                 mov     edx, [ebp+var_4]
.text:0000E548                 mov     eax, [edx]
.text:0000E54A                 mov     ecx, [ebp+var_4]
.text:0000E54D                 mov     edx, [ecx]
.text:0000E54F                 mov     eax, [eax]
.text:0000E551                 push    edx
.text:0000E552                 mov     ecx, [eax]
.text:0000E554                 call    ecx
.text:0000E556                 cmp     esi, esp
.text:0000E558                 call    __RTC_CheckEsp
.text:0000E55D                 pop     esi
.text:0000E55E                 add     esp, 4
.text:0000E561                 cmp     ebp, esp
.text:0000E563                 call    __RTC_CheckEsp
.text:0000E568                 mov     esp, ebp
.text:0000E56A                 pop     ebp
.text:0000E56B                 retn    8
.text:0000E56B ??$QueryInterface@UICryptoSetPassword@@@?$CMyComPtr@UIUnknown@@@@QBEJABU_GUID@@PAPAUICryptoSetPassword@@@Z endp
.text:0000E56B
.text:0000E56B ; ---------------------------------------------------------------------------
.text:0000E56E                 align 10h
.text:0000E56E _text           ends
.text:0000E56E
.text:0000E570 ; ===========================================================================
.text:0000E570
.text:0000E570 ; Segment type: Pure code
.text:0000E570 ; Segment permissions: Read/Execute
.text:0000E570 _text           segment para public 'CODE' use32
.text:0000E570                 assume cs:_text
.text:0000E570                 ;org 0E570h
.text:0000E570 ; COMDAT (pick any)
.text:0000E570                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000E570
.text:0000E570 ; =============== S U B R O U T I N E =======================================
.text:0000E570
.text:0000E570 ; Attributes: bp-based frame
.text:0000E570
.text:0000E570 ; public: long __thiscall CMyComPtr<struct IUnknown>::QueryInterface<struct ICryptoProperties>(struct _GUID const &, struct ICryptoProperties * *)const
.text:0000E570                 public ??$QueryInterface@UICryptoProperties@@@?$CMyComPtr@UIUnknown@@@@QBEJABU_GUID@@PAPAUICryptoProperties@@@Z
.text:0000E570 ??$QueryInterface@UICryptoProperties@@@?$CMyComPtr@UIUnknown@@@@QBEJABU_GUID@@PAPAUICryptoProperties@@@Z proc near
.text:0000E570                                         ; CODE XREF: CEncoderInfo::Encode(void)+D4p
.text:0000E570                                         ; CEncoderInfo::Decode(uint)+3F2p
.text:0000E570
.text:0000E570 var_4           = dword ptr -4
.text:0000E570 arg_0           = dword ptr  8
.text:0000E570 arg_4           = dword ptr  0Ch
.text:0000E570
.text:0000E570                 push    ebp
.text:0000E571                 mov     ebp, esp
.text:0000E573                 push    ecx
.text:0000E574                 push    esi
.text:0000E575                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000E57C                 mov     [ebp+var_4], ecx
.text:0000E57F                 mov     esi, esp
.text:0000E581                 mov     eax, [ebp+arg_4]
.text:0000E584                 push    eax
.text:0000E585                 mov     ecx, [ebp+arg_0]
.text:0000E588                 push    ecx
.text:0000E589                 mov     edx, [ebp+var_4]
.text:0000E58C                 mov     eax, [edx]
.text:0000E58E                 mov     ecx, [ebp+var_4]
.text:0000E591                 mov     edx, [ecx]
.text:0000E593                 mov     eax, [eax]
.text:0000E595                 push    edx
.text:0000E596                 mov     ecx, [eax]
.text:0000E598                 call    ecx
.text:0000E59A                 cmp     esi, esp
.text:0000E59C                 call    __RTC_CheckEsp
.text:0000E5A1                 pop     esi
.text:0000E5A2                 add     esp, 4
.text:0000E5A5                 cmp     ebp, esp
.text:0000E5A7                 call    __RTC_CheckEsp
.text:0000E5AC                 mov     esp, ebp
.text:0000E5AE                 pop     ebp
.text:0000E5AF                 retn    8
.text:0000E5AF ??$QueryInterface@UICryptoProperties@@@?$CMyComPtr@UIUnknown@@@@QBEJABU_GUID@@PAPAUICryptoProperties@@@Z endp
.text:0000E5AF
.text:0000E5AF ; ---------------------------------------------------------------------------
.text:0000E5B2                 align 4
.text:0000E5B2 _text           ends
.text:0000E5B2
.text:0000E5B4 ; ===========================================================================
.text:0000E5B4
.text:0000E5B4 ; Segment type: Pure code
.text:0000E5B4 ; Segment permissions: Read/Execute
.text:0000E5B4 _text           segment para public 'CODE' use32
.text:0000E5B4                 assume cs:_text
.text:0000E5B4                 ;org 0E5B4h
.text:0000E5B4 ; COMDAT (pick any)
.text:0000E5B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000E5B4
.text:0000E5B4 ; =============== S U B R O U T I N E =======================================
.text:0000E5B4
.text:0000E5B4 ; Attributes: bp-based frame
.text:0000E5B4
.text:0000E5B4 ; public: long __thiscall CMyComPtr<struct IUnknown>::QueryInterface<struct ICompressSetDecoderProperties2>(struct _GUID const &, struct ICompressSetDecoderProperties2 * *)const
.text:0000E5B4                 public ??$QueryInterface@UICompressSetDecoderProperties2@@@?$CMyComPtr@UIUnknown@@@@QBEJABU_GUID@@PAPAUICompressSetDecoderProperties2@@@Z
.text:0000E5B4 ??$QueryInterface@UICompressSetDecoderProperties2@@@?$CMyComPtr@UIUnknown@@@@QBEJABU_GUID@@PAPAUICompressSetDecoderProperties2@@@Z proc near
.text:0000E5B4                                         ; CODE XREF: CEncoderInfo::Decode(uint)+158p
.text:0000E5B4
.text:0000E5B4 var_4           = dword ptr -4
.text:0000E5B4 arg_0           = dword ptr  8
.text:0000E5B4 arg_4           = dword ptr  0Ch
.text:0000E5B4
.text:0000E5B4                 push    ebp
.text:0000E5B5                 mov     ebp, esp
.text:0000E5B7                 push    ecx
.text:0000E5B8                 push    esi
.text:0000E5B9                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000E5C0                 mov     [ebp+var_4], ecx
.text:0000E5C3                 mov     esi, esp
.text:0000E5C5                 mov     eax, [ebp+arg_4]
.text:0000E5C8                 push    eax
.text:0000E5C9                 mov     ecx, [ebp+arg_0]
.text:0000E5CC                 push    ecx
.text:0000E5CD                 mov     edx, [ebp+var_4]
.text:0000E5D0                 mov     eax, [edx]
.text:0000E5D2                 mov     ecx, [ebp+var_4]
.text:0000E5D5                 mov     edx, [ecx]
.text:0000E5D7                 mov     eax, [eax]
.text:0000E5D9                 push    edx
.text:0000E5DA                 mov     ecx, [eax]
.text:0000E5DC                 call    ecx
.text:0000E5DE                 cmp     esi, esp
.text:0000E5E0                 call    __RTC_CheckEsp
.text:0000E5E5                 pop     esi
.text:0000E5E6                 add     esp, 4
.text:0000E5E9                 cmp     ebp, esp
.text:0000E5EB                 call    __RTC_CheckEsp
.text:0000E5F0                 mov     esp, ebp
.text:0000E5F2                 pop     ebp
.text:0000E5F3                 retn    8
.text:0000E5F3 ??$QueryInterface@UICompressSetDecoderProperties2@@@?$CMyComPtr@UIUnknown@@@@QBEJABU_GUID@@PAPAUICompressSetDecoderProperties2@@@Z endp
.text:0000E5F3
.text:0000E5F3 ; ---------------------------------------------------------------------------
.text:0000E5F6                 align 4
.text:0000E5F6 _text           ends
.text:0000E5F6
.text:0000E5F8 ; ===========================================================================
.text:0000E5F8
.text:0000E5F8 ; Segment type: Pure code
.text:0000E5F8 ; Segment permissions: Read/Execute
.text:0000E5F8 _text           segment para public 'CODE' use32
.text:0000E5F8                 assume cs:_text
.text:0000E5F8                 ;org 0E5F8h
.text:0000E5F8 ; COMDAT (pick any)
.text:0000E5F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000E5F8
.text:0000E5F8 ; =============== S U B R O U T I N E =======================================
.text:0000E5F8
.text:0000E5F8 ; Attributes: bp-based frame
.text:0000E5F8
.text:0000E5F8 ; public: long __thiscall CMyComPtr<struct IUnknown>::QueryInterface<struct ICompressSetCoderMt>(struct _GUID const &, struct ICompressSetCoderMt * *)const
.text:0000E5F8                 public ??$QueryInterface@UICompressSetCoderMt@@@?$CMyComPtr@UIUnknown@@@@QBEJABU_GUID@@PAPAUICompressSetCoderMt@@@Z
.text:0000E5F8 ??$QueryInterface@UICompressSetCoderMt@@@?$CMyComPtr@UIUnknown@@@@QBEJABU_GUID@@PAPAUICompressSetCoderMt@@@Z proc near
.text:0000E5F8                                         ; CODE XREF: CEncoderInfo::Decode(uint)+266p
.text:0000E5F8
.text:0000E5F8 var_4           = dword ptr -4
.text:0000E5F8 arg_0           = dword ptr  8
.text:0000E5F8 arg_4           = dword ptr  0Ch
.text:0000E5F8
.text:0000E5F8                 push    ebp
.text:0000E5F9                 mov     ebp, esp
.text:0000E5FB                 push    ecx
.text:0000E5FC                 push    esi
.text:0000E5FD                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000E604                 mov     [ebp+var_4], ecx
.text:0000E607                 mov     esi, esp
.text:0000E609                 mov     eax, [ebp+arg_4]
.text:0000E60C                 push    eax
.text:0000E60D                 mov     ecx, [ebp+arg_0]
.text:0000E610                 push    ecx
.text:0000E611                 mov     edx, [ebp+var_4]
.text:0000E614                 mov     eax, [edx]
.text:0000E616                 mov     ecx, [ebp+var_4]
.text:0000E619                 mov     edx, [ecx]
.text:0000E61B                 mov     eax, [eax]
.text:0000E61D                 push    edx
.text:0000E61E                 mov     ecx, [eax]
.text:0000E620                 call    ecx
.text:0000E622                 cmp     esi, esp
.text:0000E624                 call    __RTC_CheckEsp
.text:0000E629                 pop     esi
.text:0000E62A                 add     esp, 4
.text:0000E62D                 cmp     ebp, esp
.text:0000E62F                 call    __RTC_CheckEsp
.text:0000E634                 mov     esp, ebp
.text:0000E636                 pop     ebp
.text:0000E637                 retn    8
.text:0000E637 ??$QueryInterface@UICompressSetCoderMt@@@?$CMyComPtr@UIUnknown@@@@QBEJABU_GUID@@PAPAUICompressSetCoderMt@@@Z endp
.text:0000E637
.text:0000E637 ; ---------------------------------------------------------------------------
.text:0000E63A                 align 4
.text:0000E63A _text           ends
.text:0000E63A
.text:0000E63C ; ===========================================================================
.text:0000E63C
.text:0000E63C ; Segment type: Pure code
.text:0000E63C ; Segment permissions: Read/Execute
.text:0000E63C _text           segment para public 'CODE' use32
.text:0000E63C                 assume cs:_text
.text:0000E63C                 ;org 0E63Ch
.text:0000E63C ; COMDAT (pick any)
.text:0000E63C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000E63C
.text:0000E63C ; =============== S U B R O U T I N E =======================================
.text:0000E63C
.text:0000E63C ; Attributes: bp-based frame
.text:0000E63C
.text:0000E63C ; public: long __thiscall CMyComPtr<struct IHasher>::QueryInterface<struct ICompressSetCoderProperties>(struct _GUID const &, struct ICompressSetCoderProperties * *)const
.text:0000E63C                 public ??$QueryInterface@UICompressSetCoderProperties@@@?$CMyComPtr@UIHasher@@@@QBEJABU_GUID@@PAPAUICompressSetCoderProperties@@@Z
.text:0000E63C ??$QueryInterface@UICompressSetCoderProperties@@@?$CMyComPtr@UIHasher@@@@QBEJABU_GUID@@PAPAUICompressSetCoderProperties@@@Z proc near
.text:0000E63C                                         ; CODE XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+3D4p
.text:0000E63C                                         ; CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+831p
.text:0000E63C
.text:0000E63C var_4           = dword ptr -4
.text:0000E63C arg_0           = dword ptr  8
.text:0000E63C arg_4           = dword ptr  0Ch
.text:0000E63C
.text:0000E63C                 push    ebp
.text:0000E63D                 mov     ebp, esp
.text:0000E63F                 push    ecx
.text:0000E640                 push    esi
.text:0000E641                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000E648                 mov     [ebp+var_4], ecx
.text:0000E64B                 mov     esi, esp
.text:0000E64D                 mov     eax, [ebp+arg_4]
.text:0000E650                 push    eax
.text:0000E651                 mov     ecx, [ebp+arg_0]
.text:0000E654                 push    ecx
.text:0000E655                 mov     edx, [ebp+var_4]
.text:0000E658                 mov     eax, [edx]
.text:0000E65A                 mov     ecx, [ebp+var_4]
.text:0000E65D                 mov     edx, [ecx]
.text:0000E65F                 mov     eax, [eax]
.text:0000E661                 push    edx
.text:0000E662                 mov     ecx, [eax]
.text:0000E664                 call    ecx
.text:0000E666                 cmp     esi, esp
.text:0000E668                 call    __RTC_CheckEsp
.text:0000E66D                 pop     esi
.text:0000E66E                 add     esp, 4
.text:0000E671                 cmp     ebp, esp
.text:0000E673                 call    __RTC_CheckEsp
.text:0000E678                 mov     esp, ebp
.text:0000E67A                 pop     ebp
.text:0000E67B                 retn    8
.text:0000E67B ??$QueryInterface@UICompressSetCoderProperties@@@?$CMyComPtr@UIHasher@@@@QBEJABU_GUID@@PAPAUICompressSetCoderProperties@@@Z endp
.text:0000E67B
.text:0000E67B ; ---------------------------------------------------------------------------
.text:0000E67E                 align 10h
.text:0000E67E _text           ends
.text:0000E67E
.text:0000E680 ; ===========================================================================
.text:0000E680
.text:0000E680 ; Segment type: Pure code
.text:0000E680 ; Segment permissions: Read/Execute
.text:0000E680 _text           segment para public 'CODE' use32
.text:0000E680                 assume cs:_text
.text:0000E680                 ;org 0E680h
.text:0000E680 ; COMDAT (pick any)
.text:0000E680                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000E680
.text:0000E680 ; =============== S U B R O U T I N E =======================================
.text:0000E680
.text:0000E680
.text:0000E680 ; [thunk]:public: virtual void * __thiscall CBenchmarkOutStream::`vector deleting destructor'`adjustor{4}' (unsigned int)
.text:0000E680                 public ??_ECBenchmarkOutStream@@W3AEPAXI@Z
.text:0000E680 ??_ECBenchmarkOutStream@@W3AEPAXI@Z proc near
.text:0000E680                                         ; DATA XREF: .rdata:const CBenchmarkOutStream::`vftable'{for `CBenchBuffer'}o
.text:0000E680                 sub     ecx, 4
.text:0000E683                 jmp     ??_ECBenchmarkOutStream@@UAEPAXI@Z ; CBenchmarkOutStream::`vector deleting destructor'(uint)
.text:0000E683 ??_ECBenchmarkOutStream@@W3AEPAXI@Z endp
.text:0000E683
.text:0000E683 _text           ends
.text:0000E683
.text:0000E688 ; ===========================================================================
.text:0000E688
.text:0000E688 ; Segment type: Pure code
.text:0000E688 ; Segment permissions: Read/Execute
.text:0000E688 _text           segment para public 'CODE' use32
.text:0000E688                 assume cs:_text
.text:0000E688                 ;org 0E688h
.text:0000E688 ; COMDAT (pick any)
.text:0000E688                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000E688
.text:0000E688 ; =============== S U B R O U T I N E =======================================
.text:0000E688
.text:0000E688 ; Attributes: bp-based frame
.text:0000E688
.text:0000E688 ; public: virtual void * __thiscall CBenchmarkOutStream::`scalar deleting destructor'(unsigned int)
.text:0000E688                 public ??_GCBenchmarkOutStream@@UAEPAXI@Z
.text:0000E688 ??_GCBenchmarkOutStream@@UAEPAXI@Z proc near
.text:0000E688
.text:0000E688 var_4           = dword ptr -4
.text:0000E688 arg_0           = dword ptr  8
.text:0000E688
.text:0000E688                 push    ebp
.text:0000E689                 mov     ebp, esp
.text:0000E68B                 push    ecx
.text:0000E68C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000E693                 mov     [ebp+var_4], ecx
.text:0000E696                 mov     ecx, [ebp+var_4] ; this
.text:0000E699                 call    ??1CBenchmarkOutStream@@UAE@XZ ; CBenchmarkOutStream::~CBenchmarkOutStream(void)
.text:0000E69E                 mov     eax, [ebp+arg_0]
.text:0000E6A1                 and     eax, 1
.text:0000E6A4                 jz      short loc_E6B2
.text:0000E6A6                 mov     ecx, [ebp+var_4]
.text:0000E6A9                 push    ecx             ; void *
.text:0000E6AA                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000E6AF                 add     esp, 4
.text:0000E6B2
.text:0000E6B2 loc_E6B2:                               ; CODE XREF: CBenchmarkOutStream::`scalar deleting destructor'(uint)+1Cj
.text:0000E6B2                 mov     eax, [ebp+var_4]
.text:0000E6B5                 add     esp, 4
.text:0000E6B8                 cmp     ebp, esp
.text:0000E6BA                 call    __RTC_CheckEsp
.text:0000E6BF                 mov     esp, ebp
.text:0000E6C1                 pop     ebp
.text:0000E6C2                 retn    4
.text:0000E6C2 ??_GCBenchmarkOutStream@@UAEPAXI@Z endp
.text:0000E6C2
.text:0000E6C2 ; ---------------------------------------------------------------------------
.text:0000E6C5                 align 4
.text:0000E6C5 _text           ends
.text:0000E6C5
.text:0000E6C8 ; ===========================================================================
.text:0000E6C8
.text:0000E6C8 ; Segment type: Pure code
.text:0000E6C8 ; Segment permissions: Read/Execute
.text:0000E6C8 _text           segment para public 'CODE' use32
.text:0000E6C8                 assume cs:_text
.text:0000E6C8                 ;org 0E6C8h
.text:0000E6C8 ; COMDAT (pick any)
.text:0000E6C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000E6C8
.text:0000E6C8 ; =============== S U B R O U T I N E =======================================
.text:0000E6C8
.text:0000E6C8 ; Attributes: bp-based frame
.text:0000E6C8
.text:0000E6C8 ; _DWORD __thiscall CBenchmarkOutStream::~CBenchmarkOutStream(CBenchmarkOutStream *__hidden this)
.text:0000E6C8                 public ??1CBenchmarkOutStream@@UAE@XZ
.text:0000E6C8 ??1CBenchmarkOutStream@@UAE@XZ proc near
.text:0000E6C8                                         ; CODE XREF: CBenchmarkOutStream::`scalar deleting destructor'(uint)+11p
.text:0000E6C8
.text:0000E6C8 var_4           = dword ptr -4
.text:0000E6C8
.text:0000E6C8                 push    ebp
.text:0000E6C9                 mov     ebp, esp
.text:0000E6CB                 push    ecx
.text:0000E6CC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000E6D3                 mov     [ebp+var_4], ecx
.text:0000E6D6                 mov     ecx, [ebp+var_4]
.text:0000E6D9                 add     ecx, 4          ; this
.text:0000E6DC                 call    ??1CBenchBuffer@@UAE@XZ ; CBenchBuffer::~CBenchBuffer(void)
.text:0000E6E1                 add     esp, 4
.text:0000E6E4                 cmp     ebp, esp
.text:0000E6E6                 call    __RTC_CheckEsp
.text:0000E6EB                 mov     esp, ebp
.text:0000E6ED                 pop     ebp
.text:0000E6EE                 retn
.text:0000E6EE ??1CBenchmarkOutStream@@UAE@XZ endp
.text:0000E6EE
.text:0000E6EE _text           ends
.text:0000E6EE
UNDEF:0000E6F0 ; ===========================================================================
UNDEF:0000E6F0
UNDEF:0000E6F0 ; Segment type: Externs
UNDEF:0000E6F0 ; UNDEF
UNDEF:0000E6F0                 extrn __RTC_Shutdown:near
UNDEF:0000E6F0                                         ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
UNDEF:0000E6F4                 extrn __RTC_InitBase:near
UNDEF:0000E6F4                                         ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
UNDEF:0000E6F8 ; __fastcall CrcUpdate(x, x, x)
UNDEF:0000E6F8                 extrn @CrcUpdate@12:near
UNDEF:0000E6F8                                         ; CODE XREF: CBenchmarkOutStream::Write(void const *,uint,uint *)+6Ep
UNDEF:0000E6F8                                         ; CCrcOutStream::Write(void const *,uint,uint *)+1Bp
UNDEF:0000E6FC ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:0000E6FC                 extrn _memcpy:near      ; CODE XREF: CBenchmarkOutStream::Write(void const *,uint,uint *)+4Ep
UNDEF:0000E6FC                                         ; CEncoderInfo::Encode(void)+44Ap ...
UNDEF:0000E700                 extrn __RTC_CheckEsp:near
UNDEF:0000E700                                         ; CODE XREF: CBenchmarkOutStream::Write(void const *,uint,uint *)+ACp
UNDEF:0000E700                                         ; CCrcOutStream::Write(void const *,uint,uint *)+38p ...
UNDEF:0000E704 ; DWORD __stdcall GetTickCount()
UNDEF:0000E704                 extrn __imp__GetTickCount@0:near
UNDEF:0000E704                                         ; CODE XREF: GetWinUserTime(void)+6Cp
UNDEF:0000E704                                         ; GetTimeCount(void)+6p
UNDEF:0000E704                                         ; DATA XREF: ...
UNDEF:0000E708 ; BOOL __stdcall GetProcessTimes(HANDLE hProcess, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime)
UNDEF:0000E708                 extrn __imp__GetProcessTimes@20:near
UNDEF:0000E708                                         ; CODE XREF: GetWinUserTime(void)+39p
UNDEF:0000E708                                         ; DATA XREF: GetWinUserTime(void)+39r
UNDEF:0000E70C ; HANDLE __stdcall GetCurrentProcess()
UNDEF:0000E70C                 extrn __imp__GetCurrentProcess@0:near
UNDEF:0000E70C                                         ; CODE XREF: GetWinUserTime(void)+2Bp
UNDEF:0000E70C                                         ; DATA XREF: GetWinUserTime(void)+2Br
UNDEF:0000E710 ; __fastcall _RTC_CheckStackVars(x, x)
UNDEF:0000E710                 extrn @_RTC_CheckStackVars@8:near
UNDEF:0000E710                                         ; CODE XREF: GetWinUserTime(void)+8Ap
UNDEF:0000E710                                         ; CBenchProgressInfo::SetRatioInfo(unsigned __int64 const *,unsigned __int64 const *)+135p ...
UNDEF:0000E714                 extrn __allshl:near     ; CODE XREF: GetTime64(_FILETIME const &)+Ep
UNDEF:0000E714                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+6A8p
UNDEF:0000E718 ; void __stdcall EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
UNDEF:0000E718                 extrn __imp__EnterCriticalSection@4:near
UNDEF:0000E718                                         ; CODE XREF: NWindows::NSynchronization::CCriticalSection::Enter(void)+15p
UNDEF:0000E718                                         ; DATA XREF: NWindows::NSynchronization::CCriticalSection::Enter(void)+15r
UNDEF:0000E71C ; void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
UNDEF:0000E71C                 extrn __imp__LeaveCriticalSection@4:near
UNDEF:0000E71C                                         ; CODE XREF: NWindows::NSynchronization::CCriticalSection::Leave(void)+15p
UNDEF:0000E71C                                         ; DATA XREF: NWindows::NSynchronization::CCriticalSection::Leave(void)+15r
UNDEF:0000E720                 extrn __aulldiv:near    ; CODE XREF: CBenchInfo::GetUsage(void)+C9p
UNDEF:0000E720                                         ; CBenchInfo::GetUsage(void)+D8p ...
UNDEF:0000E724                 extrn __allmul:near     ; CODE XREF: CBenchInfo::GetUsage(void)+ACp
UNDEF:0000E724                                         ; CBenchInfo::GetUsage(void)+BAp ...
UNDEF:0000E728                 extrn __aullshr:near    ; CODE XREF: NormalizeVals(unsigned __int64 &,unsigned __int64 &)+2Fp
UNDEF:0000E728                                         ; NormalizeVals(unsigned __int64 &,unsigned __int64 &)+46p ...
UNDEF:0000E72C ; void __cdecl operator delete(void *)
UNDEF:0000E72C                 extrn ??3@YAXPAX@Z:near ; CODE XREF: __unwindfunclet$?Init@CEncoderInfo@@QAEJABVCOneMethodInfo@@IIPAVCBaseRandomGenerator@@@Z$0+7p
UNDEF:0000E72C                                         ; __unwindfunclet$?Init@CEncoderInfo@@QAEJABVCOneMethodInfo@@IIPAVCBaseRandomGenerator@@@Z$1+7p ...
UNDEF:0000E730 ; void *__cdecl memset(void *Dst, int Val, size_t Size)
UNDEF:0000E730                 extrn _memset:near      ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+568p
UNDEF:0000E730                                         ; PrintNumber(IBenchPrintCallback &,unsigned __int64,int)+41p ...
UNDEF:0000E734                 extrn _IID_ICryptoSetPassword:near
UNDEF:0000E734                                         ; DATA XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+459o
UNDEF:0000E734                                         ; CEncoderInfo::Decode(uint)+4DBo
UNDEF:0000E738                 extrn _IID_ICompressWriteCoderProperties:near
UNDEF:0000E738                                         ; DATA XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+3ADo
UNDEF:0000E73C ; __int32 __thiscall CProps::SetCoderProps(CProps *__hidden this, struct ICompressSetCoderProperties *, const unsigned __int64 *)
UNDEF:0000E73C                 extrn ?SetCoderProps@CProps@@QBEJPAUICompressSetCoderProperties@@PB_K@Z:near
UNDEF:0000E73C                                         ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+31Ap
UNDEF:0000E73C                                         ; CEncoderInfo::Decode(uint)+36Ep ...
UNDEF:0000E740                 extrn _IID_ICompressSetCoderProperties:near
UNDEF:0000E740                                         ; DATA XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+2E6o
UNDEF:0000E740                                         ; CEncoderInfo::Decode(uint)+32Ao ...
UNDEF:0000E744 ; void *__cdecl operator new(unsigned int)
UNDEF:0000E744                 extrn ??2@YAPAXI@Z:near ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+11Fp
UNDEF:0000E744                                         ; CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+1DEp ...
UNDEF:0000E748 ; __fastcall CrcCalc(x, x)
UNDEF:0000E748                 extrn @CrcCalc@8:near   ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+D7p
UNDEF:0000E748                                         ; CrcInternalTest(void)+15Ap
UNDEF:0000E74C                 extrn ___security_cookie:near
UNDEF:0000E74C                                         ; DATA XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+2Dr
UNDEF:0000E74C                                         ; CEncoderInfo::Encode(void)+2Dr ...
UNDEF:0000E750                 extrn ___CxxFrameHandler3:near
UNDEF:0000E750                                         ; CODE XREF: __ehhandler$?Init@CEncoderInfo@@QAEJABVCOneMethodInfo@@IIPAVCBaseRandomGenerator@@@Z+23j
UNDEF:0000E750                                         ; __ehhandler$?Encode@CEncoderInfo@@QAEJXZ+19j ...
UNDEF:0000E754 ; __fastcall __security_check_cookie(x)
UNDEF:0000E754                 extrn @__security_check_cookie@4:near
UNDEF:0000E754                                         ; CODE XREF: CEncoderInfo::Init(COneMethodInfo const &,uint,uint,CBaseRandomGenerator *)+7ACp
UNDEF:0000E754                                         ; PrintNumber(IBenchPrintCallback &,unsigned __int64,int)+101p ...
UNDEF:0000E758 ; __stdcall MidAlloc(x)
UNDEF:0000E758                 extrn _MidAlloc@4:near  ; CODE XREF: CBenchBuffer::Alloc(uint)+3Bp
UNDEF:0000E75C ; __stdcall MidFree(x)
UNDEF:0000E75C                 extrn _MidFree@4:near   ; CODE XREF: CBenchBuffer::Free(void)+15p
UNDEF:0000E760 ; const type_info::`vftable'
UNDEF:0000E760                 extrn ??_7type_info@@6B@:near
UNDEF:0000E760                                         ; DATA XREF: .data:CCrcOutStream `RTTI Type Descriptor'o
UNDEF:0000E760                                         ; .data:ISequentialOutStream `RTTI Type Descriptor'o ...
UNDEF:0000E764 ; const IID IID_IUnknown
UNDEF:0000E764                 extrn _IID_IUnknown:near
UNDEF:0000E764                                         ; DATA XREF: CCrcOutStream::QueryInterface(_GUID const &,void * *)+Co
UNDEF:0000E764                                         ; CBenchmarkOutStream::QueryInterface(_GUID const &,void * *)+Co ...
UNDEF:0000E768 ; int __cdecl memcmp(const void *Buf1, const void *Buf2, size_t Size)
UNDEF:0000E768                 extrn _memcmp:near      ; CODE XREF: IsEqualGUID(x,x)+Dp
UNDEF:0000E76C                 extrn __purecall:near   ; DATA XREF: .rdata:const ISequentialOutStream::`vftable'o
UNDEF:0000E76C                                         ; .rdata:0000A630o ...
UNDEF:0000E770 ; public: virtual void * __thiscall CBenchBuffer::`scalar deleting destructor'(unsigned int)
UNDEF:0000E770                 extrn ??_GCBenchBuffer@@UAEPAXI@Z_0:near
UNDEF:0000E774 ; public: virtual void * __thiscall CBenchBuffer::`vector deleting destructor'(unsigned int)
UNDEF:0000E774                 extrn ??_ECBenchBuffer@@UAEPAXI@Z:near ; weak
UNDEF:0000E774                                         ; DATA XREF: .rdata:const CBenchBuffer::`vftable'o
UNDEF:0000E778 ; __int32 __stdcall WriteStream(struct ISequentialOutStream *, const void *, unsigned int)
UNDEF:0000E778                 extrn ?WriteStream@@YGJPAUISequentialOutStream@@PBXI@Z:near
UNDEF:0000E778                                         ; CODE XREF: CEncoderInfo::Encode(void)+4E5p
UNDEF:0000E778                                         ; CEncoderInfo::Decode(uint)+A81p
UNDEF:0000E77C                 extrn _IID_ICryptoProperties:near
UNDEF:0000E77C                                         ; DATA XREF: CEncoderInfo::Encode(void)+CCo
UNDEF:0000E77C                                         ; CEncoderInfo::Decode(uint)+3EAo
UNDEF:0000E780                 extrn _IID_ICompressSetCoderMt:near
UNDEF:0000E780                                         ; DATA XREF: CEncoderInfo::Decode(uint)+25Eo
UNDEF:0000E784                 extrn _IID_ICompressSetDecoderProperties2:near
UNDEF:0000E784                                         ; DATA XREF: CEncoderInfo::Decode(uint)+150o
UNDEF:0000E788 ; void __stdcall `eh vector destructor iterator'(void *, unsigned int, int, void (__thiscall *)(void *))
UNDEF:0000E788                 extrn ??_M@YGXPAXIHP6EX0@Z@Z:near
UNDEF:0000E788                                         ; CODE XREF: CEncoderInfo::`vector deleting destructor'(uint)+2Bp
UNDEF:0000E788                                         ; CEncoderInfo::~CEncoderInfo(void)+B2p ...
UNDEF:0000E78C ; __stdcall HandlePtr_Close(x)
UNDEF:0000E78C                 extrn _HandlePtr_Close@4:near
UNDEF:0000E78C                                         ; CODE XREF: NWindows::CThread::Close(void)+12p
UNDEF:0000E790                 extrn _g_CrcTable:near  ; DATA XREF: CrcCalc1(uchar const *,uint)+4Cr
UNDEF:0000E794 ; size_t __cdecl strlen(const char *Str)
UNDEF:0000E794                 extrn _strlen:near      ; CODE XREF: PrintNumber(IBenchPrintCallback &,unsigned __int64,int)+8Ap
UNDEF:0000E798 ; void __stdcall ConvertUInt64ToString(unsigned __int64, char *)
UNDEF:0000E798                 extrn ?ConvertUInt64ToString@@YGX_KPAD@Z:near
UNDEF:0000E798                                         ; CODE XREF: PrintNumber(IBenchPrintCallback &,unsigned __int64,int)+5Fp
UNDEF:0000E79C ; public: class AString & __thiscall AString::operator=(char const *)
UNDEF:0000E79C                 extrn ??4AString@@QAEAAV0@PBD@Z:near
UNDEF:0000E79C                                         ; CODE XREF: GetCpuName(AString &)+4Cp
UNDEF:0000E79C                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+76Ep ...
UNDEF:0000E7A0 ; __stdcall x86cpuid_CheckAndRead(x)
UNDEF:0000E7A0                 extrn _x86cpuid_CheckAndRead@4:near
UNDEF:0000E7A0                                         ; CODE XREF: GetCpuName(AString &)+2Cp
UNDEF:0000E7A4 ; public: class AString & __thiscall AString::operator+=(char const *)
UNDEF:0000E7A4                 extrn ??YAString@@QAEAAV0@PBD@Z:near
UNDEF:0000E7A4                                         ; CODE XREF: x86cpuid_to_String(Cx86cpuid const &,AString &)+12Fp
UNDEF:0000E7A8 ; void __stdcall ConvertUInt32ToHex(unsigned int, char *)
UNDEF:0000E7A8                 extrn ?ConvertUInt32ToHex@@YGXIPAD@Z:near
UNDEF:0000E7A8                                         ; CODE XREF: x86cpuid_to_String(Cx86cpuid const &,AString &)+119p
UNDEF:0000E7AC ; void __thiscall AString::Add_Space_if_NotEmpty(AString *__hidden this)
UNDEF:0000E7AC                 extrn ?Add_Space_if_NotEmpty@AString@@QAEXXZ:near
UNDEF:0000E7AC                                         ; CODE XREF: x86cpuid_to_String(Cx86cpuid const &,AString &)+109p
UNDEF:0000E7B0 ; __stdcall MyCPUID(x, x, x, x, x)
UNDEF:0000E7B0                 extrn _MyCPUID@20:near  ; CODE XREF: x86cpuid_to_String(Cx86cpuid const &,AString &)+44p
UNDEF:0000E7B0                                         ; x86cpuid_to_String(Cx86cpuid const &,AString &)+D4p
UNDEF:0000E7B4 ; void __thiscall AString::Grow_1(AString *__hidden this)
UNDEF:0000E7B4                 extrn ?Grow_1@AString@@AAEXXZ:near
UNDEF:0000E7B4                                         ; CODE XREF: AString::operator+=(char)+2Fp
UNDEF:0000E7B8 ; bool __stdcall StringsAreEqualNoCase_Ascii(const char *, const char *)
UNDEF:0000E7B8                 extrn ?StringsAreEqualNoCase_Ascii@@YG_NPBD0@Z:near
UNDEF:0000E7B8                                         ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1ADAp
UNDEF:0000E7B8                                         ; AString::IsEqualTo_Ascii_NoCase(char const *)+18p
UNDEF:0000E7BC ; void __stdcall ConvertUInt32ToString(unsigned int, char *)
UNDEF:0000E7BC                 extrn ?ConvertUInt32ToString@@YGXIPAD@Z:near
UNDEF:0000E7BC                                         ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+BF8p
UNDEF:0000E7BC                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1A4Cp
UNDEF:0000E7C0 ; public: __thiscall AString::AString(char const *)
UNDEF:0000E7C0                 extrn ??0AString@@QAE@PBD@Z:near
UNDEF:0000E7C0                                         ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+927p
UNDEF:0000E7C0                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+18F9p
UNDEF:0000E7C4 ; bool __stdcall FindHashMethod(const struct AString *, unsigned __int64 *)
UNDEF:0000E7C4                 extrn ?FindHashMethod@@YG_NABVAString@@AA_K@Z:near
UNDEF:0000E7C4                                         ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+85Fp
UNDEF:0000E7C4                                         ; CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+67p
UNDEF:0000E7C8 ; public: class AString & __thiscall AString::operator=(class AString const &)
UNDEF:0000E7C8                 extrn ??4AString@@QAEAAV0@ABV0@@Z:near
UNDEF:0000E7C8                                         ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+84Cp
UNDEF:0000E7C8                                         ; COneMethodInfo::operator=(COneMethodInfo const &)+27p
UNDEF:0000E7CC ; public: __thiscall AString::AString(class AString const &)
UNDEF:0000E7CC                 extrn ??0AString@@QAE@ABV0@@Z:near
UNDEF:0000E7CC                                         ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+812p
UNDEF:0000E7CC                                         ; CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+53p ...
UNDEF:0000E7D0 ; public: __thiscall AString::AString(void)
UNDEF:0000E7D0                 extrn ??0AString@@QAE@XZ:near
UNDEF:0000E7D0                                         ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+402p
UNDEF:0000E7D0                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+936p ...
UNDEF:0000E7D4 ; __int32 __thiscall COneMethodInfo::ParseMethodFromPROPVARIANT(COneMethodInfo *__hidden this, const struct UString *, const struct tagPROPVARIANT *)
UNDEF:0000E7D4                 extrn ?ParseMethodFromPROPVARIANT@COneMethodInfo@@QAEJABVUString@@ABUtagPROPVARIANT@@@Z:near
UNDEF:0000E7D4                                         ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+381p
UNDEF:0000E7D4                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1B28p ...
UNDEF:0000E7D8 ; __int32 __stdcall ParseMtProp(const struct UString *, const struct tagPROPVARIANT *, unsigned int, unsigned int *)
UNDEF:0000E7D8                 extrn ?ParseMtProp@@YGJABVUString@@ABUtagPROPVARIANT@@IAAI@Z:near
UNDEF:0000E7D8                                         ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+2E0p
UNDEF:0000E7DC ; int __cdecl _wcscmp(const wchar_t *Str1, const wchar_t *Str2)
UNDEF:0000E7DC                 extrn __imp__wcscmp:near
UNDEF:0000E7DC                                         ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+286p
UNDEF:0000E7DC                                         ; operator==(UString const &,wchar_t const *)+13p
UNDEF:0000E7DC                                         ; DATA XREF: ...
UNDEF:0000E7E0 ; bool __thiscall UString::IsPrefixedBy_Ascii_NoCase(UString *__hidden this, const char *)
UNDEF:0000E7E0                 extrn ?IsPrefixedBy_Ascii_NoCase@UString@@QBE_NPBD@Z:near
UNDEF:0000E7E0                                         ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+1E8p
UNDEF:0000E7E4 ; __int32 __stdcall ParsePropToUInt32(const struct UString *, const struct tagPROPVARIANT *, unsigned int *)
UNDEF:0000E7E4                 extrn ?ParsePropToUInt32@@YGJABVUString@@ABUtagPROPVARIANT@@AAI@Z:near
UNDEF:0000E7E4                                         ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+159p
UNDEF:0000E7E8 ; public: __thiscall UString::UString(wchar_t const *)
UNDEF:0000E7E8                 extrn ??0UString@@QAE@PB_W@Z:near
UNDEF:0000E7E8                                         ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+141p
UNDEF:0000E7E8                                         ; Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+20Cp ...
UNDEF:0000E7EC ; public: __thiscall UString::UString(class UString const &)
UNDEF:0000E7EC                 extrn ??0UString@@QAE@ABV0@@Z:near
UNDEF:0000E7EC                                         ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+E5p
UNDEF:0000E7EC                                         ; COneMethodInfo::COneMethodInfo(COneMethodInfo const &)+63p
UNDEF:0000E7F0 ; unsigned __int64 NWindows::NSystem::GetRamSize(NWindows::NSystem *__hidden this)
UNDEF:0000E7F0                 extrn ?GetRamSize@NSystem@NWindows@@YG_KXZ:near
UNDEF:0000E7F0                                         ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+72p
UNDEF:0000E7F4 ; unsigned int NWindows::NSystem::GetNumberOfProcessors(NWindows::NSystem *__hidden this)
UNDEF:0000E7F4                 extrn ?GetNumberOfProcessors@NSystem@NWindows@@YGIXZ:near
UNDEF:0000E7F4                                         ; CODE XREF: Bench(IBenchPrintCallback *,IBenchCallback *,CObjectVector<CProperty> const &,uint,bool)+6Ap
UNDEF:0000E7F8 ; int __stdcall FindCharPosInString(const char *, char)
UNDEF:0000E7F8                 extrn ?FindCharPosInString@@YGHPBDD@Z:near
UNDEF:0000E7F8                                         ; CODE XREF: AString::Find(char)+19p
UNDEF:0000E7FC ; void __stdcall MyStringLower_Ascii(wchar_t *)
UNDEF:0000E7FC                 extrn ?MyStringLower_Ascii@@YGXPA_W@Z:near
UNDEF:0000E7FC                                         ; CODE XREF: UString::MakeLower_Ascii(void)+14p
UNDEF:0000E800 ; bool __stdcall StringsAreEqual_Ascii(const wchar_t *, const char *)
UNDEF:0000E800                 extrn ?StringsAreEqual_Ascii@@YG_NPB_WPBD@Z:near
UNDEF:0000E800                                         ; CODE XREF: UString::IsEqualTo(char const *)+18p
UNDEF:0000E804 ; bool __stdcall StringsAreEqualNoCase_Ascii(const wchar_t *, const char *)
UNDEF:0000E804                 extrn ?StringsAreEqualNoCase_Ascii@@YG_NPB_WPBD@Z:near
UNDEF:0000E804                                         ; CODE XREF: UString::IsEqualTo_Ascii_NoCase(char const *)+18p
UNDEF:0000E808 ; __int32 __thiscall NWindows::NCOM::CPropVariant::Clear(NWindows::NCOM::CPropVariant *__hidden this)
UNDEF:0000E808                 extrn ?Clear@CPropVariant@NCOM@NWindows@@QAEJXZ:near
UNDEF:0000E808                                         ; CODE XREF: NWindows::NCOM::CPropVariant::~CPropVariant(void)+11p
UNDEF:0000E80C ; int __thiscall CMethodProps::FindProp(CMethodProps *__hidden this, unsigned __int32)
UNDEF:0000E80C                 extrn ?FindProp@CMethodProps@@QBEHK@Z:near
UNDEF:0000E80C                                         ; CODE XREF: CMethodProps::Get_DicSize(uint &)+25p
UNDEF:0000E80C                                         ; CMethodProps::Get_Lzma_DicSize(void)+1Fp ...
UNDEF:0000E810 ; int __thiscall CMethodProps::GetLevel(CMethodProps *__hidden this)
UNDEF:0000E810                 extrn ?GetLevel@CMethodProps@@QBEHXZ:near
UNDEF:0000E810                                         ; CODE XREF: CMethodProps::Get_Lzma_DicSize(void)+56p
UNDEF:0000E810                                         ; CMethodProps::Get_Lzma_Algo(void)+53p
UNDEF:0000E814 ; public: __thiscall UString::UString(void)
UNDEF:0000E814                 extrn ??0UString@@QAE@XZ:near
UNDEF:0000E814                                         ; CODE XREF: TotalBench(unsigned __int64,uint,bool,uint,IBenchPrintCallback *,CBenchCallbackToPrint *)+CDp
UNDEF:0000E814                                         ; TotalBench_Hash(unsigned __int64,uint,uint,IBenchPrintCallback *,CBenchCallbackToPrint *,CTotalBenchRes *,bool,unsigned __int64)+ACp ...
UNDEF:0000E818 ; long __stdcall CreateCoder(unsigned __int64, bool, class CMyComPtr<struct ICompressFilter> &, struct CCreatedCoder &)
UNDEF:0000E818                 extrn ?CreateCoder@@YGJ_K_NAAV?$CMyComPtr@UICompressFilter@@@@AAUCCreatedCoder@@@Z:near
UNDEF:0000E818                                         ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+1B9p
UNDEF:0000E818                                         ; MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+385p
UNDEF:0000E81C ; bool __stdcall FindMethod(const struct AString *, unsigned __int64 *, unsigned int *)
UNDEF:0000E81C                 extrn ?FindMethod@@YG_NABVAString@@AA_KAAI@Z:near
UNDEF:0000E81C                                         ; CODE XREF: MethodBench(unsigned __int64,bool,uint,COneMethodInfo const &,uint,uint,IBenchPrintCallback *,IBenchCallback *,CBenchProps *)+5Bp
UNDEF:0000E820 ; __stdcall Handle_WaitObject(x)
UNDEF:0000E820                 extrn _Handle_WaitObject@4:near
UNDEF:0000E820                                         ; CODE XREF: NWindows::CThread::Wait(void)+14p
UNDEF:0000E824 ; void __thiscall CProps::AddProp32(CProps *__hidden this, unsigned __int32, unsigned int)
UNDEF:0000E824                 extrn ?AddProp32@CProps@@QAEXKI@Z:near
UNDEF:0000E824                                         ; CODE XREF: CMethodProps::AddProp_NumThreads(uint)+17p
UNDEF:0000E828 ; __stdcall Thread_Create(x, x, x)
UNDEF:0000E828                 extrn _Thread_Create@12:near
UNDEF:0000E828                                         ; CODE XREF: NWindows::CThread::Create(uint (*)(void *),void *)+1Ap
UNDEF:0000E82C                 extrn __alloca_probe_16:near
UNDEF:0000E82C                                         ; CODE XREF: CrcThreadFunction(void *)+31p
UNDEF:0000E82C                                         ; CEncoderInfo::EncodeThreadFunction(void *)+53p ...
UNDEF:0000E830 ; void __stdcall `eh vector constructor iterator'(void *, unsigned int, int, void (__thiscall *)(void *), void (__thiscall *)(void *))
UNDEF:0000E830                 extrn ??_L@YGXPAXIHP6EX0@Z1@Z:near
UNDEF:0000E830                                         ; CODE XREF: FreqBench(unsigned __int64,uint,IBenchPrintCallback *,bool,unsigned __int64 &,uint &)+165p
UNDEF:0000E830                                         ; CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+241p ...
UNDEF:0000E834 ; public: virtual void * __thiscall CBenchRandomGenerator::`scalar deleting destructor'(unsigned int)
UNDEF:0000E834                 extrn ??_GCBenchRandomGenerator@@UAEPAXI@Z_0:near
UNDEF:0000E838 ; public: virtual void * __thiscall CBenchRandomGenerator::`vector deleting destructor'(unsigned int)
UNDEF:0000E838                 extrn ??_ECBenchRandomGenerator@@UAEPAXI@Z:near ; weak
UNDEF:0000E838                                         ; DATA XREF: .rdata:const CBenchRandomGenerator::`vftable'o
UNDEF:0000E83C ; public: class UString & __thiscall UString::operator=(class UString const &)
UNDEF:0000E83C                 extrn ??4UString@@QAEAAV0@ABV0@@Z:near
UNDEF:0000E83C                                         ; CODE XREF: COneMethodInfo::operator=(COneMethodInfo const &)+39p
UNDEF:0000E840 ; __stdcall CriticalSection_Init(x)
UNDEF:0000E840                 extrn _CriticalSection_Init@4:near
UNDEF:0000E840                                         ; CODE XREF: NWindows::NSynchronization::CCriticalSection::CCriticalSection(void)+12p
UNDEF:0000E844 ; void __stdcall DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
UNDEF:0000E844                 extrn __imp__DeleteCriticalSection@4:near
UNDEF:0000E844                                         ; CODE XREF: NWindows::NSynchronization::CCriticalSection::~CCriticalSection(void)+15p
UNDEF:0000E844                                         ; DATA XREF: NWindows::NSynchronization::CCriticalSection::~CCriticalSection(void)+15r
UNDEF:0000E848 ; public: class NWindows::NCOM::CPropVariant & __thiscall NWindows::NCOM::CPropVariant::operator=(char const *)
UNDEF:0000E848                 extrn ??4CPropVariant@NCOM@NWindows@@QAEAAV012@PBD@Z:near
UNDEF:0000E848                                         ; CODE XREF: TotalBench(unsigned __int64,uint,bool,uint,IBenchPrintCallback *,CBenchCallbackToPrint *)+C1p
UNDEF:0000E848                                         ; TotalBench_Hash(unsigned __int64,uint,uint,IBenchPrintCallback *,CBenchCallbackToPrint *,CTotalBenchRes *,bool,unsigned __int64)+A0p
UNDEF:0000E84C ; long __stdcall CreateHasher(unsigned __int64, class AString &, class CMyComPtr<struct IHasher> &)
UNDEF:0000E84C                 extrn ?CreateHasher@@YGJ_KAAVAString@@AAV?$CMyComPtr@UIHasher@@@@@Z:near
UNDEF:0000E84C                                         ; CODE XREF: CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+2E4p
UNDEF:0000E84C                                         ; CrcBench(unsigned __int64,uint,uint,unsigned __int64 &,uint,uint,uint const *,COneMethodInfo const &,IBenchPrintCallback *,CTotalBenchRes *,bool,unsigned __int64)+729p
UNDEF:0000E850 ; public: class NWindows::NCOM::CPropVariant & __thiscall NWindows::NCOM::CPropVariant::operator=(unsigned __int64)
UNDEF:0000E850                 extrn ??4CPropVariant@NCOM@NWindows@@QAEAAV012@_K@Z:near
UNDEF:0000E850                                         ; CODE XREF: ParseNumberString(UString const &,NWindows::NCOM::CPropVariant &)+80p
UNDEF:0000E854 ; public: class NWindows::NCOM::CPropVariant & __thiscall NWindows::NCOM::CPropVariant::operator=(unsigned int)
UNDEF:0000E854                 extrn ??4CPropVariant@NCOM@NWindows@@QAEAAV012@I@Z:near
UNDEF:0000E854                                         ; CODE XREF: ParseNumberString(UString const &,NWindows::NCOM::CPropVariant &)+6Ep
UNDEF:0000E858 ; public: class NWindows::NCOM::CPropVariant & __thiscall NWindows::NCOM::CPropVariant::operator=(class UString const &)
UNDEF:0000E858                 extrn ??4CPropVariant@NCOM@NWindows@@QAEAAV012@ABVUString@@@Z:near
UNDEF:0000E858                                         ; CODE XREF: ParseNumberString(UString const &,NWindows::NCOM::CPropVariant &)+52p
UNDEF:0000E85C ; unsigned __int64 __stdcall ConvertStringToUInt64(const wchar_t *, const wchar_t **)
UNDEF:0000E85C                 extrn ?ConvertStringToUInt64@@YG_KPB_WPAPB_W@Z:near
UNDEF:0000E85C                                         ; CODE XREF: ParseNumberString(UString const &,NWindows::NCOM::CPropVariant &)+27p
UNDEF:0000E860 ; _DWORD __thiscall NWindows::NCOM::CPropVariant::CPropVariant(NWindows::NCOM::CPropVariant *__hidden this, const struct NWindows::NCOM::CPropVariant *)
UNDEF:0000E860                 extrn ??0CPropVariant@NCOM@NWindows@@QAE@ABV012@@Z:near
UNDEF:0000E860                                         ; CODE XREF: CProp::CProp(CProp const &)+31p
UNDEF:0000E864 ; public: virtual void * __thiscall CBenchmarkOutStream::`scalar deleting destructor'(unsigned int)
UNDEF:0000E864                 extrn ??_GCBenchmarkOutStream@@UAEPAXI@Z_0:near
UNDEF:0000E868 ; public: virtual void * __thiscall CBenchmarkOutStream::`vector deleting destructor'(unsigned int)
UNDEF:0000E868                 extrn ??_ECBenchmarkOutStream@@UAEPAXI@Z:near ; weak
UNDEF:0000E868                                         ; CODE XREF: [thunk]:CBenchmarkOutStream::`vector deleting destructor'`adjustor{4}' (uint)+3j
UNDEF:0000E868
UNDEF:0000E868