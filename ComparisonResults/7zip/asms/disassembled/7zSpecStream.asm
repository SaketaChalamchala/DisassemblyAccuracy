.text:00000000 ;
.text:00000000 ; +-------------------------------------------------------------------------+
.text:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.text:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.text:00000000 ; |                      License info: 48-3677-7074-51                      |
.text:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.text:00000000 ; +-------------------------------------------------------------------------+
.text:00000000 ;
.text:00000000 ; Input MD5   : F51C64CEE193041B410F274B6153341C
.text:00000000 ; Input CRC32 : 230A3437
.text:00000000
.text:00000000 ; File Name   : C:\workspace\7z1505-src\CPP\7zip\Bundles\Alone\Debug\7zSpecStream.obj
.text:00000000 ; Format      : COFF (X386MAGIC)
.text:00000000 ; includelib "uuid.lib"
.text:00000000 ; includelib "MSVCRTD"
.text:00000000 ; includelib "OLDNAMES"
.text:00000000
.text:00000000                 .686p
.text:00000000                 .mmx
.text:00000000                 .model flat
.text:00000000
.text:00000000 ; ===========================================================================
.text:00000000
.text:00000000 ; Segment type: Pure code
.text:00000000 ; Segment permissions: Read/Execute
.text:00000000 _text           segment para public 'CODE' use32
.text:00000000                 assume cs:_text
.text:00000000                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000000
.text:00000000 ; =============== S U B R O U T I N E =======================================
.text:00000000
.text:00000000 ; Attributes: bp-based frame
.text:00000000
.text:00000000 ; __int32 __stdcall CSequentialInStreamSizeCount2::Read(CSequentialInStreamSizeCount2 *this, void *, unsigned int, unsigned int *)
.text:00000000                 public ?Read@CSequentialInStreamSizeCount2@@UAGJPAXIPAI@Z
.text:00000000 ?Read@CSequentialInStreamSizeCount2@@UAGJPAXIPAI@Z proc near
.text:00000000
.text:00000000 var_14          = dword ptr -14h
.text:00000000 var_10          = dword ptr -10h
.text:00000000 var_C           = dword ptr -0Ch
.text:00000000 var_8           = dword ptr -8
.text:00000000 var_4           = dword ptr -4
.text:00000000 this            = dword ptr  8
.text:00000000 arg_4           = dword ptr  0Ch
.text:00000000 arg_8           = dword ptr  10h
.text:00000000 arg_C           = dword ptr  14h
.text:00000000
.text:00000000                 push    ebp
.text:00000001                 mov     ebp, esp
.text:00000003                 sub     esp, 14h
.text:00000006                 push    esi
.text:00000007                 mov     eax, 0CCCCCCCCh
.text:0000000C                 mov     [ebp+var_14], eax
.text:0000000F                 mov     [ebp+var_10], eax
.text:00000012                 mov     [ebp+var_C], eax
.text:00000015                 mov     [ebp+var_8], eax
.text:00000018                 mov     [ebp+var_4], eax
.text:0000001B                 mov     ecx, [ebp+this]
.text:0000001E                 add     ecx, 0Ch
.text:00000021                 call    ??C?$CMyComPtr@UISequentialInStream@@@@QBEPAUISequentialInStream@@XZ ; CMyComPtr<ISequentialInStream>::operator->(void)
.text:00000026                 mov     [ebp+var_14], eax
.text:00000029                 mov     esi, esp
.text:0000002B                 lea     eax, [ebp+var_8]
.text:0000002E                 push    eax
.text:0000002F                 mov     ecx, [ebp+arg_8]
.text:00000032                 push    ecx
.text:00000033                 mov     edx, [ebp+arg_4]
.text:00000036                 push    edx
.text:00000037                 mov     eax, [ebp+var_14]
.text:0000003A                 push    eax
.text:0000003B                 mov     ecx, [ebp+var_14]
.text:0000003E                 mov     edx, [ecx]
.text:00000040                 mov     eax, [edx+0Ch]
.text:00000043                 call    eax
.text:00000045                 cmp     esi, esp
.text:00000047                 call    __RTC_CheckEsp
.text:0000004C                 mov     [ebp+var_10], eax
.text:0000004F                 mov     ecx, [ebp+var_8]
.text:00000052                 xor     edx, edx
.text:00000054                 mov     eax, [ebp+this]
.text:00000057                 add     ecx, [eax+18h]
.text:0000005A                 adc     edx, [eax+1Ch]
.text:0000005D                 mov     eax, [ebp+this]
.text:00000060                 mov     [eax+18h], ecx
.text:00000063                 mov     [eax+1Ch], edx
.text:00000066                 cmp     [ebp+arg_C], 0
.text:0000006A                 jz      short loc_74
.text:0000006C                 mov     ecx, [ebp+arg_C]
.text:0000006F                 mov     edx, [ebp+var_8]
.text:00000072                 mov     [ecx], edx
.text:00000074
.text:00000074 loc_74:                                 ; CODE XREF: CSequentialInStreamSizeCount2::Read(void *,uint,uint *)+6Aj
.text:00000074                 mov     eax, [ebp+var_10]
.text:00000077                 push    edx
.text:00000078                 mov     ecx, ebp
.text:0000007A                 push    eax
.text:0000007B                 lea     edx, $LN6
.text:00000081                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00000086                 pop     eax
.text:00000087                 pop     edx
.text:00000088                 pop     esi
.text:00000089                 add     esp, 14h
.text:0000008C                 cmp     ebp, esp
.text:0000008E                 call    __RTC_CheckEsp
.text:00000093                 mov     esp, ebp
.text:00000095                 pop     ebp
.text:00000096                 retn    10h
.text:00000096 ?Read@CSequentialInStreamSizeCount2@@UAGJPAXIPAI@Z endp
.text:00000096
.text:00000096 ; ---------------------------------------------------------------------------
.text:00000099                 align 4
.text:0000009C $LN6            dd 1                    ; DATA XREF: CSequentialInStreamSizeCount2::Read(void *,uint,uint *)+7Bo
.text:000000A0                 dd offset $LN5
.text:000000A4 $LN5            dd 0FFFFFFF8h, 4        ; DATA XREF: .text:000000A0o
.text:000000AC                 dd offset $LN4          ; "realProcessedSize"
.text:000000B0 $LN4            db 'realProcessedSize',0 ; DATA XREF: .text:000000ACo
.text:000000C2                 align 10h
.text:000000D0
.text:000000D0 ; =============== S U B R O U T I N E =======================================
.text:000000D0
.text:000000D0 ; Attributes: bp-based frame
.text:000000D0
.text:000000D0 ; __int32 __stdcall CSequentialInStreamSizeCount2::GetSubStreamSize(CSequentialInStreamSizeCount2 *this, unsigned __int64, unsigned __int64 *)
.text:000000D0                 public ?GetSubStreamSize@CSequentialInStreamSizeCount2@@UAGJ_KPA_K@Z
.text:000000D0 ?GetSubStreamSize@CSequentialInStreamSizeCount2@@UAGJ_KPA_K@Z proc near
.text:000000D0
.text:000000D0 var_4           = dword ptr -4
.text:000000D0 this            = dword ptr  8
.text:000000D0 arg_4           = qword ptr  0Ch
.text:000000D0 arg_C           = dword ptr  14h
.text:000000D0
.text:000000D0                 push    ebp
.text:000000D1                 mov     ebp, esp
.text:000000D3                 push    ecx
.text:000000D4                 push    esi
.text:000000D5                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000000DC                 mov     ecx, [ebp+this]
.text:000000DF                 add     ecx, 0Ch
.text:000000E2                 call    ??7?$CMyComPtr@UICompressGetSubStreamSize@@@@QBE_NXZ ; CMyComPtr<ICompressGetSubStreamSize>::operator!(void)
.text:000000E7                 movzx   eax, al
.text:000000EA                 test    eax, eax
.text:000000EC                 jz      short loc_F5
.text:000000EE                 mov     eax, 80004001h
.text:000000F3                 jmp     short loc_126
.text:000000F5 ; ---------------------------------------------------------------------------
.text:000000F5
.text:000000F5 loc_F5:                                 ; CODE XREF: CSequentialInStreamSizeCount2::GetSubStreamSize(unsigned __int64,unsigned __int64 *)+1Cj
.text:000000F5                 mov     ecx, [ebp+this]
.text:000000F8                 add     ecx, 0Ch
.text:000000FB                 call    ??C?$CMyComPtr@UICompressGetSubStreamSize@@@@QBEPAUICompressGetSubStreamSize@@XZ ; CMyComPtr<ICompressGetSubStreamSize>::operator->(void)
.text:00000100                 mov     [ebp+var_4], eax
.text:00000103                 mov     esi, esp
.text:00000105                 mov     ecx, [ebp+arg_C]
.text:00000108                 push    ecx
.text:00000109                 mov     edx, dword ptr [ebp+arg_4+4]
.text:0000010C                 push    edx
.text:0000010D                 mov     eax, dword ptr [ebp+arg_4]
.text:00000110                 push    eax
.text:00000111                 mov     ecx, [ebp+var_4]
.text:00000114                 push    ecx
.text:00000115                 mov     edx, [ebp+var_4]
.text:00000118                 mov     eax, [edx]
.text:0000011A                 mov     ecx, [eax+0Ch]
.text:0000011D                 call    ecx
.text:0000011F                 cmp     esi, esp
.text:00000121                 call    __RTC_CheckEsp
.text:00000126
.text:00000126 loc_126:                                ; CODE XREF: CSequentialInStreamSizeCount2::GetSubStreamSize(unsigned __int64,unsigned __int64 *)+23j
.text:00000126                 pop     esi
.text:00000127                 add     esp, 4
.text:0000012A                 cmp     ebp, esp
.text:0000012C                 call    __RTC_CheckEsp
.text:00000131                 mov     esp, ebp
.text:00000133                 pop     ebp
.text:00000134                 retn    10h
.text:00000134 ?GetSubStreamSize@CSequentialInStreamSizeCount2@@UAGJ_KPA_K@Z endp
.text:00000134
.text:00000134 ; ---------------------------------------------------------------------------
.text:00000137                 align 4
.text:00000137 _text           ends
.text:00000137
.rtc$TMZ:00000138 ; ===========================================================================
.rtc$TMZ:00000138
.rtc$TMZ:00000138 ; Segment type: Pure data
.rtc$TMZ:00000138 ; Segment permissions: Read
.rtc$TMZ:00000138 _rtc$TMZ        segment dword public 'DATA' use32
.rtc$TMZ:00000138                 assume cs:_rtc$TMZ
.rtc$TMZ:00000138                 ;org 138h
.rtc$TMZ:00000138 ; COMDAT (pick any)
.rtc$TMZ:00000138 __RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
.rtc$TMZ:00000138 _rtc$TMZ        ends
.rtc$TMZ:00000138
.rtc$IMZ:0000013C ; ===========================================================================
.rtc$IMZ:0000013C
.rtc$IMZ:0000013C ; Segment type: Pure data
.rtc$IMZ:0000013C ; Segment permissions: Read
.rtc$IMZ:0000013C _rtc$IMZ        segment dword public 'DATA' use32
.rtc$IMZ:0000013C                 assume cs:_rtc$IMZ
.rtc$IMZ:0000013C                 ;org 13Ch
.rtc$IMZ:0000013C ; COMDAT (pick any)
.rtc$IMZ:0000013C __RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
.rtc$IMZ:0000013C _rtc$IMZ        ends
.rtc$IMZ:0000013C
.text:00000140 ; ===========================================================================
.text:00000140
.text:00000140 ; Segment type: Pure code
.text:00000140 ; Segment permissions: Read/Execute
.text:00000140 _text           segment para public 'CODE' use32
.text:00000140                 assume cs:_text
.text:00000140                 ;org 140h
.text:00000140 ; COMDAT (pick any)
.text:00000140                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000140
.text:00000140 ; =============== S U B R O U T I N E =======================================
.text:00000140
.text:00000140 ; Attributes: bp-based frame
.text:00000140
.text:00000140 ; public: struct ISequentialInStream * __thiscall CMyComPtr<struct ISequentialInStream>::operator->(void)const
.text:00000140                 public ??C?$CMyComPtr@UISequentialInStream@@@@QBEPAUISequentialInStream@@XZ
.text:00000140 ??C?$CMyComPtr@UISequentialInStream@@@@QBEPAUISequentialInStream@@XZ proc near
.text:00000140                                         ; CODE XREF: CSequentialInStreamSizeCount2::Read(void *,uint,uint *)+21p
.text:00000140
.text:00000140 var_4           = dword ptr -4
.text:00000140
.text:00000140                 push    ebp
.text:00000141                 mov     ebp, esp
.text:00000143                 push    ecx
.text:00000144                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000014B                 mov     [ebp+var_4], ecx
.text:0000014E                 mov     eax, [ebp+var_4]
.text:00000151                 mov     eax, [eax]
.text:00000153                 mov     esp, ebp
.text:00000155                 pop     ebp
.text:00000156                 retn
.text:00000156 ??C?$CMyComPtr@UISequentialInStream@@@@QBEPAUISequentialInStream@@XZ endp
.text:00000156
.text:00000156 ; ---------------------------------------------------------------------------
.text:00000157                 align 4
.text:00000157 _text           ends
.text:00000157
.text:00000158 ; ===========================================================================
.text:00000158
.text:00000158 ; Segment type: Pure code
.text:00000158 ; Segment permissions: Read/Execute
.text:00000158 _text           segment para public 'CODE' use32
.text:00000158                 assume cs:_text
.text:00000158                 ;org 158h
.text:00000158 ; COMDAT (pick any)
.text:00000158                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000158
.text:00000158 ; =============== S U B R O U T I N E =======================================
.text:00000158
.text:00000158 ; Attributes: bp-based frame
.text:00000158
.text:00000158 ; public: struct ICompressGetSubStreamSize * __thiscall CMyComPtr<struct ICompressGetSubStreamSize>::operator->(void)const
.text:00000158                 public ??C?$CMyComPtr@UICompressGetSubStreamSize@@@@QBEPAUICompressGetSubStreamSize@@XZ
.text:00000158 ??C?$CMyComPtr@UICompressGetSubStreamSize@@@@QBEPAUICompressGetSubStreamSize@@XZ proc near
.text:00000158                                         ; CODE XREF: CSequentialInStreamSizeCount2::GetSubStreamSize(unsigned __int64,unsigned __int64 *)+2Bp
.text:00000158
.text:00000158 var_4           = dword ptr -4
.text:00000158
.text:00000158                 push    ebp
.text:00000159                 mov     ebp, esp
.text:0000015B                 push    ecx
.text:0000015C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000163                 mov     [ebp+var_4], ecx
.text:00000166                 mov     eax, [ebp+var_4]
.text:00000169                 mov     eax, [eax]
.text:0000016B                 mov     esp, ebp
.text:0000016D                 pop     ebp
.text:0000016E                 retn
.text:0000016E ??C?$CMyComPtr@UICompressGetSubStreamSize@@@@QBEPAUICompressGetSubStreamSize@@XZ endp
.text:0000016E
.text:0000016E ; ---------------------------------------------------------------------------
.text:0000016F                 align 10h
.text:0000016F _text           ends
.text:0000016F
.text:00000170 ; ===========================================================================
.text:00000170
.text:00000170 ; Segment type: Pure code
.text:00000170 ; Segment permissions: Read/Execute
.text:00000170 _text           segment para public 'CODE' use32
.text:00000170                 assume cs:_text
.text:00000170                 ;org 170h
.text:00000170 ; COMDAT (pick any)
.text:00000170                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000170
.text:00000170 ; =============== S U B R O U T I N E =======================================
.text:00000170
.text:00000170 ; Attributes: bp-based frame
.text:00000170
.text:00000170 ; public: bool __thiscall CMyComPtr<struct ICompressGetSubStreamSize>::operator!(void)const
.text:00000170                 public ??7?$CMyComPtr@UICompressGetSubStreamSize@@@@QBE_NXZ
.text:00000170 ??7?$CMyComPtr@UICompressGetSubStreamSize@@@@QBE_NXZ proc near
.text:00000170                                         ; CODE XREF: CSequentialInStreamSizeCount2::GetSubStreamSize(unsigned __int64,unsigned __int64 *)+12p
.text:00000170
.text:00000170 var_4           = dword ptr -4
.text:00000170
.text:00000170                 push    ebp
.text:00000171                 mov     ebp, esp
.text:00000173                 push    ecx
.text:00000174                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000017B                 mov     [ebp+var_4], ecx
.text:0000017E                 mov     eax, [ebp+var_4]
.text:00000181                 xor     ecx, ecx
.text:00000183                 cmp     dword ptr [eax], 0
.text:00000186                 setz    cl
.text:00000189                 mov     al, cl
.text:0000018B                 mov     esp, ebp
.text:0000018D                 pop     ebp
.text:0000018E                 retn
.text:0000018E ??7?$CMyComPtr@UICompressGetSubStreamSize@@@@QBE_NXZ endp
.text:0000018E
.text:0000018E _text           ends
.text:0000018E
UNDEF:00000190 ; ===========================================================================
UNDEF:00000190
UNDEF:00000190 ; Segment type: Externs
UNDEF:00000190 ; UNDEF
UNDEF:00000190 ; __fastcall _RTC_CheckStackVars(x, x)
UNDEF:00000190                 extrn @_RTC_CheckStackVars@8:near
UNDEF:00000190                                         ; CODE XREF: CSequentialInStreamSizeCount2::Read(void *,uint,uint *)+81p
UNDEF:00000194                 extrn __RTC_CheckEsp:near
UNDEF:00000194                                         ; CODE XREF: CSequentialInStreamSizeCount2::Read(void *,uint,uint *)+47p
UNDEF:00000194                                         ; CSequentialInStreamSizeCount2::Read(void *,uint,uint *)+8Ep ...
UNDEF:00000198                 extrn __RTC_Shutdown:near
UNDEF:00000198                                         ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
UNDEF:0000019C                 extrn __RTC_InitBase:near
UNDEF:0000019C                                         ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
UNDEF:0000019C
UNDEF:0000019C
UNDEF:0000019C                 end