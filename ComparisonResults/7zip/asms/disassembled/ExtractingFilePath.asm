.rdata:00000000 ;
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.rdata:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.rdata:00000000 ; |                      License info: 48-3677-7074-51                      |
.rdata:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ;
.rdata:00000000 ; Input MD5   : A42DFE9C272525007D967B9FF09F0C9B
.rdata:00000000 ; Input CRC32 : A00B3B4D
.rdata:00000000
.rdata:00000000 ; File Name   : C:\workspace\7z1505-src\CPP\7zip\Bundles\Alone\Debug\ExtractingFilePath.obj
.rdata:00000000 ; Format      : COFF (X386MAGIC)
.rdata:00000000 ; includelib "uuid.lib"
.rdata:00000000 ; includelib "MSVCRTD"
.rdata:00000000 ; includelib "OLDNAMES"
.rdata:00000000
.rdata:00000000                 .686p
.rdata:00000000                 .mmx
.rdata:00000000                 .model flat
.rdata:00000000
.rdata:00000000 ; ===========================================================================
.rdata:00000000
.rdata:00000000 ; Segment type: Pure data
.rdata:00000000 ; Segment permissions: Read
.rdata:00000000 _rdata          segment dword public 'DATA' use32
.rdata:00000000                 assume cs:_rdata
.rdata:00000000 ; char _SG67658[]
.rdata:00000000 $SG67658        db ':$DATA',0           ; DATA XREF: Correct_AltStream_Name(UString &)+36o
.rdata:00000007                 align 4
.rdata:00000008 $SG67669        db 'CON',0              ; DATA XREF: .rdata:_g_ReservedNameso
.rdata:0000000C $SG67670        db 'PRN',0              ; DATA XREF: .rdata:00000024o
.rdata:00000010 $SG67671        db 'AUX',0              ; DATA XREF: .rdata:00000028o
.rdata:00000014 $SG67672        db 'NUL',0              ; DATA XREF: .rdata:0000002Co
.rdata:00000018 $SG67673        db 'COM',0              ; DATA XREF: .rdata:00000030o
.rdata:0000001C $SG67674        db 'LPT',0              ; DATA XREF: .rdata:00000034o
.rdata:00000020 _g_ReservedNames dd offset $SG67669     ; DATA XREF: IsSupportedName(UString const &)+39r
.rdata:00000020                                         ; "CON"
.rdata:00000024                 dd offset $SG67670      ; "PRN"
.rdata:00000028                 dd offset $SG67671      ; "AUX"
.rdata:0000002C                 dd offset $SG67672      ; "NUL"
.rdata:00000030                 dd offset $SG67673      ; "COM"
.rdata:00000034                 dd offset $SG67674      ; "LPT"
.rdata:00000038 ; wchar_t _SG67725
.rdata:00000038 $SG67725        dd offset loc_3F        ; DATA XREF: Correct_FsPath(bool,CObjectVector<UString> &,bool)+ACo
.rdata:00000038 _rdata          ends
.rdata:00000038
.text:0000003C ; ===========================================================================
.text:0000003C
.text:0000003C ; Segment type: Pure code
.text:0000003C ; Segment permissions: Read/Execute
.text:0000003C _text           segment para public 'CODE' use32
.text:0000003C                 assume cs:_text
.text:0000003C                 ;org 3Ch
.text:0000003C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000003C
.text:0000003C ; =============== S U B R O U T I N E =======================================
.text:0000003C
.text:0000003C ; Attributes: bp-based frame
.text:0000003C
.text:0000003C ; void __stdcall Correct_AltStream_Name(struct UString *)
.text:0000003C                 public ?Correct_AltStream_Name@@YGXAAVUString@@@Z
.text:0000003C ?Correct_AltStream_Name@@YGXAAVUString@@@Z proc near
.text:0000003C
.text:0000003C var_10          = dword ptr -10h
.text:0000003C var_C           = dword ptr -0Ch
.text:0000003C var_8           = dword ptr -8
.text:0000003C var_4           = dword ptr -4
.text:0000003C arg_0           = dword ptr  8
.text:0000003C
.text:0000003C                 push    ebp
.text:0000003D                 mov     ebp, esp
.text:0000003F
.text:0000003F loc_3F:                                 ; DATA XREF: .rdata:$SG67725o
.text:0000003F                 sub     esp, 10h
.text:00000042                 mov     eax, 0CCCCCCCCh
.text:00000047                 mov     [ebp+var_10], eax
.text:0000004A                 mov     [ebp+var_C], eax
.text:0000004D                 mov     [ebp+var_8], eax
.text:00000050                 mov     [ebp+var_4], eax
.text:00000053                 mov     ecx, [ebp+arg_0] ; this
.text:00000056                 call    ?Len@UString@@QBEIXZ ; UString::Len(void)
.text:0000005B                 mov     [ebp+var_4], eax
.text:0000005E                 mov     [ebp+var_8], 6
.text:00000065                 mov     ecx, [ebp+arg_0] ; this
.text:00000068                 call    ?Len@UString@@QBEIXZ ; UString::Len(void)
.text:0000006D                 cmp     eax, 6
.text:00000070                 jb      short loc_97
.text:00000072                 push    offset $SG67658 ; ":$DATA"
.text:00000077                 push    6               ; unsigned int
.text:00000079                 mov     ecx, [ebp+arg_0] ; this
.text:0000007C                 call    ?RightPtr@UString@@QBEPB_WI@Z ; UString::RightPtr(uint)
.text:00000081                 push    eax             ; wchar_t *
.text:00000082                 call    ?StringsAreEqualNoCase_Ascii@@YG_NPB_WPBD@Z ; StringsAreEqualNoCase_Ascii(wchar_t const *,char const *)
.text:00000087                 movzx   eax, al
.text:0000008A                 test    eax, eax
.text:0000008C                 jz      short loc_97
.text:0000008E                 mov     ecx, [ebp+var_4]
.text:00000091                 sub     ecx, 6
.text:00000094                 mov     [ebp+var_4], ecx
.text:00000097
.text:00000097 loc_97:                                 ; CODE XREF: Correct_AltStream_Name(UString &)+34j
.text:00000097                                         ; Correct_AltStream_Name(UString &)+50j
.text:00000097                 mov     [ebp+var_C], 0
.text:0000009E                 jmp     short loc_A9
.text:000000A0 ; ---------------------------------------------------------------------------
.text:000000A0
.text:000000A0 loc_A0:                                 ; CODE XREF: Correct_AltStream_Name(UString &):loc_EDj
.text:000000A0                 mov     edx, [ebp+var_C]
.text:000000A3                 add     edx, 1
.text:000000A6                 mov     [ebp+var_C], edx
.text:000000A9
.text:000000A9 loc_A9:                                 ; CODE XREF: Correct_AltStream_Name(UString &)+62j
.text:000000A9                 mov     eax, [ebp+var_C]
.text:000000AC                 cmp     eax, [ebp+var_4]
.text:000000AF                 jnb     short loc_EF
.text:000000B1                 mov     ecx, [ebp+arg_0]
.text:000000B4                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000000B9                 mov     ecx, [ebp+var_C]
.text:000000BC                 mov     dx, [eax+ecx*2]
.text:000000C0                 mov     word ptr [ebp+var_10], dx
.text:000000C4                 movzx   eax, word ptr [ebp+var_10]
.text:000000C8                 cmp     eax, 3Ah ; ':'
.text:000000CB                 jz      short loc_DF
.text:000000CD                 movzx   ecx, word ptr [ebp+var_10]
.text:000000D1                 cmp     ecx, 5Ch ; '\'
.text:000000D4                 jz      short loc_DF
.text:000000D6                 movzx   edx, word ptr [ebp+var_10]
.text:000000DA                 cmp     edx, 2Fh ; '/'
.text:000000DD                 jnz     short loc_ED
.text:000000DF
.text:000000DF loc_DF:                                 ; CODE XREF: Correct_AltStream_Name(UString &)+8Fj
.text:000000DF                                         ; Correct_AltStream_Name(UString &)+98j
.text:000000DF                 push    5Fh ; '_'       ; wchar_t
.text:000000E1                 mov     eax, [ebp+var_C]
.text:000000E4                 push    eax             ; unsigned int
.text:000000E5                 mov     ecx, [ebp+arg_0] ; this
.text:000000E8                 call    ?ReplaceOneCharAtPos@UString@@QAEXI_W@Z ; UString::ReplaceOneCharAtPos(uint,wchar_t)
.text:000000ED
.text:000000ED loc_ED:                                 ; CODE XREF: Correct_AltStream_Name(UString &)+A1j
.text:000000ED                 jmp     short loc_A0
.text:000000EF ; ---------------------------------------------------------------------------
.text:000000EF
.text:000000EF loc_EF:                                 ; CODE XREF: Correct_AltStream_Name(UString &)+73j
.text:000000EF                 mov     ecx, [ebp+arg_0] ; this
.text:000000F2                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:000000F7                 movzx   ecx, al
.text:000000FA                 test    ecx, ecx
.text:000000FC                 jz      short loc_108
.text:000000FE                 push    5Fh ; '_'
.text:00000100                 mov     ecx, [ebp+arg_0]
.text:00000103                 call    ??4UString@@QAEAAV0@_W@Z ; UString::operator=(wchar_t)
.text:00000108
.text:00000108 loc_108:                                ; CODE XREF: Correct_AltStream_Name(UString &)+C0j
.text:00000108                 add     esp, 10h
.text:0000010B                 cmp     ebp, esp
.text:0000010D                 call    __RTC_CheckEsp
.text:00000112                 mov     esp, ebp
.text:00000114                 pop     ebp
.text:00000115                 retn    4
.text:00000115 ?Correct_AltStream_Name@@YGXAAVUString@@@Z endp
.text:00000115
.text:00000115 ; ---------------------------------------------------------------------------
.text:00000118                 db 4 dup(0CCh)
.text:0000011C
.text:0000011C ; =============== S U B R O U T I N E =======================================
.text:0000011C
.text:0000011C ; Attributes: bp-based frame
.text:0000011C
.text:0000011C ; class UString __stdcall Get_Correct_FsFile_Name(class UString const &)
.text:0000011C                 public ?Get_Correct_FsFile_Name@@YG?AVUString@@ABV1@@Z
.text:0000011C ?Get_Correct_FsFile_Name@@YG?AVUString@@ABV1@@Z proc near
.text:0000011C
.text:0000011C var_24          = dword ptr -24h
.text:0000011C var_20          = dword ptr -20h
.text:0000011C var_1C          = dword ptr -1Ch
.text:0000011C var_18          = dword ptr -18h
.text:0000011C var_14          = dword ptr -14h
.text:0000011C var_10          = dword ptr -10h
.text:0000011C var_C           = dword ptr -0Ch
.text:0000011C var_4           = dword ptr -4
.text:0000011C arg_0           = dword ptr  8
.text:0000011C arg_4           = dword ptr  0Ch
.text:0000011C
.text:0000011C                 push    ebp
.text:0000011D                 mov     ebp, esp
.text:0000011F                 push    0FFFFFFFFh
.text:00000121                 push    offset __ehhandler$?Get_Correct_FsFile_Name@@YG?AVUString@@ABV1@@Z
.text:00000126                 mov     eax, large fs:0
.text:0000012C                 push    eax
.text:0000012D                 sub     esp, 18h
.text:00000130                 mov     eax, 0CCCCCCCCh
.text:00000135                 mov     [ebp+var_24], eax
.text:00000138                 mov     [ebp+var_20], eax
.text:0000013B                 mov     [ebp+var_1C], eax
.text:0000013E                 mov     [ebp+var_18], eax
.text:00000141                 mov     [ebp+var_14], eax
.text:00000144                 mov     [ebp+var_10], eax
.text:00000147                 mov     eax, dword ptr ds:___security_cookie
.text:0000014C                 xor     eax, ebp
.text:0000014E                 push    eax
.text:0000014F                 lea     eax, [ebp+var_C]
.text:00000152                 mov     large fs:0, eax
.text:00000158                 mov     [ebp+var_24], 0
.text:0000015F                 mov     eax, [ebp+arg_4]
.text:00000162                 push    eax
.text:00000163                 lea     ecx, [ebp+var_1C]
.text:00000166                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:0000016B                 mov     [ebp+var_4], 1
.text:00000172                 lea     ecx, [ebp+var_1C]
.text:00000175                 push    ecx             ; UString *
.text:00000176                 call    ?Correct_PathPart@@YGXAAVUString@@@Z ; Correct_PathPart(UString &)
.text:0000017B                 lea     edx, [ebp+var_1C]
.text:0000017E                 push    edx             ; UString *
.text:0000017F                 call    ?CorrectUnsupportedName@@YGXAAVUString@@@Z ; CorrectUnsupportedName(UString &)
.text:00000184                 lea     ecx, [ebp+var_1C] ; this
.text:00000187                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:0000018C                 movzx   eax, al
.text:0000018F                 test    eax, eax
.text:00000191                 jz      short loc_19D
.text:00000193                 push    5Fh ; '_'
.text:00000195                 lea     ecx, [ebp+var_1C]
.text:00000198                 call    ??4UString@@QAEAAV0@_W@Z ; UString::operator=(wchar_t)
.text:0000019D
.text:0000019D loc_19D:                                ; CODE XREF: Get_Correct_FsFile_Name(UString const &)+75j
.text:0000019D                 lea     ecx, [ebp+var_1C]
.text:000001A0                 push    ecx
.text:000001A1                 mov     ecx, [ebp+arg_0]
.text:000001A4                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:000001A9                 mov     edx, [ebp+var_24]
.text:000001AC                 or      edx, 1
.text:000001AF                 mov     [ebp+var_24], edx
.text:000001B2                 mov     byte ptr [ebp+var_4], 0
.text:000001B6                 lea     ecx, [ebp+var_1C] ; this
.text:000001B9                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000001BE                 mov     eax, [ebp+arg_0]
.text:000001C1                 push    edx
.text:000001C2                 mov     ecx, ebp
.text:000001C4                 push    eax
.text:000001C5                 lea     edx, $LN10
.text:000001CB                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:000001D0                 pop     eax
.text:000001D1                 pop     edx
.text:000001D2                 mov     ecx, [ebp+var_C]
.text:000001D5                 mov     large fs:0, ecx
.text:000001DC                 pop     ecx
.text:000001DD                 add     esp, 24h
.text:000001E0                 cmp     ebp, esp
.text:000001E2                 call    __RTC_CheckEsp
.text:000001E7                 mov     esp, ebp
.text:000001E9                 pop     ebp
.text:000001EA                 retn    8
.text:000001EA ?Get_Correct_FsFile_Name@@YG?AVUString@@ABV1@@Z endp
.text:000001EA
.text:000001EA ; ---------------------------------------------------------------------------
.text:000001ED                 align 10h
.text:000001F0 $LN10           dd 1                    ; DATA XREF: Get_Correct_FsFile_Name(UString const &)+A9o
.text:000001F4                 dd offset $LN9
.text:000001F8 $LN9            dd 0FFFFFFE4h, 0Ch      ; DATA XREF: .text:000001F4o
.text:00000200                 dd offset $LN7
.text:00000204 $LN7            dd 736572h, 0CCCCCCCCh  ; DATA XREF: .text:00000200o
.text:0000020C
.text:0000020C ; =============== S U B R O U T I N E =======================================
.text:0000020C
.text:0000020C ; Attributes: bp-based frame
.text:0000020C
.text:0000020C ; int __stdcall CorrectUnsupportedName(UString *)
.text:0000020C ?CorrectUnsupportedName@@YGXAAVUString@@@Z proc near
.text:0000020C                                         ; CODE XREF: Get_Correct_FsFile_Name(UString const &)+63p
.text:0000020C                                         ; Correct_FsPath(bool,CObjectVector<UString> &,bool)+1FAp
.text:0000020C
.text:0000020C arg_0           = dword ptr  8
.text:0000020C
.text:0000020C                 push    ebp
.text:0000020D                 mov     ebp, esp
.text:0000020F                 mov     eax, [ebp+arg_0]
.text:00000212                 push    eax             ; UString *
.text:00000213                 call    ?IsSupportedName@@YG_NABVUString@@@Z ; IsSupportedName(UString const &)
.text:00000218                 movzx   ecx, al
.text:0000021B                 test    ecx, ecx
.text:0000021D                 jnz     short loc_229
.text:0000021F                 push    5Fh ; '_'       ; wchar_t
.text:00000221                 mov     ecx, [ebp+arg_0] ; this
.text:00000224                 call    ?InsertAtFront@UString@@QAEX_W@Z ; UString::InsertAtFront(wchar_t)
.text:00000229
.text:00000229 loc_229:                                ; CODE XREF: CorrectUnsupportedName(UString &)+11j
.text:00000229                 cmp     ebp, esp
.text:0000022B                 call    __RTC_CheckEsp
.text:00000230                 pop     ebp
.text:00000231                 retn    4
.text:00000231 ?CorrectUnsupportedName@@YGXAAVUString@@@Z endp
.text:00000231
.text:00000231 ; ---------------------------------------------------------------------------
.text:00000234                 db 8 dup(0CCh)
.text:0000023C
.text:0000023C ; =============== S U B R O U T I N E =======================================
.text:0000023C
.text:0000023C ; Attributes: bp-based frame
.text:0000023C
.text:0000023C ; int __stdcall IsSupportedName(UString *)
.text:0000023C ?IsSupportedName@@YG_NABVUString@@@Z proc near
.text:0000023C                                         ; CODE XREF: CorrectUnsupportedName(UString &)+7p
.text:0000023C
.text:0000023C var_14          = dword ptr -14h
.text:0000023C var_10          = dword ptr -10h
.text:0000023C var_C           = dword ptr -0Ch
.text:0000023C var_8           = dword ptr -8
.text:0000023C var_4           = dword ptr -4
.text:0000023C arg_0           = dword ptr  8
.text:0000023C
.text:0000023C                 push    ebp
.text:0000023D                 mov     ebp, esp
.text:0000023F                 sub     esp, 14h
.text:00000242                 mov     eax, 0CCCCCCCCh
.text:00000247                 mov     [ebp+var_14], eax
.text:0000024A                 mov     [ebp+var_10], eax
.text:0000024D                 mov     [ebp+var_C], eax
.text:00000250                 mov     [ebp+var_8], eax
.text:00000253                 mov     [ebp+var_4], eax
.text:00000256                 mov     [ebp+var_4], 0
.text:0000025D                 jmp     short loc_268
.text:0000025F ; ---------------------------------------------------------------------------
.text:0000025F
.text:0000025F loc_25F:                                ; CODE XREF: IsSupportedName(UString const &)+5Cj
.text:0000025F                                         ; IsSupportedName(UString const &)+71j ...
.text:0000025F                 mov     eax, [ebp+var_4]
.text:00000262                 add     eax, 1
.text:00000265                 mov     [ebp+var_4], eax
.text:00000268
.text:00000268 loc_268:                                ; CODE XREF: IsSupportedName(UString const &)+21j
.text:00000268                 cmp     [ebp+var_4], 6
.text:0000026C                 jnb     loc_328
.text:00000272                 mov     ecx, [ebp+var_4]
.text:00000275                 mov     edx, _g_ReservedNames[ecx*4]
.text:0000027C                 mov     [ebp+var_8], edx
.text:0000027F                 mov     eax, [ebp+var_8]
.text:00000282                 push    eax             ; char *
.text:00000283                 call    ?MyStringLen@@YGIPBD@Z ; MyStringLen(char const *)
.text:00000288                 mov     [ebp+var_C], eax
.text:0000028B                 mov     ecx, [ebp+arg_0] ; this
.text:0000028E                 call    ?Len@UString@@QBEIXZ ; UString::Len(void)
.text:00000293                 cmp     eax, [ebp+var_C]
.text:00000296                 jnb     short loc_29A
.text:00000298                 jmp     short loc_25F
.text:0000029A ; ---------------------------------------------------------------------------
.text:0000029A
.text:0000029A loc_29A:                                ; CODE XREF: IsSupportedName(UString const &)+5Aj
.text:0000029A                 mov     ecx, [ebp+var_8]
.text:0000029D                 push    ecx             ; char *
.text:0000029E                 mov     ecx, [ebp+arg_0] ; this
.text:000002A1                 call    ?IsPrefixedBy_Ascii_NoCase@UString@@QBE_NPBD@Z ; UString::IsPrefixedBy_Ascii_NoCase(char const *)
.text:000002A6                 movzx   edx, al
.text:000002A9                 test    edx, edx
.text:000002AB                 jnz     short loc_2AF
.text:000002AD                 jmp     short loc_25F
.text:000002AF ; ---------------------------------------------------------------------------
.text:000002AF
.text:000002AF loc_2AF:                                ; CODE XREF: IsSupportedName(UString const &)+6Fj
.text:000002AF                 cmp     [ebp+var_4], 4
.text:000002B3                 jb      short loc_2E5
.text:000002B5                 mov     ecx, [ebp+arg_0]
.text:000002B8                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000002BD                 mov     ecx, [ebp+var_C]
.text:000002C0                 mov     dx, [eax+ecx*2]
.text:000002C4                 mov     word ptr [ebp+var_10], dx
.text:000002C8                 movzx   eax, word ptr [ebp+var_10]
.text:000002CC                 cmp     eax, 30h ; '0'
.text:000002CF                 jl      short loc_2DA
.text:000002D1                 movzx   ecx, word ptr [ebp+var_10]
.text:000002D5                 cmp     ecx, 39h ; '9'
.text:000002D8                 jle     short loc_2DC
.text:000002DA
.text:000002DA loc_2DA:                                ; CODE XREF: IsSupportedName(UString const &)+93j
.text:000002DA                 jmp     short loc_25F
.text:000002DC ; ---------------------------------------------------------------------------
.text:000002DC
.text:000002DC loc_2DC:                                ; CODE XREF: IsSupportedName(UString const &)+9Cj
.text:000002DC                 mov     edx, [ebp+var_C]
.text:000002DF                 add     edx, 1
.text:000002E2                 mov     [ebp+var_C], edx
.text:000002E5
.text:000002E5 loc_2E5:                                ; CODE XREF: IsSupportedName(UString const &)+77j
.text:000002E5                                         ; IsSupportedName(UString const &):loc_321j
.text:000002E5                 mov     ecx, [ebp+arg_0]
.text:000002E8                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000002ED                 mov     ecx, [ebp+var_C]
.text:000002F0                 mov     dx, [eax+ecx*2]
.text:000002F4                 mov     word ptr [ebp+var_14], dx
.text:000002F8                 mov     eax, [ebp+var_C]
.text:000002FB                 add     eax, 1
.text:000002FE                 mov     [ebp+var_C], eax
.text:00000301                 movzx   ecx, word ptr [ebp+var_14]
.text:00000305                 test    ecx, ecx
.text:00000307                 jz      short loc_312
.text:00000309                 movzx   edx, word ptr [ebp+var_14]
.text:0000030D                 cmp     edx, 2Eh ; '.'
.text:00000310                 jnz     short loc_316
.text:00000312
.text:00000312 loc_312:                                ; CODE XREF: IsSupportedName(UString const &)+CBj
.text:00000312                 xor     al, al
.text:00000314                 jmp     short loc_32A
.text:00000316 ; ---------------------------------------------------------------------------
.text:00000316
.text:00000316 loc_316:                                ; CODE XREF: IsSupportedName(UString const &)+D4j
.text:00000316                 movzx   eax, word ptr [ebp+var_14]
.text:0000031A                 cmp     eax, 20h ; ' '
.text:0000031D                 jz      short loc_321
.text:0000031F                 jmp     short loc_323
.text:00000321 ; ---------------------------------------------------------------------------
.text:00000321
.text:00000321 loc_321:                                ; CODE XREF: IsSupportedName(UString const &)+E1j
.text:00000321                 jmp     short loc_2E5
.text:00000323 ; ---------------------------------------------------------------------------
.text:00000323
.text:00000323 loc_323:                                ; CODE XREF: IsSupportedName(UString const &)+E3j
.text:00000323                 jmp     loc_25F
.text:00000328 ; ---------------------------------------------------------------------------
.text:00000328
.text:00000328 loc_328:                                ; CODE XREF: IsSupportedName(UString const &)+30j
.text:00000328                 mov     al, 1
.text:0000032A
.text:0000032A loc_32A:                                ; CODE XREF: IsSupportedName(UString const &)+D8j
.text:0000032A                 add     esp, 14h
.text:0000032D                 cmp     ebp, esp
.text:0000032F                 call    __RTC_CheckEsp
.text:00000334                 mov     esp, ebp
.text:00000336                 pop     ebp
.text:00000337                 retn    4
.text:00000337 ?IsSupportedName@@YG_NABVUString@@@Z endp
.text:00000337
.text:00000337 ; ---------------------------------------------------------------------------
.text:0000033A                 align 4
.text:0000033C
.text:0000033C ; =============== S U B R O U T I N E =======================================
.text:0000033C
.text:0000033C ; Attributes: bp-based frame
.text:0000033C
.text:0000033C ; int __stdcall Correct_PathPart(UString *)
.text:0000033C ?Correct_PathPart@@YGXAAVUString@@@Z proc near
.text:0000033C                                         ; CODE XREF: Get_Correct_FsFile_Name(UString const &)+5Ap
.text:0000033C                                         ; Correct_FsPath(bool,CObjectVector<UString> &,bool)+1B0p
.text:0000033C
.text:0000033C arg_0           = dword ptr  8
.text:0000033C
.text:0000033C                 push    ebp
.text:0000033D                 mov     ebp, esp
.text:0000033F                 mov     ecx, [ebp+arg_0]
.text:00000342                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00000347                 movzx   eax, word ptr [eax]
.text:0000034A                 cmp     eax, 2Eh ; '.'
.text:0000034D                 jnz     short loc_38A
.text:0000034F                 mov     ecx, [ebp+arg_0]
.text:00000352                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00000357                 movzx   ecx, word ptr [eax+2]
.text:0000035B                 test    ecx, ecx
.text:0000035D                 jz      short loc_380
.text:0000035F                 mov     ecx, [ebp+arg_0]
.text:00000362                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00000367                 movzx   edx, word ptr [eax+2]
.text:0000036B                 cmp     edx, 2Eh ; '.'
.text:0000036E                 jnz     short loc_38A
.text:00000370                 mov     ecx, [ebp+arg_0]
.text:00000373                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00000378                 movzx   eax, word ptr [eax+4]
.text:0000037C                 test    eax, eax
.text:0000037E                 jnz     short loc_38A
.text:00000380
.text:00000380 loc_380:                                ; CODE XREF: Correct_PathPart(UString &)+21j
.text:00000380                 mov     ecx, [ebp+arg_0] ; this
.text:00000383                 call    ?Empty@UString@@QAEXXZ ; UString::Empty(void)
.text:00000388                 jmp     short loc_393
.text:0000038A ; ---------------------------------------------------------------------------
.text:0000038A
.text:0000038A loc_38A:                                ; CODE XREF: Correct_PathPart(UString &)+11j
.text:0000038A                                         ; Correct_PathPart(UString &)+32j ...
.text:0000038A                 mov     ecx, [ebp+arg_0]
.text:0000038D                 push    ecx             ; UString *
.text:0000038E                 call    ?ReplaceIncorrectChars@@YGXAAVUString@@@Z ; ReplaceIncorrectChars(UString &)
.text:00000393
.text:00000393 loc_393:                                ; CODE XREF: Correct_PathPart(UString &)+4Cj
.text:00000393                 cmp     ebp, esp
.text:00000395                 call    __RTC_CheckEsp
.text:0000039A                 pop     ebp
.text:0000039B                 retn    4
.text:0000039B ?Correct_PathPart@@YGXAAVUString@@@Z endp
.text:0000039B
.text:0000039B ; ---------------------------------------------------------------------------
.text:0000039E                 db 0Eh dup(0CCh)
.text:000003AC
.text:000003AC ; =============== S U B R O U T I N E =======================================
.text:000003AC
.text:000003AC ; Attributes: bp-based frame
.text:000003AC
.text:000003AC ; int __stdcall ReplaceIncorrectChars(UString *)
.text:000003AC ?ReplaceIncorrectChars@@YGXAAVUString@@@Z proc near
.text:000003AC                                         ; CODE XREF: Correct_PathPart(UString &)+52p
.text:000003AC
.text:000003AC var_10          = dword ptr -10h
.text:000003AC var_C           = dword ptr -0Ch
.text:000003AC var_8           = dword ptr -8
.text:000003AC var_4           = dword ptr -4
.text:000003AC arg_0           = dword ptr  8
.text:000003AC
.text:000003AC                 push    ebp
.text:000003AD                 mov     ebp, esp
.text:000003AF                 sub     esp, 10h
.text:000003B2                 mov     eax, 0CCCCCCCCh
.text:000003B7                 mov     [ebp+var_10], eax
.text:000003BA                 mov     [ebp+var_C], eax
.text:000003BD                 mov     [ebp+var_8], eax
.text:000003C0                 mov     [ebp+var_4], eax
.text:000003C3                 mov     [ebp+var_4], 0
.text:000003CA                 jmp     short loc_3D5
.text:000003CC ; ---------------------------------------------------------------------------
.text:000003CC
.text:000003CC loc_3CC:                                ; CODE XREF: ReplaceIncorrectChars(UString &):loc_461j
.text:000003CC                 mov     eax, [ebp+var_4]
.text:000003CF                 add     eax, 1
.text:000003D2                 mov     [ebp+var_4], eax
.text:000003D5
.text:000003D5 loc_3D5:                                ; CODE XREF: ReplaceIncorrectChars(UString &)+1Ej
.text:000003D5                 mov     ecx, [ebp+arg_0] ; this
.text:000003D8                 call    ?Len@UString@@QBEIXZ ; UString::Len(void)
.text:000003DD                 cmp     [ebp+var_4], eax
.text:000003E0                 jnb     loc_466
.text:000003E6                 mov     ecx, [ebp+arg_0]
.text:000003E9                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000003EE                 mov     ecx, [ebp+var_4]
.text:000003F1                 mov     dx, [eax+ecx*2]
.text:000003F5                 mov     word ptr [ebp+var_8], dx
.text:000003F9                 movzx   eax, word ptr [ebp+var_8]
.text:000003FD                 cmp     eax, 3Ah ; ':'
.text:00000400                 jz      short loc_453
.text:00000402                 movzx   ecx, word ptr [ebp+var_8]
.text:00000406                 cmp     ecx, 2Ah ; '*'
.text:00000409                 jz      short loc_453
.text:0000040B                 movzx   edx, word ptr [ebp+var_8]
.text:0000040F                 cmp     edx, 3Fh ; '?'
.text:00000412                 jz      short loc_453
.text:00000414                 movzx   eax, word ptr [ebp+var_8]
.text:00000418                 cmp     eax, 20h ; ' '
.text:0000041B                 jl      short loc_453
.text:0000041D                 movzx   ecx, word ptr [ebp+var_8]
.text:00000421                 cmp     ecx, 3Ch ; '<'
.text:00000424                 jz      short loc_453
.text:00000426                 movzx   edx, word ptr [ebp+var_8]
.text:0000042A                 cmp     edx, 3Eh ; '>'
.text:0000042D                 jz      short loc_453
.text:0000042F                 movzx   eax, word ptr [ebp+var_8]
.text:00000433                 cmp     eax, 7Ch ; '|'
.text:00000436                 jz      short loc_453
.text:00000438                 movzx   ecx, word ptr [ebp+var_8]
.text:0000043C                 cmp     ecx, 22h ; '"'
.text:0000043F                 jz      short loc_453
.text:00000441                 movzx   edx, word ptr [ebp+var_8]
.text:00000445                 cmp     edx, 2Fh ; '/'
.text:00000448                 jz      short loc_453
.text:0000044A                 movzx   eax, word ptr [ebp+var_8]
.text:0000044E                 cmp     eax, 5Ch ; '\'
.text:00000451                 jnz     short loc_461
.text:00000453
.text:00000453 loc_453:                                ; CODE XREF: ReplaceIncorrectChars(UString &)+54j
.text:00000453                                         ; ReplaceIncorrectChars(UString &)+5Dj ...
.text:00000453                 push    5Fh ; '_'       ; wchar_t
.text:00000455                 mov     ecx, [ebp+var_4]
.text:00000458                 push    ecx             ; unsigned int
.text:00000459                 mov     ecx, [ebp+arg_0] ; this
.text:0000045C                 call    ?ReplaceOneCharAtPos@UString@@QAEXI_W@Z ; UString::ReplaceOneCharAtPos(uint,wchar_t)
.text:00000461
.text:00000461 loc_461:                                ; CODE XREF: ReplaceIncorrectChars(UString &)+A5j
.text:00000461                 jmp     loc_3CC
.text:00000466 ; ---------------------------------------------------------------------------
.text:00000466
.text:00000466 loc_466:                                ; CODE XREF: ReplaceIncorrectChars(UString &)+34j
.text:00000466                 mov     ecx, [ebp+arg_0] ; this
.text:00000469                 call    ?Len@UString@@QBEIXZ ; UString::Len(void)
.text:0000046E                 mov     [ebp+var_C], eax
.text:00000471
.text:00000471 loc_471:                                ; CODE XREF: ReplaceIncorrectChars(UString &)+109j
.text:00000471                 cmp     [ebp+var_C], 0
.text:00000475                 jz      short loc_4B7
.text:00000477                 mov     edx, [ebp+var_C]
.text:0000047A                 sub     edx, 1
.text:0000047D                 mov     [ebp+var_C], edx
.text:00000480                 mov     ecx, [ebp+arg_0]
.text:00000483                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00000488                 mov     ecx, [ebp+var_C]
.text:0000048B                 mov     dx, [eax+ecx*2]
.text:0000048F                 mov     word ptr [ebp+var_10], dx
.text:00000493                 movzx   eax, word ptr [ebp+var_10]
.text:00000497                 cmp     eax, 2Eh ; '.'
.text:0000049A                 jz      short loc_4A7
.text:0000049C                 movzx   ecx, word ptr [ebp+var_10]
.text:000004A0                 cmp     ecx, 20h ; ' '
.text:000004A3                 jz      short loc_4A7
.text:000004A5                 jmp     short loc_4B7
.text:000004A7 ; ---------------------------------------------------------------------------
.text:000004A7
.text:000004A7 loc_4A7:                                ; CODE XREF: ReplaceIncorrectChars(UString &)+EEj
.text:000004A7                                         ; ReplaceIncorrectChars(UString &)+F7j
.text:000004A7                 push    5Fh ; '_'       ; wchar_t
.text:000004A9                 mov     edx, [ebp+var_C]
.text:000004AC                 push    edx             ; unsigned int
.text:000004AD                 mov     ecx, [ebp+arg_0] ; this
.text:000004B0                 call    ?ReplaceOneCharAtPos@UString@@QAEXI_W@Z ; UString::ReplaceOneCharAtPos(uint,wchar_t)
.text:000004B5                 jmp     short loc_471
.text:000004B7 ; ---------------------------------------------------------------------------
.text:000004B7
.text:000004B7 loc_4B7:                                ; CODE XREF: ReplaceIncorrectChars(UString &)+C9j
.text:000004B7                                         ; ReplaceIncorrectChars(UString &)+F9j
.text:000004B7                 add     esp, 10h
.text:000004BA                 cmp     ebp, esp
.text:000004BC                 call    __RTC_CheckEsp
.text:000004C1                 mov     esp, ebp
.text:000004C3                 pop     ebp
.text:000004C4                 retn    4
.text:000004C4 ?ReplaceIncorrectChars@@YGXAAVUString@@@Z endp
.text:000004C4
.text:000004C4 ; ---------------------------------------------------------------------------
.text:000004C7                 db 5 dup(0CCh)
.text:000004CC
.text:000004CC ; =============== S U B R O U T I N E =======================================
.text:000004CC
.text:000004CC ; Attributes: bp-based frame
.text:000004CC
.text:000004CC ; void __stdcall Correct_FsPath(bool, class CObjectVector<class UString> &, bool)
.text:000004CC                 public ?Correct_FsPath@@YGX_NAAV?$CObjectVector@VUString@@@@0@Z
.text:000004CC ?Correct_FsPath@@YGX_NAAV?$CObjectVector@VUString@@@@0@Z proc near
.text:000004CC
.text:000004CC var_40          = byte ptr -40h
.text:000004CC var_34          = dword ptr -34h
.text:000004CC var_30          = dword ptr -30h
.text:000004CC var_28          = byte ptr -28h
.text:000004CC var_18          = dword ptr -18h
.text:000004CC var_11          = byte ptr -11h
.text:000004CC var_10          = dword ptr -10h
.text:000004CC var_C           = dword ptr -0Ch
.text:000004CC var_4           = dword ptr -4
.text:000004CC arg_0           = byte ptr  8
.text:000004CC arg_4           = dword ptr  0Ch
.text:000004CC arg_8           = byte ptr  10h
.text:000004CC
.text:000004CC                 push    ebp
.text:000004CD                 mov     ebp, esp
.text:000004CF                 push    0FFFFFFFFh
.text:000004D1                 push    offset __ehhandler$?Correct_FsPath@@YGX_NAAV?$CObjectVector@VUString@@@@0@Z
.text:000004D6                 mov     eax, large fs:0
.text:000004DC                 push    eax
.text:000004DD                 sub     esp, 34h
.text:000004E0                 push    edi
.text:000004E1                 lea     edi, [ebp+var_40]
.text:000004E4                 mov     ecx, 0Dh
.text:000004E9                 mov     eax, 0CCCCCCCCh
.text:000004EE                 rep stosd
.text:000004F0                 mov     eax, dword ptr ds:___security_cookie
.text:000004F5                 xor     eax, ebp
.text:000004F7                 push    eax             ; wchar_t *
.text:000004F8                 lea     eax, [ebp+var_C]
.text:000004FB                 mov     large fs:0, eax
.text:00000501                 mov     [ebp+var_10], 0
.text:00000508                 movzx   eax, [ebp+arg_0]
.text:0000050C                 test    eax, eax
.text:0000050E                 jz      loc_65C
.text:00000514                 mov     [ebp+var_11], 0
.text:00000518                 push    0
.text:0000051A                 mov     ecx, [ebp+arg_4]
.text:0000051D                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00000522                 mov     ecx, eax        ; this
.text:00000524                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:00000529                 movzx   ecx, al
.text:0000052C                 test    ecx, ecx
.text:0000052E                 jz      loc_5D3
.text:00000534                 mov     [ebp+var_10], 1
.text:0000053B                 mov     ecx, [ebp+arg_4]
.text:0000053E                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:00000543                 cmp     eax, 1
.text:00000546                 jbe     loc_5D1
.text:0000054C                 push    1
.text:0000054E                 mov     ecx, [ebp+arg_4]
.text:00000551                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00000556                 mov     ecx, eax        ; this
.text:00000558                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:0000055D                 movzx   edx, al
.text:00000560                 test    edx, edx
.text:00000562                 jz      short loc_5D1
.text:00000564                 mov     [ebp+var_10], 2
.text:0000056B                 mov     ecx, [ebp+arg_4]
.text:0000056E                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:00000573                 cmp     eax, 2
.text:00000576                 jbe     short loc_5D1
.text:00000578                 push    offset $SG67725 ; Str2
.text:0000057D                 push    2
.text:0000057F                 mov     ecx, [ebp+arg_4]
.text:00000582                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00000587                 push    eax             ; int
.text:00000588                 call    ??8@YG_NABVUString@@PB_W@Z ; operator==(UString const &,wchar_t const *)
.text:0000058D                 movzx   eax, al
.text:00000590                 test    eax, eax
.text:00000592                 jz      short loc_5D1
.text:00000594                 mov     [ebp+var_10], 3
.text:0000059B                 mov     ecx, [ebp+arg_4]
.text:0000059E                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:000005A3                 cmp     eax, 3
.text:000005A6                 jbe     short loc_5D1
.text:000005A8                 push    3
.text:000005AA                 mov     ecx, [ebp+arg_4]
.text:000005AD                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:000005B2                 mov     ecx, eax
.text:000005B4                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000005B9                 push    eax             ; this
.text:000005BA                 call    ?IsDrivePath2@NName@NFile@NWindows@@YG_NPB_W@Z ; NWindows::NFile::NName::IsDrivePath2(wchar_t const *)
.text:000005BF                 movzx   ecx, al
.text:000005C2                 test    ecx, ecx
.text:000005C4                 jz      short loc_5D1
.text:000005C6                 mov     [ebp+var_11], 1
.text:000005CA                 mov     [ebp+var_10], 4
.text:000005D1
.text:000005D1 loc_5D1:                                ; CODE XREF: Correct_FsPath(bool,CObjectVector<UString> &,bool)+7Aj
.text:000005D1                                         ; Correct_FsPath(bool,CObjectVector<UString> &,bool)+96j ...
.text:000005D1                 jmp     short loc_5FC
.text:000005D3 ; ---------------------------------------------------------------------------
.text:000005D3
.text:000005D3 loc_5D3:                                ; CODE XREF: Correct_FsPath(bool,CObjectVector<UString> &,bool)+62j
.text:000005D3                 push    0
.text:000005D5                 mov     ecx, [ebp+arg_4]
.text:000005D8                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:000005DD                 mov     ecx, eax
.text:000005DF                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000005E4                 push    eax             ; this
.text:000005E5                 call    ?IsDrivePath2@NName@NFile@NWindows@@YG_NPB_W@Z ; NWindows::NFile::NName::IsDrivePath2(wchar_t const *)
.text:000005EA                 movzx   edx, al
.text:000005ED                 test    edx, edx
.text:000005EF                 jz      short loc_5FC
.text:000005F1                 mov     [ebp+var_11], 1
.text:000005F5                 mov     [ebp+var_10], 1
.text:000005FC
.text:000005FC loc_5FC:                                ; CODE XREF: Correct_FsPath(bool,CObjectVector<UString> &,bool):loc_5D1j
.text:000005FC                                         ; Correct_FsPath(bool,CObjectVector<UString> &,bool)+123j
.text:000005FC                 movzx   eax, [ebp+var_11]
.text:00000600                 test    eax, eax
.text:00000602                 jz      short loc_65C
.text:00000604                 mov     ecx, [ebp+var_10]
.text:00000607                 sub     ecx, 1
.text:0000060A                 push    ecx
.text:0000060B                 mov     ecx, [ebp+arg_4]
.text:0000060E                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00000613                 mov     [ebp+var_18], eax
.text:00000616                 mov     ecx, [ebp+var_18] ; this
.text:00000619                 call    ?Len@UString@@QBEIXZ ; UString::Len(void)
.text:0000061E                 cmp     eax, 2
.text:00000621                 jz      short loc_65C
.text:00000623                 push    2               ; unsigned int
.text:00000625                 mov     ecx, [ebp+var_18] ; this
.text:00000628                 call    ?Ptr@UString@@QBEPB_WI@Z ; UString::Ptr(uint)
.text:0000062D                 push    eax
.text:0000062E                 lea     ecx, [ebp+var_28]
.text:00000631                 call    ??0UString@@QAE@PB_W@Z ; UString::UString(wchar_t const *)
.text:00000636                 mov     [ebp+var_4], 0
.text:0000063D                 lea     edx, [ebp+var_28]
.text:00000640                 push    edx
.text:00000641                 mov     eax, [ebp+var_10]
.text:00000644                 push    eax
.text:00000645                 mov     ecx, [ebp+arg_4]
.text:00000648                 call    ?Insert@?$CObjectVector@VUString@@@@QAEXIABVUString@@@Z ; CObjectVector<UString>::Insert(uint,UString const &)
.text:0000064D                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000654                 lea     ecx, [ebp+var_28] ; this
.text:00000657                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000065C
.text:0000065C loc_65C:                                ; CODE XREF: Correct_FsPath(bool,CObjectVector<UString> &,bool)+42j
.text:0000065C                                         ; Correct_FsPath(bool,CObjectVector<UString> &,bool)+136j ...
.text:0000065C                 mov     ecx, [ebp+arg_4]
.text:0000065F                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:00000664                 cmp     [ebp+var_10], eax
.text:00000667                 jnb     short loc_6D6
.text:00000669                 mov     ecx, [ebp+var_10]
.text:0000066C                 push    ecx
.text:0000066D                 mov     ecx, [ebp+arg_4]
.text:00000670                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00000675                 mov     [ebp+var_30], eax
.text:00000678                 mov     edx, [ebp+var_30]
.text:0000067B                 push    edx             ; UString *
.text:0000067C                 call    ?Correct_PathPart@@YGXAAVUString@@@Z ; Correct_PathPart(UString &)
.text:00000681                 mov     ecx, [ebp+var_30] ; this
.text:00000684                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:00000689                 movzx   eax, al
.text:0000068C                 test    eax, eax
.text:0000068E                 jz      short loc_6C2
.text:00000690                 movzx   ecx, [ebp+arg_8]
.text:00000694                 test    ecx, ecx
.text:00000696                 jnz     short loc_6A8
.text:00000698                 mov     ecx, [ebp+arg_4]
.text:0000069B                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:000006A0                 sub     eax, 1
.text:000006A3                 cmp     [ebp+var_10], eax
.text:000006A6                 jz      short loc_6B6
.text:000006A8
.text:000006A8 loc_6A8:                                ; CODE XREF: Correct_FsPath(bool,CObjectVector<UString> &,bool)+1CAj
.text:000006A8                 mov     edx, [ebp+var_10]
.text:000006AB                 push    edx
.text:000006AC                 mov     ecx, [ebp+arg_4]
.text:000006AF                 call    ?Delete@?$CObjectVector@VUString@@@@QAEXI@Z ; CObjectVector<UString>::Delete(uint)
.text:000006B4                 jmp     short loc_65C
.text:000006B6 ; ---------------------------------------------------------------------------
.text:000006B6
.text:000006B6 loc_6B6:                                ; CODE XREF: Correct_FsPath(bool,CObjectVector<UString> &,bool)+1DAj
.text:000006B6                 push    5Fh ; '_'
.text:000006B8                 mov     ecx, [ebp+var_30]
.text:000006BB                 call    ??4UString@@QAEAAV0@_W@Z ; UString::operator=(wchar_t)
.text:000006C0                 jmp     short loc_6CB
.text:000006C2 ; ---------------------------------------------------------------------------
.text:000006C2
.text:000006C2 loc_6C2:                                ; CODE XREF: Correct_FsPath(bool,CObjectVector<UString> &,bool)+1C2j
.text:000006C2                 mov     eax, [ebp+var_30]
.text:000006C5                 push    eax             ; UString *
.text:000006C6                 call    ?CorrectUnsupportedName@@YGXAAVUString@@@Z ; CorrectUnsupportedName(UString &)
.text:000006CB
.text:000006CB loc_6CB:                                ; CODE XREF: Correct_FsPath(bool,CObjectVector<UString> &,bool)+1F4j
.text:000006CB                 mov     ecx, [ebp+var_10]
.text:000006CE                 add     ecx, 1
.text:000006D1                 mov     [ebp+var_10], ecx
.text:000006D4                 jmp     short loc_65C
.text:000006D6 ; ---------------------------------------------------------------------------
.text:000006D6
.text:000006D6 loc_6D6:                                ; CODE XREF: Correct_FsPath(bool,CObjectVector<UString> &,bool)+19Bj
.text:000006D6                 movzx   edx, [ebp+arg_8]
.text:000006DA                 test    edx, edx
.text:000006DC                 jnz     short loc_73F
.text:000006DE                 mov     ecx, [ebp+arg_4]
.text:000006E1                 call    ?IsEmpty@?$CObjectVector@VUString@@@@QBE_NXZ ; CObjectVector<UString>::IsEmpty(void)
.text:000006E6                 movzx   eax, al
.text:000006E9                 test    eax, eax
.text:000006EB                 jz      short loc_71B
.text:000006ED                 push    5Fh ; '_'
.text:000006EF                 lea     ecx, [ebp+var_40]
.text:000006F2                 call    ??0UString@@QAE@_W@Z ; UString::UString(wchar_t)
.text:000006F7                 mov     [ebp+var_4], 1
.text:000006FE                 lea     ecx, [ebp+var_40]
.text:00000701                 push    ecx
.text:00000702                 mov     ecx, [ebp+arg_4]
.text:00000705                 call    ?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z ; CObjectVector<UString>::Add(UString const &)
.text:0000070A                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000711                 lea     ecx, [ebp+var_40] ; this
.text:00000714                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000719                 jmp     short loc_73F
.text:0000071B ; ---------------------------------------------------------------------------
.text:0000071B
.text:0000071B loc_71B:                                ; CODE XREF: Correct_FsPath(bool,CObjectVector<UString> &,bool)+21Fj
.text:0000071B                 mov     ecx, [ebp+arg_4]
.text:0000071E                 call    ?Back@?$CObjectVector@VUString@@@@QAEAAVUString@@XZ ; CObjectVector<UString>::Back(void)
.text:00000723                 mov     [ebp+var_34], eax
.text:00000726                 mov     ecx, [ebp+var_34] ; this
.text:00000729                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:0000072E                 movzx   edx, al
.text:00000731                 test    edx, edx
.text:00000733                 jz      short loc_73F
.text:00000735                 push    5Fh ; '_'
.text:00000737                 mov     ecx, [ebp+var_34]
.text:0000073A                 call    ??4UString@@QAEAAV0@_W@Z ; UString::operator=(wchar_t)
.text:0000073F
.text:0000073F loc_73F:                                ; CODE XREF: Correct_FsPath(bool,CObjectVector<UString> &,bool)+210j
.text:0000073F                                         ; Correct_FsPath(bool,CObjectVector<UString> &,bool)+24Dj ...
.text:0000073F                 push    edx
.text:00000740                 mov     ecx, ebp
.text:00000742                 push    eax
.text:00000743                 lea     edx, $LN28
.text:00000749                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:0000074E                 pop     eax
.text:0000074F                 pop     edx
.text:00000750                 mov     ecx, [ebp+var_C]
.text:00000753                 mov     large fs:0, ecx
.text:0000075A                 pop     ecx
.text:0000075B                 pop     edi
.text:0000075C                 add     esp, 40h
.text:0000075F                 cmp     ebp, esp
.text:00000761                 call    __RTC_CheckEsp
.text:00000766                 mov     esp, ebp
.text:00000768                 pop     ebp
.text:00000769                 retn    0Ch
.text:00000769 ?Correct_FsPath@@YGX_NAAV?$CObjectVector@VUString@@@@0@Z endp ; sp-analysis failed
.text:00000769
.text:00000769 ; ---------------------------------------------------------------------------
.text:0000076C $LN28           dd 1                    ; DATA XREF: Correct_FsPath(bool,CObjectVector<UString> &,bool)+277o
.text:00000770                 dd offset $LN27
.text:00000774 $LN27           dd 0FFFFFFD8h, 0Ch      ; DATA XREF: .text:00000770o
.text:0000077C                 dd offset $LN25
.text:00000780 $LN25           dd 0CCCC0073h, 2 dup(0CCCCCCCCh) ; DATA XREF: .text:0000077Co
.text:0000078C
.text:0000078C ; =============== S U B R O U T I N E =======================================
.text:0000078C
.text:0000078C ; Attributes: bp-based frame
.text:0000078C
.text:0000078C ; class UString __stdcall MakePathFromParts(class CObjectVector<class UString> const &)
.text:0000078C                 public ?MakePathFromParts@@YG?AVUString@@ABV?$CObjectVector@VUString@@@@@Z
.text:0000078C ?MakePathFromParts@@YG?AVUString@@ABV?$CObjectVector@VUString@@@@@Z proc near
.text:0000078C
.text:0000078C var_28          = dword ptr -28h
.text:0000078C var_24          = dword ptr -24h
.text:0000078C var_20          = dword ptr -20h
.text:0000078C var_1C          = dword ptr -1Ch
.text:0000078C var_18          = dword ptr -18h
.text:0000078C var_14          = dword ptr -14h
.text:0000078C var_10          = dword ptr -10h
.text:0000078C var_C           = dword ptr -0Ch
.text:0000078C var_4           = dword ptr -4
.text:0000078C arg_0           = dword ptr  8
.text:0000078C arg_4           = dword ptr  0Ch
.text:0000078C
.text:0000078C                 push    ebp
.text:0000078D                 mov     ebp, esp
.text:0000078F                 push    0FFFFFFFFh
.text:00000791                 push    offset __ehhandler$?MakePathFromParts@@YG?AVUString@@ABV?$CObjectVector@VUString@@@@@Z
.text:00000796                 mov     eax, large fs:0
.text:0000079C                 push    eax
.text:0000079D                 sub     esp, 1Ch
.text:000007A0                 mov     eax, 0CCCCCCCCh
.text:000007A5                 mov     [ebp+var_28], eax
.text:000007A8                 mov     [ebp+var_24], eax
.text:000007AB                 mov     [ebp+var_20], eax
.text:000007AE                 mov     [ebp+var_1C], eax
.text:000007B1                 mov     [ebp+var_18], eax
.text:000007B4                 mov     [ebp+var_14], eax
.text:000007B7                 mov     [ebp+var_10], eax
.text:000007BA                 mov     eax, dword ptr ds:___security_cookie
.text:000007BF                 xor     eax, ebp
.text:000007C1                 push    eax
.text:000007C2                 lea     eax, [ebp+var_C]
.text:000007C5                 mov     large fs:0, eax
.text:000007CB                 mov     [ebp+var_28], 0
.text:000007D2                 lea     ecx, [ebp+var_1C]
.text:000007D5                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:000007DA                 mov     [ebp+var_4], 1
.text:000007E1                 mov     [ebp+var_24], 0
.text:000007E8                 jmp     short loc_7F3
.text:000007EA ; ---------------------------------------------------------------------------
.text:000007EA
.text:000007EA loc_7EA:                                ; CODE XREF: MakePathFromParts(CObjectVector<UString> const &)+97j
.text:000007EA                 mov     eax, [ebp+var_24]
.text:000007ED                 add     eax, 1
.text:000007F0                 mov     [ebp+var_24], eax
.text:000007F3
.text:000007F3 loc_7F3:                                ; CODE XREF: MakePathFromParts(CObjectVector<UString> const &)+5Cj
.text:000007F3                 mov     ecx, [ebp+arg_4]
.text:000007F6                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:000007FB                 cmp     [ebp+var_24], eax
.text:000007FE                 jnb     short loc_825
.text:00000800                 cmp     [ebp+var_24], 0
.text:00000804                 jz      short loc_80E
.text:00000806                 lea     ecx, [ebp+var_1C] ; this
.text:00000809                 call    ?Add_PathSepar@UString@@QAEXXZ ; UString::Add_PathSepar(void)
.text:0000080E
.text:0000080E loc_80E:                                ; CODE XREF: MakePathFromParts(CObjectVector<UString> const &)+78j
.text:0000080E                 mov     ecx, [ebp+var_24]
.text:00000811                 push    ecx
.text:00000812                 mov     ecx, [ebp+arg_4]
.text:00000815                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:0000081A                 push    eax
.text:0000081B                 lea     ecx, [ebp+var_1C]
.text:0000081E                 call    ??YUString@@QAEAAV0@ABV0@@Z ; UString::operator+=(UString const &)
.text:00000823                 jmp     short loc_7EA
.text:00000825 ; ---------------------------------------------------------------------------
.text:00000825
.text:00000825 loc_825:                                ; CODE XREF: MakePathFromParts(CObjectVector<UString> const &)+72j
.text:00000825                 lea     edx, [ebp+var_1C]
.text:00000828                 push    edx
.text:00000829                 mov     ecx, [ebp+arg_0]
.text:0000082C                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00000831                 mov     eax, [ebp+var_28]
.text:00000834                 or      eax, 1
.text:00000837                 mov     [ebp+var_28], eax
.text:0000083A                 mov     byte ptr [ebp+var_4], 0
.text:0000083E                 lea     ecx, [ebp+var_1C] ; this
.text:00000841                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000846                 mov     eax, [ebp+arg_0]
.text:00000849                 push    edx
.text:0000084A                 mov     ecx, ebp
.text:0000084C                 push    eax
.text:0000084D                 lea     edx, $LN13
.text:00000853                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00000858                 pop     eax
.text:00000859                 pop     edx
.text:0000085A                 mov     ecx, [ebp+var_C]
.text:0000085D                 mov     large fs:0, ecx
.text:00000864                 pop     ecx
.text:00000865                 add     esp, 28h
.text:00000868                 cmp     ebp, esp
.text:0000086A                 call    __RTC_CheckEsp
.text:0000086F                 mov     esp, ebp
.text:00000871                 pop     ebp
.text:00000872                 retn    8
.text:00000872 ?MakePathFromParts@@YG?AVUString@@ABV?$CObjectVector@VUString@@@@@Z endp
.text:00000872
.text:00000872 ; ---------------------------------------------------------------------------
.text:00000875                 align 4
.text:00000878 $LN13           dd 1                    ; DATA XREF: MakePathFromParts(CObjectVector<UString> const &)+C1o
.text:0000087C                 dd offset $LN12
.text:00000880 $LN12           dd 0FFFFFFE4h, 0Ch      ; DATA XREF: .text:0000087Co
.text:00000888                 dd offset $LN10_0
.text:0000088C $LN10_0         db 73h, 0               ; DATA XREF: .text:00000888o
.text:0000088E                 align 10h
.text:0000088E _text           ends
.text:0000088E
.rtc$TMZ:00000890 ; ===========================================================================
.rtc$TMZ:00000890
.rtc$TMZ:00000890 ; Segment type: Pure data
.rtc$TMZ:00000890 ; Segment permissions: Read
.rtc$TMZ:00000890 _rtc$TMZ        segment dword public 'DATA' use32
.rtc$TMZ:00000890                 assume cs:_rtc$TMZ
.rtc$TMZ:00000890                 ;org 890h
.rtc$TMZ:00000890 ; COMDAT (pick any)
.rtc$TMZ:00000890 __RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
.rtc$TMZ:00000890 _rtc$TMZ        ends
.rtc$TMZ:00000890
.rtc$IMZ:00000894 ; ===========================================================================
.rtc$IMZ:00000894
.rtc$IMZ:00000894 ; Segment type: Pure data
.rtc$IMZ:00000894 ; Segment permissions: Read
.rtc$IMZ:00000894 _rtc$IMZ        segment dword public 'DATA' use32
.rtc$IMZ:00000894                 assume cs:_rtc$IMZ
.rtc$IMZ:00000894                 ;org 894h
.rtc$IMZ:00000894 ; COMDAT (pick any)
.rtc$IMZ:00000894 __RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
.rtc$IMZ:00000894 _rtc$IMZ        ends
.rtc$IMZ:00000894
.text:00000898 ; ===========================================================================
.text:00000898
.text:00000898 ; Segment type: Pure code
.text:00000898 ; Segment permissions: Read/Execute
.text:00000898 _text           segment para public 'CODE' use32
.text:00000898                 assume cs:_text
.text:00000898                 ;org 898h
.text:00000898 ; COMDAT (pick any)
.text:00000898                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000898
.text:00000898 ; =============== S U B R O U T I N E =======================================
.text:00000898
.text:00000898 ; Attributes: bp-based frame
.text:00000898
.text:00000898 ; unsigned int __thiscall UString::Len(UString *__hidden this)
.text:00000898                 public ?Len@UString@@QBEIXZ
.text:00000898 ?Len@UString@@QBEIXZ proc near          ; CODE XREF: Correct_AltStream_Name(UString &)+1Ap
.text:00000898                                         ; Correct_AltStream_Name(UString &)+2Cp ...
.text:00000898
.text:00000898 var_4           = dword ptr -4
.text:00000898
.text:00000898                 push    ebp
.text:00000899                 mov     ebp, esp
.text:0000089B                 push    ecx
.text:0000089C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000008A3                 mov     [ebp+var_4], ecx
.text:000008A6                 mov     eax, [ebp+var_4]
.text:000008A9                 mov     eax, [eax+4]
.text:000008AC                 mov     esp, ebp
.text:000008AE                 pop     ebp
.text:000008AF                 retn
.text:000008AF ?Len@UString@@QBEIXZ endp
.text:000008AF
.text:000008AF _text           ends
.text:000008AF
.text:000008B0 ; ===========================================================================
.text:000008B0
.text:000008B0 ; Segment type: Pure code
.text:000008B0 ; Segment permissions: Read/Execute
.text:000008B0 _text           segment para public 'CODE' use32
.text:000008B0                 assume cs:_text
.text:000008B0                 ;org 8B0h
.text:000008B0 ; COMDAT (pick any)
.text:000008B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000008B0
.text:000008B0 ; =============== S U B R O U T I N E =======================================
.text:000008B0
.text:000008B0 ; Attributes: bp-based frame
.text:000008B0
.text:000008B0 ; bool __thiscall UString::IsEmpty(UString *__hidden this)
.text:000008B0                 public ?IsEmpty@UString@@QBE_NXZ
.text:000008B0 ?IsEmpty@UString@@QBE_NXZ proc near     ; CODE XREF: Correct_AltStream_Name(UString &)+B6p
.text:000008B0                                         ; Get_Correct_FsFile_Name(UString const &)+6Bp ...
.text:000008B0
.text:000008B0 var_4           = dword ptr -4
.text:000008B0
.text:000008B0                 push    ebp
.text:000008B1                 mov     ebp, esp
.text:000008B3                 push    ecx
.text:000008B4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000008BB                 mov     [ebp+var_4], ecx
.text:000008BE                 mov     eax, [ebp+var_4]
.text:000008C1                 xor     ecx, ecx
.text:000008C3                 cmp     dword ptr [eax+4], 0
.text:000008C7                 setz    cl
.text:000008CA                 mov     al, cl
.text:000008CC                 mov     esp, ebp
.text:000008CE                 pop     ebp
.text:000008CF                 retn
.text:000008CF ?IsEmpty@UString@@QBE_NXZ endp
.text:000008CF
.text:000008CF _text           ends
.text:000008CF
.text:000008D0 ; ===========================================================================
.text:000008D0
.text:000008D0 ; Segment type: Pure code
.text:000008D0 ; Segment permissions: Read/Execute
.text:000008D0 _text           segment para public 'CODE' use32
.text:000008D0                 assume cs:_text
.text:000008D0                 ;org 8D0h
.text:000008D0 ; COMDAT (pick any)
.text:000008D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000008D0
.text:000008D0 ; =============== S U B R O U T I N E =======================================
.text:000008D0
.text:000008D0 ; Attributes: bp-based frame
.text:000008D0
.text:000008D0 ; public: __thiscall UString::operator wchar_t const *(void)const
.text:000008D0                 public ??BUString@@QBEPB_WXZ
.text:000008D0 ??BUString@@QBEPB_WXZ proc near         ; CODE XREF: Correct_AltStream_Name(UString &)+78p
.text:000008D0                                         ; IsSupportedName(UString const &)+7Cp ...
.text:000008D0
.text:000008D0 var_4           = dword ptr -4
.text:000008D0
.text:000008D0                 push    ebp
.text:000008D1                 mov     ebp, esp
.text:000008D3                 push    ecx
.text:000008D4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000008DB                 mov     [ebp+var_4], ecx
.text:000008DE                 mov     eax, [ebp+var_4]
.text:000008E1                 mov     eax, [eax]
.text:000008E3                 mov     esp, ebp
.text:000008E5                 pop     ebp
.text:000008E6                 retn
.text:000008E6 ??BUString@@QBEPB_WXZ endp
.text:000008E6
.text:000008E6 ; ---------------------------------------------------------------------------
.text:000008E7                 align 4
.text:000008E7 _text           ends
.text:000008E7
.text:000008E8 ; ===========================================================================
.text:000008E8
.text:000008E8 ; Segment type: Pure code
.text:000008E8 ; Segment permissions: Read/Execute
.text:000008E8 _text           segment para public 'CODE' use32
.text:000008E8                 assume cs:_text
.text:000008E8                 ;org 8E8h
.text:000008E8 ; COMDAT (pick any)
.text:000008E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000008E8
.text:000008E8 ; =============== S U B R O U T I N E =======================================
.text:000008E8
.text:000008E8 ; Attributes: bp-based frame
.text:000008E8
.text:000008E8 ; const wchar_t *__thiscall UString::RightPtr(UString *this, unsigned int)
.text:000008E8                 public ?RightPtr@UString@@QBEPB_WI@Z
.text:000008E8 ?RightPtr@UString@@QBEPB_WI@Z proc near ; CODE XREF: Correct_AltStream_Name(UString &)+40p
.text:000008E8
.text:000008E8 var_4           = dword ptr -4
.text:000008E8 arg_0           = dword ptr  8
.text:000008E8
.text:000008E8                 push    ebp
.text:000008E9                 mov     ebp, esp
.text:000008EB                 push    ecx
.text:000008EC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000008F3                 mov     [ebp+var_4], ecx
.text:000008F6                 mov     eax, [ebp+var_4]
.text:000008F9                 mov     ecx, [eax+4]
.text:000008FC                 mov     edx, [ebp+var_4]
.text:000008FF                 mov     eax, [edx]
.text:00000901                 lea     eax, [eax+ecx*2]
.text:00000904                 mov     ecx, [ebp+arg_0]
.text:00000907                 shl     ecx, 1
.text:00000909                 sub     eax, ecx
.text:0000090B                 mov     esp, ebp
.text:0000090D                 pop     ebp
.text:0000090E                 retn    4
.text:0000090E ?RightPtr@UString@@QBEPB_WI@Z endp
.text:0000090E
.text:0000090E ; ---------------------------------------------------------------------------
.text:00000911                 align 4
.text:00000911 _text           ends
.text:00000911
.text:00000914 ; ===========================================================================
.text:00000914
.text:00000914 ; Segment type: Pure code
.text:00000914 ; Segment permissions: Read/Execute
.text:00000914 _text           segment para public 'CODE' use32
.text:00000914                 assume cs:_text
.text:00000914                 ;org 914h
.text:00000914 ; COMDAT (pick any)
.text:00000914                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000914
.text:00000914 ; =============== S U B R O U T I N E =======================================
.text:00000914
.text:00000914 ; Attributes: bp-based frame
.text:00000914
.text:00000914 ; void __thiscall UString::ReplaceOneCharAtPos(UString *this, unsigned int, wchar_t)
.text:00000914                 public ?ReplaceOneCharAtPos@UString@@QAEXI_W@Z
.text:00000914 ?ReplaceOneCharAtPos@UString@@QAEXI_W@Z proc near
.text:00000914                                         ; CODE XREF: Correct_AltStream_Name(UString &)+ACp
.text:00000914                                         ; ReplaceIncorrectChars(UString &)+B0p ...
.text:00000914
.text:00000914 var_4           = dword ptr -4
.text:00000914 arg_0           = dword ptr  8
.text:00000914 arg_4           = word ptr  0Ch
.text:00000914
.text:00000914                 push    ebp
.text:00000915                 mov     ebp, esp
.text:00000917                 push    ecx
.text:00000918                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000091F                 mov     [ebp+var_4], ecx
.text:00000922                 mov     eax, [ebp+var_4]
.text:00000925                 mov     ecx, [eax]
.text:00000927                 mov     edx, [ebp+arg_0]
.text:0000092A                 mov     ax, [ebp+arg_4]
.text:0000092E                 mov     [ecx+edx*2], ax
.text:00000932                 mov     esp, ebp
.text:00000934                 pop     ebp
.text:00000935                 retn    8
.text:00000935 ?ReplaceOneCharAtPos@UString@@QAEXI_W@Z endp
.text:00000935
.text:00000935 _text           ends
.text:00000935
.text$x:00000938 ; ===========================================================================
.text$x:00000938
.text$x:00000938 ; Segment type: Pure code
.text$x:00000938 ; Segment permissions: Read/Execute
.text$x:00000938 _text$x         segment para public 'CODE' use32
.text$x:00000938                 assume cs:_text$x
.text$x:00000938                 ;org 938h
.text$x:00000938                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000938
.text$x:00000938 ; =============== S U B R O U T I N E =======================================
.text$x:00000938
.text$x:00000938
.text$x:00000938 __unwindfunclet$?Get_Correct_FsFile_Name@@YG?AVUString@@ABV1@@Z$0 proc near
.text$x:00000938                                         ; DATA XREF: .xdata$x:000009E8o
.text$x:00000938                 lea     ecx, [ebp-1Ch]  ; this
.text$x:0000093B                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:0000093B __unwindfunclet$?Get_Correct_FsFile_Name@@YG?AVUString@@ABV1@@Z$0 endp
.text$x:0000093B
.text$x:00000940
.text$x:00000940 ; =============== S U B R O U T I N E =======================================
.text$x:00000940
.text$x:00000940
.text$x:00000940 __unwindfunclet$?Get_Correct_FsFile_Name@@YG?AVUString@@ABV1@@Z$1 proc near
.text$x:00000940                                         ; DATA XREF: .xdata$x:000009E0o
.text$x:00000940                 mov     eax, [ebp-24h]
.text$x:00000943                 and     eax, 1
.text$x:00000946                 jz      locret_958
.text$x:0000094C                 and     dword ptr [ebp-24h], 0FFFFFFFEh
.text$x:00000950                 mov     ecx, [ebp+8]    ; this
.text$x:00000953                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00000958 ; ---------------------------------------------------------------------------
.text$x:00000958
.text$x:00000958 locret_958:                             ; CODE XREF: __unwindfunclet$?Get_Correct_FsFile_Name@@YG?AVUString@@ABV1@@Z$1+6j
.text$x:00000958                 retn
.text$x:00000958 __unwindfunclet$?Get_Correct_FsFile_Name@@YG?AVUString@@ABV1@@Z$1 endp
.text$x:00000958
.text$x:00000959
.text$x:00000959 ; =============== S U B R O U T I N E =======================================
.text$x:00000959
.text$x:00000959
.text$x:00000959 __ehhandler$?Get_Correct_FsFile_Name@@YG?AVUString@@ABV1@@Z proc near
.text$x:00000959                                         ; DATA XREF: Get_Correct_FsFile_Name(UString const &)+5o
.text$x:00000959
.text$x:00000959 arg_4           = dword ptr  8
.text$x:00000959
.text$x:00000959                 mov     edx, [esp+arg_4]
.text$x:0000095D                 lea     eax, [edx+0Ch]
.text$x:00000960                 mov     ecx, [edx-1Ch]
.text$x:00000963                 xor     ecx, eax
.text$x:00000965                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000096A                 mov     eax, offset __ehfuncinfo$?Get_Correct_FsFile_Name@@YG?AVUString@@ABV1@@Z
.text$x:0000096F                 jmp     ___CxxFrameHandler3
.text$x:0000096F __ehhandler$?Get_Correct_FsFile_Name@@YG?AVUString@@ABV1@@Z endp
.text$x:0000096F
.text$x:00000974
.text$x:00000974 ; =============== S U B R O U T I N E =======================================
.text$x:00000974
.text$x:00000974
.text$x:00000974 __unwindfunclet$?Correct_FsPath@@YGX_NAAV?$CObjectVector@VUString@@@@0@Z$0 proc near
.text$x:00000974                                         ; DATA XREF: .xdata$x:00000A14o
.text$x:00000974                 lea     ecx, [ebp-28h]  ; this
.text$x:00000977                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00000977 __unwindfunclet$?Correct_FsPath@@YGX_NAAV?$CObjectVector@VUString@@@@0@Z$0 endp
.text$x:00000977
.text$x:0000097C
.text$x:0000097C ; =============== S U B R O U T I N E =======================================
.text$x:0000097C
.text$x:0000097C
.text$x:0000097C __unwindfunclet$?Correct_FsPath@@YGX_NAAV?$CObjectVector@VUString@@@@0@Z$1 proc near
.text$x:0000097C                                         ; DATA XREF: .xdata$x:00000A1Co
.text$x:0000097C                 lea     ecx, [ebp-40h]  ; this
.text$x:0000097F                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:0000097F __unwindfunclet$?Correct_FsPath@@YGX_NAAV?$CObjectVector@VUString@@@@0@Z$1 endp
.text$x:0000097F
.text$x:00000984
.text$x:00000984 ; =============== S U B R O U T I N E =======================================
.text$x:00000984
.text$x:00000984
.text$x:00000984 __ehhandler$?Correct_FsPath@@YGX_NAAV?$CObjectVector@VUString@@@@0@Z proc near
.text$x:00000984                                         ; DATA XREF: Correct_FsPath(bool,CObjectVector<UString> &,bool)+5o
.text$x:00000984
.text$x:00000984 arg_4           = dword ptr  8
.text$x:00000984
.text$x:00000984                 mov     edx, [esp+arg_4]
.text$x:00000988                 lea     eax, [edx+0Ch]
.text$x:0000098B                 mov     ecx, [edx-3Ch]
.text$x:0000098E                 xor     ecx, eax
.text$x:00000990                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000995                 mov     eax, offset __ehfuncinfo$?Correct_FsPath@@YGX_NAAV?$CObjectVector@VUString@@@@0@Z
.text$x:0000099A                 jmp     ___CxxFrameHandler3
.text$x:0000099A __ehhandler$?Correct_FsPath@@YGX_NAAV?$CObjectVector@VUString@@@@0@Z endp
.text$x:0000099A
.text$x:0000099F
.text$x:0000099F ; =============== S U B R O U T I N E =======================================
.text$x:0000099F
.text$x:0000099F
.text$x:0000099F __unwindfunclet$?MakePathFromParts@@YG?AVUString@@ABV?$CObjectVector@VUString@@@@@Z$0 proc near
.text$x:0000099F                                         ; DATA XREF: .xdata$x:00000A50o
.text$x:0000099F                 lea     ecx, [ebp-1Ch]  ; this
.text$x:000009A2                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000009A2 __unwindfunclet$?MakePathFromParts@@YG?AVUString@@ABV?$CObjectVector@VUString@@@@@Z$0 endp
.text$x:000009A2
.text$x:000009A7
.text$x:000009A7 ; =============== S U B R O U T I N E =======================================
.text$x:000009A7
.text$x:000009A7
.text$x:000009A7 __unwindfunclet$?MakePathFromParts@@YG?AVUString@@ABV?$CObjectVector@VUString@@@@@Z$1 proc near
.text$x:000009A7                                         ; DATA XREF: .xdata$x:00000A48o
.text$x:000009A7                 mov     eax, [ebp-28h]
.text$x:000009AA                 and     eax, 1
.text$x:000009AD                 jz      locret_9BF
.text$x:000009B3                 and     dword ptr [ebp-28h], 0FFFFFFFEh
.text$x:000009B7                 mov     ecx, [ebp+8]    ; this
.text$x:000009BA                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000009BF ; ---------------------------------------------------------------------------
.text$x:000009BF
.text$x:000009BF locret_9BF:                             ; CODE XREF: __unwindfunclet$?MakePathFromParts@@YG?AVUString@@ABV?$CObjectVector@VUString@@@@@Z$1+6j
.text$x:000009BF                 retn
.text$x:000009BF __unwindfunclet$?MakePathFromParts@@YG?AVUString@@ABV?$CObjectVector@VUString@@@@@Z$1 endp
.text$x:000009BF
.text$x:000009C0
.text$x:000009C0 ; =============== S U B R O U T I N E =======================================
.text$x:000009C0
.text$x:000009C0
.text$x:000009C0 __ehhandler$?MakePathFromParts@@YG?AVUString@@ABV?$CObjectVector@VUString@@@@@Z proc near
.text$x:000009C0                                         ; DATA XREF: MakePathFromParts(CObjectVector<UString> const &)+5o
.text$x:000009C0
.text$x:000009C0 arg_4           = dword ptr  8
.text$x:000009C0
.text$x:000009C0                 mov     edx, [esp+arg_4]
.text$x:000009C4                 lea     eax, [edx+0Ch]
.text$x:000009C7                 mov     ecx, [edx-20h]
.text$x:000009CA                 xor     ecx, eax
.text$x:000009CC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000009D1                 mov     eax, offset __ehfuncinfo$?MakePathFromParts@@YG?AVUString@@ABV?$CObjectVector@VUString@@@@@Z
.text$x:000009D6                 jmp     ___CxxFrameHandler3
.text$x:000009D6 __ehhandler$?MakePathFromParts@@YG?AVUString@@ABV?$CObjectVector@VUString@@@@@Z endp
.text$x:000009D6
.text$x:000009D6 ; ---------------------------------------------------------------------------
.text$x:000009DB                 align 4
.text$x:000009DB _text$x         ends
.text$x:000009DB
.xdata$x:000009DC ; ===========================================================================
.xdata$x:000009DC
.xdata$x:000009DC ; Segment type: Pure data
.xdata$x:000009DC ; Segment permissions: Read
.xdata$x:000009DC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000009DC                 assume cs:_xdata$x
.xdata$x:000009DC                 ;org 9DCh
.xdata$x:000009DC __unwindtable$?Get_Correct_FsFile_Name@@YG?AVUString@@ABV1@@Z db 0FFh
.xdata$x:000009DC                                         ; DATA XREF: .xdata$x:000009F4o
.xdata$x:000009DD                 db 0FFh
.xdata$x:000009DE                 db 0FFh
.xdata$x:000009DF                 db 0FFh
.xdata$x:000009E0                 dd offset __unwindfunclet$?Get_Correct_FsFile_Name@@YG?AVUString@@ABV1@@Z$1
.xdata$x:000009E4                 align 8
.xdata$x:000009E8                 dd offset __unwindfunclet$?Get_Correct_FsFile_Name@@YG?AVUString@@ABV1@@Z$0
.xdata$x:000009EC __ehfuncinfo$?Get_Correct_FsFile_Name@@YG?AVUString@@ABV1@@Z db  22h ; "
.xdata$x:000009EC                                         ; DATA XREF: __ehhandler$?Get_Correct_FsFile_Name@@YG?AVUString@@ABV1@@Z+11o
.xdata$x:000009ED                 db    5
.xdata$x:000009EE                 db  93h ; ô
.xdata$x:000009EF                 db  19h
.xdata$x:000009F0                 db    2
.xdata$x:000009F1                 db    0
.xdata$x:000009F2                 db    0
.xdata$x:000009F3                 db    0
.xdata$x:000009F4                 dd offset __unwindtable$?Get_Correct_FsFile_Name@@YG?AVUString@@ABV1@@Z
.xdata$x:000009F8                 db    0
.xdata$x:000009F9                 db    0
.xdata$x:000009FA                 db    0
.xdata$x:000009FB                 db    0
.xdata$x:000009FC                 db    0
.xdata$x:000009FD                 db    0
.xdata$x:000009FE                 db    0
.xdata$x:000009FF                 db    0
.xdata$x:00000A00                 db    0
.xdata$x:00000A01                 db    0
.xdata$x:00000A02                 db    0
.xdata$x:00000A03                 db    0
.xdata$x:00000A04                 db    0
.xdata$x:00000A05                 db    0
.xdata$x:00000A06                 db    0
.xdata$x:00000A07                 db    0
.xdata$x:00000A08                 db    0
.xdata$x:00000A09                 db    0
.xdata$x:00000A0A                 db    0
.xdata$x:00000A0B                 db    0
.xdata$x:00000A0C                 db    1
.xdata$x:00000A0D                 db    0
.xdata$x:00000A0E                 db    0
.xdata$x:00000A0F                 db    0
.xdata$x:00000A10 __unwindtable$?Correct_FsPath@@YGX_NAAV?$CObjectVector@VUString@@@@0@Z db 0FFh
.xdata$x:00000A10                                         ; DATA XREF: .xdata$x:00000A28o
.xdata$x:00000A11                 db 0FFh
.xdata$x:00000A12                 db 0FFh
.xdata$x:00000A13                 db 0FFh
.xdata$x:00000A14                 dd offset __unwindfunclet$?Correct_FsPath@@YGX_NAAV?$CObjectVector@VUString@@@@0@Z$0
.xdata$x:00000A18                 db 0FFh
.xdata$x:00000A19                 db 0FFh
.xdata$x:00000A1A                 db 0FFh
.xdata$x:00000A1B                 db 0FFh
.xdata$x:00000A1C                 dd offset __unwindfunclet$?Correct_FsPath@@YGX_NAAV?$CObjectVector@VUString@@@@0@Z$1
.xdata$x:00000A20 __ehfuncinfo$?Correct_FsPath@@YGX_NAAV?$CObjectVector@VUString@@@@0@Z db  22h ; "
.xdata$x:00000A20                                         ; DATA XREF: __ehhandler$?Correct_FsPath@@YGX_NAAV?$CObjectVector@VUString@@@@0@Z+11o
.xdata$x:00000A21                 db    5
.xdata$x:00000A22                 db  93h ; ô
.xdata$x:00000A23                 db  19h
.xdata$x:00000A24                 db    2
.xdata$x:00000A25                 db    0
.xdata$x:00000A26                 db    0
.xdata$x:00000A27                 db    0
.xdata$x:00000A28                 dd offset __unwindtable$?Correct_FsPath@@YGX_NAAV?$CObjectVector@VUString@@@@0@Z
.xdata$x:00000A2C                 align 20h
.xdata$x:00000A40                 db    1
.xdata$x:00000A41                 db    0
.xdata$x:00000A42                 db    0
.xdata$x:00000A43                 db    0
.xdata$x:00000A44 __unwindtable$?MakePathFromParts@@YG?AVUString@@ABV?$CObjectVector@VUString@@@@@Z db 0FFh
.xdata$x:00000A44                                         ; DATA XREF: .xdata$x:00000A5Co
.xdata$x:00000A45                 db 0FFh
.xdata$x:00000A46                 db 0FFh
.xdata$x:00000A47                 db 0FFh
.xdata$x:00000A48                 dd offset __unwindfunclet$?MakePathFromParts@@YG?AVUString@@ABV?$CObjectVector@VUString@@@@@Z$1
.xdata$x:00000A4C                 align 10h
.xdata$x:00000A50                 dd offset __unwindfunclet$?MakePathFromParts@@YG?AVUString@@ABV?$CObjectVector@VUString@@@@@Z$0
.xdata$x:00000A54 __ehfuncinfo$?MakePathFromParts@@YG?AVUString@@ABV?$CObjectVector@VUString@@@@@Z db  22h ; "
.xdata$x:00000A54                                         ; DATA XREF: __ehhandler$?MakePathFromParts@@YG?AVUString@@ABV?$CObjectVector@VUString@@@@@Z+11o
.xdata$x:00000A55                 db    5
.xdata$x:00000A56                 db  93h ; ô
.xdata$x:00000A57                 db  19h
.xdata$x:00000A58                 db    2
.xdata$x:00000A59                 db    0
.xdata$x:00000A5A                 db    0
.xdata$x:00000A5B                 db    0
.xdata$x:00000A5C                 dd offset __unwindtable$?MakePathFromParts@@YG?AVUString@@ABV?$CObjectVector@VUString@@@@@Z
.xdata$x:00000A60                 db    0
.xdata$x:00000A61                 db    0
.xdata$x:00000A62                 db    0
.xdata$x:00000A63                 db    0
.xdata$x:00000A64                 db    0
.xdata$x:00000A65                 db    0
.xdata$x:00000A66                 db    0
.xdata$x:00000A67                 db    0
.xdata$x:00000A68                 db    0
.xdata$x:00000A69                 db    0
.xdata$x:00000A6A                 db    0
.xdata$x:00000A6B                 db    0
.xdata$x:00000A6C                 db    0
.xdata$x:00000A6D                 db    0
.xdata$x:00000A6E                 db    0
.xdata$x:00000A6F                 db    0
.xdata$x:00000A70                 db    0
.xdata$x:00000A71                 db    0
.xdata$x:00000A72                 db    0
.xdata$x:00000A73                 db    0
.xdata$x:00000A74                 db    1
.xdata$x:00000A75                 db    0
.xdata$x:00000A76                 db    0
.xdata$x:00000A77                 db    0
.xdata$x:00000A77 _xdata$x        ends
.xdata$x:00000A77
.text:00000A78 ; ===========================================================================
.text:00000A78
.text:00000A78 ; Segment type: Pure code
.text:00000A78 ; Segment permissions: Read/Execute
.text:00000A78 _text           segment para public 'CODE' use32
.text:00000A78                 assume cs:_text
.text:00000A78                 ;org 0A78h
.text:00000A78 ; COMDAT (pick any)
.text:00000A78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000A78
.text:00000A78 ; =============== S U B R O U T I N E =======================================
.text:00000A78
.text:00000A78 ; Attributes: bp-based frame
.text:00000A78
.text:00000A78 ; _DWORD __thiscall UString::~UString(UString *__hidden this)
.text:00000A78                 public ??1UString@@QAE@XZ
.text:00000A78 ??1UString@@QAE@XZ proc near            ; CODE XREF: Get_Correct_FsFile_Name(UString const &)+9Dp
.text:00000A78                                         ; Correct_FsPath(bool,CObjectVector<UString> &,bool)+18Bp ...
.text:00000A78
.text:00000A78 var_8           = dword ptr -8
.text:00000A78 var_4           = dword ptr -4
.text:00000A78
.text:00000A78                 push    ebp
.text:00000A79                 mov     ebp, esp
.text:00000A7B                 sub     esp, 8
.text:00000A7E                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00000A85                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000A8C                 mov     [ebp+var_4], ecx
.text:00000A8F                 mov     eax, [ebp+var_4]
.text:00000A92                 mov     ecx, [eax]
.text:00000A94                 mov     [ebp+var_8], ecx
.text:00000A97                 mov     edx, [ebp+var_8]
.text:00000A9A                 push    edx             ; void *
.text:00000A9B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00000AA0                 add     esp, 4
.text:00000AA3                 add     esp, 8
.text:00000AA6                 cmp     ebp, esp
.text:00000AA8                 call    __RTC_CheckEsp
.text:00000AAD                 mov     esp, ebp
.text:00000AAF                 pop     ebp
.text:00000AB0                 retn
.text:00000AB0 ??1UString@@QAE@XZ endp
.text:00000AB0
.text:00000AB0 ; ---------------------------------------------------------------------------
.text:00000AB1                 align 4
.text:00000AB1 _text           ends
.text:00000AB1
.text:00000AB4 ; ===========================================================================
.text:00000AB4
.text:00000AB4 ; Segment type: Pure code
.text:00000AB4 ; Segment permissions: Read/Execute
.text:00000AB4 _text           segment para public 'CODE' use32
.text:00000AB4                 assume cs:_text
.text:00000AB4                 ;org 0AB4h
.text:00000AB4 ; COMDAT (pick any)
.text:00000AB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000AB4
.text:00000AB4 ; =============== S U B R O U T I N E =======================================
.text:00000AB4
.text:00000AB4 ; Attributes: bp-based frame
.text:00000AB4
.text:00000AB4 ; unsigned int __stdcall MyStringLen(const char *)
.text:00000AB4                 public ?MyStringLen@@YGIPBD@Z
.text:00000AB4 ?MyStringLen@@YGIPBD@Z proc near        ; CODE XREF: IsSupportedName(UString const &)+47p
.text:00000AB4
.text:00000AB4 var_4           = dword ptr -4
.text:00000AB4 arg_0           = dword ptr  8
.text:00000AB4
.text:00000AB4                 push    ebp
.text:00000AB5                 mov     ebp, esp
.text:00000AB7                 push    ecx
.text:00000AB8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000ABF                 mov     [ebp+var_4], 0
.text:00000AC6                 jmp     short loc_AD1
.text:00000AC8 ; ---------------------------------------------------------------------------
.text:00000AC8
.text:00000AC8 loc_AC8:                                ; CODE XREF: MyStringLen(char const *)+2Aj
.text:00000AC8                 mov     eax, [ebp+var_4]
.text:00000ACB                 add     eax, 1
.text:00000ACE                 mov     [ebp+var_4], eax
.text:00000AD1
.text:00000AD1 loc_AD1:                                ; CODE XREF: MyStringLen(char const *)+12j
.text:00000AD1                 mov     ecx, [ebp+arg_0]
.text:00000AD4                 add     ecx, [ebp+var_4]
.text:00000AD7                 movsx   edx, byte ptr [ecx]
.text:00000ADA                 test    edx, edx
.text:00000ADC                 jz      short loc_AE0
.text:00000ADE                 jmp     short loc_AC8
.text:00000AE0 ; ---------------------------------------------------------------------------
.text:00000AE0
.text:00000AE0 loc_AE0:                                ; CODE XREF: MyStringLen(char const *)+28j
.text:00000AE0                 mov     eax, [ebp+var_4]
.text:00000AE3                 mov     esp, ebp
.text:00000AE5                 pop     ebp
.text:00000AE6                 retn    4
.text:00000AE6 ?MyStringLen@@YGIPBD@Z endp
.text:00000AE6
.text:00000AE6 ; ---------------------------------------------------------------------------
.text:00000AE9                 align 4
.text:00000AE9 _text           ends
.text:00000AE9
.text:00000AEC ; ===========================================================================
.text:00000AEC
.text:00000AEC ; Segment type: Pure code
.text:00000AEC ; Segment permissions: Read/Execute
.text:00000AEC _text           segment para public 'CODE' use32
.text:00000AEC                 assume cs:_text
.text:00000AEC                 ;org 0AECh
.text:00000AEC ; COMDAT (pick any)
.text:00000AEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000AEC
.text:00000AEC ; =============== S U B R O U T I N E =======================================
.text:00000AEC
.text:00000AEC ; Attributes: bp-based frame
.text:00000AEC
.text:00000AEC ; void __thiscall UString::Empty(UString *__hidden this)
.text:00000AEC                 public ?Empty@UString@@QAEXXZ
.text:00000AEC ?Empty@UString@@QAEXXZ proc near        ; CODE XREF: Correct_PathPart(UString &)+47p
.text:00000AEC
.text:00000AEC var_4           = dword ptr -4
.text:00000AEC
.text:00000AEC                 push    ebp
.text:00000AED                 mov     ebp, esp
.text:00000AEF                 push    ecx
.text:00000AF0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000AF7                 mov     [ebp+var_4], ecx
.text:00000AFA                 mov     eax, [ebp+var_4]
.text:00000AFD                 mov     dword ptr [eax+4], 0
.text:00000B04                 mov     ecx, [ebp+var_4]
.text:00000B07                 mov     edx, [ecx]
.text:00000B09                 xor     eax, eax
.text:00000B0B                 mov     [edx], ax
.text:00000B0E                 mov     esp, ebp
.text:00000B10                 pop     ebp
.text:00000B11                 retn
.text:00000B11 ?Empty@UString@@QAEXXZ endp
.text:00000B11
.text:00000B11 ; ---------------------------------------------------------------------------
.text:00000B12                 align 4
.text:00000B12 _text           ends
.text:00000B12
.text:00000B14 ; ===========================================================================
.text:00000B14
.text:00000B14 ; Segment type: Pure code
.text:00000B14 ; Segment permissions: Read/Execute
.text:00000B14 _text           segment para public 'CODE' use32
.text:00000B14                 assume cs:_text
.text:00000B14                 ;org 0B14h
.text:00000B14 ; COMDAT (pick any)
.text:00000B14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000B14
.text:00000B14 ; =============== S U B R O U T I N E =======================================
.text:00000B14
.text:00000B14 ; Attributes: bp-based frame
.text:00000B14
.text:00000B14 ; const wchar_t *__thiscall UString::Ptr(UString *this, unsigned int)
.text:00000B14                 public ?Ptr@UString@@QBEPB_WI@Z
.text:00000B14 ?Ptr@UString@@QBEPB_WI@Z proc near      ; CODE XREF: Correct_FsPath(bool,CObjectVector<UString> &,bool)+15Cp
.text:00000B14
.text:00000B14 var_4           = dword ptr -4
.text:00000B14 arg_0           = dword ptr  8
.text:00000B14
.text:00000B14                 push    ebp
.text:00000B15                 mov     ebp, esp
.text:00000B17                 push    ecx
.text:00000B18                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000B1F                 mov     [ebp+var_4], ecx
.text:00000B22                 mov     eax, [ebp+var_4]
.text:00000B25                 mov     ecx, [eax]
.text:00000B27                 mov     edx, [ebp+arg_0]
.text:00000B2A                 lea     eax, [ecx+edx*2]
.text:00000B2D                 mov     esp, ebp
.text:00000B2F                 pop     ebp
.text:00000B30                 retn    4
.text:00000B30 ?Ptr@UString@@QBEPB_WI@Z endp
.text:00000B30
.text:00000B30 ; ---------------------------------------------------------------------------
.text:00000B33                 align 4
.text:00000B33 _text           ends
.text:00000B33
.text:00000B34 ; ===========================================================================
.text:00000B34
.text:00000B34 ; Segment type: Pure code
.text:00000B34 ; Segment permissions: Read/Execute
.text:00000B34 _text           segment para public 'CODE' use32
.text:00000B34                 assume cs:_text
.text:00000B34                 ;org 0B34h
.text:00000B34 ; COMDAT (pick any)
.text:00000B34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000B34
.text:00000B34 ; =============== S U B R O U T I N E =======================================
.text:00000B34
.text:00000B34 ; Attributes: bp-based frame
.text:00000B34
.text:00000B34 ; int __stdcall operator==(int, wchar_t *Str2)
.text:00000B34                 public ??8@YG_NABVUString@@PB_W@Z
.text:00000B34 ??8@YG_NABVUString@@PB_W@Z proc near    ; CODE XREF: Correct_FsPath(bool,CObjectVector<UString> &,bool)+BCp
.text:00000B34
.text:00000B34 arg_0           = dword ptr  8
.text:00000B34 Str2            = dword ptr  0Ch
.text:00000B34
.text:00000B34                 push    ebp
.text:00000B35                 mov     ebp, esp
.text:00000B37                 push    esi
.text:00000B38                 mov     esi, esp
.text:00000B3A                 mov     eax, [ebp+Str2]
.text:00000B3D                 push    eax             ; Str2
.text:00000B3E                 mov     ecx, [ebp+arg_0]
.text:00000B41                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00000B46                 push    eax             ; Str1
.text:00000B47                 call    dword ptr ds:__imp__wcscmp
.text:00000B4D                 add     esp, 8
.text:00000B50                 cmp     esi, esp
.text:00000B52                 call    __RTC_CheckEsp
.text:00000B57                 neg     eax
.text:00000B59                 sbb     eax, eax
.text:00000B5B                 add     eax, 1
.text:00000B5E                 pop     esi
.text:00000B5F                 cmp     ebp, esp
.text:00000B61                 call    __RTC_CheckEsp
.text:00000B66                 pop     ebp
.text:00000B67                 retn    8
.text:00000B67 ??8@YG_NABVUString@@PB_W@Z endp
.text:00000B67
.text:00000B67 ; ---------------------------------------------------------------------------
.text:00000B6A                 align 4
.text:00000B6A _text           ends
.text:00000B6A
.text:00000B6C ; ===========================================================================
.text:00000B6C
.text:00000B6C ; Segment type: Pure code
.text:00000B6C ; Segment permissions: Read/Execute
.text:00000B6C _text           segment para public 'CODE' use32
.text:00000B6C                 assume cs:_text
.text:00000B6C                 ;org 0B6Ch
.text:00000B6C ; COMDAT (pick any)
.text:00000B6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000B6C
.text:00000B6C ; =============== S U B R O U T I N E =======================================
.text:00000B6C
.text:00000B6C ; Attributes: bp-based frame
.text:00000B6C
.text:00000B6C ; void __thiscall UString::Add_PathSepar(UString *__hidden this)
.text:00000B6C                 public ?Add_PathSepar@UString@@QAEXXZ
.text:00000B6C ?Add_PathSepar@UString@@QAEXXZ proc near
.text:00000B6C                                         ; CODE XREF: MakePathFromParts(CObjectVector<UString> const &)+7Dp
.text:00000B6C
.text:00000B6C var_4           = dword ptr -4
.text:00000B6C
.text:00000B6C                 push    ebp
.text:00000B6D                 mov     ebp, esp
.text:00000B6F                 push    ecx
.text:00000B70                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000B77                 mov     [ebp+var_4], ecx
.text:00000B7A                 push    5Ch ; '\'
.text:00000B7C                 mov     ecx, [ebp+var_4]
.text:00000B7F                 call    ??YUString@@QAEAAV0@_W@Z ; UString::operator+=(wchar_t)
.text:00000B84                 add     esp, 4
.text:00000B87                 cmp     ebp, esp
.text:00000B89                 call    __RTC_CheckEsp
.text:00000B8E                 mov     esp, ebp
.text:00000B90                 pop     ebp
.text:00000B91                 retn
.text:00000B91 ?Add_PathSepar@UString@@QAEXXZ endp
.text:00000B91
.text:00000B91 ; ---------------------------------------------------------------------------
.text:00000B92                 align 4
.text:00000B92 _text           ends
.text:00000B92
.text:00000B94 ; ===========================================================================
.text:00000B94
.text:00000B94 ; Segment type: Pure code
.text:00000B94 ; Segment permissions: Read/Execute
.text:00000B94 _text           segment para public 'CODE' use32
.text:00000B94                 assume cs:_text
.text:00000B94                 ;org 0B94h
.text:00000B94 ; COMDAT (pick any)
.text:00000B94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000B94
.text:00000B94 ; =============== S U B R O U T I N E =======================================
.text:00000B94
.text:00000B94 ; Attributes: bp-based frame
.text:00000B94
.text:00000B94 ; public: class UString & __thiscall UString::operator+=(wchar_t)
.text:00000B94                 public ??YUString@@QAEAAV0@_W@Z
.text:00000B94 ??YUString@@QAEAAV0@_W@Z proc near      ; CODE XREF: UString::Add_PathSepar(void)+13p
.text:00000B94
.text:00000B94 var_C           = dword ptr -0Ch
.text:00000B94 var_8           = dword ptr -8
.text:00000B94 var_4           = dword ptr -4
.text:00000B94 arg_0           = word ptr  8
.text:00000B94
.text:00000B94                 push    ebp
.text:00000B95                 mov     ebp, esp
.text:00000B97                 sub     esp, 0Ch
.text:00000B9A                 mov     [ebp+var_C], 0CCCCCCCCh
.text:00000BA1                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00000BA8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000BAF                 mov     [ebp+var_4], ecx
.text:00000BB2                 mov     eax, [ebp+var_4]
.text:00000BB5                 mov     ecx, [ebp+var_4]
.text:00000BB8                 mov     edx, [eax+8]
.text:00000BBB                 cmp     edx, [ecx+4]
.text:00000BBE                 jnz     short loc_BC8
.text:00000BC0                 mov     ecx, [ebp+var_4] ; this
.text:00000BC3                 call    ?Grow_1@UString@@AAEXXZ ; UString::Grow_1(void)
.text:00000BC8
.text:00000BC8 loc_BC8:                                ; CODE XREF: UString::operator+=(wchar_t)+2Aj
.text:00000BC8                 mov     eax, [ebp+var_4]
.text:00000BCB                 mov     ecx, [eax+4]
.text:00000BCE                 mov     [ebp+var_8], ecx
.text:00000BD1                 mov     edx, [ebp+var_4]
.text:00000BD4                 mov     eax, [edx]
.text:00000BD6                 mov     [ebp+var_C], eax
.text:00000BD9                 mov     ecx, [ebp+var_8]
.text:00000BDC                 mov     edx, [ebp+var_C]
.text:00000BDF                 mov     ax, [ebp+arg_0]
.text:00000BE3                 mov     [edx+ecx*2], ax
.text:00000BE7                 mov     ecx, [ebp+var_8]
.text:00000BEA                 add     ecx, 1
.text:00000BED                 mov     [ebp+var_8], ecx
.text:00000BF0                 xor     edx, edx
.text:00000BF2                 mov     eax, [ebp+var_8]
.text:00000BF5                 mov     ecx, [ebp+var_C]
.text:00000BF8                 mov     [ecx+eax*2], dx
.text:00000BFC                 mov     edx, [ebp+var_4]
.text:00000BFF                 mov     eax, [ebp+var_8]
.text:00000C02                 mov     [edx+4], eax
.text:00000C05                 mov     eax, [ebp+var_4]
.text:00000C08                 add     esp, 0Ch
.text:00000C0B                 cmp     ebp, esp
.text:00000C0D                 call    __RTC_CheckEsp
.text:00000C12                 mov     esp, ebp
.text:00000C14                 pop     ebp
.text:00000C15                 retn    4
.text:00000C15 ??YUString@@QAEAAV0@_W@Z endp
.text:00000C15
.text:00000C15 _text           ends
.text:00000C15
.text:00000C18 ; ===========================================================================
.text:00000C18
.text:00000C18 ; Segment type: Pure code
.text:00000C18 ; Segment permissions: Read/Execute
.text:00000C18 _text           segment para public 'CODE' use32
.text:00000C18                 assume cs:_text
.text:00000C18                 ;org 0C18h
.text:00000C18 ; COMDAT (pick any)
.text:00000C18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000C18
.text:00000C18 ; =============== S U B R O U T I N E =======================================
.text:00000C18
.text:00000C18 ; Attributes: bp-based frame
.text:00000C18
.text:00000C18 ; public: unsigned int __thiscall CObjectVector<class UString>::Size(void)const
.text:00000C18                 public ?Size@?$CObjectVector@VUString@@@@QBEIXZ
.text:00000C18 ?Size@?$CObjectVector@VUString@@@@QBEIXZ proc near
.text:00000C18                                         ; CODE XREF: Correct_FsPath(bool,CObjectVector<UString> &,bool)+72p
.text:00000C18                                         ; Correct_FsPath(bool,CObjectVector<UString> &,bool)+A2p ...
.text:00000C18
.text:00000C18 var_4           = dword ptr -4
.text:00000C18
.text:00000C18                 push    ebp
.text:00000C19                 mov     ebp, esp
.text:00000C1B                 push    ecx
.text:00000C1C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000C23                 mov     [ebp+var_4], ecx
.text:00000C26                 mov     ecx, [ebp+var_4]
.text:00000C29                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00000C2E                 add     esp, 4
.text:00000C31                 cmp     ebp, esp
.text:00000C33                 call    __RTC_CheckEsp
.text:00000C38                 mov     esp, ebp
.text:00000C3A                 pop     ebp
.text:00000C3B                 retn
.text:00000C3B ?Size@?$CObjectVector@VUString@@@@QBEIXZ endp
.text:00000C3B
.text:00000C3B _text           ends
.text:00000C3B
.text:00000C3C ; ===========================================================================
.text:00000C3C
.text:00000C3C ; Segment type: Pure code
.text:00000C3C ; Segment permissions: Read/Execute
.text:00000C3C _text           segment para public 'CODE' use32
.text:00000C3C                 assume cs:_text
.text:00000C3C                 ;org 0C3Ch
.text:00000C3C ; COMDAT (pick any)
.text:00000C3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000C3C
.text:00000C3C ; =============== S U B R O U T I N E =======================================
.text:00000C3C
.text:00000C3C ; Attributes: bp-based frame
.text:00000C3C
.text:00000C3C ; public: bool __thiscall CObjectVector<class UString>::IsEmpty(void)const
.text:00000C3C                 public ?IsEmpty@?$CObjectVector@VUString@@@@QBE_NXZ
.text:00000C3C ?IsEmpty@?$CObjectVector@VUString@@@@QBE_NXZ proc near
.text:00000C3C                                         ; CODE XREF: Correct_FsPath(bool,CObjectVector<UString> &,bool)+215p
.text:00000C3C
.text:00000C3C var_4           = dword ptr -4
.text:00000C3C
.text:00000C3C                 push    ebp
.text:00000C3D                 mov     ebp, esp
.text:00000C3F                 push    ecx
.text:00000C40                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000C47                 mov     [ebp+var_4], ecx
.text:00000C4A                 mov     ecx, [ebp+var_4]
.text:00000C4D                 call    ?IsEmpty@?$CRecordVector@PAX@@QBE_NXZ ; CRecordVector<void *>::IsEmpty(void)
.text:00000C52                 add     esp, 4
.text:00000C55                 cmp     ebp, esp
.text:00000C57                 call    __RTC_CheckEsp
.text:00000C5C                 mov     esp, ebp
.text:00000C5E                 pop     ebp
.text:00000C5F                 retn
.text:00000C5F ?IsEmpty@?$CObjectVector@VUString@@@@QBE_NXZ endp
.text:00000C5F
.text:00000C5F _text           ends
.text:00000C5F
.text:00000C60 ; ===========================================================================
.text:00000C60
.text:00000C60 ; Segment type: Pure code
.text:00000C60 ; Segment permissions: Read/Execute
.text:00000C60 _text           segment para public 'CODE' use32
.text:00000C60                 assume cs:_text
.text:00000C60                 ;org 0C60h
.text:00000C60 ; COMDAT (pick any)
.text:00000C60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000C60
.text:00000C60 ; =============== S U B R O U T I N E =======================================
.text:00000C60
.text:00000C60 ; Attributes: bp-based frame
.text:00000C60
.text:00000C60 ; public: class UString const & __thiscall CObjectVector<class UString>::operator[](unsigned int)const
.text:00000C60                 public ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z
.text:00000C60 ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z proc near
.text:00000C60                                         ; CODE XREF: MakePathFromParts(CObjectVector<UString> const &)+89p
.text:00000C60
.text:00000C60 var_4           = dword ptr -4
.text:00000C60 arg_0           = dword ptr  8
.text:00000C60
.text:00000C60                 push    ebp
.text:00000C61                 mov     ebp, esp
.text:00000C63                 push    ecx
.text:00000C64                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000C6B                 mov     [ebp+var_4], ecx
.text:00000C6E                 mov     eax, [ebp+arg_0]
.text:00000C71                 push    eax
.text:00000C72                 mov     ecx, [ebp+var_4]
.text:00000C75                 call    ??A?$CRecordVector@PAX@@QBEABQAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00000C7A                 mov     eax, [eax]
.text:00000C7C                 add     esp, 4
.text:00000C7F                 cmp     ebp, esp
.text:00000C81                 call    __RTC_CheckEsp
.text:00000C86                 mov     esp, ebp
.text:00000C88                 pop     ebp
.text:00000C89                 retn    4
.text:00000C89 ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z endp
.text:00000C89
.text:00000C89 _text           ends
.text:00000C89
.text:00000C8C ; ===========================================================================
.text:00000C8C
.text:00000C8C ; Segment type: Pure code
.text:00000C8C ; Segment permissions: Read/Execute
.text:00000C8C _text           segment para public 'CODE' use32
.text:00000C8C                 assume cs:_text
.text:00000C8C                 ;org 0C8Ch
.text:00000C8C ; COMDAT (pick any)
.text:00000C8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000C8C
.text:00000C8C ; =============== S U B R O U T I N E =======================================
.text:00000C8C
.text:00000C8C ; Attributes: bp-based frame
.text:00000C8C
.text:00000C8C ; public: class UString & __thiscall CObjectVector<class UString>::operator[](unsigned int)
.text:00000C8C                 public ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z
.text:00000C8C ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z proc near
.text:00000C8C                                         ; CODE XREF: Correct_FsPath(bool,CObjectVector<UString> &,bool)+51p
.text:00000C8C                                         ; Correct_FsPath(bool,CObjectVector<UString> &,bool)+85p ...
.text:00000C8C
.text:00000C8C var_4           = dword ptr -4
.text:00000C8C arg_0           = dword ptr  8
.text:00000C8C
.text:00000C8C                 push    ebp
.text:00000C8D                 mov     ebp, esp
.text:00000C8F                 push    ecx
.text:00000C90                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000C97                 mov     [ebp+var_4], ecx
.text:00000C9A                 mov     eax, [ebp+arg_0]
.text:00000C9D                 push    eax
.text:00000C9E                 mov     ecx, [ebp+var_4]
.text:00000CA1                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00000CA6                 mov     eax, [eax]
.text:00000CA8                 add     esp, 4
.text:00000CAB                 cmp     ebp, esp
.text:00000CAD                 call    __RTC_CheckEsp
.text:00000CB2                 mov     esp, ebp
.text:00000CB4                 pop     ebp
.text:00000CB5                 retn    4
.text:00000CB5 ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z endp
.text:00000CB5
.text:00000CB5 _text           ends
.text:00000CB5
.text:00000CB8 ; ===========================================================================
.text:00000CB8
.text:00000CB8 ; Segment type: Pure code
.text:00000CB8 ; Segment permissions: Read/Execute
.text:00000CB8 _text           segment para public 'CODE' use32
.text:00000CB8                 assume cs:_text
.text:00000CB8                 ;org 0CB8h
.text:00000CB8 ; COMDAT (pick any)
.text:00000CB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000CB8
.text:00000CB8 ; =============== S U B R O U T I N E =======================================
.text:00000CB8
.text:00000CB8 ; Attributes: bp-based frame
.text:00000CB8
.text:00000CB8 ; public: class UString & __thiscall CObjectVector<class UString>::Back(void)
.text:00000CB8                 public ?Back@?$CObjectVector@VUString@@@@QAEAAVUString@@XZ
.text:00000CB8 ?Back@?$CObjectVector@VUString@@@@QAEAAVUString@@XZ proc near
.text:00000CB8                                         ; CODE XREF: Correct_FsPath(bool,CObjectVector<UString> &,bool)+252p
.text:00000CB8
.text:00000CB8 var_4           = dword ptr -4
.text:00000CB8
.text:00000CB8                 push    ebp
.text:00000CB9                 mov     ebp, esp
.text:00000CBB                 push    ecx
.text:00000CBC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000CC3                 mov     [ebp+var_4], ecx
.text:00000CC6                 mov     ecx, [ebp+var_4]
.text:00000CC9                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00000CCE                 sub     eax, 1
.text:00000CD1                 push    eax
.text:00000CD2                 mov     ecx, [ebp+var_4]
.text:00000CD5                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00000CDA                 add     esp, 4
.text:00000CDD                 cmp     ebp, esp
.text:00000CDF                 call    __RTC_CheckEsp
.text:00000CE4                 mov     esp, ebp
.text:00000CE6                 pop     ebp
.text:00000CE7                 retn
.text:00000CE7 ?Back@?$CObjectVector@VUString@@@@QAEAAVUString@@XZ endp
.text:00000CE7
.text:00000CE7 _text           ends
.text:00000CE7
.text:00000CE8 ; ===========================================================================
.text:00000CE8
.text:00000CE8 ; Segment type: Pure code
.text:00000CE8 ; Segment permissions: Read/Execute
.text:00000CE8 _text           segment para public 'CODE' use32
.text:00000CE8                 assume cs:_text
.text:00000CE8                 ;org 0CE8h
.text:00000CE8 ; COMDAT (pick any)
.text:00000CE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000CE8
.text:00000CE8 ; =============== S U B R O U T I N E =======================================
.text:00000CE8
.text:00000CE8 ; Attributes: bp-based frame
.text:00000CE8
.text:00000CE8 ; public: unsigned int __thiscall CObjectVector<class UString>::Add(class UString const &)
.text:00000CE8                 public ?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z
.text:00000CE8 ?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z proc near
.text:00000CE8                                         ; CODE XREF: Correct_FsPath(bool,CObjectVector<UString> &,bool)+239p
.text:00000CE8
.text:00000CE8 var_1C          = dword ptr -1Ch
.text:00000CE8 var_18          = dword ptr -18h
.text:00000CE8 var_14          = dword ptr -14h
.text:00000CE8 var_10          = dword ptr -10h
.text:00000CE8 var_C           = dword ptr -0Ch
.text:00000CE8 var_4           = dword ptr -4
.text:00000CE8 arg_0           = dword ptr  8
.text:00000CE8
.text:00000CE8                 push    ebp
.text:00000CE9                 mov     ebp, esp
.text:00000CEB                 push    0FFFFFFFFh
.text:00000CED                 push    offset __ehhandler$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z
.text:00000CF2                 mov     eax, large fs:0
.text:00000CF8                 push    eax
.text:00000CF9                 sub     esp, 10h
.text:00000CFC                 mov     eax, 0CCCCCCCCh
.text:00000D01                 mov     [ebp+var_1C], eax
.text:00000D04                 mov     [ebp+var_18], eax
.text:00000D07                 mov     [ebp+var_14], eax
.text:00000D0A                 mov     [ebp+var_10], eax
.text:00000D0D                 mov     eax, dword ptr ds:___security_cookie
.text:00000D12                 xor     eax, ebp
.text:00000D14                 push    eax
.text:00000D15                 lea     eax, [ebp+var_C]
.text:00000D18                 mov     large fs:0, eax
.text:00000D1E                 mov     [ebp+var_10], ecx
.text:00000D21                 push    0Ch             ; unsigned int
.text:00000D23                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00000D28                 add     esp, 4
.text:00000D2B                 mov     [ebp+var_18], eax
.text:00000D2E                 mov     [ebp+var_4], 0
.text:00000D35                 cmp     [ebp+var_18], 0
.text:00000D39                 jz      short loc_D4C
.text:00000D3B                 mov     eax, [ebp+arg_0]
.text:00000D3E                 push    eax
.text:00000D3F                 mov     ecx, [ebp+var_18]
.text:00000D42                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00000D47                 mov     [ebp+var_1C], eax
.text:00000D4A                 jmp     short loc_D53
.text:00000D4C ; ---------------------------------------------------------------------------
.text:00000D4C
.text:00000D4C loc_D4C:                                ; CODE XREF: CObjectVector<UString>::Add(UString const &)+51j
.text:00000D4C                 mov     [ebp+var_1C], 0
.text:00000D53
.text:00000D53 loc_D53:                                ; CODE XREF: CObjectVector<UString>::Add(UString const &)+62j
.text:00000D53                 mov     ecx, [ebp+var_1C]
.text:00000D56                 mov     [ebp+var_14], ecx
.text:00000D59                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000D60                 mov     edx, [ebp+var_14]
.text:00000D63                 push    edx
.text:00000D64                 mov     ecx, [ebp+var_10]
.text:00000D67                 call    ?Add@?$CRecordVector@PAX@@QAEIQAX@Z ; CRecordVector<void *>::Add(void * const)
.text:00000D6C                 mov     ecx, [ebp+var_C]
.text:00000D6F                 mov     large fs:0, ecx
.text:00000D76                 pop     ecx
.text:00000D77                 add     esp, 1Ch
.text:00000D7A                 cmp     ebp, esp
.text:00000D7C                 call    __RTC_CheckEsp
.text:00000D81                 mov     esp, ebp
.text:00000D83                 pop     ebp
.text:00000D84                 retn    4
.text:00000D84 ?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z endp
.text:00000D84
.text:00000D84 ; ---------------------------------------------------------------------------
.text:00000D87                 align 4
.text:00000D87 _text           ends
.text:00000D87
.text$x:00000D88 ; ===========================================================================
.text$x:00000D88
.text$x:00000D88 ; Segment type: Pure code
.text$x:00000D88 ; Segment permissions: Read/Execute
.text$x:00000D88 _text$x         segment para public 'CODE' use32
.text$x:00000D88                 assume cs:_text$x
.text$x:00000D88                 ;org 0D88h
.text$x:00000D88 ; COMDAT (pick associative to section at CE8)
.text$x:00000D88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000D88
.text$x:00000D88 ; =============== S U B R O U T I N E =======================================
.text$x:00000D88
.text$x:00000D88
.text$x:00000D88 __unwindfunclet$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z$0 proc near
.text$x:00000D88                                         ; DATA XREF: .xdata$x:00000DB4o
.text$x:00000D88                 mov     eax, [ebp-18h]
.text$x:00000D8B                 push    eax             ; void *
.text$x:00000D8C                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00000D91                 pop     ecx
.text$x:00000D92                 retn
.text$x:00000D92 __unwindfunclet$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z$0 endp
.text$x:00000D92
.text$x:00000D93
.text$x:00000D93 ; =============== S U B R O U T I N E =======================================
.text$x:00000D93
.text$x:00000D93
.text$x:00000D93 __ehhandler$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z proc near
.text$x:00000D93                                         ; DATA XREF: CObjectVector<UString>::Add(UString const &)+5o
.text$x:00000D93
.text$x:00000D93 arg_4           = dword ptr  8
.text$x:00000D93
.text$x:00000D93                 mov     edx, [esp+arg_4]
.text$x:00000D97                 lea     eax, [edx+0Ch]
.text$x:00000D9A                 mov     ecx, [edx-14h]
.text$x:00000D9D                 xor     ecx, eax
.text$x:00000D9F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000DA4                 mov     eax, offset __ehfuncinfo$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z
.text$x:00000DA9                 jmp     ___CxxFrameHandler3
.text$x:00000DA9 __ehhandler$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z endp
.text$x:00000DA9
.text$x:00000DA9 ; ---------------------------------------------------------------------------
.text$x:00000DAE                 align 10h
.text$x:00000DAE _text$x         ends
.text$x:00000DAE
.xdata$x:00000DB0 ; ===========================================================================
.xdata$x:00000DB0
.xdata$x:00000DB0 ; Segment type: Pure data
.xdata$x:00000DB0 ; Segment permissions: Read
.xdata$x:00000DB0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00000DB0                 assume cs:_xdata$x
.xdata$x:00000DB0                 ;org 0DB0h
.xdata$x:00000DB0 ; COMDAT (pick associative to section at CE8)
.xdata$x:00000DB0 __unwindtable$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z db 0FFh
.xdata$x:00000DB0                                         ; DATA XREF: .xdata$x:00000DC0o
.xdata$x:00000DB1                 db 0FFh
.xdata$x:00000DB2                 db 0FFh
.xdata$x:00000DB3                 db 0FFh
.xdata$x:00000DB4                 dd offset __unwindfunclet$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z$0
.xdata$x:00000DB8 __ehfuncinfo$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z db  22h ; "
.xdata$x:00000DB8                                         ; DATA XREF: __ehhandler$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z+11o
.xdata$x:00000DB9                 db    5
.xdata$x:00000DBA                 db  93h ; ô
.xdata$x:00000DBB                 db  19h
.xdata$x:00000DBC                 db    1
.xdata$x:00000DBD                 db    0
.xdata$x:00000DBE                 db    0
.xdata$x:00000DBF                 db    0
.xdata$x:00000DC0                 dd offset __unwindtable$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z
.xdata$x:00000DC4                 db    0
.xdata$x:00000DC5                 db    0
.xdata$x:00000DC6                 db    0
.xdata$x:00000DC7                 db    0
.xdata$x:00000DC8                 db    0
.xdata$x:00000DC9                 db    0
.xdata$x:00000DCA                 db    0
.xdata$x:00000DCB                 db    0
.xdata$x:00000DCC                 db    0
.xdata$x:00000DCD                 db    0
.xdata$x:00000DCE                 db    0
.xdata$x:00000DCF                 db    0
.xdata$x:00000DD0                 db    0
.xdata$x:00000DD1                 db    0
.xdata$x:00000DD2                 db    0
.xdata$x:00000DD3                 db    0
.xdata$x:00000DD4                 db    0
.xdata$x:00000DD5                 db    0
.xdata$x:00000DD6                 db    0
.xdata$x:00000DD7                 db    0
.xdata$x:00000DD8                 db    1
.xdata$x:00000DD9                 db    0
.xdata$x:00000DDA                 db    0
.xdata$x:00000DDB                 db    0
.xdata$x:00000DDB _xdata$x        ends
.xdata$x:00000DDB
.text:00000DDC ; ===========================================================================
.text:00000DDC
.text:00000DDC ; Segment type: Pure code
.text:00000DDC ; Segment permissions: Read/Execute
.text:00000DDC _text           segment para public 'CODE' use32
.text:00000DDC                 assume cs:_text
.text:00000DDC                 ;org 0DDCh
.text:00000DDC ; COMDAT (pick any)
.text:00000DDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000DDC
.text:00000DDC ; =============== S U B R O U T I N E =======================================
.text:00000DDC
.text:00000DDC ; Attributes: bp-based frame
.text:00000DDC
.text:00000DDC ; public: void __thiscall CObjectVector<class UString>::Insert(unsigned int, class UString const &)
.text:00000DDC                 public ?Insert@?$CObjectVector@VUString@@@@QAEXIABVUString@@@Z
.text:00000DDC ?Insert@?$CObjectVector@VUString@@@@QAEXIABVUString@@@Z proc near
.text:00000DDC                                         ; CODE XREF: Correct_FsPath(bool,CObjectVector<UString> &,bool)+17Cp
.text:00000DDC
.text:00000DDC var_1C          = dword ptr -1Ch
.text:00000DDC var_18          = dword ptr -18h
.text:00000DDC var_14          = dword ptr -14h
.text:00000DDC var_10          = dword ptr -10h
.text:00000DDC var_C           = dword ptr -0Ch
.text:00000DDC var_4           = dword ptr -4
.text:00000DDC arg_0           = dword ptr  8
.text:00000DDC arg_4           = dword ptr  0Ch
.text:00000DDC
.text:00000DDC                 push    ebp
.text:00000DDD                 mov     ebp, esp
.text:00000DDF                 push    0FFFFFFFFh
.text:00000DE1                 push    offset __ehhandler$?Insert@?$CObjectVector@VUString@@@@QAEXIABVUString@@@Z
.text:00000DE6                 mov     eax, large fs:0
.text:00000DEC                 push    eax
.text:00000DED                 sub     esp, 10h
.text:00000DF0                 mov     eax, 0CCCCCCCCh
.text:00000DF5                 mov     [ebp+var_1C], eax
.text:00000DF8                 mov     [ebp+var_18], eax
.text:00000DFB                 mov     [ebp+var_14], eax
.text:00000DFE                 mov     [ebp+var_10], eax
.text:00000E01                 mov     eax, dword ptr ds:___security_cookie
.text:00000E06                 xor     eax, ebp
.text:00000E08                 push    eax
.text:00000E09                 lea     eax, [ebp+var_C]
.text:00000E0C                 mov     large fs:0, eax
.text:00000E12                 mov     [ebp+var_10], ecx
.text:00000E15                 push    0Ch             ; unsigned int
.text:00000E17                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00000E1C                 add     esp, 4
.text:00000E1F                 mov     [ebp+var_18], eax
.text:00000E22                 mov     [ebp+var_4], 0
.text:00000E29                 cmp     [ebp+var_18], 0
.text:00000E2D                 jz      short loc_E40
.text:00000E2F                 mov     eax, [ebp+arg_4]
.text:00000E32                 push    eax
.text:00000E33                 mov     ecx, [ebp+var_18]
.text:00000E36                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00000E3B                 mov     [ebp+var_1C], eax
.text:00000E3E                 jmp     short loc_E47
.text:00000E40 ; ---------------------------------------------------------------------------
.text:00000E40
.text:00000E40 loc_E40:                                ; CODE XREF: CObjectVector<UString>::Insert(uint,UString const &)+51j
.text:00000E40                 mov     [ebp+var_1C], 0
.text:00000E47
.text:00000E47 loc_E47:                                ; CODE XREF: CObjectVector<UString>::Insert(uint,UString const &)+62j
.text:00000E47                 mov     ecx, [ebp+var_1C]
.text:00000E4A                 mov     [ebp+var_14], ecx
.text:00000E4D                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000E54                 mov     edx, [ebp+var_14]
.text:00000E57                 push    edx
.text:00000E58                 mov     eax, [ebp+arg_0]
.text:00000E5B                 push    eax
.text:00000E5C                 mov     ecx, [ebp+var_10]
.text:00000E5F                 call    ?Insert@?$CRecordVector@PAX@@QAEXIQAX@Z ; CRecordVector<void *>::Insert(uint,void * const)
.text:00000E64                 mov     ecx, [ebp+var_C]
.text:00000E67                 mov     large fs:0, ecx
.text:00000E6E                 pop     ecx
.text:00000E6F                 add     esp, 1Ch
.text:00000E72                 cmp     ebp, esp
.text:00000E74                 call    __RTC_CheckEsp
.text:00000E79                 mov     esp, ebp
.text:00000E7B                 pop     ebp
.text:00000E7C                 retn    8
.text:00000E7C ?Insert@?$CObjectVector@VUString@@@@QAEXIABVUString@@@Z endp
.text:00000E7C
.text:00000E7C ; ---------------------------------------------------------------------------
.text:00000E7F                 align 10h
.text:00000E7F _text           ends
.text:00000E7F
.text$x:00000E80 ; ===========================================================================
.text$x:00000E80
.text$x:00000E80 ; Segment type: Pure code
.text$x:00000E80 ; Segment permissions: Read/Execute
.text$x:00000E80 _text$x         segment para public 'CODE' use32
.text$x:00000E80                 assume cs:_text$x
.text$x:00000E80                 ;org 0E80h
.text$x:00000E80 ; COMDAT (pick associative to section at DDC)
.text$x:00000E80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000E80
.text$x:00000E80 ; =============== S U B R O U T I N E =======================================
.text$x:00000E80
.text$x:00000E80
.text$x:00000E80 __unwindfunclet$?Insert@?$CObjectVector@VUString@@@@QAEXIABVUString@@@Z$0 proc near
.text$x:00000E80                                         ; DATA XREF: .xdata$x:00000EACo
.text$x:00000E80                 mov     eax, [ebp-18h]
.text$x:00000E83                 push    eax             ; void *
.text$x:00000E84                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00000E89                 pop     ecx
.text$x:00000E8A                 retn
.text$x:00000E8A __unwindfunclet$?Insert@?$CObjectVector@VUString@@@@QAEXIABVUString@@@Z$0 endp
.text$x:00000E8A
.text$x:00000E8B
.text$x:00000E8B ; =============== S U B R O U T I N E =======================================
.text$x:00000E8B
.text$x:00000E8B
.text$x:00000E8B __ehhandler$?Insert@?$CObjectVector@VUString@@@@QAEXIABVUString@@@Z proc near
.text$x:00000E8B                                         ; DATA XREF: CObjectVector<UString>::Insert(uint,UString const &)+5o
.text$x:00000E8B
.text$x:00000E8B arg_4           = dword ptr  8
.text$x:00000E8B
.text$x:00000E8B                 mov     edx, [esp+arg_4]
.text$x:00000E8F                 lea     eax, [edx+0Ch]
.text$x:00000E92                 mov     ecx, [edx-14h]
.text$x:00000E95                 xor     ecx, eax
.text$x:00000E97                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000E9C                 mov     eax, offset __ehfuncinfo$?Insert@?$CObjectVector@VUString@@@@QAEXIABVUString@@@Z
.text$x:00000EA1                 jmp     ___CxxFrameHandler3
.text$x:00000EA1 __ehhandler$?Insert@?$CObjectVector@VUString@@@@QAEXIABVUString@@@Z endp
.text$x:00000EA1
.text$x:00000EA1 ; ---------------------------------------------------------------------------
.text$x:00000EA6                 align 4
.text$x:00000EA6 _text$x         ends
.text$x:00000EA6
.xdata$x:00000EA8 ; ===========================================================================
.xdata$x:00000EA8
.xdata$x:00000EA8 ; Segment type: Pure data
.xdata$x:00000EA8 ; Segment permissions: Read
.xdata$x:00000EA8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00000EA8                 assume cs:_xdata$x
.xdata$x:00000EA8                 ;org 0EA8h
.xdata$x:00000EA8 ; COMDAT (pick associative to section at DDC)
.xdata$x:00000EA8 __unwindtable$?Insert@?$CObjectVector@VUString@@@@QAEXIABVUString@@@Z db 0FFh
.xdata$x:00000EA8                                         ; DATA XREF: .xdata$x:00000EB8o
.xdata$x:00000EA9                 db 0FFh
.xdata$x:00000EAA                 db 0FFh
.xdata$x:00000EAB                 db 0FFh
.xdata$x:00000EAC                 dd offset __unwindfunclet$?Insert@?$CObjectVector@VUString@@@@QAEXIABVUString@@@Z$0
.xdata$x:00000EB0 __ehfuncinfo$?Insert@?$CObjectVector@VUString@@@@QAEXIABVUString@@@Z db  22h ; "
.xdata$x:00000EB0                                         ; DATA XREF: __ehhandler$?Insert@?$CObjectVector@VUString@@@@QAEXIABVUString@@@Z+11o
.xdata$x:00000EB1                 db    5
.xdata$x:00000EB2                 db  93h ; ô
.xdata$x:00000EB3                 db  19h
.xdata$x:00000EB4                 db    1
.xdata$x:00000EB5                 db    0
.xdata$x:00000EB6                 db    0
.xdata$x:00000EB7                 db    0
.xdata$x:00000EB8                 dd offset __unwindtable$?Insert@?$CObjectVector@VUString@@@@QAEXIABVUString@@@Z
.xdata$x:00000EBC                 db    0
.xdata$x:00000EBD                 db    0
.xdata$x:00000EBE                 db    0
.xdata$x:00000EBF                 db    0
.xdata$x:00000EC0                 db    0
.xdata$x:00000EC1                 db    0
.xdata$x:00000EC2                 db    0
.xdata$x:00000EC3                 db    0
.xdata$x:00000EC4                 db    0
.xdata$x:00000EC5                 db    0
.xdata$x:00000EC6                 db    0
.xdata$x:00000EC7                 db    0
.xdata$x:00000EC8                 db    0
.xdata$x:00000EC9                 db    0
.xdata$x:00000ECA                 db    0
.xdata$x:00000ECB                 db    0
.xdata$x:00000ECC                 db    0
.xdata$x:00000ECD                 db    0
.xdata$x:00000ECE                 db    0
.xdata$x:00000ECF                 db    0
.xdata$x:00000ED0                 db    1
.xdata$x:00000ED1                 db    0
.xdata$x:00000ED2                 db    0
.xdata$x:00000ED3                 db    0
.xdata$x:00000ED3 _xdata$x        ends
.xdata$x:00000ED3
.text:00000ED4 ; ===========================================================================
.text:00000ED4
.text:00000ED4 ; Segment type: Pure code
.text:00000ED4 ; Segment permissions: Read/Execute
.text:00000ED4 _text           segment para public 'CODE' use32
.text:00000ED4                 assume cs:_text
.text:00000ED4                 ;org 0ED4h
.text:00000ED4 ; COMDAT (pick any)
.text:00000ED4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000ED4
.text:00000ED4 ; =============== S U B R O U T I N E =======================================
.text:00000ED4
.text:00000ED4 ; Attributes: bp-based frame
.text:00000ED4
.text:00000ED4 ; public: void __thiscall CObjectVector<class UString>::Delete(unsigned int)
.text:00000ED4                 public ?Delete@?$CObjectVector@VUString@@@@QAEXI@Z
.text:00000ED4 ?Delete@?$CObjectVector@VUString@@@@QAEXI@Z proc near
.text:00000ED4                                         ; CODE XREF: Correct_FsPath(bool,CObjectVector<UString> &,bool)+1E3p
.text:00000ED4
.text:00000ED4 var_10          = dword ptr -10h
.text:00000ED4 var_C           = dword ptr -0Ch
.text:00000ED4 var_8           = dword ptr -8
.text:00000ED4 var_4           = dword ptr -4
.text:00000ED4 arg_0           = dword ptr  8
.text:00000ED4
.text:00000ED4                 push    ebp
.text:00000ED5                 mov     ebp, esp
.text:00000ED7                 sub     esp, 10h
.text:00000EDA                 mov     eax, 0CCCCCCCCh
.text:00000EDF                 mov     [ebp+var_10], eax
.text:00000EE2                 mov     [ebp+var_C], eax
.text:00000EE5                 mov     [ebp+var_8], eax
.text:00000EE8                 mov     [ebp+var_4], eax
.text:00000EEB                 mov     [ebp+var_4], ecx
.text:00000EEE                 mov     eax, [ebp+arg_0]
.text:00000EF1                 push    eax
.text:00000EF2                 mov     ecx, [ebp+var_4]
.text:00000EF5                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00000EFA                 mov     ecx, [eax]
.text:00000EFC                 mov     [ebp+var_C], ecx
.text:00000EFF                 mov     edx, [ebp+var_C]
.text:00000F02                 mov     [ebp+var_8], edx
.text:00000F05                 cmp     [ebp+var_8], 0
.text:00000F09                 jz      short loc_F1A
.text:00000F0B                 push    1
.text:00000F0D                 mov     ecx, [ebp+var_8]
.text:00000F10                 call    ??_GUString@@QAEPAXI@Z ; UString::`scalar deleting destructor'(uint)
.text:00000F15                 mov     [ebp+var_10], eax
.text:00000F18                 jmp     short loc_F21
.text:00000F1A ; ---------------------------------------------------------------------------
.text:00000F1A
.text:00000F1A loc_F1A:                                ; CODE XREF: CObjectVector<UString>::Delete(uint)+35j
.text:00000F1A                 mov     [ebp+var_10], 0
.text:00000F21
.text:00000F21 loc_F21:                                ; CODE XREF: CObjectVector<UString>::Delete(uint)+44j
.text:00000F21                 mov     eax, [ebp+arg_0]
.text:00000F24                 push    eax
.text:00000F25                 mov     ecx, [ebp+var_4]
.text:00000F28                 call    ?Delete@?$CRecordVector@PAX@@QAEXI@Z ; CRecordVector<void *>::Delete(uint)
.text:00000F2D                 add     esp, 10h
.text:00000F30                 cmp     ebp, esp
.text:00000F32                 call    __RTC_CheckEsp
.text:00000F37                 mov     esp, ebp
.text:00000F39                 pop     ebp
.text:00000F3A                 retn    4
.text:00000F3A ?Delete@?$CObjectVector@VUString@@@@QAEXI@Z endp
.text:00000F3A
.text:00000F3A ; ---------------------------------------------------------------------------
.text:00000F3D                 align 10h
.text:00000F3D _text           ends
.text:00000F3D
.text:00000F40 ; ===========================================================================
.text:00000F40
.text:00000F40 ; Segment type: Pure code
.text:00000F40 ; Segment permissions: Read/Execute
.text:00000F40 _text           segment para public 'CODE' use32
.text:00000F40                 assume cs:_text
.text:00000F40                 ;org 0F40h
.text:00000F40 ; COMDAT (pick any)
.text:00000F40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000F40
.text:00000F40 ; =============== S U B R O U T I N E =======================================
.text:00000F40
.text:00000F40 ; Attributes: bp-based frame
.text:00000F40
.text:00000F40 ; public: void * __thiscall UString::`scalar deleting destructor'(unsigned int)
.text:00000F40                 public ??_GUString@@QAEPAXI@Z
.text:00000F40 ??_GUString@@QAEPAXI@Z proc near        ; CODE XREF: CObjectVector<UString>::Delete(uint)+3Cp
.text:00000F40
.text:00000F40 var_4           = dword ptr -4
.text:00000F40 arg_0           = dword ptr  8
.text:00000F40
.text:00000F40                 push    ebp
.text:00000F41                 mov     ebp, esp
.text:00000F43                 push    ecx
.text:00000F44                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000F4B                 mov     [ebp+var_4], ecx
.text:00000F4E                 mov     ecx, [ebp+var_4] ; this
.text:00000F51                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000F56                 mov     eax, [ebp+arg_0]
.text:00000F59                 and     eax, 1
.text:00000F5C                 jz      short loc_F6A
.text:00000F5E                 mov     ecx, [ebp+var_4]
.text:00000F61                 push    ecx             ; void *
.text:00000F62                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00000F67                 add     esp, 4
.text:00000F6A
.text:00000F6A loc_F6A:                                ; CODE XREF: UString::`scalar deleting destructor'(uint)+1Cj
.text:00000F6A                 mov     eax, [ebp+var_4]
.text:00000F6D                 add     esp, 4
.text:00000F70                 cmp     ebp, esp
.text:00000F72                 call    __RTC_CheckEsp
.text:00000F77                 mov     esp, ebp
.text:00000F79                 pop     ebp
.text:00000F7A                 retn    4
.text:00000F7A ??_GUString@@QAEPAXI@Z endp
.text:00000F7A
.text:00000F7A ; ---------------------------------------------------------------------------
.text:00000F7D                 align 10h
.text:00000F7D _text           ends
.text:00000F7D
.text:00000F80 ; ===========================================================================
.text:00000F80
.text:00000F80 ; Segment type: Pure code
.text:00000F80 ; Segment permissions: Read/Execute
.text:00000F80 _text           segment para public 'CODE' use32
.text:00000F80                 assume cs:_text
.text:00000F80                 ;org 0F80h
.text:00000F80 ; COMDAT (pick any)
.text:00000F80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000F80
.text:00000F80 ; =============== S U B R O U T I N E =======================================
.text:00000F80
.text:00000F80 ; Attributes: bp-based frame
.text:00000F80
.text:00000F80 ; public: unsigned int __thiscall CRecordVector<void *>::Size(void)const
.text:00000F80                 public ?Size@?$CRecordVector@PAX@@QBEIXZ
.text:00000F80 ?Size@?$CRecordVector@PAX@@QBEIXZ proc near
.text:00000F80                                         ; CODE XREF: CObjectVector<UString>::Size(void)+11p
.text:00000F80                                         ; CObjectVector<UString>::Back(void)+11p
.text:00000F80
.text:00000F80 var_4           = dword ptr -4
.text:00000F80
.text:00000F80                 push    ebp
.text:00000F81                 mov     ebp, esp
.text:00000F83                 push    ecx
.text:00000F84                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000F8B                 mov     [ebp+var_4], ecx
.text:00000F8E                 mov     eax, [ebp+var_4]
.text:00000F91                 mov     eax, [eax+4]
.text:00000F94                 mov     esp, ebp
.text:00000F96                 pop     ebp
.text:00000F97                 retn
.text:00000F97 ?Size@?$CRecordVector@PAX@@QBEIXZ endp
.text:00000F97
.text:00000F97 _text           ends
.text:00000F97
.text:00000F98 ; ===========================================================================
.text:00000F98
.text:00000F98 ; Segment type: Pure code
.text:00000F98 ; Segment permissions: Read/Execute
.text:00000F98 _text           segment para public 'CODE' use32
.text:00000F98                 assume cs:_text
.text:00000F98                 ;org 0F98h
.text:00000F98 ; COMDAT (pick any)
.text:00000F98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000F98
.text:00000F98 ; =============== S U B R O U T I N E =======================================
.text:00000F98
.text:00000F98 ; Attributes: bp-based frame
.text:00000F98
.text:00000F98 ; public: bool __thiscall CRecordVector<void *>::IsEmpty(void)const
.text:00000F98                 public ?IsEmpty@?$CRecordVector@PAX@@QBE_NXZ
.text:00000F98 ?IsEmpty@?$CRecordVector@PAX@@QBE_NXZ proc near
.text:00000F98                                         ; CODE XREF: CObjectVector<UString>::IsEmpty(void)+11p
.text:00000F98
.text:00000F98 var_4           = dword ptr -4
.text:00000F98
.text:00000F98                 push    ebp
.text:00000F99                 mov     ebp, esp
.text:00000F9B                 push    ecx
.text:00000F9C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000FA3                 mov     [ebp+var_4], ecx
.text:00000FA6                 mov     eax, [ebp+var_4]
.text:00000FA9                 xor     ecx, ecx
.text:00000FAB                 cmp     dword ptr [eax+4], 0
.text:00000FAF                 setz    cl
.text:00000FB2                 mov     al, cl
.text:00000FB4                 mov     esp, ebp
.text:00000FB6                 pop     ebp
.text:00000FB7                 retn
.text:00000FB7 ?IsEmpty@?$CRecordVector@PAX@@QBE_NXZ endp
.text:00000FB7
.text:00000FB7 _text           ends
.text:00000FB7
.text:00000FB8 ; ===========================================================================
.text:00000FB8
.text:00000FB8 ; Segment type: Pure code
.text:00000FB8 ; Segment permissions: Read/Execute
.text:00000FB8 _text           segment para public 'CODE' use32
.text:00000FB8                 assume cs:_text
.text:00000FB8                 ;org 0FB8h
.text:00000FB8 ; COMDAT (pick any)
.text:00000FB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000FB8
.text:00000FB8 ; =============== S U B R O U T I N E =======================================
.text:00000FB8
.text:00000FB8 ; Attributes: bp-based frame
.text:00000FB8
.text:00000FB8 ; public: void __thiscall CRecordVector<void *>::Delete(unsigned int)
.text:00000FB8                 public ?Delete@?$CRecordVector@PAX@@QAEXI@Z
.text:00000FB8 ?Delete@?$CRecordVector@PAX@@QAEXI@Z proc near
.text:00000FB8                                         ; CODE XREF: CObjectVector<UString>::Delete(uint)+54p
.text:00000FB8
.text:00000FB8 var_4           = dword ptr -4
.text:00000FB8 arg_0           = dword ptr  8
.text:00000FB8
.text:00000FB8                 push    ebp
.text:00000FB9                 mov     ebp, esp
.text:00000FBB                 push    ecx
.text:00000FBC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000FC3                 mov     [ebp+var_4], ecx
.text:00000FC6                 mov     eax, [ebp+arg_0]
.text:00000FC9                 add     eax, 1
.text:00000FCC                 push    eax
.text:00000FCD                 mov     ecx, [ebp+arg_0]
.text:00000FD0                 push    ecx
.text:00000FD1                 mov     ecx, [ebp+var_4]
.text:00000FD4                 call    ?MoveItems@?$CRecordVector@PAX@@AAEXII@Z ; CRecordVector<void *>::MoveItems(uint,uint)
.text:00000FD9                 mov     edx, [ebp+var_4]
.text:00000FDC                 mov     eax, [edx+4]
.text:00000FDF                 sub     eax, 1
.text:00000FE2                 mov     ecx, [ebp+var_4]
.text:00000FE5                 mov     [ecx+4], eax
.text:00000FE8                 add     esp, 4
.text:00000FEB                 cmp     ebp, esp
.text:00000FED                 call    __RTC_CheckEsp
.text:00000FF2                 mov     esp, ebp
.text:00000FF4                 pop     ebp
.text:00000FF5                 retn    4
.text:00000FF5 ?Delete@?$CRecordVector@PAX@@QAEXI@Z endp
.text:00000FF5
.text:00000FF5 _text           ends
.text:00000FF5
.text:00000FF8 ; ===========================================================================
.text:00000FF8
.text:00000FF8 ; Segment type: Pure code
.text:00000FF8 ; Segment permissions: Read/Execute
.text:00000FF8 _text           segment para public 'CODE' use32
.text:00000FF8                 assume cs:_text
.text:00000FF8                 ;org 0FF8h
.text:00000FF8 ; COMDAT (pick any)
.text:00000FF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000FF8
.text:00000FF8 ; =============== S U B R O U T I N E =======================================
.text:00000FF8
.text:00000FF8 ; Attributes: bp-based frame
.text:00000FF8
.text:00000FF8 ; public: unsigned int __thiscall CRecordVector<void *>::Add(void * const)
.text:00000FF8                 public ?Add@?$CRecordVector@PAX@@QAEIQAX@Z
.text:00000FF8 ?Add@?$CRecordVector@PAX@@QAEIQAX@Z proc near
.text:00000FF8                                         ; CODE XREF: CObjectVector<UString>::Add(UString const &)+7Fp
.text:00000FF8
.text:00000FF8 var_8           = dword ptr -8
.text:00000FF8 var_4           = dword ptr -4
.text:00000FF8 arg_0           = dword ptr  8
.text:00000FF8
.text:00000FF8                 push    ebp
.text:00000FF9                 mov     ebp, esp
.text:00000FFB                 sub     esp, 8
.text:00000FFE                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00001005                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000100C                 mov     [ebp+var_4], ecx
.text:0000100F                 mov     ecx, [ebp+var_4]
.text:00001012                 call    ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ ; CRecordVector<void *>::ReserveOnePosition(void)
.text:00001017                 mov     eax, [ebp+var_4]
.text:0000101A                 mov     ecx, [eax+4]
.text:0000101D                 mov     edx, [ebp+var_4]
.text:00001020                 mov     eax, [edx]
.text:00001022                 mov     edx, [ebp+arg_0]
.text:00001025                 mov     [eax+ecx*4], edx
.text:00001028                 mov     eax, [ebp+var_4]
.text:0000102B                 mov     ecx, [eax+4]
.text:0000102E                 mov     [ebp+var_8], ecx
.text:00001031                 mov     edx, [ebp+var_4]
.text:00001034                 mov     eax, [edx+4]
.text:00001037                 add     eax, 1
.text:0000103A                 mov     ecx, [ebp+var_4]
.text:0000103D                 mov     [ecx+4], eax
.text:00001040                 mov     eax, [ebp+var_8]
.text:00001043                 add     esp, 8
.text:00001046                 cmp     ebp, esp
.text:00001048                 call    __RTC_CheckEsp
.text:0000104D                 mov     esp, ebp
.text:0000104F                 pop     ebp
.text:00001050                 retn    4
.text:00001050 ?Add@?$CRecordVector@PAX@@QAEIQAX@Z endp
.text:00001050
.text:00001050 ; ---------------------------------------------------------------------------
.text:00001053                 align 4
.text:00001053 _text           ends
.text:00001053
.text:00001054 ; ===========================================================================
.text:00001054
.text:00001054 ; Segment type: Pure code
.text:00001054 ; Segment permissions: Read/Execute
.text:00001054 _text           segment para public 'CODE' use32
.text:00001054                 assume cs:_text
.text:00001054                 ;org 1054h
.text:00001054 ; COMDAT (pick any)
.text:00001054                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001054
.text:00001054 ; =============== S U B R O U T I N E =======================================
.text:00001054
.text:00001054 ; Attributes: bp-based frame
.text:00001054
.text:00001054 ; public: void __thiscall CRecordVector<void *>::Insert(unsigned int, void * const)
.text:00001054                 public ?Insert@?$CRecordVector@PAX@@QAEXIQAX@Z
.text:00001054 ?Insert@?$CRecordVector@PAX@@QAEXIQAX@Z proc near
.text:00001054                                         ; CODE XREF: CObjectVector<UString>::Insert(uint,UString const &)+83p
.text:00001054
.text:00001054 var_4           = dword ptr -4
.text:00001054 arg_0           = dword ptr  8
.text:00001054 arg_4           = dword ptr  0Ch
.text:00001054
.text:00001054                 push    ebp
.text:00001055                 mov     ebp, esp
.text:00001057                 push    ecx
.text:00001058                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000105F                 mov     [ebp+var_4], ecx
.text:00001062                 mov     ecx, [ebp+var_4]
.text:00001065                 call    ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ ; CRecordVector<void *>::ReserveOnePosition(void)
.text:0000106A                 mov     eax, [ebp+arg_0]
.text:0000106D                 push    eax
.text:0000106E                 mov     ecx, [ebp+arg_0]
.text:00001071                 add     ecx, 1
.text:00001074                 push    ecx
.text:00001075                 mov     ecx, [ebp+var_4]
.text:00001078                 call    ?MoveItems@?$CRecordVector@PAX@@AAEXII@Z ; CRecordVector<void *>::MoveItems(uint,uint)
.text:0000107D                 mov     edx, [ebp+var_4]
.text:00001080                 mov     eax, [edx]
.text:00001082                 mov     ecx, [ebp+arg_0]
.text:00001085                 mov     edx, [ebp+arg_4]
.text:00001088                 mov     [eax+ecx*4], edx
.text:0000108B                 mov     eax, [ebp+var_4]
.text:0000108E                 mov     ecx, [eax+4]
.text:00001091                 add     ecx, 1
.text:00001094                 mov     edx, [ebp+var_4]
.text:00001097                 mov     [edx+4], ecx
.text:0000109A                 add     esp, 4
.text:0000109D                 cmp     ebp, esp
.text:0000109F                 call    __RTC_CheckEsp
.text:000010A4                 mov     esp, ebp
.text:000010A6                 pop     ebp
.text:000010A7                 retn    8
.text:000010A7 ?Insert@?$CRecordVector@PAX@@QAEXIQAX@Z endp
.text:000010A7
.text:000010A7 ; ---------------------------------------------------------------------------
.text:000010AA                 align 4
.text:000010AA _text           ends
.text:000010AA
.text:000010AC ; ===========================================================================
.text:000010AC
.text:000010AC ; Segment type: Pure code
.text:000010AC ; Segment permissions: Read/Execute
.text:000010AC _text           segment para public 'CODE' use32
.text:000010AC                 assume cs:_text
.text:000010AC                 ;org 10ACh
.text:000010AC ; COMDAT (pick any)
.text:000010AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000010AC
.text:000010AC ; =============== S U B R O U T I N E =======================================
.text:000010AC
.text:000010AC ; Attributes: bp-based frame
.text:000010AC
.text:000010AC ; public: void * const & __thiscall CRecordVector<void *>::operator[](unsigned int)const
.text:000010AC                 public ??A?$CRecordVector@PAX@@QBEABQAXI@Z
.text:000010AC ??A?$CRecordVector@PAX@@QBEABQAXI@Z proc near
.text:000010AC                                         ; CODE XREF: CObjectVector<UString>::operator[](uint)+15p
.text:000010AC
.text:000010AC var_4           = dword ptr -4
.text:000010AC arg_0           = dword ptr  8
.text:000010AC
.text:000010AC                 push    ebp
.text:000010AD                 mov     ebp, esp
.text:000010AF                 push    ecx
.text:000010B0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000010B7                 mov     [ebp+var_4], ecx
.text:000010BA                 mov     eax, [ebp+var_4]
.text:000010BD                 mov     ecx, [eax]
.text:000010BF                 mov     edx, [ebp+arg_0]
.text:000010C2                 lea     eax, [ecx+edx*4]
.text:000010C5                 mov     esp, ebp
.text:000010C7                 pop     ebp
.text:000010C8                 retn    4
.text:000010C8 ??A?$CRecordVector@PAX@@QBEABQAXI@Z endp
.text:000010C8
.text:000010C8 ; ---------------------------------------------------------------------------
.text:000010CB                 align 4
.text:000010CB _text           ends
.text:000010CB
.text:000010CC ; ===========================================================================
.text:000010CC
.text:000010CC ; Segment type: Pure code
.text:000010CC ; Segment permissions: Read/Execute
.text:000010CC _text           segment para public 'CODE' use32
.text:000010CC                 assume cs:_text
.text:000010CC                 ;org 10CCh
.text:000010CC ; COMDAT (pick any)
.text:000010CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000010CC
.text:000010CC ; =============== S U B R O U T I N E =======================================
.text:000010CC
.text:000010CC ; Attributes: bp-based frame
.text:000010CC
.text:000010CC ; public: void * & __thiscall CRecordVector<void *>::operator[](unsigned int)
.text:000010CC                 public ??A?$CRecordVector@PAX@@QAEAAPAXI@Z
.text:000010CC ??A?$CRecordVector@PAX@@QAEAAPAXI@Z proc near
.text:000010CC                                         ; CODE XREF: CObjectVector<UString>::operator[](uint)+15p
.text:000010CC                                         ; CObjectVector<UString>::Delete(uint)+21p
.text:000010CC
.text:000010CC var_4           = dword ptr -4
.text:000010CC arg_0           = dword ptr  8
.text:000010CC
.text:000010CC                 push    ebp
.text:000010CD                 mov     ebp, esp
.text:000010CF                 push    ecx
.text:000010D0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000010D7                 mov     [ebp+var_4], ecx
.text:000010DA                 mov     eax, [ebp+var_4]
.text:000010DD                 mov     ecx, [eax]
.text:000010DF                 mov     edx, [ebp+arg_0]
.text:000010E2                 lea     eax, [ecx+edx*4]
.text:000010E5                 mov     esp, ebp
.text:000010E7                 pop     ebp
.text:000010E8                 retn    4
.text:000010E8 ??A?$CRecordVector@PAX@@QAEAAPAXI@Z endp
.text:000010E8
.text:000010E8 ; ---------------------------------------------------------------------------
.text:000010EB                 align 4
.text:000010EB _text           ends
.text:000010EB
.text:000010EC ; ===========================================================================
.text:000010EC
.text:000010EC ; Segment type: Pure code
.text:000010EC ; Segment permissions: Read/Execute
.text:000010EC _text           segment para public 'CODE' use32
.text:000010EC                 assume cs:_text
.text:000010EC                 ;org 10ECh
.text:000010EC ; COMDAT (pick any)
.text:000010EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000010EC
.text:000010EC ; =============== S U B R O U T I N E =======================================
.text:000010EC
.text:000010EC ; Attributes: bp-based frame
.text:000010EC
.text:000010EC ; private: void __thiscall CRecordVector<void *>::MoveItems(unsigned int, unsigned int)
.text:000010EC                 public ?MoveItems@?$CRecordVector@PAX@@AAEXII@Z
.text:000010EC ?MoveItems@?$CRecordVector@PAX@@AAEXII@Z proc near
.text:000010EC                                         ; CODE XREF: CRecordVector<void *>::Delete(uint)+1Cp
.text:000010EC                                         ; CRecordVector<void *>::Insert(uint,void * const)+24p
.text:000010EC
.text:000010EC var_4           = dword ptr -4
.text:000010EC arg_0           = dword ptr  8
.text:000010EC arg_4           = dword ptr  0Ch
.text:000010EC
.text:000010EC                 push    ebp
.text:000010ED                 mov     ebp, esp
.text:000010EF                 push    ecx
.text:000010F0                 push    esi
.text:000010F1                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000010F8                 mov     [ebp+var_4], ecx
.text:000010FB                 mov     eax, [ebp+var_4]
.text:000010FE                 mov     ecx, [eax+4]
.text:00001101                 sub     ecx, [ebp+arg_4]
.text:00001104                 shl     ecx, 2
.text:00001107                 mov     esi, esp
.text:00001109                 push    ecx             ; Size
.text:0000110A                 mov     edx, [ebp+var_4]
.text:0000110D                 mov     eax, [edx]
.text:0000110F                 mov     ecx, [ebp+arg_4]
.text:00001112                 lea     edx, [eax+ecx*4]
.text:00001115                 push    edx             ; Src
.text:00001116                 mov     eax, [ebp+var_4]
.text:00001119                 mov     ecx, [eax]
.text:0000111B                 mov     edx, [ebp+arg_0]
.text:0000111E                 lea     eax, [ecx+edx*4]
.text:00001121                 push    eax             ; Dst
.text:00001122                 call    dword ptr ds:__imp__memmove
.text:00001128                 add     esp, 0Ch
.text:0000112B                 cmp     esi, esp
.text:0000112D                 call    __RTC_CheckEsp
.text:00001132                 pop     esi
.text:00001133                 add     esp, 4
.text:00001136                 cmp     ebp, esp
.text:00001138                 call    __RTC_CheckEsp
.text:0000113D                 mov     esp, ebp
.text:0000113F                 pop     ebp
.text:00001140                 retn    8
.text:00001140 ?MoveItems@?$CRecordVector@PAX@@AAEXII@Z endp
.text:00001140
.text:00001140 ; ---------------------------------------------------------------------------
.text:00001143                 align 4
.text:00001143 _text           ends
.text:00001143
.text:00001144 ; ===========================================================================
.text:00001144
.text:00001144 ; Segment type: Pure code
.text:00001144 ; Segment permissions: Read/Execute
.text:00001144 _text           segment para public 'CODE' use32
.text:00001144                 assume cs:_text
.text:00001144                 ;org 1144h
.text:00001144 ; COMDAT (pick any)
.text:00001144                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001144
.text:00001144 ; =============== S U B R O U T I N E =======================================
.text:00001144
.text:00001144 ; Attributes: bp-based frame
.text:00001144
.text:00001144 ; private: void __thiscall CRecordVector<void *>::ReserveOnePosition(void)
.text:00001144                 public ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ
.text:00001144 ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ proc near
.text:00001144                                         ; CODE XREF: CRecordVector<void *>::Add(void * const)+1Ap
.text:00001144                                         ; CRecordVector<void *>::Insert(uint,void * const)+11p
.text:00001144
.text:00001144 var_14          = dword ptr -14h
.text:00001144 var_10          = dword ptr -10h
.text:00001144 Dst             = dword ptr -0Ch
.text:00001144 var_8           = dword ptr -8
.text:00001144 var_4           = dword ptr -4
.text:00001144
.text:00001144                 push    ebp
.text:00001145                 mov     ebp, esp
.text:00001147                 sub     esp, 14h
.text:0000114A                 mov     eax, 0CCCCCCCCh
.text:0000114F                 mov     [ebp+var_14], eax
.text:00001152                 mov     [ebp+var_10], eax
.text:00001155                 mov     [ebp+Dst], eax
.text:00001158                 mov     [ebp+var_8], eax
.text:0000115B                 mov     [ebp+var_4], eax
.text:0000115E                 mov     [ebp+var_4], ecx
.text:00001161                 mov     eax, [ebp+var_4]
.text:00001164                 mov     ecx, [ebp+var_4]
.text:00001167                 mov     edx, [eax+4]
.text:0000116A                 cmp     edx, [ecx+8]
.text:0000116D                 jnz     loc_11F8
.text:00001173                 mov     eax, [ebp+var_4]
.text:00001176                 mov     ecx, [eax+8]
.text:00001179                 shr     ecx, 2
.text:0000117C                 mov     edx, [ebp+var_4]
.text:0000117F                 mov     eax, [edx+8]
.text:00001182                 lea     ecx, [eax+ecx+1]
.text:00001186                 mov     [ebp+var_8], ecx
.text:00001189                 xor     ecx, ecx
.text:0000118B                 mov     eax, [ebp+var_8]
.text:0000118E                 mov     edx, 4
.text:00001193                 mul     edx
.text:00001195                 seto    cl
.text:00001198                 neg     ecx
.text:0000119A                 or      ecx, eax
.text:0000119C                 push    ecx             ; unsigned int
.text:0000119D                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:000011A2                 add     esp, 4
.text:000011A5                 mov     [ebp+var_10], eax
.text:000011A8                 mov     eax, [ebp+var_10]
.text:000011AB                 mov     [ebp+Dst], eax
.text:000011AE                 mov     ecx, [ebp+var_4]
.text:000011B1                 cmp     dword ptr [ecx+4], 0
.text:000011B5                 jz      short loc_11D3
.text:000011B7                 mov     edx, [ebp+var_4]
.text:000011BA                 mov     eax, [edx+4]
.text:000011BD                 shl     eax, 2
.text:000011C0                 push    eax             ; Size
.text:000011C1                 mov     ecx, [ebp+var_4]
.text:000011C4                 mov     edx, [ecx]
.text:000011C6                 push    edx             ; Src
.text:000011C7                 mov     eax, [ebp+Dst]
.text:000011CA                 push    eax             ; Dst
.text:000011CB                 call    _memcpy
.text:000011D0                 add     esp, 0Ch
.text:000011D3
.text:000011D3 loc_11D3:                               ; CODE XREF: CRecordVector<void *>::ReserveOnePosition(void)+71j
.text:000011D3                 mov     ecx, [ebp+var_4]
.text:000011D6                 mov     edx, [ecx]
.text:000011D8                 mov     [ebp+var_14], edx
.text:000011DB                 mov     eax, [ebp+var_14]
.text:000011DE                 push    eax             ; void *
.text:000011DF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:000011E4                 add     esp, 4
.text:000011E7                 mov     ecx, [ebp+var_4]
.text:000011EA                 mov     edx, [ebp+Dst]
.text:000011ED                 mov     [ecx], edx
.text:000011EF                 mov     eax, [ebp+var_4]
.text:000011F2                 mov     ecx, [ebp+var_8]
.text:000011F5                 mov     [eax+8], ecx
.text:000011F8
.text:000011F8 loc_11F8:                               ; CODE XREF: CRecordVector<void *>::ReserveOnePosition(void)+29j
.text:000011F8                 add     esp, 14h
.text:000011FB                 cmp     ebp, esp
.text:000011FD                 call    __RTC_CheckEsp
.text:00001202                 mov     esp, ebp
.text:00001204                 pop     ebp
.text:00001205                 retn
.text:00001205 ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ endp
.text:00001205
.text:00001205 _text           ends
.text:00001205
UNDEF:00001210 ; ===========================================================================
UNDEF:00001210
UNDEF:00001210 ; Segment type: Externs
UNDEF:00001210 ; UNDEF
UNDEF:00001210 ; public: class UString & __thiscall UString::operator=(wchar_t)
UNDEF:00001210                 extrn ??4UString@@QAEAAV0@_W@Z:near
UNDEF:00001210                                         ; CODE XREF: Correct_AltStream_Name(UString &)+C7p
UNDEF:00001210                                         ; Get_Correct_FsFile_Name(UString const &)+7Cp ...
UNDEF:00001214 ; bool __stdcall StringsAreEqualNoCase_Ascii(const wchar_t *, const char *)
UNDEF:00001214                 extrn ?StringsAreEqualNoCase_Ascii@@YG_NPB_WPBD@Z:near
UNDEF:00001214                                         ; CODE XREF: Correct_AltStream_Name(UString &)+46p
UNDEF:00001218                 extrn __RTC_CheckEsp:near
UNDEF:00001218                                         ; CODE XREF: Correct_AltStream_Name(UString &)+D1p
UNDEF:00001218                                         ; Get_Correct_FsFile_Name(UString const &)+C6p ...
UNDEF:0000121C                 extrn __RTC_Shutdown:near
UNDEF:0000121C                                         ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
UNDEF:00001220                 extrn __RTC_InitBase:near
UNDEF:00001220                                         ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
UNDEF:00001224 ; public: __thiscall UString::UString(class UString const &)
UNDEF:00001224                 extrn ??0UString@@QAE@ABV0@@Z:near
UNDEF:00001224                                         ; CODE XREF: Get_Correct_FsFile_Name(UString const &)+4Ap
UNDEF:00001224                                         ; Get_Correct_FsFile_Name(UString const &)+88p ...
UNDEF:00001228                 extrn ___security_cookie:near
UNDEF:00001228                                         ; DATA XREF: Get_Correct_FsFile_Name(UString const &)+2Br
UNDEF:00001228                                         ; Correct_FsPath(bool,CObjectVector<UString> &,bool)+24r ...
UNDEF:0000122C                 extrn ___CxxFrameHandler3:near
UNDEF:0000122C                                         ; CODE XREF: __ehhandler$?Get_Correct_FsFile_Name@@YG?AVUString@@ABV1@@Z+16j
UNDEF:0000122C                                         ; __ehhandler$?Correct_FsPath@@YGX_NAAV?$CObjectVector@VUString@@@@0@Z+16j ...
UNDEF:00001230 ; __fastcall __security_check_cookie(x)
UNDEF:00001230                 extrn @__security_check_cookie@4:near
UNDEF:00001230                                         ; CODE XREF: __ehhandler$?Get_Correct_FsFile_Name@@YG?AVUString@@ABV1@@Z+Cp
UNDEF:00001230                                         ; __ehhandler$?Correct_FsPath@@YGX_NAAV?$CObjectVector@VUString@@@@0@Z+Cp ...
UNDEF:00001234 ; __fastcall _RTC_CheckStackVars(x, x)
UNDEF:00001234                 extrn @_RTC_CheckStackVars@8:near
UNDEF:00001234                                         ; CODE XREF: Get_Correct_FsFile_Name(UString const &)+AFp
UNDEF:00001234                                         ; Correct_FsPath(bool,CObjectVector<UString> &,bool)+27Dp ...
UNDEF:00001238 ; void __cdecl operator delete(void *)
UNDEF:00001238                 extrn ??3@YAXPAX@Z:near ; CODE XREF: UString::~UString(void)+23p
UNDEF:00001238                                         ; __unwindfunclet$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z$0+4p ...
UNDEF:0000123C ; void __thiscall UString::InsertAtFront(UString *__hidden this, wchar_t)
UNDEF:0000123C                 extrn ?InsertAtFront@UString@@QAEX_W@Z:near
UNDEF:0000123C                                         ; CODE XREF: CorrectUnsupportedName(UString &)+18p
UNDEF:00001240 ; bool __thiscall UString::IsPrefixedBy_Ascii_NoCase(UString *__hidden this, const char *)
UNDEF:00001240                 extrn ?IsPrefixedBy_Ascii_NoCase@UString@@QBE_NPBD@Z:near
UNDEF:00001240                                         ; CODE XREF: IsSupportedName(UString const &)+65p
UNDEF:00001244 ; public: __thiscall UString::UString(wchar_t)
UNDEF:00001244                 extrn ??0UString@@QAE@_W@Z:near
UNDEF:00001244                                         ; CODE XREF: Correct_FsPath(bool,CObjectVector<UString> &,bool)+226p
UNDEF:00001248 ; public: __thiscall UString::UString(wchar_t const *)
UNDEF:00001248                 extrn ??0UString@@QAE@PB_W@Z:near
UNDEF:00001248                                         ; CODE XREF: Correct_FsPath(bool,CObjectVector<UString> &,bool)+165p
UNDEF:0000124C ; bool NWindows::NFile::NName::IsDrivePath2(NWindows::NFile::NName *__hidden this, const wchar_t *)
UNDEF:0000124C                 extrn ?IsDrivePath2@NName@NFile@NWindows@@YG_NPB_W@Z:near
UNDEF:0000124C                                         ; CODE XREF: Correct_FsPath(bool,CObjectVector<UString> &,bool)+EEp
UNDEF:0000124C                                         ; Correct_FsPath(bool,CObjectVector<UString> &,bool)+119p
UNDEF:00001250 ; int __cdecl _wcscmp(const wchar_t *Str1, const wchar_t *Str2)
UNDEF:00001250                 extrn __imp__wcscmp:near
UNDEF:00001250                                         ; CODE XREF: operator==(UString const &,wchar_t const *)+13p
UNDEF:00001250                                         ; DATA XREF: operator==(UString const &,wchar_t const *)+13r
UNDEF:00001254 ; public: class UString & __thiscall UString::operator+=(class UString const &)
UNDEF:00001254                 extrn ??YUString@@QAEAAV0@ABV0@@Z:near
UNDEF:00001254                                         ; CODE XREF: MakePathFromParts(CObjectVector<UString> const &)+92p
UNDEF:00001258 ; public: __thiscall UString::UString(void)
UNDEF:00001258                 extrn ??0UString@@QAE@XZ:near
UNDEF:00001258                                         ; CODE XREF: MakePathFromParts(CObjectVector<UString> const &)+49p
UNDEF:0000125C ; void __thiscall UString::Grow_1(UString *__hidden this)
UNDEF:0000125C                 extrn ?Grow_1@UString@@AAEXXZ:near
UNDEF:0000125C                                         ; CODE XREF: UString::operator+=(wchar_t)+2Fp
UNDEF:00001260 ; void *__cdecl operator new(unsigned int)
UNDEF:00001260                 extrn ??2@YAPAXI@Z:near ; CODE XREF: CObjectVector<UString>::Add(UString const &)+3Bp
UNDEF:00001260                                         ; CObjectVector<UString>::Insert(uint,UString const &)+3Bp ...
UNDEF:00001264 ; void *__cdecl _memmove(void *Dst, const void *Src, size_t Size)
UNDEF:00001264                 extrn __imp__memmove:near
UNDEF:00001264                                         ; CODE XREF: CRecordVector<void *>::MoveItems(uint,uint)+36p
UNDEF:00001264                                         ; DATA XREF: CRecordVector<void *>::MoveItems(uint,uint)+36r
UNDEF:00001268 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:00001268                 extrn _memcpy:near      ; CODE XREF: CRecordVector<void *>::ReserveOnePosition(void)+87p
UNDEF:00001268
UNDEF:00001268
UNDEF:00001268                 end