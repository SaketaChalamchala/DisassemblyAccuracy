.text:00000000 ;
.text:00000000 ; +-------------------------------------------------------------------------+
.text:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.text:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.text:00000000 ; |                      License info: 48-3677-7074-51                      |
.text:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.text:00000000 ; +-------------------------------------------------------------------------+
.text:00000000 ;
.text:00000000 ; Input MD5   : F43BA4674455F7E086C5B70803D938E1
.text:00000000 ; Input CRC32 : 6ABE50C6
.text:00000000
.text:00000000 ; File Name   : C:\workspace\7z1505-src\CPP\7zip\Bundles\Alone\Debug\UniqBlocks.obj
.text:00000000 ; Format      : COFF (X386MAGIC)
.text:00000000 ; includelib "uuid.lib"
.text:00000000 ; includelib "MSVCRTD"
.text:00000000 ; includelib "OLDNAMES"
.text:00000000
.text:00000000                 .686p
.text:00000000                 .mmx
.text:00000000                 .model flat
.text:00000000
.text:00000000 ; ===========================================================================
.text:00000000
.text:00000000 ; Segment type: Pure code
.text:00000000 ; Segment permissions: Read/Execute
.text:00000000 _text           segment para public 'CODE' use32
.text:00000000                 assume cs:_text
.text:00000000                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000000
.text:00000000 ; =============== S U B R O U T I N E =======================================
.text:00000000
.text:00000000 ; Attributes: bp-based frame
.text:00000000
.text:00000000 ; unsigned int __thiscall CUniqBlocks::AddUniq(CUniqBlocks *this, const unsigned __int8 *Buf1, unsigned int)
.text:00000000                 public ?AddUniq@CUniqBlocks@@QAEIPBEI@Z
.text:00000000 ?AddUniq@CUniqBlocks@@QAEIPBEI@Z proc near
.text:00000000
.text:00000000 var_24          = dword ptr -24h
.text:00000000 var_20          = dword ptr -20h
.text:00000000 var_1C          = dword ptr -1Ch
.text:00000000 var_18          = dword ptr -18h
.text:00000000 var_14          = dword ptr -14h
.text:00000000 var_10          = dword ptr -10h
.text:00000000 var_C           = dword ptr -0Ch
.text:00000000 var_8           = dword ptr -8
.text:00000000 var_4           = dword ptr -4
.text:00000000 Buf1            = dword ptr  8
.text:00000000 Size            = dword ptr  0Ch
.text:00000000
.text:00000000                 push    ebp
.text:00000001                 mov     ebp, esp
.text:00000003                 sub     esp, 24h
.text:00000006                 mov     eax, 0CCCCCCCCh
.text:0000000B                 mov     [ebp+var_24], eax
.text:0000000E                 mov     [ebp+var_20], eax
.text:00000011                 mov     [ebp+var_1C], eax
.text:00000014                 mov     [ebp+var_18], eax
.text:00000017                 mov     [ebp+var_14], eax
.text:0000001A                 mov     [ebp+var_10], eax
.text:0000001D                 mov     [ebp+var_C], eax
.text:00000020                 mov     [ebp+var_8], eax
.text:00000023                 mov     [ebp+var_4], eax
.text:00000026                 mov     [ebp+var_4], ecx
.text:00000029                 mov     [ebp+var_8], 0
.text:00000030                 mov     ecx, [ebp+var_4]
.text:00000033                 add     ecx, 0Ch
.text:00000036                 call    ?Size@?$CRecordVector@I@@QBEIXZ ; CRecordVector<uint>::Size(void)
.text:0000003B                 mov     [ebp+var_C], eax
.text:0000003E
.text:0000003E loc_3E:                                 ; CODE XREF: CUniqBlocks::AddUniq(uchar const *,uint):loc_EFj
.text:0000003E                 mov     eax, [ebp+var_8]
.text:00000041                 cmp     eax, [ebp+var_C]
.text:00000044                 jz      loc_F4
.text:0000004A                 mov     ecx, [ebp+var_8]
.text:0000004D                 add     ecx, [ebp+var_C]
.text:00000050                 shr     ecx, 1
.text:00000052                 mov     [ebp+var_10], ecx
.text:00000055                 mov     edx, [ebp+var_10]
.text:00000058                 push    edx
.text:00000059                 mov     ecx, [ebp+var_4]
.text:0000005C                 add     ecx, 0Ch
.text:0000005F                 call    ??A?$CRecordVector@I@@QAEAAII@Z ; CRecordVector<uint>::operator[](uint)
.text:00000064                 mov     eax, [eax]
.text:00000066                 mov     [ebp+var_14], eax
.text:00000069                 mov     ecx, [ebp+var_14]
.text:0000006C                 push    ecx
.text:0000006D                 mov     ecx, [ebp+var_4]
.text:00000070                 call    ??A?$CObjectVector@V?$CBuffer@E@@@@QAEAAV?$CBuffer@E@@I@Z ; CObjectVector<CBuffer<uchar>>::operator[](uint)
.text:00000075                 mov     [ebp+var_18], eax
.text:00000078                 mov     ecx, [ebp+var_18]
.text:0000007B                 call    ?Size@?$CBuffer@E@@QBEIXZ ; CBuffer<uchar>::Size(void)
.text:00000080                 mov     [ebp+var_1C], eax
.text:00000083                 mov     edx, [ebp+Size]
.text:00000086                 cmp     edx, [ebp+var_1C]
.text:00000089                 jnb     short loc_93
.text:0000008B                 mov     eax, [ebp+var_10]
.text:0000008E                 mov     [ebp+var_C], eax
.text:00000091                 jmp     short loc_EF
.text:00000093 ; ---------------------------------------------------------------------------
.text:00000093
.text:00000093 loc_93:                                 ; CODE XREF: CUniqBlocks::AddUniq(uchar const *,uint)+89j
.text:00000093                 mov     ecx, [ebp+Size]
.text:00000096                 cmp     ecx, [ebp+var_1C]
.text:00000099                 jbe     short loc_A6
.text:0000009B                 mov     edx, [ebp+var_10]
.text:0000009E                 add     edx, 1
.text:000000A1                 mov     [ebp+var_8], edx
.text:000000A4                 jmp     short loc_EF
.text:000000A6 ; ---------------------------------------------------------------------------
.text:000000A6
.text:000000A6 loc_A6:                                 ; CODE XREF: CUniqBlocks::AddUniq(uchar const *,uint)+99j
.text:000000A6                 cmp     [ebp+Size], 0
.text:000000AA                 jnz     short loc_B1
.text:000000AC                 mov     eax, [ebp+var_14]
.text:000000AF                 jmp     short loc_12C
.text:000000B1 ; ---------------------------------------------------------------------------
.text:000000B1
.text:000000B1 loc_B1:                                 ; CODE XREF: CUniqBlocks::AddUniq(uchar const *,uint)+AAj
.text:000000B1                 mov     eax, [ebp+Size]
.text:000000B4                 push    eax             ; Size
.text:000000B5                 mov     ecx, [ebp+var_18]
.text:000000B8                 call    ??B?$CBuffer@E@@QBEPBEXZ ; CBuffer<uchar>::operator uchar const *(void)
.text:000000BD                 push    eax             ; Buf2
.text:000000BE                 mov     ecx, [ebp+Buf1]
.text:000000C1                 push    ecx             ; Buf1
.text:000000C2                 call    _memcmp
.text:000000C7                 add     esp, 0Ch
.text:000000CA                 mov     [ebp+var_20], eax
.text:000000CD                 cmp     [ebp+var_20], 0
.text:000000D1                 jnz     short loc_D8
.text:000000D3                 mov     eax, [ebp+var_14]
.text:000000D6                 jmp     short loc_12C
.text:000000D8 ; ---------------------------------------------------------------------------
.text:000000D8
.text:000000D8 loc_D8:                                 ; CODE XREF: CUniqBlocks::AddUniq(uchar const *,uint)+D1j
.text:000000D8                 cmp     [ebp+var_20], 0
.text:000000DC                 jge     short loc_E6
.text:000000DE                 mov     edx, [ebp+var_10]
.text:000000E1                 mov     [ebp+var_C], edx
.text:000000E4                 jmp     short loc_EF
.text:000000E6 ; ---------------------------------------------------------------------------
.text:000000E6
.text:000000E6 loc_E6:                                 ; CODE XREF: CUniqBlocks::AddUniq(uchar const *,uint)+DCj
.text:000000E6                 mov     eax, [ebp+var_10]
.text:000000E9                 add     eax, 1
.text:000000EC                 mov     [ebp+var_8], eax
.text:000000EF
.text:000000EF loc_EF:                                 ; CODE XREF: CUniqBlocks::AddUniq(uchar const *,uint)+91j
.text:000000EF                                         ; CUniqBlocks::AddUniq(uchar const *,uint)+A4j ...
.text:000000EF                 jmp     loc_3E
.text:000000F4 ; ---------------------------------------------------------------------------
.text:000000F4
.text:000000F4 loc_F4:                                 ; CODE XREF: CUniqBlocks::AddUniq(uchar const *,uint)+44j
.text:000000F4                 mov     ecx, [ebp+var_4]
.text:000000F7                 call    ?Size@?$CObjectVector@V?$CBuffer@E@@@@QBEIXZ ; CObjectVector<CBuffer<uchar>>::Size(void)
.text:000000FC                 mov     [ebp+var_24], eax
.text:000000FF                 mov     ecx, [ebp+var_24]
.text:00000102                 push    ecx
.text:00000103                 mov     edx, [ebp+var_8]
.text:00000106                 push    edx
.text:00000107                 mov     ecx, [ebp+var_4]
.text:0000010A                 add     ecx, 0Ch
.text:0000010D                 call    ?Insert@?$CRecordVector@I@@QAEXII@Z ; CRecordVector<uint>::Insert(uint,uint)
.text:00000112                 mov     eax, [ebp+Size]
.text:00000115                 push    eax             ; Size
.text:00000116                 mov     ecx, [ebp+Buf1]
.text:00000119                 push    ecx             ; Src
.text:0000011A                 mov     ecx, [ebp+var_4]
.text:0000011D                 call    ?AddNew@?$CObjectVector@V?$CBuffer@E@@@@QAEAAV?$CBuffer@E@@XZ ; CObjectVector<CBuffer<uchar>>::AddNew(void)
.text:00000122                 mov     ecx, eax
.text:00000124                 call    ?CopyFrom@?$CBuffer@E@@QAEXPBEI@Z ; CBuffer<uchar>::CopyFrom(uchar const *,uint)
.text:00000129                 mov     eax, [ebp+var_24]
.text:0000012C
.text:0000012C loc_12C:                                ; CODE XREF: CUniqBlocks::AddUniq(uchar const *,uint)+AFj
.text:0000012C                                         ; CUniqBlocks::AddUniq(uchar const *,uint)+D6j
.text:0000012C                 add     esp, 24h
.text:0000012F                 cmp     ebp, esp
.text:00000131                 call    __RTC_CheckEsp
.text:00000136                 mov     esp, ebp
.text:00000138                 pop     ebp
.text:00000139                 retn    8
.text:00000139 ?AddUniq@CUniqBlocks@@QAEIPBEI@Z endp
.text:00000139
.text:00000139 ; ---------------------------------------------------------------------------
.text:0000013C                 align 10h
.text:00000140
.text:00000140 ; =============== S U B R O U T I N E =======================================
.text:00000140
.text:00000140 ; Attributes: bp-based frame
.text:00000140
.text:00000140 ; unsigned __int64 __thiscall CUniqBlocks::GetTotalSizeInBytes(CUniqBlocks *__hidden this)
.text:00000140                 public ?GetTotalSizeInBytes@CUniqBlocks@@QBE_KXZ
.text:00000140 ?GetTotalSizeInBytes@CUniqBlocks@@QBE_KXZ proc near
.text:00000140
.text:00000140 var_10          = dword ptr -10h
.text:00000140 var_C           = dword ptr -0Ch
.text:00000140 var_8           = dword ptr -8
.text:00000140 var_4           = dword ptr -4
.text:00000140
.text:00000140                 push    ebp
.text:00000141                 mov     ebp, esp
.text:00000143                 sub     esp, 10h
.text:00000146                 mov     eax, 0CCCCCCCCh
.text:0000014B                 mov     [ebp+var_10], eax
.text:0000014E                 mov     [ebp+var_C], eax
.text:00000151                 mov     [ebp+var_8], eax
.text:00000154                 mov     [ebp+var_4], eax
.text:00000157                 mov     [ebp+var_4], ecx
.text:0000015A                 mov     [ebp+var_C], 0
.text:00000161                 mov     [ebp+var_8], 0
.text:00000168                 mov     [ebp+var_10], 0
.text:0000016F                 jmp     short loc_17A
.text:00000171 ; ---------------------------------------------------------------------------
.text:00000171
.text:00000171 loc_171:                                ; CODE XREF: CUniqBlocks::GetTotalSizeInBytes(void)+68j
.text:00000171                 mov     eax, [ebp+var_10]
.text:00000174                 add     eax, 1
.text:00000177                 mov     [ebp+var_10], eax
.text:0000017A
.text:0000017A loc_17A:                                ; CODE XREF: CUniqBlocks::GetTotalSizeInBytes(void)+2Fj
.text:0000017A                 mov     ecx, [ebp+var_4]
.text:0000017D                 call    ?Size@?$CObjectVector@V?$CBuffer@E@@@@QBEIXZ ; CObjectVector<CBuffer<uchar>>::Size(void)
.text:00000182                 cmp     [ebp+var_10], eax
.text:00000185                 jnb     short loc_1AA
.text:00000187                 mov     ecx, [ebp+var_10]
.text:0000018A                 push    ecx
.text:0000018B                 mov     ecx, [ebp+var_4]
.text:0000018E                 call    ??A?$CObjectVector@V?$CBuffer@E@@@@QBEABV?$CBuffer@E@@I@Z ; CObjectVector<CBuffer<uchar>>::operator[](uint)
.text:00000193                 mov     ecx, eax
.text:00000195                 call    ?Size@?$CBuffer@E@@QBEIXZ ; CBuffer<uchar>::Size(void)
.text:0000019A                 xor     edx, edx
.text:0000019C                 add     eax, [ebp+var_C]
.text:0000019F                 adc     edx, [ebp+var_8]
.text:000001A2                 mov     [ebp+var_C], eax
.text:000001A5                 mov     [ebp+var_8], edx
.text:000001A8                 jmp     short loc_171
.text:000001AA ; ---------------------------------------------------------------------------
.text:000001AA
.text:000001AA loc_1AA:                                ; CODE XREF: CUniqBlocks::GetTotalSizeInBytes(void)+45j
.text:000001AA                 mov     eax, [ebp+var_C]
.text:000001AD                 mov     edx, [ebp+var_8]
.text:000001B0                 add     esp, 10h
.text:000001B3                 cmp     ebp, esp
.text:000001B5                 call    __RTC_CheckEsp
.text:000001BA                 mov     esp, ebp
.text:000001BC                 pop     ebp
.text:000001BD                 retn
.text:000001BD ?GetTotalSizeInBytes@CUniqBlocks@@QBE_KXZ endp
.text:000001BD
.text:000001BD ; ---------------------------------------------------------------------------
.text:000001BE                 align 10h
.text:000001C0
.text:000001C0 ; =============== S U B R O U T I N E =======================================
.text:000001C0
.text:000001C0 ; Attributes: bp-based frame
.text:000001C0
.text:000001C0 ; void __thiscall CUniqBlocks::GetReverseMap(CUniqBlocks *__hidden this)
.text:000001C0                 public ?GetReverseMap@CUniqBlocks@@QAEXXZ
.text:000001C0 ?GetReverseMap@CUniqBlocks@@QAEXXZ proc near
.text:000001C0
.text:000001C0 var_14          = dword ptr -14h
.text:000001C0 var_10          = dword ptr -10h
.text:000001C0 var_C           = dword ptr -0Ch
.text:000001C0 var_8           = dword ptr -8
.text:000001C0 var_4           = dword ptr -4
.text:000001C0
.text:000001C0                 push    ebp
.text:000001C1                 mov     ebp, esp
.text:000001C3                 sub     esp, 14h
.text:000001C6                 mov     eax, 0CCCCCCCCh
.text:000001CB                 mov     [ebp+var_14], eax
.text:000001CE                 mov     [ebp+var_10], eax
.text:000001D1                 mov     [ebp+var_C], eax
.text:000001D4                 mov     [ebp+var_8], eax
.text:000001D7                 mov     [ebp+var_4], eax
.text:000001DA                 mov     [ebp+var_4], ecx
.text:000001DD                 mov     ecx, [ebp+var_4]
.text:000001E0                 add     ecx, 0Ch
.text:000001E3                 call    ?Size@?$CRecordVector@I@@QBEIXZ ; CRecordVector<uint>::Size(void)
.text:000001E8                 mov     [ebp+var_8], eax
.text:000001EB                 mov     eax, [ebp+var_8]
.text:000001EE                 push    eax
.text:000001EF                 mov     ecx, [ebp+var_4]
.text:000001F2                 add     ecx, 18h
.text:000001F5                 call    ?ClearAndSetSize@?$CRecordVector@I@@QAEXI@Z ; CRecordVector<uint>::ClearAndSetSize(uint)
.text:000001FA                 push    0
.text:000001FC                 mov     ecx, [ebp+var_4]
.text:000001FF                 add     ecx, 18h
.text:00000202                 call    ??A?$CRecordVector@I@@QAEAAII@Z ; CRecordVector<uint>::operator[](uint)
.text:00000207                 mov     [ebp+var_C], eax
.text:0000020A                 push    0
.text:0000020C                 mov     ecx, [ebp+var_4]
.text:0000020F                 add     ecx, 0Ch
.text:00000212                 call    ??A?$CRecordVector@I@@QAEAAII@Z ; CRecordVector<uint>::operator[](uint)
.text:00000217                 mov     [ebp+var_10], eax
.text:0000021A                 mov     [ebp+var_14], 0
.text:00000221                 jmp     short loc_22C
.text:00000223 ; ---------------------------------------------------------------------------
.text:00000223
.text:00000223 loc_223:                                ; CODE XREF: CUniqBlocks::GetReverseMap(void)+86j
.text:00000223                 mov     ecx, [ebp+var_14]
.text:00000226                 add     ecx, 1
.text:00000229                 mov     [ebp+var_14], ecx
.text:0000022C
.text:0000022C loc_22C:                                ; CODE XREF: CUniqBlocks::GetReverseMap(void)+61j
.text:0000022C                 mov     edx, [ebp+var_14]
.text:0000022F                 cmp     edx, [ebp+var_8]
.text:00000232                 jnb     short loc_248
.text:00000234                 mov     eax, [ebp+var_14]
.text:00000237                 mov     ecx, [ebp+var_10]
.text:0000023A                 mov     edx, [ecx+eax*4]
.text:0000023D                 mov     eax, [ebp+var_C]
.text:00000240                 mov     ecx, [ebp+var_14]
.text:00000243                 mov     [eax+edx*4], ecx
.text:00000246                 jmp     short loc_223
.text:00000248 ; ---------------------------------------------------------------------------
.text:00000248
.text:00000248 loc_248:                                ; CODE XREF: CUniqBlocks::GetReverseMap(void)+72j
.text:00000248                 add     esp, 14h
.text:0000024B                 cmp     ebp, esp
.text:0000024D                 call    __RTC_CheckEsp
.text:00000252                 mov     esp, ebp
.text:00000254                 pop     ebp
.text:00000255                 retn
.text:00000255 ?GetReverseMap@CUniqBlocks@@QAEXXZ endp
.text:00000255
.text:00000255 ; ---------------------------------------------------------------------------
.text:00000256                 align 4
.text:00000256 _text           ends
.text:00000256
.rtc$TMZ:00000258 ; ===========================================================================
.rtc$TMZ:00000258
.rtc$TMZ:00000258 ; Segment type: Pure data
.rtc$TMZ:00000258 ; Segment permissions: Read
.rtc$TMZ:00000258 _rtc$TMZ        segment dword public 'DATA' use32
.rtc$TMZ:00000258                 assume cs:_rtc$TMZ
.rtc$TMZ:00000258                 ;org 258h
.rtc$TMZ:00000258 ; COMDAT (pick any)
.rtc$TMZ:00000258 __RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
.rtc$TMZ:00000258 _rtc$TMZ        ends
.rtc$TMZ:00000258
.rtc$IMZ:0000025C ; ===========================================================================
.rtc$IMZ:0000025C
.rtc$IMZ:0000025C ; Segment type: Pure data
.rtc$IMZ:0000025C ; Segment permissions: Read
.rtc$IMZ:0000025C _rtc$IMZ        segment dword public 'DATA' use32
.rtc$IMZ:0000025C                 assume cs:_rtc$IMZ
.rtc$IMZ:0000025C                 ;org 25Ch
.rtc$IMZ:0000025C ; COMDAT (pick any)
.rtc$IMZ:0000025C __RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
.rtc$IMZ:0000025C _rtc$IMZ        ends
.rtc$IMZ:0000025C
.text:00000260 ; ===========================================================================
.text:00000260
.text:00000260 ; Segment type: Pure code
.text:00000260 ; Segment permissions: Read/Execute
.text:00000260 _text           segment para public 'CODE' use32
.text:00000260                 assume cs:_text
.text:00000260                 ;org 260h
.text:00000260 ; COMDAT (pick any)
.text:00000260                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000260
.text:00000260 ; =============== S U B R O U T I N E =======================================
.text:00000260
.text:00000260 ; Attributes: bp-based frame
.text:00000260
.text:00000260 ; public: unsigned int __thiscall CObjectVector<class CBuffer<unsigned char>>::Size(void)const
.text:00000260                 public ?Size@?$CObjectVector@V?$CBuffer@E@@@@QBEIXZ
.text:00000260 ?Size@?$CObjectVector@V?$CBuffer@E@@@@QBEIXZ proc near
.text:00000260                                         ; CODE XREF: CUniqBlocks::AddUniq(uchar const *,uint)+F7p
.text:00000260                                         ; CUniqBlocks::GetTotalSizeInBytes(void)+3Dp
.text:00000260
.text:00000260 var_4           = dword ptr -4
.text:00000260
.text:00000260                 push    ebp
.text:00000261                 mov     ebp, esp
.text:00000263                 push    ecx
.text:00000264                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000026B                 mov     [ebp+var_4], ecx
.text:0000026E                 mov     ecx, [ebp+var_4]
.text:00000271                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00000276                 add     esp, 4
.text:00000279                 cmp     ebp, esp
.text:0000027B                 call    __RTC_CheckEsp
.text:00000280                 mov     esp, ebp
.text:00000282                 pop     ebp
.text:00000283                 retn
.text:00000283 ?Size@?$CObjectVector@V?$CBuffer@E@@@@QBEIXZ endp
.text:00000283
.text:00000283 _text           ends
.text:00000283
.text:00000284 ; ===========================================================================
.text:00000284
.text:00000284 ; Segment type: Pure code
.text:00000284 ; Segment permissions: Read/Execute
.text:00000284 _text           segment para public 'CODE' use32
.text:00000284                 assume cs:_text
.text:00000284                 ;org 284h
.text:00000284 ; COMDAT (pick any)
.text:00000284                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000284
.text:00000284 ; =============== S U B R O U T I N E =======================================
.text:00000284
.text:00000284 ; Attributes: bp-based frame
.text:00000284
.text:00000284 ; public: class CBuffer<unsigned char> const & __thiscall CObjectVector<class CBuffer<unsigned char>>::operator[](unsigned int)const
.text:00000284                 public ??A?$CObjectVector@V?$CBuffer@E@@@@QBEABV?$CBuffer@E@@I@Z
.text:00000284 ??A?$CObjectVector@V?$CBuffer@E@@@@QBEABV?$CBuffer@E@@I@Z proc near
.text:00000284                                         ; CODE XREF: CUniqBlocks::GetTotalSizeInBytes(void)+4Ep
.text:00000284
.text:00000284 var_4           = dword ptr -4
.text:00000284 arg_0           = dword ptr  8
.text:00000284
.text:00000284                 push    ebp
.text:00000285                 mov     ebp, esp
.text:00000287                 push    ecx
.text:00000288                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000028F                 mov     [ebp+var_4], ecx
.text:00000292                 mov     eax, [ebp+arg_0]
.text:00000295                 push    eax
.text:00000296                 mov     ecx, [ebp+var_4]
.text:00000299                 call    ??A?$CRecordVector@PAX@@QBEABQAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:0000029E                 mov     eax, [eax]
.text:000002A0                 add     esp, 4
.text:000002A3                 cmp     ebp, esp
.text:000002A5                 call    __RTC_CheckEsp
.text:000002AA                 mov     esp, ebp
.text:000002AC                 pop     ebp
.text:000002AD                 retn    4
.text:000002AD ??A?$CObjectVector@V?$CBuffer@E@@@@QBEABV?$CBuffer@E@@I@Z endp
.text:000002AD
.text:000002AD _text           ends
.text:000002AD
.text:000002B0 ; ===========================================================================
.text:000002B0
.text:000002B0 ; Segment type: Pure code
.text:000002B0 ; Segment permissions: Read/Execute
.text:000002B0 _text           segment para public 'CODE' use32
.text:000002B0                 assume cs:_text
.text:000002B0                 ;org 2B0h
.text:000002B0 ; COMDAT (pick any)
.text:000002B0                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000002B0
.text:000002B0 ; =============== S U B R O U T I N E =======================================
.text:000002B0
.text:000002B0 ; Attributes: bp-based frame
.text:000002B0
.text:000002B0 ; public: class CBuffer<unsigned char> & __thiscall CObjectVector<class CBuffer<unsigned char>>::operator[](unsigned int)
.text:000002B0                 public ??A?$CObjectVector@V?$CBuffer@E@@@@QAEAAV?$CBuffer@E@@I@Z
.text:000002B0 ??A?$CObjectVector@V?$CBuffer@E@@@@QAEAAV?$CBuffer@E@@I@Z proc near
.text:000002B0                                         ; CODE XREF: CUniqBlocks::AddUniq(uchar const *,uint)+70p
.text:000002B0
.text:000002B0 var_4           = dword ptr -4
.text:000002B0 arg_0           = dword ptr  8
.text:000002B0
.text:000002B0                 push    ebp
.text:000002B1                 mov     ebp, esp
.text:000002B3                 push    ecx
.text:000002B4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000002BB                 mov     [ebp+var_4], ecx
.text:000002BE                 mov     eax, [ebp+arg_0]
.text:000002C1                 push    eax
.text:000002C2                 mov     ecx, [ebp+var_4]
.text:000002C5                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:000002CA                 mov     eax, [eax]
.text:000002CC                 add     esp, 4
.text:000002CF                 cmp     ebp, esp
.text:000002D1                 call    __RTC_CheckEsp
.text:000002D6                 mov     esp, ebp
.text:000002D8                 pop     ebp
.text:000002D9                 retn    4
.text:000002D9 ??A?$CObjectVector@V?$CBuffer@E@@@@QAEAAV?$CBuffer@E@@I@Z endp
.text:000002D9
.text:000002D9 _text           ends
.text:000002D9
.text:000002DC ; ===========================================================================
.text:000002DC
.text:000002DC ; Segment type: Pure code
.text:000002DC ; Segment permissions: Read/Execute
.text:000002DC _text           segment para public 'CODE' use32
.text:000002DC                 assume cs:_text
.text:000002DC                 ;org 2DCh
.text:000002DC ; COMDAT (pick any)
.text:000002DC                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000002DC
.text:000002DC ; =============== S U B R O U T I N E =======================================
.text:000002DC
.text:000002DC ; Attributes: bp-based frame
.text:000002DC
.text:000002DC ; public: class CBuffer<unsigned char> & __thiscall CObjectVector<class CBuffer<unsigned char>>::AddNew(void)
.text:000002DC                 public ?AddNew@?$CObjectVector@V?$CBuffer@E@@@@QAEAAV?$CBuffer@E@@XZ
.text:000002DC ?AddNew@?$CObjectVector@V?$CBuffer@E@@@@QAEAAV?$CBuffer@E@@XZ proc near
.text:000002DC                                         ; CODE XREF: CUniqBlocks::AddUniq(uchar const *,uint)+11Dp
.text:000002DC
.text:000002DC var_20          = dword ptr -20h
.text:000002DC var_1C          = dword ptr -1Ch
.text:000002DC var_18          = dword ptr -18h
.text:000002DC var_14          = dword ptr -14h
.text:000002DC var_10          = dword ptr -10h
.text:000002DC var_C           = dword ptr -0Ch
.text:000002DC var_4           = dword ptr -4
.text:000002DC
.text:000002DC                 push    ebp
.text:000002DD                 mov     ebp, esp
.text:000002DF                 push    0FFFFFFFFh
.text:000002E1                 push    offset __ehhandler$?AddNew@?$CObjectVector@V?$CBuffer@E@@@@QAEAAV?$CBuffer@E@@XZ
.text:000002E6                 mov     eax, large fs:0
.text:000002EC                 push    eax
.text:000002ED                 sub     esp, 14h
.text:000002F0                 mov     eax, 0CCCCCCCCh
.text:000002F5                 mov     [ebp+var_20], eax
.text:000002F8                 mov     [ebp+var_1C], eax
.text:000002FB                 mov     [ebp+var_18], eax
.text:000002FE                 mov     [ebp+var_14], eax
.text:00000301                 mov     [ebp+var_10], eax
.text:00000304                 mov     eax, dword ptr ds:___security_cookie
.text:00000309                 xor     eax, ebp
.text:0000030B                 push    eax
.text:0000030C                 lea     eax, [ebp+var_C]
.text:0000030F                 mov     large fs:0, eax
.text:00000315                 mov     [ebp+var_10], ecx
.text:00000318                 push    8               ; unsigned int
.text:0000031A                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0000031F                 add     esp, 4
.text:00000322                 mov     [ebp+var_1C], eax
.text:00000325                 mov     [ebp+var_4], 0
.text:0000032C                 cmp     [ebp+var_1C], 0
.text:00000330                 jz      short loc_33F
.text:00000332                 mov     ecx, [ebp+var_1C]
.text:00000335                 call    ??0?$CBuffer@E@@QAE@XZ ; CBuffer<uchar>::CBuffer<uchar>(void)
.text:0000033A                 mov     [ebp+var_20], eax
.text:0000033D                 jmp     short loc_346
.text:0000033F ; ---------------------------------------------------------------------------
.text:0000033F
.text:0000033F loc_33F:                                ; CODE XREF: CObjectVector<CBuffer<uchar>>::AddNew(void)+54j
.text:0000033F                 mov     [ebp+var_20], 0
.text:00000346
.text:00000346 loc_346:                                ; CODE XREF: CObjectVector<CBuffer<uchar>>::AddNew(void)+61j
.text:00000346                 mov     eax, [ebp+var_20]
.text:00000349                 mov     [ebp+var_18], eax
.text:0000034C                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000353                 mov     ecx, [ebp+var_18]
.text:00000356                 mov     [ebp+var_14], ecx
.text:00000359                 mov     edx, [ebp+var_14]
.text:0000035C                 push    edx
.text:0000035D                 mov     ecx, [ebp+var_10]
.text:00000360                 call    ?Add@?$CRecordVector@PAX@@QAEIQAX@Z ; CRecordVector<void *>::Add(void * const)
.text:00000365                 mov     eax, [ebp+var_14]
.text:00000368                 mov     ecx, [ebp+var_C]
.text:0000036B                 mov     large fs:0, ecx
.text:00000372                 pop     ecx
.text:00000373                 add     esp, 20h
.text:00000376                 cmp     ebp, esp
.text:00000378                 call    __RTC_CheckEsp
.text:0000037D                 mov     esp, ebp
.text:0000037F                 pop     ebp
.text:00000380                 retn
.text:00000380 ?AddNew@?$CObjectVector@V?$CBuffer@E@@@@QAEAAV?$CBuffer@E@@XZ endp
.text:00000380
.text:00000380 ; ---------------------------------------------------------------------------
.text:00000381                 align 4
.text:00000381 _text           ends
.text:00000381
.text$x:00000384 ; ===========================================================================
.text$x:00000384
.text$x:00000384 ; Segment type: Pure code
.text$x:00000384 ; Segment permissions: Read/Execute
.text$x:00000384 _text$x         segment para public 'CODE' use32
.text$x:00000384                 assume cs:_text$x
.text$x:00000384                 ;org 384h
.text$x:00000384 ; COMDAT (pick associative to section at 2DC)
.text$x:00000384                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text$x:00000384
.text$x:00000384 ; =============== S U B R O U T I N E =======================================
.text$x:00000384
.text$x:00000384
.text$x:00000384 __unwindfunclet$?AddNew@?$CObjectVector@V?$CBuffer@E@@@@QAEAAV?$CBuffer@E@@XZ$0 proc near
.text$x:00000384                                         ; DATA XREF: .xdata$x:000003B0o
.text$x:00000384                 mov     eax, [ebp-1Ch]
.text$x:00000387                 push    eax             ; void *
.text$x:00000388                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:0000038D                 pop     ecx
.text$x:0000038E                 retn
.text$x:0000038E __unwindfunclet$?AddNew@?$CObjectVector@V?$CBuffer@E@@@@QAEAAV?$CBuffer@E@@XZ$0 endp
.text$x:0000038E
.text$x:0000038F
.text$x:0000038F ; =============== S U B R O U T I N E =======================================
.text$x:0000038F
.text$x:0000038F
.text$x:0000038F __ehhandler$?AddNew@?$CObjectVector@V?$CBuffer@E@@@@QAEAAV?$CBuffer@E@@XZ proc near
.text$x:0000038F                                         ; DATA XREF: CObjectVector<CBuffer<uchar>>::AddNew(void)+5o
.text$x:0000038F
.text$x:0000038F arg_4           = dword ptr  8
.text$x:0000038F
.text$x:0000038F                 mov     edx, [esp+arg_4]
.text$x:00000393                 lea     eax, [edx+0Ch]
.text$x:00000396                 mov     ecx, [edx-18h]
.text$x:00000399                 xor     ecx, eax
.text$x:0000039B                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000003A0                 mov     eax, offset __ehfuncinfo$?AddNew@?$CObjectVector@V?$CBuffer@E@@@@QAEAAV?$CBuffer@E@@XZ
.text$x:000003A5                 jmp     ___CxxFrameHandler3
.text$x:000003A5 __ehhandler$?AddNew@?$CObjectVector@V?$CBuffer@E@@@@QAEAAV?$CBuffer@E@@XZ endp
.text$x:000003A5
.text$x:000003A5 ; ---------------------------------------------------------------------------
.text$x:000003AA                 align 4
.text$x:000003AA _text$x         ends
.text$x:000003AA
.xdata$x:000003AC ; ===========================================================================
.xdata$x:000003AC
.xdata$x:000003AC ; Segment type: Pure data
.xdata$x:000003AC ; Segment permissions: Read
.xdata$x:000003AC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000003AC                 assume cs:_xdata$x
.xdata$x:000003AC                 ;org 3ACh
.xdata$x:000003AC ; COMDAT (pick associative to section at 2DC)
.xdata$x:000003AC __unwindtable$?AddNew@?$CObjectVector@V?$CBuffer@E@@@@QAEAAV?$CBuffer@E@@XZ db 0FFh
.xdata$x:000003AC                                         ; DATA XREF: .xdata$x:000003BCo
.xdata$x:000003AD                 db 0FFh
.xdata$x:000003AE                 db 0FFh
.xdata$x:000003AF                 db 0FFh
.xdata$x:000003B0                 dd offset __unwindfunclet$?AddNew@?$CObjectVector@V?$CBuffer@E@@@@QAEAAV?$CBuffer@E@@XZ$0
.xdata$x:000003B4 __ehfuncinfo$?AddNew@?$CObjectVector@V?$CBuffer@E@@@@QAEAAV?$CBuffer@E@@XZ db  22h ; "
.xdata$x:000003B4                                         ; DATA XREF: __ehhandler$?AddNew@?$CObjectVector@V?$CBuffer@E@@@@QAEAAV?$CBuffer@E@@XZ+11o
.xdata$x:000003B5                 db    5
.xdata$x:000003B6                 db  93h ; ô
.xdata$x:000003B7                 db  19h
.xdata$x:000003B8                 db    1
.xdata$x:000003B9                 db    0
.xdata$x:000003BA                 db    0
.xdata$x:000003BB                 db    0
.xdata$x:000003BC                 dd offset __unwindtable$?AddNew@?$CObjectVector@V?$CBuffer@E@@@@QAEAAV?$CBuffer@E@@XZ
.xdata$x:000003C0                 db    0
.xdata$x:000003C1                 db    0
.xdata$x:000003C2                 db    0
.xdata$x:000003C3                 db    0
.xdata$x:000003C4                 db    0
.xdata$x:000003C5                 db    0
.xdata$x:000003C6                 db    0
.xdata$x:000003C7                 db    0
.xdata$x:000003C8                 db    0
.xdata$x:000003C9                 db    0
.xdata$x:000003CA                 db    0
.xdata$x:000003CB                 db    0
.xdata$x:000003CC                 db    0
.xdata$x:000003CD                 db    0
.xdata$x:000003CE                 db    0
.xdata$x:000003CF                 db    0
.xdata$x:000003D0                 db    0
.xdata$x:000003D1                 db    0
.xdata$x:000003D2                 db    0
.xdata$x:000003D3                 db    0
.xdata$x:000003D4                 db    1
.xdata$x:000003D5                 db    0
.xdata$x:000003D6                 db    0
.xdata$x:000003D7                 db    0
.xdata$x:000003D7 _xdata$x        ends
.xdata$x:000003D7
.text:000003D8 ; ===========================================================================
.text:000003D8
.text:000003D8 ; Segment type: Pure code
.text:000003D8 ; Segment permissions: Read/Execute
.text:000003D8 _text           segment para public 'CODE' use32
.text:000003D8                 assume cs:_text
.text:000003D8                 ;org 3D8h
.text:000003D8 ; COMDAT (pick any)
.text:000003D8                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000003D8
.text:000003D8 ; =============== S U B R O U T I N E =======================================
.text:000003D8
.text:000003D8 ; Attributes: bp-based frame
.text:000003D8
.text:000003D8 ; public: unsigned int __thiscall CRecordVector<unsigned int>::Size(void)const
.text:000003D8                 public ?Size@?$CRecordVector@I@@QBEIXZ
.text:000003D8 ?Size@?$CRecordVector@I@@QBEIXZ proc near
.text:000003D8                                         ; CODE XREF: CUniqBlocks::AddUniq(uchar const *,uint)+36p
.text:000003D8                                         ; CUniqBlocks::GetReverseMap(void)+23p
.text:000003D8
.text:000003D8 var_4           = dword ptr -4
.text:000003D8
.text:000003D8                 push    ebp
.text:000003D9                 mov     ebp, esp
.text:000003DB                 push    ecx
.text:000003DC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000003E3                 mov     [ebp+var_4], ecx
.text:000003E6                 mov     eax, [ebp+var_4]
.text:000003E9                 mov     eax, [eax+4]
.text:000003EC                 mov     esp, ebp
.text:000003EE                 pop     ebp
.text:000003EF                 retn
.text:000003EF ?Size@?$CRecordVector@I@@QBEIXZ endp
.text:000003EF
.text:000003EF _text           ends
.text:000003EF
.text:000003F0 ; ===========================================================================
.text:000003F0
.text:000003F0 ; Segment type: Pure code
.text:000003F0 ; Segment permissions: Read/Execute
.text:000003F0 _text           segment para public 'CODE' use32
.text:000003F0                 assume cs:_text
.text:000003F0                 ;org 3F0h
.text:000003F0 ; COMDAT (pick any)
.text:000003F0                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000003F0
.text:000003F0 ; =============== S U B R O U T I N E =======================================
.text:000003F0
.text:000003F0 ; Attributes: bp-based frame
.text:000003F0
.text:000003F0 ; public: void __thiscall CRecordVector<unsigned int>::ClearAndSetSize(unsigned int)
.text:000003F0                 public ?ClearAndSetSize@?$CRecordVector@I@@QAEXI@Z
.text:000003F0 ?ClearAndSetSize@?$CRecordVector@I@@QAEXI@Z proc near
.text:000003F0                                         ; CODE XREF: CUniqBlocks::GetReverseMap(void)+35p
.text:000003F0
.text:000003F0 var_4           = dword ptr -4
.text:000003F0 arg_0           = dword ptr  8
.text:000003F0
.text:000003F0                 push    ebp
.text:000003F1                 mov     ebp, esp
.text:000003F3                 push    ecx
.text:000003F4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000003FB                 mov     [ebp+var_4], ecx
.text:000003FE                 mov     eax, [ebp+arg_0]
.text:00000401                 push    eax
.text:00000402                 mov     ecx, [ebp+var_4]
.text:00000405                 call    ?ClearAndReserve@?$CRecordVector@I@@QAEXI@Z ; CRecordVector<uint>::ClearAndReserve(uint)
.text:0000040A                 mov     ecx, [ebp+var_4]
.text:0000040D                 mov     edx, [ebp+arg_0]
.text:00000410                 mov     [ecx+4], edx
.text:00000413                 add     esp, 4
.text:00000416                 cmp     ebp, esp
.text:00000418                 call    __RTC_CheckEsp
.text:0000041D                 mov     esp, ebp
.text:0000041F                 pop     ebp
.text:00000420                 retn    4
.text:00000420 ?ClearAndSetSize@?$CRecordVector@I@@QAEXI@Z endp
.text:00000420
.text:00000420 ; ---------------------------------------------------------------------------
.text:00000423                 align 4
.text:00000423 _text           ends
.text:00000423
.text:00000424 ; ===========================================================================
.text:00000424
.text:00000424 ; Segment type: Pure code
.text:00000424 ; Segment permissions: Read/Execute
.text:00000424 _text           segment para public 'CODE' use32
.text:00000424                 assume cs:_text
.text:00000424                 ;org 424h
.text:00000424 ; COMDAT (pick any)
.text:00000424                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000424
.text:00000424 ; =============== S U B R O U T I N E =======================================
.text:00000424
.text:00000424 ; Attributes: bp-based frame
.text:00000424
.text:00000424 ; public: void __thiscall CRecordVector<unsigned int>::Insert(unsigned int, unsigned int)
.text:00000424                 public ?Insert@?$CRecordVector@I@@QAEXII@Z
.text:00000424 ?Insert@?$CRecordVector@I@@QAEXII@Z proc near
.text:00000424                                         ; CODE XREF: CUniqBlocks::AddUniq(uchar const *,uint)+10Dp
.text:00000424
.text:00000424 var_4           = dword ptr -4
.text:00000424 arg_0           = dword ptr  8
.text:00000424 arg_4           = dword ptr  0Ch
.text:00000424
.text:00000424                 push    ebp
.text:00000425                 mov     ebp, esp
.text:00000427                 push    ecx
.text:00000428                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000042F                 mov     [ebp+var_4], ecx
.text:00000432                 mov     ecx, [ebp+var_4]
.text:00000435                 call    ?ReserveOnePosition@?$CRecordVector@I@@AAEXXZ ; CRecordVector<uint>::ReserveOnePosition(void)
.text:0000043A                 mov     eax, [ebp+arg_0]
.text:0000043D                 push    eax
.text:0000043E                 mov     ecx, [ebp+arg_0]
.text:00000441                 add     ecx, 1
.text:00000444                 push    ecx
.text:00000445                 mov     ecx, [ebp+var_4]
.text:00000448                 call    ?MoveItems@?$CRecordVector@I@@AAEXII@Z ; CRecordVector<uint>::MoveItems(uint,uint)
.text:0000044D                 mov     edx, [ebp+var_4]
.text:00000450                 mov     eax, [edx]
.text:00000452                 mov     ecx, [ebp+arg_0]
.text:00000455                 mov     edx, [ebp+arg_4]
.text:00000458                 mov     [eax+ecx*4], edx
.text:0000045B                 mov     eax, [ebp+var_4]
.text:0000045E                 mov     ecx, [eax+4]
.text:00000461                 add     ecx, 1
.text:00000464                 mov     edx, [ebp+var_4]
.text:00000467                 mov     [edx+4], ecx
.text:0000046A                 add     esp, 4
.text:0000046D                 cmp     ebp, esp
.text:0000046F                 call    __RTC_CheckEsp
.text:00000474                 mov     esp, ebp
.text:00000476                 pop     ebp
.text:00000477                 retn    8
.text:00000477 ?Insert@?$CRecordVector@I@@QAEXII@Z endp
.text:00000477
.text:00000477 ; ---------------------------------------------------------------------------
.text:0000047A                 align 4
.text:0000047A _text           ends
.text:0000047A
.text:0000047C ; ===========================================================================
.text:0000047C
.text:0000047C ; Segment type: Pure code
.text:0000047C ; Segment permissions: Read/Execute
.text:0000047C _text           segment para public 'CODE' use32
.text:0000047C                 assume cs:_text
.text:0000047C                 ;org 47Ch
.text:0000047C ; COMDAT (pick any)
.text:0000047C                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:0000047C
.text:0000047C ; =============== S U B R O U T I N E =======================================
.text:0000047C
.text:0000047C ; Attributes: bp-based frame
.text:0000047C
.text:0000047C ; public: unsigned int & __thiscall CRecordVector<unsigned int>::operator[](unsigned int)
.text:0000047C                 public ??A?$CRecordVector@I@@QAEAAII@Z
.text:0000047C ??A?$CRecordVector@I@@QAEAAII@Z proc near
.text:0000047C                                         ; CODE XREF: CUniqBlocks::AddUniq(uchar const *,uint)+5Fp
.text:0000047C                                         ; CUniqBlocks::GetReverseMap(void)+42p ...
.text:0000047C
.text:0000047C var_4           = dword ptr -4
.text:0000047C arg_0           = dword ptr  8
.text:0000047C
.text:0000047C                 push    ebp
.text:0000047D                 mov     ebp, esp
.text:0000047F                 push    ecx
.text:00000480                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000487                 mov     [ebp+var_4], ecx
.text:0000048A                 mov     eax, [ebp+var_4]
.text:0000048D                 mov     ecx, [eax]
.text:0000048F                 mov     edx, [ebp+arg_0]
.text:00000492                 lea     eax, [ecx+edx*4]
.text:00000495                 mov     esp, ebp
.text:00000497                 pop     ebp
.text:00000498                 retn    4
.text:00000498 ??A?$CRecordVector@I@@QAEAAII@Z endp
.text:00000498
.text:00000498 ; ---------------------------------------------------------------------------
.text:0000049B                 align 4
.text:0000049B _text           ends
.text:0000049B
.text:0000049C ; ===========================================================================
.text:0000049C
.text:0000049C ; Segment type: Pure code
.text:0000049C ; Segment permissions: Read/Execute
.text:0000049C _text           segment para public 'CODE' use32
.text:0000049C                 assume cs:_text
.text:0000049C                 ;org 49Ch
.text:0000049C ; COMDAT (pick any)
.text:0000049C                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:0000049C
.text:0000049C ; =============== S U B R O U T I N E =======================================
.text:0000049C
.text:0000049C ; Attributes: bp-based frame
.text:0000049C
.text:0000049C ; public: __thiscall CBuffer<unsigned char>::operator unsigned char const *(void)const
.text:0000049C                 public ??B?$CBuffer@E@@QBEPBEXZ
.text:0000049C ??B?$CBuffer@E@@QBEPBEXZ proc near      ; CODE XREF: CUniqBlocks::AddUniq(uchar const *,uint)+B8p
.text:0000049C
.text:0000049C var_4           = dword ptr -4
.text:0000049C
.text:0000049C                 push    ebp
.text:0000049D                 mov     ebp, esp
.text:0000049F                 push    ecx
.text:000004A0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000004A7                 mov     [ebp+var_4], ecx
.text:000004AA                 mov     eax, [ebp+var_4]
.text:000004AD                 mov     eax, [eax]
.text:000004AF                 mov     esp, ebp
.text:000004B1                 pop     ebp
.text:000004B2                 retn
.text:000004B2 ??B?$CBuffer@E@@QBEPBEXZ endp
.text:000004B2
.text:000004B2 ; ---------------------------------------------------------------------------
.text:000004B3                 align 4
.text:000004B3 _text           ends
.text:000004B3
.text:000004B4 ; ===========================================================================
.text:000004B4
.text:000004B4 ; Segment type: Pure code
.text:000004B4 ; Segment permissions: Read/Execute
.text:000004B4 _text           segment para public 'CODE' use32
.text:000004B4                 assume cs:_text
.text:000004B4                 ;org 4B4h
.text:000004B4 ; COMDAT (pick any)
.text:000004B4                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000004B4
.text:000004B4 ; =============== S U B R O U T I N E =======================================
.text:000004B4
.text:000004B4 ; Attributes: bp-based frame
.text:000004B4
.text:000004B4 ; public: unsigned int __thiscall CBuffer<unsigned char>::Size(void)const
.text:000004B4                 public ?Size@?$CBuffer@E@@QBEIXZ
.text:000004B4 ?Size@?$CBuffer@E@@QBEIXZ proc near     ; CODE XREF: CUniqBlocks::AddUniq(uchar const *,uint)+7Bp
.text:000004B4                                         ; CUniqBlocks::GetTotalSizeInBytes(void)+55p
.text:000004B4
.text:000004B4 var_4           = dword ptr -4
.text:000004B4
.text:000004B4                 push    ebp
.text:000004B5                 mov     ebp, esp
.text:000004B7                 push    ecx
.text:000004B8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000004BF                 mov     [ebp+var_4], ecx
.text:000004C2                 mov     eax, [ebp+var_4]
.text:000004C5                 mov     eax, [eax+4]
.text:000004C8                 mov     esp, ebp
.text:000004CA                 pop     ebp
.text:000004CB                 retn
.text:000004CB ?Size@?$CBuffer@E@@QBEIXZ endp
.text:000004CB
.text:000004CB _text           ends
.text:000004CB
.text:000004CC ; ===========================================================================
.text:000004CC
.text:000004CC ; Segment type: Pure code
.text:000004CC ; Segment permissions: Read/Execute
.text:000004CC _text           segment para public 'CODE' use32
.text:000004CC                 assume cs:_text
.text:000004CC                 ;org 4CCh
.text:000004CC ; COMDAT (pick any)
.text:000004CC                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000004CC
.text:000004CC ; =============== S U B R O U T I N E =======================================
.text:000004CC
.text:000004CC ; Attributes: bp-based frame
.text:000004CC
.text:000004CC ; int __stdcall CBuffer<unsigned char>::CopyFrom(void *Src, size_t Size)
.text:000004CC                 public ?CopyFrom@?$CBuffer@E@@QAEXPBEI@Z
.text:000004CC ?CopyFrom@?$CBuffer@E@@QAEXPBEI@Z proc near
.text:000004CC                                         ; CODE XREF: CUniqBlocks::AddUniq(uchar const *,uint)+124p
.text:000004CC
.text:000004CC var_4           = dword ptr -4
.text:000004CC Src             = dword ptr  8
.text:000004CC Size            = dword ptr  0Ch
.text:000004CC
.text:000004CC                 push    ebp
.text:000004CD                 mov     ebp, esp
.text:000004CF                 push    ecx
.text:000004D0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000004D7                 mov     [ebp+var_4], ecx
.text:000004DA                 mov     eax, [ebp+Size]
.text:000004DD                 push    eax
.text:000004DE                 mov     ecx, [ebp+var_4]
.text:000004E1                 call    ?Alloc@?$CBuffer@E@@QAEXI@Z ; CBuffer<uchar>::Alloc(uint)
.text:000004E6                 cmp     [ebp+Size], 0
.text:000004EA                 jz      short loc_502
.text:000004EC                 mov     ecx, [ebp+Size]
.text:000004EF                 push    ecx             ; Size
.text:000004F0                 mov     edx, [ebp+Src]
.text:000004F3                 push    edx             ; Src
.text:000004F4                 mov     eax, [ebp+var_4]
.text:000004F7                 mov     ecx, [eax]
.text:000004F9                 push    ecx             ; Dst
.text:000004FA                 call    _memcpy
.text:000004FF                 add     esp, 0Ch
.text:00000502
.text:00000502 loc_502:                                ; CODE XREF: CBuffer<uchar>::CopyFrom(uchar const *,uint)+1Ej
.text:00000502                 add     esp, 4
.text:00000505                 cmp     ebp, esp
.text:00000507                 call    __RTC_CheckEsp
.text:0000050C                 mov     esp, ebp
.text:0000050E                 pop     ebp
.text:0000050F                 retn    8
.text:0000050F ?CopyFrom@?$CBuffer@E@@QAEXPBEI@Z endp
.text:0000050F
.text:0000050F ; ---------------------------------------------------------------------------
.text:00000512                 align 4
.text:00000512 _text           ends
.text:00000512
.text:00000514 ; ===========================================================================
.text:00000514
.text:00000514 ; Segment type: Pure code
.text:00000514 ; Segment permissions: Read/Execute
.text:00000514 _text           segment para public 'CODE' use32
.text:00000514                 assume cs:_text
.text:00000514                 ;org 514h
.text:00000514 ; COMDAT (pick any)
.text:00000514                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000514
.text:00000514 ; =============== S U B R O U T I N E =======================================
.text:00000514
.text:00000514 ; Attributes: bp-based frame
.text:00000514
.text:00000514 ; public: unsigned int __thiscall CRecordVector<void *>::Size(void)const
.text:00000514                 public ?Size@?$CRecordVector@PAX@@QBEIXZ
.text:00000514 ?Size@?$CRecordVector@PAX@@QBEIXZ proc near
.text:00000514                                         ; CODE XREF: CObjectVector<CBuffer<uchar>>::Size(void)+11p
.text:00000514
.text:00000514 var_4           = dword ptr -4
.text:00000514
.text:00000514                 push    ebp
.text:00000515                 mov     ebp, esp
.text:00000517                 push    ecx
.text:00000518                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000051F                 mov     [ebp+var_4], ecx
.text:00000522                 mov     eax, [ebp+var_4]
.text:00000525                 mov     eax, [eax+4]
.text:00000528                 mov     esp, ebp
.text:0000052A                 pop     ebp
.text:0000052B                 retn
.text:0000052B ?Size@?$CRecordVector@PAX@@QBEIXZ endp
.text:0000052B
.text:0000052B _text           ends
.text:0000052B
.text:0000052C ; ===========================================================================
.text:0000052C
.text:0000052C ; Segment type: Pure code
.text:0000052C ; Segment permissions: Read/Execute
.text:0000052C _text           segment para public 'CODE' use32
.text:0000052C                 assume cs:_text
.text:0000052C                 ;org 52Ch
.text:0000052C ; COMDAT (pick any)
.text:0000052C                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:0000052C
.text:0000052C ; =============== S U B R O U T I N E =======================================
.text:0000052C
.text:0000052C ; Attributes: bp-based frame
.text:0000052C
.text:0000052C ; public: unsigned int __thiscall CRecordVector<void *>::Add(void * const)
.text:0000052C                 public ?Add@?$CRecordVector@PAX@@QAEIQAX@Z
.text:0000052C ?Add@?$CRecordVector@PAX@@QAEIQAX@Z proc near
.text:0000052C                                         ; CODE XREF: CObjectVector<CBuffer<uchar>>::AddNew(void)+84p
.text:0000052C
.text:0000052C var_8           = dword ptr -8
.text:0000052C var_4           = dword ptr -4
.text:0000052C arg_0           = dword ptr  8
.text:0000052C
.text:0000052C                 push    ebp
.text:0000052D                 mov     ebp, esp
.text:0000052F                 sub     esp, 8
.text:00000532                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00000539                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000540                 mov     [ebp+var_4], ecx
.text:00000543                 mov     ecx, [ebp+var_4]
.text:00000546                 call    ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ ; CRecordVector<void *>::ReserveOnePosition(void)
.text:0000054B                 mov     eax, [ebp+var_4]
.text:0000054E                 mov     ecx, [eax+4]
.text:00000551                 mov     edx, [ebp+var_4]
.text:00000554                 mov     eax, [edx]
.text:00000556                 mov     edx, [ebp+arg_0]
.text:00000559                 mov     [eax+ecx*4], edx
.text:0000055C                 mov     eax, [ebp+var_4]
.text:0000055F                 mov     ecx, [eax+4]
.text:00000562                 mov     [ebp+var_8], ecx
.text:00000565                 mov     edx, [ebp+var_4]
.text:00000568                 mov     eax, [edx+4]
.text:0000056B                 add     eax, 1
.text:0000056E                 mov     ecx, [ebp+var_4]
.text:00000571                 mov     [ecx+4], eax
.text:00000574                 mov     eax, [ebp+var_8]
.text:00000577                 add     esp, 8
.text:0000057A                 cmp     ebp, esp
.text:0000057C                 call    __RTC_CheckEsp
.text:00000581                 mov     esp, ebp
.text:00000583                 pop     ebp
.text:00000584                 retn    4
.text:00000584 ?Add@?$CRecordVector@PAX@@QAEIQAX@Z endp
.text:00000584
.text:00000584 ; ---------------------------------------------------------------------------
.text:00000587                 align 4
.text:00000587 _text           ends
.text:00000587
.text:00000588 ; ===========================================================================
.text:00000588
.text:00000588 ; Segment type: Pure code
.text:00000588 ; Segment permissions: Read/Execute
.text:00000588 _text           segment para public 'CODE' use32
.text:00000588                 assume cs:_text
.text:00000588                 ;org 588h
.text:00000588 ; COMDAT (pick any)
.text:00000588                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000588
.text:00000588 ; =============== S U B R O U T I N E =======================================
.text:00000588
.text:00000588 ; Attributes: bp-based frame
.text:00000588
.text:00000588 ; public: void * const & __thiscall CRecordVector<void *>::operator[](unsigned int)const
.text:00000588                 public ??A?$CRecordVector@PAX@@QBEABQAXI@Z
.text:00000588 ??A?$CRecordVector@PAX@@QBEABQAXI@Z proc near
.text:00000588                                         ; CODE XREF: CObjectVector<CBuffer<uchar>>::operator[](uint)+15p
.text:00000588
.text:00000588 var_4           = dword ptr -4
.text:00000588 arg_0           = dword ptr  8
.text:00000588
.text:00000588                 push    ebp
.text:00000589                 mov     ebp, esp
.text:0000058B                 push    ecx
.text:0000058C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000593                 mov     [ebp+var_4], ecx
.text:00000596                 mov     eax, [ebp+var_4]
.text:00000599                 mov     ecx, [eax]
.text:0000059B                 mov     edx, [ebp+arg_0]
.text:0000059E                 lea     eax, [ecx+edx*4]
.text:000005A1                 mov     esp, ebp
.text:000005A3                 pop     ebp
.text:000005A4                 retn    4
.text:000005A4 ??A?$CRecordVector@PAX@@QBEABQAXI@Z endp
.text:000005A4
.text:000005A4 ; ---------------------------------------------------------------------------
.text:000005A7                 align 4
.text:000005A7 _text           ends
.text:000005A7
.text:000005A8 ; ===========================================================================
.text:000005A8
.text:000005A8 ; Segment type: Pure code
.text:000005A8 ; Segment permissions: Read/Execute
.text:000005A8 _text           segment para public 'CODE' use32
.text:000005A8                 assume cs:_text
.text:000005A8                 ;org 5A8h
.text:000005A8 ; COMDAT (pick any)
.text:000005A8                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000005A8
.text:000005A8 ; =============== S U B R O U T I N E =======================================
.text:000005A8
.text:000005A8 ; Attributes: bp-based frame
.text:000005A8
.text:000005A8 ; public: void * & __thiscall CRecordVector<void *>::operator[](unsigned int)
.text:000005A8                 public ??A?$CRecordVector@PAX@@QAEAAPAXI@Z
.text:000005A8 ??A?$CRecordVector@PAX@@QAEAAPAXI@Z proc near
.text:000005A8                                         ; CODE XREF: CObjectVector<CBuffer<uchar>>::operator[](uint)+15p
.text:000005A8
.text:000005A8 var_4           = dword ptr -4
.text:000005A8 arg_0           = dword ptr  8
.text:000005A8
.text:000005A8                 push    ebp
.text:000005A9                 mov     ebp, esp
.text:000005AB                 push    ecx
.text:000005AC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000005B3                 mov     [ebp+var_4], ecx
.text:000005B6                 mov     eax, [ebp+var_4]
.text:000005B9                 mov     ecx, [eax]
.text:000005BB                 mov     edx, [ebp+arg_0]
.text:000005BE                 lea     eax, [ecx+edx*4]
.text:000005C1                 mov     esp, ebp
.text:000005C3                 pop     ebp
.text:000005C4                 retn    4
.text:000005C4 ??A?$CRecordVector@PAX@@QAEAAPAXI@Z endp
.text:000005C4
.text:000005C4 ; ---------------------------------------------------------------------------
.text:000005C7                 align 4
.text:000005C7 _text           ends
.text:000005C7
.text:000005C8 ; ===========================================================================
.text:000005C8
.text:000005C8 ; Segment type: Pure code
.text:000005C8 ; Segment permissions: Read/Execute
.text:000005C8 _text           segment para public 'CODE' use32
.text:000005C8                 assume cs:_text
.text:000005C8                 ;org 5C8h
.text:000005C8 ; COMDAT (pick any)
.text:000005C8                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000005C8
.text:000005C8 ; =============== S U B R O U T I N E =======================================
.text:000005C8
.text:000005C8 ; Attributes: bp-based frame
.text:000005C8
.text:000005C8 ; private: void __thiscall CRecordVector<unsigned int>::MoveItems(unsigned int, unsigned int)
.text:000005C8                 public ?MoveItems@?$CRecordVector@I@@AAEXII@Z
.text:000005C8 ?MoveItems@?$CRecordVector@I@@AAEXII@Z proc near
.text:000005C8                                         ; CODE XREF: CRecordVector<uint>::Insert(uint,uint)+24p
.text:000005C8
.text:000005C8 var_4           = dword ptr -4
.text:000005C8 arg_0           = dword ptr  8
.text:000005C8 arg_4           = dword ptr  0Ch
.text:000005C8
.text:000005C8                 push    ebp
.text:000005C9                 mov     ebp, esp
.text:000005CB                 push    ecx
.text:000005CC                 push    esi
.text:000005CD                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000005D4                 mov     [ebp+var_4], ecx
.text:000005D7                 mov     eax, [ebp+var_4]
.text:000005DA                 mov     ecx, [eax+4]
.text:000005DD                 sub     ecx, [ebp+arg_4]
.text:000005E0                 shl     ecx, 2
.text:000005E3                 mov     esi, esp
.text:000005E5                 push    ecx             ; Size
.text:000005E6                 mov     edx, [ebp+var_4]
.text:000005E9                 mov     eax, [edx]
.text:000005EB                 mov     ecx, [ebp+arg_4]
.text:000005EE                 lea     edx, [eax+ecx*4]
.text:000005F1                 push    edx             ; Src
.text:000005F2                 mov     eax, [ebp+var_4]
.text:000005F5                 mov     ecx, [eax]
.text:000005F7                 mov     edx, [ebp+arg_0]
.text:000005FA                 lea     eax, [ecx+edx*4]
.text:000005FD                 push    eax             ; Dst
.text:000005FE                 call    dword ptr ds:__imp__memmove
.text:00000604                 add     esp, 0Ch
.text:00000607                 cmp     esi, esp
.text:00000609                 call    __RTC_CheckEsp
.text:0000060E                 pop     esi
.text:0000060F                 add     esp, 4
.text:00000612                 cmp     ebp, esp
.text:00000614                 call    __RTC_CheckEsp
.text:00000619                 mov     esp, ebp
.text:0000061B                 pop     ebp
.text:0000061C                 retn    8
.text:0000061C ?MoveItems@?$CRecordVector@I@@AAEXII@Z endp
.text:0000061C
.text:0000061C ; ---------------------------------------------------------------------------
.text:0000061F                 align 10h
.text:0000061F _text           ends
.text:0000061F
.text:00000620 ; ===========================================================================
.text:00000620
.text:00000620 ; Segment type: Pure code
.text:00000620 ; Segment permissions: Read/Execute
.text:00000620 _text           segment para public 'CODE' use32
.text:00000620                 assume cs:_text
.text:00000620                 ;org 620h
.text:00000620 ; COMDAT (pick any)
.text:00000620                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000620
.text:00000620 ; =============== S U B R O U T I N E =======================================
.text:00000620
.text:00000620 ; Attributes: bp-based frame
.text:00000620
.text:00000620 ; private: void __thiscall CRecordVector<unsigned int>::ReserveOnePosition(void)
.text:00000620                 public ?ReserveOnePosition@?$CRecordVector@I@@AAEXXZ
.text:00000620 ?ReserveOnePosition@?$CRecordVector@I@@AAEXXZ proc near
.text:00000620                                         ; CODE XREF: CRecordVector<uint>::Insert(uint,uint)+11p
.text:00000620
.text:00000620 var_14          = dword ptr -14h
.text:00000620 var_10          = dword ptr -10h
.text:00000620 Dst             = dword ptr -0Ch
.text:00000620 var_8           = dword ptr -8
.text:00000620 var_4           = dword ptr -4
.text:00000620
.text:00000620                 push    ebp
.text:00000621                 mov     ebp, esp
.text:00000623                 sub     esp, 14h
.text:00000626                 mov     eax, 0CCCCCCCCh
.text:0000062B                 mov     [ebp+var_14], eax
.text:0000062E                 mov     [ebp+var_10], eax
.text:00000631                 mov     [ebp+Dst], eax
.text:00000634                 mov     [ebp+var_8], eax
.text:00000637                 mov     [ebp+var_4], eax
.text:0000063A                 mov     [ebp+var_4], ecx
.text:0000063D                 mov     eax, [ebp+var_4]
.text:00000640                 mov     ecx, [ebp+var_4]
.text:00000643                 mov     edx, [eax+4]
.text:00000646                 cmp     edx, [ecx+8]
.text:00000649                 jnz     loc_6D4
.text:0000064F                 mov     eax, [ebp+var_4]
.text:00000652                 mov     ecx, [eax+8]
.text:00000655                 shr     ecx, 2
.text:00000658                 mov     edx, [ebp+var_4]
.text:0000065B                 mov     eax, [edx+8]
.text:0000065E                 lea     ecx, [eax+ecx+1]
.text:00000662                 mov     [ebp+var_8], ecx
.text:00000665                 xor     ecx, ecx
.text:00000667                 mov     eax, [ebp+var_8]
.text:0000066A                 mov     edx, 4
.text:0000066F                 mul     edx
.text:00000671                 seto    cl
.text:00000674                 neg     ecx
.text:00000676                 or      ecx, eax
.text:00000678                 push    ecx             ; unsigned int
.text:00000679                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0000067E                 add     esp, 4
.text:00000681                 mov     [ebp+var_10], eax
.text:00000684                 mov     eax, [ebp+var_10]
.text:00000687                 mov     [ebp+Dst], eax
.text:0000068A                 mov     ecx, [ebp+var_4]
.text:0000068D                 cmp     dword ptr [ecx+4], 0
.text:00000691                 jz      short loc_6AF
.text:00000693                 mov     edx, [ebp+var_4]
.text:00000696                 mov     eax, [edx+4]
.text:00000699                 shl     eax, 2
.text:0000069C                 push    eax             ; Size
.text:0000069D                 mov     ecx, [ebp+var_4]
.text:000006A0                 mov     edx, [ecx]
.text:000006A2                 push    edx             ; Src
.text:000006A3                 mov     eax, [ebp+Dst]
.text:000006A6                 push    eax             ; Dst
.text:000006A7                 call    _memcpy
.text:000006AC                 add     esp, 0Ch
.text:000006AF
.text:000006AF loc_6AF:                                ; CODE XREF: CRecordVector<uint>::ReserveOnePosition(void)+71j
.text:000006AF                 mov     ecx, [ebp+var_4]
.text:000006B2                 mov     edx, [ecx]
.text:000006B4                 mov     [ebp+var_14], edx
.text:000006B7                 mov     eax, [ebp+var_14]
.text:000006BA                 push    eax             ; void *
.text:000006BB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:000006C0                 add     esp, 4
.text:000006C3                 mov     ecx, [ebp+var_4]
.text:000006C6                 mov     edx, [ebp+Dst]
.text:000006C9                 mov     [ecx], edx
.text:000006CB                 mov     eax, [ebp+var_4]
.text:000006CE                 mov     ecx, [ebp+var_8]
.text:000006D1                 mov     [eax+8], ecx
.text:000006D4
.text:000006D4 loc_6D4:                                ; CODE XREF: CRecordVector<uint>::ReserveOnePosition(void)+29j
.text:000006D4                 add     esp, 14h
.text:000006D7                 cmp     ebp, esp
.text:000006D9                 call    __RTC_CheckEsp
.text:000006DE                 mov     esp, ebp
.text:000006E0                 pop     ebp
.text:000006E1                 retn
.text:000006E1 ?ReserveOnePosition@?$CRecordVector@I@@AAEXXZ endp
.text:000006E1
.text:000006E1 ; ---------------------------------------------------------------------------
.text:000006E2                 align 4
.text:000006E2 _text           ends
.text:000006E2
.text:000006E4 ; ===========================================================================
.text:000006E4
.text:000006E4 ; Segment type: Pure code
.text:000006E4 ; Segment permissions: Read/Execute
.text:000006E4 _text           segment para public 'CODE' use32
.text:000006E4                 assume cs:_text
.text:000006E4                 ;org 6E4h
.text:000006E4 ; COMDAT (pick any)
.text:000006E4                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000006E4
.text:000006E4 ; =============== S U B R O U T I N E =======================================
.text:000006E4
.text:000006E4 ; Attributes: bp-based frame
.text:000006E4
.text:000006E4 ; public: void __thiscall CRecordVector<unsigned int>::ClearAndReserve(unsigned int)
.text:000006E4                 public ?ClearAndReserve@?$CRecordVector@I@@QAEXI@Z
.text:000006E4 ?ClearAndReserve@?$CRecordVector@I@@QAEXI@Z proc near
.text:000006E4                                         ; CODE XREF: CRecordVector<uint>::ClearAndSetSize(uint)+15p
.text:000006E4
.text:000006E4 var_C           = dword ptr -0Ch
.text:000006E4 var_8           = dword ptr -8
.text:000006E4 var_4           = dword ptr -4
.text:000006E4 arg_0           = dword ptr  8
.text:000006E4
.text:000006E4                 push    ebp
.text:000006E5                 mov     ebp, esp
.text:000006E7                 sub     esp, 0Ch
.text:000006EA                 mov     [ebp+var_C], 0CCCCCCCCh
.text:000006F1                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000006F8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000006FF                 mov     [ebp+var_4], ecx
.text:00000702                 mov     ecx, [ebp+var_4]
.text:00000705                 call    ?Clear@?$CRecordVector@I@@QAEXXZ ; CRecordVector<uint>::Clear(void)
.text:0000070A                 mov     eax, [ebp+var_4]
.text:0000070D                 mov     ecx, [ebp+arg_0]
.text:00000710                 cmp     ecx, [eax+8]
.text:00000713                 jbe     short loc_76C
.text:00000715                 mov     edx, [ebp+var_4]
.text:00000718                 mov     eax, [edx]
.text:0000071A                 mov     [ebp+var_8], eax
.text:0000071D                 mov     ecx, [ebp+var_8]
.text:00000720                 push    ecx             ; void *
.text:00000721                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00000726                 add     esp, 4
.text:00000729                 mov     edx, [ebp+var_4]
.text:0000072C                 mov     dword ptr [edx], 0
.text:00000732                 mov     eax, [ebp+var_4]
.text:00000735                 mov     dword ptr [eax+8], 0
.text:0000073C                 xor     ecx, ecx
.text:0000073E                 mov     eax, [ebp+arg_0]
.text:00000741                 mov     edx, 4
.text:00000746                 mul     edx
.text:00000748                 seto    cl
.text:0000074B                 neg     ecx
.text:0000074D                 or      ecx, eax
.text:0000074F                 push    ecx             ; unsigned int
.text:00000750                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00000755                 add     esp, 4
.text:00000758                 mov     [ebp+var_C], eax
.text:0000075B                 mov     eax, [ebp+var_4]
.text:0000075E                 mov     ecx, [ebp+var_C]
.text:00000761                 mov     [eax], ecx
.text:00000763                 mov     edx, [ebp+var_4]
.text:00000766                 mov     eax, [ebp+arg_0]
.text:00000769                 mov     [edx+8], eax
.text:0000076C
.text:0000076C loc_76C:                                ; CODE XREF: CRecordVector<uint>::ClearAndReserve(uint)+2Fj
.text:0000076C                 add     esp, 0Ch
.text:0000076F                 cmp     ebp, esp
.text:00000771                 call    __RTC_CheckEsp
.text:00000776                 mov     esp, ebp
.text:00000778                 pop     ebp
.text:00000779                 retn    4
.text:00000779 ?ClearAndReserve@?$CRecordVector@I@@QAEXI@Z endp
.text:00000779
.text:00000779 _text           ends
.text:00000779
.text:0000077C ; ===========================================================================
.text:0000077C
.text:0000077C ; Segment type: Pure code
.text:0000077C ; Segment permissions: Read/Execute
.text:0000077C _text           segment para public 'CODE' use32
.text:0000077C                 assume cs:_text
.text:0000077C                 ;org 77Ch
.text:0000077C ; COMDAT (pick any)
.text:0000077C                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:0000077C
.text:0000077C ; =============== S U B R O U T I N E =======================================
.text:0000077C
.text:0000077C ; Attributes: bp-based frame
.text:0000077C
.text:0000077C ; public: __thiscall CBuffer<unsigned char>::CBuffer<unsigned char>(void)
.text:0000077C                 public ??0?$CBuffer@E@@QAE@XZ
.text:0000077C ??0?$CBuffer@E@@QAE@XZ proc near        ; CODE XREF: CObjectVector<CBuffer<uchar>>::AddNew(void)+59p
.text:0000077C
.text:0000077C var_4           = dword ptr -4
.text:0000077C
.text:0000077C                 push    ebp
.text:0000077D                 mov     ebp, esp
.text:0000077F                 push    ecx
.text:00000780                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000787                 mov     [ebp+var_4], ecx
.text:0000078A                 mov     eax, [ebp+var_4]
.text:0000078D                 mov     dword ptr [eax], 0
.text:00000793                 mov     ecx, [ebp+var_4]
.text:00000796                 mov     dword ptr [ecx+4], 0
.text:0000079D                 mov     eax, [ebp+var_4]
.text:000007A0                 mov     esp, ebp
.text:000007A2                 pop     ebp
.text:000007A3                 retn
.text:000007A3 ??0?$CBuffer@E@@QAE@XZ endp
.text:000007A3
.text:000007A3 _text           ends
.text:000007A3
.text:000007A4 ; ===========================================================================
.text:000007A4
.text:000007A4 ; Segment type: Pure code
.text:000007A4 ; Segment permissions: Read/Execute
.text:000007A4 _text           segment para public 'CODE' use32
.text:000007A4                 assume cs:_text
.text:000007A4                 ;org 7A4h
.text:000007A4 ; COMDAT (pick any)
.text:000007A4                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000007A4
.text:000007A4 ; =============== S U B R O U T I N E =======================================
.text:000007A4
.text:000007A4 ; Attributes: bp-based frame
.text:000007A4
.text:000007A4 ; public: void __thiscall CBuffer<unsigned char>::Alloc(unsigned int)
.text:000007A4                 public ?Alloc@?$CBuffer@E@@QAEXI@Z
.text:000007A4 ?Alloc@?$CBuffer@E@@QAEXI@Z proc near   ; CODE XREF: CBuffer<uchar>::CopyFrom(uchar const *,uint)+15p
.text:000007A4
.text:000007A4 var_8           = dword ptr -8
.text:000007A4 var_4           = dword ptr -4
.text:000007A4 arg_0           = dword ptr  8
.text:000007A4
.text:000007A4                 push    ebp
.text:000007A5                 mov     ebp, esp
.text:000007A7                 sub     esp, 8
.text:000007AA                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000007B1                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000007B8                 mov     [ebp+var_4], ecx
.text:000007BB                 mov     eax, [ebp+var_4]
.text:000007BE                 mov     ecx, [ebp+arg_0]
.text:000007C1                 cmp     ecx, [eax+4]
.text:000007C4                 jz      short loc_7F4
.text:000007C6                 mov     ecx, [ebp+var_4]
.text:000007C9                 call    ?Free@?$CBuffer@E@@QAEXXZ ; CBuffer<uchar>::Free(void)
.text:000007CE                 cmp     [ebp+arg_0], 0
.text:000007D2                 jz      short loc_7F4
.text:000007D4                 mov     edx, [ebp+arg_0]
.text:000007D7                 push    edx             ; unsigned int
.text:000007D8                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:000007DD                 add     esp, 4
.text:000007E0                 mov     [ebp+var_8], eax
.text:000007E3                 mov     eax, [ebp+var_4]
.text:000007E6                 mov     ecx, [ebp+var_8]
.text:000007E9                 mov     [eax], ecx
.text:000007EB                 mov     edx, [ebp+var_4]
.text:000007EE                 mov     eax, [ebp+arg_0]
.text:000007F1                 mov     [edx+4], eax
.text:000007F4
.text:000007F4 loc_7F4:                                ; CODE XREF: CBuffer<uchar>::Alloc(uint)+20j
.text:000007F4                                         ; CBuffer<uchar>::Alloc(uint)+2Ej
.text:000007F4                 add     esp, 8
.text:000007F7                 cmp     ebp, esp
.text:000007F9                 call    __RTC_CheckEsp
.text:000007FE                 mov     esp, ebp
.text:00000800                 pop     ebp
.text:00000801                 retn    4
.text:00000801 ?Alloc@?$CBuffer@E@@QAEXI@Z endp
.text:00000801
.text:00000801 _text           ends
.text:00000801
.text:00000804 ; ===========================================================================
.text:00000804
.text:00000804 ; Segment type: Pure code
.text:00000804 ; Segment permissions: Read/Execute
.text:00000804 _text           segment para public 'CODE' use32
.text:00000804                 assume cs:_text
.text:00000804                 ;org 804h
.text:00000804 ; COMDAT (pick any)
.text:00000804                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000804
.text:00000804 ; =============== S U B R O U T I N E =======================================
.text:00000804
.text:00000804 ; Attributes: bp-based frame
.text:00000804
.text:00000804 ; private: void __thiscall CRecordVector<void *>::ReserveOnePosition(void)
.text:00000804                 public ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ
.text:00000804 ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ proc near
.text:00000804                                         ; CODE XREF: CRecordVector<void *>::Add(void * const)+1Ap
.text:00000804
.text:00000804 var_14          = dword ptr -14h
.text:00000804 var_10          = dword ptr -10h
.text:00000804 Dst             = dword ptr -0Ch
.text:00000804 var_8           = dword ptr -8
.text:00000804 var_4           = dword ptr -4
.text:00000804
.text:00000804                 push    ebp
.text:00000805                 mov     ebp, esp
.text:00000807                 sub     esp, 14h
.text:0000080A                 mov     eax, 0CCCCCCCCh
.text:0000080F                 mov     [ebp+var_14], eax
.text:00000812                 mov     [ebp+var_10], eax
.text:00000815                 mov     [ebp+Dst], eax
.text:00000818                 mov     [ebp+var_8], eax
.text:0000081B                 mov     [ebp+var_4], eax
.text:0000081E                 mov     [ebp+var_4], ecx
.text:00000821                 mov     eax, [ebp+var_4]
.text:00000824                 mov     ecx, [ebp+var_4]
.text:00000827                 mov     edx, [eax+4]
.text:0000082A                 cmp     edx, [ecx+8]
.text:0000082D                 jnz     loc_8B8
.text:00000833                 mov     eax, [ebp+var_4]
.text:00000836                 mov     ecx, [eax+8]
.text:00000839                 shr     ecx, 2
.text:0000083C                 mov     edx, [ebp+var_4]
.text:0000083F                 mov     eax, [edx+8]
.text:00000842                 lea     ecx, [eax+ecx+1]
.text:00000846                 mov     [ebp+var_8], ecx
.text:00000849                 xor     ecx, ecx
.text:0000084B                 mov     eax, [ebp+var_8]
.text:0000084E                 mov     edx, 4
.text:00000853                 mul     edx
.text:00000855                 seto    cl
.text:00000858                 neg     ecx
.text:0000085A                 or      ecx, eax
.text:0000085C                 push    ecx             ; unsigned int
.text:0000085D                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00000862                 add     esp, 4
.text:00000865                 mov     [ebp+var_10], eax
.text:00000868                 mov     eax, [ebp+var_10]
.text:0000086B                 mov     [ebp+Dst], eax
.text:0000086E                 mov     ecx, [ebp+var_4]
.text:00000871                 cmp     dword ptr [ecx+4], 0
.text:00000875                 jz      short loc_893
.text:00000877                 mov     edx, [ebp+var_4]
.text:0000087A                 mov     eax, [edx+4]
.text:0000087D                 shl     eax, 2
.text:00000880                 push    eax             ; Size
.text:00000881                 mov     ecx, [ebp+var_4]
.text:00000884                 mov     edx, [ecx]
.text:00000886                 push    edx             ; Src
.text:00000887                 mov     eax, [ebp+Dst]
.text:0000088A                 push    eax             ; Dst
.text:0000088B                 call    _memcpy
.text:00000890                 add     esp, 0Ch
.text:00000893
.text:00000893 loc_893:                                ; CODE XREF: CRecordVector<void *>::ReserveOnePosition(void)+71j
.text:00000893                 mov     ecx, [ebp+var_4]
.text:00000896                 mov     edx, [ecx]
.text:00000898                 mov     [ebp+var_14], edx
.text:0000089B                 mov     eax, [ebp+var_14]
.text:0000089E                 push    eax             ; void *
.text:0000089F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:000008A4                 add     esp, 4
.text:000008A7                 mov     ecx, [ebp+var_4]
.text:000008AA                 mov     edx, [ebp+Dst]
.text:000008AD                 mov     [ecx], edx
.text:000008AF                 mov     eax, [ebp+var_4]
.text:000008B2                 mov     ecx, [ebp+var_8]
.text:000008B5                 mov     [eax+8], ecx
.text:000008B8
.text:000008B8 loc_8B8:                                ; CODE XREF: CRecordVector<void *>::ReserveOnePosition(void)+29j
.text:000008B8                 add     esp, 14h
.text:000008BB                 cmp     ebp, esp
.text:000008BD                 call    __RTC_CheckEsp
.text:000008C2                 mov     esp, ebp
.text:000008C4                 pop     ebp
.text:000008C5                 retn
.text:000008C5 ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ endp
.text:000008C5
.text:000008C5 ; ---------------------------------------------------------------------------
.text:000008C6                 align 4
.text:000008C6 _text           ends
.text:000008C6
.text:000008C8 ; ===========================================================================
.text:000008C8
.text:000008C8 ; Segment type: Pure code
.text:000008C8 ; Segment permissions: Read/Execute
.text:000008C8 _text           segment para public 'CODE' use32
.text:000008C8                 assume cs:_text
.text:000008C8                 ;org 8C8h
.text:000008C8 ; COMDAT (pick any)
.text:000008C8                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000008C8
.text:000008C8 ; =============== S U B R O U T I N E =======================================
.text:000008C8
.text:000008C8 ; Attributes: bp-based frame
.text:000008C8
.text:000008C8 ; public: void __thiscall CRecordVector<unsigned int>::Clear(void)
.text:000008C8                 public ?Clear@?$CRecordVector@I@@QAEXXZ
.text:000008C8 ?Clear@?$CRecordVector@I@@QAEXXZ proc near
.text:000008C8                                         ; CODE XREF: CRecordVector<uint>::ClearAndReserve(uint)+21p
.text:000008C8
.text:000008C8 var_4           = dword ptr -4
.text:000008C8
.text:000008C8                 push    ebp
.text:000008C9                 mov     ebp, esp
.text:000008CB                 push    ecx
.text:000008CC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000008D3                 mov     [ebp+var_4], ecx
.text:000008D6                 mov     eax, [ebp+var_4]
.text:000008D9                 mov     dword ptr [eax+4], 0
.text:000008E0                 mov     esp, ebp
.text:000008E2                 pop     ebp
.text:000008E3                 retn
.text:000008E3 ?Clear@?$CRecordVector@I@@QAEXXZ endp
.text:000008E3
.text:000008E3 _text           ends
.text:000008E3
.text:000008E4 ; ===========================================================================
.text:000008E4
.text:000008E4 ; Segment type: Pure code
.text:000008E4 ; Segment permissions: Read/Execute
.text:000008E4 _text           segment para public 'CODE' use32
.text:000008E4                 assume cs:_text
.text:000008E4                 ;org 8E4h
.text:000008E4 ; COMDAT (pick any)
.text:000008E4                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000008E4
.text:000008E4 ; =============== S U B R O U T I N E =======================================
.text:000008E4
.text:000008E4 ; Attributes: bp-based frame
.text:000008E4
.text:000008E4 ; public: void __thiscall CBuffer<unsigned char>::Free(void)
.text:000008E4                 public ?Free@?$CBuffer@E@@QAEXXZ
.text:000008E4 ?Free@?$CBuffer@E@@QAEXXZ proc near     ; CODE XREF: CBuffer<uchar>::Alloc(uint)+25p
.text:000008E4
.text:000008E4 var_8           = dword ptr -8
.text:000008E4 var_4           = dword ptr -4
.text:000008E4
.text:000008E4                 push    ebp
.text:000008E5                 mov     ebp, esp
.text:000008E7                 sub     esp, 8
.text:000008EA                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000008F1                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000008F8                 mov     [ebp+var_4], ecx
.text:000008FB                 mov     eax, [ebp+var_4]
.text:000008FE                 cmp     dword ptr [eax], 0
.text:00000901                 jz      short loc_920
.text:00000903                 mov     ecx, [ebp+var_4]
.text:00000906                 mov     edx, [ecx]
.text:00000908                 mov     [ebp+var_8], edx
.text:0000090B                 mov     eax, [ebp+var_8]
.text:0000090E                 push    eax             ; void *
.text:0000090F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00000914                 add     esp, 4
.text:00000917                 mov     ecx, [ebp+var_4]
.text:0000091A                 mov     dword ptr [ecx], 0
.text:00000920
.text:00000920 loc_920:                                ; CODE XREF: CBuffer<uchar>::Free(void)+1Dj
.text:00000920                 mov     edx, [ebp+var_4]
.text:00000923                 mov     dword ptr [edx+4], 0
.text:0000092A                 add     esp, 8
.text:0000092D                 cmp     ebp, esp
.text:0000092F                 call    __RTC_CheckEsp
.text:00000934                 mov     esp, ebp
.text:00000936                 pop     ebp
.text:00000937                 retn
.text:00000937 ?Free@?$CBuffer@E@@QAEXXZ endp
.text:00000937
.text:00000937 _text           ends
.text:00000937
UNDEF:00000940 ; ===========================================================================
UNDEF:00000940
UNDEF:00000940 ; Segment type: Externs
UNDEF:00000940 ; UNDEF
UNDEF:00000940 ; int __cdecl memcmp(const void *Buf1, const void *Buf2, size_t Size)
UNDEF:00000940                 extrn _memcmp:near      ; CODE XREF: CUniqBlocks::AddUniq(uchar const *,uint)+C2p
UNDEF:00000944                 extrn __RTC_CheckEsp:near
UNDEF:00000944                                         ; CODE XREF: CUniqBlocks::AddUniq(uchar const *,uint)+131p
UNDEF:00000944                                         ; CUniqBlocks::GetTotalSizeInBytes(void)+75p ...
UNDEF:00000948                 extrn __RTC_Shutdown:near
UNDEF:00000948                                         ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
UNDEF:0000094C                 extrn __RTC_InitBase:near
UNDEF:0000094C                                         ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
UNDEF:00000950 ; void __cdecl operator delete(void *)
UNDEF:00000950                 extrn ??3@YAXPAX@Z:near ; CODE XREF: __unwindfunclet$?AddNew@?$CObjectVector@V?$CBuffer@E@@@@QAEAAV?$CBuffer@E@@XZ$0+4p
UNDEF:00000950                                         ; CRecordVector<uint>::ReserveOnePosition(void)+9Bp ...
UNDEF:00000954 ; void *__cdecl operator new(unsigned int)
UNDEF:00000954                 extrn ??2@YAPAXI@Z:near ; CODE XREF: CObjectVector<CBuffer<uchar>>::AddNew(void)+3Ep
UNDEF:00000954                                         ; CRecordVector<uint>::ReserveOnePosition(void)+59p ...
UNDEF:00000958                 extrn ___security_cookie:near
UNDEF:00000958                                         ; DATA XREF: CObjectVector<CBuffer<uchar>>::AddNew(void)+28r
UNDEF:0000095C                 extrn ___CxxFrameHandler3:near
UNDEF:0000095C                                         ; CODE XREF: __ehhandler$?AddNew@?$CObjectVector@V?$CBuffer@E@@@@QAEAAV?$CBuffer@E@@XZ+16j
UNDEF:00000960 ; __fastcall __security_check_cookie(x)
UNDEF:00000960                 extrn @__security_check_cookie@4:near
UNDEF:00000960                                         ; CODE XREF: __ehhandler$?AddNew@?$CObjectVector@V?$CBuffer@E@@@@QAEAAV?$CBuffer@E@@XZ+Cp
UNDEF:00000964 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:00000964                 extrn _memcpy:near      ; CODE XREF: CBuffer<uchar>::CopyFrom(uchar const *,uint)+2Ep
UNDEF:00000964                                         ; CRecordVector<uint>::ReserveOnePosition(void)+87p ...
UNDEF:00000968 ; void *__cdecl _memmove(void *Dst, const void *Src, size_t Size)
UNDEF:00000968                 extrn __imp__memmove:near
UNDEF:00000968                                         ; CODE XREF: CRecordVector<uint>::MoveItems(uint,uint)+36p
UNDEF:00000968                                         ; DATA XREF: CRecordVector<uint>::MoveItems(uint,uint)+36r
UNDEF:00000968
UNDEF:00000968
UNDEF:00000968                 end