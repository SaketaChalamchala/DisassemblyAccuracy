.rdata:00000000 ;
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.rdata:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.rdata:00000000 ; |                      License info: 48-3677-7074-51                      |
.rdata:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ;
.rdata:00000000 ; Input MD5   : 882009FC286A7690FCFF001CAD14945F
.rdata:00000000 ; Input CRC32 : 3A026F4E
.rdata:00000000
.rdata:00000000 ; File Name   : C:\workspace\7z1505-src\CPP\7zip\Bundles\Alone\Debug\Update.obj
.rdata:00000000 ; Format      : COFF (X386MAGIC)
.rdata:00000000 ; includelib "uuid.lib"
.rdata:00000000 ; includelib "MSVCRTD"
.rdata:00000000 ; includelib "OLDNAMES"
.rdata:00000000
.rdata:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.rdata:00000000
.rdata:00000000                 .686p
.rdata:00000000                 .mmx
.rdata:00000000                 .model flat
.rdata:00000000
.rdata:00000000 ; ===========================================================================
.rdata:00000000
.rdata:00000000 ; Segment type: Pure data
.rdata:00000000 ; Segment permissions: Read
.rdata:00000000 _rdata          segment dword public 'DATA' use32
.rdata:00000000                 assume cs:_rdata
.rdata:00000000 $SG74034        db 'update operations are not supported for this archive',0
.rdata:00000000                                         ; DATA XREF: .data:_kUpdateIsNotSupoortedo
.rdata:00000035                 align 4
.rdata:00000038 $SG74036:                               ; DATA XREF: .data:_kTempFolderPrefixo
.rdata:00000038                 unicode 0, <7zE>,0
.rdata:00000040 ; char _SG74378[]
.rdata:00000040 $SG74378        db '.tmp',0             ; DATA XREF: CArchivePath::GetTempPathA(void):loc_1075o
.rdata:00000040                                         ; .xdata$x:__catchsym$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$40o ...
.rdata:00000045                 align 4
.rdata:00000048 $SG74380:                               ; DATA XREF: .data:_kDefaultArcTypeo
.rdata:00000048                 unicode 0, <7z>,0
.rdata:0000004E                 align 10h
.rdata:00000050 $SG74382:                               ; DATA XREF: .data:_kDefaultArcExto
.rdata:00000050                 unicode 0, <7z>,0
.rdata:00000056                 align 4
.rdata:00000058 $SG74384        db 'exe',0              ; DATA XREF: .data:_kSFXExtensiono
.rdata:0000005C ; char _SG74931[]
.rdata:0000005C $SG74931        db 'cannot open file',0 ; DATA XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+B9Bo
.rdata:0000006D                 align 10h
.rdata:00000070 ; char _SG74957[]
.rdata:00000070 $SG74957        db 'cannot open SFX module',0
.rdata:00000070                                         ; DATA XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+F84o
.rdata:00000087                 align 4
.rdata:00000088 ; char _SG74971[]
.rdata:00000088 $SG74971        db 'cannot open file',0 ; DATA XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+10EDo
.rdata:00000099                 align 4
.rdata:0000009C $SG75009        db 'There are unclosed input file:',0
.rdata:0000009C                                         ; DATA XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+184Eo
.rdata:000000BB                 align 4
.rdata:000000BC ; char _SG75347[]
.rdata:000000BC $SG75347        db 'rsfx',0             ; DATA XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+194o
.rdata:000000C1                 align 4
.rdata:000000C4 $SG75349        db 'SFX file is not specified',0
.rdata:000000C4                                         ; DATA XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1C5o
.rdata:000000DE                 align 10h
.rdata:000000E0 ; char _SG75361[]
.rdata:000000E0 $SG75361        db 'cannot find specified SFX module',0
.rdata:000000E0                                         ; DATA XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+2C4o
.rdata:00000101                 align 4
.rdata:00000104 $SG75374        db 'type of archive is not specified',0
.rdata:00000104                                         ; DATA XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+3A1o
.rdata:00000125                 align 4
.rdata:00000128 $SG75380        db 'can',27h,'t find archive',0
.rdata:00000128                                         ; DATA XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+3FAo
.rdata:0000013B                 align 4
.rdata:0000013C $SG75388        db 'there is no such archive',0
.rdata:0000013C                                         ; DATA XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+491o
.rdata:00000155                 align 4
.rdata:00000158 $SG75420        db 'Updating for multivolume archives is not implemented',0
.rdata:00000158                                         ; DATA XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+8AFo
.rdata:0000018D                 align 10h
.rdata:00000190 $SG75427        db 'There is some data block after the end of the archive',0
.rdata:00000190                                         ; DATA XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+995o
.rdata:000001C6                 align 4
.rdata:000001C8 $SG75467        db 'Scanning error',0   ; DATA XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+E3Do
.rdata:000001D7                 align 4
.rdata:000001D8 $SG75502        db 'The file already exists',0
.rdata:000001D8                                         ; DATA XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+12D7o
.rdata:000001F0 ; char _SG75524[]
.rdata:000001F0 $SG75524        db 'stdout',0           ; DATA XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+159Bo
.rdata:000001F7                 align 4
.rdata:000001F8 ; char _SG75551[]
.rdata:000001F8 $SG75551        db 'cannot delete the file',0
.rdata:000001F8                                         ; DATA XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1B0Eo
.rdata:0000020F                 align 10h
.rdata:00000210 ; char _SG75553[]
.rdata:00000210 $SG75553        db 'cannot move the file',0
.rdata:00000210                                         ; DATA XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1C22o
.rdata:00000225                 align 4
.rdata:00000228 ; wchar_t _SG75558
.rdata:00000228 $SG75558:                               ; DATA XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1D4Eo
.rdata:00000228                 unicode 0, <Mapi32.dll>,0
.rdata:0000023E                 align 10h
.rdata:00000240 ; char _SG75559[]
.rdata:00000240 $SG75559        db 'cannot load Mapi32.dll',0
.rdata:00000240                                         ; DATA XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1D69o
.rdata:00000257                 align 4
.rdata:00000258 ; CHAR _SG75563[]
.rdata:00000258 $SG75563        db 'MAPISendMail',0     ; DATA XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool):loc_3544o
.rdata:00000265                 align 4
.rdata:00000268 ; char _SG75565[]
.rdata:00000268 $SG75565        db '7-Zip cannot find MAPISendMail function',0
.rdata:00000268                                         ; DATA XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1E4Bo
.rdata:00000290 ; char _SG75578[]
.rdata:00000290 $SG75578        db 'GetFullPathName error',0
.rdata:00000290                                         ; DATA XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1FB5o
.rdata:000002A6                 align 4
.rdata:000002A6 _rdata          ends
.rdata:000002A6
.data:000002A8 ; ===========================================================================
.data:000002A8
.data:000002A8 ; Segment type: Pure data
.data:000002A8 ; Segment permissions: Read/Write
.data:000002A8 _data           segment dword public 'DATA' use32
.data:000002A8                 assume cs:_data
.data:000002A8                 ;org 2A8h
.data:000002A8 _kUpdateIsNotSupoorted dd offset $SG74034
.data:000002A8                                         ; DATA XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+C6r
.data:000002A8                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+139r
.data:000002A8                                         ; "update operations are not supported for"...
.data:000002AC ; wchar_t *kTempFolderPrefix
.data:000002AC _kTempFolderPrefix dd offset $SG74036   ; DATA XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+10C4r
.data:000002AC                                         ; "7zE"
.data:000002B0 _kDefaultArcType dd offset $SG74380     ; DATA XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+B09r
.data:000002B0                                         ; "7z"
.data:000002B4 _kDefaultArcExt dd offset $SG74382      ; DATA XREF: CUpdateOptions::SetArcPath(CCodecs const *,UString const &)+58r
.data:000002B4                                         ; "7z"
.data:000002B8 ; char *kSFXExtension
.data:000002B8 _kSFXExtension  dd offset $SG74384      ; DATA XREF: CUpdateOptions::SetArcPath(CCodecs const *,UString const &)+F0r
.data:000002B8 _data           ends                    ; "exe"
.data:000002B8
.text:000002BC ; ===========================================================================
.text:000002BC
.text:000002BC ; Segment type: Pure code
.text:000002BC ; Segment permissions: Read/Execute
.text:000002BC _text           segment para public 'CODE' use32
.text:000002BC                 assume cs:_text
.text:000002BC                 ;org 2BCh
.text:000002BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000002BC
.text:000002BC ; =============== S U B R O U T I N E =======================================
.text:000002BC
.text:000002BC ; Attributes: bp-based frame
.text:000002BC
.text:000002BC ; void __thiscall CUpdateErrorInfo::SetFromLastError(CUpdateErrorInfo *this, const char *)
.text:000002BC                 public ?SetFromLastError@CUpdateErrorInfo@@QAEXPBD@Z
.text:000002BC ?SetFromLastError@CUpdateErrorInfo@@QAEXPBD@Z proc near
.text:000002BC                                         ; CODE XREF: CUpdateErrorInfo::SetFromLastError(char const *,UString const &)+15p
.text:000002BC                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1D71p ...
.text:000002BC
.text:000002BC var_4           = dword ptr -4
.text:000002BC arg_0           = dword ptr  8
.text:000002BC
.text:000002BC                 push    ebp
.text:000002BD                 mov     ebp, esp
.text:000002BF                 push    ecx
.text:000002C0                 push    esi
.text:000002C1                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000002C8                 mov     [ebp+var_4], ecx
.text:000002CB                 mov     esi, esp
.text:000002CD                 call    dword ptr ds:__imp__GetLastError@0 ; GetLastError()
.text:000002D3                 cmp     esi, esp
.text:000002D5                 call    __RTC_CheckEsp
.text:000002DA                 mov     ecx, [ebp+var_4]
.text:000002DD                 mov     [ecx], eax
.text:000002DF                 mov     edx, [ebp+arg_0]
.text:000002E2                 push    edx
.text:000002E3                 mov     ecx, [ebp+var_4]
.text:000002E6                 add     ecx, 4
.text:000002E9                 call    ??4AString@@QAEAAV0@PBD@Z ; AString::operator=(char const *)
.text:000002EE                 pop     esi
.text:000002EF                 add     esp, 4
.text:000002F2                 cmp     ebp, esp
.text:000002F4                 call    __RTC_CheckEsp
.text:000002F9                 mov     esp, ebp
.text:000002FB                 pop     ebp
.text:000002FC                 retn    4
.text:000002FC ?SetFromLastError@CUpdateErrorInfo@@QAEXPBD@Z endp
.text:000002FC
.text:000002FC ; ---------------------------------------------------------------------------
.text:000002FF                 db 0Dh dup(0CCh)
.text:0000030C
.text:0000030C ; =============== S U B R O U T I N E =======================================
.text:0000030C
.text:0000030C ; Attributes: bp-based frame
.text:0000030C
.text:0000030C ; __int32 __thiscall CUpdateErrorInfo::SetFromLastError(CUpdateErrorInfo *this, const char *, const struct UString *)
.text:0000030C                 public ?SetFromLastError@CUpdateErrorInfo@@QAEJPBDABVUString@@@Z
.text:0000030C ?SetFromLastError@CUpdateErrorInfo@@QAEJPBDABVUString@@@Z proc near
.text:0000030C                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+2CCp
.text:0000030C                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1B16p ...
.text:0000030C
.text:0000030C var_4           = dword ptr -4
.text:0000030C arg_0           = dword ptr  8
.text:0000030C arg_4           = dword ptr  0Ch
.text:0000030C
.text:0000030C                 push    ebp
.text:0000030D                 mov     ebp, esp
.text:0000030F                 push    ecx
.text:00000310                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000317                 mov     [ebp+var_4], ecx
.text:0000031A                 mov     eax, [ebp+arg_0]
.text:0000031D                 push    eax             ; char *
.text:0000031E                 mov     ecx, [ebp+var_4] ; this
.text:00000321                 call    ?SetFromLastError@CUpdateErrorInfo@@QAEXPBD@Z ; CUpdateErrorInfo::SetFromLastError(char const *)
.text:00000326                 mov     ecx, [ebp+arg_4]
.text:00000329                 push    ecx
.text:0000032A                 mov     ecx, [ebp+var_4]
.text:0000032D                 add     ecx, 10h
.text:00000330                 call    ?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z ; CObjectVector<UString>::Add(UString const &)
.text:00000335                 mov     ecx, [ebp+var_4] ; this
.text:00000338                 call    ?Get_HRESULT_Error@CUpdateErrorInfo@@QBEJXZ ; CUpdateErrorInfo::Get_HRESULT_Error(void)
.text:0000033D                 add     esp, 4
.text:00000340                 cmp     ebp, esp
.text:00000342                 call    __RTC_CheckEsp
.text:00000347                 mov     esp, ebp
.text:00000349                 pop     ebp
.text:0000034A                 retn    8
.text:0000034A ?SetFromLastError@CUpdateErrorInfo@@QAEJPBDABVUString@@@Z endp
.text:0000034A
.text:0000034A ; ---------------------------------------------------------------------------
.text:0000034D                 db 0Fh dup(0CCh)
.text:0000035C
.text:0000035C ; =============== S U B R O U T I N E =======================================
.text:0000035C
.text:0000035C ; Attributes: bp-based frame
.text:0000035C
.text:0000035C ; __int32 __thiscall COutMultiVolStream::Close(COutMultiVolStream *__hidden this)
.text:0000035C                 public ?Close@COutMultiVolStream@@QAEJXZ
.text:0000035C ?Close@COutMultiVolStream@@QAEJXZ proc near
.text:0000035C                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+1B0Dp
.text:0000035C
.text:0000035C var_14          = dword ptr -14h
.text:0000035C var_10          = dword ptr -10h
.text:0000035C var_C           = dword ptr -0Ch
.text:0000035C var_8           = dword ptr -8
.text:0000035C var_4           = dword ptr -4
.text:0000035C
.text:0000035C                 push    ebp
.text:0000035D                 mov     ebp, esp
.text:0000035F                 sub     esp, 14h
.text:00000362                 mov     eax, 0CCCCCCCCh
.text:00000367                 mov     [ebp+var_14], eax
.text:0000036A                 mov     [ebp+var_10], eax
.text:0000036D                 mov     [ebp+var_C], eax
.text:00000370                 mov     [ebp+var_8], eax
.text:00000373                 mov     [ebp+var_4], eax
.text:00000376                 mov     [ebp+var_4], ecx
.text:00000379                 mov     [ebp+var_8], 0
.text:00000380                 mov     [ebp+var_C], 0
.text:00000387                 jmp     short loc_392
.text:00000389 ; ---------------------------------------------------------------------------
.text:00000389
.text:00000389 loc_389:                                ; CODE XREF: COutMultiVolStream::Close(void):loc_3D3j
.text:00000389                 mov     eax, [ebp+var_C]
.text:0000038C                 add     eax, 1
.text:0000038F                 mov     [ebp+var_C], eax
.text:00000392
.text:00000392 loc_392:                                ; CODE XREF: COutMultiVolStream::Close(void)+2Bj
.text:00000392                 mov     ecx, [ebp+var_4]
.text:00000395                 add     ecx, 28h ; '('
.text:00000398                 call    ?Size@?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QBEIXZ ; CObjectVector<COutMultiVolStream::CAltStreamInfo>::Size(void)
.text:0000039D                 cmp     [ebp+var_C], eax
.text:000003A0                 jnb     short loc_3D5
.text:000003A2                 mov     ecx, [ebp+var_C]
.text:000003A5                 push    ecx
.text:000003A6                 mov     ecx, [ebp+var_4]
.text:000003A9                 add     ecx, 28h ; '('
.text:000003AC                 call    ??A?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAEAAUCAltStreamInfo@COutMultiVolStream@@I@Z ; CObjectVector<COutMultiVolStream::CAltStreamInfo>::operator[](uint)
.text:000003B1                 mov     edx, [eax]
.text:000003B3                 mov     [ebp+var_10], edx
.text:000003B6                 cmp     [ebp+var_10], 0
.text:000003BA                 jz      short loc_3D3
.text:000003BC                 mov     ecx, [ebp+var_10] ; this
.text:000003BF                 call    ?Close@COutFileStream@@QAEJXZ ; COutFileStream::Close(void)
.text:000003C4                 mov     [ebp+var_14], eax
.text:000003C7                 cmp     [ebp+var_14], 0
.text:000003CB                 jz      short loc_3D3
.text:000003CD                 mov     eax, [ebp+var_14]
.text:000003D0                 mov     [ebp+var_8], eax
.text:000003D3
.text:000003D3 loc_3D3:                                ; CODE XREF: COutMultiVolStream::Close(void)+5Ej
.text:000003D3                                         ; COutMultiVolStream::Close(void)+6Fj
.text:000003D3                 jmp     short loc_389
.text:000003D5 ; ---------------------------------------------------------------------------
.text:000003D5
.text:000003D5 loc_3D5:                                ; CODE XREF: COutMultiVolStream::Close(void)+44j
.text:000003D5                 mov     eax, [ebp+var_8]
.text:000003D8                 add     esp, 14h
.text:000003DB                 cmp     ebp, esp
.text:000003DD                 call    __RTC_CheckEsp
.text:000003E2                 mov     esp, ebp
.text:000003E4                 pop     ebp
.text:000003E5                 retn
.text:000003E5 ?Close@COutMultiVolStream@@QAEJXZ endp
.text:000003E5
.text:000003E5 ; ---------------------------------------------------------------------------
.text:000003E6                 db 6 dup(0CCh)
.text:000003EC
.text:000003EC ; =============== S U B R O U T I N E =======================================
.text:000003EC
.text:000003EC ; Attributes: bp-based frame
.text:000003EC
.text:000003EC ; bool __thiscall COutMultiVolStream::SetMTime(COutMultiVolStream *this, const struct _FILETIME *)
.text:000003EC                 public ?SetMTime@COutMultiVolStream@@QAE_NPBU_FILETIME@@@Z
.text:000003EC ?SetMTime@COutMultiVolStream@@QAE_NPBU_FILETIME@@@Z proc near
.text:000003EC                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+1A59p
.text:000003EC
.text:000003EC var_10          = dword ptr -10h
.text:000003EC var_C           = dword ptr -0Ch
.text:000003EC var_8           = dword ptr -8
.text:000003EC var_4           = dword ptr -4
.text:000003EC arg_0           = dword ptr  8
.text:000003EC
.text:000003EC                 push    ebp
.text:000003ED                 mov     ebp, esp
.text:000003EF                 sub     esp, 10h
.text:000003F2                 mov     eax, 0CCCCCCCCh
.text:000003F7                 mov     [ebp+var_10], eax
.text:000003FA                 mov     [ebp+var_C], eax
.text:000003FD                 mov     [ebp+var_8], eax
.text:00000400                 mov     [ebp+var_4], eax
.text:00000403                 mov     [ebp+var_4], ecx
.text:00000406                 mov     byte ptr [ebp+var_8+3], 1
.text:0000040A                 mov     [ebp+var_C], 0
.text:00000411                 jmp     short loc_41C
.text:00000413 ; ---------------------------------------------------------------------------
.text:00000413
.text:00000413 loc_413:                                ; CODE XREF: COutMultiVolStream::SetMTime(_FILETIME const *):loc_45Dj
.text:00000413                 mov     eax, [ebp+var_C]
.text:00000416                 add     eax, 1
.text:00000419                 mov     [ebp+var_C], eax
.text:0000041C
.text:0000041C loc_41C:                                ; CODE XREF: COutMultiVolStream::SetMTime(_FILETIME const *)+25j
.text:0000041C                 mov     ecx, [ebp+var_4]
.text:0000041F                 add     ecx, 28h ; '('
.text:00000422                 call    ?Size@?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QBEIXZ ; CObjectVector<COutMultiVolStream::CAltStreamInfo>::Size(void)
.text:00000427                 cmp     [ebp+var_C], eax
.text:0000042A                 jnb     short loc_45F
.text:0000042C                 mov     ecx, [ebp+var_C]
.text:0000042F                 push    ecx
.text:00000430                 mov     ecx, [ebp+var_4]
.text:00000433                 add     ecx, 28h ; '('
.text:00000436                 call    ??A?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAEAAUCAltStreamInfo@COutMultiVolStream@@I@Z ; CObjectVector<COutMultiVolStream::CAltStreamInfo>::operator[](uint)
.text:0000043B                 mov     edx, [eax]
.text:0000043D                 mov     [ebp+var_10], edx
.text:00000440                 cmp     [ebp+var_10], 0
.text:00000444                 jz      short loc_45D
.text:00000446                 mov     eax, [ebp+arg_0]
.text:00000449                 push    eax             ; struct _FILETIME *
.text:0000044A                 mov     ecx, [ebp+var_10] ; this
.text:0000044D                 call    ?SetMTime@COutFileStream@@QAE_NPBU_FILETIME@@@Z ; COutFileStream::SetMTime(_FILETIME const *)
.text:00000452                 movzx   ecx, al
.text:00000455                 test    ecx, ecx
.text:00000457                 jnz     short loc_45D
.text:00000459                 mov     byte ptr [ebp+var_8+3], 0
.text:0000045D
.text:0000045D loc_45D:                                ; CODE XREF: COutMultiVolStream::SetMTime(_FILETIME const *)+58j
.text:0000045D                                         ; COutMultiVolStream::SetMTime(_FILETIME const *)+6Bj
.text:0000045D                 jmp     short loc_413
.text:0000045F ; ---------------------------------------------------------------------------
.text:0000045F
.text:0000045F loc_45F:                                ; CODE XREF: COutMultiVolStream::SetMTime(_FILETIME const *)+3Ej
.text:0000045F                 mov     al, byte ptr [ebp+var_8+3]
.text:00000462                 add     esp, 10h
.text:00000465                 cmp     ebp, esp
.text:00000467                 call    __RTC_CheckEsp
.text:0000046C                 mov     esp, ebp
.text:0000046E                 pop     ebp
.text:0000046F                 retn    4
.text:0000046F ?SetMTime@COutMultiVolStream@@QAE_NPBU_FILETIME@@@Z endp
.text:0000046F
.text:0000046F ; ---------------------------------------------------------------------------
.text:00000472                 db 0Ah dup(0CCh)
.text:0000047C
.text:0000047C ; =============== S U B R O U T I N E =======================================
.text:0000047C
.text:0000047C ; Attributes: bp-based frame
.text:0000047C
.text:0000047C ; __int32 __stdcall COutMultiVolStream::Write(COutMultiVolStream *this, const void *, unsigned int, unsigned int *)
.text:0000047C                 public ?Write@COutMultiVolStream@@UAGJPBXIPAI@Z
.text:0000047C ?Write@COutMultiVolStream@@UAGJPBXIPAI@Z proc near
.text:0000047C                                         ; DATA XREF: .rdata:000090F8o
.text:0000047C
.text:0000047C var_D0          = dword ptr -0D0h
.text:0000047C var_CC          = dword ptr -0CCh
.text:0000047C var_C8          = dword ptr -0C8h
.text:0000047C var_C4          = dword ptr -0C4h
.text:0000047C var_C0          = dword ptr -0C0h
.text:0000047C var_BC          = dword ptr -0BCh
.text:0000047C var_B8          = dword ptr -0B8h
.text:0000047C var_B4          = dword ptr -0B4h
.text:0000047C var_B0          = dword ptr -0B0h
.text:0000047C var_AC          = dword ptr -0ACh
.text:0000047C var_A8          = dword ptr -0A8h
.text:0000047C var_A4          = dword ptr -0A4h
.text:0000047C var_A0          = dword ptr -0A0h
.text:0000047C var_9C          = dword ptr -9Ch
.text:0000047C var_98          = dword ptr -98h
.text:0000047C var_90          = dword ptr -90h
.text:0000047C var_88          = dword ptr -88h
.text:0000047C var_84          = dword ptr -84h
.text:0000047C var_80          = dword ptr -80h
.text:0000047C var_7C          = dword ptr -7Ch
.text:0000047C var_78          = dword ptr -78h
.text:0000047C var_74          = dword ptr -74h
.text:0000047C var_6C          = byte ptr -6Ch
.text:0000047C var_58          = word ptr -58h
.text:0000047C var_30          = dword ptr -30h
.text:0000047C var_2C          = byte ptr -2Ch
.text:0000047C var_28          = byte ptr -28h
.text:0000047C var_18          = dword ptr -18h
.text:0000047C var_14          = dword ptr -14h
.text:0000047C var_10          = dword ptr -10h
.text:0000047C var_C           = dword ptr -0Ch
.text:0000047C var_4           = dword ptr -4
.text:0000047C this            = dword ptr  8
.text:0000047C arg_4           = dword ptr  0Ch
.text:0000047C arg_8           = dword ptr  10h
.text:0000047C arg_C           = dword ptr  14h
.text:0000047C
.text:0000047C                 push    ebp
.text:0000047D                 mov     ebp, esp
.text:0000047F                 sub     esp, 0D0h
.text:00000485                 push    esi
.text:00000486                 push    edi
.text:00000487                 lea     edi, [ebp+var_D0]
.text:0000048D                 mov     ecx, 34h ; '4'
.text:00000492                 mov     eax, 0CCCCCCCCh
.text:00000497                 rep stosd
.text:00000499                 mov     eax, dword ptr ds:___security_cookie
.text:0000049E                 xor     eax, ebp
.text:000004A0                 mov     [ebp+var_4], eax
.text:000004A3                 cmp     [ebp+arg_C], 0
.text:000004A7                 jz      short loc_4B2
.text:000004A9                 mov     eax, [ebp+arg_C]
.text:000004AC                 mov     dword ptr [eax], 0
.text:000004B2
.text:000004B2 loc_4B2:                                ; CODE XREF: COutMultiVolStream::Write(void const *,uint,uint *)+2Bj
.text:000004B2                                         ; COutMultiVolStream::Write(void const *,uint,uint *)+19Fj ...
.text:000004B2                 cmp     [ebp+arg_8], 0
.text:000004B6                 jbe     loc_969
.text:000004BC                 mov     ecx, [ebp+this]
.text:000004BF                 add     ecx, 28h ; '('
.text:000004C2                 call    ?Size@?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QBEIXZ ; CObjectVector<COutMultiVolStream::CAltStreamInfo>::Size(void)
.text:000004C7                 mov     ecx, [ebp+this]
.text:000004CA                 cmp     [ecx+8], eax
.text:000004CD                 jb      loc_620
.text:000004D3                 lea     ecx, [ebp+var_30] ; this
.text:000004D6                 call    ??0CAltStreamInfo@COutMultiVolStream@@QAE@XZ ; COutMultiVolStream::CAltStreamInfo::CAltStreamInfo(void)
.text:000004DB                 lea     edx, [ebp+var_58]
.text:000004DE                 push    edx             ; wchar_t *
.text:000004DF                 mov     eax, [ebp+this]
.text:000004E2                 mov     ecx, [eax+8]
.text:000004E5                 add     ecx, 1
.text:000004E8                 push    ecx             ; unsigned int
.text:000004E9                 call    ?ConvertUInt32ToString@@YGXIPA_W@Z ; ConvertUInt32ToString(uint,wchar_t *)
.text:000004EE                 lea     edx, [ebp+var_58]
.text:000004F1                 push    edx
.text:000004F2                 lea     ecx, [ebp+var_6C]
.text:000004F5                 call    ??0UString@@QAE@PB_W@Z ; UString::UString(wchar_t const *)
.text:000004FA
.text:000004FA loc_4FA:                                ; CODE XREF: COutMultiVolStream::Write(void const *,uint,uint *)+95j
.text:000004FA                 lea     ecx, [ebp+var_6C] ; this
.text:000004FD                 call    ?Len@UString@@QBEIXZ ; UString::Len(void)
.text:00000502                 cmp     eax, 3
.text:00000505                 jnb     short loc_513
.text:00000507                 push    30h ; '0'       ; wchar_t
.text:00000509                 lea     ecx, [ebp+var_6C] ; this
.text:0000050C                 call    ?InsertAtFront@UString@@QAEX_W@Z ; UString::InsertAtFront(wchar_t)
.text:00000511                 jmp     short loc_4FA
.text:00000513 ; ---------------------------------------------------------------------------
.text:00000513
.text:00000513 loc_513:                                ; CODE XREF: COutMultiVolStream::Write(void const *,uint,uint *)+89j
.text:00000513                 mov     eax, [ebp+this]
.text:00000516                 add     eax, 40h ; '@'
.text:00000519                 push    eax             ; struct UString *
.text:0000051A                 push    0               ; unsigned int
.text:0000051C                 lea     ecx, [ebp+var_6C] ; this
.text:0000051F                 call    ?Insert@UString@@QAEXIABV1@@Z ; UString::Insert(uint,UString const &)
.text:00000524                 push    20h ; ' '       ; unsigned int
.text:00000526                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0000052B                 add     esp, 4
.text:0000052E                 mov     [ebp+var_A0], eax
.text:00000534                 cmp     [ebp+var_A0], 0
.text:0000053B                 jz      short loc_550
.text:0000053D                 mov     ecx, [ebp+var_A0]
.text:00000543                 call    ??0COutFileStream@@QAE@XZ ; COutFileStream::COutFileStream(void)
.text:00000548                 mov     [ebp+var_A8], eax
.text:0000054E                 jmp     short loc_55A
.text:00000550 ; ---------------------------------------------------------------------------
.text:00000550
.text:00000550 loc_550:                                ; CODE XREF: COutMultiVolStream::Write(void const *,uint,uint *)+BFj
.text:00000550                 mov     [ebp+var_A8], 0
.text:0000055A
.text:0000055A loc_55A:                                ; CODE XREF: COutMultiVolStream::Write(void const *,uint,uint *)+D2j
.text:0000055A                 mov     ecx, [ebp+var_A8]
.text:00000560                 mov     [ebp+var_9C], ecx
.text:00000566                 mov     edx, [ebp+var_9C]
.text:0000056C                 mov     [ebp+var_30], edx
.text:0000056F                 mov     eax, [ebp+var_30]
.text:00000572                 push    eax
.text:00000573                 lea     ecx, [ebp+var_2C]
.text:00000576                 call    ??4?$CMyComPtr@UIOutStream@@@@QAEPAUIOutStream@@PAU1@@Z ; CMyComPtr<IOutStream>::operator=(IOutStream *)
.text:0000057B                 push    0               ; bool
.text:0000057D                 lea     ecx, [ebp+var_6C]
.text:00000580                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00000585                 push    eax             ; wchar_t *
.text:00000586                 mov     ecx, [ebp+var_30] ; this
.text:00000589                 call    ?Create@COutFileStream@@QAE_NPB_W_N@Z ; COutFileStream::Create(wchar_t const *,bool)
.text:0000058E                 movzx   ecx, al
.text:00000591                 test    ecx, ecx
.text:00000593                 jnz     short loc_5C5
.text:00000595                 mov     esi, esp
.text:00000597                 call    dword ptr ds:__imp__GetLastError@0 ; GetLastError()
.text:0000059D                 cmp     esi, esp
.text:0000059F                 call    __RTC_CheckEsp
.text:000005A4                 mov     [ebp+var_A4], eax
.text:000005AA                 lea     ecx, [ebp+var_6C] ; this
.text:000005AD                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000005B2                 lea     ecx, [ebp+var_30] ; this
.text:000005B5                 call    ??1CAltStreamInfo@COutMultiVolStream@@QAE@XZ ; COutMultiVolStream::CAltStreamInfo::~CAltStreamInfo(void)
.text:000005BA                 mov     eax, [ebp+var_A4]
.text:000005C0                 jmp     loc_96B
.text:000005C5 ; ---------------------------------------------------------------------------
.text:000005C5
.text:000005C5 loc_5C5:                                ; CODE XREF: COutMultiVolStream::Write(void const *,uint,uint *)+117j
.text:000005C5                 lea     edx, [ebp+var_6C]
.text:000005C8                 push    edx
.text:000005C9                 mov     eax, [ebp+this]
.text:000005CC                 mov     ecx, [eax+4Ch]
.text:000005CF                 call    ?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z ; CObjectVector<UString>::Add(UString const &)
.text:000005D4                 mov     [ebp+var_18], 0
.text:000005DB                 mov     [ebp+var_14], 0
.text:000005E2                 mov     [ebp+var_10], 0
.text:000005E9                 mov     [ebp+var_C], 0
.text:000005F0                 lea     ecx, [ebp+var_6C]
.text:000005F3                 push    ecx
.text:000005F4                 lea     ecx, [ebp+var_28]
.text:000005F7                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:000005FC                 lea     edx, [ebp+var_30]
.text:000005FF                 push    edx             ; struct COutMultiVolStream::CAltStreamInfo *
.text:00000600                 mov     ecx, [ebp+this]
.text:00000603                 add     ecx, 28h ; '('
.text:00000606                 call    ?Add@?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAEIABUCAltStreamInfo@COutMultiVolStream@@@Z ; CObjectVector<COutMultiVolStream::CAltStreamInfo>::Add(COutMultiVolStream::CAltStreamInfo const &)
.text:0000060B                 lea     ecx, [ebp+var_6C] ; this
.text:0000060E                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000613                 lea     ecx, [ebp+var_30] ; this
.text:00000616                 call    ??1CAltStreamInfo@COutMultiVolStream@@QAE@XZ ; COutMultiVolStream::CAltStreamInfo::~CAltStreamInfo(void)
.text:0000061B                 jmp     loc_4B2
.text:00000620 ; ---------------------------------------------------------------------------
.text:00000620
.text:00000620 loc_620:                                ; CODE XREF: COutMultiVolStream::Write(void const *,uint,uint *)+51j
.text:00000620                 mov     eax, [ebp+this]
.text:00000623                 mov     ecx, [eax+8]
.text:00000626                 push    ecx
.text:00000627                 mov     ecx, [ebp+this]
.text:0000062A                 add     ecx, 28h ; '('
.text:0000062D                 call    ??A?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAEAAUCAltStreamInfo@COutMultiVolStream@@I@Z ; CObjectVector<COutMultiVolStream::CAltStreamInfo>::operator[](uint)
.text:00000632                 mov     [ebp+var_74], eax
.text:00000635                 mov     edx, [ebp+this]
.text:00000638                 mov     eax, [edx+8]
.text:0000063B                 mov     [ebp+var_78], eax
.text:0000063E                 mov     ecx, [ebp+this]
.text:00000641                 add     ecx, 34h ; '4'
.text:00000644                 call    ?Size@?$CRecordVector@_K@@QBEIXZ ; CRecordVector<unsigned __int64>::Size(void)
.text:00000649                 cmp     [ebp+var_78], eax
.text:0000064C                 jb      short loc_65F
.text:0000064E                 mov     ecx, [ebp+this]
.text:00000651                 add     ecx, 34h ; '4'
.text:00000654                 call    ?Size@?$CRecordVector@_K@@QBEIXZ ; CRecordVector<unsigned __int64>::Size(void)
.text:00000659                 sub     eax, 1
.text:0000065C                 mov     [ebp+var_78], eax
.text:0000065F
.text:0000065F loc_65F:                                ; CODE XREF: COutMultiVolStream::Write(void const *,uint,uint *)+1D0j
.text:0000065F                 mov     ecx, [ebp+var_78]
.text:00000662                 push    ecx
.text:00000663                 mov     ecx, [ebp+this]
.text:00000666                 add     ecx, 34h ; '4'
.text:00000669                 call    ??A?$CRecordVector@_K@@QAEAA_KI@Z ; CRecordVector<unsigned __int64>::operator[](uint)
.text:0000066E                 mov     edx, [eax]
.text:00000670                 mov     [ebp+var_80], edx
.text:00000673                 mov     eax, [eax+4]
.text:00000676                 mov     [ebp+var_7C], eax
.text:00000679                 mov     ecx, [ebp+this]
.text:0000067C                 mov     [ebp+var_AC], ecx
.text:00000682                 mov     edx, [ebp+var_AC]
.text:00000688                 mov     eax, [edx+14h]
.text:0000068B                 cmp     eax, [ebp+var_7C]
.text:0000068E                 jb      short loc_6CC
.text:00000690                 ja      short loc_6A0
.text:00000692                 mov     ecx, [ebp+var_AC]
.text:00000698                 mov     edx, [ecx+10h]
.text:0000069B                 cmp     edx, [ebp+var_80]
.text:0000069E                 jb      short loc_6CC
.text:000006A0
.text:000006A0 loc_6A0:                                ; CODE XREF: COutMultiVolStream::Write(void const *,uint,uint *)+214j
.text:000006A0                 mov     eax, [ebp+this]
.text:000006A3                 mov     ecx, [eax+10h]
.text:000006A6                 sub     ecx, [ebp+var_80]
.text:000006A9                 mov     edx, [eax+14h]
.text:000006AC                 sbb     edx, [ebp+var_7C]
.text:000006AF                 mov     eax, [ebp+this]
.text:000006B2                 mov     [eax+10h], ecx
.text:000006B5                 mov     [eax+14h], edx
.text:000006B8                 mov     ecx, [ebp+this]
.text:000006BB                 mov     edx, [ecx+8]
.text:000006BE                 add     edx, 1
.text:000006C1                 mov     eax, [ebp+this]
.text:000006C4                 mov     [eax+8], edx
.text:000006C7                 jmp     loc_4B2
.text:000006CC ; ---------------------------------------------------------------------------
.text:000006CC
.text:000006CC loc_6CC:                                ; CODE XREF: COutMultiVolStream::Write(void const *,uint,uint *)+212j
.text:000006CC                                         ; COutMultiVolStream::Write(void const *,uint,uint *)+222j
.text:000006CC                 mov     ecx, [ebp+this]
.text:000006CF                 mov     edx, [ebp+var_74]
.text:000006D2                 mov     [ebp+var_B0], ecx
.text:000006D8                 mov     [ebp+var_B4], edx
.text:000006DE                 mov     eax, [ebp+var_B0]
.text:000006E4                 mov     ecx, [ebp+var_B4]
.text:000006EA                 mov     edx, [eax+10h]
.text:000006ED                 cmp     edx, [ecx+18h]
.text:000006F0                 jnz     short loc_706
.text:000006F2                 mov     eax, [ebp+var_B0]
.text:000006F8                 mov     ecx, [ebp+var_B4]
.text:000006FE                 mov     edx, [eax+14h]
.text:00000701                 cmp     edx, [ecx+1Ch]
.text:00000704                 jz      short loc_76F
.text:00000706
.text:00000706 loc_706:                                ; CODE XREF: COutMultiVolStream::Write(void const *,uint,uint *)+274j
.text:00000706                 mov     ecx, [ebp+var_74]
.text:00000709                 add     ecx, 4
.text:0000070C                 call    ??C?$CMyComPtr@UIOutStream@@@@QBEPAUIOutStream@@XZ ; CMyComPtr<IOutStream>::operator->(void)
.text:00000711                 mov     [ebp+var_B8], eax
.text:00000717                 mov     esi, esp
.text:00000719                 push    0
.text:0000071B                 push    0
.text:0000071D                 mov     eax, [ebp+this]
.text:00000720                 mov     ecx, [eax+14h]
.text:00000723                 push    ecx
.text:00000724                 mov     edx, [eax+10h]
.text:00000727                 push    edx
.text:00000728                 mov     eax, [ebp+var_B8]
.text:0000072E                 push    eax
.text:0000072F                 mov     ecx, [ebp+var_B8]
.text:00000735                 mov     edx, [ecx]
.text:00000737                 mov     eax, [edx+10h]
.text:0000073A                 call    eax
.text:0000073C                 cmp     esi, esp
.text:0000073E                 call    __RTC_CheckEsp
.text:00000743                 mov     [ebp+var_84], eax
.text:00000749                 cmp     [ebp+var_84], 0
.text:00000750                 jz      short loc_75D
.text:00000752                 mov     eax, [ebp+var_84]
.text:00000758                 jmp     loc_96B
.text:0000075D ; ---------------------------------------------------------------------------
.text:0000075D
.text:0000075D loc_75D:                                ; CODE XREF: COutMultiVolStream::Write(void const *,uint,uint *)+2D4j
.text:0000075D                 mov     ecx, [ebp+var_74]
.text:00000760                 mov     edx, [ebp+this]
.text:00000763                 mov     eax, [edx+10h]
.text:00000766                 mov     [ecx+18h], eax
.text:00000769                 mov     edx, [edx+14h]
.text:0000076C                 mov     [ecx+1Ch], edx
.text:0000076F
.text:0000076F loc_76F:                                ; CODE XREF: COutMultiVolStream::Write(void const *,uint,uint *)+288j
.text:0000076F                 mov     eax, [ebp+var_74]
.text:00000772                 mov     ecx, [ebp+var_80]
.text:00000775                 sub     ecx, [eax+18h]
.text:00000778                 mov     edx, [ebp+var_7C]
.text:0000077B                 sbb     edx, [eax+1Ch]
.text:0000077E                 push    edx
.text:0000077F                 push    ecx
.text:00000780                 mov     eax, [ebp+arg_8]
.text:00000783                 xor     ecx, ecx
.text:00000785                 push    ecx
.text:00000786                 push    eax
.text:00000787                 call    ??$MyMin@_K@@YG_K_K0@Z ; MyMin<unsigned __int64>(unsigned __int64,unsigned __int64)
.text:0000078C                 mov     [ebp+var_88], eax
.text:00000792                 mov     ecx, [ebp+var_74]
.text:00000795                 add     ecx, 4
.text:00000798                 call    ??C?$CMyComPtr@UIOutStream@@@@QBEPAUIOutStream@@XZ ; CMyComPtr<IOutStream>::operator->(void)
.text:0000079D                 mov     [ebp+var_BC], eax
.text:000007A3                 mov     esi, esp
.text:000007A5                 lea     edx, [ebp+var_90]
.text:000007AB                 push    edx
.text:000007AC                 mov     eax, [ebp+var_88]
.text:000007B2                 push    eax
.text:000007B3                 mov     ecx, [ebp+arg_4]
.text:000007B6                 push    ecx
.text:000007B7                 mov     edx, [ebp+var_BC]
.text:000007BD                 push    edx
.text:000007BE                 mov     eax, [ebp+var_BC]
.text:000007C4                 mov     ecx, [eax]
.text:000007C6                 mov     edx, [ecx+0Ch]
.text:000007C9                 call    edx
.text:000007CB                 cmp     esi, esp
.text:000007CD                 call    __RTC_CheckEsp
.text:000007D2                 mov     [ebp+var_98], eax
.text:000007D8                 cmp     [ebp+var_98], 0
.text:000007DF                 jz      short loc_7EC
.text:000007E1                 mov     eax, [ebp+var_98]
.text:000007E7                 jmp     loc_96B
.text:000007EC ; ---------------------------------------------------------------------------
.text:000007EC
.text:000007EC loc_7EC:                                ; CODE XREF: COutMultiVolStream::Write(void const *,uint,uint *)+363j
.text:000007EC                 mov     eax, [ebp+arg_4]
.text:000007EF                 add     eax, [ebp+var_90]
.text:000007F5                 mov     [ebp+arg_4], eax
.text:000007F8                 mov     ecx, [ebp+arg_8]
.text:000007FB                 sub     ecx, [ebp+var_90]
.text:00000801                 mov     [ebp+arg_8], ecx
.text:00000804                 mov     edx, [ebp+var_90]
.text:0000080A                 xor     eax, eax
.text:0000080C                 mov     ecx, [ebp+var_74]
.text:0000080F                 add     edx, [ecx+18h]
.text:00000812                 adc     eax, [ecx+1Ch]
.text:00000815                 mov     ecx, [ebp+var_74]
.text:00000818                 mov     [ecx+18h], edx
.text:0000081B                 mov     [ecx+1Ch], eax
.text:0000081E                 mov     edx, [ebp+var_90]
.text:00000824                 xor     eax, eax
.text:00000826                 mov     ecx, [ebp+this]
.text:00000829                 add     edx, [ecx+10h]
.text:0000082C                 adc     eax, [ecx+14h]
.text:0000082F                 mov     ecx, [ebp+this]
.text:00000832                 mov     [ecx+10h], edx
.text:00000835                 mov     [ecx+14h], eax
.text:00000838                 mov     edx, [ebp+var_90]
.text:0000083E                 xor     eax, eax
.text:00000840                 mov     ecx, [ebp+this]
.text:00000843                 add     edx, [ecx+18h]
.text:00000846                 adc     eax, [ecx+1Ch]
.text:00000849                 mov     ecx, [ebp+this]
.text:0000084C                 mov     [ecx+18h], edx
.text:0000084F                 mov     [ecx+1Ch], eax
.text:00000852                 mov     edx, [ebp+this]
.text:00000855                 mov     eax, [ebp+this]
.text:00000858                 mov     [ebp+var_C0], edx
.text:0000085E                 mov     [ebp+var_C4], eax
.text:00000864                 mov     ecx, [ebp+var_C0]
.text:0000086A                 mov     edx, [ebp+var_C4]
.text:00000870                 mov     eax, [ecx+1Ch]
.text:00000873                 cmp     eax, [edx+24h]
.text:00000876                 jb      short loc_8A0
.text:00000878                 ja      short loc_88E
.text:0000087A                 mov     ecx, [ebp+var_C0]
.text:00000880                 mov     edx, [ebp+var_C4]
.text:00000886                 mov     eax, [ecx+18h]
.text:00000889                 cmp     eax, [edx+20h]
.text:0000088C                 jbe     short loc_8A0
.text:0000088E
.text:0000088E loc_88E:                                ; CODE XREF: COutMultiVolStream::Write(void const *,uint,uint *)+3FCj
.text:0000088E                 mov     ecx, [ebp+this]
.text:00000891                 mov     edx, [ebp+this]
.text:00000894                 mov     eax, [edx+18h]
.text:00000897                 mov     [ecx+20h], eax
.text:0000089A                 mov     edx, [edx+1Ch]
.text:0000089D                 mov     [ecx+24h], edx
.text:000008A0
.text:000008A0 loc_8A0:                                ; CODE XREF: COutMultiVolStream::Write(void const *,uint,uint *)+3FAj
.text:000008A0                                         ; COutMultiVolStream::Write(void const *,uint,uint *)+410j
.text:000008A0                 mov     eax, [ebp+this]
.text:000008A3                 mov     ecx, [ebp+var_74]
.text:000008A6                 mov     [ebp+var_C8], eax
.text:000008AC                 mov     [ebp+var_CC], ecx
.text:000008B2                 mov     edx, [ebp+var_C8]
.text:000008B8                 mov     eax, [ebp+var_CC]
.text:000008BE                 mov     ecx, [edx+14h]
.text:000008C1                 cmp     ecx, [eax+24h]
.text:000008C4                 jb      short loc_8EE
.text:000008C6                 ja      short loc_8DC
.text:000008C8                 mov     edx, [ebp+var_C8]
.text:000008CE                 mov     eax, [ebp+var_CC]
.text:000008D4                 mov     ecx, [edx+10h]
.text:000008D7                 cmp     ecx, [eax+20h]
.text:000008DA                 jbe     short loc_8EE
.text:000008DC
.text:000008DC loc_8DC:                                ; CODE XREF: COutMultiVolStream::Write(void const *,uint,uint *)+44Aj
.text:000008DC                 mov     edx, [ebp+var_74]
.text:000008DF                 mov     eax, [ebp+this]
.text:000008E2                 mov     ecx, [eax+10h]
.text:000008E5                 mov     [edx+20h], ecx
.text:000008E8                 mov     eax, [eax+14h]
.text:000008EB                 mov     [edx+24h], eax
.text:000008EE
.text:000008EE loc_8EE:                                ; CODE XREF: COutMultiVolStream::Write(void const *,uint,uint *)+448j
.text:000008EE                                         ; COutMultiVolStream::Write(void const *,uint,uint *)+45Ej
.text:000008EE                 cmp     [ebp+arg_C], 0
.text:000008F2                 jz      short loc_904
.text:000008F4                 mov     ecx, [ebp+arg_C]
.text:000008F7                 mov     edx, [ecx]
.text:000008F9                 add     edx, [ebp+var_90]
.text:000008FF                 mov     eax, [ebp+arg_C]
.text:00000902                 mov     [eax], edx
.text:00000904
.text:00000904 loc_904:                                ; CODE XREF: COutMultiVolStream::Write(void const *,uint,uint *)+476j
.text:00000904                 mov     ecx, [ebp+var_74]
.text:00000907                 mov     [ebp+var_D0], ecx
.text:0000090D                 mov     edx, [ebp+var_D0]
.text:00000913                 mov     eax, [edx+18h]
.text:00000916                 cmp     eax, [ebp+var_80]
.text:00000919                 jnz     short loc_949
.text:0000091B                 mov     ecx, [ebp+var_D0]
.text:00000921                 mov     edx, [ecx+1Ch]
.text:00000924                 cmp     edx, [ebp+var_7C]
.text:00000927                 jnz     short loc_949
.text:00000929                 mov     eax, [ebp+this]
.text:0000092C                 mov     ecx, [eax+8]
.text:0000092F                 add     ecx, 1
.text:00000932                 mov     edx, [ebp+this]
.text:00000935                 mov     [edx+8], ecx
.text:00000938                 mov     eax, [ebp+this]
.text:0000093B                 mov     dword ptr [eax+10h], 0
.text:00000942                 mov     dword ptr [eax+14h], 0
.text:00000949
.text:00000949 loc_949:                                ; CODE XREF: COutMultiVolStream::Write(void const *,uint,uint *)+49Dj
.text:00000949                                         ; COutMultiVolStream::Write(void const *,uint,uint *)+4ABj
.text:00000949                 cmp     [ebp+var_90], 0
.text:00000950                 jnz     short loc_962
.text:00000952                 cmp     [ebp+var_88], 0
.text:00000959                 jz      short loc_962
.text:0000095B                 mov     eax, 80004005h
.text:00000960                 jmp     short loc_96B
.text:00000962 ; ---------------------------------------------------------------------------
.text:00000962
.text:00000962 loc_962:                                ; CODE XREF: COutMultiVolStream::Write(void const *,uint,uint *)+4D4j
.text:00000962                                         ; COutMultiVolStream::Write(void const *,uint,uint *)+4DDj
.text:00000962                 jmp     short loc_969
.text:00000964 ; ---------------------------------------------------------------------------
.text:00000964                 jmp     loc_4B2
.text:00000969 ; ---------------------------------------------------------------------------
.text:00000969
.text:00000969 loc_969:                                ; CODE XREF: COutMultiVolStream::Write(void const *,uint,uint *)+3Aj
.text:00000969                                         ; COutMultiVolStream::Write(void const *,uint,uint *):loc_962j
.text:00000969                 xor     eax, eax
.text:0000096B
.text:0000096B loc_96B:                                ; CODE XREF: COutMultiVolStream::Write(void const *,uint,uint *)+144j
.text:0000096B                                         ; COutMultiVolStream::Write(void const *,uint,uint *)+2DCj ...
.text:0000096B                 push    edx
.text:0000096C                 mov     ecx, ebp
.text:0000096E                 push    eax
.text:0000096F                 lea     edx, $LN32
.text:00000975                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:0000097A                 pop     eax
.text:0000097B                 pop     edx
.text:0000097C                 pop     edi
.text:0000097D                 pop     esi
.text:0000097E                 mov     ecx, [ebp+var_4]
.text:00000981                 xor     ecx, ebp
.text:00000983                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text:00000988                 add     esp, 0D0h
.text:0000098E                 cmp     ebp, esp
.text:00000990                 call    __RTC_CheckEsp
.text:00000995                 mov     esp, ebp
.text:00000997                 pop     ebp
.text:00000998                 retn    10h
.text:00000998 ?Write@COutMultiVolStream@@UAGJPBXIPAI@Z endp
.text:00000998
.text:00000998 ; ---------------------------------------------------------------------------
.text:0000099B                 align 4
.text:0000099C $LN32           dd 4                    ; DATA XREF: COutMultiVolStream::Write(void const *,uint,uint *)+4F3o
.text:000009A0                 dd offset $LN31
.text:000009A4 $LN31           dd 0FFFFFFD0h, 28h      ; DATA XREF: .text:000009A0o
.text:000009AC                 dd offset $LN27         ; "altStream"
.text:000009B0                 dd 0FFFFFFA8h, 20h
.text:000009B8                 dd offset $LN28         ; "temp"
.text:000009BC                 dd 0FFFFFF94h, 0Ch
.text:000009C4                 dd offset $LN29         ; "name"
.text:000009C8                 dd 0FFFFFF70h, 4
.text:000009D0                 dd offset $LN30         ; "realProcessed"
.text:000009D4 $LN30           db 'realProcessed',0    ; DATA XREF: .text:000009D0o
.text:000009E2 $LN29           db 'name',0             ; DATA XREF: .text:000009C4o
.text:000009E7 $LN28           db 'temp',0             ; DATA XREF: .text:000009B8o
.text:000009EC $LN27           db 'altStream',0        ; DATA XREF: .text:000009ACo
.text:000009F6                 db 6 dup(0CCh)
.text:000009FC
.text:000009FC ; =============== S U B R O U T I N E =======================================
.text:000009FC
.text:000009FC ; Attributes: bp-based frame
.text:000009FC
.text:000009FC ; __int32 __stdcall COutMultiVolStream::Seek(COutMultiVolStream *this, __int64, unsigned int, unsigned __int64 *)
.text:000009FC                 public ?Seek@COutMultiVolStream@@UAGJ_JIPA_K@Z
.text:000009FC ?Seek@COutMultiVolStream@@UAGJ_JIPA_K@Z proc near
.text:000009FC                                         ; DATA XREF: .rdata:000090FCo
.text:000009FC
.text:000009FC var_4           = dword ptr -4
.text:000009FC this            = dword ptr  8
.text:000009FC arg_4           = qword ptr  0Ch
.text:000009FC arg_C           = dword ptr  14h
.text:000009FC arg_10          = dword ptr  18h
.text:000009FC
.text:000009FC                 push    ebp
.text:000009FD                 mov     ebp, esp
.text:000009FF                 push    ecx
.text:00000A00                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000A07                 cmp     [ebp+arg_C], 3
.text:00000A0B                 jb      short loc_A17
.text:00000A0D                 mov     eax, 80030001h
.text:00000A12                 jmp     loc_AA9
.text:00000A17 ; ---------------------------------------------------------------------------
.text:00000A17
.text:00000A17 loc_A17:                                ; CODE XREF: COutMultiVolStream::Seek(__int64,uint,unsigned __int64 *)+Fj
.text:00000A17                 mov     eax, [ebp+arg_C]
.text:00000A1A                 mov     [ebp+var_4], eax
.text:00000A1D                 cmp     [ebp+var_4], 0
.text:00000A21                 jz      short loc_A31
.text:00000A23                 cmp     [ebp+var_4], 1
.text:00000A27                 jz      short loc_A42
.text:00000A29                 cmp     [ebp+var_4], 2
.text:00000A2D                 jz      short loc_A5C
.text:00000A2F                 jmp     short loc_A74
.text:00000A31 ; ---------------------------------------------------------------------------
.text:00000A31
.text:00000A31 loc_A31:                                ; CODE XREF: COutMultiVolStream::Seek(__int64,uint,unsigned __int64 *)+25j
.text:00000A31                 mov     ecx, [ebp+this]
.text:00000A34                 mov     edx, dword ptr [ebp+arg_4]
.text:00000A37                 mov     [ecx+18h], edx
.text:00000A3A                 mov     eax, dword ptr [ebp+arg_4+4]
.text:00000A3D                 mov     [ecx+1Ch], eax
.text:00000A40                 jmp     short loc_A74
.text:00000A42 ; ---------------------------------------------------------------------------
.text:00000A42
.text:00000A42 loc_A42:                                ; CODE XREF: COutMultiVolStream::Seek(__int64,uint,unsigned __int64 *)+2Bj
.text:00000A42                 mov     ecx, [ebp+this]
.text:00000A45                 mov     edx, [ecx+18h]
.text:00000A48                 add     edx, dword ptr [ebp+arg_4]
.text:00000A4B                 mov     eax, [ecx+1Ch]
.text:00000A4E                 adc     eax, dword ptr [ebp+arg_4+4]
.text:00000A51                 mov     ecx, [ebp+this]
.text:00000A54                 mov     [ecx+18h], edx
.text:00000A57                 mov     [ecx+1Ch], eax
.text:00000A5A                 jmp     short loc_A74
.text:00000A5C ; ---------------------------------------------------------------------------
.text:00000A5C
.text:00000A5C loc_A5C:                                ; CODE XREF: COutMultiVolStream::Seek(__int64,uint,unsigned __int64 *)+31j
.text:00000A5C                 mov     edx, [ebp+this]
.text:00000A5F                 mov     eax, [edx+20h]
.text:00000A62                 add     eax, dword ptr [ebp+arg_4]
.text:00000A65                 mov     ecx, [edx+24h]
.text:00000A68                 adc     ecx, dword ptr [ebp+arg_4+4]
.text:00000A6B                 mov     edx, [ebp+this]
.text:00000A6E                 mov     [edx+18h], eax
.text:00000A71                 mov     [edx+1Ch], ecx
.text:00000A74
.text:00000A74 loc_A74:                                ; CODE XREF: COutMultiVolStream::Seek(__int64,uint,unsigned __int64 *)+33j
.text:00000A74                                         ; COutMultiVolStream::Seek(__int64,uint,unsigned __int64 *)+44j ...
.text:00000A74                 mov     eax, [ebp+this]
.text:00000A77                 mov     ecx, [ebp+this]
.text:00000A7A                 mov     edx, [ecx+18h]
.text:00000A7D                 mov     [eax+10h], edx
.text:00000A80                 mov     ecx, [ecx+1Ch]
.text:00000A83                 mov     [eax+14h], ecx
.text:00000A86                 cmp     [ebp+arg_10], 0
.text:00000A8A                 jz      short loc_A9D
.text:00000A8C                 mov     edx, [ebp+arg_10]
.text:00000A8F                 mov     eax, [ebp+this]
.text:00000A92                 mov     ecx, [eax+18h]
.text:00000A95                 mov     [edx], ecx
.text:00000A97                 mov     eax, [eax+1Ch]
.text:00000A9A                 mov     [edx+4], eax
.text:00000A9D
.text:00000A9D loc_A9D:                                ; CODE XREF: COutMultiVolStream::Seek(__int64,uint,unsigned __int64 *)+8Ej
.text:00000A9D                 mov     ecx, [ebp+this]
.text:00000AA0                 mov     dword ptr [ecx+8], 0
.text:00000AA7                 xor     eax, eax
.text:00000AA9
.text:00000AA9 loc_AA9:                                ; CODE XREF: COutMultiVolStream::Seek(__int64,uint,unsigned __int64 *)+16j
.text:00000AA9                 mov     esp, ebp
.text:00000AAB                 pop     ebp
.text:00000AAC                 retn    14h
.text:00000AAC ?Seek@COutMultiVolStream@@UAGJ_JIPA_K@Z endp
.text:00000AAC
.text:00000AAC ; ---------------------------------------------------------------------------
.text:00000AAF                 db 0Dh dup(0CCh)
.text:00000ABC
.text:00000ABC ; =============== S U B R O U T I N E =======================================
.text:00000ABC
.text:00000ABC ; Attributes: bp-based frame
.text:00000ABC
.text:00000ABC ; __int32 COutMultiVolStream::SetSize(COutMultiVolStream *__hidden this, unsigned __int64)
.text:00000ABC                 public ?SetSize@COutMultiVolStream@@UAGJ_K@Z
.text:00000ABC ?SetSize@COutMultiVolStream@@UAGJ_K@Z proc near ; DATA XREF: .rdata:00009100o
.text:00000ABC
.text:00000ABC var_1C          = dword ptr -1Ch
.text:00000ABC var_18          = dword ptr -18h
.text:00000ABC var_14          = dword ptr -14h
.text:00000ABC var_10          = dword ptr -10h
.text:00000ABC var_C           = dword ptr -0Ch
.text:00000ABC var_8           = dword ptr -8
.text:00000ABC var_4           = dword ptr -4
.text:00000ABC this            = dword ptr  8
.text:00000ABC arg_4           = qword ptr  0Ch
.text:00000ABC
.text:00000ABC                 push    ebp
.text:00000ABD                 mov     ebp, esp
.text:00000ABF                 sub     esp, 1Ch
.text:00000AC2                 push    esi             ; wchar_t *
.text:00000AC3                 mov     eax, 0CCCCCCCCh
.text:00000AC8                 mov     [ebp+var_1C], eax
.text:00000ACB                 mov     [ebp+var_18], eax
.text:00000ACE                 mov     [ebp+var_14], eax
.text:00000AD1                 mov     [ebp+var_10], eax
.text:00000AD4                 mov     [ebp+var_C], eax
.text:00000AD7                 mov     [ebp+var_8], eax
.text:00000ADA                 mov     [ebp+var_4], eax
.text:00000ADD                 cmp     dword ptr [ebp+arg_4+4], 0
.text:00000AE1                 ja      short loc_AF5
.text:00000AE3                 jb      short loc_AEB
.text:00000AE5                 cmp     dword ptr [ebp+arg_4], 0
.text:00000AE9                 jnb     short loc_AF5
.text:00000AEB
.text:00000AEB loc_AEB:                                ; CODE XREF: COutMultiVolStream::SetSize(unsigned __int64)+27j
.text:00000AEB                 mov     eax, 80070057h
.text:00000AF0                 jmp     loc_C2C
.text:00000AF5 ; ---------------------------------------------------------------------------
.text:00000AF5
.text:00000AF5 loc_AF5:                                ; CODE XREF: COutMultiVolStream::SetSize(unsigned __int64)+25j
.text:00000AF5                                         ; COutMultiVolStream::SetSize(unsigned __int64)+2Dj
.text:00000AF5                 mov     [ebp+var_4], 0
.text:00000AFC
.text:00000AFC loc_AFC:                                ; CODE XREF: COutMultiVolStream::SetSize(unsigned __int64)+F7j
.text:00000AFC                 mov     ecx, [ebp+this]
.text:00000AFF                 add     ecx, 28h ; '('
.text:00000B02                 call    ?Size@?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QBEIXZ ; CObjectVector<COutMultiVolStream::CAltStreamInfo>::Size(void)
.text:00000B07                 cmp     [ebp+var_4], eax
.text:00000B0A                 jnb     loc_BB8
.text:00000B10                 mov     eax, [ebp+var_4]
.text:00000B13                 mov     [ebp+var_14], eax
.text:00000B16                 mov     ecx, [ebp+var_4]
.text:00000B19                 add     ecx, 1
.text:00000B1C                 mov     [ebp+var_4], ecx
.text:00000B1F                 mov     edx, [ebp+var_14]
.text:00000B22                 push    edx
.text:00000B23                 mov     ecx, [ebp+this]
.text:00000B26                 add     ecx, 28h ; '('
.text:00000B29                 call    ??A?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAEAAUCAltStreamInfo@COutMultiVolStream@@I@Z ; CObjectVector<COutMultiVolStream::CAltStreamInfo>::operator[](uint)
.text:00000B2E                 mov     [ebp+var_8], eax
.text:00000B31                 mov     eax, [ebp+var_8]
.text:00000B34                 mov     [ebp+var_18], eax
.text:00000B37                 mov     ecx, [ebp+var_18]
.text:00000B3A                 mov     edx, dword ptr [ebp+arg_4+4]
.text:00000B3D                 cmp     edx, [ecx+24h]
.text:00000B40                 ja      short loc_B9E
.text:00000B42                 jb      short loc_B4F
.text:00000B44                 mov     eax, [ebp+var_18]
.text:00000B47                 mov     ecx, dword ptr [ebp+arg_4]
.text:00000B4A                 cmp     ecx, [eax+20h]
.text:00000B4D                 jnb     short loc_B9E
.text:00000B4F
.text:00000B4F loc_B4F:                                ; CODE XREF: COutMultiVolStream::SetSize(unsigned __int64)+86j
.text:00000B4F                 mov     ecx, [ebp+var_8]
.text:00000B52                 add     ecx, 4
.text:00000B55                 call    ??C?$CMyComPtr@UIOutStream@@@@QBEPAUIOutStream@@XZ ; CMyComPtr<IOutStream>::operator->(void)
.text:00000B5A                 mov     [ebp+var_1C], eax
.text:00000B5D                 mov     esi, esp
.text:00000B5F                 mov     edx, dword ptr [ebp+arg_4+4]
.text:00000B62                 push    edx
.text:00000B63                 mov     eax, dword ptr [ebp+arg_4]
.text:00000B66                 push    eax
.text:00000B67                 mov     ecx, [ebp+var_1C]
.text:00000B6A                 push    ecx
.text:00000B6B                 mov     edx, [ebp+var_1C]
.text:00000B6E                 mov     eax, [edx]
.text:00000B70                 mov     ecx, [eax+14h]
.text:00000B73                 call    ecx
.text:00000B75                 cmp     esi, esp
.text:00000B77                 call    __RTC_CheckEsp
.text:00000B7C                 mov     [ebp+var_C], eax
.text:00000B7F                 cmp     [ebp+var_C], 0
.text:00000B83                 jz      short loc_B8D
.text:00000B85                 mov     eax, [ebp+var_C]
.text:00000B88                 jmp     loc_C2C
.text:00000B8D ; ---------------------------------------------------------------------------
.text:00000B8D
.text:00000B8D loc_B8D:                                ; CODE XREF: COutMultiVolStream::SetSize(unsigned __int64)+C7j
.text:00000B8D                 mov     edx, [ebp+var_8]
.text:00000B90                 mov     eax, dword ptr [ebp+arg_4]
.text:00000B93                 mov     [edx+20h], eax
.text:00000B96                 mov     ecx, dword ptr [ebp+arg_4+4]
.text:00000B99                 mov     [edx+24h], ecx
.text:00000B9C                 jmp     short loc_BB8
.text:00000B9E ; ---------------------------------------------------------------------------
.text:00000B9E
.text:00000B9E loc_B9E:                                ; CODE XREF: COutMultiVolStream::SetSize(unsigned __int64)+84j
.text:00000B9E                                         ; COutMultiVolStream::SetSize(unsigned __int64)+91j
.text:00000B9E                 mov     edx, [ebp+var_8]
.text:00000BA1                 mov     eax, dword ptr [ebp+arg_4]
.text:00000BA4                 sub     eax, [edx+20h]
.text:00000BA7                 mov     ecx, dword ptr [ebp+arg_4+4]
.text:00000BAA                 sbb     ecx, [edx+24h]
.text:00000BAD                 mov     dword ptr [ebp+arg_4], eax
.text:00000BB0                 mov     dword ptr [ebp+arg_4+4], ecx
.text:00000BB3                 jmp     loc_AFC
.text:00000BB8 ; ---------------------------------------------------------------------------
.text:00000BB8
.text:00000BB8 loc_BB8:                                ; CODE XREF: COutMultiVolStream::SetSize(unsigned __int64)+4Ej
.text:00000BB8                                         ; COutMultiVolStream::SetSize(unsigned __int64)+E0j ...
.text:00000BB8                 mov     ecx, [ebp+this]
.text:00000BBB                 add     ecx, 28h ; '('
.text:00000BBE                 call    ?Size@?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QBEIXZ ; CObjectVector<COutMultiVolStream::CAltStreamInfo>::Size(void)
.text:00000BC3                 cmp     [ebp+var_4], eax
.text:00000BC6                 jnb     short loc_BFF
.text:00000BC8                 mov     ecx, [ebp+this]
.text:00000BCB                 add     ecx, 28h ; '('
.text:00000BCE                 call    ?Back@?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAEAAUCAltStreamInfo@COutMultiVolStream@@XZ ; CObjectVector<COutMultiVolStream::CAltStreamInfo>::Back(void)
.text:00000BD3                 mov     [ebp+var_10], eax
.text:00000BD6                 mov     ecx, [ebp+var_10]
.text:00000BD9                 add     ecx, 4
.text:00000BDC                 call    ?Release@?$CMyComPtr@UIOutStream@@@@QAEXXZ ; CMyComPtr<IOutStream>::Release(void)
.text:00000BE1                 mov     ecx, [ebp+var_10]
.text:00000BE4                 add     ecx, 8
.text:00000BE7                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00000BEC                 push    eax             ; this
.text:00000BED                 call    ?DeleteFileAlways@NDir@NFile@NWindows@@YG_NPB_W@Z ; NWindows::NFile::NDir::DeleteFileAlways(wchar_t const *)
.text:00000BF2                 mov     ecx, [ebp+this]
.text:00000BF5                 add     ecx, 28h ; '('
.text:00000BF8                 call    ?DeleteBack@?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAEXXZ ; CObjectVector<COutMultiVolStream::CAltStreamInfo>::DeleteBack(void)
.text:00000BFD                 jmp     short loc_BB8
.text:00000BFF ; ---------------------------------------------------------------------------
.text:00000BFF
.text:00000BFF loc_BFF:                                ; CODE XREF: COutMultiVolStream::SetSize(unsigned __int64)+10Aj
.text:00000BFF                 mov     edx, [ebp+this]
.text:00000C02                 mov     eax, [ebp+this]
.text:00000C05                 mov     ecx, [eax+18h]
.text:00000C08                 mov     [edx+10h], ecx
.text:00000C0B                 mov     eax, [eax+1Ch]
.text:00000C0E                 mov     [edx+14h], eax
.text:00000C11                 mov     ecx, [ebp+this]
.text:00000C14                 mov     dword ptr [ecx+8], 0
.text:00000C1B                 mov     edx, [ebp+this]
.text:00000C1E                 mov     eax, dword ptr [ebp+arg_4]
.text:00000C21                 mov     [edx+20h], eax
.text:00000C24                 mov     ecx, dword ptr [ebp+arg_4+4]
.text:00000C27                 mov     [edx+24h], ecx
.text:00000C2A                 xor     eax, eax
.text:00000C2C
.text:00000C2C loc_C2C:                                ; CODE XREF: COutMultiVolStream::SetSize(unsigned __int64)+34j
.text:00000C2C                                         ; COutMultiVolStream::SetSize(unsigned __int64)+CCj
.text:00000C2C                 pop     esi
.text:00000C2D                 add     esp, 1Ch
.text:00000C30                 cmp     ebp, esp
.text:00000C32                 call    __RTC_CheckEsp
.text:00000C37                 mov     esp, ebp
.text:00000C39                 pop     ebp
.text:00000C3A                 retn    0Ch
.text:00000C3A ?SetSize@COutMultiVolStream@@UAGJ_K@Z endp ; sp-analysis failed
.text:00000C3A
.text:00000C3A ; ---------------------------------------------------------------------------
.text:00000C3D                 db 0Fh dup(0CCh)
.text:00000C4C
.text:00000C4C ; =============== S U B R O U T I N E =======================================
.text:00000C4C
.text:00000C4C ; Attributes: bp-based frame
.text:00000C4C
.text:00000C4C ; public: void __thiscall CArchivePath::ParseFromPath(class UString const &, enum  EArcNameMode)
.text:00000C4C                 public ?ParseFromPath@CArchivePath@@QAEXABVUString@@W4EArcNameMode@@@Z
.text:00000C4C ?ParseFromPath@CArchivePath@@QAEXABVUString@@W4EArcNameMode@@@Z proc near
.text:00000C4C                                         ; CODE XREF: CUpdateOptions::SetArcPath(CCodecs const *,UString const &)+130p
.text:00000C4C                                         ; CUpdateOptions::SetArcPath(CCodecs const *,UString const &)+19Bp
.text:00000C4C
.text:00000C4C var_28          = dword ptr -28h
.text:00000C4C var_24          = dword ptr -24h
.text:00000C4C var_20          = dword ptr -20h
.text:00000C4C var_1C          = dword ptr -1Ch
.text:00000C4C var_18          = dword ptr -18h
.text:00000C4C var_14          = dword ptr -14h
.text:00000C4C var_10          = dword ptr -10h
.text:00000C4C var_C           = dword ptr -0Ch
.text:00000C4C var_4           = dword ptr -4
.text:00000C4C arg_0           = dword ptr  8
.text:00000C4C arg_4           = dword ptr  0Ch
.text:00000C4C
.text:00000C4C                 push    ebp
.text:00000C4D                 mov     ebp, esp
.text:00000C4F                 push    0FFFFFFFFh
.text:00000C51                 push    offset __ehhandler$?ParseFromPath@CArchivePath@@QAEXABVUString@@W4EArcNameMode@@@Z
.text:00000C56                 mov     eax, large fs:0
.text:00000C5C                 push    eax
.text:00000C5D                 sub     esp, 1Ch
.text:00000C60                 mov     eax, 0CCCCCCCCh
.text:00000C65                 mov     [ebp+var_28], eax
.text:00000C68                 mov     [ebp+var_24], eax
.text:00000C6B                 mov     [ebp+var_20], eax
.text:00000C6E                 mov     [ebp+var_1C], eax
.text:00000C71                 mov     [ebp+var_18], eax
.text:00000C74                 mov     [ebp+var_14], eax
.text:00000C77                 mov     [ebp+var_10], eax
.text:00000C7A                 mov     eax, dword ptr ds:___security_cookie
.text:00000C7F                 xor     eax, ebp
.text:00000C81                 push    eax
.text:00000C82                 lea     eax, [ebp+var_C]
.text:00000C85                 mov     large fs:0, eax
.text:00000C8B                 mov     [ebp+var_10], ecx
.text:00000C8E                 mov     eax, [ebp+arg_0]
.text:00000C91                 push    eax
.text:00000C92                 mov     ecx, [ebp+var_10]
.text:00000C95                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:00000C9A                 mov     ecx, [ebp+var_10]
.text:00000C9D                 add     ecx, 18h
.text:00000CA0                 push    ecx             ; struct UString *
.text:00000CA1                 mov     edx, [ebp+var_10]
.text:00000CA4                 add     edx, 0Ch
.text:00000CA7                 push    edx             ; struct UString *
.text:00000CA8                 mov     eax, [ebp+arg_0]
.text:00000CAB                 push    eax             ; struct UString *
.text:00000CAC                 call    ?SplitPathToParts_2@@YGXABVUString@@AAV1@1@Z ; SplitPathToParts_2(UString const &,UString &,UString &)
.text:00000CB1                 cmp     [ebp+arg_4], 2
.text:00000CB5                 jnz     short loc_CBC
.text:00000CB7                 jmp     loc_D8D
.text:00000CBC ; ---------------------------------------------------------------------------
.text:00000CBC
.text:00000CBC loc_CBC:                                ; CODE XREF: CArchivePath::ParseFromPath(UString const &,EArcNameMode)+69j
.text:00000CBC                 cmp     [ebp+arg_4], 1
.text:00000CC0                 jnz     short loc_CD2
.text:00000CC2                 mov     ecx, [ebp+var_10]
.text:00000CC5                 add     ecx, 24h ; '$'  ; this
.text:00000CC8                 call    ?Empty@UString@@QAEXXZ ; UString::Empty(void)
.text:00000CCD                 jmp     loc_D8D
.text:00000CD2 ; ---------------------------------------------------------------------------
.text:00000CD2
.text:00000CD2 loc_CD2:                                ; CODE XREF: CArchivePath::ParseFromPath(UString const &,EArcNameMode)+74j
.text:00000CD2                 mov     ecx, [ebp+var_10]
.text:00000CD5                 add     ecx, 18h        ; this
.text:00000CD8                 call    ?ReverseFind_Dot@UString@@QBEHXZ ; UString::ReverseFind_Dot(void)
.text:00000CDD                 mov     [ebp+var_14], eax
.text:00000CE0                 cmp     [ebp+var_14], 0
.text:00000CE4                 jge     short loc_CEB
.text:00000CE6                 jmp     loc_D8D
.text:00000CEB ; ---------------------------------------------------------------------------
.text:00000CEB
.text:00000CEB loc_CEB:                                ; CODE XREF: CArchivePath::ParseFromPath(UString const &,EArcNameMode)+98j
.text:00000CEB                 mov     ecx, [ebp+var_10]
.text:00000CEE                 add     ecx, 18h        ; this
.text:00000CF1                 call    ?Len@UString@@QBEIXZ ; UString::Len(void)
.text:00000CF6                 sub     eax, 1
.text:00000CF9                 cmp     [ebp+var_14], eax
.text:00000CFC                 jnz     short loc_D16
.text:00000CFE                 mov     ecx, [ebp+var_10]
.text:00000D01                 add     ecx, 18h        ; this
.text:00000D04                 call    ?DeleteBack@UString@@QAEXXZ ; UString::DeleteBack(void)
.text:00000D09                 mov     ecx, [ebp+var_10]
.text:00000D0C                 add     ecx, 24h ; '$'  ; this
.text:00000D0F                 call    ?Empty@UString@@QAEXXZ ; UString::Empty(void)
.text:00000D14                 jmp     short loc_D8D
.text:00000D16 ; ---------------------------------------------------------------------------
.text:00000D16
.text:00000D16 loc_D16:                                ; CODE XREF: CArchivePath::ParseFromPath(UString const &,EArcNameMode)+B0j
.text:00000D16                 mov     ecx, [ebp+var_14]
.text:00000D19                 add     ecx, 1
.text:00000D1C                 push    ecx             ; unsigned int
.text:00000D1D                 mov     ecx, [ebp+var_10]
.text:00000D20                 add     ecx, 18h        ; this
.text:00000D23                 call    ?Ptr@UString@@QBEPB_WI@Z ; UString::Ptr(uint)
.text:00000D28                 push    eax
.text:00000D29                 lea     ecx, [ebp+var_24]
.text:00000D2C                 call    ??0UString@@QAE@PB_W@Z ; UString::UString(wchar_t const *)
.text:00000D31                 mov     [ebp+var_4], 0
.text:00000D38                 lea     ecx, [ebp+var_24]
.text:00000D3B                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00000D40                 push    eax             ; wchar_t *
.text:00000D41                 mov     ecx, [ebp+var_10]
.text:00000D44                 add     ecx, 24h ; '$'  ; this
.text:00000D47                 call    ?IsEqualTo_NoCase@UString@@QBE_NPB_W@Z ; UString::IsEqualTo_NoCase(wchar_t const *)
.text:00000D4C                 movzx   edx, al
.text:00000D4F                 test    edx, edx
.text:00000D51                 jz      short loc_D73
.text:00000D53                 lea     eax, [ebp+var_24]
.text:00000D56                 push    eax
.text:00000D57                 mov     ecx, [ebp+var_10]
.text:00000D5A                 add     ecx, 24h ; '$'
.text:00000D5D                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:00000D62                 mov     ecx, [ebp+var_14]
.text:00000D65                 push    ecx             ; unsigned int
.text:00000D66                 mov     ecx, [ebp+var_10]
.text:00000D69                 add     ecx, 18h        ; this
.text:00000D6C                 call    ?DeleteFrom@UString@@QAEXI@Z ; UString::DeleteFrom(uint)
.text:00000D71                 jmp     short loc_D7E
.text:00000D73 ; ---------------------------------------------------------------------------
.text:00000D73
.text:00000D73 loc_D73:                                ; CODE XREF: CArchivePath::ParseFromPath(UString const &,EArcNameMode)+105j
.text:00000D73                 mov     ecx, [ebp+var_10]
.text:00000D76                 add     ecx, 24h ; '$'  ; this
.text:00000D79                 call    ?Empty@UString@@QAEXXZ ; UString::Empty(void)
.text:00000D7E
.text:00000D7E loc_D7E:                                ; CODE XREF: CArchivePath::ParseFromPath(UString const &,EArcNameMode)+125j
.text:00000D7E                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000D85                 lea     ecx, [ebp+var_24] ; this
.text:00000D88                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000D8D
.text:00000D8D loc_D8D:                                ; CODE XREF: CArchivePath::ParseFromPath(UString const &,EArcNameMode)+6Bj
.text:00000D8D                                         ; CArchivePath::ParseFromPath(UString const &,EArcNameMode)+81j ...
.text:00000D8D                 push    edx
.text:00000D8E                 mov     ecx, ebp
.text:00000D90                 push    eax
.text:00000D91                 lea     edx, $LN13
.text:00000D97                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00000D9C                 pop     eax
.text:00000D9D                 pop     edx
.text:00000D9E                 mov     ecx, [ebp+var_C]
.text:00000DA1                 mov     large fs:0, ecx
.text:00000DA8                 pop     ecx
.text:00000DA9                 add     esp, 28h
.text:00000DAC                 cmp     ebp, esp
.text:00000DAE                 call    __RTC_CheckEsp
.text:00000DB3                 mov     esp, ebp
.text:00000DB5                 pop     ebp
.text:00000DB6                 retn    8
.text:00000DB6 ?ParseFromPath@CArchivePath@@QAEXABVUString@@W4EArcNameMode@@@Z endp
.text:00000DB6
.text:00000DB6 ; ---------------------------------------------------------------------------
.text:00000DB9                 align 4
.text:00000DBC $LN13           dd 1                    ; DATA XREF: CArchivePath::ParseFromPath(UString const &,EArcNameMode)+145o
.text:00000DC0                 dd offset $LN12
.text:00000DC4 $LN12           dd 0FFFFFFDCh, 0Ch      ; DATA XREF: .text:00000DC0o
.text:00000DCC                 dd offset $LN10
.text:00000DD0 $LN10           dd 747865h, 2 dup(0CCCCCCCCh) ; DATA XREF: .text:00000DCCo
.text:00000DDC
.text:00000DDC ; =============== S U B R O U T I N E =======================================
.text:00000DDC
.text:00000DDC ; Attributes: bp-based frame
.text:00000DDC
.text:00000DDC ; public: class UString __thiscall CArchivePath::GetFinalPath(void)const
.text:00000DDC                 public ?GetFinalPath@CArchivePath@@QBE?AVUString@@XZ
.text:00000DDC ?GetFinalPath@CArchivePath@@QBE?AVUString@@XZ proc near
.text:00000DDC                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+380p
.text:00000DDC                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+12A9p ...
.text:00000DDC
.text:00000DDC var_28          = dword ptr -28h
.text:00000DDC var_24          = dword ptr -24h
.text:00000DDC var_20          = dword ptr -20h
.text:00000DDC var_1C          = dword ptr -1Ch
.text:00000DDC var_18          = dword ptr -18h
.text:00000DDC var_14          = dword ptr -14h
.text:00000DDC var_10          = dword ptr -10h
.text:00000DDC var_C           = dword ptr -0Ch
.text:00000DDC var_4           = dword ptr -4
.text:00000DDC arg_0           = dword ptr  8
.text:00000DDC
.text:00000DDC                 push    ebp
.text:00000DDD                 mov     ebp, esp
.text:00000DDF                 push    0FFFFFFFFh
.text:00000DE1                 push    offset __ehhandler$?GetFinalPath@CArchivePath@@QBE?AVUString@@XZ
.text:00000DE6                 mov     eax, large fs:0
.text:00000DEC                 push    eax
.text:00000DED                 sub     esp, 1Ch
.text:00000DF0                 mov     eax, 0CCCCCCCCh
.text:00000DF5                 mov     [ebp+var_28], eax
.text:00000DF8                 mov     [ebp+var_24], eax
.text:00000DFB                 mov     [ebp+var_20], eax
.text:00000DFE                 mov     [ebp+var_1C], eax
.text:00000E01                 mov     [ebp+var_18], eax
.text:00000E04                 mov     [ebp+var_14], eax
.text:00000E07                 mov     [ebp+var_10], eax
.text:00000E0A                 mov     eax, dword ptr ds:___security_cookie
.text:00000E0F                 xor     eax, ebp
.text:00000E11                 push    eax
.text:00000E12                 lea     eax, [ebp+var_C]
.text:00000E15                 mov     large fs:0, eax
.text:00000E1B                 mov     [ebp+var_10], ecx
.text:00000E1E                 mov     [ebp+var_28], 0
.text:00000E25                 lea     eax, [ebp+var_20]
.text:00000E28                 push    eax
.text:00000E29                 mov     ecx, [ebp+var_10]
.text:00000E2C                 call    ?GetPathWithoutExt@CArchivePath@@QBE?AVUString@@XZ ; CArchivePath::GetPathWithoutExt(void)
.text:00000E31                 mov     [ebp+var_4], 1
.text:00000E38                 mov     ecx, [ebp+var_10]
.text:00000E3B                 add     ecx, 24h ; '$'  ; this
.text:00000E3E                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:00000E43                 movzx   ecx, al
.text:00000E46                 test    ecx, ecx
.text:00000E48                 jnz     short loc_E63
.text:00000E4A                 push    2Eh ; '.'
.text:00000E4C                 lea     ecx, [ebp+var_20]
.text:00000E4F                 call    ??YUString@@QAEAAV0@_W@Z ; UString::operator+=(wchar_t)
.text:00000E54                 mov     edx, [ebp+var_10]
.text:00000E57                 add     edx, 24h ; '$'
.text:00000E5A                 push    edx
.text:00000E5B                 lea     ecx, [ebp+var_20]
.text:00000E5E                 call    ??YUString@@QAEAAV0@ABV0@@Z ; UString::operator+=(UString const &)
.text:00000E63
.text:00000E63 loc_E63:                                ; CODE XREF: CArchivePath::GetFinalPath(void)+6Cj
.text:00000E63                 lea     eax, [ebp+var_20]
.text:00000E66                 push    eax
.text:00000E67                 mov     ecx, [ebp+arg_0]
.text:00000E6A                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00000E6F                 mov     ecx, [ebp+var_28]
.text:00000E72                 or      ecx, 1
.text:00000E75                 mov     [ebp+var_28], ecx
.text:00000E78                 mov     byte ptr [ebp+var_4], 0
.text:00000E7C                 lea     ecx, [ebp+var_20] ; this
.text:00000E7F                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000E84                 mov     eax, [ebp+arg_0]
.text:00000E87                 push    edx
.text:00000E88                 mov     ecx, ebp
.text:00000E8A                 push    eax
.text:00000E8B                 lea     edx, $LN10_0
.text:00000E91                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00000E96                 pop     eax
.text:00000E97                 pop     edx
.text:00000E98                 mov     ecx, [ebp+var_C]
.text:00000E9B                 mov     large fs:0, ecx
.text:00000EA2                 pop     ecx
.text:00000EA3                 add     esp, 28h
.text:00000EA6                 cmp     ebp, esp
.text:00000EA8                 call    __RTC_CheckEsp
.text:00000EAD                 mov     esp, ebp
.text:00000EAF                 pop     ebp
.text:00000EB0                 retn    4
.text:00000EB0 ?GetFinalPath@CArchivePath@@QBE?AVUString@@XZ endp
.text:00000EB0
.text:00000EB0 ; ---------------------------------------------------------------------------
.text:00000EB3                 align 4
.text:00000EB4 $LN10_0         dd 1                    ; DATA XREF: CArchivePath::GetFinalPath(void)+AFo
.text:00000EB8                 dd offset $LN9
.text:00000EBC $LN9            dd 0FFFFFFE0h, 0Ch      ; DATA XREF: .text:00000EB8o
.text:00000EC4                 dd offset $LN7          ; "path"
.text:00000EC8 $LN7            db 'path',0             ; DATA XREF: .text:00000EC4o
.text:00000ECD                 db 0Fh dup(0CCh)
.text:00000EDC
.text:00000EDC ; =============== S U B R O U T I N E =======================================
.text:00000EDC
.text:00000EDC ; Attributes: bp-based frame
.text:00000EDC
.text:00000EDC ; public: class UString __thiscall CArchivePath::GetFinalVolPath(void)const
.text:00000EDC                 public ?GetFinalVolPath@CArchivePath@@QBE?AVUString@@XZ
.text:00000EDC ?GetFinalVolPath@CArchivePath@@QBE?AVUString@@XZ proc near
.text:00000EDC                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+DE3p
.text:00000EDC
.text:00000EDC var_28          = dword ptr -28h
.text:00000EDC var_24          = dword ptr -24h
.text:00000EDC var_20          = dword ptr -20h
.text:00000EDC var_1C          = dword ptr -1Ch
.text:00000EDC var_18          = dword ptr -18h
.text:00000EDC var_14          = dword ptr -14h
.text:00000EDC var_10          = dword ptr -10h
.text:00000EDC var_C           = dword ptr -0Ch
.text:00000EDC var_4           = dword ptr -4
.text:00000EDC arg_0           = dword ptr  8
.text:00000EDC
.text:00000EDC                 push    ebp
.text:00000EDD                 mov     ebp, esp
.text:00000EDF                 push    0FFFFFFFFh
.text:00000EE1                 push    offset __ehhandler$?GetFinalVolPath@CArchivePath@@QBE?AVUString@@XZ
.text:00000EE6                 mov     eax, large fs:0
.text:00000EEC                 push    eax
.text:00000EED                 sub     esp, 1Ch
.text:00000EF0                 mov     eax, 0CCCCCCCCh
.text:00000EF5                 mov     [ebp+var_28], eax
.text:00000EF8                 mov     [ebp+var_24], eax
.text:00000EFB                 mov     [ebp+var_20], eax
.text:00000EFE                 mov     [ebp+var_1C], eax
.text:00000F01                 mov     [ebp+var_18], eax
.text:00000F04                 mov     [ebp+var_14], eax
.text:00000F07                 mov     [ebp+var_10], eax
.text:00000F0A                 mov     eax, dword ptr ds:___security_cookie
.text:00000F0F                 xor     eax, ebp
.text:00000F11                 push    eax
.text:00000F12                 lea     eax, [ebp+var_C]
.text:00000F15                 mov     large fs:0, eax
.text:00000F1B                 mov     [ebp+var_10], ecx
.text:00000F1E                 mov     [ebp+var_28], 0
.text:00000F25                 lea     eax, [ebp+var_20]
.text:00000F28                 push    eax
.text:00000F29                 mov     ecx, [ebp+var_10]
.text:00000F2C                 call    ?GetPathWithoutExt@CArchivePath@@QBE?AVUString@@XZ ; CArchivePath::GetPathWithoutExt(void)
.text:00000F31                 mov     [ebp+var_4], 1
.text:00000F38                 mov     ecx, [ebp+var_10]
.text:00000F3B                 add     ecx, 24h ; '$'  ; this
.text:00000F3E                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:00000F43                 movzx   ecx, al
.text:00000F46                 test    ecx, ecx
.text:00000F48                 jnz     short loc_F63
.text:00000F4A                 push    2Eh ; '.'
.text:00000F4C                 lea     ecx, [ebp+var_20]
.text:00000F4F                 call    ??YUString@@QAEAAV0@_W@Z ; UString::operator+=(wchar_t)
.text:00000F54                 mov     edx, [ebp+var_10]
.text:00000F57                 add     edx, 30h ; '0'
.text:00000F5A                 push    edx
.text:00000F5B                 lea     ecx, [ebp+var_20]
.text:00000F5E                 call    ??YUString@@QAEAAV0@ABV0@@Z ; UString::operator+=(UString const &)
.text:00000F63
.text:00000F63 loc_F63:                                ; CODE XREF: CArchivePath::GetFinalVolPath(void)+6Cj
.text:00000F63                 lea     eax, [ebp+var_20]
.text:00000F66                 push    eax
.text:00000F67                 mov     ecx, [ebp+arg_0]
.text:00000F6A                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00000F6F                 mov     ecx, [ebp+var_28]
.text:00000F72                 or      ecx, 1
.text:00000F75                 mov     [ebp+var_28], ecx
.text:00000F78                 mov     byte ptr [ebp+var_4], 0
.text:00000F7C                 lea     ecx, [ebp+var_20] ; this
.text:00000F7F                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000F84                 mov     eax, [ebp+arg_0]
.text:00000F87                 push    edx
.text:00000F88                 mov     ecx, ebp
.text:00000F8A                 push    eax
.text:00000F8B                 lea     edx, $LN10_1
.text:00000F91                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00000F96                 pop     eax
.text:00000F97                 pop     edx
.text:00000F98                 mov     ecx, [ebp+var_C]
.text:00000F9B                 mov     large fs:0, ecx
.text:00000FA2                 pop     ecx
.text:00000FA3                 add     esp, 28h
.text:00000FA6                 cmp     ebp, esp
.text:00000FA8                 call    __RTC_CheckEsp
.text:00000FAD                 mov     esp, ebp
.text:00000FAF                 pop     ebp
.text:00000FB0                 retn    4
.text:00000FB0 ?GetFinalVolPath@CArchivePath@@QBE?AVUString@@XZ endp
.text:00000FB0
.text:00000FB0 ; ---------------------------------------------------------------------------
.text:00000FB3                 align 4
.text:00000FB4 $LN10_1         dd 1                    ; DATA XREF: CArchivePath::GetFinalVolPath(void)+AFo
.text:00000FB8                 dd offset $LN9_0
.text:00000FBC $LN9_0          dd 0FFFFFFE0h, 0Ch      ; DATA XREF: .text:00000FB8o
.text:00000FC4                 dd offset $LN7_0        ; "path"
.text:00000FC8 $LN7_0          db 'path',0             ; DATA XREF: .text:00000FC4o
.text:00000FCD                 db 0Fh dup(0CCh)
.text:00000FDC
.text:00000FDC ; =============== S U B R O U T I N E =======================================
.text:00000FDC
.text:00000FDC ; Attributes: bp-based frame
.text:00000FDC
.text:00000FDC ; public: class UString __thiscall CArchivePath::GetTempPathA(void)const
.text:00000FDC                 public ?GetTempPathA@CArchivePath@@QBE?AVUString@@XZ
.text:00000FDC ?GetTempPathA@CArchivePath@@QBE?AVUString@@XZ proc near
.text:00000FDC                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1AABp
.text:00000FDC                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+AA1p
.text:00000FDC
.text:00000FDC var_28          = dword ptr -28h
.text:00000FDC var_24          = dword ptr -24h
.text:00000FDC var_20          = dword ptr -20h
.text:00000FDC var_1C          = dword ptr -1Ch
.text:00000FDC var_18          = dword ptr -18h
.text:00000FDC var_14          = dword ptr -14h
.text:00000FDC var_10          = dword ptr -10h
.text:00000FDC var_C           = dword ptr -0Ch
.text:00000FDC var_4           = dword ptr -4
.text:00000FDC arg_0           = dword ptr  8
.text:00000FDC
.text:00000FDC                 push    ebp
.text:00000FDD                 mov     ebp, esp
.text:00000FDF                 push    0FFFFFFFFh
.text:00000FE1                 push    offset __ehhandler$?GetTempPathA@CArchivePath@@QBE?AVUString@@XZ
.text:00000FE6                 mov     eax, large fs:0
.text:00000FEC                 push    eax
.text:00000FED                 sub     esp, 1Ch
.text:00000FF0                 mov     eax, 0CCCCCCCCh
.text:00000FF5                 mov     [ebp+var_28], eax
.text:00000FF8                 mov     [ebp+var_24], eax
.text:00000FFB                 mov     [ebp+var_20], eax
.text:00000FFE                 mov     [ebp+var_1C], eax
.text:00001001                 mov     [ebp+var_18], eax
.text:00001004                 mov     [ebp+var_14], eax
.text:00001007                 mov     [ebp+var_10], eax
.text:0000100A                 mov     eax, dword ptr ds:___security_cookie
.text:0000100F                 xor     eax, ebp
.text:00001011                 push    eax
.text:00001012                 lea     eax, [ebp+var_C]
.text:00001015                 mov     large fs:0, eax
.text:0000101B                 mov     [ebp+var_10], ecx
.text:0000101E                 mov     [ebp+var_28], 0
.text:00001025                 mov     eax, [ebp+var_10]
.text:00001028                 add     eax, 40h ; '@'
.text:0000102B                 push    eax
.text:0000102C                 lea     ecx, [ebp+var_20]
.text:0000102F                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00001034                 mov     [ebp+var_4], 1
.text:0000103B                 mov     ecx, [ebp+var_10]
.text:0000103E                 add     ecx, 18h
.text:00001041                 push    ecx
.text:00001042                 lea     ecx, [ebp+var_20]
.text:00001045                 call    ??YUString@@QAEAAV0@ABV0@@Z ; UString::operator+=(UString const &)
.text:0000104A                 mov     ecx, [ebp+var_10]
.text:0000104D                 add     ecx, 24h ; '$'  ; this
.text:00001050                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:00001055                 movzx   edx, al
.text:00001058                 test    edx, edx
.text:0000105A                 jnz     short loc_1075
.text:0000105C                 push    2Eh ; '.'
.text:0000105E                 lea     ecx, [ebp+var_20]
.text:00001061                 call    ??YUString@@QAEAAV0@_W@Z ; UString::operator+=(wchar_t)
.text:00001066                 mov     eax, [ebp+var_10]
.text:00001069                 add     eax, 24h ; '$'
.text:0000106C                 push    eax
.text:0000106D                 lea     ecx, [ebp+var_20]
.text:00001070                 call    ??YUString@@QAEAAV0@ABV0@@Z ; UString::operator+=(UString const &)
.text:00001075
.text:00001075 loc_1075:                               ; CODE XREF: CArchivePath::GetTempPathA(void)+7Ej
.text:00001075                 push    offset $SG74378 ; ".tmp"
.text:0000107A                 lea     ecx, [ebp+var_20] ; this
.text:0000107D                 call    ?AddAscii@UString@@QAEXPBD@Z ; UString::AddAscii(char const *)
.text:00001082                 mov     ecx, [ebp+var_10]
.text:00001085                 add     ecx, 4Ch ; 'L'
.text:00001088                 push    ecx
.text:00001089                 lea     ecx, [ebp+var_20]
.text:0000108C                 call    ??YUString@@QAEAAV0@ABV0@@Z ; UString::operator+=(UString const &)
.text:00001091                 lea     edx, [ebp+var_20]
.text:00001094                 push    edx
.text:00001095                 mov     ecx, [ebp+arg_0]
.text:00001098                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:0000109D                 mov     eax, [ebp+var_28]
.text:000010A0                 or      eax, 1
.text:000010A3                 mov     [ebp+var_28], eax
.text:000010A6                 mov     byte ptr [ebp+var_4], 0
.text:000010AA                 lea     ecx, [ebp+var_20] ; this
.text:000010AD                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000010B2                 mov     eax, [ebp+arg_0]
.text:000010B5                 push    edx
.text:000010B6                 mov     ecx, ebp
.text:000010B8                 push    eax
.text:000010B9                 lea     edx, $LN10_2
.text:000010BF                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:000010C4                 pop     eax
.text:000010C5                 pop     edx
.text:000010C6                 mov     ecx, [ebp+var_C]
.text:000010C9                 mov     large fs:0, ecx
.text:000010D0                 pop     ecx
.text:000010D1                 add     esp, 28h
.text:000010D4                 cmp     ebp, esp
.text:000010D6                 call    __RTC_CheckEsp
.text:000010DB                 mov     esp, ebp
.text:000010DD                 pop     ebp
.text:000010DE                 retn    4
.text:000010DE ?GetTempPathA@CArchivePath@@QBE?AVUString@@XZ endp
.text:000010DE
.text:000010DE ; ---------------------------------------------------------------------------
.text:000010E1                 align 4
.text:000010E4 $LN10_2         dd 1                    ; DATA XREF: CArchivePath::GetTempPathA(void)+DDo
.text:000010E8                 dd offset $LN9_1
.text:000010EC $LN9_1          dd 0FFFFFFE0h, 0Ch      ; DATA XREF: .text:000010E8o
.text:000010F4                 dd offset $LN7_1        ; "path"
.text:000010F8 $LN7_1          db 'path',0             ; DATA XREF: .text:000010F4o
.text:000010FD                 db 0Fh dup(0CCh)
.text:0000110C
.text:0000110C ; =============== S U B R O U T I N E =======================================
.text:0000110C
.text:0000110C ; Attributes: bp-based frame
.text:0000110C
.text:0000110C ; int __stdcall CUpdateOptions::InitFormatIndex(CCodecs *, int, struct UString *)
.text:0000110C                 public ?InitFormatIndex@CUpdateOptions@@QAE_NPBVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@@Z
.text:0000110C ?InitFormatIndex@CUpdateOptions@@QAE_NPBVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@@Z proc near
.text:0000110C                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+329p
.text:0000110C
.text:0000110C var_24          = dword ptr -24h
.text:0000110C var_20          = dword ptr -20h
.text:0000110C var_1C          = dword ptr -1Ch
.text:0000110C var_18          = dword ptr -18h
.text:0000110C var_14          = dword ptr -14h
.text:0000110C var_10          = dword ptr -10h
.text:0000110C var_C           = dword ptr -0Ch
.text:0000110C var_8           = dword ptr -8
.text:0000110C var_4           = dword ptr -4
.text:0000110C arg_0           = dword ptr  8
.text:0000110C arg_4           = dword ptr  0Ch
.text:0000110C arg_8           = dword ptr  10h
.text:0000110C
.text:0000110C                 push    ebp
.text:0000110D                 mov     ebp, esp
.text:0000110F                 sub     esp, 24h
.text:00001112                 push    esi
.text:00001113                 push    edi
.text:00001114                 mov     eax, 0CCCCCCCCh
.text:00001119                 mov     [ebp+var_24], eax
.text:0000111C                 mov     [ebp+var_20], eax
.text:0000111F                 mov     [ebp+var_1C], eax
.text:00001122                 mov     [ebp+var_18], eax
.text:00001125                 mov     [ebp+var_14], eax
.text:00001128                 mov     [ebp+var_10], eax
.text:0000112B                 mov     [ebp+var_C], eax
.text:0000112E                 mov     [ebp+var_8], eax
.text:00001131                 mov     [ebp+var_4], eax
.text:00001134                 mov     [ebp+var_4], ecx
.text:00001137                 mov     ecx, [ebp+arg_4]
.text:0000113A                 call    ?Size@?$CObjectVector@UCOpenType@@@@QBEIXZ ; CObjectVector<COpenType>::Size(void)
.text:0000113F                 cmp     eax, 1
.text:00001142                 jbe     short loc_1148
.text:00001144                 xor     al, al
.text:00001146                 jmp     short loc_11C2
.text:00001148 ; ---------------------------------------------------------------------------
.text:00001148
.text:00001148 loc_1148:                               ; CODE XREF: CUpdateOptions::InitFormatIndex(CCodecs const *,CObjectVector<COpenType> const &,UString const &)+36j
.text:00001148                 mov     ecx, [ebp+arg_4]
.text:0000114B                 call    ?Size@?$CObjectVector@UCOpenType@@@@QBEIXZ ; CObjectVector<COpenType>::Size(void)
.text:00001150                 test    eax, eax
.text:00001152                 jz      short loc_1173
.text:00001154                 push    0
.text:00001156                 mov     ecx, [ebp+arg_4]
.text:00001159                 call    ??A?$CObjectVector@UCOpenType@@@@QBEABUCOpenType@@I@Z ; CObjectVector<COpenType>::operator[](uint)
.text:0000115E                 mov     edi, [ebp+var_4]
.text:00001161                 add     edi, 8
.text:00001164                 mov     ecx, 8
.text:00001169                 mov     esi, eax
.text:0000116B                 rep movsd
.text:0000116D                 mov     eax, [ebp+var_4]
.text:00001170                 mov     byte ptr [eax], 1
.text:00001173
.text:00001173 loc_1173:                               ; CODE XREF: CUpdateOptions::InitFormatIndex(CCodecs const *,CObjectVector<COpenType> const &,UString const &)+46j
.text:00001173                 mov     ecx, [ebp+var_4]
.text:00001176                 cmp     dword ptr [ecx+8], 0
.text:0000117A                 jge     short loc_11C0
.text:0000117C                 lea     ecx, [ebp+var_24] ; this
.text:0000117F                 call    ??0COpenType@@QAE@XZ ; COpenType::COpenType(void)
.text:00001184                 mov     edi, [ebp+var_4]
.text:00001187                 add     edi, 8
.text:0000118A                 mov     ecx, 8
.text:0000118F                 mov     esi, eax
.text:00001191                 rep movsd
.text:00001193                 mov     edx, [ebp+var_4]
.text:00001196                 cmp     dword ptr [edx+0A0h], 2
.text:0000119D                 jz      short loc_11C0
.text:0000119F                 mov     eax, [ebp+arg_8]
.text:000011A2                 push    eax             ; struct UString *
.text:000011A3                 mov     ecx, [ebp+arg_0] ; this
.text:000011A6                 call    ?FindFormatForArchiveName@CCodecs@@QBEHABVUString@@@Z ; CCodecs::FindFormatForArchiveName(UString const &)
.text:000011AB                 mov     ecx, [ebp+var_4]
.text:000011AE                 mov     [ecx+8], eax
.text:000011B1                 mov     edx, [ebp+var_4]
.text:000011B4                 cmp     dword ptr [edx+8], 0
.text:000011B8                 jl      short loc_11C0
.text:000011BA                 mov     eax, [ebp+var_4]
.text:000011BD                 mov     byte ptr [eax], 1
.text:000011C0
.text:000011C0 loc_11C0:                               ; CODE XREF: CUpdateOptions::InitFormatIndex(CCodecs const *,CObjectVector<COpenType> const &,UString const &)+6Ej
.text:000011C0                                         ; CUpdateOptions::InitFormatIndex(CCodecs const *,CObjectVector<COpenType> const &,UString const &)+91j ...
.text:000011C0                 mov     al, 1
.text:000011C2
.text:000011C2 loc_11C2:                               ; CODE XREF: CUpdateOptions::InitFormatIndex(CCodecs const *,CObjectVector<COpenType> const &,UString const &)+3Aj
.text:000011C2                 pop     edi
.text:000011C3                 pop     esi
.text:000011C4                 add     esp, 24h
.text:000011C7                 cmp     ebp, esp
.text:000011C9                 call    __RTC_CheckEsp
.text:000011CE                 mov     esp, ebp
.text:000011D0                 pop     ebp
.text:000011D1                 retn    0Ch
.text:000011D1 ?InitFormatIndex@CUpdateOptions@@QAE_NPBVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@@Z endp
.text:000011D1
.text:000011D1 ; ---------------------------------------------------------------------------
.text:000011D4                 db 8 dup(0CCh)
.text:000011DC
.text:000011DC ; =============== S U B R O U T I N E =======================================
.text:000011DC
.text:000011DC ; Attributes: bp-based frame
.text:000011DC
.text:000011DC ; bool __thiscall CUpdateOptions::SetArcPath(CUpdateOptions *this, const struct CCodecs *, const struct UString *)
.text:000011DC                 public ?SetArcPath@CUpdateOptions@@QAE_NPBVCCodecs@@ABVUString@@@Z
.text:000011DC ?SetArcPath@CUpdateOptions@@QAE_NPBVCCodecs@@ABVUString@@@Z proc near
.text:000011DC                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+340p
.text:000011DC                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+429p ...
.text:000011DC
.text:000011DC var_64          = dword ptr -64h
.text:000011DC var_60          = dword ptr -60h
.text:000011DC var_59          = byte ptr -59h
.text:000011DC var_58          = byte ptr -58h
.text:000011DC var_49          = byte ptr -49h
.text:000011DC var_48          = dword ptr -48h
.text:000011DC var_44          = dword ptr -44h
.text:000011DC var_3C          = byte ptr -3Ch
.text:000011DC var_2C          = dword ptr -2Ch
.text:000011DC var_28          = dword ptr -28h
.text:000011DC var_20          = byte ptr -20h
.text:000011DC var_10          = dword ptr -10h
.text:000011DC var_C           = dword ptr -0Ch
.text:000011DC var_4           = dword ptr -4
.text:000011DC arg_0           = dword ptr  8
.text:000011DC arg_4           = dword ptr  0Ch
.text:000011DC
.text:000011DC                 push    ebp
.text:000011DD                 mov     ebp, esp
.text:000011DF                 push    0FFFFFFFFh
.text:000011E1                 push    offset __ehhandler$?SetArcPath@CUpdateOptions@@QAE_NPBVCCodecs@@ABVUString@@@Z
.text:000011E6                 mov     eax, large fs:0
.text:000011EC                 push    eax
.text:000011ED                 sub     esp, 58h
.text:000011F0                 push    edi
.text:000011F1                 push    ecx
.text:000011F2                 lea     edi, [ebp+var_64]
.text:000011F5                 mov     ecx, 16h
.text:000011FA                 mov     eax, 0CCCCCCCCh
.text:000011FF                 rep stosd
.text:00001201                 pop     ecx
.text:00001202                 mov     eax, dword ptr ds:___security_cookie
.text:00001207                 xor     eax, ebp
.text:00001209                 push    eax
.text:0000120A                 lea     eax, [ebp+var_C]
.text:0000120D                 mov     large fs:0, eax
.text:00001213                 mov     [ebp+var_10], ecx
.text:00001216                 lea     ecx, [ebp+var_20]
.text:00001219                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:0000121E                 mov     [ebp+var_4], 0
.text:00001225                 mov     eax, [ebp+var_10]
.text:00001228                 mov     ecx, [eax+8]
.text:0000122B                 mov     [ebp+var_28], ecx
.text:0000122E                 cmp     [ebp+var_28], 0
.text:00001232                 jge     short loc_1245
.text:00001234                 mov     edx, ds:_kDefaultArcExt
.text:0000123A                 push    edx
.text:0000123B                 lea     ecx, [ebp+var_20]
.text:0000123E                 call    ??4UString@@QAEAAV0@PB_W@Z ; UString::operator=(wchar_t const *)
.text:00001243                 jmp     short loc_12AE
.text:00001245 ; ---------------------------------------------------------------------------
.text:00001245
.text:00001245 loc_1245:                               ; CODE XREF: CUpdateOptions::SetArcPath(CCodecs const *,UString const &)+56j
.text:00001245                 mov     eax, [ebp+var_28]
.text:00001248                 push    eax
.text:00001249                 mov     ecx, [ebp+arg_0]
.text:0000124C                 add     ecx, 8
.text:0000124F                 call    ??A?$CObjectVector@UCArcInfoEx@@@@QBEABUCArcInfoEx@@I@Z ; CObjectVector<CArcInfoEx>::operator[](uint)
.text:00001254                 mov     [ebp+var_2C], eax
.text:00001257                 mov     ecx, [ebp+var_2C]
.text:0000125A                 movzx   edx, byte ptr [ecx+28h]
.text:0000125E                 test    edx, edx
.text:00001260                 jnz     short loc_127D
.text:00001262                 mov     [ebp+var_49], 0
.text:00001266                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000126D                 lea     ecx, [ebp+var_20] ; this
.text:00001270                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00001275                 mov     al, [ebp+var_49]
.text:00001278                 jmp     loc_13A0
.text:0000127D ; ---------------------------------------------------------------------------
.text:0000127D
.text:0000127D loc_127D:                               ; CODE XREF: CUpdateOptions::SetArcPath(CCodecs const *,UString const &)+84j
.text:0000127D                 lea     eax, [ebp+var_58]
.text:00001280                 push    eax
.text:00001281                 mov     ecx, [ebp+var_2C]
.text:00001284                 call    ?GetMainExt@CArcInfoEx@@QBE?AVUString@@XZ ; CArcInfoEx::GetMainExt(void)
.text:00001289                 mov     [ebp+var_60], eax
.text:0000128C                 mov     ecx, [ebp+var_60]
.text:0000128F                 mov     [ebp+var_64], ecx
.text:00001292                 mov     byte ptr [ebp+var_4], 1
.text:00001296                 mov     edx, [ebp+var_64]
.text:00001299                 push    edx
.text:0000129A                 lea     ecx, [ebp+var_20]
.text:0000129D                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:000012A2                 mov     byte ptr [ebp+var_4], 0
.text:000012A6                 lea     ecx, [ebp+var_58] ; this
.text:000012A9                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000012AE
.text:000012AE loc_12AE:                               ; CODE XREF: CUpdateOptions::SetArcPath(CCodecs const *,UString const &)+67j
.text:000012AE                 lea     eax, [ebp+var_20]
.text:000012B1                 push    eax
.text:000012B2                 lea     ecx, [ebp+var_3C]
.text:000012B5                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:000012BA                 mov     byte ptr [ebp+var_4], 2
.text:000012BE                 mov     ecx, [ebp+var_10]
.text:000012C1                 movzx   edx, byte ptr [ecx+0A4h]
.text:000012C8                 test    edx, edx
.text:000012CA                 jz      short loc_12DA
.text:000012CC                 mov     eax, ds:_kSFXExtension
.text:000012D1                 push    eax             ; char *
.text:000012D2                 lea     ecx, [ebp+var_3C] ; this
.text:000012D5                 call    ?SetFromAscii@UString@@QAEXPBD@Z ; UString::SetFromAscii(char const *)
.text:000012DA
.text:000012DA loc_12DA:                               ; CODE XREF: CUpdateOptions::SetArcPath(CCodecs const *,UString const &)+EEj
.text:000012DA                 lea     ecx, [ebp+var_3C]
.text:000012DD                 push    ecx
.text:000012DE                 mov     ecx, [ebp+var_10]
.text:000012E1                 add     ecx, 6Ch ; 'l'
.text:000012E4                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:000012E9                 lea     edx, [ebp+var_20]
.text:000012EC                 push    edx
.text:000012ED                 mov     ecx, [ebp+var_10]
.text:000012F0                 add     ecx, 78h ; 'x'
.text:000012F3                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:000012F8                 mov     eax, [ebp+var_10]
.text:000012FB                 mov     ecx, [eax+0A0h]
.text:00001301                 push    ecx
.text:00001302                 mov     edx, [ebp+arg_4]
.text:00001305                 push    edx
.text:00001306                 mov     ecx, [ebp+var_10]
.text:00001309                 add     ecx, 48h ; 'H'
.text:0000130C                 call    ?ParseFromPath@CArchivePath@@QAEXABVUString@@W4EArcNameMode@@@Z ; CArchivePath::ParseFromPath(UString const &,EArcNameMode)
.text:00001311                 mov     [ebp+var_44], 0
.text:00001318                 jmp     short loc_1323
.text:0000131A ; ---------------------------------------------------------------------------
.text:0000131A
.text:0000131A loc_131A:                               ; CODE XREF: CUpdateOptions::SetArcPath(CCodecs const *,UString const &)+1A0j
.text:0000131A                 mov     eax, [ebp+var_44]
.text:0000131D                 add     eax, 1
.text:00001320                 mov     [ebp+var_44], eax
.text:00001323
.text:00001323 loc_1323:                               ; CODE XREF: CUpdateOptions::SetArcPath(CCodecs const *,UString const &)+13Cj
.text:00001323                 mov     ecx, [ebp+var_10]
.text:00001326                 add     ecx, 38h ; '8'
.text:00001329                 call    ?Size@?$CObjectVector@UCUpdateArchiveCommand@@@@QBEIXZ ; CObjectVector<CUpdateArchiveCommand>::Size(void)
.text:0000132E                 cmp     [ebp+var_44], eax
.text:00001331                 jnb     short loc_137E
.text:00001333                 mov     ecx, [ebp+var_44]
.text:00001336                 push    ecx
.text:00001337                 mov     ecx, [ebp+var_10]
.text:0000133A                 add     ecx, 38h ; '8'
.text:0000133D                 call    ??A?$CObjectVector@UCUpdateArchiveCommand@@@@QAEAAUCUpdateArchiveCommand@@I@Z ; CObjectVector<CUpdateArchiveCommand>::operator[](uint)
.text:00001342                 mov     [ebp+var_48], eax
.text:00001345                 lea     edx, [ebp+var_3C]
.text:00001348                 push    edx
.text:00001349                 mov     ecx, [ebp+var_48]
.text:0000134C                 add     ecx, 30h ; '0'
.text:0000134F                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:00001354                 lea     eax, [ebp+var_20]
.text:00001357                 push    eax
.text:00001358                 mov     ecx, [ebp+var_48]
.text:0000135B                 add     ecx, 3Ch ; '<'
.text:0000135E                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:00001363                 mov     ecx, [ebp+var_10]
.text:00001366                 mov     edx, [ecx+0A0h]
.text:0000136C                 push    edx
.text:0000136D                 mov     eax, [ebp+var_48]
.text:00001370                 push    eax
.text:00001371                 mov     ecx, [ebp+var_48]
.text:00001374                 add     ecx, 0Ch
.text:00001377                 call    ?ParseFromPath@CArchivePath@@QAEXABVUString@@W4EArcNameMode@@@Z ; CArchivePath::ParseFromPath(UString const &,EArcNameMode)
.text:0000137C                 jmp     short loc_131A
.text:0000137E ; ---------------------------------------------------------------------------
.text:0000137E
.text:0000137E loc_137E:                               ; CODE XREF: CUpdateOptions::SetArcPath(CCodecs const *,UString const &)+155j
.text:0000137E                 mov     [ebp+var_59], 1
.text:00001382                 mov     byte ptr [ebp+var_4], 0
.text:00001386                 lea     ecx, [ebp+var_3C] ; this
.text:00001389                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000138E                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001395                 lea     ecx, [ebp+var_20] ; this
.text:00001398                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000139D                 mov     al, [ebp+var_59]
.text:000013A0
.text:000013A0 loc_13A0:                               ; CODE XREF: CUpdateOptions::SetArcPath(CCodecs const *,UString const &)+9Cj
.text:000013A0                 push    edx
.text:000013A1                 mov     ecx, ebp
.text:000013A3                 push    eax
.text:000013A4                 lea     edx, $LN17
.text:000013AA                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:000013AF                 pop     eax
.text:000013B0                 pop     edx
.text:000013B1                 mov     ecx, [ebp+var_C]
.text:000013B4                 mov     large fs:0, ecx
.text:000013BB                 pop     ecx
.text:000013BC                 pop     edi
.text:000013BD                 add     esp, 64h
.text:000013C0                 cmp     ebp, esp
.text:000013C2                 call    __RTC_CheckEsp
.text:000013C7                 mov     esp, ebp
.text:000013C9                 pop     ebp
.text:000013CA                 retn    8
.text:000013CA ?SetArcPath@CUpdateOptions@@QAE_NPBVCCodecs@@ABVUString@@@Z endp
.text:000013CA
.text:000013CA ; ---------------------------------------------------------------------------
.text:000013CD                 align 10h
.text:000013D0 $LN17           dd 2                    ; DATA XREF: CUpdateOptions::SetArcPath(CCodecs const *,UString const &)+1C8o
.text:000013D4                 dd offset $LN16
.text:000013D8 $LN16           dd 0FFFFFFE0h, 0Ch      ; DATA XREF: .text:000013D4o
.text:000013E0                 dd offset $LN13_0       ; "typeExt"
.text:000013E4                 dd 0FFFFFFC4h, 0Ch
.text:000013EC                 dd offset $LN14
.text:000013F0 $LN14           dd 747865h              ; DATA XREF: .text:000013ECo
.text:000013F4 $LN13_0         db 'typeExt',0          ; DATA XREF: .text:000013E0o
.text:000013FC
.text:000013FC ; =============== S U B R O U T I N E =======================================
.text:000013FC
.text:000013FC ; Attributes: bp-based frame
.text:000013FC
.text:000013FC ; __int32 __thiscall CUpdateProduceCallbackImp::ShowDeleteFile(CUpdateProduceCallbackImp *this, unsigned int)
.text:000013FC                 public ?ShowDeleteFile@CUpdateProduceCallbackImp@@UAEJI@Z
.text:000013FC ?ShowDeleteFile@CUpdateProduceCallbackImp@@UAEJI@Z proc near
.text:000013FC                                         ; DATA XREF: .rdata:const CUpdateProduceCallbackImp::`vftable'o
.text:000013FC
.text:000013FC var_8           = dword ptr -8
.text:000013FC var_4           = dword ptr -4
.text:000013FC arg_0           = dword ptr  8
.text:000013FC
.text:000013FC                 push    ebp
.text:000013FD                 mov     ebp, esp
.text:000013FF                 sub     esp, 8
.text:00001402                 push    esi
.text:00001403                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000140A                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001411                 mov     [ebp+var_4], ecx
.text:00001414                 mov     eax, [ebp+arg_0]
.text:00001417                 push    eax
.text:00001418                 mov     ecx, [ebp+var_4]
.text:0000141B                 mov     ecx, [ecx+4]
.text:0000141E                 call    ??A?$CObjectVector@UCArcItem@@@@QBEABUCArcItem@@I@Z ; CObjectVector<CArcItem>::operator[](uint)
.text:00001423                 mov     [ebp+var_8], eax
.text:00001426                 mov     esi, esp
.text:00001428                 mov     edx, [ebp+var_8]
.text:0000142B                 movzx   eax, byte ptr [edx+1Ch]
.text:0000142F                 push    eax
.text:00001430                 mov     ecx, [ebp+var_8]
.text:00001433                 add     ecx, 10h
.text:00001436                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:0000143B                 push    eax
.text:0000143C                 mov     ecx, [ebp+var_4]
.text:0000143F                 mov     edx, [ecx+8]
.text:00001442                 mov     eax, [ebp+var_4]
.text:00001445                 mov     ecx, [eax+8]
.text:00001448                 mov     edx, [edx]
.text:0000144A                 mov     eax, [edx+38h]
.text:0000144D                 call    eax
.text:0000144F                 cmp     esi, esp
.text:00001451                 call    __RTC_CheckEsp
.text:00001456                 pop     esi
.text:00001457                 add     esp, 8
.text:0000145A                 cmp     ebp, esp
.text:0000145C                 call    __RTC_CheckEsp
.text:00001461                 mov     esp, ebp
.text:00001463                 pop     ebp
.text:00001464                 retn    4
.text:00001464 ?ShowDeleteFile@CUpdateProduceCallbackImp@@UAEJI@Z endp
.text:00001464
.text:00001464 ; ---------------------------------------------------------------------------
.text:00001467                 db 5 dup(0CCh)
.text:0000146C
.text:0000146C ; =============== S U B R O U T I N E =======================================
.text:0000146C
.text:0000146C ; Attributes: bp-based frame
.text:0000146C
.text:0000146C ; bool __thiscall CRenamePair::Prepare(CRenamePair *__hidden this)
.text:0000146C                 public ?Prepare@CRenamePair@@QAE_NXZ
.text:0000146C ?Prepare@CRenamePair@@QAE_NXZ proc near
.text:0000146C
.text:0000146C var_4           = dword ptr -4
.text:0000146C
.text:0000146C                 push    ebp
.text:0000146D                 mov     ebp, esp
.text:0000146F                 push    ecx
.text:00001470                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001477                 mov     [ebp+var_4], ecx
.text:0000147A                 mov     eax, [ebp+var_4]
.text:0000147D                 cmp     dword ptr [eax+1Ch], 2
.text:00001481                 jz      short loc_1487
.text:00001483                 xor     al, al
.text:00001485                 jmp     short loc_14A9
.text:00001487 ; ---------------------------------------------------------------------------
.text:00001487
.text:00001487 loc_1487:                               ; CODE XREF: CRenamePair::Prepare(void)+15j
.text:00001487                 mov     ecx, [ebp+var_4]
.text:0000148A                 movzx   edx, byte ptr [ecx+18h]
.text:0000148E                 test    edx, edx
.text:00001490                 jnz     short loc_1496
.text:00001492                 mov     al, 1
.text:00001494                 jmp     short loc_14A9
.text:00001496 ; ---------------------------------------------------------------------------
.text:00001496
.text:00001496 loc_1496:                               ; CODE XREF: CRenamePair::Prepare(void)+24j
.text:00001496                 mov     eax, [ebp+var_4]
.text:00001499                 push    eax             ; struct UString *
.text:0000149A                 call    ?DoesNameContainWildcard@@YG_NABVUString@@@Z ; DoesNameContainWildcard(UString const &)
.text:0000149F                 movzx   eax, al
.text:000014A2                 neg     eax
.text:000014A4                 sbb     eax, eax
.text:000014A6                 add     eax, 1
.text:000014A9
.text:000014A9 loc_14A9:                               ; CODE XREF: CRenamePair::Prepare(void)+19j
.text:000014A9                                         ; CRenamePair::Prepare(void)+28j
.text:000014A9                 add     esp, 4
.text:000014AC                 cmp     ebp, esp
.text:000014AE                 call    __RTC_CheckEsp
.text:000014B3                 mov     esp, ebp
.text:000014B5                 pop     ebp
.text:000014B6                 retn
.text:000014B6 ?Prepare@CRenamePair@@QAE_NXZ endp
.text:000014B6
.text:000014B6 ; ---------------------------------------------------------------------------
.text:000014B7                 db 5 dup(0CCh)
.text:000014BC
.text:000014BC ; =============== S U B R O U T I N E =======================================
.text:000014BC
.text:000014BC ; Attributes: bp-based frame
.text:000014BC
.text:000014BC ; bool __thiscall CRenamePair::GetNewPath(CRenamePair *this, bool, const struct UString *, struct UString *)
.text:000014BC                 public ?GetNewPath@CRenamePair@@QBE_N_NABVUString@@AAV2@@Z
.text:000014BC ?GetNewPath@CRenamePair@@QBE_N_NABVUString@@AAV2@@Z proc near
.text:000014BC                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+37Cp
.text:000014BC                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+3F7p
.text:000014BC
.text:000014BC var_28          = dword ptr -28h
.text:000014BC var_24          = dword ptr -24h
.text:000014BC var_20          = dword ptr -20h
.text:000014BC var_1C          = dword ptr -1Ch
.text:000014BC var_18          = dword ptr -18h
.text:000014BC var_14          = dword ptr -14h
.text:000014BC var_10          = dword ptr -10h
.text:000014BC var_C           = dword ptr -0Ch
.text:000014BC var_4           = dword ptr -4
.text:000014BC arg_0           = byte ptr  8
.text:000014BC arg_4           = dword ptr  0Ch
.text:000014BC arg_8           = dword ptr  10h
.text:000014BC
.text:000014BC                 push    ebp
.text:000014BD                 mov     ebp, esp
.text:000014BF                 push    0FFFFFFFFh
.text:000014C1                 push    offset __ehhandler$?GetNewPath@CRenamePair@@QBE_N_NABVUString@@AAV2@@Z
.text:000014C6                 mov     eax, large fs:0
.text:000014CC                 push    eax
.text:000014CD                 sub     esp, 1Ch
.text:000014D0                 mov     eax, 0CCCCCCCCh
.text:000014D5                 mov     [ebp+var_28], eax
.text:000014D8                 mov     [ebp+var_24], eax
.text:000014DB                 mov     [ebp+var_20], eax
.text:000014DE                 mov     [ebp+var_1C], eax
.text:000014E1                 mov     [ebp+var_18], eax
.text:000014E4                 mov     [ebp+var_14], eax
.text:000014E7                 mov     [ebp+var_10], eax
.text:000014EA                 mov     eax, dword ptr ds:___security_cookie
.text:000014EF                 xor     eax, ebp
.text:000014F1                 push    eax
.text:000014F2                 lea     eax, [ebp+var_C]
.text:000014F5                 mov     large fs:0, eax
.text:000014FB                 mov     [ebp+var_10], ecx
.text:000014FE                 mov     ecx, [ebp+arg_4]
.text:00001501                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00001506                 push    eax
.text:00001507                 mov     ecx, [ebp+var_10]
.text:0000150A                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:0000150F                 push    eax
.text:00001510                 call    ?CompareTwoNames@@YGIPB_W0@Z ; CompareTwoNames(wchar_t const *,wchar_t const *)
.text:00001515                 mov     [ebp+var_14], eax
.text:00001518                 mov     ecx, [ebp+var_10]
.text:0000151B                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00001520                 mov     ecx, [ebp+var_14]
.text:00001523                 movzx   edx, word ptr [eax+ecx*2]
.text:00001527                 test    edx, edx
.text:00001529                 jnz     short loc_1586
.text:0000152B                 mov     ecx, [ebp+arg_4]
.text:0000152E                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00001533                 mov     ecx, [ebp+var_14]
.text:00001536                 movzx   edx, word ptr [eax+ecx*2]
.text:0000153A                 test    edx, edx
.text:0000153C                 jz      short loc_1584
.text:0000153E                 mov     ecx, [ebp+arg_4]
.text:00001541                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00001546                 mov     ecx, [ebp+var_14]
.text:00001549                 movzx   edx, word ptr [eax+ecx*2]
.text:0000154D                 push    edx             ; wchar_t
.text:0000154E                 call    ?IsPathSepar@@YG_N_W@Z ; IsPathSepar(wchar_t)
.text:00001553                 movzx   eax, al
.text:00001556                 test    eax, eax
.text:00001558                 jnz     short loc_1584
.text:0000155A                 cmp     [ebp+var_14], 0
.text:0000155E                 jz      short loc_1584
.text:00001560                 mov     ecx, [ebp+arg_4]
.text:00001563                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00001568                 mov     ecx, [ebp+var_14]
.text:0000156B                 movzx   edx, word ptr [eax+ecx*2-2]
.text:00001570                 push    edx             ; wchar_t
.text:00001571                 call    ?IsPathSepar@@YG_N_W@Z ; IsPathSepar(wchar_t)
.text:00001576                 movzx   eax, al
.text:00001579                 test    eax, eax
.text:0000157B                 jnz     short loc_1584
.text:0000157D                 xor     al, al
.text:0000157F                 jmp     loc_161F
.text:00001584 ; ---------------------------------------------------------------------------
.text:00001584
.text:00001584 loc_1584:                               ; CODE XREF: CRenamePair::GetNewPath(bool,UString const &,UString &)+80j
.text:00001584                                         ; CRenamePair::GetNewPath(bool,UString const &,UString &)+9Cj ...
.text:00001584                 jmp     short loc_15D5
.text:00001586 ; ---------------------------------------------------------------------------
.text:00001586
.text:00001586 loc_1586:                               ; CODE XREF: CRenamePair::GetNewPath(bool,UString const &,UString &)+6Dj
.text:00001586                 movzx   ecx, [ebp+arg_0]
.text:0000158A                 test    ecx, ecx
.text:0000158C                 jz      short loc_15D1
.text:0000158E                 mov     ecx, [ebp+arg_4]
.text:00001591                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00001596                 mov     edx, [ebp+var_14]
.text:00001599                 movzx   eax, word ptr [eax+edx*2]
.text:0000159D                 test    eax, eax
.text:0000159F                 jnz     short loc_15D1
.text:000015A1                 mov     ecx, [ebp+var_10]
.text:000015A4                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000015A9                 mov     ecx, [ebp+var_14]
.text:000015AC                 movzx   edx, word ptr [eax+ecx*2]
.text:000015B0                 push    edx             ; wchar_t
.text:000015B1                 call    ?IsPathSepar@@YG_N_W@Z ; IsPathSepar(wchar_t)
.text:000015B6                 movzx   eax, al
.text:000015B9                 test    eax, eax
.text:000015BB                 jz      short loc_15D1
.text:000015BD                 mov     ecx, [ebp+var_10]
.text:000015C0                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000015C5                 mov     ecx, [ebp+var_14]
.text:000015C8                 movzx   edx, word ptr [eax+ecx*2+2]
.text:000015CD                 test    edx, edx
.text:000015CF                 jz      short loc_15D5
.text:000015D1
.text:000015D1 loc_15D1:                               ; CODE XREF: CRenamePair::GetNewPath(bool,UString const &,UString &)+D0j
.text:000015D1                                         ; CRenamePair::GetNewPath(bool,UString const &,UString &)+E3j ...
.text:000015D1                 xor     al, al
.text:000015D3                 jmp     short loc_161F
.text:000015D5 ; ---------------------------------------------------------------------------
.text:000015D5
.text:000015D5 loc_15D5:                               ; CODE XREF: CRenamePair::GetNewPath(bool,UString const &,UString &):loc_1584j
.text:000015D5                                         ; CRenamePair::GetNewPath(bool,UString const &,UString &)+113j
.text:000015D5                 mov     eax, [ebp+var_14]
.text:000015D8                 push    eax             ; unsigned int
.text:000015D9                 mov     ecx, [ebp+arg_4] ; this
.text:000015DC                 call    ?Ptr@UString@@QBEPB_WI@Z ; UString::Ptr(uint)
.text:000015E1                 push    eax
.text:000015E2                 mov     ecx, [ebp+var_10]
.text:000015E5                 add     ecx, 0Ch
.text:000015E8                 push    ecx
.text:000015E9                 lea     edx, [ebp+var_20]
.text:000015EC                 push    edx
.text:000015ED                 call    ??H@YG?AVUString@@ABV0@PB_W@Z ; operator+(UString const &,wchar_t const *)
.text:000015F2                 mov     [ebp+var_24], eax
.text:000015F5                 mov     eax, [ebp+var_24]
.text:000015F8                 mov     [ebp+var_28], eax
.text:000015FB                 mov     [ebp+var_4], 0
.text:00001602                 mov     ecx, [ebp+var_28]
.text:00001605                 push    ecx
.text:00001606                 mov     ecx, [ebp+arg_8]
.text:00001609                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:0000160E                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001615                 lea     ecx, [ebp+var_20] ; this
.text:00001618                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000161D                 mov     al, 1
.text:0000161F
.text:0000161F loc_161F:                               ; CODE XREF: CRenamePair::GetNewPath(bool,UString const &,UString &)+C3j
.text:0000161F                                         ; CRenamePair::GetNewPath(bool,UString const &,UString &)+117j
.text:0000161F                 mov     ecx, [ebp+var_C]
.text:00001622                 mov     large fs:0, ecx
.text:00001629                 pop     ecx
.text:0000162A                 add     esp, 28h
.text:0000162D                 cmp     ebp, esp
.text:0000162F                 call    __RTC_CheckEsp
.text:00001634                 mov     esp, ebp
.text:00001636                 pop     ebp
.text:00001637                 retn    0Ch
.text:00001637 ?GetNewPath@CRenamePair@@QBE_N_NABVUString@@AAV2@@Z endp
.text:00001637
.text:00001637 ; ---------------------------------------------------------------------------
.text:0000163A                 align 4
.text:0000163C
.text:0000163C ; =============== S U B R O U T I N E =======================================
.text:0000163C
.text:0000163C ; Attributes: bp-based frame
.text:0000163C
.text:0000163C ; unsigned int __stdcall CompareTwoNames(wchar_t const *, wchar_t const *)
.text:0000163C ?CompareTwoNames@@YGIPB_W0@Z proc near  ; CODE XREF: CRenamePair::GetNewPath(bool,UString const &,UString &)+54p
.text:0000163C
.text:0000163C var_C           = dword ptr -0Ch
.text:0000163C var_8           = dword ptr -8
.text:0000163C var_4           = dword ptr -4
.text:0000163C arg_0           = dword ptr  8
.text:0000163C arg_4           = dword ptr  0Ch
.text:0000163C
.text:0000163C                 push    ebp
.text:0000163D                 mov     ebp, esp
.text:0000163F                 sub     esp, 0Ch
.text:00001642                 push    esi
.text:00001643                 mov     [ebp+var_C], 0CCCCCCCCh
.text:0000164A                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00001651                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001658                 mov     [ebp+var_4], 0
.text:0000165F                 jmp     short loc_166A
.text:00001661 ; ---------------------------------------------------------------------------
.text:00001661
.text:00001661 loc_1661:                               ; CODE XREF: CompareTwoNames(wchar_t const *,wchar_t const *)+6Bj
.text:00001661                                         ; CompareTwoNames(wchar_t const *,wchar_t const *)+96j ...
.text:00001661                 mov     eax, [ebp+var_4]
.text:00001664                 add     eax, 1
.text:00001667                 mov     [ebp+var_4], eax
.text:0000166A
.text:0000166A loc_166A:                               ; CODE XREF: CompareTwoNames(wchar_t const *,wchar_t const *)+23j
.text:0000166A                 mov     ecx, [ebp+var_4]
.text:0000166D                 mov     edx, [ebp+arg_0]
.text:00001670                 mov     ax, [edx+ecx*2]
.text:00001674                 mov     word ptr [ebp+var_8], ax
.text:00001678                 mov     ecx, [ebp+var_4]
.text:0000167B                 mov     edx, [ebp+arg_4]
.text:0000167E                 mov     ax, [edx+ecx*2]
.text:00001682                 mov     word ptr [ebp+var_C], ax
.text:00001686                 movzx   ecx, word ptr [ebp+var_8]
.text:0000168A                 test    ecx, ecx
.text:0000168C                 jz      short loc_1696
.text:0000168E                 movzx   edx, word ptr [ebp+var_C]
.text:00001692                 test    edx, edx
.text:00001694                 jnz     short loc_169B
.text:00001696
.text:00001696 loc_1696:                               ; CODE XREF: CompareTwoNames(wchar_t const *,wchar_t const *)+50j
.text:00001696                 mov     eax, [ebp+var_4]
.text:00001699                 jmp     short loc_1705
.text:0000169B ; ---------------------------------------------------------------------------
.text:0000169B
.text:0000169B loc_169B:                               ; CODE XREF: CompareTwoNames(wchar_t const *,wchar_t const *)+58j
.text:0000169B                 movzx   eax, word ptr [ebp+var_8]
.text:0000169F                 movzx   ecx, word ptr [ebp+var_C]
.text:000016A3                 cmp     eax, ecx
.text:000016A5                 jnz     short loc_16A9
.text:000016A7                 jmp     short loc_1661
.text:000016A9 ; ---------------------------------------------------------------------------
.text:000016A9
.text:000016A9 loc_16A9:                               ; CODE XREF: CompareTwoNames(wchar_t const *,wchar_t const *)+69j
.text:000016A9                 movzx   edx, byte ptr ds:?g_CaseSensitive@@3_NA ; bool g_CaseSensitive
.text:000016B0                 test    edx, edx
.text:000016B2                 jnz     short loc_16D4
.text:000016B4                 movzx   eax, word ptr [ebp+var_8]
.text:000016B8                 push    eax             ; wchar_t
.text:000016B9                 call    ?MyCharUpper@@YG_W_W@Z ; MyCharUpper(wchar_t)
.text:000016BE                 movzx   esi, ax
.text:000016C1                 movzx   ecx, word ptr [ebp+var_C]
.text:000016C5                 push    ecx             ; wchar_t
.text:000016C6                 call    ?MyCharUpper@@YG_W_W@Z ; MyCharUpper(wchar_t)
.text:000016CB                 movzx   edx, ax
.text:000016CE                 cmp     esi, edx
.text:000016D0                 jnz     short loc_16D4
.text:000016D2                 jmp     short loc_1661
.text:000016D4 ; ---------------------------------------------------------------------------
.text:000016D4
.text:000016D4 loc_16D4:                               ; CODE XREF: CompareTwoNames(wchar_t const *,wchar_t const *)+76j
.text:000016D4                                         ; CompareTwoNames(wchar_t const *,wchar_t const *)+94j
.text:000016D4                 movzx   eax, word ptr [ebp+var_8]
.text:000016D8                 push    eax             ; wchar_t
.text:000016D9                 call    ?IsPathSepar@@YG_N_W@Z ; IsPathSepar(wchar_t)
.text:000016DE                 movzx   ecx, al
.text:000016E1                 test    ecx, ecx
.text:000016E3                 jz      short loc_16FB
.text:000016E5                 movzx   edx, word ptr [ebp+var_C]
.text:000016E9                 push    edx             ; wchar_t
.text:000016EA                 call    ?IsPathSepar@@YG_N_W@Z ; IsPathSepar(wchar_t)
.text:000016EF                 movzx   eax, al
.text:000016F2                 test    eax, eax
.text:000016F4                 jz      short loc_16FB
.text:000016F6                 jmp     loc_1661
.text:000016FB ; ---------------------------------------------------------------------------
.text:000016FB
.text:000016FB loc_16FB:                               ; CODE XREF: CompareTwoNames(wchar_t const *,wchar_t const *)+A7j
.text:000016FB                                         ; CompareTwoNames(wchar_t const *,wchar_t const *)+B8j
.text:000016FB                 mov     eax, [ebp+var_4]
.text:000016FE                 jmp     short loc_1705
.text:00001700 ; ---------------------------------------------------------------------------
.text:00001700                 jmp     loc_1661
.text:00001705 ; ---------------------------------------------------------------------------
.text:00001705
.text:00001705 loc_1705:                               ; CODE XREF: CompareTwoNames(wchar_t const *,wchar_t const *)+5Dj
.text:00001705                                         ; CompareTwoNames(wchar_t const *,wchar_t const *)+C2j
.text:00001705                 pop     esi
.text:00001706                 add     esp, 0Ch
.text:00001709                 cmp     ebp, esp
.text:0000170B                 call    __RTC_CheckEsp
.text:00001710                 mov     esp, ebp
.text:00001712                 pop     ebp
.text:00001713                 retn    8
.text:00001713 ?CompareTwoNames@@YGIPB_W0@Z endp
.text:00001713
.text:00001713 ; ---------------------------------------------------------------------------
.text:00001716                 db 6 dup(0CCh)
.text:0000171C
.text:0000171C ; =============== S U B R O U T I N E =======================================
.text:0000171C
.text:0000171C ; Attributes: bp-based frame
.text:0000171C
.text:0000171C ; long __stdcall UpdateArchive(class CCodecs *, class CObjectVector<struct COpenType> const &, class UString const &, class NWildcard::CCensor &, struct CUpdateOptions &, struct CUpdateErrorInfo &, struct IOpenCallbackUI *, struct IUpdateCallbackUI2 *, bool)
.text:0000171C                 public ?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z
.text:0000171C ?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z proc near
.text:0000171C
.text:0000171C var_728         = dword ptr -728h
.text:0000171C var_724         = dword ptr -724h
.text:0000171C var_71D         = byte ptr -71Dh
.text:0000171C var_71C         = dword ptr -71Ch
.text:0000171C var_718         = dword ptr -718h
.text:0000171C var_714         = dword ptr -714h
.text:0000171C var_70D         = byte ptr -70Dh
.text:0000171C var_70C         = dword ptr -70Ch
.text:0000171C var_708         = dword ptr -708h
.text:0000171C var_704         = dword ptr -704h
.text:0000171C var_700         = dword ptr -700h
.text:0000171C var_6FC         = dword ptr -6FCh
.text:0000171C var_6F8         = dword ptr -6F8h
.text:0000171C var_6F4         = dword ptr -6F4h
.text:0000171C var_6F0         = dword ptr -6F0h
.text:0000171C var_6EC         = dword ptr -6ECh
.text:0000171C var_6E8         = dword ptr -6E8h
.text:0000171C var_6E4         = dword ptr -6E4h
.text:0000171C var_6E0         = dword ptr -6E0h
.text:0000171C var_6DC         = dword ptr -6DCh
.text:0000171C var_6D8         = dword ptr -6D8h
.text:0000171C var_6D4         = dword ptr -6D4h
.text:0000171C var_6D0         = dword ptr -6D0h
.text:0000171C var_6CC         = dword ptr -6CCh
.text:0000171C var_6C8         = dword ptr -6C8h
.text:0000171C var_6C4         = dword ptr -6C4h
.text:0000171C var_6C0         = dword ptr -6C0h
.text:0000171C var_6BC         = dword ptr -6BCh
.text:0000171C var_6B8         = dword ptr -6B8h
.text:0000171C var_6B4         = dword ptr -6B4h
.text:0000171C var_6B0         = dword ptr -6B0h
.text:0000171C var_6AC         = byte ptr -6ACh
.text:0000171C var_6A0         = dword ptr -6A0h
.text:0000171C var_69C         = dword ptr -69Ch
.text:0000171C var_698         = dword ptr -698h
.text:0000171C var_694         = dword ptr -694h
.text:0000171C var_690         = dword ptr -690h
.text:0000171C var_68C         = dword ptr -68Ch
.text:0000171C var_688         = dword ptr -688h
.text:0000171C var_684         = byte ptr -684h
.text:0000171C var_678         = dword ptr -678h
.text:0000171C var_674         = dword ptr -674h
.text:0000171C var_670         = dword ptr -670h
.text:0000171C var_66C         = dword ptr -66Ch
.text:0000171C var_668         = dword ptr -668h
.text:0000171C var_664         = dword ptr -664h
.text:0000171C var_660         = dword ptr -660h
.text:0000171C var_65C         = dword ptr -65Ch
.text:0000171C var_658         = dword ptr -658h
.text:0000171C var_654         = dword ptr -654h
.text:0000171C var_650         = dword ptr -650h
.text:0000171C var_64C         = dword ptr -64Ch
.text:0000171C var_648         = dword ptr -648h
.text:0000171C var_644         = dword ptr -644h
.text:0000171C var_640         = dword ptr -640h
.text:0000171C var_63C         = word ptr -63Ch
.text:0000171C var_630         = dword ptr -630h
.text:0000171C var_62C         = dword ptr -62Ch
.text:0000171C var_628         = dword ptr -628h
.text:0000171C var_620         = word ptr -620h
.text:0000171C var_610         = dword ptr -610h
.text:0000171C var_608         = dword ptr -608h
.text:0000171C var_604         = dword ptr -604h
.text:0000171C var_5F8         = word ptr -5F8h
.text:0000171C var_5E8         = dword ptr -5E8h
.text:0000171C var_5E0         = byte ptr -5E0h
.text:0000171C var_5CC         = byte ptr -5CCh
.text:0000171C var_5B8         = byte ptr -5B8h
.text:0000171C var_5B4         = dword ptr -5B4h
.text:0000171C var_5AC         = dword ptr -5ACh
.text:0000171C var_598         = byte ptr -598h
.text:0000171C var_584         = byte ptr -584h
.text:0000171C var_564         = dword ptr -564h
.text:0000171C var_560         = dword ptr -560h
.text:0000171C var_55C         = dword ptr -55Ch
.text:0000171C var_558         = dword ptr -558h
.text:0000171C Dst             = byte ptr -54Ch
.text:0000171C var_544         = dword ptr -544h
.text:0000171C var_540         = dword ptr -540h
.text:0000171C var_53C         = dword ptr -53Ch
.text:0000171C var_52C         = byte ptr -52Ch
.text:0000171C var_518         = byte ptr -518h
.text:0000171C var_504         = byte ptr -504h
.text:0000171C var_4F0         = byte ptr -4F0h
.text:0000171C var_4DC         = byte ptr -4DCh
.text:0000171C var_4C4         = word ptr -4C4h
.text:0000171C var_4B0         = byte ptr -4B0h
.text:0000171C var_4A0         = dword ptr -4A0h
.text:0000171C var_49C         = dword ptr -49Ch
.text:0000171C var_494         = byte ptr -494h
.text:0000171C var_484         = dword ptr -484h
.text:0000171C var_47C         = byte ptr -47Ch
.text:0000171C var_470         = byte ptr -470h
.text:0000171C var_460         = dword ptr -460h
.text:0000171C var_45C         = dword ptr -45Ch
.text:0000171C var_458         = dword ptr -458h
.text:0000171C var_454         = dword ptr -454h
.text:0000171C var_450         = dword ptr -450h
.text:0000171C var_448         = dword ptr -448h
.text:0000171C var_43C         = dword ptr -43Ch
.text:0000171C var_435         = byte ptr -435h
.text:0000171C var_430         = byte ptr -430h
.text:0000171C var_420         = dword ptr -420h
.text:0000171C var_41C         = dword ptr -41Ch
.text:0000171C var_418         = dword ptr -418h
.text:0000171C var_410         = byte ptr -410h
.text:0000171C var_404         = dword ptr -404h
.text:0000171C var_3FC         = dword ptr -3FCh
.text:0000171C var_3E8         = byte ptr -3E8h
.text:0000171C var_3D8         = dword ptr -3D8h
.text:0000171C var_3D4         = dword ptr -3D4h
.text:0000171C var_3D0         = dword ptr -3D0h
.text:0000171C var_3C9         = byte ptr -3C9h
.text:0000171C var_3C4         = dword ptr -3C4h
.text:0000171C var_3B0         = byte ptr -3B0h
.text:0000171C var_399         = byte ptr -399h
.text:0000171C var_394         = byte ptr -394h
.text:0000171C var_380         = dword ptr -380h
.text:0000171C var_374         = byte ptr -374h
.text:0000171C var_360         = dword ptr -360h
.text:0000171C var_35C         = dword ptr -35Ch
.text:0000171C var_358         = dword ptr -358h
.text:0000171C var_354         = dword ptr -354h
.text:0000171C var_350         = dword ptr -350h
.text:0000171C var_34C         = dword ptr -34Ch
.text:0000171C var_348         = dword ptr -348h
.text:0000171C var_344         = dword ptr -344h
.text:0000171C var_340         = dword ptr -340h
.text:0000171C var_324         = dword ptr -324h
.text:0000171C var_320         = dword ptr -320h
.text:0000171C var_31C         = dword ptr -31Ch
.text:0000171C var_318         = dword ptr -318h
.text:0000171C var_311         = byte ptr -311h
.text:0000171C var_30C         = dword ptr -30Ch
.text:0000171C var_308         = dword ptr -308h
.text:0000171C var_304         = dword ptr -304h
.text:0000171C var_300         = dword ptr -300h
.text:0000171C var_2FC         = dword ptr -2FCh
.text:0000171C var_2F8         = dword ptr -2F8h
.text:0000171C var_2F4         = dword ptr -2F4h
.text:0000171C var_2F0         = dword ptr -2F0h
.text:0000171C var_2EC         = byte ptr -2ECh
.text:0000171C var_2D0         = dword ptr -2D0h
.text:0000171C var_2B8         = dword ptr -2B8h
.text:0000171C var_2B0         = dword ptr -2B0h
.text:0000171C var_2AC         = dword ptr -2ACh
.text:0000171C var_2A8         = dword ptr -2A8h
.text:0000171C var_2A4         = dword ptr -2A4h
.text:0000171C var_2A0         = dword ptr -2A0h
.text:0000171C var_29C         = dword ptr -29Ch
.text:0000171C var_298         = dword ptr -298h
.text:0000171C var_294         = dword ptr -294h
.text:0000171C var_274         = dword ptr -274h
.text:0000171C var_268         = dword ptr -268h
.text:0000171C var_258         = dword ptr -258h
.text:0000171C var_234         = byte ptr -234h
.text:0000171C var_228         = byte ptr -228h
.text:0000171C var_227         = byte ptr -227h
.text:0000171C var_220         = byte ptr -220h
.text:0000171C var_1C3         = byte ptr -1C3h
.text:0000171C var_1C0         = dword ptr -1C0h
.text:0000171C var_1B1         = byte ptr -1B1h
.text:0000171C var_1B0         = dword ptr -1B0h
.text:0000171C var_1AC         = dword ptr -1ACh
.text:0000171C var_1A8         = dword ptr -1A8h
.text:0000171C var_1A4         = dword ptr -1A4h
.text:0000171C var_1A0         = dword ptr -1A0h
.text:0000171C var_19C         = dword ptr -19Ch
.text:0000171C var_194         = dword ptr -194h
.text:0000171C var_16C         = dword ptr -16Ch
.text:0000171C var_168         = dword ptr -168h
.text:0000171C var_164         = dword ptr -164h
.text:0000171C var_154         = dword ptr -154h
.text:0000171C var_150         = byte ptr -150h
.text:0000171C var_14C         = byte ptr -14Ch
.text:0000171C var_134         = byte ptr -134h
.text:0000171C var_120         = byte ptr -120h
.text:0000171C var_10C         = byte ptr -10Ch
.text:0000171C var_F4          = dword ptr -0F4h
.text:0000171C var_F0          = dword ptr -0F0h
.text:0000171C var_E7          = byte ptr -0E7h
.text:0000171C var_CC          = byte ptr -0CCh
.text:0000171C var_B8          = byte ptr -0B8h
.text:0000171C var_AC          = byte ptr -0ACh
.text:0000171C var_98          = byte ptr -98h
.text:0000171C var_7C          = dword ptr -7Ch
.text:0000171C var_50          = byte ptr -50h
.text:0000171C var_3D          = byte ptr -3Dh
.text:0000171C var_38          = byte ptr -38h
.text:0000171C var_1C          = dword ptr -1Ch
.text:0000171C var_18          = dword ptr -18h
.text:0000171C var_11          = byte ptr -11h
.text:0000171C var_10          = dword ptr -10h
.text:0000171C var_C           = dword ptr -0Ch
.text:0000171C var_4           = dword ptr -4
.text:0000171C arg_0           = dword ptr  8
.text:0000171C arg_4           = dword ptr  0Ch
.text:0000171C arg_8           = dword ptr  10h
.text:0000171C arg_C           = dword ptr  14h
.text:0000171C arg_10          = dword ptr  18h
.text:0000171C arg_14          = dword ptr  1Ch
.text:0000171C arg_18          = dword ptr  20h
.text:0000171C arg_1C          = dword ptr  24h
.text:0000171C arg_20          = byte ptr  28h
.text:0000171C
.text:0000171C ; FUNCTION CHUNK AT .text:00003442 SIZE 00000B90 BYTES
.text:0000171C
.text:0000171C                 push    ebp
.text:0000171D                 mov     ebp, esp
.text:0000171F                 push    0FFFFFFFFh
.text:00001721                 push    offset __ehhandler$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z
.text:00001726                 mov     eax, large fs:0
.text:0000172C                 push    eax
.text:0000172D                 push    ecx
.text:0000172E                 sub     esp, 718h
.text:00001734                 push    ebx
.text:00001735                 push    esi
.text:00001736                 push    edi             ; struct UString *
.text:00001737                 lea     edi, [ebp+var_728]
.text:0000173D                 mov     ecx, 1C6h
.text:00001742                 mov     eax, 0CCCCCCCCh
.text:00001747                 rep stosd
.text:00001749                 mov     eax, dword ptr ds:___security_cookie
.text:0000174E                 xor     eax, ebp
.text:00001750                 push    eax             ; wchar_t *
.text:00001751                 lea     eax, [ebp+var_C]
.text:00001754                 mov     large fs:0, eax
.text:0000175A                 mov     [ebp+var_10], esp
.text:0000175D                 mov     eax, [ebp+arg_10]
.text:00001760                 movzx   ecx, byte ptr [eax+0C4h]
.text:00001767                 test    ecx, ecx
.text:00001769                 jz      short loc_1783
.text:0000176B                 mov     edx, [ebp+arg_10]
.text:0000176E                 movzx   eax, byte ptr [edx+0C5h]
.text:00001775                 test    eax, eax
.text:00001777                 jz      short loc_1783
.text:00001779                 mov     eax, 80004005h
.text:0000177E                 jmp     loc_3FA0
.text:00001783 ; ---------------------------------------------------------------------------
.text:00001783
.text:00001783 loc_1783:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+4Dj
.text:00001783                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+5Bj
.text:00001783                 mov     ecx, [ebp+arg_4]
.text:00001786                 call    ?Size@?$CObjectVector@UCOpenType@@@@QBEIXZ ; CObjectVector<COpenType>::Size(void)
.text:0000178B                 cmp     eax, 1
.text:0000178E                 jbe     short loc_179A
.text:00001790                 mov     eax, 80004001h
.text:00001795                 jmp     loc_3FA0
.text:0000179A ; ---------------------------------------------------------------------------
.text:0000179A
.text:0000179A loc_179A:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+72j
.text:0000179A                 mov     ecx, [ebp+arg_10]
.text:0000179D                 add     ecx, 0FCh ; 'n'
.text:000017A3                 call    ?IsEmpty@?$CObjectVector@UCRenamePair@@@@QBE_NXZ ; CObjectVector<CRenamePair>::IsEmpty(void)
.text:000017A8                 movzx   ecx, al
.text:000017AB                 neg     ecx
.text:000017AD                 sbb     ecx, ecx
.text:000017AF                 add     ecx, 1
.text:000017B2                 mov     [ebp+var_11], cl
.text:000017B5                 movzx   edx, [ebp+var_11]
.text:000017B9                 test    edx, edx
.text:000017BB                 jz      short loc_17D7
.text:000017BD                 mov     ecx, [ebp+arg_10]
.text:000017C0                 add     ecx, 38h ; '8'
.text:000017C3                 call    ?Size@?$CObjectVector@UCUpdateArchiveCommand@@@@QBEIXZ ; CObjectVector<CUpdateArchiveCommand>::Size(void)
.text:000017C8                 cmp     eax, 1
.text:000017CB                 jz      short loc_17D7
.text:000017CD                 mov     eax, 80004005h
.text:000017D2                 jmp     loc_3FA0
.text:000017D7 ; ---------------------------------------------------------------------------
.text:000017D7
.text:000017D7 loc_17D7:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+9Fj
.text:000017D7                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+AFj
.text:000017D7                 mov     eax, [ebp+arg_10]
.text:000017DA                 movzx   ecx, byte ptr [eax+0F8h]
.text:000017E1                 test    ecx, ecx
.text:000017E3                 jz      short loc_1842
.text:000017E5                 mov     ecx, [ebp+arg_10]
.text:000017E8                 add     ecx, 38h ; '8'
.text:000017EB                 call    ?Size@?$CObjectVector@UCUpdateArchiveCommand@@@@QBEIXZ ; CObjectVector<CUpdateArchiveCommand>::Size(void)
.text:000017F0                 cmp     eax, 1
.text:000017F3                 jz      short loc_17FF
.text:000017F5                 mov     eax, 80004001h
.text:000017FA                 jmp     loc_3FA0
.text:000017FF ; ---------------------------------------------------------------------------
.text:000017FF
.text:000017FF loc_17FF:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+D7j
.text:000017FF                 push    0
.text:00001801                 mov     ecx, [ebp+arg_10]
.text:00001804                 add     ecx, 38h ; '8'
.text:00001807                 call    ??A?$CObjectVector@UCUpdateArchiveCommand@@@@QAEAAUCUpdateArchiveCommand@@I@Z ; CObjectVector<CUpdateArchiveCommand>::operator[](uint)
.text:0000180C                 add     eax, 64h ; 'd'
.text:0000180F                 mov     [ebp+var_18], eax
.text:00001812                 mov     [ebp+var_1C], 2
.text:00001819                 jmp     short loc_1824
.text:0000181B ; ---------------------------------------------------------------------------
.text:0000181B
.text:0000181B loc_181B:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool):loc_1840j
.text:0000181B                 mov     edx, [ebp+var_1C]
.text:0000181E                 add     edx, 1
.text:00001821                 mov     [ebp+var_1C], edx
.text:00001824
.text:00001824 loc_1824:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+FDj
.text:00001824                 cmp     [ebp+var_1C], 7
.text:00001828                 jnb     short loc_1842
.text:0000182A                 mov     eax, [ebp+var_1C]
.text:0000182D                 mov     ecx, [ebp+var_18]
.text:00001830                 cmp     dword ptr [ecx+eax*4], 2
.text:00001834                 jz      short loc_1840
.text:00001836                 mov     eax, 80004001h
.text:0000183B                 jmp     loc_3FA0
.text:00001840 ; ---------------------------------------------------------------------------
.text:00001840
.text:00001840 loc_1840:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+118j
.text:00001840                 jmp     short loc_181B
.text:00001842 ; ---------------------------------------------------------------------------
.text:00001842
.text:00001842 loc_1842:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+C7j
.text:00001842                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+10Cj
.text:00001842                 mov     edx, [ebp+arg_10]
.text:00001845                 mov     eax, [edx+0E0h]
.text:0000184B                 push    eax
.text:0000184C                 mov     ecx, [ebp+arg_C]
.text:0000184F                 call    ?AddPathsToCensor@CCensor@NWildcard@@QAEXW4ECensorPathMode@2@@Z ; NWildcard::CCensor::AddPathsToCensor(NWildcard::ECensorPathMode)
.text:00001854                 mov     ecx, [ebp+arg_C]
.text:00001857                 push    ecx             ; struct NWildcard::CCensor *
.text:00001858                 call    ?ConvertToLongNames@@YGXAAVCCensor@NWildcard@@@Z ; ConvertToLongNames(NWildcard::CCensor &)
.text:0000185D                 mov     ecx, [ebp+arg_C] ; this
.text:00001860                 call    ?ExtendExclude@CCensor@NWildcard@@QAEXXZ ; NWildcard::CCensor::ExtendExclude(void)
.text:00001865                 mov     ecx, [ebp+arg_10]
.text:00001868                 add     ecx, 108h
.text:0000186E                 call    ?Size@?$CRecordVector@_K@@QBEIXZ ; CRecordVector<unsigned __int64>::Size(void)
.text:00001873                 test    eax, eax
.text:00001875                 jbe     short loc_188F
.text:00001877                 mov     edx, [ebp+arg_10]
.text:0000187A                 movzx   eax, byte ptr [edx+0C5h]
.text:00001881                 test    eax, eax
.text:00001883                 jz      short loc_188F
.text:00001885                 mov     eax, 80004001h
.text:0000188A                 jmp     loc_3FA0
.text:0000188F ; ---------------------------------------------------------------------------
.text:0000188F
.text:0000188F loc_188F:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+159j
.text:0000188F                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+167j
.text:0000188F                 mov     ecx, [ebp+arg_10]
.text:00001892                 movzx   edx, byte ptr [ecx+0A4h]
.text:00001899                 test    edx, edx
.text:0000189B                 jz      loc_1A1C
.text:000018A1                 lea     ecx, [ebp+var_38] ; this
.text:000018A4                 call    ??0CProperty@@QAE@XZ ; CProperty::CProperty(void)
.text:000018A9                 mov     [ebp+var_4], 0
.text:000018B0                 push    offset $SG75347 ; "rsfx"
.text:000018B5                 lea     ecx, [ebp+var_38] ; this
.text:000018B8                 call    ?SetFromAscii@UString@@QAEXPBD@Z ; UString::SetFromAscii(char const *)
.text:000018BD                 lea     eax, [ebp+var_38]
.text:000018C0                 push    eax
.text:000018C1                 mov     ecx, [ebp+arg_10]
.text:000018C4                 add     ecx, 28h ; '('
.text:000018C7                 call    ?Add@?$CObjectVector@UCProperty@@@@QAEIABUCProperty@@@Z ; CObjectVector<CProperty>::Add(CProperty const &)
.text:000018CC                 mov     ecx, [ebp+arg_10]
.text:000018CF                 add     ecx, 0A8h ; '' ; this
.text:000018D5                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:000018DA                 movzx   ecx, al
.text:000018DD                 test    ecx, ecx
.text:000018DF                 jz      short loc_1915
.text:000018E1                 push    offset $SG75349 ; "SFX file is not specified"
.text:000018E6                 mov     ecx, [ebp+arg_14]
.text:000018E9                 add     ecx, 4
.text:000018EC                 call    ??4AString@@QAEAAV0@PBD@Z ; AString::operator=(char const *)
.text:000018F1                 mov     [ebp+var_630], 80004005h
.text:000018FB                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001902                 lea     ecx, [ebp+var_38] ; this
.text:00001905                 call    ??1CProperty@@QAE@XZ ; CProperty::~CProperty(void)
.text:0000190A                 mov     eax, [ebp+var_630]
.text:00001910                 jmp     loc_3FA0
.text:00001915 ; ---------------------------------------------------------------------------
.text:00001915
.text:00001915 loc_1915:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1C3j
.text:00001915                 mov     [ebp+var_3D], 0
.text:00001919                 push    5Ch ; '\'       ; wchar_t
.text:0000191B                 mov     ecx, [ebp+arg_10]
.text:0000191E                 add     ecx, 0A8h ; '' ; this
.text:00001924                 call    ?Find@UString@@QBEH_W@Z ; UString::Find(wchar_t)
.text:00001929                 test    eax, eax
.text:0000192B                 jge     loc_19B3
.text:00001931                 lea     edx, [ebp+var_63C]
.text:00001937                 push    edx             ; wchar_t *
.text:00001938                 call    ?GetModuleDirPrefix@NDLL@NWindows@@YG?AVUString@@XZ ; NWindows::NDLL::GetModuleDirPrefix(void)
.text:0000193D                 mov     [ebp+var_6E4], eax
.text:00001943                 mov     eax, [ebp+var_6E4]
.text:00001949                 mov     [ebp+var_6E8], eax
.text:0000194F                 mov     byte ptr [ebp+var_4], 1
.text:00001953                 mov     ecx, [ebp+arg_10]
.text:00001956                 add     ecx, 0A8h ; ''
.text:0000195C                 push    ecx
.text:0000195D                 mov     edx, [ebp+var_6E8]
.text:00001963                 push    edx
.text:00001964                 lea     eax, [ebp+var_50]
.text:00001967                 push    eax
.text:00001968                 call    ??H@YG?AVUString@@ABV0@0@Z ; operator+(UString const &,UString const &)
.text:0000196D                 mov     byte ptr [ebp+var_4], 3
.text:00001971                 lea     ecx, [ebp+var_63C] ; this
.text:00001977                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000197C                 lea     ecx, [ebp+var_50]
.text:0000197F                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00001984                 push    eax             ; struct _FILETIME *
.text:00001985                 call    ?DoesFileExist@NFind@NFile@NWindows@@YG_NPB_W@Z ; NWindows::NFile::NFind::DoesFileExist(wchar_t const *)
.text:0000198A                 movzx   ecx, al
.text:0000198D                 test    ecx, ecx
.text:0000198F                 jz      short loc_19A7
.text:00001991                 lea     edx, [ebp+var_50]
.text:00001994                 push    edx
.text:00001995                 mov     ecx, [ebp+arg_10]
.text:00001998                 add     ecx, 0A8h ; ''
.text:0000199E                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:000019A3                 mov     [ebp+var_3D], 1
.text:000019A7
.text:000019A7 loc_19A7:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+273j
.text:000019A7                 mov     byte ptr [ebp+var_4], 0
.text:000019AB                 lea     ecx, [ebp+var_50] ; this
.text:000019AE                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000019B3
.text:000019B3 loc_19B3:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+20Fj
.text:000019B3                 movzx   eax, [ebp+var_3D]
.text:000019B7                 test    eax, eax
.text:000019B9                 jnz     short loc_1A0D
.text:000019BB                 mov     ecx, [ebp+arg_10]
.text:000019BE                 add     ecx, 0A8h ; ''
.text:000019C4                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000019C9                 push    eax             ; this
.text:000019CA                 call    ?DoesFileExist@NFind@NFile@NWindows@@YG_NPB_W@Z ; NWindows::NFile::NFind::DoesFileExist(wchar_t const *)
.text:000019CF                 movzx   ecx, al
.text:000019D2                 test    ecx, ecx
.text:000019D4                 jnz     short loc_1A0D
.text:000019D6                 mov     edx, [ebp+arg_10]
.text:000019D9                 add     edx, 0A8h ; ''
.text:000019DF                 push    edx             ; struct UString *
.text:000019E0                 push    offset $SG75361 ; "cannot find specified SFX module"
.text:000019E5                 mov     ecx, [ebp+arg_14] ; this
.text:000019E8                 call    ?SetFromLastError@CUpdateErrorInfo@@QAEJPBDABVUString@@@Z ; CUpdateErrorInfo::SetFromLastError(char const *,UString const &)
.text:000019ED                 mov     [ebp+var_640], eax
.text:000019F3                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000019FA                 lea     ecx, [ebp+var_38] ; this
.text:000019FD                 call    ??1CProperty@@QAE@XZ ; CProperty::~CProperty(void)
.text:00001A02                 mov     eax, [ebp+var_640]
.text:00001A08                 jmp     loc_3FA0
.text:00001A0D ; ---------------------------------------------------------------------------
.text:00001A0D
.text:00001A0D loc_1A0D:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+29Dj
.text:00001A0D                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+2B8j
.text:00001A0D                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001A14                 lea     ecx, [ebp+var_38] ; this
.text:00001A17                 call    ??1CProperty@@QAE@XZ ; CProperty::~CProperty(void)
.text:00001A1C
.text:00001A1C loc_1A1C:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+17Fj
.text:00001A1C                 lea     ecx, [ebp+var_B8]
.text:00001A22                 call    ??0CArchiveLink@@QAE@XZ ; CArchiveLink::CArchiveLink(void)
.text:00001A27                 mov     [ebp+var_4], 4
.text:00001A2E                 movzx   eax, [ebp+arg_20]
.text:00001A32                 test    eax, eax
.text:00001A34                 jz      short loc_1A8F
.text:00001A36                 mov     ecx, [ebp+arg_8]
.text:00001A39                 push    ecx             ; struct UString *
.text:00001A3A                 mov     edx, [ebp+arg_4]
.text:00001A3D                 push    edx             ; int
.text:00001A3E                 mov     eax, [ebp+arg_0]
.text:00001A41                 push    eax             ; CCodecs *
.text:00001A42                 mov     ecx, [ebp+arg_10]
.text:00001A45                 call    ?InitFormatIndex@CUpdateOptions@@QAE_NPBVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@@Z ; CUpdateOptions::InitFormatIndex(CCodecs const *,CObjectVector<COpenType> const &,UString const &)
.text:00001A4A                 movzx   ecx, al
.text:00001A4D                 test    ecx, ecx
.text:00001A4F                 jz      short loc_1A68
.text:00001A51                 mov     edx, [ebp+arg_8]
.text:00001A54                 push    edx             ; struct UString *
.text:00001A55                 mov     eax, [ebp+arg_0]
.text:00001A58                 push    eax             ; struct CCodecs *
.text:00001A59                 mov     ecx, [ebp+arg_10] ; this
.text:00001A5C                 call    ?SetArcPath@CUpdateOptions@@QAE_NPBVCCodecs@@ABVUString@@@Z ; CUpdateOptions::SetArcPath(CCodecs const *,UString const &)
.text:00001A61                 movzx   ecx, al
.text:00001A64                 test    ecx, ecx
.text:00001A66                 jnz     short loc_1A8F
.text:00001A68
.text:00001A68 loc_1A68:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+333j
.text:00001A68                 mov     [ebp+var_644], 80004001h
.text:00001A72                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001A79                 lea     ecx, [ebp+var_B8] ; this
.text:00001A7F                 call    ??1CArchiveLink@@QAE@XZ ; CArchiveLink::~CArchiveLink(void)
.text:00001A84                 mov     eax, [ebp+var_644]
.text:00001A8A                 jmp     loc_3FA0
.text:00001A8F ; ---------------------------------------------------------------------------
.text:00001A8F
.text:00001A8F loc_1A8F:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+318j
.text:00001A8F                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+34Aj
.text:00001A8F                 lea     edx, [ebp+var_CC]
.text:00001A95                 push    edx
.text:00001A96                 mov     ecx, [ebp+arg_10]
.text:00001A99                 add     ecx, 48h ; 'H'
.text:00001A9C                 call    ?GetFinalPath@CArchivePath@@QBE?AVUString@@XZ ; CArchivePath::GetFinalPath(void)
.text:00001AA1                 mov     byte ptr [ebp+var_4], 5
.text:00001AA5                 mov     ecx, [ebp+arg_8] ; this
.text:00001AA8                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:00001AAD                 movzx   eax, al
.text:00001AB0                 test    eax, eax
.text:00001AB2                 jz      short loc_1ADD
.text:00001AB4                 mov     ecx, [ebp+arg_10]
.text:00001AB7                 cmp     dword ptr [ecx+8], 0
.text:00001ABB                 jge     short loc_1AD8
.text:00001ABD                 mov     [ebp+var_648], offset $SG75374 ; "type of archive is not specified"
.text:00001AC7                 push    offset __TI2PAD
.text:00001ACC                 lea     edx, [ebp+var_648]
.text:00001AD2                 push    edx
.text:00001AD3                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:00001AD8 ; ---------------------------------------------------------------------------
.text:00001AD8
.text:00001AD8 loc_1AD8:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+39Fj
.text:00001AD8                 jmp     loc_221C
.text:00001ADD ; ---------------------------------------------------------------------------
.text:00001ADD
.text:00001ADD loc_1ADD:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+396j
.text:00001ADD                 lea     ecx, [ebp+var_10C] ; this
.text:00001AE3                 call    ??0CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::CFileInfo(void)
.text:00001AE8                 mov     byte ptr [ebp+var_4], 6
.text:00001AEC                 lea     ecx, [ebp+var_CC]
.text:00001AF2                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00001AF7                 push    eax             ; wchar_t *
.text:00001AF8                 lea     ecx, [ebp+var_10C] ; this
.text:00001AFE                 call    ?Find@CFileInfo@NFind@NFile@NWindows@@QAE_NPB_W@Z ; NWindows::NFile::NFind::CFileInfo::Find(wchar_t const *)
.text:00001B03                 movzx   eax, al
.text:00001B06                 test    eax, eax
.text:00001B08                 jnz     loc_1B9B
.text:00001B0E                 movzx   ecx, [ebp+var_11]
.text:00001B12                 test    ecx, ecx
.text:00001B14                 jz      short loc_1B31
.text:00001B16                 mov     [ebp+var_64C], offset $SG75380 ; "can't find archive"
.text:00001B20                 push    offset __TI2PAD
.text:00001B25                 lea     edx, [ebp+var_64C]
.text:00001B2B                 push    edx
.text:00001B2C                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:00001B31 ; ---------------------------------------------------------------------------
.text:00001B31
.text:00001B31 loc_1B31:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+3F8j
.text:00001B31                 mov     eax, [ebp+arg_10]
.text:00001B34                 cmp     dword ptr [eax+8], 0
.text:00001B38                 jge     short loc_1B96
.text:00001B3A                 mov     ecx, [ebp+arg_8]
.text:00001B3D                 push    ecx             ; struct UString *
.text:00001B3E                 mov     edx, [ebp+arg_0]
.text:00001B41                 push    edx             ; struct CCodecs *
.text:00001B42                 mov     ecx, [ebp+arg_10] ; this
.text:00001B45                 call    ?SetArcPath@CUpdateOptions@@QAE_NPBVCCodecs@@ABVUString@@@Z ; CUpdateOptions::SetArcPath(CCodecs const *,UString const &)
.text:00001B4A                 movzx   eax, al
.text:00001B4D                 test    eax, eax
.text:00001B4F                 jnz     short loc_1B96
.text:00001B51                 mov     [ebp+var_650], 80004001h
.text:00001B5B                 mov     byte ptr [ebp+var_4], 5
.text:00001B5F                 lea     ecx, [ebp+var_10C] ; this
.text:00001B65                 call    ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text:00001B6A                 mov     byte ptr [ebp+var_4], 4
.text:00001B6E                 lea     ecx, [ebp+var_CC] ; this
.text:00001B74                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00001B79                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001B80                 lea     ecx, [ebp+var_B8] ; this
.text:00001B86                 call    ??1CArchiveLink@@QAE@XZ ; CArchiveLink::~CArchiveLink(void)
.text:00001B8B                 mov     eax, [ebp+var_650]
.text:00001B91                 jmp     loc_3FA0
.text:00001B96 ; ---------------------------------------------------------------------------
.text:00001B96
.text:00001B96 loc_1B96:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+41Cj
.text:00001B96                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+433j
.text:00001B96                 jmp     loc_220D
.text:00001B9B ; ---------------------------------------------------------------------------
.text:00001B9B
.text:00001B9B loc_1B9B:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+3ECj
.text:00001B9B                 lea     ecx, [ebp+var_10C] ; this
.text:00001BA1                 call    ?IsDir@CFileInfoBase@NFind@NFile@NWindows@@QBE_NXZ ; NWindows::NFile::NFind::CFileInfoBase::IsDir(void)
.text:00001BA6                 movzx   ecx, al
.text:00001BA9                 test    ecx, ecx
.text:00001BAB                 jz      short loc_1BC8
.text:00001BAD                 mov     [ebp+var_654], offset $SG75388 ; "there is no such archive"
.text:00001BB7                 push    offset __TI2PAD
.text:00001BBC                 lea     edx, [ebp+var_654]
.text:00001BC2                 push    edx
.text:00001BC3                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:00001BC8 ; ---------------------------------------------------------------------------
.text:00001BC8
.text:00001BC8 loc_1BC8:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+48Fj
.text:00001BC8                 movzx   eax, [ebp+var_E7]
.text:00001BCF                 test    eax, eax
.text:00001BD1                 jz      short loc_1C18
.text:00001BD3                 mov     [ebp+var_658], 80004001h
.text:00001BDD                 mov     byte ptr [ebp+var_4], 5
.text:00001BE1                 lea     ecx, [ebp+var_10C] ; this
.text:00001BE7                 call    ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text:00001BEC                 mov     byte ptr [ebp+var_4], 4
.text:00001BF0                 lea     ecx, [ebp+var_CC] ; this
.text:00001BF6                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00001BFB                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001C02                 lea     ecx, [ebp+var_B8] ; this
.text:00001C08                 call    ??1CArchiveLink@@QAE@XZ ; CArchiveLink::~CArchiveLink(void)
.text:00001C0D                 mov     eax, [ebp+var_658]
.text:00001C13                 jmp     loc_3FA0
.text:00001C18 ; ---------------------------------------------------------------------------
.text:00001C18
.text:00001C18 loc_1C18:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+4B5j
.text:00001C18                 mov     ecx, [ebp+arg_10]
.text:00001C1B                 add     ecx, 108h
.text:00001C21                 call    ?Size@?$CRecordVector@_K@@QBEIXZ ; CRecordVector<unsigned __int64>::Size(void)
.text:00001C26                 test    eax, eax
.text:00001C28                 jbe     short loc_1C6F
.text:00001C2A                 mov     [ebp+var_65C], 80004001h
.text:00001C34                 mov     byte ptr [ebp+var_4], 5
.text:00001C38                 lea     ecx, [ebp+var_10C] ; this
.text:00001C3E                 call    ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text:00001C43                 mov     byte ptr [ebp+var_4], 4
.text:00001C47                 lea     ecx, [ebp+var_CC] ; this
.text:00001C4D                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00001C52                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001C59                 lea     ecx, [ebp+var_B8] ; this
.text:00001C5F                 call    ??1CArchiveLink@@QAE@XZ ; CArchiveLink::~CArchiveLink(void)
.text:00001C64                 mov     eax, [ebp+var_65C]
.text:00001C6A                 jmp     loc_3FA0
.text:00001C6F ; ---------------------------------------------------------------------------
.text:00001C6F
.text:00001C6F loc_1C6F:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+50Cj
.text:00001C6F                 lea     ecx, [ebp+var_120]
.text:00001C75                 call    ??0?$CObjectVector@UCOpenType@@@@QAE@XZ ; CObjectVector<COpenType>::CObjectVector<COpenType>(void)
.text:00001C7A                 mov     byte ptr [ebp+var_4], 7
.text:00001C7E                 mov     ecx, [ebp+arg_10]
.text:00001C81                 movzx   edx, byte ptr [ecx]
.text:00001C84                 test    edx, edx
.text:00001C86                 jz      short loc_1C9A
.text:00001C88                 mov     eax, [ebp+arg_10]
.text:00001C8B                 add     eax, 8
.text:00001C8E                 push    eax
.text:00001C8F                 lea     ecx, [ebp+var_120]
.text:00001C95                 call    ?Add@?$CObjectVector@UCOpenType@@@@QAEIABUCOpenType@@@Z ; CObjectVector<COpenType>::Add(COpenType const &)
.text:00001C9A
.text:00001C9A loc_1C9A:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+56Aj
.text:00001C9A                 lea     ecx, [ebp+var_134]
.text:00001CA0                 call    ??0?$CRecordVector@H@@QAE@XZ ; CRecordVector<int>::CRecordVector<int>(void)
.text:00001CA5                 mov     byte ptr [ebp+var_4], 8
.text:00001CA9                 lea     ecx, [ebp+var_194] ; this
.text:00001CAF                 call    ??0COpenOptions@@QAE@XZ ; COpenOptions::COpenOptions(void)
.text:00001CB4                 mov     byte ptr [ebp+var_4], 9
.text:00001CB8                 mov     ecx, [ebp+arg_10]
.text:00001CBB                 add     ecx, 28h ; '('
.text:00001CBE                 mov     [ebp+var_154], ecx
.text:00001CC4                 mov     edx, [ebp+arg_0]
.text:00001CC7                 mov     [ebp+var_194], edx
.text:00001CCD                 lea     eax, [ebp+var_120]
.text:00001CD3                 mov     [ebp+var_16C], eax
.text:00001CD9                 lea     ecx, [ebp+var_134]
.text:00001CDF                 mov     [ebp+var_168], ecx
.text:00001CE5                 mov     [ebp+var_150], 0
.text:00001CEC                 mov     [ebp+var_164], 0
.text:00001CF6                 lea     edx, [ebp+var_CC]
.text:00001CFC                 push    edx
.text:00001CFD                 lea     ecx, [ebp+var_14C]
.text:00001D03                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:00001D08                 lea     ecx, [ebp+var_CC]
.text:00001D0E                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00001D13                 mov     esi, esp
.text:00001D15                 push    eax
.text:00001D16                 mov     eax, [ebp+arg_1C]
.text:00001D19                 mov     edx, [eax]
.text:00001D1B                 mov     ecx, [ebp+arg_1C]
.text:00001D1E                 mov     eax, [edx+48h]
.text:00001D21                 call    eax
.text:00001D23                 cmp     esi, esp
.text:00001D25                 call    __RTC_CheckEsp
.text:00001D2A                 mov     [ebp+var_19C], eax
.text:00001D30                 cmp     [ebp+var_19C], 0
.text:00001D37                 jz      short loc_1DAD
.text:00001D39                 mov     ecx, [ebp+var_19C]
.text:00001D3F                 mov     [ebp+var_660], ecx
.text:00001D45                 mov     byte ptr [ebp+var_4], 8
.text:00001D49                 lea     ecx, [ebp+var_194] ; this
.text:00001D4F                 call    ??1COpenOptions@@QAE@XZ ; COpenOptions::~COpenOptions(void)
.text:00001D54                 mov     byte ptr [ebp+var_4], 7
.text:00001D58                 lea     ecx, [ebp+var_134]
.text:00001D5E                 call    ??1?$CRecordVector@H@@QAE@XZ ; CRecordVector<int>::~CRecordVector<int>(void)
.text:00001D63                 mov     byte ptr [ebp+var_4], 6
.text:00001D67                 lea     ecx, [ebp+var_120]
.text:00001D6D                 call    ??1?$CObjectVector@UCOpenType@@@@QAE@XZ ; CObjectVector<COpenType>::~CObjectVector<COpenType>(void)
.text:00001D72                 mov     byte ptr [ebp+var_4], 5
.text:00001D76                 lea     ecx, [ebp+var_10C] ; this
.text:00001D7C                 call    ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text:00001D81                 mov     byte ptr [ebp+var_4], 4
.text:00001D85                 lea     ecx, [ebp+var_CC] ; this
.text:00001D8B                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00001D90                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001D97                 lea     ecx, [ebp+var_B8] ; this
.text:00001D9D                 call    ??1CArchiveLink@@QAE@XZ ; CArchiveLink::~CArchiveLink(void)
.text:00001DA2                 mov     eax, [ebp+var_660]
.text:00001DA8                 jmp     loc_3FA0
.text:00001DAD ; ---------------------------------------------------------------------------
.text:00001DAD
.text:00001DAD loc_1DAD:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+61Bj
.text:00001DAD                 mov     edx, [ebp+arg_18]
.text:00001DB0                 push    edx             ; struct IOpenCallbackUI *
.text:00001DB1                 lea     eax, [ebp+var_194]
.text:00001DB7                 push    eax             ; struct COpenOptions *
.text:00001DB8                 lea     ecx, [ebp+var_B8] ; this
.text:00001DBE                 call    ?Open3@CArchiveLink@@QAEJAAUCOpenOptions@@PAUIOpenCallbackUI@@@Z ; CArchiveLink::Open3(COpenOptions &,IOpenCallbackUI *)
.text:00001DC3                 mov     [ebp+var_1A0], eax
.text:00001DC9                 cmp     [ebp+var_1A0], 80004004h
.text:00001DD3                 jnz     short loc_1E49
.text:00001DD5                 mov     ecx, [ebp+var_1A0]
.text:00001DDB                 mov     [ebp+var_664], ecx
.text:00001DE1                 mov     byte ptr [ebp+var_4], 8
.text:00001DE5                 lea     ecx, [ebp+var_194] ; this
.text:00001DEB                 call    ??1COpenOptions@@QAE@XZ ; COpenOptions::~COpenOptions(void)
.text:00001DF0                 mov     byte ptr [ebp+var_4], 7
.text:00001DF4                 lea     ecx, [ebp+var_134]
.text:00001DFA                 call    ??1?$CRecordVector@H@@QAE@XZ ; CRecordVector<int>::~CRecordVector<int>(void)
.text:00001DFF                 mov     byte ptr [ebp+var_4], 6
.text:00001E03                 lea     ecx, [ebp+var_120]
.text:00001E09                 call    ??1?$CObjectVector@UCOpenType@@@@QAE@XZ ; CObjectVector<COpenType>::~CObjectVector<COpenType>(void)
.text:00001E0E                 mov     byte ptr [ebp+var_4], 5
.text:00001E12                 lea     ecx, [ebp+var_10C] ; this
.text:00001E18                 call    ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text:00001E1D                 mov     byte ptr [ebp+var_4], 4
.text:00001E21                 lea     ecx, [ebp+var_CC] ; this
.text:00001E27                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00001E2C                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001E33                 lea     ecx, [ebp+var_B8] ; this
.text:00001E39                 call    ??1CArchiveLink@@QAE@XZ ; CArchiveLink::~CArchiveLink(void)
.text:00001E3E                 mov     eax, [ebp+var_664]
.text:00001E44                 jmp     loc_3FA0
.text:00001E49 ; ---------------------------------------------------------------------------
.text:00001E49
.text:00001E49 loc_1E49:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+6B7j
.text:00001E49                 cmp     [ebp+var_1A0], 0
.text:00001E50                 jnz     short loc_1E62
.text:00001E52                 cmp     [ebp+var_7C], 0
.text:00001E56                 jl      short loc_1E62
.text:00001E58                 mov     [ebp+var_1A0], 1
.text:00001E62
.text:00001E62 loc_1E62:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+734j
.text:00001E62                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+73Aj
.text:00001E62                 mov     esi, esp
.text:00001E64                 mov     edx, [ebp+var_1A0]
.text:00001E6A                 push    edx
.text:00001E6B                 lea     ecx, [ebp+var_CC]
.text:00001E71                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00001E76                 push    eax
.text:00001E77                 lea     eax, [ebp+var_B8]
.text:00001E7D                 push    eax
.text:00001E7E                 mov     ecx, [ebp+arg_0]
.text:00001E81                 push    ecx
.text:00001E82                 mov     edx, [ebp+arg_1C]
.text:00001E85                 mov     eax, [edx]
.text:00001E87                 mov     ecx, [ebp+arg_1C]
.text:00001E8A                 mov     edx, [eax+3Ch]
.text:00001E8D                 call    edx
.text:00001E8F                 cmp     esi, esp
.text:00001E91                 call    __RTC_CheckEsp
.text:00001E96                 mov     [ebp+var_1A4], eax
.text:00001E9C                 mov     eax, [ebp+var_1A4]
.text:00001EA2                 mov     [ebp+var_1A8], eax
.text:00001EA8                 cmp     [ebp+var_1A8], 0
.text:00001EAF                 jz      short loc_1F25
.text:00001EB1                 mov     ecx, [ebp+var_1A8]
.text:00001EB7                 mov     [ebp+var_668], ecx
.text:00001EBD                 mov     byte ptr [ebp+var_4], 8
.text:00001EC1                 lea     ecx, [ebp+var_194] ; this
.text:00001EC7                 call    ??1COpenOptions@@QAE@XZ ; COpenOptions::~COpenOptions(void)
.text:00001ECC                 mov     byte ptr [ebp+var_4], 7
.text:00001ED0                 lea     ecx, [ebp+var_134]
.text:00001ED6                 call    ??1?$CRecordVector@H@@QAE@XZ ; CRecordVector<int>::~CRecordVector<int>(void)
.text:00001EDB                 mov     byte ptr [ebp+var_4], 6
.text:00001EDF                 lea     ecx, [ebp+var_120]
.text:00001EE5                 call    ??1?$CObjectVector@UCOpenType@@@@QAE@XZ ; CObjectVector<COpenType>::~CObjectVector<COpenType>(void)
.text:00001EEA                 mov     byte ptr [ebp+var_4], 5
.text:00001EEE                 lea     ecx, [ebp+var_10C] ; this
.text:00001EF4                 call    ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text:00001EF9                 mov     byte ptr [ebp+var_4], 4
.text:00001EFD                 lea     ecx, [ebp+var_CC] ; this
.text:00001F03                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00001F08                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001F0F                 lea     ecx, [ebp+var_B8] ; this
.text:00001F15                 call    ??1CArchiveLink@@QAE@XZ ; CArchiveLink::~CArchiveLink(void)
.text:00001F1A                 mov     eax, [ebp+var_668]
.text:00001F20                 jmp     loc_3FA0
.text:00001F25 ; ---------------------------------------------------------------------------
.text:00001F25
.text:00001F25 loc_1F25:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+793j
.text:00001F25                 mov     edx, [ebp+var_1A0]
.text:00001F2B                 mov     [ebp+var_1AC], edx
.text:00001F31                 cmp     [ebp+var_1AC], 0
.text:00001F38                 jz      short loc_1FAE
.text:00001F3A                 mov     eax, [ebp+var_1AC]
.text:00001F40                 mov     [ebp+var_66C], eax
.text:00001F46                 mov     byte ptr [ebp+var_4], 8
.text:00001F4A                 lea     ecx, [ebp+var_194] ; this
.text:00001F50                 call    ??1COpenOptions@@QAE@XZ ; COpenOptions::~COpenOptions(void)
.text:00001F55                 mov     byte ptr [ebp+var_4], 7
.text:00001F59                 lea     ecx, [ebp+var_134]
.text:00001F5F                 call    ??1?$CRecordVector@H@@QAE@XZ ; CRecordVector<int>::~CRecordVector<int>(void)
.text:00001F64                 mov     byte ptr [ebp+var_4], 6
.text:00001F68                 lea     ecx, [ebp+var_120]
.text:00001F6E                 call    ??1?$CObjectVector@UCOpenType@@@@QAE@XZ ; CObjectVector<COpenType>::~CObjectVector<COpenType>(void)
.text:00001F73                 mov     byte ptr [ebp+var_4], 5
.text:00001F77                 lea     ecx, [ebp+var_10C] ; this
.text:00001F7D                 call    ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text:00001F82                 mov     byte ptr [ebp+var_4], 4
.text:00001F86                 lea     ecx, [ebp+var_CC] ; this
.text:00001F8C                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00001F91                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001F98                 lea     ecx, [ebp+var_B8] ; this
.text:00001F9E                 call    ??1CArchiveLink@@QAE@XZ ; CArchiveLink::~CArchiveLink(void)
.text:00001FA3                 mov     eax, [ebp+var_66C]
.text:00001FA9                 jmp     loc_3FA0
.text:00001FAE ; ---------------------------------------------------------------------------
.text:00001FAE
.text:00001FAE loc_1FAE:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+81Cj
.text:00001FAE                 lea     ecx, [ebp+var_AC]
.text:00001FB4                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:00001FB9                 cmp     eax, 1
.text:00001FBC                 jbe     loc_204D
.text:00001FC2                 mov     ecx, [ebp+arg_14]
.text:00001FC5                 mov     dword ptr [ecx], 80004001h
.text:00001FCB                 push    offset $SG75420 ; "Updating for multivolume archives is no"...
.text:00001FD0                 mov     ecx, [ebp+arg_14]
.text:00001FD3                 add     ecx, 4
.text:00001FD6                 call    ??4AString@@QAEAAV0@PBD@Z ; AString::operator=(char const *)
.text:00001FDB                 mov     [ebp+var_670], 80004001h
.text:00001FE5                 mov     byte ptr [ebp+var_4], 8
.text:00001FE9                 lea     ecx, [ebp+var_194] ; this
.text:00001FEF                 call    ??1COpenOptions@@QAE@XZ ; COpenOptions::~COpenOptions(void)
.text:00001FF4                 mov     byte ptr [ebp+var_4], 7
.text:00001FF8                 lea     ecx, [ebp+var_134]
.text:00001FFE                 call    ??1?$CRecordVector@H@@QAE@XZ ; CRecordVector<int>::~CRecordVector<int>(void)
.text:00002003                 mov     byte ptr [ebp+var_4], 6
.text:00002007                 lea     ecx, [ebp+var_120]
.text:0000200D                 call    ??1?$CObjectVector@UCOpenType@@@@QAE@XZ ; CObjectVector<COpenType>::~CObjectVector<COpenType>(void)
.text:00002012                 mov     byte ptr [ebp+var_4], 5
.text:00002016                 lea     ecx, [ebp+var_10C] ; this
.text:0000201C                 call    ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text:00002021                 mov     byte ptr [ebp+var_4], 4
.text:00002025                 lea     ecx, [ebp+var_CC] ; this
.text:0000202B                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00002030                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00002037                 lea     ecx, [ebp+var_B8] ; this
.text:0000203D                 call    ??1CArchiveLink@@QAE@XZ ; CArchiveLink::~CArchiveLink(void)
.text:00002042                 mov     eax, [ebp+var_670]
.text:00002048                 jmp     loc_3FA0
.text:0000204D ; ---------------------------------------------------------------------------
.text:0000204D
.text:0000204D loc_204D:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+8A0j
.text:0000204D                 lea     ecx, [ebp+var_B8]
.text:00002053                 call    ?Back@?$CObjectVector@VCArc@@@@QAEAAVCArc@@XZ ; CObjectVector<CArc>::Back(void)
.text:00002058                 mov     [ebp+var_1B0], eax
.text:0000205E                 movzx   edx, [ebp+var_E7]
.text:00002065                 neg     edx
.text:00002067                 sbb     edx, edx
.text:00002069                 add     edx, 1
.text:0000206C                 mov     eax, [ebp+var_1B0]
.text:00002072                 mov     [eax+0A4h], dl
.text:00002078                 mov     ecx, [ebp+var_1B0]
.text:0000207E                 mov     edx, [ebp+var_F4]
.text:00002084                 mov     [ecx+9Ch], edx
.text:0000208A                 mov     eax, [ebp+var_F0]
.text:00002090                 mov     [ecx+0A0h], eax
.text:00002096                 mov     ecx, [ebp+var_1B0]
.text:0000209C                 movzx   edx, byte ptr [ecx+10h]
.text:000020A0                 test    edx, edx
.text:000020A2                 jz      loc_2133
.text:000020A8                 mov     eax, [ebp+arg_14]
.text:000020AB                 mov     dword ptr [eax], 80004001h
.text:000020B1                 push    offset $SG75427 ; "There is some data block after the end "...
.text:000020B6                 mov     ecx, [ebp+arg_14]
.text:000020B9                 add     ecx, 4
.text:000020BC                 call    ??4AString@@QAEAAV0@PBD@Z ; AString::operator=(char const *)
.text:000020C1                 mov     [ebp+var_674], 80004001h
.text:000020CB                 mov     byte ptr [ebp+var_4], 8
.text:000020CF                 lea     ecx, [ebp+var_194] ; this
.text:000020D5                 call    ??1COpenOptions@@QAE@XZ ; COpenOptions::~COpenOptions(void)
.text:000020DA                 mov     byte ptr [ebp+var_4], 7
.text:000020DE                 lea     ecx, [ebp+var_134]
.text:000020E4                 call    ??1?$CRecordVector@H@@QAE@XZ ; CRecordVector<int>::~CRecordVector<int>(void)
.text:000020E9                 mov     byte ptr [ebp+var_4], 6
.text:000020ED                 lea     ecx, [ebp+var_120]
.text:000020F3                 call    ??1?$CObjectVector@UCOpenType@@@@QAE@XZ ; CObjectVector<COpenType>::~CObjectVector<COpenType>(void)
.text:000020F8                 mov     byte ptr [ebp+var_4], 5
.text:000020FC                 lea     ecx, [ebp+var_10C] ; this
.text:00002102                 call    ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text:00002107                 mov     byte ptr [ebp+var_4], 4
.text:0000210B                 lea     ecx, [ebp+var_CC] ; this
.text:00002111                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00002116                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000211D                 lea     ecx, [ebp+var_B8] ; this
.text:00002123                 call    ??1CArchiveLink@@QAE@XZ ; CArchiveLink::~CArchiveLink(void)
.text:00002128                 mov     eax, [ebp+var_674]
.text:0000212E                 jmp     loc_3FA0
.text:00002133 ; ---------------------------------------------------------------------------
.text:00002133
.text:00002133 loc_2133:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+986j
.text:00002133                 mov     ecx, [ebp+arg_10]
.text:00002136                 cmp     dword ptr [ecx+8], 0
.text:0000213A                 jge     loc_21E0
.text:00002140                 lea     ecx, [ebp+var_B8] ; this
.text:00002146                 call    ?GetArc@CArchiveLink@@QBEPBVCArc@@XZ ; CArchiveLink::GetArc(void)
.text:0000214B                 mov     edx, [ebp+arg_10]
.text:0000214E                 mov     eax, [eax+94h]
.text:00002154                 mov     [edx+8], eax
.text:00002157                 mov     ecx, [ebp+arg_8]
.text:0000215A                 push    ecx             ; struct UString *
.text:0000215B                 mov     edx, [ebp+arg_0]
.text:0000215E                 push    edx             ; struct CCodecs *
.text:0000215F                 mov     ecx, [ebp+arg_10] ; this
.text:00002162                 call    ?SetArcPath@CUpdateOptions@@QAE_NPBVCCodecs@@ABVUString@@@Z ; CUpdateOptions::SetArcPath(CCodecs const *,UString const &)
.text:00002167                 movzx   eax, al
.text:0000216A                 test    eax, eax
.text:0000216C                 jnz     short loc_21E0
.text:0000216E                 mov     [ebp+var_678], 80004001h
.text:00002178                 mov     byte ptr [ebp+var_4], 8
.text:0000217C                 lea     ecx, [ebp+var_194] ; this
.text:00002182                 call    ??1COpenOptions@@QAE@XZ ; COpenOptions::~COpenOptions(void)
.text:00002187                 mov     byte ptr [ebp+var_4], 7
.text:0000218B                 lea     ecx, [ebp+var_134]
.text:00002191                 call    ??1?$CRecordVector@H@@QAE@XZ ; CRecordVector<int>::~CRecordVector<int>(void)
.text:00002196                 mov     byte ptr [ebp+var_4], 6
.text:0000219A                 lea     ecx, [ebp+var_120]
.text:000021A0                 call    ??1?$CObjectVector@UCOpenType@@@@QAE@XZ ; CObjectVector<COpenType>::~CObjectVector<COpenType>(void)
.text:000021A5                 mov     byte ptr [ebp+var_4], 5
.text:000021A9                 lea     ecx, [ebp+var_10C] ; this
.text:000021AF                 call    ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text:000021B4                 mov     byte ptr [ebp+var_4], 4
.text:000021B8                 lea     ecx, [ebp+var_CC] ; this
.text:000021BE                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000021C3                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000021CA                 lea     ecx, [ebp+var_B8] ; this
.text:000021D0                 call    ??1CArchiveLink@@QAE@XZ ; CArchiveLink::~CArchiveLink(void)
.text:000021D5                 mov     eax, [ebp+var_678]
.text:000021DB                 jmp     loc_3FA0
.text:000021E0 ; ---------------------------------------------------------------------------
.text:000021E0
.text:000021E0 loc_21E0:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+A1Ej
.text:000021E0                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+A50j
.text:000021E0                 mov     byte ptr [ebp+var_4], 8
.text:000021E4                 lea     ecx, [ebp+var_194] ; this
.text:000021EA                 call    ??1COpenOptions@@QAE@XZ ; COpenOptions::~COpenOptions(void)
.text:000021EF                 mov     byte ptr [ebp+var_4], 7
.text:000021F3                 lea     ecx, [ebp+var_134]
.text:000021F9                 call    ??1?$CRecordVector@H@@QAE@XZ ; CRecordVector<int>::~CRecordVector<int>(void)
.text:000021FE                 mov     byte ptr [ebp+var_4], 6
.text:00002202                 lea     ecx, [ebp+var_120]
.text:00002208                 call    ??1?$CObjectVector@UCOpenType@@@@QAE@XZ ; CObjectVector<COpenType>::~CObjectVector<COpenType>(void)
.text:0000220D
.text:0000220D loc_220D:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool):loc_1B96j
.text:0000220D                 mov     byte ptr [ebp+var_4], 5
.text:00002211                 lea     ecx, [ebp+var_10C] ; this
.text:00002217                 call    ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text:0000221C
.text:0000221C loc_221C:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool):loc_1AD8j
.text:0000221C                 mov     ecx, [ebp+arg_10]
.text:0000221F                 cmp     dword ptr [ecx+8], 0
.text:00002223                 jge     short loc_229E
.text:00002225                 mov     edx, ds:_kDefaultArcType
.text:0000222B                 push    edx
.text:0000222C                 lea     ecx, [ebp+var_684]
.text:00002232                 call    ??0UString@@QAE@PB_W@Z ; UString::UString(wchar_t const *)
.text:00002237                 mov     byte ptr [ebp+var_4], 0Ah
.text:0000223B                 lea     eax, [ebp+var_684]
.text:00002241                 push    eax             ; struct UString *
.text:00002242                 mov     ecx, [ebp+arg_0] ; this
.text:00002245                 call    ?FindFormatForArchiveType@CCodecs@@QBEHABVUString@@@Z ; CCodecs::FindFormatForArchiveType(UString const &)
.text:0000224A                 mov     ecx, [ebp+arg_10]
.text:0000224D                 mov     [ecx+8], eax
.text:00002250                 mov     byte ptr [ebp+var_4], 5
.text:00002254                 lea     ecx, [ebp+var_684] ; this
.text:0000225A                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000225F                 mov     edx, [ebp+arg_10]
.text:00002262                 cmp     dword ptr [edx+8], 0
.text:00002266                 jge     short loc_229E
.text:00002268                 mov     [ebp+var_688], 80004001h
.text:00002272                 mov     byte ptr [ebp+var_4], 4
.text:00002276                 lea     ecx, [ebp+var_CC] ; this
.text:0000227C                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00002281                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00002288                 lea     ecx, [ebp+var_B8] ; this
.text:0000228E                 call    ??1CArchiveLink@@QAE@XZ ; CArchiveLink::~CArchiveLink(void)
.text:00002293                 mov     eax, [ebp+var_688]
.text:00002299                 jmp     loc_3FA0
.text:0000229E ; ---------------------------------------------------------------------------
.text:0000229E
.text:0000229E loc_229E:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+B07j
.text:0000229E                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+B4Aj
.text:0000229E                 mov     al, [ebp+var_98]
.text:000022A4                 mov     [ebp+var_1B1], al
.text:000022AA                 movzx   ecx, [ebp+var_1B1]
.text:000022B1                 test    ecx, ecx
.text:000022B3                 jnz     short loc_22F3
.text:000022B5                 movzx   edx, [ebp+var_11]
.text:000022B9                 test    edx, edx
.text:000022BB                 jz      short loc_22F3
.text:000022BD                 mov     [ebp+var_68C], 80004005h
.text:000022C7                 mov     byte ptr [ebp+var_4], 4
.text:000022CB                 lea     ecx, [ebp+var_CC] ; this
.text:000022D1                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000022D6                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000022DD                 lea     ecx, [ebp+var_B8] ; this
.text:000022E3                 call    ??1CArchiveLink@@QAE@XZ ; CArchiveLink::~CArchiveLink(void)
.text:000022E8                 mov     eax, [ebp+var_68C]
.text:000022EE                 jmp     loc_3FA0
.text:000022F3 ; ---------------------------------------------------------------------------
.text:000022F3
.text:000022F3 loc_22F3:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+B97j
.text:000022F3                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+B9Fj
.text:000022F3                 lea     ecx, [ebp+var_258]
.text:000022F9                 call    ??0CDirItems@@QAE@XZ ; CDirItems::CDirItems(void)
.text:000022FE                 mov     byte ptr [ebp+var_4], 0Bh
.text:00002302                 cmp     [ebp+arg_1C], 0
.text:00002306                 jz      short loc_2316
.text:00002308                 mov     eax, [ebp+arg_1C]
.text:0000230B                 add     eax, 4
.text:0000230E                 mov     [ebp+var_6EC], eax
.text:00002314                 jmp     short loc_2320
.text:00002316 ; ---------------------------------------------------------------------------
.text:00002316
.text:00002316 loc_2316:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+BEAj
.text:00002316                 mov     [ebp+var_6EC], 0
.text:00002320
.text:00002320 loc_2320:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+BF8j
.text:00002320                 mov     ecx, [ebp+var_6EC]
.text:00002326                 mov     [ebp+var_1C0], ecx
.text:0000232C                 lea     ecx, [ebp+var_2B0]
.text:00002332                 call    ??0CDirItem@@QAE@XZ ; CDirItem::CDirItem(void)
.text:00002337                 mov     byte ptr [ebp+var_4], 0Ch
.text:0000233B                 mov     [ebp+var_2B8], 0
.text:00002345                 mov     edx, [ebp+arg_10]
.text:00002348                 movzx   eax, byte ptr [edx+0B5h]
.text:0000234F                 test    eax, eax
.text:00002351                 jz      loc_23FB
.text:00002357                 lea     ecx, [ebp+var_30C]
.text:0000235D                 call    ??0CDirItem@@QAE@XZ ; CDirItem::CDirItem(void)
.text:00002362                 mov     byte ptr [ebp+var_4], 0Dh
.text:00002366                 mov     ecx, [ebp+arg_10]
.text:00002369                 add     ecx, 0B8h ; '+'
.text:0000236F                 push    ecx
.text:00002370                 lea     ecx, [ebp+var_2EC]
.text:00002376                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:0000237B                 mov     [ebp+var_30C], 0FFFFFFFFh
.text:00002385                 mov     [ebp+var_308], 0FFFFFFFFh
.text:0000238F                 mov     [ebp+var_2D0], 0
.text:00002399                 lea     edx, [ebp+var_2F4]
.text:0000239F                 push    edx             ; this
.text:000023A0                 call    ?GetCurUtcFileTime@NTime@NWindows@@YGXAAU_FILETIME@@@Z ; NWindows::NTime::GetCurUtcFileTime(_FILETIME &)
.text:000023A5                 mov     eax, [ebp+var_2F4]
.text:000023AB                 mov     [ebp+var_2FC], eax
.text:000023B1                 mov     ecx, [ebp+var_2F0]
.text:000023B7                 mov     [ebp+var_2F8], ecx
.text:000023BD                 mov     edx, [ebp+var_2FC]
.text:000023C3                 mov     [ebp+var_304], edx
.text:000023C9                 mov     eax, [ebp+var_2F8]
.text:000023CF                 mov     [ebp+var_300], eax
.text:000023D5                 lea     ecx, [ebp+var_30C]
.text:000023DB                 push    ecx
.text:000023DC                 lea     ecx, [ebp+var_234]
.text:000023E2                 call    ?Add@?$CObjectVector@UCDirItem@@@@QAEIABUCDirItem@@@Z ; CObjectVector<CDirItem>::Add(CDirItem const &)
.text:000023E7                 mov     byte ptr [ebp+var_4], 0Ch
.text:000023EB                 lea     ecx, [ebp+var_30C] ; this
.text:000023F1                 call    ??1CDirItem@@QAE@XZ ; CDirItem::~CDirItem(void)
.text:000023F6                 jmp     loc_279F
.text:000023FB ; ---------------------------------------------------------------------------
.text:000023FB
.text:000023FB loc_23FB:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+C35j
.text:000023FB                 mov     [ebp+var_311], 0
.text:00002402                 movzx   edx, [ebp+var_11]
.text:00002406                 test    edx, edx
.text:00002408                 jnz     short loc_2464
.text:0000240A                 mov     [ebp+var_318], 0
.text:00002414                 jmp     short loc_2425
.text:00002416 ; ---------------------------------------------------------------------------
.text:00002416
.text:00002416 loc_2416:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool):loc_2462j
.text:00002416                 mov     eax, [ebp+var_318]
.text:0000241C                 add     eax, 1
.text:0000241F                 mov     [ebp+var_318], eax
.text:00002425
.text:00002425 loc_2425:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+CF8j
.text:00002425                 mov     ecx, [ebp+arg_10]
.text:00002428                 add     ecx, 38h ; '8'
.text:0000242B                 call    ?Size@?$CObjectVector@UCUpdateArchiveCommand@@@@QBEIXZ ; CObjectVector<CUpdateArchiveCommand>::Size(void)
.text:00002430                 cmp     [ebp+var_318], eax
.text:00002436                 jnb     short loc_2464
.text:00002438                 mov     ecx, [ebp+var_318]
.text:0000243E                 push    ecx
.text:0000243F                 mov     ecx, [ebp+arg_10]
.text:00002442                 add     ecx, 38h ; '8'
.text:00002445                 call    ??A?$CObjectVector@UCUpdateArchiveCommand@@@@QAEAAUCUpdateArchiveCommand@@I@Z ; CObjectVector<CUpdateArchiveCommand>::operator[](uint)
.text:0000244A                 add     eax, 64h ; 'd'
.text:0000244D                 mov     ecx, eax        ; this
.text:0000244F                 call    ?NeedScanning@CActionSet@NUpdateArchive@@QBE_NXZ ; NUpdateArchive::CActionSet::NeedScanning(void)
.text:00002454                 movzx   edx, al
.text:00002457                 test    edx, edx
.text:00002459                 jz      short loc_2462
.text:0000245B                 mov     [ebp+var_311], 1
.text:00002462
.text:00002462 loc_2462:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+D3Dj
.text:00002462                 jmp     short loc_2416
.text:00002464 ; ---------------------------------------------------------------------------
.text:00002464
.text:00002464 loc_2464:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+CECj
.text:00002464                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+D1Aj
.text:00002464                 movzx   eax, [ebp+var_311]
.text:0000246B                 test    eax, eax
.text:0000246D                 jz      loc_279F
.text:00002473                 mov     esi, esp
.text:00002475                 mov     ecx, [ebp+arg_1C]
.text:00002478                 mov     edx, [ecx]
.text:0000247A                 mov     ecx, [ebp+arg_1C]
.text:0000247D                 mov     eax, [edx+40h]
.text:00002480                 call    eax
.text:00002482                 cmp     esi, esp
.text:00002484                 call    __RTC_CheckEsp
.text:00002489                 mov     [ebp+var_31C], eax
.text:0000248F                 cmp     [ebp+var_31C], 0
.text:00002496                 jz      short loc_24EE
.text:00002498                 mov     ecx, [ebp+var_31C]
.text:0000249E                 mov     [ebp+var_690], ecx
.text:000024A4                 mov     byte ptr [ebp+var_4], 0Bh
.text:000024A8                 lea     ecx, [ebp+var_2B0] ; this
.text:000024AE                 call    ??1CDirItem@@QAE@XZ ; CDirItem::~CDirItem(void)
.text:000024B3                 mov     byte ptr [ebp+var_4], 5
.text:000024B7                 lea     ecx, [ebp+var_258] ; this
.text:000024BD                 call    ??1CDirItems@@QAE@XZ ; CDirItems::~CDirItems(void)
.text:000024C2                 mov     byte ptr [ebp+var_4], 4
.text:000024C6                 lea     ecx, [ebp+var_CC] ; this
.text:000024CC                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000024D1                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000024D8                 lea     ecx, [ebp+var_B8] ; this
.text:000024DE                 call    ??1CArchiveLink@@QAE@XZ ; CArchiveLink::~CArchiveLink(void)
.text:000024E3                 mov     eax, [ebp+var_690]
.text:000024E9                 jmp     loc_3FA0
.text:000024EE ; ---------------------------------------------------------------------------
.text:000024EE
.text:000024EE loc_24EE:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+D7Aj
.text:000024EE                 mov     edx, [ebp+arg_10]
.text:000024F1                 mov     al, [edx+0F6h]
.text:000024F7                 mov     [ebp+var_228], al
.text:000024FD                 mov     ecx, [ebp+arg_10]
.text:00002500                 mov     dl, [ecx+0F0h]
.text:00002506                 mov     [ebp+var_1C3], dl
.text:0000250C                 mov     eax, [ebp+arg_10]
.text:0000250F                 mov     cl, [eax+0F2h]
.text:00002515                 mov     [ebp+var_227], cl
.text:0000251B                 lea     edx, [ebp+var_258]
.text:00002521                 push    edx
.text:00002522                 mov     eax, [ebp+arg_10]
.text:00002525                 add     eax, 0E4h ; 'S'
.text:0000252A                 push    eax
.text:0000252B                 mov     ecx, [ebp+arg_10]
.text:0000252E                 mov     edx, [ecx+0E0h]
.text:00002534                 push    edx
.text:00002535                 mov     eax, [ebp+arg_C]
.text:00002538                 push    eax             ; struct UString *
.text:00002539                 call    ?EnumerateItems@@YGJABVCCensor@NWildcard@@W4ECensorPathMode@2@ABVUString@@AAVCDirItems@@@Z ; EnumerateItems(NWildcard::CCensor const &,NWildcard::ECensorPathMode,UString const &,CDirItems &)
.text:0000253E                 mov     [ebp+var_320], eax
.text:00002544                 cmp     [ebp+var_320], 0
.text:0000254B                 jz      short loc_25BF
.text:0000254D                 cmp     [ebp+var_320], 80004004h
.text:00002557                 jz      short loc_2569
.text:00002559                 push    offset $SG75467 ; "Scanning error"
.text:0000255E                 mov     ecx, [ebp+arg_14]
.text:00002561                 add     ecx, 4
.text:00002564                 call    ??4AString@@QAEAAV0@PBD@Z ; AString::operator=(char const *)
.text:00002569
.text:00002569 loc_2569:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+E3Bj
.text:00002569                 mov     ecx, [ebp+var_320]
.text:0000256F                 mov     [ebp+var_694], ecx
.text:00002575                 mov     byte ptr [ebp+var_4], 0Bh
.text:00002579                 lea     ecx, [ebp+var_2B0] ; this
.text:0000257F                 call    ??1CDirItem@@QAE@XZ ; CDirItem::~CDirItem(void)
.text:00002584                 mov     byte ptr [ebp+var_4], 5
.text:00002588                 lea     ecx, [ebp+var_258] ; this
.text:0000258E                 call    ??1CDirItems@@QAE@XZ ; CDirItems::~CDirItems(void)
.text:00002593                 mov     byte ptr [ebp+var_4], 4
.text:00002597                 lea     ecx, [ebp+var_CC] ; this
.text:0000259D                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000025A2                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000025A9                 lea     ecx, [ebp+var_B8] ; this
.text:000025AF                 call    ??1CArchiveLink@@QAE@XZ ; CArchiveLink::~CArchiveLink(void)
.text:000025B4                 mov     eax, [ebp+var_694]
.text:000025BA                 jmp     loc_3FA0
.text:000025BF ; ---------------------------------------------------------------------------
.text:000025BF
.text:000025BF loc_25BF:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+E2Fj
.text:000025BF                 mov     esi, esp
.text:000025C1                 lea     edx, [ebp+var_220]
.text:000025C7                 push    edx
.text:000025C8                 mov     eax, [ebp+arg_1C]
.text:000025CB                 mov     edx, [eax]
.text:000025CD                 mov     ecx, [ebp+arg_1C]
.text:000025D0                 mov     eax, [edx+44h]
.text:000025D3                 call    eax
.text:000025D5                 cmp     esi, esp
.text:000025D7                 call    __RTC_CheckEsp
.text:000025DC                 mov     [ebp+var_324], eax
.text:000025E2                 cmp     [ebp+var_324], 0
.text:000025E9                 jz      short loc_2641
.text:000025EB                 mov     ecx, [ebp+var_324]
.text:000025F1                 mov     [ebp+var_698], ecx
.text:000025F7                 mov     byte ptr [ebp+var_4], 0Bh
.text:000025FB                 lea     ecx, [ebp+var_2B0] ; this
.text:00002601                 call    ??1CDirItem@@QAE@XZ ; CDirItem::~CDirItem(void)
.text:00002606                 mov     byte ptr [ebp+var_4], 5
.text:0000260A                 lea     ecx, [ebp+var_258] ; this
.text:00002610                 call    ??1CDirItems@@QAE@XZ ; CDirItems::~CDirItems(void)
.text:00002615                 mov     byte ptr [ebp+var_4], 4
.text:00002619                 lea     ecx, [ebp+var_CC] ; this
.text:0000261F                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00002624                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000262B                 lea     ecx, [ebp+var_B8] ; this
.text:00002631                 call    ??1CArchiveLink@@QAE@XZ ; CArchiveLink::~CArchiveLink(void)
.text:00002636                 mov     eax, [ebp+var_698]
.text:0000263C                 jmp     loc_3FA0
.text:00002641 ; ---------------------------------------------------------------------------
.text:00002641
.text:00002641 loc_2641:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+ECDj
.text:00002641                 mov     ecx, [ebp+arg_C]
.text:00002644                 call    ?Size@?$CObjectVector@UCPair@NWildcard@@@@QBEIXZ ; CObjectVector<NWildcard::CPair>::Size(void)
.text:00002649                 cmp     eax, 1
.text:0000264C                 jnz     loc_279F
.text:00002652                 lea     ecx, [ebp+var_360] ; this
.text:00002658                 call    ??0CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::CFileInfo(void)
.text:0000265D                 mov     byte ptr [ebp+var_4], 0Eh
.text:00002661                 push    0
.text:00002663                 mov     ecx, [ebp+arg_C]
.text:00002666                 call    ??A?$CObjectVector@UCPair@NWildcard@@@@QAEAAUCPair@NWildcard@@I@Z ; CObjectVector<NWildcard::CPair>::operator[](uint)
.text:0000266B                 push    eax
.text:0000266C                 lea     ecx, [ebp+var_374]
.text:00002672                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00002677                 mov     byte ptr [ebp+var_4], 0Fh
.text:0000267B                 push    2Eh ; '.'
.text:0000267D                 lea     ecx, [ebp+var_374]
.text:00002683                 call    ??YUString@@QAEAAV0@_W@Z ; UString::operator+=(wchar_t)
.text:00002688                 lea     ecx, [ebp+var_374]
.text:0000268E                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00002693                 push    eax             ; wchar_t *
.text:00002694                 lea     ecx, [ebp+var_360] ; this
.text:0000269A                 call    ?Find@CFileInfo@NFind@NFile@NWindows@@QAE_NPB_W@Z ; NWindows::NFile::NFind::CFileInfo::Find(wchar_t const *)
.text:0000269F                 movzx   edx, al
.text:000026A2                 test    edx, edx
.text:000026A4                 jz      loc_2781
.text:000026AA                 lea     ecx, [ebp+var_360] ; this
.text:000026B0                 call    ?IsDir@CFileInfoBase@NFind@NFile@NWindows@@QBE_NXZ ; NWindows::NFile::NFind::CFileInfoBase::IsDir(void)
.text:000026B5                 movzx   eax, al
.text:000026B8                 test    eax, eax
.text:000026BA                 jz      loc_2781
.text:000026C0                 mov     ecx, [ebp+var_360]
.text:000026C6                 mov     [ebp+var_2B0], ecx
.text:000026CC                 mov     edx, [ebp+var_35C]
.text:000026D2                 mov     [ebp+var_2AC], edx
.text:000026D8                 mov     eax, [ebp+var_358]
.text:000026DE                 mov     [ebp+var_2A8], eax
.text:000026E4                 mov     ecx, [ebp+var_354]
.text:000026EA                 mov     [ebp+var_2A4], ecx
.text:000026F0                 mov     edx, [ebp+var_350]
.text:000026F6                 mov     [ebp+var_2A0], edx
.text:000026FC                 mov     eax, [ebp+var_34C]
.text:00002702                 mov     [ebp+var_29C], eax
.text:00002708                 mov     ecx, [ebp+var_348]
.text:0000270E                 mov     [ebp+var_298], ecx
.text:00002714                 mov     edx, [ebp+var_344]
.text:0000271A                 mov     [ebp+var_294], edx
.text:00002720                 mov     eax, [ebp+var_340]
.text:00002726                 mov     [ebp+var_274], eax
.text:0000272C                 lea     ecx, [ebp+var_2B0]
.text:00002732                 mov     [ebp+var_2B8], ecx
.text:00002738                 mov     [ebp+var_380], 0FFFFFFFFh
.text:00002742                 mov     edx, [ebp+arg_10]
.text:00002745                 movzx   eax, byte ptr [edx+0F0h]
.text:0000274C                 test    eax, eax
.text:0000274E                 jz      short loc_2769
.text:00002750                 lea     ecx, [ebp+var_380]
.text:00002756                 push    ecx             ; int *
.text:00002757                 lea     edx, [ebp+var_374]
.text:0000275D                 push    edx             ; struct UString *
.text:0000275E                 lea     ecx, [ebp+var_258] ; this
.text:00002764                 call    ?AddSecurityItem@CDirItems@@QAEJABVUString@@AAH@Z ; CDirItems::AddSecurityItem(UString const &,int &)
.text:00002769
.text:00002769 loc_2769:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1032j
.text:00002769                 mov     eax, [ebp+var_380]
.text:0000276F                 mov     [ebp+var_268], eax
.text:00002775                 lea     ecx, [ebp+var_2B0]
.text:0000277B                 mov     [ebp+var_2B8], ecx
.text:00002781
.text:00002781 loc_2781:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+F88j
.text:00002781                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+F9Ej
.text:00002781                 mov     byte ptr [ebp+var_4], 0Eh
.text:00002785                 lea     ecx, [ebp+var_374] ; this
.text:0000278B                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00002790                 mov     byte ptr [ebp+var_4], 0Ch
.text:00002794                 lea     ecx, [ebp+var_360] ; this
.text:0000279A                 call    ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text:0000279F
.text:0000279F loc_279F:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+CDAj
.text:0000279F                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+D51j ...
.text:0000279F                 lea     ecx, [ebp+var_394]
.text:000027A5                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:000027AA                 mov     byte ptr [ebp+var_4], 10h
.text:000027AE                 mov     [ebp+var_399], 0
.text:000027B5                 lea     ecx, [ebp+var_3B0] ; this
.text:000027BB                 call    ??0CTempDir@NDir@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NDir::CTempDir::CTempDir(void)
.text:000027C0                 mov     byte ptr [ebp+var_4], 11h
.text:000027C4                 mov     edx, [ebp+arg_10]
.text:000027C7                 movzx   eax, byte ptr [edx+0C5h]
.text:000027CE                 test    eax, eax
.text:000027D0                 jz      short loc_281B
.text:000027D2                 mov     ecx, [ebp+arg_10]
.text:000027D5                 movzx   edx, byte ptr [ecx+0C6h]
.text:000027DC                 test    edx, edx
.text:000027DE                 jz      short loc_281B
.text:000027E0                 mov     eax, ds:_kTempFolderPrefix
.text:000027E5                 push    eax             ; wchar_t *
.text:000027E6                 lea     ecx, [ebp+var_3B0] ; this
.text:000027EC                 call    ?Create@CTempDir@NDir@NFile@NWindows@@QAE_NPB_W@Z ; NWindows::NFile::NDir::CTempDir::Create(wchar_t const *)
.text:000027F1                 lea     ecx, [ebp+var_3B0] ; this
.text:000027F7                 call    ?GetPath@CTempDir@NDir@NFile@NWindows@@QBEABVUString@@XZ ; NWindows::NFile::NDir::CTempDir::GetPath(void)
.text:000027FC                 push    eax
.text:000027FD                 lea     ecx, [ebp+var_394]
.text:00002803                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:00002808                 lea     ecx, [ebp+var_394]
.text:0000280E                 push    ecx             ; this
.text:0000280F                 call    ?NormalizeDirPathPrefix@NName@NFile@NWindows@@YGXAAVUString@@@Z ; NWindows::NFile::NName::NormalizeDirPathPrefix(UString &)
.text:00002814                 mov     [ebp+var_399], 1
.text:0000281B
.text:0000281B loc_281B:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+10B4j
.text:0000281B                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+10C2j
.text:0000281B                 lea     ecx, [ebp+var_3C4]
.text:00002821                 call    ??0CTempFiles@@QAE@XZ ; CTempFiles::CTempFiles(void)
.text:00002826                 mov     byte ptr [ebp+var_4], 12h
.text:0000282A                 mov     [ebp+var_3C9], 0
.text:00002831                 mov     edx, [ebp+arg_10]
.text:00002834                 movzx   eax, byte ptr [edx+0C4h]
.text:0000283B                 test    eax, eax
.text:0000283D                 jnz     loc_2921
.text:00002843                 mov     ecx, [ebp+arg_10]
.text:00002846                 movzx   edx, byte ptr [ecx+44h]
.text:0000284A                 test    edx, edx
.text:0000284C                 jz      loc_2921
.text:00002852                 push    0
.text:00002854                 mov     ecx, [ebp+arg_10]
.text:00002857                 add     ecx, 38h ; '8'
.text:0000285A                 call    ??A?$CObjectVector@UCUpdateArchiveCommand@@@@QAEAAUCUpdateArchiveCommand@@I@Z ; CObjectVector<CUpdateArchiveCommand>::operator[](uint)
.text:0000285F                 add     eax, 0Ch
.text:00002862                 mov     [ebp+var_3D0], eax
.text:00002868                 mov     eax, [ebp+arg_10]
.text:0000286B                 add     eax, 48h ; 'H'
.text:0000286E                 push    eax
.text:0000286F                 mov     ecx, [ebp+var_3D0]
.text:00002875                 call    ??4CArchivePath@@QAEAAU0@ABU0@@Z ; CArchivePath::operator=(CArchivePath const &)
.text:0000287A                 movzx   ecx, [ebp+var_1B1]
.text:00002881                 test    ecx, ecx
.text:00002883                 jnz     short loc_289E
.text:00002885                 mov     ecx, [ebp+arg_10]
.text:00002888                 add     ecx, 0D4h ; '+' ; this
.text:0000288E                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:00002893                 movzx   edx, al
.text:00002896                 test    edx, edx
.text:00002898                 jnz     loc_2921
.text:0000289E
.text:0000289E loc_289E:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1167j
.text:0000289E                 movzx   eax, [ebp+var_399]
.text:000028A5                 test    eax, eax
.text:000028A7                 jnz     short loc_2921
.text:000028A9                 mov     ecx, [ebp+arg_10]
.text:000028AC                 add     ecx, 108h
.text:000028B2                 call    ?Size@?$CRecordVector@_K@@QBEIXZ ; CRecordVector<unsigned __int64>::Size(void)
.text:000028B7                 test    eax, eax
.text:000028B9                 jnz     short loc_2921
.text:000028BB                 mov     [ebp+var_3C9], 1
.text:000028C2                 mov     ecx, [ebp+var_3D0]
.text:000028C8                 mov     byte ptr [ecx+3Ch], 1
.text:000028CC                 mov     ecx, [ebp+arg_10]
.text:000028CF                 add     ecx, 0D4h ; '+' ; this
.text:000028D5                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:000028DA                 movzx   edx, al
.text:000028DD                 test    edx, edx
.text:000028DF                 jnz     short loc_28FA
.text:000028E1                 mov     eax, [ebp+arg_10]
.text:000028E4                 add     eax, 0D4h ; '+'
.text:000028E9                 push    eax
.text:000028EA                 mov     ecx, [ebp+var_3D0]
.text:000028F0                 add     ecx, 40h ; '@'
.text:000028F3                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:000028F8                 jmp     short loc_2912
.text:000028FA ; ---------------------------------------------------------------------------
.text:000028FA
.text:000028FA loc_28FA:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+11C3j
.text:000028FA                 mov     ecx, [ebp+var_3D0]
.text:00002900                 add     ecx, 0Ch
.text:00002903                 push    ecx
.text:00002904                 mov     ecx, [ebp+var_3D0]
.text:0000290A                 add     ecx, 40h ; '@'
.text:0000290D                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:00002912
.text:00002912 loc_2912:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+11DCj
.text:00002912                 mov     edx, [ebp+var_3D0]
.text:00002918                 add     edx, 40h ; '@'
.text:0000291B                 push    edx             ; wchar_t *
.text:0000291C                 call    ?NormalizeDirPathPrefix@NName@NFile@NWindows@@YGXAAVUString@@@Z ; NWindows::NFile::NName::NormalizeDirPathPrefix(UString &)
.text:00002921
.text:00002921 loc_2921:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1121j
.text:00002921                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1130j ...
.text:00002921                 mov     [ebp+var_3D4], 0
.text:0000292B                 jmp     short loc_293C
.text:0000292D ; ---------------------------------------------------------------------------
.text:0000292D
.text:0000292D loc_292D:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool):loc_2AB8j
.text:0000292D                 mov     eax, [ebp+var_3D4]
.text:00002933                 add     eax, 1
.text:00002936                 mov     [ebp+var_3D4], eax
.text:0000293C
.text:0000293C loc_293C:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+120Fj
.text:0000293C                 mov     ecx, [ebp+arg_10]
.text:0000293F                 add     ecx, 38h ; '8'
.text:00002942                 call    ?Size@?$CObjectVector@UCUpdateArchiveCommand@@@@QBEIXZ ; CObjectVector<CUpdateArchiveCommand>::Size(void)
.text:00002947                 cmp     [ebp+var_3D4], eax
.text:0000294D                 jnb     loc_2ABD
.text:00002953                 mov     ecx, [ebp+var_3D4]
.text:00002959                 push    ecx
.text:0000295A                 mov     ecx, [ebp+arg_10]
.text:0000295D                 add     ecx, 38h ; '8'
.text:00002960                 call    ??A?$CObjectVector@UCUpdateArchiveCommand@@@@QAEAAUCUpdateArchiveCommand@@I@Z ; CObjectVector<CUpdateArchiveCommand>::operator[](uint)
.text:00002965                 add     eax, 0Ch
.text:00002968                 mov     [ebp+var_3D8], eax
.text:0000296E                 movzx   edx, [ebp+var_399]
.text:00002975                 test    edx, edx
.text:00002977                 jz      short loc_298E
.text:00002979                 lea     eax, [ebp+var_394]
.text:0000297F                 push    eax
.text:00002980                 mov     ecx, [ebp+var_3D8]
.text:00002986                 add     ecx, 0Ch
.text:00002989                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:0000298E
.text:0000298E loc_298E:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+125Bj
.text:0000298E                 mov     ecx, [ebp+arg_10]
.text:00002991                 movzx   edx, byte ptr [ecx+0C4h]
.text:00002998                 test    edx, edx
.text:0000299A                 jnz     loc_2AB8
.text:000029A0                 cmp     [ebp+var_3D4], 0
.text:000029A7                 ja      short loc_29B8
.text:000029A9                 movzx   eax, [ebp+var_3C9]
.text:000029B0                 test    eax, eax
.text:000029B2                 jnz     loc_2AB8
.text:000029B8
.text:000029B8 loc_29B8:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+128Bj
.text:000029B8                 lea     ecx, [ebp+var_3E8]
.text:000029BE                 push    ecx
.text:000029BF                 mov     ecx, [ebp+var_3D8]
.text:000029C5                 call    ?GetFinalPath@CArchivePath@@QBE?AVUString@@XZ ; CArchivePath::GetFinalPath(void)
.text:000029CA                 mov     byte ptr [ebp+var_4], 13h
.text:000029CE                 lea     ecx, [ebp+var_3E8]
.text:000029D4                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000029D9                 push    eax             ; this
.text:000029DA                 call    ?DoesFileOrDirExist@NFind@NFile@NWindows@@YG_NPB_W@Z ; NWindows::NFile::NFind::DoesFileOrDirExist(wchar_t const *)
.text:000029DF                 movzx   edx, al
.text:000029E2                 test    edx, edx
.text:000029E4                 jz      loc_2AA9
.text:000029EA                 mov     eax, [ebp+arg_14]
.text:000029ED                 mov     dword ptr [eax], 50h ; 'P'
.text:000029F3                 push    offset $SG75502 ; "The file already exists"
.text:000029F8                 mov     ecx, [ebp+arg_14]
.text:000029FB                 add     ecx, 4
.text:000029FE                 call    ??4AString@@QAEAAV0@PBD@Z ; AString::operator=(char const *)
.text:00002A03                 lea     ecx, [ebp+var_3E8]
.text:00002A09                 push    ecx
.text:00002A0A                 mov     ecx, [ebp+arg_14]
.text:00002A0D                 add     ecx, 10h
.text:00002A10                 call    ?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z ; CObjectVector<UString>::Add(UString const &)
.text:00002A15                 mov     ecx, [ebp+arg_14] ; this
.text:00002A18                 call    ?Get_HRESULT_Error@CUpdateErrorInfo@@QBEJXZ ; CUpdateErrorInfo::Get_HRESULT_Error(void)
.text:00002A1D                 mov     [ebp+var_69C], eax
.text:00002A23                 mov     byte ptr [ebp+var_4], 12h
.text:00002A27                 lea     ecx, [ebp+var_3E8] ; this
.text:00002A2D                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00002A32                 mov     byte ptr [ebp+var_4], 11h
.text:00002A36                 lea     ecx, [ebp+var_3C4] ; this
.text:00002A3C                 call    ??1CTempFiles@@QAE@XZ ; CTempFiles::~CTempFiles(void)
.text:00002A41                 mov     byte ptr [ebp+var_4], 10h
.text:00002A45                 lea     ecx, [ebp+var_3B0] ; this
.text:00002A4B                 call    ??1CTempDir@NDir@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NDir::CTempDir::~CTempDir(void)
.text:00002A50                 mov     byte ptr [ebp+var_4], 0Ch
.text:00002A54                 lea     ecx, [ebp+var_394] ; this
.text:00002A5A                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00002A5F                 mov     byte ptr [ebp+var_4], 0Bh
.text:00002A63                 lea     ecx, [ebp+var_2B0] ; this
.text:00002A69                 call    ??1CDirItem@@QAE@XZ ; CDirItem::~CDirItem(void)
.text:00002A6E                 mov     byte ptr [ebp+var_4], 5
.text:00002A72                 lea     ecx, [ebp+var_258] ; this
.text:00002A78                 call    ??1CDirItems@@QAE@XZ ; CDirItems::~CDirItems(void)
.text:00002A7D                 mov     byte ptr [ebp+var_4], 4
.text:00002A81                 lea     ecx, [ebp+var_CC] ; this
.text:00002A87                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00002A8C                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00002A93                 lea     ecx, [ebp+var_B8] ; this
.text:00002A99                 call    ??1CArchiveLink@@QAE@XZ ; CArchiveLink::~CArchiveLink(void)
.text:00002A9E                 mov     eax, [ebp+var_69C]
.text:00002AA4                 jmp     loc_3FA0
.text:00002AA9 ; ---------------------------------------------------------------------------
.text:00002AA9
.text:00002AA9 loc_2AA9:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+12C8j
.text:00002AA9                 mov     byte ptr [ebp+var_4], 12h
.text:00002AAD                 lea     ecx, [ebp+var_3E8] ; this
.text:00002AB3                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00002AB8
.text:00002AB8 loc_2AB8:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+127Ej
.text:00002AB8                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1296j
.text:00002AB8                 jmp     loc_292D
.text:00002ABD ; ---------------------------------------------------------------------------
.text:00002ABD
.text:00002ABD loc_2ABD:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1231j
.text:00002ABD                 lea     ecx, [ebp+var_3FC]
.text:00002AC3                 call    ??0?$CObjectVector@UCArcItem@@@@QAE@XZ ; CObjectVector<CArcItem>::CObjectVector<CArcItem>(void)
.text:00002AC8                 mov     byte ptr [ebp+var_4], 14h
.text:00002ACC                 movzx   edx, [ebp+var_1B1]
.text:00002AD3                 test    edx, edx
.text:00002AD5                 jz      loc_2B9C
.text:00002ADB                 lea     eax, [ebp+var_3FC]
.text:00002AE1                 push    eax             ; int
.text:00002AE2                 lea     ecx, [ebp+var_B8]
.text:00002AE8                 call    ?Back@?$CObjectVector@VCArc@@@@QAEAAVCArc@@XZ ; CObjectVector<CArc>::Back(void)
.text:00002AED                 push    eax             ; CArc *
.text:00002AEE                 mov     ecx, [ebp+arg_C]
.text:00002AF1                 push    ecx             ; int
.text:00002AF2                 call    ?EnumerateInArchiveItems@@YGJABVCCensor@NWildcard@@ABVCArc@@AAV?$CObjectVector@UCArcItem@@@@@Z ; EnumerateInArchiveItems(NWildcard::CCensor const &,CArc const &,CObjectVector<CArcItem> &)
.text:00002AF7                 mov     [ebp+var_404], eax
.text:00002AFD                 cmp     [ebp+var_404], 0
.text:00002B04                 jz      loc_2B9C
.text:00002B0A                 mov     edx, [ebp+var_404]
.text:00002B10                 mov     [ebp+var_6A0], edx
.text:00002B16                 mov     byte ptr [ebp+var_4], 12h
.text:00002B1A                 lea     ecx, [ebp+var_3FC]
.text:00002B20                 call    ??1?$CObjectVector@UCArcItem@@@@QAE@XZ ; CObjectVector<CArcItem>::~CObjectVector<CArcItem>(void)
.text:00002B25                 mov     byte ptr [ebp+var_4], 11h
.text:00002B29                 lea     ecx, [ebp+var_3C4] ; this
.text:00002B2F                 call    ??1CTempFiles@@QAE@XZ ; CTempFiles::~CTempFiles(void)
.text:00002B34                 mov     byte ptr [ebp+var_4], 10h
.text:00002B38                 lea     ecx, [ebp+var_3B0] ; this
.text:00002B3E                 call    ??1CTempDir@NDir@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NDir::CTempDir::~CTempDir(void)
.text:00002B43                 mov     byte ptr [ebp+var_4], 0Ch
.text:00002B47                 lea     ecx, [ebp+var_394] ; this
.text:00002B4D                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00002B52                 mov     byte ptr [ebp+var_4], 0Bh
.text:00002B56                 lea     ecx, [ebp+var_2B0] ; this
.text:00002B5C                 call    ??1CDirItem@@QAE@XZ ; CDirItem::~CDirItem(void)
.text:00002B61                 mov     byte ptr [ebp+var_4], 5
.text:00002B65                 lea     ecx, [ebp+var_258] ; this
.text:00002B6B                 call    ??1CDirItems@@QAE@XZ ; CDirItems::~CDirItems(void)
.text:00002B70                 mov     byte ptr [ebp+var_4], 4
.text:00002B74                 lea     ecx, [ebp+var_CC] ; this
.text:00002B7A                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00002B7F                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00002B86                 lea     ecx, [ebp+var_B8] ; this
.text:00002B8C                 call    ??1CArchiveLink@@QAE@XZ ; CArchiveLink::~CArchiveLink(void)
.text:00002B91                 mov     eax, [ebp+var_6A0]
.text:00002B97                 jmp     loc_3FA0
.text:00002B9C ; ---------------------------------------------------------------------------
.text:00002B9C
.text:00002B9C loc_2B9C:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+13B9j
.text:00002B9C                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+13E8j
.text:00002B9C                 lea     ecx, [ebp+var_410]
.text:00002BA2                 call    ??0?$CBuffer@E@@QAE@XZ ; CBuffer<uchar>::CBuffer<uchar>(void)
.text:00002BA7                 mov     byte ptr [ebp+var_4], 15h
.text:00002BAB                 mov     eax, [ebp+arg_10]
.text:00002BAE                 movzx   ecx, byte ptr [eax+0F8h]
.text:00002BB5                 test    ecx, ecx
.text:00002BB7                 jz      short loc_2C1C
.text:00002BB9                 lea     ecx, [ebp+var_234]
.text:00002BBF                 call    ?Size@?$CObjectVector@UCDirItem@@@@QBEIXZ ; CObjectVector<CDirItem>::Size(void)
.text:00002BC4                 mov     [ebp+var_418], eax
.text:00002BCA                 mov     edx, [ebp+var_418]
.text:00002BD0                 push    edx
.text:00002BD1                 lea     ecx, [ebp+var_410]
.text:00002BD7                 call    ?Alloc@?$CBuffer@E@@QAEXI@Z ; CBuffer<uchar>::Alloc(uint)
.text:00002BDC                 mov     [ebp+var_3D4], 0
.text:00002BE6                 jmp     short loc_2BF7
.text:00002BE8 ; ---------------------------------------------------------------------------
.text:00002BE8
.text:00002BE8 loc_2BE8:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+14FEj
.text:00002BE8                 mov     eax, [ebp+var_3D4]
.text:00002BEE                 add     eax, 1
.text:00002BF1                 mov     [ebp+var_3D4], eax
.text:00002BF7
.text:00002BF7 loc_2BF7:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+14CAj
.text:00002BF7                 mov     ecx, [ebp+var_3D4]
.text:00002BFD                 cmp     ecx, [ebp+var_418]
.text:00002C03                 jnb     short loc_2C1C
.text:00002C05                 lea     ecx, [ebp+var_410]
.text:00002C0B                 call    ??B?$CBuffer@E@@QAEPAEXZ ; CBuffer<uchar>::operator uchar *(void)
.text:00002C10                 mov     edx, [ebp+var_3D4]
.text:00002C16                 mov     byte ptr [eax+edx], 0
.text:00002C1A                 jmp     short loc_2BE8
.text:00002C1C ; ---------------------------------------------------------------------------
.text:00002C1C
.text:00002C1C loc_2C1C:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+149Bj
.text:00002C1C                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+14E7j
.text:00002C1C                 mov     [ebp+var_3D4], 0
.text:00002C26                 jmp     short loc_2C37
.text:00002C28 ; ---------------------------------------------------------------------------
.text:00002C28
.text:00002C28 loc_2C28:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1980j
.text:00002C28                 mov     eax, [ebp+var_3D4]
.text:00002C2E                 add     eax, 1
.text:00002C31                 mov     [ebp+var_3D4], eax
.text:00002C37
.text:00002C37 loc_2C37:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+150Aj
.text:00002C37                 mov     ecx, [ebp+arg_10]
.text:00002C3A                 add     ecx, 38h ; '8'
.text:00002C3D                 call    ?Size@?$CObjectVector@UCUpdateArchiveCommand@@@@QBEIXZ ; CObjectVector<CUpdateArchiveCommand>::Size(void)
.text:00002C42                 cmp     [ebp+var_3D4], eax
.text:00002C48                 jnb     loc_30A1
.text:00002C4E                 movzx   ecx, [ebp+var_1B1]
.text:00002C55                 test    ecx, ecx
.text:00002C57                 jz      short loc_2C6C
.text:00002C59                 lea     ecx, [ebp+var_B8] ; this
.text:00002C5F                 call    ?GetArc@CArchiveLink@@QBEPBVCArc@@XZ ; CArchiveLink::GetArc(void)
.text:00002C64                 mov     [ebp+var_6F0], eax
.text:00002C6A                 jmp     short loc_2C76
.text:00002C6C ; ---------------------------------------------------------------------------
.text:00002C6C
.text:00002C6C loc_2C6C:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+153Bj
.text:00002C6C                 mov     [ebp+var_6F0], 0
.text:00002C76
.text:00002C76 loc_2C76:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+154Ej
.text:00002C76                 mov     edx, [ebp+var_6F0]
.text:00002C7C                 mov     [ebp+var_41C], edx
.text:00002C82                 mov     eax, [ebp+var_3D4]
.text:00002C88                 push    eax
.text:00002C89                 mov     ecx, [ebp+arg_10]
.text:00002C8C                 add     ecx, 38h ; '8'
.text:00002C8F                 call    ??A?$CObjectVector@UCUpdateArchiveCommand@@@@QAEAAUCUpdateArchiveCommand@@I@Z ; CObjectVector<CUpdateArchiveCommand>::operator[](uint)
.text:00002C94                 mov     [ebp+var_420], eax
.text:00002C9A                 lea     ecx, [ebp+var_430]
.text:00002CA0                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00002CA5                 mov     byte ptr [ebp+var_4], 16h
.text:00002CA9                 mov     ecx, [ebp+arg_10]
.text:00002CAC                 movzx   edx, byte ptr [ecx+0C4h]
.text:00002CB3                 test    edx, edx
.text:00002CB5                 jz      short loc_2CD8
.text:00002CB7                 push    offset $SG75524 ; "stdout"
.text:00002CBC                 lea     ecx, [ebp+var_430] ; this
.text:00002CC2                 call    ?SetFromAscii@UString@@QAEXPBD@Z ; UString::SetFromAscii(char const *)
.text:00002CC7                 mov     al, [ebp+var_1B1]
.text:00002CCD                 mov     [ebp+var_435], al
.text:00002CD3                 jmp     loc_2D65
.text:00002CD8 ; ---------------------------------------------------------------------------
.text:00002CD8
.text:00002CD8 loc_2CD8:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1599j
.text:00002CD8                 lea     ecx, [ebp+var_6AC]
.text:00002CDE                 push    ecx
.text:00002CDF                 mov     ecx, [ebp+var_420]
.text:00002CE5                 add     ecx, 0Ch
.text:00002CE8                 call    ?GetFinalPath@CArchivePath@@QBE?AVUString@@XZ ; CArchivePath::GetFinalPath(void)
.text:00002CED                 mov     [ebp+var_6F4], eax
.text:00002CF3                 mov     edx, [ebp+var_6F4]
.text:00002CF9                 mov     [ebp+var_6F8], edx
.text:00002CFF                 mov     byte ptr [ebp+var_4], 17h
.text:00002D03                 mov     eax, [ebp+var_6F8]
.text:00002D09                 push    eax
.text:00002D0A                 lea     ecx, [ebp+var_430]
.text:00002D10                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:00002D15                 mov     byte ptr [ebp+var_4], 16h
.text:00002D19                 lea     ecx, [ebp+var_6AC] ; this
.text:00002D1F                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00002D24                 cmp     [ebp+var_3D4], 0
.text:00002D2B                 jnz     short loc_2D4F
.text:00002D2D                 mov     ecx, [ebp+arg_10]
.text:00002D30                 movzx   edx, byte ptr [ecx+44h]
.text:00002D34                 test    edx, edx
.text:00002D36                 jz      short loc_2D4F
.text:00002D38                 movzx   eax, [ebp+var_1B1]
.text:00002D3F                 test    eax, eax
.text:00002D41                 jz      short loc_2D4F
.text:00002D43                 mov     [ebp+var_6FC], 1
.text:00002D4D                 jmp     short loc_2D59
.text:00002D4F ; ---------------------------------------------------------------------------
.text:00002D4F
.text:00002D4F loc_2D4F:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+160Fj
.text:00002D4F                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+161Aj ...
.text:00002D4F                 mov     [ebp+var_6FC], 0
.text:00002D59
.text:00002D59 loc_2D59:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1631j
.text:00002D59                 mov     cl, byte ptr [ebp+var_6FC]
.text:00002D5F                 mov     [ebp+var_435], cl
.text:00002D65
.text:00002D65 loc_2D65:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+15B7j
.text:00002D65                 mov     esi, esp
.text:00002D67                 movzx   edx, [ebp+var_435]
.text:00002D6E                 push    edx             ; wchar_t *
.text:00002D6F                 lea     ecx, [ebp+var_430]
.text:00002D75                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00002D7A                 push    eax
.text:00002D7B                 mov     eax, [ebp+arg_1C]
.text:00002D7E                 mov     edx, [eax]
.text:00002D80                 mov     ecx, [ebp+arg_1C]
.text:00002D83                 mov     eax, [edx+4Ch]
.text:00002D86                 call    eax
.text:00002D88                 cmp     esi, esp
.text:00002D8A                 call    __RTC_CheckEsp
.text:00002D8F                 mov     [ebp+var_43C], eax
.text:00002D95                 cmp     [ebp+var_43C], 0
.text:00002D9C                 jz      loc_2E52
.text:00002DA2                 mov     ecx, [ebp+var_43C]
.text:00002DA8                 mov     [ebp+var_6B0], ecx
.text:00002DAE                 mov     byte ptr [ebp+var_4], 15h
.text:00002DB2                 lea     ecx, [ebp+var_430] ; this
.text:00002DB8                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00002DBD                 mov     byte ptr [ebp+var_4], 14h
.text:00002DC1                 lea     ecx, [ebp+var_410]
.text:00002DC7                 call    ??1?$CBuffer@E@@QAE@XZ ; CBuffer<uchar>::~CBuffer<uchar>(void)
.text:00002DCC                 mov     byte ptr [ebp+var_4], 12h
.text:00002DD0                 lea     ecx, [ebp+var_3FC]
.text:00002DD6                 call    ??1?$CObjectVector@UCArcItem@@@@QAE@XZ ; CObjectVector<CArcItem>::~CObjectVector<CArcItem>(void)
.text:00002DDB                 mov     byte ptr [ebp+var_4], 11h
.text:00002DDF                 lea     ecx, [ebp+var_3C4] ; this
.text:00002DE5                 call    ??1CTempFiles@@QAE@XZ ; CTempFiles::~CTempFiles(void)
.text:00002DEA                 mov     byte ptr [ebp+var_4], 10h
.text:00002DEE                 lea     ecx, [ebp+var_3B0] ; this
.text:00002DF4                 call    ??1CTempDir@NDir@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NDir::CTempDir::~CTempDir(void)
.text:00002DF9                 mov     byte ptr [ebp+var_4], 0Ch
.text:00002DFD                 lea     ecx, [ebp+var_394] ; this
.text:00002E03                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00002E08                 mov     byte ptr [ebp+var_4], 0Bh
.text:00002E0C                 lea     ecx, [ebp+var_2B0] ; this
.text:00002E12                 call    ??1CDirItem@@QAE@XZ ; CDirItem::~CDirItem(void)
.text:00002E17                 mov     byte ptr [ebp+var_4], 5
.text:00002E1B                 lea     ecx, [ebp+var_258] ; this
.text:00002E21                 call    ??1CDirItems@@QAE@XZ ; CDirItems::~CDirItems(void)
.text:00002E26                 mov     byte ptr [ebp+var_4], 4
.text:00002E2A                 lea     ecx, [ebp+var_CC] ; this
.text:00002E30                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00002E35                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00002E3C                 lea     ecx, [ebp+var_B8] ; this
.text:00002E42                 call    ??1CArchiveLink@@QAE@XZ ; CArchiveLink::~CArchiveLink(void)
.text:00002E47                 mov     eax, [ebp+var_6B0]
.text:00002E4D                 jmp     loc_3FA0
.text:00002E52 ; ---------------------------------------------------------------------------
.text:00002E52
.text:00002E52 loc_2E52:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1680j
.text:00002E52                 lea     ecx, [ebp+var_448] ; this
.text:00002E58                 call    ??0CFinishArchiveStat@@QAE@XZ ; CFinishArchiveStat::CFinishArchiveStat(void)
.text:00002E5D                 mov     edx, [ebp+arg_10]
.text:00002E60                 movzx   eax, byte ptr [edx+0F8h]
.text:00002E67                 test    eax, eax
.text:00002E69                 jz      short loc_2E7E
.text:00002E6B                 lea     ecx, [ebp+var_410]
.text:00002E71                 call    ??B?$CBuffer@E@@QAEPAEXZ ; CBuffer<uchar>::operator uchar *(void)
.text:00002E76                 mov     [ebp+var_700], eax
.text:00002E7C                 jmp     short loc_2E88
.text:00002E7E ; ---------------------------------------------------------------------------
.text:00002E7E
.text:00002E7E loc_2E7E:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+174Dj
.text:00002E7E                 mov     [ebp+var_700], 0
.text:00002E88
.text:00002E88 loc_2E88:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1760j
.text:00002E88                 lea     ecx, [ebp+var_448]
.text:00002E8E                 push    ecx             ; int
.text:00002E8F                 mov     edx, [ebp+arg_1C]
.text:00002E92                 push    edx             ; int
.text:00002E93                 mov     eax, [ebp+arg_14]
.text:00002E96                 push    eax             ; CUpdateErrorInfo *
.text:00002E97                 lea     ecx, [ebp+var_3C4]
.text:00002E9D                 push    ecx             ; int
.text:00002E9E                 mov     edx, [ebp+var_2B8]
.text:00002EA4                 push    edx             ; int
.text:00002EA5                 lea     eax, [ebp+var_258]
.text:00002EAB                 push    eax             ; int
.text:00002EAC                 mov     ecx, [ebp+var_700]
.text:00002EB2                 push    ecx             ; int
.text:00002EB3                 lea     edx, [ebp+var_3FC]
.text:00002EB9                 push    edx             ; int
.text:00002EBA                 mov     eax, [ebp+var_420]
.text:00002EC0                 add     eax, 0Ch
.text:00002EC3                 push    eax             ; int
.text:00002EC4                 mov     ecx, [ebp+var_41C]
.text:00002ECA                 push    ecx             ; CArc *
.text:00002ECB                 mov     edx, [ebp+var_420]
.text:00002ED1                 add     edx, 64h ; 'd'
.text:00002ED4                 push    edx             ; int
.text:00002ED5                 mov     eax, [ebp+arg_0]
.text:00002ED8                 push    eax             ; int
.text:00002ED9                 movzx   ecx, [ebp+var_435]
.text:00002EE0                 push    ecx             ; char
.text:00002EE1                 mov     edx, [ebp+arg_10]
.text:00002EE4                 push    edx             ; int
.text:00002EE5                 call    ?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)
.text:00002EEA                 mov     [ebp+var_450], eax
.text:00002EF0                 cmp     [ebp+var_450], 0
.text:00002EF7                 jz      loc_2FAD
.text:00002EFD                 mov     eax, [ebp+var_450]
.text:00002F03                 mov     [ebp+var_6B4], eax
.text:00002F09                 mov     byte ptr [ebp+var_4], 15h
.text:00002F0D                 lea     ecx, [ebp+var_430] ; this
.text:00002F13                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00002F18                 mov     byte ptr [ebp+var_4], 14h
.text:00002F1C                 lea     ecx, [ebp+var_410]
.text:00002F22                 call    ??1?$CBuffer@E@@QAE@XZ ; CBuffer<uchar>::~CBuffer<uchar>(void)
.text:00002F27                 mov     byte ptr [ebp+var_4], 12h
.text:00002F2B                 lea     ecx, [ebp+var_3FC]
.text:00002F31                 call    ??1?$CObjectVector@UCArcItem@@@@QAE@XZ ; CObjectVector<CArcItem>::~CObjectVector<CArcItem>(void)
.text:00002F36                 mov     byte ptr [ebp+var_4], 11h
.text:00002F3A                 lea     ecx, [ebp+var_3C4] ; this
.text:00002F40                 call    ??1CTempFiles@@QAE@XZ ; CTempFiles::~CTempFiles(void)
.text:00002F45                 mov     byte ptr [ebp+var_4], 10h
.text:00002F49                 lea     ecx, [ebp+var_3B0] ; this
.text:00002F4F                 call    ??1CTempDir@NDir@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NDir::CTempDir::~CTempDir(void)
.text:00002F54                 mov     byte ptr [ebp+var_4], 0Ch
.text:00002F58                 lea     ecx, [ebp+var_394] ; this
.text:00002F5E                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00002F63                 mov     byte ptr [ebp+var_4], 0Bh
.text:00002F67                 lea     ecx, [ebp+var_2B0] ; this
.text:00002F6D                 call    ??1CDirItem@@QAE@XZ ; CDirItem::~CDirItem(void)
.text:00002F72                 mov     byte ptr [ebp+var_4], 5
.text:00002F76                 lea     ecx, [ebp+var_258] ; this
.text:00002F7C                 call    ??1CDirItems@@QAE@XZ ; CDirItems::~CDirItems(void)
.text:00002F81                 mov     byte ptr [ebp+var_4], 4
.text:00002F85                 lea     ecx, [ebp+var_CC] ; this
.text:00002F8B                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00002F90                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00002F97                 lea     ecx, [ebp+var_B8] ; this
.text:00002F9D                 call    ??1CArchiveLink@@QAE@XZ ; CArchiveLink::~CArchiveLink(void)
.text:00002FA2                 mov     eax, [ebp+var_6B4]
.text:00002FA8                 jmp     loc_3FA0
.text:00002FAD ; ---------------------------------------------------------------------------
.text:00002FAD
.text:00002FAD loc_2FAD:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+17DBj
.text:00002FAD                 mov     esi, esp
.text:00002FAF                 lea     ecx, [ebp+var_448]
.text:00002FB5                 push    ecx
.text:00002FB6                 mov     edx, [ebp+arg_1C]
.text:00002FB9                 mov     eax, [edx]
.text:00002FBB                 mov     ecx, [ebp+arg_1C]
.text:00002FBE                 mov     edx, [eax+50h]
.text:00002FC1                 call    edx
.text:00002FC3                 cmp     esi, esp
.text:00002FC5                 call    __RTC_CheckEsp
.text:00002FCA                 mov     [ebp+var_454], eax
.text:00002FD0                 cmp     [ebp+var_454], 0
.text:00002FD7                 jz      loc_308D
.text:00002FDD                 mov     eax, [ebp+var_454]
.text:00002FE3                 mov     [ebp+var_6B8], eax
.text:00002FE9                 mov     byte ptr [ebp+var_4], 15h
.text:00002FED                 lea     ecx, [ebp+var_430] ; this
.text:00002FF3                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00002FF8                 mov     byte ptr [ebp+var_4], 14h
.text:00002FFC                 lea     ecx, [ebp+var_410]
.text:00003002                 call    ??1?$CBuffer@E@@QAE@XZ ; CBuffer<uchar>::~CBuffer<uchar>(void)
.text:00003007                 mov     byte ptr [ebp+var_4], 12h
.text:0000300B                 lea     ecx, [ebp+var_3FC]
.text:00003011                 call    ??1?$CObjectVector@UCArcItem@@@@QAE@XZ ; CObjectVector<CArcItem>::~CObjectVector<CArcItem>(void)
.text:00003016                 mov     byte ptr [ebp+var_4], 11h
.text:0000301A                 lea     ecx, [ebp+var_3C4] ; this
.text:00003020                 call    ??1CTempFiles@@QAE@XZ ; CTempFiles::~CTempFiles(void)
.text:00003025                 mov     byte ptr [ebp+var_4], 10h
.text:00003029                 lea     ecx, [ebp+var_3B0] ; this
.text:0000302F                 call    ??1CTempDir@NDir@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NDir::CTempDir::~CTempDir(void)
.text:00003034                 mov     byte ptr [ebp+var_4], 0Ch
.text:00003038                 lea     ecx, [ebp+var_394] ; this
.text:0000303E                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003043                 mov     byte ptr [ebp+var_4], 0Bh
.text:00003047                 lea     ecx, [ebp+var_2B0] ; this
.text:0000304D                 call    ??1CDirItem@@QAE@XZ ; CDirItem::~CDirItem(void)
.text:00003052                 mov     byte ptr [ebp+var_4], 5
.text:00003056                 lea     ecx, [ebp+var_258] ; this
.text:0000305C                 call    ??1CDirItems@@QAE@XZ ; CDirItems::~CDirItems(void)
.text:00003061                 mov     byte ptr [ebp+var_4], 4
.text:00003065                 lea     ecx, [ebp+var_CC] ; this
.text:0000306B                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003070                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00003077                 lea     ecx, [ebp+var_B8] ; this
.text:0000307D                 call    ??1CArchiveLink@@QAE@XZ ; CArchiveLink::~CArchiveLink(void)
.text:00003082                 mov     eax, [ebp+var_6B8]
.text:00003088                 jmp     loc_3FA0
.text:0000308D ; ---------------------------------------------------------------------------
.text:0000308D
.text:0000308D loc_308D:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+18BBj
.text:0000308D                 mov     byte ptr [ebp+var_4], 15h
.text:00003091                 lea     ecx, [ebp+var_430] ; this
.text:00003097                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000309C                 jmp     loc_2C28
.text:000030A1 ; ---------------------------------------------------------------------------
.text:000030A1
.text:000030A1 loc_30A1:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+152Cj
.text:000030A1                 movzx   ecx, [ebp+var_1B1]
.text:000030A8                 test    ecx, ecx
.text:000030AA                 jz      loc_317A
.text:000030B0                 lea     ecx, [ebp+var_B8] ; this
.text:000030B6                 call    ?Close@CArchiveLink@@QAEJXZ ; CArchiveLink::Close(void)
.text:000030BB                 mov     [ebp+var_458], eax
.text:000030C1                 cmp     [ebp+var_458], 0
.text:000030C8                 jz      loc_316F
.text:000030CE                 mov     edx, [ebp+var_458]
.text:000030D4                 mov     [ebp+var_6BC], edx
.text:000030DA                 mov     byte ptr [ebp+var_4], 14h
.text:000030DE                 lea     ecx, [ebp+var_410]
.text:000030E4                 call    ??1?$CBuffer@E@@QAE@XZ ; CBuffer<uchar>::~CBuffer<uchar>(void)
.text:000030E9                 mov     byte ptr [ebp+var_4], 12h
.text:000030ED                 lea     ecx, [ebp+var_3FC]
.text:000030F3                 call    ??1?$CObjectVector@UCArcItem@@@@QAE@XZ ; CObjectVector<CArcItem>::~CObjectVector<CArcItem>(void)
.text:000030F8                 mov     byte ptr [ebp+var_4], 11h
.text:000030FC                 lea     ecx, [ebp+var_3C4] ; this
.text:00003102                 call    ??1CTempFiles@@QAE@XZ ; CTempFiles::~CTempFiles(void)
.text:00003107                 mov     byte ptr [ebp+var_4], 10h
.text:0000310B                 lea     ecx, [ebp+var_3B0] ; this
.text:00003111                 call    ??1CTempDir@NDir@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NDir::CTempDir::~CTempDir(void)
.text:00003116                 mov     byte ptr [ebp+var_4], 0Ch
.text:0000311A                 lea     ecx, [ebp+var_394] ; this
.text:00003120                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003125                 mov     byte ptr [ebp+var_4], 0Bh
.text:00003129                 lea     ecx, [ebp+var_2B0] ; this
.text:0000312F                 call    ??1CDirItem@@QAE@XZ ; CDirItem::~CDirItem(void)
.text:00003134                 mov     byte ptr [ebp+var_4], 5
.text:00003138                 lea     ecx, [ebp+var_258] ; this
.text:0000313E                 call    ??1CDirItems@@QAE@XZ ; CDirItems::~CDirItems(void)
.text:00003143                 mov     byte ptr [ebp+var_4], 4
.text:00003147                 lea     ecx, [ebp+var_CC] ; this
.text:0000314D                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003152                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00003159                 lea     ecx, [ebp+var_B8] ; this
.text:0000315F                 call    ??1CArchiveLink@@QAE@XZ ; CArchiveLink::~CArchiveLink(void)
.text:00003164                 mov     eax, [ebp+var_6BC]
.text:0000316A                 jmp     loc_3FA0
.text:0000316F ; ---------------------------------------------------------------------------
.text:0000316F
.text:0000316F loc_316F:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+19ACj
.text:0000316F                 lea     ecx, [ebp+var_B8] ; this
.text:00003175                 call    ?Release@CArchiveLink@@QAEXXZ ; CArchiveLink::Release(void)
.text:0000317A
.text:0000317A loc_317A:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+198Ej
.text:0000317A                 lea     ecx, [ebp+var_3C4]
.text:00003180                 call    ?Clear@?$CObjectVector@VUString@@@@QAEXXZ ; CObjectVector<UString>::Clear(void)
.text:00003185                 movzx   eax, [ebp+var_3C9]
.text:0000318C                 test    eax, eax
.text:0000318E                 jz      $LN32_0
.text:00003194                 mov     byte ptr [ebp+var_4], 18h
.text:00003198                 push    0
.text:0000319A                 mov     ecx, [ebp+arg_10]
.text:0000319D                 add     ecx, 38h ; '8'
.text:000031A0                 call    ??A?$CObjectVector@UCUpdateArchiveCommand@@@@QAEAAUCUpdateArchiveCommand@@I@Z ; CObjectVector<CUpdateArchiveCommand>::operator[](uint)
.text:000031A5                 mov     [ebp+var_704], eax
.text:000031AB                 mov     ecx, [ebp+var_704]
.text:000031B1                 add     ecx, 0Ch
.text:000031B4                 mov     [ebp+var_45C], ecx
.text:000031BA                 lea     edx, [ebp+var_470]
.text:000031C0                 push    edx
.text:000031C1                 mov     ecx, [ebp+var_45C]
.text:000031C7                 call    ?GetTempPathA@CArchivePath@@QBE?AVUString@@XZ ; CArchivePath::GetTempPathA(void)
.text:000031CC                 mov     [ebp+var_708], eax
.text:000031D2                 mov     byte ptr [ebp+var_4], 19h
.text:000031D6                 lea     eax, [ebp+var_470]
.text:000031DC                 mov     [ebp+var_460], eax
.text:000031E2                 movzx   ecx, [ebp+var_1B1]
.text:000031E9                 test    ecx, ecx
.text:000031EB                 jz      loc_32ED
.text:000031F1                 lea     ecx, [ebp+var_CC]
.text:000031F7                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000031FC                 mov     [ebp+var_70C], eax
.text:00003202                 mov     edx, [ebp+var_70C]
.text:00003208                 push    edx             ; this
.text:00003209                 call    ?DeleteFileAlways@NDir@NFile@NWindows@@YG_NPB_W@Z ; NWindows::NFile::NDir::DeleteFileAlways(wchar_t const *)
.text:0000320E                 mov     [ebp+var_70D], al
.text:00003214                 movzx   eax, [ebp+var_70D]
.text:0000321B                 test    eax, eax
.text:0000321D                 jnz     loc_32ED
.text:00003223                 lea     ecx, [ebp+var_CC]
.text:00003229                 push    ecx             ; struct UString *
.text:0000322A                 push    offset $SG75551 ; "cannot delete the file"
.text:0000322F                 mov     ecx, [ebp+arg_14] ; this
.text:00003232                 call    ?SetFromLastError@CUpdateErrorInfo@@QAEJPBDABVUString@@@Z ; CUpdateErrorInfo::SetFromLastError(char const *,UString const &)
.text:00003237                 mov     [ebp+var_714], eax
.text:0000323D                 mov     edx, [ebp+var_714]
.text:00003243                 mov     [ebp+var_6C0], edx
.text:00003249                 mov     byte ptr [ebp+var_4], 18h
.text:0000324D                 lea     ecx, [ebp+var_470] ; this
.text:00003253                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003258                 mov     byte ptr [ebp+var_4], 14h
.text:0000325C                 lea     ecx, [ebp+var_410]
.text:00003262                 call    ??1?$CBuffer@E@@QAE@XZ ; CBuffer<uchar>::~CBuffer<uchar>(void)
.text:00003267                 mov     byte ptr [ebp+var_4], 12h
.text:0000326B                 lea     ecx, [ebp+var_3FC]
.text:00003271                 call    ??1?$CObjectVector@UCArcItem@@@@QAE@XZ ; CObjectVector<CArcItem>::~CObjectVector<CArcItem>(void)
.text:00003276                 mov     byte ptr [ebp+var_4], 11h
.text:0000327A                 lea     ecx, [ebp+var_3C4] ; this
.text:00003280                 call    ??1CTempFiles@@QAE@XZ ; CTempFiles::~CTempFiles(void)
.text:00003285                 mov     byte ptr [ebp+var_4], 10h
.text:00003289                 lea     ecx, [ebp+var_3B0] ; this
.text:0000328F                 call    ??1CTempDir@NDir@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NDir::CTempDir::~CTempDir(void)
.text:00003294                 mov     byte ptr [ebp+var_4], 0Ch
.text:00003298                 lea     ecx, [ebp+var_394] ; this
.text:0000329E                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000032A3                 mov     byte ptr [ebp+var_4], 0Bh
.text:000032A7                 lea     ecx, [ebp+var_2B0] ; this
.text:000032AD                 call    ??1CDirItem@@QAE@XZ ; CDirItem::~CDirItem(void)
.text:000032B2                 mov     byte ptr [ebp+var_4], 5
.text:000032B6                 lea     ecx, [ebp+var_258] ; this
.text:000032BC                 call    ??1CDirItems@@QAE@XZ ; CDirItems::~CDirItems(void)
.text:000032C1                 mov     byte ptr [ebp+var_4], 4
.text:000032C5                 lea     ecx, [ebp+var_CC] ; this
.text:000032CB                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000032D0                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000032D7                 lea     ecx, [ebp+var_B8] ; this
.text:000032DD                 call    ??1CArchiveLink@@QAE@XZ ; CArchiveLink::~CArchiveLink(void)
.text:000032E2                 mov     eax, [ebp+var_6C0]
.text:000032E8                 jmp     loc_3FA0
.text:000032ED ; ---------------------------------------------------------------------------
.text:000032ED
.text:000032ED loc_32ED:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1ACFj
.text:000032ED                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1B01j
.text:000032ED                 lea     ecx, [ebp+var_CC]
.text:000032F3                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000032F8                 mov     [ebp+var_718], eax
.text:000032FE                 mov     ecx, [ebp+var_460]
.text:00003304                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00003309                 mov     [ebp+var_71C], eax
.text:0000330F                 mov     eax, [ebp+var_718]
.text:00003315                 push    eax             ; wchar_t *
.text:00003316                 mov     ecx, [ebp+var_71C]
.text:0000331C                 push    ecx             ; struct UString *
.text:0000331D                 call    ?MyMoveFile@NDir@NFile@NWindows@@YG_NPB_W0@Z ; NWindows::NFile::NDir::MyMoveFile(wchar_t const *,wchar_t const *)
.text:00003322                 mov     [ebp+var_71D], al
.text:00003328                 movzx   edx, [ebp+var_71D]
.text:0000332F                 test    edx, edx
.text:00003331                 jnz     loc_341B
.text:00003337                 mov     eax, [ebp+var_460]
.text:0000333D                 push    eax             ; struct UString *
.text:0000333E                 push    offset $SG75553 ; "cannot move the file"
.text:00003343                 mov     ecx, [ebp+arg_14] ; this
.text:00003346                 call    ?SetFromLastError@CUpdateErrorInfo@@QAEJPBDABVUString@@@Z ; CUpdateErrorInfo::SetFromLastError(char const *,UString const &)
.text:0000334B                 lea     ecx, [ebp+var_CC]
.text:00003351                 push    ecx
.text:00003352                 mov     ecx, [ebp+arg_14]
.text:00003355                 add     ecx, 10h
.text:00003358                 call    ?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z ; CObjectVector<UString>::Add(UString const &)
.text:0000335D                 mov     ecx, [ebp+arg_14] ; this
.text:00003360                 call    ?Get_HRESULT_Error@CUpdateErrorInfo@@QBEJXZ ; CUpdateErrorInfo::Get_HRESULT_Error(void)
.text:00003365                 mov     [ebp+var_724], eax
.text:0000336B                 mov     edx, [ebp+var_724]
.text:00003371                 mov     [ebp+var_6C4], edx
.text:00003377                 mov     byte ptr [ebp+var_4], 18h
.text:0000337B                 lea     ecx, [ebp+var_470] ; this
.text:00003381                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003386                 mov     byte ptr [ebp+var_4], 14h
.text:0000338A                 lea     ecx, [ebp+var_410]
.text:00003390                 call    ??1?$CBuffer@E@@QAE@XZ ; CBuffer<uchar>::~CBuffer<uchar>(void)
.text:00003395                 mov     byte ptr [ebp+var_4], 12h
.text:00003399                 lea     ecx, [ebp+var_3FC]
.text:0000339F                 call    ??1?$CObjectVector@UCArcItem@@@@QAE@XZ ; CObjectVector<CArcItem>::~CObjectVector<CArcItem>(void)
.text:000033A4                 mov     byte ptr [ebp+var_4], 11h
.text:000033A8                 lea     ecx, [ebp+var_3C4] ; this
.text:000033AE                 call    ??1CTempFiles@@QAE@XZ ; CTempFiles::~CTempFiles(void)
.text:000033B3                 mov     byte ptr [ebp+var_4], 10h
.text:000033B7                 lea     ecx, [ebp+var_3B0] ; this
.text:000033BD                 call    ??1CTempDir@NDir@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NDir::CTempDir::~CTempDir(void)
.text:000033C2                 mov     byte ptr [ebp+var_4], 0Ch
.text:000033C6                 lea     ecx, [ebp+var_394] ; this
.text:000033CC                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000033D1                 mov     byte ptr [ebp+var_4], 0Bh
.text:000033D5                 lea     ecx, [ebp+var_2B0] ; this
.text:000033DB                 call    ??1CDirItem@@QAE@XZ ; CDirItem::~CDirItem(void)
.text:000033E0                 mov     byte ptr [ebp+var_4], 5
.text:000033E4                 lea     ecx, [ebp+var_258] ; this
.text:000033EA                 call    ??1CDirItems@@QAE@XZ ; CDirItems::~CDirItems(void)
.text:000033EF                 mov     byte ptr [ebp+var_4], 4
.text:000033F3                 lea     ecx, [ebp+var_CC] ; this
.text:000033F9                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000033FE                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00003405                 lea     ecx, [ebp+var_B8] ; this
.text:0000340B                 call    ??1CArchiveLink@@QAE@XZ ; CArchiveLink::~CArchiveLink(void)
.text:00003410                 mov     eax, [ebp+var_6C4]
.text:00003416                 jmp     loc_3FA0
.text:0000341B ; ---------------------------------------------------------------------------
.text:0000341B
.text:0000341B loc_341B:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1C15j
.text:0000341B                 mov     byte ptr [ebp+var_4], 18h
.text:0000341F                 lea     ecx, [ebp+var_470] ; this
.text:00003425                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000342A                 jmp     short loc_3442
.text:0000342A ?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z endp ; sp-analysis failed
.text:0000342A
.text:0000342C
.text:0000342C ; =============== S U B R O U T I N E =======================================
.text:0000342C
.text:0000342C ; Attributes: noreturn
.text:0000342C
.text:0000342C __catch$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$0 proc near
.text:0000342C                                         ; DATA XREF: .xdata$x:00007460o
.text:0000342C                 push    0
.text:0000342E                 push    0
.text:00003430                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:00003430 __catch$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$0 endp
.text:00003430
.text:00003435 ; ---------------------------------------------------------------------------
.text:00003435                 mov     dword ptr [ebp-4], 15h
.text:0000343C                 mov     eax, offset $LN32_0
.text:00003441                 retn
.text:00003442 ; ---------------------------------------------------------------------------
.text:00003442 ; START OF FUNCTION CHUNK FOR ?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z
.text:00003442
.text:00003442 loc_3442:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1D0Ej
.text:00003442                 mov     [ebp+var_4], 15h
.text:00003449
.text:00003449 $LN32_0:                                ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1A72j
.text:00003449                                         ; DATA XREF: .text:0000343Co
.text:00003449                 mov     eax, [ebp+arg_10]
.text:0000344C                 movzx   ecx, byte ptr [eax+0C5h]
.text:00003453                 test    ecx, ecx
.text:00003455                 jz      loc_3A04
.text:0000345B                 lea     ecx, [ebp+var_47C] ; this
.text:00003461                 call    ??0CLibrary@NDLL@NWindows@@QAE@XZ ; NWindows::NDLL::CLibrary::CLibrary(void)
.text:00003466                 mov     byte ptr [ebp+var_4], 1Bh
.text:0000346A                 push    offset $SG75558 ; "Mapi32.dll"
.text:0000346F                 lea     ecx, [ebp+var_47C] ; this
.text:00003475                 call    ?Load@CLibrary@NDLL@NWindows@@QAE_NPB_W@Z ; NWindows::NDLL::CLibrary::Load(wchar_t const *)
.text:0000347A                 movzx   edx, al
.text:0000347D                 test    edx, edx
.text:0000347F                 jnz     loc_3544
.text:00003485                 push    offset $SG75559 ; "cannot load Mapi32.dll"
.text:0000348A                 mov     ecx, [ebp+arg_14] ; this
.text:0000348D                 call    ?SetFromLastError@CUpdateErrorInfo@@QAEXPBD@Z ; CUpdateErrorInfo::SetFromLastError(char const *)
.text:00003492                 mov     ecx, [ebp+arg_14] ; this
.text:00003495                 call    ?Get_HRESULT_Error@CUpdateErrorInfo@@QBEJXZ ; CUpdateErrorInfo::Get_HRESULT_Error(void)
.text:0000349A                 mov     [ebp+var_6C8], eax
.text:000034A0                 mov     byte ptr [ebp+var_4], 15h
.text:000034A4                 lea     ecx, [ebp+var_47C] ; this
.text:000034AA                 call    ??1CLibrary@NDLL@NWindows@@QAE@XZ ; NWindows::NDLL::CLibrary::~CLibrary(void)
.text:000034AF                 mov     byte ptr [ebp+var_4], 14h
.text:000034B3                 lea     ecx, [ebp+var_410]
.text:000034B9                 call    ??1?$CBuffer@E@@QAE@XZ ; CBuffer<uchar>::~CBuffer<uchar>(void)
.text:000034BE                 mov     byte ptr [ebp+var_4], 12h
.text:000034C2                 lea     ecx, [ebp+var_3FC]
.text:000034C8                 call    ??1?$CObjectVector@UCArcItem@@@@QAE@XZ ; CObjectVector<CArcItem>::~CObjectVector<CArcItem>(void)
.text:000034CD                 mov     byte ptr [ebp+var_4], 11h
.text:000034D1                 lea     ecx, [ebp+var_3C4] ; this
.text:000034D7                 call    ??1CTempFiles@@QAE@XZ ; CTempFiles::~CTempFiles(void)
.text:000034DC                 mov     byte ptr [ebp+var_4], 10h
.text:000034E0                 lea     ecx, [ebp+var_3B0] ; this
.text:000034E6                 call    ??1CTempDir@NDir@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NDir::CTempDir::~CTempDir(void)
.text:000034EB                 mov     byte ptr [ebp+var_4], 0Ch
.text:000034EF                 lea     ecx, [ebp+var_394] ; this
.text:000034F5                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000034FA                 mov     byte ptr [ebp+var_4], 0Bh
.text:000034FE                 lea     ecx, [ebp+var_2B0] ; this
.text:00003504                 call    ??1CDirItem@@QAE@XZ ; CDirItem::~CDirItem(void)
.text:00003509                 mov     byte ptr [ebp+var_4], 5
.text:0000350D                 lea     ecx, [ebp+var_258] ; this
.text:00003513                 call    ??1CDirItems@@QAE@XZ ; CDirItems::~CDirItems(void)
.text:00003518                 mov     byte ptr [ebp+var_4], 4
.text:0000351C                 lea     ecx, [ebp+var_CC] ; this
.text:00003522                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003527                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000352E                 lea     ecx, [ebp+var_B8] ; this
.text:00003534                 call    ??1CArchiveLink@@QAE@XZ ; CArchiveLink::~CArchiveLink(void)
.text:00003539                 mov     eax, [ebp+var_6C8]
.text:0000353F                 jmp     loc_3FA0
.text:00003544 ; ---------------------------------------------------------------------------
.text:00003544
.text:00003544 loc_3544:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1D63j
.text:00003544                 push    offset $SG75563 ; "MAPISendMail"
.text:00003549                 lea     ecx, [ebp+var_47C]
.text:0000354F                 call    ?GetProc@CLibrary@NDLL@NWindows@@QBEP6GHXZPBD@Z ; NWindows::NDLL::CLibrary::GetProc(char const *)
.text:00003554                 mov     [ebp+var_484], eax
.text:0000355A                 cmp     [ebp+var_484], 0
.text:00003561                 jnz     loc_3626
.text:00003567                 push    offset $SG75565 ; "7-Zip cannot find MAPISendMail function"
.text:0000356C                 mov     ecx, [ebp+arg_14] ; this
.text:0000356F                 call    ?SetFromLastError@CUpdateErrorInfo@@QAEXPBD@Z ; CUpdateErrorInfo::SetFromLastError(char const *)
.text:00003574                 mov     ecx, [ebp+arg_14] ; this
.text:00003577                 call    ?Get_HRESULT_Error@CUpdateErrorInfo@@QBEJXZ ; CUpdateErrorInfo::Get_HRESULT_Error(void)
.text:0000357C                 mov     [ebp+var_6CC], eax
.text:00003582                 mov     byte ptr [ebp+var_4], 15h
.text:00003586                 lea     ecx, [ebp+var_47C] ; this
.text:0000358C                 call    ??1CLibrary@NDLL@NWindows@@QAE@XZ ; NWindows::NDLL::CLibrary::~CLibrary(void)
.text:00003591                 mov     byte ptr [ebp+var_4], 14h
.text:00003595                 lea     ecx, [ebp+var_410]
.text:0000359B                 call    ??1?$CBuffer@E@@QAE@XZ ; CBuffer<uchar>::~CBuffer<uchar>(void)
.text:000035A0                 mov     byte ptr [ebp+var_4], 12h
.text:000035A4                 lea     ecx, [ebp+var_3FC]
.text:000035AA                 call    ??1?$CObjectVector@UCArcItem@@@@QAE@XZ ; CObjectVector<CArcItem>::~CObjectVector<CArcItem>(void)
.text:000035AF                 mov     byte ptr [ebp+var_4], 11h
.text:000035B3                 lea     ecx, [ebp+var_3C4] ; this
.text:000035B9                 call    ??1CTempFiles@@QAE@XZ ; CTempFiles::~CTempFiles(void)
.text:000035BE                 mov     byte ptr [ebp+var_4], 10h
.text:000035C2                 lea     ecx, [ebp+var_3B0] ; this
.text:000035C8                 call    ??1CTempDir@NDir@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NDir::CTempDir::~CTempDir(void)
.text:000035CD                 mov     byte ptr [ebp+var_4], 0Ch
.text:000035D1                 lea     ecx, [ebp+var_394] ; this
.text:000035D7                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000035DC                 mov     byte ptr [ebp+var_4], 0Bh
.text:000035E0                 lea     ecx, [ebp+var_2B0] ; this
.text:000035E6                 call    ??1CDirItem@@QAE@XZ ; CDirItem::~CDirItem(void)
.text:000035EB                 mov     byte ptr [ebp+var_4], 5
.text:000035EF                 lea     ecx, [ebp+var_258] ; this
.text:000035F5                 call    ??1CDirItems@@QAE@XZ ; CDirItems::~CDirItems(void)
.text:000035FA                 mov     byte ptr [ebp+var_4], 4
.text:000035FE                 lea     ecx, [ebp+var_CC] ; this
.text:00003604                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003609                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00003610                 lea     ecx, [ebp+var_B8] ; this
.text:00003616                 call    ??1CArchiveLink@@QAE@XZ ; CArchiveLink::~CArchiveLink(void)
.text:0000361B                 mov     eax, [ebp+var_6CC]
.text:00003621                 jmp     loc_3FA0
.text:00003626 ; ---------------------------------------------------------------------------
.text:00003626
.text:00003626 loc_3626:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1E45j
.text:00003626                 lea     ecx, [ebp+var_494]
.text:0000362C                 call    ??0?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::CObjectVector<UString>(void)
.text:00003631                 mov     byte ptr [ebp+var_4], 1Ch
.text:00003635                 mov     [ebp+var_49C], 0
.text:0000363F                 jmp     short loc_3650
.text:00003641 ; ---------------------------------------------------------------------------
.text:00003641
.text:00003641 loc_3641:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+20C9j
.text:00003641                 mov     eax, [ebp+var_49C]
.text:00003647                 add     eax, 1
.text:0000364A                 mov     [ebp+var_49C], eax
.text:00003650
.text:00003650 loc_3650:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1F23j
.text:00003650                 mov     ecx, [ebp+arg_10]
.text:00003653                 add     ecx, 38h ; '8'
.text:00003656                 call    ?Size@?$CObjectVector@UCUpdateArchiveCommand@@@@QBEIXZ ; CObjectVector<CUpdateArchiveCommand>::Size(void)
.text:0000365B                 cmp     [ebp+var_49C], eax
.text:00003661                 jnb     loc_37EA
.text:00003667                 mov     ecx, [ebp+var_49C]
.text:0000366D                 push    ecx
.text:0000366E                 mov     ecx, [ebp+arg_10]
.text:00003671                 add     ecx, 38h ; '8'
.text:00003674                 call    ??A?$CObjectVector@UCUpdateArchiveCommand@@@@QAEAAUCUpdateArchiveCommand@@I@Z ; CObjectVector<CUpdateArchiveCommand>::operator[](uint)
.text:00003679                 add     eax, 0Ch
.text:0000367C                 mov     [ebp+var_4A0], eax
.text:00003682                 lea     edx, [ebp+var_4B0]
.text:00003688                 push    edx
.text:00003689                 mov     ecx, [ebp+var_4A0]
.text:0000368F                 call    ?GetFinalPath@CArchivePath@@QBE?AVUString@@XZ ; CArchivePath::GetFinalPath(void)
.text:00003694                 mov     byte ptr [ebp+var_4], 1Dh
.text:00003698                 lea     ecx, [ebp+var_4C4]
.text:0000369E                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:000036A3                 mov     byte ptr [ebp+var_4], 1Eh
.text:000036A7                 lea     eax, [ebp+var_4C4]
.text:000036AD                 push    eax             ; wchar_t *
.text:000036AE                 lea     ecx, [ebp+var_4B0]
.text:000036B4                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000036B9                 push    eax             ; this
.text:000036BA                 call    ?MyGetFullPathName@NDir@NFile@NWindows@@YG_NPB_WAAVUString@@@Z ; NWindows::NFile::NDir::MyGetFullPathName(wchar_t const *,UString &)
.text:000036BF                 movzx   ecx, al
.text:000036C2                 test    ecx, ecx
.text:000036C4                 jnz     loc_37B5
.text:000036CA                 lea     edx, [ebp+var_4B0]
.text:000036D0                 push    edx             ; struct UString *
.text:000036D1                 push    offset $SG75578 ; "GetFullPathName error"
.text:000036D6                 mov     ecx, [ebp+arg_14] ; this
.text:000036D9                 call    ?SetFromLastError@CUpdateErrorInfo@@QAEJPBDABVUString@@@Z ; CUpdateErrorInfo::SetFromLastError(char const *,UString const &)
.text:000036DE                 mov     [ebp+var_6D0], eax
.text:000036E4                 mov     byte ptr [ebp+var_4], 1Dh
.text:000036E8                 lea     ecx, [ebp+var_4C4] ; this
.text:000036EE                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000036F3                 mov     byte ptr [ebp+var_4], 1Ch
.text:000036F7                 lea     ecx, [ebp+var_4B0] ; this
.text:000036FD                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003702                 mov     byte ptr [ebp+var_4], 1Bh
.text:00003706                 lea     ecx, [ebp+var_494]
.text:0000370C                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:00003711                 mov     byte ptr [ebp+var_4], 15h
.text:00003715                 lea     ecx, [ebp+var_47C] ; this
.text:0000371B                 call    ??1CLibrary@NDLL@NWindows@@QAE@XZ ; NWindows::NDLL::CLibrary::~CLibrary(void)
.text:00003720                 mov     byte ptr [ebp+var_4], 14h
.text:00003724                 lea     ecx, [ebp+var_410]
.text:0000372A                 call    ??1?$CBuffer@E@@QAE@XZ ; CBuffer<uchar>::~CBuffer<uchar>(void)
.text:0000372F                 mov     byte ptr [ebp+var_4], 12h
.text:00003733                 lea     ecx, [ebp+var_3FC]
.text:00003739                 call    ??1?$CObjectVector@UCArcItem@@@@QAE@XZ ; CObjectVector<CArcItem>::~CObjectVector<CArcItem>(void)
.text:0000373E                 mov     byte ptr [ebp+var_4], 11h
.text:00003742                 lea     ecx, [ebp+var_3C4] ; this
.text:00003748                 call    ??1CTempFiles@@QAE@XZ ; CTempFiles::~CTempFiles(void)
.text:0000374D                 mov     byte ptr [ebp+var_4], 10h
.text:00003751                 lea     ecx, [ebp+var_3B0] ; this
.text:00003757                 call    ??1CTempDir@NDir@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NDir::CTempDir::~CTempDir(void)
.text:0000375C                 mov     byte ptr [ebp+var_4], 0Ch
.text:00003760                 lea     ecx, [ebp+var_394] ; this
.text:00003766                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000376B                 mov     byte ptr [ebp+var_4], 0Bh
.text:0000376F                 lea     ecx, [ebp+var_2B0] ; this
.text:00003775                 call    ??1CDirItem@@QAE@XZ ; CDirItem::~CDirItem(void)
.text:0000377A                 mov     byte ptr [ebp+var_4], 5
.text:0000377E                 lea     ecx, [ebp+var_258] ; this
.text:00003784                 call    ??1CDirItems@@QAE@XZ ; CDirItems::~CDirItems(void)
.text:00003789                 mov     byte ptr [ebp+var_4], 4
.text:0000378D                 lea     ecx, [ebp+var_CC] ; this
.text:00003793                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003798                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000379F                 lea     ecx, [ebp+var_B8] ; this
.text:000037A5                 call    ??1CArchiveLink@@QAE@XZ ; CArchiveLink::~CArchiveLink(void)
.text:000037AA                 mov     eax, [ebp+var_6D0]
.text:000037B0                 jmp     loc_3FA0
.text:000037B5 ; ---------------------------------------------------------------------------
.text:000037B5
.text:000037B5 loc_37B5:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1FA8j
.text:000037B5                 lea     eax, [ebp+var_4C4]
.text:000037BB                 push    eax
.text:000037BC                 lea     ecx, [ebp+var_494]
.text:000037C2                 call    ?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z ; CObjectVector<UString>::Add(UString const &)
.text:000037C7                 mov     byte ptr [ebp+var_4], 1Dh
.text:000037CB                 lea     ecx, [ebp+var_4C4] ; this
.text:000037D1                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000037D6                 mov     byte ptr [ebp+var_4], 1Ch
.text:000037DA                 lea     ecx, [ebp+var_4B0] ; this
.text:000037E0                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000037E5                 jmp     loc_3641
.text:000037EA ; ---------------------------------------------------------------------------
.text:000037EA
.text:000037EA loc_37EA:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1F45j
.text:000037EA                 lea     ecx, [ebp+var_4DC] ; this
.text:000037F0                 call    ??0CCurrentDirRestorer@NDir@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NDir::CCurrentDirRestorer::CCurrentDirRestorer(void)
.text:000037F5                 mov     byte ptr [ebp+var_4], 1Fh
.text:000037F9                 mov     [ebp+var_49C], 0
.text:00003803                 jmp     short loc_3814
.text:00003805 ; ---------------------------------------------------------------------------
.text:00003805
.text:00003805 loc_3805:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+22B6j
.text:00003805                 mov     ecx, [ebp+var_49C]
.text:0000380B                 add     ecx, 1
.text:0000380E                 mov     [ebp+var_49C], ecx
.text:00003814
.text:00003814 loc_3814:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+20E7j
.text:00003814                 lea     ecx, [ebp+var_494]
.text:0000381A                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:0000381F                 cmp     [ebp+var_49C], eax
.text:00003825                 jnb     loc_39D7
.text:0000382B                 mov     edx, [ebp+var_49C]
.text:00003831                 push    edx
.text:00003832                 lea     ecx, [ebp+var_494]
.text:00003838                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:0000383D                 push    eax
.text:0000383E                 lea     ecx, [ebp+var_4F0]
.text:00003844                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00003849                 mov     byte ptr [ebp+var_4], 20h ; ' '
.text:0000384D                 lea     eax, [ebp+var_4F0]
.text:00003853                 push    eax
.text:00003854                 lea     ecx, [ebp+var_504]
.text:0000385A                 push    ecx
.text:0000385B                 call    ?ExtractFileNameFromPath@@YG?AVUString@@ABV1@@Z ; ExtractFileNameFromPath(UString const &)
.text:00003860                 mov     byte ptr [ebp+var_4], 21h ; '!'
.text:00003864                 lea     edx, [ebp+var_4F0]
.text:0000386A                 push    edx
.text:0000386B                 lea     eax, [ebp+var_518]
.text:00003871                 push    eax
.text:00003872                 call    ?GetAnsiString@@YG?AVAString@@ABVUString@@@Z ; GetAnsiString(UString const &)
.text:00003877                 mov     byte ptr [ebp+var_4], 22h ; '"'
.text:0000387B                 lea     ecx, [ebp+var_504]
.text:00003881                 push    ecx
.text:00003882                 lea     edx, [ebp+var_52C]
.text:00003888                 push    edx
.text:00003889                 call    ?GetAnsiString@@YG?AVAString@@ABVUString@@@Z ; GetAnsiString(UString const &)
.text:0000388E                 mov     byte ptr [ebp+var_4], 23h ; '#'
.text:00003892                 push    18h             ; Size
.text:00003894                 push    0               ; Val
.text:00003896                 lea     eax, [ebp+Dst]
.text:0000389C                 push    eax             ; Dst
.text:0000389D                 call    _memset
.text:000038A2                 add     esp, 0Ch
.text:000038A5                 mov     [ebp+var_544], 0FFFFFFFFh
.text:000038AF                 lea     ecx, [ebp+var_518]
.text:000038B5                 call    ??BAString@@QBEPBDXZ ; AString::operator char const *(void)
.text:000038BA                 mov     [ebp+var_540], eax
.text:000038C0                 lea     ecx, [ebp+var_52C]
.text:000038C6                 call    ??BAString@@QBEPBDXZ ; AString::operator char const *(void)
.text:000038CB                 mov     [ebp+var_53C], eax
.text:000038D1                 push    30h ; '0'       ; Size
.text:000038D3                 push    0               ; Val
.text:000038D5                 lea     ecx, [ebp+var_584]
.text:000038DB                 push    ecx             ; Dst
.text:000038DC                 call    _memset
.text:000038E1                 add     esp, 0Ch
.text:000038E4                 mov     [ebp+var_55C], 1
.text:000038EE                 lea     edx, [ebp+Dst]
.text:000038F4                 mov     [ebp+var_558], edx
.text:000038FA                 mov     eax, [ebp+arg_10]
.text:000038FD                 add     eax, 0C8h ; '+'
.text:00003902                 push    eax
.text:00003903                 lea     ecx, [ebp+var_598]
.text:00003909                 push    ecx
.text:0000390A                 call    ?GetAnsiString@@YG?AVAString@@ABVUString@@@Z ; GetAnsiString(UString const &)
.text:0000390F                 mov     byte ptr [ebp+var_4], 24h ; '$'
.text:00003913                 lea     ecx, [ebp+var_598] ; this
.text:00003919                 call    ?IsEmpty@AString@@QBE_NXZ ; AString::IsEmpty(void)
.text:0000391E                 movzx   edx, al
.text:00003921                 test    edx, edx
.text:00003923                 jnz     short loc_3969
.text:00003925                 push    18h             ; Size
.text:00003927                 push    0               ; Val
.text:00003929                 lea     eax, [ebp+var_5B8]
.text:0000392F                 push    eax             ; Dst
.text:00003930                 call    _memset
.text:00003935                 add     esp, 0Ch
.text:00003938                 mov     [ebp+var_5B4], 1
.text:00003942                 lea     ecx, [ebp+var_598]
.text:00003948                 call    ??BAString@@QBEPBDXZ ; AString::operator char const *(void)
.text:0000394D                 mov     [ebp+var_5AC], eax
.text:00003953                 mov     [ebp+var_564], 1
.text:0000395D                 lea     ecx, [ebp+var_5B8]
.text:00003963                 mov     [ebp+var_560], ecx
.text:00003969
.text:00003969 loc_3969:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+2207j
.text:00003969                 mov     esi, esp
.text:0000396B                 push    0               ; wchar_t *
.text:0000396D                 push    8
.text:0000396F                 lea     edx, [ebp+var_584]
.text:00003975                 push    edx
.text:00003976                 push    0
.text:00003978                 push    0
.text:0000397A                 call    [ebp+var_484]
.text:00003980                 cmp     esi, esp
.text:00003982                 call    __RTC_CheckEsp
.text:00003987                 mov     byte ptr [ebp+var_4], 23h ; '#'
.text:0000398B                 lea     ecx, [ebp+var_598] ; this
.text:00003991                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00003996                 mov     byte ptr [ebp+var_4], 22h ; '"'
.text:0000399A                 lea     ecx, [ebp+var_52C] ; this
.text:000039A0                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:000039A5                 mov     byte ptr [ebp+var_4], 21h ; '!'
.text:000039A9                 lea     ecx, [ebp+var_518] ; this
.text:000039AF                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:000039B4                 mov     byte ptr [ebp+var_4], 20h ; ' '
.text:000039B8                 lea     ecx, [ebp+var_504] ; this
.text:000039BE                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000039C3                 mov     byte ptr [ebp+var_4], 1Fh
.text:000039C7                 lea     ecx, [ebp+var_4F0] ; this
.text:000039CD                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000039D2                 jmp     loc_3805
.text:000039D7 ; ---------------------------------------------------------------------------
.text:000039D7
.text:000039D7 loc_39D7:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+2109j
.text:000039D7                 mov     byte ptr [ebp+var_4], 1Ch
.text:000039DB                 lea     ecx, [ebp+var_4DC] ; this
.text:000039E1                 call    ??1CCurrentDirRestorer@NDir@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NDir::CCurrentDirRestorer::~CCurrentDirRestorer(void)
.text:000039E6                 mov     byte ptr [ebp+var_4], 1Bh
.text:000039EA                 lea     ecx, [ebp+var_494]
.text:000039F0                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:000039F5                 mov     byte ptr [ebp+var_4], 15h
.text:000039F9                 lea     ecx, [ebp+var_47C] ; this
.text:000039FF                 call    ??1CLibrary@NDLL@NWindows@@QAE@XZ ; NWindows::NDLL::CLibrary::~CLibrary(void)
.text:00003A04
.text:00003A04 loc_3A04:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1D39j
.text:00003A04                 mov     eax, [ebp+arg_10]
.text:00003A07                 movzx   ecx, byte ptr [eax+0F8h]
.text:00003A0E                 test    ecx, ecx
.text:00003A10                 jz      loc_3F06
.text:00003A16                 lea     ecx, [ebp+var_5CC]
.text:00003A1C                 call    ??0?$CRecordVector@UCRefSortPair@@@@QAE@XZ ; CRecordVector<CRefSortPair>::CRecordVector<CRefSortPair>(void)
.text:00003A21                 mov     byte ptr [ebp+var_4], 25h ; '%'
.text:00003A25                 lea     ecx, [ebp+var_5E0]
.text:00003A2B                 call    ??0?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::CObjectVector<UString>(void)
.text:00003A30                 mov     byte ptr [ebp+var_4], 26h ; '&'
.text:00003A34                 mov     [ebp+var_3D4], 0
.text:00003A3E                 jmp     short loc_3A4F
.text:00003A40 ; ---------------------------------------------------------------------------
.text:00003A40
.text:00003A40 loc_3A40:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+252Ej
.text:00003A40                 mov     edx, [ebp+var_3D4]
.text:00003A46                 add     edx, 1
.text:00003A49                 mov     [ebp+var_3D4], edx
.text:00003A4F
.text:00003A4F loc_3A4F:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+2322j
.text:00003A4F                 lea     ecx, [ebp+var_234]
.text:00003A55                 call    ?Size@?$CObjectVector@UCDirItem@@@@QBEIXZ ; CObjectVector<CDirItem>::Size(void)
.text:00003A5A                 cmp     [ebp+var_3D4], eax
.text:00003A60                 jnb     loc_3C4F
.text:00003A66                 mov     eax, [ebp+var_3D4]
.text:00003A6C                 push    eax
.text:00003A6D                 lea     ecx, [ebp+var_234]
.text:00003A73                 call    ??A?$CObjectVector@UCDirItem@@@@QAEAAUCDirItem@@I@Z ; CObjectVector<CDirItem>::operator[](uint)
.text:00003A78                 mov     [ebp+var_5E8], eax
.text:00003A7E                 mov     ecx, [ebp+var_3D4]
.text:00003A84                 push    ecx
.text:00003A85                 lea     edx, [ebp+var_5F8]
.text:00003A8B                 push    edx             ; wchar_t *
.text:00003A8C                 lea     ecx, [ebp+var_258]
.text:00003A92                 call    ?GetPhyPath@CDirItems@@QBE?AVUString@@I@Z ; CDirItems::GetPhyPath(uint)
.text:00003A97                 mov     byte ptr [ebp+var_4], 27h ; '''
.text:00003A9B                 mov     ecx, [ebp+var_5E8] ; this
.text:00003AA1                 call    ?IsDir@CDirItem@@QBE_NXZ ; CDirItem::IsDir(void)
.text:00003AA6                 movzx   eax, al
.text:00003AA9                 test    eax, eax
.text:00003AAB                 jz      short loc_3AEE
.text:00003AAD                 mov     ecx, [ebp+var_3D4]
.text:00003AB3                 mov     [ebp+var_604], ecx
.text:00003AB9                 lea     ecx, [ebp+var_5F8]
.text:00003ABF                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00003AC4                 push    eax
.text:00003AC5                 call    ?GetNumSlashes@@YGIPB_W@Z ; GetNumSlashes(wchar_t const *)
.text:00003ACA                 mov     [ebp+var_608], eax
.text:00003AD0                 mov     edx, [ebp+var_604]
.text:00003AD6                 push    edx
.text:00003AD7                 mov     eax, [ebp+var_608]
.text:00003ADD                 push    eax
.text:00003ADE                 lea     ecx, [ebp+var_5CC]
.text:00003AE4                 call    ?Add@?$CRecordVector@UCRefSortPair@@@@QAEIUCRefSortPair@@@Z ; CRecordVector<CRefSortPair>::Add(CRefSortPair)
.text:00003AE9                 jmp     loc_3C3B
.text:00003AEE ; ---------------------------------------------------------------------------
.text:00003AEE
.text:00003AEE loc_3AEE:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+238Fj
.text:00003AEE                 lea     ecx, [ebp+var_410]
.text:00003AF4                 call    ??B?$CBuffer@E@@QAEPAEXZ ; CBuffer<uchar>::operator uchar *(void)
.text:00003AF9                 mov     ecx, [ebp+var_3D4]
.text:00003AFF                 movzx   edx, byte ptr [eax+ecx]
.text:00003B03                 test    edx, edx
.text:00003B05                 jnz     short loc_3B2A
.text:00003B07                 mov     eax, [ebp+var_5E8]
.text:00003B0D                 mov     [ebp+var_728], eax
.text:00003B13                 mov     ecx, [ebp+var_728]
.text:00003B19                 mov     edx, [ebp+var_728]
.text:00003B1F                 mov     eax, [ecx]
.text:00003B21                 or      eax, [edx+4]
.text:00003B24                 jnz     loc_3C3B
.text:00003B2A
.text:00003B2A loc_3B2A:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+23E9j
.text:00003B2A                 mov     esi, esp
.text:00003B2C                 push    0
.text:00003B2E                 lea     ecx, [ebp+var_5F8]
.text:00003B34                 push    ecx
.text:00003B35                 mov     edx, [ebp+arg_1C]
.text:00003B38                 mov     eax, [edx]
.text:00003B3A                 mov     ecx, [ebp+arg_1C]
.text:00003B3D                 mov     edx, [eax+54h]
.text:00003B40                 call    edx
.text:00003B42                 cmp     esi, esp
.text:00003B44                 call    __RTC_CheckEsp
.text:00003B49                 mov     [ebp+var_610], eax
.text:00003B4F                 cmp     [ebp+var_610], 0
.text:00003B56                 jz      loc_3C2A
.text:00003B5C                 mov     eax, [ebp+var_610]
.text:00003B62                 mov     [ebp+var_6D4], eax
.text:00003B68                 mov     byte ptr [ebp+var_4], 26h ; '&'
.text:00003B6C                 lea     ecx, [ebp+var_5F8] ; this
.text:00003B72                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003B77                 mov     byte ptr [ebp+var_4], 25h ; '%'
.text:00003B7B                 lea     ecx, [ebp+var_5E0]
.text:00003B81                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:00003B86                 mov     byte ptr [ebp+var_4], 15h
.text:00003B8A                 lea     ecx, [ebp+var_5CC]
.text:00003B90                 call    ??1?$CRecordVector@UCRefSortPair@@@@QAE@XZ ; CRecordVector<CRefSortPair>::~CRecordVector<CRefSortPair>(void)
.text:00003B95                 mov     byte ptr [ebp+var_4], 14h
.text:00003B99                 lea     ecx, [ebp+var_410]
.text:00003B9F                 call    ??1?$CBuffer@E@@QAE@XZ ; CBuffer<uchar>::~CBuffer<uchar>(void)
.text:00003BA4                 mov     byte ptr [ebp+var_4], 12h
.text:00003BA8                 lea     ecx, [ebp+var_3FC]
.text:00003BAE                 call    ??1?$CObjectVector@UCArcItem@@@@QAE@XZ ; CObjectVector<CArcItem>::~CObjectVector<CArcItem>(void)
.text:00003BB3                 mov     byte ptr [ebp+var_4], 11h
.text:00003BB7                 lea     ecx, [ebp+var_3C4] ; this
.text:00003BBD                 call    ??1CTempFiles@@QAE@XZ ; CTempFiles::~CTempFiles(void)
.text:00003BC2                 mov     byte ptr [ebp+var_4], 10h
.text:00003BC6                 lea     ecx, [ebp+var_3B0] ; this
.text:00003BCC                 call    ??1CTempDir@NDir@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NDir::CTempDir::~CTempDir(void)
.text:00003BD1                 mov     byte ptr [ebp+var_4], 0Ch
.text:00003BD5                 lea     ecx, [ebp+var_394] ; this
.text:00003BDB                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003BE0                 mov     byte ptr [ebp+var_4], 0Bh
.text:00003BE4                 lea     ecx, [ebp+var_2B0] ; this
.text:00003BEA                 call    ??1CDirItem@@QAE@XZ ; CDirItem::~CDirItem(void)
.text:00003BEF                 mov     byte ptr [ebp+var_4], 5
.text:00003BF3                 lea     ecx, [ebp+var_258] ; this
.text:00003BF9                 call    ??1CDirItems@@QAE@XZ ; CDirItems::~CDirItems(void)
.text:00003BFE                 mov     byte ptr [ebp+var_4], 4
.text:00003C02                 lea     ecx, [ebp+var_CC] ; this
.text:00003C08                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003C0D                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00003C14                 lea     ecx, [ebp+var_B8] ; this
.text:00003C1A                 call    ??1CArchiveLink@@QAE@XZ ; CArchiveLink::~CArchiveLink(void)
.text:00003C1F                 mov     eax, [ebp+var_6D4]
.text:00003C25                 jmp     loc_3FA0
.text:00003C2A ; ---------------------------------------------------------------------------
.text:00003C2A
.text:00003C2A loc_3C2A:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+243Aj
.text:00003C2A                 lea     ecx, [ebp+var_5F8]
.text:00003C30                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00003C35                 push    eax             ; this
.text:00003C36                 call    ?DeleteFileAlways@NDir@NFile@NWindows@@YG_NPB_W@Z ; NWindows::NFile::NDir::DeleteFileAlways(wchar_t const *)
.text:00003C3B
.text:00003C3B loc_3C3B:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+23CDj
.text:00003C3B                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+2408j
.text:00003C3B                 mov     byte ptr [ebp+var_4], 26h ; '&'
.text:00003C3F                 lea     ecx, [ebp+var_5F8] ; this
.text:00003C45                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003C4A                 jmp     loc_3A40
.text:00003C4F ; ---------------------------------------------------------------------------
.text:00003C4F
.text:00003C4F loc_3C4F:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+2344j
.text:00003C4F                 push    0
.text:00003C51                 push    offset ?CompareRefSortPair@@YGHPBUCRefSortPair@@0PAX@Z ; CompareRefSortPair(CRefSortPair const *,CRefSortPair const *,void *)
.text:00003C56                 lea     ecx, [ebp+var_5CC]
.text:00003C5C                 call    ?Sort@?$CRecordVector@UCRefSortPair@@@@QAEXP6GHPBUCRefSortPair@@0PAX@Z1@Z ; CRecordVector<CRefSortPair>::Sort(int (*)(CRefSortPair const *,CRefSortPair const *,void *),void *)
.text:00003C61                 mov     [ebp+var_3D4], 0
.text:00003C6B                 jmp     short loc_3C7C
.text:00003C6D ; ---------------------------------------------------------------------------
.text:00003C6D
.text:00003C6D loc_3C6D:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+26DFj
.text:00003C6D                 mov     ecx, [ebp+var_3D4]
.text:00003C73                 add     ecx, 1
.text:00003C76                 mov     [ebp+var_3D4], ecx
.text:00003C7C
.text:00003C7C loc_3C7C:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+254Fj
.text:00003C7C                 lea     ecx, [ebp+var_5CC]
.text:00003C82                 call    ?Size@?$CRecordVector@UCRefSortPair@@@@QBEIXZ ; CRecordVector<CRefSortPair>::Size(void)
.text:00003C87                 cmp     [ebp+var_3D4], eax
.text:00003C8D                 jnb     loc_3E00
.text:00003C93                 mov     edx, [ebp+var_3D4]
.text:00003C99                 push    edx
.text:00003C9A                 lea     ecx, [ebp+var_5CC]
.text:00003CA0                 call    ??A?$CRecordVector@UCRefSortPair@@@@QAEAAUCRefSortPair@@I@Z ; CRecordVector<CRefSortPair>::operator[](uint)
.text:00003CA5                 mov     eax, [eax+4]
.text:00003CA8                 push    eax
.text:00003CA9                 lea     ecx, [ebp+var_620]
.text:00003CAF                 push    ecx             ; wchar_t *
.text:00003CB0                 lea     ecx, [ebp+var_258]
.text:00003CB6                 call    ?GetPhyPath@CDirItems@@QBE?AVUString@@I@Z ; CDirItems::GetPhyPath(uint)
.text:00003CBB                 mov     byte ptr [ebp+var_4], 28h ; '('
.text:00003CBF                 lea     ecx, [ebp+var_620]
.text:00003CC5                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00003CCA                 push    eax             ; wchar_t *
.text:00003CCB                 call    ?DoesDirExist@NFind@NFile@NWindows@@YG_NPB_W@Z ; NWindows::NFile::NFind::DoesDirExist(wchar_t const *)
.text:00003CD0                 movzx   edx, al
.text:00003CD3                 test    edx, edx
.text:00003CD5                 jz      loc_3DEC
.text:00003CDB                 mov     esi, esp
.text:00003CDD                 push    1
.text:00003CDF                 lea     eax, [ebp+var_620]
.text:00003CE5                 push    eax
.text:00003CE6                 mov     ecx, [ebp+arg_1C]
.text:00003CE9                 mov     edx, [ecx]
.text:00003CEB                 mov     ecx, [ebp+arg_1C]
.text:00003CEE                 mov     eax, [edx+54h]
.text:00003CF1                 call    eax
.text:00003CF3                 cmp     esi, esp
.text:00003CF5                 call    __RTC_CheckEsp
.text:00003CFA                 mov     [ebp+var_628], eax
.text:00003D00                 cmp     [ebp+var_628], 0
.text:00003D07                 jz      loc_3DDB
.text:00003D0D                 mov     ecx, [ebp+var_628]
.text:00003D13                 mov     [ebp+var_6D8], ecx
.text:00003D19                 mov     byte ptr [ebp+var_4], 26h ; '&'
.text:00003D1D                 lea     ecx, [ebp+var_620] ; this
.text:00003D23                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003D28                 mov     byte ptr [ebp+var_4], 25h ; '%'
.text:00003D2C                 lea     ecx, [ebp+var_5E0]
.text:00003D32                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:00003D37                 mov     byte ptr [ebp+var_4], 15h
.text:00003D3B                 lea     ecx, [ebp+var_5CC]
.text:00003D41                 call    ??1?$CRecordVector@UCRefSortPair@@@@QAE@XZ ; CRecordVector<CRefSortPair>::~CRecordVector<CRefSortPair>(void)
.text:00003D46                 mov     byte ptr [ebp+var_4], 14h
.text:00003D4A                 lea     ecx, [ebp+var_410]
.text:00003D50                 call    ??1?$CBuffer@E@@QAE@XZ ; CBuffer<uchar>::~CBuffer<uchar>(void)
.text:00003D55                 mov     byte ptr [ebp+var_4], 12h
.text:00003D59                 lea     ecx, [ebp+var_3FC]
.text:00003D5F                 call    ??1?$CObjectVector@UCArcItem@@@@QAE@XZ ; CObjectVector<CArcItem>::~CObjectVector<CArcItem>(void)
.text:00003D64                 mov     byte ptr [ebp+var_4], 11h
.text:00003D68                 lea     ecx, [ebp+var_3C4] ; this
.text:00003D6E                 call    ??1CTempFiles@@QAE@XZ ; CTempFiles::~CTempFiles(void)
.text:00003D73                 mov     byte ptr [ebp+var_4], 10h
.text:00003D77                 lea     ecx, [ebp+var_3B0] ; this
.text:00003D7D                 call    ??1CTempDir@NDir@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NDir::CTempDir::~CTempDir(void)
.text:00003D82                 mov     byte ptr [ebp+var_4], 0Ch
.text:00003D86                 lea     ecx, [ebp+var_394] ; this
.text:00003D8C                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003D91                 mov     byte ptr [ebp+var_4], 0Bh
.text:00003D95                 lea     ecx, [ebp+var_2B0] ; this
.text:00003D9B                 call    ??1CDirItem@@QAE@XZ ; CDirItem::~CDirItem(void)
.text:00003DA0                 mov     byte ptr [ebp+var_4], 5
.text:00003DA4                 lea     ecx, [ebp+var_258] ; this
.text:00003DAA                 call    ??1CDirItems@@QAE@XZ ; CDirItems::~CDirItems(void)
.text:00003DAF                 mov     byte ptr [ebp+var_4], 4
.text:00003DB3                 lea     ecx, [ebp+var_CC] ; this
.text:00003DB9                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003DBE                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00003DC5                 lea     ecx, [ebp+var_B8] ; this
.text:00003DCB                 call    ??1CArchiveLink@@QAE@XZ ; CArchiveLink::~CArchiveLink(void)
.text:00003DD0                 mov     eax, [ebp+var_6D8]
.text:00003DD6                 jmp     loc_3FA0
.text:00003DDB ; ---------------------------------------------------------------------------
.text:00003DDB
.text:00003DDB loc_3DDB:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+25EBj
.text:00003DDB                 lea     ecx, [ebp+var_620]
.text:00003DE1                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00003DE6                 push    eax             ; this
.text:00003DE7                 call    ?RemoveDir@NDir@NFile@NWindows@@YG_NPB_W@Z ; NWindows::NFile::NDir::RemoveDir(wchar_t const *)
.text:00003DEC
.text:00003DEC loc_3DEC:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+25B9j
.text:00003DEC                 mov     byte ptr [ebp+var_4], 26h ; '&'
.text:00003DF0                 lea     ecx, [ebp+var_620] ; this
.text:00003DF6                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003DFB                 jmp     loc_3C6D
.text:00003E00 ; ---------------------------------------------------------------------------
.text:00003E00
.text:00003E00 loc_3E00:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+2571j
.text:00003E00                 mov     esi, esp
.text:00003E02                 mov     edx, [ebp+arg_1C]
.text:00003E05                 mov     eax, [edx]
.text:00003E07                 mov     ecx, [ebp+arg_1C]
.text:00003E0A                 mov     edx, [eax+58h]
.text:00003E0D                 call    edx
.text:00003E0F                 cmp     esi, esp
.text:00003E11                 call    __RTC_CheckEsp
.text:00003E16                 mov     [ebp+var_62C], eax
.text:00003E1C                 cmp     [ebp+var_62C], 0
.text:00003E23                 jz      loc_3EE8
.text:00003E29                 mov     eax, [ebp+var_62C]
.text:00003E2F                 mov     [ebp+var_6DC], eax
.text:00003E35                 mov     byte ptr [ebp+var_4], 25h ; '%'
.text:00003E39                 lea     ecx, [ebp+var_5E0]
.text:00003E3F                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:00003E44                 mov     byte ptr [ebp+var_4], 15h
.text:00003E48                 lea     ecx, [ebp+var_5CC]
.text:00003E4E                 call    ??1?$CRecordVector@UCRefSortPair@@@@QAE@XZ ; CRecordVector<CRefSortPair>::~CRecordVector<CRefSortPair>(void)
.text:00003E53                 mov     byte ptr [ebp+var_4], 14h
.text:00003E57                 lea     ecx, [ebp+var_410]
.text:00003E5D                 call    ??1?$CBuffer@E@@QAE@XZ ; CBuffer<uchar>::~CBuffer<uchar>(void)
.text:00003E62                 mov     byte ptr [ebp+var_4], 12h
.text:00003E66                 lea     ecx, [ebp+var_3FC]
.text:00003E6C                 call    ??1?$CObjectVector@UCArcItem@@@@QAE@XZ ; CObjectVector<CArcItem>::~CObjectVector<CArcItem>(void)
.text:00003E71                 mov     byte ptr [ebp+var_4], 11h
.text:00003E75                 lea     ecx, [ebp+var_3C4] ; this
.text:00003E7B                 call    ??1CTempFiles@@QAE@XZ ; CTempFiles::~CTempFiles(void)
.text:00003E80                 mov     byte ptr [ebp+var_4], 10h
.text:00003E84                 lea     ecx, [ebp+var_3B0] ; this
.text:00003E8A                 call    ??1CTempDir@NDir@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NDir::CTempDir::~CTempDir(void)
.text:00003E8F                 mov     byte ptr [ebp+var_4], 0Ch
.text:00003E93                 lea     ecx, [ebp+var_394] ; this
.text:00003E99                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003E9E                 mov     byte ptr [ebp+var_4], 0Bh
.text:00003EA2                 lea     ecx, [ebp+var_2B0] ; this
.text:00003EA8                 call    ??1CDirItem@@QAE@XZ ; CDirItem::~CDirItem(void)
.text:00003EAD                 mov     byte ptr [ebp+var_4], 5
.text:00003EB1                 lea     ecx, [ebp+var_258] ; this
.text:00003EB7                 call    ??1CDirItems@@QAE@XZ ; CDirItems::~CDirItems(void)
.text:00003EBC                 mov     byte ptr [ebp+var_4], 4
.text:00003EC0                 lea     ecx, [ebp+var_CC] ; this
.text:00003EC6                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003ECB                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00003ED2                 lea     ecx, [ebp+var_B8] ; this
.text:00003ED8                 call    ??1CArchiveLink@@QAE@XZ ; CArchiveLink::~CArchiveLink(void)
.text:00003EDD                 mov     eax, [ebp+var_6DC]
.text:00003EE3                 jmp     loc_3FA0
.text:00003EE8 ; ---------------------------------------------------------------------------
.text:00003EE8
.text:00003EE8 loc_3EE8:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+2707j
.text:00003EE8                 mov     byte ptr [ebp+var_4], 25h ; '%'
.text:00003EEC                 lea     ecx, [ebp+var_5E0]
.text:00003EF2                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:00003EF7                 mov     byte ptr [ebp+var_4], 15h
.text:00003EFB                 lea     ecx, [ebp+var_5CC]
.text:00003F01                 call    ??1?$CRecordVector@UCRefSortPair@@@@QAE@XZ ; CRecordVector<CRefSortPair>::~CRecordVector<CRefSortPair>(void)
.text:00003F06
.text:00003F06 loc_3F06:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+22F4j
.text:00003F06                 mov     [ebp+var_6E0], 0
.text:00003F10                 mov     byte ptr [ebp+var_4], 14h
.text:00003F14                 lea     ecx, [ebp+var_410]
.text:00003F1A                 call    ??1?$CBuffer@E@@QAE@XZ ; CBuffer<uchar>::~CBuffer<uchar>(void)
.text:00003F1F                 mov     byte ptr [ebp+var_4], 12h
.text:00003F23                 lea     ecx, [ebp+var_3FC]
.text:00003F29                 call    ??1?$CObjectVector@UCArcItem@@@@QAE@XZ ; CObjectVector<CArcItem>::~CObjectVector<CArcItem>(void)
.text:00003F2E                 mov     byte ptr [ebp+var_4], 11h
.text:00003F32                 lea     ecx, [ebp+var_3C4] ; this
.text:00003F38                 call    ??1CTempFiles@@QAE@XZ ; CTempFiles::~CTempFiles(void)
.text:00003F3D                 mov     byte ptr [ebp+var_4], 10h
.text:00003F41                 lea     ecx, [ebp+var_3B0] ; this
.text:00003F47                 call    ??1CTempDir@NDir@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NDir::CTempDir::~CTempDir(void)
.text:00003F4C                 mov     byte ptr [ebp+var_4], 0Ch
.text:00003F50                 lea     ecx, [ebp+var_394] ; this
.text:00003F56                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003F5B                 mov     byte ptr [ebp+var_4], 0Bh
.text:00003F5F                 lea     ecx, [ebp+var_2B0] ; this
.text:00003F65                 call    ??1CDirItem@@QAE@XZ ; CDirItem::~CDirItem(void)
.text:00003F6A                 mov     byte ptr [ebp+var_4], 5
.text:00003F6E                 lea     ecx, [ebp+var_258] ; this
.text:00003F74                 call    ??1CDirItems@@QAE@XZ ; CDirItems::~CDirItems(void)
.text:00003F79                 mov     byte ptr [ebp+var_4], 4
.text:00003F7D                 lea     ecx, [ebp+var_CC] ; this
.text:00003F83                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003F88                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00003F8F                 lea     ecx, [ebp+var_B8] ; this
.text:00003F95                 call    ??1CArchiveLink@@QAE@XZ ; CArchiveLink::~CArchiveLink(void)
.text:00003F9A                 mov     eax, [ebp+var_6E0]
.text:00003FA0
.text:00003FA0 loc_3FA0:                               ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+62j
.text:00003FA0                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+79j ...
.text:00003FA0                 push    edx
.text:00003FA1                 mov     ecx, ebp
.text:00003FA3                 push    eax
.text:00003FA4                 lea     edx, $LN236
.text:00003FAA                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00003FAF                 pop     eax
.text:00003FB0                 pop     edx
.text:00003FB1                 mov     ecx, [ebp+var_C]
.text:00003FB4                 mov     large fs:0, ecx
.text:00003FBB                 pop     ecx
.text:00003FBC                 pop     edi
.text:00003FBD                 pop     esi
.text:00003FBE                 pop     ebx
.text:00003FBF                 add     esp, 728h
.text:00003FC5                 cmp     ebp, esp
.text:00003FC7                 call    __RTC_CheckEsp
.text:00003FCC                 mov     esp, ebp
.text:00003FCE                 pop     ebp
.text:00003FCF                 retn    24h
.text:00003FCF ; END OF FUNCTION CHUNK FOR ?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z
.text:00003FCF ; ---------------------------------------------------------------------------
.text:00003FD2                 align 4
.text:00003FD4 $LN236          dd offset $SG74034+29h  ; DATA XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+2888o
.text:00003FD4                                         ; "his archive"
.text:00003FD8                 dd offset $LN235
.text:00003FDC $LN235          dd 0FFFFFFC8h, 18h      ; DATA XREF: .text:00003FD8o
.text:00003FE4                 dd offset $LN193        ; "property"
.text:00003FE8                 dd 0FFFFFFB0h, 0Ch
.text:00003FF0                 dd offset $LN194        ; "fullName"
.text:00003FF4                 dd 0FFFFFF48h, 60h
.text:00003FFC                 dd offset $LN195        ; "arcLink"
.text:00004000                 dd 0FFFFFF34h, 0Ch
.text:00004008                 dd offset $LN196        ; "arcPath"
.text:0000400C                 dd 0FFFFFEF4h, 38h
.text:00004014                 dd offset $LN197        ; "fi"
.text:00004018                 dd 0FFFFFEE0h, 0Ch
.text:00004020                 dd offset $LN198        ; "types"
.text:00004024                 db 0CCh
.text:00004025                 db 0FEh, 2 dup(0FFh)
.text:00004028                 dd 0Ch
.text:0000402C                 dd offset $LN199        ; "excl"
.text:00004030                 dd 0FFFFFE6Ch, 58h
.text:00004038                 dd offset $LN200        ; "op"
.text:0000403C                 dd 0FFFFFDA8h, 0A0h
.text:00004044                 dd offset $LN201        ; "dirItems"
.text:00004048                 dd 0FFFFFD50h, 50h
.text:00004050                 dd offset $LN202        ; "parentDirItem"
.text:00004054                 dd 0FFFFFCF4h, 50h
.text:0000405C                 dd offset $LN203        ; "di"
.text:00004060                 dd 0FFFFFCA0h, 38h
.text:00004068                 dd offset $LN204        ; "fi"
.text:0000406C                 dd 0FFFFFC8Ch, 0Ch
.text:00004074                 dd offset $LN205        ; "prefix"
.text:00004078                 dd 0FFFFFC80h, 4
.text:00004080                 dd offset $LN206        ; "secureIndex"
.text:00004084                 dd 0FFFFFC6Ch, 0Ch
.text:0000408C                 dd offset $LN207        ; "tempDirPrefix"
.text:00004090                 dd 0FFFFFC50h, 10h
.text:00004098                 dd offset $LN208        ; "tempDirectory"
.text:0000409C                 dd 0FFFFFC3Ch, 0Ch
.text:000040A4                 dd offset $LN209        ; "tempFiles"
.text:000040A8                 dd 0FFFFFC18h, 0Ch
.text:000040B0                 dd offset $LN210        ; "path"
.text:000040B4                 dd 0FFFFFC04h, 0Ch
.text:000040BC                 dd offset $LN211        ; "arcItems"
.text:000040C0                 dd 0FFFFFBF0h, 8
.text:000040C8                 dd offset $LN212        ; "processedItems"
.text:000040CC                 dd 0FFFFFBD0h, 0Ch
.text:000040D4                 dd offset $LN213        ; "name"
.text:000040D8                 dd 0FFFFFBB8h, 8
.text:000040E0                 dd offset $LN214        ; "st"
.text:000040E4                 db 90h
.text:000040E5                 db 0FBh, 2 dup(0FFh)
.text:000040E8                 dd 0Ch
.text:000040EC                 dd offset $LN215        ; "$S1"
.text:000040F0                 dd 0FFFFFB84h, 4
.text:000040F8                 dd offset $LN216        ; "mapiLib"
.text:000040FC                 dd 0FFFFFB6Ch, 0Ch
.text:00004104                 dd offset $LN217        ; "fullPaths"
.text:00004108                 dd 0FFFFFB50h, 0Ch
.text:00004110                 dd offset $LN218        ; "finalPath"
.text:00004114                 dd 0FFFFFB3Ch, 0Ch
.text:0000411C                 dd offset $LN219        ; "arcPath"
.text:00004120                 dd 0FFFFFB24h, 10h
.text:00004128                 dd offset $LN220        ; "curDirRestorer"
.text:0000412C                 dd 0FFFFFB10h, 0Ch
.text:00004134                 dd offset $LN221        ; "arcPath"
.text:00004138                 dd 0FFFFFAFCh, 0Ch
.text:00004140                 dd offset $LN222        ; "fileName"
.text:00004144                 dd 0FFFFFAE8h, 0Ch
.text:0000414C                 dd offset $LN223        ; "path"
.text:00004150                 dd 0FFFFFAD4h, 0Ch
.text:00004158                 dd offset $LN224        ; "name"
.text:0000415C                 dd 0FFFFFAB4h, 18h
.text:00004164                 dd offset $LN225        ; "f"
.text:00004168                 dd 0FFFFFA7Ch, 30h
.text:00004170                 dd offset $LN226        ; "m"
.text:00004174                 dd 0FFFFFA68h, 0Ch
.text:0000417C                 dd offset $LN227        ; "addr"
.text:00004180                 dd 0FFFFFA48h, 18h
.text:00004188                 dd offset $LN228        ; "rec"
.text:0000418C                 dd 0FFFFFA34h, 0Ch
.text:00004194                 dd offset $LN229        ; "pairs"
.text:00004198                 dd 0FFFFFA20h, 0Ch
.text:000041A0                 dd offset $LN230        ; "foldersNames"
.text:000041A4                 dd 0FFFFFA08h, 0Ch
.text:000041AC                 dd offset $LN231        ; "phyPath"
.text:000041B0                 dd 0FFFFF9F8h, 8
.text:000041B8                 db 0D0h ; - OFF32 SEGDEF [_text,41D0]
.text:000041B9                 db  41h ; A
.text:000041BA                 db    0
.text:000041BB                 db    0
.text:000041BC                 dd 0FFFFF9E0h, 0Ch
.text:000041C4                 dd offset $LN233        ; "phyPath"
.text:000041C8 $LN233          db 'phyPath',0          ; DATA XREF: .text:000041C4o
.text:000041D0 $LN232          db 'pair',0
.text:000041D5 $LN231          db 'phyPath',0          ; DATA XREF: .text:000041ACo
.text:000041DD $LN230          db 'foldersNames',0     ; DATA XREF: .text:000041A0o
.text:000041EA $LN229          db 'pairs',0            ; DATA XREF: .text:00004194o
.text:000041F0 $LN228          db 'rec',0              ; DATA XREF: .text:00004188o
.text:000041F4 $LN227          db 'addr',0             ; DATA XREF: .text:0000417Co
.text:000041F9 $LN226          db 'm',0                ; DATA XREF: .text:00004170o
.text:000041FB $LN225          db 'f',0                ; DATA XREF: .text:00004164o
.text:000041FD $LN224          db 'name',0             ; DATA XREF: .text:00004158o
.text:00004202 $LN223          db 'path',0             ; DATA XREF: .text:0000414Co
.text:00004207 $LN222          db 'fileName',0         ; DATA XREF: .text:00004140o
.text:00004210 $LN221          db 'arcPath',0          ; DATA XREF: .text:00004134o
.text:00004218 $LN220          db 'curDirRestorer',0   ; DATA XREF: .text:00004128o
.text:00004227 $LN219          db 'arcPath',0          ; DATA XREF: .text:0000411Co
.text:0000422F $LN218          db 'finalPath',0        ; DATA XREF: .text:00004110o
.text:00004239 $LN217          db 'fullPaths',0        ; DATA XREF: .text:00004104o
.text:00004243 $LN216          db 'mapiLib',0          ; DATA XREF: .text:000040F8o
.text:0000424B $LN215          db '$S1',0              ; DATA XREF: .text:000040ECo
.text:0000424F $LN214          db 'st',0               ; DATA XREF: .text:000040E0o
.text:00004252 $LN213          db 'name',0             ; DATA XREF: .text:000040D4o
.text:00004257 $LN212          db 'processedItems',0   ; DATA XREF: .text:000040C8o
.text:00004266 $LN211          db 'arcItems',0         ; DATA XREF: .text:000040BCo
.text:0000426F $LN210          db 'path',0             ; DATA XREF: .text:000040B0o
.text:00004274 $LN209          db 'tempFiles',0        ; DATA XREF: .text:000040A4o
.text:0000427E $LN208          db 'tempDirectory',0    ; DATA XREF: .text:00004098o
.text:0000428C $LN207          db 'tempDirPrefix',0    ; DATA XREF: .text:0000408Co
.text:0000429A $LN206          db 'secureIndex',0      ; DATA XREF: .text:00004080o
.text:000042A6 $LN205          db 'prefix',0           ; DATA XREF: .text:00004074o
.text:000042AD $LN204          db 'fi',0               ; DATA XREF: .text:00004068o
.text:000042B0 $LN203          db 'di',0               ; DATA XREF: .text:0000405Co
.text:000042B3 $LN202          db 'parentDirItem',0    ; DATA XREF: .text:00004050o
.text:000042C1 $LN201          db 'dirItems',0         ; DATA XREF: .text:00004044o
.text:000042CA $LN200          db 'op',0               ; DATA XREF: .text:00004038o
.text:000042CD $LN199          db 'excl',0             ; DATA XREF: .text:0000402Co
.text:000042D2 $LN198          db 'types',0            ; DATA XREF: .text:00004020o
.text:000042D8 $LN197          db 'fi',0               ; DATA XREF: .text:00004014o
.text:000042DB $LN196          db 'arcPath',0          ; DATA XREF: .text:00004008o
.text:000042E3 $LN195          db 'arcLink',0          ; DATA XREF: .text:00003FFCo
.text:000042EB $LN194          db 'fullName',0         ; DATA XREF: .text:00003FF0o
.text:000042F4 $LN193          db 'property',0         ; DATA XREF: .text:00003FE4o
.text:000042FD                 db 0Fh dup(0CCh)
.text:0000430C
.text:0000430C ; =============== S U B R O U T I N E =======================================
.text:0000430C
.text:0000430C ; Attributes: bp-based frame
.text:0000430C
.text:0000430C ; int __stdcall Compress(int, char, int, int, CArc *, int, int, int, int, int, int, CUpdateErrorInfo *, int, int)
.text:0000430C ?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z proc near
.text:0000430C                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+17C9p
.text:0000430C
.text:0000430C var_364         = dword ptr -364h
.text:0000430C var_360         = dword ptr -360h
.text:0000430C var_35C         = dword ptr -35Ch
.text:0000430C var_358         = dword ptr -358h
.text:0000430C var_354         = dword ptr -354h
.text:0000430C var_350         = dword ptr -350h
.text:0000430C var_34C         = dword ptr -34Ch
.text:0000430C var_348         = dword ptr -348h
.text:0000430C var_344         = dword ptr -344h
.text:0000430C var_340         = dword ptr -340h
.text:0000430C var_33C         = dword ptr -33Ch
.text:0000430C var_338         = dword ptr -338h
.text:0000430C var_334         = dword ptr -334h
.text:0000430C var_330         = dword ptr -330h
.text:0000430C var_32C         = dword ptr -32Ch
.text:0000430C var_328         = dword ptr -328h
.text:0000430C var_324         = dword ptr -324h
.text:0000430C var_320         = dword ptr -320h
.text:0000430C var_31C         = dword ptr -31Ch
.text:0000430C var_318         = dword ptr -318h
.text:0000430C var_314         = dword ptr -314h
.text:0000430C var_310         = dword ptr -310h
.text:0000430C var_30C         = dword ptr -30Ch
.text:0000430C var_308         = dword ptr -308h
.text:0000430C var_304         = dword ptr -304h
.text:0000430C var_300         = dword ptr -300h
.text:0000430C var_2FC         = dword ptr -2FCh
.text:0000430C var_2F8         = dword ptr -2F8h
.text:0000430C var_2F4         = dword ptr -2F4h
.text:0000430C var_2F0         = dword ptr -2F0h
.text:0000430C var_2EC         = dword ptr -2ECh
.text:0000430C var_2E8         = dword ptr -2E8h
.text:0000430C var_2E4         = dword ptr -2E4h
.text:0000430C var_2E0         = dword ptr -2E0h
.text:0000430C var_2DC         = dword ptr -2DCh
.text:0000430C var_2D8         = dword ptr -2D8h
.text:0000430C var_2D4         = dword ptr -2D4h
.text:0000430C var_2D0         = dword ptr -2D0h
.text:0000430C var_2CC         = dword ptr -2CCh
.text:0000430C var_2C8         = dword ptr -2C8h
.text:0000430C var_2C4         = byte ptr -2C4h
.text:0000430C var_2B8         = dword ptr -2B8h
.text:0000430C var_2B4         = dword ptr -2B4h
.text:0000430C var_2B0         = dword ptr -2B0h
.text:0000430C var_2AC         = dword ptr -2ACh
.text:0000430C var_2A8         = dword ptr -2A8h
.text:0000430C var_2A4         = byte ptr -2A4h
.text:0000430C var_298         = byte ptr -298h
.text:0000430C var_28C         = dword ptr -28Ch
.text:0000430C var_288         = dword ptr -288h
.text:0000430C var_284         = dword ptr -284h
.text:0000430C var_280         = dword ptr -280h
.text:0000430C var_27C         = dword ptr -27Ch
.text:0000430C var_278         = byte ptr -278h
.text:0000430C var_269         = byte ptr -269h
.text:0000430C var_268         = dword ptr -268h
.text:0000430C var_264         = dword ptr -264h
.text:0000430C var_260         = dword ptr -260h
.text:0000430C var_25C         = dword ptr -25Ch
.text:0000430C var_258         = dword ptr -258h
.text:0000430C var_254         = dword ptr -254h
.text:0000430C var_250         = dword ptr -250h
.text:0000430C var_24C         = dword ptr -24Ch
.text:0000430C var_248         = dword ptr -248h
.text:0000430C var_244         = dword ptr -244h
.text:0000430C var_240         = dword ptr -240h
.text:0000430C var_23C         = dword ptr -23Ch
.text:0000430C var_234         = qword ptr -234h
.text:0000430C lpFileTime2     = dword ptr -228h
.text:0000430C var_224         = dword ptr -224h
.text:0000430C var_220         = dword ptr -220h
.text:0000430C FileTime1       = FILETIME ptr -218h
.text:0000430C var_20C         = dword ptr -20Ch
.text:0000430C var_208         = dword ptr -208h
.text:0000430C var_204         = dword ptr -204h
.text:0000430C var_200         = dword ptr -200h
.text:0000430C var_1FC         = dword ptr -1FCh
.text:0000430C var_1F4         = byte ptr -1F4h
.text:0000430C var_1EC         = dword ptr -1ECh
.text:0000430C var_1E8         = dword ptr -1E8h
.text:0000430C var_1E4         = dword ptr -1E4h
.text:0000430C var_1E0         = dword ptr -1E0h
.text:0000430C var_1D8         = dword ptr -1D8h
.text:0000430C var_1D4         = dword ptr -1D4h
.text:0000430C var_1C8         = byte ptr -1C8h
.text:0000430C var_1B8         = dword ptr -1B8h
.text:0000430C var_1B0         = byte ptr -1B0h
.text:0000430C var_1A4         = byte ptr -1A4h
.text:0000430C var_19C         = dword ptr -19Ch
.text:0000430C var_198         = dword ptr -198h
.text:0000430C var_190         = word ptr -190h
.text:0000430C var_16C         = dword ptr -16Ch
.text:0000430C var_164         = byte ptr -164h
.text:0000430C var_151         = byte ptr -151h
.text:0000430C var_150         = dword ptr -150h
.text:0000430C var_14C         = dword ptr -14Ch
.text:0000430C var_148         = dword ptr -148h
.text:0000430C var_140         = word ptr -140h
.text:0000430C var_12C         = byte ptr -12Ch
.text:0000430C var_120         = byte ptr -120h
.text:0000430C var_114         = byte ptr -114h
.text:0000430C var_10C         = dword ptr -10Ch
.text:0000430C var_108         = dword ptr -108h
.text:0000430C var_104         = dword ptr -104h
.text:0000430C var_100         = dword ptr -100h
.text:0000430C var_F8          = byte ptr -0F8h
.text:0000430C var_E4          = byte ptr -0E4h
.text:0000430C var_D4          = dword ptr -0D4h
.text:0000430C var_CC          = byte ptr -0CCh
.text:0000430C var_C8          = dword ptr -0C8h
.text:0000430C var_C4          = dword ptr -0C4h
.text:0000430C var_C0          = dword ptr -0C0h
.text:0000430C var_BC          = dword ptr -0BCh
.text:0000430C var_B0          = byte ptr -0B0h
.text:0000430C var_A0          = dword ptr -0A0h
.text:0000430C var_9C          = dword ptr -9Ch
.text:0000430C var_98          = dword ptr -98h
.text:0000430C var_90          = byte ptr -90h
.text:0000430C var_7D          = byte ptr -7Dh
.text:0000430C var_7C          = dword ptr -7Ch
.text:0000430C var_78          = dword ptr -78h
.text:0000430C var_70          = byte ptr -70h
.text:0000430C var_5C          = byte ptr -5Ch
.text:0000430C var_4C          = dword ptr -4Ch
.text:0000430C var_48          = dword ptr -48h
.text:0000430C var_40          = dword ptr -40h
.text:0000430C var_38          = dword ptr -38h
.text:0000430C var_34          = dword ptr -34h
.text:0000430C var_30          = dword ptr -30h
.text:0000430C var_28          = byte ptr -28h
.text:0000430C var_20          = dword ptr -20h
.text:0000430C var_18          = byte ptr -18h
.text:0000430C var_10          = dword ptr -10h
.text:0000430C var_C           = dword ptr -0Ch
.text:0000430C var_4           = dword ptr -4
.text:0000430C arg_0           = dword ptr  8
.text:0000430C arg_4           = byte ptr  0Ch
.text:0000430C arg_8           = dword ptr  10h
.text:0000430C arg_C           = dword ptr  14h
.text:0000430C arg_10          = dword ptr  18h
.text:0000430C arg_14          = dword ptr  1Ch
.text:0000430C arg_18          = dword ptr  20h
.text:0000430C arg_1C          = dword ptr  24h
.text:0000430C arg_20          = dword ptr  28h
.text:0000430C arg_24          = dword ptr  2Ch
.text:0000430C arg_28          = dword ptr  30h
.text:0000430C arg_2C          = dword ptr  34h
.text:0000430C arg_30          = dword ptr  38h
.text:0000430C arg_34          = dword ptr  3Ch
.text:0000430C
.text:0000430C                 push    ebp
.text:0000430D                 mov     ebp, esp
.text:0000430F                 push    0FFFFFFFFh
.text:00004311                 push    offset __ehhandler$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z
.text:00004316                 mov     eax, large fs:0
.text:0000431C                 push    eax
.text:0000431D                 sub     esp, 358h
.text:00004323                 push    esi
.text:00004324                 push    edi
.text:00004325                 lea     edi, [ebp+var_364]
.text:0000432B                 mov     ecx, 0D6h ; '+'
.text:00004330                 mov     eax, 0CCCCCCCCh
.text:00004335                 rep stosd
.text:00004337                 mov     eax, dword ptr ds:___security_cookie
.text:0000433C                 xor     eax, ebp
.text:0000433E                 mov     [ebp+var_10], eax
.text:00004341                 push    eax
.text:00004342                 lea     eax, [ebp+var_C]
.text:00004345                 mov     large fs:0, eax
.text:0000434B                 lea     ecx, [ebp+var_18]
.text:0000434E                 call    ??0?$CMyComPtr@UIOutArchive@@@@QAE@XZ ; CMyComPtr<IOutArchive>::CMyComPtr<IOutArchive>(void)
.text:00004353                 mov     [ebp+var_4], 0
.text:0000435A                 mov     eax, [ebp+arg_0]
.text:0000435D                 mov     ecx, [eax+8]
.text:00004360                 mov     [ebp+var_20], ecx
.text:00004363                 cmp     [ebp+arg_10], 0
.text:00004367                 jz      loc_43FD
.text:0000436D                 mov     edx, [ebp+arg_10]
.text:00004370                 mov     eax, [edx+94h]
.text:00004376                 mov     [ebp+var_20], eax
.text:00004379                 cmp     [ebp+var_20], 0
.text:0000437D                 jge     short loc_43A3
.text:0000437F                 mov     [ebp+var_23C], 80004001h
.text:00004389                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00004390                 lea     ecx, [ebp+var_18]
.text:00004393                 call    ??1?$CMyComPtr@UIOutArchive@@@@QAE@XZ ; CMyComPtr<IOutArchive>::~CMyComPtr<IOutArchive>(void)
.text:00004398                 mov     eax, [ebp+var_23C]
.text:0000439E                 jmp     loc_5E99
.text:000043A3 ; ---------------------------------------------------------------------------
.text:000043A3
.text:000043A3 loc_43A3:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+71j
.text:000043A3                 mov     ecx, [ebp+arg_10]
.text:000043A6                 push    ecx
.text:000043A7                 lea     ecx, [ebp+var_28]
.text:000043AA                 call    ??0?$CMyComPtr@UIInArchive@@@@QAE@ABV0@@Z ; CMyComPtr<IInArchive>::CMyComPtr<IInArchive>(CMyComPtr<IInArchive> const &)
.text:000043AF                 mov     byte ptr [ebp+var_4], 1
.text:000043B3                 lea     ecx, [ebp+var_18]
.text:000043B6                 call    ??I?$CMyComPtr@UIOutArchive@@@@QAEPAPAUIOutArchive@@XZ ; CMyComPtr<IOutArchive>::operator&(void)
.text:000043BB                 push    eax
.text:000043BC                 push    offset _IID_IOutArchive
.text:000043C1                 lea     ecx, [ebp+var_28]
.text:000043C4                 call    ??$QueryInterface@UIOutArchive@@@?$CMyComPtr@UIInArchive@@@@QBEJABU_GUID@@PAPAUIOutArchive@@@Z ; CMyComPtr<IInArchive>::QueryInterface<IOutArchive>(_GUID const &,IOutArchive * *)
.text:000043C9                 mov     [ebp+var_30], eax
.text:000043CC                 cmp     [ebp+var_30], 0
.text:000043D0                 jz      short loc_43EF
.text:000043D2                 mov     edx, ds:_kUpdateIsNotSupoorted
.text:000043D8                 mov     [ebp+var_240], edx
.text:000043DE                 push    offset __TI2CPAD
.text:000043E3                 lea     eax, [ebp+var_240]
.text:000043E9                 push    eax
.text:000043EA                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:000043EF ; ---------------------------------------------------------------------------
.text:000043EF
.text:000043EF loc_43EF:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+C4j
.text:000043EF                 mov     byte ptr [ebp+var_4], 0
.text:000043F3                 lea     ecx, [ebp+var_28]
.text:000043F6                 call    ??1?$CMyComPtr@UIInArchive@@@@QAE@XZ ; CMyComPtr<IInArchive>::~CMyComPtr<IInArchive>(void)
.text:000043FB                 jmp     short loc_4439
.text:000043FD ; ---------------------------------------------------------------------------
.text:000043FD
.text:000043FD loc_43FD:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+5Bj
.text:000043FD                 lea     ecx, [ebp+var_18]
.text:00004400                 push    ecx
.text:00004401                 mov     edx, [ebp+var_20]
.text:00004404                 push    edx
.text:00004405                 mov     ecx, [ebp+arg_8]
.text:00004408                 call    ?CreateOutArchive@CCodecs@@QBEJIAAV?$CMyComPtr@UIOutArchive@@@@@Z ; CCodecs::CreateOutArchive(uint,CMyComPtr<IOutArchive> &)
.text:0000440D                 mov     [ebp+var_34], eax
.text:00004410                 cmp     [ebp+var_34], 0
.text:00004414                 jz      short loc_4439
.text:00004416                 mov     eax, [ebp+var_34]
.text:00004419                 mov     [ebp+var_244], eax
.text:0000441F                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00004426                 lea     ecx, [ebp+var_18]
.text:00004429                 call    ??1?$CMyComPtr@UIOutArchive@@@@QAE@XZ ; CMyComPtr<IOutArchive>::~CMyComPtr<IOutArchive>(void)
.text:0000442E                 mov     eax, [ebp+var_244]
.text:00004434                 jmp     loc_5E99
.text:00004439 ; ---------------------------------------------------------------------------
.text:00004439
.text:00004439 loc_4439:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+EFj
.text:00004439                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+108j
.text:00004439                 lea     ecx, [ebp+var_18]
.text:0000443C                 call    ??B?$CMyComPtr@UIOutArchive@@@@QBEPAUIOutArchive@@XZ ; CMyComPtr<IOutArchive>::operator IOutArchive *(void)
.text:00004441                 test    eax, eax
.text:00004443                 jnz     short loc_4462
.text:00004445                 mov     ecx, ds:_kUpdateIsNotSupoorted
.text:0000444B                 mov     [ebp+var_248], ecx
.text:00004451                 push    offset __TI2CPAD
.text:00004456                 lea     edx, [ebp+var_248]
.text:0000445C                 push    edx
.text:0000445D                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:00004462 ; ---------------------------------------------------------------------------
.text:00004462
.text:00004462 loc_4462:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+137j
.text:00004462                 lea     ecx, [ebp+var_18]
.text:00004465                 call    ??C?$CMyComPtr@UIOutArchive@@@@QBEPAUIOutArchive@@XZ ; CMyComPtr<IOutArchive>::operator->(void)
.text:0000446A                 mov     [ebp+var_310], eax
.text:00004470                 mov     esi, esp
.text:00004472                 lea     eax, [ebp+var_40]
.text:00004475                 push    eax
.text:00004476                 mov     ecx, [ebp+var_310]
.text:0000447C                 push    ecx
.text:0000447D                 mov     edx, [ebp+var_310]
.text:00004483                 mov     eax, [edx]
.text:00004485                 mov     ecx, [eax+10h]
.text:00004488                 call    ecx
.text:0000448A                 cmp     esi, esp
.text:0000448C                 call    __RTC_CheckEsp
.text:00004491                 mov     [ebp+var_48], eax
.text:00004494                 cmp     [ebp+var_48], 0
.text:00004498                 jz      short loc_44BD
.text:0000449A                 mov     edx, [ebp+var_48]
.text:0000449D                 mov     [ebp+var_24C], edx
.text:000044A3                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000044AA                 lea     ecx, [ebp+var_18]
.text:000044AD                 call    ??1?$CMyComPtr@UIOutArchive@@@@QAE@XZ ; CMyComPtr<IOutArchive>::~CMyComPtr<IOutArchive>(void)
.text:000044B2                 mov     eax, [ebp+var_24C]
.text:000044B8                 jmp     loc_5E99
.text:000044BD ; ---------------------------------------------------------------------------
.text:000044BD
.text:000044BD loc_44BD:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+18Cj
.text:000044BD                 mov     eax, [ebp+var_40]
.text:000044C0                 mov     [ebp+var_314], eax
.text:000044C6                 cmp     [ebp+var_314], 0
.text:000044CD                 jb      short loc_44E2
.text:000044CF                 cmp     [ebp+var_314], 2
.text:000044D6                 jbe     short loc_44DA
.text:000044D8                 jmp     short loc_44E2
.text:000044DA ; ---------------------------------------------------------------------------
.text:000044DA
.text:000044DA loc_44DA:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+1CAj
.text:000044DA                 mov     ecx, [ebp+var_40]
.text:000044DD                 mov     [ebp+var_38], ecx
.text:000044E0                 jmp     short loc_4506
.text:000044E2 ; ---------------------------------------------------------------------------
.text:000044E2
.text:000044E2 loc_44E2:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+1C1j
.text:000044E2                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+1CCj
.text:000044E2                 mov     [ebp+var_250], 80004005h
.text:000044EC                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000044F3                 lea     ecx, [ebp+var_18]
.text:000044F6                 call    ??1?$CMyComPtr@UIOutArchive@@@@QAE@XZ ; CMyComPtr<IOutArchive>::~CMyComPtr<IOutArchive>(void)
.text:000044FB                 mov     eax, [ebp+var_250]
.text:00004501                 jmp     loc_5E99
.text:00004506 ; ---------------------------------------------------------------------------
.text:00004506
.text:00004506 loc_4506:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+1D4j
.text:00004506                 mov     edx, [ebp+var_20]
.text:00004509                 push    edx
.text:0000450A                 mov     ecx, [ebp+arg_8]
.text:0000450D                 add     ecx, 8
.text:00004510                 call    ??A?$CObjectVector@UCArcInfoEx@@@@QAEAAUCArcInfoEx@@I@Z ; CObjectVector<CArcInfoEx>::operator[](uint)
.text:00004515                 mov     [ebp+var_4C], eax
.text:00004518                 mov     eax, [ebp+arg_0]
.text:0000451B                 movzx   ecx, byte ptr [eax+0F2h]
.text:00004522                 test    ecx, ecx
.text:00004524                 jz      short loc_4559
.text:00004526                 mov     ecx, [ebp+var_4C] ; this
.text:00004529                 call    ?Flags_AltStreams@CArcInfoEx@@QBE_NXZ ; CArcInfoEx::Flags_AltStreams(void)
.text:0000452E                 movzx   edx, al
.text:00004531                 test    edx, edx
.text:00004533                 jnz     short loc_4559
.text:00004535                 mov     [ebp+var_254], 80004001h
.text:0000453F                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00004546                 lea     ecx, [ebp+var_18]
.text:00004549                 call    ??1?$CMyComPtr@UIOutArchive@@@@QAE@XZ ; CMyComPtr<IOutArchive>::~CMyComPtr<IOutArchive>(void)
.text:0000454E                 mov     eax, [ebp+var_254]
.text:00004554                 jmp     loc_5E99
.text:00004559 ; ---------------------------------------------------------------------------
.text:00004559
.text:00004559 loc_4559:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+218j
.text:00004559                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+227j
.text:00004559                 mov     eax, [ebp+arg_0]
.text:0000455C                 movzx   ecx, byte ptr [eax+0F0h]
.text:00004563                 test    ecx, ecx
.text:00004565                 jz      short loc_459A
.text:00004567                 mov     ecx, [ebp+var_4C] ; this
.text:0000456A                 call    ?Flags_NtSecure@CArcInfoEx@@QBE_NXZ ; CArcInfoEx::Flags_NtSecure(void)
.text:0000456F                 movzx   edx, al
.text:00004572                 test    edx, edx
.text:00004574                 jnz     short loc_459A
.text:00004576                 mov     [ebp+var_258], 80004001h
.text:00004580                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00004587                 lea     ecx, [ebp+var_18]
.text:0000458A                 call    ??1?$CMyComPtr@UIOutArchive@@@@QAE@XZ ; CMyComPtr<IOutArchive>::~CMyComPtr<IOutArchive>(void)
.text:0000458F                 mov     eax, [ebp+var_258]
.text:00004595                 jmp     loc_5E99
.text:0000459A ; ---------------------------------------------------------------------------
.text:0000459A
.text:0000459A loc_459A:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+259j
.text:0000459A                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+268j
.text:0000459A                 lea     ecx, [ebp+var_5C]
.text:0000459D                 call    ??0?$CRecordVector@UCUpdatePair2@@@@QAE@XZ ; CRecordVector<CUpdatePair2>::CRecordVector<CUpdatePair2>(void)
.text:000045A2                 mov     byte ptr [ebp+var_4], 2
.text:000045A6                 lea     ecx, [ebp+var_70]
.text:000045A9                 call    ??0?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::CObjectVector<UString>(void)
.text:000045AE                 mov     byte ptr [ebp+var_4], 3
.text:000045B2                 mov     ecx, [ebp+arg_0]
.text:000045B5                 add     ecx, 0FCh ; 'n'
.text:000045BB                 call    ?Size@?$CObjectVector@UCRenamePair@@@@QBEIXZ ; CObjectVector<CRenamePair>::Size(void)
.text:000045C0                 test    eax, eax
.text:000045C2                 jz      loc_4869
.text:000045C8                 mov     [ebp+var_78], 0
.text:000045CF                 jmp     short loc_45DA
.text:000045D1 ; ---------------------------------------------------------------------------
.text:000045D1
.text:000045D1 loc_45D1:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+556j
.text:000045D1                 mov     eax, [ebp+var_78]
.text:000045D4                 add     eax, 1
.text:000045D7                 mov     [ebp+var_78], eax
.text:000045DA
.text:000045DA loc_45DA:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+2C3j
.text:000045DA                 mov     ecx, [ebp+arg_18]
.text:000045DD                 call    ?Size@?$CObjectVector@UCArcItem@@@@QBEIXZ ; CObjectVector<CArcItem>::Size(void)
.text:000045E2                 cmp     [ebp+var_78], eax
.text:000045E5                 jnb     loc_4867
.text:000045EB                 mov     ecx, [ebp+var_78]
.text:000045EE                 push    ecx
.text:000045EF                 mov     ecx, [ebp+arg_18]
.text:000045F2                 call    ??A?$CObjectVector@UCArcItem@@@@QBEABUCArcItem@@I@Z ; CObjectVector<CArcItem>::operator[](uint)
.text:000045F7                 mov     [ebp+var_7C], eax
.text:000045FA                 mov     [ebp+var_7D], 0
.text:000045FE                 lea     ecx, [ebp+var_90]
.text:00004604                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00004609                 mov     byte ptr [ebp+var_4], 4
.text:0000460D                 mov     edx, [ebp+var_7C]
.text:00004610                 movzx   eax, byte ptr [edx+20h]
.text:00004614                 test    eax, eax
.text:00004616                 jz      loc_4766
.text:0000461C                 mov     [ebp+var_98], 0
.text:00004626                 jmp     short loc_4637
.text:00004628 ; ---------------------------------------------------------------------------
.text:00004628
.text:00004628 loc_4628:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &):loc_4761j
.text:00004628                 mov     ecx, [ebp+var_98]
.text:0000462E                 add     ecx, 1
.text:00004631                 mov     [ebp+var_98], ecx
.text:00004637
.text:00004637 loc_4637:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+31Aj
.text:00004637                 mov     ecx, [ebp+arg_0]
.text:0000463A                 add     ecx, 0FCh ; 'n'
.text:00004640                 call    ?Size@?$CObjectVector@UCRenamePair@@@@QBEIXZ ; CObjectVector<CRenamePair>::Size(void)
.text:00004645                 cmp     [ebp+var_98], eax
.text:0000464B                 jnb     loc_4766
.text:00004651                 mov     edx, [ebp+var_98]
.text:00004657                 push    edx
.text:00004658                 mov     ecx, [ebp+arg_0]
.text:0000465B                 add     ecx, 0FCh ; 'n'
.text:00004661                 call    ??A?$CObjectVector@UCRenamePair@@@@QBEABUCRenamePair@@I@Z ; CObjectVector<CRenamePair>::operator[](uint)
.text:00004666                 mov     [ebp+var_9C], eax
.text:0000466C                 lea     eax, [ebp+var_90]
.text:00004672                 push    eax             ; struct UString *
.text:00004673                 mov     ecx, [ebp+var_7C]
.text:00004676                 add     ecx, 10h
.text:00004679                 push    ecx             ; struct UString *
.text:0000467A                 mov     edx, [ebp+var_7C]
.text:0000467D                 movzx   eax, byte ptr [edx+1Ch]
.text:00004681                 push    eax             ; bool
.text:00004682                 mov     ecx, [ebp+var_9C] ; this
.text:00004688                 call    ?GetNewPath@CRenamePair@@QBE_N_NABVUString@@AAV2@@Z ; CRenamePair::GetNewPath(bool,UString const &,UString &)
.text:0000468D                 movzx   ecx, al
.text:00004690                 test    ecx, ecx
.text:00004692                 jz      short loc_469D
.text:00004694                 mov     [ebp+var_7D], 1
.text:00004698                 jmp     loc_4766
.text:0000469D ; ---------------------------------------------------------------------------
.text:0000469D
.text:0000469D loc_469D:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+386j
.text:0000469D                 mov     edx, [ebp+var_7C]
.text:000046A0                 movzx   eax, byte ptr [edx+1Dh]
.text:000046A4                 test    eax, eax
.text:000046A6                 jz      loc_4761
.text:000046AC                 mov     ecx, [ebp+var_7C]
.text:000046AF                 add     ecx, 10h
.text:000046B2                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000046B7                 push    eax             ; wchar_t *
.text:000046B8                 call    ?FindAltStreamColon_in_Path@@YGHPB_W@Z ; FindAltStreamColon_in_Path(wchar_t const *)
.text:000046BD                 mov     [ebp+var_A0], eax
.text:000046C3                 cmp     [ebp+var_A0], 0
.text:000046CA                 jl      loc_4761
.text:000046D0                 mov     ecx, [ebp+var_A0]
.text:000046D6                 push    ecx
.text:000046D7                 lea     edx, [ebp+var_B0]
.text:000046DD                 push    edx
.text:000046DE                 mov     ecx, [ebp+var_7C]
.text:000046E1                 add     ecx, 10h
.text:000046E4                 call    ?Left@UString@@QBE?AV1@I@Z ; UString::Left(uint)
.text:000046E9                 mov     byte ptr [ebp+var_4], 5
.text:000046ED                 lea     eax, [ebp+var_90]
.text:000046F3                 push    eax             ; struct UString *
.text:000046F4                 lea     ecx, [ebp+var_B0]
.text:000046FA                 push    ecx             ; struct UString *
.text:000046FB                 push    0               ; bool
.text:000046FD                 mov     ecx, [ebp+var_9C] ; this
.text:00004703                 call    ?GetNewPath@CRenamePair@@QBE_N_NABVUString@@AAV2@@Z ; CRenamePair::GetNewPath(bool,UString const &,UString &)
.text:00004708                 movzx   edx, al
.text:0000470B                 test    edx, edx
.text:0000470D                 jz      short loc_4752
.text:0000470F                 mov     [ebp+var_7D], 1
.text:00004713                 push    3Ah ; ':'
.text:00004715                 lea     ecx, [ebp+var_90]
.text:0000471B                 call    ??YUString@@QAEAAV0@_W@Z ; UString::operator+=(wchar_t)
.text:00004720                 mov     eax, [ebp+var_A0]
.text:00004726                 add     eax, 1
.text:00004729                 push    eax             ; unsigned int
.text:0000472A                 mov     ecx, [ebp+var_7C]
.text:0000472D                 add     ecx, 10h        ; this
.text:00004730                 call    ?Ptr@UString@@QBEPB_WI@Z ; UString::Ptr(uint)
.text:00004735                 push    eax
.text:00004736                 lea     ecx, [ebp+var_90]
.text:0000473C                 call    ??YUString@@QAEAAV0@PB_W@Z ; UString::operator+=(wchar_t const *)
.text:00004741                 mov     byte ptr [ebp+var_4], 4
.text:00004745                 lea     ecx, [ebp+var_B0] ; this
.text:0000474B                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00004750                 jmp     short loc_4766
.text:00004752 ; ---------------------------------------------------------------------------
.text:00004752
.text:00004752 loc_4752:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+401j
.text:00004752                 mov     byte ptr [ebp+var_4], 4
.text:00004756                 lea     ecx, [ebp+var_B0] ; this
.text:0000475C                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00004761
.text:00004761 loc_4761:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+39Aj
.text:00004761                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+3BEj
.text:00004761                 jmp     loc_4628
.text:00004766 ; ---------------------------------------------------------------------------
.text:00004766
.text:00004766 loc_4766:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+30Aj
.text:00004766                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+33Fj ...
.text:00004766                 lea     ecx, [ebp+var_CC]
.text:0000476C                 call    ??0CUpdatePair2@@QAE@XZ ; CUpdatePair2::CUpdatePair2(void)
.text:00004771                 mov     ecx, [ebp+var_7C]
.text:00004774                 mov     edx, [ecx+24h]
.text:00004777                 push    edx             ; int
.text:00004778                 lea     ecx, [ebp+var_CC] ; this
.text:0000477E                 call    ?SetAs_NoChangeArcItem@CUpdatePair2@@QAEXH@Z ; CUpdatePair2::SetAs_NoChangeArcItem(int)
.text:00004783                 movzx   eax, [ebp+var_7D]
.text:00004787                 test    eax, eax
.text:00004789                 jz      loc_481A
.text:0000478F                 mov     [ebp+var_CC+1], 1
.text:00004796                 lea     ecx, [ebp+var_CC+3]
.text:0000479C                 push    ecx             ; bool *
.text:0000479D                 mov     edx, [ebp+var_78]
.text:000047A0                 push    edx             ; unsigned int
.text:000047A1                 mov     ecx, [ebp+arg_10] ; this
.text:000047A4                 call    ?IsItemAnti@CArc@@QBEJIAA_N@Z ; CArc::IsItemAnti(uint,bool &)
.text:000047A9                 mov     [ebp+var_D4], eax
.text:000047AF                 cmp     [ebp+var_D4], 0
.text:000047B6                 jz      short loc_4805
.text:000047B8                 mov     eax, [ebp+var_D4]
.text:000047BE                 mov     [ebp+var_25C], eax
.text:000047C4                 mov     byte ptr [ebp+var_4], 3
.text:000047C8                 lea     ecx, [ebp+var_90] ; this
.text:000047CE                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000047D3                 mov     byte ptr [ebp+var_4], 2
.text:000047D7                 lea     ecx, [ebp+var_70]
.text:000047DA                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:000047DF                 mov     byte ptr [ebp+var_4], 0
.text:000047E3                 lea     ecx, [ebp+var_5C]
.text:000047E6                 call    ??1?$CRecordVector@UCUpdatePair2@@@@QAE@XZ ; CRecordVector<CUpdatePair2>::~CRecordVector<CUpdatePair2>(void)
.text:000047EB                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000047F2                 lea     ecx, [ebp+var_18]
.text:000047F5                 call    ??1?$CMyComPtr@UIOutArchive@@@@QAE@XZ ; CMyComPtr<IOutArchive>::~CMyComPtr<IOutArchive>(void)
.text:000047FA                 mov     eax, [ebp+var_25C]
.text:00004800                 jmp     loc_5E99
.text:00004805 ; ---------------------------------------------------------------------------
.text:00004805
.text:00004805 loc_4805:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+4AAj
.text:00004805                 lea     ecx, [ebp+var_90]
.text:0000480B                 push    ecx
.text:0000480C                 lea     ecx, [ebp+var_70]
.text:0000480F                 call    ?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z ; CObjectVector<UString>::Add(UString const &)
.text:00004814                 mov     [ebp+var_C0], eax
.text:0000481A
.text:0000481A loc_481A:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+47Dj
.text:0000481A                 sub     esp, 14h
.text:0000481D                 mov     edx, esp
.text:0000481F                 mov     eax, dword ptr [ebp+var_CC]
.text:00004825                 mov     [edx], eax
.text:00004827                 mov     ecx, [ebp+var_C8]
.text:0000482D                 mov     [edx+4], ecx
.text:00004830                 mov     eax, [ebp+var_C4]
.text:00004836                 mov     [edx+8], eax
.text:00004839                 mov     ecx, [ebp+var_C0]
.text:0000483F                 mov     [edx+0Ch], ecx
.text:00004842                 mov     eax, [ebp+var_BC]
.text:00004848                 mov     [edx+10h], eax
.text:0000484B                 lea     ecx, [ebp+var_5C]
.text:0000484E                 call    ?Add@?$CRecordVector@UCUpdatePair2@@@@QAEIUCUpdatePair2@@@Z ; CRecordVector<CUpdatePair2>::Add(CUpdatePair2)
.text:00004853                 mov     byte ptr [ebp+var_4], 3
.text:00004857                 lea     ecx, [ebp+var_90] ; this
.text:0000485D                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00004862                 jmp     loc_45D1
.text:00004867 ; ---------------------------------------------------------------------------
.text:00004867
.text:00004867 loc_4867:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+2D9j
.text:00004867                 jmp     short loc_48D7
.text:00004869 ; ---------------------------------------------------------------------------
.text:00004869
.text:00004869 loc_4869:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+2B6j
.text:00004869                 lea     ecx, [ebp+var_E4]
.text:0000486F                 call    ??0?$CRecordVector@UCUpdatePair@@@@QAE@XZ ; CRecordVector<CUpdatePair>::CRecordVector<CUpdatePair>(void)
.text:00004874                 mov     byte ptr [ebp+var_4], 6
.text:00004878                 lea     ecx, [ebp+var_E4]
.text:0000487E                 push    ecx
.text:0000487F                 mov     edx, [ebp+var_38]
.text:00004882                 push    edx
.text:00004883                 mov     eax, [ebp+arg_18]
.text:00004886                 push    eax
.text:00004887                 mov     ecx, [ebp+arg_20]
.text:0000488A                 push    ecx
.text:0000488B                 call    ?GetUpdatePairInfoList@@YGXABVCDirItems@@ABV?$CObjectVector@UCArcItem@@@@W4EEnum@NFileTimeType@@AAV?$CRecordVector@UCUpdatePair@@@@@Z ; GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)
.text:00004890                 mov     edx, [ebp+arg_30]
.text:00004893                 push    edx
.text:00004894                 mov     eax, [ebp+arg_18]
.text:00004897                 push    eax
.text:00004898                 lea     ecx, [ebp+var_F8]
.text:0000489E                 call    ??0CUpdateProduceCallbackImp@@QAE@PBV?$CObjectVector@UCArcItem@@@@PAUIUpdateCallbackUI@@@Z ; CUpdateProduceCallbackImp::CUpdateProduceCallbackImp(CObjectVector<CArcItem> const *,IUpdateCallbackUI *)
.text:000048A3                 movzx   ecx, [ebp+arg_4]
.text:000048A7                 neg     ecx
.text:000048A9                 sbb     ecx, ecx
.text:000048AB                 lea     edx, [ebp+var_F8]
.text:000048B1                 and     ecx, edx
.text:000048B3                 push    ecx
.text:000048B4                 lea     eax, [ebp+var_5C]
.text:000048B7                 push    eax
.text:000048B8                 mov     ecx, [ebp+arg_C]
.text:000048BB                 push    ecx
.text:000048BC                 lea     edx, [ebp+var_E4]
.text:000048C2                 push    edx
.text:000048C3                 call    ?UpdateProduce@@YGXABV?$CRecordVector@UCUpdatePair@@@@ABUCActionSet@NUpdateArchive@@AAV?$CRecordVector@UCUpdatePair2@@@@PAUIUpdateProduceCallback@@@Z ; UpdateProduce(CRecordVector<CUpdatePair> const &,NUpdateArchive::CActionSet const &,CRecordVector<CUpdatePair2> &,IUpdateProduceCallback *)
.text:000048C8                 mov     byte ptr [ebp+var_4], 3
.text:000048CC                 lea     ecx, [ebp+var_E4]
.text:000048D2                 call    ??1?$CRecordVector@UCUpdatePair@@@@QAE@XZ ; CRecordVector<CUpdatePair>::~CRecordVector<CUpdatePair>(void)
.text:000048D7
.text:000048D7 loc_48D7:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &):loc_4867j
.text:000048D7                 mov     [ebp+var_100], 0
.text:000048E1                 mov     [ebp+var_104], 0
.text:000048EB                 jmp     short loc_48FC
.text:000048ED ; ---------------------------------------------------------------------------
.text:000048ED
.text:000048ED loc_48ED:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &):loc_4931j
.text:000048ED                 mov     eax, [ebp+var_104]
.text:000048F3                 add     eax, 1
.text:000048F6                 mov     [ebp+var_104], eax
.text:000048FC
.text:000048FC loc_48FC:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+5DFj
.text:000048FC                 lea     ecx, [ebp+var_5C]
.text:000048FF                 call    ?Size@?$CRecordVector@UCUpdatePair2@@@@QBEIXZ ; CRecordVector<CUpdatePair2>::Size(void)
.text:00004904                 cmp     [ebp+var_104], eax
.text:0000490A                 jnb     short loc_4933
.text:0000490C                 mov     ecx, [ebp+var_104]
.text:00004912                 push    ecx
.text:00004913                 lea     ecx, [ebp+var_5C]
.text:00004916                 call    ??A?$CRecordVector@UCUpdatePair2@@@@QAEAAUCUpdatePair2@@I@Z ; CRecordVector<CUpdatePair2>::operator[](uint)
.text:0000491B                 movzx   edx, byte ptr [eax]
.text:0000491E                 test    edx, edx
.text:00004920                 jz      short loc_4931
.text:00004922                 mov     eax, [ebp+var_100]
.text:00004928                 add     eax, 1
.text:0000492B                 mov     [ebp+var_100], eax
.text:00004931
.text:00004931 loc_4931:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+614j
.text:00004931                 jmp     short loc_48ED
.text:00004933 ; ---------------------------------------------------------------------------
.text:00004933
.text:00004933 loc_4933:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+5FEj
.text:00004933                 mov     ecx, [ebp+var_100]
.text:00004939                 xor     edx, edx
.text:0000493B                 mov     esi, esp
.text:0000493D                 push    edx
.text:0000493E                 push    ecx
.text:0000493F                 mov     eax, [ebp+arg_30]
.text:00004942                 mov     edx, [eax]
.text:00004944                 mov     ecx, [ebp+arg_30]
.text:00004947                 mov     eax, [edx+14h]
.text:0000494A                 call    eax
.text:0000494C                 cmp     esi, esp
.text:0000494E                 call    __RTC_CheckEsp
.text:00004953                 mov     [ebp+var_108], eax
.text:00004959                 cmp     [ebp+var_108], 0
.text:00004960                 jz      short loc_49A0
.text:00004962                 mov     ecx, [ebp+var_108]
.text:00004968                 mov     [ebp+var_260], ecx
.text:0000496E                 mov     byte ptr [ebp+var_4], 2
.text:00004972                 lea     ecx, [ebp+var_70]
.text:00004975                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:0000497A                 mov     byte ptr [ebp+var_4], 0
.text:0000497E                 lea     ecx, [ebp+var_5C]
.text:00004981                 call    ??1?$CRecordVector@UCUpdatePair2@@@@QAE@XZ ; CRecordVector<CUpdatePair2>::~CRecordVector<CUpdatePair2>(void)
.text:00004986                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000498D                 lea     ecx, [ebp+var_18]
.text:00004990                 call    ??1?$CMyComPtr@UIOutArchive@@@@QAE@XZ ; CMyComPtr<IOutArchive>::~CMyComPtr<IOutArchive>(void)
.text:00004995                 mov     eax, [ebp+var_260]
.text:0000499B                 jmp     loc_5E99
.text:000049A0 ; ---------------------------------------------------------------------------
.text:000049A0
.text:000049A0 loc_49A0:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+654j
.text:000049A0                 push    0A8h ; ''      ; unsigned int
.text:000049A5                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:000049AA                 add     esp, 4
.text:000049AD                 mov     [ebp+var_268], eax
.text:000049B3                 mov     byte ptr [ebp+var_4], 7
.text:000049B7                 cmp     [ebp+var_268], 0
.text:000049BE                 jz      short loc_49D3
.text:000049C0                 mov     ecx, [ebp+var_268] ; this
.text:000049C6                 call    ??0CArchiveUpdateCallback@@QAE@XZ ; CArchiveUpdateCallback::CArchiveUpdateCallback(void)
.text:000049CB                 mov     [ebp+var_318], eax
.text:000049D1                 jmp     short loc_49DD
.text:000049D3 ; ---------------------------------------------------------------------------
.text:000049D3
.text:000049D3 loc_49D3:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+6B2j
.text:000049D3                 mov     [ebp+var_318], 0
.text:000049DD
.text:000049DD loc_49DD:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+6C5j
.text:000049DD                 mov     edx, [ebp+var_318]
.text:000049E3                 mov     [ebp+var_264], edx
.text:000049E9                 mov     byte ptr [ebp+var_4], 3
.text:000049ED                 mov     eax, [ebp+var_264]
.text:000049F3                 mov     [ebp+var_10C], eax
.text:000049F9                 mov     ecx, [ebp+var_10C]
.text:000049FF                 push    ecx
.text:00004A00                 lea     ecx, [ebp+var_114]
.text:00004A06                 call    ??0?$CMyComPtr@UIArchiveUpdateCallback@@@@QAE@PAUIArchiveUpdateCallback@@@Z ; CMyComPtr<IArchiveUpdateCallback>::CMyComPtr<IArchiveUpdateCallback>(IArchiveUpdateCallback *)
.text:00004A0B                 mov     byte ptr [ebp+var_4], 8
.text:00004A0F                 mov     edx, [ebp+var_10C]
.text:00004A15                 mov     eax, [ebp+arg_0]
.text:00004A18                 mov     cl, [eax+0B4h]
.text:00004A1E                 mov     [edx+9Ch], cl
.text:00004A24                 mov     edx, [ebp+var_10C]
.text:00004A2A                 mov     eax, [ebp+arg_0]
.text:00004A2D                 mov     cl, [eax+0B5h]
.text:00004A33                 mov     [edx+9Dh], cl
.text:00004A39                 mov     edx, [ebp+var_10C]
.text:00004A3F                 mov     eax, [ebp+arg_30]
.text:00004A42                 mov     [edx+7Ch], eax
.text:00004A45                 cmp     [ebp+arg_10], 0
.text:00004A49                 jz      short loc_4A60
.text:00004A4B                 mov     ecx, [ebp+arg_10]
.text:00004A4E                 push    ecx
.text:00004A4F                 mov     ecx, [ebp+var_10C]
.text:00004A55                 add     ecx, 8Ch ; ''
.text:00004A5B                 call    ??4?$CMyComPtr@UIInArchive@@@@QAEPAUIInArchive@@ABV0@@Z ; CMyComPtr<IInArchive>::operator=(CMyComPtr<IInArchive> const &)
.text:00004A60
.text:00004A60 loc_4A60:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+73Dj
.text:00004A60                 mov     edx, [ebp+var_10C]
.text:00004A66                 mov     eax, [ebp+arg_20]
.text:00004A69                 mov     [edx+80h], eax
.text:00004A6F                 mov     ecx, [ebp+var_10C]
.text:00004A75                 mov     edx, [ebp+arg_24]
.text:00004A78                 mov     [ecx+84h], edx
.text:00004A7E                 mov     eax, [ebp+var_10C]
.text:00004A84                 mov     ecx, [ebp+arg_0]
.text:00004A87                 mov     dl, [ecx+0F0h]
.text:00004A8D                 mov     [eax+9Fh], dl
.text:00004A93                 mov     eax, [ebp+var_10C]
.text:00004A99                 mov     ecx, [ebp+arg_0]
.text:00004A9C                 mov     dl, [ecx+0F4h]
.text:00004AA2                 mov     [eax+0A0h], dl
.text:00004AA8                 mov     eax, [ebp+var_10C]
.text:00004AAE                 mov     ecx, [ebp+arg_0]
.text:00004AB1                 mov     dl, [ecx+0F6h]
.text:00004AB7                 mov     [eax+0A1h], dl
.text:00004ABD                 mov     eax, [ebp+var_10C]
.text:00004AC3                 mov     ecx, [ebp+arg_10]
.text:00004AC6                 mov     [eax+88h], ecx
.text:00004ACC                 mov     edx, [ebp+var_10C]
.text:00004AD2                 mov     eax, [ebp+arg_18]
.text:00004AD5                 mov     [edx+90h], eax
.text:00004ADB                 mov     ecx, [ebp+var_10C]
.text:00004AE1                 lea     edx, [ebp+var_5C]
.text:00004AE4                 mov     [ecx+94h], edx
.text:00004AEA                 mov     eax, [ebp+var_10C]
.text:00004AF0                 mov     ecx, [ebp+arg_1C]
.text:00004AF3                 mov     [eax+0A4h], ecx
.text:00004AF9                 mov     ecx, [ebp+arg_0]
.text:00004AFC                 add     ecx, 0FCh ; 'n'
.text:00004B02                 call    ?Size@?$CObjectVector@UCRenamePair@@@@QBEIXZ ; CObjectVector<CRenamePair>::Size(void)
.text:00004B07                 test    eax, eax
.text:00004B09                 jz      short loc_4B1A
.text:00004B0B                 mov     edx, [ebp+var_10C]
.text:00004B11                 lea     eax, [ebp+var_70]
.text:00004B14                 mov     [edx+98h], eax
.text:00004B1A
.text:00004B1A loc_4B1A:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+7FDj
.text:00004B1A                 lea     ecx, [ebp+var_120]
.text:00004B20                 call    ??0?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::CMyComPtr<IOutStream>(void)
.text:00004B25                 mov     byte ptr [ebp+var_4], 9
.text:00004B29                 lea     ecx, [ebp+var_12C]
.text:00004B2F                 call    ??0?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::CMyComPtr<ISequentialOutStream>(void)
.text:00004B34                 mov     byte ptr [ebp+var_4], 0Ah
.text:00004B38                 mov     ecx, [ebp+arg_0]
.text:00004B3B                 movzx   edx, byte ptr [ecx+0C4h]
.text:00004B42                 test    edx, edx
.text:00004B44                 jnz     loc_4BFB
.text:00004B4A                 lea     ecx, [ebp+var_140]
.text:00004B50                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00004B55                 mov     byte ptr [ebp+var_4], 0Bh
.text:00004B59                 lea     eax, [ebp+var_140]
.text:00004B5F                 push    eax             ; wchar_t *
.text:00004B60                 lea     ecx, [ebp+var_278]
.text:00004B66                 push    ecx
.text:00004B67                 mov     ecx, [ebp+arg_14]
.text:00004B6A                 call    ?GetFinalPath@CArchivePath@@QBE?AVUString@@XZ ; CArchivePath::GetFinalPath(void)
.text:00004B6F                 mov     [ebp+var_31C], eax
.text:00004B75                 mov     edx, [ebp+var_31C]
.text:00004B7B                 mov     [ebp+var_320], edx
.text:00004B81                 mov     byte ptr [ebp+var_4], 0Ch
.text:00004B85                 mov     ecx, [ebp+var_320]
.text:00004B8B                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00004B90                 push    eax             ; wchar_t *
.text:00004B91                 call    ?GetOnlyDirPrefix@NDir@NFile@NWindows@@YG_NPB_WAAVUString@@@Z ; NWindows::NFile::NDir::GetOnlyDirPrefix(wchar_t const *,UString &)
.text:00004B96                 movzx   eax, al
.text:00004B99                 neg     eax
.text:00004B9B                 sbb     eax, eax
.text:00004B9D                 add     eax, 1
.text:00004BA0                 mov     [ebp+var_269], al
.text:00004BA6                 mov     byte ptr [ebp+var_4], 0Bh
.text:00004BAA                 lea     ecx, [ebp+var_278] ; this
.text:00004BB0                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00004BB5                 movzx   ecx, [ebp+var_269]
.text:00004BBC                 test    ecx, ecx
.text:00004BBE                 jz      short loc_4BDB
.text:00004BC0                 mov     [ebp+var_27C], 159FC9h
.text:00004BCA                 push    offset __TI1H
.text:00004BCF                 lea     edx, [ebp+var_27C]
.text:00004BD5                 push    edx
.text:00004BD6                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:00004BDB ; ---------------------------------------------------------------------------
.text:00004BDB
.text:00004BDB loc_4BDB:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+8B2j
.text:00004BDB                 lea     ecx, [ebp+var_140]
.text:00004BE1                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00004BE6                 push    eax             ; this
.text:00004BE7                 call    ?CreateComplexDir@NDir@NFile@NWindows@@YG_NPB_W@Z ; NWindows::NFile::NDir::CreateComplexDir(wchar_t const *)
.text:00004BEC                 mov     byte ptr [ebp+var_4], 0Ah
.text:00004BF0                 lea     ecx, [ebp+var_140] ; this
.text:00004BF6                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00004BFB
.text:00004BFB loc_4BFB:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+838j
.text:00004BFB                 mov     [ebp+var_148], 0
.text:00004C05                 mov     [ebp+var_14C], 0
.text:00004C0F                 mov     [ebp+var_150], 0
.text:00004C19                 mov     ecx, [ebp+arg_0]
.text:00004C1C                 add     ecx, 108h
.text:00004C22                 call    ?Size@?$CRecordVector@_K@@QBEIXZ ; CRecordVector<unsigned __int64>::Size(void)
.text:00004C27                 test    eax, eax
.text:00004C29                 jnz     loc_4F3C
.text:00004C2F                 mov     eax, [ebp+arg_0]
.text:00004C32                 movzx   ecx, byte ptr [eax+0C4h]
.text:00004C39                 test    ecx, ecx
.text:00004C3B                 jz      short loc_4CAA
.text:00004C3D                 push    10h             ; unsigned int
.text:00004C3F                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00004C44                 add     esp, 4
.text:00004C47                 mov     [ebp+var_284], eax
.text:00004C4D                 mov     byte ptr [ebp+var_4], 0Dh
.text:00004C51                 cmp     [ebp+var_284], 0
.text:00004C58                 jz      short loc_4C6D
.text:00004C5A                 mov     ecx, [ebp+var_284]
.text:00004C60                 call    ??0CStdOutFileStream@@QAE@XZ ; CStdOutFileStream::CStdOutFileStream(void)
.text:00004C65                 mov     [ebp+var_324], eax
.text:00004C6B                 jmp     short loc_4C77
.text:00004C6D ; ---------------------------------------------------------------------------
.text:00004C6D
.text:00004C6D loc_4C6D:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+94Cj
.text:00004C6D                 mov     [ebp+var_324], 0
.text:00004C77
.text:00004C77 loc_4C77:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+95Fj
.text:00004C77                 mov     edx, [ebp+var_324]
.text:00004C7D                 mov     [ebp+var_280], edx
.text:00004C83                 mov     byte ptr [ebp+var_4], 0Ah
.text:00004C87                 mov     eax, [ebp+var_280]
.text:00004C8D                 mov     [ebp+var_14C], eax
.text:00004C93                 mov     ecx, [ebp+var_14C]
.text:00004C99                 push    ecx
.text:00004C9A                 lea     ecx, [ebp+var_12C]
.text:00004CA0                 call    ??4?$CMyComPtr@UISequentialOutStream@@@@QAEPAUISequentialOutStream@@PAU1@@Z ; CMyComPtr<ISequentialOutStream>::operator=(ISequentialOutStream *)
.text:00004CA5                 jmp     loc_4F37
.text:00004CAA ; ---------------------------------------------------------------------------
.text:00004CAA
.text:00004CAA loc_4CAA:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+92Fj
.text:00004CAA                 push    20h ; ' '       ; unsigned int
.text:00004CAC                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00004CB1                 add     esp, 4
.text:00004CB4                 mov     [ebp+var_28C], eax
.text:00004CBA                 mov     byte ptr [ebp+var_4], 0Eh
.text:00004CBE                 cmp     [ebp+var_28C], 0
.text:00004CC5                 jz      short loc_4CDA
.text:00004CC7                 mov     ecx, [ebp+var_28C]
.text:00004CCD                 call    ??0COutFileStream@@QAE@XZ ; COutFileStream::COutFileStream(void)
.text:00004CD2                 mov     [ebp+var_328], eax
.text:00004CD8                 jmp     short loc_4CE4
.text:00004CDA ; ---------------------------------------------------------------------------
.text:00004CDA
.text:00004CDA loc_4CDA:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+9B9j
.text:00004CDA                 mov     [ebp+var_328], 0
.text:00004CE4
.text:00004CE4 loc_4CE4:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+9CCj
.text:00004CE4                 mov     edx, [ebp+var_328]
.text:00004CEA                 mov     [ebp+var_288], edx
.text:00004CF0                 mov     byte ptr [ebp+var_4], 0Ah
.text:00004CF4                 mov     eax, [ebp+var_288]
.text:00004CFA                 mov     [ebp+var_148], eax
.text:00004D00                 mov     ecx, [ebp+var_148]
.text:00004D06                 push    ecx
.text:00004D07                 lea     ecx, [ebp+var_120]
.text:00004D0D                 call    ??4?$CMyComPtr@UIOutStream@@@@QAEPAUIOutStream@@PAU1@@Z ; CMyComPtr<IOutStream>::operator=(IOutStream *)
.text:00004D12                 lea     ecx, [ebp+var_120]
.text:00004D18                 call    ??B?$CMyComPtr@UIOutStream@@@@QBEPAUIOutStream@@XZ ; CMyComPtr<IOutStream>::operator IOutStream *(void)
.text:00004D1D                 push    eax
.text:00004D1E                 lea     ecx, [ebp+var_12C]
.text:00004D24                 call    ??4?$CMyComPtr@UISequentialOutStream@@@@QAEPAUISequentialOutStream@@PAU1@@Z ; CMyComPtr<ISequentialOutStream>::operator=(ISequentialOutStream *)
.text:00004D29                 mov     [ebp+var_151], 0
.text:00004D30                 lea     ecx, [ebp+var_164]
.text:00004D36                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00004D3B                 mov     byte ptr [ebp+var_4], 0Fh
.text:00004D3F                 mov     [ebp+var_16C], 0
.text:00004D49                 jmp     short loc_4D5A
.text:00004D4B ; ---------------------------------------------------------------------------
.text:00004D4B
.text:00004D4B loc_4D4B:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &):loc_4E8Cj
.text:00004D4B                 mov     edx, [ebp+var_16C]
.text:00004D51                 add     edx, 1
.text:00004D54                 mov     [ebp+var_16C], edx
.text:00004D5A
.text:00004D5A loc_4D5A:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+A3Dj
.text:00004D5A                 cmp     [ebp+var_16C], 10000h
.text:00004D64                 jnb     loc_4E91
.text:00004D6A                 mov     eax, [ebp+arg_14]
.text:00004D6D                 movzx   ecx, byte ptr [eax+3Ch]
.text:00004D71                 test    ecx, ecx
.text:00004D73                 jz      short loc_4DEB
.text:00004D75                 cmp     [ebp+var_16C], 0
.text:00004D7C                 jbe     short loc_4DA3
.text:00004D7E                 lea     edx, [ebp+var_190]
.text:00004D84                 push    edx             ; wchar_t *
.text:00004D85                 mov     eax, [ebp+var_16C]
.text:00004D8B                 push    eax             ; unsigned int
.text:00004D8C                 call    ?ConvertUInt32ToString@@YGXIPA_W@Z ; ConvertUInt32ToString(uint,wchar_t *)
.text:00004D91                 lea     ecx, [ebp+var_190]
.text:00004D97                 push    ecx
.text:00004D98                 mov     ecx, [ebp+arg_14]
.text:00004D9B                 add     ecx, 4Ch ; 'L'
.text:00004D9E                 call    ??4UString@@QAEAAV0@PB_W@Z ; UString::operator=(wchar_t const *)
.text:00004DA3
.text:00004DA3 loc_4DA3:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+A70j
.text:00004DA3                 lea     edx, [ebp+var_298]
.text:00004DA9                 push    edx
.text:00004DAA                 mov     ecx, [ebp+arg_14]
.text:00004DAD                 call    ?GetTempPathA@CArchivePath@@QBE?AVUString@@XZ ; CArchivePath::GetTempPathA(void)
.text:00004DB2                 mov     [ebp+var_32C], eax
.text:00004DB8                 mov     eax, [ebp+var_32C]
.text:00004DBE                 mov     [ebp+var_330], eax
.text:00004DC4                 mov     byte ptr [ebp+var_4], 10h
.text:00004DC8                 mov     ecx, [ebp+var_330]
.text:00004DCE                 push    ecx
.text:00004DCF                 lea     ecx, [ebp+var_164]
.text:00004DD5                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:00004DDA                 mov     byte ptr [ebp+var_4], 0Fh
.text:00004DDE                 lea     ecx, [ebp+var_298] ; this
.text:00004DE4                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00004DE9                 jmp     short loc_4E31
.text:00004DEB ; ---------------------------------------------------------------------------
.text:00004DEB
.text:00004DEB loc_4DEB:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+A67j
.text:00004DEB                 lea     edx, [ebp+var_2A4]
.text:00004DF1                 push    edx
.text:00004DF2                 mov     ecx, [ebp+arg_14]
.text:00004DF5                 call    ?GetFinalPath@CArchivePath@@QBE?AVUString@@XZ ; CArchivePath::GetFinalPath(void)
.text:00004DFA                 mov     [ebp+var_334], eax
.text:00004E00                 mov     eax, [ebp+var_334]
.text:00004E06                 mov     [ebp+var_338], eax
.text:00004E0C                 mov     byte ptr [ebp+var_4], 11h
.text:00004E10                 mov     ecx, [ebp+var_338]
.text:00004E16                 push    ecx
.text:00004E17                 lea     ecx, [ebp+var_164]
.text:00004E1D                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:00004E22                 mov     byte ptr [ebp+var_4], 0Fh
.text:00004E26                 lea     ecx, [ebp+var_2A4] ; this
.text:00004E2C                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00004E31
.text:00004E31 loc_4E31:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+ADDj
.text:00004E31                 push    0               ; bool
.text:00004E33                 lea     ecx, [ebp+var_164]
.text:00004E39                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00004E3E                 push    eax             ; wchar_t *
.text:00004E3F                 mov     ecx, [ebp+var_148] ; this
.text:00004E45                 call    ?Create@COutFileStream@@QAE_NPB_W_N@Z ; COutFileStream::Create(wchar_t const *,bool)
.text:00004E4A                 movzx   edx, al
.text:00004E4D                 test    edx, edx
.text:00004E4F                 jz      short loc_4E69
.text:00004E51                 lea     eax, [ebp+var_164]
.text:00004E57                 push    eax
.text:00004E58                 mov     ecx, [ebp+arg_28]
.text:00004E5B                 call    ?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z ; CObjectVector<UString>::Add(UString const &)
.text:00004E60                 mov     [ebp+var_151], 1
.text:00004E67                 jmp     short loc_4E91
.text:00004E69 ; ---------------------------------------------------------------------------
.text:00004E69
.text:00004E69 loc_4E69:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+B43j
.text:00004E69                 mov     esi, esp
.text:00004E6B                 call    dword ptr ds:__imp__GetLastError@0 ; GetLastError()
.text:00004E71                 cmp     esi, esp
.text:00004E73                 call    __RTC_CheckEsp
.text:00004E78                 cmp     eax, 50h ; 'P'
.text:00004E7B                 jz      short loc_4E7F
.text:00004E7D                 jmp     short loc_4E91
.text:00004E7F ; ---------------------------------------------------------------------------
.text:00004E7F
.text:00004E7F loc_4E7F:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+B6Fj
.text:00004E7F                 mov     ecx, [ebp+arg_14]
.text:00004E82                 movzx   edx, byte ptr [ecx+3Ch]
.text:00004E86                 test    edx, edx
.text:00004E88                 jnz     short loc_4E8C
.text:00004E8A                 jmp     short loc_4E91
.text:00004E8C ; ---------------------------------------------------------------------------
.text:00004E8C
.text:00004E8C loc_4E8C:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+B7Cj
.text:00004E8C                 jmp     loc_4D4B
.text:00004E91 ; ---------------------------------------------------------------------------
.text:00004E91
.text:00004E91 loc_4E91:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+A58j
.text:00004E91                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+B5Bj ...
.text:00004E91                 movzx   eax, [ebp+var_151]
.text:00004E98                 test    eax, eax
.text:00004E9A                 jnz     loc_4F28
.text:00004EA0                 lea     ecx, [ebp+var_164]
.text:00004EA6                 push    ecx             ; struct UString *
.text:00004EA7                 push    offset $SG74931 ; "cannot open file"
.text:00004EAC                 mov     ecx, [ebp+arg_2C] ; this
.text:00004EAF                 call    ?SetFromLastError@CUpdateErrorInfo@@QAEJPBDABVUString@@@Z ; CUpdateErrorInfo::SetFromLastError(char const *,UString const &)
.text:00004EB4                 mov     [ebp+var_2A8], eax
.text:00004EBA                 mov     byte ptr [ebp+var_4], 0Ah
.text:00004EBE                 lea     ecx, [ebp+var_164] ; this
.text:00004EC4                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00004EC9                 mov     byte ptr [ebp+var_4], 9
.text:00004ECD                 lea     ecx, [ebp+var_12C]
.text:00004ED3                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00004ED8                 mov     byte ptr [ebp+var_4], 8
.text:00004EDC                 lea     ecx, [ebp+var_120]
.text:00004EE2                 call    ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::~CMyComPtr<IOutStream>(void)
.text:00004EE7                 mov     byte ptr [ebp+var_4], 3
.text:00004EEB                 lea     ecx, [ebp+var_114]
.text:00004EF1                 call    ??1?$CMyComPtr@UIArchiveUpdateCallback@@@@QAE@XZ ; CMyComPtr<IArchiveUpdateCallback>::~CMyComPtr<IArchiveUpdateCallback>(void)
.text:00004EF6                 mov     byte ptr [ebp+var_4], 2
.text:00004EFA                 lea     ecx, [ebp+var_70]
.text:00004EFD                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:00004F02                 mov     byte ptr [ebp+var_4], 0
.text:00004F06                 lea     ecx, [ebp+var_5C]
.text:00004F09                 call    ??1?$CRecordVector@UCUpdatePair2@@@@QAE@XZ ; CRecordVector<CUpdatePair2>::~CRecordVector<CUpdatePair2>(void)
.text:00004F0E                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00004F15                 lea     ecx, [ebp+var_18]
.text:00004F18                 call    ??1?$CMyComPtr@UIOutArchive@@@@QAE@XZ ; CMyComPtr<IOutArchive>::~CMyComPtr<IOutArchive>(void)
.text:00004F1D                 mov     eax, [ebp+var_2A8]
.text:00004F23                 jmp     loc_5E99
.text:00004F28 ; ---------------------------------------------------------------------------
.text:00004F28
.text:00004F28 loc_4F28:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+B8Ej
.text:00004F28                 mov     byte ptr [ebp+var_4], 0Ah
.text:00004F2C                 lea     ecx, [ebp+var_164] ; this
.text:00004F32                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00004F37
.text:00004F37 loc_4F37:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+999j
.text:00004F37                 jmp     loc_5155
.text:00004F3C ; ---------------------------------------------------------------------------
.text:00004F3C
.text:00004F3C loc_4F3C:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+91Dj
.text:00004F3C                 mov     edx, [ebp+arg_0]
.text:00004F3F                 movzx   eax, byte ptr [edx+0C4h]
.text:00004F46                 test    eax, eax
.text:00004F48                 jz      short loc_4FB3
.text:00004F4A                 mov     [ebp+var_2AC], 80004005h
.text:00004F54                 mov     byte ptr [ebp+var_4], 9
.text:00004F58                 lea     ecx, [ebp+var_12C]
.text:00004F5E                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00004F63                 mov     byte ptr [ebp+var_4], 8
.text:00004F67                 lea     ecx, [ebp+var_120]
.text:00004F6D                 call    ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::~CMyComPtr<IOutStream>(void)
.text:00004F72                 mov     byte ptr [ebp+var_4], 3
.text:00004F76                 lea     ecx, [ebp+var_114]
.text:00004F7C                 call    ??1?$CMyComPtr@UIArchiveUpdateCallback@@@@QAE@XZ ; CMyComPtr<IArchiveUpdateCallback>::~CMyComPtr<IArchiveUpdateCallback>(void)
.text:00004F81                 mov     byte ptr [ebp+var_4], 2
.text:00004F85                 lea     ecx, [ebp+var_70]
.text:00004F88                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:00004F8D                 mov     byte ptr [ebp+var_4], 0
.text:00004F91                 lea     ecx, [ebp+var_5C]
.text:00004F94                 call    ??1?$CRecordVector@UCUpdatePair2@@@@QAE@XZ ; CRecordVector<CUpdatePair2>::~CRecordVector<CUpdatePair2>(void)
.text:00004F99                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00004FA0                 lea     ecx, [ebp+var_18]
.text:00004FA3                 call    ??1?$CMyComPtr@UIOutArchive@@@@QAE@XZ ; CMyComPtr<IOutArchive>::~CMyComPtr<IOutArchive>(void)
.text:00004FA8                 mov     eax, [ebp+var_2AC]
.text:00004FAE                 jmp     loc_5E99
.text:00004FB3 ; ---------------------------------------------------------------------------
.text:00004FB3
.text:00004FB3 loc_4FB3:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+C3Cj
.text:00004FB3                 cmp     [ebp+arg_10], 0
.text:00004FB7                 jz      loc_504E
.text:00004FBD                 mov     ecx, [ebp+arg_10] ; this
.text:00004FC0                 call    ?GetGlobalOffset@CArc@@QBE_JXZ ; CArc::GetGlobalOffset(void)
.text:00004FC5                 mov     [ebp+var_340], eax
.text:00004FCB                 mov     [ebp+var_33C], edx
.text:00004FD1                 cmp     [ebp+var_33C], 0
.text:00004FD8                 jl      short loc_504E
.text:00004FDA                 jg      short loc_4FE5
.text:00004FDC                 cmp     [ebp+var_340], 0
.text:00004FE3                 jbe     short loc_504E
.text:00004FE5
.text:00004FE5 loc_4FE5:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+CCEj
.text:00004FE5                 mov     [ebp+var_2B0], 80004001h
.text:00004FEF                 mov     byte ptr [ebp+var_4], 9
.text:00004FF3                 lea     ecx, [ebp+var_12C]
.text:00004FF9                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00004FFE                 mov     byte ptr [ebp+var_4], 8
.text:00005002                 lea     ecx, [ebp+var_120]
.text:00005008                 call    ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::~CMyComPtr<IOutStream>(void)
.text:0000500D                 mov     byte ptr [ebp+var_4], 3
.text:00005011                 lea     ecx, [ebp+var_114]
.text:00005017                 call    ??1?$CMyComPtr@UIArchiveUpdateCallback@@@@QAE@XZ ; CMyComPtr<IArchiveUpdateCallback>::~CMyComPtr<IArchiveUpdateCallback>(void)
.text:0000501C                 mov     byte ptr [ebp+var_4], 2
.text:00005020                 lea     ecx, [ebp+var_70]
.text:00005023                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:00005028                 mov     byte ptr [ebp+var_4], 0
.text:0000502C                 lea     ecx, [ebp+var_5C]
.text:0000502F                 call    ??1?$CRecordVector@UCUpdatePair2@@@@QAE@XZ ; CRecordVector<CUpdatePair2>::~CRecordVector<CUpdatePair2>(void)
.text:00005034                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000503B                 lea     ecx, [ebp+var_18]
.text:0000503E                 call    ??1?$CMyComPtr@UIOutArchive@@@@QAE@XZ ; CMyComPtr<IOutArchive>::~CMyComPtr<IOutArchive>(void)
.text:00005043                 mov     eax, [ebp+var_2B0]
.text:00005049                 jmp     loc_5E99
.text:0000504E ; ---------------------------------------------------------------------------
.text:0000504E
.text:0000504E loc_504E:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+CABj
.text:0000504E                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+CCCj ...
.text:0000504E                 push    50h ; 'P'       ; unsigned int
.text:00005050                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00005055                 add     esp, 4
.text:00005058                 mov     [ebp+var_2B8], eax
.text:0000505E                 mov     byte ptr [ebp+var_4], 12h
.text:00005062                 cmp     [ebp+var_2B8], 0
.text:00005069                 jz      short loc_507E
.text:0000506B                 mov     ecx, [ebp+var_2B8]
.text:00005071                 call    ??0COutMultiVolStream@@QAE@XZ ; COutMultiVolStream::COutMultiVolStream(void)
.text:00005076                 mov     [ebp+var_344], eax
.text:0000507C                 jmp     short loc_5088
.text:0000507E ; ---------------------------------------------------------------------------
.text:0000507E
.text:0000507E loc_507E:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+D5Dj
.text:0000507E                 mov     [ebp+var_344], 0
.text:00005088
.text:00005088 loc_5088:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+D70j
.text:00005088                 mov     ecx, [ebp+var_344]
.text:0000508E                 mov     [ebp+var_2B4], ecx
.text:00005094                 mov     byte ptr [ebp+var_4], 0Ah
.text:00005098                 mov     edx, [ebp+var_2B4]
.text:0000509E                 mov     [ebp+var_150], edx
.text:000050A4                 mov     eax, [ebp+var_150]
.text:000050AA                 push    eax
.text:000050AB                 lea     ecx, [ebp+var_120]
.text:000050B1                 call    ??4?$CMyComPtr@UIOutStream@@@@QAEPAUIOutStream@@PAU1@@Z ; CMyComPtr<IOutStream>::operator=(IOutStream *)
.text:000050B6                 lea     ecx, [ebp+var_120]
.text:000050BC                 call    ??B?$CMyComPtr@UIOutStream@@@@QBEPAUIOutStream@@XZ ; CMyComPtr<IOutStream>::operator IOutStream *(void)
.text:000050C1                 push    eax
.text:000050C2                 lea     ecx, [ebp+var_12C]
.text:000050C8                 call    ??4?$CMyComPtr@UISequentialOutStream@@@@QAEPAUISequentialOutStream@@PAU1@@Z ; CMyComPtr<ISequentialOutStream>::operator=(ISequentialOutStream *)
.text:000050CD                 mov     ecx, [ebp+arg_0]
.text:000050D0                 add     ecx, 108h
.text:000050D6                 push    ecx
.text:000050D7                 mov     ecx, [ebp+var_150]
.text:000050DD                 add     ecx, 34h ; '4'
.text:000050E0                 call    ??4?$CRecordVector@_K@@QAEAAV0@ABV0@@Z ; CRecordVector<unsigned __int64>::operator=(CRecordVector<unsigned __int64> const &)
.text:000050E5                 lea     edx, [ebp+var_2C4]
.text:000050EB                 push    edx
.text:000050EC                 mov     ecx, [ebp+arg_14]
.text:000050EF                 call    ?GetFinalVolPath@CArchivePath@@QBE?AVUString@@XZ ; CArchivePath::GetFinalVolPath(void)
.text:000050F4                 mov     [ebp+var_348], eax
.text:000050FA                 mov     eax, [ebp+var_348]
.text:00005100                 mov     [ebp+var_34C], eax
.text:00005106                 mov     byte ptr [ebp+var_4], 13h
.text:0000510A                 mov     ecx, [ebp+var_34C]
.text:00005110                 push    ecx             ; struct ICompressProgressInfo *
.text:00005111                 mov     ecx, [ebp+var_150]
.text:00005117                 add     ecx, 40h ; '@'
.text:0000511A                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:0000511F                 mov     byte ptr [ebp+var_4], 0Ah
.text:00005123                 lea     ecx, [ebp+var_2C4] ; this
.text:00005129                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000512E                 push    2Eh ; '.'
.text:00005130                 mov     ecx, [ebp+var_150]
.text:00005136                 add     ecx, 40h ; '@'
.text:00005139                 call    ??YUString@@QAEAAV0@_W@Z ; UString::operator+=(wchar_t)
.text:0000513E                 mov     edx, [ebp+var_150]
.text:00005144                 mov     eax, [ebp+arg_28]
.text:00005147                 mov     [edx+4Ch], eax
.text:0000514A                 mov     ecx, [ebp+var_150] ; this
.text:00005150                 call    ?Init@COutMultiVolStream@@QAEXXZ ; COutMultiVolStream::Init(void)
.text:00005155
.text:00005155 loc_5155:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &):loc_4F37j
.text:00005155                 mov     ecx, [ebp+arg_0]
.text:00005158                 add     ecx, 28h ; '('
.text:0000515B                 push    ecx
.text:0000515C                 lea     ecx, [ebp+var_18]
.text:0000515F                 call    ??B?$CMyComPtr@UIOutArchive@@@@QBEPAUIOutArchive@@XZ ; CMyComPtr<IOutArchive>::operator IOutArchive *(void)
.text:00005164                 push    eax
.text:00005165                 call    ?SetProperties@@YGJPAUIUnknown@@ABV?$CObjectVector@UCProperty@@@@@Z ; SetProperties(IUnknown *,CObjectVector<CProperty> const &)
.text:0000516A                 mov     [ebp+var_198], eax
.text:00005170                 cmp     [ebp+var_198], 0
.text:00005177                 jz      short loc_51E4
.text:00005179                 mov     edx, [ebp+var_198]
.text:0000517F                 mov     [ebp+var_2C8], edx
.text:00005185                 mov     byte ptr [ebp+var_4], 9
.text:00005189                 lea     ecx, [ebp+var_12C]
.text:0000518F                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00005194                 mov     byte ptr [ebp+var_4], 8
.text:00005198                 lea     ecx, [ebp+var_120]
.text:0000519E                 call    ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::~CMyComPtr<IOutStream>(void)
.text:000051A3                 mov     byte ptr [ebp+var_4], 3
.text:000051A7                 lea     ecx, [ebp+var_114]
.text:000051AD                 call    ??1?$CMyComPtr@UIArchiveUpdateCallback@@@@QAE@XZ ; CMyComPtr<IArchiveUpdateCallback>::~CMyComPtr<IArchiveUpdateCallback>(void)
.text:000051B2                 mov     byte ptr [ebp+var_4], 2
.text:000051B6                 lea     ecx, [ebp+var_70]
.text:000051B9                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:000051BE                 mov     byte ptr [ebp+var_4], 0
.text:000051C2                 lea     ecx, [ebp+var_5C]
.text:000051C5                 call    ??1?$CRecordVector@UCUpdatePair2@@@@QAE@XZ ; CRecordVector<CUpdatePair2>::~CRecordVector<CUpdatePair2>(void)
.text:000051CA                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000051D1                 lea     ecx, [ebp+var_18]
.text:000051D4                 call    ??1?$CMyComPtr@UIOutArchive@@@@QAE@XZ ; CMyComPtr<IOutArchive>::~CMyComPtr<IOutArchive>(void)
.text:000051D9                 mov     eax, [ebp+var_2C8]
.text:000051DF                 jmp     loc_5E99
.text:000051E4 ; ---------------------------------------------------------------------------
.text:000051E4
.text:000051E4 loc_51E4:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+E6Bj
.text:000051E4                 mov     eax, [ebp+arg_0]
.text:000051E7                 movzx   ecx, byte ptr [eax+0A4h]
.text:000051EE                 test    ecx, ecx
.text:000051F0                 jz      loc_57C6
.text:000051F6                 push    58h ; 'X'       ; unsigned int
.text:000051F8                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:000051FD                 add     esp, 4
.text:00005200                 mov     [ebp+var_2D0], eax
.text:00005206                 mov     byte ptr [ebp+var_4], 14h
.text:0000520A                 cmp     [ebp+var_2D0], 0
.text:00005211                 jz      short loc_5226
.text:00005213                 mov     ecx, [ebp+var_2D0] ; this
.text:00005219                 call    ??0CInFileStream@@QAE@XZ ; CInFileStream::CInFileStream(void)
.text:0000521E                 mov     [ebp+var_350], eax
.text:00005224                 jmp     short loc_5230
.text:00005226 ; ---------------------------------------------------------------------------
.text:00005226
.text:00005226 loc_5226:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+F05j
.text:00005226                 mov     [ebp+var_350], 0
.text:00005230
.text:00005230 loc_5230:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+F18j
.text:00005230                 mov     edx, [ebp+var_350]
.text:00005236                 mov     [ebp+var_2CC], edx
.text:0000523C                 mov     byte ptr [ebp+var_4], 0Ah
.text:00005240                 mov     eax, [ebp+var_2CC]
.text:00005246                 mov     [ebp+var_19C], eax
.text:0000524C                 mov     ecx, [ebp+var_19C]
.text:00005252                 push    ecx
.text:00005253                 lea     ecx, [ebp+var_1A4]
.text:00005259                 call    ??0?$CMyComPtr@UIInStream@@@@QAE@PAUIInStream@@@Z ; CMyComPtr<IInStream>::CMyComPtr<IInStream>(IInStream *)
.text:0000525E                 mov     byte ptr [ebp+var_4], 15h
.text:00005262                 mov     ecx, [ebp+arg_0]
.text:00005265                 add     ecx, 0A8h ; ''
.text:0000526B                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00005270                 push    eax             ; wchar_t *
.text:00005271                 mov     ecx, [ebp+var_19C] ; this
.text:00005277                 call    ?Open@CInFileStream@@QAE_NPB_W@Z ; CInFileStream::Open(wchar_t const *)
.text:0000527C                 movzx   edx, al
.text:0000527F                 test    edx, edx
.text:00005281                 jnz     loc_5311
.text:00005287                 mov     eax, [ebp+arg_0]
.text:0000528A                 add     eax, 0A8h ; ''
.text:0000528F                 push    eax             ; struct UString *
.text:00005290                 push    offset $SG74957 ; "cannot open SFX module"
.text:00005295                 mov     ecx, [ebp+arg_2C] ; this
.text:00005298                 call    ?SetFromLastError@CUpdateErrorInfo@@QAEJPBDABVUString@@@Z ; CUpdateErrorInfo::SetFromLastError(char const *,UString const &)
.text:0000529D                 mov     [ebp+var_2D4], eax
.text:000052A3                 mov     byte ptr [ebp+var_4], 0Ah
.text:000052A7                 lea     ecx, [ebp+var_1A4]
.text:000052AD                 call    ??1?$CMyComPtr@UIInStream@@@@QAE@XZ ; CMyComPtr<IInStream>::~CMyComPtr<IInStream>(void)
.text:000052B2                 mov     byte ptr [ebp+var_4], 9
.text:000052B6                 lea     ecx, [ebp+var_12C]
.text:000052BC                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:000052C1                 mov     byte ptr [ebp+var_4], 8
.text:000052C5                 lea     ecx, [ebp+var_120]
.text:000052CB                 call    ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::~CMyComPtr<IOutStream>(void)
.text:000052D0                 mov     byte ptr [ebp+var_4], 3
.text:000052D4                 lea     ecx, [ebp+var_114]
.text:000052DA                 call    ??1?$CMyComPtr@UIArchiveUpdateCallback@@@@QAE@XZ ; CMyComPtr<IArchiveUpdateCallback>::~CMyComPtr<IArchiveUpdateCallback>(void)
.text:000052DF                 mov     byte ptr [ebp+var_4], 2
.text:000052E3                 lea     ecx, [ebp+var_70]
.text:000052E6                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:000052EB                 mov     byte ptr [ebp+var_4], 0
.text:000052EF                 lea     ecx, [ebp+var_5C]
.text:000052F2                 call    ??1?$CRecordVector@UCUpdatePair2@@@@QAE@XZ ; CRecordVector<CUpdatePair2>::~CRecordVector<CUpdatePair2>(void)
.text:000052F7                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000052FE                 lea     ecx, [ebp+var_18]
.text:00005301                 call    ??1?$CMyComPtr@UIOutArchive@@@@QAE@XZ ; CMyComPtr<IOutArchive>::~CMyComPtr<IOutArchive>(void)
.text:00005306                 mov     eax, [ebp+var_2D4]
.text:0000530C                 jmp     loc_5E99
.text:00005311 ; ---------------------------------------------------------------------------
.text:00005311
.text:00005311 loc_5311:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+F75j
.text:00005311                 lea     ecx, [ebp+var_1B0]
.text:00005317                 call    ??0?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::CMyComPtr<ISequentialOutStream>(void)
.text:0000531C                 mov     byte ptr [ebp+var_4], 16h
.text:00005320                 mov     [ebp+var_1B8], 0
.text:0000532A                 mov     ecx, [ebp+arg_0]
.text:0000532D                 add     ecx, 108h
.text:00005333                 call    ?Size@?$CRecordVector@_K@@QBEIXZ ; CRecordVector<unsigned __int64>::Size(void)
.text:00005338                 test    eax, eax
.text:0000533A                 jnz     short loc_5353
.text:0000533C                 lea     ecx, [ebp+var_12C]
.text:00005342                 push    ecx
.text:00005343                 lea     ecx, [ebp+var_1B0]
.text:00005349                 call    ??4?$CMyComPtr@UISequentialOutStream@@@@QAEPAUISequentialOutStream@@ABV0@@Z ; CMyComPtr<ISequentialOutStream>::operator=(CMyComPtr<ISequentialOutStream> const &)
.text:0000534E                 jmp     loc_54A7
.text:00005353 ; ---------------------------------------------------------------------------
.text:00005353
.text:00005353 loc_5353:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+102Ej
.text:00005353                 push    20h ; ' '       ; unsigned int
.text:00005355                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0000535A                 add     esp, 4
.text:0000535D                 mov     [ebp+var_2DC], eax
.text:00005363                 mov     byte ptr [ebp+var_4], 17h
.text:00005367                 cmp     [ebp+var_2DC], 0
.text:0000536E                 jz      short loc_5383
.text:00005370                 mov     ecx, [ebp+var_2DC]
.text:00005376                 call    ??0COutFileStream@@QAE@XZ ; COutFileStream::COutFileStream(void)
.text:0000537B                 mov     [ebp+var_354], eax
.text:00005381                 jmp     short loc_538D
.text:00005383 ; ---------------------------------------------------------------------------
.text:00005383
.text:00005383 loc_5383:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+1062j
.text:00005383                 mov     [ebp+var_354], 0
.text:0000538D
.text:0000538D loc_538D:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+1075j
.text:0000538D                 mov     edx, [ebp+var_354]
.text:00005393                 mov     [ebp+var_2D8], edx
.text:00005399                 mov     byte ptr [ebp+var_4], 16h
.text:0000539D                 mov     eax, [ebp+var_2D8]
.text:000053A3                 mov     [ebp+var_1B8], eax
.text:000053A9                 mov     ecx, [ebp+var_1B8]
.text:000053AF                 push    ecx
.text:000053B0                 lea     ecx, [ebp+var_1B0]
.text:000053B6                 call    ??4?$CMyComPtr@UISequentialOutStream@@@@QAEPAUISequentialOutStream@@PAU1@@Z ; CMyComPtr<ISequentialOutStream>::operator=(ISequentialOutStream *)
.text:000053BB                 lea     edx, [ebp+var_1C8]
.text:000053C1                 push    edx
.text:000053C2                 mov     ecx, [ebp+arg_14]
.text:000053C5                 call    ?GetFinalPath@CArchivePath@@QBE?AVUString@@XZ ; CArchivePath::GetFinalPath(void)
.text:000053CA                 mov     byte ptr [ebp+var_4], 18h
.text:000053CE                 push    0               ; bool
.text:000053D0                 lea     ecx, [ebp+var_1C8]
.text:000053D6                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000053DB                 push    eax             ; wchar_t *
.text:000053DC                 mov     ecx, [ebp+var_1B8] ; this
.text:000053E2                 call    ?Create@COutFileStream@@QAE_NPB_W_N@Z ; COutFileStream::Create(wchar_t const *,bool)
.text:000053E7                 movzx   eax, al
.text:000053EA                 test    eax, eax
.text:000053EC                 jnz     loc_5498
.text:000053F2                 lea     ecx, [ebp+var_1C8]
.text:000053F8                 push    ecx             ; struct UString *
.text:000053F9                 push    offset $SG74971 ; "cannot open file"
.text:000053FE                 mov     ecx, [ebp+arg_2C] ; this
.text:00005401                 call    ?SetFromLastError@CUpdateErrorInfo@@QAEJPBDABVUString@@@Z ; CUpdateErrorInfo::SetFromLastError(char const *,UString const &)
.text:00005406                 mov     [ebp+var_2E0], eax
.text:0000540C                 mov     byte ptr [ebp+var_4], 16h
.text:00005410                 lea     ecx, [ebp+var_1C8] ; this
.text:00005416                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000541B                 mov     byte ptr [ebp+var_4], 15h
.text:0000541F                 lea     ecx, [ebp+var_1B0]
.text:00005425                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:0000542A                 mov     byte ptr [ebp+var_4], 0Ah
.text:0000542E                 lea     ecx, [ebp+var_1A4]
.text:00005434                 call    ??1?$CMyComPtr@UIInStream@@@@QAE@XZ ; CMyComPtr<IInStream>::~CMyComPtr<IInStream>(void)
.text:00005439                 mov     byte ptr [ebp+var_4], 9
.text:0000543D                 lea     ecx, [ebp+var_12C]
.text:00005443                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00005448                 mov     byte ptr [ebp+var_4], 8
.text:0000544C                 lea     ecx, [ebp+var_120]
.text:00005452                 call    ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::~CMyComPtr<IOutStream>(void)
.text:00005457                 mov     byte ptr [ebp+var_4], 3
.text:0000545B                 lea     ecx, [ebp+var_114]
.text:00005461                 call    ??1?$CMyComPtr@UIArchiveUpdateCallback@@@@QAE@XZ ; CMyComPtr<IArchiveUpdateCallback>::~CMyComPtr<IArchiveUpdateCallback>(void)
.text:00005466                 mov     byte ptr [ebp+var_4], 2
.text:0000546A                 lea     ecx, [ebp+var_70]
.text:0000546D                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:00005472                 mov     byte ptr [ebp+var_4], 0
.text:00005476                 lea     ecx, [ebp+var_5C]
.text:00005479                 call    ??1?$CRecordVector@UCUpdatePair2@@@@QAE@XZ ; CRecordVector<CUpdatePair2>::~CRecordVector<CUpdatePair2>(void)
.text:0000547E                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00005485                 lea     ecx, [ebp+var_18]
.text:00005488                 call    ??1?$CMyComPtr@UIOutArchive@@@@QAE@XZ ; CMyComPtr<IOutArchive>::~CMyComPtr<IOutArchive>(void)
.text:0000548D                 mov     eax, [ebp+var_2E0]
.text:00005493                 jmp     loc_5E99
.text:00005498 ; ---------------------------------------------------------------------------
.text:00005498
.text:00005498 loc_5498:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+10E0j
.text:00005498                 mov     byte ptr [ebp+var_4], 16h
.text:0000549C                 lea     ecx, [ebp+var_1C8] ; this
.text:000054A2                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000054A7
.text:000054A7 loc_54A7:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+1042j
.text:000054A7                 mov     esi, esp
.text:000054A9                 lea     edx, [ebp+var_1D8]
.text:000054AF                 push    edx
.text:000054B0                 mov     eax, [ebp+var_19C]
.text:000054B6                 add     eax, 4
.text:000054B9                 mov     ecx, [ebp+var_19C]
.text:000054BF                 mov     edx, [ecx+4]
.text:000054C2                 push    eax
.text:000054C3                 mov     eax, [edx+0Ch]
.text:000054C6                 call    eax
.text:000054C8                 cmp     esi, esp
.text:000054CA                 call    __RTC_CheckEsp
.text:000054CF                 mov     [ebp+var_1E0], eax
.text:000054D5                 cmp     [ebp+var_1E0], 0
.text:000054DC                 jz      loc_556B
.text:000054E2                 mov     ecx, [ebp+var_1E0]
.text:000054E8                 mov     [ebp+var_2E4], ecx
.text:000054EE                 mov     byte ptr [ebp+var_4], 15h
.text:000054F2                 lea     ecx, [ebp+var_1B0]
.text:000054F8                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:000054FD                 mov     byte ptr [ebp+var_4], 0Ah
.text:00005501                 lea     ecx, [ebp+var_1A4]
.text:00005507                 call    ??1?$CMyComPtr@UIInStream@@@@QAE@XZ ; CMyComPtr<IInStream>::~CMyComPtr<IInStream>(void)
.text:0000550C                 mov     byte ptr [ebp+var_4], 9
.text:00005510                 lea     ecx, [ebp+var_12C]
.text:00005516                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:0000551B                 mov     byte ptr [ebp+var_4], 8
.text:0000551F                 lea     ecx, [ebp+var_120]
.text:00005525                 call    ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::~CMyComPtr<IOutStream>(void)
.text:0000552A                 mov     byte ptr [ebp+var_4], 3
.text:0000552E                 lea     ecx, [ebp+var_114]
.text:00005534                 call    ??1?$CMyComPtr@UIArchiveUpdateCallback@@@@QAE@XZ ; CMyComPtr<IArchiveUpdateCallback>::~CMyComPtr<IArchiveUpdateCallback>(void)
.text:00005539                 mov     byte ptr [ebp+var_4], 2
.text:0000553D                 lea     ecx, [ebp+var_70]
.text:00005540                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:00005545                 mov     byte ptr [ebp+var_4], 0
.text:00005549                 lea     ecx, [ebp+var_5C]
.text:0000554C                 call    ??1?$CRecordVector@UCUpdatePair2@@@@QAE@XZ ; CRecordVector<CUpdatePair2>::~CRecordVector<CUpdatePair2>(void)
.text:00005551                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00005558                 lea     ecx, [ebp+var_18]
.text:0000555B                 call    ??1?$CMyComPtr@UIOutArchive@@@@QAE@XZ ; CMyComPtr<IOutArchive>::~CMyComPtr<IOutArchive>(void)
.text:00005560                 mov     eax, [ebp+var_2E4]
.text:00005566                 jmp     loc_5E99
.text:0000556B ; ---------------------------------------------------------------------------
.text:0000556B
.text:0000556B loc_556B:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+11D0j
.text:0000556B                 mov     esi, esp
.text:0000556D                 mov     edx, [ebp+var_1D4]
.text:00005573                 push    edx
.text:00005574                 mov     eax, [ebp+var_1D8]
.text:0000557A                 push    eax
.text:0000557B                 mov     ecx, [ebp+arg_0]
.text:0000557E                 add     ecx, 0A8h ; ''
.text:00005584                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00005589                 push    eax
.text:0000558A                 mov     ecx, [ebp+arg_30]
.text:0000558D                 mov     edx, [ecx]
.text:0000558F                 mov     ecx, [ebp+arg_30]
.text:00005592                 mov     eax, [edx]
.text:00005594                 call    eax
.text:00005596                 cmp     esi, esp
.text:00005598                 call    __RTC_CheckEsp
.text:0000559D                 mov     [ebp+var_1E4], eax
.text:000055A3                 cmp     [ebp+var_1E4], 0
.text:000055AA                 jz      loc_5639
.text:000055B0                 mov     ecx, [ebp+var_1E4]
.text:000055B6                 mov     [ebp+var_2E8], ecx
.text:000055BC                 mov     byte ptr [ebp+var_4], 15h
.text:000055C0                 lea     ecx, [ebp+var_1B0]
.text:000055C6                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:000055CB                 mov     byte ptr [ebp+var_4], 0Ah
.text:000055CF                 lea     ecx, [ebp+var_1A4]
.text:000055D5                 call    ??1?$CMyComPtr@UIInStream@@@@QAE@XZ ; CMyComPtr<IInStream>::~CMyComPtr<IInStream>(void)
.text:000055DA                 mov     byte ptr [ebp+var_4], 9
.text:000055DE                 lea     ecx, [ebp+var_12C]
.text:000055E4                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:000055E9                 mov     byte ptr [ebp+var_4], 8
.text:000055ED                 lea     ecx, [ebp+var_120]
.text:000055F3                 call    ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::~CMyComPtr<IOutStream>(void)
.text:000055F8                 mov     byte ptr [ebp+var_4], 3
.text:000055FC                 lea     ecx, [ebp+var_114]
.text:00005602                 call    ??1?$CMyComPtr@UIArchiveUpdateCallback@@@@QAE@XZ ; CMyComPtr<IArchiveUpdateCallback>::~CMyComPtr<IArchiveUpdateCallback>(void)
.text:00005607                 mov     byte ptr [ebp+var_4], 2
.text:0000560B                 lea     ecx, [ebp+var_70]
.text:0000560E                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:00005613                 mov     byte ptr [ebp+var_4], 0
.text:00005617                 lea     ecx, [ebp+var_5C]
.text:0000561A                 call    ??1?$CRecordVector@UCUpdatePair2@@@@QAE@XZ ; CRecordVector<CUpdatePair2>::~CRecordVector<CUpdatePair2>(void)
.text:0000561F                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00005626                 lea     ecx, [ebp+var_18]
.text:00005629                 call    ??1?$CMyComPtr@UIOutArchive@@@@QAE@XZ ; CMyComPtr<IOutArchive>::~CMyComPtr<IOutArchive>(void)
.text:0000562E                 mov     eax, [ebp+var_2E8]
.text:00005634                 jmp     loc_5E99
.text:00005639 ; ---------------------------------------------------------------------------
.text:00005639
.text:00005639 loc_5639:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+129Ej
.text:00005639                 push    0               ; struct ISequentialOutStream *
.text:0000563B                 lea     ecx, [ebp+var_1B0]
.text:00005641                 call    ??B?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ ; CMyComPtr<ISequentialOutStream>::operator ISequentialOutStream *(void)
.text:00005646                 push    eax             ; struct ISequentialInStream *
.text:00005647                 lea     ecx, [ebp+var_1A4]
.text:0000564D                 call    ??B?$CMyComPtr@UIInStream@@@@QBEPAUIInStream@@XZ ; CMyComPtr<IInStream>::operator IInStream *(void)
.text:00005652                 push    eax             ; struct ICompressProgressInfo *
.text:00005653                 call    ?CopyStream@NCompress@@YGJPAUISequentialInStream@@PAUISequentialOutStream@@PAUICompressProgressInfo@@@Z ; NCompress::CopyStream(ISequentialInStream *,ISequentialOutStream *,ICompressProgressInfo *)
.text:00005658                 mov     [ebp+var_1E8], eax
.text:0000565E                 cmp     [ebp+var_1E8], 0
.text:00005665                 jz      loc_56F4
.text:0000566B                 mov     edx, [ebp+var_1E8]
.text:00005671                 mov     [ebp+var_2EC], edx
.text:00005677                 mov     byte ptr [ebp+var_4], 15h
.text:0000567B                 lea     ecx, [ebp+var_1B0]
.text:00005681                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00005686                 mov     byte ptr [ebp+var_4], 0Ah
.text:0000568A                 lea     ecx, [ebp+var_1A4]
.text:00005690                 call    ??1?$CMyComPtr@UIInStream@@@@QAE@XZ ; CMyComPtr<IInStream>::~CMyComPtr<IInStream>(void)
.text:00005695                 mov     byte ptr [ebp+var_4], 9
.text:00005699                 lea     ecx, [ebp+var_12C]
.text:0000569F                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:000056A4                 mov     byte ptr [ebp+var_4], 8
.text:000056A8                 lea     ecx, [ebp+var_120]
.text:000056AE                 call    ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::~CMyComPtr<IOutStream>(void)
.text:000056B3                 mov     byte ptr [ebp+var_4], 3
.text:000056B7                 lea     ecx, [ebp+var_114]
.text:000056BD                 call    ??1?$CMyComPtr@UIArchiveUpdateCallback@@@@QAE@XZ ; CMyComPtr<IArchiveUpdateCallback>::~CMyComPtr<IArchiveUpdateCallback>(void)
.text:000056C2                 mov     byte ptr [ebp+var_4], 2
.text:000056C6                 lea     ecx, [ebp+var_70]
.text:000056C9                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:000056CE                 mov     byte ptr [ebp+var_4], 0
.text:000056D2                 lea     ecx, [ebp+var_5C]
.text:000056D5                 call    ??1?$CRecordVector@UCUpdatePair2@@@@QAE@XZ ; CRecordVector<CUpdatePair2>::~CRecordVector<CUpdatePair2>(void)
.text:000056DA                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000056E1                 lea     ecx, [ebp+var_18]
.text:000056E4                 call    ??1?$CMyComPtr@UIOutArchive@@@@QAE@XZ ; CMyComPtr<IOutArchive>::~CMyComPtr<IOutArchive>(void)
.text:000056E9                 mov     eax, [ebp+var_2EC]
.text:000056EF                 jmp     loc_5E99
.text:000056F4 ; ---------------------------------------------------------------------------
.text:000056F4
.text:000056F4 loc_56F4:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+1359j
.text:000056F4                 cmp     [ebp+var_1B8], 0
.text:000056FB                 jz      loc_57A8
.text:00005701                 mov     ecx, [ebp+var_1B8] ; this
.text:00005707                 call    ?Close@COutFileStream@@QAEJXZ ; COutFileStream::Close(void)
.text:0000570C                 mov     [ebp+var_1EC], eax
.text:00005712                 cmp     [ebp+var_1EC], 0
.text:00005719                 jz      loc_57A8
.text:0000571F                 mov     eax, [ebp+var_1EC]
.text:00005725                 mov     [ebp+var_2F0], eax
.text:0000572B                 mov     byte ptr [ebp+var_4], 15h
.text:0000572F                 lea     ecx, [ebp+var_1B0]
.text:00005735                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:0000573A                 mov     byte ptr [ebp+var_4], 0Ah
.text:0000573E                 lea     ecx, [ebp+var_1A4]
.text:00005744                 call    ??1?$CMyComPtr@UIInStream@@@@QAE@XZ ; CMyComPtr<IInStream>::~CMyComPtr<IInStream>(void)
.text:00005749                 mov     byte ptr [ebp+var_4], 9
.text:0000574D                 lea     ecx, [ebp+var_12C]
.text:00005753                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00005758                 mov     byte ptr [ebp+var_4], 8
.text:0000575C                 lea     ecx, [ebp+var_120]
.text:00005762                 call    ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::~CMyComPtr<IOutStream>(void)
.text:00005767                 mov     byte ptr [ebp+var_4], 3
.text:0000576B                 lea     ecx, [ebp+var_114]
.text:00005771                 call    ??1?$CMyComPtr@UIArchiveUpdateCallback@@@@QAE@XZ ; CMyComPtr<IArchiveUpdateCallback>::~CMyComPtr<IArchiveUpdateCallback>(void)
.text:00005776                 mov     byte ptr [ebp+var_4], 2
.text:0000577A                 lea     ecx, [ebp+var_70]
.text:0000577D                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:00005782                 mov     byte ptr [ebp+var_4], 0
.text:00005786                 lea     ecx, [ebp+var_5C]
.text:00005789                 call    ??1?$CRecordVector@UCUpdatePair2@@@@QAE@XZ ; CRecordVector<CUpdatePair2>::~CRecordVector<CUpdatePair2>(void)
.text:0000578E                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00005795                 lea     ecx, [ebp+var_18]
.text:00005798                 call    ??1?$CMyComPtr@UIOutArchive@@@@QAE@XZ ; CMyComPtr<IOutArchive>::~CMyComPtr<IOutArchive>(void)
.text:0000579D                 mov     eax, [ebp+var_2F0]
.text:000057A3                 jmp     loc_5E99
.text:000057A8 ; ---------------------------------------------------------------------------
.text:000057A8
.text:000057A8 loc_57A8:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+13EFj
.text:000057A8                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+140Dj
.text:000057A8                 mov     byte ptr [ebp+var_4], 15h
.text:000057AC                 lea     ecx, [ebp+var_1B0]
.text:000057B2                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:000057B7                 mov     byte ptr [ebp+var_4], 0Ah
.text:000057BB                 lea     ecx, [ebp+var_1A4]
.text:000057C1                 call    ??1?$CMyComPtr@UIInStream@@@@QAE@XZ ; CMyComPtr<IInStream>::~CMyComPtr<IInStream>(void)
.text:000057C6
.text:000057C6 loc_57C6:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+EE4j
.text:000057C6                 lea     ecx, [ebp+var_1F4]
.text:000057CC                 call    ??0?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::CMyComPtr<ISequentialOutStream>(void)
.text:000057D1                 mov     byte ptr [ebp+var_4], 19h
.text:000057D5                 mov     ecx, [ebp+arg_0]
.text:000057D8                 movzx   edx, byte ptr [ecx+0A4h]
.text:000057DF                 test    edx, edx
.text:000057E1                 jnz     short loc_580C
.text:000057E3                 cmp     [ebp+arg_10], 0
.text:000057E7                 jz      short loc_580C
.text:000057E9                 mov     eax, [ebp+arg_10]
.text:000057EC                 mov     [ebp+var_358], eax
.text:000057F2                 mov     ecx, [ebp+var_358]
.text:000057F8                 mov     edx, [ebp+var_358]
.text:000057FE                 mov     eax, [ecx+0D0h]
.text:00005804                 or      eax, [edx+0D4h]
.text:0000580A                 jnz     short loc_5823
.text:0000580C
.text:0000580C loc_580C:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+14D5j
.text:0000580C                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+14DBj
.text:0000580C                 lea     ecx, [ebp+var_12C]
.text:00005812                 push    ecx
.text:00005813                 lea     ecx, [ebp+var_1F4]
.text:00005819                 call    ??4?$CMyComPtr@UISequentialOutStream@@@@QAEPAUISequentialOutStream@@ABV0@@Z ; CMyComPtr<ISequentialOutStream>::operator=(CMyComPtr<ISequentialOutStream> const &)
.text:0000581E                 jmp     loc_5A63
.text:00005823 ; ---------------------------------------------------------------------------
.text:00005823
.text:00005823 loc_5823:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+14FEj
.text:00005823                 mov     ecx, [ebp+arg_10]
.text:00005826                 add     ecx, 4
.text:00005829                 call    ??C?$CMyComPtr@UIInStream@@@@QBEPAUIInStream@@XZ ; CMyComPtr<IInStream>::operator->(void)
.text:0000582E                 mov     [ebp+var_35C], eax
.text:00005834                 mov     esi, esp
.text:00005836                 push    0
.text:00005838                 push    0
.text:0000583A                 push    0
.text:0000583C                 push    0
.text:0000583E                 mov     edx, [ebp+var_35C]
.text:00005844                 push    edx
.text:00005845                 mov     eax, [ebp+var_35C]
.text:0000584B                 mov     ecx, [eax]
.text:0000584D                 mov     edx, [ecx+10h]
.text:00005850                 call    edx
.text:00005852                 cmp     esi, esp
.text:00005854                 call    __RTC_CheckEsp
.text:00005859                 mov     [ebp+var_1FC], eax
.text:0000585F                 cmp     [ebp+var_1FC], 0
.text:00005866                 jz      short loc_58E2
.text:00005868                 mov     eax, [ebp+var_1FC]
.text:0000586E                 mov     [ebp+var_2F4], eax
.text:00005874                 mov     byte ptr [ebp+var_4], 0Ah
.text:00005878                 lea     ecx, [ebp+var_1F4]
.text:0000587E                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00005883                 mov     byte ptr [ebp+var_4], 9
.text:00005887                 lea     ecx, [ebp+var_12C]
.text:0000588D                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00005892                 mov     byte ptr [ebp+var_4], 8
.text:00005896                 lea     ecx, [ebp+var_120]
.text:0000589C                 call    ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::~CMyComPtr<IOutStream>(void)
.text:000058A1                 mov     byte ptr [ebp+var_4], 3
.text:000058A5                 lea     ecx, [ebp+var_114]
.text:000058AB                 call    ??1?$CMyComPtr@UIArchiveUpdateCallback@@@@QAE@XZ ; CMyComPtr<IArchiveUpdateCallback>::~CMyComPtr<IArchiveUpdateCallback>(void)
.text:000058B0                 mov     byte ptr [ebp+var_4], 2
.text:000058B4                 lea     ecx, [ebp+var_70]
.text:000058B7                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:000058BC                 mov     byte ptr [ebp+var_4], 0
.text:000058C0                 lea     ecx, [ebp+var_5C]
.text:000058C3                 call    ??1?$CRecordVector@UCUpdatePair2@@@@QAE@XZ ; CRecordVector<CUpdatePair2>::~CRecordVector<CUpdatePair2>(void)
.text:000058C8                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000058CF                 lea     ecx, [ebp+var_18]
.text:000058D2                 call    ??1?$CMyComPtr@UIOutArchive@@@@QAE@XZ ; CMyComPtr<IOutArchive>::~CMyComPtr<IOutArchive>(void)
.text:000058D7                 mov     eax, [ebp+var_2F4]
.text:000058DD                 jmp     loc_5E99
.text:000058E2 ; ---------------------------------------------------------------------------
.text:000058E2
.text:000058E2 loc_58E2:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+155Aj
.text:000058E2                 push    0
.text:000058E4                 mov     ecx, [ebp+arg_10]
.text:000058E7                 mov     edx, [ecx+0D4h]
.text:000058ED                 push    edx             ; unsigned __int64
.text:000058EE                 mov     eax, [ecx+0D0h]
.text:000058F4                 push    eax             ; struct ISequentialOutStream *
.text:000058F5                 lea     ecx, [ebp+var_12C]
.text:000058FB                 call    ??B?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ ; CMyComPtr<ISequentialOutStream>::operator ISequentialOutStream *(void)
.text:00005900                 push    eax             ; struct ISequentialInStream *
.text:00005901                 mov     ecx, [ebp+arg_10]
.text:00005904                 add     ecx, 4
.text:00005907                 call    ??B?$CMyComPtr@UIInStream@@@@QBEPAUIInStream@@XZ ; CMyComPtr<IInStream>::operator IInStream *(void)
.text:0000590C                 push    eax             ; this
.text:0000590D                 call    ?CopyStream_ExactSize@NCompress@@YGJPAUISequentialInStream@@PAUISequentialOutStream@@_KPAUICompressProgressInfo@@@Z ; NCompress::CopyStream_ExactSize(ISequentialInStream *,ISequentialOutStream *,unsigned __int64,ICompressProgressInfo *)
.text:00005912                 mov     [ebp+var_200], eax
.text:00005918                 cmp     [ebp+var_200], 0
.text:0000591F                 jz      short loc_599B
.text:00005921                 mov     ecx, [ebp+var_200]
.text:00005927                 mov     [ebp+var_2F8], ecx
.text:0000592D                 mov     byte ptr [ebp+var_4], 0Ah
.text:00005931                 lea     ecx, [ebp+var_1F4]
.text:00005937                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:0000593C                 mov     byte ptr [ebp+var_4], 9
.text:00005940                 lea     ecx, [ebp+var_12C]
.text:00005946                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:0000594B                 mov     byte ptr [ebp+var_4], 8
.text:0000594F                 lea     ecx, [ebp+var_120]
.text:00005955                 call    ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::~CMyComPtr<IOutStream>(void)
.text:0000595A                 mov     byte ptr [ebp+var_4], 3
.text:0000595E                 lea     ecx, [ebp+var_114]
.text:00005964                 call    ??1?$CMyComPtr@UIArchiveUpdateCallback@@@@QAE@XZ ; CMyComPtr<IArchiveUpdateCallback>::~CMyComPtr<IArchiveUpdateCallback>(void)
.text:00005969                 mov     byte ptr [ebp+var_4], 2
.text:0000596D                 lea     ecx, [ebp+var_70]
.text:00005970                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:00005975                 mov     byte ptr [ebp+var_4], 0
.text:00005979                 lea     ecx, [ebp+var_5C]
.text:0000597C                 call    ??1?$CRecordVector@UCUpdatePair2@@@@QAE@XZ ; CRecordVector<CUpdatePair2>::~CRecordVector<CUpdatePair2>(void)
.text:00005981                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00005988                 lea     ecx, [ebp+var_18]
.text:0000598B                 call    ??1?$CMyComPtr@UIOutArchive@@@@QAE@XZ ; CMyComPtr<IOutArchive>::~CMyComPtr<IOutArchive>(void)
.text:00005990                 mov     eax, [ebp+var_2F8]
.text:00005996                 jmp     loc_5E99
.text:0000599B ; ---------------------------------------------------------------------------
.text:0000599B
.text:0000599B loc_599B:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+1613j
.text:0000599B                 mov     edx, [ebp+arg_0]
.text:0000599E                 movzx   eax, byte ptr [edx+0C4h]
.text:000059A5                 test    eax, eax
.text:000059A7                 jz      short loc_59C0
.text:000059A9                 lea     ecx, [ebp+var_12C]
.text:000059AF                 push    ecx
.text:000059B0                 lea     ecx, [ebp+var_1F4]
.text:000059B6                 call    ??4?$CMyComPtr@UISequentialOutStream@@@@QAEPAUISequentialOutStream@@ABV0@@Z ; CMyComPtr<ISequentialOutStream>::operator=(CMyComPtr<ISequentialOutStream> const &)
.text:000059BB                 jmp     loc_5A63
.text:000059C0 ; ---------------------------------------------------------------------------
.text:000059C0
.text:000059C0 loc_59C0:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+169Bj
.text:000059C0                 push    28h ; '('       ; unsigned int
.text:000059C2                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:000059C7                 add     esp, 4
.text:000059CA                 mov     [ebp+var_300], eax
.text:000059D0                 mov     byte ptr [ebp+var_4], 1Ah
.text:000059D4                 cmp     [ebp+var_300], 0
.text:000059DB                 jz      short loc_59F0
.text:000059DD                 mov     ecx, [ebp+var_300]
.text:000059E3                 call    ??0CTailOutStream@@QAE@XZ ; CTailOutStream::CTailOutStream(void)
.text:000059E8                 mov     [ebp+var_360], eax
.text:000059EE                 jmp     short loc_59FA
.text:000059F0 ; ---------------------------------------------------------------------------
.text:000059F0
.text:000059F0 loc_59F0:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+16CFj
.text:000059F0                 mov     [ebp+var_360], 0
.text:000059FA
.text:000059FA loc_59FA:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+16E2j
.text:000059FA                 mov     edx, [ebp+var_360]
.text:00005A00                 mov     [ebp+var_2FC], edx
.text:00005A06                 mov     byte ptr [ebp+var_4], 19h
.text:00005A0A                 mov     eax, [ebp+var_2FC]
.text:00005A10                 mov     [ebp+var_204], eax
.text:00005A16                 mov     ecx, [ebp+var_204]
.text:00005A1C                 push    ecx
.text:00005A1D                 lea     ecx, [ebp+var_1F4]
.text:00005A23                 call    ??4?$CMyComPtr@UISequentialOutStream@@@@QAEPAUISequentialOutStream@@PAU1@@Z ; CMyComPtr<ISequentialOutStream>::operator=(ISequentialOutStream *)
.text:00005A28                 lea     edx, [ebp+var_120]
.text:00005A2E                 push    edx
.text:00005A2F                 mov     ecx, [ebp+var_204]
.text:00005A35                 add     ecx, 18h
.text:00005A38                 call    ??4?$CMyComPtr@UIOutStream@@@@QAEPAUIOutStream@@ABV0@@Z ; CMyComPtr<IOutStream>::operator=(CMyComPtr<IOutStream> const &)
.text:00005A3D                 mov     eax, [ebp+var_204]
.text:00005A43                 mov     ecx, [ebp+arg_10]
.text:00005A46                 mov     edx, [ecx+0D0h]
.text:00005A4C                 mov     [eax+20h], edx
.text:00005A4F                 mov     ecx, [ecx+0D4h]
.text:00005A55                 mov     [eax+24h], ecx
.text:00005A58                 mov     ecx, [ebp+var_204] ; this
.text:00005A5E                 call    ?Init@CTailOutStream@@QAEXXZ ; CTailOutStream::Init(void)
.text:00005A63
.text:00005A63 loc_5A63:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+1512j
.text:00005A63                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+16AFj
.text:00005A63                 lea     ecx, [ebp+var_18]
.text:00005A66                 call    ??C?$CMyComPtr@UIOutArchive@@@@QBEPAUIOutArchive@@XZ ; CMyComPtr<IOutArchive>::operator->(void)
.text:00005A6B                 mov     [ebp+var_364], eax
.text:00005A71                 lea     ecx, [ebp+var_114]
.text:00005A77                 call    ??B?$CMyComPtr@UIArchiveUpdateCallback@@@@QBEPAUIArchiveUpdateCallback@@XZ ; CMyComPtr<IArchiveUpdateCallback>::operator IArchiveUpdateCallback *(void)
.text:00005A7C                 mov     esi, esp
.text:00005A7E                 push    eax
.text:00005A7F                 lea     ecx, [ebp+var_5C]
.text:00005A82                 call    ?Size@?$CRecordVector@UCUpdatePair2@@@@QBEIXZ ; CRecordVector<CUpdatePair2>::Size(void)
.text:00005A87                 push    eax
.text:00005A88                 lea     ecx, [ebp+var_1F4]
.text:00005A8E                 call    ??B?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ ; CMyComPtr<ISequentialOutStream>::operator ISequentialOutStream *(void)
.text:00005A93                 push    eax
.text:00005A94                 mov     edx, [ebp+var_364]
.text:00005A9A                 push    edx
.text:00005A9B                 mov     eax, [ebp+var_364]
.text:00005AA1                 mov     ecx, [eax]
.text:00005AA3                 mov     edx, [ecx+0Ch]
.text:00005AA6                 call    edx
.text:00005AA8                 cmp     esi, esp
.text:00005AAA                 call    __RTC_CheckEsp
.text:00005AAF                 mov     [ebp+var_208], eax
.text:00005AB5                 mov     eax, [ebp+var_208]
.text:00005ABB                 mov     [ebp+var_20C], eax
.text:00005AC1                 cmp     [ebp+var_20C], 0
.text:00005AC8                 jz      short loc_5B44
.text:00005ACA                 mov     ecx, [ebp+var_20C]
.text:00005AD0                 mov     [ebp+var_304], ecx
.text:00005AD6                 mov     byte ptr [ebp+var_4], 0Ah
.text:00005ADA                 lea     ecx, [ebp+var_1F4]
.text:00005AE0                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00005AE5                 mov     byte ptr [ebp+var_4], 9
.text:00005AE9                 lea     ecx, [ebp+var_12C]
.text:00005AEF                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00005AF4                 mov     byte ptr [ebp+var_4], 8
.text:00005AF8                 lea     ecx, [ebp+var_120]
.text:00005AFE                 call    ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::~CMyComPtr<IOutStream>(void)
.text:00005B03                 mov     byte ptr [ebp+var_4], 3
.text:00005B07                 lea     ecx, [ebp+var_114]
.text:00005B0D                 call    ??1?$CMyComPtr@UIArchiveUpdateCallback@@@@QAE@XZ ; CMyComPtr<IArchiveUpdateCallback>::~CMyComPtr<IArchiveUpdateCallback>(void)
.text:00005B12                 mov     byte ptr [ebp+var_4], 2
.text:00005B16                 lea     ecx, [ebp+var_70]
.text:00005B19                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:00005B1E                 mov     byte ptr [ebp+var_4], 0
.text:00005B22                 lea     ecx, [ebp+var_5C]
.text:00005B25                 call    ??1?$CRecordVector@UCUpdatePair2@@@@QAE@XZ ; CRecordVector<CUpdatePair2>::~CRecordVector<CUpdatePair2>(void)
.text:00005B2A                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00005B31                 lea     ecx, [ebp+var_18]
.text:00005B34                 call    ??1?$CMyComPtr@UIOutArchive@@@@QAE@XZ ; CMyComPtr<IOutArchive>::~CMyComPtr<IOutArchive>(void)
.text:00005B39                 mov     eax, [ebp+var_304]
.text:00005B3F                 jmp     loc_5E99
.text:00005B44 ; ---------------------------------------------------------------------------
.text:00005B44
.text:00005B44 loc_5B44:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+17BCj
.text:00005B44                 mov     ecx, [ebp+var_10C] ; this
.text:00005B4A                 call    ?AreAllFilesClosed@CArchiveUpdateCallback@@QBE_NXZ ; CArchiveUpdateCallback::AreAllFilesClosed(void)
.text:00005B4F                 movzx   edx, al
.text:00005B52                 test    edx, edx
.text:00005B54                 jnz     loc_5BF7
.text:00005B5A                 push    offset $SG75009 ; "There are unclosed input file:"
.text:00005B5F                 mov     ecx, [ebp+arg_2C]
.text:00005B62                 add     ecx, 4
.text:00005B65                 call    ??4AString@@QAEAAV0@PBD@Z ; AString::operator=(char const *)
.text:00005B6A                 mov     eax, [ebp+var_10C]
.text:00005B70                 add     eax, 4Ch ; 'L'
.text:00005B73                 push    eax
.text:00005B74                 mov     ecx, [ebp+arg_2C]
.text:00005B77                 add     ecx, 10h
.text:00005B7A                 call    ??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z ; CObjectVector<UString>::operator=(CObjectVector<UString> const &)
.text:00005B7F                 mov     [ebp+var_308], 80004005h
.text:00005B89                 mov     byte ptr [ebp+var_4], 0Ah
.text:00005B8D                 lea     ecx, [ebp+var_1F4]
.text:00005B93                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00005B98                 mov     byte ptr [ebp+var_4], 9
.text:00005B9C                 lea     ecx, [ebp+var_12C]
.text:00005BA2                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00005BA7                 mov     byte ptr [ebp+var_4], 8
.text:00005BAB                 lea     ecx, [ebp+var_120]
.text:00005BB1                 call    ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::~CMyComPtr<IOutStream>(void)
.text:00005BB6                 mov     byte ptr [ebp+var_4], 3
.text:00005BBA                 lea     ecx, [ebp+var_114]
.text:00005BC0                 call    ??1?$CMyComPtr@UIArchiveUpdateCallback@@@@QAE@XZ ; CMyComPtr<IArchiveUpdateCallback>::~CMyComPtr<IArchiveUpdateCallback>(void)
.text:00005BC5                 mov     byte ptr [ebp+var_4], 2
.text:00005BC9                 lea     ecx, [ebp+var_70]
.text:00005BCC                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:00005BD1                 mov     byte ptr [ebp+var_4], 0
.text:00005BD5                 lea     ecx, [ebp+var_5C]
.text:00005BD8                 call    ??1?$CRecordVector@UCUpdatePair2@@@@QAE@XZ ; CRecordVector<CUpdatePair2>::~CRecordVector<CUpdatePair2>(void)
.text:00005BDD                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00005BE4                 lea     ecx, [ebp+var_18]
.text:00005BE7                 call    ??1?$CMyComPtr@UIOutArchive@@@@QAE@XZ ; CMyComPtr<IOutArchive>::~CMyComPtr<IOutArchive>(void)
.text:00005BEC                 mov     eax, [ebp+var_308]
.text:00005BF2                 jmp     loc_5E99
.text:00005BF7 ; ---------------------------------------------------------------------------
.text:00005BF7
.text:00005BF7 loc_5BF7:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+1848j
.text:00005BF7                 mov     ecx, [ebp+arg_0]
.text:00005BFA                 movzx   edx, byte ptr [ecx+0F9h]
.text:00005C01                 test    edx, edx
.text:00005C03                 jz      loc_5D6A
.text:00005C09                 mov     [ebp+FileTime1.dwLowDateTime], 0
.text:00005C13                 mov     [ebp+FileTime1.dwHighDateTime], 0
.text:00005C1D                 mov     [ebp+var_220], 0
.text:00005C27                 jmp     short loc_5C38
.text:00005C29 ; ---------------------------------------------------------------------------
.text:00005C29
.text:00005C29 loc_5C29:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &):loc_5D1Bj
.text:00005C29                 mov     eax, [ebp+var_220]
.text:00005C2F                 add     eax, 1
.text:00005C32                 mov     [ebp+var_220], eax
.text:00005C38
.text:00005C38 loc_5C38:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+191Bj
.text:00005C38                 lea     ecx, [ebp+var_5C]
.text:00005C3B                 call    ?Size@?$CRecordVector@UCUpdatePair2@@@@QBEIXZ ; CRecordVector<CUpdatePair2>::Size(void)
.text:00005C40                 cmp     [ebp+var_220], eax
.text:00005C46                 jnb     loc_5D20
.text:00005C4C                 mov     ecx, [ebp+var_220]
.text:00005C52                 push    ecx
.text:00005C53                 lea     ecx, [ebp+var_5C]
.text:00005C56                 call    ??A?$CRecordVector@UCUpdatePair2@@@@QAEAAUCUpdatePair2@@I@Z ; CRecordVector<CUpdatePair2>::operator[](uint)
.text:00005C5B                 mov     [ebp+var_224], eax
.text:00005C61                 mov     [ebp+lpFileTime2], 0
.text:00005C6B                 mov     edx, [ebp+var_224]
.text:00005C71                 movzx   eax, byte ptr [edx+1]
.text:00005C75                 test    eax, eax
.text:00005C77                 jz      short loc_5CA5
.text:00005C79                 mov     ecx, [ebp+var_224]
.text:00005C7F                 cmp     dword ptr [ecx+4], 0
.text:00005C83                 jl      short loc_5CA5
.text:00005C85                 mov     edx, [ebp+var_224]
.text:00005C8B                 mov     eax, [edx+4]
.text:00005C8E                 push    eax
.text:00005C8F                 mov     ecx, [ebp+arg_20]
.text:00005C92                 add     ecx, 24h ; '$'
.text:00005C95                 call    ??A?$CObjectVector@UCDirItem@@@@QBEABUCDirItem@@I@Z ; CObjectVector<CDirItem>::operator[](uint)
.text:00005C9A                 add     eax, 18h
.text:00005C9D                 mov     [ebp+lpFileTime2], eax
.text:00005CA3                 jmp     short loc_5CDA
.text:00005CA5 ; ---------------------------------------------------------------------------
.text:00005CA5
.text:00005CA5 loc_5CA5:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+196Bj
.text:00005CA5                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+1977j
.text:00005CA5                 mov     ecx, [ebp+var_224]
.text:00005CAB                 movzx   edx, byte ptr [ecx+2]
.text:00005CAF                 test    edx, edx
.text:00005CB1                 jz      short loc_5CDA
.text:00005CB3                 mov     eax, [ebp+var_224]
.text:00005CB9                 cmp     dword ptr [eax+8], 0
.text:00005CBD                 jl      short loc_5CDA
.text:00005CBF                 mov     ecx, [ebp+var_224]
.text:00005CC5                 mov     edx, [ecx+8]
.text:00005CC8                 push    edx
.text:00005CC9                 mov     ecx, [ebp+arg_18]
.text:00005CCC                 call    ??A?$CObjectVector@UCArcItem@@@@QBEABUCArcItem@@I@Z ; CObjectVector<CArcItem>::operator[](uint)
.text:00005CD1                 add     eax, 8
.text:00005CD4                 mov     [ebp+lpFileTime2], eax
.text:00005CDA
.text:00005CDA loc_5CDA:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+1997j
.text:00005CDA                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+19A5j ...
.text:00005CDA                 cmp     [ebp+lpFileTime2], 0
.text:00005CE1                 jz      short loc_5D1B
.text:00005CE3                 mov     esi, esp
.text:00005CE5                 mov     eax, [ebp+lpFileTime2]
.text:00005CEB                 push    eax             ; lpFileTime2
.text:00005CEC                 lea     ecx, [ebp+FileTime1]
.text:00005CF2                 push    ecx             ; lpFileTime1
.text:00005CF3                 call    dword ptr ds:__imp__CompareFileTime@8 ; CompareFileTime(x,x)
.text:00005CF9                 cmp     esi, esp
.text:00005CFB                 call    __RTC_CheckEsp
.text:00005D00                 test    eax, eax
.text:00005D02                 jge     short loc_5D1B
.text:00005D04                 mov     edx, [ebp+lpFileTime2]
.text:00005D0A                 mov     eax, [edx]
.text:00005D0C                 mov     ecx, [edx+4]
.text:00005D0F                 mov     [ebp+FileTime1.dwLowDateTime], eax
.text:00005D15                 mov     [ebp+FileTime1.dwHighDateTime], ecx
.text:00005D1B
.text:00005D1B loc_5D1B:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+19D5j
.text:00005D1B                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+19F6j
.text:00005D1B                 jmp     loc_5C29
.text:00005D20 ; ---------------------------------------------------------------------------
.text:00005D20
.text:00005D20 loc_5D20:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+193Aj
.text:00005D20                 cmp     [ebp+FileTime1.dwLowDateTime], 0
.text:00005D27                 jnz     short loc_5D32
.text:00005D29                 cmp     [ebp+FileTime1.dwHighDateTime], 0
.text:00005D30                 jz      short loc_5D6A
.text:00005D32
.text:00005D32 loc_5D32:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+1A1Bj
.text:00005D32                 cmp     [ebp+var_148], 0
.text:00005D39                 jz      short loc_5D4F
.text:00005D3B                 lea     edx, [ebp+FileTime1]
.text:00005D41                 push    edx             ; struct _FILETIME *
.text:00005D42                 mov     ecx, [ebp+var_148] ; this
.text:00005D48                 call    ?SetMTime@COutFileStream@@QAE_NPBU_FILETIME@@@Z ; COutFileStream::SetMTime(_FILETIME const *)
.text:00005D4D                 jmp     short loc_5D6A
.text:00005D4F ; ---------------------------------------------------------------------------
.text:00005D4F
.text:00005D4F loc_5D4F:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+1A2Dj
.text:00005D4F                 cmp     [ebp+var_150], 0
.text:00005D56                 jz      short loc_5D6A
.text:00005D58                 lea     eax, [ebp+FileTime1]
.text:00005D5E                 push    eax             ; struct _FILETIME *
.text:00005D5F                 mov     ecx, [ebp+var_150] ; this
.text:00005D65                 call    ?SetMTime@COutMultiVolStream@@QAE_NPBU_FILETIME@@@Z ; COutMultiVolStream::SetMTime(_FILETIME const *)
.text:00005D6A
.text:00005D6A loc_5D6A:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+18F7j
.text:00005D6A                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+1A24j ...
.text:00005D6A                 cmp     [ebp+arg_30], 0
.text:00005D6E                 jz      short loc_5DEE
.text:00005D70                 mov     dword ptr [ebp+var_234], 0
.text:00005D7A                 mov     dword ptr [ebp+var_234+4], 0
.text:00005D84                 cmp     [ebp+var_148], 0
.text:00005D8B                 jz      short loc_5DA1
.text:00005D8D                 lea     ecx, [ebp+var_234]
.text:00005D93                 push    ecx             ; unsigned __int64 *
.text:00005D94                 mov     ecx, [ebp+var_148] ; this
.text:00005D9A                 call    ?GetSize@COutFileStream@@QAEJPA_K@Z ; COutFileStream::GetSize(unsigned __int64 *)
.text:00005D9F                 jmp     short loc_5DDA
.text:00005DA1 ; ---------------------------------------------------------------------------
.text:00005DA1
.text:00005DA1 loc_5DA1:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+1A7Fj
.text:00005DA1                 cmp     [ebp+var_14C], 0
.text:00005DA8                 jz      short loc_5DC3
.text:00005DAA                 mov     ecx, [ebp+var_14C] ; this
.text:00005DB0                 call    ?GetSize@CStdOutFileStream@@QBE_KXZ ; CStdOutFileStream::GetSize(void)
.text:00005DB5                 mov     dword ptr [ebp+var_234], eax
.text:00005DBB                 mov     dword ptr [ebp+var_234+4], edx
.text:00005DC1                 jmp     short loc_5DDA
.text:00005DC3 ; ---------------------------------------------------------------------------
.text:00005DC3
.text:00005DC3 loc_5DC3:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+1A9Cj
.text:00005DC3                 mov     ecx, [ebp+var_150] ; this
.text:00005DC9                 call    ?GetSize@COutMultiVolStream@@QBE_KXZ ; COutMultiVolStream::GetSize(void)
.text:00005DCE                 mov     dword ptr [ebp+var_234], eax
.text:00005DD4                 mov     dword ptr [ebp+var_234+4], edx
.text:00005DDA
.text:00005DDA loc_5DDA:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+1A93j
.text:00005DDA                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+1AB5j
.text:00005DDA                 mov     edx, [ebp+arg_34]
.text:00005DDD                 mov     eax, dword ptr [ebp+var_234]
.text:00005DE3                 mov     [edx], eax
.text:00005DE5                 mov     ecx, dword ptr [ebp+var_234+4]
.text:00005DEB                 mov     [edx+4], ecx
.text:00005DEE
.text:00005DEE loc_5DEE:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+1A62j
.text:00005DEE                 cmp     [ebp+var_148], 0
.text:00005DF5                 jz      short loc_5E0A
.text:00005DF7                 mov     ecx, [ebp+var_148] ; this
.text:00005DFD                 call    ?Close@COutFileStream@@QAEJXZ ; COutFileStream::Close(void)
.text:00005E02                 mov     [ebp+var_208], eax
.text:00005E08                 jmp     short loc_5E24
.text:00005E0A ; ---------------------------------------------------------------------------
.text:00005E0A
.text:00005E0A loc_5E0A:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+1AE9j
.text:00005E0A                 cmp     [ebp+var_150], 0
.text:00005E11                 jz      short loc_5E24
.text:00005E13                 mov     ecx, [ebp+var_150] ; this
.text:00005E19                 call    ?Close@COutMultiVolStream@@QAEJXZ ; COutMultiVolStream::Close(void)
.text:00005E1E                 mov     [ebp+var_208], eax
.text:00005E24
.text:00005E24 loc_5E24:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+1AFCj
.text:00005E24                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+1B05j
.text:00005E24                 mov     edx, [ebp+var_208]
.text:00005E2A                 mov     [ebp+var_30C], edx
.text:00005E30                 mov     byte ptr [ebp+var_4], 0Ah
.text:00005E34                 lea     ecx, [ebp+var_1F4]
.text:00005E3A                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00005E3F                 mov     byte ptr [ebp+var_4], 9
.text:00005E43                 lea     ecx, [ebp+var_12C]
.text:00005E49                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:00005E4E                 mov     byte ptr [ebp+var_4], 8
.text:00005E52                 lea     ecx, [ebp+var_120]
.text:00005E58                 call    ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::~CMyComPtr<IOutStream>(void)
.text:00005E5D                 mov     byte ptr [ebp+var_4], 3
.text:00005E61                 lea     ecx, [ebp+var_114]
.text:00005E67                 call    ??1?$CMyComPtr@UIArchiveUpdateCallback@@@@QAE@XZ ; CMyComPtr<IArchiveUpdateCallback>::~CMyComPtr<IArchiveUpdateCallback>(void)
.text:00005E6C                 mov     byte ptr [ebp+var_4], 2
.text:00005E70                 lea     ecx, [ebp+var_70]
.text:00005E73                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:00005E78                 mov     byte ptr [ebp+var_4], 0
.text:00005E7C                 lea     ecx, [ebp+var_5C]
.text:00005E7F                 call    ??1?$CRecordVector@UCUpdatePair2@@@@QAE@XZ ; CRecordVector<CUpdatePair2>::~CRecordVector<CUpdatePair2>(void)
.text:00005E84                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00005E8B                 lea     ecx, [ebp+var_18]
.text:00005E8E                 call    ??1?$CMyComPtr@UIOutArchive@@@@QAE@XZ ; CMyComPtr<IOutArchive>::~CMyComPtr<IOutArchive>(void)
.text:00005E93                 mov     eax, [ebp+var_30C]
.text:00005E99
.text:00005E99 loc_5E99:                               ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+92j
.text:00005E99                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+128j ...
.text:00005E99                 push    edx
.text:00005E9A                 mov     ecx, ebp
.text:00005E9C                 push    eax
.text:00005E9D                 lea     edx, $LN165
.text:00005EA3                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00005EA8                 pop     eax
.text:00005EA9                 pop     edx
.text:00005EAA                 mov     ecx, [ebp+var_C]
.text:00005EAD                 mov     large fs:0, ecx
.text:00005EB4                 pop     ecx
.text:00005EB5                 pop     edi
.text:00005EB6                 pop     esi
.text:00005EB7                 mov     ecx, [ebp+var_10]
.text:00005EBA                 xor     ecx, ebp
.text:00005EBC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text:00005EC1                 add     esp, 364h
.text:00005EC7                 cmp     ebp, esp
.text:00005EC9                 call    __RTC_CheckEsp
.text:00005ECE                 mov     esp, ebp
.text:00005ED0                 pop     ebp
.text:00005ED1                 retn    38h
.text:00005ED1 ?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z endp ; sp-analysis failed
.text:00005ED1
.text:00005ED1 ; ---------------------------------------------------------------------------
.text:00005ED4 $LN165          dd 17h                  ; DATA XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+1B91o
.text:00005ED8                 dd offset $LN164
.text:00005EDC $LN164          dd 0FFFFFFE8h, 4        ; DATA XREF: .text:00005ED8o
.text:00005EE4                 dd offset $LN140        ; "outArchive"
.text:00005EE8                 dd 0FFFFFFD8h, 4
.text:00005EF0                 dd offset $LN141        ; "archive2"
.text:00005EF4                 dd 0FFFFFFC0h, 4
.text:00005EFC                 dd offset $LN142        ; "value"
.text:00005F00                 dd 0FFFFFFA4h, 0Ch
.text:00005F08                 dd offset $LN143        ; "updatePairs2"
.text:00005F0C                 db 90h
.text:00005F0D                 db 3 dup(0FFh)
.text:00005F10                 dd 0Ch
.text:00005F14                 dd offset $LN144        ; "newNames"
.text:00005F18                 dd 0FFFFFF70h, 0Ch
.text:00005F20                 dd offset $LN145        ; "dest"
.text:00005F24                 dd 0FFFFFF50h, 0Ch
.text:00005F2C                 dd offset $LN146        ; "mainName"
.text:00005F30                 dd 0FFFFFF34h, 14h
.text:00005F38                 dd offset $LN147        ; "up2"
.text:00005F3C                 dd 0FFFFFF1Ch, 0Ch
.text:00005F44                 dd offset $LN148        ; "updatePairs"
.text:00005F48                 db 8, 0FFh
.text:00005F4A                 dw 0FFFFh
.text:00005F4C                 dd 0Ch
.text:00005F50                 dd offset $LN149        ; "upCallback"
.text:00005F54                 dd 0FFFFFEECh, 4
.text:00005F5C                 dd offset $LN150        ; "updateCallback"
.text:00005F60                 dd 0FFFFFEE0h, 4
.text:00005F68                 dd offset $LN151        ; "outSeekStream"
.text:00005F6C                 dd 0FFFFFED4h, 4
.text:00005F74                 dd offset $LN152        ; "outStream"
.text:00005F78                 dd 0FFFFFEC0h, 0Ch
.text:00005F80                 dd offset $LN153        ; "dirPrefix"
.text:00005F84                 dd 0FFFFFE9Ch, 0Ch
.text:00005F8C                 dd offset $LN154        ; "realPath"
.text:00005F90                 dd 0FFFFFE70h, 20h
.text:00005F98                 dd offset $LN155        ; "s"
.text:00005F9C                 dd 0FFFFFE5Ch, 4
.text:00005FA4                 dd offset $LN156        ; "sfxStream"
.text:00005FA8                 dd 0FFFFFE50h, 4
.text:00005FB0                 dd offset $LN157        ; "sfxOutStream"
.text:00005FB4                 dd 0FFFFFE38h, 0Ch
.text:00005FBC                 dd offset $LN158        ; "realPath"
.text:00005FC0                 dd 0FFFFFE28h, 8
.text:00005FC8                 dd offset $LN159        ; "sfxSize"
.text:00005FCC                 dd 0FFFFFE0Ch, 4
.text:00005FD4                 dd offset $LN160        ; "tailStream"
.text:00005FD8                 dd 0FFFFFDE8h, 8
.text:00005FE0                 dd offset $LN161        ; "ft"
.text:00005FE4                 db 0CCh
.text:00005FE5                 db 0FDh, 2 dup(0FFh)
.text:00005FE8                 dd 8
.text:00005FEC                 dd offset $LN162        ; "size"
.text:00005FF0 $LN162          db 'size',0             ; DATA XREF: .text:00005FECo
.text:00005FF5 $LN161          db 'ft',0               ; DATA XREF: .text:00005FE0o
.text:00005FF8 $LN160          db 'tailStream',0       ; DATA XREF: .text:00005FD4o
.text:00006003 $LN159          db 'sfxSize',0          ; DATA XREF: .text:00005FC8o
.text:0000600B $LN158          db 'realPath',0         ; DATA XREF: .text:00005FBCo
.text:00006014 $LN157          db 'sfxOutStream',0     ; DATA XREF: .text:00005FB0o
.text:00006021 $LN156          db 'sfxStream',0        ; DATA XREF: .text:00005FA4o
.text:0000602B $LN155          db 's',0                ; DATA XREF: .text:00005F98o
.text:0000602D $LN154          db 'realPath',0         ; DATA XREF: .text:00005F8Co
.text:00006036 $LN153          db 'dirPrefix',0        ; DATA XREF: .text:00005F80o
.text:00006040 $LN152          db 'outStream',0        ; DATA XREF: .text:00005F74o
.text:0000604A $LN151          db 'outSeekStream',0    ; DATA XREF: .text:00005F68o
.text:00006058 $LN150          db 'updateCallback',0   ; DATA XREF: .text:00005F5Co
.text:00006067 $LN149          db 'upCallback',0       ; DATA XREF: .text:00005F50o
.text:00006072 $LN148          db 'updatePairs',0      ; DATA XREF: .text:00005F44o
.text:0000607E $LN147          db 'up2',0              ; DATA XREF: .text:00005F38o
.text:00006082 $LN146          db 'mainName',0         ; DATA XREF: .text:00005F2Co
.text:0000608B $LN145          db 'dest',0             ; DATA XREF: .text:00005F20o
.text:00006090 $LN144          db 'newNames',0         ; DATA XREF: .text:00005F14o
.text:00006099 $LN143          db 'updatePairs2',0     ; DATA XREF: .text:00005F08o
.text:000060A6 $LN142          db 'value',0            ; DATA XREF: .text:00005EFCo
.text:000060AC $LN141          db 'archive2',0         ; DATA XREF: .text:00005EF0o
.text:000060B5 $LN140          db 'outArchive',0       ; DATA XREF: .text:00005EE4o
.text:000060C0                 db 0Ch dup(0CCh)
.text:000060CC
.text:000060CC ; =============== S U B R O U T I N E =======================================
.text:000060CC
.text:000060CC ; Attributes: bp-based frame
.text:000060CC
.text:000060CC ; int __stdcall EnumerateInArchiveItems(int, CArc *, int)
.text:000060CC ?EnumerateInArchiveItems@@YGJABVCCensor@NWildcard@@ABVCArc@@AAV?$CObjectVector@UCArcItem@@@@@Z proc near
.text:000060CC                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+13D6p
.text:000060CC
.text:000060CC var_E8          = dword ptr -0E8h
.text:000060CC var_E4          = dword ptr -0E4h
.text:000060CC var_E0          = dword ptr -0E0h
.text:000060CC var_DC          = dword ptr -0DCh
.text:000060CC var_D8          = dword ptr -0D8h
.text:000060CC var_D4          = dword ptr -0D4h
.text:000060CC var_D0          = dword ptr -0D0h
.text:000060CC var_CC          = dword ptr -0CCh
.text:000060CC var_C4          = word ptr -0C4h
.text:000060CC var_BC          = dword ptr -0BCh
.text:000060CC var_B0          = dword ptr -0B0h
.text:000060CC var_AC          = dword ptr -0ACh
.text:000060CC var_A8          = dword ptr -0A8h
.text:000060CC var_A0          = qword ptr -0A0h
.text:000060CC var_98          = _FILETIME ptr -98h
.text:000060CC var_90          = byte ptr -90h
.text:000060CC var_84          = byte ptr -84h
.text:000060CC var_83          = byte ptr -83h
.text:000060CC var_82          = byte ptr -82h
.text:000060CC var_81          = byte ptr -81h
.text:000060CC var_80          = byte ptr -80h
.text:000060CC var_7C          = dword ptr -7Ch
.text:000060CC var_78          = dword ptr -78h
.text:000060CC var_6C          = dword ptr -6Ch
.text:000060CC var_64          = byte ptr -64h
.text:000060CC var_34          = byte ptr -34h
.text:000060CC var_32          = byte ptr -32h
.text:000060CC var_20          = dword ptr -20h
.text:000060CC var_1C          = dword ptr -1Ch
.text:000060CC var_14          = dword ptr -14h
.text:000060CC var_C           = dword ptr -0Ch
.text:000060CC var_4           = dword ptr -4
.text:000060CC arg_0           = dword ptr  8
.text:000060CC arg_4           = dword ptr  0Ch
.text:000060CC arg_8           = dword ptr  10h
.text:000060CC
.text:000060CC                 push    ebp
.text:000060CD                 mov     ebp, esp
.text:000060CF                 push    0FFFFFFFFh
.text:000060D1                 push    offset __ehhandler$?EnumerateInArchiveItems@@YGJABVCCensor@NWildcard@@ABVCArc@@AAV?$CObjectVector@UCArcItem@@@@@Z
.text:000060D6                 mov     eax, large fs:0
.text:000060DC                 push    eax
.text:000060DD                 sub     esp, 0DCh
.text:000060E3                 push    esi
.text:000060E4                 push    edi
.text:000060E5                 lea     edi, [ebp+var_E8]
.text:000060EB                 mov     ecx, 37h ; '7'
.text:000060F0                 mov     eax, 0CCCCCCCCh
.text:000060F5                 rep stosd
.text:000060F7                 mov     eax, dword ptr ds:___security_cookie
.text:000060FC                 xor     eax, ebp
.text:000060FE                 push    eax
.text:000060FF                 lea     eax, [ebp+var_C]
.text:00006102                 mov     large fs:0, eax
.text:00006108                 mov     ecx, [ebp+arg_8]
.text:0000610B                 call    ?Clear@?$CObjectVector@UCArcItem@@@@QAEXXZ ; CObjectVector<CArcItem>::Clear(void)
.text:00006110                 mov     ecx, [ebp+arg_4]
.text:00006113                 call    ??B?$CMyComPtr@UIInArchive@@@@QBEPAUIInArchive@@XZ ; CMyComPtr<IInArchive>::operator IInArchive *(void)
.text:00006118                 mov     [ebp+var_1C], eax
.text:0000611B                 mov     esi, esp
.text:0000611D                 lea     eax, [ebp+var_14]
.text:00006120                 push    eax
.text:00006121                 mov     ecx, [ebp+var_1C]
.text:00006124                 mov     edx, [ecx]
.text:00006126                 mov     eax, [ebp+var_1C]
.text:00006129                 push    eax
.text:0000612A                 mov     ecx, [edx+14h]
.text:0000612D                 call    ecx
.text:0000612F                 cmp     esi, esp
.text:00006131                 call    __RTC_CheckEsp
.text:00006136                 mov     [ebp+var_20], eax
.text:00006139                 cmp     [ebp+var_20], 0
.text:0000613D                 jz      short loc_6147
.text:0000613F                 mov     eax, [ebp+var_20]
.text:00006142                 jmp     loc_6420
.text:00006147 ; ---------------------------------------------------------------------------
.text:00006147
.text:00006147 loc_6147:                               ; CODE XREF: EnumerateInArchiveItems(NWildcard::CCensor const &,CArc const &,CObjectVector<CArcItem> &)+71j
.text:00006147                 mov     edx, [ebp+var_14]
.text:0000614A                 push    edx
.text:0000614B                 mov     ecx, [ebp+arg_8]
.text:0000614E                 call    ?ClearAndReserve@?$CObjectVector@UCArcItem@@@@QAEXI@Z ; CObjectVector<CArcItem>::ClearAndReserve(uint)
.text:00006153                 lea     ecx, [ebp+var_64] ; this
.text:00006156                 call    ??0CReadArcItem@@QAE@XZ ; CReadArcItem::CReadArcItem(void)
.text:0000615B                 mov     [ebp+var_4], 0
.text:00006162                 mov     [ebp+var_6C], 0
.text:00006169                 jmp     short loc_6174
.text:0000616B ; ---------------------------------------------------------------------------
.text:0000616B
.text:0000616B loc_616B:                               ; CODE XREF: EnumerateInArchiveItems(NWildcard::CCensor const &,CArc const &,CObjectVector<CArcItem> &)+330j
.text:0000616B                 mov     eax, [ebp+var_6C]
.text:0000616E                 add     eax, 1
.text:00006171                 mov     [ebp+var_6C], eax
.text:00006174
.text:00006174 loc_6174:                               ; CODE XREF: EnumerateInArchiveItems(NWildcard::CCensor const &,CArc const &,CObjectVector<CArcItem> &)+9Dj
.text:00006174                 mov     ecx, [ebp+var_6C]
.text:00006177                 cmp     ecx, [ebp+var_14]
.text:0000617A                 jnb     loc_6401
.text:00006180                 lea     ecx, [ebp+var_A0] ; this
.text:00006186                 call    ??0CArcItem@@QAE@XZ ; CArcItem::CArcItem(void)
.text:0000618B                 mov     byte ptr [ebp+var_4], 1
.text:0000618F                 lea     edx, [ebp+var_64]
.text:00006192                 push    edx             ; struct CReadArcItem *
.text:00006193                 mov     eax, [ebp+var_6C]
.text:00006196                 push    eax             ; unsigned int
.text:00006197                 mov     ecx, [ebp+arg_4] ; this
.text:0000619A                 call    ?GetItem@CArc@@QBEJIAAUCReadArcItem@@@Z ; CArc::GetItem(uint,CReadArcItem &)
.text:0000619F                 mov     [ebp+var_A8], eax
.text:000061A5                 cmp     [ebp+var_A8], 0
.text:000061AC                 jz      short loc_61E3
.text:000061AE                 mov     ecx, [ebp+var_A8]
.text:000061B4                 mov     [ebp+var_D0], ecx
.text:000061BA                 mov     byte ptr [ebp+var_4], 0
.text:000061BE                 lea     ecx, [ebp+var_A0] ; this
.text:000061C4                 call    ??1CArcItem@@QAE@XZ ; CArcItem::~CArcItem(void)
.text:000061C9                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000061D0                 lea     ecx, [ebp+var_64] ; this
.text:000061D3                 call    ??1CReadArcItem@@QAE@XZ ; CReadArcItem::~CReadArcItem(void)
.text:000061D8                 mov     eax, [ebp+var_D0]
.text:000061DE                 jmp     loc_6420
.text:000061E3 ; ---------------------------------------------------------------------------
.text:000061E3
.text:000061E3 loc_61E3:                               ; CODE XREF: EnumerateInArchiveItems(NWildcard::CCensor const &,CArc const &,CObjectVector<CArcItem> &)+E0j
.text:000061E3                 lea     edx, [ebp+var_64]
.text:000061E6                 push    edx
.text:000061E7                 lea     ecx, [ebp+var_90]
.text:000061ED                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:000061F2                 mov     al, [ebp+var_32]
.text:000061F5                 mov     [ebp+var_84], al
.text:000061FB                 mov     cl, [ebp+var_34]
.text:000061FE                 mov     [ebp+var_83], cl
.text:00006204                 lea     edx, [ebp+var_64]
.text:00006207                 push    edx             ; struct CReadArcItem *
.text:00006208                 mov     eax, [ebp+arg_0]
.text:0000620B                 push    eax             ; int
.text:0000620C                 call    ?Censor_CheckPath@@YG_NABVCCensor@NWildcard@@ABUCReadArcItem@@@Z ; Censor_CheckPath(NWildcard::CCensor const &,CReadArcItem const &)
.text:00006211                 mov     [ebp+var_80], al
.text:00006214                 lea     ecx, [ebp+var_81]
.text:0000621A                 push    ecx             ; bool *
.text:0000621B                 lea     edx, [ebp+var_98]
.text:00006221                 push    edx             ; struct _FILETIME *
.text:00006222                 mov     eax, [ebp+var_6C]
.text:00006225                 push    eax             ; unsigned int
.text:00006226                 mov     ecx, [ebp+arg_4] ; this
.text:00006229                 call    ?GetItemMTime@CArc@@QBEJIAAU_FILETIME@@AA_N@Z ; CArc::GetItemMTime(uint,_FILETIME &,bool &)
.text:0000622E                 mov     [ebp+var_AC], eax
.text:00006234                 cmp     [ebp+var_AC], 0
.text:0000623B                 jz      short loc_6272
.text:0000623D                 mov     ecx, [ebp+var_AC]
.text:00006243                 mov     [ebp+var_D4], ecx
.text:00006249                 mov     byte ptr [ebp+var_4], 0
.text:0000624D                 lea     ecx, [ebp+var_A0] ; this
.text:00006253                 call    ??1CArcItem@@QAE@XZ ; CArcItem::~CArcItem(void)
.text:00006258                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000625F                 lea     ecx, [ebp+var_64] ; this
.text:00006262                 call    ??1CReadArcItem@@QAE@XZ ; CReadArcItem::~CReadArcItem(void)
.text:00006267                 mov     eax, [ebp+var_D4]
.text:0000626D                 jmp     loc_6420
.text:00006272 ; ---------------------------------------------------------------------------
.text:00006272
.text:00006272 loc_6272:                               ; CODE XREF: EnumerateInArchiveItems(NWildcard::CCensor const &,CArc const &,CObjectVector<CArcItem> &)+16Fj
.text:00006272                 lea     edx, [ebp+var_82]
.text:00006278                 push    edx             ; bool *
.text:00006279                 lea     eax, [ebp+var_A0]
.text:0000627F                 push    eax             ; unsigned __int64 *
.text:00006280                 mov     ecx, [ebp+var_6C]
.text:00006283                 push    ecx             ; unsigned int
.text:00006284                 mov     ecx, [ebp+arg_4] ; this
.text:00006287                 call    ?GetItemSize@CArc@@QBEJIAA_KAA_N@Z ; CArc::GetItemSize(uint,unsigned __int64 &,bool &)
.text:0000628C                 mov     [ebp+var_B0], eax
.text:00006292                 cmp     [ebp+var_B0], 0
.text:00006299                 jz      short loc_62D0
.text:0000629B                 mov     edx, [ebp+var_B0]
.text:000062A1                 mov     [ebp+var_D8], edx
.text:000062A7                 mov     byte ptr [ebp+var_4], 0
.text:000062AB                 lea     ecx, [ebp+var_A0] ; this
.text:000062B1                 call    ??1CArcItem@@QAE@XZ ; CArcItem::~CArcItem(void)
.text:000062B6                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000062BD                 lea     ecx, [ebp+var_64] ; this
.text:000062C0                 call    ??1CReadArcItem@@QAE@XZ ; CReadArcItem::~CReadArcItem(void)
.text:000062C5                 mov     eax, [ebp+var_D8]
.text:000062CB                 jmp     loc_6420
.text:000062D0 ; ---------------------------------------------------------------------------
.text:000062D0
.text:000062D0 loc_62D0:                               ; CODE XREF: EnumerateInArchiveItems(NWildcard::CCensor const &,CArc const &,CObjectVector<CArcItem> &)+1CDj
.text:000062D0                 lea     ecx, [ebp+var_C4] ; this
.text:000062D6                 call    ??0CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::CPropVariant(void)
.text:000062DB                 mov     byte ptr [ebp+var_4], 2
.text:000062DF                 mov     esi, esp
.text:000062E1                 lea     eax, [ebp+var_C4]
.text:000062E7                 push    eax
.text:000062E8                 push    28h ; '('
.text:000062EA                 mov     ecx, [ebp+var_6C]
.text:000062ED                 push    ecx
.text:000062EE                 mov     edx, [ebp+var_1C]
.text:000062F1                 mov     eax, [edx]
.text:000062F3                 mov     ecx, [ebp+var_1C]
.text:000062F6                 push    ecx
.text:000062F7                 mov     edx, [eax+18h]
.text:000062FA                 call    edx
.text:000062FC                 cmp     esi, esp
.text:000062FE                 call    __RTC_CheckEsp
.text:00006303                 mov     [ebp+var_CC], eax
.text:00006309                 cmp     [ebp+var_CC], 0
.text:00006310                 jz      short loc_6356
.text:00006312                 mov     eax, [ebp+var_CC]
.text:00006318                 mov     [ebp+var_DC], eax
.text:0000631E                 mov     byte ptr [ebp+var_4], 1
.text:00006322                 lea     ecx, [ebp+var_C4] ; this
.text:00006328                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:0000632D                 mov     byte ptr [ebp+var_4], 0
.text:00006331                 lea     ecx, [ebp+var_A0] ; this
.text:00006337                 call    ??1CArcItem@@QAE@XZ ; CArcItem::~CArcItem(void)
.text:0000633C                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00006343                 lea     ecx, [ebp+var_64] ; this
.text:00006346                 call    ??1CReadArcItem@@QAE@XZ ; CReadArcItem::~CReadArcItem(void)
.text:0000634B                 mov     eax, [ebp+var_DC]
.text:00006351                 jmp     loc_6420
.text:00006356 ; ---------------------------------------------------------------------------
.text:00006356
.text:00006356 loc_6356:                               ; CODE XREF: EnumerateInArchiveItems(NWildcard::CCensor const &,CArc const &,CObjectVector<CArcItem> &)+244j
.text:00006356                 movzx   ecx, [ebp+var_C4]
.text:0000635D                 cmp     ecx, 13h
.text:00006360                 jnz     short loc_63C9
.text:00006362                 mov     edx, [ebp+var_BC]
.text:00006368                 mov     [ebp+var_78], edx
.text:0000636B                 mov     eax, [ebp+var_78]
.text:0000636E                 mov     [ebp+var_E8], eax
.text:00006374                 cmp     [ebp+var_E8], 0
.text:0000637B                 jl      short loc_638A
.text:0000637D                 cmp     [ebp+var_E8], 2
.text:00006384                 jle     short loc_6388
.text:00006386                 jmp     short loc_638A
.text:00006388 ; ---------------------------------------------------------------------------
.text:00006388
.text:00006388 loc_6388:                               ; CODE XREF: EnumerateInArchiveItems(NWildcard::CCensor const &,CArc const &,CObjectVector<CArcItem> &)+2B8j
.text:00006388                 jmp     short loc_63C9
.text:0000638A ; ---------------------------------------------------------------------------
.text:0000638A
.text:0000638A loc_638A:                               ; CODE XREF: EnumerateInArchiveItems(NWildcard::CCensor const &,CArc const &,CObjectVector<CArcItem> &)+2AFj
.text:0000638A                                         ; EnumerateInArchiveItems(NWildcard::CCensor const &,CArc const &,CObjectVector<CArcItem> &)+2BAj
.text:0000638A                 mov     [ebp+var_E0], 80004005h
.text:00006394                 mov     byte ptr [ebp+var_4], 1
.text:00006398                 lea     ecx, [ebp+var_C4] ; this
.text:0000639E                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:000063A3                 mov     byte ptr [ebp+var_4], 0
.text:000063A7                 lea     ecx, [ebp+var_A0] ; this
.text:000063AD                 call    ??1CArcItem@@QAE@XZ ; CArcItem::~CArcItem(void)
.text:000063B2                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000063B9                 lea     ecx, [ebp+var_64] ; this
.text:000063BC                 call    ??1CReadArcItem@@QAE@XZ ; CReadArcItem::~CReadArcItem(void)
.text:000063C1                 mov     eax, [ebp+var_E0]
.text:000063C7                 jmp     short loc_6420
.text:000063C9 ; ---------------------------------------------------------------------------
.text:000063C9
.text:000063C9 loc_63C9:                               ; CODE XREF: EnumerateInArchiveItems(NWildcard::CCensor const &,CArc const &,CObjectVector<CArcItem> &)+294j
.text:000063C9                                         ; EnumerateInArchiveItems(NWildcard::CCensor const &,CArc const &,CObjectVector<CArcItem> &):loc_6388j
.text:000063C9                 mov     byte ptr [ebp+var_4], 1
.text:000063CD                 lea     ecx, [ebp+var_C4] ; this
.text:000063D3                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:000063D8                 mov     ecx, [ebp+var_6C]
.text:000063DB                 mov     [ebp+var_7C], ecx
.text:000063DE                 lea     edx, [ebp+var_A0]
.text:000063E4                 push    edx
.text:000063E5                 mov     ecx, [ebp+arg_8]
.text:000063E8                 call    ?AddInReserved@?$CObjectVector@UCArcItem@@@@QAEXABUCArcItem@@@Z ; CObjectVector<CArcItem>::AddInReserved(CArcItem const &)
.text:000063ED                 mov     byte ptr [ebp+var_4], 0
.text:000063F1                 lea     ecx, [ebp+var_A0] ; this
.text:000063F7                 call    ??1CArcItem@@QAE@XZ ; CArcItem::~CArcItem(void)
.text:000063FC                 jmp     loc_616B
.text:00006401 ; ---------------------------------------------------------------------------
.text:00006401
.text:00006401 loc_6401:                               ; CODE XREF: EnumerateInArchiveItems(NWildcard::CCensor const &,CArc const &,CObjectVector<CArcItem> &)+AEj
.text:00006401                 mov     [ebp+var_E4], 0
.text:0000640B                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00006412                 lea     ecx, [ebp+var_64] ; this
.text:00006415                 call    ??1CReadArcItem@@QAE@XZ ; CReadArcItem::~CReadArcItem(void)
.text:0000641A                 mov     eax, [ebp+var_E4]
.text:00006420
.text:00006420 loc_6420:                               ; CODE XREF: EnumerateInArchiveItems(NWildcard::CCensor const &,CArc const &,CObjectVector<CArcItem> &)+76j
.text:00006420                                         ; EnumerateInArchiveItems(NWildcard::CCensor const &,CArc const &,CObjectVector<CArcItem> &)+112j ...
.text:00006420                 push    edx
.text:00006421                 mov     ecx, ebp
.text:00006423                 push    eax
.text:00006424                 lea     edx, $LN25
.text:0000642A                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:0000642F                 pop     eax
.text:00006430                 pop     edx
.text:00006431                 mov     ecx, [ebp+var_C]
.text:00006434                 mov     large fs:0, ecx
.text:0000643B                 pop     ecx
.text:0000643C                 pop     edi
.text:0000643D                 pop     esi
.text:0000643E                 add     esp, 0E8h
.text:00006444                 cmp     ebp, esp
.text:00006446                 call    __RTC_CheckEsp
.text:0000644B                 mov     esp, ebp
.text:0000644D                 pop     ebp
.text:0000644E                 retn    0Ch
.text:0000644E ?EnumerateInArchiveItems@@YGJABVCCensor@NWildcard@@ABVCArc@@AAV?$CObjectVector@UCArcItem@@@@@Z endp
.text:0000644E
.text:0000644E ; ---------------------------------------------------------------------------
.text:00006451                 align 4
.text:00006454 $LN25           dd 4                    ; DATA XREF: EnumerateInArchiveItems(NWildcard::CCensor const &,CArc const &,CObjectVector<CArcItem> &)+358o
.text:00006458                 dd offset $LN24
.text:0000645C $LN24           dd 0FFFFFFECh, 4        ; DATA XREF: .text:00006458o
.text:00006464                 dd offset $LN19         ; "numItems"
.text:00006468                 dd 0FFFFFF9Ch, 40h
.text:00006470                 dd offset $LN20         ; "item"
.text:00006474                 dd 0FFFFFF60h, 30h
.text:0000647C                 dd offset $LN21         ; "ai"
.text:00006480                 dd 0FFFFFF3Ch, 10h
.text:00006488                 dd offset $LN22         ; "prop"
.text:0000648C $LN22           db 'prop',0             ; DATA XREF: .text:00006488o
.text:00006491 $LN21           db 'ai',0               ; DATA XREF: .text:0000647Co
.text:00006494 $LN20           db 'item',0             ; DATA XREF: .text:00006470o
.text:00006499 $LN19           db 'numItems',0         ; DATA XREF: .text:00006464o
.text:000064A2                 db 0Ah dup(0CCh)
.text:000064AC
.text:000064AC ; =============== S U B R O U T I N E =======================================
.text:000064AC
.text:000064AC ; Attributes: bp-based frame
.text:000064AC
.text:000064AC ; int __stdcall Censor_CheckPath(int, struct CReadArcItem *)
.text:000064AC ?Censor_CheckPath@@YG_NABVCCensor@NWildcard@@ABUCReadArcItem@@@Z proc near
.text:000064AC                                         ; CODE XREF: EnumerateInArchiveItems(NWildcard::CCensor const &,CArc const &,CObjectVector<CArcItem> &)+140p
.text:000064AC
.text:000064AC var_14          = dword ptr -14h
.text:000064AC var_10          = byte ptr -10h
.text:000064AC var_C           = dword ptr -0Ch
.text:000064AC var_8           = dword ptr -8
.text:000064AC var_4           = dword ptr -4
.text:000064AC arg_0           = dword ptr  8
.text:000064AC arg_4           = dword ptr  0Ch
.text:000064AC
.text:000064AC                 push    ebp
.text:000064AD                 mov     ebp, esp
.text:000064AF                 sub     esp, 14h
.text:000064B2                 mov     eax, 0CCCCCCCCh
.text:000064B7                 mov     [ebp+var_14], eax
.text:000064BA                 mov     dword ptr [ebp+var_10], eax
.text:000064BD                 mov     [ebp+var_C], eax
.text:000064C0                 mov     [ebp+var_8], eax
.text:000064C3                 mov     [ebp+var_4], eax
.text:000064C6                 mov     byte ptr [ebp+var_4+3], 0
.text:000064CA                 mov     [ebp+var_8], 0
.text:000064D1                 jmp     short loc_64DC
.text:000064D3 ; ---------------------------------------------------------------------------
.text:000064D3
.text:000064D3 loc_64D3:                               ; CODE XREF: Censor_CheckPath(NWildcard::CCensor const &,CReadArcItem const &):loc_651Dj
.text:000064D3                 mov     eax, [ebp+var_8]
.text:000064D6                 add     eax, 1
.text:000064D9                 mov     [ebp+var_8], eax
.text:000064DC
.text:000064DC loc_64DC:                               ; CODE XREF: Censor_CheckPath(NWildcard::CCensor const &,CReadArcItem const &)+25j
.text:000064DC                 mov     ecx, [ebp+arg_0]
.text:000064DF                 call    ?Size@?$CObjectVector@UCPair@NWildcard@@@@QBEIXZ ; CObjectVector<NWildcard::CPair>::Size(void)
.text:000064E4                 cmp     [ebp+var_8], eax
.text:000064E7                 jnb     short loc_651F
.text:000064E9                 lea     ecx, [ebp+var_10+3]
.text:000064EC                 push    ecx             ; bool *
.text:000064ED                 mov     edx, [ebp+arg_4]
.text:000064F0                 push    edx             ; struct CReadArcItem *
.text:000064F1                 mov     eax, [ebp+var_8]
.text:000064F4                 push    eax
.text:000064F5                 mov     ecx, [ebp+arg_0]
.text:000064F8                 call    ??A?$CObjectVector@UCPair@NWildcard@@@@QBEABUCPair@NWildcard@@I@Z ; CObjectVector<NWildcard::CPair>::operator[](uint)
.text:000064FD                 add     eax, 0Ch
.text:00006500                 push    eax             ; struct NWildcard::CCensorNode *
.text:00006501                 call    ?CensorNode_CheckPath2@@YG_NABVCCensorNode@NWildcard@@ABUCReadArcItem@@AA_N@Z ; CensorNode_CheckPath2(NWildcard::CCensorNode const &,CReadArcItem const &,bool &)
.text:00006506                 movzx   ecx, al
.text:00006509                 test    ecx, ecx
.text:0000650B                 jz      short loc_651D
.text:0000650D                 movzx   edx, [ebp+var_10+3]
.text:00006511                 test    edx, edx
.text:00006513                 jnz     short loc_6519
.text:00006515                 xor     al, al
.text:00006517                 jmp     short loc_6522
.text:00006519 ; ---------------------------------------------------------------------------
.text:00006519
.text:00006519 loc_6519:                               ; CODE XREF: Censor_CheckPath(NWildcard::CCensor const &,CReadArcItem const &)+67j
.text:00006519                 mov     byte ptr [ebp+var_4+3], 1
.text:0000651D
.text:0000651D loc_651D:                               ; CODE XREF: Censor_CheckPath(NWildcard::CCensor const &,CReadArcItem const &)+5Fj
.text:0000651D                 jmp     short loc_64D3
.text:0000651F ; ---------------------------------------------------------------------------
.text:0000651F
.text:0000651F loc_651F:                               ; CODE XREF: Censor_CheckPath(NWildcard::CCensor const &,CReadArcItem const &)+3Bj
.text:0000651F                 mov     al, byte ptr [ebp+var_4+3]
.text:00006522
.text:00006522 loc_6522:                               ; CODE XREF: Censor_CheckPath(NWildcard::CCensor const &,CReadArcItem const &)+6Bj
.text:00006522                 push    edx
.text:00006523                 mov     ecx, ebp
.text:00006525                 push    eax
.text:00006526                 lea     edx, $LN10_4
.text:0000652C                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00006531                 pop     eax
.text:00006532                 pop     edx
.text:00006533                 add     esp, 14h
.text:00006536                 cmp     ebp, esp
.text:00006538                 call    __RTC_CheckEsp
.text:0000653D                 mov     esp, ebp
.text:0000653F                 pop     ebp
.text:00006540                 retn    8
.text:00006540 ?Censor_CheckPath@@YG_NABVCCensor@NWildcard@@ABUCReadArcItem@@@Z endp
.text:00006540
.text:00006540 ; ---------------------------------------------------------------------------
.text:00006543                 align 4
.text:00006544 $LN10_4         dd 1                    ; DATA XREF: Censor_CheckPath(NWildcard::CCensor const &,CReadArcItem const &)+7Ao
.text:00006548                 dd offset $LN9_2
.text:0000654C $LN9_2          dd 0FFFFFFF3h, 1        ; DATA XREF: .text:00006548o
.text:00006554                 dd offset $LN8_0        ; "include"
.text:00006558 $LN8_0          db 'include',0          ; DATA XREF: .text:00006554o
.text:00006560                 db 0Ch dup(0CCh)
.text:0000656C
.text:0000656C ; =============== S U B R O U T I N E =======================================
.text:0000656C
.text:0000656C ; Attributes: bp-based frame
.text:0000656C
.text:0000656C ; int __stdcall CompareRefSortPair(struct CRefSortPair const *, struct CRefSortPair const *, void *)
.text:0000656C ?CompareRefSortPair@@YGHPBUCRefSortPair@@0PAX@Z proc near
.text:0000656C                                         ; DATA XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+2535o
.text:0000656C
.text:0000656C var_4           = dword ptr -4
.text:0000656C arg_0           = dword ptr  8
.text:0000656C arg_4           = dword ptr  0Ch
.text:0000656C
.text:0000656C                 push    ebp
.text:0000656D                 mov     ebp, esp
.text:0000656F                 push    ecx
.text:00006570                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00006577                 mov     eax, [ebp+arg_4]
.text:0000657A                 mov     ecx, [eax]
.text:0000657C                 push    ecx
.text:0000657D                 mov     edx, [ebp+arg_0]
.text:00006580                 mov     eax, [edx]
.text:00006582                 push    eax
.text:00006583                 call    ??$MyCompare@I@@YGHII@Z ; MyCompare<uint>(uint,uint)
.text:00006588                 neg     eax
.text:0000658A                 mov     [ebp+var_4], eax
.text:0000658D                 jz      short loc_6594
.text:0000658F                 mov     eax, [ebp+var_4]
.text:00006592                 jmp     short loc_65A7
.text:00006594 ; ---------------------------------------------------------------------------
.text:00006594
.text:00006594 loc_6594:                               ; CODE XREF: CompareRefSortPair(CRefSortPair const *,CRefSortPair const *,void *)+21j
.text:00006594                 mov     ecx, [ebp+arg_4]
.text:00006597                 mov     edx, [ecx+4]
.text:0000659A                 push    edx
.text:0000659B                 mov     eax, [ebp+arg_0]
.text:0000659E                 mov     ecx, [eax+4]
.text:000065A1                 push    ecx
.text:000065A2                 call    ??$MyCompare@I@@YGHII@Z ; MyCompare<uint>(uint,uint)
.text:000065A7
.text:000065A7 loc_65A7:                               ; CODE XREF: CompareRefSortPair(CRefSortPair const *,CRefSortPair const *,void *)+26j
.text:000065A7                 add     esp, 4
.text:000065AA                 cmp     ebp, esp
.text:000065AC                 call    __RTC_CheckEsp
.text:000065B1                 mov     esp, ebp
.text:000065B3                 pop     ebp
.text:000065B4                 retn    0Ch
.text:000065B4 ?CompareRefSortPair@@YGHPBUCRefSortPair@@0PAX@Z endp
.text:000065B4
.text:000065B4 ; ---------------------------------------------------------------------------
.text:000065B7                 db 5 dup(0CCh)
.text:000065BC
.text:000065BC ; =============== S U B R O U T I N E =======================================
.text:000065BC
.text:000065BC ; Attributes: bp-based frame
.text:000065BC
.text:000065BC ; unsigned int __stdcall GetNumSlashes(wchar_t const *)
.text:000065BC ?GetNumSlashes@@YGIPB_W@Z proc near     ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+23A9p
.text:000065BC
.text:000065BC var_8           = dword ptr -8
.text:000065BC var_4           = dword ptr -4
.text:000065BC arg_0           = dword ptr  8
.text:000065BC
.text:000065BC                 push    ebp
.text:000065BD                 mov     ebp, esp
.text:000065BF                 sub     esp, 8
.text:000065C2                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000065C9                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000065D0                 mov     [ebp+var_4], 0
.text:000065D7
.text:000065D7 loc_65D7:                               ; CODE XREF: GetNumSlashes(wchar_t const *):loc_6612j
.text:000065D7                 mov     eax, [ebp+arg_0]
.text:000065DA                 mov     cx, [eax]
.text:000065DD                 mov     word ptr [ebp+var_8], cx
.text:000065E1                 mov     edx, [ebp+arg_0]
.text:000065E4                 add     edx, 2
.text:000065E7                 mov     [ebp+arg_0], edx
.text:000065EA                 movzx   eax, word ptr [ebp+var_8]
.text:000065EE                 test    eax, eax
.text:000065F0                 jnz     short loc_65F7
.text:000065F2                 mov     eax, [ebp+var_4]
.text:000065F5                 jmp     short loc_6614
.text:000065F7 ; ---------------------------------------------------------------------------
.text:000065F7
.text:000065F7 loc_65F7:                               ; CODE XREF: GetNumSlashes(wchar_t const *)+34j
.text:000065F7                 movzx   ecx, word ptr [ebp+var_8]
.text:000065FB                 cmp     ecx, 5Ch ; '\'
.text:000065FE                 jz      short loc_6609
.text:00006600                 movzx   edx, word ptr [ebp+var_8]
.text:00006604                 cmp     edx, 2Fh ; '/'
.text:00006607                 jnz     short loc_6612
.text:00006609
.text:00006609 loc_6609:                               ; CODE XREF: GetNumSlashes(wchar_t const *)+42j
.text:00006609                 mov     eax, [ebp+var_4]
.text:0000660C                 add     eax, 1
.text:0000660F                 mov     [ebp+var_4], eax
.text:00006612
.text:00006612 loc_6612:                               ; CODE XREF: GetNumSlashes(wchar_t const *)+4Bj
.text:00006612                 jmp     short loc_65D7
.text:00006614 ; ---------------------------------------------------------------------------
.text:00006614
.text:00006614 loc_6614:                               ; CODE XREF: GetNumSlashes(wchar_t const *)+39j
.text:00006614                 mov     esp, ebp
.text:00006616                 pop     ebp
.text:00006617                 retn    4
.text:00006617 ?GetNumSlashes@@YGIPB_W@Z endp
.text:00006617
.text:00006617 ; ---------------------------------------------------------------------------
.text:0000661A                 align 4
.text:0000661A _text           ends
.text:0000661A
.rtc$TMZ:0000661C ; ===========================================================================
.rtc$TMZ:0000661C
.rtc$TMZ:0000661C ; Segment type: Pure data
.rtc$TMZ:0000661C ; Segment permissions: Read
.rtc$TMZ:0000661C _rtc$TMZ        segment dword public 'DATA' use32
.rtc$TMZ:0000661C                 assume cs:_rtc$TMZ
.rtc$TMZ:0000661C                 ;org 661Ch
.rtc$TMZ:0000661C ; COMDAT (pick any)
.rtc$TMZ:0000661C __RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
.rtc$TMZ:0000661C _rtc$TMZ        ends
.rtc$TMZ:0000661C
.rtc$IMZ:00006620 ; ===========================================================================
.rtc$IMZ:00006620
.rtc$IMZ:00006620 ; Segment type: Pure data
.rtc$IMZ:00006620 ; Segment permissions: Read
.rtc$IMZ:00006620 _rtc$IMZ        segment dword public 'DATA' use32
.rtc$IMZ:00006620                 assume cs:_rtc$IMZ
.rtc$IMZ:00006620                 ;org 6620h
.rtc$IMZ:00006620 ; COMDAT (pick any)
.rtc$IMZ:00006620 __RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
.rtc$IMZ:00006620 _rtc$IMZ        ends
.rtc$IMZ:00006620
.text:00006624 ; ===========================================================================
.text:00006624
.text:00006624 ; Segment type: Pure code
.text:00006624 ; Segment permissions: Read/Execute
.text:00006624 _text           segment para public 'CODE' use32
.text:00006624                 assume cs:_text
.text:00006624                 ;org 6624h
.text:00006624 ; COMDAT (pick any)
.text:00006624                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00006624
.text:00006624 ; =============== S U B R O U T I N E =======================================
.text:00006624
.text:00006624 ; Attributes: bp-based frame
.text:00006624
.text:00006624 ; __int32 __thiscall CUpdateErrorInfo::Get_HRESULT_Error(CUpdateErrorInfo *__hidden this)
.text:00006624                 public ?Get_HRESULT_Error@CUpdateErrorInfo@@QBEJXZ
.text:00006624 ?Get_HRESULT_Error@CUpdateErrorInfo@@QBEJXZ proc near
.text:00006624                                         ; CODE XREF: CUpdateErrorInfo::SetFromLastError(char const *,UString const &)+2Cp
.text:00006624                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+12FCp ...
.text:00006624
.text:00006624 var_8           = dword ptr -8
.text:00006624 var_4           = dword ptr -4
.text:00006624
.text:00006624                 push    ebp
.text:00006625                 mov     ebp, esp
.text:00006627                 sub     esp, 8
.text:0000662A                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00006631                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00006638                 mov     [ebp+var_4], ecx
.text:0000663B                 mov     eax, [ebp+var_4]
.text:0000663E                 cmp     dword ptr [eax], 0
.text:00006641                 jnz     short loc_664C
.text:00006643                 mov     [ebp+var_8], 80004005h
.text:0000664A                 jmp     short loc_665A
.text:0000664C ; ---------------------------------------------------------------------------
.text:0000664C
.text:0000664C loc_664C:                               ; CODE XREF: CUpdateErrorInfo::Get_HRESULT_Error(void)+1Dj
.text:0000664C                 mov     ecx, [ebp+var_4]
.text:0000664F                 mov     edx, [ecx]
.text:00006651                 push    edx
.text:00006652                 call    _HRESULT_FROM_WIN32@4 ; HRESULT_FROM_WIN32(x)
.text:00006657                 mov     [ebp+var_8], eax
.text:0000665A
.text:0000665A loc_665A:                               ; CODE XREF: CUpdateErrorInfo::Get_HRESULT_Error(void)+26j
.text:0000665A                 mov     eax, [ebp+var_8]
.text:0000665D                 add     esp, 8
.text:00006660                 cmp     ebp, esp
.text:00006662                 call    __RTC_CheckEsp
.text:00006667                 mov     esp, ebp
.text:00006669                 pop     ebp
.text:0000666A                 retn
.text:0000666A ?Get_HRESULT_Error@CUpdateErrorInfo@@QBEJXZ endp
.text:0000666A
.text:0000666A ; ---------------------------------------------------------------------------
.text:0000666B                 align 4
.text:0000666B _text           ends
.text:0000666B
.text:0000666C ; ===========================================================================
.text:0000666C
.text:0000666C ; Segment type: Pure code
.text:0000666C ; Segment permissions: Read/Execute
.text:0000666C _text           segment para public 'CODE' use32
.text:0000666C                 assume cs:_text
.text:0000666C                 ;org 666Ch
.text:0000666C ; COMDAT (pick any)
.text:0000666C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000666C
.text:0000666C ; =============== S U B R O U T I N E =======================================
.text:0000666C
.text:0000666C ; Attributes: bp-based frame
.text:0000666C
.text:0000666C ; __stdcall HRESULT_FROM_WIN32(x)
.text:0000666C                 public _HRESULT_FROM_WIN32@4
.text:0000666C _HRESULT_FROM_WIN32@4 proc near         ; CODE XREF: CUpdateErrorInfo::Get_HRESULT_Error(void)+2Ep
.text:0000666C
.text:0000666C var_4           = dword ptr -4
.text:0000666C arg_0           = dword ptr  8
.text:0000666C
.text:0000666C                 push    ebp
.text:0000666D                 mov     ebp, esp
.text:0000666F                 push    ecx
.text:00006670                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00006677                 cmp     [ebp+arg_0], 0
.text:0000667B                 jg      short loc_6685
.text:0000667D                 mov     eax, [ebp+arg_0]
.text:00006680                 mov     [ebp+var_4], eax
.text:00006683                 jmp     short loc_669D
.text:00006685 ; ---------------------------------------------------------------------------
.text:00006685
.text:00006685 loc_6685:                               ; CODE XREF: HRESULT_FROM_WIN32(x)+Fj
.text:00006685                 mov     ecx, [ebp+arg_0]
.text:00006688                 and     ecx, 0FFFFh
.text:0000668E                 or      ecx, 70000h
.text:00006694                 or      ecx, 80000000h
.text:0000669A                 mov     [ebp+var_4], ecx
.text:0000669D
.text:0000669D loc_669D:                               ; CODE XREF: HRESULT_FROM_WIN32(x)+17j
.text:0000669D                 mov     eax, [ebp+var_4]
.text:000066A0                 mov     esp, ebp
.text:000066A2                 pop     ebp
.text:000066A3                 retn    4
.text:000066A3 _HRESULT_FROM_WIN32@4 endp
.text:000066A3
.text:000066A3 ; ---------------------------------------------------------------------------
.text:000066A6                 align 4
.text:000066A6 _text           ends
.text:000066A6
.text:000066A8 ; ===========================================================================
.text:000066A8
.text:000066A8 ; Segment type: Pure code
.text:000066A8 ; Segment permissions: Read/Execute
.text:000066A8 _text           segment para public 'CODE' use32
.text:000066A8                 assume cs:_text
.text:000066A8                 ;org 66A8h
.text:000066A8 ; COMDAT (pick any)
.text:000066A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000066A8
.text:000066A8 ; =============== S U B R O U T I N E =======================================
.text:000066A8
.text:000066A8 ; Attributes: bp-based frame
.text:000066A8
.text:000066A8 ; bool __thiscall COutFileStream::SetMTime(COutFileStream *this, const struct _FILETIME *)
.text:000066A8                 public ?SetMTime@COutFileStream@@QAE_NPBU_FILETIME@@@Z
.text:000066A8 ?SetMTime@COutFileStream@@QAE_NPBU_FILETIME@@@Z proc near
.text:000066A8                                         ; CODE XREF: COutMultiVolStream::SetMTime(_FILETIME const *)+61p
.text:000066A8                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+1A3Cp
.text:000066A8
.text:000066A8 var_4           = dword ptr -4
.text:000066A8 arg_0           = dword ptr  8
.text:000066A8
.text:000066A8                 push    ebp
.text:000066A9                 mov     ebp, esp
.text:000066AB                 push    ecx
.text:000066AC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000066B3                 mov     [ebp+var_4], ecx
.text:000066B6                 mov     eax, [ebp+arg_0]
.text:000066B9                 push    eax             ; struct _FILETIME *
.text:000066BA                 mov     ecx, [ebp+var_4]
.text:000066BD                 add     ecx, 8          ; this
.text:000066C0                 call    ?SetMTime@COutFile@NIO@NFile@NWindows@@QAE_NPBU_FILETIME@@@Z ; NWindows::NFile::NIO::COutFile::SetMTime(_FILETIME const *)
.text:000066C5                 add     esp, 4
.text:000066C8                 cmp     ebp, esp
.text:000066CA                 call    __RTC_CheckEsp
.text:000066CF                 mov     esp, ebp
.text:000066D1                 pop     ebp
.text:000066D2                 retn    4
.text:000066D2 ?SetMTime@COutFileStream@@QAE_NPBU_FILETIME@@@Z endp
.text:000066D2
.text:000066D2 ; ---------------------------------------------------------------------------
.text:000066D5                 align 4
.text:000066D5 _text           ends
.text:000066D5
.text:000066D8 ; ===========================================================================
.text:000066D8
.text:000066D8 ; Segment type: Pure code
.text:000066D8 ; Segment permissions: Read/Execute
.text:000066D8 _text           segment para public 'CODE' use32
.text:000066D8                 assume cs:_text
.text:000066D8                 ;org 66D8h
.text:000066D8 ; COMDAT (pick any)
.text:000066D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000066D8
.text:000066D8 ; =============== S U B R O U T I N E =======================================
.text:000066D8
.text:000066D8 ; Attributes: bp-based frame
.text:000066D8
.text:000066D8 ; _DWORD __thiscall UString::~UString(UString *__hidden this)
.text:000066D8                 public ??1UString@@QAE@XZ
.text:000066D8 ??1UString@@QAE@XZ proc near            ; CODE XREF: COutMultiVolStream::Write(void const *,uint,uint *)+131p
.text:000066D8                                         ; COutMultiVolStream::Write(void const *,uint,uint *)+192p ...
.text:000066D8
.text:000066D8 var_8           = dword ptr -8
.text:000066D8 var_4           = dword ptr -4
.text:000066D8
.text:000066D8                 push    ebp
.text:000066D9                 mov     ebp, esp
.text:000066DB                 sub     esp, 8
.text:000066DE                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000066E5                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000066EC                 mov     [ebp+var_4], ecx
.text:000066EF                 mov     eax, [ebp+var_4]
.text:000066F2                 mov     ecx, [eax]
.text:000066F4                 mov     [ebp+var_8], ecx
.text:000066F7                 mov     edx, [ebp+var_8]
.text:000066FA                 push    edx             ; void *
.text:000066FB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00006700                 add     esp, 4
.text:00006703                 add     esp, 8
.text:00006706                 cmp     ebp, esp
.text:00006708                 call    __RTC_CheckEsp
.text:0000670D                 mov     esp, ebp
.text:0000670F                 pop     ebp
.text:00006710                 retn
.text:00006710 ??1UString@@QAE@XZ endp
.text:00006710
.text:00006710 ; ---------------------------------------------------------------------------
.text:00006711                 align 4
.text:00006711 _text           ends
.text:00006711
.text:00006714 ; ===========================================================================
.text:00006714
.text:00006714 ; Segment type: Pure code
.text:00006714 ; Segment permissions: Read/Execute
.text:00006714 _text           segment para public 'CODE' use32
.text:00006714                 assume cs:_text
.text:00006714                 ;org 6714h
.text:00006714 ; COMDAT (pick any)
.text:00006714                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00006714
.text:00006714 ; =============== S U B R O U T I N E =======================================
.text:00006714
.text:00006714 ; Attributes: bp-based frame
.text:00006714
.text:00006714 ; unsigned int __thiscall UString::Len(UString *__hidden this)
.text:00006714                 public ?Len@UString@@QBEIXZ
.text:00006714 ?Len@UString@@QBEIXZ proc near          ; CODE XREF: COutMultiVolStream::Write(void const *,uint,uint *)+81p
.text:00006714                                         ; CArchivePath::ParseFromPath(UString const &,EArcNameMode)+A5p ...
.text:00006714
.text:00006714 var_4           = dword ptr -4
.text:00006714
.text:00006714                 push    ebp
.text:00006715                 mov     ebp, esp
.text:00006717                 push    ecx
.text:00006718                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000671F                 mov     [ebp+var_4], ecx
.text:00006722                 mov     eax, [ebp+var_4]
.text:00006725                 mov     eax, [eax+4]
.text:00006728                 mov     esp, ebp
.text:0000672A                 pop     ebp
.text:0000672B                 retn
.text:0000672B ?Len@UString@@QBEIXZ endp
.text:0000672B
.text:0000672B _text           ends
.text:0000672B
.text:0000672C ; ===========================================================================
.text:0000672C
.text:0000672C ; Segment type: Pure code
.text:0000672C ; Segment permissions: Read/Execute
.text:0000672C _text           segment para public 'CODE' use32
.text:0000672C                 assume cs:_text
.text:0000672C                 ;org 672Ch
.text:0000672C ; COMDAT (pick any)
.text:0000672C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000672C
.text:0000672C ; =============== S U B R O U T I N E =======================================
.text:0000672C
.text:0000672C ; Attributes: bp-based frame
.text:0000672C
.text:0000672C ; public: __thiscall UString::operator wchar_t const *(void)const
.text:0000672C                 public ??BUString@@QBEPB_WXZ
.text:0000672C ??BUString@@QBEPB_WXZ proc near         ; CODE XREF: COutMultiVolStream::Write(void const *,uint,uint *)+104p
.text:0000672C                                         ; COutMultiVolStream::SetSize(unsigned __int64)+12Bp ...
.text:0000672C
.text:0000672C var_4           = dword ptr -4
.text:0000672C
.text:0000672C                 push    ebp
.text:0000672D                 mov     ebp, esp
.text:0000672F                 push    ecx
.text:00006730                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00006737                 mov     [ebp+var_4], ecx
.text:0000673A                 mov     eax, [ebp+var_4]
.text:0000673D                 mov     eax, [eax]
.text:0000673F                 mov     esp, ebp
.text:00006741                 pop     ebp
.text:00006742                 retn
.text:00006742 ??BUString@@QBEPB_WXZ endp
.text:00006742
.text:00006742 ; ---------------------------------------------------------------------------
.text:00006743                 align 4
.text:00006743 _text           ends
.text:00006743
.text:00006744 ; ===========================================================================
.text:00006744
.text:00006744 ; Segment type: Pure code
.text:00006744 ; Segment permissions: Read/Execute
.text:00006744 _text           segment para public 'CODE' use32
.text:00006744                 assume cs:_text
.text:00006744                 ;org 6744h
.text:00006744 ; COMDAT (pick any)
.text:00006744                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00006744
.text:00006744 ; =============== S U B R O U T I N E =======================================
.text:00006744
.text:00006744 ; Attributes: bp-based frame
.text:00006744
.text:00006744 ; bool __thiscall COutFileStream::Create(COutFileStream *this, const wchar_t *, bool)
.text:00006744                 public ?Create@COutFileStream@@QAE_NPB_W_N@Z
.text:00006744 ?Create@COutFileStream@@QAE_NPB_W_N@Z proc near
.text:00006744                                         ; CODE XREF: COutMultiVolStream::Write(void const *,uint,uint *)+10Dp
.text:00006744                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+B39p ...
.text:00006744
.text:00006744 var_4           = dword ptr -4
.text:00006744 arg_0           = dword ptr  8
.text:00006744 arg_4           = byte ptr  0Ch
.text:00006744
.text:00006744                 push    ebp
.text:00006745                 mov     ebp, esp
.text:00006747                 push    ecx
.text:00006748                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000674F                 mov     [ebp+var_4], ecx
.text:00006752                 mov     eax, [ebp+var_4]
.text:00006755                 mov     dword ptr [eax+18h], 0
.text:0000675C                 mov     dword ptr [eax+1Ch], 0
.text:00006763                 movzx   ecx, [ebp+arg_4]
.text:00006767                 push    ecx             ; bool
.text:00006768                 mov     edx, [ebp+arg_0]
.text:0000676B                 push    edx             ; wchar_t *
.text:0000676C                 mov     ecx, [ebp+var_4]
.text:0000676F                 add     ecx, 8          ; this
.text:00006772                 call    ?Create@COutFile@NIO@NFile@NWindows@@QAE_NPB_W_N@Z ; NWindows::NFile::NIO::COutFile::Create(wchar_t const *,bool)
.text:00006777                 add     esp, 4
.text:0000677A                 cmp     ebp, esp
.text:0000677C                 call    __RTC_CheckEsp
.text:00006781                 mov     esp, ebp
.text:00006783                 pop     ebp
.text:00006784                 retn    8
.text:00006784 ?Create@COutFileStream@@QAE_NPB_W_N@Z endp
.text:00006784
.text:00006784 ; ---------------------------------------------------------------------------
.text:00006787                 align 4
.text:00006787 _text           ends
.text:00006787
.text:00006788 ; ===========================================================================
.text:00006788
.text:00006788 ; Segment type: Pure code
.text:00006788 ; Segment permissions: Read/Execute
.text:00006788 _text           segment para public 'CODE' use32
.text:00006788                 assume cs:_text
.text:00006788                 ;org 6788h
.text:00006788 ; COMDAT (pick any)
.text:00006788                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00006788
.text:00006788 ; =============== S U B R O U T I N E =======================================
.text:00006788
.text:00006788 ; Attributes: bp-based frame
.text:00006788
.text:00006788 ; _DWORD __thiscall COutMultiVolStream::CAltStreamInfo::CAltStreamInfo(COutMultiVolStream::CAltStreamInfo *__hidden this)
.text:00006788                 public ??0CAltStreamInfo@COutMultiVolStream@@QAE@XZ
.text:00006788 ??0CAltStreamInfo@COutMultiVolStream@@QAE@XZ proc near
.text:00006788                                         ; CODE XREF: COutMultiVolStream::Write(void const *,uint,uint *)+5Ap
.text:00006788
.text:00006788 var_10          = dword ptr -10h
.text:00006788 var_C           = dword ptr -0Ch
.text:00006788 var_4           = dword ptr -4
.text:00006788
.text:00006788                 push    ebp
.text:00006789                 mov     ebp, esp
.text:0000678B                 push    0FFFFFFFFh
.text:0000678D                 push    offset __ehhandler$??0CAltStreamInfo@COutMultiVolStream@@QAE@XZ
.text:00006792                 mov     eax, large fs:0
.text:00006798                 push    eax
.text:00006799                 push    ecx
.text:0000679A                 mov     [ebp+var_10], 0CCCCCCCCh
.text:000067A1                 mov     eax, dword ptr ds:___security_cookie
.text:000067A6                 xor     eax, ebp
.text:000067A8                 push    eax
.text:000067A9                 lea     eax, [ebp+var_C]
.text:000067AC                 mov     large fs:0, eax
.text:000067B2                 mov     [ebp+var_10], ecx
.text:000067B5                 mov     ecx, [ebp+var_10]
.text:000067B8                 add     ecx, 4
.text:000067BB                 call    ??0?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::CMyComPtr<IOutStream>(void)
.text:000067C0                 mov     [ebp+var_4], 0
.text:000067C7                 mov     ecx, [ebp+var_10]
.text:000067CA                 add     ecx, 8
.text:000067CD                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:000067D2                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000067D9                 mov     eax, [ebp+var_10]
.text:000067DC                 mov     ecx, [ebp+var_C]
.text:000067DF                 mov     large fs:0, ecx
.text:000067E6                 pop     ecx
.text:000067E7                 add     esp, 10h
.text:000067EA                 cmp     ebp, esp
.text:000067EC                 call    __RTC_CheckEsp
.text:000067F1                 mov     esp, ebp
.text:000067F3                 pop     ebp
.text:000067F4                 retn
.text:000067F4 ??0CAltStreamInfo@COutMultiVolStream@@QAE@XZ endp
.text:000067F4
.text:000067F4 ; ---------------------------------------------------------------------------
.text:000067F5                 align 4
.text:000067F5 _text           ends
.text:000067F5
.text$x:000067F8 ; ===========================================================================
.text$x:000067F8
.text$x:000067F8 ; Segment type: Pure code
.text$x:000067F8 ; Segment permissions: Read/Execute
.text$x:000067F8 _text$x         segment para public 'CODE' use32
.text$x:000067F8                 assume cs:_text$x
.text$x:000067F8                 ;org 67F8h
.text$x:000067F8 ; COMDAT (pick associative to section at 6788)
.text$x:000067F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000067F8
.text$x:000067F8 ; =============== S U B R O U T I N E =======================================
.text$x:000067F8
.text$x:000067F8
.text$x:000067F8 __unwindfunclet$??0CAltStreamInfo@COutMultiVolStream@@QAE@XZ$0 proc near
.text$x:000067F8                                         ; DATA XREF: .xdata$x:00006824o
.text$x:000067F8                 mov     ecx, [ebp-10h]
.text$x:000067FB                 add     ecx, 4
.text$x:000067FE                 jmp     ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::~CMyComPtr<IOutStream>(void)
.text$x:000067FE __unwindfunclet$??0CAltStreamInfo@COutMultiVolStream@@QAE@XZ$0 endp
.text$x:000067FE
.text$x:00006803
.text$x:00006803 ; =============== S U B R O U T I N E =======================================
.text$x:00006803
.text$x:00006803
.text$x:00006803 __ehhandler$??0CAltStreamInfo@COutMultiVolStream@@QAE@XZ proc near
.text$x:00006803                                         ; DATA XREF: COutMultiVolStream::CAltStreamInfo::CAltStreamInfo(void)+5o
.text$x:00006803
.text$x:00006803 arg_4           = dword ptr  8
.text$x:00006803
.text$x:00006803                 mov     edx, [esp+arg_4]
.text$x:00006807                 lea     eax, [edx+0Ch]
.text$x:0000680A                 mov     ecx, [edx-8]
.text$x:0000680D                 xor     ecx, eax
.text$x:0000680F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006814                 mov     eax, offset __ehfuncinfo$??0CAltStreamInfo@COutMultiVolStream@@QAE@XZ
.text$x:00006819                 jmp     ___CxxFrameHandler3
.text$x:00006819 __ehhandler$??0CAltStreamInfo@COutMultiVolStream@@QAE@XZ endp
.text$x:00006819
.text$x:00006819 ; ---------------------------------------------------------------------------
.text$x:0000681E                 align 10h
.text$x:0000681E _text$x         ends
.text$x:0000681E
.xdata$x:00006820 ; ===========================================================================
.xdata$x:00006820
.xdata$x:00006820 ; Segment type: Pure data
.xdata$x:00006820 ; Segment permissions: Read
.xdata$x:00006820 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006820                 assume cs:_xdata$x
.xdata$x:00006820                 ;org 6820h
.xdata$x:00006820 ; COMDAT (pick associative to section at 6788)
.xdata$x:00006820 __unwindtable$??0CAltStreamInfo@COutMultiVolStream@@QAE@XZ db 0FFh
.xdata$x:00006820                                         ; DATA XREF: .xdata$x:00006830o
.xdata$x:00006821                 db 0FFh
.xdata$x:00006822                 db 0FFh
.xdata$x:00006823                 db 0FFh
.xdata$x:00006824                 dd offset __unwindfunclet$??0CAltStreamInfo@COutMultiVolStream@@QAE@XZ$0
.xdata$x:00006828 __ehfuncinfo$??0CAltStreamInfo@COutMultiVolStream@@QAE@XZ db  22h ; "
.xdata$x:00006828                                         ; DATA XREF: __ehhandler$??0CAltStreamInfo@COutMultiVolStream@@QAE@XZ+11o
.xdata$x:00006829                 db    5
.xdata$x:0000682A                 db  93h ; 
.xdata$x:0000682B                 db  19h
.xdata$x:0000682C                 db    1
.xdata$x:0000682D                 db    0
.xdata$x:0000682E                 db    0
.xdata$x:0000682F                 db    0
.xdata$x:00006830                 dd offset __unwindtable$??0CAltStreamInfo@COutMultiVolStream@@QAE@XZ
.xdata$x:00006834                 db    0
.xdata$x:00006835                 db    0
.xdata$x:00006836                 db    0
.xdata$x:00006837                 db    0
.xdata$x:00006838                 db    0
.xdata$x:00006839                 db    0
.xdata$x:0000683A                 db    0
.xdata$x:0000683B                 db    0
.xdata$x:0000683C                 db    0
.xdata$x:0000683D                 db    0
.xdata$x:0000683E                 db    0
.xdata$x:0000683F                 db    0
.xdata$x:00006840                 db    0
.xdata$x:00006841                 db    0
.xdata$x:00006842                 db    0
.xdata$x:00006843                 db    0
.xdata$x:00006844                 db    0
.xdata$x:00006845                 db    0
.xdata$x:00006846                 db    0
.xdata$x:00006847                 db    0
.xdata$x:00006848                 db    1
.xdata$x:00006849                 db    0
.xdata$x:0000684A                 db    0
.xdata$x:0000684B                 db    0
.xdata$x:0000684B _xdata$x        ends
.xdata$x:0000684B
.text:0000684C ; ===========================================================================
.text:0000684C
.text:0000684C ; Segment type: Pure code
.text:0000684C ; Segment permissions: Read/Execute
.text:0000684C _text           segment para public 'CODE' use32
.text:0000684C                 assume cs:_text
.text:0000684C                 ;org 684Ch
.text:0000684C ; COMDAT (pick any)
.text:0000684C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000684C
.text:0000684C ; =============== S U B R O U T I N E =======================================
.text:0000684C
.text:0000684C ; Attributes: bp-based frame
.text:0000684C
.text:0000684C ; _DWORD __thiscall COutMultiVolStream::CAltStreamInfo::~CAltStreamInfo(COutMultiVolStream::CAltStreamInfo *__hidden this)
.text:0000684C                 public ??1CAltStreamInfo@COutMultiVolStream@@QAE@XZ
.text:0000684C ??1CAltStreamInfo@COutMultiVolStream@@QAE@XZ proc near
.text:0000684C                                         ; CODE XREF: COutMultiVolStream::Write(void const *,uint,uint *)+139p
.text:0000684C                                         ; COutMultiVolStream::Write(void const *,uint,uint *)+19Ap ...
.text:0000684C
.text:0000684C var_10          = dword ptr -10h
.text:0000684C var_C           = dword ptr -0Ch
.text:0000684C var_4           = dword ptr -4
.text:0000684C
.text:0000684C                 push    ebp
.text:0000684D                 mov     ebp, esp
.text:0000684F                 push    0FFFFFFFFh
.text:00006851                 push    offset __ehhandler$??1CAltStreamInfo@COutMultiVolStream@@QAE@XZ
.text:00006856                 mov     eax, large fs:0
.text:0000685C                 push    eax
.text:0000685D                 push    ecx
.text:0000685E                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00006865                 mov     eax, dword ptr ds:___security_cookie
.text:0000686A                 xor     eax, ebp
.text:0000686C                 push    eax
.text:0000686D                 lea     eax, [ebp+var_C]
.text:00006870                 mov     large fs:0, eax
.text:00006876                 mov     [ebp+var_10], ecx
.text:00006879                 mov     [ebp+var_4], 0
.text:00006880                 mov     ecx, [ebp+var_10]
.text:00006883                 add     ecx, 8          ; this
.text:00006886                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000688B                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00006892                 mov     ecx, [ebp+var_10]
.text:00006895                 add     ecx, 4
.text:00006898                 call    ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::~CMyComPtr<IOutStream>(void)
.text:0000689D                 mov     ecx, [ebp+var_C]
.text:000068A0                 mov     large fs:0, ecx
.text:000068A7                 pop     ecx
.text:000068A8                 add     esp, 10h
.text:000068AB                 cmp     ebp, esp
.text:000068AD                 call    __RTC_CheckEsp
.text:000068B2                 mov     esp, ebp
.text:000068B4                 pop     ebp
.text:000068B5                 retn
.text:000068B5 ??1CAltStreamInfo@COutMultiVolStream@@QAE@XZ endp
.text:000068B5
.text:000068B5 ; ---------------------------------------------------------------------------
.text:000068B6                 align 4
.text:000068B6 _text           ends
.text:000068B6
.text$x:000068B8 ; ===========================================================================
.text$x:000068B8
.text$x:000068B8 ; Segment type: Pure code
.text$x:000068B8 ; Segment permissions: Read/Execute
.text$x:000068B8 _text$x         segment para public 'CODE' use32
.text$x:000068B8                 assume cs:_text$x
.text$x:000068B8                 ;org 68B8h
.text$x:000068B8 ; COMDAT (pick associative to section at 684C)
.text$x:000068B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000068B8
.text$x:000068B8 ; =============== S U B R O U T I N E =======================================
.text$x:000068B8
.text$x:000068B8
.text$x:000068B8 __unwindfunclet$??1CAltStreamInfo@COutMultiVolStream@@QAE@XZ$0 proc near
.text$x:000068B8                                         ; DATA XREF: .xdata$x:000068E4o
.text$x:000068B8                 mov     ecx, [ebp-10h]
.text$x:000068BB                 add     ecx, 4
.text$x:000068BE                 jmp     ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::~CMyComPtr<IOutStream>(void)
.text$x:000068BE __unwindfunclet$??1CAltStreamInfo@COutMultiVolStream@@QAE@XZ$0 endp
.text$x:000068BE
.text$x:000068C3
.text$x:000068C3 ; =============== S U B R O U T I N E =======================================
.text$x:000068C3
.text$x:000068C3
.text$x:000068C3 __ehhandler$??1CAltStreamInfo@COutMultiVolStream@@QAE@XZ proc near
.text$x:000068C3                                         ; DATA XREF: COutMultiVolStream::CAltStreamInfo::~CAltStreamInfo(void)+5o
.text$x:000068C3
.text$x:000068C3 arg_4           = dword ptr  8
.text$x:000068C3
.text$x:000068C3                 mov     edx, [esp+arg_4]
.text$x:000068C7                 lea     eax, [edx+0Ch]
.text$x:000068CA                 mov     ecx, [edx-8]
.text$x:000068CD                 xor     ecx, eax
.text$x:000068CF                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000068D4                 mov     eax, offset __ehfuncinfo$??1CAltStreamInfo@COutMultiVolStream@@QAE@XZ
.text$x:000068D9                 jmp     ___CxxFrameHandler3
.text$x:000068D9 __ehhandler$??1CAltStreamInfo@COutMultiVolStream@@QAE@XZ endp
.text$x:000068D9
.text$x:000068D9 ; ---------------------------------------------------------------------------
.text$x:000068DE                 align 10h
.text$x:000068DE _text$x         ends
.text$x:000068DE
.xdata$x:000068E0 ; ===========================================================================
.xdata$x:000068E0
.xdata$x:000068E0 ; Segment type: Pure data
.xdata$x:000068E0 ; Segment permissions: Read
.xdata$x:000068E0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000068E0                 assume cs:_xdata$x
.xdata$x:000068E0                 ;org 68E0h
.xdata$x:000068E0 ; COMDAT (pick associative to section at 684C)
.xdata$x:000068E0 __unwindtable$??1CAltStreamInfo@COutMultiVolStream@@QAE@XZ db 0FFh
.xdata$x:000068E0                                         ; DATA XREF: .xdata$x:000068F0o
.xdata$x:000068E1                 db 0FFh
.xdata$x:000068E2                 db 0FFh
.xdata$x:000068E3                 db 0FFh
.xdata$x:000068E4                 dd offset __unwindfunclet$??1CAltStreamInfo@COutMultiVolStream@@QAE@XZ$0
.xdata$x:000068E8 __ehfuncinfo$??1CAltStreamInfo@COutMultiVolStream@@QAE@XZ db  22h ; "
.xdata$x:000068E8                                         ; DATA XREF: __ehhandler$??1CAltStreamInfo@COutMultiVolStream@@QAE@XZ+11o
.xdata$x:000068E9                 db    5
.xdata$x:000068EA                 db  93h ; 
.xdata$x:000068EB                 db  19h
.xdata$x:000068EC                 db    1
.xdata$x:000068ED                 db    0
.xdata$x:000068EE                 db    0
.xdata$x:000068EF                 db    0
.xdata$x:000068F0                 dd offset __unwindtable$??1CAltStreamInfo@COutMultiVolStream@@QAE@XZ
.xdata$x:000068F4                 db    0
.xdata$x:000068F5                 db    0
.xdata$x:000068F6                 db    0
.xdata$x:000068F7                 db    0
.xdata$x:000068F8                 db    0
.xdata$x:000068F9                 db    0
.xdata$x:000068FA                 db    0
.xdata$x:000068FB                 db    0
.xdata$x:000068FC                 db    0
.xdata$x:000068FD                 db    0
.xdata$x:000068FE                 db    0
.xdata$x:000068FF                 db    0
.xdata$x:00006900                 db    0
.xdata$x:00006901                 db    0
.xdata$x:00006902                 db    0
.xdata$x:00006903                 db    0
.xdata$x:00006904                 db    0
.xdata$x:00006905                 db    0
.xdata$x:00006906                 db    0
.xdata$x:00006907                 db    0
.xdata$x:00006908                 db    1
.xdata$x:00006909                 db    0
.xdata$x:0000690A                 db    0
.xdata$x:0000690B                 db    0
.xdata$x:0000690B _xdata$x        ends
.xdata$x:0000690B
.text:0000690C ; ===========================================================================
.text:0000690C
.text:0000690C ; Segment type: Pure code
.text:0000690C ; Segment permissions: Read/Execute
.text:0000690C _text           segment para public 'CODE' use32
.text:0000690C                 assume cs:_text
.text:0000690C                 ;org 690Ch
.text:0000690C ; COMDAT (pick any)
.text:0000690C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000690C
.text:0000690C ; =============== S U B R O U T I N E =======================================
.text:0000690C
.text:0000690C ; Attributes: bp-based frame
.text:0000690C
.text:0000690C ; public: __thiscall COutFileStream::COutFileStream(void)
.text:0000690C                 public ??0COutFileStream@@QAE@XZ
.text:0000690C ??0COutFileStream@@QAE@XZ proc near     ; CODE XREF: COutMultiVolStream::Write(void const *,uint,uint *)+C7p
.text:0000690C                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+9C1p ...
.text:0000690C
.text:0000690C var_4           = dword ptr -4
.text:0000690C
.text:0000690C                 push    ebp
.text:0000690D                 mov     ebp, esp
.text:0000690F                 push    ecx
.text:00006910                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00006917                 mov     [ebp+var_4], ecx
.text:0000691A                 mov     ecx, [ebp+var_4] ; this
.text:0000691D                 call    ??0IOutStream@@QAE@XZ ; IOutStream::IOutStream(void)
.text:00006922                 mov     ecx, [ebp+var_4]
.text:00006925                 add     ecx, 4          ; this
.text:00006928                 call    ??0CMyUnknownImp@@QAE@XZ ; CMyUnknownImp::CMyUnknownImp(void)
.text:0000692D                 mov     eax, [ebp+var_4]
.text:00006930                 mov     dword ptr [eax], offset ??_7COutFileStream@@6B@ ; const COutFileStream::`vftable'
.text:00006936                 mov     ecx, [ebp+var_4]
.text:00006939                 add     ecx, 8          ; this
.text:0000693C                 call    ??0COutFile@NIO@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NIO::COutFile::COutFile(void)
.text:00006941                 mov     eax, [ebp+var_4]
.text:00006944                 add     esp, 4
.text:00006947                 cmp     ebp, esp
.text:00006949                 call    __RTC_CheckEsp
.text:0000694E                 mov     esp, ebp
.text:00006950                 pop     ebp
.text:00006951                 retn
.text:00006951 ??0COutFileStream@@QAE@XZ endp
.text:00006951
.text:00006951 ; ---------------------------------------------------------------------------
.text:00006952                 align 4
.text:00006952 _text           ends
.text:00006952
.rdata:00006954 ; ===========================================================================
.rdata:00006954
.rdata:00006954 ; Segment type: Pure data
.rdata:00006954 ; Segment permissions: Read
.rdata:00006954 _rdata          segment dword public 'DATA' use32
.rdata:00006954                 assume cs:_rdata
.rdata:00006954                 ;org 6954h
.rdata:00006954 ; COMDAT (pick largest)
.rdata:00006954                 dd offset ??_R4COutFileStream@@6B@ ; const COutFileStream::`RTTI Complete Object Locator'
.rdata:00006958                 public ??_7COutFileStream@@6B@
.rdata:00006958 ; const COutFileStream::`vftable'
.rdata:00006958 ??_7COutFileStream@@6B@ dd offset ?QueryInterface@COutFileStream@@UAGJABU_GUID@@PAPAX@Z
.rdata:00006958                                         ; DATA XREF: COutFileStream::COutFileStream(void)+24o
.rdata:00006958                                         ; COutFileStream::~COutFileStream(void)+11o
.rdata:00006958                                         ; COutFileStream::QueryInterface(_GUID const &,void * *)
.rdata:0000695C                 dd offset ?AddRef@COutFileStream@@UAGKXZ ; COutFileStream::AddRef(void)
.rdata:00006960                 dd offset ?Release@COutFileStream@@UAGKXZ ; COutFileStream::Release(void)
.rdata:00006964                 dd offset ?Write@COutFileStream@@UAGJPBXIPAI@Z ; COutFileStream::Write(void const *,uint,uint *)
.rdata:00006968                 dd offset ?Seek@COutFileStream@@UAGJ_JIPA_K@Z ; COutFileStream::Seek(__int64,uint,unsigned __int64 *)
.rdata:0000696C                 dd offset ?SetSize@COutFileStream@@UAGJ_K@Z ; COutFileStream::SetSize(unsigned __int64)
.rdata:00006970                 dd offset ??_ECOutFileStream@@UAEPAXI@Z ; COutFileStream::`vector deleting destructor'(uint)
.rdata:00006970 _rdata          ends
.rdata:00006970
.rdata$r:00006974 ; ===========================================================================
.rdata$r:00006974
.rdata$r:00006974 ; Segment type: Pure data
.rdata$r:00006974 ; Segment permissions: Read
.rdata$r:00006974 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00006974                 assume cs:_rdata$r
.rdata$r:00006974                 ;org 6974h
.rdata$r:00006974 ; COMDAT (pick any)
.rdata$r:00006974                 public ??_R4COutFileStream@@6B@
.rdata$r:00006974 ; const COutFileStream::`RTTI Complete Object Locator'
.rdata$r:00006974 ??_R4COutFileStream@@6B@ db    0        ; DATA XREF: .rdata:00006954o
.rdata$r:00006975                 db    0
.rdata$r:00006976                 db    0
.rdata$r:00006977                 db    0
.rdata$r:00006978                 db    0
.rdata$r:00006979                 db    0
.rdata$r:0000697A                 db    0
.rdata$r:0000697B                 db    0
.rdata$r:0000697C                 db    0
.rdata$r:0000697D                 db    0
.rdata$r:0000697E                 db    0
.rdata$r:0000697F                 db    0
.rdata$r:00006980                 dd offset ??_R0?AVCOutFileStream@@@8 ; COutFileStream `RTTI Type Descriptor'
.rdata$r:00006984                 dd offset ??_R3COutFileStream@@8 ; COutFileStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00006984 _rdata$r        ends
.rdata$r:00006984
.data:00006988 ; ===========================================================================
.data:00006988
.data:00006988 ; Segment type: Pure data
.data:00006988 ; Segment permissions: Read/Write
.data:00006988 _data           segment dword public 'DATA' use32
.data:00006988                 assume cs:_data
.data:00006988                 ;org 6988h
.data:00006988 ; COMDAT (pick any)
.data:00006988                 public ??_R0?AVCOutFileStream@@@8
.data:00006988 ; class COutFileStream `RTTI Type Descriptor'
.data:00006988 ??_R0?AVCOutFileStream@@@8 dd offset ??_7type_info@@6B@
.data:00006988                                         ; DATA XREF: .rdata$r:00006980o
.data:00006988                                         ; .rdata$r:COutFileStream::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:00006988                                         ; const type_info::`vftable'
.data:0000698C                 align 10h
.data:00006990 a_?avcoutfilest db '.?AVCOutFileStream@@',0
.data:000069A5                 align 4
.data:000069A5 _data           ends
.data:000069A5
.rdata$r:000069A8 ; ===========================================================================
.rdata$r:000069A8
.rdata$r:000069A8 ; Segment type: Pure data
.rdata$r:000069A8 ; Segment permissions: Read
.rdata$r:000069A8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000069A8                 assume cs:_rdata$r
.rdata$r:000069A8                 ;org 69A8h
.rdata$r:000069A8 ; COMDAT (pick any)
.rdata$r:000069A8                 public ??_R3COutFileStream@@8
.rdata$r:000069A8 ; COutFileStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:000069A8 ??_R3COutFileStream@@8 db    0          ; DATA XREF: .rdata$r:00006984o
.rdata$r:000069A8                                         ; .rdata$r:000069E8o
.rdata$r:000069A9                 db    0
.rdata$r:000069AA                 db    0
.rdata$r:000069AB                 db    0
.rdata$r:000069AC                 db    1
.rdata$r:000069AD                 db    0
.rdata$r:000069AE                 db    0
.rdata$r:000069AF                 db    0
.rdata$r:000069B0                 db    5
.rdata$r:000069B1                 db    0
.rdata$r:000069B2                 db    0
.rdata$r:000069B3                 db    0
.rdata$r:000069B4                 dd offset ??_R2COutFileStream@@8 ; COutFileStream::`RTTI Base Class Array'
.rdata$r:000069B4 _rdata$r        ends
.rdata$r:000069B4
.rdata$r:000069B8 ; ===========================================================================
.rdata$r:000069B8
.rdata$r:000069B8 ; Segment type: Pure data
.rdata$r:000069B8 ; Segment permissions: Read
.rdata$r:000069B8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000069B8                 assume cs:_rdata$r
.rdata$r:000069B8                 ;org 69B8h
.rdata$r:000069B8 ; COMDAT (pick any)
.rdata$r:000069B8                 public ??_R2COutFileStream@@8
.rdata$r:000069B8 ; COutFileStream::`RTTI Base Class Array'
.rdata$r:000069B8 ??_R2COutFileStream@@8 dd offset ??_R1A@?0A@EA@COutFileStream@@8
.rdata$r:000069B8                                         ; DATA XREF: .rdata$r:000069B4o
.rdata$r:000069B8                                         ; COutFileStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000069BC                 dd offset ??_R1A@?0A@EA@IOutStream@@8 ; IOutStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000069C0                 dd offset ??_R1A@?0A@EA@ISequentialOutStream@@8 ; ISequentialOutStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000069C4                 dd offset ??_R1A@?0A@EA@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000069C8                 dd offset ??_R13?0A@EA@CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Base Class Descriptor at (4,-1,0,64)'
.rdata$r:000069CC                 db    0
.rdata$r:000069CD                 align 10h
.rdata$r:000069CD _rdata$r        ends
.rdata$r:000069CD
.rdata$r:000069D0 ; ===========================================================================
.rdata$r:000069D0
.rdata$r:000069D0 ; Segment type: Pure data
.rdata$r:000069D0 ; Segment permissions: Read
.rdata$r:000069D0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000069D0                 assume cs:_rdata$r
.rdata$r:000069D0                 ;org 69D0h
.rdata$r:000069D0 ; COMDAT (pick any)
.rdata$r:000069D0                 public ??_R1A@?0A@EA@COutFileStream@@8
.rdata$r:000069D0 ; COutFileStream::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000069D0 ??_R1A@?0A@EA@COutFileStream@@8 dd offset ??_R0?AVCOutFileStream@@@8
.rdata$r:000069D0                                         ; DATA XREF: .rdata$r:COutFileStream::`RTTI Base Class Array'o
.rdata$r:000069D0                                         ; COutFileStream `RTTI Type Descriptor'
.rdata$r:000069D4                 db    4
.rdata$r:000069D5                 db    0
.rdata$r:000069D6                 db    0
.rdata$r:000069D7                 db    0
.rdata$r:000069D8                 db    0
.rdata$r:000069D9                 db    0
.rdata$r:000069DA                 db    0
.rdata$r:000069DB                 db    0
.rdata$r:000069DC                 db 0FFh
.rdata$r:000069DD                 db 0FFh
.rdata$r:000069DE                 db 0FFh
.rdata$r:000069DF                 db 0FFh
.rdata$r:000069E0                 db    0
.rdata$r:000069E1                 db    0
.rdata$r:000069E2                 db    0
.rdata$r:000069E3                 db    0
.rdata$r:000069E4                 db  40h ; @
.rdata$r:000069E5                 db    0
.rdata$r:000069E6                 db    0
.rdata$r:000069E7                 db    0
.rdata$r:000069E8                 dd offset ??_R3COutFileStream@@8 ; COutFileStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:000069E8 _rdata$r        ends
.rdata$r:000069E8
.rdata$r:000069EC ; ===========================================================================
.rdata$r:000069EC
.rdata$r:000069EC ; Segment type: Pure data
.rdata$r:000069EC ; Segment permissions: Read
.rdata$r:000069EC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000069EC                 assume cs:_rdata$r
.rdata$r:000069EC                 ;org 69ECh
.rdata$r:000069EC ; COMDAT (pick any)
.rdata$r:000069EC                 public ??_R1A@?0A@EA@IOutStream@@8
.rdata$r:000069EC ; IOutStream::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000069EC ??_R1A@?0A@EA@IOutStream@@8 dd offset ??_R0?AUIOutStream@@@8
.rdata$r:000069EC                                         ; DATA XREF: .rdata$r:000069BCo
.rdata$r:000069EC                                         ; .rdata$r:IOutStream::`RTTI Base Class Array'o ...
.rdata$r:000069EC                                         ; IOutStream `RTTI Type Descriptor'
.rdata$r:000069F0                 db    2
.rdata$r:000069F1                 db    0
.rdata$r:000069F2                 db    0
.rdata$r:000069F3                 db    0
.rdata$r:000069F4                 db    0
.rdata$r:000069F5                 db    0
.rdata$r:000069F6                 db    0
.rdata$r:000069F7                 db    0
.rdata$r:000069F8                 db 0FFh
.rdata$r:000069F9                 db 0FFh
.rdata$r:000069FA                 db 0FFh
.rdata$r:000069FB                 db 0FFh
.rdata$r:000069FC                 db    0
.rdata$r:000069FD                 db    0
.rdata$r:000069FE                 db    0
.rdata$r:000069FF                 db    0
.rdata$r:00006A00                 db  40h ; @
.rdata$r:00006A01                 db    0
.rdata$r:00006A02                 db    0
.rdata$r:00006A03                 db    0
.rdata$r:00006A04                 dd offset ??_R3IOutStream@@8 ; IOutStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00006A04 _rdata$r        ends
.rdata$r:00006A04
.data:00006A08 ; ===========================================================================
.data:00006A08
.data:00006A08 ; Segment type: Pure data
.data:00006A08 ; Segment permissions: Read/Write
.data:00006A08 _data           segment dword public 'DATA' use32
.data:00006A08                 assume cs:_data
.data:00006A08                 ;org 6A08h
.data:00006A08 ; COMDAT (pick any)
.data:00006A08                 public ??_R0?AUIOutStream@@@8
.data:00006A08 ; struct IOutStream `RTTI Type Descriptor'
.data:00006A08 ??_R0?AUIOutStream@@@8 dd offset ??_7type_info@@6B@
.data:00006A08                                         ; DATA XREF: .rdata$r:IOutStream::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:00006A08                                         ; .rdata$r:00006DE4o
.data:00006A08                                         ; const type_info::`vftable'
.data:00006A0C                 align 10h
.data:00006A10 a_?auioutstream db '.?AUIOutStream@@',0
.data:00006A21                 align 4
.data:00006A21 _data           ends
.data:00006A21
.rdata$r:00006A24 ; ===========================================================================
.rdata$r:00006A24
.rdata$r:00006A24 ; Segment type: Pure data
.rdata$r:00006A24 ; Segment permissions: Read
.rdata$r:00006A24 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00006A24                 assume cs:_rdata$r
.rdata$r:00006A24                 ;org 6A24h
.rdata$r:00006A24 ; COMDAT (pick any)
.rdata$r:00006A24                 public ??_R3IOutStream@@8
.rdata$r:00006A24 ; IOutStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00006A24 ??_R3IOutStream@@8 db    0              ; DATA XREF: .rdata$r:00006A04o
.rdata$r:00006A24                                         ; .rdata$r:00006DE8o
.rdata$r:00006A25                 db    0
.rdata$r:00006A26                 db    0
.rdata$r:00006A27                 db    0
.rdata$r:00006A28                 db    0
.rdata$r:00006A29                 db    0
.rdata$r:00006A2A                 db    0
.rdata$r:00006A2B                 db    0
.rdata$r:00006A2C                 db    3
.rdata$r:00006A2D                 db    0
.rdata$r:00006A2E                 db    0
.rdata$r:00006A2F                 db    0
.rdata$r:00006A30                 dd offset ??_R2IOutStream@@8 ; IOutStream::`RTTI Base Class Array'
.rdata$r:00006A30 _rdata$r        ends
.rdata$r:00006A30
.rdata$r:00006A34 ; ===========================================================================
.rdata$r:00006A34
.rdata$r:00006A34 ; Segment type: Pure data
.rdata$r:00006A34 ; Segment permissions: Read
.rdata$r:00006A34 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00006A34                 assume cs:_rdata$r
.rdata$r:00006A34                 ;org 6A34h
.rdata$r:00006A34 ; COMDAT (pick any)
.rdata$r:00006A34                 public ??_R2IOutStream@@8
.rdata$r:00006A34 ; IOutStream::`RTTI Base Class Array'
.rdata$r:00006A34 ??_R2IOutStream@@8 dd offset ??_R1A@?0A@EA@IOutStream@@8
.rdata$r:00006A34                                         ; DATA XREF: .rdata$r:00006A30o
.rdata$r:00006A34                                         ; IOutStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00006A38                 dd offset ??_R1A@?0A@EA@ISequentialOutStream@@8 ; ISequentialOutStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00006A3C                 dd offset ??_R1A@?0A@EA@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00006A40                 db    0
.rdata$r:00006A41                 align 4
.rdata$r:00006A41 _rdata$r        ends
.rdata$r:00006A41
.rdata$r:00006A44 ; ===========================================================================
.rdata$r:00006A44
.rdata$r:00006A44 ; Segment type: Pure data
.rdata$r:00006A44 ; Segment permissions: Read
.rdata$r:00006A44 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00006A44                 assume cs:_rdata$r
.rdata$r:00006A44                 ;org 6A44h
.rdata$r:00006A44 ; COMDAT (pick any)
.rdata$r:00006A44                 public ??_R1A@?0A@EA@ISequentialOutStream@@8
.rdata$r:00006A44 ; ISequentialOutStream::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00006A44 ??_R1A@?0A@EA@ISequentialOutStream@@8 dd offset ??_R0?AUISequentialOutStream@@@8
.rdata$r:00006A44                                         ; DATA XREF: .rdata$r:000069C0o
.rdata$r:00006A44                                         ; .rdata$r:00006A38o ...
.rdata$r:00006A44                                         ; ISequentialOutStream `RTTI Type Descriptor'
.rdata$r:00006A48                 db    1
.rdata$r:00006A49                 db    0
.rdata$r:00006A4A                 db    0
.rdata$r:00006A4B                 db    0
.rdata$r:00006A4C                 db    0
.rdata$r:00006A4D                 db    0
.rdata$r:00006A4E                 db    0
.rdata$r:00006A4F                 db    0
.rdata$r:00006A50                 db 0FFh
.rdata$r:00006A51                 db 0FFh
.rdata$r:00006A52                 db 0FFh
.rdata$r:00006A53                 db 0FFh
.rdata$r:00006A54                 db    0
.rdata$r:00006A55                 db    0
.rdata$r:00006A56                 db    0
.rdata$r:00006A57                 db    0
.rdata$r:00006A58                 db  40h ; @
.rdata$r:00006A59                 db    0
.rdata$r:00006A5A                 db    0
.rdata$r:00006A5B                 db    0
.rdata$r:00006A5C                 dd offset ??_R3ISequentialOutStream@@8 ; ISequentialOutStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00006A5C _rdata$r        ends
.rdata$r:00006A5C
.data:00006A60 ; ===========================================================================
.data:00006A60
.data:00006A60 ; Segment type: Pure data
.data:00006A60 ; Segment permissions: Read/Write
.data:00006A60 _data           segment dword public 'DATA' use32
.data:00006A60                 assume cs:_data
.data:00006A60                 ;org 6A60h
.data:00006A60 ; COMDAT (pick any)
.data:00006A60                 public ??_R0?AUISequentialOutStream@@@8
.data:00006A60 ; struct ISequentialOutStream `RTTI Type Descriptor'
.data:00006A60 ??_R0?AUISequentialOutStream@@@8 dd offset ??_7type_info@@6B@
.data:00006A60                                         ; DATA XREF: .rdata$r:ISequentialOutStream::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:00006A60                                         ; .rdata$r:00006E3Co
.data:00006A60                                         ; const type_info::`vftable'
.data:00006A64                 align 8
.data:00006A68 a_?auisequentia db '.?AUISequentialOutStream@@',0
.data:00006A83                 align 4
.data:00006A83 _data           ends
.data:00006A83
.rdata$r:00006A84 ; ===========================================================================
.rdata$r:00006A84
.rdata$r:00006A84 ; Segment type: Pure data
.rdata$r:00006A84 ; Segment permissions: Read
.rdata$r:00006A84 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00006A84                 assume cs:_rdata$r
.rdata$r:00006A84                 ;org 6A84h
.rdata$r:00006A84 ; COMDAT (pick any)
.rdata$r:00006A84                 public ??_R3ISequentialOutStream@@8
.rdata$r:00006A84 ; ISequentialOutStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00006A84 ??_R3ISequentialOutStream@@8 db    0    ; DATA XREF: .rdata$r:00006A5Co
.rdata$r:00006A84                                         ; .rdata$r:00006E40o
.rdata$r:00006A85                 db    0
.rdata$r:00006A86                 db    0
.rdata$r:00006A87                 db    0
.rdata$r:00006A88                 db    0
.rdata$r:00006A89                 db    0
.rdata$r:00006A8A                 db    0
.rdata$r:00006A8B                 db    0
.rdata$r:00006A8C                 db    2
.rdata$r:00006A8D                 db    0
.rdata$r:00006A8E                 db    0
.rdata$r:00006A8F                 db    0
.rdata$r:00006A90                 dd offset ??_R2ISequentialOutStream@@8 ; ISequentialOutStream::`RTTI Base Class Array'
.rdata$r:00006A90 _rdata$r        ends
.rdata$r:00006A90
.rdata$r:00006A94 ; ===========================================================================
.rdata$r:00006A94
.rdata$r:00006A94 ; Segment type: Pure data
.rdata$r:00006A94 ; Segment permissions: Read
.rdata$r:00006A94 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00006A94                 assume cs:_rdata$r
.rdata$r:00006A94                 ;org 6A94h
.rdata$r:00006A94 ; COMDAT (pick any)
.rdata$r:00006A94                 public ??_R2ISequentialOutStream@@8
.rdata$r:00006A94 ; ISequentialOutStream::`RTTI Base Class Array'
.rdata$r:00006A94 ??_R2ISequentialOutStream@@8 dd offset ??_R1A@?0A@EA@ISequentialOutStream@@8
.rdata$r:00006A94                                         ; DATA XREF: .rdata$r:00006A90o
.rdata$r:00006A94                                         ; ISequentialOutStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00006A98                 dd offset ??_R1A@?0A@EA@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00006A9C                 db    0
.rdata$r:00006A9D                 align 10h
.rdata$r:00006A9D _rdata$r        ends
.rdata$r:00006A9D
.rdata$r:00006AA0 ; ===========================================================================
.rdata$r:00006AA0
.rdata$r:00006AA0 ; Segment type: Pure data
.rdata$r:00006AA0 ; Segment permissions: Read
.rdata$r:00006AA0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00006AA0                 assume cs:_rdata$r
.rdata$r:00006AA0                 ;org 6AA0h
.rdata$r:00006AA0 ; COMDAT (pick any)
.rdata$r:00006AA0                 public ??_R1A@?0A@EA@IUnknown@@8
.rdata$r:00006AA0 ; IUnknown::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00006AA0 ??_R1A@?0A@EA@IUnknown@@8 dd offset ??_R0?AUIUnknown@@@8
.rdata$r:00006AA0                                         ; DATA XREF: .rdata$r:000069C4o
.rdata$r:00006AA0                                         ; .rdata$r:00006A3Co ...
.rdata$r:00006AA0                                         ; IUnknown `RTTI Type Descriptor'
.rdata$r:00006AA4                 db    0
.rdata$r:00006AA5                 db    0
.rdata$r:00006AA6                 db    0
.rdata$r:00006AA7                 db    0
.rdata$r:00006AA8                 db    0
.rdata$r:00006AA9                 db    0
.rdata$r:00006AAA                 db    0
.rdata$r:00006AAB                 db    0
.rdata$r:00006AAC                 db 0FFh
.rdata$r:00006AAD                 db 0FFh
.rdata$r:00006AAE                 db 0FFh
.rdata$r:00006AAF                 db 0FFh
.rdata$r:00006AB0                 db    0
.rdata$r:00006AB1                 db    0
.rdata$r:00006AB2                 db    0
.rdata$r:00006AB3                 db    0
.rdata$r:00006AB4                 db  40h ; @
.rdata$r:00006AB5                 db    0
.rdata$r:00006AB6                 db    0
.rdata$r:00006AB7                 db    0
.rdata$r:00006AB8                 dd offset ??_R3IUnknown@@8 ; IUnknown::`RTTI Class Hierarchy Descriptor'
.rdata$r:00006AB8 _rdata$r        ends
.rdata$r:00006AB8
.data:00006ABC ; ===========================================================================
.data:00006ABC
.data:00006ABC ; Segment type: Pure data
.data:00006ABC ; Segment permissions: Read/Write
.data:00006ABC _data           segment dword public 'DATA' use32
.data:00006ABC                 assume cs:_data
.data:00006ABC                 ;org 6ABCh
.data:00006ABC ; COMDAT (pick any)
.data:00006ABC                 public ??_R0?AUIUnknown@@@8
.data:00006ABC ; struct IUnknown `RTTI Type Descriptor'
.data:00006ABC ??_R0?AUIUnknown@@@8 dd offset ??_7type_info@@6B@
.data:00006ABC                                         ; DATA XREF: .rdata$r:IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:00006ABC                                         ; const type_info::`vftable'
.data:00006AC0                 db    0
.data:00006AC1                 db    0
.data:00006AC2                 db    0
.data:00006AC3                 db    0
.data:00006AC4                 db  2Eh ; .
.data:00006AC5                 db  3Fh ; ?
.data:00006AC6                 db  41h ; A
.data:00006AC7                 db  55h ; U
.data:00006AC8                 db  49h ; I
.data:00006AC9                 db  55h ; U
.data:00006ACA                 db  6Eh ; n
.data:00006ACB                 db  6Bh ; k
.data:00006ACC                 db  6Eh ; n
.data:00006ACD                 db  6Fh ; o
.data:00006ACE                 db  77h ; w
.data:00006ACF                 db  6Eh ; n
.data:00006AD0                 db  40h ; @
.data:00006AD1                 db  40h ; @
.data:00006AD2                 db    0
.data:00006AD3                 align 4
.data:00006AD3 _data           ends
.data:00006AD3
.rdata$r:00006AD4 ; ===========================================================================
.rdata$r:00006AD4
.rdata$r:00006AD4 ; Segment type: Pure data
.rdata$r:00006AD4 ; Segment permissions: Read
.rdata$r:00006AD4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00006AD4                 assume cs:_rdata$r
.rdata$r:00006AD4                 ;org 6AD4h
.rdata$r:00006AD4 ; COMDAT (pick any)
.rdata$r:00006AD4                 public ??_R3IUnknown@@8
.rdata$r:00006AD4 ; IUnknown::`RTTI Class Hierarchy Descriptor'
.rdata$r:00006AD4 ??_R3IUnknown@@8 db    0                ; DATA XREF: .rdata$r:00006AB8o
.rdata$r:00006AD5                 db    0
.rdata$r:00006AD6                 db    0
.rdata$r:00006AD7                 db    0
.rdata$r:00006AD8                 db    0
.rdata$r:00006AD9                 db    0
.rdata$r:00006ADA                 db    0
.rdata$r:00006ADB                 db    0
.rdata$r:00006ADC                 db    1
.rdata$r:00006ADD                 db    0
.rdata$r:00006ADE                 db    0
.rdata$r:00006ADF                 db    0
.rdata$r:00006AE0                 dd offset ??_R2IUnknown@@8 ; IUnknown::`RTTI Base Class Array'
.rdata$r:00006AE0 _rdata$r        ends
.rdata$r:00006AE0
.rdata$r:00006AE4 ; ===========================================================================
.rdata$r:00006AE4
.rdata$r:00006AE4 ; Segment type: Pure data
.rdata$r:00006AE4 ; Segment permissions: Read
.rdata$r:00006AE4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00006AE4                 assume cs:_rdata$r
.rdata$r:00006AE4                 ;org 6AE4h
.rdata$r:00006AE4 ; COMDAT (pick any)
.rdata$r:00006AE4                 public ??_R2IUnknown@@8
.rdata$r:00006AE4 ; IUnknown::`RTTI Base Class Array'
.rdata$r:00006AE4 ??_R2IUnknown@@8 dd offset ??_R1A@?0A@EA@IUnknown@@8
.rdata$r:00006AE4                                         ; DATA XREF: .rdata$r:00006AE0o
.rdata$r:00006AE4                                         ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00006AE8                 db    0
.rdata$r:00006AE9                 align 4
.rdata$r:00006AE9 _rdata$r        ends
.rdata$r:00006AE9
.rdata$r:00006AEC ; ===========================================================================
.rdata$r:00006AEC
.rdata$r:00006AEC ; Segment type: Pure data
.rdata$r:00006AEC ; Segment permissions: Read
.rdata$r:00006AEC _rdata$r        segment dword public 'DATA' use32
.rdata$r:00006AEC                 assume cs:_rdata$r
.rdata$r:00006AEC                 ;org 6AECh
.rdata$r:00006AEC ; COMDAT (pick any)
.rdata$r:00006AEC                 public ??_R13?0A@EA@CMyUnknownImp@@8
.rdata$r:00006AEC ; CMyUnknownImp::`RTTI Base Class Descriptor at (4, -1, 0, 64)'
.rdata$r:00006AEC ??_R13?0A@EA@CMyUnknownImp@@8 dd offset ??_R0?AVCMyUnknownImp@@@8
.rdata$r:00006AEC                                         ; DATA XREF: .rdata$r:000069C8o
.rdata$r:00006AEC                                         ; .rdata$r:00008BF0o ...
.rdata$r:00006AEC                                         ; CMyUnknownImp `RTTI Type Descriptor'
.rdata$r:00006AF0                 db    0
.rdata$r:00006AF1                 db    0
.rdata$r:00006AF2                 db    0
.rdata$r:00006AF3                 db    0
.rdata$r:00006AF4                 db    4
.rdata$r:00006AF5                 db    0
.rdata$r:00006AF6                 db    0
.rdata$r:00006AF7                 db    0
.rdata$r:00006AF8                 db 0FFh
.rdata$r:00006AF9                 db 0FFh
.rdata$r:00006AFA                 db 0FFh
.rdata$r:00006AFB                 db 0FFh
.rdata$r:00006AFC                 db    0
.rdata$r:00006AFD                 db    0
.rdata$r:00006AFE                 db    0
.rdata$r:00006AFF                 db    0
.rdata$r:00006B00                 db  40h ; @
.rdata$r:00006B01                 db    0
.rdata$r:00006B02                 db    0
.rdata$r:00006B03                 db    0
.rdata$r:00006B04                 dd offset ??_R3CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Class Hierarchy Descriptor'
.rdata$r:00006B04 _rdata$r        ends
.rdata$r:00006B04
.data:00006B08 ; ===========================================================================
.data:00006B08
.data:00006B08 ; Segment type: Pure data
.data:00006B08 ; Segment permissions: Read/Write
.data:00006B08 _data           segment dword public 'DATA' use32
.data:00006B08                 assume cs:_data
.data:00006B08                 ;org 6B08h
.data:00006B08 ; COMDAT (pick any)
.data:00006B08                 public ??_R0?AVCMyUnknownImp@@@8
.data:00006B08 ; class CMyUnknownImp `RTTI Type Descriptor'
.data:00006B08 ??_R0?AVCMyUnknownImp@@@8 dd offset ??_7type_info@@6B@
.data:00006B08                                         ; DATA XREF: .rdata$r:CMyUnknownImp::`RTTI Base Class Descriptor at (4,-1,0,64)'o
.data:00006B08                                         ; .rdata$r:CMyUnknownImp::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:00006B08                                         ; const type_info::`vftable'
.data:00006B0C                 align 10h
.data:00006B10 a_?avcmyunknown db '.?AVCMyUnknownImp@@',0
.data:00006B10 _data           ends
.data:00006B10
.rdata$r:00006B24 ; ===========================================================================
.rdata$r:00006B24
.rdata$r:00006B24 ; Segment type: Pure data
.rdata$r:00006B24 ; Segment permissions: Read
.rdata$r:00006B24 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00006B24                 assume cs:_rdata$r
.rdata$r:00006B24                 ;org 6B24h
.rdata$r:00006B24 ; COMDAT (pick any)
.rdata$r:00006B24                 public ??_R3CMyUnknownImp@@8
.rdata$r:00006B24 ; CMyUnknownImp::`RTTI Class Hierarchy Descriptor'
.rdata$r:00006B24 ??_R3CMyUnknownImp@@8 db    0           ; DATA XREF: .rdata$r:00006B04o
.rdata$r:00006B24                                         ; .rdata$r:00006B54o
.rdata$r:00006B25                 db    0
.rdata$r:00006B26                 db    0
.rdata$r:00006B27                 db    0
.rdata$r:00006B28                 db    0
.rdata$r:00006B29                 db    0
.rdata$r:00006B2A                 db    0
.rdata$r:00006B2B                 db    0
.rdata$r:00006B2C                 db    1
.rdata$r:00006B2D                 db    0
.rdata$r:00006B2E                 db    0
.rdata$r:00006B2F                 db    0
.rdata$r:00006B30                 dd offset ??_R2CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Base Class Array'
.rdata$r:00006B30 _rdata$r        ends
.rdata$r:00006B30
.rdata$r:00006B34 ; ===========================================================================
.rdata$r:00006B34
.rdata$r:00006B34 ; Segment type: Pure data
.rdata$r:00006B34 ; Segment permissions: Read
.rdata$r:00006B34 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00006B34                 assume cs:_rdata$r
.rdata$r:00006B34                 ;org 6B34h
.rdata$r:00006B34 ; COMDAT (pick any)
.rdata$r:00006B34                 public ??_R2CMyUnknownImp@@8
.rdata$r:00006B34 ; CMyUnknownImp::`RTTI Base Class Array'
.rdata$r:00006B34 ??_R2CMyUnknownImp@@8 dd offset ??_R1A@?0A@EA@CMyUnknownImp@@8
.rdata$r:00006B34                                         ; DATA XREF: .rdata$r:00006B30o
.rdata$r:00006B34                                         ; CMyUnknownImp::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00006B38                 db    0
.rdata$r:00006B39                 align 4
.rdata$r:00006B39 _rdata$r        ends
.rdata$r:00006B39
.rdata$r:00006B3C ; ===========================================================================
.rdata$r:00006B3C
.rdata$r:00006B3C ; Segment type: Pure data
.rdata$r:00006B3C ; Segment permissions: Read
.rdata$r:00006B3C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00006B3C                 assume cs:_rdata$r
.rdata$r:00006B3C                 ;org 6B3Ch
.rdata$r:00006B3C ; COMDAT (pick any)
.rdata$r:00006B3C                 public ??_R1A@?0A@EA@CMyUnknownImp@@8
.rdata$r:00006B3C ; CMyUnknownImp::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00006B3C ??_R1A@?0A@EA@CMyUnknownImp@@8 dd offset ??_R0?AVCMyUnknownImp@@@8
.rdata$r:00006B3C                                         ; DATA XREF: .rdata$r:CMyUnknownImp::`RTTI Base Class Array'o
.rdata$r:00006B3C                                         ; CMyUnknownImp `RTTI Type Descriptor'
.rdata$r:00006B40                 db    0
.rdata$r:00006B41                 db    0
.rdata$r:00006B42                 db    0
.rdata$r:00006B43                 db    0
.rdata$r:00006B44                 db    0
.rdata$r:00006B45                 db    0
.rdata$r:00006B46                 db    0
.rdata$r:00006B47                 db    0
.rdata$r:00006B48                 db 0FFh
.rdata$r:00006B49                 db 0FFh
.rdata$r:00006B4A                 db 0FFh
.rdata$r:00006B4B                 db 0FFh
.rdata$r:00006B4C                 db    0
.rdata$r:00006B4D                 db    0
.rdata$r:00006B4E                 db    0
.rdata$r:00006B4F                 db    0
.rdata$r:00006B50                 db  40h ; @
.rdata$r:00006B51                 db    0
.rdata$r:00006B52                 db    0
.rdata$r:00006B53                 db    0
.rdata$r:00006B54                 dd offset ??_R3CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Class Hierarchy Descriptor'
.rdata$r:00006B54 _rdata$r        ends
.rdata$r:00006B54
.text:00006B58 ; ===========================================================================
.text:00006B58
.text:00006B58 ; Segment type: Pure code
.text:00006B58 ; Segment permissions: Read/Execute
.text:00006B58 _text           segment para public 'CODE' use32
.text:00006B58                 assume cs:_text
.text:00006B58                 ;org 6B58h
.text:00006B58 ; COMDAT (pick any)
.text:00006B58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00006B58
.text:00006B58 ; =============== S U B R O U T I N E =======================================
.text:00006B58
.text:00006B58 ; Attributes: bp-based frame
.text:00006B58
.text:00006B58 ; _DWORD __thiscall CMyUnknownImp::CMyUnknownImp(CMyUnknownImp *__hidden this)
.text:00006B58                 public ??0CMyUnknownImp@@QAE@XZ
.text:00006B58 ??0CMyUnknownImp@@QAE@XZ proc near      ; CODE XREF: COutFileStream::COutFileStream(void)+1Cp
.text:00006B58                                         ; CStdOutFileStream::CStdOutFileStream(void)+1Cp ...
.text:00006B58
.text:00006B58 var_4           = dword ptr -4
.text:00006B58
.text:00006B58                 push    ebp
.text:00006B59                 mov     ebp, esp
.text:00006B5B                 push    ecx
.text:00006B5C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00006B63                 mov     [ebp+var_4], ecx
.text:00006B66                 mov     eax, [ebp+var_4]
.text:00006B69                 mov     dword ptr [eax], 0
.text:00006B6F                 mov     eax, [ebp+var_4]
.text:00006B72                 mov     esp, ebp
.text:00006B74                 pop     ebp
.text:00006B75                 retn
.text:00006B75 ??0CMyUnknownImp@@QAE@XZ endp
.text:00006B75
.text:00006B75 ; ---------------------------------------------------------------------------
.text:00006B76                 align 4
.text:00006B76 _text           ends
.text:00006B76
.text:00006B78 ; ===========================================================================
.text:00006B78
.text:00006B78 ; Segment type: Pure code
.text:00006B78 ; Segment permissions: Read/Execute
.text:00006B78 _text           segment para public 'CODE' use32
.text:00006B78                 assume cs:_text
.text:00006B78                 ;org 6B78h
.text:00006B78 ; COMDAT (pick any)
.text:00006B78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00006B78
.text:00006B78 ; =============== S U B R O U T I N E =======================================
.text:00006B78
.text:00006B78 ; Attributes: bp-based frame
.text:00006B78
.text:00006B78 ; __int32 __stdcall COutFileStream::QueryInterface(COutFileStream *this, const struct _GUID *Buf1, void **)
.text:00006B78                 public ?QueryInterface@COutFileStream@@UAGJABU_GUID@@PAPAX@Z
.text:00006B78 ?QueryInterface@COutFileStream@@UAGJABU_GUID@@PAPAX@Z proc near
.text:00006B78                                         ; DATA XREF: .rdata:const COutFileStream::`vftable'o
.text:00006B78
.text:00006B78 this            = dword ptr  8
.text:00006B78 Buf1            = dword ptr  0Ch
.text:00006B78 arg_8           = dword ptr  10h
.text:00006B78
.text:00006B78                 push    ebp
.text:00006B79                 mov     ebp, esp
.text:00006B7B                 mov     eax, [ebp+arg_8]
.text:00006B7E                 mov     dword ptr [eax], 0
.text:00006B84                 push    offset _IID_IUnknown ; Buf2
.text:00006B89                 mov     ecx, [ebp+Buf1]
.text:00006B8C                 push    ecx             ; Buf1
.text:00006B8D                 call    ___@8           ; __(x,x)
.text:00006B92                 test    eax, eax
.text:00006B94                 jz      short loc_6BA0
.text:00006B96                 mov     edx, [ebp+arg_8]
.text:00006B99                 mov     eax, [ebp+this]
.text:00006B9C                 mov     [edx], eax
.text:00006B9E                 jmp     short loc_6BC3
.text:00006BA0 ; ---------------------------------------------------------------------------
.text:00006BA0
.text:00006BA0 loc_6BA0:                               ; CODE XREF: COutFileStream::QueryInterface(_GUID const &,void * *)+1Cj
.text:00006BA0                 push    offset _IID_IOutStream ; Buf2
.text:00006BA5                 mov     ecx, [ebp+Buf1]
.text:00006BA8                 push    ecx             ; Buf1
.text:00006BA9                 call    ___@8           ; __(x,x)
.text:00006BAE                 test    eax, eax
.text:00006BB0                 jz      short loc_6BBC
.text:00006BB2                 mov     edx, [ebp+arg_8]
.text:00006BB5                 mov     eax, [ebp+this]
.text:00006BB8                 mov     [edx], eax
.text:00006BBA                 jmp     short loc_6BC3
.text:00006BBC ; ---------------------------------------------------------------------------
.text:00006BBC
.text:00006BBC loc_6BBC:                               ; CODE XREF: COutFileStream::QueryInterface(_GUID const &,void * *)+38j
.text:00006BBC                 mov     eax, 80004002h
.text:00006BC1                 jmp     short loc_6BD4
.text:00006BC3 ; ---------------------------------------------------------------------------
.text:00006BC3
.text:00006BC3 loc_6BC3:                               ; CODE XREF: COutFileStream::QueryInterface(_GUID const &,void * *)+26j
.text:00006BC3                                         ; COutFileStream::QueryInterface(_GUID const &,void * *)+42j
.text:00006BC3                 mov     ecx, [ebp+this]
.text:00006BC6                 mov     edx, [ecx+4]
.text:00006BC9                 add     edx, 1
.text:00006BCC                 mov     eax, [ebp+this]
.text:00006BCF                 mov     [eax+4], edx
.text:00006BD2                 xor     eax, eax
.text:00006BD4
.text:00006BD4 loc_6BD4:                               ; CODE XREF: COutFileStream::QueryInterface(_GUID const &,void * *)+49j
.text:00006BD4                 cmp     ebp, esp
.text:00006BD6                 call    __RTC_CheckEsp
.text:00006BDB                 pop     ebp
.text:00006BDC                 retn    0Ch
.text:00006BDC ?QueryInterface@COutFileStream@@UAGJABU_GUID@@PAPAX@Z endp
.text:00006BDC
.text:00006BDC ; ---------------------------------------------------------------------------
.text:00006BDF                 align 10h
.text:00006BDF _text           ends
.text:00006BDF
.text:00006BE0 ; ===========================================================================
.text:00006BE0
.text:00006BE0 ; Segment type: Pure code
.text:00006BE0 ; Segment permissions: Read/Execute
.text:00006BE0 _text           segment para public 'CODE' use32
.text:00006BE0                 assume cs:_text
.text:00006BE0                 ;org 6BE0h
.text:00006BE0 ; COMDAT (pick any)
.text:00006BE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00006BE0
.text:00006BE0 ; =============== S U B R O U T I N E =======================================
.text:00006BE0
.text:00006BE0 ; Attributes: bp-based frame
.text:00006BE0
.text:00006BE0 ; int __stdcall __(void *Buf1, void *Buf2)
.text:00006BE0                 public ___@8
.text:00006BE0 ___@8           proc near               ; CODE XREF: COutFileStream::QueryInterface(_GUID const &,void * *)+15p
.text:00006BE0                                         ; COutFileStream::QueryInterface(_GUID const &,void * *)+31p ...
.text:00006BE0
.text:00006BE0 Buf1            = dword ptr  8
.text:00006BE0 Buf2            = dword ptr  0Ch
.text:00006BE0
.text:00006BE0                 push    ebp
.text:00006BE1                 mov     ebp, esp
.text:00006BE3                 mov     eax, [ebp+Buf2]
.text:00006BE6                 push    eax             ; Buf2
.text:00006BE7                 mov     ecx, [ebp+Buf1]
.text:00006BEA                 push    ecx             ; Buf1
.text:00006BEB                 call    _IsEqualGUID@8  ; IsEqualGUID(x,x)
.text:00006BF0                 cmp     ebp, esp
.text:00006BF2                 call    __RTC_CheckEsp
.text:00006BF7                 pop     ebp
.text:00006BF8                 retn    8
.text:00006BF8 ___@8           endp
.text:00006BF8
.text:00006BF8 ; ---------------------------------------------------------------------------
.text:00006BFB                 align 4
.text:00006BFB _text           ends
.text:00006BFB
.text:00006BFC ; ===========================================================================
.text:00006BFC
.text:00006BFC ; Segment type: Pure code
.text:00006BFC ; Segment permissions: Read/Execute
.text:00006BFC _text           segment para public 'CODE' use32
.text:00006BFC                 assume cs:_text
.text:00006BFC                 ;org 6BFCh
.text:00006BFC ; COMDAT (pick any)
.text:00006BFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00006BFC
.text:00006BFC ; =============== S U B R O U T I N E =======================================
.text:00006BFC
.text:00006BFC ; Attributes: bp-based frame
.text:00006BFC
.text:00006BFC ; int __stdcall IsEqualGUID(void *Buf1, void *Buf2)
.text:00006BFC                 public _IsEqualGUID@8
.text:00006BFC _IsEqualGUID@8  proc near               ; CODE XREF: __(x,x)+Bp
.text:00006BFC
.text:00006BFC Buf1            = dword ptr  8
.text:00006BFC Buf2            = dword ptr  0Ch
.text:00006BFC
.text:00006BFC                 push    ebp
.text:00006BFD                 mov     ebp, esp
.text:00006BFF                 push    10h             ; Size
.text:00006C01                 mov     eax, [ebp+Buf2]
.text:00006C04                 push    eax             ; Buf2
.text:00006C05                 mov     ecx, [ebp+Buf1]
.text:00006C08                 push    ecx             ; Buf1
.text:00006C09                 call    _memcmp
.text:00006C0E                 add     esp, 0Ch
.text:00006C11                 neg     eax
.text:00006C13                 sbb     eax, eax
.text:00006C15                 add     eax, 1
.text:00006C18                 cmp     ebp, esp
.text:00006C1A                 call    __RTC_CheckEsp
.text:00006C1F                 pop     ebp
.text:00006C20                 retn    8
.text:00006C20 _IsEqualGUID@8  endp
.text:00006C20
.text:00006C20 ; ---------------------------------------------------------------------------
.text:00006C23                 align 4
.text:00006C23 _text           ends
.text:00006C23
.text:00006C24 ; ===========================================================================
.text:00006C24
.text:00006C24 ; Segment type: Pure code
.text:00006C24 ; Segment permissions: Read/Execute
.text:00006C24 _text           segment para public 'CODE' use32
.text:00006C24                 assume cs:_text
.text:00006C24                 ;org 6C24h
.text:00006C24 ; COMDAT (pick any)
.text:00006C24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00006C24
.text:00006C24 ; =============== S U B R O U T I N E =======================================
.text:00006C24
.text:00006C24 ; Attributes: bp-based frame
.text:00006C24
.text:00006C24 ; unsigned __int32 __stdcall COutFileStream::AddRef(COutFileStream *this)
.text:00006C24                 public ?AddRef@COutFileStream@@UAGKXZ
.text:00006C24 ?AddRef@COutFileStream@@UAGKXZ proc near ; DATA XREF: .rdata:0000695Co
.text:00006C24
.text:00006C24 var_4           = dword ptr -4
.text:00006C24 this            = dword ptr  8
.text:00006C24
.text:00006C24                 push    ebp
.text:00006C25                 mov     ebp, esp
.text:00006C27                 push    ecx
.text:00006C28                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00006C2F                 mov     eax, [ebp+this]
.text:00006C32                 mov     ecx, [eax+4]
.text:00006C35                 add     ecx, 1
.text:00006C38                 mov     [ebp+var_4], ecx
.text:00006C3B                 mov     edx, [ebp+this]
.text:00006C3E                 mov     eax, [ebp+var_4]
.text:00006C41                 mov     [edx+4], eax
.text:00006C44                 mov     eax, [ebp+var_4]
.text:00006C47                 mov     esp, ebp
.text:00006C49                 pop     ebp
.text:00006C4A                 retn    4
.text:00006C4A ?AddRef@COutFileStream@@UAGKXZ endp
.text:00006C4A
.text:00006C4A ; ---------------------------------------------------------------------------
.text:00006C4D                 align 10h
.text:00006C4D _text           ends
.text:00006C4D
.text:00006C50 ; ===========================================================================
.text:00006C50
.text:00006C50 ; Segment type: Pure code
.text:00006C50 ; Segment permissions: Read/Execute
.text:00006C50 _text           segment para public 'CODE' use32
.text:00006C50                 assume cs:_text
.text:00006C50                 ;org 6C50h
.text:00006C50 ; COMDAT (pick any)
.text:00006C50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00006C50
.text:00006C50 ; =============== S U B R O U T I N E =======================================
.text:00006C50
.text:00006C50 ; Attributes: bp-based frame
.text:00006C50
.text:00006C50 ; unsigned __int32 __stdcall COutFileStream::Release(COutFileStream *this)
.text:00006C50                 public ?Release@COutFileStream@@UAGKXZ
.text:00006C50 ?Release@COutFileStream@@UAGKXZ proc near ; DATA XREF: .rdata:00006960o
.text:00006C50
.text:00006C50 var_10          = dword ptr -10h
.text:00006C50 var_C           = dword ptr -0Ch
.text:00006C50 var_8           = dword ptr -8
.text:00006C50 var_4           = dword ptr -4
.text:00006C50 this            = dword ptr  8
.text:00006C50
.text:00006C50                 push    ebp
.text:00006C51                 mov     ebp, esp
.text:00006C53                 sub     esp, 10h
.text:00006C56                 push    esi
.text:00006C57                 mov     eax, 0CCCCCCCCh
.text:00006C5C                 mov     [ebp+var_10], eax
.text:00006C5F                 mov     [ebp+var_C], eax
.text:00006C62                 mov     [ebp+var_8], eax
.text:00006C65                 mov     [ebp+var_4], eax
.text:00006C68                 mov     eax, [ebp+this]
.text:00006C6B                 mov     ecx, [eax+4]
.text:00006C6E                 sub     ecx, 1
.text:00006C71                 mov     [ebp+var_C], ecx
.text:00006C74                 mov     edx, [ebp+this]
.text:00006C77                 mov     eax, [ebp+var_C]
.text:00006C7A                 mov     [edx+4], eax
.text:00006C7D                 cmp     [ebp+var_C], 0
.text:00006C81                 jz      short loc_6C8B
.text:00006C83                 mov     ecx, [ebp+this]
.text:00006C86                 mov     eax, [ecx+4]
.text:00006C89                 jmp     short loc_6CC3
.text:00006C8B ; ---------------------------------------------------------------------------
.text:00006C8B
.text:00006C8B loc_6C8B:                               ; CODE XREF: COutFileStream::Release(void)+31j
.text:00006C8B                 mov     edx, [ebp+this]
.text:00006C8E                 mov     [ebp+var_8], edx
.text:00006C91                 mov     eax, [ebp+var_8]
.text:00006C94                 mov     [ebp+var_4], eax
.text:00006C97                 cmp     [ebp+var_4], 0
.text:00006C9B                 jz      short loc_6CBA
.text:00006C9D                 mov     esi, esp
.text:00006C9F                 push    1
.text:00006CA1                 mov     ecx, [ebp+var_4]
.text:00006CA4                 mov     edx, [ecx]
.text:00006CA6                 mov     ecx, [ebp+var_4]
.text:00006CA9                 mov     eax, [edx+18h]
.text:00006CAC                 call    eax
.text:00006CAE                 cmp     esi, esp
.text:00006CB0                 call    __RTC_CheckEsp
.text:00006CB5                 mov     [ebp+var_10], eax
.text:00006CB8                 jmp     short loc_6CC1
.text:00006CBA ; ---------------------------------------------------------------------------
.text:00006CBA
.text:00006CBA loc_6CBA:                               ; CODE XREF: COutFileStream::Release(void)+4Bj
.text:00006CBA                 mov     [ebp+var_10], 0
.text:00006CC1
.text:00006CC1 loc_6CC1:                               ; CODE XREF: COutFileStream::Release(void)+68j
.text:00006CC1                 xor     eax, eax
.text:00006CC3
.text:00006CC3 loc_6CC3:                               ; CODE XREF: COutFileStream::Release(void)+39j
.text:00006CC3                 pop     esi
.text:00006CC4                 add     esp, 10h
.text:00006CC7                 cmp     ebp, esp
.text:00006CC9                 call    __RTC_CheckEsp
.text:00006CCE                 mov     esp, ebp
.text:00006CD0                 pop     ebp
.text:00006CD1                 retn    4
.text:00006CD1 ?Release@COutFileStream@@UAGKXZ endp
.text:00006CD1
.text:00006CD1 _text           ends
.text:00006CD1
.text:00006CD4 ; ===========================================================================
.text:00006CD4
.text:00006CD4 ; Segment type: Pure code
.text:00006CD4 ; Segment permissions: Read/Execute
.text:00006CD4 _text           segment para public 'CODE' use32
.text:00006CD4                 assume cs:_text
.text:00006CD4                 ;org 6CD4h
.text:00006CD4 ; COMDAT (pick any)
.text:00006CD4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00006CD4
.text:00006CD4 ; =============== S U B R O U T I N E =======================================
.text:00006CD4
.text:00006CD4 ; Attributes: bp-based frame
.text:00006CD4
.text:00006CD4 ; public: virtual void * __thiscall COutFileStream::`scalar deleting destructor'(unsigned int)
.text:00006CD4                 public ??_GCOutFileStream@@UAEPAXI@Z
.text:00006CD4 ??_GCOutFileStream@@UAEPAXI@Z proc near
.text:00006CD4
.text:00006CD4 var_4           = dword ptr -4
.text:00006CD4 arg_0           = dword ptr  8
.text:00006CD4
.text:00006CD4                 push    ebp
.text:00006CD5                 mov     ebp, esp
.text:00006CD7                 push    ecx
.text:00006CD8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00006CDF                 mov     [ebp+var_4], ecx
.text:00006CE2                 mov     ecx, [ebp+var_4] ; this
.text:00006CE5                 call    ??1COutFileStream@@UAE@XZ ; COutFileStream::~COutFileStream(void)
.text:00006CEA                 mov     eax, [ebp+arg_0]
.text:00006CED                 and     eax, 1
.text:00006CF0                 jz      short loc_6CFE
.text:00006CF2                 mov     ecx, [ebp+var_4]
.text:00006CF5                 push    ecx             ; void *
.text:00006CF6                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00006CFB                 add     esp, 4
.text:00006CFE
.text:00006CFE loc_6CFE:                               ; CODE XREF: COutFileStream::`scalar deleting destructor'(uint)+1Cj
.text:00006CFE                 mov     eax, [ebp+var_4]
.text:00006D01                 add     esp, 4
.text:00006D04                 cmp     ebp, esp
.text:00006D06                 call    __RTC_CheckEsp
.text:00006D0B                 mov     esp, ebp
.text:00006D0D                 pop     ebp
.text:00006D0E                 retn    4
.text:00006D0E ??_GCOutFileStream@@UAEPAXI@Z endp
.text:00006D0E
.text:00006D0E ; ---------------------------------------------------------------------------
.text:00006D11                 align 4
.text:00006D11 _text           ends
.text:00006D11
.text:00006D14 ; ===========================================================================
.text:00006D14
.text:00006D14 ; Segment type: Pure code
.text:00006D14 ; Segment permissions: Read/Execute
.text:00006D14 _text           segment para public 'CODE' use32
.text:00006D14                 assume cs:_text
.text:00006D14                 ;org 6D14h
.text:00006D14 ; COMDAT (pick any)
.text:00006D14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00006D14
.text:00006D14 ; =============== S U B R O U T I N E =======================================
.text:00006D14
.text:00006D14 ; Attributes: bp-based frame
.text:00006D14
.text:00006D14 ; _DWORD __thiscall COutFileStream::~COutFileStream(COutFileStream *__hidden this)
.text:00006D14                 public ??1COutFileStream@@UAE@XZ
.text:00006D14 ??1COutFileStream@@UAE@XZ proc near     ; CODE XREF: COutFileStream::`scalar deleting destructor'(uint)+11p
.text:00006D14
.text:00006D14 var_4           = dword ptr -4
.text:00006D14
.text:00006D14                 push    ebp
.text:00006D15                 mov     ebp, esp
.text:00006D17                 push    ecx
.text:00006D18                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00006D1F                 mov     [ebp+var_4], ecx
.text:00006D22                 mov     eax, [ebp+var_4]
.text:00006D25                 mov     dword ptr [eax], offset ??_7COutFileStream@@6B@ ; const COutFileStream::`vftable'
.text:00006D2B                 mov     ecx, [ebp+var_4]
.text:00006D2E                 add     ecx, 8          ; this
.text:00006D31                 call    ??1COutFile@NIO@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NIO::COutFile::~COutFile(void)
.text:00006D36                 add     esp, 4
.text:00006D39                 cmp     ebp, esp
.text:00006D3B                 call    __RTC_CheckEsp
.text:00006D40                 mov     esp, ebp
.text:00006D42                 pop     ebp
.text:00006D43                 retn
.text:00006D43 ??1COutFileStream@@UAE@XZ endp
.text:00006D43
.text:00006D43 _text           ends
.text:00006D43
.text:00006D44 ; ===========================================================================
.text:00006D44
.text:00006D44 ; Segment type: Pure code
.text:00006D44 ; Segment permissions: Read/Execute
.text:00006D44 _text           segment para public 'CODE' use32
.text:00006D44                 assume cs:_text
.text:00006D44                 ;org 6D44h
.text:00006D44 ; COMDAT (pick any)
.text:00006D44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00006D44
.text:00006D44 ; =============== S U B R O U T I N E =======================================
.text:00006D44
.text:00006D44 ; Attributes: bp-based frame
.text:00006D44
.text:00006D44 ; _DWORD __thiscall NWindows::NFile::NIO::COutFile::~COutFile(NWindows::NFile::NIO::COutFile *__hidden this)
.text:00006D44                 public ??1COutFile@NIO@NFile@NWindows@@QAE@XZ
.text:00006D44 ??1COutFile@NIO@NFile@NWindows@@QAE@XZ proc near
.text:00006D44                                         ; CODE XREF: COutFileStream::~COutFileStream(void)+1Dp
.text:00006D44
.text:00006D44 var_4           = dword ptr -4
.text:00006D44
.text:00006D44                 push    ebp
.text:00006D45                 mov     ebp, esp
.text:00006D47                 push    ecx
.text:00006D48                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00006D4F                 mov     [ebp+var_4], ecx
.text:00006D52                 mov     ecx, [ebp+var_4] ; this
.text:00006D55                 call    ??1CFileBase@NIO@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NIO::CFileBase::~CFileBase(void)
.text:00006D5A                 add     esp, 4
.text:00006D5D                 cmp     ebp, esp
.text:00006D5F                 call    __RTC_CheckEsp
.text:00006D64                 mov     esp, ebp
.text:00006D66                 pop     ebp
.text:00006D67                 retn
.text:00006D67 ??1COutFile@NIO@NFile@NWindows@@QAE@XZ endp
.text:00006D67
.text:00006D67 _text           ends
.text:00006D67
.text:00006D68 ; ===========================================================================
.text:00006D68
.text:00006D68 ; Segment type: Pure code
.text:00006D68 ; Segment permissions: Read/Execute
.text:00006D68 _text           segment para public 'CODE' use32
.text:00006D68                 assume cs:_text
.text:00006D68                 ;org 6D68h
.text:00006D68 ; COMDAT (pick any)
.text:00006D68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00006D68
.text:00006D68 ; =============== S U B R O U T I N E =======================================
.text:00006D68
.text:00006D68 ; Attributes: bp-based frame
.text:00006D68
.text:00006D68 ; _DWORD __thiscall NWindows::NFile::NIO::CFileBase::~CFileBase(NWindows::NFile::NIO::CFileBase *__hidden this)
.text:00006D68                 public ??1CFileBase@NIO@NFile@NWindows@@QAE@XZ
.text:00006D68 ??1CFileBase@NIO@NFile@NWindows@@QAE@XZ proc near
.text:00006D68                                         ; CODE XREF: NWindows::NFile::NIO::COutFile::~COutFile(void)+11p
.text:00006D68
.text:00006D68 var_4           = dword ptr -4
.text:00006D68
.text:00006D68                 push    ebp
.text:00006D69                 mov     ebp, esp
.text:00006D6B                 push    ecx
.text:00006D6C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00006D73                 mov     [ebp+var_4], ecx
.text:00006D76                 mov     ecx, [ebp+var_4] ; this
.text:00006D79                 call    ?Close@CFileBase@NIO@NFile@NWindows@@QAE_NXZ ; NWindows::NFile::NIO::CFileBase::Close(void)
.text:00006D7E                 add     esp, 4
.text:00006D81                 cmp     ebp, esp
.text:00006D83                 call    __RTC_CheckEsp
.text:00006D88                 mov     esp, ebp
.text:00006D8A                 pop     ebp
.text:00006D8B                 retn
.text:00006D8B ??1CFileBase@NIO@NFile@NWindows@@QAE@XZ endp
.text:00006D8B
.text:00006D8B _text           ends
.text:00006D8B
.text:00006D8C ; ===========================================================================
.text:00006D8C
.text:00006D8C ; Segment type: Pure code
.text:00006D8C ; Segment permissions: Read/Execute
.text:00006D8C _text           segment para public 'CODE' use32
.text:00006D8C                 assume cs:_text
.text:00006D8C                 ;org 6D8Ch
.text:00006D8C ; COMDAT (pick any)
.text:00006D8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00006D8C
.text:00006D8C ; =============== S U B R O U T I N E =======================================
.text:00006D8C
.text:00006D8C ; Attributes: bp-based frame
.text:00006D8C
.text:00006D8C ; _DWORD __thiscall IOutStream::IOutStream(IOutStream *__hidden this)
.text:00006D8C                 public ??0IOutStream@@QAE@XZ
.text:00006D8C ??0IOutStream@@QAE@XZ proc near         ; CODE XREF: COutFileStream::COutFileStream(void)+11p
.text:00006D8C                                         ; COutMultiVolStream::COutMultiVolStream(void)+30p ...
.text:00006D8C
.text:00006D8C var_4           = dword ptr -4
.text:00006D8C
.text:00006D8C                 push    ebp
.text:00006D8D                 mov     ebp, esp
.text:00006D8F                 push    ecx
.text:00006D90                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00006D97                 mov     [ebp+var_4], ecx
.text:00006D9A                 mov     ecx, [ebp+var_4] ; this
.text:00006D9D                 call    ??0ISequentialOutStream@@QAE@XZ ; ISequentialOutStream::ISequentialOutStream(void)
.text:00006DA2                 mov     eax, [ebp+var_4]
.text:00006DA5                 mov     dword ptr [eax], offset ??_7IOutStream@@6B@ ; const IOutStream::`vftable'
.text:00006DAB                 mov     eax, [ebp+var_4]
.text:00006DAE                 add     esp, 4
.text:00006DB1                 cmp     ebp, esp
.text:00006DB3                 call    __RTC_CheckEsp
.text:00006DB8                 mov     esp, ebp
.text:00006DBA                 pop     ebp
.text:00006DBB                 retn
.text:00006DBB ??0IOutStream@@QAE@XZ endp
.text:00006DBB
.text:00006DBB _text           ends
.text:00006DBB
.rdata:00006DBC ; ===========================================================================
.rdata:00006DBC
.rdata:00006DBC ; Segment type: Pure data
.rdata:00006DBC ; Segment permissions: Read
.rdata:00006DBC _rdata          segment dword public 'DATA' use32
.rdata:00006DBC                 assume cs:_rdata
.rdata:00006DBC                 ;org 6DBCh
.rdata:00006DBC ; COMDAT (pick largest)
.rdata:00006DBC                 dd offset ??_R4IOutStream@@6B@ ; const IOutStream::`RTTI Complete Object Locator'
.rdata:00006DC0                 public ??_7IOutStream@@6B@
.rdata:00006DC0 ; const IOutStream::`vftable'
.rdata:00006DC0 ??_7IOutStream@@6B@ dd offset __purecall
.rdata:00006DC0                                         ; DATA XREF: IOutStream::IOutStream(void)+19o
.rdata:00006DC4                 dd offset __purecall
.rdata:00006DC8                 dd offset __purecall
.rdata:00006DCC                 dd offset __purecall
.rdata:00006DD0                 dd offset __purecall
.rdata:00006DD4                 dd offset __purecall
.rdata:00006DD4 _rdata          ends
.rdata:00006DD4
.rdata$r:00006DD8 ; ===========================================================================
.rdata$r:00006DD8
.rdata$r:00006DD8 ; Segment type: Pure data
.rdata$r:00006DD8 ; Segment permissions: Read
.rdata$r:00006DD8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00006DD8                 assume cs:_rdata$r
.rdata$r:00006DD8                 ;org 6DD8h
.rdata$r:00006DD8 ; COMDAT (pick any)
.rdata$r:00006DD8                 public ??_R4IOutStream@@6B@
.rdata$r:00006DD8 ; const IOutStream::`RTTI Complete Object Locator'
.rdata$r:00006DD8 ??_R4IOutStream@@6B@ db    0            ; DATA XREF: .rdata:00006DBCo
.rdata$r:00006DD9                 db    0
.rdata$r:00006DDA                 db    0
.rdata$r:00006DDB                 db    0
.rdata$r:00006DDC                 db    0
.rdata$r:00006DDD                 db    0
.rdata$r:00006DDE                 db    0
.rdata$r:00006DDF                 db    0
.rdata$r:00006DE0                 db    0
.rdata$r:00006DE1                 db    0
.rdata$r:00006DE2                 db    0
.rdata$r:00006DE3                 db    0
.rdata$r:00006DE4                 dd offset ??_R0?AUIOutStream@@@8 ; IOutStream `RTTI Type Descriptor'
.rdata$r:00006DE8                 dd offset ??_R3IOutStream@@8 ; IOutStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00006DE8 _rdata$r        ends
.rdata$r:00006DE8
.text:00006DEC ; ===========================================================================
.text:00006DEC
.text:00006DEC ; Segment type: Pure code
.text:00006DEC ; Segment permissions: Read/Execute
.text:00006DEC _text           segment para public 'CODE' use32
.text:00006DEC                 assume cs:_text
.text:00006DEC                 ;org 6DECh
.text:00006DEC ; COMDAT (pick any)
.text:00006DEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00006DEC
.text:00006DEC ; =============== S U B R O U T I N E =======================================
.text:00006DEC
.text:00006DEC ; Attributes: bp-based frame
.text:00006DEC
.text:00006DEC ; _DWORD __thiscall ISequentialOutStream::ISequentialOutStream(ISequentialOutStream *__hidden this)
.text:00006DEC                 public ??0ISequentialOutStream@@QAE@XZ
.text:00006DEC ??0ISequentialOutStream@@QAE@XZ proc near
.text:00006DEC                                         ; CODE XREF: IOutStream::IOutStream(void)+11p
.text:00006DEC                                         ; CStdOutFileStream::CStdOutFileStream(void)+11p
.text:00006DEC
.text:00006DEC var_4           = dword ptr -4
.text:00006DEC
.text:00006DEC                 push    ebp
.text:00006DED                 mov     ebp, esp
.text:00006DEF                 push    ecx
.text:00006DF0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00006DF7                 mov     [ebp+var_4], ecx
.text:00006DFA                 mov     ecx, [ebp+var_4]
.text:00006DFD                 call    ??0IUnknown@@QAE@XZ ; IUnknown::IUnknown(void)
.text:00006E02                 mov     eax, [ebp+var_4]
.text:00006E05                 mov     dword ptr [eax], offset ??_7ISequentialOutStream@@6B@ ; const ISequentialOutStream::`vftable'
.text:00006E0B                 mov     eax, [ebp+var_4]
.text:00006E0E                 add     esp, 4
.text:00006E11                 cmp     ebp, esp
.text:00006E13                 call    __RTC_CheckEsp
.text:00006E18                 mov     esp, ebp
.text:00006E1A                 pop     ebp
.text:00006E1B                 retn
.text:00006E1B ??0ISequentialOutStream@@QAE@XZ endp
.text:00006E1B
.text:00006E1B _text           ends
.text:00006E1B
.rdata:00006E1C ; ===========================================================================
.rdata:00006E1C
.rdata:00006E1C ; Segment type: Pure data
.rdata:00006E1C ; Segment permissions: Read
.rdata:00006E1C _rdata          segment dword public 'DATA' use32
.rdata:00006E1C                 assume cs:_rdata
.rdata:00006E1C                 ;org 6E1Ch
.rdata:00006E1C ; COMDAT (pick largest)
.rdata:00006E1C                 dd offset ??_R4ISequentialOutStream@@6B@ ; const ISequentialOutStream::`RTTI Complete Object Locator'
.rdata:00006E20                 public ??_7ISequentialOutStream@@6B@
.rdata:00006E20 ; const ISequentialOutStream::`vftable'
.rdata:00006E20 ??_7ISequentialOutStream@@6B@ dd offset __purecall
.rdata:00006E20                                         ; DATA XREF: ISequentialOutStream::ISequentialOutStream(void)+19o
.rdata:00006E24                 dd offset __purecall
.rdata:00006E28                 dd offset __purecall
.rdata:00006E2C                 dd offset __purecall
.rdata:00006E2C _rdata          ends
.rdata:00006E2C
.rdata$r:00006E30 ; ===========================================================================
.rdata$r:00006E30
.rdata$r:00006E30 ; Segment type: Pure data
.rdata$r:00006E30 ; Segment permissions: Read
.rdata$r:00006E30 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00006E30                 assume cs:_rdata$r
.rdata$r:00006E30                 ;org 6E30h
.rdata$r:00006E30 ; COMDAT (pick any)
.rdata$r:00006E30                 public ??_R4ISequentialOutStream@@6B@
.rdata$r:00006E30 ; const ISequentialOutStream::`RTTI Complete Object Locator'
.rdata$r:00006E30 ??_R4ISequentialOutStream@@6B@ db    0  ; DATA XREF: .rdata:00006E1Co
.rdata$r:00006E31                 db    0
.rdata$r:00006E32                 db    0
.rdata$r:00006E33                 db    0
.rdata$r:00006E34                 db    0
.rdata$r:00006E35                 db    0
.rdata$r:00006E36                 db    0
.rdata$r:00006E37                 db    0
.rdata$r:00006E38                 db    0
.rdata$r:00006E39                 db    0
.rdata$r:00006E3A                 db    0
.rdata$r:00006E3B                 db    0
.rdata$r:00006E3C                 dd offset ??_R0?AUISequentialOutStream@@@8 ; ISequentialOutStream `RTTI Type Descriptor'
.rdata$r:00006E40                 dd offset ??_R3ISequentialOutStream@@8 ; ISequentialOutStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00006E40 _rdata$r        ends
.rdata$r:00006E40
.text:00006E44 ; ===========================================================================
.text:00006E44
.text:00006E44 ; Segment type: Pure code
.text:00006E44 ; Segment permissions: Read/Execute
.text:00006E44 _text           segment para public 'CODE' use32
.text:00006E44                 assume cs:_text
.text:00006E44                 ;org 6E44h
.text:00006E44 ; COMDAT (pick any)
.text:00006E44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00006E44
.text:00006E44 ; =============== S U B R O U T I N E =======================================
.text:00006E44
.text:00006E44 ; Attributes: bp-based frame
.text:00006E44
.text:00006E44 ; public: __thiscall IUnknown::IUnknown(void)
.text:00006E44                 public ??0IUnknown@@QAE@XZ
.text:00006E44 ??0IUnknown@@QAE@XZ proc near           ; CODE XREF: ISequentialOutStream::ISequentialOutStream(void)+11p
.text:00006E44
.text:00006E44 var_4           = dword ptr -4
.text:00006E44
.text:00006E44                 push    ebp
.text:00006E45                 mov     ebp, esp
.text:00006E47                 push    ecx
.text:00006E48                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00006E4F                 mov     [ebp+var_4], ecx
.text:00006E52                 mov     eax, [ebp+var_4]
.text:00006E55                 mov     esp, ebp
.text:00006E57                 pop     ebp
.text:00006E58                 retn
.text:00006E58 ??0IUnknown@@QAE@XZ endp
.text:00006E58
.text:00006E58 ; ---------------------------------------------------------------------------
.text:00006E59                 align 4
.text:00006E59 _text           ends
.text:00006E59
.text:00006E5C ; ===========================================================================
.text:00006E5C
.text:00006E5C ; Segment type: Pure code
.text:00006E5C ; Segment permissions: Read/Execute
.text:00006E5C _text           segment para public 'CODE' use32
.text:00006E5C                 assume cs:_text
.text:00006E5C                 ;org 6E5Ch
.text:00006E5C ; COMDAT (pick any)
.text:00006E5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00006E5C
.text:00006E5C ; =============== S U B R O U T I N E =======================================
.text:00006E5C
.text:00006E5C ; Attributes: bp-based frame
.text:00006E5C
.text:00006E5C ; _DWORD __thiscall NWindows::NFile::NIO::COutFile::COutFile(NWindows::NFile::NIO::COutFile *__hidden this)
.text:00006E5C                 public ??0COutFile@NIO@NFile@NWindows@@QAE@XZ
.text:00006E5C ??0COutFile@NIO@NFile@NWindows@@QAE@XZ proc near
.text:00006E5C                                         ; CODE XREF: COutFileStream::COutFileStream(void)+30p
.text:00006E5C
.text:00006E5C var_4           = dword ptr -4
.text:00006E5C
.text:00006E5C                 push    ebp
.text:00006E5D                 mov     ebp, esp
.text:00006E5F                 push    ecx
.text:00006E60                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00006E67                 mov     [ebp+var_4], ecx
.text:00006E6A                 mov     ecx, [ebp+var_4] ; this
.text:00006E6D                 call    ??0CFileBase@NIO@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NIO::CFileBase::CFileBase(void)
.text:00006E72                 mov     eax, [ebp+var_4]
.text:00006E75                 add     esp, 4
.text:00006E78                 cmp     ebp, esp
.text:00006E7A                 call    __RTC_CheckEsp
.text:00006E7F                 mov     esp, ebp
.text:00006E81                 pop     ebp
.text:00006E82                 retn
.text:00006E82 ??0COutFile@NIO@NFile@NWindows@@QAE@XZ endp
.text:00006E82
.text:00006E82 ; ---------------------------------------------------------------------------
.text:00006E83                 align 4
.text:00006E83 _text           ends
.text:00006E83
.text:00006E84 ; ===========================================================================
.text:00006E84
.text:00006E84 ; Segment type: Pure code
.text:00006E84 ; Segment permissions: Read/Execute
.text:00006E84 _text           segment para public 'CODE' use32
.text:00006E84                 assume cs:_text
.text:00006E84                 ;org 6E84h
.text:00006E84 ; COMDAT (pick any)
.text:00006E84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00006E84
.text:00006E84 ; =============== S U B R O U T I N E =======================================
.text:00006E84
.text:00006E84 ; Attributes: bp-based frame
.text:00006E84
.text:00006E84 ; _DWORD __thiscall NWindows::NFile::NIO::CFileBase::CFileBase(NWindows::NFile::NIO::CFileBase *__hidden this)
.text:00006E84                 public ??0CFileBase@NIO@NFile@NWindows@@QAE@XZ
.text:00006E84 ??0CFileBase@NIO@NFile@NWindows@@QAE@XZ proc near
.text:00006E84                                         ; CODE XREF: NWindows::NFile::NIO::COutFile::COutFile(void)+11p
.text:00006E84
.text:00006E84 var_4           = dword ptr -4
.text:00006E84
.text:00006E84                 push    ebp
.text:00006E85                 mov     ebp, esp
.text:00006E87                 push    ecx
.text:00006E88                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00006E8F                 mov     [ebp+var_4], ecx
.text:00006E92                 mov     eax, [ebp+var_4]
.text:00006E95                 mov     dword ptr [eax], 0FFFFFFFFh
.text:00006E9B                 mov     eax, [ebp+var_4]
.text:00006E9E                 mov     esp, ebp
.text:00006EA0                 pop     ebp
.text:00006EA1                 retn
.text:00006EA1 ??0CFileBase@NIO@NFile@NWindows@@QAE@XZ endp
.text:00006EA1
.text:00006EA1 ; ---------------------------------------------------------------------------
.text:00006EA2                 align 4
.text:00006EA2 _text           ends
.text:00006EA2
.text$x:00006EA4 ; ===========================================================================
.text$x:00006EA4
.text$x:00006EA4 ; Segment type: Pure code
.text$x:00006EA4 ; Segment permissions: Read/Execute
.text$x:00006EA4 _text$x         segment para public 'CODE' use32
.text$x:00006EA4                 assume cs:_text$x
.text$x:00006EA4                 ;org 6EA4h
.text$x:00006EA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006EA4
.text$x:00006EA4 ; =============== S U B R O U T I N E =======================================
.text$x:00006EA4
.text$x:00006EA4
.text$x:00006EA4 __unwindfunclet$?ParseFromPath@CArchivePath@@QAEXABVUString@@W4EArcNameMode@@@Z$0 proc near
.text$x:00006EA4                                         ; DATA XREF: .xdata$x:00007328o
.text$x:00006EA4                 lea     ecx, [ebp-24h]  ; this
.text$x:00006EA7                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00006EA7 __unwindfunclet$?ParseFromPath@CArchivePath@@QAEXABVUString@@W4EArcNameMode@@@Z$0 endp
.text$x:00006EA7
.text$x:00006EAC
.text$x:00006EAC ; =============== S U B R O U T I N E =======================================
.text$x:00006EAC
.text$x:00006EAC
.text$x:00006EAC __ehhandler$?ParseFromPath@CArchivePath@@QAEXABVUString@@W4EArcNameMode@@@Z proc near
.text$x:00006EAC                                         ; DATA XREF: CArchivePath::ParseFromPath(UString const &,EArcNameMode)+5o
.text$x:00006EAC
.text$x:00006EAC arg_4           = dword ptr  8
.text$x:00006EAC
.text$x:00006EAC                 mov     edx, [esp+arg_4]
.text$x:00006EB0                 lea     eax, [edx+0Ch]
.text$x:00006EB3                 mov     ecx, [edx-20h]
.text$x:00006EB6                 xor     ecx, eax
.text$x:00006EB8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006EBD                 mov     eax, offset __ehfuncinfo$?ParseFromPath@CArchivePath@@QAEXABVUString@@W4EArcNameMode@@@Z
.text$x:00006EC2                 jmp     ___CxxFrameHandler3
.text$x:00006EC2 __ehhandler$?ParseFromPath@CArchivePath@@QAEXABVUString@@W4EArcNameMode@@@Z endp
.text$x:00006EC2
.text$x:00006EC7
.text$x:00006EC7 ; =============== S U B R O U T I N E =======================================
.text$x:00006EC7
.text$x:00006EC7
.text$x:00006EC7 __unwindfunclet$?GetFinalPath@CArchivePath@@QBE?AVUString@@XZ$0 proc near
.text$x:00006EC7                                         ; DATA XREF: .xdata$x:0000735Co
.text$x:00006EC7                 lea     ecx, [ebp-20h]  ; this
.text$x:00006ECA                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00006ECA __unwindfunclet$?GetFinalPath@CArchivePath@@QBE?AVUString@@XZ$0 endp
.text$x:00006ECA
.text$x:00006ECF
.text$x:00006ECF ; =============== S U B R O U T I N E =======================================
.text$x:00006ECF
.text$x:00006ECF
.text$x:00006ECF __unwindfunclet$?GetFinalPath@CArchivePath@@QBE?AVUString@@XZ$1 proc near
.text$x:00006ECF                                         ; DATA XREF: .xdata$x:00007354o
.text$x:00006ECF                 mov     eax, [ebp-28h]
.text$x:00006ED2                 and     eax, 1
.text$x:00006ED5                 jz      locret_6EE7
.text$x:00006EDB                 and     dword ptr [ebp-28h], 0FFFFFFFEh
.text$x:00006EDF                 mov     ecx, [ebp+8]    ; this
.text$x:00006EE2                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00006EE7 ; ---------------------------------------------------------------------------
.text$x:00006EE7
.text$x:00006EE7 locret_6EE7:                            ; CODE XREF: __unwindfunclet$?GetFinalPath@CArchivePath@@QBE?AVUString@@XZ$1+6j
.text$x:00006EE7                 retn
.text$x:00006EE7 __unwindfunclet$?GetFinalPath@CArchivePath@@QBE?AVUString@@XZ$1 endp
.text$x:00006EE7
.text$x:00006EE8
.text$x:00006EE8 ; =============== S U B R O U T I N E =======================================
.text$x:00006EE8
.text$x:00006EE8
.text$x:00006EE8 __ehhandler$?GetFinalPath@CArchivePath@@QBE?AVUString@@XZ proc near
.text$x:00006EE8                                         ; DATA XREF: CArchivePath::GetFinalPath(void)+5o
.text$x:00006EE8
.text$x:00006EE8 arg_4           = dword ptr  8
.text$x:00006EE8
.text$x:00006EE8                 mov     edx, [esp+arg_4]
.text$x:00006EEC                 lea     eax, [edx+0Ch]
.text$x:00006EEF                 mov     ecx, [edx-20h]
.text$x:00006EF2                 xor     ecx, eax
.text$x:00006EF4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006EF9                 mov     eax, offset __ehfuncinfo$?GetFinalPath@CArchivePath@@QBE?AVUString@@XZ
.text$x:00006EFE                 jmp     ___CxxFrameHandler3
.text$x:00006EFE __ehhandler$?GetFinalPath@CArchivePath@@QBE?AVUString@@XZ endp
.text$x:00006EFE
.text$x:00006F03
.text$x:00006F03 ; =============== S U B R O U T I N E =======================================
.text$x:00006F03
.text$x:00006F03
.text$x:00006F03 __unwindfunclet$?GetFinalVolPath@CArchivePath@@QBE?AVUString@@XZ$0 proc near
.text$x:00006F03                                         ; DATA XREF: .xdata$x:00007390o
.text$x:00006F03                 lea     ecx, [ebp-20h]  ; this
.text$x:00006F06                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00006F06 __unwindfunclet$?GetFinalVolPath@CArchivePath@@QBE?AVUString@@XZ$0 endp
.text$x:00006F06
.text$x:00006F0B
.text$x:00006F0B ; =============== S U B R O U T I N E =======================================
.text$x:00006F0B
.text$x:00006F0B
.text$x:00006F0B __unwindfunclet$?GetFinalVolPath@CArchivePath@@QBE?AVUString@@XZ$1 proc near
.text$x:00006F0B                                         ; DATA XREF: .xdata$x:00007388o
.text$x:00006F0B                 mov     eax, [ebp-28h]
.text$x:00006F0E                 and     eax, 1
.text$x:00006F11                 jz      locret_6F23
.text$x:00006F17                 and     dword ptr [ebp-28h], 0FFFFFFFEh
.text$x:00006F1B                 mov     ecx, [ebp+8]    ; this
.text$x:00006F1E                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00006F23 ; ---------------------------------------------------------------------------
.text$x:00006F23
.text$x:00006F23 locret_6F23:                            ; CODE XREF: __unwindfunclet$?GetFinalVolPath@CArchivePath@@QBE?AVUString@@XZ$1+6j
.text$x:00006F23                 retn
.text$x:00006F23 __unwindfunclet$?GetFinalVolPath@CArchivePath@@QBE?AVUString@@XZ$1 endp
.text$x:00006F23
.text$x:00006F24
.text$x:00006F24 ; =============== S U B R O U T I N E =======================================
.text$x:00006F24
.text$x:00006F24
.text$x:00006F24 __ehhandler$?GetFinalVolPath@CArchivePath@@QBE?AVUString@@XZ proc near
.text$x:00006F24                                         ; DATA XREF: CArchivePath::GetFinalVolPath(void)+5o
.text$x:00006F24
.text$x:00006F24 arg_4           = dword ptr  8
.text$x:00006F24
.text$x:00006F24                 mov     edx, [esp+arg_4]
.text$x:00006F28                 lea     eax, [edx+0Ch]
.text$x:00006F2B                 mov     ecx, [edx-20h]
.text$x:00006F2E                 xor     ecx, eax
.text$x:00006F30                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006F35                 mov     eax, offset __ehfuncinfo$?GetFinalVolPath@CArchivePath@@QBE?AVUString@@XZ
.text$x:00006F3A                 jmp     ___CxxFrameHandler3
.text$x:00006F3A __ehhandler$?GetFinalVolPath@CArchivePath@@QBE?AVUString@@XZ endp
.text$x:00006F3A
.text$x:00006F3F
.text$x:00006F3F ; =============== S U B R O U T I N E =======================================
.text$x:00006F3F
.text$x:00006F3F
.text$x:00006F3F __unwindfunclet$?GetTempPathA@CArchivePath@@QBE?AVUString@@XZ$0 proc near
.text$x:00006F3F                                         ; DATA XREF: .xdata$x:000073C4o
.text$x:00006F3F                 lea     ecx, [ebp-20h]  ; this
.text$x:00006F42                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00006F42 __unwindfunclet$?GetTempPathA@CArchivePath@@QBE?AVUString@@XZ$0 endp
.text$x:00006F42
.text$x:00006F47
.text$x:00006F47 ; =============== S U B R O U T I N E =======================================
.text$x:00006F47
.text$x:00006F47
.text$x:00006F47 __unwindfunclet$?GetTempPathA@CArchivePath@@QBE?AVUString@@XZ$1 proc near
.text$x:00006F47                                         ; DATA XREF: .xdata$x:000073BCo
.text$x:00006F47                 mov     eax, [ebp-28h]
.text$x:00006F4A                 and     eax, 1
.text$x:00006F4D                 jz      locret_6F5F
.text$x:00006F53                 and     dword ptr [ebp-28h], 0FFFFFFFEh
.text$x:00006F57                 mov     ecx, [ebp+8]    ; this
.text$x:00006F5A                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00006F5F ; ---------------------------------------------------------------------------
.text$x:00006F5F
.text$x:00006F5F locret_6F5F:                            ; CODE XREF: __unwindfunclet$?GetTempPathA@CArchivePath@@QBE?AVUString@@XZ$1+6j
.text$x:00006F5F                 retn
.text$x:00006F5F __unwindfunclet$?GetTempPathA@CArchivePath@@QBE?AVUString@@XZ$1 endp
.text$x:00006F5F
.text$x:00006F60
.text$x:00006F60 ; =============== S U B R O U T I N E =======================================
.text$x:00006F60
.text$x:00006F60
.text$x:00006F60 __ehhandler$?GetTempPathA@CArchivePath@@QBE?AVUString@@XZ proc near
.text$x:00006F60                                         ; DATA XREF: CArchivePath::GetTempPathA(void)+5o
.text$x:00006F60
.text$x:00006F60 arg_4           = dword ptr  8
.text$x:00006F60
.text$x:00006F60                 mov     edx, [esp+arg_4]
.text$x:00006F64                 lea     eax, [edx+0Ch]
.text$x:00006F67                 mov     ecx, [edx-20h]
.text$x:00006F6A                 xor     ecx, eax
.text$x:00006F6C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006F71                 mov     eax, offset __ehfuncinfo$?GetTempPathA@CArchivePath@@QBE?AVUString@@XZ
.text$x:00006F76                 jmp     ___CxxFrameHandler3
.text$x:00006F76 __ehhandler$?GetTempPathA@CArchivePath@@QBE?AVUString@@XZ endp
.text$x:00006F76
.text$x:00006F7B
.text$x:00006F7B ; =============== S U B R O U T I N E =======================================
.text$x:00006F7B
.text$x:00006F7B
.text$x:00006F7B __unwindfunclet$?SetArcPath@CUpdateOptions@@QAE_NPBVCCodecs@@ABVUString@@@Z$0 proc near
.text$x:00006F7B                                         ; DATA XREF: .xdata$x:000073F0o
.text$x:00006F7B                 lea     ecx, [ebp-20h]  ; this
.text$x:00006F7E                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00006F7E __unwindfunclet$?SetArcPath@CUpdateOptions@@QAE_NPBVCCodecs@@ABVUString@@@Z$0 endp
.text$x:00006F7E
.text$x:00006F83
.text$x:00006F83 ; =============== S U B R O U T I N E =======================================
.text$x:00006F83
.text$x:00006F83
.text$x:00006F83 __unwindfunclet$?SetArcPath@CUpdateOptions@@QAE_NPBVCCodecs@@ABVUString@@@Z$1 proc near
.text$x:00006F83                                         ; DATA XREF: .xdata$x:000073F8o
.text$x:00006F83                 lea     ecx, [ebp-58h]  ; this
.text$x:00006F86                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00006F86 __unwindfunclet$?SetArcPath@CUpdateOptions@@QAE_NPBVCCodecs@@ABVUString@@@Z$1 endp
.text$x:00006F86
.text$x:00006F8B
.text$x:00006F8B ; =============== S U B R O U T I N E =======================================
.text$x:00006F8B
.text$x:00006F8B
.text$x:00006F8B __unwindfunclet$?SetArcPath@CUpdateOptions@@QAE_NPBVCCodecs@@ABVUString@@@Z$2 proc near
.text$x:00006F8B                                         ; DATA XREF: .xdata$x:00007400o
.text$x:00006F8B                 lea     ecx, [ebp-3Ch]  ; this
.text$x:00006F8E                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00006F8E __unwindfunclet$?SetArcPath@CUpdateOptions@@QAE_NPBVCCodecs@@ABVUString@@@Z$2 endp
.text$x:00006F8E
.text$x:00006F93
.text$x:00006F93 ; =============== S U B R O U T I N E =======================================
.text$x:00006F93
.text$x:00006F93
.text$x:00006F93 __ehhandler$?SetArcPath@CUpdateOptions@@QAE_NPBVCCodecs@@ABVUString@@@Z proc near
.text$x:00006F93                                         ; DATA XREF: CUpdateOptions::SetArcPath(CCodecs const *,UString const &)+5o
.text$x:00006F93
.text$x:00006F93 arg_4           = dword ptr  8
.text$x:00006F93
.text$x:00006F93                 mov     edx, [esp+arg_4]
.text$x:00006F97                 lea     eax, [edx+0Ch]
.text$x:00006F9A                 mov     ecx, [edx-60h]
.text$x:00006F9D                 xor     ecx, eax
.text$x:00006F9F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006FA4                 mov     eax, offset __ehfuncinfo$?SetArcPath@CUpdateOptions@@QAE_NPBVCCodecs@@ABVUString@@@Z
.text$x:00006FA9                 jmp     ___CxxFrameHandler3
.text$x:00006FA9 __ehhandler$?SetArcPath@CUpdateOptions@@QAE_NPBVCCodecs@@ABVUString@@@Z endp
.text$x:00006FA9
.text$x:00006FAE
.text$x:00006FAE ; =============== S U B R O U T I N E =======================================
.text$x:00006FAE
.text$x:00006FAE
.text$x:00006FAE __unwindfunclet$?GetNewPath@CRenamePair@@QBE_N_NABVUString@@AAV2@@Z$0 proc near
.text$x:00006FAE                                         ; DATA XREF: .xdata$x:0000742Co
.text$x:00006FAE                 lea     ecx, [ebp-20h]  ; this
.text$x:00006FB1                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00006FB1 __unwindfunclet$?GetNewPath@CRenamePair@@QBE_N_NABVUString@@AAV2@@Z$0 endp
.text$x:00006FB1
.text$x:00006FB6
.text$x:00006FB6 ; =============== S U B R O U T I N E =======================================
.text$x:00006FB6
.text$x:00006FB6
.text$x:00006FB6 __ehhandler$?GetNewPath@CRenamePair@@QBE_N_NABVUString@@AAV2@@Z proc near
.text$x:00006FB6                                         ; DATA XREF: CRenamePair::GetNewPath(bool,UString const &,UString &)+5o
.text$x:00006FB6
.text$x:00006FB6 arg_4           = dword ptr  8
.text$x:00006FB6
.text$x:00006FB6                 mov     edx, [esp+arg_4]
.text$x:00006FBA                 lea     eax, [edx+0Ch]
.text$x:00006FBD                 mov     ecx, [edx-20h]
.text$x:00006FC0                 xor     ecx, eax
.text$x:00006FC2                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006FC7                 mov     eax, offset __ehfuncinfo$?GetNewPath@CRenamePair@@QBE_N_NABVUString@@AAV2@@Z
.text$x:00006FCC                 jmp     ___CxxFrameHandler3
.text$x:00006FCC __ehhandler$?GetNewPath@CRenamePair@@QBE_N_NABVUString@@AAV2@@Z endp
.text$x:00006FCC
.text$x:00006FD1
.text$x:00006FD1 ; =============== S U B R O U T I N E =======================================
.text$x:00006FD1
.text$x:00006FD1
.text$x:00006FD1 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$2 proc near
.text$x:00006FD1                                         ; DATA XREF: .xdata$x:000074A0o
.text$x:00006FD1                 lea     ecx, [ebp-38h]  ; this
.text$x:00006FD4                 jmp     ??1CProperty@@QAE@XZ ; CProperty::~CProperty(void)
.text$x:00006FD4 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$2 endp
.text$x:00006FD4
.text$x:00006FD9
.text$x:00006FD9 ; =============== S U B R O U T I N E =======================================
.text$x:00006FD9
.text$x:00006FD9
.text$x:00006FD9 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$3 proc near
.text$x:00006FD9                                         ; DATA XREF: .xdata$x:000074A8o
.text$x:00006FD9                 lea     ecx, [ebp-63Ch] ; this
.text$x:00006FDF                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00006FDF __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$3 endp
.text$x:00006FDF
.text$x:00006FE4
.text$x:00006FE4 ; =============== S U B R O U T I N E =======================================
.text$x:00006FE4
.text$x:00006FE4
.text$x:00006FE4 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$4 proc near
.text$x:00006FE4                                         ; DATA XREF: .xdata$x:000074B0o
.text$x:00006FE4                                         ; .xdata$x:000074B8o
.text$x:00006FE4                 lea     ecx, [ebp-50h]  ; this
.text$x:00006FE7                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00006FE7 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$4 endp
.text$x:00006FE7
.text$x:00006FEC
.text$x:00006FEC ; =============== S U B R O U T I N E =======================================
.text$x:00006FEC
.text$x:00006FEC
.text$x:00006FEC __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$5 proc near
.text$x:00006FEC                                         ; DATA XREF: .xdata$x:000074C0o
.text$x:00006FEC                 lea     ecx, [ebp-0B8h] ; this
.text$x:00006FF2                 jmp     ??1CArchiveLink@@QAE@XZ ; CArchiveLink::~CArchiveLink(void)
.text$x:00006FF2 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$5 endp
.text$x:00006FF2
.text$x:00006FF7
.text$x:00006FF7 ; =============== S U B R O U T I N E =======================================
.text$x:00006FF7
.text$x:00006FF7
.text$x:00006FF7 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$6 proc near
.text$x:00006FF7                                         ; DATA XREF: .xdata$x:000074C8o
.text$x:00006FF7                 lea     ecx, [ebp-0CCh] ; this
.text$x:00006FFD                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00006FFD __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$6 endp
.text$x:00006FFD
.text$x:00007002
.text$x:00007002 ; =============== S U B R O U T I N E =======================================
.text$x:00007002
.text$x:00007002
.text$x:00007002 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$7 proc near
.text$x:00007002                                         ; DATA XREF: .xdata$x:000074D0o
.text$x:00007002                 lea     ecx, [ebp-10Ch] ; this
.text$x:00007008                 jmp     ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text$x:00007008 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$7 endp
.text$x:00007008
.text$x:0000700D
.text$x:0000700D ; =============== S U B R O U T I N E =======================================
.text$x:0000700D
.text$x:0000700D
.text$x:0000700D __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$8 proc near
.text$x:0000700D                                         ; DATA XREF: .xdata$x:000074D8o
.text$x:0000700D                 lea     ecx, [ebp-120h]
.text$x:00007013                 jmp     ??1?$CObjectVector@UCOpenType@@@@QAE@XZ ; CObjectVector<COpenType>::~CObjectVector<COpenType>(void)
.text$x:00007013 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$8 endp
.text$x:00007013
.text$x:00007018
.text$x:00007018 ; =============== S U B R O U T I N E =======================================
.text$x:00007018
.text$x:00007018
.text$x:00007018 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$9 proc near
.text$x:00007018                                         ; DATA XREF: .xdata$x:000074E0o
.text$x:00007018                 lea     ecx, [ebp-134h]
.text$x:0000701E                 jmp     ??1?$CRecordVector@H@@QAE@XZ ; CRecordVector<int>::~CRecordVector<int>(void)
.text$x:0000701E __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$9 endp
.text$x:0000701E
.text$x:00007023
.text$x:00007023 ; =============== S U B R O U T I N E =======================================
.text$x:00007023
.text$x:00007023
.text$x:00007023 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$10 proc near
.text$x:00007023                                         ; DATA XREF: .xdata$x:000074E8o
.text$x:00007023                 lea     ecx, [ebp-194h] ; this
.text$x:00007029                 jmp     ??1COpenOptions@@QAE@XZ ; COpenOptions::~COpenOptions(void)
.text$x:00007029 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$10 endp
.text$x:00007029
.text$x:0000702E
.text$x:0000702E ; =============== S U B R O U T I N E =======================================
.text$x:0000702E
.text$x:0000702E
.text$x:0000702E __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$11 proc near
.text$x:0000702E                                         ; DATA XREF: .xdata$x:000074F0o
.text$x:0000702E                 lea     ecx, [ebp-684h] ; this
.text$x:00007034                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00007034 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$11 endp
.text$x:00007034
.text$x:00007039
.text$x:00007039 ; =============== S U B R O U T I N E =======================================
.text$x:00007039
.text$x:00007039
.text$x:00007039 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$12 proc near
.text$x:00007039                                         ; DATA XREF: .xdata$x:000074F8o
.text$x:00007039                 lea     ecx, [ebp-258h] ; this
.text$x:0000703F                 jmp     ??1CDirItems@@QAE@XZ ; CDirItems::~CDirItems(void)
.text$x:0000703F __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$12 endp
.text$x:0000703F
.text$x:00007044
.text$x:00007044 ; =============== S U B R O U T I N E =======================================
.text$x:00007044
.text$x:00007044
.text$x:00007044 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$13 proc near
.text$x:00007044                                         ; DATA XREF: .xdata$x:00007500o
.text$x:00007044                 lea     ecx, [ebp-2B0h] ; this
.text$x:0000704A                 jmp     ??1CDirItem@@QAE@XZ ; CDirItem::~CDirItem(void)
.text$x:0000704A __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$13 endp
.text$x:0000704A
.text$x:0000704F
.text$x:0000704F ; =============== S U B R O U T I N E =======================================
.text$x:0000704F
.text$x:0000704F
.text$x:0000704F __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$14 proc near
.text$x:0000704F                                         ; DATA XREF: .xdata$x:00007508o
.text$x:0000704F                 lea     ecx, [ebp-30Ch] ; this
.text$x:00007055                 jmp     ??1CDirItem@@QAE@XZ ; CDirItem::~CDirItem(void)
.text$x:00007055 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$14 endp
.text$x:00007055
.text$x:0000705A
.text$x:0000705A ; =============== S U B R O U T I N E =======================================
.text$x:0000705A
.text$x:0000705A
.text$x:0000705A __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$15 proc near
.text$x:0000705A                                         ; DATA XREF: .xdata$x:00007510o
.text$x:0000705A                 lea     ecx, [ebp-360h] ; this
.text$x:00007060                 jmp     ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text$x:00007060 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$15 endp
.text$x:00007060
.text$x:00007065
.text$x:00007065 ; =============== S U B R O U T I N E =======================================
.text$x:00007065
.text$x:00007065
.text$x:00007065 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$16 proc near
.text$x:00007065                                         ; DATA XREF: .xdata$x:00007518o
.text$x:00007065                 lea     ecx, [ebp-374h] ; this
.text$x:0000706B                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:0000706B __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$16 endp
.text$x:0000706B
.text$x:00007070
.text$x:00007070 ; =============== S U B R O U T I N E =======================================
.text$x:00007070
.text$x:00007070
.text$x:00007070 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$17 proc near
.text$x:00007070                                         ; DATA XREF: .xdata$x:00007520o
.text$x:00007070                 lea     ecx, [ebp-394h] ; this
.text$x:00007076                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00007076 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$17 endp
.text$x:00007076
.text$x:0000707B
.text$x:0000707B ; =============== S U B R O U T I N E =======================================
.text$x:0000707B
.text$x:0000707B
.text$x:0000707B __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$18 proc near
.text$x:0000707B                                         ; DATA XREF: .xdata$x:00007528o
.text$x:0000707B                 lea     ecx, [ebp-3B0h] ; this
.text$x:00007081                 jmp     ??1CTempDir@NDir@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NDir::CTempDir::~CTempDir(void)
.text$x:00007081 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$18 endp
.text$x:00007081
.text$x:00007086
.text$x:00007086 ; =============== S U B R O U T I N E =======================================
.text$x:00007086
.text$x:00007086
.text$x:00007086 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$19 proc near
.text$x:00007086                                         ; DATA XREF: .xdata$x:00007530o
.text$x:00007086                 lea     ecx, [ebp-3C4h] ; this
.text$x:0000708C                 jmp     ??1CTempFiles@@QAE@XZ ; CTempFiles::~CTempFiles(void)
.text$x:0000708C __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$19 endp
.text$x:0000708C
.text$x:00007091
.text$x:00007091 ; =============== S U B R O U T I N E =======================================
.text$x:00007091
.text$x:00007091
.text$x:00007091 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$20 proc near
.text$x:00007091                                         ; DATA XREF: .xdata$x:00007538o
.text$x:00007091                 lea     ecx, [ebp-3E8h] ; this
.text$x:00007097                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00007097 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$20 endp
.text$x:00007097
.text$x:0000709C
.text$x:0000709C ; =============== S U B R O U T I N E =======================================
.text$x:0000709C
.text$x:0000709C
.text$x:0000709C __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$21 proc near
.text$x:0000709C                                         ; DATA XREF: .xdata$x:00007540o
.text$x:0000709C                 lea     ecx, [ebp-3FCh]
.text$x:000070A2                 jmp     ??1?$CObjectVector@UCArcItem@@@@QAE@XZ ; CObjectVector<CArcItem>::~CObjectVector<CArcItem>(void)
.text$x:000070A2 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$21 endp
.text$x:000070A2
.text$x:000070A7
.text$x:000070A7 ; =============== S U B R O U T I N E =======================================
.text$x:000070A7
.text$x:000070A7
.text$x:000070A7 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$22 proc near
.text$x:000070A7                                         ; DATA XREF: .xdata$x:00007548o
.text$x:000070A7                 lea     ecx, [ebp-410h]
.text$x:000070AD                 jmp     ??1?$CBuffer@E@@QAE@XZ ; CBuffer<uchar>::~CBuffer<uchar>(void)
.text$x:000070AD __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$22 endp
.text$x:000070AD
.text$x:000070B2
.text$x:000070B2 ; =============== S U B R O U T I N E =======================================
.text$x:000070B2
.text$x:000070B2
.text$x:000070B2 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$23 proc near
.text$x:000070B2                                         ; DATA XREF: .xdata$x:00007550o
.text$x:000070B2                 lea     ecx, [ebp-430h] ; this
.text$x:000070B8                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000070B8 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$23 endp
.text$x:000070B8
.text$x:000070BD
.text$x:000070BD ; =============== S U B R O U T I N E =======================================
.text$x:000070BD
.text$x:000070BD
.text$x:000070BD __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$24 proc near
.text$x:000070BD                                         ; DATA XREF: .xdata$x:00007558o
.text$x:000070BD                 lea     ecx, [ebp-6ACh] ; this
.text$x:000070C3                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000070C3 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$24 endp
.text$x:000070C3
.text$x:000070C8
.text$x:000070C8 ; =============== S U B R O U T I N E =======================================
.text$x:000070C8
.text$x:000070C8
.text$x:000070C8 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$25 proc near
.text$x:000070C8                                         ; DATA XREF: .xdata$x:00007568o
.text$x:000070C8                 lea     ecx, [ebp-470h] ; this
.text$x:000070CE                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000070CE __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$25 endp
.text$x:000070CE
.text$x:000070D3
.text$x:000070D3 ; =============== S U B R O U T I N E =======================================
.text$x:000070D3
.text$x:000070D3
.text$x:000070D3 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$26 proc near
.text$x:000070D3                                         ; DATA XREF: .xdata$x:00007578o
.text$x:000070D3                 lea     ecx, [ebp-47Ch] ; this
.text$x:000070D9                 jmp     ??1CLibrary@NDLL@NWindows@@QAE@XZ ; NWindows::NDLL::CLibrary::~CLibrary(void)
.text$x:000070D9 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$26 endp
.text$x:000070D9
.text$x:000070DE
.text$x:000070DE ; =============== S U B R O U T I N E =======================================
.text$x:000070DE
.text$x:000070DE
.text$x:000070DE __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$27 proc near
.text$x:000070DE                                         ; DATA XREF: .xdata$x:00007580o
.text$x:000070DE                 lea     ecx, [ebp-494h]
.text$x:000070E4                 jmp     ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text$x:000070E4 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$27 endp
.text$x:000070E4
.text$x:000070E9
.text$x:000070E9 ; =============== S U B R O U T I N E =======================================
.text$x:000070E9
.text$x:000070E9
.text$x:000070E9 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$28 proc near
.text$x:000070E9                                         ; DATA XREF: .xdata$x:00007588o
.text$x:000070E9                 lea     ecx, [ebp-4B0h] ; this
.text$x:000070EF                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000070EF __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$28 endp
.text$x:000070EF
.text$x:000070F4
.text$x:000070F4 ; =============== S U B R O U T I N E =======================================
.text$x:000070F4
.text$x:000070F4
.text$x:000070F4 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$29 proc near
.text$x:000070F4                                         ; DATA XREF: .xdata$x:00007590o
.text$x:000070F4                 lea     ecx, [ebp-4C4h] ; this
.text$x:000070FA                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000070FA __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$29 endp
.text$x:000070FA
.text$x:000070FF
.text$x:000070FF ; =============== S U B R O U T I N E =======================================
.text$x:000070FF
.text$x:000070FF
.text$x:000070FF __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$30 proc near
.text$x:000070FF                                         ; DATA XREF: .xdata$x:00007598o
.text$x:000070FF                 lea     ecx, [ebp-4DCh] ; this
.text$x:00007105                 jmp     ??1CCurrentDirRestorer@NDir@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NDir::CCurrentDirRestorer::~CCurrentDirRestorer(void)
.text$x:00007105 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$30 endp
.text$x:00007105
.text$x:0000710A
.text$x:0000710A ; =============== S U B R O U T I N E =======================================
.text$x:0000710A
.text$x:0000710A
.text$x:0000710A __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$31 proc near
.text$x:0000710A                                         ; DATA XREF: .xdata$x:000075A0o
.text$x:0000710A                 lea     ecx, [ebp-4F0h] ; this
.text$x:00007110                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00007110 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$31 endp
.text$x:00007110
.text$x:00007115
.text$x:00007115 ; =============== S U B R O U T I N E =======================================
.text$x:00007115
.text$x:00007115
.text$x:00007115 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$32 proc near
.text$x:00007115                                         ; DATA XREF: .xdata$x:000075A8o
.text$x:00007115                 lea     ecx, [ebp-504h] ; this
.text$x:0000711B                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:0000711B __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$32 endp
.text$x:0000711B
.text$x:00007120
.text$x:00007120 ; =============== S U B R O U T I N E =======================================
.text$x:00007120
.text$x:00007120
.text$x:00007120 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$33 proc near
.text$x:00007120                                         ; DATA XREF: .xdata$x:000075B0o
.text$x:00007120                 lea     ecx, [ebp-518h] ; this
.text$x:00007126                 jmp     ??1AString@@QAE@XZ ; AString::~AString(void)
.text$x:00007126 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$33 endp
.text$x:00007126
.text$x:0000712B
.text$x:0000712B ; =============== S U B R O U T I N E =======================================
.text$x:0000712B
.text$x:0000712B
.text$x:0000712B __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$34 proc near
.text$x:0000712B                                         ; DATA XREF: .xdata$x:000075B8o
.text$x:0000712B                 lea     ecx, [ebp-52Ch] ; this
.text$x:00007131                 jmp     ??1AString@@QAE@XZ ; AString::~AString(void)
.text$x:00007131 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$34 endp
.text$x:00007131
.text$x:00007136
.text$x:00007136 ; =============== S U B R O U T I N E =======================================
.text$x:00007136
.text$x:00007136
.text$x:00007136 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$35 proc near
.text$x:00007136                                         ; DATA XREF: .xdata$x:000075C0o
.text$x:00007136                 lea     ecx, [ebp-598h] ; this
.text$x:0000713C                 jmp     ??1AString@@QAE@XZ ; AString::~AString(void)
.text$x:0000713C __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$35 endp
.text$x:0000713C
.text$x:00007141
.text$x:00007141 ; =============== S U B R O U T I N E =======================================
.text$x:00007141
.text$x:00007141
.text$x:00007141 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$36 proc near
.text$x:00007141                                         ; DATA XREF: .xdata$x:000075C8o
.text$x:00007141                 lea     ecx, [ebp-5CCh]
.text$x:00007147                 jmp     ??1?$CRecordVector@UCRefSortPair@@@@QAE@XZ ; CRecordVector<CRefSortPair>::~CRecordVector<CRefSortPair>(void)
.text$x:00007147 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$36 endp
.text$x:00007147
.text$x:0000714C
.text$x:0000714C ; =============== S U B R O U T I N E =======================================
.text$x:0000714C
.text$x:0000714C
.text$x:0000714C __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$37 proc near
.text$x:0000714C                                         ; DATA XREF: .xdata$x:000075D0o
.text$x:0000714C                 lea     ecx, [ebp-5E0h]
.text$x:00007152                 jmp     ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text$x:00007152 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$37 endp
.text$x:00007152
.text$x:00007157
.text$x:00007157 ; =============== S U B R O U T I N E =======================================
.text$x:00007157
.text$x:00007157
.text$x:00007157 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$38 proc near
.text$x:00007157                                         ; DATA XREF: .xdata$x:000075D8o
.text$x:00007157                 lea     ecx, [ebp-5F8h] ; this
.text$x:0000715D                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:0000715D __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$38 endp
.text$x:0000715D
.text$x:00007162
.text$x:00007162 ; =============== S U B R O U T I N E =======================================
.text$x:00007162
.text$x:00007162
.text$x:00007162 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$39 proc near
.text$x:00007162                                         ; DATA XREF: .xdata$x:000075E0o
.text$x:00007162                 lea     ecx, [ebp-620h] ; this
.text$x:00007168                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00007168 __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$39 endp
.text$x:00007168
.text$x:0000716D
.text$x:0000716D ; =============== S U B R O U T I N E =======================================
.text$x:0000716D
.text$x:0000716D
.text$x:0000716D __ehhandler$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z proc near
.text$x:0000716D                                         ; DATA XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+5o
.text$x:0000716D
.text$x:0000716D arg_4           = dword ptr  8
.text$x:0000716D
.text$x:0000716D                 mov     edx, [esp+arg_4]
.text$x:00007171                 lea     eax, [edx+0Ch]
.text$x:00007174                 mov     ecx, [edx-72Ch]
.text$x:0000717A                 xor     ecx, eax
.text$x:0000717C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007181                 mov     eax, offset __ehfuncinfo$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z
.text$x:00007186                 jmp     ___CxxFrameHandler3
.text$x:00007186 __ehhandler$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z endp
.text$x:00007186
.text$x:0000718B
.text$x:0000718B ; =============== S U B R O U T I N E =======================================
.text$x:0000718B
.text$x:0000718B
.text$x:0000718B __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$0 proc near
.text$x:0000718B                                         ; DATA XREF: .xdata$x:0000760Co
.text$x:0000718B                 lea     ecx, [ebp-18h]
.text$x:0000718E                 jmp     ??1?$CMyComPtr@UIOutArchive@@@@QAE@XZ ; CMyComPtr<IOutArchive>::~CMyComPtr<IOutArchive>(void)
.text$x:0000718E __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$0 endp
.text$x:0000718E
.text$x:00007193
.text$x:00007193 ; =============== S U B R O U T I N E =======================================
.text$x:00007193
.text$x:00007193
.text$x:00007193 __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$1 proc near
.text$x:00007193                                         ; DATA XREF: .xdata$x:00007614o
.text$x:00007193                 lea     ecx, [ebp-28h]
.text$x:00007196                 jmp     ??1?$CMyComPtr@UIInArchive@@@@QAE@XZ ; CMyComPtr<IInArchive>::~CMyComPtr<IInArchive>(void)
.text$x:00007196 __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$1 endp
.text$x:00007196
.text$x:0000719B
.text$x:0000719B ; =============== S U B R O U T I N E =======================================
.text$x:0000719B
.text$x:0000719B
.text$x:0000719B __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$2 proc near
.text$x:0000719B                                         ; DATA XREF: .xdata$x:0000761Co
.text$x:0000719B                 lea     ecx, [ebp-5Ch]
.text$x:0000719E                 jmp     ??1?$CRecordVector@UCUpdatePair2@@@@QAE@XZ ; CRecordVector<CUpdatePair2>::~CRecordVector<CUpdatePair2>(void)
.text$x:0000719E __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$2 endp
.text$x:0000719E
.text$x:000071A3
.text$x:000071A3 ; =============== S U B R O U T I N E =======================================
.text$x:000071A3
.text$x:000071A3
.text$x:000071A3 __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$3 proc near
.text$x:000071A3                                         ; DATA XREF: .xdata$x:00007624o
.text$x:000071A3                 lea     ecx, [ebp-70h]
.text$x:000071A6                 jmp     ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text$x:000071A6 __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$3 endp
.text$x:000071A6
.text$x:000071AB
.text$x:000071AB ; =============== S U B R O U T I N E =======================================
.text$x:000071AB
.text$x:000071AB
.text$x:000071AB __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$4 proc near
.text$x:000071AB                                         ; DATA XREF: .xdata$x:0000762Co
.text$x:000071AB                 lea     ecx, [ebp-90h]  ; this
.text$x:000071B1                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000071B1 __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$4 endp
.text$x:000071B1
.text$x:000071B6
.text$x:000071B6 ; =============== S U B R O U T I N E =======================================
.text$x:000071B6
.text$x:000071B6
.text$x:000071B6 __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$5 proc near
.text$x:000071B6                                         ; DATA XREF: .xdata$x:00007634o
.text$x:000071B6                 lea     ecx, [ebp-0B0h] ; this
.text$x:000071BC                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000071BC __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$5 endp
.text$x:000071BC
.text$x:000071C1
.text$x:000071C1 ; =============== S U B R O U T I N E =======================================
.text$x:000071C1
.text$x:000071C1
.text$x:000071C1 __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$6 proc near
.text$x:000071C1                                         ; DATA XREF: .xdata$x:0000763Co
.text$x:000071C1                 lea     ecx, [ebp-0E4h]
.text$x:000071C7                 jmp     ??1?$CRecordVector@UCUpdatePair@@@@QAE@XZ ; CRecordVector<CUpdatePair>::~CRecordVector<CUpdatePair>(void)
.text$x:000071C7 __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$6 endp
.text$x:000071C7
.text$x:000071CC
.text$x:000071CC ; =============== S U B R O U T I N E =======================================
.text$x:000071CC
.text$x:000071CC
.text$x:000071CC __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$7 proc near
.text$x:000071CC                                         ; DATA XREF: .xdata$x:00007644o
.text$x:000071CC                 mov     eax, [ebp-268h]
.text$x:000071D2                 push    eax             ; void *
.text$x:000071D3                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:000071D8                 pop     ecx
.text$x:000071D9                 retn
.text$x:000071D9 __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$7 endp
.text$x:000071D9
.text$x:000071DA
.text$x:000071DA ; =============== S U B R O U T I N E =======================================
.text$x:000071DA
.text$x:000071DA
.text$x:000071DA __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$8 proc near
.text$x:000071DA                                         ; DATA XREF: .xdata$x:0000764Co
.text$x:000071DA                 lea     ecx, [ebp-114h]
.text$x:000071E0                 jmp     ??1?$CMyComPtr@UIArchiveUpdateCallback@@@@QAE@XZ ; CMyComPtr<IArchiveUpdateCallback>::~CMyComPtr<IArchiveUpdateCallback>(void)
.text$x:000071E0 __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$8 endp
.text$x:000071E0
.text$x:000071E5
.text$x:000071E5 ; =============== S U B R O U T I N E =======================================
.text$x:000071E5
.text$x:000071E5
.text$x:000071E5 __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$9 proc near
.text$x:000071E5                                         ; DATA XREF: .xdata$x:00007654o
.text$x:000071E5                 lea     ecx, [ebp-120h]
.text$x:000071EB                 jmp     ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::~CMyComPtr<IOutStream>(void)
.text$x:000071EB __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$9 endp
.text$x:000071EB
.text$x:000071F0
.text$x:000071F0 ; =============== S U B R O U T I N E =======================================
.text$x:000071F0
.text$x:000071F0
.text$x:000071F0 __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$10 proc near
.text$x:000071F0                                         ; DATA XREF: .xdata$x:0000765Co
.text$x:000071F0                 lea     ecx, [ebp-12Ch]
.text$x:000071F6                 jmp     ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text$x:000071F6 __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$10 endp
.text$x:000071F6
.text$x:000071FB
.text$x:000071FB ; =============== S U B R O U T I N E =======================================
.text$x:000071FB
.text$x:000071FB
.text$x:000071FB __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$11 proc near
.text$x:000071FB                                         ; DATA XREF: .xdata$x:00007664o
.text$x:000071FB                 lea     ecx, [ebp-140h] ; this
.text$x:00007201                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00007201 __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$11 endp
.text$x:00007201
.text$x:00007206
.text$x:00007206 ; =============== S U B R O U T I N E =======================================
.text$x:00007206
.text$x:00007206
.text$x:00007206 __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$12 proc near
.text$x:00007206                                         ; DATA XREF: .xdata$x:0000766Co
.text$x:00007206                 lea     ecx, [ebp-278h] ; this
.text$x:0000720C                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:0000720C __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$12 endp
.text$x:0000720C
.text$x:00007211
.text$x:00007211 ; =============== S U B R O U T I N E =======================================
.text$x:00007211
.text$x:00007211
.text$x:00007211 __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$13 proc near
.text$x:00007211                                         ; DATA XREF: .xdata$x:00007674o
.text$x:00007211                 mov     eax, [ebp-284h]
.text$x:00007217                 push    eax             ; void *
.text$x:00007218                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:0000721D                 pop     ecx
.text$x:0000721E                 retn
.text$x:0000721E __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$13 endp
.text$x:0000721E
.text$x:0000721F
.text$x:0000721F ; =============== S U B R O U T I N E =======================================
.text$x:0000721F
.text$x:0000721F
.text$x:0000721F __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$14 proc near
.text$x:0000721F                                         ; DATA XREF: .xdata$x:0000767Co
.text$x:0000721F                 mov     eax, [ebp-28Ch]
.text$x:00007225                 push    eax             ; void *
.text$x:00007226                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:0000722B                 pop     ecx
.text$x:0000722C                 retn
.text$x:0000722C __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$14 endp
.text$x:0000722C
.text$x:0000722D
.text$x:0000722D ; =============== S U B R O U T I N E =======================================
.text$x:0000722D
.text$x:0000722D
.text$x:0000722D __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$15 proc near
.text$x:0000722D                                         ; DATA XREF: .xdata$x:00007684o
.text$x:0000722D                 lea     ecx, [ebp-164h] ; this
.text$x:00007233                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00007233 __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$15 endp
.text$x:00007233
.text$x:00007238
.text$x:00007238 ; =============== S U B R O U T I N E =======================================
.text$x:00007238
.text$x:00007238
.text$x:00007238 __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$16 proc near
.text$x:00007238                                         ; DATA XREF: .xdata$x:0000768Co
.text$x:00007238                 lea     ecx, [ebp-298h] ; this
.text$x:0000723E                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:0000723E __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$16 endp
.text$x:0000723E
.text$x:00007243
.text$x:00007243 ; =============== S U B R O U T I N E =======================================
.text$x:00007243
.text$x:00007243
.text$x:00007243 __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$17 proc near
.text$x:00007243                                         ; DATA XREF: .xdata$x:00007694o
.text$x:00007243                 lea     ecx, [ebp-2A4h] ; this
.text$x:00007249                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00007249 __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$17 endp
.text$x:00007249
.text$x:0000724E
.text$x:0000724E ; =============== S U B R O U T I N E =======================================
.text$x:0000724E
.text$x:0000724E
.text$x:0000724E __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$18 proc near
.text$x:0000724E                                         ; DATA XREF: .xdata$x:0000769Co
.text$x:0000724E                 mov     eax, [ebp-2B8h]
.text$x:00007254                 push    eax             ; void *
.text$x:00007255                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:0000725A                 pop     ecx
.text$x:0000725B                 retn
.text$x:0000725B __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$18 endp
.text$x:0000725B
.text$x:0000725C
.text$x:0000725C ; =============== S U B R O U T I N E =======================================
.text$x:0000725C
.text$x:0000725C
.text$x:0000725C __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$19 proc near
.text$x:0000725C                                         ; DATA XREF: .xdata$x:000076A4o
.text$x:0000725C                 lea     ecx, [ebp-2C4h] ; this
.text$x:00007262                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00007262 __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$19 endp
.text$x:00007262
.text$x:00007267
.text$x:00007267 ; =============== S U B R O U T I N E =======================================
.text$x:00007267
.text$x:00007267
.text$x:00007267 __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$20 proc near
.text$x:00007267                                         ; DATA XREF: .xdata$x:000076ACo
.text$x:00007267                 mov     eax, [ebp-2D0h]
.text$x:0000726D                 push    eax             ; void *
.text$x:0000726E                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00007273                 pop     ecx
.text$x:00007274                 retn
.text$x:00007274 __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$20 endp
.text$x:00007274
.text$x:00007275
.text$x:00007275 ; =============== S U B R O U T I N E =======================================
.text$x:00007275
.text$x:00007275
.text$x:00007275 __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$21 proc near
.text$x:00007275                                         ; DATA XREF: .xdata$x:000076B4o
.text$x:00007275                 lea     ecx, [ebp-1A4h]
.text$x:0000727B                 jmp     ??1?$CMyComPtr@UIInStream@@@@QAE@XZ ; CMyComPtr<IInStream>::~CMyComPtr<IInStream>(void)
.text$x:0000727B __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$21 endp
.text$x:0000727B
.text$x:00007280
.text$x:00007280 ; =============== S U B R O U T I N E =======================================
.text$x:00007280
.text$x:00007280
.text$x:00007280 __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$22 proc near
.text$x:00007280                                         ; DATA XREF: .xdata$x:000076BCo
.text$x:00007280                 lea     ecx, [ebp-1B0h]
.text$x:00007286                 jmp     ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text$x:00007286 __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$22 endp
.text$x:00007286
.text$x:0000728B
.text$x:0000728B ; =============== S U B R O U T I N E =======================================
.text$x:0000728B
.text$x:0000728B
.text$x:0000728B __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$23 proc near
.text$x:0000728B                                         ; DATA XREF: .xdata$x:000076C4o
.text$x:0000728B                 mov     eax, [ebp-2DCh]
.text$x:00007291                 push    eax             ; void *
.text$x:00007292                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00007297                 pop     ecx
.text$x:00007298                 retn
.text$x:00007298 __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$23 endp
.text$x:00007298
.text$x:00007299
.text$x:00007299 ; =============== S U B R O U T I N E =======================================
.text$x:00007299
.text$x:00007299
.text$x:00007299 __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$24 proc near
.text$x:00007299                                         ; DATA XREF: .xdata$x:000076CCo
.text$x:00007299                 lea     ecx, [ebp-1C8h] ; this
.text$x:0000729F                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:0000729F __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$24 endp
.text$x:0000729F
.text$x:000072A4
.text$x:000072A4 ; =============== S U B R O U T I N E =======================================
.text$x:000072A4
.text$x:000072A4
.text$x:000072A4 __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$25 proc near
.text$x:000072A4                                         ; DATA XREF: .xdata$x:000076D4o
.text$x:000072A4                 lea     ecx, [ebp-1F4h]
.text$x:000072AA                 jmp     ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text$x:000072AA __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$25 endp
.text$x:000072AA
.text$x:000072AF
.text$x:000072AF ; =============== S U B R O U T I N E =======================================
.text$x:000072AF
.text$x:000072AF
.text$x:000072AF __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$26 proc near
.text$x:000072AF                                         ; DATA XREF: .xdata$x:000076DCo
.text$x:000072AF                 mov     eax, [ebp-300h]
.text$x:000072B5                 push    eax             ; void *
.text$x:000072B6                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:000072BB                 pop     ecx
.text$x:000072BC                 retn
.text$x:000072BC __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$26 endp
.text$x:000072BC
.text$x:000072BD
.text$x:000072BD ; =============== S U B R O U T I N E =======================================
.text$x:000072BD
.text$x:000072BD
.text$x:000072BD __ehhandler$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z proc near
.text$x:000072BD                                         ; DATA XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+5o
.text$x:000072BD
.text$x:000072BD arg_4           = dword ptr  8
.text$x:000072BD
.text$x:000072BD                 mov     edx, [esp+arg_4]
.text$x:000072C1                 lea     eax, [edx+0Ch]
.text$x:000072C4                 mov     ecx, [edx-364h]
.text$x:000072CA                 xor     ecx, eax
.text$x:000072CC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000072D1                 mov     ecx, [edx-4]
.text$x:000072D4                 xor     ecx, eax
.text$x:000072D6                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000072DB                 mov     eax, offset __ehfuncinfo$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z
.text$x:000072E0                 jmp     ___CxxFrameHandler3
.text$x:000072E0 __ehhandler$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z endp
.text$x:000072E0
.text$x:000072E5
.text$x:000072E5 ; =============== S U B R O U T I N E =======================================
.text$x:000072E5
.text$x:000072E5
.text$x:000072E5 __unwindfunclet$?EnumerateInArchiveItems@@YGJABVCCensor@NWildcard@@ABVCArc@@AAV?$CObjectVector@UCArcItem@@@@@Z$0 proc near
.text$x:000072E5                                         ; DATA XREF: .xdata$x:000076E4o
.text$x:000072E5                 lea     ecx, [ebp-64h]  ; this
.text$x:000072E8                 jmp     ??1CReadArcItem@@QAE@XZ ; CReadArcItem::~CReadArcItem(void)
.text$x:000072E8 __unwindfunclet$?EnumerateInArchiveItems@@YGJABVCCensor@NWildcard@@ABVCArc@@AAV?$CObjectVector@UCArcItem@@@@@Z$0 endp
.text$x:000072E8
.text$x:000072ED
.text$x:000072ED ; =============== S U B R O U T I N E =======================================
.text$x:000072ED
.text$x:000072ED
.text$x:000072ED __unwindfunclet$?EnumerateInArchiveItems@@YGJABVCCensor@NWildcard@@ABVCArc@@AAV?$CObjectVector@UCArcItem@@@@@Z$1 proc near
.text$x:000072ED                                         ; DATA XREF: .xdata$x:000076ECo
.text$x:000072ED                 lea     ecx, [ebp-0A0h] ; this
.text$x:000072F3                 jmp     ??1CArcItem@@QAE@XZ ; CArcItem::~CArcItem(void)
.text$x:000072F3 __unwindfunclet$?EnumerateInArchiveItems@@YGJABVCCensor@NWildcard@@ABVCArc@@AAV?$CObjectVector@UCArcItem@@@@@Z$1 endp
.text$x:000072F3
.text$x:000072F8
.text$x:000072F8 ; =============== S U B R O U T I N E =======================================
.text$x:000072F8
.text$x:000072F8
.text$x:000072F8 __unwindfunclet$?EnumerateInArchiveItems@@YGJABVCCensor@NWildcard@@ABVCArc@@AAV?$CObjectVector@UCArcItem@@@@@Z$2 proc near
.text$x:000072F8                                         ; DATA XREF: .xdata$x:000076F4o
.text$x:000072F8                 lea     ecx, [ebp-0C4h] ; this
.text$x:000072FE                 jmp     ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text$x:000072FE __unwindfunclet$?EnumerateInArchiveItems@@YGJABVCCensor@NWildcard@@ABVCArc@@AAV?$CObjectVector@UCArcItem@@@@@Z$2 endp
.text$x:000072FE
.text$x:00007303
.text$x:00007303 ; =============== S U B R O U T I N E =======================================
.text$x:00007303
.text$x:00007303
.text$x:00007303 __ehhandler$?EnumerateInArchiveItems@@YGJABVCCensor@NWildcard@@ABVCArc@@AAV?$CObjectVector@UCArcItem@@@@@Z proc near
.text$x:00007303                                         ; DATA XREF: EnumerateInArchiveItems(NWildcard::CCensor const &,CArc const &,CObjectVector<CArcItem> &)+5o
.text$x:00007303
.text$x:00007303 arg_4           = dword ptr  8
.text$x:00007303
.text$x:00007303                 mov     edx, [esp+arg_4]
.text$x:00007307                 lea     eax, [edx+0Ch]
.text$x:0000730A                 mov     ecx, [edx-0E8h]
.text$x:00007310                 xor     ecx, eax
.text$x:00007312                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007317                 mov     eax, offset __ehfuncinfo$?EnumerateInArchiveItems@@YGJABVCCensor@NWildcard@@ABVCArc@@AAV?$CObjectVector@UCArcItem@@@@@Z
.text$x:0000731C                 jmp     ___CxxFrameHandler3
.text$x:0000731C __ehhandler$?EnumerateInArchiveItems@@YGJABVCCensor@NWildcard@@ABVCArc@@AAV?$CObjectVector@UCArcItem@@@@@Z endp
.text$x:0000731C
.text$x:0000731C ; ---------------------------------------------------------------------------
.text$x:00007321                 align 4
.text$x:00007321 _text$x         ends
.text$x:00007321
.xdata$x:00007324 ; ===========================================================================
.xdata$x:00007324
.xdata$x:00007324 ; Segment type: Pure data
.xdata$x:00007324 ; Segment permissions: Read
.xdata$x:00007324 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007324                 assume cs:_xdata$x
.xdata$x:00007324                 ;org 7324h
.xdata$x:00007324 __unwindtable$?ParseFromPath@CArchivePath@@QAEXABVUString@@W4EArcNameMode@@@Z db 0FFh
.xdata$x:00007324                                         ; DATA XREF: .xdata$x:00007334o
.xdata$x:00007325                 db 0FFh
.xdata$x:00007326                 db 0FFh
.xdata$x:00007327                 db 0FFh
.xdata$x:00007328                 dd offset __unwindfunclet$?ParseFromPath@CArchivePath@@QAEXABVUString@@W4EArcNameMode@@@Z$0
.xdata$x:0000732C __ehfuncinfo$?ParseFromPath@CArchivePath@@QAEXABVUString@@W4EArcNameMode@@@Z db  22h ; "
.xdata$x:0000732C                                         ; DATA XREF: __ehhandler$?ParseFromPath@CArchivePath@@QAEXABVUString@@W4EArcNameMode@@@Z+11o
.xdata$x:0000732D                 db    5
.xdata$x:0000732E                 db  93h ; 
.xdata$x:0000732F                 db  19h
.xdata$x:00007330                 db    1
.xdata$x:00007331                 db    0
.xdata$x:00007332                 db    0
.xdata$x:00007333                 db    0
.xdata$x:00007334                 dd offset __unwindtable$?ParseFromPath@CArchivePath@@QAEXABVUString@@W4EArcNameMode@@@Z
.xdata$x:00007338                 db    0
.xdata$x:00007339                 db    0
.xdata$x:0000733A                 db    0
.xdata$x:0000733B                 db    0
.xdata$x:0000733C                 db    0
.xdata$x:0000733D                 db    0
.xdata$x:0000733E                 db    0
.xdata$x:0000733F                 db    0
.xdata$x:00007340                 db    0
.xdata$x:00007341                 db    0
.xdata$x:00007342                 db    0
.xdata$x:00007343                 db    0
.xdata$x:00007344                 db    0
.xdata$x:00007345                 db    0
.xdata$x:00007346                 db    0
.xdata$x:00007347                 db    0
.xdata$x:00007348                 db    0
.xdata$x:00007349                 db    0
.xdata$x:0000734A                 db    0
.xdata$x:0000734B                 db    0
.xdata$x:0000734C                 db    1
.xdata$x:0000734D                 db    0
.xdata$x:0000734E                 db    0
.xdata$x:0000734F                 db    0
.xdata$x:00007350 __unwindtable$?GetFinalPath@CArchivePath@@QBE?AVUString@@XZ db 0FFh
.xdata$x:00007350                                         ; DATA XREF: .xdata$x:00007368o
.xdata$x:00007351                 db 0FFh
.xdata$x:00007352                 db 0FFh
.xdata$x:00007353                 db 0FFh
.xdata$x:00007354                 dd offset __unwindfunclet$?GetFinalPath@CArchivePath@@QBE?AVUString@@XZ$1
.xdata$x:00007358                 db    0
.xdata$x:00007359                 db    0
.xdata$x:0000735A                 db    0
.xdata$x:0000735B                 db    0
.xdata$x:0000735C                 dd offset __unwindfunclet$?GetFinalPath@CArchivePath@@QBE?AVUString@@XZ$0
.xdata$x:00007360 __ehfuncinfo$?GetFinalPath@CArchivePath@@QBE?AVUString@@XZ db  22h ; "
.xdata$x:00007360                                         ; DATA XREF: __ehhandler$?GetFinalPath@CArchivePath@@QBE?AVUString@@XZ+11o
.xdata$x:00007361                 db    5
.xdata$x:00007362                 db  93h ; 
.xdata$x:00007363                 db  19h
.xdata$x:00007364                 db    2
.xdata$x:00007365                 db    0
.xdata$x:00007366                 db    0
.xdata$x:00007367                 db    0
.xdata$x:00007368                 dd offset __unwindtable$?GetFinalPath@CArchivePath@@QBE?AVUString@@XZ
.xdata$x:0000736C                 align 20h
.xdata$x:00007380                 db    1
.xdata$x:00007381                 db    0
.xdata$x:00007382                 db    0
.xdata$x:00007383                 db    0
.xdata$x:00007384 __unwindtable$?GetFinalVolPath@CArchivePath@@QBE?AVUString@@XZ db 0FFh
.xdata$x:00007384                                         ; DATA XREF: .xdata$x:0000739Co
.xdata$x:00007385                 db 0FFh
.xdata$x:00007386                 db 0FFh
.xdata$x:00007387                 db 0FFh
.xdata$x:00007388                 dd offset __unwindfunclet$?GetFinalVolPath@CArchivePath@@QBE?AVUString@@XZ$1
.xdata$x:0000738C                 align 10h
.xdata$x:00007390                 dd offset __unwindfunclet$?GetFinalVolPath@CArchivePath@@QBE?AVUString@@XZ$0
.xdata$x:00007394 __ehfuncinfo$?GetFinalVolPath@CArchivePath@@QBE?AVUString@@XZ db  22h ; "
.xdata$x:00007394                                         ; DATA XREF: __ehhandler$?GetFinalVolPath@CArchivePath@@QBE?AVUString@@XZ+11o
.xdata$x:00007395                 db    5
.xdata$x:00007396                 db  93h ; 
.xdata$x:00007397                 db  19h
.xdata$x:00007398                 db    2
.xdata$x:00007399                 db    0
.xdata$x:0000739A                 db    0
.xdata$x:0000739B                 db    0
.xdata$x:0000739C                 dd offset __unwindtable$?GetFinalVolPath@CArchivePath@@QBE?AVUString@@XZ
.xdata$x:000073A0                 db    0
.xdata$x:000073A1                 db    0
.xdata$x:000073A2                 db    0
.xdata$x:000073A3                 db    0
.xdata$x:000073A4                 db    0
.xdata$x:000073A5                 db    0
.xdata$x:000073A6                 db    0
.xdata$x:000073A7                 db    0
.xdata$x:000073A8                 db    0
.xdata$x:000073A9                 db    0
.xdata$x:000073AA                 db    0
.xdata$x:000073AB                 db    0
.xdata$x:000073AC                 db    0
.xdata$x:000073AD                 db    0
.xdata$x:000073AE                 db    0
.xdata$x:000073AF                 db    0
.xdata$x:000073B0                 db    0
.xdata$x:000073B1                 db    0
.xdata$x:000073B2                 db    0
.xdata$x:000073B3                 db    0
.xdata$x:000073B4                 db    1
.xdata$x:000073B5                 db    0
.xdata$x:000073B6                 db    0
.xdata$x:000073B7                 db    0
.xdata$x:000073B8 __unwindtable$?GetTempPathA@CArchivePath@@QBE?AVUString@@XZ db 0FFh
.xdata$x:000073B8                                         ; DATA XREF: .xdata$x:000073D0o
.xdata$x:000073B9                 db 0FFh
.xdata$x:000073BA                 db 0FFh
.xdata$x:000073BB                 db 0FFh
.xdata$x:000073BC                 dd offset __unwindfunclet$?GetTempPathA@CArchivePath@@QBE?AVUString@@XZ$1
.xdata$x:000073C0                 db    0
.xdata$x:000073C1                 db    0
.xdata$x:000073C2                 db    0
.xdata$x:000073C3                 db    0
.xdata$x:000073C4                 dd offset __unwindfunclet$?GetTempPathA@CArchivePath@@QBE?AVUString@@XZ$0
.xdata$x:000073C8 __ehfuncinfo$?GetTempPathA@CArchivePath@@QBE?AVUString@@XZ db  22h ; "
.xdata$x:000073C8                                         ; DATA XREF: __ehhandler$?GetTempPathA@CArchivePath@@QBE?AVUString@@XZ+11o
.xdata$x:000073C9                 db    5
.xdata$x:000073CA                 db  93h ; 
.xdata$x:000073CB                 db  19h
.xdata$x:000073CC                 db    2
.xdata$x:000073CD                 db    0
.xdata$x:000073CE                 db    0
.xdata$x:000073CF                 db    0
.xdata$x:000073D0                 dd offset __unwindtable$?GetTempPathA@CArchivePath@@QBE?AVUString@@XZ
.xdata$x:000073D4                 db    0
.xdata$x:000073D5                 db    0
.xdata$x:000073D6                 db    0
.xdata$x:000073D7                 db    0
.xdata$x:000073D8                 db    0
.xdata$x:000073D9                 db    0
.xdata$x:000073DA                 db    0
.xdata$x:000073DB                 db    0
.xdata$x:000073DC                 db    0
.xdata$x:000073DD                 db    0
.xdata$x:000073DE                 db    0
.xdata$x:000073DF                 db    0
.xdata$x:000073E0                 db    0
.xdata$x:000073E1                 db    0
.xdata$x:000073E2                 db    0
.xdata$x:000073E3                 db    0
.xdata$x:000073E4                 db    0
.xdata$x:000073E5                 db    0
.xdata$x:000073E6                 db    0
.xdata$x:000073E7                 db    0
.xdata$x:000073E8                 db    1
.xdata$x:000073E9                 db    0
.xdata$x:000073EA                 db    0
.xdata$x:000073EB                 db    0
.xdata$x:000073EC __unwindtable$?SetArcPath@CUpdateOptions@@QAE_NPBVCCodecs@@ABVUString@@@Z db 0FFh
.xdata$x:000073EC                                         ; DATA XREF: .xdata$x:0000740Co
.xdata$x:000073ED                 db 0FFh
.xdata$x:000073EE                 db 0FFh
.xdata$x:000073EF                 db 0FFh
.xdata$x:000073F0                 dd offset __unwindfunclet$?SetArcPath@CUpdateOptions@@QAE_NPBVCCodecs@@ABVUString@@@Z$0
.xdata$x:000073F4                 align 8
.xdata$x:000073F8                 dd offset __unwindfunclet$?SetArcPath@CUpdateOptions@@QAE_NPBVCCodecs@@ABVUString@@@Z$1
.xdata$x:000073FC                 align 10h
.xdata$x:00007400                 dd offset __unwindfunclet$?SetArcPath@CUpdateOptions@@QAE_NPBVCCodecs@@ABVUString@@@Z$2
.xdata$x:00007404 __ehfuncinfo$?SetArcPath@CUpdateOptions@@QAE_NPBVCCodecs@@ABVUString@@@Z db  22h ; "
.xdata$x:00007404                                         ; DATA XREF: __ehhandler$?SetArcPath@CUpdateOptions@@QAE_NPBVCCodecs@@ABVUString@@@Z+11o
.xdata$x:00007405                 db    5
.xdata$x:00007406                 db  93h ; 
.xdata$x:00007407                 db  19h
.xdata$x:00007408                 db    3
.xdata$x:00007409                 db    0
.xdata$x:0000740A                 db    0
.xdata$x:0000740B                 db    0
.xdata$x:0000740C                 dd offset __unwindtable$?SetArcPath@CUpdateOptions@@QAE_NPBVCCodecs@@ABVUString@@@Z
.xdata$x:00007410                 db    0
.xdata$x:00007411                 db    0
.xdata$x:00007412                 db    0
.xdata$x:00007413                 db    0
.xdata$x:00007414                 db    0
.xdata$x:00007415                 db    0
.xdata$x:00007416                 db    0
.xdata$x:00007417                 db    0
.xdata$x:00007418                 db    0
.xdata$x:00007419                 db    0
.xdata$x:0000741A                 db    0
.xdata$x:0000741B                 db    0
.xdata$x:0000741C                 db    0
.xdata$x:0000741D                 db    0
.xdata$x:0000741E                 db    0
.xdata$x:0000741F                 db    0
.xdata$x:00007420                 db    0
.xdata$x:00007421                 db    0
.xdata$x:00007422                 db    0
.xdata$x:00007423                 db    0
.xdata$x:00007424                 db    1
.xdata$x:00007425                 db    0
.xdata$x:00007426                 db    0
.xdata$x:00007427                 db    0
.xdata$x:00007428 __unwindtable$?GetNewPath@CRenamePair@@QBE_N_NABVUString@@AAV2@@Z db 0FFh
.xdata$x:00007428                                         ; DATA XREF: .xdata$x:00007438o
.xdata$x:00007429                 db 0FFh
.xdata$x:0000742A                 db 0FFh
.xdata$x:0000742B                 db 0FFh
.xdata$x:0000742C                 dd offset __unwindfunclet$?GetNewPath@CRenamePair@@QBE_N_NABVUString@@AAV2@@Z$0
.xdata$x:00007430 __ehfuncinfo$?GetNewPath@CRenamePair@@QBE_N_NABVUString@@AAV2@@Z db  22h ; "
.xdata$x:00007430                                         ; DATA XREF: __ehhandler$?GetNewPath@CRenamePair@@QBE_N_NABVUString@@AAV2@@Z+11o
.xdata$x:00007431                 db    5
.xdata$x:00007432                 db  93h ; 
.xdata$x:00007433                 db  19h
.xdata$x:00007434                 db    1
.xdata$x:00007435                 db    0
.xdata$x:00007436                 db    0
.xdata$x:00007437                 db    0
.xdata$x:00007438                 dd offset __unwindtable$?GetNewPath@CRenamePair@@QBE_N_NABVUString@@AAV2@@Z
.xdata$x:0000743C                 db    0
.xdata$x:0000743D                 db    0
.xdata$x:0000743E                 db    0
.xdata$x:0000743F                 db    0
.xdata$x:00007440                 db    0
.xdata$x:00007441                 db    0
.xdata$x:00007442                 db    0
.xdata$x:00007443                 db    0
.xdata$x:00007444                 db    0
.xdata$x:00007445                 db    0
.xdata$x:00007446                 db    0
.xdata$x:00007447                 db    0
.xdata$x:00007448                 db    0
.xdata$x:00007449                 db    0
.xdata$x:0000744A                 db    0
.xdata$x:0000744B                 db    0
.xdata$x:0000744C                 db    0
.xdata$x:0000744D                 db    0
.xdata$x:0000744E                 db    0
.xdata$x:0000744F                 db    0
.xdata$x:00007450                 db    1
.xdata$x:00007451                 db    0
.xdata$x:00007452                 db    0
.xdata$x:00007453                 db    0
.xdata$x:00007454 __catchsym$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$40 dd offset $SG74378
.xdata$x:00007454                                         ; DATA XREF: .xdata$x:00007474o
.xdata$x:00007454                                         ; ".tmp"
.xdata$x:00007458                 align 10h
.xdata$x:00007460                 dd offset __catch$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$0
.xdata$x:00007464 __tryblocktable$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z db  18h
.xdata$x:00007464                                         ; DATA XREF: .xdata$x:00007488o
.xdata$x:00007465                 db    0
.xdata$x:00007466                 db    0
.xdata$x:00007467                 db    0
.xdata$x:00007468                 db  19h
.xdata$x:00007469                 db    0
.xdata$x:0000746A                 db    0
.xdata$x:0000746B                 db    0
.xdata$x:0000746C                 db  1Ah
.xdata$x:0000746D                 db    0
.xdata$x:0000746E                 db    0
.xdata$x:0000746F                 db    0
.xdata$x:00007470                 db    1
.xdata$x:00007471                 db    0
.xdata$x:00007472                 db    0
.xdata$x:00007473                 db    0
.xdata$x:00007474                 dd offset __catchsym$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$40
.xdata$x:00007478 __ehfuncinfo$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z db  22h ; "
.xdata$x:00007478                                         ; DATA XREF: __ehhandler$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z+14o
.xdata$x:00007479                 db    5
.xdata$x:0000747A                 db  93h ; 
.xdata$x:0000747B                 db  19h
.xdata$x:0000747C                 db  29h ; )
.xdata$x:0000747D                 db    0
.xdata$x:0000747E                 db    0
.xdata$x:0000747F                 db    0
.xdata$x:00007480                 dd offset __unwindtable$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z
.xdata$x:00007484                 db    1
.xdata$x:00007485                 db    0
.xdata$x:00007486                 db    0
.xdata$x:00007487                 db    0
.xdata$x:00007488                 dd offset __tryblocktable$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z
.xdata$x:0000748C                 db    0
.xdata$x:0000748D                 db    0
.xdata$x:0000748E                 db    0
.xdata$x:0000748F                 db    0
.xdata$x:00007490                 db    0
.xdata$x:00007491                 db    0
.xdata$x:00007492                 db    0
.xdata$x:00007493                 db    0
.xdata$x:00007494                 db    0
.xdata$x:00007495                 db    0
.xdata$x:00007496                 db    0
.xdata$x:00007497                 db    0
.xdata$x:00007498                 db    1
.xdata$x:00007499                 db    0
.xdata$x:0000749A                 db    0
.xdata$x:0000749B                 db    0
.xdata$x:0000749C __unwindtable$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z db 0FFh
.xdata$x:0000749C                                         ; DATA XREF: .xdata$x:00007480o
.xdata$x:0000749D                 db 0FFh
.xdata$x:0000749E                 db 0FFh
.xdata$x:0000749F                 db 0FFh
.xdata$x:000074A0                 dd offset __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$2
.xdata$x:000074A4                 align 8
.xdata$x:000074A8                 dd offset __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$3
.xdata$x:000074AC                 db    1
.xdata$x:000074AD                 db    0
.xdata$x:000074AE                 db    0
.xdata$x:000074AF                 db    0
.xdata$x:000074B0                 dd offset __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$4
.xdata$x:000074B4                 align 8
.xdata$x:000074B8                 dd offset __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$4
.xdata$x:000074BC                 db 0FFh
.xdata$x:000074BD                 db 0FFh
.xdata$x:000074BE                 db 0FFh
.xdata$x:000074BF                 db 0FFh
.xdata$x:000074C0                 dd offset __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$5
.xdata$x:000074C4                 db    4
.xdata$x:000074C5                 db    0
.xdata$x:000074C6                 db    0
.xdata$x:000074C7                 db    0
.xdata$x:000074C8                 dd offset __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$6
.xdata$x:000074CC                 db    5
.xdata$x:000074CD                 db    0
.xdata$x:000074CE                 db    0
.xdata$x:000074CF                 db    0
.xdata$x:000074D0                 dd offset __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$7
.xdata$x:000074D4                 db    6
.xdata$x:000074D5                 db    0
.xdata$x:000074D6                 db    0
.xdata$x:000074D7                 db    0
.xdata$x:000074D8                 dd offset __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$8
.xdata$x:000074DC                 db    7
.xdata$x:000074DD                 db    0
.xdata$x:000074DE                 db    0
.xdata$x:000074DF                 db    0
.xdata$x:000074E0                 dd offset __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$9
.xdata$x:000074E4                 db    8
.xdata$x:000074E5                 db    0
.xdata$x:000074E6                 db    0
.xdata$x:000074E7                 db    0
.xdata$x:000074E8                 dd offset __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$10
.xdata$x:000074EC                 db    5
.xdata$x:000074ED                 db    0
.xdata$x:000074EE                 db    0
.xdata$x:000074EF                 db    0
.xdata$x:000074F0                 dd offset __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$11
.xdata$x:000074F4                 db    5
.xdata$x:000074F5                 db    0
.xdata$x:000074F6                 db    0
.xdata$x:000074F7                 db    0
.xdata$x:000074F8                 dd offset __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$12
.xdata$x:000074FC                 db  0Bh
.xdata$x:000074FD                 db    0
.xdata$x:000074FE                 db    0
.xdata$x:000074FF                 db    0
.xdata$x:00007500                 dd offset __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$13
.xdata$x:00007504                 db  0Ch
.xdata$x:00007505                 db    0
.xdata$x:00007506                 db    0
.xdata$x:00007507                 db    0
.xdata$x:00007508                 dd offset __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$14
.xdata$x:0000750C                 db  0Ch
.xdata$x:0000750D                 db    0
.xdata$x:0000750E                 db    0
.xdata$x:0000750F                 db    0
.xdata$x:00007510                 dd offset __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$15
.xdata$x:00007514                 db  0Eh
.xdata$x:00007515                 db    0
.xdata$x:00007516                 db    0
.xdata$x:00007517                 db    0
.xdata$x:00007518                 dd offset __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$16
.xdata$x:0000751C                 db  0Ch
.xdata$x:0000751D                 db    0
.xdata$x:0000751E                 db    0
.xdata$x:0000751F                 db    0
.xdata$x:00007520                 dd offset __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$17
.xdata$x:00007524                 db  10h
.xdata$x:00007525                 db    0
.xdata$x:00007526                 db    0
.xdata$x:00007527                 db    0
.xdata$x:00007528                 dd offset __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$18
.xdata$x:0000752C                 db  11h
.xdata$x:0000752D                 db    0
.xdata$x:0000752E                 db    0
.xdata$x:0000752F                 db    0
.xdata$x:00007530                 dd offset __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$19
.xdata$x:00007534                 db  12h
.xdata$x:00007535                 db    0
.xdata$x:00007536                 db    0
.xdata$x:00007537                 db    0
.xdata$x:00007538                 dd offset __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$20
.xdata$x:0000753C                 db  12h
.xdata$x:0000753D                 db    0
.xdata$x:0000753E                 db    0
.xdata$x:0000753F                 db    0
.xdata$x:00007540                 dd offset __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$21
.xdata$x:00007544                 db  14h
.xdata$x:00007545                 db    0
.xdata$x:00007546                 db    0
.xdata$x:00007547                 db    0
.xdata$x:00007548                 dd offset __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$22
.xdata$x:0000754C                 db  15h
.xdata$x:0000754D                 db    0
.xdata$x:0000754E                 db    0
.xdata$x:0000754F                 db    0
.xdata$x:00007550                 dd offset __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$23
.xdata$x:00007554                 db  16h
.xdata$x:00007555                 db    0
.xdata$x:00007556                 db    0
.xdata$x:00007557                 db    0
.xdata$x:00007558                 dd offset __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$24
.xdata$x:0000755C                 db  15h
.xdata$x:0000755D                 db    0
.xdata$x:0000755E                 db    0
.xdata$x:0000755F                 db    0
.xdata$x:00007560                 db    0
.xdata$x:00007561                 db    0
.xdata$x:00007562                 db    0
.xdata$x:00007563                 db    0
.xdata$x:00007564                 db  18h
.xdata$x:00007565                 db    0
.xdata$x:00007566                 db    0
.xdata$x:00007567                 db    0
.xdata$x:00007568                 dd offset __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$25
.xdata$x:0000756C                 db  15h
.xdata$x:0000756D                 db    0
.xdata$x:0000756E                 db    0
.xdata$x:0000756F                 db    0
.xdata$x:00007570                 db    0
.xdata$x:00007571                 db    0
.xdata$x:00007572                 db    0
.xdata$x:00007573                 db    0
.xdata$x:00007574                 db  15h
.xdata$x:00007575                 db    0
.xdata$x:00007576                 db    0
.xdata$x:00007577                 db    0
.xdata$x:00007578                 dd offset __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$26
.xdata$x:0000757C                 db  1Bh
.xdata$x:0000757D                 db    0
.xdata$x:0000757E                 db    0
.xdata$x:0000757F                 db    0
.xdata$x:00007580                 dd offset __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$27
.xdata$x:00007584                 db  1Ch
.xdata$x:00007585                 db    0
.xdata$x:00007586                 db    0
.xdata$x:00007587                 db    0
.xdata$x:00007588                 dd offset __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$28
.xdata$x:0000758C                 db  1Dh
.xdata$x:0000758D                 db    0
.xdata$x:0000758E                 db    0
.xdata$x:0000758F                 db    0
.xdata$x:00007590                 dd offset __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$29
.xdata$x:00007594                 db  1Ch
.xdata$x:00007595                 db    0
.xdata$x:00007596                 db    0
.xdata$x:00007597                 db    0
.xdata$x:00007598                 dd offset __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$30
.xdata$x:0000759C                 db  1Fh
.xdata$x:0000759D                 db    0
.xdata$x:0000759E                 db    0
.xdata$x:0000759F                 db    0
.xdata$x:000075A0                 dd offset __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$31
.xdata$x:000075A4                 dd offset $SG74034+20h  ; "ted for this archive"
.xdata$x:000075A8                 dd offset __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$32
.xdata$x:000075AC                 dd offset $SG74034+21h  ; "ed for this archive"
.xdata$x:000075B0                 dd offset __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$33
.xdata$x:000075B4                 dd offset $SG74034+22h  ; "d for this archive"
.xdata$x:000075B8                 dd offset __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$34
.xdata$x:000075BC                 dd offset $SG74034+23h  ; " for this archive"
.xdata$x:000075C0                 dd offset __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$35
.xdata$x:000075C4                 db  15h
.xdata$x:000075C5                 db    0
.xdata$x:000075C6                 db    0
.xdata$x:000075C7                 db    0
.xdata$x:000075C8                 dd offset __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$36
.xdata$x:000075CC                 dd offset $SG74034+25h  ; "or this archive"
.xdata$x:000075D0                 dd offset __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$37
.xdata$x:000075D4                 dd offset $SG74034+26h  ; "r this archive"
.xdata$x:000075D8                 dd offset __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$38
.xdata$x:000075DC                 dd offset $SG74034+26h  ; "r this archive"
.xdata$x:000075E0                 dd offset __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$39
.xdata$x:000075E4 __ehfuncinfo$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z db  22h ; "
.xdata$x:000075E4                                         ; DATA XREF: __ehhandler$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z+1Eo
.xdata$x:000075E5                 db    5
.xdata$x:000075E6                 db  93h ; 
.xdata$x:000075E7                 db  19h
.xdata$x:000075E8                 db  1Bh
.xdata$x:000075E9                 db    0
.xdata$x:000075EA                 db    0
.xdata$x:000075EB                 db    0
.xdata$x:000075EC                 dd offset __unwindtable$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z
.xdata$x:000075F0                 db    0
.xdata$x:000075F1                 db    0
.xdata$x:000075F2                 db    0
.xdata$x:000075F3                 db    0
.xdata$x:000075F4                 db    0
.xdata$x:000075F5                 db    0
.xdata$x:000075F6                 db    0
.xdata$x:000075F7                 db    0
.xdata$x:000075F8                 db    0
.xdata$x:000075F9                 db    0
.xdata$x:000075FA                 db    0
.xdata$x:000075FB                 db    0
.xdata$x:000075FC                 db    0
.xdata$x:000075FD                 db    0
.xdata$x:000075FE                 db    0
.xdata$x:000075FF                 db    0
.xdata$x:00007600                 db    0
.xdata$x:00007601                 db    0
.xdata$x:00007602                 db    0
.xdata$x:00007603                 db    0
.xdata$x:00007604                 db    1
.xdata$x:00007605                 db    0
.xdata$x:00007606                 db    0
.xdata$x:00007607                 db    0
.xdata$x:00007608 __unwindtable$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z db 0FFh
.xdata$x:00007608                                         ; DATA XREF: .xdata$x:000075ECo
.xdata$x:00007609                 db 0FFh
.xdata$x:0000760A                 db 0FFh
.xdata$x:0000760B                 db 0FFh
.xdata$x:0000760C                 dd offset __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$0
.xdata$x:00007610                 db    0
.xdata$x:00007611                 db    0
.xdata$x:00007612                 db    0
.xdata$x:00007613                 db    0
.xdata$x:00007614                 dd offset __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$1
.xdata$x:00007618                 db    0
.xdata$x:00007619                 db    0
.xdata$x:0000761A                 db    0
.xdata$x:0000761B                 db    0
.xdata$x:0000761C                 dd offset __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$2
.xdata$x:00007620                 db    2
.xdata$x:00007621                 db    0
.xdata$x:00007622                 db    0
.xdata$x:00007623                 db    0
.xdata$x:00007624                 dd offset __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$3
.xdata$x:00007628                 db    3
.xdata$x:00007629                 db    0
.xdata$x:0000762A                 db    0
.xdata$x:0000762B                 db    0
.xdata$x:0000762C                 dd offset __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$4
.xdata$x:00007630                 db    4
.xdata$x:00007631                 db    0
.xdata$x:00007632                 db    0
.xdata$x:00007633                 db    0
.xdata$x:00007634                 dd offset __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$5
.xdata$x:00007638                 db    3
.xdata$x:00007639                 db    0
.xdata$x:0000763A                 db    0
.xdata$x:0000763B                 db    0
.xdata$x:0000763C                 dd offset __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$6
.xdata$x:00007640                 db    3
.xdata$x:00007641                 db    0
.xdata$x:00007642                 db    0
.xdata$x:00007643                 db    0
.xdata$x:00007644                 dd offset __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$7
.xdata$x:00007648                 db    3
.xdata$x:00007649                 db    0
.xdata$x:0000764A                 db    0
.xdata$x:0000764B                 db    0
.xdata$x:0000764C                 dd offset __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$8
.xdata$x:00007650                 db    8
.xdata$x:00007651                 db    0
.xdata$x:00007652                 db    0
.xdata$x:00007653                 db    0
.xdata$x:00007654                 dd offset __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$9
.xdata$x:00007658                 db    9
.xdata$x:00007659                 db    0
.xdata$x:0000765A                 db    0
.xdata$x:0000765B                 db    0
.xdata$x:0000765C                 dd offset __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$10
.xdata$x:00007660                 db  0Ah
.xdata$x:00007661                 db    0
.xdata$x:00007662                 db    0
.xdata$x:00007663                 db    0
.xdata$x:00007664                 dd offset __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$11
.xdata$x:00007668                 db  0Bh
.xdata$x:00007669                 db    0
.xdata$x:0000766A                 db    0
.xdata$x:0000766B                 db    0
.xdata$x:0000766C                 dd offset __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$12
.xdata$x:00007670                 db  0Ah
.xdata$x:00007671                 db    0
.xdata$x:00007672                 db    0
.xdata$x:00007673                 db    0
.xdata$x:00007674                 dd offset __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$13
.xdata$x:00007678                 db  0Ah
.xdata$x:00007679                 db    0
.xdata$x:0000767A                 db    0
.xdata$x:0000767B                 db    0
.xdata$x:0000767C                 dd offset __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$14
.xdata$x:00007680                 db  0Ah
.xdata$x:00007681                 db    0
.xdata$x:00007682                 db    0
.xdata$x:00007683                 db    0
.xdata$x:00007684                 dd offset __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$15
.xdata$x:00007688                 db  0Fh
.xdata$x:00007689                 db    0
.xdata$x:0000768A                 db    0
.xdata$x:0000768B                 db    0
.xdata$x:0000768C                 dd offset __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$16
.xdata$x:00007690                 db  0Fh
.xdata$x:00007691                 db    0
.xdata$x:00007692                 db    0
.xdata$x:00007693                 db    0
.xdata$x:00007694                 dd offset __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$17
.xdata$x:00007698                 db  0Ah
.xdata$x:00007699                 db    0
.xdata$x:0000769A                 db    0
.xdata$x:0000769B                 db    0
.xdata$x:0000769C                 dd offset __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$18
.xdata$x:000076A0                 db  0Ah
.xdata$x:000076A1                 db    0
.xdata$x:000076A2                 db    0
.xdata$x:000076A3                 db    0
.xdata$x:000076A4                 dd offset __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$19
.xdata$x:000076A8                 db  0Ah
.xdata$x:000076A9                 db    0
.xdata$x:000076AA                 db    0
.xdata$x:000076AB                 db    0
.xdata$x:000076AC                 dd offset __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$20
.xdata$x:000076B0                 db  0Ah
.xdata$x:000076B1                 db    0
.xdata$x:000076B2                 db    0
.xdata$x:000076B3                 db    0
.xdata$x:000076B4                 dd offset __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$21
.xdata$x:000076B8                 db  15h
.xdata$x:000076B9                 db    0
.xdata$x:000076BA                 db    0
.xdata$x:000076BB                 db    0
.xdata$x:000076BC                 dd offset __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$22
.xdata$x:000076C0                 db  16h
.xdata$x:000076C1                 db    0
.xdata$x:000076C2                 db    0
.xdata$x:000076C3                 db    0
.xdata$x:000076C4                 dd offset __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$23
.xdata$x:000076C8                 db  16h
.xdata$x:000076C9                 db    0
.xdata$x:000076CA                 db    0
.xdata$x:000076CB                 db    0
.xdata$x:000076CC                 dd offset __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$24
.xdata$x:000076D0                 db  0Ah
.xdata$x:000076D1                 db    0
.xdata$x:000076D2                 db    0
.xdata$x:000076D3                 db    0
.xdata$x:000076D4                 dd offset __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$25
.xdata$x:000076D8                 db  19h
.xdata$x:000076D9                 db    0
.xdata$x:000076DA                 db    0
.xdata$x:000076DB                 db    0
.xdata$x:000076DC                 dd offset __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$26
.xdata$x:000076E0 __unwindtable$?EnumerateInArchiveItems@@YGJABVCCensor@NWildcard@@ABVCArc@@AAV?$CObjectVector@UCArcItem@@@@@Z db 0FFh
.xdata$x:000076E0                                         ; DATA XREF: .xdata$x:00007700o
.xdata$x:000076E1                 db 0FFh
.xdata$x:000076E2                 db 0FFh
.xdata$x:000076E3                 db 0FFh
.xdata$x:000076E4                 dd offset __unwindfunclet$?EnumerateInArchiveItems@@YGJABVCCensor@NWildcard@@ABVCArc@@AAV?$CObjectVector@UCArcItem@@@@@Z$0
.xdata$x:000076E8                 db    0
.xdata$x:000076E9                 db    0
.xdata$x:000076EA                 db    0
.xdata$x:000076EB                 db    0
.xdata$x:000076EC                 dd offset __unwindfunclet$?EnumerateInArchiveItems@@YGJABVCCensor@NWildcard@@ABVCArc@@AAV?$CObjectVector@UCArcItem@@@@@Z$1
.xdata$x:000076F0                 db    1
.xdata$x:000076F1                 db    0
.xdata$x:000076F2                 db    0
.xdata$x:000076F3                 db    0
.xdata$x:000076F4                 dd offset __unwindfunclet$?EnumerateInArchiveItems@@YGJABVCCensor@NWildcard@@ABVCArc@@AAV?$CObjectVector@UCArcItem@@@@@Z$2
.xdata$x:000076F8 __ehfuncinfo$?EnumerateInArchiveItems@@YGJABVCCensor@NWildcard@@ABVCArc@@AAV?$CObjectVector@UCArcItem@@@@@Z db  22h ; "
.xdata$x:000076F8                                         ; DATA XREF: __ehhandler$?EnumerateInArchiveItems@@YGJABVCCensor@NWildcard@@ABVCArc@@AAV?$CObjectVector@UCArcItem@@@@@Z+14o
.xdata$x:000076F9                 db    5
.xdata$x:000076FA                 db  93h ; 
.xdata$x:000076FB                 db  19h
.xdata$x:000076FC                 db    3
.xdata$x:000076FD                 db    0
.xdata$x:000076FE                 db    0
.xdata$x:000076FF                 db    0
.xdata$x:00007700                 dd offset __unwindtable$?EnumerateInArchiveItems@@YGJABVCCensor@NWildcard@@ABVCArc@@AAV?$CObjectVector@UCArcItem@@@@@Z
.xdata$x:00007704                 db    0
.xdata$x:00007705                 db    0
.xdata$x:00007706                 db    0
.xdata$x:00007707                 db    0
.xdata$x:00007708                 db    0
.xdata$x:00007709                 db    0
.xdata$x:0000770A                 db    0
.xdata$x:0000770B                 db    0
.xdata$x:0000770C                 db    0
.xdata$x:0000770D                 db    0
.xdata$x:0000770E                 db    0
.xdata$x:0000770F                 db    0
.xdata$x:00007710                 db    0
.xdata$x:00007711                 db    0
.xdata$x:00007712                 db    0
.xdata$x:00007713                 db    0
.xdata$x:00007714                 db    0
.xdata$x:00007715                 db    0
.xdata$x:00007716                 db    0
.xdata$x:00007717                 db    0
.xdata$x:00007718                 db    1
.xdata$x:00007719                 db    0
.xdata$x:0000771A                 db    0
.xdata$x:0000771B                 db    0
.xdata$x:0000771B _xdata$x        ends
.xdata$x:0000771B
.text:0000771C ; ===========================================================================
.text:0000771C
.text:0000771C ; Segment type: Pure code
.text:0000771C ; Segment permissions: Read/Execute
.text:0000771C _text           segment para public 'CODE' use32
.text:0000771C                 assume cs:_text
.text:0000771C                 ;org 771Ch
.text:0000771C ; COMDAT (pick any)
.text:0000771C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000771C
.text:0000771C ; =============== S U B R O U T I N E =======================================
.text:0000771C
.text:0000771C ; Attributes: bp-based frame
.text:0000771C
.text:0000771C ; void __thiscall UString::Empty(UString *__hidden this)
.text:0000771C                 public ?Empty@UString@@QAEXXZ
.text:0000771C ?Empty@UString@@QAEXXZ proc near        ; CODE XREF: CArchivePath::ParseFromPath(UString const &,EArcNameMode)+7Cp
.text:0000771C                                         ; CArchivePath::ParseFromPath(UString const &,EArcNameMode)+C3p ...
.text:0000771C
.text:0000771C var_4           = dword ptr -4
.text:0000771C
.text:0000771C                 push    ebp
.text:0000771D                 mov     ebp, esp
.text:0000771F                 push    ecx
.text:00007720                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00007727                 mov     [ebp+var_4], ecx
.text:0000772A                 mov     eax, [ebp+var_4]
.text:0000772D                 mov     dword ptr [eax+4], 0
.text:00007734                 mov     ecx, [ebp+var_4]
.text:00007737                 mov     edx, [ecx]
.text:00007739                 xor     eax, eax
.text:0000773B                 mov     [edx], ax
.text:0000773E                 mov     esp, ebp
.text:00007740                 pop     ebp
.text:00007741                 retn
.text:00007741 ?Empty@UString@@QAEXXZ endp
.text:00007741
.text:00007741 ; ---------------------------------------------------------------------------
.text:00007742                 align 4
.text:00007742 _text           ends
.text:00007742
.text:00007744 ; ===========================================================================
.text:00007744
.text:00007744 ; Segment type: Pure code
.text:00007744 ; Segment permissions: Read/Execute
.text:00007744 _text           segment para public 'CODE' use32
.text:00007744                 assume cs:_text
.text:00007744                 ;org 7744h
.text:00007744 ; COMDAT (pick any)
.text:00007744                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007744
.text:00007744 ; =============== S U B R O U T I N E =======================================
.text:00007744
.text:00007744 ; Attributes: bp-based frame
.text:00007744
.text:00007744 ; const wchar_t *__thiscall UString::Ptr(UString *this, unsigned int)
.text:00007744                 public ?Ptr@UString@@QBEPB_WI@Z
.text:00007744 ?Ptr@UString@@QBEPB_WI@Z proc near      ; CODE XREF: CArchivePath::ParseFromPath(UString const &,EArcNameMode)+D7p
.text:00007744                                         ; CRenamePair::GetNewPath(bool,UString const &,UString &)+120p ...
.text:00007744
.text:00007744 var_4           = dword ptr -4
.text:00007744 arg_0           = dword ptr  8
.text:00007744
.text:00007744                 push    ebp
.text:00007745                 mov     ebp, esp
.text:00007747                 push    ecx
.text:00007748                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000774F                 mov     [ebp+var_4], ecx
.text:00007752                 mov     eax, [ebp+var_4]
.text:00007755                 mov     ecx, [eax]
.text:00007757                 mov     edx, [ebp+arg_0]
.text:0000775A                 lea     eax, [ecx+edx*2]
.text:0000775D                 mov     esp, ebp
.text:0000775F                 pop     ebp
.text:00007760                 retn    4
.text:00007760 ?Ptr@UString@@QBEPB_WI@Z endp
.text:00007760
.text:00007760 ; ---------------------------------------------------------------------------
.text:00007763                 align 4
.text:00007763 _text           ends
.text:00007763
.text:00007764 ; ===========================================================================
.text:00007764
.text:00007764 ; Segment type: Pure code
.text:00007764 ; Segment permissions: Read/Execute
.text:00007764 _text           segment para public 'CODE' use32
.text:00007764                 assume cs:_text
.text:00007764                 ;org 7764h
.text:00007764 ; COMDAT (pick any)
.text:00007764                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007764
.text:00007764 ; =============== S U B R O U T I N E =======================================
.text:00007764
.text:00007764 ; Attributes: bp-based frame
.text:00007764
.text:00007764 ; bool __thiscall UString::IsEqualTo_NoCase(UString *this, const wchar_t *)
.text:00007764                 public ?IsEqualTo_NoCase@UString@@QBE_NPB_W@Z
.text:00007764 ?IsEqualTo_NoCase@UString@@QBE_NPB_W@Z proc near
.text:00007764                                         ; CODE XREF: CArchivePath::ParseFromPath(UString const &,EArcNameMode)+FBp
.text:00007764
.text:00007764 var_4           = dword ptr -4
.text:00007764 arg_0           = dword ptr  8
.text:00007764
.text:00007764                 push    ebp
.text:00007765                 mov     ebp, esp
.text:00007767                 push    ecx
.text:00007768                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000776F                 mov     [ebp+var_4], ecx
.text:00007772                 mov     eax, [ebp+arg_0]
.text:00007775                 push    eax             ; wchar_t *
.text:00007776                 mov     ecx, [ebp+var_4]
.text:00007779                 mov     edx, [ecx]
.text:0000777B                 push    edx             ; wchar_t *
.text:0000777C                 call    ?StringsAreEqualNoCase@@YG_NPB_W0@Z ; StringsAreEqualNoCase(wchar_t const *,wchar_t const *)
.text:00007781                 add     esp, 4
.text:00007784                 cmp     ebp, esp
.text:00007786                 call    __RTC_CheckEsp
.text:0000778B                 mov     esp, ebp
.text:0000778D                 pop     ebp
.text:0000778E                 retn    4
.text:0000778E ?IsEqualTo_NoCase@UString@@QBE_NPB_W@Z endp
.text:0000778E
.text:0000778E ; ---------------------------------------------------------------------------
.text:00007791                 align 4
.text:00007791 _text           ends
.text:00007791
.text:00007794 ; ===========================================================================
.text:00007794
.text:00007794 ; Segment type: Pure code
.text:00007794 ; Segment permissions: Read/Execute
.text:00007794 _text           segment para public 'CODE' use32
.text:00007794                 assume cs:_text
.text:00007794                 ;org 7794h
.text:00007794 ; COMDAT (pick any)
.text:00007794                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007794
.text:00007794 ; =============== S U B R O U T I N E =======================================
.text:00007794
.text:00007794 ; Attributes: bp-based frame
.text:00007794
.text:00007794 ; int __thiscall UString::ReverseFind_Dot(UString *__hidden this)
.text:00007794                 public ?ReverseFind_Dot@UString@@QBEHXZ
.text:00007794 ?ReverseFind_Dot@UString@@QBEHXZ proc near
.text:00007794                                         ; CODE XREF: CArchivePath::ParseFromPath(UString const &,EArcNameMode)+8Cp
.text:00007794
.text:00007794 var_4           = dword ptr -4
.text:00007794
.text:00007794                 push    ebp
.text:00007795                 mov     ebp, esp
.text:00007797                 push    ecx
.text:00007798                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000779F                 mov     [ebp+var_4], ecx
.text:000077A2                 push    2Eh ; '.'       ; wchar_t
.text:000077A4                 mov     ecx, [ebp+var_4] ; this
.text:000077A7                 call    ?ReverseFind@UString@@QBEH_W@Z ; UString::ReverseFind(wchar_t)
.text:000077AC                 add     esp, 4
.text:000077AF                 cmp     ebp, esp
.text:000077B1                 call    __RTC_CheckEsp
.text:000077B6                 mov     esp, ebp
.text:000077B8                 pop     ebp
.text:000077B9                 retn
.text:000077B9 ?ReverseFind_Dot@UString@@QBEHXZ endp
.text:000077B9
.text:000077B9 ; ---------------------------------------------------------------------------
.text:000077BA                 align 4
.text:000077BA _text           ends
.text:000077BA
.text:000077BC ; ===========================================================================
.text:000077BC
.text:000077BC ; Segment type: Pure code
.text:000077BC ; Segment permissions: Read/Execute
.text:000077BC _text           segment para public 'CODE' use32
.text:000077BC                 assume cs:_text
.text:000077BC                 ;org 77BCh
.text:000077BC ; COMDAT (pick any)
.text:000077BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000077BC
.text:000077BC ; =============== S U B R O U T I N E =======================================
.text:000077BC
.text:000077BC ; Attributes: bp-based frame
.text:000077BC
.text:000077BC ; void __thiscall UString::DeleteBack(UString *__hidden this)
.text:000077BC                 public ?DeleteBack@UString@@QAEXXZ
.text:000077BC ?DeleteBack@UString@@QAEXXZ proc near   ; CODE XREF: CArchivePath::ParseFromPath(UString const &,EArcNameMode)+B8p
.text:000077BC
.text:000077BC var_8           = dword ptr -8
.text:000077BC var_4           = dword ptr -4
.text:000077BC
.text:000077BC                 push    ebp
.text:000077BD                 mov     ebp, esp
.text:000077BF                 sub     esp, 8
.text:000077C2                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000077C9                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000077D0                 mov     [ebp+var_4], ecx
.text:000077D3                 mov     eax, [ebp+var_4]
.text:000077D6                 mov     ecx, [eax+4]
.text:000077D9                 sub     ecx, 1
.text:000077DC                 mov     [ebp+var_8], ecx
.text:000077DF                 mov     edx, [ebp+var_4]
.text:000077E2                 mov     eax, [ebp+var_8]
.text:000077E5                 mov     [edx+4], eax
.text:000077E8                 mov     ecx, [ebp+var_4]
.text:000077EB                 mov     edx, [ecx]
.text:000077ED                 xor     eax, eax
.text:000077EF                 mov     ecx, [ebp+var_8]
.text:000077F2                 mov     [edx+ecx*2], ax
.text:000077F6                 mov     esp, ebp
.text:000077F8                 pop     ebp
.text:000077F9                 retn
.text:000077F9 ?DeleteBack@UString@@QAEXXZ endp
.text:000077F9
.text:000077F9 ; ---------------------------------------------------------------------------
.text:000077FA                 align 4
.text:000077FA _text           ends
.text:000077FA
.text:000077FC ; ===========================================================================
.text:000077FC
.text:000077FC ; Segment type: Pure code
.text:000077FC ; Segment permissions: Read/Execute
.text:000077FC _text           segment para public 'CODE' use32
.text:000077FC                 assume cs:_text
.text:000077FC                 ;org 77FCh
.text:000077FC ; COMDAT (pick any)
.text:000077FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000077FC
.text:000077FC ; =============== S U B R O U T I N E =======================================
.text:000077FC
.text:000077FC ; Attributes: bp-based frame
.text:000077FC
.text:000077FC ; void __thiscall UString::DeleteFrom(UString *this, unsigned int)
.text:000077FC                 public ?DeleteFrom@UString@@QAEXI@Z
.text:000077FC ?DeleteFrom@UString@@QAEXI@Z proc near  ; CODE XREF: CArchivePath::ParseFromPath(UString const &,EArcNameMode)+120p
.text:000077FC
.text:000077FC var_4           = dword ptr -4
.text:000077FC arg_0           = dword ptr  8
.text:000077FC
.text:000077FC                 push    ebp
.text:000077FD                 mov     ebp, esp
.text:000077FF                 push    ecx
.text:00007800                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00007807                 mov     [ebp+var_4], ecx
.text:0000780A                 mov     eax, [ebp+var_4]
.text:0000780D                 mov     ecx, [ebp+arg_0]
.text:00007810                 cmp     ecx, [eax+4]
.text:00007813                 jnb     short loc_782C
.text:00007815                 mov     edx, [ebp+var_4]
.text:00007818                 mov     eax, [ebp+arg_0]
.text:0000781B                 mov     [edx+4], eax
.text:0000781E                 mov     ecx, [ebp+var_4]
.text:00007821                 mov     edx, [ecx]
.text:00007823                 xor     eax, eax
.text:00007825                 mov     ecx, [ebp+arg_0]
.text:00007828                 mov     [edx+ecx*2], ax
.text:0000782C
.text:0000782C loc_782C:                               ; CODE XREF: UString::DeleteFrom(uint)+17j
.text:0000782C                 mov     esp, ebp
.text:0000782E                 pop     ebp
.text:0000782F                 retn    4
.text:0000782F ?DeleteFrom@UString@@QAEXI@Z endp
.text:0000782F
.text:0000782F ; ---------------------------------------------------------------------------
.text:00007832                 align 4
.text:00007832 _text           ends
.text:00007832
.text:00007834 ; ===========================================================================
.text:00007834
.text:00007834 ; Segment type: Pure code
.text:00007834 ; Segment permissions: Read/Execute
.text:00007834 _text           segment para public 'CODE' use32
.text:00007834                 assume cs:_text
.text:00007834                 ;org 7834h
.text:00007834 ; COMDAT (pick any)
.text:00007834                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007834
.text:00007834 ; =============== S U B R O U T I N E =======================================
.text:00007834
.text:00007834 ; Attributes: bp-based frame
.text:00007834
.text:00007834 ; bool __thiscall UString::IsEmpty(UString *__hidden this)
.text:00007834                 public ?IsEmpty@UString@@QBE_NXZ
.text:00007834 ?IsEmpty@UString@@QBE_NXZ proc near     ; CODE XREF: CArchivePath::GetFinalPath(void)+62p
.text:00007834                                         ; CArchivePath::GetFinalVolPath(void)+62p ...
.text:00007834
.text:00007834 var_4           = dword ptr -4
.text:00007834
.text:00007834                 push    ebp
.text:00007835                 mov     ebp, esp
.text:00007837                 push    ecx
.text:00007838                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000783F                 mov     [ebp+var_4], ecx
.text:00007842                 mov     eax, [ebp+var_4]
.text:00007845                 xor     ecx, ecx
.text:00007847                 cmp     dword ptr [eax+4], 0
.text:0000784B                 setz    cl
.text:0000784E                 mov     al, cl
.text:00007850                 mov     esp, ebp
.text:00007852                 pop     ebp
.text:00007853                 retn
.text:00007853 ?IsEmpty@UString@@QBE_NXZ endp
.text:00007853
.text:00007853 _text           ends
.text:00007853
.text:00007854 ; ===========================================================================
.text:00007854
.text:00007854 ; Segment type: Pure code
.text:00007854 ; Segment permissions: Read/Execute
.text:00007854 _text           segment para public 'CODE' use32
.text:00007854                 assume cs:_text
.text:00007854                 ;org 7854h
.text:00007854 ; COMDAT (pick any)
.text:00007854                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007854
.text:00007854 ; =============== S U B R O U T I N E =======================================
.text:00007854
.text:00007854 ; Attributes: bp-based frame
.text:00007854
.text:00007854 ; public: class UString & __thiscall UString::operator+=(wchar_t)
.text:00007854                 public ??YUString@@QAEAAV0@_W@Z
.text:00007854 ??YUString@@QAEAAV0@_W@Z proc near      ; CODE XREF: CArchivePath::GetFinalPath(void)+73p
.text:00007854                                         ; CArchivePath::GetFinalVolPath(void)+73p ...
.text:00007854
.text:00007854 var_C           = dword ptr -0Ch
.text:00007854 var_8           = dword ptr -8
.text:00007854 var_4           = dword ptr -4
.text:00007854 arg_0           = word ptr  8
.text:00007854
.text:00007854                 push    ebp
.text:00007855                 mov     ebp, esp
.text:00007857                 sub     esp, 0Ch
.text:0000785A                 mov     [ebp+var_C], 0CCCCCCCCh
.text:00007861                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00007868                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000786F                 mov     [ebp+var_4], ecx
.text:00007872                 mov     eax, [ebp+var_4]
.text:00007875                 mov     ecx, [ebp+var_4]
.text:00007878                 mov     edx, [eax+8]
.text:0000787B                 cmp     edx, [ecx+4]
.text:0000787E                 jnz     short loc_7888
.text:00007880                 mov     ecx, [ebp+var_4] ; this
.text:00007883                 call    ?Grow_1@UString@@AAEXXZ ; UString::Grow_1(void)
.text:00007888
.text:00007888 loc_7888:                               ; CODE XREF: UString::operator+=(wchar_t)+2Aj
.text:00007888                 mov     eax, [ebp+var_4]
.text:0000788B                 mov     ecx, [eax+4]
.text:0000788E                 mov     [ebp+var_8], ecx
.text:00007891                 mov     edx, [ebp+var_4]
.text:00007894                 mov     eax, [edx]
.text:00007896                 mov     [ebp+var_C], eax
.text:00007899                 mov     ecx, [ebp+var_8]
.text:0000789C                 mov     edx, [ebp+var_C]
.text:0000789F                 mov     ax, [ebp+arg_0]
.text:000078A3                 mov     [edx+ecx*2], ax
.text:000078A7                 mov     ecx, [ebp+var_8]
.text:000078AA                 add     ecx, 1
.text:000078AD                 mov     [ebp+var_8], ecx
.text:000078B0                 xor     edx, edx
.text:000078B2                 mov     eax, [ebp+var_8]
.text:000078B5                 mov     ecx, [ebp+var_C]
.text:000078B8                 mov     [ecx+eax*2], dx
.text:000078BC                 mov     edx, [ebp+var_4]
.text:000078BF                 mov     eax, [ebp+var_8]
.text:000078C2                 mov     [edx+4], eax
.text:000078C5                 mov     eax, [ebp+var_4]
.text:000078C8                 add     esp, 0Ch
.text:000078CB                 cmp     ebp, esp
.text:000078CD                 call    __RTC_CheckEsp
.text:000078D2                 mov     esp, ebp
.text:000078D4                 pop     ebp
.text:000078D5                 retn    4
.text:000078D5 ??YUString@@QAEAAV0@_W@Z endp
.text:000078D5
.text:000078D5 _text           ends
.text:000078D5
.text:000078D8 ; ===========================================================================
.text:000078D8
.text:000078D8 ; Segment type: Pure code
.text:000078D8 ; Segment permissions: Read/Execute
.text:000078D8 _text           segment para public 'CODE' use32
.text:000078D8                 assume cs:_text
.text:000078D8                 ;org 78D8h
.text:000078D8 ; COMDAT (pick any)
.text:000078D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000078D8
.text:000078D8 ; =============== S U B R O U T I N E =======================================
.text:000078D8
.text:000078D8 ; Attributes: bp-based frame
.text:000078D8
.text:000078D8 ; public: class UString __thiscall CArchivePath::GetPathWithoutExt(void)const
.text:000078D8                 public ?GetPathWithoutExt@CArchivePath@@QBE?AVUString@@XZ
.text:000078D8 ?GetPathWithoutExt@CArchivePath@@QBE?AVUString@@XZ proc near
.text:000078D8                                         ; CODE XREF: CArchivePath::GetFinalPath(void)+50p
.text:000078D8                                         ; CArchivePath::GetFinalVolPath(void)+50p
.text:000078D8
.text:000078D8 var_8           = dword ptr -8
.text:000078D8 var_4           = dword ptr -4
.text:000078D8 arg_0           = dword ptr  8
.text:000078D8
.text:000078D8                 push    ebp
.text:000078D9                 mov     ebp, esp
.text:000078DB                 sub     esp, 8
.text:000078DE                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000078E5                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000078EC                 mov     [ebp+var_4], ecx
.text:000078EF                 mov     [ebp+var_8], 0
.text:000078F6                 mov     eax, [ebp+var_4]
.text:000078F9                 add     eax, 18h
.text:000078FC                 push    eax
.text:000078FD                 mov     ecx, [ebp+var_4]
.text:00007900                 add     ecx, 0Ch
.text:00007903                 push    ecx
.text:00007904                 mov     edx, [ebp+arg_0]
.text:00007907                 push    edx
.text:00007908                 call    ??H@YG?AVUString@@ABV0@0@Z ; operator+(UString const &,UString const &)
.text:0000790D                 mov     eax, [ebp+var_8]
.text:00007910                 or      eax, 1
.text:00007913                 mov     [ebp+var_8], eax
.text:00007916                 mov     eax, [ebp+arg_0]
.text:00007919                 add     esp, 8
.text:0000791C                 cmp     ebp, esp
.text:0000791E                 call    __RTC_CheckEsp
.text:00007923                 mov     esp, ebp
.text:00007925                 pop     ebp
.text:00007926                 retn    4
.text:00007926 ?GetPathWithoutExt@CArchivePath@@QBE?AVUString@@XZ endp
.text:00007926
.text:00007926 ; ---------------------------------------------------------------------------
.text:00007929                 align 4
.text:00007929 _text           ends
.text:00007929
.text:0000792C ; ===========================================================================
.text:0000792C
.text:0000792C ; Segment type: Pure code
.text:0000792C ; Segment permissions: Read/Execute
.text:0000792C _text           segment para public 'CODE' use32
.text:0000792C                 assume cs:_text
.text:0000792C                 ;org 792Ch
.text:0000792C ; COMDAT (pick any)
.text:0000792C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000792C
.text:0000792C ; =============== S U B R O U T I N E =======================================
.text:0000792C
.text:0000792C ; Attributes: bp-based frame
.text:0000792C
.text:0000792C ; _DWORD __thiscall COpenType::COpenType(COpenType *__hidden this)
.text:0000792C                 public ??0COpenType@@QAE@XZ
.text:0000792C ??0COpenType@@QAE@XZ proc near          ; CODE XREF: CUpdateOptions::InitFormatIndex(CCodecs const *,CObjectVector<COpenType> const &,UString const &)+73p
.text:0000792C                                         ; COpenOptions::COpenOptions(void)+1Dp
.text:0000792C
.text:0000792C var_4           = dword ptr -4
.text:0000792C
.text:0000792C                 push    ebp
.text:0000792D                 mov     ebp, esp
.text:0000792F                 push    ecx
.text:00007930                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00007937                 mov     [ebp+var_4], ecx
.text:0000793A                 mov     eax, [ebp+var_4]
.text:0000793D                 mov     dword ptr [eax], 0FFFFFFFFh
.text:00007943                 mov     ecx, [ebp+var_4]
.text:00007946                 add     ecx, 4          ; this
.text:00007949                 call    ??0COpenSpecFlags@@QAE@XZ ; COpenSpecFlags::COpenSpecFlags(void)
.text:0000794E                 mov     ecx, [ebp+var_4]
.text:00007951                 add     ecx, 7          ; this
.text:00007954                 call    ??0COpenSpecFlags@@QAE@XZ ; COpenSpecFlags::COpenSpecFlags(void)
.text:00007959                 mov     ecx, [ebp+var_4]
.text:0000795C                 add     ecx, 0Ah        ; this
.text:0000795F                 call    ??0COpenSpecFlags@@QAE@XZ ; COpenSpecFlags::COpenSpecFlags(void)
.text:00007964                 mov     ecx, [ebp+var_4]
.text:00007967                 add     ecx, 0Dh        ; this
.text:0000796A                 call    ??0COpenSpecFlags@@QAE@XZ ; COpenSpecFlags::COpenSpecFlags(void)
.text:0000796F                 mov     ecx, [ebp+var_4]
.text:00007972                 mov     byte ptr [ecx+10h], 1
.text:00007976                 mov     edx, [ebp+var_4]
.text:00007979                 mov     byte ptr [edx+11h], 1
.text:0000797D                 mov     eax, [ebp+var_4]
.text:00007980                 mov     byte ptr [eax+12h], 0
.text:00007984                 mov     ecx, [ebp+var_4]
.text:00007987                 mov     byte ptr [ecx+13h], 0
.text:0000798B                 mov     edx, [ebp+var_4]
.text:0000798E                 mov     byte ptr [edx+14h], 0
.text:00007992                 mov     eax, [ebp+var_4]
.text:00007995                 mov     byte ptr [eax+15h], 0
.text:00007999                 mov     ecx, [ebp+var_4]
.text:0000799C                 mov     dword ptr [ecx+18h], 0
.text:000079A3                 mov     dword ptr [ecx+1Ch], 0
.text:000079AA                 mov     edx, [ebp+var_4]
.text:000079AD                 mov     byte ptr [edx+4], 1
.text:000079B1                 mov     eax, [ebp+var_4]
.text:000079B4                 mov     byte ptr [eax+5], 1
.text:000079B8                 mov     ecx, [ebp+var_4]
.text:000079BB                 mov     byte ptr [ecx+6], 1
.text:000079BF                 mov     edx, [ebp+var_4]
.text:000079C2                 mov     byte ptr [edx+7], 1
.text:000079C6                 mov     eax, [ebp+var_4]
.text:000079C9                 mov     byte ptr [eax+0Eh], 1
.text:000079CD                 mov     ecx, [ebp+var_4]
.text:000079D0                 mov     byte ptr [ecx+0Fh], 1
.text:000079D4                 mov     edx, [ebp+var_4]
.text:000079D7                 mov     byte ptr [edx+0Dh], 1
.text:000079DB                 mov     eax, [ebp+var_4]
.text:000079DE                 add     esp, 4
.text:000079E1                 cmp     ebp, esp
.text:000079E3                 call    __RTC_CheckEsp
.text:000079E8                 mov     esp, ebp
.text:000079EA                 pop     ebp
.text:000079EB                 retn
.text:000079EB ??0COpenType@@QAE@XZ endp
.text:000079EB
.text:000079EB _text           ends
.text:000079EB
.text:000079EC ; ===========================================================================
.text:000079EC
.text:000079EC ; Segment type: Pure code
.text:000079EC ; Segment permissions: Read/Execute
.text:000079EC _text           segment para public 'CODE' use32
.text:000079EC                 assume cs:_text
.text:000079EC                 ;org 79ECh
.text:000079EC ; COMDAT (pick any)
.text:000079EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000079EC
.text:000079EC ; =============== S U B R O U T I N E =======================================
.text:000079EC
.text:000079EC ; Attributes: bp-based frame
.text:000079EC
.text:000079EC ; _DWORD __thiscall COpenSpecFlags::COpenSpecFlags(COpenSpecFlags *__hidden this)
.text:000079EC                 public ??0COpenSpecFlags@@QAE@XZ
.text:000079EC ??0COpenSpecFlags@@QAE@XZ proc near     ; CODE XREF: COpenType::COpenType(void)+1Dp
.text:000079EC                                         ; COpenType::COpenType(void)+28p ...
.text:000079EC
.text:000079EC var_4           = dword ptr -4
.text:000079EC
.text:000079EC                 push    ebp
.text:000079ED                 mov     ebp, esp
.text:000079EF                 push    ecx
.text:000079F0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000079F7                 mov     [ebp+var_4], ecx
.text:000079FA                 mov     eax, [ebp+var_4]
.text:000079FD                 mov     byte ptr [eax], 0
.text:00007A00                 mov     ecx, [ebp+var_4]
.text:00007A03                 mov     byte ptr [ecx+1], 0
.text:00007A07                 mov     edx, [ebp+var_4]
.text:00007A0A                 mov     byte ptr [edx+2], 0
.text:00007A0E                 mov     eax, [ebp+var_4]
.text:00007A11                 mov     esp, ebp
.text:00007A13                 pop     ebp
.text:00007A14                 retn
.text:00007A14 ??0COpenSpecFlags@@QAE@XZ endp
.text:00007A14
.text:00007A14 ; ---------------------------------------------------------------------------
.text:00007A15                 align 4
.text:00007A15 _text           ends
.text:00007A15
.text:00007A18 ; ===========================================================================
.text:00007A18
.text:00007A18 ; Segment type: Pure code
.text:00007A18 ; Segment permissions: Read/Execute
.text:00007A18 _text           segment para public 'CODE' use32
.text:00007A18                 assume cs:_text
.text:00007A18                 ;org 7A18h
.text:00007A18 ; COMDAT (pick any)
.text:00007A18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007A18
.text:00007A18 ; =============== S U B R O U T I N E =======================================
.text:00007A18
.text:00007A18 ; Attributes: bp-based frame
.text:00007A18
.text:00007A18 ; public: class UString __thiscall CArcInfoEx::GetMainExt(void)const
.text:00007A18                 public ?GetMainExt@CArcInfoEx@@QBE?AVUString@@XZ
.text:00007A18 ?GetMainExt@CArcInfoEx@@QBE?AVUString@@XZ proc near
.text:00007A18                                         ; CODE XREF: CUpdateOptions::SetArcPath(CCodecs const *,UString const &)+A8p
.text:00007A18
.text:00007A18 var_8           = dword ptr -8
.text:00007A18 var_4           = dword ptr -4
.text:00007A18 arg_0           = dword ptr  8
.text:00007A18
.text:00007A18                 push    ebp
.text:00007A19                 mov     ebp, esp
.text:00007A1B                 sub     esp, 8
.text:00007A1E                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00007A25                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00007A2C                 mov     [ebp+var_4], ecx
.text:00007A2F                 mov     [ebp+var_8], 0
.text:00007A36                 mov     ecx, [ebp+var_4]
.text:00007A39                 add     ecx, 18h
.text:00007A3C                 call    ?IsEmpty@?$CObjectVector@UCArcExtInfo@@@@QBE_NXZ ; CObjectVector<CArcExtInfo>::IsEmpty(void)
.text:00007A41                 movzx   eax, al
.text:00007A44                 test    eax, eax
.text:00007A46                 jz      short loc_7A5E
.text:00007A48                 mov     ecx, [ebp+arg_0]
.text:00007A4B                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00007A50                 mov     ecx, [ebp+var_8]
.text:00007A53                 or      ecx, 1
.text:00007A56                 mov     [ebp+var_8], ecx
.text:00007A59                 mov     eax, [ebp+arg_0]
.text:00007A5C                 jmp     short loc_7A80
.text:00007A5E ; ---------------------------------------------------------------------------
.text:00007A5E
.text:00007A5E loc_7A5E:                               ; CODE XREF: CArcInfoEx::GetMainExt(void)+2Ej
.text:00007A5E                 push    0
.text:00007A60                 mov     ecx, [ebp+var_4]
.text:00007A63                 add     ecx, 18h
.text:00007A66                 call    ??A?$CObjectVector@UCArcExtInfo@@@@QBEABUCArcExtInfo@@I@Z ; CObjectVector<CArcExtInfo>::operator[](uint)
.text:00007A6B                 push    eax
.text:00007A6C                 mov     ecx, [ebp+arg_0]
.text:00007A6F                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00007A74                 mov     edx, [ebp+var_8]
.text:00007A77                 or      edx, 1
.text:00007A7A                 mov     [ebp+var_8], edx
.text:00007A7D                 mov     eax, [ebp+arg_0]
.text:00007A80
.text:00007A80 loc_7A80:                               ; CODE XREF: CArcInfoEx::GetMainExt(void)+44j
.text:00007A80                 add     esp, 8
.text:00007A83                 cmp     ebp, esp
.text:00007A85                 call    __RTC_CheckEsp
.text:00007A8A                 mov     esp, ebp
.text:00007A8C                 pop     ebp
.text:00007A8D                 retn    4
.text:00007A8D ?GetMainExt@CArcInfoEx@@QBE?AVUString@@XZ endp
.text:00007A8D
.text:00007A8D _text           ends
.text:00007A8D
.text:00007A90 ; ===========================================================================
.text:00007A90
.text:00007A90 ; Segment type: Pure code
.text:00007A90 ; Segment permissions: Read/Execute
.text:00007A90 _text           segment para public 'CODE' use32
.text:00007A90                 assume cs:_text
.text:00007A90                 ;org 7A90h
.text:00007A90 ; COMDAT (pick any)
.text:00007A90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007A90
.text:00007A90 ; =============== S U B R O U T I N E =======================================
.text:00007A90
.text:00007A90 ; Attributes: bp-based frame
.text:00007A90
.text:00007A90 ; bool __stdcall IsPathSepar(wchar_t)
.text:00007A90                 public ?IsPathSepar@@YG_N_W@Z
.text:00007A90 ?IsPathSepar@@YG_N_W@Z proc near        ; CODE XREF: CRenamePair::GetNewPath(bool,UString const &,UString &)+92p
.text:00007A90                                         ; CRenamePair::GetNewPath(bool,UString const &,UString &)+B5p ...
.text:00007A90
.text:00007A90 var_4           = dword ptr -4
.text:00007A90 arg_0           = word ptr  8
.text:00007A90
.text:00007A90                 push    ebp
.text:00007A91                 mov     ebp, esp
.text:00007A93                 push    ecx
.text:00007A94                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00007A9B                 movzx   eax, [ebp+arg_0]
.text:00007A9F                 cmp     eax, 5Ch ; '\'
.text:00007AA2                 jz      short loc_7AB6
.text:00007AA4                 movzx   ecx, [ebp+arg_0]
.text:00007AA8                 cmp     ecx, 2Fh ; '/'
.text:00007AAB                 jz      short loc_7AB6
.text:00007AAD                 mov     [ebp+var_4], 0
.text:00007AB4                 jmp     short loc_7ABD
.text:00007AB6 ; ---------------------------------------------------------------------------
.text:00007AB6
.text:00007AB6 loc_7AB6:                               ; CODE XREF: IsPathSepar(wchar_t)+12j
.text:00007AB6                                         ; IsPathSepar(wchar_t)+1Bj
.text:00007AB6                 mov     [ebp+var_4], 1
.text:00007ABD
.text:00007ABD loc_7ABD:                               ; CODE XREF: IsPathSepar(wchar_t)+24j
.text:00007ABD                 mov     al, byte ptr [ebp+var_4]
.text:00007AC0                 mov     esp, ebp
.text:00007AC2                 pop     ebp
.text:00007AC3                 retn    4
.text:00007AC3 ?IsPathSepar@@YG_N_W@Z endp
.text:00007AC3
.text:00007AC3 ; ---------------------------------------------------------------------------
.text:00007AC6                 align 4
.text:00007AC6 _text           ends
.text:00007AC6
.text:00007AC8 ; ===========================================================================
.text:00007AC8
.text:00007AC8 ; Segment type: Pure code
.text:00007AC8 ; Segment permissions: Read/Execute
.text:00007AC8 _text           segment para public 'CODE' use32
.text:00007AC8                 assume cs:_text
.text:00007AC8                 ;org 7AC8h
.text:00007AC8 ; COMDAT (pick any)
.text:00007AC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007AC8
.text:00007AC8 ; =============== S U B R O U T I N E =======================================
.text:00007AC8
.text:00007AC8 ; Attributes: bp-based frame
.text:00007AC8
.text:00007AC8 ; wchar_t __stdcall MyCharUpper(wchar_t)
.text:00007AC8                 public ?MyCharUpper@@YG_W_W@Z
.text:00007AC8 ?MyCharUpper@@YG_W_W@Z proc near        ; CODE XREF: CompareTwoNames(wchar_t const *,wchar_t const *)+7Dp
.text:00007AC8                                         ; CompareTwoNames(wchar_t const *,wchar_t const *)+8Ap
.text:00007AC8
.text:00007AC8 arg_0           = word ptr  8
.text:00007AC8
.text:00007AC8                 push    ebp
.text:00007AC9                 mov     ebp, esp
.text:00007ACB                 movzx   eax, [ebp+arg_0]
.text:00007ACF                 cmp     eax, 61h ; 'a'
.text:00007AD2                 jge     short loc_7ADA
.text:00007AD4                 mov     ax, [ebp+arg_0]
.text:00007AD8                 jmp     short loc_7B05
.text:00007ADA ; ---------------------------------------------------------------------------
.text:00007ADA
.text:00007ADA loc_7ADA:                               ; CODE XREF: MyCharUpper(wchar_t)+Aj
.text:00007ADA                 movzx   ecx, [ebp+arg_0]
.text:00007ADE                 cmp     ecx, 7Ah ; 'z'
.text:00007AE1                 jg      short loc_7AEC
.text:00007AE3                 movzx   eax, [ebp+arg_0]
.text:00007AE7                 sub     eax, 20h ; ' '
.text:00007AEA                 jmp     short loc_7B05
.text:00007AEC ; ---------------------------------------------------------------------------
.text:00007AEC
.text:00007AEC loc_7AEC:                               ; CODE XREF: MyCharUpper(wchar_t)+19j
.text:00007AEC                 movzx   edx, [ebp+arg_0]
.text:00007AF0                 cmp     edx, 7Fh ; ''
.text:00007AF3                 jg      short loc_7AFB
.text:00007AF5                 mov     ax, [ebp+arg_0]
.text:00007AF9                 jmp     short loc_7B05
.text:00007AFB ; ---------------------------------------------------------------------------
.text:00007AFB
.text:00007AFB loc_7AFB:                               ; CODE XREF: MyCharUpper(wchar_t)+2Bj
.text:00007AFB                 movzx   eax, [ebp+arg_0]
.text:00007AFF                 push    eax             ; wchar_t
.text:00007B00                 call    ?MyCharUpper_WIN@@YG_W_W@Z ; MyCharUpper_WIN(wchar_t)
.text:00007B05
.text:00007B05 loc_7B05:                               ; CODE XREF: MyCharUpper(wchar_t)+10j
.text:00007B05                                         ; MyCharUpper(wchar_t)+22j ...
.text:00007B05                 cmp     ebp, esp
.text:00007B07                 call    __RTC_CheckEsp
.text:00007B0C                 pop     ebp
.text:00007B0D                 retn    4
.text:00007B0D ?MyCharUpper@@YG_W_W@Z endp
.text:00007B0D
.text:00007B0D _text           ends
.text:00007B0D
.xdata$x:00007B10 ; ===========================================================================
.xdata$x:00007B10
.xdata$x:00007B10 ; Segment type: Pure data
.xdata$x:00007B10 ; Segment permissions: Read
.xdata$x:00007B10 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007B10                 assume cs:_xdata$x
.xdata$x:00007B10                 ;org 7B10h
.xdata$x:00007B10 ; COMDAT (pick any)
.xdata$x:00007B10                 public __TI2PAD
.xdata$x:00007B10 __TI2PAD        db    0                 ; DATA XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+3ABo
.xdata$x:00007B10                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+404o ...
.xdata$x:00007B11                 db    0
.xdata$x:00007B12                 db    0
.xdata$x:00007B13                 db    0
.xdata$x:00007B14                 db    0
.xdata$x:00007B15                 db    0
.xdata$x:00007B16                 db    0
.xdata$x:00007B17                 db    0
.xdata$x:00007B18                 db    0
.xdata$x:00007B19                 db    0
.xdata$x:00007B1A                 db    0
.xdata$x:00007B1B                 db    0
.xdata$x:00007B1C                 dd offset __CTA2PAD
.xdata$x:00007B1C _xdata$x        ends
.xdata$x:00007B1C
.xdata$x:00007B20 ; ===========================================================================
.xdata$x:00007B20
.xdata$x:00007B20 ; Segment type: Pure data
.xdata$x:00007B20 ; Segment permissions: Read
.xdata$x:00007B20 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007B20                 assume cs:_xdata$x
.xdata$x:00007B20                 ;org 7B20h
.xdata$x:00007B20 ; COMDAT (pick any)
.xdata$x:00007B20                 public __CTA2PAD
.xdata$x:00007B20 __CTA2PAD       db    2                 ; DATA XREF: .xdata$x:00007B1Co
.xdata$x:00007B20                                         ; .xdata$x:00008888o
.xdata$x:00007B21                 db    0
.xdata$x:00007B22                 db    0
.xdata$x:00007B23                 db    0
.xdata$x:00007B24                 dd offset __CT??_R0PAD@84
.xdata$x:00007B28                 dd offset __CT??_R0PAX@84
.xdata$x:00007B28 _xdata$x        ends
.xdata$x:00007B28
.xdata$x:00007B2C ; ===========================================================================
.xdata$x:00007B2C
.xdata$x:00007B2C ; Segment type: Pure data
.xdata$x:00007B2C ; Segment permissions: Read
.xdata$x:00007B2C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007B2C                 assume cs:_xdata$x
.xdata$x:00007B2C                 ;org 7B2Ch
.xdata$x:00007B2C ; COMDAT (pick any)
.xdata$x:00007B2C                 public __CT??_R0PAD@84
.xdata$x:00007B2C __CT??_R0PAD@84 db    1                 ; DATA XREF: .xdata$x:00007B24o
.xdata$x:00007B2D                 db    0
.xdata$x:00007B2E                 db    0
.xdata$x:00007B2F                 db    0
.xdata$x:00007B30                 dd offset ??_R0PAD@8    ; char * `RTTI Type Descriptor'
.xdata$x:00007B34                 align 8
.xdata$x:00007B38                 db 0FFh
.xdata$x:00007B39                 db 0FFh
.xdata$x:00007B3A                 db 0FFh
.xdata$x:00007B3B                 db 0FFh
.xdata$x:00007B3C                 db    0
.xdata$x:00007B3D                 db    0
.xdata$x:00007B3E                 db    0
.xdata$x:00007B3F                 db    0
.xdata$x:00007B40                 db    4
.xdata$x:00007B41                 db    0
.xdata$x:00007B42                 db    0
.xdata$x:00007B43                 db    0
.xdata$x:00007B44                 db    0
.xdata$x:00007B45                 db    0
.xdata$x:00007B46                 db    0
.xdata$x:00007B47                 db    0
.xdata$x:00007B47 _xdata$x        ends
.xdata$x:00007B47
.data:00007B48 ; ===========================================================================
.data:00007B48
.data:00007B48 ; Segment type: Pure data
.data:00007B48 ; Segment permissions: Read/Write
.data:00007B48 _data           segment dword public 'DATA' use32
.data:00007B48                 assume cs:_data
.data:00007B48                 ;org 7B48h
.data:00007B48 ; COMDAT (pick any)
.data:00007B48                 public ??_R0PAD@8
.data:00007B48 ; char * `RTTI Type Descriptor'
.data:00007B48 ??_R0PAD@8      dd offset ??_7type_info@@6B@ ; DATA XREF: .xdata$x:00007B30o
.data:00007B48                                         ; const type_info::`vftable'
.data:00007B4C                 align 10h
.data:00007B50 a_pad           db '.PAD',0
.data:00007B55                 align 4
.data:00007B55 _data           ends
.data:00007B55
.xdata$x:00007B58 ; ===========================================================================
.xdata$x:00007B58
.xdata$x:00007B58 ; Segment type: Pure data
.xdata$x:00007B58 ; Segment permissions: Read
.xdata$x:00007B58 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007B58                 assume cs:_xdata$x
.xdata$x:00007B58                 ;org 7B58h
.xdata$x:00007B58 ; COMDAT (pick any)
.xdata$x:00007B58                 public __CT??_R0PAX@84
.xdata$x:00007B58 __CT??_R0PAX@84 db    1                 ; DATA XREF: .xdata$x:00007B28o
.xdata$x:00007B59                 db    0
.xdata$x:00007B5A                 db    0
.xdata$x:00007B5B                 db    0
.xdata$x:00007B5C                 dd offset ??_R0PAX@8    ; void * `RTTI Type Descriptor'
.xdata$x:00007B60                 db    0
.xdata$x:00007B61                 db    0
.xdata$x:00007B62                 db    0
.xdata$x:00007B63                 db    0
.xdata$x:00007B64                 db 0FFh
.xdata$x:00007B65                 db 0FFh
.xdata$x:00007B66                 db 0FFh
.xdata$x:00007B67                 db 0FFh
.xdata$x:00007B68                 db    0
.xdata$x:00007B69                 db    0
.xdata$x:00007B6A                 db    0
.xdata$x:00007B6B                 db    0
.xdata$x:00007B6C                 db    4
.xdata$x:00007B6D                 db    0
.xdata$x:00007B6E                 db    0
.xdata$x:00007B6F                 db    0
.xdata$x:00007B70                 db    0
.xdata$x:00007B71                 db    0
.xdata$x:00007B72                 db    0
.xdata$x:00007B73                 db    0
.xdata$x:00007B73 _xdata$x        ends
.xdata$x:00007B73
.data:00007B74 ; ===========================================================================
.data:00007B74
.data:00007B74 ; Segment type: Pure data
.data:00007B74 ; Segment permissions: Read/Write
.data:00007B74 _data           segment dword public 'DATA' use32
.data:00007B74                 assume cs:_data
.data:00007B74                 ;org 7B74h
.data:00007B74 ; COMDAT (pick any)
.data:00007B74                 public ??_R0PAX@8
.data:00007B74 ; void * `RTTI Type Descriptor'
.data:00007B74 ??_R0PAX@8      dd offset ??_7type_info@@6B@ ; DATA XREF: .xdata$x:00007B5Co
.data:00007B74                                         ; const type_info::`vftable'
.data:00007B78                 db    0
.data:00007B79                 db    0
.data:00007B7A                 db    0
.data:00007B7B                 db    0
.data:00007B7C                 db  2Eh ; .
.data:00007B7D                 db  50h ; P
.data:00007B7E                 db  41h ; A
.data:00007B7F                 db  58h ; X
.data:00007B80                 db    0
.data:00007B81                 align 4
.data:00007B81 _data           ends
.data:00007B81
.text:00007B84 ; ===========================================================================
.text:00007B84
.text:00007B84 ; Segment type: Pure code
.text:00007B84 ; Segment permissions: Read/Execute
.text:00007B84 _text           segment para public 'CODE' use32
.text:00007B84                 assume cs:_text
.text:00007B84                 ;org 7B84h
.text:00007B84 ; COMDAT (pick any)
.text:00007B84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007B84
.text:00007B84 ; =============== S U B R O U T I N E =======================================
.text:00007B84
.text:00007B84 ; Attributes: bp-based frame
.text:00007B84
.text:00007B84 ; _DWORD __thiscall AString::~AString(AString *__hidden this)
.text:00007B84                 public ??1AString@@QAE@XZ
.text:00007B84 ??1AString@@QAE@XZ proc near            ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+2275p
.text:00007B84                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+2284p ...
.text:00007B84
.text:00007B84 var_8           = dword ptr -8
.text:00007B84 var_4           = dword ptr -4
.text:00007B84
.text:00007B84                 push    ebp
.text:00007B85                 mov     ebp, esp
.text:00007B87                 sub     esp, 8
.text:00007B8A                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00007B91                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00007B98                 mov     [ebp+var_4], ecx
.text:00007B9B                 mov     eax, [ebp+var_4]
.text:00007B9E                 mov     ecx, [eax]
.text:00007BA0                 mov     [ebp+var_8], ecx
.text:00007BA3                 mov     edx, [ebp+var_8]
.text:00007BA6                 push    edx             ; void *
.text:00007BA7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00007BAC                 add     esp, 4
.text:00007BAF                 add     esp, 8
.text:00007BB2                 cmp     ebp, esp
.text:00007BB4                 call    __RTC_CheckEsp
.text:00007BB9                 mov     esp, ebp
.text:00007BBB                 pop     ebp
.text:00007BBC                 retn
.text:00007BBC ??1AString@@QAE@XZ endp
.text:00007BBC
.text:00007BBC ; ---------------------------------------------------------------------------
.text:00007BBD                 align 10h
.text:00007BBD _text           ends
.text:00007BBD
.text:00007BC0 ; ===========================================================================
.text:00007BC0
.text:00007BC0 ; Segment type: Pure code
.text:00007BC0 ; Segment permissions: Read/Execute
.text:00007BC0 _text           segment para public 'CODE' use32
.text:00007BC0                 assume cs:_text
.text:00007BC0                 ;org 7BC0h
.text:00007BC0 ; COMDAT (pick any)
.text:00007BC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007BC0
.text:00007BC0 ; =============== S U B R O U T I N E =======================================
.text:00007BC0
.text:00007BC0 ; Attributes: bp-based frame
.text:00007BC0
.text:00007BC0 ; bool __thiscall AString::IsEmpty(AString *__hidden this)
.text:00007BC0                 public ?IsEmpty@AString@@QBE_NXZ
.text:00007BC0 ?IsEmpty@AString@@QBE_NXZ proc near     ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+21FDp
.text:00007BC0
.text:00007BC0 var_4           = dword ptr -4
.text:00007BC0
.text:00007BC0                 push    ebp
.text:00007BC1                 mov     ebp, esp
.text:00007BC3                 push    ecx
.text:00007BC4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00007BCB                 mov     [ebp+var_4], ecx
.text:00007BCE                 mov     eax, [ebp+var_4]
.text:00007BD1                 xor     ecx, ecx
.text:00007BD3                 cmp     dword ptr [eax+4], 0
.text:00007BD7                 setz    cl
.text:00007BDA                 mov     al, cl
.text:00007BDC                 mov     esp, ebp
.text:00007BDE                 pop     ebp
.text:00007BDF                 retn
.text:00007BDF ?IsEmpty@AString@@QBE_NXZ endp
.text:00007BDF
.text:00007BDF _text           ends
.text:00007BDF
.text:00007BE0 ; ===========================================================================
.text:00007BE0
.text:00007BE0 ; Segment type: Pure code
.text:00007BE0 ; Segment permissions: Read/Execute
.text:00007BE0 _text           segment para public 'CODE' use32
.text:00007BE0                 assume cs:_text
.text:00007BE0                 ;org 7BE0h
.text:00007BE0 ; COMDAT (pick any)
.text:00007BE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007BE0
.text:00007BE0 ; =============== S U B R O U T I N E =======================================
.text:00007BE0
.text:00007BE0 ; Attributes: bp-based frame
.text:00007BE0
.text:00007BE0 ; public: __thiscall AString::operator char const *(void)const
.text:00007BE0                 public ??BAString@@QBEPBDXZ
.text:00007BE0 ??BAString@@QBEPBDXZ proc near          ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+2199p
.text:00007BE0                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+21AAp ...
.text:00007BE0
.text:00007BE0 var_4           = dword ptr -4
.text:00007BE0
.text:00007BE0                 push    ebp
.text:00007BE1                 mov     ebp, esp
.text:00007BE3                 push    ecx
.text:00007BE4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00007BEB                 mov     [ebp+var_4], ecx
.text:00007BEE                 mov     eax, [ebp+var_4]
.text:00007BF1                 mov     eax, [eax]
.text:00007BF3                 mov     esp, ebp
.text:00007BF5                 pop     ebp
.text:00007BF6                 retn
.text:00007BF6 ??BAString@@QBEPBDXZ endp
.text:00007BF6
.text:00007BF6 ; ---------------------------------------------------------------------------
.text:00007BF7                 align 4
.text:00007BF7 _text           ends
.text:00007BF7
.text:00007BF8 ; ===========================================================================
.text:00007BF8
.text:00007BF8 ; Segment type: Pure code
.text:00007BF8 ; Segment permissions: Read/Execute
.text:00007BF8 _text           segment para public 'CODE' use32
.text:00007BF8                 assume cs:_text
.text:00007BF8                 ;org 7BF8h
.text:00007BF8 ; COMDAT (pick any)
.text:00007BF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007BF8
.text:00007BF8 ; =============== S U B R O U T I N E =======================================
.text:00007BF8
.text:00007BF8 ; Attributes: bp-based frame
.text:00007BF8
.text:00007BF8 ; int __thiscall UString::Find(UString *this, wchar_t)
.text:00007BF8                 public ?Find@UString@@QBEH_W@Z
.text:00007BF8 ?Find@UString@@QBEH_W@Z proc near       ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+208p
.text:00007BF8
.text:00007BF8 var_4           = dword ptr -4
.text:00007BF8 arg_0           = word ptr  8
.text:00007BF8
.text:00007BF8                 push    ebp
.text:00007BF9                 mov     ebp, esp
.text:00007BFB                 push    ecx
.text:00007BFC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00007C03                 mov     [ebp+var_4], ecx
.text:00007C06                 movzx   eax, [ebp+arg_0]
.text:00007C0A                 push    eax             ; wchar_t
.text:00007C0B                 mov     ecx, [ebp+var_4]
.text:00007C0E                 mov     edx, [ecx]
.text:00007C10                 push    edx             ; wchar_t *
.text:00007C11                 call    ?FindCharPosInString@@YGHPB_W_W@Z ; FindCharPosInString(wchar_t const *,wchar_t)
.text:00007C16                 add     esp, 4
.text:00007C19                 cmp     ebp, esp
.text:00007C1B                 call    __RTC_CheckEsp
.text:00007C20                 mov     esp, ebp
.text:00007C22                 pop     ebp
.text:00007C23                 retn    4
.text:00007C23 ?Find@UString@@QBEH_W@Z endp
.text:00007C23
.text:00007C23 ; ---------------------------------------------------------------------------
.text:00007C26                 align 4
.text:00007C26 _text           ends
.text:00007C26
.text:00007C28 ; ===========================================================================
.text:00007C28
.text:00007C28 ; Segment type: Pure code
.text:00007C28 ; Segment permissions: Read/Execute
.text:00007C28 _text           segment para public 'CODE' use32
.text:00007C28                 assume cs:_text
.text:00007C28                 ;org 7C28h
.text:00007C28 ; COMDAT (pick any)
.text:00007C28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007C28
.text:00007C28 ; =============== S U B R O U T I N E =======================================
.text:00007C28
.text:00007C28 ; Attributes: bp-based frame
.text:00007C28
.text:00007C28 ; bool __thiscall NWindows::NFile::NFind::CFileInfoBase::IsDir(NWindows::NFile::NFind::CFileInfoBase *__hidden this)
.text:00007C28                 public ?IsDir@CFileInfoBase@NFind@NFile@NWindows@@QBE_NXZ
.text:00007C28 ?IsDir@CFileInfoBase@NFind@NFile@NWindows@@QBE_NXZ proc near
.text:00007C28                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+485p
.text:00007C28                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+F94p
.text:00007C28
.text:00007C28 var_4           = dword ptr -4
.text:00007C28
.text:00007C28                 push    ebp
.text:00007C29                 mov     ebp, esp
.text:00007C2B                 push    ecx
.text:00007C2C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00007C33                 mov     [ebp+var_4], ecx
.text:00007C36                 push    10h             ; unsigned int
.text:00007C38                 mov     ecx, [ebp+var_4] ; this
.text:00007C3B                 call    ?MatchesMask@CFileInfoBase@NFind@NFile@NWindows@@ABE_NI@Z ; NWindows::NFile::NFind::CFileInfoBase::MatchesMask(uint)
.text:00007C40                 add     esp, 4
.text:00007C43                 cmp     ebp, esp
.text:00007C45                 call    __RTC_CheckEsp
.text:00007C4A                 mov     esp, ebp
.text:00007C4C                 pop     ebp
.text:00007C4D                 retn
.text:00007C4D ?IsDir@CFileInfoBase@NFind@NFile@NWindows@@QBE_NXZ endp
.text:00007C4D
.text:00007C4D ; ---------------------------------------------------------------------------
.text:00007C4E                 align 10h
.text:00007C4E _text           ends
.text:00007C4E
.text:00007C50 ; ===========================================================================
.text:00007C50
.text:00007C50 ; Segment type: Pure code
.text:00007C50 ; Segment permissions: Read/Execute
.text:00007C50 _text           segment para public 'CODE' use32
.text:00007C50                 assume cs:_text
.text:00007C50                 ;org 7C50h
.text:00007C50 ; COMDAT (pick any)
.text:00007C50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007C50
.text:00007C50 ; =============== S U B R O U T I N E =======================================
.text:00007C50
.text:00007C50 ; Attributes: bp-based frame
.text:00007C50
.text:00007C50 ; bool __thiscall NWindows::NFile::NFind::CFileInfoBase::MatchesMask(NWindows::NFile::NFind::CFileInfoBase *this, unsigned int)
.text:00007C50                 public ?MatchesMask@CFileInfoBase@NFind@NFile@NWindows@@ABE_NI@Z
.text:00007C50 ?MatchesMask@CFileInfoBase@NFind@NFile@NWindows@@ABE_NI@Z proc near
.text:00007C50                                         ; CODE XREF: NWindows::NFile::NFind::CFileInfoBase::IsDir(void)+13p
.text:00007C50
.text:00007C50 var_4           = dword ptr -4
.text:00007C50 arg_0           = dword ptr  8
.text:00007C50
.text:00007C50                 push    ebp
.text:00007C51                 mov     ebp, esp
.text:00007C53                 push    ecx
.text:00007C54                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00007C5B                 mov     [ebp+var_4], ecx
.text:00007C5E                 mov     eax, [ebp+var_4]
.text:00007C61                 mov     eax, [eax+20h]
.text:00007C64                 and     eax, [ebp+arg_0]
.text:00007C67                 neg     eax
.text:00007C69                 sbb     eax, eax
.text:00007C6B                 neg     eax
.text:00007C6D                 mov     esp, ebp
.text:00007C6F                 pop     ebp
.text:00007C70                 retn    4
.text:00007C70 ?MatchesMask@CFileInfoBase@NFind@NFile@NWindows@@ABE_NI@Z endp
.text:00007C70
.text:00007C70 ; ---------------------------------------------------------------------------
.text:00007C73                 align 4
.text:00007C73 _text           ends
.text:00007C73
.text:00007C74 ; ===========================================================================
.text:00007C74
.text:00007C74 ; Segment type: Pure code
.text:00007C74 ; Segment permissions: Read/Execute
.text:00007C74 _text           segment para public 'CODE' use32
.text:00007C74                 assume cs:_text
.text:00007C74                 ;org 7C74h
.text:00007C74 ; COMDAT (pick any)
.text:00007C74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007C74
.text:00007C74 ; =============== S U B R O U T I N E =======================================
.text:00007C74
.text:00007C74 ; Attributes: bp-based frame
.text:00007C74
.text:00007C74 ; _DWORD __thiscall NWindows::NFile::NFind::CFileInfo::CFileInfo(NWindows::NFile::NFind::CFileInfo *__hidden this)
.text:00007C74                 public ??0CFileInfo@NFind@NFile@NWindows@@QAE@XZ
.text:00007C74 ??0CFileInfo@NFind@NFile@NWindows@@QAE@XZ proc near
.text:00007C74                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+3C7p
.text:00007C74                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+F3Cp
.text:00007C74
.text:00007C74 var_4           = dword ptr -4
.text:00007C74
.text:00007C74                 push    ebp
.text:00007C75                 mov     ebp, esp
.text:00007C77                 push    ecx
.text:00007C78                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00007C7F                 mov     [ebp+var_4], ecx
.text:00007C82                 mov     ecx, [ebp+var_4] ; this
.text:00007C85                 call    ??0CFileInfoBase@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfoBase::CFileInfoBase(void)
.text:00007C8A                 mov     ecx, [ebp+var_4]
.text:00007C8D                 add     ecx, 28h ; '('
.text:00007C90                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00007C95                 mov     eax, [ebp+var_4]
.text:00007C98                 add     esp, 4
.text:00007C9B                 cmp     ebp, esp
.text:00007C9D                 call    __RTC_CheckEsp
.text:00007CA2                 mov     esp, ebp
.text:00007CA4                 pop     ebp
.text:00007CA5                 retn
.text:00007CA5 ??0CFileInfo@NFind@NFile@NWindows@@QAE@XZ endp
.text:00007CA5
.text:00007CA5 ; ---------------------------------------------------------------------------
.text:00007CA6                 align 4
.text:00007CA6 _text           ends
.text:00007CA6
.text:00007CA8 ; ===========================================================================
.text:00007CA8
.text:00007CA8 ; Segment type: Pure code
.text:00007CA8 ; Segment permissions: Read/Execute
.text:00007CA8 _text           segment para public 'CODE' use32
.text:00007CA8                 assume cs:_text
.text:00007CA8                 ;org 7CA8h
.text:00007CA8 ; COMDAT (pick any)
.text:00007CA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007CA8
.text:00007CA8 ; =============== S U B R O U T I N E =======================================
.text:00007CA8
.text:00007CA8 ; Attributes: bp-based frame
.text:00007CA8
.text:00007CA8 ; _DWORD __thiscall NWindows::NFile::NFind::CFileInfoBase::CFileInfoBase(NWindows::NFile::NFind::CFileInfoBase *__hidden this)
.text:00007CA8                 public ??0CFileInfoBase@NFind@NFile@NWindows@@QAE@XZ
.text:00007CA8 ??0CFileInfoBase@NFind@NFile@NWindows@@QAE@XZ proc near
.text:00007CA8                                         ; CODE XREF: NWindows::NFile::NFind::CFileInfo::CFileInfo(void)+11p
.text:00007CA8
.text:00007CA8 var_4           = dword ptr -4
.text:00007CA8
.text:00007CA8                 push    ebp
.text:00007CA9                 mov     ebp, esp
.text:00007CAB                 push    ecx
.text:00007CAC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00007CB3                 mov     [ebp+var_4], ecx
.text:00007CB6                 mov     ecx, [ebp+var_4] ; this
.text:00007CB9                 call    ?ClearBase@CFileInfoBase@NFind@NFile@NWindows@@QAEXXZ ; NWindows::NFile::NFind::CFileInfoBase::ClearBase(void)
.text:00007CBE                 mov     eax, [ebp+var_4]
.text:00007CC1                 add     esp, 4
.text:00007CC4                 cmp     ebp, esp
.text:00007CC6                 call    __RTC_CheckEsp
.text:00007CCB                 mov     esp, ebp
.text:00007CCD                 pop     ebp
.text:00007CCE                 retn
.text:00007CCE ??0CFileInfoBase@NFind@NFile@NWindows@@QAE@XZ endp
.text:00007CCE
.text:00007CCE ; ---------------------------------------------------------------------------
.text:00007CCF                 align 10h
.text:00007CCF _text           ends
.text:00007CCF
.text:00007CD0 ; ===========================================================================
.text:00007CD0
.text:00007CD0 ; Segment type: Pure code
.text:00007CD0 ; Segment permissions: Read/Execute
.text:00007CD0 _text           segment para public 'CODE' use32
.text:00007CD0                 assume cs:_text
.text:00007CD0                 ;org 7CD0h
.text:00007CD0 ; COMDAT (pick any)
.text:00007CD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007CD0
.text:00007CD0 ; =============== S U B R O U T I N E =======================================
.text:00007CD0
.text:00007CD0 ; Attributes: bp-based frame
.text:00007CD0
.text:00007CD0 ; _DWORD __thiscall NWindows::NFile::NFind::CFileInfo::~CFileInfo(NWindows::NFile::NFind::CFileInfo *__hidden this)
.text:00007CD0                 public ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ
.text:00007CD0 ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ proc near
.text:00007CD0                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+449p
.text:00007CD0                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+4CBp ...
.text:00007CD0
.text:00007CD0 var_4           = dword ptr -4
.text:00007CD0
.text:00007CD0                 push    ebp
.text:00007CD1                 mov     ebp, esp
.text:00007CD3                 push    ecx
.text:00007CD4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00007CDB                 mov     [ebp+var_4], ecx
.text:00007CDE                 mov     ecx, [ebp+var_4]
.text:00007CE1                 add     ecx, 28h ; '('  ; this
.text:00007CE4                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00007CE9                 add     esp, 4
.text:00007CEC                 cmp     ebp, esp
.text:00007CEE                 call    __RTC_CheckEsp
.text:00007CF3                 mov     esp, ebp
.text:00007CF5                 pop     ebp
.text:00007CF6                 retn
.text:00007CF6 ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ endp
.text:00007CF6
.text:00007CF6 ; ---------------------------------------------------------------------------
.text:00007CF7                 align 4
.text:00007CF7 _text           ends
.text:00007CF7
.text:00007CF8 ; ===========================================================================
.text:00007CF8
.text:00007CF8 ; Segment type: Pure code
.text:00007CF8 ; Segment permissions: Read/Execute
.text:00007CF8 _text           segment para public 'CODE' use32
.text:00007CF8                 assume cs:_text
.text:00007CF8                 ;org 7CF8h
.text:00007CF8 ; COMDAT (pick any)
.text:00007CF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007CF8
.text:00007CF8 ; =============== S U B R O U T I N E =======================================
.text:00007CF8
.text:00007CF8 ; Attributes: bp-based frame
.text:00007CF8
.text:00007CF8 ; _DWORD __thiscall COpenOptions::COpenOptions(COpenOptions *__hidden this)
.text:00007CF8                 public ??0COpenOptions@@QAE@XZ
.text:00007CF8 ??0COpenOptions@@QAE@XZ proc near       ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+593p
.text:00007CF8
.text:00007CF8 var_4           = dword ptr -4
.text:00007CF8
.text:00007CF8                 push    ebp
.text:00007CF9                 mov     ebp, esp
.text:00007CFB                 push    ecx
.text:00007CFC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00007D03                 mov     [ebp+var_4], ecx
.text:00007D06                 mov     eax, [ebp+var_4]
.text:00007D09                 mov     dword ptr [eax], 0
.text:00007D0F                 mov     ecx, [ebp+var_4]
.text:00007D12                 add     ecx, 8          ; this
.text:00007D15                 call    ??0COpenType@@QAE@XZ ; COpenType::COpenType(void)
.text:00007D1A                 mov     ecx, [ebp+var_4]
.text:00007D1D                 mov     dword ptr [ecx+28h], 0
.text:00007D24                 mov     edx, [ebp+var_4]
.text:00007D27                 mov     dword ptr [edx+2Ch], 0
.text:00007D2E                 mov     eax, [ebp+var_4]
.text:00007D31                 mov     dword ptr [eax+30h], 0
.text:00007D38                 mov     ecx, [ebp+var_4]
.text:00007D3B                 mov     dword ptr [ecx+34h], 0
.text:00007D42                 mov     edx, [ebp+var_4]
.text:00007D45                 mov     dword ptr [edx+38h], 0
.text:00007D4C                 mov     eax, [ebp+var_4]
.text:00007D4F                 mov     dword ptr [eax+3Ch], 0
.text:00007D56                 mov     ecx, [ebp+var_4]
.text:00007D59                 mov     byte ptr [ecx+44h], 0
.text:00007D5D                 mov     ecx, [ebp+var_4]
.text:00007D60                 add     ecx, 48h ; 'H'
.text:00007D63                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00007D68                 mov     eax, [ebp+var_4]
.text:00007D6B                 add     esp, 4
.text:00007D6E                 cmp     ebp, esp
.text:00007D70                 call    __RTC_CheckEsp
.text:00007D75                 mov     esp, ebp
.text:00007D77                 pop     ebp
.text:00007D78                 retn
.text:00007D78 ??0COpenOptions@@QAE@XZ endp
.text:00007D78
.text:00007D78 ; ---------------------------------------------------------------------------
.text:00007D79                 align 4
.text:00007D79 _text           ends
.text:00007D79
.text:00007D7C ; ===========================================================================
.text:00007D7C
.text:00007D7C ; Segment type: Pure code
.text:00007D7C ; Segment permissions: Read/Execute
.text:00007D7C _text           segment para public 'CODE' use32
.text:00007D7C                 assume cs:_text
.text:00007D7C                 ;org 7D7Ch
.text:00007D7C ; COMDAT (pick any)
.text:00007D7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007D7C
.text:00007D7C ; =============== S U B R O U T I N E =======================================
.text:00007D7C
.text:00007D7C ; Attributes: bp-based frame
.text:00007D7C
.text:00007D7C ; public: __thiscall CArchiveLink::CArchiveLink(void)
.text:00007D7C                 public ??0CArchiveLink@@QAE@XZ
.text:00007D7C ??0CArchiveLink@@QAE@XZ proc near       ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+306p
.text:00007D7C
.text:00007D7C var_10          = dword ptr -10h
.text:00007D7C var_C           = dword ptr -0Ch
.text:00007D7C var_4           = dword ptr -4
.text:00007D7C
.text:00007D7C                 push    ebp
.text:00007D7D                 mov     ebp, esp
.text:00007D7F                 push    0FFFFFFFFh
.text:00007D81                 push    offset __ehhandler$??0CArchiveLink@@QAE@XZ
.text:00007D86                 mov     eax, large fs:0
.text:00007D8C                 push    eax
.text:00007D8D                 push    ecx
.text:00007D8E                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00007D95                 mov     eax, dword ptr ds:___security_cookie
.text:00007D9A                 xor     eax, ebp
.text:00007D9C                 push    eax
.text:00007D9D                 lea     eax, [ebp+var_C]
.text:00007DA0                 mov     large fs:0, eax
.text:00007DA6                 mov     [ebp+var_10], ecx
.text:00007DA9                 mov     ecx, [ebp+var_10]
.text:00007DAC                 call    ??0?$CObjectVector@VCArc@@@@QAE@XZ ; CObjectVector<CArc>::CObjectVector<CArc>(void)
.text:00007DB1                 mov     [ebp+var_4], 0
.text:00007DB8                 mov     ecx, [ebp+var_10]
.text:00007DBB                 add     ecx, 0Ch
.text:00007DBE                 call    ??0?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::CObjectVector<UString>(void)
.text:00007DC3                 mov     byte ptr [ebp+var_4], 1
.text:00007DC7                 mov     eax, [ebp+var_10]
.text:00007DCA                 mov     dword ptr [eax+18h], 0
.text:00007DD1                 mov     dword ptr [eax+1Ch], 0
.text:00007DD8                 mov     ecx, [ebp+var_10]
.text:00007DDB                 mov     byte ptr [ecx+20h], 0
.text:00007DDF                 mov     edx, [ebp+var_10]
.text:00007DE2                 mov     byte ptr [edx+21h], 0
.text:00007DE6                 mov     ecx, [ebp+var_10]
.text:00007DE9                 add     ecx, 24h ; '$'
.text:00007DEC                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00007DF1                 mov     byte ptr [ebp+var_4], 2
.text:00007DF5                 mov     ecx, [ebp+var_10]
.text:00007DF8                 add     ecx, 30h ; '0'  ; this
.text:00007DFB                 call    ??0CArcErrorInfo@@QAE@XZ ; CArcErrorInfo::CArcErrorInfo(void)
.text:00007E00                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00007E07                 mov     eax, [ebp+var_10]
.text:00007E0A                 mov     ecx, [ebp+var_C]
.text:00007E0D                 mov     large fs:0, ecx
.text:00007E14                 pop     ecx
.text:00007E15                 add     esp, 10h
.text:00007E18                 cmp     ebp, esp
.text:00007E1A                 call    __RTC_CheckEsp
.text:00007E1F                 mov     esp, ebp
.text:00007E21                 pop     ebp
.text:00007E22                 retn
.text:00007E22 ??0CArchiveLink@@QAE@XZ endp
.text:00007E22
.text:00007E22 ; ---------------------------------------------------------------------------
.text:00007E23                 align 4
.text:00007E23 _text           ends
.text:00007E23
.text$x:00007E24 ; ===========================================================================
.text$x:00007E24
.text$x:00007E24 ; Segment type: Pure code
.text$x:00007E24 ; Segment permissions: Read/Execute
.text$x:00007E24 _text$x         segment para public 'CODE' use32
.text$x:00007E24                 assume cs:_text$x
.text$x:00007E24                 ;org 7E24h
.text$x:00007E24 ; COMDAT (pick associative to section at 7D7C)
.text$x:00007E24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007E24
.text$x:00007E24 ; =============== S U B R O U T I N E =======================================
.text$x:00007E24
.text$x:00007E24
.text$x:00007E24 __unwindfunclet$??0CArchiveLink@@QAE@XZ$0 proc near
.text$x:00007E24                                         ; DATA XREF: .xdata$x:00007E64o
.text$x:00007E24                 mov     ecx, [ebp-10h]
.text$x:00007E27                 jmp     ??1?$CObjectVector@VCArc@@@@QAE@XZ ; CObjectVector<CArc>::~CObjectVector<CArc>(void)
.text$x:00007E27 __unwindfunclet$??0CArchiveLink@@QAE@XZ$0 endp
.text$x:00007E27
.text$x:00007E2C
.text$x:00007E2C ; =============== S U B R O U T I N E =======================================
.text$x:00007E2C
.text$x:00007E2C
.text$x:00007E2C __unwindfunclet$??0CArchiveLink@@QAE@XZ$1 proc near
.text$x:00007E2C                                         ; DATA XREF: .xdata$x:00007E6Co
.text$x:00007E2C                 mov     ecx, [ebp-10h]
.text$x:00007E2F                 add     ecx, 0Ch
.text$x:00007E32                 jmp     ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text$x:00007E32 __unwindfunclet$??0CArchiveLink@@QAE@XZ$1 endp
.text$x:00007E32
.text$x:00007E37
.text$x:00007E37 ; =============== S U B R O U T I N E =======================================
.text$x:00007E37
.text$x:00007E37
.text$x:00007E37 __unwindfunclet$??0CArchiveLink@@QAE@XZ$2 proc near
.text$x:00007E37                                         ; DATA XREF: .xdata$x:00007E74o
.text$x:00007E37                 mov     ecx, [ebp-10h]
.text$x:00007E3A                 add     ecx, 24h ; '$'  ; this
.text$x:00007E3D                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00007E3D __unwindfunclet$??0CArchiveLink@@QAE@XZ$2 endp
.text$x:00007E3D
.text$x:00007E42
.text$x:00007E42 ; =============== S U B R O U T I N E =======================================
.text$x:00007E42
.text$x:00007E42
.text$x:00007E42 __ehhandler$??0CArchiveLink@@QAE@XZ proc near
.text$x:00007E42                                         ; DATA XREF: CArchiveLink::CArchiveLink(void)+5o
.text$x:00007E42
.text$x:00007E42 arg_4           = dword ptr  8
.text$x:00007E42
.text$x:00007E42                 mov     edx, [esp+arg_4]
.text$x:00007E46                 lea     eax, [edx+0Ch]
.text$x:00007E49                 mov     ecx, [edx-8]
.text$x:00007E4C                 xor     ecx, eax
.text$x:00007E4E                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007E53                 mov     eax, offset __ehfuncinfo$??0CArchiveLink@@QAE@XZ
.text$x:00007E58                 jmp     ___CxxFrameHandler3
.text$x:00007E58 __ehhandler$??0CArchiveLink@@QAE@XZ endp
.text$x:00007E58
.text$x:00007E58 ; ---------------------------------------------------------------------------
.text$x:00007E5D                 align 10h
.text$x:00007E5D _text$x         ends
.text$x:00007E5D
.xdata$x:00007E60 ; ===========================================================================
.xdata$x:00007E60
.xdata$x:00007E60 ; Segment type: Pure data
.xdata$x:00007E60 ; Segment permissions: Read
.xdata$x:00007E60 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007E60                 assume cs:_xdata$x
.xdata$x:00007E60                 ;org 7E60h
.xdata$x:00007E60 ; COMDAT (pick associative to section at 7D7C)
.xdata$x:00007E60 __unwindtable$??0CArchiveLink@@QAE@XZ db 0FFh
.xdata$x:00007E60                                         ; DATA XREF: .xdata$x:00007E80o
.xdata$x:00007E61                 db 0FFh
.xdata$x:00007E62                 db 0FFh
.xdata$x:00007E63                 db 0FFh
.xdata$x:00007E64                 dd offset __unwindfunclet$??0CArchiveLink@@QAE@XZ$0
.xdata$x:00007E68                 db    0
.xdata$x:00007E69                 db    0
.xdata$x:00007E6A                 db    0
.xdata$x:00007E6B                 db    0
.xdata$x:00007E6C                 dd offset __unwindfunclet$??0CArchiveLink@@QAE@XZ$1
.xdata$x:00007E70                 db    1
.xdata$x:00007E71                 db    0
.xdata$x:00007E72                 db    0
.xdata$x:00007E73                 db    0
.xdata$x:00007E74                 dd offset __unwindfunclet$??0CArchiveLink@@QAE@XZ$2
.xdata$x:00007E78 __ehfuncinfo$??0CArchiveLink@@QAE@XZ db  22h ; "
.xdata$x:00007E78                                         ; DATA XREF: __ehhandler$??0CArchiveLink@@QAE@XZ+11o
.xdata$x:00007E79                 db    5
.xdata$x:00007E7A                 db  93h ; 
.xdata$x:00007E7B                 db  19h
.xdata$x:00007E7C                 db    3
.xdata$x:00007E7D                 db    0
.xdata$x:00007E7E                 db    0
.xdata$x:00007E7F                 db    0
.xdata$x:00007E80                 dd offset __unwindtable$??0CArchiveLink@@QAE@XZ
.xdata$x:00007E84                 db    0
.xdata$x:00007E85                 db    0
.xdata$x:00007E86                 db    0
.xdata$x:00007E87                 db    0
.xdata$x:00007E88                 db    0
.xdata$x:00007E89                 db    0
.xdata$x:00007E8A                 db    0
.xdata$x:00007E8B                 db    0
.xdata$x:00007E8C                 db    0
.xdata$x:00007E8D                 db    0
.xdata$x:00007E8E                 db    0
.xdata$x:00007E8F                 db    0
.xdata$x:00007E90                 db    0
.xdata$x:00007E91                 db    0
.xdata$x:00007E92                 db    0
.xdata$x:00007E93                 db    0
.xdata$x:00007E94                 db    0
.xdata$x:00007E95                 db    0
.xdata$x:00007E96                 db    0
.xdata$x:00007E97                 db    0
.xdata$x:00007E98                 db    1
.xdata$x:00007E99                 db    0
.xdata$x:00007E9A                 db    0
.xdata$x:00007E9B                 db    0
.xdata$x:00007E9B _xdata$x        ends
.xdata$x:00007E9B
.text:00007E9C ; ===========================================================================
.text:00007E9C
.text:00007E9C ; Segment type: Pure code
.text:00007E9C ; Segment permissions: Read/Execute
.text:00007E9C _text           segment para public 'CODE' use32
.text:00007E9C                 assume cs:_text
.text:00007E9C                 ;org 7E9Ch
.text:00007E9C ; COMDAT (pick any)
.text:00007E9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007E9C
.text:00007E9C ; =============== S U B R O U T I N E =======================================
.text:00007E9C
.text:00007E9C ; Attributes: bp-based frame
.text:00007E9C
.text:00007E9C ; _DWORD __thiscall CArcErrorInfo::CArcErrorInfo(CArcErrorInfo *__hidden this)
.text:00007E9C                 public ??0CArcErrorInfo@@QAE@XZ
.text:00007E9C ??0CArcErrorInfo@@QAE@XZ proc near      ; CODE XREF: CArchiveLink::CArchiveLink(void)+7Fp
.text:00007E9C
.text:00007E9C var_10          = dword ptr -10h
.text:00007E9C var_C           = dword ptr -0Ch
.text:00007E9C var_4           = dword ptr -4
.text:00007E9C
.text:00007E9C                 push    ebp
.text:00007E9D                 mov     ebp, esp
.text:00007E9F                 push    0FFFFFFFFh
.text:00007EA1                 push    offset __ehhandler$??0CArcErrorInfo@@QAE@XZ
.text:00007EA6                 mov     eax, large fs:0
.text:00007EAC                 push    eax
.text:00007EAD                 push    ecx
.text:00007EAE                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00007EB5                 mov     eax, dword ptr ds:___security_cookie
.text:00007EBA                 xor     eax, ebp
.text:00007EBC                 push    eax
.text:00007EBD                 lea     eax, [ebp+var_C]
.text:00007EC0                 mov     large fs:0, eax
.text:00007EC6                 mov     [ebp+var_10], ecx
.text:00007EC9                 mov     eax, [ebp+var_10]
.text:00007ECC                 mov     byte ptr [eax], 0
.text:00007ECF                 mov     ecx, [ebp+var_10]
.text:00007ED2                 mov     byte ptr [ecx+1], 0
.text:00007ED6                 mov     edx, [ebp+var_10]
.text:00007ED9                 mov     byte ptr [edx+2], 0
.text:00007EDD                 mov     eax, [ebp+var_10]
.text:00007EE0                 mov     byte ptr [eax+3], 0
.text:00007EE4                 mov     ecx, [ebp+var_10]
.text:00007EE7                 mov     dword ptr [ecx+4], 0
.text:00007EEE                 mov     edx, [ebp+var_10]
.text:00007EF1                 mov     dword ptr [edx+8], 0
.text:00007EF8                 mov     eax, [ebp+var_10]
.text:00007EFB                 mov     dword ptr [eax+0Ch], 0FFFFFFFFh
.text:00007F02                 mov     ecx, [ebp+var_10]
.text:00007F05                 mov     dword ptr [ecx+10h], 0
.text:00007F0C                 mov     dword ptr [ecx+14h], 0
.text:00007F13                 mov     ecx, [ebp+var_10]
.text:00007F16                 add     ecx, 18h
.text:00007F19                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00007F1E                 mov     [ebp+var_4], 0
.text:00007F25                 mov     ecx, [ebp+var_10]
.text:00007F28                 add     ecx, 24h ; '$'
.text:00007F2B                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00007F30                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00007F37                 mov     eax, [ebp+var_10]
.text:00007F3A                 mov     ecx, [ebp+var_C]
.text:00007F3D                 mov     large fs:0, ecx
.text:00007F44                 pop     ecx
.text:00007F45                 add     esp, 10h
.text:00007F48                 cmp     ebp, esp
.text:00007F4A                 call    __RTC_CheckEsp
.text:00007F4F                 mov     esp, ebp
.text:00007F51                 pop     ebp
.text:00007F52                 retn
.text:00007F52 ??0CArcErrorInfo@@QAE@XZ endp
.text:00007F52
.text:00007F52 ; ---------------------------------------------------------------------------
.text:00007F53                 align 4
.text:00007F53 _text           ends
.text:00007F53
.text$x:00007F54 ; ===========================================================================
.text$x:00007F54
.text$x:00007F54 ; Segment type: Pure code
.text$x:00007F54 ; Segment permissions: Read/Execute
.text$x:00007F54 _text$x         segment para public 'CODE' use32
.text$x:00007F54                 assume cs:_text$x
.text$x:00007F54                 ;org 7F54h
.text$x:00007F54 ; COMDAT (pick associative to section at 7E9C)
.text$x:00007F54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007F54
.text$x:00007F54 ; =============== S U B R O U T I N E =======================================
.text$x:00007F54
.text$x:00007F54
.text$x:00007F54 __unwindfunclet$??0CArcErrorInfo@@QAE@XZ$0 proc near
.text$x:00007F54                                         ; DATA XREF: .xdata$x:00007F80o
.text$x:00007F54                 mov     ecx, [ebp-10h]
.text$x:00007F57                 add     ecx, 18h        ; this
.text$x:00007F5A                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00007F5A __unwindfunclet$??0CArcErrorInfo@@QAE@XZ$0 endp
.text$x:00007F5A
.text$x:00007F5F
.text$x:00007F5F ; =============== S U B R O U T I N E =======================================
.text$x:00007F5F
.text$x:00007F5F
.text$x:00007F5F __ehhandler$??0CArcErrorInfo@@QAE@XZ proc near
.text$x:00007F5F                                         ; DATA XREF: CArcErrorInfo::CArcErrorInfo(void)+5o
.text$x:00007F5F
.text$x:00007F5F arg_4           = dword ptr  8
.text$x:00007F5F
.text$x:00007F5F                 mov     edx, [esp+arg_4]
.text$x:00007F63                 lea     eax, [edx+0Ch]
.text$x:00007F66                 mov     ecx, [edx-8]
.text$x:00007F69                 xor     ecx, eax
.text$x:00007F6B                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007F70                 mov     eax, offset __ehfuncinfo$??0CArcErrorInfo@@QAE@XZ
.text$x:00007F75                 jmp     ___CxxFrameHandler3
.text$x:00007F75 __ehhandler$??0CArcErrorInfo@@QAE@XZ endp
.text$x:00007F75
.text$x:00007F75 ; ---------------------------------------------------------------------------
.text$x:00007F7A                 align 4
.text$x:00007F7A _text$x         ends
.text$x:00007F7A
.xdata$x:00007F7C ; ===========================================================================
.xdata$x:00007F7C
.xdata$x:00007F7C ; Segment type: Pure data
.xdata$x:00007F7C ; Segment permissions: Read
.xdata$x:00007F7C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007F7C                 assume cs:_xdata$x
.xdata$x:00007F7C                 ;org 7F7Ch
.xdata$x:00007F7C ; COMDAT (pick associative to section at 7E9C)
.xdata$x:00007F7C __unwindtable$??0CArcErrorInfo@@QAE@XZ db 0FFh
.xdata$x:00007F7C                                         ; DATA XREF: .xdata$x:00007F8Co
.xdata$x:00007F7D                 db 0FFh
.xdata$x:00007F7E                 db 0FFh
.xdata$x:00007F7F                 db 0FFh
.xdata$x:00007F80                 dd offset __unwindfunclet$??0CArcErrorInfo@@QAE@XZ$0
.xdata$x:00007F84 __ehfuncinfo$??0CArcErrorInfo@@QAE@XZ db  22h ; "
.xdata$x:00007F84                                         ; DATA XREF: __ehhandler$??0CArcErrorInfo@@QAE@XZ+11o
.xdata$x:00007F85                 db    5
.xdata$x:00007F86                 db  93h ; 
.xdata$x:00007F87                 db  19h
.xdata$x:00007F88                 db    1
.xdata$x:00007F89                 db    0
.xdata$x:00007F8A                 db    0
.xdata$x:00007F8B                 db    0
.xdata$x:00007F8C                 dd offset __unwindtable$??0CArcErrorInfo@@QAE@XZ
.xdata$x:00007F90                 db    0
.xdata$x:00007F91                 db    0
.xdata$x:00007F92                 db    0
.xdata$x:00007F93                 db    0
.xdata$x:00007F94                 db    0
.xdata$x:00007F95                 db    0
.xdata$x:00007F96                 db    0
.xdata$x:00007F97                 db    0
.xdata$x:00007F98                 db    0
.xdata$x:00007F99                 db    0
.xdata$x:00007F9A                 db    0
.xdata$x:00007F9B                 db    0
.xdata$x:00007F9C                 db    0
.xdata$x:00007F9D                 db    0
.xdata$x:00007F9E                 db    0
.xdata$x:00007F9F                 db    0
.xdata$x:00007FA0                 db    0
.xdata$x:00007FA1                 db    0
.xdata$x:00007FA2                 db    0
.xdata$x:00007FA3                 db    0
.xdata$x:00007FA4                 db    1
.xdata$x:00007FA5                 db    0
.xdata$x:00007FA6                 db    0
.xdata$x:00007FA7                 db    0
.xdata$x:00007FA7 _xdata$x        ends
.xdata$x:00007FA7
.text:00007FA8 ; ===========================================================================
.text:00007FA8
.text:00007FA8 ; Segment type: Pure code
.text:00007FA8 ; Segment permissions: Read/Execute
.text:00007FA8 _text           segment para public 'CODE' use32
.text:00007FA8                 assume cs:_text
.text:00007FA8                 ;org 7FA8h
.text:00007FA8 ; COMDAT (pick any)
.text:00007FA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00007FA8
.text:00007FA8 ; =============== S U B R O U T I N E =======================================
.text:00007FA8
.text:00007FA8 ; Attributes: bp-based frame
.text:00007FA8
.text:00007FA8 ; _DWORD __thiscall CArchiveLink::~CArchiveLink(CArchiveLink *__hidden this)
.text:00007FA8                 public ??1CArchiveLink@@QAE@XZ
.text:00007FA8 ??1CArchiveLink@@QAE@XZ proc near       ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+363p
.text:00007FA8                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+46Ap ...
.text:00007FA8
.text:00007FA8 var_10          = dword ptr -10h
.text:00007FA8 var_C           = dword ptr -0Ch
.text:00007FA8 var_4           = dword ptr -4
.text:00007FA8
.text:00007FA8                 push    ebp
.text:00007FA9                 mov     ebp, esp
.text:00007FAB                 push    0FFFFFFFFh
.text:00007FAD                 push    offset __ehhandler$??1CArchiveLink@@QAE@XZ
.text:00007FB2                 mov     eax, large fs:0
.text:00007FB8                 push    eax
.text:00007FB9                 push    ecx
.text:00007FBA                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00007FC1                 mov     eax, dword ptr ds:___security_cookie
.text:00007FC6                 xor     eax, ebp
.text:00007FC8                 push    eax
.text:00007FC9                 lea     eax, [ebp+var_C]
.text:00007FCC                 mov     large fs:0, eax
.text:00007FD2                 mov     [ebp+var_10], ecx
.text:00007FD5                 mov     [ebp+var_4], 3
.text:00007FDC                 mov     ecx, [ebp+var_10] ; this
.text:00007FDF                 call    ?Release@CArchiveLink@@QAEXXZ ; CArchiveLink::Release(void)
.text:00007FE4                 mov     byte ptr [ebp+var_4], 2
.text:00007FE8                 mov     ecx, [ebp+var_10]
.text:00007FEB                 add     ecx, 30h ; '0'  ; this
.text:00007FEE                 call    ??1CArcErrorInfo@@QAE@XZ ; CArcErrorInfo::~CArcErrorInfo(void)
.text:00007FF3                 mov     byte ptr [ebp+var_4], 1
.text:00007FF7                 mov     ecx, [ebp+var_10]
.text:00007FFA                 add     ecx, 24h ; '$'  ; this
.text:00007FFD                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00008002                 mov     byte ptr [ebp+var_4], 0
.text:00008006                 mov     ecx, [ebp+var_10]
.text:00008009                 add     ecx, 0Ch
.text:0000800C                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:00008011                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00008018                 mov     ecx, [ebp+var_10]
.text:0000801B                 call    ??1?$CObjectVector@VCArc@@@@QAE@XZ ; CObjectVector<CArc>::~CObjectVector<CArc>(void)
.text:00008020                 mov     ecx, [ebp+var_C]
.text:00008023                 mov     large fs:0, ecx
.text:0000802A                 pop     ecx
.text:0000802B                 add     esp, 10h
.text:0000802E                 cmp     ebp, esp
.text:00008030                 call    __RTC_CheckEsp
.text:00008035                 mov     esp, ebp
.text:00008037                 pop     ebp
.text:00008038                 retn
.text:00008038 ??1CArchiveLink@@QAE@XZ endp
.text:00008038
.text:00008038 ; ---------------------------------------------------------------------------
.text:00008039                 align 4
.text:00008039 _text           ends
.text:00008039
.text$x:0000803C ; ===========================================================================
.text$x:0000803C
.text$x:0000803C ; Segment type: Pure code
.text$x:0000803C ; Segment permissions: Read/Execute
.text$x:0000803C _text$x         segment para public 'CODE' use32
.text$x:0000803C                 assume cs:_text$x
.text$x:0000803C                 ;org 803Ch
.text$x:0000803C ; COMDAT (pick associative to section at 7FA8)
.text$x:0000803C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000803C
.text$x:0000803C ; =============== S U B R O U T I N E =======================================
.text$x:0000803C
.text$x:0000803C
.text$x:0000803C __unwindfunclet$??1CArchiveLink@@QAE@XZ$0 proc near
.text$x:0000803C                                         ; DATA XREF: .xdata$x:00008084o
.text$x:0000803C                 mov     ecx, [ebp-10h]
.text$x:0000803F                 jmp     ??1?$CObjectVector@VCArc@@@@QAE@XZ ; CObjectVector<CArc>::~CObjectVector<CArc>(void)
.text$x:0000803F __unwindfunclet$??1CArchiveLink@@QAE@XZ$0 endp
.text$x:0000803F
.text$x:00008044
.text$x:00008044 ; =============== S U B R O U T I N E =======================================
.text$x:00008044
.text$x:00008044
.text$x:00008044 __unwindfunclet$??1CArchiveLink@@QAE@XZ$1 proc near
.text$x:00008044                                         ; DATA XREF: .xdata$x:0000808Co
.text$x:00008044                 mov     ecx, [ebp-10h]
.text$x:00008047                 add     ecx, 0Ch
.text$x:0000804A                 jmp     ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text$x:0000804A __unwindfunclet$??1CArchiveLink@@QAE@XZ$1 endp
.text$x:0000804A
.text$x:0000804F
.text$x:0000804F ; =============== S U B R O U T I N E =======================================
.text$x:0000804F
.text$x:0000804F
.text$x:0000804F __unwindfunclet$??1CArchiveLink@@QAE@XZ$2 proc near
.text$x:0000804F                                         ; DATA XREF: .xdata$x:00008094o
.text$x:0000804F                 mov     ecx, [ebp-10h]
.text$x:00008052                 add     ecx, 24h ; '$'  ; this
.text$x:00008055                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00008055 __unwindfunclet$??1CArchiveLink@@QAE@XZ$2 endp
.text$x:00008055
.text$x:0000805A
.text$x:0000805A ; =============== S U B R O U T I N E =======================================
.text$x:0000805A
.text$x:0000805A
.text$x:0000805A __unwindfunclet$??1CArchiveLink@@QAE@XZ$3 proc near
.text$x:0000805A                                         ; DATA XREF: .xdata$x:0000809Co
.text$x:0000805A                 mov     ecx, [ebp-10h]
.text$x:0000805D                 add     ecx, 30h ; '0'  ; this
.text$x:00008060                 jmp     ??1CArcErrorInfo@@QAE@XZ ; CArcErrorInfo::~CArcErrorInfo(void)
.text$x:00008060 __unwindfunclet$??1CArchiveLink@@QAE@XZ$3 endp
.text$x:00008060
.text$x:00008065
.text$x:00008065 ; =============== S U B R O U T I N E =======================================
.text$x:00008065
.text$x:00008065
.text$x:00008065 __ehhandler$??1CArchiveLink@@QAE@XZ proc near
.text$x:00008065                                         ; DATA XREF: CArchiveLink::~CArchiveLink(void)+5o
.text$x:00008065
.text$x:00008065 arg_4           = dword ptr  8
.text$x:00008065
.text$x:00008065                 mov     edx, [esp+arg_4]
.text$x:00008069                 lea     eax, [edx+0Ch]
.text$x:0000806C                 mov     ecx, [edx-8]
.text$x:0000806F                 xor     ecx, eax
.text$x:00008071                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008076                 mov     eax, offset __ehfuncinfo$??1CArchiveLink@@QAE@XZ
.text$x:0000807B                 jmp     ___CxxFrameHandler3
.text$x:0000807B __ehhandler$??1CArchiveLink@@QAE@XZ endp
.text$x:0000807B
.text$x:0000807B _text$x         ends
.text$x:0000807B
.xdata$x:00008080 ; ===========================================================================
.xdata$x:00008080
.xdata$x:00008080 ; Segment type: Pure data
.xdata$x:00008080 ; Segment permissions: Read
.xdata$x:00008080 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008080                 assume cs:_xdata$x
.xdata$x:00008080                 ;org 8080h
.xdata$x:00008080 ; COMDAT (pick associative to section at 7FA8)
.xdata$x:00008080 __unwindtable$??1CArchiveLink@@QAE@XZ db 0FFh
.xdata$x:00008080                                         ; DATA XREF: .xdata$x:000080A8o
.xdata$x:00008081                 db 0FFh
.xdata$x:00008082                 db 0FFh
.xdata$x:00008083                 db 0FFh
.xdata$x:00008084                 dd offset __unwindfunclet$??1CArchiveLink@@QAE@XZ$0
.xdata$x:00008088                 db    0
.xdata$x:00008089                 db    0
.xdata$x:0000808A                 db    0
.xdata$x:0000808B                 db    0
.xdata$x:0000808C                 dd offset __unwindfunclet$??1CArchiveLink@@QAE@XZ$1
.xdata$x:00008090                 db    1
.xdata$x:00008091                 db    0
.xdata$x:00008092                 db    0
.xdata$x:00008093                 db    0
.xdata$x:00008094                 dd offset __unwindfunclet$??1CArchiveLink@@QAE@XZ$2
.xdata$x:00008098                 db    2
.xdata$x:00008099                 db    0
.xdata$x:0000809A                 db    0
.xdata$x:0000809B                 db    0
.xdata$x:0000809C                 dd offset __unwindfunclet$??1CArchiveLink@@QAE@XZ$3
.xdata$x:000080A0 __ehfuncinfo$??1CArchiveLink@@QAE@XZ db  22h ; "
.xdata$x:000080A0                                         ; DATA XREF: __ehhandler$??1CArchiveLink@@QAE@XZ+11o
.xdata$x:000080A1                 db    5
.xdata$x:000080A2                 db  93h ; 
.xdata$x:000080A3                 db  19h
.xdata$x:000080A4                 db    4
.xdata$x:000080A5                 db    0
.xdata$x:000080A6                 db    0
.xdata$x:000080A7                 db    0
.xdata$x:000080A8                 dd offset __unwindtable$??1CArchiveLink@@QAE@XZ
.xdata$x:000080AC                 align 20h
.xdata$x:000080C0                 db    1
.xdata$x:000080C1                 db    0
.xdata$x:000080C2                 db    0
.xdata$x:000080C3                 db    0
.xdata$x:000080C3 _xdata$x        ends
.xdata$x:000080C3
.text:000080C4 ; ===========================================================================
.text:000080C4
.text:000080C4 ; Segment type: Pure code
.text:000080C4 ; Segment permissions: Read/Execute
.text:000080C4 _text           segment para public 'CODE' use32
.text:000080C4                 assume cs:_text
.text:000080C4                 ;org 80C4h
.text:000080C4 ; COMDAT (pick any)
.text:000080C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000080C4
.text:000080C4 ; =============== S U B R O U T I N E =======================================
.text:000080C4
.text:000080C4 ; Attributes: bp-based frame
.text:000080C4
.text:000080C4 ; _DWORD __thiscall CArcErrorInfo::~CArcErrorInfo(CArcErrorInfo *__hidden this)
.text:000080C4                 public ??1CArcErrorInfo@@QAE@XZ
.text:000080C4 ??1CArcErrorInfo@@QAE@XZ proc near      ; CODE XREF: CArchiveLink::~CArchiveLink(void)+46p
.text:000080C4                                         ; __unwindfunclet$??1CArchiveLink@@QAE@XZ$3+6j ...
.text:000080C4
.text:000080C4 var_10          = dword ptr -10h
.text:000080C4 var_C           = dword ptr -0Ch
.text:000080C4 var_4           = dword ptr -4
.text:000080C4
.text:000080C4                 push    ebp
.text:000080C5                 mov     ebp, esp
.text:000080C7                 push    0FFFFFFFFh
.text:000080C9                 push    offset __ehhandler$??1CArcErrorInfo@@QAE@XZ
.text:000080CE                 mov     eax, large fs:0
.text:000080D4                 push    eax
.text:000080D5                 push    ecx
.text:000080D6                 mov     [ebp+var_10], 0CCCCCCCCh
.text:000080DD                 mov     eax, dword ptr ds:___security_cookie
.text:000080E2                 xor     eax, ebp
.text:000080E4                 push    eax
.text:000080E5                 lea     eax, [ebp+var_C]
.text:000080E8                 mov     large fs:0, eax
.text:000080EE                 mov     [ebp+var_10], ecx
.text:000080F1                 mov     [ebp+var_4], 0
.text:000080F8                 mov     ecx, [ebp+var_10]
.text:000080FB                 add     ecx, 24h ; '$'  ; this
.text:000080FE                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00008103                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000810A                 mov     ecx, [ebp+var_10]
.text:0000810D                 add     ecx, 18h        ; this
.text:00008110                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00008115                 mov     ecx, [ebp+var_C]
.text:00008118                 mov     large fs:0, ecx
.text:0000811F                 pop     ecx
.text:00008120                 add     esp, 10h
.text:00008123                 cmp     ebp, esp
.text:00008125                 call    __RTC_CheckEsp
.text:0000812A                 mov     esp, ebp
.text:0000812C                 pop     ebp
.text:0000812D                 retn
.text:0000812D ??1CArcErrorInfo@@QAE@XZ endp
.text:0000812D
.text:0000812D ; ---------------------------------------------------------------------------
.text:0000812E                 align 10h
.text:0000812E _text           ends
.text:0000812E
.text$x:00008130 ; ===========================================================================
.text$x:00008130
.text$x:00008130 ; Segment type: Pure code
.text$x:00008130 ; Segment permissions: Read/Execute
.text$x:00008130 _text$x         segment para public 'CODE' use32
.text$x:00008130                 assume cs:_text$x
.text$x:00008130                 ;org 8130h
.text$x:00008130 ; COMDAT (pick associative to section at 80C4)
.text$x:00008130                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00008130
.text$x:00008130 ; =============== S U B R O U T I N E =======================================
.text$x:00008130
.text$x:00008130
.text$x:00008130 __unwindfunclet$??1CArcErrorInfo@@QAE@XZ$0 proc near
.text$x:00008130                                         ; DATA XREF: .xdata$x:0000815Co
.text$x:00008130                 mov     ecx, [ebp-10h]
.text$x:00008133                 add     ecx, 18h        ; this
.text$x:00008136                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00008136 __unwindfunclet$??1CArcErrorInfo@@QAE@XZ$0 endp
.text$x:00008136
.text$x:0000813B
.text$x:0000813B ; =============== S U B R O U T I N E =======================================
.text$x:0000813B
.text$x:0000813B
.text$x:0000813B __ehhandler$??1CArcErrorInfo@@QAE@XZ proc near
.text$x:0000813B                                         ; DATA XREF: CArcErrorInfo::~CArcErrorInfo(void)+5o
.text$x:0000813B
.text$x:0000813B arg_4           = dword ptr  8
.text$x:0000813B
.text$x:0000813B                 mov     edx, [esp+arg_4]
.text$x:0000813F                 lea     eax, [edx+0Ch]
.text$x:00008142                 mov     ecx, [edx-8]
.text$x:00008145                 xor     ecx, eax
.text$x:00008147                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000814C                 mov     eax, offset __ehfuncinfo$??1CArcErrorInfo@@QAE@XZ
.text$x:00008151                 jmp     ___CxxFrameHandler3
.text$x:00008151 __ehhandler$??1CArcErrorInfo@@QAE@XZ endp
.text$x:00008151
.text$x:00008151 ; ---------------------------------------------------------------------------
.text$x:00008156                 align 4
.text$x:00008156 _text$x         ends
.text$x:00008156
.xdata$x:00008158 ; ===========================================================================
.xdata$x:00008158
.xdata$x:00008158 ; Segment type: Pure data
.xdata$x:00008158 ; Segment permissions: Read
.xdata$x:00008158 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008158                 assume cs:_xdata$x
.xdata$x:00008158                 ;org 8158h
.xdata$x:00008158 ; COMDAT (pick associative to section at 80C4)
.xdata$x:00008158 __unwindtable$??1CArcErrorInfo@@QAE@XZ db 0FFh
.xdata$x:00008158                                         ; DATA XREF: .xdata$x:00008168o
.xdata$x:00008159                 db 0FFh
.xdata$x:0000815A                 db 0FFh
.xdata$x:0000815B                 db 0FFh
.xdata$x:0000815C                 dd offset __unwindfunclet$??1CArcErrorInfo@@QAE@XZ$0
.xdata$x:00008160 __ehfuncinfo$??1CArcErrorInfo@@QAE@XZ db  22h ; "
.xdata$x:00008160                                         ; DATA XREF: __ehhandler$??1CArcErrorInfo@@QAE@XZ+11o
.xdata$x:00008161                 db    5
.xdata$x:00008162                 db  93h ; 
.xdata$x:00008163                 db  19h
.xdata$x:00008164                 db    1
.xdata$x:00008165                 db    0
.xdata$x:00008166                 db    0
.xdata$x:00008167                 db    0
.xdata$x:00008168                 dd offset __unwindtable$??1CArcErrorInfo@@QAE@XZ
.xdata$x:0000816C                 align 20h
.xdata$x:00008180                 db    1
.xdata$x:00008181                 db    0
.xdata$x:00008182                 db    0
.xdata$x:00008183                 db    0
.xdata$x:00008183 _xdata$x        ends
.xdata$x:00008183
.text:00008184 ; ===========================================================================
.text:00008184
.text:00008184 ; Segment type: Pure code
.text:00008184 ; Segment permissions: Read/Execute
.text:00008184 _text           segment para public 'CODE' use32
.text:00008184                 assume cs:_text
.text:00008184                 ;org 8184h
.text:00008184 ; COMDAT (pick any)
.text:00008184                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008184
.text:00008184 ; =============== S U B R O U T I N E =======================================
.text:00008184
.text:00008184 ; Attributes: bp-based frame
.text:00008184
.text:00008184 ; const struct CArc *__thiscall CArchiveLink::GetArc(CArchiveLink *__hidden this)
.text:00008184                 public ?GetArc@CArchiveLink@@QBEPBVCArc@@XZ
.text:00008184 ?GetArc@CArchiveLink@@QBEPBVCArc@@XZ proc near
.text:00008184                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+A2Ap
.text:00008184                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1543p
.text:00008184
.text:00008184 var_4           = dword ptr -4
.text:00008184
.text:00008184                 push    ebp
.text:00008185                 mov     ebp, esp
.text:00008187                 push    ecx
.text:00008188                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000818F                 mov     [ebp+var_4], ecx
.text:00008192                 mov     ecx, [ebp+var_4]
.text:00008195                 call    ?Back@?$CObjectVector@VCArc@@@@QBEABVCArc@@XZ ; CObjectVector<CArc>::Back(void)
.text:0000819A                 add     esp, 4
.text:0000819D                 cmp     ebp, esp
.text:0000819F                 call    __RTC_CheckEsp
.text:000081A4                 mov     esp, ebp
.text:000081A6                 pop     ebp
.text:000081A7                 retn
.text:000081A7 ?GetArc@CArchiveLink@@QBEPBVCArc@@XZ endp
.text:000081A7
.text:000081A7 _text           ends
.text:000081A7
.text:000081A8 ; ===========================================================================
.text:000081A8
.text:000081A8 ; Segment type: Pure code
.text:000081A8 ; Segment permissions: Read/Execute
.text:000081A8 _text           segment para public 'CODE' use32
.text:000081A8                 assume cs:_text
.text:000081A8                 ;org 81A8h
.text:000081A8 ; COMDAT (pick any)
.text:000081A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000081A8
.text:000081A8 ; =============== S U B R O U T I N E =======================================
.text:000081A8
.text:000081A8 ; Attributes: bp-based frame
.text:000081A8
.text:000081A8 ; bool __thiscall NUpdateArchive::CActionSet::NeedScanning(NUpdateArchive::CActionSet *__hidden this)
.text:000081A8                 public ?NeedScanning@CActionSet@NUpdateArchive@@QBE_NXZ
.text:000081A8 ?NeedScanning@CActionSet@NUpdateArchive@@QBE_NXZ proc near
.text:000081A8                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+D33p
.text:000081A8
.text:000081A8 var_8           = dword ptr -8
.text:000081A8 var_4           = dword ptr -4
.text:000081A8
.text:000081A8                 push    ebp
.text:000081A9                 mov     ebp, esp
.text:000081AB                 sub     esp, 8
.text:000081AE                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000081B5                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000081BC                 mov     [ebp+var_4], ecx
.text:000081BF                 mov     [ebp+var_8], 0
.text:000081C6                 jmp     short loc_81D1
.text:000081C8 ; ---------------------------------------------------------------------------
.text:000081C8
.text:000081C8 loc_81C8:                               ; CODE XREF: NUpdateArchive::CActionSet::NeedScanning(void):loc_81E7j
.text:000081C8                 mov     eax, [ebp+var_8]
.text:000081CB                 add     eax, 1
.text:000081CE                 mov     [ebp+var_8], eax
.text:000081D1
.text:000081D1 loc_81D1:                               ; CODE XREF: NUpdateArchive::CActionSet::NeedScanning(void)+1Ej
.text:000081D1                 cmp     [ebp+var_8], 7
.text:000081D5                 jnb     short loc_81E9
.text:000081D7                 mov     ecx, [ebp+var_8]
.text:000081DA                 mov     edx, [ebp+var_4]
.text:000081DD                 cmp     dword ptr [edx+ecx*4], 2
.text:000081E1                 jnz     short loc_81E7
.text:000081E3                 mov     al, 1
.text:000081E5                 jmp     short loc_8215
.text:000081E7 ; ---------------------------------------------------------------------------
.text:000081E7
.text:000081E7 loc_81E7:                               ; CODE XREF: NUpdateArchive::CActionSet::NeedScanning(void)+39j
.text:000081E7                 jmp     short loc_81C8
.text:000081E9 ; ---------------------------------------------------------------------------
.text:000081E9
.text:000081E9 loc_81E9:                               ; CODE XREF: NUpdateArchive::CActionSet::NeedScanning(void)+2Dj
.text:000081E9                 mov     [ebp+var_8], 1
.text:000081F0                 jmp     short loc_81FB
.text:000081F2 ; ---------------------------------------------------------------------------
.text:000081F2
.text:000081F2 loc_81F2:                               ; CODE XREF: NUpdateArchive::CActionSet::NeedScanning(void):loc_8211j
.text:000081F2                 mov     eax, [ebp+var_8]
.text:000081F5                 add     eax, 1
.text:000081F8                 mov     [ebp+var_8], eax
.text:000081FB
.text:000081FB loc_81FB:                               ; CODE XREF: NUpdateArchive::CActionSet::NeedScanning(void)+48j
.text:000081FB                 cmp     [ebp+var_8], 7
.text:000081FF                 jnb     short loc_8213
.text:00008201                 mov     ecx, [ebp+var_8]
.text:00008204                 mov     edx, [ebp+var_4]
.text:00008207                 cmp     dword ptr [edx+ecx*4], 0
.text:0000820B                 jz      short loc_8211
.text:0000820D                 mov     al, 1
.text:0000820F                 jmp     short loc_8215
.text:00008211 ; ---------------------------------------------------------------------------
.text:00008211
.text:00008211 loc_8211:                               ; CODE XREF: NUpdateArchive::CActionSet::NeedScanning(void)+63j
.text:00008211                 jmp     short loc_81F2
.text:00008213 ; ---------------------------------------------------------------------------
.text:00008213
.text:00008213 loc_8213:                               ; CODE XREF: NUpdateArchive::CActionSet::NeedScanning(void)+57j
.text:00008213                 xor     al, al
.text:00008215
.text:00008215 loc_8215:                               ; CODE XREF: NUpdateArchive::CActionSet::NeedScanning(void)+3Dj
.text:00008215                                         ; NUpdateArchive::CActionSet::NeedScanning(void)+67j
.text:00008215                 mov     esp, ebp
.text:00008217                 pop     ebp
.text:00008218                 retn
.text:00008218 ?NeedScanning@CActionSet@NUpdateArchive@@QBE_NXZ endp
.text:00008218
.text:00008218 ; ---------------------------------------------------------------------------
.text:00008219                 align 4
.text:00008219 _text           ends
.text:00008219
.text:0000821C ; ===========================================================================
.text:0000821C
.text:0000821C ; Segment type: Pure code
.text:0000821C ; Segment permissions: Read/Execute
.text:0000821C _text           segment para public 'CODE' use32
.text:0000821C                 assume cs:_text
.text:0000821C                 ;org 821Ch
.text:0000821C ; COMDAT (pick any)
.text:0000821C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000821C
.text:0000821C ; =============== S U B R O U T I N E =======================================
.text:0000821C
.text:0000821C ; Attributes: bp-based frame
.text:0000821C
.text:0000821C ; public: __thiscall CDirItem::CDirItem(void)
.text:0000821C                 public ??0CDirItem@@QAE@XZ
.text:0000821C ??0CDirItem@@QAE@XZ proc near           ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+C16p
.text:0000821C                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+C41p
.text:0000821C
.text:0000821C var_10          = dword ptr -10h
.text:0000821C var_C           = dword ptr -0Ch
.text:0000821C var_4           = dword ptr -4
.text:0000821C
.text:0000821C                 push    ebp
.text:0000821D                 mov     ebp, esp
.text:0000821F                 push    0FFFFFFFFh
.text:00008221                 push    offset __ehhandler$??0CDirItem@@QAE@XZ
.text:00008226                 mov     eax, large fs:0
.text:0000822C                 push    eax
.text:0000822D                 push    ecx
.text:0000822E                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00008235                 mov     eax, dword ptr ds:___security_cookie
.text:0000823A                 xor     eax, ebp
.text:0000823C                 push    eax
.text:0000823D                 lea     eax, [ebp+var_C]
.text:00008240                 mov     large fs:0, eax
.text:00008246                 mov     [ebp+var_10], ecx
.text:00008249                 mov     ecx, [ebp+var_10]
.text:0000824C                 add     ecx, 20h ; ' '
.text:0000824F                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00008254                 mov     [ebp+var_4], 0
.text:0000825B                 mov     ecx, [ebp+var_10]
.text:0000825E                 add     ecx, 2Ch ; ','
.text:00008261                 call    ??0?$CBuffer@E@@QAE@XZ ; CBuffer<uchar>::CBuffer<uchar>(void)
.text:00008266                 mov     byte ptr [ebp+var_4], 1
.text:0000826A                 mov     ecx, [ebp+var_10]
.text:0000826D                 add     ecx, 34h ; '4'
.text:00008270                 call    ??0?$CBuffer@E@@QAE@XZ ; CBuffer<uchar>::CBuffer<uchar>(void)
.text:00008275                 mov     eax, [ebp+var_10]
.text:00008278                 mov     dword ptr [eax+40h], 0FFFFFFFFh
.text:0000827F                 mov     ecx, [ebp+var_10]
.text:00008282                 mov     dword ptr [ecx+44h], 0FFFFFFFFh
.text:00008289                 mov     edx, [ebp+var_10]
.text:0000828C                 mov     dword ptr [edx+48h], 0FFFFFFFFh
.text:00008293                 mov     eax, [ebp+var_10]
.text:00008296                 mov     byte ptr [eax+4Ch], 0
.text:0000829A                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000082A1                 mov     eax, [ebp+var_10]
.text:000082A4                 mov     ecx, [ebp+var_C]
.text:000082A7                 mov     large fs:0, ecx
.text:000082AE                 pop     ecx
.text:000082AF                 add     esp, 10h
.text:000082B2                 cmp     ebp, esp
.text:000082B4                 call    __RTC_CheckEsp
.text:000082B9                 mov     esp, ebp
.text:000082BB                 pop     ebp
.text:000082BC                 retn
.text:000082BC ??0CDirItem@@QAE@XZ endp
.text:000082BC
.text:000082BC ; ---------------------------------------------------------------------------
.text:000082BD                 align 10h
.text:000082BD _text           ends
.text:000082BD
.text$x:000082C0 ; ===========================================================================
.text$x:000082C0
.text$x:000082C0 ; Segment type: Pure code
.text$x:000082C0 ; Segment permissions: Read/Execute
.text$x:000082C0 _text$x         segment para public 'CODE' use32
.text$x:000082C0                 assume cs:_text$x
.text$x:000082C0                 ;org 82C0h
.text$x:000082C0 ; COMDAT (pick associative to section at 821C)
.text$x:000082C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000082C0
.text$x:000082C0 ; =============== S U B R O U T I N E =======================================
.text$x:000082C0
.text$x:000082C0
.text$x:000082C0 __unwindfunclet$??0CDirItem@@QAE@XZ$0 proc near
.text$x:000082C0                                         ; DATA XREF: .xdata$x:000082F8o
.text$x:000082C0                 mov     ecx, [ebp-10h]
.text$x:000082C3                 add     ecx, 20h ; ' '  ; this
.text$x:000082C6                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000082C6 __unwindfunclet$??0CDirItem@@QAE@XZ$0 endp
.text$x:000082C6
.text$x:000082CB
.text$x:000082CB ; =============== S U B R O U T I N E =======================================
.text$x:000082CB
.text$x:000082CB
.text$x:000082CB __unwindfunclet$??0CDirItem@@QAE@XZ$1 proc near
.text$x:000082CB                                         ; DATA XREF: .xdata$x:00008300o
.text$x:000082CB                 mov     ecx, [ebp-10h]
.text$x:000082CE                 add     ecx, 2Ch ; ','
.text$x:000082D1                 jmp     ??1?$CBuffer@E@@QAE@XZ ; CBuffer<uchar>::~CBuffer<uchar>(void)
.text$x:000082D1 __unwindfunclet$??0CDirItem@@QAE@XZ$1 endp
.text$x:000082D1
.text$x:000082D6
.text$x:000082D6 ; =============== S U B R O U T I N E =======================================
.text$x:000082D6
.text$x:000082D6
.text$x:000082D6 __ehhandler$??0CDirItem@@QAE@XZ proc near
.text$x:000082D6                                         ; DATA XREF: CDirItem::CDirItem(void)+5o
.text$x:000082D6
.text$x:000082D6 arg_4           = dword ptr  8
.text$x:000082D6
.text$x:000082D6                 mov     edx, [esp+arg_4]
.text$x:000082DA                 lea     eax, [edx+0Ch]
.text$x:000082DD                 mov     ecx, [edx-8]
.text$x:000082E0                 xor     ecx, eax
.text$x:000082E2                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000082E7                 mov     eax, offset __ehfuncinfo$??0CDirItem@@QAE@XZ
.text$x:000082EC                 jmp     ___CxxFrameHandler3
.text$x:000082EC __ehhandler$??0CDirItem@@QAE@XZ endp
.text$x:000082EC
.text$x:000082EC ; ---------------------------------------------------------------------------
.text$x:000082F1                 align 4
.text$x:000082F1 _text$x         ends
.text$x:000082F1
.xdata$x:000082F4 ; ===========================================================================
.xdata$x:000082F4
.xdata$x:000082F4 ; Segment type: Pure data
.xdata$x:000082F4 ; Segment permissions: Read
.xdata$x:000082F4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000082F4                 assume cs:_xdata$x
.xdata$x:000082F4                 ;org 82F4h
.xdata$x:000082F4 ; COMDAT (pick associative to section at 821C)
.xdata$x:000082F4 __unwindtable$??0CDirItem@@QAE@XZ db 0FFh ; DATA XREF: .xdata$x:0000830Co
.xdata$x:000082F5                 db 0FFh
.xdata$x:000082F6                 db 0FFh
.xdata$x:000082F7                 db 0FFh
.xdata$x:000082F8                 dd offset __unwindfunclet$??0CDirItem@@QAE@XZ$0
.xdata$x:000082FC                 align 10h
.xdata$x:00008300                 dd offset __unwindfunclet$??0CDirItem@@QAE@XZ$1
.xdata$x:00008304 __ehfuncinfo$??0CDirItem@@QAE@XZ db  22h ; "
.xdata$x:00008304                                         ; DATA XREF: __ehhandler$??0CDirItem@@QAE@XZ+11o
.xdata$x:00008305                 db    5
.xdata$x:00008306                 db  93h ; 
.xdata$x:00008307                 db  19h
.xdata$x:00008308                 db    2
.xdata$x:00008309                 db    0
.xdata$x:0000830A                 db    0
.xdata$x:0000830B                 db    0
.xdata$x:0000830C                 dd offset __unwindtable$??0CDirItem@@QAE@XZ
.xdata$x:00008310                 db    0
.xdata$x:00008311                 db    0
.xdata$x:00008312                 db    0
.xdata$x:00008313                 db    0
.xdata$x:00008314                 db    0
.xdata$x:00008315                 db    0
.xdata$x:00008316                 db    0
.xdata$x:00008317                 db    0
.xdata$x:00008318                 db    0
.xdata$x:00008319                 db    0
.xdata$x:0000831A                 db    0
.xdata$x:0000831B                 db    0
.xdata$x:0000831C                 db    0
.xdata$x:0000831D                 db    0
.xdata$x:0000831E                 db    0
.xdata$x:0000831F                 db    0
.xdata$x:00008320                 db    0
.xdata$x:00008321                 db    0
.xdata$x:00008322                 db    0
.xdata$x:00008323                 db    0
.xdata$x:00008324                 db    1
.xdata$x:00008325                 db    0
.xdata$x:00008326                 db    0
.xdata$x:00008327                 db    0
.xdata$x:00008327 _xdata$x        ends
.xdata$x:00008327
.text:00008328 ; ===========================================================================
.text:00008328
.text:00008328 ; Segment type: Pure code
.text:00008328 ; Segment permissions: Read/Execute
.text:00008328 _text           segment para public 'CODE' use32
.text:00008328                 assume cs:_text
.text:00008328                 ;org 8328h
.text:00008328 ; COMDAT (pick any)
.text:00008328                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008328
.text:00008328 ; =============== S U B R O U T I N E =======================================
.text:00008328
.text:00008328 ; Attributes: bp-based frame
.text:00008328
.text:00008328 ; bool __thiscall CDirItem::IsDir(CDirItem *__hidden this)
.text:00008328                 public ?IsDir@CDirItem@@QBE_NXZ
.text:00008328 ?IsDir@CDirItem@@QBE_NXZ proc near      ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+2385p
.text:00008328
.text:00008328 var_4           = dword ptr -4
.text:00008328
.text:00008328                 push    ebp
.text:00008329                 mov     ebp, esp
.text:0000832B                 push    ecx
.text:0000832C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00008333                 mov     [ebp+var_4], ecx
.text:00008336                 mov     eax, [ebp+var_4]
.text:00008339                 mov     eax, [eax+3Ch]
.text:0000833C                 and     eax, 10h
.text:0000833F                 neg     eax
.text:00008341                 sbb     eax, eax
.text:00008343                 neg     eax
.text:00008345                 mov     esp, ebp
.text:00008347                 pop     ebp
.text:00008348                 retn
.text:00008348 ?IsDir@CDirItem@@QBE_NXZ endp
.text:00008348
.text:00008348 ; ---------------------------------------------------------------------------
.text:00008349                 align 4
.text:00008349 _text           ends
.text:00008349
.text:0000834C ; ===========================================================================
.text:0000834C
.text:0000834C ; Segment type: Pure code
.text:0000834C ; Segment permissions: Read/Execute
.text:0000834C _text           segment para public 'CODE' use32
.text:0000834C                 assume cs:_text
.text:0000834C                 ;org 834Ch
.text:0000834C ; COMDAT (pick any)
.text:0000834C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000834C
.text:0000834C ; =============== S U B R O U T I N E =======================================
.text:0000834C
.text:0000834C ; Attributes: bp-based frame
.text:0000834C
.text:0000834C ; _DWORD __thiscall CFinishArchiveStat::CFinishArchiveStat(CFinishArchiveStat *__hidden this)
.text:0000834C                 public ??0CFinishArchiveStat@@QAE@XZ
.text:0000834C ??0CFinishArchiveStat@@QAE@XZ proc near ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+173Cp
.text:0000834C
.text:0000834C var_4           = dword ptr -4
.text:0000834C
.text:0000834C                 push    ebp
.text:0000834D                 mov     ebp, esp
.text:0000834F                 push    ecx
.text:00008350                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00008357                 mov     [ebp+var_4], ecx
.text:0000835A                 mov     eax, [ebp+var_4]
.text:0000835D                 mov     dword ptr [eax], 0
.text:00008363                 mov     dword ptr [eax+4], 0
.text:0000836A                 mov     eax, [ebp+var_4]
.text:0000836D                 mov     esp, ebp
.text:0000836F                 pop     ebp
.text:00008370                 retn
.text:00008370 ??0CFinishArchiveStat@@QAE@XZ endp
.text:00008370
.text:00008370 ; ---------------------------------------------------------------------------
.text:00008371                 align 4
.text:00008371 _text           ends
.text:00008371
.text:00008374 ; ===========================================================================
.text:00008374
.text:00008374 ; Segment type: Pure code
.text:00008374 ; Segment permissions: Read/Execute
.text:00008374 _text           segment para public 'CODE' use32
.text:00008374                 assume cs:_text
.text:00008374                 ;org 8374h
.text:00008374 ; COMDAT (pick any)
.text:00008374                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008374
.text:00008374 ; =============== S U B R O U T I N E =======================================
.text:00008374
.text:00008374 ; Attributes: bp-based frame
.text:00008374
.text:00008374 ; class AString __stdcall GetAnsiString(class UString const &)
.text:00008374                 public ?GetAnsiString@@YG?AVAString@@ABVUString@@@Z
.text:00008374 ?GetAnsiString@@YG?AVAString@@ABVUString@@@Z proc near
.text:00008374                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+2156p
.text:00008374                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+216Dp ...
.text:00008374
.text:00008374 var_4           = dword ptr -4
.text:00008374 arg_0           = dword ptr  8
.text:00008374 arg_4           = dword ptr  0Ch
.text:00008374
.text:00008374                 push    ebp
.text:00008375                 mov     ebp, esp
.text:00008377                 push    ecx
.text:00008378                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000837F                 mov     [ebp+var_4], 0
.text:00008386                 push    0
.text:00008388                 mov     eax, [ebp+arg_4]
.text:0000838B                 push    eax
.text:0000838C                 mov     ecx, [ebp+arg_0]
.text:0000838F                 push    ecx
.text:00008390                 call    ?UnicodeStringToMultiByte@@YG?AVAString@@ABVUString@@I@Z ; UnicodeStringToMultiByte(UString const &,uint)
.text:00008395                 mov     edx, [ebp+var_4]
.text:00008398                 or      edx, 1
.text:0000839B                 mov     [ebp+var_4], edx
.text:0000839E                 mov     eax, [ebp+arg_0]
.text:000083A1                 add     esp, 4
.text:000083A4                 cmp     ebp, esp
.text:000083A6                 call    __RTC_CheckEsp
.text:000083AB                 mov     esp, ebp
.text:000083AD                 pop     ebp
.text:000083AE                 retn    8
.text:000083AE ?GetAnsiString@@YG?AVAString@@ABVUString@@@Z endp
.text:000083AE
.text:000083AE ; ---------------------------------------------------------------------------
.text:000083B1                 align 4
.text:000083B1 _text           ends
.text:000083B1
.text:000083B4 ; ===========================================================================
.text:000083B4
.text:000083B4 ; Segment type: Pure code
.text:000083B4 ; Segment permissions: Read/Execute
.text:000083B4 _text           segment para public 'CODE' use32
.text:000083B4                 assume cs:_text
.text:000083B4                 ;org 83B4h
.text:000083B4 ; COMDAT (pick any)
.text:000083B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000083B4
.text:000083B4 ; =============== S U B R O U T I N E =======================================
.text:000083B4
.text:000083B4 ; Attributes: bp-based frame
.text:000083B4
.text:000083B4 ; _DWORD __thiscall NWindows::NDLL::CLibrary::CLibrary(NWindows::NDLL::CLibrary *__hidden this)
.text:000083B4                 public ??0CLibrary@NDLL@NWindows@@QAE@XZ
.text:000083B4 ??0CLibrary@NDLL@NWindows@@QAE@XZ proc near
.text:000083B4                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1D45p
.text:000083B4
.text:000083B4 var_4           = dword ptr -4
.text:000083B4
.text:000083B4                 push    ebp
.text:000083B5                 mov     ebp, esp
.text:000083B7                 push    ecx
.text:000083B8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000083BF                 mov     [ebp+var_4], ecx
.text:000083C2                 mov     eax, [ebp+var_4]
.text:000083C5                 mov     dword ptr [eax], 0
.text:000083CB                 mov     eax, [ebp+var_4]
.text:000083CE                 mov     esp, ebp
.text:000083D0                 pop     ebp
.text:000083D1                 retn
.text:000083D1 ??0CLibrary@NDLL@NWindows@@QAE@XZ endp
.text:000083D1
.text:000083D1 ; ---------------------------------------------------------------------------
.text:000083D2                 align 4
.text:000083D2 _text           ends
.text:000083D2
.text:000083D4 ; ===========================================================================
.text:000083D4
.text:000083D4 ; Segment type: Pure code
.text:000083D4 ; Segment permissions: Read/Execute
.text:000083D4 _text           segment para public 'CODE' use32
.text:000083D4                 assume cs:_text
.text:000083D4                 ;org 83D4h
.text:000083D4 ; COMDAT (pick any)
.text:000083D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000083D4
.text:000083D4 ; =============== S U B R O U T I N E =======================================
.text:000083D4
.text:000083D4 ; Attributes: bp-based frame
.text:000083D4
.text:000083D4 ; _DWORD __thiscall NWindows::NDLL::CLibrary::~CLibrary(NWindows::NDLL::CLibrary *__hidden this)
.text:000083D4                 public ??1CLibrary@NDLL@NWindows@@QAE@XZ
.text:000083D4 ??1CLibrary@NDLL@NWindows@@QAE@XZ proc near
.text:000083D4                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1D8Ep
.text:000083D4                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1E70p ...
.text:000083D4
.text:000083D4 var_4           = dword ptr -4
.text:000083D4
.text:000083D4                 push    ebp
.text:000083D5                 mov     ebp, esp
.text:000083D7                 push    ecx
.text:000083D8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000083DF                 mov     [ebp+var_4], ecx
.text:000083E2                 mov     ecx, [ebp+var_4] ; this
.text:000083E5                 call    ?Free@CLibrary@NDLL@NWindows@@QAE_NXZ ; NWindows::NDLL::CLibrary::Free(void)
.text:000083EA                 add     esp, 4
.text:000083ED                 cmp     ebp, esp
.text:000083EF                 call    __RTC_CheckEsp
.text:000083F4                 mov     esp, ebp
.text:000083F6                 pop     ebp
.text:000083F7                 retn
.text:000083F7 ??1CLibrary@NDLL@NWindows@@QAE@XZ endp
.text:000083F7
.text:000083F7 _text           ends
.text:000083F7
.text:000083F8 ; ===========================================================================
.text:000083F8
.text:000083F8 ; Segment type: Pure code
.text:000083F8 ; Segment permissions: Read/Execute
.text:000083F8 _text           segment para public 'CODE' use32
.text:000083F8                 assume cs:_text
.text:000083F8                 ;org 83F8h
.text:000083F8 ; COMDAT (pick any)
.text:000083F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000083F8
.text:000083F8 ; =============== S U B R O U T I N E =======================================
.text:000083F8
.text:000083F8 ; Attributes: bp-based frame
.text:000083F8
.text:000083F8 ; int __stdcall NWindows::NDLL::CLibrary::GetProc(LPCSTR lpProcName)
.text:000083F8                 public ?GetProc@CLibrary@NDLL@NWindows@@QBEP6GHXZPBD@Z
.text:000083F8 ?GetProc@CLibrary@NDLL@NWindows@@QBEP6GHXZPBD@Z proc near
.text:000083F8                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1E33p
.text:000083F8
.text:000083F8 var_4           = dword ptr -4
.text:000083F8 lpProcName      = dword ptr  8
.text:000083F8
.text:000083F8                 push    ebp
.text:000083F9                 mov     ebp, esp
.text:000083FB                 push    ecx
.text:000083FC                 push    esi
.text:000083FD                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00008404                 mov     [ebp+var_4], ecx
.text:00008407                 mov     esi, esp
.text:00008409                 mov     eax, [ebp+lpProcName]
.text:0000840C                 push    eax             ; lpProcName
.text:0000840D                 mov     ecx, [ebp+var_4]
.text:00008410                 mov     edx, [ecx]
.text:00008412                 push    edx             ; hModule
.text:00008413                 call    dword ptr ds:__imp__GetProcAddress@8 ; GetProcAddress(x,x)
.text:00008419                 cmp     esi, esp
.text:0000841B                 call    __RTC_CheckEsp
.text:00008420                 pop     esi
.text:00008421                 add     esp, 4
.text:00008424                 cmp     ebp, esp
.text:00008426                 call    __RTC_CheckEsp
.text:0000842B                 mov     esp, ebp
.text:0000842D                 pop     ebp
.text:0000842E                 retn    4
.text:0000842E ?GetProc@CLibrary@NDLL@NWindows@@QBEP6GHXZPBD@Z endp
.text:0000842E
.text:0000842E ; ---------------------------------------------------------------------------
.text:00008431                 align 4
.text:00008431 _text           ends
.text:00008431
.text:00008434 ; ===========================================================================
.text:00008434
.text:00008434 ; Segment type: Pure code
.text:00008434 ; Segment permissions: Read/Execute
.text:00008434 _text           segment para public 'CODE' use32
.text:00008434                 assume cs:_text
.text:00008434                 ;org 8434h
.text:00008434 ; COMDAT (pick any)
.text:00008434                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008434
.text:00008434 ; =============== S U B R O U T I N E =======================================
.text:00008434
.text:00008434 ; Attributes: bp-based frame
.text:00008434
.text:00008434 ; _DWORD __thiscall NWindows::NFile::NDir::CTempDir::CTempDir(NWindows::NFile::NDir::CTempDir *__hidden this)
.text:00008434                 public ??0CTempDir@NDir@NFile@NWindows@@QAE@XZ
.text:00008434 ??0CTempDir@NDir@NFile@NWindows@@QAE@XZ proc near
.text:00008434                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+109Fp
.text:00008434
.text:00008434 var_4           = dword ptr -4
.text:00008434
.text:00008434                 push    ebp
.text:00008435                 mov     ebp, esp
.text:00008437                 push    ecx
.text:00008438                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000843F                 mov     [ebp+var_4], ecx
.text:00008442                 mov     eax, [ebp+var_4]
.text:00008445                 mov     byte ptr [eax], 0
.text:00008448                 mov     ecx, [ebp+var_4]
.text:0000844B                 add     ecx, 4
.text:0000844E                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00008453                 mov     eax, [ebp+var_4]
.text:00008456                 add     esp, 4
.text:00008459                 cmp     ebp, esp
.text:0000845B                 call    __RTC_CheckEsp
.text:00008460                 mov     esp, ebp
.text:00008462                 pop     ebp
.text:00008463                 retn
.text:00008463 ??0CTempDir@NDir@NFile@NWindows@@QAE@XZ endp
.text:00008463
.text:00008463 _text           ends
.text:00008463
.text:00008464 ; ===========================================================================
.text:00008464
.text:00008464 ; Segment type: Pure code
.text:00008464 ; Segment permissions: Read/Execute
.text:00008464 _text           segment para public 'CODE' use32
.text:00008464                 assume cs:_text
.text:00008464                 ;org 8464h
.text:00008464 ; COMDAT (pick any)
.text:00008464                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008464
.text:00008464 ; =============== S U B R O U T I N E =======================================
.text:00008464
.text:00008464 ; Attributes: bp-based frame
.text:00008464
.text:00008464 ; _DWORD __thiscall NWindows::NFile::NDir::CTempDir::~CTempDir(NWindows::NFile::NDir::CTempDir *__hidden this)
.text:00008464                 public ??1CTempDir@NDir@NFile@NWindows@@QAE@XZ
.text:00008464 ??1CTempDir@NDir@NFile@NWindows@@QAE@XZ proc near
.text:00008464                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+132Fp
.text:00008464                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1422p ...
.text:00008464
.text:00008464 var_10          = dword ptr -10h
.text:00008464 var_C           = dword ptr -0Ch
.text:00008464 var_4           = dword ptr -4
.text:00008464
.text:00008464                 push    ebp
.text:00008465                 mov     ebp, esp
.text:00008467                 push    0FFFFFFFFh
.text:00008469                 push    offset __ehhandler$??1CTempDir@NDir@NFile@NWindows@@QAE@XZ
.text:0000846E                 mov     eax, large fs:0
.text:00008474                 push    eax
.text:00008475                 push    ecx
.text:00008476                 mov     [ebp+var_10], 0CCCCCCCCh
.text:0000847D                 mov     eax, dword ptr ds:___security_cookie
.text:00008482                 xor     eax, ebp
.text:00008484                 push    eax
.text:00008485                 lea     eax, [ebp+var_C]
.text:00008488                 mov     large fs:0, eax
.text:0000848E                 mov     [ebp+var_10], ecx
.text:00008491                 mov     [ebp+var_4], 0
.text:00008498                 mov     ecx, [ebp+var_10] ; this
.text:0000849B                 call    ?Remove@CTempDir@NDir@NFile@NWindows@@QAE_NXZ ; NWindows::NFile::NDir::CTempDir::Remove(void)
.text:000084A0                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000084A7                 mov     ecx, [ebp+var_10]
.text:000084AA                 add     ecx, 4          ; this
.text:000084AD                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000084B2                 mov     ecx, [ebp+var_C]
.text:000084B5                 mov     large fs:0, ecx
.text:000084BC                 pop     ecx
.text:000084BD                 add     esp, 10h
.text:000084C0                 cmp     ebp, esp
.text:000084C2                 call    __RTC_CheckEsp
.text:000084C7                 mov     esp, ebp
.text:000084C9                 pop     ebp
.text:000084CA                 retn
.text:000084CA ??1CTempDir@NDir@NFile@NWindows@@QAE@XZ endp
.text:000084CA
.text:000084CA ; ---------------------------------------------------------------------------
.text:000084CB                 align 4
.text:000084CB _text           ends
.text:000084CB
.text$x:000084CC ; ===========================================================================
.text$x:000084CC
.text$x:000084CC ; Segment type: Pure code
.text$x:000084CC ; Segment permissions: Read/Execute
.text$x:000084CC _text$x         segment para public 'CODE' use32
.text$x:000084CC                 assume cs:_text$x
.text$x:000084CC                 ;org 84CCh
.text$x:000084CC ; COMDAT (pick associative to section at 8464)
.text$x:000084CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000084CC
.text$x:000084CC ; =============== S U B R O U T I N E =======================================
.text$x:000084CC
.text$x:000084CC
.text$x:000084CC __unwindfunclet$??1CTempDir@NDir@NFile@NWindows@@QAE@XZ$0 proc near
.text$x:000084CC                                         ; DATA XREF: .xdata$x:000084F8o
.text$x:000084CC                 mov     ecx, [ebp-10h]
.text$x:000084CF                 add     ecx, 4          ; this
.text$x:000084D2                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000084D2 __unwindfunclet$??1CTempDir@NDir@NFile@NWindows@@QAE@XZ$0 endp
.text$x:000084D2
.text$x:000084D7
.text$x:000084D7 ; =============== S U B R O U T I N E =======================================
.text$x:000084D7
.text$x:000084D7
.text$x:000084D7 __ehhandler$??1CTempDir@NDir@NFile@NWindows@@QAE@XZ proc near
.text$x:000084D7                                         ; DATA XREF: NWindows::NFile::NDir::CTempDir::~CTempDir(void)+5o
.text$x:000084D7
.text$x:000084D7 arg_4           = dword ptr  8
.text$x:000084D7
.text$x:000084D7                 mov     edx, [esp+arg_4]
.text$x:000084DB                 lea     eax, [edx+0Ch]
.text$x:000084DE                 mov     ecx, [edx-8]
.text$x:000084E1                 xor     ecx, eax
.text$x:000084E3                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000084E8                 mov     eax, offset __ehfuncinfo$??1CTempDir@NDir@NFile@NWindows@@QAE@XZ
.text$x:000084ED                 jmp     ___CxxFrameHandler3
.text$x:000084ED __ehhandler$??1CTempDir@NDir@NFile@NWindows@@QAE@XZ endp
.text$x:000084ED
.text$x:000084ED ; ---------------------------------------------------------------------------
.text$x:000084F2                 align 4
.text$x:000084F2 _text$x         ends
.text$x:000084F2
.xdata$x:000084F4 ; ===========================================================================
.xdata$x:000084F4
.xdata$x:000084F4 ; Segment type: Pure data
.xdata$x:000084F4 ; Segment permissions: Read
.xdata$x:000084F4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000084F4                 assume cs:_xdata$x
.xdata$x:000084F4                 ;org 84F4h
.xdata$x:000084F4 ; COMDAT (pick associative to section at 8464)
.xdata$x:000084F4 __unwindtable$??1CTempDir@NDir@NFile@NWindows@@QAE@XZ db 0FFh
.xdata$x:000084F4                                         ; DATA XREF: .xdata$x:00008504o
.xdata$x:000084F5                 db 0FFh
.xdata$x:000084F6                 db 0FFh
.xdata$x:000084F7                 db 0FFh
.xdata$x:000084F8                 dd offset __unwindfunclet$??1CTempDir@NDir@NFile@NWindows@@QAE@XZ$0
.xdata$x:000084FC __ehfuncinfo$??1CTempDir@NDir@NFile@NWindows@@QAE@XZ db  22h ; "
.xdata$x:000084FC                                         ; DATA XREF: __ehhandler$??1CTempDir@NDir@NFile@NWindows@@QAE@XZ+11o
.xdata$x:000084FD                 db    5
.xdata$x:000084FE                 db  93h ; 
.xdata$x:000084FF                 db  19h
.xdata$x:00008500                 db    1
.xdata$x:00008501                 db    0
.xdata$x:00008502                 db    0
.xdata$x:00008503                 db    0
.xdata$x:00008504                 dd offset __unwindtable$??1CTempDir@NDir@NFile@NWindows@@QAE@XZ
.xdata$x:00008508                 db    0
.xdata$x:00008509                 db    0
.xdata$x:0000850A                 db    0
.xdata$x:0000850B                 db    0
.xdata$x:0000850C                 db    0
.xdata$x:0000850D                 db    0
.xdata$x:0000850E                 db    0
.xdata$x:0000850F                 db    0
.xdata$x:00008510                 db    0
.xdata$x:00008511                 db    0
.xdata$x:00008512                 db    0
.xdata$x:00008513                 db    0
.xdata$x:00008514                 db    0
.xdata$x:00008515                 db    0
.xdata$x:00008516                 db    0
.xdata$x:00008517                 db    0
.xdata$x:00008518                 db    0
.xdata$x:00008519                 db    0
.xdata$x:0000851A                 db    0
.xdata$x:0000851B                 db    0
.xdata$x:0000851C                 db    1
.xdata$x:0000851D                 db    0
.xdata$x:0000851E                 db    0
.xdata$x:0000851F                 db    0
.xdata$x:0000851F _xdata$x        ends
.xdata$x:0000851F
.text:00008520 ; ===========================================================================
.text:00008520
.text:00008520 ; Segment type: Pure code
.text:00008520 ; Segment permissions: Read/Execute
.text:00008520 _text           segment para public 'CODE' use32
.text:00008520                 assume cs:_text
.text:00008520                 ;org 8520h
.text:00008520 ; COMDAT (pick any)
.text:00008520                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008520
.text:00008520 ; =============== S U B R O U T I N E =======================================
.text:00008520
.text:00008520 ; Attributes: bp-based frame
.text:00008520
.text:00008520 ; const struct UString *__thiscall NWindows::NFile::NDir::CTempDir::GetPath(NWindows::NFile::NDir::CTempDir *__hidden this)
.text:00008520                 public ?GetPath@CTempDir@NDir@NFile@NWindows@@QBEABVUString@@XZ
.text:00008520 ?GetPath@CTempDir@NDir@NFile@NWindows@@QBEABVUString@@XZ proc near
.text:00008520                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+10DBp
.text:00008520
.text:00008520 var_4           = dword ptr -4
.text:00008520
.text:00008520                 push    ebp
.text:00008521                 mov     ebp, esp
.text:00008523                 push    ecx
.text:00008524                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000852B                 mov     [ebp+var_4], ecx
.text:0000852E                 mov     eax, [ebp+var_4]
.text:00008531                 add     eax, 4
.text:00008534                 mov     esp, ebp
.text:00008536                 pop     ebp
.text:00008537                 retn
.text:00008537 ?GetPath@CTempDir@NDir@NFile@NWindows@@QBEABVUString@@XZ endp
.text:00008537
.text:00008537 _text           ends
.text:00008537
.text:00008538 ; ===========================================================================
.text:00008538
.text:00008538 ; Segment type: Pure code
.text:00008538 ; Segment permissions: Read/Execute
.text:00008538 _text           segment para public 'CODE' use32
.text:00008538                 assume cs:_text
.text:00008538                 ;org 8538h
.text:00008538 ; COMDAT (pick any)
.text:00008538                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008538
.text:00008538 ; =============== S U B R O U T I N E =======================================
.text:00008538
.text:00008538 ; Attributes: bp-based frame
.text:00008538
.text:00008538 ; _DWORD __thiscall NWindows::NFile::NDir::CCurrentDirRestorer::CCurrentDirRestorer(NWindows::NFile::NDir::CCurrentDirRestorer *__hidden this)
.text:00008538                 public ??0CCurrentDirRestorer@NDir@NFile@NWindows@@QAE@XZ
.text:00008538 ??0CCurrentDirRestorer@NDir@NFile@NWindows@@QAE@XZ proc near
.text:00008538                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+20D4p
.text:00008538
.text:00008538 var_10          = dword ptr -10h
.text:00008538 var_C           = dword ptr -0Ch
.text:00008538 var_4           = dword ptr -4
.text:00008538
.text:00008538                 push    ebp
.text:00008539                 mov     ebp, esp
.text:0000853B                 push    0FFFFFFFFh
.text:0000853D                 push    offset __ehhandler$??0CCurrentDirRestorer@NDir@NFile@NWindows@@QAE@XZ
.text:00008542                 mov     eax, large fs:0
.text:00008548                 push    eax
.text:00008549                 push    ecx
.text:0000854A                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00008551                 mov     eax, dword ptr ds:___security_cookie
.text:00008556                 xor     eax, ebp
.text:00008558                 push    eax             ; struct UString *
.text:00008559                 lea     eax, [ebp+var_C]
.text:0000855C                 mov     large fs:0, eax
.text:00008562                 mov     [ebp+var_10], ecx
.text:00008565                 mov     ecx, [ebp+var_10]
.text:00008568                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:0000856D                 mov     [ebp+var_4], 0
.text:00008574                 mov     eax, [ebp+var_10]
.text:00008577                 mov     byte ptr [eax+0Ch], 1
.text:0000857B                 mov     ecx, [ebp+var_10]
.text:0000857E                 push    ecx             ; this
.text:0000857F                 call    ?GetCurrentDir@NDir@NFile@NWindows@@YG_NAAVUString@@@Z ; NWindows::NFile::NDir::GetCurrentDir(UString &)
.text:00008584                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000858B                 mov     eax, [ebp+var_10]
.text:0000858E                 mov     ecx, [ebp+var_C]
.text:00008591                 mov     large fs:0, ecx
.text:00008598                 pop     ecx
.text:00008599                 add     esp, 10h
.text:0000859C                 cmp     ebp, esp
.text:0000859E                 call    __RTC_CheckEsp
.text:000085A3                 mov     esp, ebp
.text:000085A5                 pop     ebp
.text:000085A6                 retn
.text:000085A6 ??0CCurrentDirRestorer@NDir@NFile@NWindows@@QAE@XZ endp
.text:000085A6
.text:000085A6 ; ---------------------------------------------------------------------------
.text:000085A7                 align 4
.text:000085A7 _text           ends
.text:000085A7
.text$x:000085A8 ; ===========================================================================
.text$x:000085A8
.text$x:000085A8 ; Segment type: Pure code
.text$x:000085A8 ; Segment permissions: Read/Execute
.text$x:000085A8 _text$x         segment para public 'CODE' use32
.text$x:000085A8                 assume cs:_text$x
.text$x:000085A8                 ;org 85A8h
.text$x:000085A8 ; COMDAT (pick associative to section at 8538)
.text$x:000085A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000085A8
.text$x:000085A8 ; =============== S U B R O U T I N E =======================================
.text$x:000085A8
.text$x:000085A8
.text$x:000085A8 __unwindfunclet$??0CCurrentDirRestorer@NDir@NFile@NWindows@@QAE@XZ$0 proc near
.text$x:000085A8                                         ; DATA XREF: .xdata$x:000085D0o
.text$x:000085A8                 mov     ecx, [ebp-10h]  ; this
.text$x:000085AB                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000085AB __unwindfunclet$??0CCurrentDirRestorer@NDir@NFile@NWindows@@QAE@XZ$0 endp
.text$x:000085AB
.text$x:000085B0
.text$x:000085B0 ; =============== S U B R O U T I N E =======================================
.text$x:000085B0
.text$x:000085B0
.text$x:000085B0 __ehhandler$??0CCurrentDirRestorer@NDir@NFile@NWindows@@QAE@XZ proc near
.text$x:000085B0                                         ; DATA XREF: NWindows::NFile::NDir::CCurrentDirRestorer::CCurrentDirRestorer(void)+5o
.text$x:000085B0
.text$x:000085B0 arg_4           = dword ptr  8
.text$x:000085B0
.text$x:000085B0                 mov     edx, [esp+arg_4]
.text$x:000085B4                 lea     eax, [edx+0Ch]
.text$x:000085B7                 mov     ecx, [edx-8]
.text$x:000085BA                 xor     ecx, eax
.text$x:000085BC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000085C1                 mov     eax, offset __ehfuncinfo$??0CCurrentDirRestorer@NDir@NFile@NWindows@@QAE@XZ
.text$x:000085C6                 jmp     ___CxxFrameHandler3
.text$x:000085C6 __ehhandler$??0CCurrentDirRestorer@NDir@NFile@NWindows@@QAE@XZ endp
.text$x:000085C6
.text$x:000085C6 ; ---------------------------------------------------------------------------
.text$x:000085CB                 align 4
.text$x:000085CB _text$x         ends
.text$x:000085CB
.xdata$x:000085CC ; ===========================================================================
.xdata$x:000085CC
.xdata$x:000085CC ; Segment type: Pure data
.xdata$x:000085CC ; Segment permissions: Read
.xdata$x:000085CC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000085CC                 assume cs:_xdata$x
.xdata$x:000085CC                 ;org 85CCh
.xdata$x:000085CC ; COMDAT (pick associative to section at 8538)
.xdata$x:000085CC __unwindtable$??0CCurrentDirRestorer@NDir@NFile@NWindows@@QAE@XZ db 0FFh
.xdata$x:000085CC                                         ; DATA XREF: .xdata$x:000085DCo
.xdata$x:000085CD                 db 0FFh
.xdata$x:000085CE                 db 0FFh
.xdata$x:000085CF                 db 0FFh
.xdata$x:000085D0                 dd offset __unwindfunclet$??0CCurrentDirRestorer@NDir@NFile@NWindows@@QAE@XZ$0
.xdata$x:000085D4 __ehfuncinfo$??0CCurrentDirRestorer@NDir@NFile@NWindows@@QAE@XZ db  22h ; "
.xdata$x:000085D4                                         ; DATA XREF: __ehhandler$??0CCurrentDirRestorer@NDir@NFile@NWindows@@QAE@XZ+11o
.xdata$x:000085D5                 db    5
.xdata$x:000085D6                 db  93h ; 
.xdata$x:000085D7                 db  19h
.xdata$x:000085D8                 db    1
.xdata$x:000085D9                 db    0
.xdata$x:000085DA                 db    0
.xdata$x:000085DB                 db    0
.xdata$x:000085DC                 dd offset __unwindtable$??0CCurrentDirRestorer@NDir@NFile@NWindows@@QAE@XZ
.xdata$x:000085E0                 db    0
.xdata$x:000085E1                 db    0
.xdata$x:000085E2                 db    0
.xdata$x:000085E3                 db    0
.xdata$x:000085E4                 db    0
.xdata$x:000085E5                 db    0
.xdata$x:000085E6                 db    0
.xdata$x:000085E7                 db    0
.xdata$x:000085E8                 db    0
.xdata$x:000085E9                 db    0
.xdata$x:000085EA                 db    0
.xdata$x:000085EB                 db    0
.xdata$x:000085EC                 db    0
.xdata$x:000085ED                 db    0
.xdata$x:000085EE                 db    0
.xdata$x:000085EF                 db    0
.xdata$x:000085F0                 db    0
.xdata$x:000085F1                 db    0
.xdata$x:000085F2                 db    0
.xdata$x:000085F3                 db    0
.xdata$x:000085F4                 db    1
.xdata$x:000085F5                 db    0
.xdata$x:000085F6                 db    0
.xdata$x:000085F7                 db    0
.xdata$x:000085F7 _xdata$x        ends
.xdata$x:000085F7
.text:000085F8 ; ===========================================================================
.text:000085F8
.text:000085F8 ; Segment type: Pure code
.text:000085F8 ; Segment permissions: Read/Execute
.text:000085F8 _text           segment para public 'CODE' use32
.text:000085F8                 assume cs:_text
.text:000085F8                 ;org 85F8h
.text:000085F8 ; COMDAT (pick any)
.text:000085F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000085F8
.text:000085F8 ; =============== S U B R O U T I N E =======================================
.text:000085F8
.text:000085F8 ; Attributes: bp-based frame
.text:000085F8
.text:000085F8 ; _DWORD __thiscall NWindows::NFile::NDir::CCurrentDirRestorer::~CCurrentDirRestorer(NWindows::NFile::NDir::CCurrentDirRestorer *__hidden this)
.text:000085F8                 public ??1CCurrentDirRestorer@NDir@NFile@NWindows@@QAE@XZ
.text:000085F8 ??1CCurrentDirRestorer@NDir@NFile@NWindows@@QAE@XZ proc near
.text:000085F8                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+22C5p
.text:000085F8                                         ; __unwindfunclet$?UpdateArchive@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABVUString@@AAVCCensor@NWildcard@@AAUCUpdateOptions@@AAUCUpdateErrorInfo@@PAUIOpenCallbackUI@@PAUIUpdateCallbackUI2@@_N@Z$30+6j
.text:000085F8
.text:000085F8 var_24          = dword ptr -24h
.text:000085F8 var_20          = word ptr -20h
.text:000085F8 var_1C          = dword ptr -1Ch
.text:000085F8 var_18          = dword ptr -18h
.text:000085F8 var_14          = dword ptr -14h
.text:000085F8 var_10          = dword ptr -10h
.text:000085F8 var_C           = dword ptr -0Ch
.text:000085F8 var_4           = dword ptr -4
.text:000085F8
.text:000085F8                 push    ebp
.text:000085F9                 mov     ebp, esp
.text:000085FB                 push    0FFFFFFFFh
.text:000085FD                 push    offset __ehhandler$??1CCurrentDirRestorer@NDir@NFile@NWindows@@QAE@XZ
.text:00008602                 mov     eax, large fs:0
.text:00008608                 push    eax
.text:00008609                 sub     esp, 18h
.text:0000860C                 mov     eax, 0CCCCCCCCh
.text:00008611                 mov     [ebp+var_24], eax
.text:00008614                 mov     dword ptr [ebp+var_20], eax
.text:00008617                 mov     [ebp+var_1C], eax
.text:0000861A                 mov     [ebp+var_18], eax
.text:0000861D                 mov     [ebp+var_14], eax
.text:00008620                 mov     [ebp+var_10], eax
.text:00008623                 mov     eax, dword ptr ds:___security_cookie
.text:00008628                 xor     eax, ebp
.text:0000862A                 push    eax             ; struct UString *
.text:0000862B                 lea     eax, [ebp+var_C]
.text:0000862E                 mov     large fs:0, eax
.text:00008634                 mov     [ebp+var_10], ecx
.text:00008637                 mov     [ebp+var_4], 0
.text:0000863E                 mov     eax, [ebp+var_10]
.text:00008641                 movzx   ecx, byte ptr [eax+0Ch]
.text:00008645                 test    ecx, ecx
.text:00008647                 jnz     short loc_864B
.text:00008649                 jmp     short loc_8695
.text:0000864B ; ---------------------------------------------------------------------------
.text:0000864B
.text:0000864B loc_864B:                               ; CODE XREF: NWindows::NFile::NDir::CCurrentDirRestorer::~CCurrentDirRestorer(void)+4Fj
.text:0000864B                 lea     ecx, [ebp+var_20]
.text:0000864E                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00008653                 mov     byte ptr [ebp+var_4], 1
.text:00008657                 lea     edx, [ebp+var_20]
.text:0000865A                 push    edx             ; wchar_t *
.text:0000865B                 call    ?GetCurrentDir@NDir@NFile@NWindows@@YG_NAAVUString@@@Z ; NWindows::NFile::NDir::GetCurrentDir(UString &)
.text:00008660                 movzx   eax, al
.text:00008663                 test    eax, eax
.text:00008665                 jz      short loc_8689
.text:00008667                 mov     ecx, [ebp+var_10]
.text:0000866A                 push    ecx             ; UString *
.text:0000866B                 lea     edx, [ebp+var_20]
.text:0000866E                 push    edx             ; UString *
.text:0000866F                 call    ??9@YG_NABVUString@@0@Z ; operator!=(UString const &,UString const &)
.text:00008674                 movzx   eax, al
.text:00008677                 test    eax, eax
.text:00008679                 jz      short loc_8689
.text:0000867B                 mov     ecx, [ebp+var_10]
.text:0000867E                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00008683                 push    eax             ; this
.text:00008684                 call    ?SetCurrentDir@NDir@NFile@NWindows@@YG_NPB_W@Z ; NWindows::NFile::NDir::SetCurrentDir(wchar_t const *)
.text:00008689
.text:00008689 loc_8689:                               ; CODE XREF: NWindows::NFile::NDir::CCurrentDirRestorer::~CCurrentDirRestorer(void)+6Dj
.text:00008689                                         ; NWindows::NFile::NDir::CCurrentDirRestorer::~CCurrentDirRestorer(void)+81j
.text:00008689                 mov     byte ptr [ebp+var_4], 0
.text:0000868D                 lea     ecx, [ebp+var_20] ; this
.text:00008690                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00008695
.text:00008695 loc_8695:                               ; CODE XREF: NWindows::NFile::NDir::CCurrentDirRestorer::~CCurrentDirRestorer(void)+51j
.text:00008695                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000869C                 mov     ecx, [ebp+var_10] ; this
.text:0000869F                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000086A4                 push    edx
.text:000086A5                 mov     ecx, ebp
.text:000086A7                 push    eax
.text:000086A8                 lea     edx, $LN11
.text:000086AE                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:000086B3                 pop     eax
.text:000086B4                 pop     edx
.text:000086B5                 mov     ecx, [ebp+var_C]
.text:000086B8                 mov     large fs:0, ecx
.text:000086BF                 pop     ecx
.text:000086C0                 add     esp, 24h
.text:000086C3                 cmp     ebp, esp
.text:000086C5                 call    __RTC_CheckEsp
.text:000086CA                 mov     esp, ebp
.text:000086CC                 pop     ebp
.text:000086CD                 retn
.text:000086CD ??1CCurrentDirRestorer@NDir@NFile@NWindows@@QAE@XZ endp ; sp-analysis failed
.text:000086CD
.text:000086CD ; ---------------------------------------------------------------------------
.text:000086CE                 align 10h
.text:000086D0 $LN11           dd 1                    ; DATA XREF: NWindows::NFile::NDir::CCurrentDirRestorer::~CCurrentDirRestorer(void)+B0o
.text:000086D4                 dd offset $LN10_3
.text:000086D8 $LN10_3         dd 0FFFFFFE0h, 0Ch      ; DATA XREF: .text:000086D4o
.text:000086E0                 dd offset $LN8
.text:000086E4 $LN8            db 73h, 0               ; DATA XREF: .text:000086E0o
.text:000086E6                 align 4
.text:000086E6 _text           ends
.text:000086E6
.text$x:000086E8 ; ===========================================================================
.text$x:000086E8
.text$x:000086E8 ; Segment type: Pure code
.text$x:000086E8 ; Segment permissions: Read/Execute
.text$x:000086E8 _text$x         segment para public 'CODE' use32
.text$x:000086E8                 assume cs:_text$x
.text$x:000086E8                 ;org 86E8h
.text$x:000086E8 ; COMDAT (pick associative to section at 85F8)
.text$x:000086E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000086E8
.text$x:000086E8 ; =============== S U B R O U T I N E =======================================
.text$x:000086E8
.text$x:000086E8
.text$x:000086E8 __unwindfunclet$??1CCurrentDirRestorer@NDir@NFile@NWindows@@QAE@XZ$0 proc near
.text$x:000086E8                                         ; DATA XREF: .xdata$x:00008718o
.text$x:000086E8                 mov     ecx, [ebp-10h]  ; this
.text$x:000086EB                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000086EB __unwindfunclet$??1CCurrentDirRestorer@NDir@NFile@NWindows@@QAE@XZ$0 endp
.text$x:000086EB
.text$x:000086F0
.text$x:000086F0 ; =============== S U B R O U T I N E =======================================
.text$x:000086F0
.text$x:000086F0
.text$x:000086F0 __unwindfunclet$??1CCurrentDirRestorer@NDir@NFile@NWindows@@QAE@XZ$1 proc near
.text$x:000086F0                                         ; DATA XREF: .xdata$x:00008720o
.text$x:000086F0                 lea     ecx, [ebp-20h]  ; this
.text$x:000086F3                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000086F3 __unwindfunclet$??1CCurrentDirRestorer@NDir@NFile@NWindows@@QAE@XZ$1 endp
.text$x:000086F3
.text$x:000086F8
.text$x:000086F8 ; =============== S U B R O U T I N E =======================================
.text$x:000086F8
.text$x:000086F8
.text$x:000086F8 __ehhandler$??1CCurrentDirRestorer@NDir@NFile@NWindows@@QAE@XZ proc near
.text$x:000086F8                                         ; DATA XREF: NWindows::NFile::NDir::CCurrentDirRestorer::~CCurrentDirRestorer(void)+5o
.text$x:000086F8
.text$x:000086F8 arg_4           = dword ptr  8
.text$x:000086F8
.text$x:000086F8                 mov     edx, [esp+arg_4]
.text$x:000086FC                 lea     eax, [edx+0Ch]
.text$x:000086FF                 mov     ecx, [edx-1Ch]
.text$x:00008702                 xor     ecx, eax
.text$x:00008704                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008709                 mov     eax, offset __ehfuncinfo$??1CCurrentDirRestorer@NDir@NFile@NWindows@@QAE@XZ
.text$x:0000870E                 jmp     ___CxxFrameHandler3
.text$x:0000870E __ehhandler$??1CCurrentDirRestorer@NDir@NFile@NWindows@@QAE@XZ endp
.text$x:0000870E
.text$x:0000870E ; ---------------------------------------------------------------------------
.text$x:00008713                 align 4
.text$x:00008713 _text$x         ends
.text$x:00008713
.xdata$x:00008714 ; ===========================================================================
.xdata$x:00008714
.xdata$x:00008714 ; Segment type: Pure data
.xdata$x:00008714 ; Segment permissions: Read
.xdata$x:00008714 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008714                 assume cs:_xdata$x
.xdata$x:00008714                 ;org 8714h
.xdata$x:00008714 ; COMDAT (pick associative to section at 85F8)
.xdata$x:00008714 __unwindtable$??1CCurrentDirRestorer@NDir@NFile@NWindows@@QAE@XZ db 0FFh
.xdata$x:00008714                                         ; DATA XREF: .xdata$x:0000872Co
.xdata$x:00008715                 db 0FFh
.xdata$x:00008716                 db 0FFh
.xdata$x:00008717                 db 0FFh
.xdata$x:00008718                 dd offset __unwindfunclet$??1CCurrentDirRestorer@NDir@NFile@NWindows@@QAE@XZ$0
.xdata$x:0000871C                 align 10h
.xdata$x:00008720                 dd offset __unwindfunclet$??1CCurrentDirRestorer@NDir@NFile@NWindows@@QAE@XZ$1
.xdata$x:00008724 __ehfuncinfo$??1CCurrentDirRestorer@NDir@NFile@NWindows@@QAE@XZ db  22h ; "
.xdata$x:00008724                                         ; DATA XREF: __ehhandler$??1CCurrentDirRestorer@NDir@NFile@NWindows@@QAE@XZ+11o
.xdata$x:00008725                 db    5
.xdata$x:00008726                 db  93h ; 
.xdata$x:00008727                 db  19h
.xdata$x:00008728                 db    2
.xdata$x:00008729                 db    0
.xdata$x:0000872A                 db    0
.xdata$x:0000872B                 db    0
.xdata$x:0000872C                 dd offset __unwindtable$??1CCurrentDirRestorer@NDir@NFile@NWindows@@QAE@XZ
.xdata$x:00008730                 db    0
.xdata$x:00008731                 db    0
.xdata$x:00008732                 db    0
.xdata$x:00008733                 db    0
.xdata$x:00008734                 db    0
.xdata$x:00008735                 db    0
.xdata$x:00008736                 db    0
.xdata$x:00008737                 db    0
.xdata$x:00008738                 db    0
.xdata$x:00008739                 db    0
.xdata$x:0000873A                 db    0
.xdata$x:0000873B                 db    0
.xdata$x:0000873C                 db    0
.xdata$x:0000873D                 db    0
.xdata$x:0000873E                 db    0
.xdata$x:0000873F                 db    0
.xdata$x:00008740                 db    0
.xdata$x:00008741                 db    0
.xdata$x:00008742                 db    0
.xdata$x:00008743                 db    0
.xdata$x:00008744                 db    1
.xdata$x:00008745                 db    0
.xdata$x:00008746                 db    0
.xdata$x:00008747                 db    0
.xdata$x:00008747 _xdata$x        ends
.xdata$x:00008747
.text:00008748 ; ===========================================================================
.text:00008748
.text:00008748 ; Segment type: Pure code
.text:00008748 ; Segment permissions: Read/Execute
.text:00008748 _text           segment para public 'CODE' use32
.text:00008748                 assume cs:_text
.text:00008748                 ;org 8748h
.text:00008748 ; COMDAT (pick any)
.text:00008748                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008748
.text:00008748 ; =============== S U B R O U T I N E =======================================
.text:00008748
.text:00008748 ; Attributes: bp-based frame
.text:00008748
.text:00008748 ; int __stdcall operator!=(UString *, UString *)
.text:00008748                 public ??9@YG_NABVUString@@0@Z
.text:00008748 ??9@YG_NABVUString@@0@Z proc near       ; CODE XREF: NWindows::NFile::NDir::CCurrentDirRestorer::~CCurrentDirRestorer(void)+77p
.text:00008748
.text:00008748 var_4           = dword ptr -4
.text:00008748 arg_0           = dword ptr  8
.text:00008748 arg_4           = dword ptr  0Ch
.text:00008748
.text:00008748                 push    ebp
.text:00008749                 mov     ebp, esp
.text:0000874B                 push    ecx
.text:0000874C                 push    esi
.text:0000874D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00008754                 mov     ecx, [ebp+arg_0] ; this
.text:00008757                 call    ?Len@UString@@QBEIXZ ; UString::Len(void)
.text:0000875C                 mov     esi, eax
.text:0000875E                 mov     ecx, [ebp+arg_4] ; this
.text:00008761                 call    ?Len@UString@@QBEIXZ ; UString::Len(void)
.text:00008766                 cmp     esi, eax
.text:00008768                 jnz     short loc_879B
.text:0000876A                 mov     ecx, [ebp+arg_4]
.text:0000876D                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00008772                 mov     esi, esp
.text:00008774                 push    eax             ; Str2
.text:00008775                 mov     ecx, [ebp+arg_0]
.text:00008778                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:0000877D                 push    eax             ; Str1
.text:0000877E                 call    dword ptr ds:__imp__wcscmp
.text:00008784                 add     esp, 8
.text:00008787                 cmp     esi, esp
.text:00008789                 call    __RTC_CheckEsp
.text:0000878E                 test    eax, eax
.text:00008790                 jnz     short loc_879B
.text:00008792                 mov     [ebp+var_4], 0
.text:00008799                 jmp     short loc_87A2
.text:0000879B ; ---------------------------------------------------------------------------
.text:0000879B
.text:0000879B loc_879B:                               ; CODE XREF: operator!=(UString const &,UString const &)+20j
.text:0000879B                                         ; operator!=(UString const &,UString const &)+48j
.text:0000879B                 mov     [ebp+var_4], 1
.text:000087A2
.text:000087A2 loc_87A2:                               ; CODE XREF: operator!=(UString const &,UString const &)+51j
.text:000087A2                 mov     al, byte ptr [ebp+var_4]
.text:000087A5                 pop     esi
.text:000087A6                 add     esp, 4
.text:000087A9                 cmp     ebp, esp
.text:000087AB                 call    __RTC_CheckEsp
.text:000087B0                 mov     esp, ebp
.text:000087B2                 pop     ebp
.text:000087B3                 retn    8
.text:000087B3 ??9@YG_NABVUString@@0@Z endp
.text:000087B3
.text:000087B3 ; ---------------------------------------------------------------------------
.text:000087B6                 align 4
.text:000087B6 _text           ends
.text:000087B6
.text:000087B8 ; ===========================================================================
.text:000087B8
.text:000087B8 ; Segment type: Pure code
.text:000087B8 ; Segment permissions: Read/Execute
.text:000087B8 _text           segment para public 'CODE' use32
.text:000087B8                 assume cs:_text
.text:000087B8                 ;org 87B8h
.text:000087B8 ; COMDAT (pick any)
.text:000087B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000087B8
.text:000087B8 ; =============== S U B R O U T I N E =======================================
.text:000087B8
.text:000087B8 ; Attributes: bp-based frame
.text:000087B8
.text:000087B8 ; _DWORD __thiscall CTempFiles::~CTempFiles(CTempFiles *__hidden this)
.text:000087B8                 public ??1CTempFiles@@QAE@XZ
.text:000087B8 ??1CTempFiles@@QAE@XZ proc near         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1320p
.text:000087B8                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1413p ...
.text:000087B8
.text:000087B8 var_10          = dword ptr -10h
.text:000087B8 var_C           = dword ptr -0Ch
.text:000087B8 var_4           = dword ptr -4
.text:000087B8
.text:000087B8                 push    ebp
.text:000087B9                 mov     ebp, esp
.text:000087BB                 push    0FFFFFFFFh
.text:000087BD                 push    offset __ehhandler$??1CTempFiles@@QAE@XZ
.text:000087C2                 mov     eax, large fs:0
.text:000087C8                 push    eax
.text:000087C9                 push    ecx
.text:000087CA                 mov     [ebp+var_10], 0CCCCCCCCh
.text:000087D1                 mov     eax, dword ptr ds:___security_cookie
.text:000087D6                 xor     eax, ebp
.text:000087D8                 push    eax
.text:000087D9                 lea     eax, [ebp+var_C]
.text:000087DC                 mov     large fs:0, eax
.text:000087E2                 mov     [ebp+var_10], ecx
.text:000087E5                 mov     [ebp+var_4], 0
.text:000087EC                 mov     ecx, [ebp+var_10] ; this
.text:000087EF                 call    ?Clear@CTempFiles@@AAEXXZ ; CTempFiles::Clear(void)
.text:000087F4                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000087FB                 mov     ecx, [ebp+var_10]
.text:000087FE                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:00008803                 mov     ecx, [ebp+var_C]
.text:00008806                 mov     large fs:0, ecx
.text:0000880D                 pop     ecx
.text:0000880E                 add     esp, 10h
.text:00008811                 cmp     ebp, esp
.text:00008813                 call    __RTC_CheckEsp
.text:00008818                 mov     esp, ebp
.text:0000881A                 pop     ebp
.text:0000881B                 retn
.text:0000881B ??1CTempFiles@@QAE@XZ endp
.text:0000881B
.text:0000881B _text           ends
.text:0000881B
.text$x:0000881C ; ===========================================================================
.text$x:0000881C
.text$x:0000881C ; Segment type: Pure code
.text$x:0000881C ; Segment permissions: Read/Execute
.text$x:0000881C _text$x         segment para public 'CODE' use32
.text$x:0000881C                 assume cs:_text$x
.text$x:0000881C                 ;org 881Ch
.text$x:0000881C ; COMDAT (pick associative to section at 87B8)
.text$x:0000881C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000881C
.text$x:0000881C ; =============== S U B R O U T I N E =======================================
.text$x:0000881C
.text$x:0000881C
.text$x:0000881C __unwindfunclet$??1CTempFiles@@QAE@XZ$0 proc near
.text$x:0000881C                                         ; DATA XREF: .xdata$x:00008844o
.text$x:0000881C                 mov     ecx, [ebp-10h]
.text$x:0000881F                 jmp     ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text$x:0000881F __unwindfunclet$??1CTempFiles@@QAE@XZ$0 endp
.text$x:0000881F
.text$x:00008824
.text$x:00008824 ; =============== S U B R O U T I N E =======================================
.text$x:00008824
.text$x:00008824
.text$x:00008824 __ehhandler$??1CTempFiles@@QAE@XZ proc near
.text$x:00008824                                         ; DATA XREF: CTempFiles::~CTempFiles(void)+5o
.text$x:00008824
.text$x:00008824 arg_4           = dword ptr  8
.text$x:00008824
.text$x:00008824                 mov     edx, [esp+arg_4]
.text$x:00008828                 lea     eax, [edx+0Ch]
.text$x:0000882B                 mov     ecx, [edx-8]
.text$x:0000882E                 xor     ecx, eax
.text$x:00008830                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008835                 mov     eax, offset __ehfuncinfo$??1CTempFiles@@QAE@XZ
.text$x:0000883A                 jmp     ___CxxFrameHandler3
.text$x:0000883A __ehhandler$??1CTempFiles@@QAE@XZ endp
.text$x:0000883A
.text$x:0000883A ; ---------------------------------------------------------------------------
.text$x:0000883F                 align 10h
.text$x:0000883F _text$x         ends
.text$x:0000883F
.xdata$x:00008840 ; ===========================================================================
.xdata$x:00008840
.xdata$x:00008840 ; Segment type: Pure data
.xdata$x:00008840 ; Segment permissions: Read
.xdata$x:00008840 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008840                 assume cs:_xdata$x
.xdata$x:00008840                 ;org 8840h
.xdata$x:00008840 ; COMDAT (pick associative to section at 87B8)
.xdata$x:00008840 __unwindtable$??1CTempFiles@@QAE@XZ db 0FFh
.xdata$x:00008840                                         ; DATA XREF: .xdata$x:00008850o
.xdata$x:00008841                 db 0FFh
.xdata$x:00008842                 db 0FFh
.xdata$x:00008843                 db 0FFh
.xdata$x:00008844                 dd offset __unwindfunclet$??1CTempFiles@@QAE@XZ$0
.xdata$x:00008848 __ehfuncinfo$??1CTempFiles@@QAE@XZ db  22h ; "
.xdata$x:00008848                                         ; DATA XREF: __ehhandler$??1CTempFiles@@QAE@XZ+11o
.xdata$x:00008849                 db    5
.xdata$x:0000884A                 db  93h ; 
.xdata$x:0000884B                 db  19h
.xdata$x:0000884C                 db    1
.xdata$x:0000884D                 db    0
.xdata$x:0000884E                 db    0
.xdata$x:0000884F                 db    0
.xdata$x:00008850                 dd offset __unwindtable$??1CTempFiles@@QAE@XZ
.xdata$x:00008854                 db    0
.xdata$x:00008855                 db    0
.xdata$x:00008856                 db    0
.xdata$x:00008857                 db    0
.xdata$x:00008858                 db    0
.xdata$x:00008859                 db    0
.xdata$x:0000885A                 db    0
.xdata$x:0000885B                 db    0
.xdata$x:0000885C                 db    0
.xdata$x:0000885D                 db    0
.xdata$x:0000885E                 db    0
.xdata$x:0000885F                 db    0
.xdata$x:00008860                 db    0
.xdata$x:00008861                 db    0
.xdata$x:00008862                 db    0
.xdata$x:00008863                 db    0
.xdata$x:00008864                 db    0
.xdata$x:00008865                 db    0
.xdata$x:00008866                 db    0
.xdata$x:00008867                 db    0
.xdata$x:00008868                 db    1
.xdata$x:00008869                 db    0
.xdata$x:0000886A                 db    0
.xdata$x:0000886B                 db    0
.xdata$x:0000886B _xdata$x        ends
.xdata$x:0000886B
.xdata$x:0000886C ; ===========================================================================
.xdata$x:0000886C
.xdata$x:0000886C ; Segment type: Pure data
.xdata$x:0000886C ; Segment permissions: Read
.xdata$x:0000886C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000886C                 assume cs:_xdata$x
.xdata$x:0000886C                 ;org 886Ch
.xdata$x:0000886C ; COMDAT (pick any)
.xdata$x:0000886C                 public __TI1H
.xdata$x:0000886C __TI1H          db    0                 ; DATA XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+8BEo
.xdata$x:0000886D                 db    0
.xdata$x:0000886E                 db    0
.xdata$x:0000886F                 db    0
.xdata$x:00008870                 db    0
.xdata$x:00008871                 db    0
.xdata$x:00008872                 db    0
.xdata$x:00008873                 db    0
.xdata$x:00008874                 db    0
.xdata$x:00008875                 db    0
.xdata$x:00008876                 db    0
.xdata$x:00008877                 db    0
.xdata$x:00008878                 dd offset __CTA1H
.xdata$x:00008878 _xdata$x        ends
.xdata$x:00008878
.xdata$x:0000887C ; ===========================================================================
.xdata$x:0000887C
.xdata$x:0000887C ; Segment type: Pure data
.xdata$x:0000887C ; Segment permissions: Read
.xdata$x:0000887C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000887C                 assume cs:_xdata$x
.xdata$x:0000887C                 ;org 887Ch
.xdata$x:0000887C ; COMDAT (pick any)
.xdata$x:0000887C                 public __TI2CPAD
.xdata$x:0000887C __TI2CPAD       db    1                 ; DATA XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+D2o
.xdata$x:0000887C                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+145o
.xdata$x:0000887D                 db    0
.xdata$x:0000887E                 db    0
.xdata$x:0000887F                 db    0
.xdata$x:00008880                 db    0
.xdata$x:00008881                 db    0
.xdata$x:00008882                 db    0
.xdata$x:00008883                 db    0
.xdata$x:00008884                 db    0
.xdata$x:00008885                 db    0
.xdata$x:00008886                 db    0
.xdata$x:00008887                 db    0
.xdata$x:00008888                 dd offset __CTA2PAD
.xdata$x:00008888 _xdata$x        ends
.xdata$x:00008888
.xdata$x:0000888C ; ===========================================================================
.xdata$x:0000888C
.xdata$x:0000888C ; Segment type: Pure data
.xdata$x:0000888C ; Segment permissions: Read
.xdata$x:0000888C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000888C                 assume cs:_xdata$x
.xdata$x:0000888C                 ;org 888Ch
.xdata$x:0000888C ; COMDAT (pick any)
.xdata$x:0000888C                 public __CTA1H
.xdata$x:0000888C __CTA1H         db    1                 ; DATA XREF: .xdata$x:00008878o
.xdata$x:0000888D                 db    0
.xdata$x:0000888E                 db    0
.xdata$x:0000888F                 db    0
.xdata$x:00008890                 dd offset __CT??_R0H@84
.xdata$x:00008890 _xdata$x        ends
.xdata$x:00008890
.xdata$x:00008894 ; ===========================================================================
.xdata$x:00008894
.xdata$x:00008894 ; Segment type: Pure data
.xdata$x:00008894 ; Segment permissions: Read
.xdata$x:00008894 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008894                 assume cs:_xdata$x
.xdata$x:00008894                 ;org 8894h
.xdata$x:00008894 ; COMDAT (pick any)
.xdata$x:00008894                 public __CT??_R0H@84
.xdata$x:00008894 __CT??_R0H@84   db    1                 ; DATA XREF: .xdata$x:00008890o
.xdata$x:00008895                 db    0
.xdata$x:00008896                 db    0
.xdata$x:00008897                 db    0
.xdata$x:00008898                 dd offset ??_R0H@8      ; int `RTTI Type Descriptor'
.xdata$x:0000889C                 align 10h
.xdata$x:000088A0                 db 0FFh
.xdata$x:000088A1                 db 0FFh
.xdata$x:000088A2                 db 0FFh
.xdata$x:000088A3                 db 0FFh
.xdata$x:000088A4                 db    0
.xdata$x:000088A5                 db    0
.xdata$x:000088A6                 db    0
.xdata$x:000088A7                 db    0
.xdata$x:000088A8                 db    4
.xdata$x:000088A9                 db    0
.xdata$x:000088AA                 db    0
.xdata$x:000088AB                 db    0
.xdata$x:000088AC                 db    0
.xdata$x:000088AD                 db    0
.xdata$x:000088AE                 db    0
.xdata$x:000088AF                 db    0
.xdata$x:000088AF _xdata$x        ends
.xdata$x:000088AF
.data:000088B0 ; ===========================================================================
.data:000088B0
.data:000088B0 ; Segment type: Pure data
.data:000088B0 ; Segment permissions: Read/Write
.data:000088B0 _data           segment dword public 'DATA' use32
.data:000088B0                 assume cs:_data
.data:000088B0                 ;org 88B0h
.data:000088B0 ; COMDAT (pick any)
.data:000088B0                 public ??_R0H@8
.data:000088B0 ; int `RTTI Type Descriptor'
.data:000088B0 ??_R0H@8        dd offset ??_7type_info@@6B@ ; DATA XREF: .xdata$x:00008898o
.data:000088B0                                         ; const type_info::`vftable'
.data:000088B4                 align 8
.data:000088B8                 db  2Eh ; .
.data:000088B9                 db  48h ; H
.data:000088BA                 db    0
.data:000088BB                 align 4
.data:000088BB _data           ends
.data:000088BB
.text:000088BC ; ===========================================================================
.text:000088BC
.text:000088BC ; Segment type: Pure code
.text:000088BC ; Segment permissions: Read/Execute
.text:000088BC _text           segment para public 'CODE' use32
.text:000088BC                 assume cs:_text
.text:000088BC                 ;org 88BCh
.text:000088BC ; COMDAT (pick any)
.text:000088BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000088BC
.text:000088BC ; =============== S U B R O U T I N E =======================================
.text:000088BC
.text:000088BC ; Attributes: bp-based frame
.text:000088BC
.text:000088BC ; public: class UString __thiscall UString::Left(unsigned int)const
.text:000088BC                 public ?Left@UString@@QBE?AV1@I@Z
.text:000088BC ?Left@UString@@QBE?AV1@I@Z proc near    ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+3D8p
.text:000088BC
.text:000088BC var_8           = dword ptr -8
.text:000088BC var_4           = dword ptr -4
.text:000088BC arg_0           = dword ptr  8
.text:000088BC arg_4           = dword ptr  0Ch
.text:000088BC
.text:000088BC                 push    ebp
.text:000088BD                 mov     ebp, esp
.text:000088BF                 sub     esp, 8
.text:000088C2                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000088C9                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000088D0                 mov     [ebp+var_4], ecx
.text:000088D3                 mov     [ebp+var_8], 0
.text:000088DA                 mov     eax, [ebp+var_4]
.text:000088DD                 push    eax
.text:000088DE                 mov     ecx, [ebp+arg_4]
.text:000088E1                 push    ecx
.text:000088E2                 mov     ecx, [ebp+arg_0]
.text:000088E5                 call    ??0UString@@AAE@IABV0@@Z ; UString::UString(uint,UString const &)
.text:000088EA                 mov     edx, [ebp+var_8]
.text:000088ED                 or      edx, 1
.text:000088F0                 mov     [ebp+var_8], edx
.text:000088F3                 mov     eax, [ebp+arg_0]
.text:000088F6                 add     esp, 8
.text:000088F9                 cmp     ebp, esp
.text:000088FB                 call    __RTC_CheckEsp
.text:00008900                 mov     esp, ebp
.text:00008902                 pop     ebp
.text:00008903                 retn    8
.text:00008903 ?Left@UString@@QBE?AV1@I@Z endp
.text:00008903
.text:00008903 ; ---------------------------------------------------------------------------
.text:00008906                 align 4
.text:00008906 _text           ends
.text:00008906
.text:00008908 ; ===========================================================================
.text:00008908
.text:00008908 ; Segment type: Pure code
.text:00008908 ; Segment permissions: Read/Execute
.text:00008908 _text           segment para public 'CODE' use32
.text:00008908                 assume cs:_text
.text:00008908                 ;org 8908h
.text:00008908 ; COMDAT (pick any)
.text:00008908                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008908
.text:00008908 ; =============== S U B R O U T I N E =======================================
.text:00008908
.text:00008908 ; Attributes: bp-based frame
.text:00008908
.text:00008908 ; bool __thiscall CArcInfoEx::Flags_AltStreams(CArcInfoEx *__hidden this)
.text:00008908                 public ?Flags_AltStreams@CArcInfoEx@@QBE_NXZ
.text:00008908 ?Flags_AltStreams@CArcInfoEx@@QBE_NXZ proc near
.text:00008908                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+21Dp
.text:00008908
.text:00008908 var_4           = dword ptr -4
.text:00008908
.text:00008908                 push    ebp
.text:00008909                 mov     ebp, esp
.text:0000890B                 push    ecx
.text:0000890C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00008913                 mov     [ebp+var_4], ecx
.text:00008916                 mov     eax, [ebp+var_4]
.text:00008919                 mov     eax, [eax]
.text:0000891B                 and     eax, 2
.text:0000891E                 neg     eax
.text:00008920                 sbb     eax, eax
.text:00008922                 neg     eax
.text:00008924                 mov     esp, ebp
.text:00008926                 pop     ebp
.text:00008927                 retn
.text:00008927 ?Flags_AltStreams@CArcInfoEx@@QBE_NXZ endp
.text:00008927
.text:00008927 _text           ends
.text:00008927
.text:00008928 ; ===========================================================================
.text:00008928
.text:00008928 ; Segment type: Pure code
.text:00008928 ; Segment permissions: Read/Execute
.text:00008928 _text           segment para public 'CODE' use32
.text:00008928                 assume cs:_text
.text:00008928                 ;org 8928h
.text:00008928 ; COMDAT (pick any)
.text:00008928                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008928
.text:00008928 ; =============== S U B R O U T I N E =======================================
.text:00008928
.text:00008928 ; Attributes: bp-based frame
.text:00008928
.text:00008928 ; bool __thiscall CArcInfoEx::Flags_NtSecure(CArcInfoEx *__hidden this)
.text:00008928                 public ?Flags_NtSecure@CArcInfoEx@@QBE_NXZ
.text:00008928 ?Flags_NtSecure@CArcInfoEx@@QBE_NXZ proc near
.text:00008928                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+25Ep
.text:00008928
.text:00008928 var_4           = dword ptr -4
.text:00008928
.text:00008928                 push    ebp
.text:00008929                 mov     ebp, esp
.text:0000892B                 push    ecx
.text:0000892C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00008933                 mov     [ebp+var_4], ecx
.text:00008936                 mov     eax, [ebp+var_4]
.text:00008939                 mov     eax, [eax]
.text:0000893B                 and     eax, 4
.text:0000893E                 neg     eax
.text:00008940                 sbb     eax, eax
.text:00008942                 neg     eax
.text:00008944                 mov     esp, ebp
.text:00008946                 pop     ebp
.text:00008947                 retn
.text:00008947 ?Flags_NtSecure@CArcInfoEx@@QBE_NXZ endp
.text:00008947
.text:00008947 _text           ends
.text:00008947
.text:00008948 ; ===========================================================================
.text:00008948
.text:00008948 ; Segment type: Pure code
.text:00008948 ; Segment permissions: Read/Execute
.text:00008948 _text           segment para public 'CODE' use32
.text:00008948                 assume cs:_text
.text:00008948                 ;org 8948h
.text:00008948 ; COMDAT (pick any)
.text:00008948                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008948
.text:00008948 ; =============== S U B R O U T I N E =======================================
.text:00008948
.text:00008948 ; Attributes: bp-based frame
.text:00008948
.text:00008948 ; public: long __thiscall CCodecs::CreateOutArchive(unsigned int, class CMyComPtr<struct IOutArchive> &)const
.text:00008948                 public ?CreateOutArchive@CCodecs@@QBEJIAAV?$CMyComPtr@UIOutArchive@@@@@Z
.text:00008948 ?CreateOutArchive@CCodecs@@QBEJIAAV?$CMyComPtr@UIOutArchive@@@@@Z proc near
.text:00008948                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+FCp
.text:00008948
.text:00008948 var_20          = dword ptr -20h
.text:00008948 var_1C          = dword ptr -1Ch
.text:00008948 var_18          = dword ptr -18h
.text:00008948 var_14          = dword ptr -14h
.text:00008948 var_10          = dword ptr -10h
.text:00008948 var_C           = dword ptr -0Ch
.text:00008948 var_4           = dword ptr -4
.text:00008948 arg_0           = dword ptr  8
.text:00008948 arg_4           = dword ptr  0Ch
.text:00008948
.text:00008948 ; FUNCTION CHUNK AT .text:000089EB SIZE 0000001E BYTES
.text:00008948
.text:00008948                 push    ebp
.text:00008949                 mov     ebp, esp
.text:0000894B                 push    0FFFFFFFFh
.text:0000894D                 push    offset __ehhandler$?CreateOutArchive@CCodecs@@QBEJIAAV?$CMyComPtr@UIOutArchive@@@@@Z
.text:00008952                 mov     eax, large fs:0
.text:00008958                 push    eax
.text:00008959                 push    ecx
.text:0000895A                 sub     esp, 10h
.text:0000895D                 push    ebx
.text:0000895E                 push    esi
.text:0000895F                 push    edi
.text:00008960                 mov     eax, 0CCCCCCCCh
.text:00008965                 mov     [ebp+var_20], eax
.text:00008968                 mov     [ebp+var_1C], eax
.text:0000896B                 mov     [ebp+var_18], eax
.text:0000896E                 mov     [ebp+var_14], eax
.text:00008971                 mov     eax, dword ptr ds:___security_cookie
.text:00008976                 xor     eax, ebp
.text:00008978                 push    eax
.text:00008979                 lea     eax, [ebp+var_C]
.text:0000897C                 mov     large fs:0, eax
.text:00008982                 mov     [ebp+var_10], esp
.text:00008985                 mov     [ebp+var_14], ecx
.text:00008988                 mov     eax, [ebp+arg_0]
.text:0000898B                 push    eax
.text:0000898C                 mov     ecx, [ebp+var_14]
.text:0000898F                 add     ecx, 8
.text:00008992                 call    ??A?$CObjectVector@UCArcInfoEx@@@@QBEABUCArcInfoEx@@I@Z ; CObjectVector<CArcInfoEx>::operator[](uint)
.text:00008997                 mov     [ebp+var_18], eax
.text:0000899A                 mov     [ebp+var_4], 0
.text:000089A1                 mov     ecx, [ebp+var_18]
.text:000089A4                 mov     esi, esp
.text:000089A6                 mov     edx, [ecx+24h]
.text:000089A9                 call    edx
.text:000089AB                 cmp     esi, esp
.text:000089AD                 call    __RTC_CheckEsp
.text:000089B2                 mov     [ebp+var_20], eax
.text:000089B5                 mov     eax, [ebp+var_20]
.text:000089B8                 push    eax
.text:000089B9                 mov     ecx, [ebp+arg_4]
.text:000089BC                 call    ??4?$CMyComPtr@UIOutArchive@@@@QAEPAUIOutArchive@@PAU1@@Z ; CMyComPtr<IOutArchive>::operator=(IOutArchive *)
.text:000089C1                 xor     eax, eax
.text:000089C3                 jmp     short loc_89EB
.text:000089C3 ?CreateOutArchive@CCodecs@@QBEJIAAV?$CMyComPtr@UIOutArchive@@@@@Z endp
.text:000089C3
.text:000089C5
.text:000089C5 ; =============== S U B R O U T I N E =======================================
.text:000089C5
.text:000089C5
.text:000089C5 __catch$?CreateOutArchive@CCodecs@@QBEJIAAV?$CMyComPtr@UIOutArchive@@@@@Z$0 proc near
.text:000089C5                                         ; DATA XREF: .xdata$x:00008A34o
.text:000089C5                 mov     dword ptr [ebp-1Ch], 8007000Eh
.text:000089CC                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text:000089D3                 mov     eax, offset $LN7_2
.text:000089D8                 retn
.text:000089D8 __catch$?CreateOutArchive@CCodecs@@QBEJIAAV?$CMyComPtr@UIOutArchive@@@@@Z$0 endp
.text:000089D8
.text:000089D9 ; ---------------------------------------------------------------------------
.text:000089D9                 mov     eax, offset __tryend$?CreateOutArchive@CCodecs@@QBEJIAAV?$CMyComPtr@UIOutArchive@@@@@Z$1
.text:000089DE                 retn
.text:000089DF ; ---------------------------------------------------------------------------
.text:000089DF
.text:000089DF __tryend$?CreateOutArchive@CCodecs@@QBEJIAAV?$CMyComPtr@UIOutArchive@@@@@Z$1:
.text:000089DF                                         ; DATA XREF: .text:000089D9o
.text:000089DF                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text:000089E6                 jmp     short loc_89EB
.text:000089E8 ; ---------------------------------------------------------------------------
.text:000089E8
.text:000089E8 $LN7_2:                                 ; DATA XREF: __catch$?CreateOutArchive@CCodecs@@QBEJIAAV?$CMyComPtr@UIOutArchive@@@@@Z$0+Eo
.text:000089E8                 mov     eax, [ebp-1Ch]
.text:000089EB ; START OF FUNCTION CHUNK FOR ?CreateOutArchive@CCodecs@@QBEJIAAV?$CMyComPtr@UIOutArchive@@@@@Z
.text:000089EB
.text:000089EB loc_89EB:                               ; CODE XREF: CCodecs::CreateOutArchive(uint,CMyComPtr<IOutArchive> &)+7Bj
.text:000089EB                                         ; .text:000089E6j
.text:000089EB                 mov     ecx, [ebp+var_C]
.text:000089EE                 mov     large fs:0, ecx
.text:000089F5                 pop     ecx
.text:000089F6                 pop     edi
.text:000089F7                 pop     esi
.text:000089F8                 pop     ebx
.text:000089F9                 add     esp, 20h
.text:000089FC                 cmp     ebp, esp
.text:000089FE                 call    __RTC_CheckEsp
.text:00008A03                 mov     esp, ebp
.text:00008A05                 pop     ebp
.text:00008A06                 retn    8
.text:00008A06 ; END OF FUNCTION CHUNK FOR ?CreateOutArchive@CCodecs@@QBEJIAAV?$CMyComPtr@UIOutArchive@@@@@Z
.text:00008A06 ; ---------------------------------------------------------------------------
.text:00008A09                 align 4
.text:00008A09 _text           ends
.text:00008A09
.text$x:00008A0C ; ===========================================================================
.text$x:00008A0C
.text$x:00008A0C ; Segment type: Pure code
.text$x:00008A0C ; Segment permissions: Read/Execute
.text$x:00008A0C _text$x         segment para public 'CODE' use32
.text$x:00008A0C                 assume cs:_text$x
.text$x:00008A0C                 ;org 8A0Ch
.text$x:00008A0C ; COMDAT (pick associative to section at 8948)
.text$x:00008A0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00008A0C
.text$x:00008A0C ; =============== S U B R O U T I N E =======================================
.text$x:00008A0C
.text$x:00008A0C
.text$x:00008A0C __ehhandler$?CreateOutArchive@CCodecs@@QBEJIAAV?$CMyComPtr@UIOutArchive@@@@@Z proc near
.text$x:00008A0C                                         ; DATA XREF: CCodecs::CreateOutArchive(uint,CMyComPtr<IOutArchive> &)+5o
.text$x:00008A0C
.text$x:00008A0C arg_4           = dword ptr  8
.text$x:00008A0C
.text$x:00008A0C                 mov     edx, [esp+arg_4]
.text$x:00008A10                 lea     eax, [edx+0Ch]
.text$x:00008A13                 mov     ecx, [edx-24h]
.text$x:00008A16                 xor     ecx, eax
.text$x:00008A18                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008A1D                 mov     eax, offset __ehfuncinfo$?CreateOutArchive@CCodecs@@QBEJIAAV?$CMyComPtr@UIOutArchive@@@@@Z
.text$x:00008A22                 jmp     ___CxxFrameHandler3
.text$x:00008A22 __ehhandler$?CreateOutArchive@CCodecs@@QBEJIAAV?$CMyComPtr@UIOutArchive@@@@@Z endp
.text$x:00008A22
.text$x:00008A22 ; ---------------------------------------------------------------------------
.text$x:00008A27                 align 4
.text$x:00008A27 _text$x         ends
.text$x:00008A27
.xdata$x:00008A28 ; ===========================================================================
.xdata$x:00008A28
.xdata$x:00008A28 ; Segment type: Pure data
.xdata$x:00008A28 ; Segment permissions: Read
.xdata$x:00008A28 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008A28                 assume cs:_xdata$x
.xdata$x:00008A28                 ;org 8A28h
.xdata$x:00008A28 ; COMDAT (pick associative to section at 8948)
.xdata$x:00008A28 __catchsym$?CreateOutArchive@CCodecs@@QBEJIAAV?$CMyComPtr@UIOutArchive@@@@@Z$2 dd offset $SG74378
.xdata$x:00008A28                                         ; DATA XREF: .xdata$x:00008A58o
.xdata$x:00008A28                                         ; ".tmp"
.xdata$x:00008A2C                 db    0
.xdata$x:00008A2D                 db    0
.xdata$x:00008A2E                 db    0
.xdata$x:00008A2F                 db    0
.xdata$x:00008A30                 db    0
.xdata$x:00008A31                 db    0
.xdata$x:00008A32                 db    0
.xdata$x:00008A33                 db    0
.xdata$x:00008A34                 dd offset __catch$?CreateOutArchive@CCodecs@@QBEJIAAV?$CMyComPtr@UIOutArchive@@@@@Z$0
.xdata$x:00008A38 __unwindtable$?CreateOutArchive@CCodecs@@QBEJIAAV?$CMyComPtr@UIOutArchive@@@@@Z db 0FFh
.xdata$x:00008A38                                         ; DATA XREF: .xdata$x:00008A64o
.xdata$x:00008A39                 db 0FFh
.xdata$x:00008A3A                 db 0FFh
.xdata$x:00008A3B                 db 0FFh
.xdata$x:00008A3C                 db    0
.xdata$x:00008A3D                 db    0
.xdata$x:00008A3E                 db    0
.xdata$x:00008A3F                 db    0
.xdata$x:00008A40                 db 0FFh
.xdata$x:00008A41                 db 0FFh
.xdata$x:00008A42                 db 0FFh
.xdata$x:00008A43                 db 0FFh
.xdata$x:00008A44                 db    0
.xdata$x:00008A45                 db    0
.xdata$x:00008A46                 db    0
.xdata$x:00008A47                 db    0
.xdata$x:00008A48 __tryblocktable$?CreateOutArchive@CCodecs@@QBEJIAAV?$CMyComPtr@UIOutArchive@@@@@Z db    0
.xdata$x:00008A48                                         ; DATA XREF: .xdata$x:00008A6Co
.xdata$x:00008A49                 db    0
.xdata$x:00008A4A                 db    0
.xdata$x:00008A4B                 db    0
.xdata$x:00008A4C                 db    0
.xdata$x:00008A4D                 db    0
.xdata$x:00008A4E                 db    0
.xdata$x:00008A4F                 db    0
.xdata$x:00008A50                 db    1
.xdata$x:00008A51                 db    0
.xdata$x:00008A52                 db    0
.xdata$x:00008A53                 db    0
.xdata$x:00008A54                 db    1
.xdata$x:00008A55                 db    0
.xdata$x:00008A56                 db    0
.xdata$x:00008A57                 db    0
.xdata$x:00008A58                 dd offset __catchsym$?CreateOutArchive@CCodecs@@QBEJIAAV?$CMyComPtr@UIOutArchive@@@@@Z$2
.xdata$x:00008A5C __ehfuncinfo$?CreateOutArchive@CCodecs@@QBEJIAAV?$CMyComPtr@UIOutArchive@@@@@Z db  22h ; "
.xdata$x:00008A5C                                         ; DATA XREF: __ehhandler$?CreateOutArchive@CCodecs@@QBEJIAAV?$CMyComPtr@UIOutArchive@@@@@Z+11o
.xdata$x:00008A5D                 db    5
.xdata$x:00008A5E                 db  93h ; 
.xdata$x:00008A5F                 db  19h
.xdata$x:00008A60                 db    2
.xdata$x:00008A61                 db    0
.xdata$x:00008A62                 db    0
.xdata$x:00008A63                 db    0
.xdata$x:00008A64                 dd offset __unwindtable$?CreateOutArchive@CCodecs@@QBEJIAAV?$CMyComPtr@UIOutArchive@@@@@Z
.xdata$x:00008A68                 db    1
.xdata$x:00008A69                 db    0
.xdata$x:00008A6A                 db    0
.xdata$x:00008A6B                 db    0
.xdata$x:00008A6C                 dd offset __tryblocktable$?CreateOutArchive@CCodecs@@QBEJIAAV?$CMyComPtr@UIOutArchive@@@@@Z
.xdata$x:00008A70                 db    0
.xdata$x:00008A71                 db    0
.xdata$x:00008A72                 db    0
.xdata$x:00008A73                 db    0
.xdata$x:00008A74                 db    0
.xdata$x:00008A75                 db    0
.xdata$x:00008A76                 db    0
.xdata$x:00008A77                 db    0
.xdata$x:00008A78                 db    0
.xdata$x:00008A79                 db    0
.xdata$x:00008A7A                 db    0
.xdata$x:00008A7B                 db    0
.xdata$x:00008A7C                 db    1
.xdata$x:00008A7D                 db    0
.xdata$x:00008A7E                 db    0
.xdata$x:00008A7F                 db    0
.xdata$x:00008A7F _xdata$x        ends
.xdata$x:00008A7F
.text:00008A80 ; ===========================================================================
.text:00008A80
.text:00008A80 ; Segment type: Pure code
.text:00008A80 ; Segment permissions: Read/Execute
.text:00008A80 _text           segment para public 'CODE' use32
.text:00008A80                 assume cs:_text
.text:00008A80                 ;org 8A80h
.text:00008A80 ; COMDAT (pick any)
.text:00008A80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008A80
.text:00008A80 ; =============== S U B R O U T I N E =======================================
.text:00008A80
.text:00008A80 ; Attributes: bp-based frame
.text:00008A80
.text:00008A80 ; __int64 __thiscall CArc::GetGlobalOffset(CArc *__hidden this)
.text:00008A80                 public ?GetGlobalOffset@CArc@@QBE_JXZ
.text:00008A80 ?GetGlobalOffset@CArc@@QBE_JXZ proc near
.text:00008A80                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+CB4p
.text:00008A80
.text:00008A80 var_4           = dword ptr -4
.text:00008A80
.text:00008A80                 push    ebp
.text:00008A81                 mov     ebp, esp
.text:00008A83                 push    ecx
.text:00008A84                 push    esi
.text:00008A85                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00008A8C                 mov     [ebp+var_4], ecx
.text:00008A8F                 mov     eax, [ebp+var_4]
.text:00008A92                 mov     ecx, [ebp+var_4]
.text:00008A95                 mov     edx, [eax+0D0h]
.text:00008A9B                 add     edx, [ecx+0A8h]
.text:00008AA1                 mov     esi, [eax+0D4h]
.text:00008AA7                 adc     esi, [ecx+0ACh]
.text:00008AAD                 mov     eax, edx
.text:00008AAF                 mov     edx, esi
.text:00008AB1                 pop     esi
.text:00008AB2                 mov     esp, ebp
.text:00008AB4                 pop     ebp
.text:00008AB5                 retn
.text:00008AB5 ?GetGlobalOffset@CArc@@QBE_JXZ endp
.text:00008AB5
.text:00008AB5 ; ---------------------------------------------------------------------------
.text:00008AB6                 align 4
.text:00008AB6 _text           ends
.text:00008AB6
.text:00008AB8 ; ===========================================================================
.text:00008AB8
.text:00008AB8 ; Segment type: Pure code
.text:00008AB8 ; Segment permissions: Read/Execute
.text:00008AB8 _text           segment para public 'CODE' use32
.text:00008AB8                 assume cs:_text
.text:00008AB8                 ;org 8AB8h
.text:00008AB8 ; COMDAT (pick any)
.text:00008AB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008AB8
.text:00008AB8 ; =============== S U B R O U T I N E =======================================
.text:00008AB8
.text:00008AB8 ; Attributes: bp-based frame
.text:00008AB8
.text:00008AB8 ; __int32 __thiscall CArc::IsItemAnti(CArc *this, unsigned int, bool *)
.text:00008AB8                 public ?IsItemAnti@CArc@@QBEJIAA_N@Z
.text:00008AB8 ?IsItemAnti@CArc@@QBEJIAA_N@Z proc near ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+498p
.text:00008AB8
.text:00008AB8 var_4           = dword ptr -4
.text:00008AB8 arg_0           = dword ptr  8
.text:00008AB8 arg_4           = dword ptr  0Ch
.text:00008AB8
.text:00008AB8                 push    ebp
.text:00008AB9                 mov     ebp, esp
.text:00008ABB                 push    ecx
.text:00008ABC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00008AC3                 mov     [ebp+var_4], ecx
.text:00008AC6                 mov     eax, [ebp+arg_4]
.text:00008AC9                 push    eax             ; bool *
.text:00008ACA                 push    15h             ; unsigned __int32
.text:00008ACC                 mov     ecx, [ebp+arg_0]
.text:00008ACF                 push    ecx             ; unsigned int
.text:00008AD0                 mov     ecx, [ebp+var_4]
.text:00008AD3                 call    ??B?$CMyComPtr@UIInArchive@@@@QBEPAUIInArchive@@XZ ; CMyComPtr<IInArchive>::operator IInArchive *(void)
.text:00008AD8                 push    eax             ; struct IInArchive *
.text:00008AD9                 call    ?Archive_GetItemBoolProp@@YGJPAUIInArchive@@IKAA_N@Z ; Archive_GetItemBoolProp(IInArchive *,uint,ulong,bool &)
.text:00008ADE                 add     esp, 4
.text:00008AE1                 cmp     ebp, esp
.text:00008AE3                 call    __RTC_CheckEsp
.text:00008AE8                 mov     esp, ebp
.text:00008AEA                 pop     ebp
.text:00008AEB                 retn    8
.text:00008AEB ?IsItemAnti@CArc@@QBEJIAA_N@Z endp
.text:00008AEB
.text:00008AEB ; ---------------------------------------------------------------------------
.text:00008AEE                 align 10h
.text:00008AEE _text           ends
.text:00008AEE
.text:00008AF0 ; ===========================================================================
.text:00008AF0
.text:00008AF0 ; Segment type: Pure code
.text:00008AF0 ; Segment permissions: Read/Execute
.text:00008AF0 _text           segment para public 'CODE' use32
.text:00008AF0                 assume cs:_text
.text:00008AF0                 ;org 8AF0h
.text:00008AF0 ; COMDAT (pick any)
.text:00008AF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008AF0
.text:00008AF0 ; =============== S U B R O U T I N E =======================================
.text:00008AF0
.text:00008AF0 ; Attributes: bp-based frame
.text:00008AF0
.text:00008AF0 ; bool __thiscall CInFileStream::Open(CInFileStream *this, const wchar_t *)
.text:00008AF0                 public ?Open@CInFileStream@@QAE_NPB_W@Z
.text:00008AF0 ?Open@CInFileStream@@QAE_NPB_W@Z proc near
.text:00008AF0                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+F6Bp
.text:00008AF0
.text:00008AF0 var_4           = dword ptr -4
.text:00008AF0 arg_0           = dword ptr  8
.text:00008AF0
.text:00008AF0                 push    ebp
.text:00008AF1                 mov     ebp, esp
.text:00008AF3                 push    ecx
.text:00008AF4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00008AFB                 mov     [ebp+var_4], ecx
.text:00008AFE                 mov     eax, [ebp+arg_0]
.text:00008B01                 push    eax             ; wchar_t *
.text:00008B02                 mov     ecx, [ebp+var_4]
.text:00008B05                 add     ecx, 18h        ; this
.text:00008B08                 call    ?Open@CInFile@NIO@NFile@NWindows@@QAE_NPB_W@Z ; NWindows::NFile::NIO::CInFile::Open(wchar_t const *)
.text:00008B0D                 add     esp, 4
.text:00008B10                 cmp     ebp, esp
.text:00008B12                 call    __RTC_CheckEsp
.text:00008B17                 mov     esp, ebp
.text:00008B19                 pop     ebp
.text:00008B1A                 retn    4
.text:00008B1A ?Open@CInFileStream@@QAE_NPB_W@Z endp
.text:00008B1A
.text:00008B1A ; ---------------------------------------------------------------------------
.text:00008B1D                 align 10h
.text:00008B1D _text           ends
.text:00008B1D
.text:00008B20 ; ===========================================================================
.text:00008B20
.text:00008B20 ; Segment type: Pure code
.text:00008B20 ; Segment permissions: Read/Execute
.text:00008B20 _text           segment para public 'CODE' use32
.text:00008B20                 assume cs:_text
.text:00008B20                 ;org 8B20h
.text:00008B20 ; COMDAT (pick any)
.text:00008B20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008B20
.text:00008B20 ; =============== S U B R O U T I N E =======================================
.text:00008B20
.text:00008B20 ; Attributes: bp-based frame
.text:00008B20
.text:00008B20 ; unsigned __int64 __thiscall CStdOutFileStream::GetSize(CStdOutFileStream *__hidden this)
.text:00008B20                 public ?GetSize@CStdOutFileStream@@QBE_KXZ
.text:00008B20 ?GetSize@CStdOutFileStream@@QBE_KXZ proc near
.text:00008B20                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+1AA4p
.text:00008B20
.text:00008B20 var_4           = dword ptr -4
.text:00008B20
.text:00008B20                 push    ebp
.text:00008B21                 mov     ebp, esp
.text:00008B23                 push    ecx
.text:00008B24                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00008B2B                 mov     [ebp+var_4], ecx
.text:00008B2E                 mov     ecx, [ebp+var_4]
.text:00008B31                 mov     eax, [ecx+8]
.text:00008B34                 mov     edx, [ecx+0Ch]
.text:00008B37                 mov     esp, ebp
.text:00008B39                 pop     ebp
.text:00008B3A                 retn
.text:00008B3A ?GetSize@CStdOutFileStream@@QBE_KXZ endp
.text:00008B3A
.text:00008B3A ; ---------------------------------------------------------------------------
.text:00008B3B                 align 4
.text:00008B3B _text           ends
.text:00008B3B
.text:00008B3C ; ===========================================================================
.text:00008B3C
.text:00008B3C ; Segment type: Pure code
.text:00008B3C ; Segment permissions: Read/Execute
.text:00008B3C _text           segment para public 'CODE' use32
.text:00008B3C                 assume cs:_text
.text:00008B3C                 ;org 8B3Ch
.text:00008B3C ; COMDAT (pick any)
.text:00008B3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008B3C
.text:00008B3C ; =============== S U B R O U T I N E =======================================
.text:00008B3C
.text:00008B3C ; Attributes: bp-based frame
.text:00008B3C
.text:00008B3C ; public: __thiscall CStdOutFileStream::CStdOutFileStream(void)
.text:00008B3C                 public ??0CStdOutFileStream@@QAE@XZ
.text:00008B3C ??0CStdOutFileStream@@QAE@XZ proc near  ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+954p
.text:00008B3C
.text:00008B3C var_4           = dword ptr -4
.text:00008B3C
.text:00008B3C                 push    ebp
.text:00008B3D                 mov     ebp, esp
.text:00008B3F                 push    ecx
.text:00008B40                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00008B47                 mov     [ebp+var_4], ecx
.text:00008B4A                 mov     ecx, [ebp+var_4] ; this
.text:00008B4D                 call    ??0ISequentialOutStream@@QAE@XZ ; ISequentialOutStream::ISequentialOutStream(void)
.text:00008B52                 mov     ecx, [ebp+var_4]
.text:00008B55                 add     ecx, 4          ; this
.text:00008B58                 call    ??0CMyUnknownImp@@QAE@XZ ; CMyUnknownImp::CMyUnknownImp(void)
.text:00008B5D                 mov     eax, [ebp+var_4]
.text:00008B60                 mov     dword ptr [eax], offset ??_7CStdOutFileStream@@6B@ ; const CStdOutFileStream::`vftable'
.text:00008B66                 mov     ecx, [ebp+var_4]
.text:00008B69                 mov     dword ptr [ecx+8], 0
.text:00008B70                 mov     dword ptr [ecx+0Ch], 0
.text:00008B77                 mov     eax, [ebp+var_4]
.text:00008B7A                 add     esp, 4
.text:00008B7D                 cmp     ebp, esp
.text:00008B7F                 call    __RTC_CheckEsp
.text:00008B84                 mov     esp, ebp
.text:00008B86                 pop     ebp
.text:00008B87                 retn
.text:00008B87 ??0CStdOutFileStream@@QAE@XZ endp
.text:00008B87
.text:00008B87 _text           ends
.text:00008B87
.rdata:00008B88 ; ===========================================================================
.rdata:00008B88
.rdata:00008B88 ; Segment type: Pure data
.rdata:00008B88 ; Segment permissions: Read
.rdata:00008B88 _rdata          segment dword public 'DATA' use32
.rdata:00008B88                 assume cs:_rdata
.rdata:00008B88                 ;org 8B88h
.rdata:00008B88 ; COMDAT (pick largest)
.rdata:00008B88                 dd offset ??_R4CStdOutFileStream@@6B@ ; const CStdOutFileStream::`RTTI Complete Object Locator'
.rdata:00008B8C                 public ??_7CStdOutFileStream@@6B@
.rdata:00008B8C ; const CStdOutFileStream::`vftable'
.rdata:00008B8C ??_7CStdOutFileStream@@6B@ dd offset ?QueryInterface@CStdOutFileStream@@UAGJABU_GUID@@PAPAX@Z
.rdata:00008B8C                                         ; DATA XREF: CStdOutFileStream::CStdOutFileStream(void)+24o
.rdata:00008B8C                                         ; CStdOutFileStream::~CStdOutFileStream(void)+11o
.rdata:00008B8C                                         ; CStdOutFileStream::QueryInterface(_GUID const &,void * *)
.rdata:00008B90                 dd offset ?AddRef@CStdOutFileStream@@UAGKXZ ; CStdOutFileStream::AddRef(void)
.rdata:00008B94                 dd offset ?Release@CStdOutFileStream@@UAGKXZ ; CStdOutFileStream::Release(void)
.rdata:00008B98                 dd offset ?Write@CStdOutFileStream@@UAGJPBXIPAI@Z ; CStdOutFileStream::Write(void const *,uint,uint *)
.rdata:00008B9C                 dd offset ??_ECStdOutFileStream@@UAEPAXI@Z ; CStdOutFileStream::`vector deleting destructor'(uint)
.rdata:00008B9C _rdata          ends
.rdata:00008B9C
.rdata$r:00008BA0 ; ===========================================================================
.rdata$r:00008BA0
.rdata$r:00008BA0 ; Segment type: Pure data
.rdata$r:00008BA0 ; Segment permissions: Read
.rdata$r:00008BA0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00008BA0                 assume cs:_rdata$r
.rdata$r:00008BA0                 ;org 8BA0h
.rdata$r:00008BA0 ; COMDAT (pick any)
.rdata$r:00008BA0                 public ??_R4CStdOutFileStream@@6B@
.rdata$r:00008BA0 ; const CStdOutFileStream::`RTTI Complete Object Locator'
.rdata$r:00008BA0 ??_R4CStdOutFileStream@@6B@ db    0     ; DATA XREF: .rdata:00008B88o
.rdata$r:00008BA1                 db    0
.rdata$r:00008BA2                 db    0
.rdata$r:00008BA3                 db    0
.rdata$r:00008BA4                 db    0
.rdata$r:00008BA5                 db    0
.rdata$r:00008BA6                 db    0
.rdata$r:00008BA7                 db    0
.rdata$r:00008BA8                 db    0
.rdata$r:00008BA9                 db    0
.rdata$r:00008BAA                 db    0
.rdata$r:00008BAB                 db    0
.rdata$r:00008BAC                 dd offset ??_R0?AVCStdOutFileStream@@@8 ; CStdOutFileStream `RTTI Type Descriptor'
.rdata$r:00008BB0                 dd offset ??_R3CStdOutFileStream@@8 ; CStdOutFileStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00008BB0 _rdata$r        ends
.rdata$r:00008BB0
.data:00008BB4 ; ===========================================================================
.data:00008BB4
.data:00008BB4 ; Segment type: Pure data
.data:00008BB4 ; Segment permissions: Read/Write
.data:00008BB4 _data           segment dword public 'DATA' use32
.data:00008BB4                 assume cs:_data
.data:00008BB4                 ;org 8BB4h
.data:00008BB4 ; COMDAT (pick any)
.data:00008BB4                 public ??_R0?AVCStdOutFileStream@@@8
.data:00008BB4 ; class CStdOutFileStream `RTTI Type Descriptor'
.data:00008BB4 ??_R0?AVCStdOutFileStream@@@8 dd offset ??_7type_info@@6B@
.data:00008BB4                                         ; DATA XREF: .rdata$r:00008BACo
.data:00008BB4                                         ; .rdata$r:CStdOutFileStream::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:00008BB4                                         ; const type_info::`vftable'
.data:00008BB8                 db    0
.data:00008BB9                 db    0
.data:00008BBA                 db    0
.data:00008BBB                 db    0
.data:00008BBC                 db  2Eh ; .
.data:00008BBD                 db  3Fh ; ?
.data:00008BBE                 db  41h ; A
.data:00008BBF                 db  56h ; V
.data:00008BC0                 db  43h ; C
.data:00008BC1                 db  53h ; S
.data:00008BC2                 db  74h ; t
.data:00008BC3                 db  64h ; d
.data:00008BC4                 db  4Fh ; O
.data:00008BC5                 db  75h ; u
.data:00008BC6                 db  74h ; t
.data:00008BC7                 db  46h ; F
.data:00008BC8                 db  69h ; i
.data:00008BC9                 db  6Ch ; l
.data:00008BCA                 db  65h ; e
.data:00008BCB                 db  53h ; S
.data:00008BCC                 db  74h ; t
.data:00008BCD                 db  72h ; r
.data:00008BCE                 db  65h ; e
.data:00008BCF                 db  61h ; a
.data:00008BD0                 db  6Dh ; m
.data:00008BD1                 db  40h ; @
.data:00008BD2                 db  40h ; @
.data:00008BD3                 db    0
.data:00008BD3 _data           ends
.data:00008BD3
.rdata$r:00008BD4 ; ===========================================================================
.rdata$r:00008BD4
.rdata$r:00008BD4 ; Segment type: Pure data
.rdata$r:00008BD4 ; Segment permissions: Read
.rdata$r:00008BD4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00008BD4                 assume cs:_rdata$r
.rdata$r:00008BD4                 ;org 8BD4h
.rdata$r:00008BD4 ; COMDAT (pick any)
.rdata$r:00008BD4                 public ??_R3CStdOutFileStream@@8
.rdata$r:00008BD4 ; CStdOutFileStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00008BD4 ??_R3CStdOutFileStream@@8 db    0       ; DATA XREF: .rdata$r:00008BB0o
.rdata$r:00008BD4                                         ; .rdata$r:00008C10o
.rdata$r:00008BD5                 db    0
.rdata$r:00008BD6                 db    0
.rdata$r:00008BD7                 db    0
.rdata$r:00008BD8                 db    1
.rdata$r:00008BD9                 db    0
.rdata$r:00008BDA                 db    0
.rdata$r:00008BDB                 db    0
.rdata$r:00008BDC                 db    4
.rdata$r:00008BDD                 db    0
.rdata$r:00008BDE                 db    0
.rdata$r:00008BDF                 db    0
.rdata$r:00008BE0                 dd offset ??_R2CStdOutFileStream@@8 ; CStdOutFileStream::`RTTI Base Class Array'
.rdata$r:00008BE0 _rdata$r        ends
.rdata$r:00008BE0
.rdata$r:00008BE4 ; ===========================================================================
.rdata$r:00008BE4
.rdata$r:00008BE4 ; Segment type: Pure data
.rdata$r:00008BE4 ; Segment permissions: Read
.rdata$r:00008BE4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00008BE4                 assume cs:_rdata$r
.rdata$r:00008BE4                 ;org 8BE4h
.rdata$r:00008BE4 ; COMDAT (pick any)
.rdata$r:00008BE4                 public ??_R2CStdOutFileStream@@8
.rdata$r:00008BE4 ; CStdOutFileStream::`RTTI Base Class Array'
.rdata$r:00008BE4 ??_R2CStdOutFileStream@@8 dd offset ??_R1A@?0A@EA@CStdOutFileStream@@8
.rdata$r:00008BE4                                         ; DATA XREF: .rdata$r:00008BE0o
.rdata$r:00008BE4                                         ; CStdOutFileStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00008BE8                 dd offset ??_R1A@?0A@EA@ISequentialOutStream@@8 ; ISequentialOutStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00008BEC                 dd offset ??_R1A@?0A@EA@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00008BF0                 dd offset ??_R13?0A@EA@CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Base Class Descriptor at (4,-1,0,64)'
.rdata$r:00008BF4                 db    0
.rdata$r:00008BF5                 align 4
.rdata$r:00008BF5 _rdata$r        ends
.rdata$r:00008BF5
.rdata$r:00008BF8 ; ===========================================================================
.rdata$r:00008BF8
.rdata$r:00008BF8 ; Segment type: Pure data
.rdata$r:00008BF8 ; Segment permissions: Read
.rdata$r:00008BF8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00008BF8                 assume cs:_rdata$r
.rdata$r:00008BF8                 ;org 8BF8h
.rdata$r:00008BF8 ; COMDAT (pick any)
.rdata$r:00008BF8                 public ??_R1A@?0A@EA@CStdOutFileStream@@8
.rdata$r:00008BF8 ; CStdOutFileStream::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00008BF8 ??_R1A@?0A@EA@CStdOutFileStream@@8 dd offset ??_R0?AVCStdOutFileStream@@@8
.rdata$r:00008BF8                                         ; DATA XREF: .rdata$r:CStdOutFileStream::`RTTI Base Class Array'o
.rdata$r:00008BF8                                         ; CStdOutFileStream `RTTI Type Descriptor'
.rdata$r:00008BFC                 db    3
.rdata$r:00008BFD                 db    0
.rdata$r:00008BFE                 db    0
.rdata$r:00008BFF                 db    0
.rdata$r:00008C00                 db    0
.rdata$r:00008C01                 db    0
.rdata$r:00008C02                 db    0
.rdata$r:00008C03                 db    0
.rdata$r:00008C04                 db 0FFh
.rdata$r:00008C05                 db 0FFh
.rdata$r:00008C06                 db 0FFh
.rdata$r:00008C07                 db 0FFh
.rdata$r:00008C08                 db    0
.rdata$r:00008C09                 db    0
.rdata$r:00008C0A                 db    0
.rdata$r:00008C0B                 db    0
.rdata$r:00008C0C                 db  40h ; @
.rdata$r:00008C0D                 db    0
.rdata$r:00008C0E                 db    0
.rdata$r:00008C0F                 db    0
.rdata$r:00008C10                 dd offset ??_R3CStdOutFileStream@@8 ; CStdOutFileStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00008C10 _rdata$r        ends
.rdata$r:00008C10
.text:00008C14 ; ===========================================================================
.text:00008C14
.text:00008C14 ; Segment type: Pure code
.text:00008C14 ; Segment permissions: Read/Execute
.text:00008C14 _text           segment para public 'CODE' use32
.text:00008C14                 assume cs:_text
.text:00008C14                 ;org 8C14h
.text:00008C14 ; COMDAT (pick any)
.text:00008C14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008C14
.text:00008C14 ; =============== S U B R O U T I N E =======================================
.text:00008C14
.text:00008C14 ; Attributes: bp-based frame
.text:00008C14
.text:00008C14 ; __int32 __stdcall CStdOutFileStream::QueryInterface(CStdOutFileStream *this, const struct _GUID *Buf1, void **)
.text:00008C14                 public ?QueryInterface@CStdOutFileStream@@UAGJABU_GUID@@PAPAX@Z
.text:00008C14 ?QueryInterface@CStdOutFileStream@@UAGJABU_GUID@@PAPAX@Z proc near
.text:00008C14                                         ; DATA XREF: .rdata:const CStdOutFileStream::`vftable'o
.text:00008C14
.text:00008C14 this            = dword ptr  8
.text:00008C14 Buf1            = dword ptr  0Ch
.text:00008C14 arg_8           = dword ptr  10h
.text:00008C14
.text:00008C14                 push    ebp
.text:00008C15                 mov     ebp, esp
.text:00008C17                 mov     eax, [ebp+arg_8]
.text:00008C1A                 mov     dword ptr [eax], 0
.text:00008C20                 push    offset _IID_IUnknown ; Buf2
.text:00008C25                 mov     ecx, [ebp+Buf1]
.text:00008C28                 push    ecx             ; Buf1
.text:00008C29                 call    ___@8           ; __(x,x)
.text:00008C2E                 test    eax, eax
.text:00008C30                 jz      short loc_8C3C
.text:00008C32                 mov     edx, [ebp+arg_8]
.text:00008C35                 mov     eax, [ebp+this]
.text:00008C38                 mov     [edx], eax
.text:00008C3A                 jmp     short loc_8C43
.text:00008C3C ; ---------------------------------------------------------------------------
.text:00008C3C
.text:00008C3C loc_8C3C:                               ; CODE XREF: CStdOutFileStream::QueryInterface(_GUID const &,void * *)+1Cj
.text:00008C3C                 mov     eax, 80004002h
.text:00008C41                 jmp     short loc_8C54
.text:00008C43 ; ---------------------------------------------------------------------------
.text:00008C43
.text:00008C43 loc_8C43:                               ; CODE XREF: CStdOutFileStream::QueryInterface(_GUID const &,void * *)+26j
.text:00008C43                 mov     ecx, [ebp+this]
.text:00008C46                 mov     edx, [ecx+4]
.text:00008C49                 add     edx, 1
.text:00008C4C                 mov     eax, [ebp+this]
.text:00008C4F                 mov     [eax+4], edx
.text:00008C52                 xor     eax, eax
.text:00008C54
.text:00008C54 loc_8C54:                               ; CODE XREF: CStdOutFileStream::QueryInterface(_GUID const &,void * *)+2Dj
.text:00008C54                 cmp     ebp, esp
.text:00008C56                 call    __RTC_CheckEsp
.text:00008C5B                 pop     ebp
.text:00008C5C                 retn    0Ch
.text:00008C5C ?QueryInterface@CStdOutFileStream@@UAGJABU_GUID@@PAPAX@Z endp
.text:00008C5C
.text:00008C5C ; ---------------------------------------------------------------------------
.text:00008C5F                 align 10h
.text:00008C5F _text           ends
.text:00008C5F
.text:00008C60 ; ===========================================================================
.text:00008C60
.text:00008C60 ; Segment type: Pure code
.text:00008C60 ; Segment permissions: Read/Execute
.text:00008C60 _text           segment para public 'CODE' use32
.text:00008C60                 assume cs:_text
.text:00008C60                 ;org 8C60h
.text:00008C60 ; COMDAT (pick any)
.text:00008C60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008C60
.text:00008C60 ; =============== S U B R O U T I N E =======================================
.text:00008C60
.text:00008C60 ; Attributes: bp-based frame
.text:00008C60
.text:00008C60 ; unsigned __int32 __stdcall CStdOutFileStream::AddRef(CStdOutFileStream *this)
.text:00008C60                 public ?AddRef@CStdOutFileStream@@UAGKXZ
.text:00008C60 ?AddRef@CStdOutFileStream@@UAGKXZ proc near ; DATA XREF: .rdata:00008B90o
.text:00008C60
.text:00008C60 var_4           = dword ptr -4
.text:00008C60 this            = dword ptr  8
.text:00008C60
.text:00008C60                 push    ebp
.text:00008C61                 mov     ebp, esp
.text:00008C63                 push    ecx
.text:00008C64                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00008C6B                 mov     eax, [ebp+this]
.text:00008C6E                 mov     ecx, [eax+4]
.text:00008C71                 add     ecx, 1
.text:00008C74                 mov     [ebp+var_4], ecx
.text:00008C77                 mov     edx, [ebp+this]
.text:00008C7A                 mov     eax, [ebp+var_4]
.text:00008C7D                 mov     [edx+4], eax
.text:00008C80                 mov     eax, [ebp+var_4]
.text:00008C83                 mov     esp, ebp
.text:00008C85                 pop     ebp
.text:00008C86                 retn    4
.text:00008C86 ?AddRef@CStdOutFileStream@@UAGKXZ endp
.text:00008C86
.text:00008C86 ; ---------------------------------------------------------------------------
.text:00008C89                 align 4
.text:00008C89 _text           ends
.text:00008C89
.text:00008C8C ; ===========================================================================
.text:00008C8C
.text:00008C8C ; Segment type: Pure code
.text:00008C8C ; Segment permissions: Read/Execute
.text:00008C8C _text           segment para public 'CODE' use32
.text:00008C8C                 assume cs:_text
.text:00008C8C                 ;org 8C8Ch
.text:00008C8C ; COMDAT (pick any)
.text:00008C8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008C8C
.text:00008C8C ; =============== S U B R O U T I N E =======================================
.text:00008C8C
.text:00008C8C ; Attributes: bp-based frame
.text:00008C8C
.text:00008C8C ; unsigned __int32 __stdcall CStdOutFileStream::Release(CStdOutFileStream *this)
.text:00008C8C                 public ?Release@CStdOutFileStream@@UAGKXZ
.text:00008C8C ?Release@CStdOutFileStream@@UAGKXZ proc near ; DATA XREF: .rdata:00008B94o
.text:00008C8C
.text:00008C8C var_10          = dword ptr -10h
.text:00008C8C var_C           = dword ptr -0Ch
.text:00008C8C var_8           = dword ptr -8
.text:00008C8C var_4           = dword ptr -4
.text:00008C8C this            = dword ptr  8
.text:00008C8C
.text:00008C8C                 push    ebp
.text:00008C8D                 mov     ebp, esp
.text:00008C8F                 sub     esp, 10h
.text:00008C92                 push    esi
.text:00008C93                 mov     eax, 0CCCCCCCCh
.text:00008C98                 mov     [ebp+var_10], eax
.text:00008C9B                 mov     [ebp+var_C], eax
.text:00008C9E                 mov     [ebp+var_8], eax
.text:00008CA1                 mov     [ebp+var_4], eax
.text:00008CA4                 mov     eax, [ebp+this]
.text:00008CA7                 mov     ecx, [eax+4]
.text:00008CAA                 sub     ecx, 1
.text:00008CAD                 mov     [ebp+var_C], ecx
.text:00008CB0                 mov     edx, [ebp+this]
.text:00008CB3                 mov     eax, [ebp+var_C]
.text:00008CB6                 mov     [edx+4], eax
.text:00008CB9                 cmp     [ebp+var_C], 0
.text:00008CBD                 jz      short loc_8CC7
.text:00008CBF                 mov     ecx, [ebp+this]
.text:00008CC2                 mov     eax, [ecx+4]
.text:00008CC5                 jmp     short loc_8CFF
.text:00008CC7 ; ---------------------------------------------------------------------------
.text:00008CC7
.text:00008CC7 loc_8CC7:                               ; CODE XREF: CStdOutFileStream::Release(void)+31j
.text:00008CC7                 mov     edx, [ebp+this]
.text:00008CCA                 mov     [ebp+var_8], edx
.text:00008CCD                 mov     eax, [ebp+var_8]
.text:00008CD0                 mov     [ebp+var_4], eax
.text:00008CD3                 cmp     [ebp+var_4], 0
.text:00008CD7                 jz      short loc_8CF6
.text:00008CD9                 mov     esi, esp
.text:00008CDB                 push    1
.text:00008CDD                 mov     ecx, [ebp+var_4]
.text:00008CE0                 mov     edx, [ecx]
.text:00008CE2                 mov     ecx, [ebp+var_4]
.text:00008CE5                 mov     eax, [edx+10h]
.text:00008CE8                 call    eax
.text:00008CEA                 cmp     esi, esp
.text:00008CEC                 call    __RTC_CheckEsp
.text:00008CF1                 mov     [ebp+var_10], eax
.text:00008CF4                 jmp     short loc_8CFD
.text:00008CF6 ; ---------------------------------------------------------------------------
.text:00008CF6
.text:00008CF6 loc_8CF6:                               ; CODE XREF: CStdOutFileStream::Release(void)+4Bj
.text:00008CF6                 mov     [ebp+var_10], 0
.text:00008CFD
.text:00008CFD loc_8CFD:                               ; CODE XREF: CStdOutFileStream::Release(void)+68j
.text:00008CFD                 xor     eax, eax
.text:00008CFF
.text:00008CFF loc_8CFF:                               ; CODE XREF: CStdOutFileStream::Release(void)+39j
.text:00008CFF                 pop     esi
.text:00008D00                 add     esp, 10h
.text:00008D03                 cmp     ebp, esp
.text:00008D05                 call    __RTC_CheckEsp
.text:00008D0A                 mov     esp, ebp
.text:00008D0C                 pop     ebp
.text:00008D0D                 retn    4
.text:00008D0D ?Release@CStdOutFileStream@@UAGKXZ endp
.text:00008D0D
.text:00008D0D _text           ends
.text:00008D0D
.text:00008D10 ; ===========================================================================
.text:00008D10
.text:00008D10 ; Segment type: Pure code
.text:00008D10 ; Segment permissions: Read/Execute
.text:00008D10 _text           segment para public 'CODE' use32
.text:00008D10                 assume cs:_text
.text:00008D10                 ;org 8D10h
.text:00008D10 ; COMDAT (pick any)
.text:00008D10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008D10
.text:00008D10 ; =============== S U B R O U T I N E =======================================
.text:00008D10
.text:00008D10 ; Attributes: bp-based frame
.text:00008D10
.text:00008D10 ; public: virtual void * __thiscall CStdOutFileStream::`scalar deleting destructor'(unsigned int)
.text:00008D10                 public ??_GCStdOutFileStream@@UAEPAXI@Z
.text:00008D10 ??_GCStdOutFileStream@@UAEPAXI@Z proc near
.text:00008D10
.text:00008D10 var_4           = dword ptr -4
.text:00008D10 arg_0           = dword ptr  8
.text:00008D10
.text:00008D10                 push    ebp
.text:00008D11                 mov     ebp, esp
.text:00008D13                 push    ecx
.text:00008D14                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00008D1B                 mov     [ebp+var_4], ecx
.text:00008D1E                 mov     ecx, [ebp+var_4] ; this
.text:00008D21                 call    ??1CStdOutFileStream@@UAE@XZ ; CStdOutFileStream::~CStdOutFileStream(void)
.text:00008D26                 mov     eax, [ebp+arg_0]
.text:00008D29                 and     eax, 1
.text:00008D2C                 jz      short loc_8D3A
.text:00008D2E                 mov     ecx, [ebp+var_4]
.text:00008D31                 push    ecx             ; void *
.text:00008D32                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00008D37                 add     esp, 4
.text:00008D3A
.text:00008D3A loc_8D3A:                               ; CODE XREF: CStdOutFileStream::`scalar deleting destructor'(uint)+1Cj
.text:00008D3A                 mov     eax, [ebp+var_4]
.text:00008D3D                 add     esp, 4
.text:00008D40                 cmp     ebp, esp
.text:00008D42                 call    __RTC_CheckEsp
.text:00008D47                 mov     esp, ebp
.text:00008D49                 pop     ebp
.text:00008D4A                 retn    4
.text:00008D4A ??_GCStdOutFileStream@@UAEPAXI@Z endp
.text:00008D4A
.text:00008D4A ; ---------------------------------------------------------------------------
.text:00008D4D                 align 10h
.text:00008D4D _text           ends
.text:00008D4D
.text:00008D50 ; ===========================================================================
.text:00008D50
.text:00008D50 ; Segment type: Pure code
.text:00008D50 ; Segment permissions: Read/Execute
.text:00008D50 _text           segment para public 'CODE' use32
.text:00008D50                 assume cs:_text
.text:00008D50                 ;org 8D50h
.text:00008D50 ; COMDAT (pick any)
.text:00008D50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008D50
.text:00008D50 ; =============== S U B R O U T I N E =======================================
.text:00008D50
.text:00008D50 ; Attributes: bp-based frame
.text:00008D50
.text:00008D50 ; _DWORD __thiscall CStdOutFileStream::~CStdOutFileStream(CStdOutFileStream *__hidden this)
.text:00008D50                 public ??1CStdOutFileStream@@UAE@XZ
.text:00008D50 ??1CStdOutFileStream@@UAE@XZ proc near  ; CODE XREF: CStdOutFileStream::`scalar deleting destructor'(uint)+11p
.text:00008D50
.text:00008D50 var_4           = dword ptr -4
.text:00008D50
.text:00008D50                 push    ebp
.text:00008D51                 mov     ebp, esp
.text:00008D53                 push    ecx
.text:00008D54                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00008D5B                 mov     [ebp+var_4], ecx
.text:00008D5E                 mov     eax, [ebp+var_4]
.text:00008D61                 mov     dword ptr [eax], offset ??_7CStdOutFileStream@@6B@ ; const CStdOutFileStream::`vftable'
.text:00008D67                 mov     esp, ebp
.text:00008D69                 pop     ebp
.text:00008D6A                 retn
.text:00008D6A ??1CStdOutFileStream@@UAE@XZ endp
.text:00008D6A
.text:00008D6A ; ---------------------------------------------------------------------------
.text:00008D6B                 align 4
.text:00008D6B _text           ends
.text:00008D6B
.text:00008D6C ; ===========================================================================
.text:00008D6C
.text:00008D6C ; Segment type: Pure code
.text:00008D6C ; Segment permissions: Read/Execute
.text:00008D6C _text           segment para public 'CODE' use32
.text:00008D6C                 assume cs:_text
.text:00008D6C                 ;org 8D6Ch
.text:00008D6C ; COMDAT (pick any)
.text:00008D6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008D6C
.text:00008D6C ; =============== S U B R O U T I N E =======================================
.text:00008D6C
.text:00008D6C ; Attributes: bp-based frame
.text:00008D6C
.text:00008D6C ; void __thiscall CUpdatePair2::SetAs_NoChangeArcItem(CUpdatePair2 *this, int)
.text:00008D6C                 public ?SetAs_NoChangeArcItem@CUpdatePair2@@QAEXH@Z
.text:00008D6C ?SetAs_NoChangeArcItem@CUpdatePair2@@QAEXH@Z proc near
.text:00008D6C                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+472p
.text:00008D6C
.text:00008D6C var_4           = dword ptr -4
.text:00008D6C arg_0           = dword ptr  8
.text:00008D6C
.text:00008D6C                 push    ebp
.text:00008D6D                 mov     ebp, esp
.text:00008D6F                 push    ecx
.text:00008D70                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00008D77                 mov     [ebp+var_4], ecx
.text:00008D7A                 mov     eax, [ebp+var_4]
.text:00008D7D                 mov     byte ptr [eax+1], 0
.text:00008D81                 mov     ecx, [ebp+var_4]
.text:00008D84                 mov     byte ptr [ecx], 0
.text:00008D87                 mov     edx, [ebp+var_4]
.text:00008D8A                 mov     byte ptr [edx+2], 1
.text:00008D8E                 mov     eax, [ebp+var_4]
.text:00008D91                 mov     byte ptr [eax+3], 0
.text:00008D95                 mov     ecx, [ebp+var_4]
.text:00008D98                 mov     edx, [ebp+arg_0]
.text:00008D9B                 mov     [ecx+8], edx
.text:00008D9E                 mov     esp, ebp
.text:00008DA0                 pop     ebp
.text:00008DA1                 retn    4
.text:00008DA1 ?SetAs_NoChangeArcItem@CUpdatePair2@@QAEXH@Z endp
.text:00008DA1
.text:00008DA1 _text           ends
.text:00008DA1
.text:00008DA4 ; ===========================================================================
.text:00008DA4
.text:00008DA4 ; Segment type: Pure code
.text:00008DA4 ; Segment permissions: Read/Execute
.text:00008DA4 _text           segment para public 'CODE' use32
.text:00008DA4                 assume cs:_text
.text:00008DA4                 ;org 8DA4h
.text:00008DA4 ; COMDAT (pick any)
.text:00008DA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008DA4
.text:00008DA4 ; =============== S U B R O U T I N E =======================================
.text:00008DA4
.text:00008DA4 ; Attributes: bp-based frame
.text:00008DA4
.text:00008DA4 ; public: __thiscall CUpdatePair2::CUpdatePair2(void)
.text:00008DA4                 public ??0CUpdatePair2@@QAE@XZ
.text:00008DA4 ??0CUpdatePair2@@QAE@XZ proc near       ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+460p
.text:00008DA4                                         ; DATA XREF: CRecordVector<CUpdatePair2>::ReserveOnePosition(void)+9Fo
.text:00008DA4
.text:00008DA4 var_4           = dword ptr -4
.text:00008DA4
.text:00008DA4                 push    ebp
.text:00008DA5                 mov     ebp, esp
.text:00008DA7                 push    ecx
.text:00008DA8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00008DAF                 mov     [ebp+var_4], ecx
.text:00008DB2                 mov     eax, [ebp+var_4]
.text:00008DB5                 mov     byte ptr [eax], 0
.text:00008DB8                 mov     ecx, [ebp+var_4]
.text:00008DBB                 mov     byte ptr [ecx+1], 0
.text:00008DBF                 mov     edx, [ebp+var_4]
.text:00008DC2                 mov     byte ptr [edx+2], 0
.text:00008DC6                 mov     eax, [ebp+var_4]
.text:00008DC9                 mov     byte ptr [eax+3], 0
.text:00008DCD                 mov     ecx, [ebp+var_4]
.text:00008DD0                 mov     dword ptr [ecx+4], 0FFFFFFFFh
.text:00008DD7                 mov     edx, [ebp+var_4]
.text:00008DDA                 mov     dword ptr [edx+8], 0FFFFFFFFh
.text:00008DE1                 mov     eax, [ebp+var_4]
.text:00008DE4                 mov     dword ptr [eax+0Ch], 0FFFFFFFFh
.text:00008DEB                 mov     ecx, [ebp+var_4]
.text:00008DEE                 mov     byte ptr [ecx+10h], 0
.text:00008DF2                 mov     eax, [ebp+var_4]
.text:00008DF5                 mov     esp, ebp
.text:00008DF7                 pop     ebp
.text:00008DF8                 retn
.text:00008DF8 ??0CUpdatePair2@@QAE@XZ endp
.text:00008DF8
.text:00008DF8 ; ---------------------------------------------------------------------------
.text:00008DF9                 align 4
.text:00008DF9 _text           ends
.text:00008DF9
.text:00008DFC ; ===========================================================================
.text:00008DFC
.text:00008DFC ; Segment type: Pure code
.text:00008DFC ; Segment permissions: Read/Execute
.text:00008DFC _text           segment para public 'CODE' use32
.text:00008DFC                 assume cs:_text
.text:00008DFC                 ;org 8DFCh
.text:00008DFC ; COMDAT (pick any)
.text:00008DFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008DFC
.text:00008DFC ; =============== S U B R O U T I N E =======================================
.text:00008DFC
.text:00008DFC ; Attributes: bp-based frame
.text:00008DFC
.text:00008DFC ; bool __thiscall CArchiveUpdateCallback::AreAllFilesClosed(CArchiveUpdateCallback *__hidden this)
.text:00008DFC                 public ?AreAllFilesClosed@CArchiveUpdateCallback@@QBE_NXZ
.text:00008DFC ?AreAllFilesClosed@CArchiveUpdateCallback@@QBE_NXZ proc near
.text:00008DFC                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+183Ep
.text:00008DFC
.text:00008DFC var_4           = dword ptr -4
.text:00008DFC
.text:00008DFC                 push    ebp
.text:00008DFD                 mov     ebp, esp
.text:00008DFF                 push    ecx
.text:00008E00                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00008E07                 mov     [ebp+var_4], ecx
.text:00008E0A                 mov     ecx, [ebp+var_4]
.text:00008E0D                 add     ecx, 40h ; '@'
.text:00008E10                 call    ?IsEmpty@?$CRecordVector@I@@QBE_NXZ ; CRecordVector<uint>::IsEmpty(void)
.text:00008E15                 add     esp, 4
.text:00008E18                 cmp     ebp, esp
.text:00008E1A                 call    __RTC_CheckEsp
.text:00008E1F                 mov     esp, ebp
.text:00008E21                 pop     ebp
.text:00008E22                 retn
.text:00008E22 ?AreAllFilesClosed@CArchiveUpdateCallback@@QBE_NXZ endp
.text:00008E22
.text:00008E22 ; ---------------------------------------------------------------------------
.text:00008E23                 align 4
.text:00008E23 _text           ends
.text:00008E23
.text:00008E24 ; ===========================================================================
.text:00008E24
.text:00008E24 ; Segment type: Pure code
.text:00008E24 ; Segment permissions: Read/Execute
.text:00008E24 _text           segment para public 'CODE' use32
.text:00008E24                 assume cs:_text
.text:00008E24                 ;org 8E24h
.text:00008E24 ; COMDAT (pick any)
.text:00008E24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008E24
.text:00008E24 ; =============== S U B R O U T I N E =======================================
.text:00008E24
.text:00008E24 ; Attributes: bp-based frame
.text:00008E24
.text:00008E24 ; void __thiscall CTailOutStream::Init(CTailOutStream *__hidden this)
.text:00008E24                 public ?Init@CTailOutStream@@QAEXXZ
.text:00008E24 ?Init@CTailOutStream@@QAEXXZ proc near  ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+1752p
.text:00008E24
.text:00008E24 var_4           = dword ptr -4
.text:00008E24
.text:00008E24                 push    ebp
.text:00008E25                 mov     ebp, esp
.text:00008E27                 push    ecx
.text:00008E28                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00008E2F                 mov     [ebp+var_4], ecx
.text:00008E32                 mov     eax, [ebp+var_4]
.text:00008E35                 mov     dword ptr [eax+8], 0
.text:00008E3C                 mov     dword ptr [eax+0Ch], 0
.text:00008E43                 mov     ecx, [ebp+var_4]
.text:00008E46                 mov     dword ptr [ecx+10h], 0
.text:00008E4D                 mov     dword ptr [ecx+14h], 0
.text:00008E54                 mov     esp, ebp
.text:00008E56                 pop     ebp
.text:00008E57                 retn
.text:00008E57 ?Init@CTailOutStream@@QAEXXZ endp
.text:00008E57
.text:00008E57 _text           ends
.text:00008E57
.text:00008E58 ; ===========================================================================
.text:00008E58
.text:00008E58 ; Segment type: Pure code
.text:00008E58 ; Segment permissions: Read/Execute
.text:00008E58 _text           segment para public 'CODE' use32
.text:00008E58                 assume cs:_text
.text:00008E58                 ;org 8E58h
.text:00008E58 ; COMDAT (pick any)
.text:00008E58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008E58
.text:00008E58 ; =============== S U B R O U T I N E =======================================
.text:00008E58
.text:00008E58 ; Attributes: bp-based frame
.text:00008E58
.text:00008E58 ; void __thiscall COutMultiVolStream::Init(COutMultiVolStream *__hidden this)
.text:00008E58                 public ?Init@COutMultiVolStream@@QAEXXZ
.text:00008E58 ?Init@COutMultiVolStream@@QAEXXZ proc near
.text:00008E58                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+E44p
.text:00008E58
.text:00008E58 var_4           = dword ptr -4
.text:00008E58
.text:00008E58                 push    ebp
.text:00008E59                 mov     ebp, esp
.text:00008E5B                 push    ecx
.text:00008E5C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00008E63                 mov     [ebp+var_4], ecx
.text:00008E66                 mov     eax, [ebp+var_4]
.text:00008E69                 mov     dword ptr [eax+8], 0
.text:00008E70                 mov     ecx, [ebp+var_4]
.text:00008E73                 mov     dword ptr [ecx+10h], 0
.text:00008E7A                 mov     dword ptr [ecx+14h], 0
.text:00008E81                 mov     edx, [ebp+var_4]
.text:00008E84                 mov     dword ptr [edx+18h], 0
.text:00008E8B                 mov     dword ptr [edx+1Ch], 0
.text:00008E92                 mov     eax, [ebp+var_4]
.text:00008E95                 mov     dword ptr [eax+20h], 0
.text:00008E9C                 mov     dword ptr [eax+24h], 0
.text:00008EA3                 mov     esp, ebp
.text:00008EA5                 pop     ebp
.text:00008EA6                 retn
.text:00008EA6 ?Init@COutMultiVolStream@@QAEXXZ endp
.text:00008EA6
.text:00008EA6 ; ---------------------------------------------------------------------------
.text:00008EA7                 align 4
.text:00008EA7 _text           ends
.text:00008EA7
.text:00008EA8 ; ===========================================================================
.text:00008EA8
.text:00008EA8 ; Segment type: Pure code
.text:00008EA8 ; Segment permissions: Read/Execute
.text:00008EA8 _text           segment para public 'CODE' use32
.text:00008EA8                 assume cs:_text
.text:00008EA8                 ;org 8EA8h
.text:00008EA8 ; COMDAT (pick any)
.text:00008EA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008EA8
.text:00008EA8 ; =============== S U B R O U T I N E =======================================
.text:00008EA8
.text:00008EA8 ; Attributes: bp-based frame
.text:00008EA8
.text:00008EA8 ; unsigned __int64 __thiscall COutMultiVolStream::GetSize(COutMultiVolStream *__hidden this)
.text:00008EA8                 public ?GetSize@COutMultiVolStream@@QBE_KXZ
.text:00008EA8 ?GetSize@COutMultiVolStream@@QBE_KXZ proc near
.text:00008EA8                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+1ABDp
.text:00008EA8
.text:00008EA8 var_4           = dword ptr -4
.text:00008EA8
.text:00008EA8                 push    ebp
.text:00008EA9                 mov     ebp, esp
.text:00008EAB                 push    ecx
.text:00008EAC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00008EB3                 mov     [ebp+var_4], ecx
.text:00008EB6                 mov     ecx, [ebp+var_4]
.text:00008EB9                 mov     eax, [ecx+20h]
.text:00008EBC                 mov     edx, [ecx+24h]
.text:00008EBF                 mov     esp, ebp
.text:00008EC1                 pop     ebp
.text:00008EC2                 retn
.text:00008EC2 ?GetSize@COutMultiVolStream@@QBE_KXZ endp
.text:00008EC2
.text:00008EC2 ; ---------------------------------------------------------------------------
.text:00008EC3                 align 4
.text:00008EC3 _text           ends
.text:00008EC3
.text:00008EC4 ; ===========================================================================
.text:00008EC4
.text:00008EC4 ; Segment type: Pure code
.text:00008EC4 ; Segment permissions: Read/Execute
.text:00008EC4 _text           segment para public 'CODE' use32
.text:00008EC4                 assume cs:_text
.text:00008EC4                 ;org 8EC4h
.text:00008EC4 ; COMDAT (pick any)
.text:00008EC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008EC4
.text:00008EC4 ; =============== S U B R O U T I N E =======================================
.text:00008EC4
.text:00008EC4 ; Attributes: bp-based frame
.text:00008EC4
.text:00008EC4 ; public: __thiscall CUpdateProduceCallbackImp::CUpdateProduceCallbackImp(class CObjectVector<struct CArcItem> const *, struct IUpdateCallbackUI *)
.text:00008EC4                 public ??0CUpdateProduceCallbackImp@@QAE@PBV?$CObjectVector@UCArcItem@@@@PAUIUpdateCallbackUI@@@Z
.text:00008EC4 ??0CUpdateProduceCallbackImp@@QAE@PBV?$CObjectVector@UCArcItem@@@@PAUIUpdateCallbackUI@@@Z proc near
.text:00008EC4                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+592p
.text:00008EC4
.text:00008EC4 var_4           = dword ptr -4
.text:00008EC4 arg_0           = dword ptr  8
.text:00008EC4 arg_4           = dword ptr  0Ch
.text:00008EC4
.text:00008EC4                 push    ebp
.text:00008EC5                 mov     ebp, esp
.text:00008EC7                 push    ecx
.text:00008EC8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00008ECF                 mov     [ebp+var_4], ecx
.text:00008ED2                 mov     ecx, [ebp+var_4] ; this
.text:00008ED5                 call    ??0IUpdateProduceCallback@@QAE@XZ ; IUpdateProduceCallback::IUpdateProduceCallback(void)
.text:00008EDA                 mov     eax, [ebp+var_4]
.text:00008EDD                 mov     dword ptr [eax], offset ??_7CUpdateProduceCallbackImp@@6B@ ; const CUpdateProduceCallbackImp::`vftable'
.text:00008EE3                 mov     ecx, [ebp+var_4]
.text:00008EE6                 mov     edx, [ebp+arg_0]
.text:00008EE9                 mov     [ecx+4], edx
.text:00008EEC                 mov     eax, [ebp+var_4]
.text:00008EEF                 mov     ecx, [ebp+arg_4]
.text:00008EF2                 mov     [eax+8], ecx
.text:00008EF5                 mov     eax, [ebp+var_4]
.text:00008EF8                 add     esp, 4
.text:00008EFB                 cmp     ebp, esp
.text:00008EFD                 call    __RTC_CheckEsp
.text:00008F02                 mov     esp, ebp
.text:00008F04                 pop     ebp
.text:00008F05                 retn    8
.text:00008F05 ??0CUpdateProduceCallbackImp@@QAE@PBV?$CObjectVector@UCArcItem@@@@PAUIUpdateCallbackUI@@@Z endp
.text:00008F05
.text:00008F05 _text           ends
.text:00008F05
.rdata:00008F08 ; ===========================================================================
.rdata:00008F08
.rdata:00008F08 ; Segment type: Pure data
.rdata:00008F08 ; Segment permissions: Read
.rdata:00008F08 _rdata          segment dword public 'DATA' use32
.rdata:00008F08                 assume cs:_rdata
.rdata:00008F08                 ;org 8F08h
.rdata:00008F08 ; COMDAT (pick largest)
.rdata:00008F08                 dd offset ??_R4CUpdateProduceCallbackImp@@6B@ ; const CUpdateProduceCallbackImp::`RTTI Complete Object Locator'
.rdata:00008F0C                 public ??_7CUpdateProduceCallbackImp@@6B@
.rdata:00008F0C ; const CUpdateProduceCallbackImp::`vftable'
.rdata:00008F0C ??_7CUpdateProduceCallbackImp@@6B@ dd offset ?ShowDeleteFile@CUpdateProduceCallbackImp@@UAEJI@Z
.rdata:00008F0C                                         ; DATA XREF: CUpdateProduceCallbackImp::CUpdateProduceCallbackImp(CObjectVector<CArcItem> const *,IUpdateCallbackUI *)+19o
.rdata:00008F0C _rdata          ends                    ; CUpdateProduceCallbackImp::ShowDeleteFile(uint)
.rdata:00008F0C
.rdata$r:00008F10 ; ===========================================================================
.rdata$r:00008F10
.rdata$r:00008F10 ; Segment type: Pure data
.rdata$r:00008F10 ; Segment permissions: Read
.rdata$r:00008F10 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00008F10                 assume cs:_rdata$r
.rdata$r:00008F10                 ;org 8F10h
.rdata$r:00008F10 ; COMDAT (pick any)
.rdata$r:00008F10                 public ??_R4CUpdateProduceCallbackImp@@6B@
.rdata$r:00008F10 ; const CUpdateProduceCallbackImp::`RTTI Complete Object Locator'
.rdata$r:00008F10 ??_R4CUpdateProduceCallbackImp@@6B@ db    0 ; DATA XREF: .rdata:00008F08o
.rdata$r:00008F11                 db    0
.rdata$r:00008F12                 db    0
.rdata$r:00008F13                 db    0
.rdata$r:00008F14                 db    0
.rdata$r:00008F15                 db    0
.rdata$r:00008F16                 db    0
.rdata$r:00008F17                 db    0
.rdata$r:00008F18                 db    0
.rdata$r:00008F19                 db    0
.rdata$r:00008F1A                 db    0
.rdata$r:00008F1B                 db    0
.rdata$r:00008F1C                 dd offset ??_R0?AUCUpdateProduceCallbackImp@@@8 ; CUpdateProduceCallbackImp `RTTI Type Descriptor'
.rdata$r:00008F20                 dd offset ??_R3CUpdateProduceCallbackImp@@8 ; CUpdateProduceCallbackImp::`RTTI Class Hierarchy Descriptor'
.rdata$r:00008F20 _rdata$r        ends
.rdata$r:00008F20
.data:00008F24 ; ===========================================================================
.data:00008F24
.data:00008F24 ; Segment type: Pure data
.data:00008F24 ; Segment permissions: Read/Write
.data:00008F24 _data           segment dword public 'DATA' use32
.data:00008F24                 assume cs:_data
.data:00008F24                 ;org 8F24h
.data:00008F24 ; COMDAT (pick any)
.data:00008F24                 public ??_R0?AUCUpdateProduceCallbackImp@@@8
.data:00008F24 ; struct CUpdateProduceCallbackImp `RTTI Type Descriptor'
.data:00008F24 ??_R0?AUCUpdateProduceCallbackImp@@@8 dd offset ??_7type_info@@6B@
.data:00008F24                                         ; DATA XREF: .rdata$r:00008F1Co
.data:00008F24                                         ; .rdata$r:CUpdateProduceCallbackImp::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:00008F24                                         ; const type_info::`vftable'
.data:00008F28                 db    0
.data:00008F29                 db    0
.data:00008F2A                 db    0
.data:00008F2B                 db    0
.data:00008F2C                 db  2Eh ; .
.data:00008F2D                 db  3Fh ; ?
.data:00008F2E                 db  41h ; A
.data:00008F2F                 db  55h ; U
.data:00008F30                 db  43h ; C
.data:00008F31                 db  55h ; U
.data:00008F32                 db  70h ; p
.data:00008F33                 db  64h ; d
.data:00008F34                 db  61h ; a
.data:00008F35                 db  74h ; t
.data:00008F36                 db  65h ; e
.data:00008F37                 db  50h ; P
.data:00008F38                 db  72h ; r
.data:00008F39                 db  6Fh ; o
.data:00008F3A                 db  64h ; d
.data:00008F3B                 db  75h ; u
.data:00008F3C                 db  63h ; c
.data:00008F3D                 db  65h ; e
.data:00008F3E                 db  43h ; C
.data:00008F3F                 db  61h ; a
.data:00008F40                 db  6Ch ; l
.data:00008F41                 db  6Ch ; l
.data:00008F42                 db  62h ; b
.data:00008F43                 db  61h ; a
.data:00008F44                 db  63h ; c
.data:00008F45                 db  6Bh ; k
.data:00008F46                 db  49h ; I
.data:00008F47                 db  6Dh ; m
.data:00008F48                 db  70h ; p
.data:00008F49                 db  40h ; @
.data:00008F4A                 db  40h ; @
.data:00008F4B                 db    0
.data:00008F4B _data           ends
.data:00008F4B
.rdata$r:00008F4C ; ===========================================================================
.rdata$r:00008F4C
.rdata$r:00008F4C ; Segment type: Pure data
.rdata$r:00008F4C ; Segment permissions: Read
.rdata$r:00008F4C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00008F4C                 assume cs:_rdata$r
.rdata$r:00008F4C                 ;org 8F4Ch
.rdata$r:00008F4C ; COMDAT (pick any)
.rdata$r:00008F4C                 public ??_R3CUpdateProduceCallbackImp@@8
.rdata$r:00008F4C ; CUpdateProduceCallbackImp::`RTTI Class Hierarchy Descriptor'
.rdata$r:00008F4C ??_R3CUpdateProduceCallbackImp@@8 db    0 ; DATA XREF: .rdata$r:00008F20o
.rdata$r:00008F4C                                         ; .rdata$r:00008F80o
.rdata$r:00008F4D                 db    0
.rdata$r:00008F4E                 db    0
.rdata$r:00008F4F                 db    0
.rdata$r:00008F50                 db    0
.rdata$r:00008F51                 db    0
.rdata$r:00008F52                 db    0
.rdata$r:00008F53                 db    0
.rdata$r:00008F54                 db    2
.rdata$r:00008F55                 db    0
.rdata$r:00008F56                 db    0
.rdata$r:00008F57                 db    0
.rdata$r:00008F58                 dd offset ??_R2CUpdateProduceCallbackImp@@8 ; CUpdateProduceCallbackImp::`RTTI Base Class Array'
.rdata$r:00008F58 _rdata$r        ends
.rdata$r:00008F58
.rdata$r:00008F5C ; ===========================================================================
.rdata$r:00008F5C
.rdata$r:00008F5C ; Segment type: Pure data
.rdata$r:00008F5C ; Segment permissions: Read
.rdata$r:00008F5C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00008F5C                 assume cs:_rdata$r
.rdata$r:00008F5C                 ;org 8F5Ch
.rdata$r:00008F5C ; COMDAT (pick any)
.rdata$r:00008F5C                 public ??_R2CUpdateProduceCallbackImp@@8
.rdata$r:00008F5C ; CUpdateProduceCallbackImp::`RTTI Base Class Array'
.rdata$r:00008F5C ??_R2CUpdateProduceCallbackImp@@8 dd offset ??_R1A@?0A@EA@CUpdateProduceCallbackImp@@8
.rdata$r:00008F5C                                         ; DATA XREF: .rdata$r:00008F58o
.rdata$r:00008F5C                                         ; CUpdateProduceCallbackImp::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00008F60                 dd offset ??_R1A@?0A@EA@IUpdateProduceCallback@@8 ; IUpdateProduceCallback::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00008F64                 db    0
.rdata$r:00008F65                 align 4
.rdata$r:00008F65 _rdata$r        ends
.rdata$r:00008F65
.rdata$r:00008F68 ; ===========================================================================
.rdata$r:00008F68
.rdata$r:00008F68 ; Segment type: Pure data
.rdata$r:00008F68 ; Segment permissions: Read
.rdata$r:00008F68 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00008F68                 assume cs:_rdata$r
.rdata$r:00008F68                 ;org 8F68h
.rdata$r:00008F68 ; COMDAT (pick any)
.rdata$r:00008F68                 public ??_R1A@?0A@EA@CUpdateProduceCallbackImp@@8
.rdata$r:00008F68 ; CUpdateProduceCallbackImp::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00008F68 ??_R1A@?0A@EA@CUpdateProduceCallbackImp@@8 dd offset ??_R0?AUCUpdateProduceCallbackImp@@@8
.rdata$r:00008F68                                         ; DATA XREF: .rdata$r:CUpdateProduceCallbackImp::`RTTI Base Class Array'o
.rdata$r:00008F68                                         ; CUpdateProduceCallbackImp `RTTI Type Descriptor'
.rdata$r:00008F6C                 db    1
.rdata$r:00008F6D                 db    0
.rdata$r:00008F6E                 db    0
.rdata$r:00008F6F                 db    0
.rdata$r:00008F70                 db    0
.rdata$r:00008F71                 db    0
.rdata$r:00008F72                 db    0
.rdata$r:00008F73                 db    0
.rdata$r:00008F74                 db 0FFh
.rdata$r:00008F75                 db 0FFh
.rdata$r:00008F76                 db 0FFh
.rdata$r:00008F77                 db 0FFh
.rdata$r:00008F78                 db    0
.rdata$r:00008F79                 db    0
.rdata$r:00008F7A                 db    0
.rdata$r:00008F7B                 db    0
.rdata$r:00008F7C                 db  40h ; @
.rdata$r:00008F7D                 db    0
.rdata$r:00008F7E                 db    0
.rdata$r:00008F7F                 db    0
.rdata$r:00008F80                 dd offset ??_R3CUpdateProduceCallbackImp@@8 ; CUpdateProduceCallbackImp::`RTTI Class Hierarchy Descriptor'
.rdata$r:00008F80 _rdata$r        ends
.rdata$r:00008F80
.rdata$r:00008F84 ; ===========================================================================
.rdata$r:00008F84
.rdata$r:00008F84 ; Segment type: Pure data
.rdata$r:00008F84 ; Segment permissions: Read
.rdata$r:00008F84 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00008F84                 assume cs:_rdata$r
.rdata$r:00008F84                 ;org 8F84h
.rdata$r:00008F84 ; COMDAT (pick any)
.rdata$r:00008F84                 public ??_R1A@?0A@EA@IUpdateProduceCallback@@8
.rdata$r:00008F84 ; IUpdateProduceCallback::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00008F84 ??_R1A@?0A@EA@IUpdateProduceCallback@@8 dd offset ??_R0?AUIUpdateProduceCallback@@@8
.rdata$r:00008F84                                         ; DATA XREF: .rdata$r:00008F60o
.rdata$r:00008F84                                         ; .rdata$r:IUpdateProduceCallback::`RTTI Base Class Array'o
.rdata$r:00008F84                                         ; IUpdateProduceCallback `RTTI Type Descriptor'
.rdata$r:00008F88                 align 10h
.rdata$r:00008F90                 db 0FFh
.rdata$r:00008F91                 db 0FFh
.rdata$r:00008F92                 db 0FFh
.rdata$r:00008F93                 db 0FFh
.rdata$r:00008F94                 db    0
.rdata$r:00008F95                 db    0
.rdata$r:00008F96                 db    0
.rdata$r:00008F97                 db    0
.rdata$r:00008F98                 db  40h ; @
.rdata$r:00008F99                 db    0
.rdata$r:00008F9A                 db    0
.rdata$r:00008F9B                 db    0
.rdata$r:00008F9C                 dd offset ??_R3IUpdateProduceCallback@@8 ; IUpdateProduceCallback::`RTTI Class Hierarchy Descriptor'
.rdata$r:00008F9C _rdata$r        ends
.rdata$r:00008F9C
.data:00008FA0 ; ===========================================================================
.data:00008FA0
.data:00008FA0 ; Segment type: Pure data
.data:00008FA0 ; Segment permissions: Read/Write
.data:00008FA0 _data           segment dword public 'DATA' use32
.data:00008FA0                 assume cs:_data
.data:00008FA0                 ;org 8FA0h
.data:00008FA0 ; COMDAT (pick any)
.data:00008FA0                 public ??_R0?AUIUpdateProduceCallback@@@8
.data:00008FA0 ; struct IUpdateProduceCallback `RTTI Type Descriptor'
.data:00008FA0 ??_R0?AUIUpdateProduceCallback@@@8 dd offset ??_7type_info@@6B@
.data:00008FA0                                         ; DATA XREF: .rdata$r:IUpdateProduceCallback::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:00008FA0                                         ; .rdata$r:00009014o
.data:00008FA0                                         ; const type_info::`vftable'
.data:00008FA4                 align 8
.data:00008FA8 a_?auiupdatepro db '.?AUIUpdateProduceCallback@@',0
.data:00008FC5                 align 4
.data:00008FC5 _data           ends
.data:00008FC5
.rdata$r:00008FC8 ; ===========================================================================
.rdata$r:00008FC8
.rdata$r:00008FC8 ; Segment type: Pure data
.rdata$r:00008FC8 ; Segment permissions: Read
.rdata$r:00008FC8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00008FC8                 assume cs:_rdata$r
.rdata$r:00008FC8                 ;org 8FC8h
.rdata$r:00008FC8 ; COMDAT (pick any)
.rdata$r:00008FC8                 public ??_R3IUpdateProduceCallback@@8
.rdata$r:00008FC8 ; IUpdateProduceCallback::`RTTI Class Hierarchy Descriptor'
.rdata$r:00008FC8 ??_R3IUpdateProduceCallback@@8 db    0  ; DATA XREF: .rdata$r:00008F9Co
.rdata$r:00008FC8                                         ; .rdata$r:00009018o
.rdata$r:00008FC9                 db    0
.rdata$r:00008FCA                 db    0
.rdata$r:00008FCB                 db    0
.rdata$r:00008FCC                 db    0
.rdata$r:00008FCD                 db    0
.rdata$r:00008FCE                 db    0
.rdata$r:00008FCF                 db    0
.rdata$r:00008FD0                 db    1
.rdata$r:00008FD1                 db    0
.rdata$r:00008FD2                 db    0
.rdata$r:00008FD3                 db    0
.rdata$r:00008FD4                 dd offset ??_R2IUpdateProduceCallback@@8 ; IUpdateProduceCallback::`RTTI Base Class Array'
.rdata$r:00008FD4 _rdata$r        ends
.rdata$r:00008FD4
.rdata$r:00008FD8 ; ===========================================================================
.rdata$r:00008FD8
.rdata$r:00008FD8 ; Segment type: Pure data
.rdata$r:00008FD8 ; Segment permissions: Read
.rdata$r:00008FD8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00008FD8                 assume cs:_rdata$r
.rdata$r:00008FD8                 ;org 8FD8h
.rdata$r:00008FD8 ; COMDAT (pick any)
.rdata$r:00008FD8                 public ??_R2IUpdateProduceCallback@@8
.rdata$r:00008FD8 ; IUpdateProduceCallback::`RTTI Base Class Array'
.rdata$r:00008FD8 ??_R2IUpdateProduceCallback@@8 dd offset ??_R1A@?0A@EA@IUpdateProduceCallback@@8
.rdata$r:00008FD8                                         ; DATA XREF: .rdata$r:00008FD4o
.rdata$r:00008FD8                                         ; IUpdateProduceCallback::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00008FDC                 db    0
.rdata$r:00008FDD                 align 10h
.rdata$r:00008FDD _rdata$r        ends
.rdata$r:00008FDD
.text:00008FE0 ; ===========================================================================
.text:00008FE0
.text:00008FE0 ; Segment type: Pure code
.text:00008FE0 ; Segment permissions: Read/Execute
.text:00008FE0 _text           segment para public 'CODE' use32
.text:00008FE0                 assume cs:_text
.text:00008FE0                 ;org 8FE0h
.text:00008FE0 ; COMDAT (pick any)
.text:00008FE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00008FE0
.text:00008FE0 ; =============== S U B R O U T I N E =======================================
.text:00008FE0
.text:00008FE0 ; Attributes: bp-based frame
.text:00008FE0
.text:00008FE0 ; _DWORD __thiscall IUpdateProduceCallback::IUpdateProduceCallback(IUpdateProduceCallback *__hidden this)
.text:00008FE0                 public ??0IUpdateProduceCallback@@QAE@XZ
.text:00008FE0 ??0IUpdateProduceCallback@@QAE@XZ proc near
.text:00008FE0                                         ; CODE XREF: CUpdateProduceCallbackImp::CUpdateProduceCallbackImp(CObjectVector<CArcItem> const *,IUpdateCallbackUI *)+11p
.text:00008FE0
.text:00008FE0 var_4           = dword ptr -4
.text:00008FE0
.text:00008FE0                 push    ebp
.text:00008FE1                 mov     ebp, esp
.text:00008FE3                 push    ecx
.text:00008FE4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00008FEB                 mov     [ebp+var_4], ecx
.text:00008FEE                 mov     eax, [ebp+var_4]
.text:00008FF1                 mov     dword ptr [eax], offset ??_7IUpdateProduceCallback@@6B@ ; const IUpdateProduceCallback::`vftable'
.text:00008FF7                 mov     eax, [ebp+var_4]
.text:00008FFA                 mov     esp, ebp
.text:00008FFC                 pop     ebp
.text:00008FFD                 retn
.text:00008FFD ??0IUpdateProduceCallback@@QAE@XZ endp
.text:00008FFD
.text:00008FFD ; ---------------------------------------------------------------------------
.text:00008FFE                 align 10h
.text:00008FFE _text           ends
.text:00008FFE
.rdata:00009000 ; ===========================================================================
.rdata:00009000
.rdata:00009000 ; Segment type: Pure data
.rdata:00009000 ; Segment permissions: Read
.rdata:00009000 _rdata          segment dword public 'DATA' use32
.rdata:00009000                 assume cs:_rdata
.rdata:00009000                 ;org 9000h
.rdata:00009000 ; COMDAT (pick largest)
.rdata:00009000                 dd offset ??_R4IUpdateProduceCallback@@6B@ ; const IUpdateProduceCallback::`RTTI Complete Object Locator'
.rdata:00009004                 public ??_7IUpdateProduceCallback@@6B@
.rdata:00009004 ; const IUpdateProduceCallback::`vftable'
.rdata:00009004 ??_7IUpdateProduceCallback@@6B@ dd offset __purecall
.rdata:00009004                                         ; DATA XREF: IUpdateProduceCallback::IUpdateProduceCallback(void)+11o
.rdata:00009004 _rdata          ends
.rdata:00009004
.rdata$r:00009008 ; ===========================================================================
.rdata$r:00009008
.rdata$r:00009008 ; Segment type: Pure data
.rdata$r:00009008 ; Segment permissions: Read
.rdata$r:00009008 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009008                 assume cs:_rdata$r
.rdata$r:00009008                 ;org 9008h
.rdata$r:00009008 ; COMDAT (pick any)
.rdata$r:00009008                 public ??_R4IUpdateProduceCallback@@6B@
.rdata$r:00009008 ; const IUpdateProduceCallback::`RTTI Complete Object Locator'
.rdata$r:00009008 ??_R4IUpdateProduceCallback@@6B@ db    0 ; DATA XREF: .rdata:00009000o
.rdata$r:00009009                 db    0
.rdata$r:0000900A                 db    0
.rdata$r:0000900B                 db    0
.rdata$r:0000900C                 db    0
.rdata$r:0000900D                 db    0
.rdata$r:0000900E                 db    0
.rdata$r:0000900F                 db    0
.rdata$r:00009010                 db    0
.rdata$r:00009011                 db    0
.rdata$r:00009012                 db    0
.rdata$r:00009013                 db    0
.rdata$r:00009014                 dd offset ??_R0?AUIUpdateProduceCallback@@@8 ; IUpdateProduceCallback `RTTI Type Descriptor'
.rdata$r:00009018                 dd offset ??_R3IUpdateProduceCallback@@8 ; IUpdateProduceCallback::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009018 _rdata$r        ends
.rdata$r:00009018
.text:0000901C ; ===========================================================================
.text:0000901C
.text:0000901C ; Segment type: Pure code
.text:0000901C ; Segment permissions: Read/Execute
.text:0000901C _text           segment para public 'CODE' use32
.text:0000901C                 assume cs:_text
.text:0000901C                 ;org 901Ch
.text:0000901C ; COMDAT (pick any)
.text:0000901C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000901C
.text:0000901C ; =============== S U B R O U T I N E =======================================
.text:0000901C
.text:0000901C ; Attributes: bp-based frame
.text:0000901C
.text:0000901C ; public: __thiscall COutMultiVolStream::COutMultiVolStream(void)
.text:0000901C                 public ??0COutMultiVolStream@@QAE@XZ
.text:0000901C ??0COutMultiVolStream@@QAE@XZ proc near ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+D65p
.text:0000901C
.text:0000901C var_10          = dword ptr -10h
.text:0000901C var_C           = dword ptr -0Ch
.text:0000901C var_4           = dword ptr -4
.text:0000901C
.text:0000901C                 push    ebp
.text:0000901D                 mov     ebp, esp
.text:0000901F                 push    0FFFFFFFFh
.text:00009021                 push    offset __ehhandler$??0COutMultiVolStream@@QAE@XZ
.text:00009026                 mov     eax, large fs:0
.text:0000902C                 push    eax
.text:0000902D                 push    ecx
.text:0000902E                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00009035                 mov     eax, dword ptr ds:___security_cookie
.text:0000903A                 xor     eax, ebp
.text:0000903C                 push    eax
.text:0000903D                 lea     eax, [ebp+var_C]
.text:00009040                 mov     large fs:0, eax
.text:00009046                 mov     [ebp+var_10], ecx
.text:00009049                 mov     ecx, [ebp+var_10] ; this
.text:0000904C                 call    ??0IOutStream@@QAE@XZ ; IOutStream::IOutStream(void)
.text:00009051                 mov     ecx, [ebp+var_10]
.text:00009054                 add     ecx, 4          ; this
.text:00009057                 call    ??0CMyUnknownImp@@QAE@XZ ; CMyUnknownImp::CMyUnknownImp(void)
.text:0000905C                 mov     eax, [ebp+var_10]
.text:0000905F                 mov     dword ptr [eax], offset ??_7COutMultiVolStream@@6B@ ; const COutMultiVolStream::`vftable'
.text:00009065                 mov     ecx, [ebp+var_10]
.text:00009068                 add     ecx, 28h ; '('
.text:0000906B                 call    ??0?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAE@XZ ; CObjectVector<COutMultiVolStream::CAltStreamInfo>::CObjectVector<COutMultiVolStream::CAltStreamInfo>(void)
.text:00009070                 mov     [ebp+var_4], 0
.text:00009077                 mov     ecx, [ebp+var_10]
.text:0000907A                 add     ecx, 34h ; '4'
.text:0000907D                 call    ??0?$CRecordVector@_K@@QAE@XZ ; CRecordVector<unsigned __int64>::CRecordVector<unsigned __int64>(void)
.text:00009082                 mov     byte ptr [ebp+var_4], 1
.text:00009086                 mov     ecx, [ebp+var_10]
.text:00009089                 add     ecx, 40h ; '@'
.text:0000908C                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00009091                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00009098                 mov     eax, [ebp+var_10]
.text:0000909B                 mov     ecx, [ebp+var_C]
.text:0000909E                 mov     large fs:0, ecx
.text:000090A5                 pop     ecx
.text:000090A6                 add     esp, 10h
.text:000090A9                 cmp     ebp, esp
.text:000090AB                 call    __RTC_CheckEsp
.text:000090B0                 mov     esp, ebp
.text:000090B2                 pop     ebp
.text:000090B3                 retn
.text:000090B3 ??0COutMultiVolStream@@QAE@XZ endp
.text:000090B3
.text:000090B3 _text           ends
.text:000090B3
.text$x:000090B4 ; ===========================================================================
.text$x:000090B4
.text$x:000090B4 ; Segment type: Pure code
.text$x:000090B4 ; Segment permissions: Read/Execute
.text$x:000090B4 _text$x         segment para public 'CODE' use32
.text$x:000090B4                 assume cs:_text$x
.text$x:000090B4                 ;org 90B4h
.text$x:000090B4 ; COMDAT (pick associative to section at 901C)
.text$x:000090B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000090B4
.text$x:000090B4 ; =============== S U B R O U T I N E =======================================
.text$x:000090B4
.text$x:000090B4
.text$x:000090B4 __unwindfunclet$??0COutMultiVolStream@@QAE@XZ$0 proc near
.text$x:000090B4                                         ; DATA XREF: .xdata$x:00009108o
.text$x:000090B4                 mov     ecx, [ebp-10h]
.text$x:000090B7                 add     ecx, 28h ; '('
.text$x:000090BA                 jmp     ??1?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAE@XZ ; CObjectVector<COutMultiVolStream::CAltStreamInfo>::~CObjectVector<COutMultiVolStream::CAltStreamInfo>(void)
.text$x:000090BA __unwindfunclet$??0COutMultiVolStream@@QAE@XZ$0 endp
.text$x:000090BA
.text$x:000090BF
.text$x:000090BF ; =============== S U B R O U T I N E =======================================
.text$x:000090BF
.text$x:000090BF
.text$x:000090BF __unwindfunclet$??0COutMultiVolStream@@QAE@XZ$1 proc near
.text$x:000090BF                                         ; DATA XREF: .xdata$x:00009110o
.text$x:000090BF                 mov     ecx, [ebp-10h]
.text$x:000090C2                 add     ecx, 34h ; '4'
.text$x:000090C5                 jmp     ??1?$CRecordVector@_K@@QAE@XZ ; CRecordVector<unsigned __int64>::~CRecordVector<unsigned __int64>(void)
.text$x:000090C5 __unwindfunclet$??0COutMultiVolStream@@QAE@XZ$1 endp
.text$x:000090C5
.text$x:000090CA
.text$x:000090CA ; =============== S U B R O U T I N E =======================================
.text$x:000090CA
.text$x:000090CA
.text$x:000090CA __ehhandler$??0COutMultiVolStream@@QAE@XZ proc near
.text$x:000090CA                                         ; DATA XREF: COutMultiVolStream::COutMultiVolStream(void)+5o
.text$x:000090CA
.text$x:000090CA arg_4           = dword ptr  8
.text$x:000090CA
.text$x:000090CA                 mov     edx, [esp+arg_4]
.text$x:000090CE                 lea     eax, [edx+0Ch]
.text$x:000090D1                 mov     ecx, [edx-8]
.text$x:000090D4                 xor     ecx, eax
.text$x:000090D6                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000090DB                 mov     eax, offset __ehfuncinfo$??0COutMultiVolStream@@QAE@XZ
.text$x:000090E0                 jmp     ___CxxFrameHandler3
.text$x:000090E0 __ehhandler$??0COutMultiVolStream@@QAE@XZ endp
.text$x:000090E0
.text$x:000090E0 ; ---------------------------------------------------------------------------
.text$x:000090E5                 align 4
.text$x:000090E5 _text$x         ends
.text$x:000090E5
.rdata:000090E8 ; ===========================================================================
.rdata:000090E8
.rdata:000090E8 ; Segment type: Pure data
.rdata:000090E8 ; Segment permissions: Read
.rdata:000090E8 _rdata          segment dword public 'DATA' use32
.rdata:000090E8                 assume cs:_rdata
.rdata:000090E8                 ;org 90E8h
.rdata:000090E8 ; COMDAT (pick largest)
.rdata:000090E8                 dd offset ??_R4COutMultiVolStream@@6B@ ; const COutMultiVolStream::`RTTI Complete Object Locator'
.rdata:000090EC                 public ??_7COutMultiVolStream@@6B@
.rdata:000090EC ; const COutMultiVolStream::`vftable'
.rdata:000090EC ??_7COutMultiVolStream@@6B@ dd offset ?QueryInterface@COutMultiVolStream@@UAGJABU_GUID@@PAPAX@Z
.rdata:000090EC                                         ; DATA XREF: COutMultiVolStream::COutMultiVolStream(void)+43o
.rdata:000090EC                                         ; COutMultiVolStream::QueryInterface(_GUID const &,void * *)
.rdata:000090F0                 dd offset ?AddRef@COutMultiVolStream@@UAGKXZ ; COutMultiVolStream::AddRef(void)
.rdata:000090F4                 dd offset ?Release@COutMultiVolStream@@UAGKXZ ; COutMultiVolStream::Release(void)
.rdata:000090F8                 dd offset ?Write@COutMultiVolStream@@UAGJPBXIPAI@Z ; COutMultiVolStream::Write(void const *,uint,uint *)
.rdata:000090FC                 dd offset ?Seek@COutMultiVolStream@@UAGJ_JIPA_K@Z ; COutMultiVolStream::Seek(__int64,uint,unsigned __int64 *)
.rdata:00009100                 dd offset ?SetSize@COutMultiVolStream@@UAGJ_K@Z ; COutMultiVolStream::SetSize(unsigned __int64)
.rdata:00009100 _rdata          ends
.rdata:00009100
.xdata$x:00009104 ; ===========================================================================
.xdata$x:00009104
.xdata$x:00009104 ; Segment type: Pure data
.xdata$x:00009104 ; Segment permissions: Read
.xdata$x:00009104 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009104                 assume cs:_xdata$x
.xdata$x:00009104                 ;org 9104h
.xdata$x:00009104 ; COMDAT (pick associative to section at 901C)
.xdata$x:00009104 __unwindtable$??0COutMultiVolStream@@QAE@XZ db 0FFh
.xdata$x:00009104                                         ; DATA XREF: .xdata$x:0000911Co
.xdata$x:00009105                 db 0FFh
.xdata$x:00009106                 db 0FFh
.xdata$x:00009107                 db 0FFh
.xdata$x:00009108                 dd offset __unwindfunclet$??0COutMultiVolStream@@QAE@XZ$0
.xdata$x:0000910C                 align 10h
.xdata$x:00009110                 dd offset __unwindfunclet$??0COutMultiVolStream@@QAE@XZ$1
.xdata$x:00009114 __ehfuncinfo$??0COutMultiVolStream@@QAE@XZ db  22h ; "
.xdata$x:00009114                                         ; DATA XREF: __ehhandler$??0COutMultiVolStream@@QAE@XZ+11o
.xdata$x:00009115                 db    5
.xdata$x:00009116                 db  93h ; 
.xdata$x:00009117                 db  19h
.xdata$x:00009118                 db    2
.xdata$x:00009119                 db    0
.xdata$x:0000911A                 db    0
.xdata$x:0000911B                 db    0
.xdata$x:0000911C                 dd offset __unwindtable$??0COutMultiVolStream@@QAE@XZ
.xdata$x:00009120                 db    0
.xdata$x:00009121                 db    0
.xdata$x:00009122                 db    0
.xdata$x:00009123                 db    0
.xdata$x:00009124                 db    0
.xdata$x:00009125                 db    0
.xdata$x:00009126                 db    0
.xdata$x:00009127                 db    0
.xdata$x:00009128                 db    0
.xdata$x:00009129                 db    0
.xdata$x:0000912A                 db    0
.xdata$x:0000912B                 db    0
.xdata$x:0000912C                 db    0
.xdata$x:0000912D                 db    0
.xdata$x:0000912E                 db    0
.xdata$x:0000912F                 db    0
.xdata$x:00009130                 db    0
.xdata$x:00009131                 db    0
.xdata$x:00009132                 db    0
.xdata$x:00009133                 db    0
.xdata$x:00009134                 db    1
.xdata$x:00009135                 db    0
.xdata$x:00009136                 db    0
.xdata$x:00009137                 db    0
.xdata$x:00009137 _xdata$x        ends
.xdata$x:00009137
.rdata$r:00009138 ; ===========================================================================
.rdata$r:00009138
.rdata$r:00009138 ; Segment type: Pure data
.rdata$r:00009138 ; Segment permissions: Read
.rdata$r:00009138 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009138                 assume cs:_rdata$r
.rdata$r:00009138                 ;org 9138h
.rdata$r:00009138 ; COMDAT (pick any)
.rdata$r:00009138                 public ??_R4COutMultiVolStream@@6B@
.rdata$r:00009138 ; const COutMultiVolStream::`RTTI Complete Object Locator'
.rdata$r:00009138 ??_R4COutMultiVolStream@@6B@ db    0    ; DATA XREF: .rdata:000090E8o
.rdata$r:00009139                 db    0
.rdata$r:0000913A                 db    0
.rdata$r:0000913B                 db    0
.rdata$r:0000913C                 db    0
.rdata$r:0000913D                 db    0
.rdata$r:0000913E                 db    0
.rdata$r:0000913F                 db    0
.rdata$r:00009140                 db    0
.rdata$r:00009141                 db    0
.rdata$r:00009142                 db    0
.rdata$r:00009143                 db    0
.rdata$r:00009144                 dd offset ??_R0?AVCOutMultiVolStream@@@8 ; COutMultiVolStream `RTTI Type Descriptor'
.rdata$r:00009148                 dd offset ??_R3COutMultiVolStream@@8 ; COutMultiVolStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009148 _rdata$r        ends
.rdata$r:00009148
.data:0000914C ; ===========================================================================
.data:0000914C
.data:0000914C ; Segment type: Pure data
.data:0000914C ; Segment permissions: Read/Write
.data:0000914C _data           segment dword public 'DATA' use32
.data:0000914C                 assume cs:_data
.data:0000914C                 ;org 914Ch
.data:0000914C ; COMDAT (pick any)
.data:0000914C                 public ??_R0?AVCOutMultiVolStream@@@8
.data:0000914C ; class COutMultiVolStream `RTTI Type Descriptor'
.data:0000914C ??_R0?AVCOutMultiVolStream@@@8 dd offset ??_7type_info@@6B@
.data:0000914C                                         ; DATA XREF: .rdata$r:00009144o
.data:0000914C                                         ; .rdata$r:COutMultiVolStream::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:0000914C                                         ; const type_info::`vftable'
.data:00009150                 db    0
.data:00009151                 db    0
.data:00009152                 db    0
.data:00009153                 db    0
.data:00009154                 db  2Eh ; .
.data:00009155                 db  3Fh ; ?
.data:00009156                 db  41h ; A
.data:00009157                 db  56h ; V
.data:00009158                 db  43h ; C
.data:00009159                 db  4Fh ; O
.data:0000915A                 db  75h ; u
.data:0000915B                 db  74h ; t
.data:0000915C                 db  4Dh ; M
.data:0000915D                 db  75h ; u
.data:0000915E                 db  6Ch ; l
.data:0000915F                 db  74h ; t
.data:00009160                 db  69h ; i
.data:00009161                 db  56h ; V
.data:00009162                 db  6Fh ; o
.data:00009163                 db  6Ch ; l
.data:00009164                 db  53h ; S
.data:00009165                 db  74h ; t
.data:00009166                 db  72h ; r
.data:00009167                 db  65h ; e
.data:00009168                 db  61h ; a
.data:00009169                 db  6Dh ; m
.data:0000916A                 db  40h ; @
.data:0000916B                 db  40h ; @
.data:0000916C                 db    0
.data:0000916D                 align 10h
.data:0000916D _data           ends
.data:0000916D
.rdata$r:00009170 ; ===========================================================================
.rdata$r:00009170
.rdata$r:00009170 ; Segment type: Pure data
.rdata$r:00009170 ; Segment permissions: Read
.rdata$r:00009170 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009170                 assume cs:_rdata$r
.rdata$r:00009170                 ;org 9170h
.rdata$r:00009170 ; COMDAT (pick any)
.rdata$r:00009170                 public ??_R3COutMultiVolStream@@8
.rdata$r:00009170 ; COutMultiVolStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009170 ??_R3COutMultiVolStream@@8 db    0      ; DATA XREF: .rdata$r:00009148o
.rdata$r:00009170                                         ; .rdata$r:000091B0o
.rdata$r:00009171                 db    0
.rdata$r:00009172                 db    0
.rdata$r:00009173                 db    0
.rdata$r:00009174                 db    1
.rdata$r:00009175                 db    0
.rdata$r:00009176                 db    0
.rdata$r:00009177                 db    0
.rdata$r:00009178                 db    5
.rdata$r:00009179                 db    0
.rdata$r:0000917A                 db    0
.rdata$r:0000917B                 db    0
.rdata$r:0000917C                 dd offset ??_R2COutMultiVolStream@@8 ; COutMultiVolStream::`RTTI Base Class Array'
.rdata$r:0000917C _rdata$r        ends
.rdata$r:0000917C
.rdata$r:00009180 ; ===========================================================================
.rdata$r:00009180
.rdata$r:00009180 ; Segment type: Pure data
.rdata$r:00009180 ; Segment permissions: Read
.rdata$r:00009180 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009180                 assume cs:_rdata$r
.rdata$r:00009180                 ;org 9180h
.rdata$r:00009180 ; COMDAT (pick any)
.rdata$r:00009180                 public ??_R2COutMultiVolStream@@8
.rdata$r:00009180 ; COutMultiVolStream::`RTTI Base Class Array'
.rdata$r:00009180 ??_R2COutMultiVolStream@@8 dd offset ??_R1A@?0A@EA@COutMultiVolStream@@8
.rdata$r:00009180                                         ; DATA XREF: .rdata$r:0000917Co
.rdata$r:00009180                                         ; COutMultiVolStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009184                 dd offset ??_R1A@?0A@EA@IOutStream@@8 ; IOutStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009188                 dd offset ??_R1A@?0A@EA@ISequentialOutStream@@8 ; ISequentialOutStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000918C                 dd offset ??_R1A@?0A@EA@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009190                 dd offset ??_R13?0A@EA@CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Base Class Descriptor at (4,-1,0,64)'
.rdata$r:00009194                 db    0
.rdata$r:00009195                 align 4
.rdata$r:00009195 _rdata$r        ends
.rdata$r:00009195
.rdata$r:00009198 ; ===========================================================================
.rdata$r:00009198
.rdata$r:00009198 ; Segment type: Pure data
.rdata$r:00009198 ; Segment permissions: Read
.rdata$r:00009198 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009198                 assume cs:_rdata$r
.rdata$r:00009198                 ;org 9198h
.rdata$r:00009198 ; COMDAT (pick any)
.rdata$r:00009198                 public ??_R1A@?0A@EA@COutMultiVolStream@@8
.rdata$r:00009198 ; COutMultiVolStream::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00009198 ??_R1A@?0A@EA@COutMultiVolStream@@8 dd offset ??_R0?AVCOutMultiVolStream@@@8
.rdata$r:00009198                                         ; DATA XREF: .rdata$r:COutMultiVolStream::`RTTI Base Class Array'o
.rdata$r:00009198                                         ; COutMultiVolStream `RTTI Type Descriptor'
.rdata$r:0000919C                 db    4
.rdata$r:0000919D                 db    0
.rdata$r:0000919E                 db    0
.rdata$r:0000919F                 db    0
.rdata$r:000091A0                 db    0
.rdata$r:000091A1                 db    0
.rdata$r:000091A2                 db    0
.rdata$r:000091A3                 db    0
.rdata$r:000091A4                 db 0FFh
.rdata$r:000091A5                 db 0FFh
.rdata$r:000091A6                 db 0FFh
.rdata$r:000091A7                 db 0FFh
.rdata$r:000091A8                 db    0
.rdata$r:000091A9                 db    0
.rdata$r:000091AA                 db    0
.rdata$r:000091AB                 db    0
.rdata$r:000091AC                 db  40h ; @
.rdata$r:000091AD                 db    0
.rdata$r:000091AE                 db    0
.rdata$r:000091AF                 db    0
.rdata$r:000091B0                 dd offset ??_R3COutMultiVolStream@@8 ; COutMultiVolStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:000091B0 _rdata$r        ends
.rdata$r:000091B0
.text:000091B4 ; ===========================================================================
.text:000091B4
.text:000091B4 ; Segment type: Pure code
.text:000091B4 ; Segment permissions: Read/Execute
.text:000091B4 _text           segment para public 'CODE' use32
.text:000091B4                 assume cs:_text
.text:000091B4                 ;org 91B4h
.text:000091B4 ; COMDAT (pick any)
.text:000091B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000091B4
.text:000091B4 ; =============== S U B R O U T I N E =======================================
.text:000091B4
.text:000091B4 ; Attributes: bp-based frame
.text:000091B4
.text:000091B4 ; __int32 __stdcall COutMultiVolStream::QueryInterface(COutMultiVolStream *this, const struct _GUID *Buf1, void **)
.text:000091B4                 public ?QueryInterface@COutMultiVolStream@@UAGJABU_GUID@@PAPAX@Z
.text:000091B4 ?QueryInterface@COutMultiVolStream@@UAGJABU_GUID@@PAPAX@Z proc near
.text:000091B4                                         ; DATA XREF: .rdata:const COutMultiVolStream::`vftable'o
.text:000091B4
.text:000091B4 this            = dword ptr  8
.text:000091B4 Buf1            = dword ptr  0Ch
.text:000091B4 arg_8           = dword ptr  10h
.text:000091B4
.text:000091B4                 push    ebp
.text:000091B5                 mov     ebp, esp
.text:000091B7                 mov     eax, [ebp+arg_8]
.text:000091BA                 mov     dword ptr [eax], 0
.text:000091C0                 push    offset _IID_IUnknown ; Buf2
.text:000091C5                 mov     ecx, [ebp+Buf1]
.text:000091C8                 push    ecx             ; Buf1
.text:000091C9                 call    ___@8           ; __(x,x)
.text:000091CE                 test    eax, eax
.text:000091D0                 jz      short loc_91DC
.text:000091D2                 mov     edx, [ebp+arg_8]
.text:000091D5                 mov     eax, [ebp+this]
.text:000091D8                 mov     [edx], eax
.text:000091DA                 jmp     short loc_91FF
.text:000091DC ; ---------------------------------------------------------------------------
.text:000091DC
.text:000091DC loc_91DC:                               ; CODE XREF: COutMultiVolStream::QueryInterface(_GUID const &,void * *)+1Cj
.text:000091DC                 push    offset _IID_IOutStream ; Buf2
.text:000091E1                 mov     ecx, [ebp+Buf1]
.text:000091E4                 push    ecx             ; Buf1
.text:000091E5                 call    ___@8           ; __(x,x)
.text:000091EA                 test    eax, eax
.text:000091EC                 jz      short loc_91F8
.text:000091EE                 mov     edx, [ebp+arg_8]
.text:000091F1                 mov     eax, [ebp+this]
.text:000091F4                 mov     [edx], eax
.text:000091F6                 jmp     short loc_91FF
.text:000091F8 ; ---------------------------------------------------------------------------
.text:000091F8
.text:000091F8 loc_91F8:                               ; CODE XREF: COutMultiVolStream::QueryInterface(_GUID const &,void * *)+38j
.text:000091F8                 mov     eax, 80004002h
.text:000091FD                 jmp     short loc_9210
.text:000091FF ; ---------------------------------------------------------------------------
.text:000091FF
.text:000091FF loc_91FF:                               ; CODE XREF: COutMultiVolStream::QueryInterface(_GUID const &,void * *)+26j
.text:000091FF                                         ; COutMultiVolStream::QueryInterface(_GUID const &,void * *)+42j
.text:000091FF                 mov     ecx, [ebp+this]
.text:00009202                 mov     edx, [ecx+4]
.text:00009205                 add     edx, 1
.text:00009208                 mov     eax, [ebp+this]
.text:0000920B                 mov     [eax+4], edx
.text:0000920E                 xor     eax, eax
.text:00009210
.text:00009210 loc_9210:                               ; CODE XREF: COutMultiVolStream::QueryInterface(_GUID const &,void * *)+49j
.text:00009210                 cmp     ebp, esp
.text:00009212                 call    __RTC_CheckEsp
.text:00009217                 pop     ebp
.text:00009218                 retn    0Ch
.text:00009218 ?QueryInterface@COutMultiVolStream@@UAGJABU_GUID@@PAPAX@Z endp
.text:00009218
.text:00009218 ; ---------------------------------------------------------------------------
.text:0000921B                 align 4
.text:0000921B _text           ends
.text:0000921B
.text:0000921C ; ===========================================================================
.text:0000921C
.text:0000921C ; Segment type: Pure code
.text:0000921C ; Segment permissions: Read/Execute
.text:0000921C _text           segment para public 'CODE' use32
.text:0000921C                 assume cs:_text
.text:0000921C                 ;org 921Ch
.text:0000921C ; COMDAT (pick any)
.text:0000921C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000921C
.text:0000921C ; =============== S U B R O U T I N E =======================================
.text:0000921C
.text:0000921C ; Attributes: bp-based frame
.text:0000921C
.text:0000921C ; unsigned __int32 __stdcall COutMultiVolStream::AddRef(COutMultiVolStream *this)
.text:0000921C                 public ?AddRef@COutMultiVolStream@@UAGKXZ
.text:0000921C ?AddRef@COutMultiVolStream@@UAGKXZ proc near ; DATA XREF: .rdata:000090F0o
.text:0000921C
.text:0000921C var_4           = dword ptr -4
.text:0000921C this            = dword ptr  8
.text:0000921C
.text:0000921C                 push    ebp
.text:0000921D                 mov     ebp, esp
.text:0000921F                 push    ecx
.text:00009220                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00009227                 mov     eax, [ebp+this]
.text:0000922A                 mov     ecx, [eax+4]
.text:0000922D                 add     ecx, 1
.text:00009230                 mov     [ebp+var_4], ecx
.text:00009233                 mov     edx, [ebp+this]
.text:00009236                 mov     eax, [ebp+var_4]
.text:00009239                 mov     [edx+4], eax
.text:0000923C                 mov     eax, [ebp+var_4]
.text:0000923F                 mov     esp, ebp
.text:00009241                 pop     ebp
.text:00009242                 retn    4
.text:00009242 ?AddRef@COutMultiVolStream@@UAGKXZ endp
.text:00009242
.text:00009242 ; ---------------------------------------------------------------------------
.text:00009245                 align 4
.text:00009245 _text           ends
.text:00009245
.text:00009248 ; ===========================================================================
.text:00009248
.text:00009248 ; Segment type: Pure code
.text:00009248 ; Segment permissions: Read/Execute
.text:00009248 _text           segment para public 'CODE' use32
.text:00009248                 assume cs:_text
.text:00009248                 ;org 9248h
.text:00009248 ; COMDAT (pick any)
.text:00009248                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009248
.text:00009248 ; =============== S U B R O U T I N E =======================================
.text:00009248
.text:00009248 ; Attributes: bp-based frame
.text:00009248
.text:00009248 ; unsigned __int32 __stdcall COutMultiVolStream::Release(COutMultiVolStream *this)
.text:00009248                 public ?Release@COutMultiVolStream@@UAGKXZ
.text:00009248 ?Release@COutMultiVolStream@@UAGKXZ proc near ; DATA XREF: .rdata:000090F4o
.text:00009248
.text:00009248 var_10          = dword ptr -10h
.text:00009248 var_C           = dword ptr -0Ch
.text:00009248 var_8           = dword ptr -8
.text:00009248 var_4           = dword ptr -4
.text:00009248 this            = dword ptr  8
.text:00009248
.text:00009248                 push    ebp
.text:00009249                 mov     ebp, esp
.text:0000924B                 sub     esp, 10h
.text:0000924E                 mov     eax, 0CCCCCCCCh
.text:00009253                 mov     [ebp+var_10], eax
.text:00009256                 mov     [ebp+var_C], eax
.text:00009259                 mov     [ebp+var_8], eax
.text:0000925C                 mov     [ebp+var_4], eax
.text:0000925F                 mov     eax, [ebp+this]
.text:00009262                 mov     ecx, [eax+4]
.text:00009265                 sub     ecx, 1
.text:00009268                 mov     [ebp+var_C], ecx
.text:0000926B                 mov     edx, [ebp+this]
.text:0000926E                 mov     eax, [ebp+var_C]
.text:00009271                 mov     [edx+4], eax
.text:00009274                 cmp     [ebp+var_C], 0
.text:00009278                 jz      short loc_9282
.text:0000927A                 mov     ecx, [ebp+this]
.text:0000927D                 mov     eax, [ecx+4]
.text:00009280                 jmp     short loc_92AC
.text:00009282 ; ---------------------------------------------------------------------------
.text:00009282
.text:00009282 loc_9282:                               ; CODE XREF: COutMultiVolStream::Release(void)+30j
.text:00009282                 mov     edx, [ebp+this]
.text:00009285                 mov     [ebp+var_8], edx
.text:00009288                 mov     eax, [ebp+var_8]
.text:0000928B                 mov     [ebp+var_4], eax
.text:0000928E                 cmp     [ebp+var_4], 0
.text:00009292                 jz      short loc_92A3
.text:00009294                 push    1
.text:00009296                 mov     ecx, [ebp+var_4]
.text:00009299                 call    ??_GCOutMultiVolStream@@QAEPAXI@Z ; COutMultiVolStream::`scalar deleting destructor'(uint)
.text:0000929E                 mov     [ebp+var_10], eax
.text:000092A1                 jmp     short loc_92AA
.text:000092A3 ; ---------------------------------------------------------------------------
.text:000092A3
.text:000092A3 loc_92A3:                               ; CODE XREF: COutMultiVolStream::Release(void)+4Aj
.text:000092A3                 mov     [ebp+var_10], 0
.text:000092AA
.text:000092AA loc_92AA:                               ; CODE XREF: COutMultiVolStream::Release(void)+59j
.text:000092AA                 xor     eax, eax
.text:000092AC
.text:000092AC loc_92AC:                               ; CODE XREF: COutMultiVolStream::Release(void)+38j
.text:000092AC                 add     esp, 10h
.text:000092AF                 cmp     ebp, esp
.text:000092B1                 call    __RTC_CheckEsp
.text:000092B6                 mov     esp, ebp
.text:000092B8                 pop     ebp
.text:000092B9                 retn    4
.text:000092B9 ?Release@COutMultiVolStream@@UAGKXZ endp
.text:000092B9
.text:000092B9 _text           ends
.text:000092B9
.text:000092BC ; ===========================================================================
.text:000092BC
.text:000092BC ; Segment type: Pure code
.text:000092BC ; Segment permissions: Read/Execute
.text:000092BC _text           segment para public 'CODE' use32
.text:000092BC                 assume cs:_text
.text:000092BC                 ;org 92BCh
.text:000092BC ; COMDAT (pick any)
.text:000092BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000092BC
.text:000092BC ; =============== S U B R O U T I N E =======================================
.text:000092BC
.text:000092BC ; Attributes: bp-based frame
.text:000092BC
.text:000092BC ; public: void * __thiscall COutMultiVolStream::`scalar deleting destructor'(unsigned int)
.text:000092BC                 public ??_GCOutMultiVolStream@@QAEPAXI@Z
.text:000092BC ??_GCOutMultiVolStream@@QAEPAXI@Z proc near
.text:000092BC                                         ; CODE XREF: COutMultiVolStream::Release(void)+51p
.text:000092BC
.text:000092BC var_4           = dword ptr -4
.text:000092BC arg_0           = dword ptr  8
.text:000092BC
.text:000092BC                 push    ebp
.text:000092BD                 mov     ebp, esp
.text:000092BF                 push    ecx
.text:000092C0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000092C7                 mov     [ebp+var_4], ecx
.text:000092CA                 mov     ecx, [ebp+var_4] ; this
.text:000092CD                 call    ??1COutMultiVolStream@@QAE@XZ ; COutMultiVolStream::~COutMultiVolStream(void)
.text:000092D2                 mov     eax, [ebp+arg_0]
.text:000092D5                 and     eax, 1
.text:000092D8                 jz      short loc_92E6
.text:000092DA                 mov     ecx, [ebp+var_4]
.text:000092DD                 push    ecx             ; void *
.text:000092DE                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:000092E3                 add     esp, 4
.text:000092E6
.text:000092E6 loc_92E6:                               ; CODE XREF: COutMultiVolStream::`scalar deleting destructor'(uint)+1Cj
.text:000092E6                 mov     eax, [ebp+var_4]
.text:000092E9                 add     esp, 4
.text:000092EC                 cmp     ebp, esp
.text:000092EE                 call    __RTC_CheckEsp
.text:000092F3                 mov     esp, ebp
.text:000092F5                 pop     ebp
.text:000092F6                 retn    4
.text:000092F6 ??_GCOutMultiVolStream@@QAEPAXI@Z endp
.text:000092F6
.text:000092F6 ; ---------------------------------------------------------------------------
.text:000092F9                 align 4
.text:000092F9 _text           ends
.text:000092F9
.text:000092FC ; ===========================================================================
.text:000092FC
.text:000092FC ; Segment type: Pure code
.text:000092FC ; Segment permissions: Read/Execute
.text:000092FC _text           segment para public 'CODE' use32
.text:000092FC                 assume cs:_text
.text:000092FC                 ;org 92FCh
.text:000092FC ; COMDAT (pick any)
.text:000092FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000092FC
.text:000092FC ; =============== S U B R O U T I N E =======================================
.text:000092FC
.text:000092FC ; Attributes: bp-based frame
.text:000092FC
.text:000092FC ; _DWORD __thiscall COutMultiVolStream::~COutMultiVolStream(COutMultiVolStream *__hidden this)
.text:000092FC                 public ??1COutMultiVolStream@@QAE@XZ
.text:000092FC ??1COutMultiVolStream@@QAE@XZ proc near ; CODE XREF: COutMultiVolStream::`scalar deleting destructor'(uint)+11p
.text:000092FC
.text:000092FC var_10          = dword ptr -10h
.text:000092FC var_C           = dword ptr -0Ch
.text:000092FC var_4           = dword ptr -4
.text:000092FC
.text:000092FC                 push    ebp
.text:000092FD                 mov     ebp, esp
.text:000092FF                 push    0FFFFFFFFh
.text:00009301                 push    offset __ehhandler$??1COutMultiVolStream@@QAE@XZ
.text:00009306                 mov     eax, large fs:0
.text:0000930C                 push    eax
.text:0000930D                 push    ecx
.text:0000930E                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00009315                 mov     eax, dword ptr ds:___security_cookie
.text:0000931A                 xor     eax, ebp
.text:0000931C                 push    eax
.text:0000931D                 lea     eax, [ebp+var_C]
.text:00009320                 mov     large fs:0, eax
.text:00009326                 mov     [ebp+var_10], ecx
.text:00009329                 mov     [ebp+var_4], 1
.text:00009330                 mov     ecx, [ebp+var_10]
.text:00009333                 add     ecx, 40h ; '@'  ; this
.text:00009336                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000933B                 mov     byte ptr [ebp+var_4], 0
.text:0000933F                 mov     ecx, [ebp+var_10]
.text:00009342                 add     ecx, 34h ; '4'
.text:00009345                 call    ??1?$CRecordVector@_K@@QAE@XZ ; CRecordVector<unsigned __int64>::~CRecordVector<unsigned __int64>(void)
.text:0000934A                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00009351                 mov     ecx, [ebp+var_10]
.text:00009354                 add     ecx, 28h ; '('
.text:00009357                 call    ??1?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAE@XZ ; CObjectVector<COutMultiVolStream::CAltStreamInfo>::~CObjectVector<COutMultiVolStream::CAltStreamInfo>(void)
.text:0000935C                 mov     ecx, [ebp+var_C]
.text:0000935F                 mov     large fs:0, ecx
.text:00009366                 pop     ecx
.text:00009367                 add     esp, 10h
.text:0000936A                 cmp     ebp, esp
.text:0000936C                 call    __RTC_CheckEsp
.text:00009371                 mov     esp, ebp
.text:00009373                 pop     ebp
.text:00009374                 retn
.text:00009374 ??1COutMultiVolStream@@QAE@XZ endp
.text:00009374
.text:00009374 ; ---------------------------------------------------------------------------
.text:00009375                 align 4
.text:00009375 _text           ends
.text:00009375
.text$x:00009378 ; ===========================================================================
.text$x:00009378
.text$x:00009378 ; Segment type: Pure code
.text$x:00009378 ; Segment permissions: Read/Execute
.text$x:00009378 _text$x         segment para public 'CODE' use32
.text$x:00009378                 assume cs:_text$x
.text$x:00009378                 ;org 9378h
.text$x:00009378 ; COMDAT (pick associative to section at 92FC)
.text$x:00009378                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00009378
.text$x:00009378 ; =============== S U B R O U T I N E =======================================
.text$x:00009378
.text$x:00009378
.text$x:00009378 __unwindfunclet$??1COutMultiVolStream@@QAE@XZ$0 proc near
.text$x:00009378                                         ; DATA XREF: .xdata$x:000093B0o
.text$x:00009378                 mov     ecx, [ebp-10h]
.text$x:0000937B                 add     ecx, 28h ; '('
.text$x:0000937E                 jmp     ??1?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAE@XZ ; CObjectVector<COutMultiVolStream::CAltStreamInfo>::~CObjectVector<COutMultiVolStream::CAltStreamInfo>(void)
.text$x:0000937E __unwindfunclet$??1COutMultiVolStream@@QAE@XZ$0 endp
.text$x:0000937E
.text$x:00009383
.text$x:00009383 ; =============== S U B R O U T I N E =======================================
.text$x:00009383
.text$x:00009383
.text$x:00009383 __unwindfunclet$??1COutMultiVolStream@@QAE@XZ$1 proc near
.text$x:00009383                                         ; DATA XREF: .xdata$x:000093B8o
.text$x:00009383                 mov     ecx, [ebp-10h]
.text$x:00009386                 add     ecx, 34h ; '4'
.text$x:00009389                 jmp     ??1?$CRecordVector@_K@@QAE@XZ ; CRecordVector<unsigned __int64>::~CRecordVector<unsigned __int64>(void)
.text$x:00009389 __unwindfunclet$??1COutMultiVolStream@@QAE@XZ$1 endp
.text$x:00009389
.text$x:0000938E
.text$x:0000938E ; =============== S U B R O U T I N E =======================================
.text$x:0000938E
.text$x:0000938E
.text$x:0000938E __ehhandler$??1COutMultiVolStream@@QAE@XZ proc near
.text$x:0000938E                                         ; DATA XREF: COutMultiVolStream::~COutMultiVolStream(void)+5o
.text$x:0000938E
.text$x:0000938E arg_4           = dword ptr  8
.text$x:0000938E
.text$x:0000938E                 mov     edx, [esp+arg_4]
.text$x:00009392                 lea     eax, [edx+0Ch]
.text$x:00009395                 mov     ecx, [edx-8]
.text$x:00009398                 xor     ecx, eax
.text$x:0000939A                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000939F                 mov     eax, offset __ehfuncinfo$??1COutMultiVolStream@@QAE@XZ
.text$x:000093A4                 jmp     ___CxxFrameHandler3
.text$x:000093A4 __ehhandler$??1COutMultiVolStream@@QAE@XZ endp
.text$x:000093A4
.text$x:000093A4 ; ---------------------------------------------------------------------------
.text$x:000093A9                 align 4
.text$x:000093A9 _text$x         ends
.text$x:000093A9
.xdata$x:000093AC ; ===========================================================================
.xdata$x:000093AC
.xdata$x:000093AC ; Segment type: Pure data
.xdata$x:000093AC ; Segment permissions: Read
.xdata$x:000093AC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000093AC                 assume cs:_xdata$x
.xdata$x:000093AC                 ;org 93ACh
.xdata$x:000093AC ; COMDAT (pick associative to section at 92FC)
.xdata$x:000093AC __unwindtable$??1COutMultiVolStream@@QAE@XZ db 0FFh
.xdata$x:000093AC                                         ; DATA XREF: .xdata$x:000093C4o
.xdata$x:000093AD                 db 0FFh
.xdata$x:000093AE                 db 0FFh
.xdata$x:000093AF                 db 0FFh
.xdata$x:000093B0                 dd offset __unwindfunclet$??1COutMultiVolStream@@QAE@XZ$0
.xdata$x:000093B4                 align 8
.xdata$x:000093B8                 dd offset __unwindfunclet$??1COutMultiVolStream@@QAE@XZ$1
.xdata$x:000093BC __ehfuncinfo$??1COutMultiVolStream@@QAE@XZ db  22h ; "
.xdata$x:000093BC                                         ; DATA XREF: __ehhandler$??1COutMultiVolStream@@QAE@XZ+11o
.xdata$x:000093BD                 db    5
.xdata$x:000093BE                 db  93h ; 
.xdata$x:000093BF                 db  19h
.xdata$x:000093C0                 db    2
.xdata$x:000093C1                 db    0
.xdata$x:000093C2                 db    0
.xdata$x:000093C3                 db    0
.xdata$x:000093C4                 dd offset __unwindtable$??1COutMultiVolStream@@QAE@XZ
.xdata$x:000093C8                 db    0
.xdata$x:000093C9                 db    0
.xdata$x:000093CA                 db    0
.xdata$x:000093CB                 db    0
.xdata$x:000093CC                 db    0
.xdata$x:000093CD                 db    0
.xdata$x:000093CE                 db    0
.xdata$x:000093CF                 db    0
.xdata$x:000093D0                 db    0
.xdata$x:000093D1                 db    0
.xdata$x:000093D2                 db    0
.xdata$x:000093D3                 db    0
.xdata$x:000093D4                 db    0
.xdata$x:000093D5                 db    0
.xdata$x:000093D6                 db    0
.xdata$x:000093D7                 db    0
.xdata$x:000093D8                 db    0
.xdata$x:000093D9                 db    0
.xdata$x:000093DA                 db    0
.xdata$x:000093DB                 db    0
.xdata$x:000093DC                 db    1
.xdata$x:000093DD                 db    0
.xdata$x:000093DE                 db    0
.xdata$x:000093DF                 db    0
.xdata$x:000093DF _xdata$x        ends
.xdata$x:000093DF
.text:000093E0 ; ===========================================================================
.text:000093E0
.text:000093E0 ; Segment type: Pure code
.text:000093E0 ; Segment permissions: Read/Execute
.text:000093E0 _text           segment para public 'CODE' use32
.text:000093E0                 assume cs:_text
.text:000093E0                 ;org 93E0h
.text:000093E0 ; COMDAT (pick any)
.text:000093E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000093E0
.text:000093E0 ; =============== S U B R O U T I N E =======================================
.text:000093E0
.text:000093E0 ; Attributes: bp-based frame
.text:000093E0
.text:000093E0 ; public: __thiscall CTailOutStream::CTailOutStream(void)
.text:000093E0                 public ??0CTailOutStream@@QAE@XZ
.text:000093E0 ??0CTailOutStream@@QAE@XZ proc near     ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+16D7p
.text:000093E0
.text:000093E0 var_4           = dword ptr -4
.text:000093E0
.text:000093E0                 push    ebp
.text:000093E1                 mov     ebp, esp
.text:000093E3                 push    ecx
.text:000093E4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000093EB                 mov     [ebp+var_4], ecx
.text:000093EE                 mov     ecx, [ebp+var_4] ; this
.text:000093F1                 call    ??0IOutStream@@QAE@XZ ; IOutStream::IOutStream(void)
.text:000093F6                 mov     ecx, [ebp+var_4]
.text:000093F9                 add     ecx, 4          ; this
.text:000093FC                 call    ??0CMyUnknownImp@@QAE@XZ ; CMyUnknownImp::CMyUnknownImp(void)
.text:00009401                 mov     eax, [ebp+var_4]
.text:00009404                 mov     dword ptr [eax], offset ??_7CTailOutStream@@6B@ ; const CTailOutStream::`vftable'
.text:0000940A                 mov     ecx, [ebp+var_4]
.text:0000940D                 add     ecx, 18h
.text:00009410                 call    ??0?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::CMyComPtr<IOutStream>(void)
.text:00009415                 mov     eax, [ebp+var_4]
.text:00009418                 add     esp, 4
.text:0000941B                 cmp     ebp, esp
.text:0000941D                 call    __RTC_CheckEsp
.text:00009422                 mov     esp, ebp
.text:00009424                 pop     ebp
.text:00009425                 retn
.text:00009425 ??0CTailOutStream@@QAE@XZ endp
.text:00009425
.text:00009425 ; ---------------------------------------------------------------------------
.text:00009426                 align 4
.text:00009426 _text           ends
.text:00009426
.rdata:00009428 ; ===========================================================================
.rdata:00009428
.rdata:00009428 ; Segment type: Pure data
.rdata:00009428 ; Segment permissions: Read
.rdata:00009428 _rdata          segment dword public 'DATA' use32
.rdata:00009428                 assume cs:_rdata
.rdata:00009428                 ;org 9428h
.rdata:00009428 ; COMDAT (pick largest)
.rdata:00009428                 dd offset ??_R4CTailOutStream@@6B@ ; const CTailOutStream::`RTTI Complete Object Locator'
.rdata:0000942C                 public ??_7CTailOutStream@@6B@
.rdata:0000942C ; const CTailOutStream::`vftable'
.rdata:0000942C ??_7CTailOutStream@@6B@ dd offset ?QueryInterface@CTailOutStream@@UAGJABU_GUID@@PAPAX@Z
.rdata:0000942C                                         ; DATA XREF: CTailOutStream::CTailOutStream(void)+24o
.rdata:0000942C                                         ; CTailOutStream::~CTailOutStream(void)+11o
.rdata:0000942C                                         ; CTailOutStream::QueryInterface(_GUID const &,void * *)
.rdata:00009430                 dd offset ?AddRef@CTailOutStream@@UAGKXZ ; CTailOutStream::AddRef(void)
.rdata:00009434                 dd offset ?Release@CTailOutStream@@UAGKXZ ; CTailOutStream::Release(void)
.rdata:00009438                 dd offset ?Write@CTailOutStream@@UAGJPBXIPAI@Z ; CTailOutStream::Write(void const *,uint,uint *)
.rdata:0000943C                 dd offset ?Seek@CTailOutStream@@UAGJ_JIPA_K@Z ; CTailOutStream::Seek(__int64,uint,unsigned __int64 *)
.rdata:00009440                 dd offset ?SetSize@CTailOutStream@@UAGJ_K@Z ; CTailOutStream::SetSize(unsigned __int64)
.rdata:00009444                 dd offset ??_ECTailOutStream@@UAEPAXI@Z ; CTailOutStream::`vector deleting destructor'(uint)
.rdata:00009444 _rdata          ends
.rdata:00009444
.rdata$r:00009448 ; ===========================================================================
.rdata$r:00009448
.rdata$r:00009448 ; Segment type: Pure data
.rdata$r:00009448 ; Segment permissions: Read
.rdata$r:00009448 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009448                 assume cs:_rdata$r
.rdata$r:00009448                 ;org 9448h
.rdata$r:00009448 ; COMDAT (pick any)
.rdata$r:00009448                 public ??_R4CTailOutStream@@6B@
.rdata$r:00009448 ; const CTailOutStream::`RTTI Complete Object Locator'
.rdata$r:00009448 ??_R4CTailOutStream@@6B@ db    0        ; DATA XREF: .rdata:00009428o
.rdata$r:00009449                 db    0
.rdata$r:0000944A                 db    0
.rdata$r:0000944B                 db    0
.rdata$r:0000944C                 db    0
.rdata$r:0000944D                 db    0
.rdata$r:0000944E                 db    0
.rdata$r:0000944F                 db    0
.rdata$r:00009450                 db    0
.rdata$r:00009451                 db    0
.rdata$r:00009452                 db    0
.rdata$r:00009453                 db    0
.rdata$r:00009454                 dd offset ??_R0?AVCTailOutStream@@@8 ; CTailOutStream `RTTI Type Descriptor'
.rdata$r:00009458                 dd offset ??_R3CTailOutStream@@8 ; CTailOutStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009458 _rdata$r        ends
.rdata$r:00009458
.data:0000945C ; ===========================================================================
.data:0000945C
.data:0000945C ; Segment type: Pure data
.data:0000945C ; Segment permissions: Read/Write
.data:0000945C _data           segment dword public 'DATA' use32
.data:0000945C                 assume cs:_data
.data:0000945C                 ;org 945Ch
.data:0000945C ; COMDAT (pick any)
.data:0000945C                 public ??_R0?AVCTailOutStream@@@8
.data:0000945C ; class CTailOutStream `RTTI Type Descriptor'
.data:0000945C ??_R0?AVCTailOutStream@@@8 dd offset ??_7type_info@@6B@
.data:0000945C                                         ; DATA XREF: .rdata$r:00009454o
.data:0000945C                                         ; .rdata$r:CTailOutStream::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:0000945C                                         ; const type_info::`vftable'
.data:00009460                 db    0
.data:00009461                 db    0
.data:00009462                 db    0
.data:00009463                 db    0
.data:00009464                 db  2Eh ; .
.data:00009465                 db  3Fh ; ?
.data:00009466                 db  41h ; A
.data:00009467                 db  56h ; V
.data:00009468                 db  43h ; C
.data:00009469                 db  54h ; T
.data:0000946A                 db  61h ; a
.data:0000946B                 db  69h ; i
.data:0000946C                 db  6Ch ; l
.data:0000946D                 db  4Fh ; O
.data:0000946E                 db  75h ; u
.data:0000946F                 db  74h ; t
.data:00009470                 db  53h ; S
.data:00009471                 db  74h ; t
.data:00009472                 db  72h ; r
.data:00009473                 db  65h ; e
.data:00009474                 db  61h ; a
.data:00009475                 db  6Dh ; m
.data:00009476                 db  40h ; @
.data:00009477                 db  40h ; @
.data:00009478                 db    0
.data:00009479                 align 4
.data:00009479 _data           ends
.data:00009479
.rdata$r:0000947C ; ===========================================================================
.rdata$r:0000947C
.rdata$r:0000947C ; Segment type: Pure data
.rdata$r:0000947C ; Segment permissions: Read
.rdata$r:0000947C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000947C                 assume cs:_rdata$r
.rdata$r:0000947C                 ;org 947Ch
.rdata$r:0000947C ; COMDAT (pick any)
.rdata$r:0000947C                 public ??_R3CTailOutStream@@8
.rdata$r:0000947C ; CTailOutStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000947C ??_R3CTailOutStream@@8 db    0          ; DATA XREF: .rdata$r:00009458o
.rdata$r:0000947C                                         ; .rdata$r:000094BCo
.rdata$r:0000947D                 db    0
.rdata$r:0000947E                 db    0
.rdata$r:0000947F                 db    0
.rdata$r:00009480                 db    1
.rdata$r:00009481                 db    0
.rdata$r:00009482                 db    0
.rdata$r:00009483                 db    0
.rdata$r:00009484                 db    5
.rdata$r:00009485                 db    0
.rdata$r:00009486                 db    0
.rdata$r:00009487                 db    0
.rdata$r:00009488                 dd offset ??_R2CTailOutStream@@8 ; CTailOutStream::`RTTI Base Class Array'
.rdata$r:00009488 _rdata$r        ends
.rdata$r:00009488
.rdata$r:0000948C ; ===========================================================================
.rdata$r:0000948C
.rdata$r:0000948C ; Segment type: Pure data
.rdata$r:0000948C ; Segment permissions: Read
.rdata$r:0000948C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000948C                 assume cs:_rdata$r
.rdata$r:0000948C                 ;org 948Ch
.rdata$r:0000948C ; COMDAT (pick any)
.rdata$r:0000948C                 public ??_R2CTailOutStream@@8
.rdata$r:0000948C ; CTailOutStream::`RTTI Base Class Array'
.rdata$r:0000948C ??_R2CTailOutStream@@8 dd offset ??_R1A@?0A@EA@CTailOutStream@@8
.rdata$r:0000948C                                         ; DATA XREF: .rdata$r:00009488o
.rdata$r:0000948C                                         ; CTailOutStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009490                 dd offset ??_R1A@?0A@EA@IOutStream@@8 ; IOutStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009494                 dd offset ??_R1A@?0A@EA@ISequentialOutStream@@8 ; ISequentialOutStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009498                 dd offset ??_R1A@?0A@EA@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000949C                 dd offset ??_R13?0A@EA@CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Base Class Descriptor at (4,-1,0,64)'
.rdata$r:000094A0                 db    0
.rdata$r:000094A1                 align 4
.rdata$r:000094A1 _rdata$r        ends
.rdata$r:000094A1
.rdata$r:000094A4 ; ===========================================================================
.rdata$r:000094A4
.rdata$r:000094A4 ; Segment type: Pure data
.rdata$r:000094A4 ; Segment permissions: Read
.rdata$r:000094A4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000094A4                 assume cs:_rdata$r
.rdata$r:000094A4                 ;org 94A4h
.rdata$r:000094A4 ; COMDAT (pick any)
.rdata$r:000094A4                 public ??_R1A@?0A@EA@CTailOutStream@@8
.rdata$r:000094A4 ; CTailOutStream::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000094A4 ??_R1A@?0A@EA@CTailOutStream@@8 dd offset ??_R0?AVCTailOutStream@@@8
.rdata$r:000094A4                                         ; DATA XREF: .rdata$r:CTailOutStream::`RTTI Base Class Array'o
.rdata$r:000094A4                                         ; CTailOutStream `RTTI Type Descriptor'
.rdata$r:000094A8                 db    4
.rdata$r:000094A9                 db    0
.rdata$r:000094AA                 db    0
.rdata$r:000094AB                 db    0
.rdata$r:000094AC                 db    0
.rdata$r:000094AD                 db    0
.rdata$r:000094AE                 db    0
.rdata$r:000094AF                 db    0
.rdata$r:000094B0                 db 0FFh
.rdata$r:000094B1                 db 0FFh
.rdata$r:000094B2                 db 0FFh
.rdata$r:000094B3                 db 0FFh
.rdata$r:000094B4                 db    0
.rdata$r:000094B5                 db    0
.rdata$r:000094B6                 db    0
.rdata$r:000094B7                 db    0
.rdata$r:000094B8                 db  40h ; @
.rdata$r:000094B9                 db    0
.rdata$r:000094BA                 db    0
.rdata$r:000094BB                 db    0
.rdata$r:000094BC                 dd offset ??_R3CTailOutStream@@8 ; CTailOutStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:000094BC _rdata$r        ends
.rdata$r:000094BC
.text:000094C0 ; ===========================================================================
.text:000094C0
.text:000094C0 ; Segment type: Pure code
.text:000094C0 ; Segment permissions: Read/Execute
.text:000094C0 _text           segment para public 'CODE' use32
.text:000094C0                 assume cs:_text
.text:000094C0                 ;org 94C0h
.text:000094C0 ; COMDAT (pick any)
.text:000094C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000094C0
.text:000094C0 ; =============== S U B R O U T I N E =======================================
.text:000094C0
.text:000094C0 ; Attributes: bp-based frame
.text:000094C0
.text:000094C0 ; __int32 __stdcall CTailOutStream::QueryInterface(CTailOutStream *this, const struct _GUID *Buf1, void **)
.text:000094C0                 public ?QueryInterface@CTailOutStream@@UAGJABU_GUID@@PAPAX@Z
.text:000094C0 ?QueryInterface@CTailOutStream@@UAGJABU_GUID@@PAPAX@Z proc near
.text:000094C0                                         ; DATA XREF: .rdata:const CTailOutStream::`vftable'o
.text:000094C0
.text:000094C0 this            = dword ptr  8
.text:000094C0 Buf1            = dword ptr  0Ch
.text:000094C0 arg_8           = dword ptr  10h
.text:000094C0
.text:000094C0                 push    ebp
.text:000094C1                 mov     ebp, esp
.text:000094C3                 mov     eax, [ebp+arg_8]
.text:000094C6                 mov     dword ptr [eax], 0
.text:000094CC                 push    offset _IID_IUnknown ; Buf2
.text:000094D1                 mov     ecx, [ebp+Buf1]
.text:000094D4                 push    ecx             ; Buf1
.text:000094D5                 call    ___@8           ; __(x,x)
.text:000094DA                 test    eax, eax
.text:000094DC                 jz      short loc_94E8
.text:000094DE                 mov     edx, [ebp+arg_8]
.text:000094E1                 mov     eax, [ebp+this]
.text:000094E4                 mov     [edx], eax
.text:000094E6                 jmp     short loc_9527
.text:000094E8 ; ---------------------------------------------------------------------------
.text:000094E8
.text:000094E8 loc_94E8:                               ; CODE XREF: CTailOutStream::QueryInterface(_GUID const &,void * *)+1Cj
.text:000094E8                 push    offset _IID_ISequentialOutStream ; Buf2
.text:000094ED                 mov     ecx, [ebp+Buf1]
.text:000094F0                 push    ecx             ; Buf1
.text:000094F1                 call    ___@8           ; __(x,x)
.text:000094F6                 test    eax, eax
.text:000094F8                 jz      short loc_9504
.text:000094FA                 mov     edx, [ebp+arg_8]
.text:000094FD                 mov     eax, [ebp+this]
.text:00009500                 mov     [edx], eax
.text:00009502                 jmp     short loc_9527
.text:00009504 ; ---------------------------------------------------------------------------
.text:00009504
.text:00009504 loc_9504:                               ; CODE XREF: CTailOutStream::QueryInterface(_GUID const &,void * *)+38j
.text:00009504                 push    offset _IID_IOutStream ; Buf2
.text:00009509                 mov     ecx, [ebp+Buf1]
.text:0000950C                 push    ecx             ; Buf1
.text:0000950D                 call    ___@8           ; __(x,x)
.text:00009512                 test    eax, eax
.text:00009514                 jz      short loc_9520
.text:00009516                 mov     edx, [ebp+arg_8]
.text:00009519                 mov     eax, [ebp+this]
.text:0000951C                 mov     [edx], eax
.text:0000951E                 jmp     short loc_9527
.text:00009520 ; ---------------------------------------------------------------------------
.text:00009520
.text:00009520 loc_9520:                               ; CODE XREF: CTailOutStream::QueryInterface(_GUID const &,void * *)+54j
.text:00009520                 mov     eax, 80004002h
.text:00009525                 jmp     short loc_9538
.text:00009527 ; ---------------------------------------------------------------------------
.text:00009527
.text:00009527 loc_9527:                               ; CODE XREF: CTailOutStream::QueryInterface(_GUID const &,void * *)+26j
.text:00009527                                         ; CTailOutStream::QueryInterface(_GUID const &,void * *)+42j ...
.text:00009527                 mov     ecx, [ebp+this]
.text:0000952A                 mov     edx, [ecx+4]
.text:0000952D                 add     edx, 1
.text:00009530                 mov     eax, [ebp+this]
.text:00009533                 mov     [eax+4], edx
.text:00009536                 xor     eax, eax
.text:00009538
.text:00009538 loc_9538:                               ; CODE XREF: CTailOutStream::QueryInterface(_GUID const &,void * *)+65j
.text:00009538                 cmp     ebp, esp
.text:0000953A                 call    __RTC_CheckEsp
.text:0000953F                 pop     ebp
.text:00009540                 retn    0Ch
.text:00009540 ?QueryInterface@CTailOutStream@@UAGJABU_GUID@@PAPAX@Z endp
.text:00009540
.text:00009540 ; ---------------------------------------------------------------------------
.text:00009543                 align 4
.text:00009543 _text           ends
.text:00009543
.text:00009544 ; ===========================================================================
.text:00009544
.text:00009544 ; Segment type: Pure code
.text:00009544 ; Segment permissions: Read/Execute
.text:00009544 _text           segment para public 'CODE' use32
.text:00009544                 assume cs:_text
.text:00009544                 ;org 9544h
.text:00009544 ; COMDAT (pick any)
.text:00009544                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009544
.text:00009544 ; =============== S U B R O U T I N E =======================================
.text:00009544
.text:00009544 ; Attributes: bp-based frame
.text:00009544
.text:00009544 ; unsigned __int32 __stdcall CTailOutStream::AddRef(CTailOutStream *this)
.text:00009544                 public ?AddRef@CTailOutStream@@UAGKXZ
.text:00009544 ?AddRef@CTailOutStream@@UAGKXZ proc near ; DATA XREF: .rdata:00009430o
.text:00009544
.text:00009544 var_4           = dword ptr -4
.text:00009544 this            = dword ptr  8
.text:00009544
.text:00009544                 push    ebp
.text:00009545                 mov     ebp, esp
.text:00009547                 push    ecx
.text:00009548                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000954F                 mov     eax, [ebp+this]
.text:00009552                 mov     ecx, [eax+4]
.text:00009555                 add     ecx, 1
.text:00009558                 mov     [ebp+var_4], ecx
.text:0000955B                 mov     edx, [ebp+this]
.text:0000955E                 mov     eax, [ebp+var_4]
.text:00009561                 mov     [edx+4], eax
.text:00009564                 mov     eax, [ebp+var_4]
.text:00009567                 mov     esp, ebp
.text:00009569                 pop     ebp
.text:0000956A                 retn    4
.text:0000956A ?AddRef@CTailOutStream@@UAGKXZ endp
.text:0000956A
.text:0000956A ; ---------------------------------------------------------------------------
.text:0000956D                 align 10h
.text:0000956D _text           ends
.text:0000956D
.text:00009570 ; ===========================================================================
.text:00009570
.text:00009570 ; Segment type: Pure code
.text:00009570 ; Segment permissions: Read/Execute
.text:00009570 _text           segment para public 'CODE' use32
.text:00009570                 assume cs:_text
.text:00009570                 ;org 9570h
.text:00009570 ; COMDAT (pick any)
.text:00009570                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009570
.text:00009570 ; =============== S U B R O U T I N E =======================================
.text:00009570
.text:00009570 ; Attributes: bp-based frame
.text:00009570
.text:00009570 ; unsigned __int32 __stdcall CTailOutStream::Release(CTailOutStream *this)
.text:00009570                 public ?Release@CTailOutStream@@UAGKXZ
.text:00009570 ?Release@CTailOutStream@@UAGKXZ proc near ; DATA XREF: .rdata:00009434o
.text:00009570
.text:00009570 var_10          = dword ptr -10h
.text:00009570 var_C           = dword ptr -0Ch
.text:00009570 var_8           = dword ptr -8
.text:00009570 var_4           = dword ptr -4
.text:00009570 this            = dword ptr  8
.text:00009570
.text:00009570                 push    ebp
.text:00009571                 mov     ebp, esp
.text:00009573                 sub     esp, 10h
.text:00009576                 push    esi
.text:00009577                 mov     eax, 0CCCCCCCCh
.text:0000957C                 mov     [ebp+var_10], eax
.text:0000957F                 mov     [ebp+var_C], eax
.text:00009582                 mov     [ebp+var_8], eax
.text:00009585                 mov     [ebp+var_4], eax
.text:00009588                 mov     eax, [ebp+this]
.text:0000958B                 mov     ecx, [eax+4]
.text:0000958E                 sub     ecx, 1
.text:00009591                 mov     [ebp+var_C], ecx
.text:00009594                 mov     edx, [ebp+this]
.text:00009597                 mov     eax, [ebp+var_C]
.text:0000959A                 mov     [edx+4], eax
.text:0000959D                 cmp     [ebp+var_C], 0
.text:000095A1                 jz      short loc_95AB
.text:000095A3                 mov     ecx, [ebp+this]
.text:000095A6                 mov     eax, [ecx+4]
.text:000095A9                 jmp     short loc_95E3
.text:000095AB ; ---------------------------------------------------------------------------
.text:000095AB
.text:000095AB loc_95AB:                               ; CODE XREF: CTailOutStream::Release(void)+31j
.text:000095AB                 mov     edx, [ebp+this]
.text:000095AE                 mov     [ebp+var_8], edx
.text:000095B1                 mov     eax, [ebp+var_8]
.text:000095B4                 mov     [ebp+var_4], eax
.text:000095B7                 cmp     [ebp+var_4], 0
.text:000095BB                 jz      short loc_95DA
.text:000095BD                 mov     esi, esp
.text:000095BF                 push    1
.text:000095C1                 mov     ecx, [ebp+var_4]
.text:000095C4                 mov     edx, [ecx]
.text:000095C6                 mov     ecx, [ebp+var_4]
.text:000095C9                 mov     eax, [edx+18h]
.text:000095CC                 call    eax
.text:000095CE                 cmp     esi, esp
.text:000095D0                 call    __RTC_CheckEsp
.text:000095D5                 mov     [ebp+var_10], eax
.text:000095D8                 jmp     short loc_95E1
.text:000095DA ; ---------------------------------------------------------------------------
.text:000095DA
.text:000095DA loc_95DA:                               ; CODE XREF: CTailOutStream::Release(void)+4Bj
.text:000095DA                 mov     [ebp+var_10], 0
.text:000095E1
.text:000095E1 loc_95E1:                               ; CODE XREF: CTailOutStream::Release(void)+68j
.text:000095E1                 xor     eax, eax
.text:000095E3
.text:000095E3 loc_95E3:                               ; CODE XREF: CTailOutStream::Release(void)+39j
.text:000095E3                 pop     esi
.text:000095E4                 add     esp, 10h
.text:000095E7                 cmp     ebp, esp
.text:000095E9                 call    __RTC_CheckEsp
.text:000095EE                 mov     esp, ebp
.text:000095F0                 pop     ebp
.text:000095F1                 retn    4
.text:000095F1 ?Release@CTailOutStream@@UAGKXZ endp
.text:000095F1
.text:000095F1 _text           ends
.text:000095F1
.text:000095F4 ; ===========================================================================
.text:000095F4
.text:000095F4 ; Segment type: Pure code
.text:000095F4 ; Segment permissions: Read/Execute
.text:000095F4 _text           segment para public 'CODE' use32
.text:000095F4                 assume cs:_text
.text:000095F4                 ;org 95F4h
.text:000095F4 ; COMDAT (pick any)
.text:000095F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000095F4
.text:000095F4 ; =============== S U B R O U T I N E =======================================
.text:000095F4
.text:000095F4 ; Attributes: bp-based frame
.text:000095F4
.text:000095F4 ; public: virtual void * __thiscall CTailOutStream::`scalar deleting destructor'(unsigned int)
.text:000095F4                 public ??_GCTailOutStream@@UAEPAXI@Z
.text:000095F4 ??_GCTailOutStream@@UAEPAXI@Z proc near
.text:000095F4
.text:000095F4 var_4           = dword ptr -4
.text:000095F4 arg_0           = dword ptr  8
.text:000095F4
.text:000095F4                 push    ebp
.text:000095F5                 mov     ebp, esp
.text:000095F7                 push    ecx
.text:000095F8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000095FF                 mov     [ebp+var_4], ecx
.text:00009602                 mov     ecx, [ebp+var_4] ; this
.text:00009605                 call    ??1CTailOutStream@@UAE@XZ ; CTailOutStream::~CTailOutStream(void)
.text:0000960A                 mov     eax, [ebp+arg_0]
.text:0000960D                 and     eax, 1
.text:00009610                 jz      short loc_961E
.text:00009612                 mov     ecx, [ebp+var_4]
.text:00009615                 push    ecx             ; void *
.text:00009616                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000961B                 add     esp, 4
.text:0000961E
.text:0000961E loc_961E:                               ; CODE XREF: CTailOutStream::`scalar deleting destructor'(uint)+1Cj
.text:0000961E                 mov     eax, [ebp+var_4]
.text:00009621                 add     esp, 4
.text:00009624                 cmp     ebp, esp
.text:00009626                 call    __RTC_CheckEsp
.text:0000962B                 mov     esp, ebp
.text:0000962D                 pop     ebp
.text:0000962E                 retn    4
.text:0000962E ??_GCTailOutStream@@UAEPAXI@Z endp
.text:0000962E
.text:0000962E ; ---------------------------------------------------------------------------
.text:00009631                 align 4
.text:00009631 _text           ends
.text:00009631
.text:00009634 ; ===========================================================================
.text:00009634
.text:00009634 ; Segment type: Pure code
.text:00009634 ; Segment permissions: Read/Execute
.text:00009634 _text           segment para public 'CODE' use32
.text:00009634                 assume cs:_text
.text:00009634                 ;org 9634h
.text:00009634 ; COMDAT (pick any)
.text:00009634                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009634
.text:00009634 ; =============== S U B R O U T I N E =======================================
.text:00009634
.text:00009634 ; Attributes: bp-based frame
.text:00009634
.text:00009634 ; _DWORD __thiscall CTailOutStream::~CTailOutStream(CTailOutStream *__hidden this)
.text:00009634                 public ??1CTailOutStream@@UAE@XZ
.text:00009634 ??1CTailOutStream@@UAE@XZ proc near     ; CODE XREF: CTailOutStream::`scalar deleting destructor'(uint)+11p
.text:00009634
.text:00009634 var_4           = dword ptr -4
.text:00009634
.text:00009634                 push    ebp
.text:00009635                 mov     ebp, esp
.text:00009637                 push    ecx
.text:00009638                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000963F                 mov     [ebp+var_4], ecx
.text:00009642                 mov     eax, [ebp+var_4]
.text:00009645                 mov     dword ptr [eax], offset ??_7CTailOutStream@@6B@ ; const CTailOutStream::`vftable'
.text:0000964B                 mov     ecx, [ebp+var_4]
.text:0000964E                 add     ecx, 18h
.text:00009651                 call    ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::~CMyComPtr<IOutStream>(void)
.text:00009656                 add     esp, 4
.text:00009659                 cmp     ebp, esp
.text:0000965B                 call    __RTC_CheckEsp
.text:00009660                 mov     esp, ebp
.text:00009662                 pop     ebp
.text:00009663                 retn
.text:00009663 ??1CTailOutStream@@UAE@XZ endp
.text:00009663
.text:00009663 _text           ends
.text:00009663
.text:00009664 ; ===========================================================================
.text:00009664
.text:00009664 ; Segment type: Pure code
.text:00009664 ; Segment permissions: Read/Execute
.text:00009664 _text           segment para public 'CODE' use32
.text:00009664                 assume cs:_text
.text:00009664                 ;org 9664h
.text:00009664 ; COMDAT (pick any)
.text:00009664                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009664
.text:00009664 ; =============== S U B R O U T I N E =======================================
.text:00009664
.text:00009664 ; Attributes: bp-based frame
.text:00009664
.text:00009664 ; _DWORD __thiscall NWindows::NCOM::CPropVariant::CPropVariant(NWindows::NCOM::CPropVariant *__hidden this)
.text:00009664                 public ??0CPropVariant@NCOM@NWindows@@QAE@XZ
.text:00009664 ??0CPropVariant@NCOM@NWindows@@QAE@XZ proc near
.text:00009664                                         ; CODE XREF: EnumerateInArchiveItems(NWildcard::CCensor const &,CArc const &,CObjectVector<CArcItem> &)+20Ap
.text:00009664
.text:00009664 var_4           = dword ptr -4
.text:00009664
.text:00009664                 push    ebp
.text:00009665                 mov     ebp, esp
.text:00009667                 push    ecx
.text:00009668                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000966F                 mov     [ebp+var_4], ecx
.text:00009672                 xor     eax, eax
.text:00009674                 mov     ecx, [ebp+var_4]
.text:00009677                 mov     [ecx], ax
.text:0000967A                 xor     edx, edx
.text:0000967C                 mov     eax, [ebp+var_4]
.text:0000967F                 mov     [eax+2], dx
.text:00009683                 mov     ecx, [ebp+var_4]
.text:00009686                 mov     dword ptr [ecx+8], 0
.text:0000968D                 mov     eax, [ebp+var_4]
.text:00009690                 mov     esp, ebp
.text:00009692                 pop     ebp
.text:00009693                 retn
.text:00009693 ??0CPropVariant@NCOM@NWindows@@QAE@XZ endp
.text:00009693
.text:00009693 _text           ends
.text:00009693
.text:00009694 ; ===========================================================================
.text:00009694
.text:00009694 ; Segment type: Pure code
.text:00009694 ; Segment permissions: Read/Execute
.text:00009694 _text           segment para public 'CODE' use32
.text:00009694                 assume cs:_text
.text:00009694                 ;org 9694h
.text:00009694 ; COMDAT (pick any)
.text:00009694                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009694
.text:00009694 ; =============== S U B R O U T I N E =======================================
.text:00009694
.text:00009694 ; Attributes: bp-based frame
.text:00009694
.text:00009694 ; _DWORD __thiscall NWindows::NCOM::CPropVariant::~CPropVariant(NWindows::NCOM::CPropVariant *__hidden this)
.text:00009694                 public ??1CPropVariant@NCOM@NWindows@@QAE@XZ
.text:00009694 ??1CPropVariant@NCOM@NWindows@@QAE@XZ proc near
.text:00009694                                         ; CODE XREF: EnumerateInArchiveItems(NWildcard::CCensor const &,CArc const &,CObjectVector<CArcItem> &)+25Cp
.text:00009694                                         ; EnumerateInArchiveItems(NWildcard::CCensor const &,CArc const &,CObjectVector<CArcItem> &)+2D2p ...
.text:00009694
.text:00009694 var_4           = dword ptr -4
.text:00009694
.text:00009694                 push    ebp
.text:00009695                 mov     ebp, esp
.text:00009697                 push    ecx
.text:00009698                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000969F                 mov     [ebp+var_4], ecx
.text:000096A2                 mov     ecx, [ebp+var_4] ; this
.text:000096A5                 call    ?Clear@CPropVariant@NCOM@NWindows@@QAEJXZ ; NWindows::NCOM::CPropVariant::Clear(void)
.text:000096AA                 add     esp, 4
.text:000096AD                 cmp     ebp, esp
.text:000096AF                 call    __RTC_CheckEsp
.text:000096B4                 mov     esp, ebp
.text:000096B6                 pop     ebp
.text:000096B7                 retn
.text:000096B7 ??1CPropVariant@NCOM@NWindows@@QAE@XZ endp
.text:000096B7
.text:000096B7 _text           ends
.text:000096B7
.text:000096B8 ; ===========================================================================
.text:000096B8
.text:000096B8 ; Segment type: Pure code
.text:000096B8 ; Segment permissions: Read/Execute
.text:000096B8 _text           segment para public 'CODE' use32
.text:000096B8                 assume cs:_text
.text:000096B8                 ;org 96B8h
.text:000096B8 ; COMDAT (pick any)
.text:000096B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000096B8
.text:000096B8 ; =============== S U B R O U T I N E =======================================
.text:000096B8
.text:000096B8 ; Attributes: bp-based frame
.text:000096B8
.text:000096B8 ; _DWORD __thiscall CReadArcItem::CReadArcItem(CReadArcItem *__hidden this)
.text:000096B8                 public ??0CReadArcItem@@QAE@XZ
.text:000096B8 ??0CReadArcItem@@QAE@XZ proc near       ; CODE XREF: EnumerateInArchiveItems(NWildcard::CCensor const &,CArc const &,CObjectVector<CArcItem> &)+8Ap
.text:000096B8
.text:000096B8 var_10          = dword ptr -10h
.text:000096B8 var_C           = dword ptr -0Ch
.text:000096B8 var_4           = dword ptr -4
.text:000096B8
.text:000096B8                 push    ebp
.text:000096B9                 mov     ebp, esp
.text:000096BB                 push    0FFFFFFFFh
.text:000096BD                 push    offset __ehhandler$??0CReadArcItem@@QAE@XZ
.text:000096C2                 mov     eax, large fs:0
.text:000096C8                 push    eax
.text:000096C9                 push    ecx
.text:000096CA                 mov     [ebp+var_10], 0CCCCCCCCh
.text:000096D1                 mov     eax, dword ptr ds:___security_cookie
.text:000096D6                 xor     eax, ebp
.text:000096D8                 push    eax
.text:000096D9                 lea     eax, [ebp+var_C]
.text:000096DC                 mov     large fs:0, eax
.text:000096E2                 mov     [ebp+var_10], ecx
.text:000096E5                 mov     ecx, [ebp+var_10]
.text:000096E8                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:000096ED                 mov     [ebp+var_4], 0
.text:000096F4                 mov     ecx, [ebp+var_10]
.text:000096F7                 add     ecx, 0Ch
.text:000096FA                 call    ??0?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::CObjectVector<UString>(void)
.text:000096FF                 mov     byte ptr [ebp+var_4], 1
.text:00009703                 mov     ecx, [ebp+var_10]
.text:00009706                 add     ecx, 18h
.text:00009709                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:0000970E                 mov     byte ptr [ebp+var_4], 2
.text:00009712                 mov     ecx, [ebp+var_10]
.text:00009715                 add     ecx, 24h ; '$'
.text:00009718                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:0000971D                 mov     eax, [ebp+var_10]
.text:00009720                 mov     byte ptr [eax+31h], 0
.text:00009724                 mov     ecx, [ebp+var_10]
.text:00009727                 mov     byte ptr [ecx+38h], 0
.text:0000972B                 mov     edx, [ebp+var_10]
.text:0000972E                 mov     dword ptr [edx+3Ch], 0FFFFFFFFh
.text:00009735                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000973C                 mov     eax, [ebp+var_10]
.text:0000973F                 mov     ecx, [ebp+var_C]
.text:00009742                 mov     large fs:0, ecx
.text:00009749                 pop     ecx
.text:0000974A                 add     esp, 10h
.text:0000974D                 cmp     ebp, esp
.text:0000974F                 call    __RTC_CheckEsp
.text:00009754                 mov     esp, ebp
.text:00009756                 pop     ebp
.text:00009757                 retn
.text:00009757 ??0CReadArcItem@@QAE@XZ endp
.text:00009757
.text:00009757 _text           ends
.text:00009757
.text$x:00009758 ; ===========================================================================
.text$x:00009758
.text$x:00009758 ; Segment type: Pure code
.text$x:00009758 ; Segment permissions: Read/Execute
.text$x:00009758 _text$x         segment para public 'CODE' use32
.text$x:00009758                 assume cs:_text$x
.text$x:00009758                 ;org 9758h
.text$x:00009758 ; COMDAT (pick associative to section at 96B8)
.text$x:00009758                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00009758
.text$x:00009758 ; =============== S U B R O U T I N E =======================================
.text$x:00009758
.text$x:00009758
.text$x:00009758 __unwindfunclet$??0CReadArcItem@@QAE@XZ$0 proc near
.text$x:00009758                                         ; DATA XREF: .xdata$x:00009798o
.text$x:00009758                 mov     ecx, [ebp-10h]  ; this
.text$x:0000975B                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:0000975B __unwindfunclet$??0CReadArcItem@@QAE@XZ$0 endp
.text$x:0000975B
.text$x:00009760
.text$x:00009760 ; =============== S U B R O U T I N E =======================================
.text$x:00009760
.text$x:00009760
.text$x:00009760 __unwindfunclet$??0CReadArcItem@@QAE@XZ$1 proc near
.text$x:00009760                                         ; DATA XREF: .xdata$x:000097A0o
.text$x:00009760                 mov     ecx, [ebp-10h]
.text$x:00009763                 add     ecx, 0Ch
.text$x:00009766                 jmp     ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text$x:00009766 __unwindfunclet$??0CReadArcItem@@QAE@XZ$1 endp
.text$x:00009766
.text$x:0000976B
.text$x:0000976B ; =============== S U B R O U T I N E =======================================
.text$x:0000976B
.text$x:0000976B
.text$x:0000976B __unwindfunclet$??0CReadArcItem@@QAE@XZ$2 proc near
.text$x:0000976B                                         ; DATA XREF: .xdata$x:000097A8o
.text$x:0000976B                 mov     ecx, [ebp-10h]
.text$x:0000976E                 add     ecx, 18h        ; this
.text$x:00009771                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00009771 __unwindfunclet$??0CReadArcItem@@QAE@XZ$2 endp
.text$x:00009771
.text$x:00009776
.text$x:00009776 ; =============== S U B R O U T I N E =======================================
.text$x:00009776
.text$x:00009776
.text$x:00009776 __ehhandler$??0CReadArcItem@@QAE@XZ proc near
.text$x:00009776                                         ; DATA XREF: CReadArcItem::CReadArcItem(void)+5o
.text$x:00009776
.text$x:00009776 arg_4           = dword ptr  8
.text$x:00009776
.text$x:00009776                 mov     edx, [esp+arg_4]
.text$x:0000977A                 lea     eax, [edx+0Ch]
.text$x:0000977D                 mov     ecx, [edx-8]
.text$x:00009780                 xor     ecx, eax
.text$x:00009782                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009787                 mov     eax, offset __ehfuncinfo$??0CReadArcItem@@QAE@XZ
.text$x:0000978C                 jmp     ___CxxFrameHandler3
.text$x:0000978C __ehhandler$??0CReadArcItem@@QAE@XZ endp
.text$x:0000978C
.text$x:0000978C ; ---------------------------------------------------------------------------
.text$x:00009791                 align 4
.text$x:00009791 _text$x         ends
.text$x:00009791
.xdata$x:00009794 ; ===========================================================================
.xdata$x:00009794
.xdata$x:00009794 ; Segment type: Pure data
.xdata$x:00009794 ; Segment permissions: Read
.xdata$x:00009794 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009794                 assume cs:_xdata$x
.xdata$x:00009794                 ;org 9794h
.xdata$x:00009794 ; COMDAT (pick associative to section at 96B8)
.xdata$x:00009794 __unwindtable$??0CReadArcItem@@QAE@XZ db 0FFh
.xdata$x:00009794                                         ; DATA XREF: .xdata$x:000097B4o
.xdata$x:00009795                 db 0FFh
.xdata$x:00009796                 db 0FFh
.xdata$x:00009797                 db 0FFh
.xdata$x:00009798                 dd offset __unwindfunclet$??0CReadArcItem@@QAE@XZ$0
.xdata$x:0000979C                 align 10h
.xdata$x:000097A0                 dd offset __unwindfunclet$??0CReadArcItem@@QAE@XZ$1
.xdata$x:000097A4                 db    1
.xdata$x:000097A5                 db    0
.xdata$x:000097A6                 db    0
.xdata$x:000097A7                 db    0
.xdata$x:000097A8                 dd offset __unwindfunclet$??0CReadArcItem@@QAE@XZ$2
.xdata$x:000097AC __ehfuncinfo$??0CReadArcItem@@QAE@XZ db  22h ; "
.xdata$x:000097AC                                         ; DATA XREF: __ehhandler$??0CReadArcItem@@QAE@XZ+11o
.xdata$x:000097AD                 db    5
.xdata$x:000097AE                 db  93h ; 
.xdata$x:000097AF                 db  19h
.xdata$x:000097B0                 db    3
.xdata$x:000097B1                 db    0
.xdata$x:000097B2                 db    0
.xdata$x:000097B3                 db    0
.xdata$x:000097B4                 dd offset __unwindtable$??0CReadArcItem@@QAE@XZ
.xdata$x:000097B8                 db    0
.xdata$x:000097B9                 db    0
.xdata$x:000097BA                 db    0
.xdata$x:000097BB                 db    0
.xdata$x:000097BC                 db    0
.xdata$x:000097BD                 db    0
.xdata$x:000097BE                 db    0
.xdata$x:000097BF                 db    0
.xdata$x:000097C0                 db    0
.xdata$x:000097C1                 db    0
.xdata$x:000097C2                 db    0
.xdata$x:000097C3                 db    0
.xdata$x:000097C4                 db    0
.xdata$x:000097C5                 db    0
.xdata$x:000097C6                 db    0
.xdata$x:000097C7                 db    0
.xdata$x:000097C8                 db    0
.xdata$x:000097C9                 db    0
.xdata$x:000097CA                 db    0
.xdata$x:000097CB                 db    0
.xdata$x:000097CC                 db    1
.xdata$x:000097CD                 db    0
.xdata$x:000097CE                 db    0
.xdata$x:000097CF                 db    0
.xdata$x:000097CF _xdata$x        ends
.xdata$x:000097CF
.text:000097D0 ; ===========================================================================
.text:000097D0
.text:000097D0 ; Segment type: Pure code
.text:000097D0 ; Segment permissions: Read/Execute
.text:000097D0 _text           segment para public 'CODE' use32
.text:000097D0                 assume cs:_text
.text:000097D0                 ;org 97D0h
.text:000097D0 ; COMDAT (pick any)
.text:000097D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000097D0
.text:000097D0 ; =============== S U B R O U T I N E =======================================
.text:000097D0
.text:000097D0 ; Attributes: bp-based frame
.text:000097D0
.text:000097D0 ; _DWORD __thiscall CArcItem::CArcItem(CArcItem *__hidden this)
.text:000097D0                 public ??0CArcItem@@QAE@XZ
.text:000097D0 ??0CArcItem@@QAE@XZ proc near           ; CODE XREF: EnumerateInArchiveItems(NWildcard::CCensor const &,CArc const &,CObjectVector<CArcItem> &)+BAp
.text:000097D0
.text:000097D0 var_4           = dword ptr -4
.text:000097D0
.text:000097D0                 push    ebp
.text:000097D1                 mov     ebp, esp
.text:000097D3                 push    ecx
.text:000097D4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000097DB                 mov     [ebp+var_4], ecx
.text:000097DE                 mov     ecx, [ebp+var_4]
.text:000097E1                 add     ecx, 10h
.text:000097E4                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:000097E9                 mov     eax, [ebp+var_4]
.text:000097EC                 mov     byte ptr [eax+1Ch], 0
.text:000097F0                 mov     ecx, [ebp+var_4]
.text:000097F3                 mov     byte ptr [ecx+1Dh], 0
.text:000097F7                 mov     edx, [ebp+var_4]
.text:000097FA                 mov     byte ptr [edx+1Eh], 0
.text:000097FE                 mov     eax, [ebp+var_4]
.text:00009801                 mov     byte ptr [eax+1Fh], 0
.text:00009805                 mov     ecx, [ebp+var_4]
.text:00009808                 mov     byte ptr [ecx+20h], 0
.text:0000980C                 mov     edx, [ebp+var_4]
.text:0000980F                 mov     dword ptr [edx+28h], 0FFFFFFFFh
.text:00009816                 mov     eax, [ebp+var_4]
.text:00009819                 add     esp, 4
.text:0000981C                 cmp     ebp, esp
.text:0000981E                 call    __RTC_CheckEsp
.text:00009823                 mov     esp, ebp
.text:00009825                 pop     ebp
.text:00009826                 retn
.text:00009826 ??0CArcItem@@QAE@XZ endp
.text:00009826
.text:00009826 ; ---------------------------------------------------------------------------
.text:00009827                 align 4
.text:00009827 _text           ends
.text:00009827
.text:00009828 ; ===========================================================================
.text:00009828
.text:00009828 ; Segment type: Pure code
.text:00009828 ; Segment permissions: Read/Execute
.text:00009828 _text           segment para public 'CODE' use32
.text:00009828                 assume cs:_text
.text:00009828                 ;org 9828h
.text:00009828 ; COMDAT (pick any)
.text:00009828                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009828
.text:00009828 ; =============== S U B R O U T I N E =======================================
.text:00009828
.text:00009828 ; Attributes: bp-based frame
.text:00009828
.text:00009828 ; _DWORD __thiscall CReadArcItem::~CReadArcItem(CReadArcItem *__hidden this)
.text:00009828                 public ??1CReadArcItem@@QAE@XZ
.text:00009828 ??1CReadArcItem@@QAE@XZ proc near       ; CODE XREF: EnumerateInArchiveItems(NWildcard::CCensor const &,CArc const &,CObjectVector<CArcItem> &)+107p
.text:00009828                                         ; EnumerateInArchiveItems(NWildcard::CCensor const &,CArc const &,CObjectVector<CArcItem> &)+196p ...
.text:00009828
.text:00009828 var_10          = dword ptr -10h
.text:00009828 var_C           = dword ptr -0Ch
.text:00009828 var_4           = dword ptr -4
.text:00009828
.text:00009828                 push    ebp
.text:00009829                 mov     ebp, esp
.text:0000982B                 push    0FFFFFFFFh
.text:0000982D                 push    offset __ehhandler$??1CReadArcItem@@QAE@XZ
.text:00009832                 mov     eax, large fs:0
.text:00009838                 push    eax
.text:00009839                 push    ecx
.text:0000983A                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00009841                 mov     eax, dword ptr ds:___security_cookie
.text:00009846                 xor     eax, ebp
.text:00009848                 push    eax
.text:00009849                 lea     eax, [ebp+var_C]
.text:0000984C                 mov     large fs:0, eax
.text:00009852                 mov     [ebp+var_10], ecx
.text:00009855                 mov     [ebp+var_4], 2
.text:0000985C                 mov     ecx, [ebp+var_10]
.text:0000985F                 add     ecx, 24h ; '$'  ; this
.text:00009862                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00009867                 mov     byte ptr [ebp+var_4], 1
.text:0000986B                 mov     ecx, [ebp+var_10]
.text:0000986E                 add     ecx, 18h        ; this
.text:00009871                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00009876                 mov     byte ptr [ebp+var_4], 0
.text:0000987A                 mov     ecx, [ebp+var_10]
.text:0000987D                 add     ecx, 0Ch
.text:00009880                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:00009885                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000988C                 mov     ecx, [ebp+var_10] ; this
.text:0000988F                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00009894                 mov     ecx, [ebp+var_C]
.text:00009897                 mov     large fs:0, ecx
.text:0000989E                 pop     ecx
.text:0000989F                 add     esp, 10h
.text:000098A2                 cmp     ebp, esp
.text:000098A4                 call    __RTC_CheckEsp
.text:000098A9                 mov     esp, ebp
.text:000098AB                 pop     ebp
.text:000098AC                 retn
.text:000098AC ??1CReadArcItem@@QAE@XZ endp
.text:000098AC
.text:000098AC ; ---------------------------------------------------------------------------
.text:000098AD                 align 10h
.text:000098AD _text           ends
.text:000098AD
.text$x:000098B0 ; ===========================================================================
.text$x:000098B0
.text$x:000098B0 ; Segment type: Pure code
.text$x:000098B0 ; Segment permissions: Read/Execute
.text$x:000098B0 _text$x         segment para public 'CODE' use32
.text$x:000098B0                 assume cs:_text$x
.text$x:000098B0                 ;org 98B0h
.text$x:000098B0 ; COMDAT (pick associative to section at 9828)
.text$x:000098B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000098B0
.text$x:000098B0 ; =============== S U B R O U T I N E =======================================
.text$x:000098B0
.text$x:000098B0
.text$x:000098B0 __unwindfunclet$??1CReadArcItem@@QAE@XZ$0 proc near
.text$x:000098B0                                         ; DATA XREF: .xdata$x:000098F0o
.text$x:000098B0                 mov     ecx, [ebp-10h]  ; this
.text$x:000098B3                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000098B3 __unwindfunclet$??1CReadArcItem@@QAE@XZ$0 endp
.text$x:000098B3
.text$x:000098B8
.text$x:000098B8 ; =============== S U B R O U T I N E =======================================
.text$x:000098B8
.text$x:000098B8
.text$x:000098B8 __unwindfunclet$??1CReadArcItem@@QAE@XZ$1 proc near
.text$x:000098B8                                         ; DATA XREF: .xdata$x:000098F8o
.text$x:000098B8                 mov     ecx, [ebp-10h]
.text$x:000098BB                 add     ecx, 0Ch
.text$x:000098BE                 jmp     ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text$x:000098BE __unwindfunclet$??1CReadArcItem@@QAE@XZ$1 endp
.text$x:000098BE
.text$x:000098C3
.text$x:000098C3 ; =============== S U B R O U T I N E =======================================
.text$x:000098C3
.text$x:000098C3
.text$x:000098C3 __unwindfunclet$??1CReadArcItem@@QAE@XZ$2 proc near
.text$x:000098C3                                         ; DATA XREF: .xdata$x:00009900o
.text$x:000098C3                 mov     ecx, [ebp-10h]
.text$x:000098C6                 add     ecx, 18h        ; this
.text$x:000098C9                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000098C9 __unwindfunclet$??1CReadArcItem@@QAE@XZ$2 endp
.text$x:000098C9
.text$x:000098CE
.text$x:000098CE ; =============== S U B R O U T I N E =======================================
.text$x:000098CE
.text$x:000098CE
.text$x:000098CE __ehhandler$??1CReadArcItem@@QAE@XZ proc near
.text$x:000098CE                                         ; DATA XREF: CReadArcItem::~CReadArcItem(void)+5o
.text$x:000098CE
.text$x:000098CE arg_4           = dword ptr  8
.text$x:000098CE
.text$x:000098CE                 mov     edx, [esp+arg_4]
.text$x:000098D2                 lea     eax, [edx+0Ch]
.text$x:000098D5                 mov     ecx, [edx-8]
.text$x:000098D8                 xor     ecx, eax
.text$x:000098DA                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000098DF                 mov     eax, offset __ehfuncinfo$??1CReadArcItem@@QAE@XZ
.text$x:000098E4                 jmp     ___CxxFrameHandler3
.text$x:000098E4 __ehhandler$??1CReadArcItem@@QAE@XZ endp
.text$x:000098E4
.text$x:000098E4 ; ---------------------------------------------------------------------------
.text$x:000098E9                 align 4
.text$x:000098E9 _text$x         ends
.text$x:000098E9
.xdata$x:000098EC ; ===========================================================================
.xdata$x:000098EC
.xdata$x:000098EC ; Segment type: Pure data
.xdata$x:000098EC ; Segment permissions: Read
.xdata$x:000098EC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000098EC                 assume cs:_xdata$x
.xdata$x:000098EC                 ;org 98ECh
.xdata$x:000098EC ; COMDAT (pick associative to section at 9828)
.xdata$x:000098EC __unwindtable$??1CReadArcItem@@QAE@XZ db 0FFh
.xdata$x:000098EC                                         ; DATA XREF: .xdata$x:0000990Co
.xdata$x:000098ED                 db 0FFh
.xdata$x:000098EE                 db 0FFh
.xdata$x:000098EF                 db 0FFh
.xdata$x:000098F0                 dd offset __unwindfunclet$??1CReadArcItem@@QAE@XZ$0
.xdata$x:000098F4                 align 8
.xdata$x:000098F8                 dd offset __unwindfunclet$??1CReadArcItem@@QAE@XZ$1
.xdata$x:000098FC                 db    1
.xdata$x:000098FD                 db    0
.xdata$x:000098FE                 db    0
.xdata$x:000098FF                 db    0
.xdata$x:00009900                 dd offset __unwindfunclet$??1CReadArcItem@@QAE@XZ$2
.xdata$x:00009904 __ehfuncinfo$??1CReadArcItem@@QAE@XZ db  22h ; "
.xdata$x:00009904                                         ; DATA XREF: __ehhandler$??1CReadArcItem@@QAE@XZ+11o
.xdata$x:00009905                 db    5
.xdata$x:00009906                 db  93h ; 
.xdata$x:00009907                 db  19h
.xdata$x:00009908                 db    3
.xdata$x:00009909                 db    0
.xdata$x:0000990A                 db    0
.xdata$x:0000990B                 db    0
.xdata$x:0000990C                 dd offset __unwindtable$??1CReadArcItem@@QAE@XZ
.xdata$x:00009910                 db    0
.xdata$x:00009911                 db    0
.xdata$x:00009912                 db    0
.xdata$x:00009913                 db    0
.xdata$x:00009914                 db    0
.xdata$x:00009915                 db    0
.xdata$x:00009916                 db    0
.xdata$x:00009917                 db    0
.xdata$x:00009918                 db    0
.xdata$x:00009919                 db    0
.xdata$x:0000991A                 db    0
.xdata$x:0000991B                 db    0
.xdata$x:0000991C                 db    0
.xdata$x:0000991D                 db    0
.xdata$x:0000991E                 db    0
.xdata$x:0000991F                 db    0
.xdata$x:00009920                 db    0
.xdata$x:00009921                 db    0
.xdata$x:00009922                 db    0
.xdata$x:00009923                 db    0
.xdata$x:00009924                 db    1
.xdata$x:00009925                 db    0
.xdata$x:00009926                 db    0
.xdata$x:00009927                 db    0
.xdata$x:00009927 _xdata$x        ends
.xdata$x:00009927
.text:00009928 ; ===========================================================================
.text:00009928
.text:00009928 ; Segment type: Pure code
.text:00009928 ; Segment permissions: Read/Execute
.text:00009928 _text           segment para public 'CODE' use32
.text:00009928                 assume cs:_text
.text:00009928                 ;org 9928h
.text:00009928 ; COMDAT (pick any)
.text:00009928                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009928
.text:00009928 ; =============== S U B R O U T I N E =======================================
.text:00009928
.text:00009928 ; Attributes: bp-based frame
.text:00009928
.text:00009928 ; _DWORD __thiscall CArcItem::~CArcItem(CArcItem *__hidden this)
.text:00009928                 public ??1CArcItem@@QAE@XZ
.text:00009928 ??1CArcItem@@QAE@XZ proc near           ; CODE XREF: EnumerateInArchiveItems(NWildcard::CCensor const &,CArc const &,CObjectVector<CArcItem> &)+F8p
.text:00009928                                         ; EnumerateInArchiveItems(NWildcard::CCensor const &,CArc const &,CObjectVector<CArcItem> &)+187p ...
.text:00009928
.text:00009928 var_4           = dword ptr -4
.text:00009928
.text:00009928                 push    ebp
.text:00009929                 mov     ebp, esp
.text:0000992B                 push    ecx
.text:0000992C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00009933                 mov     [ebp+var_4], ecx
.text:00009936                 mov     ecx, [ebp+var_4]
.text:00009939                 add     ecx, 10h        ; this
.text:0000993C                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00009941                 add     esp, 4
.text:00009944                 cmp     ebp, esp
.text:00009946                 call    __RTC_CheckEsp
.text:0000994B                 mov     esp, ebp
.text:0000994D                 pop     ebp
.text:0000994E                 retn
.text:0000994E ??1CArcItem@@QAE@XZ endp
.text:0000994E
.text:0000994E ; ---------------------------------------------------------------------------
.text:0000994F                 align 10h
.text:0000994F _text           ends
.text:0000994F
.text:00009950 ; ===========================================================================
.text:00009950
.text:00009950 ; Segment type: Pure code
.text:00009950 ; Segment permissions: Read/Execute
.text:00009950 _text           segment para public 'CODE' use32
.text:00009950                 assume cs:_text
.text:00009950                 ;org 9950h
.text:00009950 ; COMDAT (pick any)
.text:00009950                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009950
.text:00009950 ; =============== S U B R O U T I N E =======================================
.text:00009950
.text:00009950 ; Attributes: bp-based frame
.text:00009950
.text:00009950 ; _DWORD __thiscall CProperty::CProperty(CProperty *__hidden this)
.text:00009950                 public ??0CProperty@@QAE@XZ
.text:00009950 ??0CProperty@@QAE@XZ proc near          ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+188p
.text:00009950
.text:00009950 var_10          = dword ptr -10h
.text:00009950 var_C           = dword ptr -0Ch
.text:00009950 var_4           = dword ptr -4
.text:00009950
.text:00009950                 push    ebp
.text:00009951                 mov     ebp, esp
.text:00009953                 push    0FFFFFFFFh
.text:00009955                 push    offset __ehhandler$??0CProperty@@QAE@XZ
.text:0000995A                 mov     eax, large fs:0
.text:00009960                 push    eax
.text:00009961                 push    ecx
.text:00009962                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00009969                 mov     eax, dword ptr ds:___security_cookie
.text:0000996E                 xor     eax, ebp
.text:00009970                 push    eax
.text:00009971                 lea     eax, [ebp+var_C]
.text:00009974                 mov     large fs:0, eax
.text:0000997A                 mov     [ebp+var_10], ecx
.text:0000997D                 mov     ecx, [ebp+var_10]
.text:00009980                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00009985                 mov     [ebp+var_4], 0
.text:0000998C                 mov     ecx, [ebp+var_10]
.text:0000998F                 add     ecx, 0Ch
.text:00009992                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00009997                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000999E                 mov     eax, [ebp+var_10]
.text:000099A1                 mov     ecx, [ebp+var_C]
.text:000099A4                 mov     large fs:0, ecx
.text:000099AB                 pop     ecx
.text:000099AC                 add     esp, 10h
.text:000099AF                 cmp     ebp, esp
.text:000099B1                 call    __RTC_CheckEsp
.text:000099B6                 mov     esp, ebp
.text:000099B8                 pop     ebp
.text:000099B9                 retn
.text:000099B9 ??0CProperty@@QAE@XZ endp
.text:000099B9
.text:000099B9 ; ---------------------------------------------------------------------------
.text:000099BA                 align 4
.text:000099BA _text           ends
.text:000099BA
.text$x:000099BC ; ===========================================================================
.text$x:000099BC
.text$x:000099BC ; Segment type: Pure code
.text$x:000099BC ; Segment permissions: Read/Execute
.text$x:000099BC _text$x         segment para public 'CODE' use32
.text$x:000099BC                 assume cs:_text$x
.text$x:000099BC                 ;org 99BCh
.text$x:000099BC ; COMDAT (pick associative to section at 9950)
.text$x:000099BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000099BC
.text$x:000099BC ; =============== S U B R O U T I N E =======================================
.text$x:000099BC
.text$x:000099BC
.text$x:000099BC __unwindfunclet$??0CProperty@@QAE@XZ$0 proc near
.text$x:000099BC                                         ; DATA XREF: .xdata$x:000099E4o
.text$x:000099BC                 mov     ecx, [ebp-10h]  ; this
.text$x:000099BF                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000099BF __unwindfunclet$??0CProperty@@QAE@XZ$0 endp
.text$x:000099BF
.text$x:000099C4
.text$x:000099C4 ; =============== S U B R O U T I N E =======================================
.text$x:000099C4
.text$x:000099C4
.text$x:000099C4 __ehhandler$??0CProperty@@QAE@XZ proc near
.text$x:000099C4                                         ; DATA XREF: CProperty::CProperty(void)+5o
.text$x:000099C4
.text$x:000099C4 arg_4           = dword ptr  8
.text$x:000099C4
.text$x:000099C4                 mov     edx, [esp+arg_4]
.text$x:000099C8                 lea     eax, [edx+0Ch]
.text$x:000099CB                 mov     ecx, [edx-8]
.text$x:000099CE                 xor     ecx, eax
.text$x:000099D0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000099D5                 mov     eax, offset __ehfuncinfo$??0CProperty@@QAE@XZ
.text$x:000099DA                 jmp     ___CxxFrameHandler3
.text$x:000099DA __ehhandler$??0CProperty@@QAE@XZ endp
.text$x:000099DA
.text$x:000099DA ; ---------------------------------------------------------------------------
.text$x:000099DF                 align 10h
.text$x:000099DF _text$x         ends
.text$x:000099DF
.xdata$x:000099E0 ; ===========================================================================
.xdata$x:000099E0
.xdata$x:000099E0 ; Segment type: Pure data
.xdata$x:000099E0 ; Segment permissions: Read
.xdata$x:000099E0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000099E0                 assume cs:_xdata$x
.xdata$x:000099E0                 ;org 99E0h
.xdata$x:000099E0 ; COMDAT (pick associative to section at 9950)
.xdata$x:000099E0 __unwindtable$??0CProperty@@QAE@XZ db 0FFh ; DATA XREF: .xdata$x:000099F0o
.xdata$x:000099E1                 db 0FFh
.xdata$x:000099E2                 db 0FFh
.xdata$x:000099E3                 db 0FFh
.xdata$x:000099E4                 dd offset __unwindfunclet$??0CProperty@@QAE@XZ$0
.xdata$x:000099E8 __ehfuncinfo$??0CProperty@@QAE@XZ db  22h ; "
.xdata$x:000099E8                                         ; DATA XREF: __ehhandler$??0CProperty@@QAE@XZ+11o
.xdata$x:000099E9                 db    5
.xdata$x:000099EA                 db  93h ; 
.xdata$x:000099EB                 db  19h
.xdata$x:000099EC                 db    1
.xdata$x:000099ED                 db    0
.xdata$x:000099EE                 db    0
.xdata$x:000099EF                 db    0
.xdata$x:000099F0                 dd offset __unwindtable$??0CProperty@@QAE@XZ
.xdata$x:000099F4                 db    0
.xdata$x:000099F5                 db    0
.xdata$x:000099F6                 db    0
.xdata$x:000099F7                 db    0
.xdata$x:000099F8                 db    0
.xdata$x:000099F9                 db    0
.xdata$x:000099FA                 db    0
.xdata$x:000099FB                 db    0
.xdata$x:000099FC                 db    0
.xdata$x:000099FD                 db    0
.xdata$x:000099FE                 db    0
.xdata$x:000099FF                 db    0
.xdata$x:00009A00                 db    0
.xdata$x:00009A01                 db    0
.xdata$x:00009A02                 db    0
.xdata$x:00009A03                 db    0
.xdata$x:00009A04                 db    0
.xdata$x:00009A05                 db    0
.xdata$x:00009A06                 db    0
.xdata$x:00009A07                 db    0
.xdata$x:00009A08                 db    1
.xdata$x:00009A09                 db    0
.xdata$x:00009A0A                 db    0
.xdata$x:00009A0B                 db    0
.xdata$x:00009A0B _xdata$x        ends
.xdata$x:00009A0B
.text:00009A0C ; ===========================================================================
.text:00009A0C
.text:00009A0C ; Segment type: Pure code
.text:00009A0C ; Segment permissions: Read/Execute
.text:00009A0C _text           segment para public 'CODE' use32
.text:00009A0C                 assume cs:_text
.text:00009A0C                 ;org 9A0Ch
.text:00009A0C ; COMDAT (pick any)
.text:00009A0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009A0C
.text:00009A0C ; =============== S U B R O U T I N E =======================================
.text:00009A0C
.text:00009A0C ; Attributes: bp-based frame
.text:00009A0C
.text:00009A0C ; _DWORD __thiscall CProperty::~CProperty(CProperty *__hidden this)
.text:00009A0C                 public ??1CProperty@@QAE@XZ
.text:00009A0C ??1CProperty@@QAE@XZ proc near          ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1E9p
.text:00009A0C                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+2E1p ...
.text:00009A0C
.text:00009A0C var_10          = dword ptr -10h
.text:00009A0C var_C           = dword ptr -0Ch
.text:00009A0C var_4           = dword ptr -4
.text:00009A0C
.text:00009A0C                 push    ebp
.text:00009A0D                 mov     ebp, esp
.text:00009A0F                 push    0FFFFFFFFh
.text:00009A11                 push    offset __ehhandler$??1CProperty@@QAE@XZ
.text:00009A16                 mov     eax, large fs:0
.text:00009A1C                 push    eax
.text:00009A1D                 push    ecx
.text:00009A1E                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00009A25                 mov     eax, dword ptr ds:___security_cookie
.text:00009A2A                 xor     eax, ebp
.text:00009A2C                 push    eax
.text:00009A2D                 lea     eax, [ebp+var_C]
.text:00009A30                 mov     large fs:0, eax
.text:00009A36                 mov     [ebp+var_10], ecx
.text:00009A39                 mov     [ebp+var_4], 0
.text:00009A40                 mov     ecx, [ebp+var_10]
.text:00009A43                 add     ecx, 0Ch        ; this
.text:00009A46                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00009A4B                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00009A52                 mov     ecx, [ebp+var_10] ; this
.text:00009A55                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00009A5A                 mov     ecx, [ebp+var_C]
.text:00009A5D                 mov     large fs:0, ecx
.text:00009A64                 pop     ecx
.text:00009A65                 add     esp, 10h
.text:00009A68                 cmp     ebp, esp
.text:00009A6A                 call    __RTC_CheckEsp
.text:00009A6F                 mov     esp, ebp
.text:00009A71                 pop     ebp
.text:00009A72                 retn
.text:00009A72 ??1CProperty@@QAE@XZ endp
.text:00009A72
.text:00009A72 ; ---------------------------------------------------------------------------
.text:00009A73                 align 4
.text:00009A73 _text           ends
.text:00009A73
.text$x:00009A74 ; ===========================================================================
.text$x:00009A74
.text$x:00009A74 ; Segment type: Pure code
.text$x:00009A74 ; Segment permissions: Read/Execute
.text$x:00009A74 _text$x         segment para public 'CODE' use32
.text$x:00009A74                 assume cs:_text$x
.text$x:00009A74                 ;org 9A74h
.text$x:00009A74 ; COMDAT (pick associative to section at 9A0C)
.text$x:00009A74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00009A74
.text$x:00009A74 ; =============== S U B R O U T I N E =======================================
.text$x:00009A74
.text$x:00009A74
.text$x:00009A74 __unwindfunclet$??1CProperty@@QAE@XZ$0 proc near
.text$x:00009A74                                         ; DATA XREF: .xdata$x:00009A9Co
.text$x:00009A74                 mov     ecx, [ebp-10h]  ; this
.text$x:00009A77                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00009A77 __unwindfunclet$??1CProperty@@QAE@XZ$0 endp
.text$x:00009A77
.text$x:00009A7C
.text$x:00009A7C ; =============== S U B R O U T I N E =======================================
.text$x:00009A7C
.text$x:00009A7C
.text$x:00009A7C __ehhandler$??1CProperty@@QAE@XZ proc near
.text$x:00009A7C                                         ; DATA XREF: CProperty::~CProperty(void)+5o
.text$x:00009A7C
.text$x:00009A7C arg_4           = dword ptr  8
.text$x:00009A7C
.text$x:00009A7C                 mov     edx, [esp+arg_4]
.text$x:00009A80                 lea     eax, [edx+0Ch]
.text$x:00009A83                 mov     ecx, [edx-8]
.text$x:00009A86                 xor     ecx, eax
.text$x:00009A88                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009A8D                 mov     eax, offset __ehfuncinfo$??1CProperty@@QAE@XZ
.text$x:00009A92                 jmp     ___CxxFrameHandler3
.text$x:00009A92 __ehhandler$??1CProperty@@QAE@XZ endp
.text$x:00009A92
.text$x:00009A92 ; ---------------------------------------------------------------------------
.text$x:00009A97                 align 4
.text$x:00009A97 _text$x         ends
.text$x:00009A97
.xdata$x:00009A98 ; ===========================================================================
.xdata$x:00009A98
.xdata$x:00009A98 ; Segment type: Pure data
.xdata$x:00009A98 ; Segment permissions: Read
.xdata$x:00009A98 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009A98                 assume cs:_xdata$x
.xdata$x:00009A98                 ;org 9A98h
.xdata$x:00009A98 ; COMDAT (pick associative to section at 9A0C)
.xdata$x:00009A98 __unwindtable$??1CProperty@@QAE@XZ db 0FFh ; DATA XREF: .xdata$x:00009AA8o
.xdata$x:00009A99                 db 0FFh
.xdata$x:00009A9A                 db 0FFh
.xdata$x:00009A9B                 db 0FFh
.xdata$x:00009A9C                 dd offset __unwindfunclet$??1CProperty@@QAE@XZ$0
.xdata$x:00009AA0 __ehfuncinfo$??1CProperty@@QAE@XZ db  22h ; "
.xdata$x:00009AA0                                         ; DATA XREF: __ehhandler$??1CProperty@@QAE@XZ+11o
.xdata$x:00009AA1                 db    5
.xdata$x:00009AA2                 db  93h ; 
.xdata$x:00009AA3                 db  19h
.xdata$x:00009AA4                 db    1
.xdata$x:00009AA5                 db    0
.xdata$x:00009AA6                 db    0
.xdata$x:00009AA7                 db    0
.xdata$x:00009AA8                 dd offset __unwindtable$??1CProperty@@QAE@XZ
.xdata$x:00009AAC                 align 20h
.xdata$x:00009AC0                 db    1
.xdata$x:00009AC1                 db    0
.xdata$x:00009AC2                 db    0
.xdata$x:00009AC3                 db    0
.xdata$x:00009AC3 _xdata$x        ends
.xdata$x:00009AC3
.text:00009AC4 ; ===========================================================================
.text:00009AC4
.text:00009AC4 ; Segment type: Pure code
.text:00009AC4 ; Segment permissions: Read/Execute
.text:00009AC4 _text           segment para public 'CODE' use32
.text:00009AC4                 assume cs:_text
.text:00009AC4                 ;org 9AC4h
.text:00009AC4 ; COMDAT (pick any)
.text:00009AC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009AC4
.text:00009AC4 ; =============== S U B R O U T I N E =======================================
.text:00009AC4
.text:00009AC4 ; Attributes: bp-based frame
.text:00009AC4
.text:00009AC4 ; _DWORD __thiscall COpenOptions::~COpenOptions(COpenOptions *__hidden this)
.text:00009AC4                 public ??1COpenOptions@@QAE@XZ
.text:00009AC4 ??1COpenOptions@@QAE@XZ proc near       ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+633p
.text:00009AC4                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+6CFp ...
.text:00009AC4
.text:00009AC4 var_4           = dword ptr -4
.text:00009AC4
.text:00009AC4                 push    ebp
.text:00009AC5                 mov     ebp, esp
.text:00009AC7                 push    ecx
.text:00009AC8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00009ACF                 mov     [ebp+var_4], ecx
.text:00009AD2                 mov     ecx, [ebp+var_4]
.text:00009AD5                 add     ecx, 48h ; 'H'  ; this
.text:00009AD8                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00009ADD                 add     esp, 4
.text:00009AE0                 cmp     ebp, esp
.text:00009AE2                 call    __RTC_CheckEsp
.text:00009AE7                 mov     esp, ebp
.text:00009AE9                 pop     ebp
.text:00009AEA                 retn
.text:00009AEA ??1COpenOptions@@QAE@XZ endp
.text:00009AEA
.text:00009AEA ; ---------------------------------------------------------------------------
.text:00009AEB                 align 4
.text:00009AEB _text           ends
.text:00009AEB
.text:00009AEC ; ===========================================================================
.text:00009AEC
.text:00009AEC ; Segment type: Pure code
.text:00009AEC ; Segment permissions: Read/Execute
.text:00009AEC _text           segment para public 'CODE' use32
.text:00009AEC                 assume cs:_text
.text:00009AEC                 ;org 9AECh
.text:00009AEC ; COMDAT (pick any)
.text:00009AEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009AEC
.text:00009AEC ; =============== S U B R O U T I N E =======================================
.text:00009AEC
.text:00009AEC ; Attributes: bp-based frame
.text:00009AEC
.text:00009AEC ; _DWORD __thiscall CDirItems::~CDirItems(CDirItems *__hidden this)
.text:00009AEC                 public ??1CDirItems@@QAE@XZ
.text:00009AEC ??1CDirItems@@QAE@XZ proc near          ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+DA1p
.text:00009AEC                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+E72p ...
.text:00009AEC
.text:00009AEC var_10          = dword ptr -10h
.text:00009AEC var_C           = dword ptr -0Ch
.text:00009AEC var_4           = dword ptr -4
.text:00009AEC
.text:00009AEC                 push    ebp
.text:00009AED                 mov     ebp, esp
.text:00009AEF                 push    0FFFFFFFFh
.text:00009AF1                 push    offset __ehhandler$??1CDirItems@@QAE@XZ
.text:00009AF6                 mov     eax, large fs:0
.text:00009AFC                 push    eax
.text:00009AFD                 push    ecx
.text:00009AFE                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00009B05                 mov     eax, dword ptr ds:___security_cookie
.text:00009B0A                 xor     eax, ebp
.text:00009B0C                 push    eax
.text:00009B0D                 lea     eax, [ebp+var_C]
.text:00009B10                 mov     large fs:0, eax
.text:00009B16                 mov     [ebp+var_10], ecx
.text:00009B19                 mov     [ebp+var_4], 4
.text:00009B20                 mov     ecx, [ebp+var_10]
.text:00009B23                 add     ecx, 8Ch ; ''
.text:00009B29                 call    ??1?$CBuffer@E@@QAE@XZ ; CBuffer<uchar>::~CBuffer<uchar>(void)
.text:00009B2E                 mov     byte ptr [ebp+var_4], 3
.text:00009B32                 mov     ecx, [ebp+var_10]
.text:00009B35                 add     ecx, 68h ; 'h'  ; this
.text:00009B38                 call    ??1CUniqBlocks@@QAE@XZ ; CUniqBlocks::~CUniqBlocks(void)
.text:00009B3D                 mov     byte ptr [ebp+var_4], 2
.text:00009B41                 mov     ecx, [ebp+var_10]
.text:00009B44                 add     ecx, 24h ; '$'
.text:00009B47                 call    ??1?$CObjectVector@UCDirItem@@@@QAE@XZ ; CObjectVector<CDirItem>::~CObjectVector<CDirItem>(void)
.text:00009B4C                 mov     byte ptr [ebp+var_4], 1
.text:00009B50                 mov     ecx, [ebp+var_10]
.text:00009B53                 add     ecx, 18h
.text:00009B56                 call    ??1?$CRecordVector@H@@QAE@XZ ; CRecordVector<int>::~CRecordVector<int>(void)
.text:00009B5B                 mov     byte ptr [ebp+var_4], 0
.text:00009B5F                 mov     ecx, [ebp+var_10]
.text:00009B62                 add     ecx, 0Ch
.text:00009B65                 call    ??1?$CRecordVector@H@@QAE@XZ ; CRecordVector<int>::~CRecordVector<int>(void)
.text:00009B6A                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00009B71                 mov     ecx, [ebp+var_10]
.text:00009B74                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:00009B79                 mov     ecx, [ebp+var_C]
.text:00009B7C                 mov     large fs:0, ecx
.text:00009B83                 pop     ecx
.text:00009B84                 add     esp, 10h
.text:00009B87                 cmp     ebp, esp
.text:00009B89                 call    __RTC_CheckEsp
.text:00009B8E                 mov     esp, ebp
.text:00009B90                 pop     ebp
.text:00009B91                 retn
.text:00009B91 ??1CDirItems@@QAE@XZ endp
.text:00009B91
.text:00009B91 ; ---------------------------------------------------------------------------
.text:00009B92                 align 4
.text:00009B92 _text           ends
.text:00009B92
.text$x:00009B94 ; ===========================================================================
.text$x:00009B94
.text$x:00009B94 ; Segment type: Pure code
.text$x:00009B94 ; Segment permissions: Read/Execute
.text$x:00009B94 _text$x         segment para public 'CODE' use32
.text$x:00009B94                 assume cs:_text$x
.text$x:00009B94                 ;org 9B94h
.text$x:00009B94 ; COMDAT (pick associative to section at 9AEC)
.text$x:00009B94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00009B94
.text$x:00009B94 ; =============== S U B R O U T I N E =======================================
.text$x:00009B94
.text$x:00009B94
.text$x:00009B94 __unwindfunclet$??1CDirItems@@QAE@XZ$0 proc near
.text$x:00009B94                                         ; DATA XREF: .xdata$x:00009C0Co
.text$x:00009B94                 mov     ecx, [ebp-10h]
.text$x:00009B97                 jmp     ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text$x:00009B97 __unwindfunclet$??1CDirItems@@QAE@XZ$0 endp
.text$x:00009B97
.text$x:00009B9C
.text$x:00009B9C ; =============== S U B R O U T I N E =======================================
.text$x:00009B9C
.text$x:00009B9C
.text$x:00009B9C __unwindfunclet$??1CDirItems@@QAE@XZ$1 proc near
.text$x:00009B9C                                         ; DATA XREF: .xdata$x:00009C14o
.text$x:00009B9C                 mov     ecx, [ebp-10h]
.text$x:00009B9F                 add     ecx, 0Ch
.text$x:00009BA2                 jmp     ??1?$CRecordVector@H@@QAE@XZ ; CRecordVector<int>::~CRecordVector<int>(void)
.text$x:00009BA2 __unwindfunclet$??1CDirItems@@QAE@XZ$1 endp
.text$x:00009BA2
.text$x:00009BA7
.text$x:00009BA7 ; =============== S U B R O U T I N E =======================================
.text$x:00009BA7
.text$x:00009BA7
.text$x:00009BA7 __unwindfunclet$??1CDirItems@@QAE@XZ$2 proc near
.text$x:00009BA7                                         ; DATA XREF: .xdata$x:00009C1Co
.text$x:00009BA7                 mov     ecx, [ebp-10h]
.text$x:00009BAA                 add     ecx, 18h
.text$x:00009BAD                 jmp     ??1?$CRecordVector@H@@QAE@XZ ; CRecordVector<int>::~CRecordVector<int>(void)
.text$x:00009BAD __unwindfunclet$??1CDirItems@@QAE@XZ$2 endp
.text$x:00009BAD
.text$x:00009BB2
.text$x:00009BB2 ; =============== S U B R O U T I N E =======================================
.text$x:00009BB2
.text$x:00009BB2
.text$x:00009BB2 __unwindfunclet$??1CDirItems@@QAE@XZ$3 proc near
.text$x:00009BB2                                         ; DATA XREF: .xdata$x:00009C24o
.text$x:00009BB2                 mov     ecx, [ebp-10h]
.text$x:00009BB5                 add     ecx, 24h ; '$'
.text$x:00009BB8                 jmp     ??1?$CObjectVector@UCDirItem@@@@QAE@XZ ; CObjectVector<CDirItem>::~CObjectVector<CDirItem>(void)
.text$x:00009BB8 __unwindfunclet$??1CDirItems@@QAE@XZ$3 endp
.text$x:00009BB8
.text$x:00009BBD
.text$x:00009BBD ; =============== S U B R O U T I N E =======================================
.text$x:00009BBD
.text$x:00009BBD
.text$x:00009BBD __unwindfunclet$??1CDirItems@@QAE@XZ$4 proc near
.text$x:00009BBD                                         ; DATA XREF: .xdata$x:00009C2Co
.text$x:00009BBD                 mov     ecx, [ebp-10h]
.text$x:00009BC0                 add     ecx, 68h ; 'h'  ; this
.text$x:00009BC3                 jmp     ??1CUniqBlocks@@QAE@XZ ; CUniqBlocks::~CUniqBlocks(void)
.text$x:00009BC3 __unwindfunclet$??1CDirItems@@QAE@XZ$4 endp
.text$x:00009BC3
.text$x:00009BC8
.text$x:00009BC8 ; =============== S U B R O U T I N E =======================================
.text$x:00009BC8
.text$x:00009BC8
.text$x:00009BC8 __ehhandler$??1CDirItems@@QAE@XZ proc near
.text$x:00009BC8                                         ; DATA XREF: CDirItems::~CDirItems(void)+5o
.text$x:00009BC8
.text$x:00009BC8 arg_4           = dword ptr  8
.text$x:00009BC8
.text$x:00009BC8                 mov     edx, [esp+arg_4]
.text$x:00009BCC                 lea     eax, [edx+0Ch]
.text$x:00009BCF                 mov     ecx, [edx-8]
.text$x:00009BD2                 xor     ecx, eax
.text$x:00009BD4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009BD9                 mov     eax, offset __ehfuncinfo$??1CDirItems@@QAE@XZ
.text$x:00009BDE                 jmp     ___CxxFrameHandler3
.text$x:00009BDE __ehhandler$??1CDirItems@@QAE@XZ endp
.text$x:00009BDE
.text$x:00009BDE ; ---------------------------------------------------------------------------
.text$x:00009BE3                 align 4
.text$x:00009BE3 _text$x         ends
.text$x:00009BE3
.xdata$x:00009BE4 ; ===========================================================================
.xdata$x:00009BE4
.xdata$x:00009BE4 ; Segment type: Pure data
.xdata$x:00009BE4 ; Segment permissions: Read
.xdata$x:00009BE4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009BE4                 assume cs:_xdata$x
.xdata$x:00009BE4                 ;org 9BE4h
.xdata$x:00009BE4 ; COMDAT (pick associative to section at 9AEC)
.xdata$x:00009BE4 __ehfuncinfo$??1CDirItems@@QAE@XZ db  22h ; "
.xdata$x:00009BE4                                         ; DATA XREF: __ehhandler$??1CDirItems@@QAE@XZ+11o
.xdata$x:00009BE5                 db    5
.xdata$x:00009BE6                 db  93h ; 
.xdata$x:00009BE7                 db  19h
.xdata$x:00009BE8                 db    5
.xdata$x:00009BE9                 db    0
.xdata$x:00009BEA                 db    0
.xdata$x:00009BEB                 db    0
.xdata$x:00009BEC                 dd offset __unwindtable$??1CDirItems@@QAE@XZ
.xdata$x:00009BF0                 db    0
.xdata$x:00009BF1                 db    0
.xdata$x:00009BF2                 db    0
.xdata$x:00009BF3                 db    0
.xdata$x:00009BF4                 db    0
.xdata$x:00009BF5                 db    0
.xdata$x:00009BF6                 db    0
.xdata$x:00009BF7                 db    0
.xdata$x:00009BF8                 db    0
.xdata$x:00009BF9                 db    0
.xdata$x:00009BFA                 db    0
.xdata$x:00009BFB                 db    0
.xdata$x:00009BFC                 db    0
.xdata$x:00009BFD                 db    0
.xdata$x:00009BFE                 db    0
.xdata$x:00009BFF                 db    0
.xdata$x:00009C00                 db    0
.xdata$x:00009C01                 db    0
.xdata$x:00009C02                 db    0
.xdata$x:00009C03                 db    0
.xdata$x:00009C04                 db    1
.xdata$x:00009C05                 db    0
.xdata$x:00009C06                 db    0
.xdata$x:00009C07                 db    0
.xdata$x:00009C08 __unwindtable$??1CDirItems@@QAE@XZ db 0FFh ; DATA XREF: .xdata$x:00009BECo
.xdata$x:00009C09                 db 0FFh
.xdata$x:00009C0A                 db 0FFh
.xdata$x:00009C0B                 db 0FFh
.xdata$x:00009C0C                 dd offset __unwindfunclet$??1CDirItems@@QAE@XZ$0
.xdata$x:00009C10                 db    0
.xdata$x:00009C11                 db    0
.xdata$x:00009C12                 db    0
.xdata$x:00009C13                 db    0
.xdata$x:00009C14                 dd offset __unwindfunclet$??1CDirItems@@QAE@XZ$1
.xdata$x:00009C18                 db    1
.xdata$x:00009C19                 db    0
.xdata$x:00009C1A                 db    0
.xdata$x:00009C1B                 db    0
.xdata$x:00009C1C                 dd offset __unwindfunclet$??1CDirItems@@QAE@XZ$2
.xdata$x:00009C20                 db    2
.xdata$x:00009C21                 db    0
.xdata$x:00009C22                 db    0
.xdata$x:00009C23                 db    0
.xdata$x:00009C24                 dd offset __unwindfunclet$??1CDirItems@@QAE@XZ$3
.xdata$x:00009C28                 db    3
.xdata$x:00009C29                 db    0
.xdata$x:00009C2A                 db    0
.xdata$x:00009C2B                 db    0
.xdata$x:00009C2C                 dd offset __unwindfunclet$??1CDirItems@@QAE@XZ$4
.xdata$x:00009C2C _xdata$x        ends
.xdata$x:00009C2C
.text:00009C30 ; ===========================================================================
.text:00009C30
.text:00009C30 ; Segment type: Pure code
.text:00009C30 ; Segment permissions: Read/Execute
.text:00009C30 _text           segment para public 'CODE' use32
.text:00009C30                 assume cs:_text
.text:00009C30                 ;org 9C30h
.text:00009C30 ; COMDAT (pick any)
.text:00009C30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009C30
.text:00009C30 ; =============== S U B R O U T I N E =======================================
.text:00009C30
.text:00009C30 ; Attributes: bp-based frame
.text:00009C30
.text:00009C30 ; _DWORD __thiscall CDirItem::~CDirItem(CDirItem *__hidden this)
.text:00009C30                 public ??1CDirItem@@QAE@XZ
.text:00009C30 ??1CDirItem@@QAE@XZ proc near           ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+CD5p
.text:00009C30                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+D92p ...
.text:00009C30
.text:00009C30 var_10          = dword ptr -10h
.text:00009C30 var_C           = dword ptr -0Ch
.text:00009C30 var_4           = dword ptr -4
.text:00009C30
.text:00009C30                 push    ebp
.text:00009C31                 mov     ebp, esp
.text:00009C33                 push    0FFFFFFFFh
.text:00009C35                 push    offset __ehhandler$??1CDirItem@@QAE@XZ
.text:00009C3A                 mov     eax, large fs:0
.text:00009C40                 push    eax
.text:00009C41                 push    ecx
.text:00009C42                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00009C49                 mov     eax, dword ptr ds:___security_cookie
.text:00009C4E                 xor     eax, ebp
.text:00009C50                 push    eax
.text:00009C51                 lea     eax, [ebp+var_C]
.text:00009C54                 mov     large fs:0, eax
.text:00009C5A                 mov     [ebp+var_10], ecx
.text:00009C5D                 mov     [ebp+var_4], 1
.text:00009C64                 mov     ecx, [ebp+var_10]
.text:00009C67                 add     ecx, 34h ; '4'
.text:00009C6A                 call    ??1?$CBuffer@E@@QAE@XZ ; CBuffer<uchar>::~CBuffer<uchar>(void)
.text:00009C6F                 mov     byte ptr [ebp+var_4], 0
.text:00009C73                 mov     ecx, [ebp+var_10]
.text:00009C76                 add     ecx, 2Ch ; ','
.text:00009C79                 call    ??1?$CBuffer@E@@QAE@XZ ; CBuffer<uchar>::~CBuffer<uchar>(void)
.text:00009C7E                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00009C85                 mov     ecx, [ebp+var_10]
.text:00009C88                 add     ecx, 20h ; ' '  ; this
.text:00009C8B                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00009C90                 mov     ecx, [ebp+var_C]
.text:00009C93                 mov     large fs:0, ecx
.text:00009C9A                 pop     ecx
.text:00009C9B                 add     esp, 10h
.text:00009C9E                 cmp     ebp, esp
.text:00009CA0                 call    __RTC_CheckEsp
.text:00009CA5                 mov     esp, ebp
.text:00009CA7                 pop     ebp
.text:00009CA8                 retn
.text:00009CA8 ??1CDirItem@@QAE@XZ endp
.text:00009CA8
.text:00009CA8 ; ---------------------------------------------------------------------------
.text:00009CA9                 align 4
.text:00009CA9 _text           ends
.text:00009CA9
.text$x:00009CAC ; ===========================================================================
.text$x:00009CAC
.text$x:00009CAC ; Segment type: Pure code
.text$x:00009CAC ; Segment permissions: Read/Execute
.text$x:00009CAC _text$x         segment para public 'CODE' use32
.text$x:00009CAC                 assume cs:_text$x
.text$x:00009CAC                 ;org 9CACh
.text$x:00009CAC ; COMDAT (pick associative to section at 9C30)
.text$x:00009CAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00009CAC
.text$x:00009CAC ; =============== S U B R O U T I N E =======================================
.text$x:00009CAC
.text$x:00009CAC
.text$x:00009CAC __unwindfunclet$??1CDirItem@@QAE@XZ$0 proc near
.text$x:00009CAC                                         ; DATA XREF: .xdata$x:00009CE4o
.text$x:00009CAC                 mov     ecx, [ebp-10h]
.text$x:00009CAF                 add     ecx, 20h ; ' '  ; this
.text$x:00009CB2                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00009CB2 __unwindfunclet$??1CDirItem@@QAE@XZ$0 endp
.text$x:00009CB2
.text$x:00009CB7
.text$x:00009CB7 ; =============== S U B R O U T I N E =======================================
.text$x:00009CB7
.text$x:00009CB7
.text$x:00009CB7 __unwindfunclet$??1CDirItem@@QAE@XZ$1 proc near
.text$x:00009CB7                                         ; DATA XREF: .xdata$x:00009CECo
.text$x:00009CB7                 mov     ecx, [ebp-10h]
.text$x:00009CBA                 add     ecx, 2Ch ; ','
.text$x:00009CBD                 jmp     ??1?$CBuffer@E@@QAE@XZ ; CBuffer<uchar>::~CBuffer<uchar>(void)
.text$x:00009CBD __unwindfunclet$??1CDirItem@@QAE@XZ$1 endp
.text$x:00009CBD
.text$x:00009CC2
.text$x:00009CC2 ; =============== S U B R O U T I N E =======================================
.text$x:00009CC2
.text$x:00009CC2
.text$x:00009CC2 __ehhandler$??1CDirItem@@QAE@XZ proc near
.text$x:00009CC2                                         ; DATA XREF: CDirItem::~CDirItem(void)+5o
.text$x:00009CC2
.text$x:00009CC2 arg_4           = dword ptr  8
.text$x:00009CC2
.text$x:00009CC2                 mov     edx, [esp+arg_4]
.text$x:00009CC6                 lea     eax, [edx+0Ch]
.text$x:00009CC9                 mov     ecx, [edx-8]
.text$x:00009CCC                 xor     ecx, eax
.text$x:00009CCE                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009CD3                 mov     eax, offset __ehfuncinfo$??1CDirItem@@QAE@XZ
.text$x:00009CD8                 jmp     ___CxxFrameHandler3
.text$x:00009CD8 __ehhandler$??1CDirItem@@QAE@XZ endp
.text$x:00009CD8
.text$x:00009CD8 ; ---------------------------------------------------------------------------
.text$x:00009CDD                 align 10h
.text$x:00009CDD _text$x         ends
.text$x:00009CDD
.xdata$x:00009CE0 ; ===========================================================================
.xdata$x:00009CE0
.xdata$x:00009CE0 ; Segment type: Pure data
.xdata$x:00009CE0 ; Segment permissions: Read
.xdata$x:00009CE0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009CE0                 assume cs:_xdata$x
.xdata$x:00009CE0                 ;org 9CE0h
.xdata$x:00009CE0 ; COMDAT (pick associative to section at 9C30)
.xdata$x:00009CE0 __unwindtable$??1CDirItem@@QAE@XZ db 0FFh ; DATA XREF: .xdata$x:00009CF8o
.xdata$x:00009CE1                 db 0FFh
.xdata$x:00009CE2                 db 0FFh
.xdata$x:00009CE3                 db 0FFh
.xdata$x:00009CE4                 dd offset __unwindfunclet$??1CDirItem@@QAE@XZ$0
.xdata$x:00009CE8                 db    0
.xdata$x:00009CE9                 db    0
.xdata$x:00009CEA                 db    0
.xdata$x:00009CEB                 db    0
.xdata$x:00009CEC                 dd offset __unwindfunclet$??1CDirItem@@QAE@XZ$1
.xdata$x:00009CF0 __ehfuncinfo$??1CDirItem@@QAE@XZ db  22h ; "
.xdata$x:00009CF0                                         ; DATA XREF: __ehhandler$??1CDirItem@@QAE@XZ+11o
.xdata$x:00009CF1                 db    5
.xdata$x:00009CF2                 db  93h ; 
.xdata$x:00009CF3                 db  19h
.xdata$x:00009CF4                 db    2
.xdata$x:00009CF5                 db    0
.xdata$x:00009CF6                 db    0
.xdata$x:00009CF7                 db    0
.xdata$x:00009CF8                 dd offset __unwindtable$??1CDirItem@@QAE@XZ
.xdata$x:00009CFC                 db    0
.xdata$x:00009CFD                 db    0
.xdata$x:00009CFE                 db    0
.xdata$x:00009CFF                 db    0
.xdata$x:00009D00                 db    0
.xdata$x:00009D01                 db    0
.xdata$x:00009D02                 db    0
.xdata$x:00009D03                 db    0
.xdata$x:00009D04                 db    0
.xdata$x:00009D05                 db    0
.xdata$x:00009D06                 db    0
.xdata$x:00009D07                 db    0
.xdata$x:00009D08                 db    0
.xdata$x:00009D09                 db    0
.xdata$x:00009D0A                 db    0
.xdata$x:00009D0B                 db    0
.xdata$x:00009D0C                 db    0
.xdata$x:00009D0D                 db    0
.xdata$x:00009D0E                 db    0
.xdata$x:00009D0F                 db    0
.xdata$x:00009D10                 db    1
.xdata$x:00009D11                 db    0
.xdata$x:00009D12                 db    0
.xdata$x:00009D13                 db    0
.xdata$x:00009D13 _xdata$x        ends
.xdata$x:00009D13
.text:00009D14 ; ===========================================================================
.text:00009D14
.text:00009D14 ; Segment type: Pure code
.text:00009D14 ; Segment permissions: Read/Execute
.text:00009D14 _text           segment para public 'CODE' use32
.text:00009D14                 assume cs:_text
.text:00009D14                 ;org 9D14h
.text:00009D14 ; COMDAT (pick any)
.text:00009D14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009D14
.text:00009D14 ; =============== S U B R O U T I N E =======================================
.text:00009D14
.text:00009D14 ; Attributes: bp-based frame
.text:00009D14
.text:00009D14 ; public: __thiscall CTempFiles::CTempFiles(void)
.text:00009D14                 public ??0CTempFiles@@QAE@XZ
.text:00009D14 ??0CTempFiles@@QAE@XZ proc near         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1105p
.text:00009D14
.text:00009D14 var_4           = dword ptr -4
.text:00009D14
.text:00009D14                 push    ebp
.text:00009D15                 mov     ebp, esp
.text:00009D17                 push    ecx
.text:00009D18                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00009D1F                 mov     [ebp+var_4], ecx
.text:00009D22                 mov     ecx, [ebp+var_4]
.text:00009D25                 call    ??0?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::CObjectVector<UString>(void)
.text:00009D2A                 mov     eax, [ebp+var_4]
.text:00009D2D                 add     esp, 4
.text:00009D30                 cmp     ebp, esp
.text:00009D32                 call    __RTC_CheckEsp
.text:00009D37                 mov     esp, ebp
.text:00009D39                 pop     ebp
.text:00009D3A                 retn
.text:00009D3A ??0CTempFiles@@QAE@XZ endp
.text:00009D3A
.text:00009D3A ; ---------------------------------------------------------------------------
.text:00009D3B                 align 4
.text:00009D3B _text           ends
.text:00009D3B
.text:00009D3C ; ===========================================================================
.text:00009D3C
.text:00009D3C ; Segment type: Pure code
.text:00009D3C ; Segment permissions: Read/Execute
.text:00009D3C _text           segment para public 'CODE' use32
.text:00009D3C                 assume cs:_text
.text:00009D3C                 ;org 9D3Ch
.text:00009D3C ; COMDAT (pick any)
.text:00009D3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009D3C
.text:00009D3C ; =============== S U B R O U T I N E =======================================
.text:00009D3C
.text:00009D3C ; Attributes: bp-based frame
.text:00009D3C
.text:00009D3C ; public: struct CArchivePath & __thiscall CArchivePath::operator=(struct CArchivePath const &)
.text:00009D3C                 public ??4CArchivePath@@QAEAAU0@ABU0@@Z
.text:00009D3C ??4CArchivePath@@QAEAAU0@ABU0@@Z proc near
.text:00009D3C                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1159p
.text:00009D3C
.text:00009D3C var_4           = dword ptr -4
.text:00009D3C arg_0           = dword ptr  8
.text:00009D3C
.text:00009D3C                 push    ebp
.text:00009D3D                 mov     ebp, esp
.text:00009D3F                 push    ecx
.text:00009D40                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00009D47                 mov     [ebp+var_4], ecx
.text:00009D4A                 mov     eax, [ebp+arg_0]
.text:00009D4D                 push    eax
.text:00009D4E                 mov     ecx, [ebp+var_4]
.text:00009D51                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:00009D56                 mov     ecx, [ebp+arg_0]
.text:00009D59                 add     ecx, 0Ch
.text:00009D5C                 push    ecx
.text:00009D5D                 mov     ecx, [ebp+var_4]
.text:00009D60                 add     ecx, 0Ch
.text:00009D63                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:00009D68                 mov     edx, [ebp+arg_0]
.text:00009D6B                 add     edx, 18h
.text:00009D6E                 push    edx
.text:00009D6F                 mov     ecx, [ebp+var_4]
.text:00009D72                 add     ecx, 18h
.text:00009D75                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:00009D7A                 mov     eax, [ebp+arg_0]
.text:00009D7D                 add     eax, 24h ; '$'
.text:00009D80                 push    eax
.text:00009D81                 mov     ecx, [ebp+var_4]
.text:00009D84                 add     ecx, 24h ; '$'
.text:00009D87                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:00009D8C                 mov     ecx, [ebp+arg_0]
.text:00009D8F                 add     ecx, 30h ; '0'
.text:00009D92                 push    ecx
.text:00009D93                 mov     ecx, [ebp+var_4]
.text:00009D96                 add     ecx, 30h ; '0'
.text:00009D99                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:00009D9E                 mov     edx, [ebp+var_4]
.text:00009DA1                 mov     eax, [ebp+arg_0]
.text:00009DA4                 mov     cl, [eax+3Ch]
.text:00009DA7                 mov     [edx+3Ch], cl
.text:00009DAA                 mov     edx, [ebp+arg_0]
.text:00009DAD                 add     edx, 40h ; '@'
.text:00009DB0                 push    edx
.text:00009DB1                 mov     ecx, [ebp+var_4]
.text:00009DB4                 add     ecx, 40h ; '@'
.text:00009DB7                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:00009DBC                 mov     eax, [ebp+arg_0]
.text:00009DBF                 add     eax, 4Ch ; 'L'
.text:00009DC2                 push    eax
.text:00009DC3                 mov     ecx, [ebp+var_4]
.text:00009DC6                 add     ecx, 4Ch ; 'L'
.text:00009DC9                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:00009DCE                 mov     eax, [ebp+var_4]
.text:00009DD1                 add     esp, 4
.text:00009DD4                 cmp     ebp, esp
.text:00009DD6                 call    __RTC_CheckEsp
.text:00009DDB                 mov     esp, ebp
.text:00009DDD                 pop     ebp
.text:00009DDE                 retn    4
.text:00009DDE ??4CArchivePath@@QAEAAU0@ABU0@@Z endp
.text:00009DDE
.text:00009DDE ; ---------------------------------------------------------------------------
.text:00009DE1                 align 4
.text:00009DE1 _text           ends
.text:00009DE1
.text:00009DE4 ; ===========================================================================
.text:00009DE4
.text:00009DE4 ; Segment type: Pure code
.text:00009DE4 ; Segment permissions: Read/Execute
.text:00009DE4 _text           segment para public 'CODE' use32
.text:00009DE4                 assume cs:_text
.text:00009DE4                 ;org 9DE4h
.text:00009DE4 ; COMDAT (pick any)
.text:00009DE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009DE4
.text:00009DE4 ; =============== S U B R O U T I N E =======================================
.text:00009DE4
.text:00009DE4 ; Attributes: bp-based frame
.text:00009DE4
.text:00009DE4 ; _DWORD __thiscall CUniqBlocks::~CUniqBlocks(CUniqBlocks *__hidden this)
.text:00009DE4                 public ??1CUniqBlocks@@QAE@XZ
.text:00009DE4 ??1CUniqBlocks@@QAE@XZ proc near        ; CODE XREF: CDirItems::~CDirItems(void)+4Cp
.text:00009DE4                                         ; __unwindfunclet$??1CDirItems@@QAE@XZ$4+6j
.text:00009DE4
.text:00009DE4 var_10          = dword ptr -10h
.text:00009DE4 var_C           = dword ptr -0Ch
.text:00009DE4 var_4           = dword ptr -4
.text:00009DE4
.text:00009DE4                 push    ebp
.text:00009DE5                 mov     ebp, esp
.text:00009DE7                 push    0FFFFFFFFh
.text:00009DE9                 push    offset __ehhandler$??1CUniqBlocks@@QAE@XZ
.text:00009DEE                 mov     eax, large fs:0
.text:00009DF4                 push    eax
.text:00009DF5                 push    ecx
.text:00009DF6                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00009DFD                 mov     eax, dword ptr ds:___security_cookie
.text:00009E02                 xor     eax, ebp
.text:00009E04                 push    eax
.text:00009E05                 lea     eax, [ebp+var_C]
.text:00009E08                 mov     large fs:0, eax
.text:00009E0E                 mov     [ebp+var_10], ecx
.text:00009E11                 mov     [ebp+var_4], 1
.text:00009E18                 mov     ecx, [ebp+var_10]
.text:00009E1B                 add     ecx, 18h
.text:00009E1E                 call    ??1?$CRecordVector@I@@QAE@XZ ; CRecordVector<uint>::~CRecordVector<uint>(void)
.text:00009E23                 mov     byte ptr [ebp+var_4], 0
.text:00009E27                 mov     ecx, [ebp+var_10]
.text:00009E2A                 add     ecx, 0Ch
.text:00009E2D                 call    ??1?$CRecordVector@I@@QAE@XZ ; CRecordVector<uint>::~CRecordVector<uint>(void)
.text:00009E32                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00009E39                 mov     ecx, [ebp+var_10]
.text:00009E3C                 call    ??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ ; CObjectVector<CBuffer<uchar>>::~CObjectVector<CBuffer<uchar>>(void)
.text:00009E41                 mov     ecx, [ebp+var_C]
.text:00009E44                 mov     large fs:0, ecx
.text:00009E4B                 pop     ecx
.text:00009E4C                 add     esp, 10h
.text:00009E4F                 cmp     ebp, esp
.text:00009E51                 call    __RTC_CheckEsp
.text:00009E56                 mov     esp, ebp
.text:00009E58                 pop     ebp
.text:00009E59                 retn
.text:00009E59 ??1CUniqBlocks@@QAE@XZ endp
.text:00009E59
.text:00009E59 ; ---------------------------------------------------------------------------
.text:00009E5A                 align 4
.text:00009E5A _text           ends
.text:00009E5A
.text$x:00009E5C ; ===========================================================================
.text$x:00009E5C
.text$x:00009E5C ; Segment type: Pure code
.text$x:00009E5C ; Segment permissions: Read/Execute
.text$x:00009E5C _text$x         segment para public 'CODE' use32
.text$x:00009E5C                 assume cs:_text$x
.text$x:00009E5C                 ;org 9E5Ch
.text$x:00009E5C ; COMDAT (pick associative to section at 9DE4)
.text$x:00009E5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00009E5C
.text$x:00009E5C ; =============== S U B R O U T I N E =======================================
.text$x:00009E5C
.text$x:00009E5C
.text$x:00009E5C __unwindfunclet$??1CUniqBlocks@@QAE@XZ$0 proc near
.text$x:00009E5C                                         ; DATA XREF: .xdata$x:00009E90o
.text$x:00009E5C                 mov     ecx, [ebp-10h]
.text$x:00009E5F                 jmp     ??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ ; CObjectVector<CBuffer<uchar>>::~CObjectVector<CBuffer<uchar>>(void)
.text$x:00009E5F __unwindfunclet$??1CUniqBlocks@@QAE@XZ$0 endp
.text$x:00009E5F
.text$x:00009E64
.text$x:00009E64 ; =============== S U B R O U T I N E =======================================
.text$x:00009E64
.text$x:00009E64
.text$x:00009E64 __unwindfunclet$??1CUniqBlocks@@QAE@XZ$1 proc near
.text$x:00009E64                                         ; DATA XREF: .xdata$x:00009E98o
.text$x:00009E64                 mov     ecx, [ebp-10h]
.text$x:00009E67                 add     ecx, 0Ch
.text$x:00009E6A                 jmp     ??1?$CRecordVector@I@@QAE@XZ ; CRecordVector<uint>::~CRecordVector<uint>(void)
.text$x:00009E6A __unwindfunclet$??1CUniqBlocks@@QAE@XZ$1 endp
.text$x:00009E6A
.text$x:00009E6F
.text$x:00009E6F ; =============== S U B R O U T I N E =======================================
.text$x:00009E6F
.text$x:00009E6F
.text$x:00009E6F __ehhandler$??1CUniqBlocks@@QAE@XZ proc near
.text$x:00009E6F                                         ; DATA XREF: CUniqBlocks::~CUniqBlocks(void)+5o
.text$x:00009E6F
.text$x:00009E6F arg_4           = dword ptr  8
.text$x:00009E6F
.text$x:00009E6F                 mov     edx, [esp+arg_4]
.text$x:00009E73                 lea     eax, [edx+0Ch]
.text$x:00009E76                 mov     ecx, [edx-8]
.text$x:00009E79                 xor     ecx, eax
.text$x:00009E7B                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009E80                 mov     eax, offset __ehfuncinfo$??1CUniqBlocks@@QAE@XZ
.text$x:00009E85                 jmp     ___CxxFrameHandler3
.text$x:00009E85 __ehhandler$??1CUniqBlocks@@QAE@XZ endp
.text$x:00009E85
.text$x:00009E85 ; ---------------------------------------------------------------------------
.text$x:00009E8A                 align 4
.text$x:00009E8A _text$x         ends
.text$x:00009E8A
.xdata$x:00009E8C ; ===========================================================================
.xdata$x:00009E8C
.xdata$x:00009E8C ; Segment type: Pure data
.xdata$x:00009E8C ; Segment permissions: Read
.xdata$x:00009E8C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009E8C                 assume cs:_xdata$x
.xdata$x:00009E8C                 ;org 9E8Ch
.xdata$x:00009E8C ; COMDAT (pick associative to section at 9DE4)
.xdata$x:00009E8C __unwindtable$??1CUniqBlocks@@QAE@XZ db 0FFh
.xdata$x:00009E8C                                         ; DATA XREF: .xdata$x:00009EA4o
.xdata$x:00009E8D                 db 0FFh
.xdata$x:00009E8E                 db 0FFh
.xdata$x:00009E8F                 db 0FFh
.xdata$x:00009E90                 dd offset __unwindfunclet$??1CUniqBlocks@@QAE@XZ$0
.xdata$x:00009E94                 align 8
.xdata$x:00009E98                 dd offset __unwindfunclet$??1CUniqBlocks@@QAE@XZ$1
.xdata$x:00009E9C __ehfuncinfo$??1CUniqBlocks@@QAE@XZ db  22h ; "
.xdata$x:00009E9C                                         ; DATA XREF: __ehhandler$??1CUniqBlocks@@QAE@XZ+11o
.xdata$x:00009E9D                 db    5
.xdata$x:00009E9E                 db  93h ; 
.xdata$x:00009E9F                 db  19h
.xdata$x:00009EA0                 db    2
.xdata$x:00009EA1                 db    0
.xdata$x:00009EA2                 db    0
.xdata$x:00009EA3                 db    0
.xdata$x:00009EA4                 dd offset __unwindtable$??1CUniqBlocks@@QAE@XZ
.xdata$x:00009EA8                 db    0
.xdata$x:00009EA9                 db    0
.xdata$x:00009EAA                 db    0
.xdata$x:00009EAB                 db    0
.xdata$x:00009EAC                 db    0
.xdata$x:00009EAD                 db    0
.xdata$x:00009EAE                 db    0
.xdata$x:00009EAF                 db    0
.xdata$x:00009EB0                 db    0
.xdata$x:00009EB1                 db    0
.xdata$x:00009EB2                 db    0
.xdata$x:00009EB3                 db    0
.xdata$x:00009EB4                 db    0
.xdata$x:00009EB5                 db    0
.xdata$x:00009EB6                 db    0
.xdata$x:00009EB7                 db    0
.xdata$x:00009EB8                 db    0
.xdata$x:00009EB9                 db    0
.xdata$x:00009EBA                 db    0
.xdata$x:00009EBB                 db    0
.xdata$x:00009EBC                 db    1
.xdata$x:00009EBD                 db    0
.xdata$x:00009EBE                 db    0
.xdata$x:00009EBF                 db    0
.xdata$x:00009EBF _xdata$x        ends
.xdata$x:00009EBF
.text:00009EC0 ; ===========================================================================
.text:00009EC0
.text:00009EC0 ; Segment type: Pure code
.text:00009EC0 ; Segment permissions: Read/Execute
.text:00009EC0 _text           segment para public 'CODE' use32
.text:00009EC0                 assume cs:_text
.text:00009EC0                 ;org 9EC0h
.text:00009EC0 ; COMDAT (pick any)
.text:00009EC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009EC0
.text:00009EC0 ; =============== S U B R O U T I N E =======================================
.text:00009EC0
.text:00009EC0 ; Attributes: bp-based frame
.text:00009EC0
.text:00009EC0 ; public: unsigned int __thiscall CObjectVector<class UString>::Size(void)const
.text:00009EC0                 public ?Size@?$CObjectVector@VUString@@@@QBEIXZ
.text:00009EC0 ?Size@?$CObjectVector@VUString@@@@QBEIXZ proc near
.text:00009EC0                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+898p
.text:00009EC0                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+20FEp ...
.text:00009EC0
.text:00009EC0 var_4           = dword ptr -4
.text:00009EC0
.text:00009EC0                 push    ebp
.text:00009EC1                 mov     ebp, esp
.text:00009EC3                 push    ecx
.text:00009EC4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00009ECB                 mov     [ebp+var_4], ecx
.text:00009ECE                 mov     ecx, [ebp+var_4]
.text:00009ED1                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00009ED6                 add     esp, 4
.text:00009ED9                 cmp     ebp, esp
.text:00009EDB                 call    __RTC_CheckEsp
.text:00009EE0                 mov     esp, ebp
.text:00009EE2                 pop     ebp
.text:00009EE3                 retn
.text:00009EE3 ?Size@?$CObjectVector@VUString@@@@QBEIXZ endp
.text:00009EE3
.text:00009EE3 _text           ends
.text:00009EE3
.text:00009EE4 ; ===========================================================================
.text:00009EE4
.text:00009EE4 ; Segment type: Pure code
.text:00009EE4 ; Segment permissions: Read/Execute
.text:00009EE4 _text           segment para public 'CODE' use32
.text:00009EE4                 assume cs:_text
.text:00009EE4                 ;org 9EE4h
.text:00009EE4 ; COMDAT (pick any)
.text:00009EE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009EE4
.text:00009EE4 ; =============== S U B R O U T I N E =======================================
.text:00009EE4
.text:00009EE4 ; Attributes: bp-based frame
.text:00009EE4
.text:00009EE4 ; public: __thiscall CObjectVector<class UString>::CObjectVector<class UString>(void)
.text:00009EE4                 public ??0?$CObjectVector@VUString@@@@QAE@XZ
.text:00009EE4 ??0?$CObjectVector@VUString@@@@QAE@XZ proc near
.text:00009EE4                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1F10p
.text:00009EE4                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+230Fp ...
.text:00009EE4
.text:00009EE4 var_4           = dword ptr -4
.text:00009EE4
.text:00009EE4                 push    ebp
.text:00009EE5                 mov     ebp, esp
.text:00009EE7                 push    ecx
.text:00009EE8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00009EEF                 mov     [ebp+var_4], ecx
.text:00009EF2                 mov     ecx, [ebp+var_4]
.text:00009EF5                 call    ??0?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::CRecordVector<void *>(void)
.text:00009EFA                 mov     eax, [ebp+var_4]
.text:00009EFD                 add     esp, 4
.text:00009F00                 cmp     ebp, esp
.text:00009F02                 call    __RTC_CheckEsp
.text:00009F07                 mov     esp, ebp
.text:00009F09                 pop     ebp
.text:00009F0A                 retn
.text:00009F0A ??0?$CObjectVector@VUString@@@@QAE@XZ endp
.text:00009F0A
.text:00009F0A ; ---------------------------------------------------------------------------
.text:00009F0B                 align 4
.text:00009F0B _text           ends
.text:00009F0B
.text:00009F0C ; ===========================================================================
.text:00009F0C
.text:00009F0C ; Segment type: Pure code
.text:00009F0C ; Segment permissions: Read/Execute
.text:00009F0C _text           segment para public 'CODE' use32
.text:00009F0C                 assume cs:_text
.text:00009F0C                 ;org 9F0Ch
.text:00009F0C ; COMDAT (pick any)
.text:00009F0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00009F0C
.text:00009F0C ; =============== S U B R O U T I N E =======================================
.text:00009F0C
.text:00009F0C ; Attributes: bp-based frame
.text:00009F0C
.text:00009F0C ; public: class CObjectVector<class UString> & __thiscall CObjectVector<class UString>::operator=(class CObjectVector<class UString> const &)
.text:00009F0C                 public ??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z
.text:00009F0C ??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z proc near
.text:00009F0C                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+186Ep
.text:00009F0C
.text:00009F0C var_24          = dword ptr -24h
.text:00009F0C var_20          = dword ptr -20h
.text:00009F0C var_1C          = dword ptr -1Ch
.text:00009F0C var_18          = dword ptr -18h
.text:00009F0C var_14          = dword ptr -14h
.text:00009F0C var_10          = dword ptr -10h
.text:00009F0C var_C           = dword ptr -0Ch
.text:00009F0C var_4           = dword ptr -4
.text:00009F0C arg_0           = dword ptr  8
.text:00009F0C
.text:00009F0C                 push    ebp
.text:00009F0D                 mov     ebp, esp
.text:00009F0F                 push    0FFFFFFFFh
.text:00009F11                 push    offset __ehhandler$??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z
.text:00009F16                 mov     eax, large fs:0
.text:00009F1C                 push    eax
.text:00009F1D                 sub     esp, 18h
.text:00009F20                 mov     eax, 0CCCCCCCCh
.text:00009F25                 mov     [ebp+var_24], eax
.text:00009F28                 mov     [ebp+var_20], eax
.text:00009F2B                 mov     [ebp+var_1C], eax
.text:00009F2E                 mov     [ebp+var_18], eax
.text:00009F31                 mov     [ebp+var_14], eax
.text:00009F34                 mov     [ebp+var_10], eax
.text:00009F37                 mov     eax, dword ptr ds:___security_cookie
.text:00009F3C                 xor     eax, ebp
.text:00009F3E                 push    eax
.text:00009F3F                 lea     eax, [ebp+var_C]
.text:00009F42                 mov     large fs:0, eax
.text:00009F48                 mov     [ebp+var_10], ecx
.text:00009F4B                 mov     eax, [ebp+arg_0]
.text:00009F4E                 cmp     eax, [ebp+var_10]
.text:00009F51                 jnz     short loc_9F5B
.text:00009F53                 mov     eax, [ebp+var_10]
.text:00009F56                 jmp     loc_9FED
.text:00009F5B ; ---------------------------------------------------------------------------
.text:00009F5B
.text:00009F5B loc_9F5B:                               ; CODE XREF: CObjectVector<UString>::operator=(CObjectVector<UString> const &)+45j
.text:00009F5B                 mov     ecx, [ebp+var_10]
.text:00009F5E                 call    ?Clear@?$CObjectVector@VUString@@@@QAEXXZ ; CObjectVector<UString>::Clear(void)
.text:00009F63                 mov     ecx, [ebp+arg_0]
.text:00009F66                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:00009F6B                 mov     [ebp+var_14], eax
.text:00009F6E                 mov     ecx, [ebp+var_14]
.text:00009F71                 push    ecx
.text:00009F72                 mov     ecx, [ebp+var_10]
.text:00009F75                 call    ?Reserve@?$CRecordVector@PAX@@QAEXI@Z ; CRecordVector<void *>::Reserve(uint)
.text:00009F7A                 mov     [ebp+var_18], 0
.text:00009F81                 jmp     short loc_9F8C
.text:00009F83 ; ---------------------------------------------------------------------------
.text:00009F83
.text:00009F83 loc_9F83:                               ; CODE XREF: CObjectVector<UString>::operator=(CObjectVector<UString> const &)+DCj
.text:00009F83                 mov     edx, [ebp+var_18]
.text:00009F86                 add     edx, 1
.text:00009F89                 mov     [ebp+var_18], edx
.text:00009F8C
.text:00009F8C loc_9F8C:                               ; CODE XREF: CObjectVector<UString>::operator=(CObjectVector<UString> const &)+75j
.text:00009F8C                 mov     eax, [ebp+var_18]
.text:00009F8F                 cmp     eax, [ebp+var_14]
.text:00009F92                 jnb     short loc_9FEA
.text:00009F94                 push    0Ch             ; unsigned int
.text:00009F96                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00009F9B                 add     esp, 4
.text:00009F9E                 mov     [ebp+var_20], eax
.text:00009FA1                 mov     [ebp+var_4], 0
.text:00009FA8                 cmp     [ebp+var_20], 0
.text:00009FAC                 jz      short loc_9FC8
.text:00009FAE                 mov     ecx, [ebp+var_18]
.text:00009FB1                 push    ecx
.text:00009FB2                 mov     ecx, [ebp+arg_0]
.text:00009FB5                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00009FBA                 push    eax
.text:00009FBB                 mov     ecx, [ebp+var_20]
.text:00009FBE                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00009FC3                 mov     [ebp+var_24], eax
.text:00009FC6                 jmp     short loc_9FCF
.text:00009FC8 ; ---------------------------------------------------------------------------
.text:00009FC8
.text:00009FC8 loc_9FC8:                               ; CODE XREF: CObjectVector<UString>::operator=(CObjectVector<UString> const &)+A0j
.text:00009FC8                 mov     [ebp+var_24], 0
.text:00009FCF
.text:00009FCF loc_9FCF:                               ; CODE XREF: CObjectVector<UString>::operator=(CObjectVector<UString> const &)+BAj
.text:00009FCF                 mov     edx, [ebp+var_24]
.text:00009FD2                 mov     [ebp+var_1C], edx
.text:00009FD5                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00009FDC                 mov     eax, [ebp+var_1C]
.text:00009FDF                 push    eax
.text:00009FE0                 mov     ecx, [ebp+var_10]
.text:00009FE3                 call    ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z ; CRecordVector<void *>::AddInReserved(void * const)
.text:00009FE8                 jmp     short loc_9F83
.text:00009FEA ; ---------------------------------------------------------------------------
.text:00009FEA
.text:00009FEA loc_9FEA:                               ; CODE XREF: CObjectVector<UString>::operator=(CObjectVector<UString> const &)+86j
.text:00009FEA                 mov     eax, [ebp+var_10]
.text:00009FED
.text:00009FED loc_9FED:                               ; CODE XREF: CObjectVector<UString>::operator=(CObjectVector<UString> const &)+4Aj
.text:00009FED                 mov     ecx, [ebp+var_C]
.text:00009FF0                 mov     large fs:0, ecx
.text:00009FF7                 pop     ecx
.text:00009FF8                 add     esp, 24h
.text:00009FFB                 cmp     ebp, esp
.text:00009FFD                 call    __RTC_CheckEsp
.text:0000A002                 mov     esp, ebp
.text:0000A004                 pop     ebp
.text:0000A005                 retn    4
.text:0000A005 ??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z endp
.text:0000A005
.text:0000A005 _text           ends
.text:0000A005
.text$x:0000A008 ; ===========================================================================
.text$x:0000A008
.text$x:0000A008 ; Segment type: Pure code
.text$x:0000A008 ; Segment permissions: Read/Execute
.text$x:0000A008 _text$x         segment para public 'CODE' use32
.text$x:0000A008                 assume cs:_text$x
.text$x:0000A008                 ;org 0A008h
.text$x:0000A008 ; COMDAT (pick associative to section at 9F0C)
.text$x:0000A008                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000A008
.text$x:0000A008 ; =============== S U B R O U T I N E =======================================
.text$x:0000A008
.text$x:0000A008
.text$x:0000A008 __unwindfunclet$??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z$0 proc near
.text$x:0000A008                                         ; DATA XREF: .xdata$x:0000A034o
.text$x:0000A008                 mov     eax, [ebp-20h]
.text$x:0000A00B                 push    eax             ; void *
.text$x:0000A00C                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:0000A011                 pop     ecx
.text$x:0000A012                 retn
.text$x:0000A012 __unwindfunclet$??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z$0 endp
.text$x:0000A012
.text$x:0000A013
.text$x:0000A013 ; =============== S U B R O U T I N E =======================================
.text$x:0000A013
.text$x:0000A013
.text$x:0000A013 __ehhandler$??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z proc near
.text$x:0000A013                                         ; DATA XREF: CObjectVector<UString>::operator=(CObjectVector<UString> const &)+5o
.text$x:0000A013
.text$x:0000A013 arg_4           = dword ptr  8
.text$x:0000A013
.text$x:0000A013                 mov     edx, [esp+arg_4]
.text$x:0000A017                 lea     eax, [edx+0Ch]
.text$x:0000A01A                 mov     ecx, [edx-1Ch]
.text$x:0000A01D                 xor     ecx, eax
.text$x:0000A01F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000A024                 mov     eax, offset __ehfuncinfo$??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z
.text$x:0000A029                 jmp     ___CxxFrameHandler3
.text$x:0000A029 __ehhandler$??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z endp
.text$x:0000A029
.text$x:0000A029 ; ---------------------------------------------------------------------------
.text$x:0000A02E                 align 10h
.text$x:0000A02E _text$x         ends
.text$x:0000A02E
.xdata$x:0000A030 ; ===========================================================================
.xdata$x:0000A030
.xdata$x:0000A030 ; Segment type: Pure data
.xdata$x:0000A030 ; Segment permissions: Read
.xdata$x:0000A030 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A030                 assume cs:_xdata$x
.xdata$x:0000A030                 ;org 0A030h
.xdata$x:0000A030 ; COMDAT (pick associative to section at 9F0C)
.xdata$x:0000A030 __unwindtable$??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z db 0FFh
.xdata$x:0000A030                                         ; DATA XREF: .xdata$x:0000A040o
.xdata$x:0000A031                 db 0FFh
.xdata$x:0000A032                 db 0FFh
.xdata$x:0000A033                 db 0FFh
.xdata$x:0000A034                 dd offset __unwindfunclet$??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z$0
.xdata$x:0000A038 __ehfuncinfo$??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z db  22h ; "
.xdata$x:0000A038                                         ; DATA XREF: __ehhandler$??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z+11o
.xdata$x:0000A039                 db    5
.xdata$x:0000A03A                 db  93h ; 
.xdata$x:0000A03B                 db  19h
.xdata$x:0000A03C                 db    1
.xdata$x:0000A03D                 db    0
.xdata$x:0000A03E                 db    0
.xdata$x:0000A03F                 db    0
.xdata$x:0000A040                 dd offset __unwindtable$??4?$CObjectVector@VUString@@@@QAEAAV0@ABV0@@Z
.xdata$x:0000A044                 db    0
.xdata$x:0000A045                 db    0
.xdata$x:0000A046                 db    0
.xdata$x:0000A047                 db    0
.xdata$x:0000A048                 db    0
.xdata$x:0000A049                 db    0
.xdata$x:0000A04A                 db    0
.xdata$x:0000A04B                 db    0
.xdata$x:0000A04C                 db    0
.xdata$x:0000A04D                 db    0
.xdata$x:0000A04E                 db    0
.xdata$x:0000A04F                 db    0
.xdata$x:0000A050                 db    0
.xdata$x:0000A051                 db    0
.xdata$x:0000A052                 db    0
.xdata$x:0000A053                 db    0
.xdata$x:0000A054                 db    0
.xdata$x:0000A055                 db    0
.xdata$x:0000A056                 db    0
.xdata$x:0000A057                 db    0
.xdata$x:0000A058                 db    1
.xdata$x:0000A059                 db    0
.xdata$x:0000A05A                 db    0
.xdata$x:0000A05B                 db    0
.xdata$x:0000A05B _xdata$x        ends
.xdata$x:0000A05B
.text:0000A05C ; ===========================================================================
.text:0000A05C
.text:0000A05C ; Segment type: Pure code
.text:0000A05C ; Segment permissions: Read/Execute
.text:0000A05C _text           segment para public 'CODE' use32
.text:0000A05C                 assume cs:_text
.text:0000A05C                 ;org 0A05Ch
.text:0000A05C ; COMDAT (pick any)
.text:0000A05C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A05C
.text:0000A05C ; =============== S U B R O U T I N E =======================================
.text:0000A05C
.text:0000A05C ; Attributes: bp-based frame
.text:0000A05C
.text:0000A05C ; public: class UString const & __thiscall CObjectVector<class UString>::operator[](unsigned int)const
.text:0000A05C                 public ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z
.text:0000A05C ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z proc near
.text:0000A05C                                         ; CODE XREF: CObjectVector<UString>::operator=(CObjectVector<UString> const &)+A9p
.text:0000A05C
.text:0000A05C var_4           = dword ptr -4
.text:0000A05C arg_0           = dword ptr  8
.text:0000A05C
.text:0000A05C                 push    ebp
.text:0000A05D                 mov     ebp, esp
.text:0000A05F                 push    ecx
.text:0000A060                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A067                 mov     [ebp+var_4], ecx
.text:0000A06A                 mov     eax, [ebp+arg_0]
.text:0000A06D                 push    eax
.text:0000A06E                 mov     ecx, [ebp+var_4]
.text:0000A071                 call    ??A?$CRecordVector@PAX@@QBEABQAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:0000A076                 mov     eax, [eax]
.text:0000A078                 add     esp, 4
.text:0000A07B                 cmp     ebp, esp
.text:0000A07D                 call    __RTC_CheckEsp
.text:0000A082                 mov     esp, ebp
.text:0000A084                 pop     ebp
.text:0000A085                 retn    4
.text:0000A085 ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z endp
.text:0000A085
.text:0000A085 _text           ends
.text:0000A085
.text:0000A088 ; ===========================================================================
.text:0000A088
.text:0000A088 ; Segment type: Pure code
.text:0000A088 ; Segment permissions: Read/Execute
.text:0000A088 _text           segment para public 'CODE' use32
.text:0000A088                 assume cs:_text
.text:0000A088                 ;org 0A088h
.text:0000A088 ; COMDAT (pick any)
.text:0000A088                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A088
.text:0000A088 ; =============== S U B R O U T I N E =======================================
.text:0000A088
.text:0000A088 ; Attributes: bp-based frame
.text:0000A088
.text:0000A088 ; public: class UString & __thiscall CObjectVector<class UString>::operator[](unsigned int)
.text:0000A088                 public ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z
.text:0000A088 ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z proc near
.text:0000A088                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+211Cp
.text:0000A088
.text:0000A088 var_4           = dword ptr -4
.text:0000A088 arg_0           = dword ptr  8
.text:0000A088
.text:0000A088                 push    ebp
.text:0000A089                 mov     ebp, esp
.text:0000A08B                 push    ecx
.text:0000A08C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A093                 mov     [ebp+var_4], ecx
.text:0000A096                 mov     eax, [ebp+arg_0]
.text:0000A099                 push    eax
.text:0000A09A                 mov     ecx, [ebp+var_4]
.text:0000A09D                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:0000A0A2                 mov     eax, [eax]
.text:0000A0A4                 add     esp, 4
.text:0000A0A7                 cmp     ebp, esp
.text:0000A0A9                 call    __RTC_CheckEsp
.text:0000A0AE                 mov     esp, ebp
.text:0000A0B0                 pop     ebp
.text:0000A0B1                 retn    4
.text:0000A0B1 ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z endp
.text:0000A0B1
.text:0000A0B1 _text           ends
.text:0000A0B1
.text:0000A0B4 ; ===========================================================================
.text:0000A0B4
.text:0000A0B4 ; Segment type: Pure code
.text:0000A0B4 ; Segment permissions: Read/Execute
.text:0000A0B4 _text           segment para public 'CODE' use32
.text:0000A0B4                 assume cs:_text
.text:0000A0B4                 ;org 0A0B4h
.text:0000A0B4 ; COMDAT (pick any)
.text:0000A0B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A0B4
.text:0000A0B4 ; =============== S U B R O U T I N E =======================================
.text:0000A0B4
.text:0000A0B4 ; Attributes: bp-based frame
.text:0000A0B4
.text:0000A0B4 ; public: unsigned int __thiscall CObjectVector<class UString>::Add(class UString const &)
.text:0000A0B4                 public ?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z
.text:0000A0B4 ?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z proc near
.text:0000A0B4                                         ; CODE XREF: CUpdateErrorInfo::SetFromLastError(char const *,UString const &)+24p
.text:0000A0B4                                         ; COutMultiVolStream::Write(void const *,uint,uint *)+153p ...
.text:0000A0B4
.text:0000A0B4 var_1C          = dword ptr -1Ch
.text:0000A0B4 var_18          = dword ptr -18h
.text:0000A0B4 var_14          = dword ptr -14h
.text:0000A0B4 var_10          = dword ptr -10h
.text:0000A0B4 var_C           = dword ptr -0Ch
.text:0000A0B4 var_4           = dword ptr -4
.text:0000A0B4 arg_0           = dword ptr  8
.text:0000A0B4
.text:0000A0B4                 push    ebp
.text:0000A0B5                 mov     ebp, esp
.text:0000A0B7                 push    0FFFFFFFFh
.text:0000A0B9                 push    offset __ehhandler$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z
.text:0000A0BE                 mov     eax, large fs:0
.text:0000A0C4                 push    eax
.text:0000A0C5                 sub     esp, 10h
.text:0000A0C8                 mov     eax, 0CCCCCCCCh
.text:0000A0CD                 mov     [ebp+var_1C], eax
.text:0000A0D0                 mov     [ebp+var_18], eax
.text:0000A0D3                 mov     [ebp+var_14], eax
.text:0000A0D6                 mov     [ebp+var_10], eax
.text:0000A0D9                 mov     eax, dword ptr ds:___security_cookie
.text:0000A0DE                 xor     eax, ebp
.text:0000A0E0                 push    eax
.text:0000A0E1                 lea     eax, [ebp+var_C]
.text:0000A0E4                 mov     large fs:0, eax
.text:0000A0EA                 mov     [ebp+var_10], ecx
.text:0000A0ED                 push    0Ch             ; unsigned int
.text:0000A0EF                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0000A0F4                 add     esp, 4
.text:0000A0F7                 mov     [ebp+var_18], eax
.text:0000A0FA                 mov     [ebp+var_4], 0
.text:0000A101                 cmp     [ebp+var_18], 0
.text:0000A105                 jz      short loc_A118
.text:0000A107                 mov     eax, [ebp+arg_0]
.text:0000A10A                 push    eax
.text:0000A10B                 mov     ecx, [ebp+var_18]
.text:0000A10E                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:0000A113                 mov     [ebp+var_1C], eax
.text:0000A116                 jmp     short loc_A11F
.text:0000A118 ; ---------------------------------------------------------------------------
.text:0000A118
.text:0000A118 loc_A118:                               ; CODE XREF: CObjectVector<UString>::Add(UString const &)+51j
.text:0000A118                 mov     [ebp+var_1C], 0
.text:0000A11F
.text:0000A11F loc_A11F:                               ; CODE XREF: CObjectVector<UString>::Add(UString const &)+62j
.text:0000A11F                 mov     ecx, [ebp+var_1C]
.text:0000A122                 mov     [ebp+var_14], ecx
.text:0000A125                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000A12C                 mov     edx, [ebp+var_14]
.text:0000A12F                 push    edx
.text:0000A130                 mov     ecx, [ebp+var_10]
.text:0000A133                 call    ?Add@?$CRecordVector@PAX@@QAEIQAX@Z ; CRecordVector<void *>::Add(void * const)
.text:0000A138                 mov     ecx, [ebp+var_C]
.text:0000A13B                 mov     large fs:0, ecx
.text:0000A142                 pop     ecx
.text:0000A143                 add     esp, 1Ch
.text:0000A146                 cmp     ebp, esp
.text:0000A148                 call    __RTC_CheckEsp
.text:0000A14D                 mov     esp, ebp
.text:0000A14F                 pop     ebp
.text:0000A150                 retn    4
.text:0000A150 ?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z endp
.text:0000A150
.text:0000A150 ; ---------------------------------------------------------------------------
.text:0000A153                 align 4
.text:0000A153 _text           ends
.text:0000A153
.text$x:0000A154 ; ===========================================================================
.text$x:0000A154
.text$x:0000A154 ; Segment type: Pure code
.text$x:0000A154 ; Segment permissions: Read/Execute
.text$x:0000A154 _text$x         segment para public 'CODE' use32
.text$x:0000A154                 assume cs:_text$x
.text$x:0000A154                 ;org 0A154h
.text$x:0000A154 ; COMDAT (pick associative to section at A0B4)
.text$x:0000A154                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000A154
.text$x:0000A154 ; =============== S U B R O U T I N E =======================================
.text$x:0000A154
.text$x:0000A154
.text$x:0000A154 __unwindfunclet$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z$0 proc near
.text$x:0000A154                                         ; DATA XREF: .xdata$x:0000A180o
.text$x:0000A154                 mov     eax, [ebp-18h]
.text$x:0000A157                 push    eax             ; void *
.text$x:0000A158                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:0000A15D                 pop     ecx
.text$x:0000A15E                 retn
.text$x:0000A15E __unwindfunclet$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z$0 endp
.text$x:0000A15E
.text$x:0000A15F
.text$x:0000A15F ; =============== S U B R O U T I N E =======================================
.text$x:0000A15F
.text$x:0000A15F
.text$x:0000A15F __ehhandler$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z proc near
.text$x:0000A15F                                         ; DATA XREF: CObjectVector<UString>::Add(UString const &)+5o
.text$x:0000A15F
.text$x:0000A15F arg_4           = dword ptr  8
.text$x:0000A15F
.text$x:0000A15F                 mov     edx, [esp+arg_4]
.text$x:0000A163                 lea     eax, [edx+0Ch]
.text$x:0000A166                 mov     ecx, [edx-14h]
.text$x:0000A169                 xor     ecx, eax
.text$x:0000A16B                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000A170                 mov     eax, offset __ehfuncinfo$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z
.text$x:0000A175                 jmp     ___CxxFrameHandler3
.text$x:0000A175 __ehhandler$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z endp
.text$x:0000A175
.text$x:0000A175 ; ---------------------------------------------------------------------------
.text$x:0000A17A                 align 4
.text$x:0000A17A _text$x         ends
.text$x:0000A17A
.xdata$x:0000A17C ; ===========================================================================
.xdata$x:0000A17C
.xdata$x:0000A17C ; Segment type: Pure data
.xdata$x:0000A17C ; Segment permissions: Read
.xdata$x:0000A17C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A17C                 assume cs:_xdata$x
.xdata$x:0000A17C                 ;org 0A17Ch
.xdata$x:0000A17C ; COMDAT (pick associative to section at A0B4)
.xdata$x:0000A17C __unwindtable$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z db 0FFh
.xdata$x:0000A17C                                         ; DATA XREF: .xdata$x:0000A18Co
.xdata$x:0000A17D                 db 0FFh
.xdata$x:0000A17E                 db 0FFh
.xdata$x:0000A17F                 db 0FFh
.xdata$x:0000A180                 dd offset __unwindfunclet$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z$0
.xdata$x:0000A184 __ehfuncinfo$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z db  22h ; "
.xdata$x:0000A184                                         ; DATA XREF: __ehhandler$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z+11o
.xdata$x:0000A185                 db    5
.xdata$x:0000A186                 db  93h ; 
.xdata$x:0000A187                 db  19h
.xdata$x:0000A188                 db    1
.xdata$x:0000A189                 db    0
.xdata$x:0000A18A                 db    0
.xdata$x:0000A18B                 db    0
.xdata$x:0000A18C                 dd offset __unwindtable$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z
.xdata$x:0000A190                 db    0
.xdata$x:0000A191                 db    0
.xdata$x:0000A192                 db    0
.xdata$x:0000A193                 db    0
.xdata$x:0000A194                 db    0
.xdata$x:0000A195                 db    0
.xdata$x:0000A196                 db    0
.xdata$x:0000A197                 db    0
.xdata$x:0000A198                 db    0
.xdata$x:0000A199                 db    0
.xdata$x:0000A19A                 db    0
.xdata$x:0000A19B                 db    0
.xdata$x:0000A19C                 db    0
.xdata$x:0000A19D                 db    0
.xdata$x:0000A19E                 db    0
.xdata$x:0000A19F                 db    0
.xdata$x:0000A1A0                 db    0
.xdata$x:0000A1A1                 db    0
.xdata$x:0000A1A2                 db    0
.xdata$x:0000A1A3                 db    0
.xdata$x:0000A1A4                 db    1
.xdata$x:0000A1A5                 db    0
.xdata$x:0000A1A6                 db    0
.xdata$x:0000A1A7                 db    0
.xdata$x:0000A1A7 _xdata$x        ends
.xdata$x:0000A1A7
.text:0000A1A8 ; ===========================================================================
.text:0000A1A8
.text:0000A1A8 ; Segment type: Pure code
.text:0000A1A8 ; Segment permissions: Read/Execute
.text:0000A1A8 _text           segment para public 'CODE' use32
.text:0000A1A8                 assume cs:_text
.text:0000A1A8                 ;org 0A1A8h
.text:0000A1A8 ; COMDAT (pick any)
.text:0000A1A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A1A8
.text:0000A1A8 ; =============== S U B R O U T I N E =======================================
.text:0000A1A8
.text:0000A1A8 ; Attributes: bp-based frame
.text:0000A1A8
.text:0000A1A8 ; public: __thiscall CObjectVector<class UString>::~CObjectVector<class UString>(void)
.text:0000A1A8                 public ??1?$CObjectVector@VUString@@@@QAE@XZ
.text:0000A1A8 ??1?$CObjectVector@VUString@@@@QAE@XZ proc near
.text:0000A1A8                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1FF0p
.text:0000A1A8                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+22D4p ...
.text:0000A1A8
.text:0000A1A8 var_20          = dword ptr -20h
.text:0000A1A8 var_1C          = dword ptr -1Ch
.text:0000A1A8 var_18          = dword ptr -18h
.text:0000A1A8 var_14          = dword ptr -14h
.text:0000A1A8 var_10          = dword ptr -10h
.text:0000A1A8 var_C           = dword ptr -0Ch
.text:0000A1A8 var_4           = dword ptr -4
.text:0000A1A8
.text:0000A1A8                 push    ebp
.text:0000A1A9                 mov     ebp, esp
.text:0000A1AB                 push    0FFFFFFFFh
.text:0000A1AD                 push    offset __ehhandler$??1?$CObjectVector@VUString@@@@QAE@XZ
.text:0000A1B2                 mov     eax, large fs:0
.text:0000A1B8                 push    eax
.text:0000A1B9                 sub     esp, 14h
.text:0000A1BC                 mov     eax, 0CCCCCCCCh
.text:0000A1C1                 mov     [ebp+var_20], eax
.text:0000A1C4                 mov     [ebp+var_1C], eax
.text:0000A1C7                 mov     [ebp+var_18], eax
.text:0000A1CA                 mov     [ebp+var_14], eax
.text:0000A1CD                 mov     [ebp+var_10], eax
.text:0000A1D0                 mov     eax, dword ptr ds:___security_cookie
.text:0000A1D5                 xor     eax, ebp
.text:0000A1D7                 push    eax
.text:0000A1D8                 lea     eax, [ebp+var_C]
.text:0000A1DB                 mov     large fs:0, eax
.text:0000A1E1                 mov     [ebp+var_10], ecx
.text:0000A1E4                 mov     [ebp+var_4], 0
.text:0000A1EB                 mov     ecx, [ebp+var_10]
.text:0000A1EE                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:0000A1F3                 mov     [ebp+var_14], eax
.text:0000A1F6
.text:0000A1F6 loc_A1F6:                               ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void):loc_A238j
.text:0000A1F6                 cmp     [ebp+var_14], 0
.text:0000A1FA                 jz      short loc_A23A
.text:0000A1FC                 mov     eax, [ebp+var_14]
.text:0000A1FF                 sub     eax, 1
.text:0000A202                 mov     [ebp+var_14], eax
.text:0000A205                 mov     ecx, [ebp+var_14]
.text:0000A208                 push    ecx
.text:0000A209                 mov     ecx, [ebp+var_10]
.text:0000A20C                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:0000A211                 mov     edx, [eax]
.text:0000A213                 mov     [ebp+var_1C], edx
.text:0000A216                 mov     eax, [ebp+var_1C]
.text:0000A219                 mov     [ebp+var_18], eax
.text:0000A21C                 cmp     [ebp+var_18], 0
.text:0000A220                 jz      short loc_A231
.text:0000A222                 push    1
.text:0000A224                 mov     ecx, [ebp+var_18]
.text:0000A227                 call    ??_GUString@@QAEPAXI@Z ; UString::`scalar deleting destructor'(uint)
.text:0000A22C                 mov     [ebp+var_20], eax
.text:0000A22F                 jmp     short loc_A238
.text:0000A231 ; ---------------------------------------------------------------------------
.text:0000A231
.text:0000A231 loc_A231:                               ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+78j
.text:0000A231                 mov     [ebp+var_20], 0
.text:0000A238
.text:0000A238 loc_A238:                               ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+87j
.text:0000A238                 jmp     short loc_A1F6
.text:0000A23A ; ---------------------------------------------------------------------------
.text:0000A23A
.text:0000A23A loc_A23A:                               ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+52j
.text:0000A23A                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000A241                 mov     ecx, [ebp+var_10]
.text:0000A244                 call    ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text:0000A249                 mov     ecx, [ebp+var_C]
.text:0000A24C                 mov     large fs:0, ecx
.text:0000A253                 pop     ecx
.text:0000A254                 add     esp, 20h
.text:0000A257                 cmp     ebp, esp
.text:0000A259                 call    __RTC_CheckEsp
.text:0000A25E                 mov     esp, ebp
.text:0000A260                 pop     ebp
.text:0000A261                 retn
.text:0000A261 ??1?$CObjectVector@VUString@@@@QAE@XZ endp
.text:0000A261
.text:0000A261 ; ---------------------------------------------------------------------------
.text:0000A262                 align 4
.text:0000A262 _text           ends
.text:0000A262
.text$x:0000A264 ; ===========================================================================
.text$x:0000A264
.text$x:0000A264 ; Segment type: Pure code
.text$x:0000A264 ; Segment permissions: Read/Execute
.text$x:0000A264 _text$x         segment para public 'CODE' use32
.text$x:0000A264                 assume cs:_text$x
.text$x:0000A264                 ;org 0A264h
.text$x:0000A264 ; COMDAT (pick associative to section at A1A8)
.text$x:0000A264                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000A264
.text$x:0000A264 ; =============== S U B R O U T I N E =======================================
.text$x:0000A264
.text$x:0000A264
.text$x:0000A264 __unwindfunclet$??1?$CObjectVector@VUString@@@@QAE@XZ$0 proc near
.text$x:0000A264                                         ; DATA XREF: .xdata$x:0000A28Co
.text$x:0000A264                 mov     ecx, [ebp-10h]
.text$x:0000A267                 jmp     ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text$x:0000A267 __unwindfunclet$??1?$CObjectVector@VUString@@@@QAE@XZ$0 endp
.text$x:0000A267
.text$x:0000A26C
.text$x:0000A26C ; =============== S U B R O U T I N E =======================================
.text$x:0000A26C
.text$x:0000A26C
.text$x:0000A26C __ehhandler$??1?$CObjectVector@VUString@@@@QAE@XZ proc near
.text$x:0000A26C                                         ; DATA XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+5o
.text$x:0000A26C
.text$x:0000A26C arg_4           = dword ptr  8
.text$x:0000A26C
.text$x:0000A26C                 mov     edx, [esp+arg_4]
.text$x:0000A270                 lea     eax, [edx+0Ch]
.text$x:0000A273                 mov     ecx, [edx-18h]
.text$x:0000A276                 xor     ecx, eax
.text$x:0000A278                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000A27D                 mov     eax, offset __ehfuncinfo$??1?$CObjectVector@VUString@@@@QAE@XZ
.text$x:0000A282                 jmp     ___CxxFrameHandler3
.text$x:0000A282 __ehhandler$??1?$CObjectVector@VUString@@@@QAE@XZ endp
.text$x:0000A282
.text$x:0000A282 ; ---------------------------------------------------------------------------
.text$x:0000A287                 align 4
.text$x:0000A287 _text$x         ends
.text$x:0000A287
.xdata$x:0000A288 ; ===========================================================================
.xdata$x:0000A288
.xdata$x:0000A288 ; Segment type: Pure data
.xdata$x:0000A288 ; Segment permissions: Read
.xdata$x:0000A288 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A288                 assume cs:_xdata$x
.xdata$x:0000A288                 ;org 0A288h
.xdata$x:0000A288 ; COMDAT (pick associative to section at A1A8)
.xdata$x:0000A288 __unwindtable$??1?$CObjectVector@VUString@@@@QAE@XZ db 0FFh
.xdata$x:0000A288                                         ; DATA XREF: .xdata$x:0000A298o
.xdata$x:0000A289                 db 0FFh
.xdata$x:0000A28A                 db 0FFh
.xdata$x:0000A28B                 db 0FFh
.xdata$x:0000A28C                 dd offset __unwindfunclet$??1?$CObjectVector@VUString@@@@QAE@XZ$0
.xdata$x:0000A290 __ehfuncinfo$??1?$CObjectVector@VUString@@@@QAE@XZ db  22h ; "
.xdata$x:0000A290                                         ; DATA XREF: __ehhandler$??1?$CObjectVector@VUString@@@@QAE@XZ+11o
.xdata$x:0000A291                 db    5
.xdata$x:0000A292                 db  93h ; 
.xdata$x:0000A293                 db  19h
.xdata$x:0000A294                 db    1
.xdata$x:0000A295                 db    0
.xdata$x:0000A296                 db    0
.xdata$x:0000A297                 db    0
.xdata$x:0000A298                 dd offset __unwindtable$??1?$CObjectVector@VUString@@@@QAE@XZ
.xdata$x:0000A29C                 db    0
.xdata$x:0000A29D                 db    0
.xdata$x:0000A29E                 db    0
.xdata$x:0000A29F                 db    0
.xdata$x:0000A2A0                 db    0
.xdata$x:0000A2A1                 db    0
.xdata$x:0000A2A2                 db    0
.xdata$x:0000A2A3                 db    0
.xdata$x:0000A2A4                 db    0
.xdata$x:0000A2A5                 db    0
.xdata$x:0000A2A6                 db    0
.xdata$x:0000A2A7                 db    0
.xdata$x:0000A2A8                 db    0
.xdata$x:0000A2A9                 db    0
.xdata$x:0000A2AA                 db    0
.xdata$x:0000A2AB                 db    0
.xdata$x:0000A2AC                 db    0
.xdata$x:0000A2AD                 db    0
.xdata$x:0000A2AE                 db    0
.xdata$x:0000A2AF                 db    0
.xdata$x:0000A2B0                 db    1
.xdata$x:0000A2B1                 db    0
.xdata$x:0000A2B2                 db    0
.xdata$x:0000A2B3                 db    0
.xdata$x:0000A2B3 _xdata$x        ends
.xdata$x:0000A2B3
.text:0000A2B4 ; ===========================================================================
.text:0000A2B4
.text:0000A2B4 ; Segment type: Pure code
.text:0000A2B4 ; Segment permissions: Read/Execute
.text:0000A2B4 _text           segment para public 'CODE' use32
.text:0000A2B4                 assume cs:_text
.text:0000A2B4                 ;org 0A2B4h
.text:0000A2B4 ; COMDAT (pick any)
.text:0000A2B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A2B4
.text:0000A2B4 ; =============== S U B R O U T I N E =======================================
.text:0000A2B4
.text:0000A2B4 ; Attributes: bp-based frame
.text:0000A2B4
.text:0000A2B4 ; public: void __thiscall CObjectVector<class UString>::Clear(void)
.text:0000A2B4                 public ?Clear@?$CObjectVector@VUString@@@@QAEXXZ
.text:0000A2B4 ?Clear@?$CObjectVector@VUString@@@@QAEXXZ proc near
.text:0000A2B4                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1A64p
.text:0000A2B4                                         ; CObjectVector<UString>::operator=(CObjectVector<UString> const &)+52p
.text:0000A2B4
.text:0000A2B4 var_14          = dword ptr -14h
.text:0000A2B4 var_10          = dword ptr -10h
.text:0000A2B4 var_C           = dword ptr -0Ch
.text:0000A2B4 var_8           = dword ptr -8
.text:0000A2B4 var_4           = dword ptr -4
.text:0000A2B4
.text:0000A2B4                 push    ebp
.text:0000A2B5                 mov     ebp, esp
.text:0000A2B7                 sub     esp, 14h
.text:0000A2BA                 mov     eax, 0CCCCCCCCh
.text:0000A2BF                 mov     [ebp+var_14], eax
.text:0000A2C2                 mov     [ebp+var_10], eax
.text:0000A2C5                 mov     [ebp+var_C], eax
.text:0000A2C8                 mov     [ebp+var_8], eax
.text:0000A2CB                 mov     [ebp+var_4], eax
.text:0000A2CE                 mov     [ebp+var_4], ecx
.text:0000A2D1                 mov     ecx, [ebp+var_4]
.text:0000A2D4                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:0000A2D9                 mov     [ebp+var_8], eax
.text:0000A2DC
.text:0000A2DC loc_A2DC:                               ; CODE XREF: CObjectVector<UString>::Clear(void):loc_A31Ej
.text:0000A2DC                 cmp     [ebp+var_8], 0
.text:0000A2E0                 jz      short loc_A320
.text:0000A2E2                 mov     eax, [ebp+var_8]
.text:0000A2E5                 sub     eax, 1
.text:0000A2E8                 mov     [ebp+var_8], eax
.text:0000A2EB                 mov     ecx, [ebp+var_8]
.text:0000A2EE                 push    ecx
.text:0000A2EF                 mov     ecx, [ebp+var_4]
.text:0000A2F2                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:0000A2F7                 mov     edx, [eax]
.text:0000A2F9                 mov     [ebp+var_10], edx
.text:0000A2FC                 mov     eax, [ebp+var_10]
.text:0000A2FF                 mov     [ebp+var_C], eax
.text:0000A302                 cmp     [ebp+var_C], 0
.text:0000A306                 jz      short loc_A317
.text:0000A308                 push    1
.text:0000A30A                 mov     ecx, [ebp+var_C]
.text:0000A30D                 call    ??_GUString@@QAEPAXI@Z ; UString::`scalar deleting destructor'(uint)
.text:0000A312                 mov     [ebp+var_14], eax
.text:0000A315                 jmp     short loc_A31E
.text:0000A317 ; ---------------------------------------------------------------------------
.text:0000A317
.text:0000A317 loc_A317:                               ; CODE XREF: CObjectVector<UString>::Clear(void)+52j
.text:0000A317                 mov     [ebp+var_14], 0
.text:0000A31E
.text:0000A31E loc_A31E:                               ; CODE XREF: CObjectVector<UString>::Clear(void)+61j
.text:0000A31E                 jmp     short loc_A2DC
.text:0000A320 ; ---------------------------------------------------------------------------
.text:0000A320
.text:0000A320 loc_A320:                               ; CODE XREF: CObjectVector<UString>::Clear(void)+2Cj
.text:0000A320                 mov     ecx, [ebp+var_4]
.text:0000A323                 call    ?Clear@?$CRecordVector@PAX@@QAEXXZ ; CRecordVector<void *>::Clear(void)
.text:0000A328                 add     esp, 14h
.text:0000A32B                 cmp     ebp, esp
.text:0000A32D                 call    __RTC_CheckEsp
.text:0000A332                 mov     esp, ebp
.text:0000A334                 pop     ebp
.text:0000A335                 retn
.text:0000A335 ?Clear@?$CObjectVector@VUString@@@@QAEXXZ endp
.text:0000A335
.text:0000A335 ; ---------------------------------------------------------------------------
.text:0000A336                 align 4
.text:0000A336 _text           ends
.text:0000A336
.text:0000A338 ; ===========================================================================
.text:0000A338
.text:0000A338 ; Segment type: Pure code
.text:0000A338 ; Segment permissions: Read/Execute
.text:0000A338 _text           segment para public 'CODE' use32
.text:0000A338                 assume cs:_text
.text:0000A338                 ;org 0A338h
.text:0000A338 ; COMDAT (pick any)
.text:0000A338                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A338
.text:0000A338 ; =============== S U B R O U T I N E =======================================
.text:0000A338
.text:0000A338 ; Attributes: bp-based frame
.text:0000A338
.text:0000A338 ; public: unsigned int __thiscall CObjectVector<struct NWildcard::CPair>::Size(void)const
.text:0000A338                 public ?Size@?$CObjectVector@UCPair@NWildcard@@@@QBEIXZ
.text:0000A338 ?Size@?$CObjectVector@UCPair@NWildcard@@@@QBEIXZ proc near
.text:0000A338                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+F28p
.text:0000A338                                         ; Censor_CheckPath(NWildcard::CCensor const &,CReadArcItem const &)+33p
.text:0000A338
.text:0000A338 var_4           = dword ptr -4
.text:0000A338
.text:0000A338                 push    ebp
.text:0000A339                 mov     ebp, esp
.text:0000A33B                 push    ecx
.text:0000A33C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A343                 mov     [ebp+var_4], ecx
.text:0000A346                 mov     ecx, [ebp+var_4]
.text:0000A349                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:0000A34E                 add     esp, 4
.text:0000A351                 cmp     ebp, esp
.text:0000A353                 call    __RTC_CheckEsp
.text:0000A358                 mov     esp, ebp
.text:0000A35A                 pop     ebp
.text:0000A35B                 retn
.text:0000A35B ?Size@?$CObjectVector@UCPair@NWildcard@@@@QBEIXZ endp
.text:0000A35B
.text:0000A35B _text           ends
.text:0000A35B
.text:0000A35C ; ===========================================================================
.text:0000A35C
.text:0000A35C ; Segment type: Pure code
.text:0000A35C ; Segment permissions: Read/Execute
.text:0000A35C _text           segment para public 'CODE' use32
.text:0000A35C                 assume cs:_text
.text:0000A35C                 ;org 0A35Ch
.text:0000A35C ; COMDAT (pick any)
.text:0000A35C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A35C
.text:0000A35C ; =============== S U B R O U T I N E =======================================
.text:0000A35C
.text:0000A35C ; Attributes: bp-based frame
.text:0000A35C
.text:0000A35C ; public: struct NWildcard::CPair const & __thiscall CObjectVector<struct NWildcard::CPair>::operator[](unsigned int)const
.text:0000A35C                 public ??A?$CObjectVector@UCPair@NWildcard@@@@QBEABUCPair@NWildcard@@I@Z
.text:0000A35C ??A?$CObjectVector@UCPair@NWildcard@@@@QBEABUCPair@NWildcard@@I@Z proc near
.text:0000A35C                                         ; CODE XREF: Censor_CheckPath(NWildcard::CCensor const &,CReadArcItem const &)+4Cp
.text:0000A35C
.text:0000A35C var_4           = dword ptr -4
.text:0000A35C arg_0           = dword ptr  8
.text:0000A35C
.text:0000A35C                 push    ebp
.text:0000A35D                 mov     ebp, esp
.text:0000A35F                 push    ecx
.text:0000A360                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A367                 mov     [ebp+var_4], ecx
.text:0000A36A                 mov     eax, [ebp+arg_0]
.text:0000A36D                 push    eax
.text:0000A36E                 mov     ecx, [ebp+var_4]
.text:0000A371                 call    ??A?$CRecordVector@PAX@@QBEABQAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:0000A376                 mov     eax, [eax]
.text:0000A378                 add     esp, 4
.text:0000A37B                 cmp     ebp, esp
.text:0000A37D                 call    __RTC_CheckEsp
.text:0000A382                 mov     esp, ebp
.text:0000A384                 pop     ebp
.text:0000A385                 retn    4
.text:0000A385 ??A?$CObjectVector@UCPair@NWildcard@@@@QBEABUCPair@NWildcard@@I@Z endp
.text:0000A385
.text:0000A385 _text           ends
.text:0000A385
.text:0000A388 ; ===========================================================================
.text:0000A388
.text:0000A388 ; Segment type: Pure code
.text:0000A388 ; Segment permissions: Read/Execute
.text:0000A388 _text           segment para public 'CODE' use32
.text:0000A388                 assume cs:_text
.text:0000A388                 ;org 0A388h
.text:0000A388 ; COMDAT (pick any)
.text:0000A388                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A388
.text:0000A388 ; =============== S U B R O U T I N E =======================================
.text:0000A388
.text:0000A388 ; Attributes: bp-based frame
.text:0000A388
.text:0000A388 ; public: struct NWildcard::CPair & __thiscall CObjectVector<struct NWildcard::CPair>::operator[](unsigned int)
.text:0000A388                 public ??A?$CObjectVector@UCPair@NWildcard@@@@QAEAAUCPair@NWildcard@@I@Z
.text:0000A388 ??A?$CObjectVector@UCPair@NWildcard@@@@QAEAAUCPair@NWildcard@@I@Z proc near
.text:0000A388                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+F4Ap
.text:0000A388
.text:0000A388 var_4           = dword ptr -4
.text:0000A388 arg_0           = dword ptr  8
.text:0000A388
.text:0000A388                 push    ebp
.text:0000A389                 mov     ebp, esp
.text:0000A38B                 push    ecx
.text:0000A38C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A393                 mov     [ebp+var_4], ecx
.text:0000A396                 mov     eax, [ebp+arg_0]
.text:0000A399                 push    eax
.text:0000A39A                 mov     ecx, [ebp+var_4]
.text:0000A39D                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:0000A3A2                 mov     eax, [eax]
.text:0000A3A4                 add     esp, 4
.text:0000A3A7                 cmp     ebp, esp
.text:0000A3A9                 call    __RTC_CheckEsp
.text:0000A3AE                 mov     esp, ebp
.text:0000A3B0                 pop     ebp
.text:0000A3B1                 retn    4
.text:0000A3B1 ??A?$CObjectVector@UCPair@NWildcard@@@@QAEAAUCPair@NWildcard@@I@Z endp
.text:0000A3B1
.text:0000A3B1 _text           ends
.text:0000A3B1
.text:0000A3B4 ; ===========================================================================
.text:0000A3B4
.text:0000A3B4 ; Segment type: Pure code
.text:0000A3B4 ; Segment permissions: Read/Execute
.text:0000A3B4 _text           segment para public 'CODE' use32
.text:0000A3B4                 assume cs:_text
.text:0000A3B4                 ;org 0A3B4h
.text:0000A3B4 ; COMDAT (pick any)
.text:0000A3B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A3B4
.text:0000A3B4 ; =============== S U B R O U T I N E =======================================
.text:0000A3B4
.text:0000A3B4 ; Attributes: bp-based frame
.text:0000A3B4
.text:0000A3B4 ; public: __thiscall CRecordVector<unsigned __int64>::CRecordVector<unsigned __int64>(void)
.text:0000A3B4                 public ??0?$CRecordVector@_K@@QAE@XZ
.text:0000A3B4 ??0?$CRecordVector@_K@@QAE@XZ proc near ; CODE XREF: COutMultiVolStream::COutMultiVolStream(void)+61p
.text:0000A3B4
.text:0000A3B4 var_4           = dword ptr -4
.text:0000A3B4
.text:0000A3B4                 push    ebp
.text:0000A3B5                 mov     ebp, esp
.text:0000A3B7                 push    ecx
.text:0000A3B8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A3BF                 mov     [ebp+var_4], ecx
.text:0000A3C2                 mov     eax, [ebp+var_4]
.text:0000A3C5                 mov     dword ptr [eax], 0
.text:0000A3CB                 mov     ecx, [ebp+var_4]
.text:0000A3CE                 mov     dword ptr [ecx+4], 0
.text:0000A3D5                 mov     edx, [ebp+var_4]
.text:0000A3D8                 mov     dword ptr [edx+8], 0
.text:0000A3DF                 mov     eax, [ebp+var_4]
.text:0000A3E2                 mov     esp, ebp
.text:0000A3E4                 pop     ebp
.text:0000A3E5                 retn
.text:0000A3E5 ??0?$CRecordVector@_K@@QAE@XZ endp
.text:0000A3E5
.text:0000A3E5 ; ---------------------------------------------------------------------------
.text:0000A3E6                 align 4
.text:0000A3E6 _text           ends
.text:0000A3E6
.text:0000A3E8 ; ===========================================================================
.text:0000A3E8
.text:0000A3E8 ; Segment type: Pure code
.text:0000A3E8 ; Segment permissions: Read/Execute
.text:0000A3E8 _text           segment para public 'CODE' use32
.text:0000A3E8                 assume cs:_text
.text:0000A3E8                 ;org 0A3E8h
.text:0000A3E8 ; COMDAT (pick any)
.text:0000A3E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A3E8
.text:0000A3E8 ; =============== S U B R O U T I N E =======================================
.text:0000A3E8
.text:0000A3E8 ; Attributes: bp-based frame
.text:0000A3E8
.text:0000A3E8 ; public: unsigned int __thiscall CRecordVector<unsigned __int64>::Size(void)const
.text:0000A3E8                 public ?Size@?$CRecordVector@_K@@QBEIXZ
.text:0000A3E8 ?Size@?$CRecordVector@_K@@QBEIXZ proc near
.text:0000A3E8                                         ; CODE XREF: COutMultiVolStream::Write(void const *,uint,uint *)+1C8p
.text:0000A3E8                                         ; COutMultiVolStream::Write(void const *,uint,uint *)+1D8p ...
.text:0000A3E8
.text:0000A3E8 var_4           = dword ptr -4
.text:0000A3E8
.text:0000A3E8                 push    ebp
.text:0000A3E9                 mov     ebp, esp
.text:0000A3EB                 push    ecx
.text:0000A3EC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A3F3                 mov     [ebp+var_4], ecx
.text:0000A3F6                 mov     eax, [ebp+var_4]
.text:0000A3F9                 mov     eax, [eax+4]
.text:0000A3FC                 mov     esp, ebp
.text:0000A3FE                 pop     ebp
.text:0000A3FF                 retn
.text:0000A3FF ?Size@?$CRecordVector@_K@@QBEIXZ endp
.text:0000A3FF
.text:0000A3FF _text           ends
.text:0000A3FF
.text:0000A400 ; ===========================================================================
.text:0000A400
.text:0000A400 ; Segment type: Pure code
.text:0000A400 ; Segment permissions: Read/Execute
.text:0000A400 _text           segment para public 'CODE' use32
.text:0000A400                 assume cs:_text
.text:0000A400                 ;org 0A400h
.text:0000A400 ; COMDAT (pick any)
.text:0000A400                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A400
.text:0000A400 ; =============== S U B R O U T I N E =======================================
.text:0000A400
.text:0000A400 ; Attributes: bp-based frame
.text:0000A400
.text:0000A400 ; public: __thiscall CRecordVector<unsigned __int64>::~CRecordVector<unsigned __int64>(void)
.text:0000A400                 public ??1?$CRecordVector@_K@@QAE@XZ
.text:0000A400 ??1?$CRecordVector@_K@@QAE@XZ proc near ; CODE XREF: __unwindfunclet$??0COutMultiVolStream@@QAE@XZ$1+6j
.text:0000A400                                         ; COutMultiVolStream::~COutMultiVolStream(void)+49p ...
.text:0000A400
.text:0000A400 var_8           = dword ptr -8
.text:0000A400 var_4           = dword ptr -4
.text:0000A400
.text:0000A400                 push    ebp
.text:0000A401                 mov     ebp, esp
.text:0000A403                 sub     esp, 8
.text:0000A406                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000A40D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A414                 mov     [ebp+var_4], ecx
.text:0000A417                 mov     eax, [ebp+var_4]
.text:0000A41A                 mov     ecx, [eax]
.text:0000A41C                 mov     [ebp+var_8], ecx
.text:0000A41F                 mov     edx, [ebp+var_8]
.text:0000A422                 push    edx             ; void *
.text:0000A423                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000A428                 add     esp, 4
.text:0000A42B                 add     esp, 8
.text:0000A42E                 cmp     ebp, esp
.text:0000A430                 call    __RTC_CheckEsp
.text:0000A435                 mov     esp, ebp
.text:0000A437                 pop     ebp
.text:0000A438                 retn
.text:0000A438 ??1?$CRecordVector@_K@@QAE@XZ endp
.text:0000A438
.text:0000A438 ; ---------------------------------------------------------------------------
.text:0000A439                 align 4
.text:0000A439 _text           ends
.text:0000A439
.text:0000A43C ; ===========================================================================
.text:0000A43C
.text:0000A43C ; Segment type: Pure code
.text:0000A43C ; Segment permissions: Read/Execute
.text:0000A43C _text           segment para public 'CODE' use32
.text:0000A43C                 assume cs:_text
.text:0000A43C                 ;org 0A43Ch
.text:0000A43C ; COMDAT (pick any)
.text:0000A43C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A43C
.text:0000A43C ; =============== S U B R O U T I N E =======================================
.text:0000A43C
.text:0000A43C ; Attributes: bp-based frame
.text:0000A43C
.text:0000A43C ; public: class CRecordVector<unsigned __int64> & __thiscall CRecordVector<unsigned __int64>::operator=(class CRecordVector<unsigned __int64> const &)
.text:0000A43C                 public ??4?$CRecordVector@_K@@QAEAAV0@ABV0@@Z
.text:0000A43C ??4?$CRecordVector@_K@@QAEAAV0@ABV0@@Z proc near
.text:0000A43C                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+DD4p
.text:0000A43C
.text:0000A43C var_10          = dword ptr -10h
.text:0000A43C var_C           = dword ptr -0Ch
.text:0000A43C var_8           = dword ptr -8
.text:0000A43C var_4           = dword ptr -4
.text:0000A43C arg_0           = dword ptr  8
.text:0000A43C
.text:0000A43C                 push    ebp
.text:0000A43D                 mov     ebp, esp
.text:0000A43F                 sub     esp, 10h
.text:0000A442                 mov     eax, 0CCCCCCCCh
.text:0000A447                 mov     [ebp+var_10], eax
.text:0000A44A                 mov     [ebp+var_C], eax
.text:0000A44D                 mov     [ebp+var_8], eax
.text:0000A450                 mov     [ebp+var_4], eax
.text:0000A453                 mov     [ebp+var_4], ecx
.text:0000A456                 mov     eax, [ebp+arg_0]
.text:0000A459                 cmp     eax, [ebp+var_4]
.text:0000A45C                 jnz     short loc_A466
.text:0000A45E                 mov     eax, [ebp+var_4]
.text:0000A461                 jmp     loc_A50A
.text:0000A466 ; ---------------------------------------------------------------------------
.text:0000A466
.text:0000A466 loc_A466:                               ; CODE XREF: CRecordVector<unsigned __int64>::operator=(CRecordVector<unsigned __int64> const &)+20j
.text:0000A466                 mov     ecx, [ebp+arg_0]
.text:0000A469                 call    ?Size@?$CRecordVector@_K@@QBEIXZ ; CRecordVector<unsigned __int64>::Size(void)
.text:0000A46E                 mov     [ebp+var_8], eax
.text:0000A471                 mov     ecx, [ebp+var_4]
.text:0000A474                 mov     edx, [ebp+var_8]
.text:0000A477                 cmp     edx, [ecx+8]
.text:0000A47A                 jbe     short loc_A4DD
.text:0000A47C                 mov     eax, [ebp+var_4]
.text:0000A47F                 mov     ecx, [eax]
.text:0000A481                 mov     [ebp+var_C], ecx
.text:0000A484                 mov     edx, [ebp+var_C]
.text:0000A487                 push    edx             ; void *
.text:0000A488                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000A48D                 add     esp, 4
.text:0000A490                 mov     eax, [ebp+var_4]
.text:0000A493                 mov     dword ptr [eax+8], 0
.text:0000A49A                 mov     ecx, [ebp+var_4]
.text:0000A49D                 mov     dword ptr [ecx+4], 0
.text:0000A4A4                 mov     edx, [ebp+var_4]
.text:0000A4A7                 mov     dword ptr [edx], 0
.text:0000A4AD                 xor     ecx, ecx
.text:0000A4AF                 mov     eax, [ebp+var_8]
.text:0000A4B2                 mov     edx, 8
.text:0000A4B7                 mul     edx
.text:0000A4B9                 seto    cl
.text:0000A4BC                 neg     ecx
.text:0000A4BE                 or      ecx, eax
.text:0000A4C0                 push    ecx             ; unsigned int
.text:0000A4C1                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0000A4C6                 add     esp, 4
.text:0000A4C9                 mov     [ebp+var_10], eax
.text:0000A4CC                 mov     eax, [ebp+var_4]
.text:0000A4CF                 mov     ecx, [ebp+var_10]
.text:0000A4D2                 mov     [eax], ecx
.text:0000A4D4                 mov     edx, [ebp+var_4]
.text:0000A4D7                 mov     eax, [ebp+var_8]
.text:0000A4DA                 mov     [edx+8], eax
.text:0000A4DD
.text:0000A4DD loc_A4DD:                               ; CODE XREF: CRecordVector<unsigned __int64>::operator=(CRecordVector<unsigned __int64> const &)+3Ej
.text:0000A4DD                 mov     ecx, [ebp+var_4]
.text:0000A4E0                 mov     edx, [ebp+var_8]
.text:0000A4E3                 mov     [ecx+4], edx
.text:0000A4E6                 cmp     [ebp+var_8], 0
.text:0000A4EA                 jz      short loc_A507
.text:0000A4EC                 mov     eax, [ebp+var_8]
.text:0000A4EF                 shl     eax, 3
.text:0000A4F2                 push    eax             ; Size
.text:0000A4F3                 mov     ecx, [ebp+arg_0]
.text:0000A4F6                 mov     edx, [ecx]
.text:0000A4F8                 push    edx             ; Src
.text:0000A4F9                 mov     eax, [ebp+var_4]
.text:0000A4FC                 mov     ecx, [eax]
.text:0000A4FE                 push    ecx             ; Dst
.text:0000A4FF                 call    _memcpy
.text:0000A504                 add     esp, 0Ch
.text:0000A507
.text:0000A507 loc_A507:                               ; CODE XREF: CRecordVector<unsigned __int64>::operator=(CRecordVector<unsigned __int64> const &)+AEj
.text:0000A507                 mov     eax, [ebp+var_4]
.text:0000A50A
.text:0000A50A loc_A50A:                               ; CODE XREF: CRecordVector<unsigned __int64>::operator=(CRecordVector<unsigned __int64> const &)+25j
.text:0000A50A                 add     esp, 10h
.text:0000A50D                 cmp     ebp, esp
.text:0000A50F                 call    __RTC_CheckEsp
.text:0000A514                 mov     esp, ebp
.text:0000A516                 pop     ebp
.text:0000A517                 retn    4
.text:0000A517 ??4?$CRecordVector@_K@@QAEAAV0@ABV0@@Z endp
.text:0000A517
.text:0000A517 ; ---------------------------------------------------------------------------
.text:0000A51A                 align 4
.text:0000A51A _text           ends
.text:0000A51A
.text:0000A51C ; ===========================================================================
.text:0000A51C
.text:0000A51C ; Segment type: Pure code
.text:0000A51C ; Segment permissions: Read/Execute
.text:0000A51C _text           segment para public 'CODE' use32
.text:0000A51C                 assume cs:_text
.text:0000A51C                 ;org 0A51Ch
.text:0000A51C ; COMDAT (pick any)
.text:0000A51C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A51C
.text:0000A51C ; =============== S U B R O U T I N E =======================================
.text:0000A51C
.text:0000A51C ; Attributes: bp-based frame
.text:0000A51C
.text:0000A51C ; public: unsigned __int64 & __thiscall CRecordVector<unsigned __int64>::operator[](unsigned int)
.text:0000A51C                 public ??A?$CRecordVector@_K@@QAEAA_KI@Z
.text:0000A51C ??A?$CRecordVector@_K@@QAEAA_KI@Z proc near
.text:0000A51C                                         ; CODE XREF: COutMultiVolStream::Write(void const *,uint,uint *)+1EDp
.text:0000A51C
.text:0000A51C var_4           = dword ptr -4
.text:0000A51C arg_0           = dword ptr  8
.text:0000A51C
.text:0000A51C                 push    ebp
.text:0000A51D                 mov     ebp, esp
.text:0000A51F                 push    ecx
.text:0000A520                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A527                 mov     [ebp+var_4], ecx
.text:0000A52A                 mov     eax, [ebp+var_4]
.text:0000A52D                 mov     ecx, [eax]
.text:0000A52F                 mov     edx, [ebp+arg_0]
.text:0000A532                 lea     eax, [ecx+edx*8]
.text:0000A535                 mov     esp, ebp
.text:0000A537                 pop     ebp
.text:0000A538                 retn    4
.text:0000A538 ??A?$CRecordVector@_K@@QAEAA_KI@Z endp
.text:0000A538
.text:0000A538 ; ---------------------------------------------------------------------------
.text:0000A53B                 align 4
.text:0000A53B _text           ends
.text:0000A53B
.text:0000A53C ; ===========================================================================
.text:0000A53C
.text:0000A53C ; Segment type: Pure code
.text:0000A53C ; Segment permissions: Read/Execute
.text:0000A53C _text           segment para public 'CODE' use32
.text:0000A53C                 assume cs:_text
.text:0000A53C                 ;org 0A53Ch
.text:0000A53C ; COMDAT (pick any)
.text:0000A53C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A53C
.text:0000A53C ; =============== S U B R O U T I N E =======================================
.text:0000A53C
.text:0000A53C ; Attributes: bp-based frame
.text:0000A53C
.text:0000A53C ; public: bool __thiscall CObjectVector<struct CArcExtInfo>::IsEmpty(void)const
.text:0000A53C                 public ?IsEmpty@?$CObjectVector@UCArcExtInfo@@@@QBE_NXZ
.text:0000A53C ?IsEmpty@?$CObjectVector@UCArcExtInfo@@@@QBE_NXZ proc near
.text:0000A53C                                         ; CODE XREF: CArcInfoEx::GetMainExt(void)+24p
.text:0000A53C
.text:0000A53C var_4           = dword ptr -4
.text:0000A53C
.text:0000A53C                 push    ebp
.text:0000A53D                 mov     ebp, esp
.text:0000A53F                 push    ecx
.text:0000A540                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A547                 mov     [ebp+var_4], ecx
.text:0000A54A                 mov     ecx, [ebp+var_4]
.text:0000A54D                 call    ?IsEmpty@?$CRecordVector@PAX@@QBE_NXZ ; CRecordVector<void *>::IsEmpty(void)
.text:0000A552                 add     esp, 4
.text:0000A555                 cmp     ebp, esp
.text:0000A557                 call    __RTC_CheckEsp
.text:0000A55C                 mov     esp, ebp
.text:0000A55E                 pop     ebp
.text:0000A55F                 retn
.text:0000A55F ?IsEmpty@?$CObjectVector@UCArcExtInfo@@@@QBE_NXZ endp
.text:0000A55F
.text:0000A55F _text           ends
.text:0000A55F
.text:0000A560 ; ===========================================================================
.text:0000A560
.text:0000A560 ; Segment type: Pure code
.text:0000A560 ; Segment permissions: Read/Execute
.text:0000A560 _text           segment para public 'CODE' use32
.text:0000A560                 assume cs:_text
.text:0000A560                 ;org 0A560h
.text:0000A560 ; COMDAT (pick any)
.text:0000A560                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A560
.text:0000A560 ; =============== S U B R O U T I N E =======================================
.text:0000A560
.text:0000A560 ; Attributes: bp-based frame
.text:0000A560
.text:0000A560 ; public: struct CArcExtInfo const & __thiscall CObjectVector<struct CArcExtInfo>::operator[](unsigned int)const
.text:0000A560                 public ??A?$CObjectVector@UCArcExtInfo@@@@QBEABUCArcExtInfo@@I@Z
.text:0000A560 ??A?$CObjectVector@UCArcExtInfo@@@@QBEABUCArcExtInfo@@I@Z proc near
.text:0000A560                                         ; CODE XREF: CArcInfoEx::GetMainExt(void)+4Ep
.text:0000A560
.text:0000A560 var_4           = dword ptr -4
.text:0000A560 arg_0           = dword ptr  8
.text:0000A560
.text:0000A560                 push    ebp
.text:0000A561                 mov     ebp, esp
.text:0000A563                 push    ecx
.text:0000A564                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A56B                 mov     [ebp+var_4], ecx
.text:0000A56E                 mov     eax, [ebp+arg_0]
.text:0000A571                 push    eax
.text:0000A572                 mov     ecx, [ebp+var_4]
.text:0000A575                 call    ??A?$CRecordVector@PAX@@QBEABQAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:0000A57A                 mov     eax, [eax]
.text:0000A57C                 add     esp, 4
.text:0000A57F                 cmp     ebp, esp
.text:0000A581                 call    __RTC_CheckEsp
.text:0000A586                 mov     esp, ebp
.text:0000A588                 pop     ebp
.text:0000A589                 retn    4
.text:0000A589 ??A?$CObjectVector@UCArcExtInfo@@@@QBEABUCArcExtInfo@@I@Z endp
.text:0000A589
.text:0000A589 _text           ends
.text:0000A589
.text:0000A58C ; ===========================================================================
.text:0000A58C
.text:0000A58C ; Segment type: Pure code
.text:0000A58C ; Segment permissions: Read/Execute
.text:0000A58C _text           segment para public 'CODE' use32
.text:0000A58C                 assume cs:_text
.text:0000A58C                 ;org 0A58Ch
.text:0000A58C ; COMDAT (pick any)
.text:0000A58C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A58C
.text:0000A58C ; =============== S U B R O U T I N E =======================================
.text:0000A58C
.text:0000A58C ; Attributes: bp-based frame
.text:0000A58C
.text:0000A58C ; public: __thiscall CObjectVector<class CBuffer<unsigned char>>::~CObjectVector<class CBuffer<unsigned char>>(void)
.text:0000A58C                 public ??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ
.text:0000A58C ??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ proc near
.text:0000A58C                                         ; CODE XREF: CUniqBlocks::~CUniqBlocks(void)+58p
.text:0000A58C                                         ; __unwindfunclet$??1CUniqBlocks@@QAE@XZ$0+3j
.text:0000A58C
.text:0000A58C var_20          = dword ptr -20h
.text:0000A58C var_1C          = dword ptr -1Ch
.text:0000A58C var_18          = dword ptr -18h
.text:0000A58C var_14          = dword ptr -14h
.text:0000A58C var_10          = dword ptr -10h
.text:0000A58C var_C           = dword ptr -0Ch
.text:0000A58C var_4           = dword ptr -4
.text:0000A58C
.text:0000A58C                 push    ebp
.text:0000A58D                 mov     ebp, esp
.text:0000A58F                 push    0FFFFFFFFh
.text:0000A591                 push    offset __ehhandler$??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ
.text:0000A596                 mov     eax, large fs:0
.text:0000A59C                 push    eax
.text:0000A59D                 sub     esp, 14h
.text:0000A5A0                 mov     eax, 0CCCCCCCCh
.text:0000A5A5                 mov     [ebp+var_20], eax
.text:0000A5A8                 mov     [ebp+var_1C], eax
.text:0000A5AB                 mov     [ebp+var_18], eax
.text:0000A5AE                 mov     [ebp+var_14], eax
.text:0000A5B1                 mov     [ebp+var_10], eax
.text:0000A5B4                 mov     eax, dword ptr ds:___security_cookie
.text:0000A5B9                 xor     eax, ebp
.text:0000A5BB                 push    eax
.text:0000A5BC                 lea     eax, [ebp+var_C]
.text:0000A5BF                 mov     large fs:0, eax
.text:0000A5C5                 mov     [ebp+var_10], ecx
.text:0000A5C8                 mov     [ebp+var_4], 0
.text:0000A5CF                 mov     ecx, [ebp+var_10]
.text:0000A5D2                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:0000A5D7                 mov     [ebp+var_14], eax
.text:0000A5DA
.text:0000A5DA loc_A5DA:                               ; CODE XREF: CObjectVector<CBuffer<uchar>>::~CObjectVector<CBuffer<uchar>>(void):loc_A61Cj
.text:0000A5DA                 cmp     [ebp+var_14], 0
.text:0000A5DE                 jz      short loc_A61E
.text:0000A5E0                 mov     eax, [ebp+var_14]
.text:0000A5E3                 sub     eax, 1
.text:0000A5E6                 mov     [ebp+var_14], eax
.text:0000A5E9                 mov     ecx, [ebp+var_14]
.text:0000A5EC                 push    ecx
.text:0000A5ED                 mov     ecx, [ebp+var_10]
.text:0000A5F0                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:0000A5F5                 mov     edx, [eax]
.text:0000A5F7                 mov     [ebp+var_1C], edx
.text:0000A5FA                 mov     eax, [ebp+var_1C]
.text:0000A5FD                 mov     [ebp+var_18], eax
.text:0000A600                 cmp     [ebp+var_18], 0
.text:0000A604                 jz      short loc_A615
.text:0000A606                 push    1
.text:0000A608                 mov     ecx, [ebp+var_18]
.text:0000A60B                 call    ??_G?$CBuffer@E@@QAEPAXI@Z ; CBuffer<uchar>::`scalar deleting destructor'(uint)
.text:0000A610                 mov     [ebp+var_20], eax
.text:0000A613                 jmp     short loc_A61C
.text:0000A615 ; ---------------------------------------------------------------------------
.text:0000A615
.text:0000A615 loc_A615:                               ; CODE XREF: CObjectVector<CBuffer<uchar>>::~CObjectVector<CBuffer<uchar>>(void)+78j
.text:0000A615                 mov     [ebp+var_20], 0
.text:0000A61C
.text:0000A61C loc_A61C:                               ; CODE XREF: CObjectVector<CBuffer<uchar>>::~CObjectVector<CBuffer<uchar>>(void)+87j
.text:0000A61C                 jmp     short loc_A5DA
.text:0000A61E ; ---------------------------------------------------------------------------
.text:0000A61E
.text:0000A61E loc_A61E:                               ; CODE XREF: CObjectVector<CBuffer<uchar>>::~CObjectVector<CBuffer<uchar>>(void)+52j
.text:0000A61E                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000A625                 mov     ecx, [ebp+var_10]
.text:0000A628                 call    ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text:0000A62D                 mov     ecx, [ebp+var_C]
.text:0000A630                 mov     large fs:0, ecx
.text:0000A637                 pop     ecx
.text:0000A638                 add     esp, 20h
.text:0000A63B                 cmp     ebp, esp
.text:0000A63D                 call    __RTC_CheckEsp
.text:0000A642                 mov     esp, ebp
.text:0000A644                 pop     ebp
.text:0000A645                 retn
.text:0000A645 ??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ endp
.text:0000A645
.text:0000A645 ; ---------------------------------------------------------------------------
.text:0000A646                 align 4
.text:0000A646 _text           ends
.text:0000A646
.text$x:0000A648 ; ===========================================================================
.text$x:0000A648
.text$x:0000A648 ; Segment type: Pure code
.text$x:0000A648 ; Segment permissions: Read/Execute
.text$x:0000A648 _text$x         segment para public 'CODE' use32
.text$x:0000A648                 assume cs:_text$x
.text$x:0000A648                 ;org 0A648h
.text$x:0000A648 ; COMDAT (pick associative to section at A58C)
.text$x:0000A648                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000A648
.text$x:0000A648 ; =============== S U B R O U T I N E =======================================
.text$x:0000A648
.text$x:0000A648
.text$x:0000A648 __unwindfunclet$??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ$0 proc near
.text$x:0000A648                                         ; DATA XREF: .xdata$x:0000A670o
.text$x:0000A648                 mov     ecx, [ebp-10h]
.text$x:0000A64B                 jmp     ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text$x:0000A64B __unwindfunclet$??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ$0 endp
.text$x:0000A64B
.text$x:0000A650
.text$x:0000A650 ; =============== S U B R O U T I N E =======================================
.text$x:0000A650
.text$x:0000A650
.text$x:0000A650 __ehhandler$??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ proc near
.text$x:0000A650                                         ; DATA XREF: CObjectVector<CBuffer<uchar>>::~CObjectVector<CBuffer<uchar>>(void)+5o
.text$x:0000A650
.text$x:0000A650 arg_4           = dword ptr  8
.text$x:0000A650
.text$x:0000A650                 mov     edx, [esp+arg_4]
.text$x:0000A654                 lea     eax, [edx+0Ch]
.text$x:0000A657                 mov     ecx, [edx-18h]
.text$x:0000A65A                 xor     ecx, eax
.text$x:0000A65C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000A661                 mov     eax, offset __ehfuncinfo$??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ
.text$x:0000A666                 jmp     ___CxxFrameHandler3
.text$x:0000A666 __ehhandler$??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ endp
.text$x:0000A666
.text$x:0000A666 ; ---------------------------------------------------------------------------
.text$x:0000A66B                 align 4
.text$x:0000A66B _text$x         ends
.text$x:0000A66B
.xdata$x:0000A66C ; ===========================================================================
.xdata$x:0000A66C
.xdata$x:0000A66C ; Segment type: Pure data
.xdata$x:0000A66C ; Segment permissions: Read
.xdata$x:0000A66C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A66C                 assume cs:_xdata$x
.xdata$x:0000A66C                 ;org 0A66Ch
.xdata$x:0000A66C ; COMDAT (pick associative to section at A58C)
.xdata$x:0000A66C __unwindtable$??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ db 0FFh
.xdata$x:0000A66C                                         ; DATA XREF: .xdata$x:0000A67Co
.xdata$x:0000A66D                 db 0FFh
.xdata$x:0000A66E                 db 0FFh
.xdata$x:0000A66F                 db 0FFh
.xdata$x:0000A670                 dd offset __unwindfunclet$??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ$0
.xdata$x:0000A674 __ehfuncinfo$??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ db  22h ; "
.xdata$x:0000A674                                         ; DATA XREF: __ehhandler$??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ+11o
.xdata$x:0000A675                 db    5
.xdata$x:0000A676                 db  93h ; 
.xdata$x:0000A677                 db  19h
.xdata$x:0000A678                 db    1
.xdata$x:0000A679                 db    0
.xdata$x:0000A67A                 db    0
.xdata$x:0000A67B                 db    0
.xdata$x:0000A67C                 dd offset __unwindtable$??1?$CObjectVector@V?$CBuffer@E@@@@QAE@XZ
.xdata$x:0000A680                 db    0
.xdata$x:0000A681                 db    0
.xdata$x:0000A682                 db    0
.xdata$x:0000A683                 db    0
.xdata$x:0000A684                 db    0
.xdata$x:0000A685                 db    0
.xdata$x:0000A686                 db    0
.xdata$x:0000A687                 db    0
.xdata$x:0000A688                 db    0
.xdata$x:0000A689                 db    0
.xdata$x:0000A68A                 db    0
.xdata$x:0000A68B                 db    0
.xdata$x:0000A68C                 db    0
.xdata$x:0000A68D                 db    0
.xdata$x:0000A68E                 db    0
.xdata$x:0000A68F                 db    0
.xdata$x:0000A690                 db    0
.xdata$x:0000A691                 db    0
.xdata$x:0000A692                 db    0
.xdata$x:0000A693                 db    0
.xdata$x:0000A694                 db    1
.xdata$x:0000A695                 db    0
.xdata$x:0000A696                 db    0
.xdata$x:0000A697                 db    0
.xdata$x:0000A697 _xdata$x        ends
.xdata$x:0000A697
.text:0000A698 ; ===========================================================================
.text:0000A698
.text:0000A698 ; Segment type: Pure code
.text:0000A698 ; Segment permissions: Read/Execute
.text:0000A698 _text           segment para public 'CODE' use32
.text:0000A698                 assume cs:_text
.text:0000A698                 ;org 0A698h
.text:0000A698 ; COMDAT (pick any)
.text:0000A698                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A698
.text:0000A698 ; =============== S U B R O U T I N E =======================================
.text:0000A698
.text:0000A698 ; Attributes: bp-based frame
.text:0000A698
.text:0000A698 ; public: struct CArcInfoEx const & __thiscall CObjectVector<struct CArcInfoEx>::operator[](unsigned int)const
.text:0000A698                 public ??A?$CObjectVector@UCArcInfoEx@@@@QBEABUCArcInfoEx@@I@Z
.text:0000A698 ??A?$CObjectVector@UCArcInfoEx@@@@QBEABUCArcInfoEx@@I@Z proc near
.text:0000A698                                         ; CODE XREF: CUpdateOptions::SetArcPath(CCodecs const *,UString const &)+73p
.text:0000A698                                         ; CCodecs::CreateOutArchive(uint,CMyComPtr<IOutArchive> &)+4Ap
.text:0000A698
.text:0000A698 var_4           = dword ptr -4
.text:0000A698 arg_0           = dword ptr  8
.text:0000A698
.text:0000A698                 push    ebp
.text:0000A699                 mov     ebp, esp
.text:0000A69B                 push    ecx
.text:0000A69C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A6A3                 mov     [ebp+var_4], ecx
.text:0000A6A6                 mov     eax, [ebp+arg_0]
.text:0000A6A9                 push    eax
.text:0000A6AA                 mov     ecx, [ebp+var_4]
.text:0000A6AD                 call    ??A?$CRecordVector@PAX@@QBEABQAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:0000A6B2                 mov     eax, [eax]
.text:0000A6B4                 add     esp, 4
.text:0000A6B7                 cmp     ebp, esp
.text:0000A6B9                 call    __RTC_CheckEsp
.text:0000A6BE                 mov     esp, ebp
.text:0000A6C0                 pop     ebp
.text:0000A6C1                 retn    4
.text:0000A6C1 ??A?$CObjectVector@UCArcInfoEx@@@@QBEABUCArcInfoEx@@I@Z endp
.text:0000A6C1
.text:0000A6C1 _text           ends
.text:0000A6C1
.text:0000A6C4 ; ===========================================================================
.text:0000A6C4
.text:0000A6C4 ; Segment type: Pure code
.text:0000A6C4 ; Segment permissions: Read/Execute
.text:0000A6C4 _text           segment para public 'CODE' use32
.text:0000A6C4                 assume cs:_text
.text:0000A6C4                 ;org 0A6C4h
.text:0000A6C4 ; COMDAT (pick any)
.text:0000A6C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A6C4
.text:0000A6C4 ; =============== S U B R O U T I N E =======================================
.text:0000A6C4
.text:0000A6C4 ; Attributes: bp-based frame
.text:0000A6C4
.text:0000A6C4 ; public: struct CArcInfoEx & __thiscall CObjectVector<struct CArcInfoEx>::operator[](unsigned int)
.text:0000A6C4                 public ??A?$CObjectVector@UCArcInfoEx@@@@QAEAAUCArcInfoEx@@I@Z
.text:0000A6C4 ??A?$CObjectVector@UCArcInfoEx@@@@QAEAAUCArcInfoEx@@I@Z proc near
.text:0000A6C4                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+204p
.text:0000A6C4
.text:0000A6C4 var_4           = dword ptr -4
.text:0000A6C4 arg_0           = dword ptr  8
.text:0000A6C4
.text:0000A6C4                 push    ebp
.text:0000A6C5                 mov     ebp, esp
.text:0000A6C7                 push    ecx
.text:0000A6C8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A6CF                 mov     [ebp+var_4], ecx
.text:0000A6D2                 mov     eax, [ebp+arg_0]
.text:0000A6D5                 push    eax
.text:0000A6D6                 mov     ecx, [ebp+var_4]
.text:0000A6D9                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:0000A6DE                 mov     eax, [eax]
.text:0000A6E0                 add     esp, 4
.text:0000A6E3                 cmp     ebp, esp
.text:0000A6E5                 call    __RTC_CheckEsp
.text:0000A6EA                 mov     esp, ebp
.text:0000A6EC                 pop     ebp
.text:0000A6ED                 retn    4
.text:0000A6ED ??A?$CObjectVector@UCArcInfoEx@@@@QAEAAUCArcInfoEx@@I@Z endp
.text:0000A6ED
.text:0000A6ED _text           ends
.text:0000A6ED
.text:0000A6F0 ; ===========================================================================
.text:0000A6F0
.text:0000A6F0 ; Segment type: Pure code
.text:0000A6F0 ; Segment permissions: Read/Execute
.text:0000A6F0 _text           segment para public 'CODE' use32
.text:0000A6F0                 assume cs:_text
.text:0000A6F0                 ;org 0A6F0h
.text:0000A6F0 ; COMDAT (pick any)
.text:0000A6F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A6F0
.text:0000A6F0 ; =============== S U B R O U T I N E =======================================
.text:0000A6F0
.text:0000A6F0 ; Attributes: bp-based frame
.text:0000A6F0
.text:0000A6F0 ; public: __thiscall CMyComPtr<struct IInArchive>::CMyComPtr<struct IInArchive>(class CMyComPtr<struct IInArchive> const &)
.text:0000A6F0                 public ??0?$CMyComPtr@UIInArchive@@@@QAE@ABV0@@Z
.text:0000A6F0 ??0?$CMyComPtr@UIInArchive@@@@QAE@ABV0@@Z proc near
.text:0000A6F0                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+9Ep
.text:0000A6F0
.text:0000A6F0 var_4           = dword ptr -4
.text:0000A6F0 arg_0           = dword ptr  8
.text:0000A6F0
.text:0000A6F0                 push    ebp
.text:0000A6F1                 mov     ebp, esp
.text:0000A6F3                 push    ecx
.text:0000A6F4                 push    esi
.text:0000A6F5                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A6FC                 mov     [ebp+var_4], ecx
.text:0000A6FF                 mov     eax, [ebp+var_4]
.text:0000A702                 mov     ecx, [ebp+arg_0]
.text:0000A705                 mov     edx, [ecx]
.text:0000A707                 mov     [eax], edx
.text:0000A709                 mov     eax, [ebp+var_4]
.text:0000A70C                 cmp     dword ptr [eax], 0
.text:0000A70F                 jz      short loc_A72C
.text:0000A711                 mov     ecx, [ebp+var_4]
.text:0000A714                 mov     edx, [ecx]
.text:0000A716                 mov     eax, [ebp+var_4]
.text:0000A719                 mov     ecx, [eax]
.text:0000A71B                 mov     edx, [edx]
.text:0000A71D                 mov     esi, esp
.text:0000A71F                 push    ecx
.text:0000A720                 mov     eax, [edx+4]
.text:0000A723                 call    eax
.text:0000A725                 cmp     esi, esp
.text:0000A727                 call    __RTC_CheckEsp
.text:0000A72C
.text:0000A72C loc_A72C:                               ; CODE XREF: CMyComPtr<IInArchive>::CMyComPtr<IInArchive>(CMyComPtr<IInArchive> const &)+1Fj
.text:0000A72C                 mov     eax, [ebp+var_4]
.text:0000A72F                 pop     esi
.text:0000A730                 add     esp, 4
.text:0000A733                 cmp     ebp, esp
.text:0000A735                 call    __RTC_CheckEsp
.text:0000A73A                 mov     esp, ebp
.text:0000A73C                 pop     ebp
.text:0000A73D                 retn    4
.text:0000A73D ??0?$CMyComPtr@UIInArchive@@@@QAE@ABV0@@Z endp
.text:0000A73D
.text:0000A73D _text           ends
.text:0000A73D
.text:0000A740 ; ===========================================================================
.text:0000A740
.text:0000A740 ; Segment type: Pure code
.text:0000A740 ; Segment permissions: Read/Execute
.text:0000A740 _text           segment para public 'CODE' use32
.text:0000A740                 assume cs:_text
.text:0000A740                 ;org 0A740h
.text:0000A740 ; COMDAT (pick any)
.text:0000A740                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A740
.text:0000A740 ; =============== S U B R O U T I N E =======================================
.text:0000A740
.text:0000A740 ; Attributes: bp-based frame
.text:0000A740
.text:0000A740 ; public: __thiscall CMyComPtr<struct IInArchive>::~CMyComPtr<struct IInArchive>(void)
.text:0000A740                 public ??1?$CMyComPtr@UIInArchive@@@@QAE@XZ
.text:0000A740 ??1?$CMyComPtr@UIInArchive@@@@QAE@XZ proc near
.text:0000A740                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+EAp
.text:0000A740                                         ; __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$1+3j ...
.text:0000A740
.text:0000A740 var_4           = dword ptr -4
.text:0000A740
.text:0000A740                 push    ebp
.text:0000A741                 mov     ebp, esp
.text:0000A743                 push    ecx
.text:0000A744                 push    esi
.text:0000A745                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A74C                 mov     [ebp+var_4], ecx
.text:0000A74F                 mov     eax, [ebp+var_4]
.text:0000A752                 cmp     dword ptr [eax], 0
.text:0000A755                 jz      short loc_A772
.text:0000A757                 mov     ecx, [ebp+var_4]
.text:0000A75A                 mov     edx, [ecx]
.text:0000A75C                 mov     eax, [ebp+var_4]
.text:0000A75F                 mov     ecx, [eax]
.text:0000A761                 mov     edx, [edx]
.text:0000A763                 mov     esi, esp
.text:0000A765                 push    ecx
.text:0000A766                 mov     eax, [edx+8]
.text:0000A769                 call    eax
.text:0000A76B                 cmp     esi, esp
.text:0000A76D                 call    __RTC_CheckEsp
.text:0000A772
.text:0000A772 loc_A772:                               ; CODE XREF: CMyComPtr<IInArchive>::~CMyComPtr<IInArchive>(void)+15j
.text:0000A772                 pop     esi
.text:0000A773                 add     esp, 4
.text:0000A776                 cmp     ebp, esp
.text:0000A778                 call    __RTC_CheckEsp
.text:0000A77D                 mov     esp, ebp
.text:0000A77F                 pop     ebp
.text:0000A780                 retn
.text:0000A780 ??1?$CMyComPtr@UIInArchive@@@@QAE@XZ endp
.text:0000A780
.text:0000A780 ; ---------------------------------------------------------------------------
.text:0000A781                 align 4
.text:0000A781 _text           ends
.text:0000A781
.text:0000A784 ; ===========================================================================
.text:0000A784
.text:0000A784 ; Segment type: Pure code
.text:0000A784 ; Segment permissions: Read/Execute
.text:0000A784 _text           segment para public 'CODE' use32
.text:0000A784                 assume cs:_text
.text:0000A784                 ;org 0A784h
.text:0000A784 ; COMDAT (pick any)
.text:0000A784                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A784
.text:0000A784 ; =============== S U B R O U T I N E =======================================
.text:0000A784
.text:0000A784 ; Attributes: bp-based frame
.text:0000A784
.text:0000A784 ; public: __thiscall CMyComPtr<struct IInArchive>::operator struct IInArchive *(void)const
.text:0000A784                 public ??B?$CMyComPtr@UIInArchive@@@@QBEPAUIInArchive@@XZ
.text:0000A784 ??B?$CMyComPtr@UIInArchive@@@@QBEPAUIInArchive@@XZ proc near
.text:0000A784                                         ; CODE XREF: EnumerateInArchiveItems(NWildcard::CCensor const &,CArc const &,CObjectVector<CArcItem> &)+47p
.text:0000A784                                         ; CArc::IsItemAnti(uint,bool &)+1Bp
.text:0000A784
.text:0000A784 var_4           = dword ptr -4
.text:0000A784
.text:0000A784                 push    ebp
.text:0000A785                 mov     ebp, esp
.text:0000A787                 push    ecx
.text:0000A788                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A78F                 mov     [ebp+var_4], ecx
.text:0000A792                 mov     eax, [ebp+var_4]
.text:0000A795                 mov     eax, [eax]
.text:0000A797                 mov     esp, ebp
.text:0000A799                 pop     ebp
.text:0000A79A                 retn
.text:0000A79A ??B?$CMyComPtr@UIInArchive@@@@QBEPAUIInArchive@@XZ endp
.text:0000A79A
.text:0000A79A ; ---------------------------------------------------------------------------
.text:0000A79B                 align 4
.text:0000A79B _text           ends
.text:0000A79B
.text:0000A79C ; ===========================================================================
.text:0000A79C
.text:0000A79C ; Segment type: Pure code
.text:0000A79C ; Segment permissions: Read/Execute
.text:0000A79C _text           segment para public 'CODE' use32
.text:0000A79C                 assume cs:_text
.text:0000A79C                 ;org 0A79Ch
.text:0000A79C ; COMDAT (pick any)
.text:0000A79C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A79C
.text:0000A79C ; =============== S U B R O U T I N E =======================================
.text:0000A79C
.text:0000A79C ; Attributes: bp-based frame
.text:0000A79C
.text:0000A79C ; public: struct IInArchive * __thiscall CMyComPtr<struct IInArchive>::operator=(class CMyComPtr<struct IInArchive> const &)
.text:0000A79C                 public ??4?$CMyComPtr@UIInArchive@@@@QAEPAUIInArchive@@ABV0@@Z
.text:0000A79C ??4?$CMyComPtr@UIInArchive@@@@QAEPAUIInArchive@@ABV0@@Z proc near
.text:0000A79C                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+74Fp
.text:0000A79C
.text:0000A79C var_4           = dword ptr -4
.text:0000A79C arg_0           = dword ptr  8
.text:0000A79C
.text:0000A79C                 push    ebp
.text:0000A79D                 mov     ebp, esp
.text:0000A79F                 push    ecx
.text:0000A7A0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A7A7                 mov     [ebp+var_4], ecx
.text:0000A7AA                 mov     eax, [ebp+arg_0]
.text:0000A7AD                 mov     ecx, [eax]
.text:0000A7AF                 push    ecx
.text:0000A7B0                 mov     ecx, [ebp+var_4]
.text:0000A7B3                 call    ??4?$CMyComPtr@UIInArchive@@@@QAEPAUIInArchive@@PAU1@@Z ; CMyComPtr<IInArchive>::operator=(IInArchive *)
.text:0000A7B8                 add     esp, 4
.text:0000A7BB                 cmp     ebp, esp
.text:0000A7BD                 call    __RTC_CheckEsp
.text:0000A7C2                 mov     esp, ebp
.text:0000A7C4                 pop     ebp
.text:0000A7C5                 retn    4
.text:0000A7C5 ??4?$CMyComPtr@UIInArchive@@@@QAEPAUIInArchive@@ABV0@@Z endp
.text:0000A7C5
.text:0000A7C5 _text           ends
.text:0000A7C5
.text:0000A7C8 ; ===========================================================================
.text:0000A7C8
.text:0000A7C8 ; Segment type: Pure code
.text:0000A7C8 ; Segment permissions: Read/Execute
.text:0000A7C8 _text           segment para public 'CODE' use32
.text:0000A7C8                 assume cs:_text
.text:0000A7C8                 ;org 0A7C8h
.text:0000A7C8 ; COMDAT (pick any)
.text:0000A7C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A7C8
.text:0000A7C8 ; =============== S U B R O U T I N E =======================================
.text:0000A7C8
.text:0000A7C8 ; Attributes: bp-based frame
.text:0000A7C8
.text:0000A7C8 ; public: struct IInArchive * __thiscall CMyComPtr<struct IInArchive>::operator=(struct IInArchive *)
.text:0000A7C8                 public ??4?$CMyComPtr@UIInArchive@@@@QAEPAUIInArchive@@PAU1@@Z
.text:0000A7C8 ??4?$CMyComPtr@UIInArchive@@@@QAEPAUIInArchive@@PAU1@@Z proc near
.text:0000A7C8                                         ; CODE XREF: CMyComPtr<IInArchive>::operator=(CMyComPtr<IInArchive> const &)+17p
.text:0000A7C8
.text:0000A7C8 var_4           = dword ptr -4
.text:0000A7C8 arg_0           = dword ptr  8
.text:0000A7C8
.text:0000A7C8                 push    ebp
.text:0000A7C9                 mov     ebp, esp
.text:0000A7CB                 push    ecx
.text:0000A7CC                 push    esi
.text:0000A7CD                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A7D4                 mov     [ebp+var_4], ecx
.text:0000A7D7                 cmp     [ebp+arg_0], 0
.text:0000A7DB                 jz      short loc_A7F4
.text:0000A7DD                 mov     eax, [ebp+arg_0]
.text:0000A7E0                 mov     ecx, [eax]
.text:0000A7E2                 mov     esi, esp
.text:0000A7E4                 mov     edx, [ebp+arg_0]
.text:0000A7E7                 push    edx
.text:0000A7E8                 mov     eax, [ecx+4]
.text:0000A7EB                 call    eax
.text:0000A7ED                 cmp     esi, esp
.text:0000A7EF                 call    __RTC_CheckEsp
.text:0000A7F4
.text:0000A7F4 loc_A7F4:                               ; CODE XREF: CMyComPtr<IInArchive>::operator=(IInArchive *)+13j
.text:0000A7F4                 mov     ecx, [ebp+var_4]
.text:0000A7F7                 cmp     dword ptr [ecx], 0
.text:0000A7FA                 jz      short loc_A817
.text:0000A7FC                 mov     edx, [ebp+var_4]
.text:0000A7FF                 mov     eax, [edx]
.text:0000A801                 mov     ecx, [ebp+var_4]
.text:0000A804                 mov     edx, [ecx]
.text:0000A806                 mov     eax, [eax]
.text:0000A808                 mov     esi, esp
.text:0000A80A                 push    edx
.text:0000A80B                 mov     ecx, [eax+8]
.text:0000A80E                 call    ecx
.text:0000A810                 cmp     esi, esp
.text:0000A812                 call    __RTC_CheckEsp
.text:0000A817
.text:0000A817 loc_A817:                               ; CODE XREF: CMyComPtr<IInArchive>::operator=(IInArchive *)+32j
.text:0000A817                 mov     edx, [ebp+var_4]
.text:0000A81A                 mov     eax, [ebp+arg_0]
.text:0000A81D                 mov     [edx], eax
.text:0000A81F                 mov     eax, [ebp+arg_0]
.text:0000A822                 pop     esi
.text:0000A823                 add     esp, 4
.text:0000A826                 cmp     ebp, esp
.text:0000A828                 call    __RTC_CheckEsp
.text:0000A82D                 mov     esp, ebp
.text:0000A82F                 pop     ebp
.text:0000A830                 retn    4
.text:0000A830 ??4?$CMyComPtr@UIInArchive@@@@QAEPAUIInArchive@@PAU1@@Z endp
.text:0000A830
.text:0000A830 ; ---------------------------------------------------------------------------
.text:0000A833                 align 4
.text:0000A833 _text           ends
.text:0000A833
.text:0000A834 ; ===========================================================================
.text:0000A834
.text:0000A834 ; Segment type: Pure code
.text:0000A834 ; Segment permissions: Read/Execute
.text:0000A834 _text           segment para public 'CODE' use32
.text:0000A834                 assume cs:_text
.text:0000A834                 ;org 0A834h
.text:0000A834 ; COMDAT (pick any)
.text:0000A834                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A834
.text:0000A834 ; =============== S U B R O U T I N E =======================================
.text:0000A834
.text:0000A834 ; Attributes: bp-based frame
.text:0000A834
.text:0000A834 ; public: __thiscall CMyComPtr<struct IOutArchive>::CMyComPtr<struct IOutArchive>(void)
.text:0000A834                 public ??0?$CMyComPtr@UIOutArchive@@@@QAE@XZ
.text:0000A834 ??0?$CMyComPtr@UIOutArchive@@@@QAE@XZ proc near
.text:0000A834                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+42p
.text:0000A834
.text:0000A834 var_4           = dword ptr -4
.text:0000A834
.text:0000A834                 push    ebp
.text:0000A835                 mov     ebp, esp
.text:0000A837                 push    ecx
.text:0000A838                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A83F                 mov     [ebp+var_4], ecx
.text:0000A842                 mov     eax, [ebp+var_4]
.text:0000A845                 mov     dword ptr [eax], 0
.text:0000A84B                 mov     eax, [ebp+var_4]
.text:0000A84E                 mov     esp, ebp
.text:0000A850                 pop     ebp
.text:0000A851                 retn
.text:0000A851 ??0?$CMyComPtr@UIOutArchive@@@@QAE@XZ endp
.text:0000A851
.text:0000A851 ; ---------------------------------------------------------------------------
.text:0000A852                 align 4
.text:0000A852 _text           ends
.text:0000A852
.text:0000A854 ; ===========================================================================
.text:0000A854
.text:0000A854 ; Segment type: Pure code
.text:0000A854 ; Segment permissions: Read/Execute
.text:0000A854 _text           segment para public 'CODE' use32
.text:0000A854                 assume cs:_text
.text:0000A854                 ;org 0A854h
.text:0000A854 ; COMDAT (pick any)
.text:0000A854                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A854
.text:0000A854 ; =============== S U B R O U T I N E =======================================
.text:0000A854
.text:0000A854 ; Attributes: bp-based frame
.text:0000A854
.text:0000A854 ; public: __thiscall CMyComPtr<struct IOutArchive>::~CMyComPtr<struct IOutArchive>(void)
.text:0000A854                 public ??1?$CMyComPtr@UIOutArchive@@@@QAE@XZ
.text:0000A854 ??1?$CMyComPtr@UIOutArchive@@@@QAE@XZ proc near
.text:0000A854                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+87p
.text:0000A854                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+11Dp ...
.text:0000A854
.text:0000A854 var_4           = dword ptr -4
.text:0000A854
.text:0000A854                 push    ebp
.text:0000A855                 mov     ebp, esp
.text:0000A857                 push    ecx
.text:0000A858                 push    esi
.text:0000A859                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A860                 mov     [ebp+var_4], ecx
.text:0000A863                 mov     eax, [ebp+var_4]
.text:0000A866                 cmp     dword ptr [eax], 0
.text:0000A869                 jz      short loc_A886
.text:0000A86B                 mov     ecx, [ebp+var_4]
.text:0000A86E                 mov     edx, [ecx]
.text:0000A870                 mov     eax, [ebp+var_4]
.text:0000A873                 mov     ecx, [eax]
.text:0000A875                 mov     edx, [edx]
.text:0000A877                 mov     esi, esp
.text:0000A879                 push    ecx
.text:0000A87A                 mov     eax, [edx+8]
.text:0000A87D                 call    eax
.text:0000A87F                 cmp     esi, esp
.text:0000A881                 call    __RTC_CheckEsp
.text:0000A886
.text:0000A886 loc_A886:                               ; CODE XREF: CMyComPtr<IOutArchive>::~CMyComPtr<IOutArchive>(void)+15j
.text:0000A886                 pop     esi
.text:0000A887                 add     esp, 4
.text:0000A88A                 cmp     ebp, esp
.text:0000A88C                 call    __RTC_CheckEsp
.text:0000A891                 mov     esp, ebp
.text:0000A893                 pop     ebp
.text:0000A894                 retn
.text:0000A894 ??1?$CMyComPtr@UIOutArchive@@@@QAE@XZ endp
.text:0000A894
.text:0000A894 ; ---------------------------------------------------------------------------
.text:0000A895                 align 4
.text:0000A895 _text           ends
.text:0000A895
.text:0000A898 ; ===========================================================================
.text:0000A898
.text:0000A898 ; Segment type: Pure code
.text:0000A898 ; Segment permissions: Read/Execute
.text:0000A898 _text           segment para public 'CODE' use32
.text:0000A898                 assume cs:_text
.text:0000A898                 ;org 0A898h
.text:0000A898 ; COMDAT (pick any)
.text:0000A898                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A898
.text:0000A898 ; =============== S U B R O U T I N E =======================================
.text:0000A898
.text:0000A898 ; Attributes: bp-based frame
.text:0000A898
.text:0000A898 ; public: __thiscall CMyComPtr<struct IOutArchive>::operator struct IOutArchive *(void)const
.text:0000A898                 public ??B?$CMyComPtr@UIOutArchive@@@@QBEPAUIOutArchive@@XZ
.text:0000A898 ??B?$CMyComPtr@UIOutArchive@@@@QBEPAUIOutArchive@@XZ proc near
.text:0000A898                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+130p
.text:0000A898                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+E53p
.text:0000A898
.text:0000A898 var_4           = dword ptr -4
.text:0000A898
.text:0000A898                 push    ebp
.text:0000A899                 mov     ebp, esp
.text:0000A89B                 push    ecx
.text:0000A89C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A8A3                 mov     [ebp+var_4], ecx
.text:0000A8A6                 mov     eax, [ebp+var_4]
.text:0000A8A9                 mov     eax, [eax]
.text:0000A8AB                 mov     esp, ebp
.text:0000A8AD                 pop     ebp
.text:0000A8AE                 retn
.text:0000A8AE ??B?$CMyComPtr@UIOutArchive@@@@QBEPAUIOutArchive@@XZ endp
.text:0000A8AE
.text:0000A8AE ; ---------------------------------------------------------------------------
.text:0000A8AF                 align 10h
.text:0000A8AF _text           ends
.text:0000A8AF
.text:0000A8B0 ; ===========================================================================
.text:0000A8B0
.text:0000A8B0 ; Segment type: Pure code
.text:0000A8B0 ; Segment permissions: Read/Execute
.text:0000A8B0 _text           segment para public 'CODE' use32
.text:0000A8B0                 assume cs:_text
.text:0000A8B0                 ;org 0A8B0h
.text:0000A8B0 ; COMDAT (pick any)
.text:0000A8B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A8B0
.text:0000A8B0 ; =============== S U B R O U T I N E =======================================
.text:0000A8B0
.text:0000A8B0 ; Attributes: bp-based frame
.text:0000A8B0
.text:0000A8B0 ; public: struct IOutArchive * * __thiscall CMyComPtr<struct IOutArchive>::operator&(void)
.text:0000A8B0                 public ??I?$CMyComPtr@UIOutArchive@@@@QAEPAPAUIOutArchive@@XZ
.text:0000A8B0 ??I?$CMyComPtr@UIOutArchive@@@@QAEPAPAUIOutArchive@@XZ proc near
.text:0000A8B0                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+AAp
.text:0000A8B0
.text:0000A8B0 var_4           = dword ptr -4
.text:0000A8B0
.text:0000A8B0                 push    ebp
.text:0000A8B1                 mov     ebp, esp
.text:0000A8B3                 push    ecx
.text:0000A8B4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A8BB                 mov     [ebp+var_4], ecx
.text:0000A8BE                 mov     eax, [ebp+var_4]
.text:0000A8C1                 mov     esp, ebp
.text:0000A8C3                 pop     ebp
.text:0000A8C4                 retn
.text:0000A8C4 ??I?$CMyComPtr@UIOutArchive@@@@QAEPAPAUIOutArchive@@XZ endp
.text:0000A8C4
.text:0000A8C4 ; ---------------------------------------------------------------------------
.text:0000A8C5                 align 4
.text:0000A8C5 _text           ends
.text:0000A8C5
.text:0000A8C8 ; ===========================================================================
.text:0000A8C8
.text:0000A8C8 ; Segment type: Pure code
.text:0000A8C8 ; Segment permissions: Read/Execute
.text:0000A8C8 _text           segment para public 'CODE' use32
.text:0000A8C8                 assume cs:_text
.text:0000A8C8                 ;org 0A8C8h
.text:0000A8C8 ; COMDAT (pick any)
.text:0000A8C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A8C8
.text:0000A8C8 ; =============== S U B R O U T I N E =======================================
.text:0000A8C8
.text:0000A8C8 ; Attributes: bp-based frame
.text:0000A8C8
.text:0000A8C8 ; public: struct IOutArchive * __thiscall CMyComPtr<struct IOutArchive>::operator->(void)const
.text:0000A8C8                 public ??C?$CMyComPtr@UIOutArchive@@@@QBEPAUIOutArchive@@XZ
.text:0000A8C8 ??C?$CMyComPtr@UIOutArchive@@@@QBEPAUIOutArchive@@XZ proc near
.text:0000A8C8                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+159p
.text:0000A8C8                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+175Ap
.text:0000A8C8
.text:0000A8C8 var_4           = dword ptr -4
.text:0000A8C8
.text:0000A8C8                 push    ebp
.text:0000A8C9                 mov     ebp, esp
.text:0000A8CB                 push    ecx
.text:0000A8CC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A8D3                 mov     [ebp+var_4], ecx
.text:0000A8D6                 mov     eax, [ebp+var_4]
.text:0000A8D9                 mov     eax, [eax]
.text:0000A8DB                 mov     esp, ebp
.text:0000A8DD                 pop     ebp
.text:0000A8DE                 retn
.text:0000A8DE ??C?$CMyComPtr@UIOutArchive@@@@QBEPAUIOutArchive@@XZ endp
.text:0000A8DE
.text:0000A8DE ; ---------------------------------------------------------------------------
.text:0000A8DF                 align 10h
.text:0000A8DF _text           ends
.text:0000A8DF
.text:0000A8E0 ; ===========================================================================
.text:0000A8E0
.text:0000A8E0 ; Segment type: Pure code
.text:0000A8E0 ; Segment permissions: Read/Execute
.text:0000A8E0 _text           segment para public 'CODE' use32
.text:0000A8E0                 assume cs:_text
.text:0000A8E0                 ;org 0A8E0h
.text:0000A8E0 ; COMDAT (pick any)
.text:0000A8E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A8E0
.text:0000A8E0 ; =============== S U B R O U T I N E =======================================
.text:0000A8E0
.text:0000A8E0 ; Attributes: bp-based frame
.text:0000A8E0
.text:0000A8E0 ; public: struct IOutArchive * __thiscall CMyComPtr<struct IOutArchive>::operator=(struct IOutArchive *)
.text:0000A8E0                 public ??4?$CMyComPtr@UIOutArchive@@@@QAEPAUIOutArchive@@PAU1@@Z
.text:0000A8E0 ??4?$CMyComPtr@UIOutArchive@@@@QAEPAUIOutArchive@@PAU1@@Z proc near
.text:0000A8E0                                         ; CODE XREF: CCodecs::CreateOutArchive(uint,CMyComPtr<IOutArchive> &)+74p
.text:0000A8E0
.text:0000A8E0 var_4           = dword ptr -4
.text:0000A8E0 arg_0           = dword ptr  8
.text:0000A8E0
.text:0000A8E0                 push    ebp
.text:0000A8E1                 mov     ebp, esp
.text:0000A8E3                 push    ecx
.text:0000A8E4                 push    esi
.text:0000A8E5                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A8EC                 mov     [ebp+var_4], ecx
.text:0000A8EF                 cmp     [ebp+arg_0], 0
.text:0000A8F3                 jz      short loc_A90C
.text:0000A8F5                 mov     eax, [ebp+arg_0]
.text:0000A8F8                 mov     ecx, [eax]
.text:0000A8FA                 mov     esi, esp
.text:0000A8FC                 mov     edx, [ebp+arg_0]
.text:0000A8FF                 push    edx
.text:0000A900                 mov     eax, [ecx+4]
.text:0000A903                 call    eax
.text:0000A905                 cmp     esi, esp
.text:0000A907                 call    __RTC_CheckEsp
.text:0000A90C
.text:0000A90C loc_A90C:                               ; CODE XREF: CMyComPtr<IOutArchive>::operator=(IOutArchive *)+13j
.text:0000A90C                 mov     ecx, [ebp+var_4]
.text:0000A90F                 cmp     dword ptr [ecx], 0
.text:0000A912                 jz      short loc_A92F
.text:0000A914                 mov     edx, [ebp+var_4]
.text:0000A917                 mov     eax, [edx]
.text:0000A919                 mov     ecx, [ebp+var_4]
.text:0000A91C                 mov     edx, [ecx]
.text:0000A91E                 mov     eax, [eax]
.text:0000A920                 mov     esi, esp
.text:0000A922                 push    edx
.text:0000A923                 mov     ecx, [eax+8]
.text:0000A926                 call    ecx
.text:0000A928                 cmp     esi, esp
.text:0000A92A                 call    __RTC_CheckEsp
.text:0000A92F
.text:0000A92F loc_A92F:                               ; CODE XREF: CMyComPtr<IOutArchive>::operator=(IOutArchive *)+32j
.text:0000A92F                 mov     edx, [ebp+var_4]
.text:0000A932                 mov     eax, [ebp+arg_0]
.text:0000A935                 mov     [edx], eax
.text:0000A937                 mov     eax, [ebp+arg_0]
.text:0000A93A                 pop     esi
.text:0000A93B                 add     esp, 4
.text:0000A93E                 cmp     ebp, esp
.text:0000A940                 call    __RTC_CheckEsp
.text:0000A945                 mov     esp, ebp
.text:0000A947                 pop     ebp
.text:0000A948                 retn    4
.text:0000A948 ??4?$CMyComPtr@UIOutArchive@@@@QAEPAUIOutArchive@@PAU1@@Z endp
.text:0000A948
.text:0000A948 ; ---------------------------------------------------------------------------
.text:0000A94B                 align 4
.text:0000A94B _text           ends
.text:0000A94B
.text:0000A94C ; ===========================================================================
.text:0000A94C
.text:0000A94C ; Segment type: Pure code
.text:0000A94C ; Segment permissions: Read/Execute
.text:0000A94C _text           segment para public 'CODE' use32
.text:0000A94C                 assume cs:_text
.text:0000A94C                 ;org 0A94Ch
.text:0000A94C ; COMDAT (pick any)
.text:0000A94C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A94C
.text:0000A94C ; =============== S U B R O U T I N E =======================================
.text:0000A94C
.text:0000A94C ; Attributes: bp-based frame
.text:0000A94C
.text:0000A94C ; public: __thiscall CMyComPtr<struct IInStream>::CMyComPtr<struct IInStream>(struct IInStream *)
.text:0000A94C                 public ??0?$CMyComPtr@UIInStream@@@@QAE@PAUIInStream@@@Z
.text:0000A94C ??0?$CMyComPtr@UIInStream@@@@QAE@PAUIInStream@@@Z proc near
.text:0000A94C                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+F4Dp
.text:0000A94C
.text:0000A94C var_4           = dword ptr -4
.text:0000A94C arg_0           = dword ptr  8
.text:0000A94C
.text:0000A94C                 push    ebp
.text:0000A94D                 mov     ebp, esp
.text:0000A94F                 push    ecx
.text:0000A950                 push    esi
.text:0000A951                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A958                 mov     [ebp+var_4], ecx
.text:0000A95B                 mov     eax, [ebp+var_4]
.text:0000A95E                 mov     ecx, [ebp+arg_0]
.text:0000A961                 mov     [eax], ecx
.text:0000A963                 cmp     [ebp+arg_0], 0
.text:0000A967                 jz      short loc_A980
.text:0000A969                 mov     edx, [ebp+arg_0]
.text:0000A96C                 mov     eax, [edx]
.text:0000A96E                 mov     esi, esp
.text:0000A970                 mov     ecx, [ebp+arg_0]
.text:0000A973                 push    ecx
.text:0000A974                 mov     edx, [eax+4]
.text:0000A977                 call    edx
.text:0000A979                 cmp     esi, esp
.text:0000A97B                 call    __RTC_CheckEsp
.text:0000A980
.text:0000A980 loc_A980:                               ; CODE XREF: CMyComPtr<IInStream>::CMyComPtr<IInStream>(IInStream *)+1Bj
.text:0000A980                 mov     eax, [ebp+var_4]
.text:0000A983                 pop     esi
.text:0000A984                 add     esp, 4
.text:0000A987                 cmp     ebp, esp
.text:0000A989                 call    __RTC_CheckEsp
.text:0000A98E                 mov     esp, ebp
.text:0000A990                 pop     ebp
.text:0000A991                 retn    4
.text:0000A991 ??0?$CMyComPtr@UIInStream@@@@QAE@PAUIInStream@@@Z endp
.text:0000A991
.text:0000A991 _text           ends
.text:0000A991
.text:0000A994 ; ===========================================================================
.text:0000A994
.text:0000A994 ; Segment type: Pure code
.text:0000A994 ; Segment permissions: Read/Execute
.text:0000A994 _text           segment para public 'CODE' use32
.text:0000A994                 assume cs:_text
.text:0000A994                 ;org 0A994h
.text:0000A994 ; COMDAT (pick any)
.text:0000A994                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A994
.text:0000A994 ; =============== S U B R O U T I N E =======================================
.text:0000A994
.text:0000A994 ; Attributes: bp-based frame
.text:0000A994
.text:0000A994 ; public: __thiscall CMyComPtr<struct IInStream>::~CMyComPtr<struct IInStream>(void)
.text:0000A994                 public ??1?$CMyComPtr@UIInStream@@@@QAE@XZ
.text:0000A994 ??1?$CMyComPtr@UIInStream@@@@QAE@XZ proc near
.text:0000A994                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+FA1p
.text:0000A994                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+1128p ...
.text:0000A994
.text:0000A994 var_4           = dword ptr -4
.text:0000A994
.text:0000A994                 push    ebp
.text:0000A995                 mov     ebp, esp
.text:0000A997                 push    ecx
.text:0000A998                 push    esi
.text:0000A999                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A9A0                 mov     [ebp+var_4], ecx
.text:0000A9A3                 mov     eax, [ebp+var_4]
.text:0000A9A6                 cmp     dword ptr [eax], 0
.text:0000A9A9                 jz      short loc_A9C6
.text:0000A9AB                 mov     ecx, [ebp+var_4]
.text:0000A9AE                 mov     edx, [ecx]
.text:0000A9B0                 mov     eax, [ebp+var_4]
.text:0000A9B3                 mov     ecx, [eax]
.text:0000A9B5                 mov     edx, [edx]
.text:0000A9B7                 mov     esi, esp
.text:0000A9B9                 push    ecx
.text:0000A9BA                 mov     eax, [edx+8]
.text:0000A9BD                 call    eax
.text:0000A9BF                 cmp     esi, esp
.text:0000A9C1                 call    __RTC_CheckEsp
.text:0000A9C6
.text:0000A9C6 loc_A9C6:                               ; CODE XREF: CMyComPtr<IInStream>::~CMyComPtr<IInStream>(void)+15j
.text:0000A9C6                 pop     esi
.text:0000A9C7                 add     esp, 4
.text:0000A9CA                 cmp     ebp, esp
.text:0000A9CC                 call    __RTC_CheckEsp
.text:0000A9D1                 mov     esp, ebp
.text:0000A9D3                 pop     ebp
.text:0000A9D4                 retn
.text:0000A9D4 ??1?$CMyComPtr@UIInStream@@@@QAE@XZ endp
.text:0000A9D4
.text:0000A9D4 ; ---------------------------------------------------------------------------
.text:0000A9D5                 align 4
.text:0000A9D5 _text           ends
.text:0000A9D5
.text:0000A9D8 ; ===========================================================================
.text:0000A9D8
.text:0000A9D8 ; Segment type: Pure code
.text:0000A9D8 ; Segment permissions: Read/Execute
.text:0000A9D8 _text           segment para public 'CODE' use32
.text:0000A9D8                 assume cs:_text
.text:0000A9D8                 ;org 0A9D8h
.text:0000A9D8 ; COMDAT (pick any)
.text:0000A9D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A9D8
.text:0000A9D8 ; =============== S U B R O U T I N E =======================================
.text:0000A9D8
.text:0000A9D8 ; Attributes: bp-based frame
.text:0000A9D8
.text:0000A9D8 ; public: __thiscall CMyComPtr<struct IInStream>::operator struct IInStream *(void)const
.text:0000A9D8                 public ??B?$CMyComPtr@UIInStream@@@@QBEPAUIInStream@@XZ
.text:0000A9D8 ??B?$CMyComPtr@UIInStream@@@@QBEPAUIInStream@@XZ proc near
.text:0000A9D8                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+1341p
.text:0000A9D8                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+15FBp
.text:0000A9D8
.text:0000A9D8 var_4           = dword ptr -4
.text:0000A9D8
.text:0000A9D8                 push    ebp
.text:0000A9D9                 mov     ebp, esp
.text:0000A9DB                 push    ecx
.text:0000A9DC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A9E3                 mov     [ebp+var_4], ecx
.text:0000A9E6                 mov     eax, [ebp+var_4]
.text:0000A9E9                 mov     eax, [eax]
.text:0000A9EB                 mov     esp, ebp
.text:0000A9ED                 pop     ebp
.text:0000A9EE                 retn
.text:0000A9EE ??B?$CMyComPtr@UIInStream@@@@QBEPAUIInStream@@XZ endp
.text:0000A9EE
.text:0000A9EE ; ---------------------------------------------------------------------------
.text:0000A9EF                 align 10h
.text:0000A9EF _text           ends
.text:0000A9EF
.text:0000A9F0 ; ===========================================================================
.text:0000A9F0
.text:0000A9F0 ; Segment type: Pure code
.text:0000A9F0 ; Segment permissions: Read/Execute
.text:0000A9F0 _text           segment para public 'CODE' use32
.text:0000A9F0                 assume cs:_text
.text:0000A9F0                 ;org 0A9F0h
.text:0000A9F0 ; COMDAT (pick any)
.text:0000A9F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000A9F0
.text:0000A9F0 ; =============== S U B R O U T I N E =======================================
.text:0000A9F0
.text:0000A9F0 ; Attributes: bp-based frame
.text:0000A9F0
.text:0000A9F0 ; public: struct IInStream * __thiscall CMyComPtr<struct IInStream>::operator->(void)const
.text:0000A9F0                 public ??C?$CMyComPtr@UIInStream@@@@QBEPAUIInStream@@XZ
.text:0000A9F0 ??C?$CMyComPtr@UIInStream@@@@QBEPAUIInStream@@XZ proc near
.text:0000A9F0                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+151Dp
.text:0000A9F0
.text:0000A9F0 var_4           = dword ptr -4
.text:0000A9F0
.text:0000A9F0                 push    ebp
.text:0000A9F1                 mov     ebp, esp
.text:0000A9F3                 push    ecx
.text:0000A9F4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000A9FB                 mov     [ebp+var_4], ecx
.text:0000A9FE                 mov     eax, [ebp+var_4]
.text:0000AA01                 mov     eax, [eax]
.text:0000AA03                 mov     esp, ebp
.text:0000AA05                 pop     ebp
.text:0000AA06                 retn
.text:0000AA06 ??C?$CMyComPtr@UIInStream@@@@QBEPAUIInStream@@XZ endp
.text:0000AA06
.text:0000AA06 ; ---------------------------------------------------------------------------
.text:0000AA07                 align 4
.text:0000AA07 _text           ends
.text:0000AA07
.text:0000AA08 ; ===========================================================================
.text:0000AA08
.text:0000AA08 ; Segment type: Pure code
.text:0000AA08 ; Segment permissions: Read/Execute
.text:0000AA08 _text           segment para public 'CODE' use32
.text:0000AA08                 assume cs:_text
.text:0000AA08                 ;org 0AA08h
.text:0000AA08 ; COMDAT (pick any)
.text:0000AA08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000AA08
.text:0000AA08 ; =============== S U B R O U T I N E =======================================
.text:0000AA08
.text:0000AA08 ; Attributes: bp-based frame
.text:0000AA08
.text:0000AA08 ; public: __thiscall CObjectVector<class CArc>::CObjectVector<class CArc>(void)
.text:0000AA08                 public ??0?$CObjectVector@VCArc@@@@QAE@XZ
.text:0000AA08 ??0?$CObjectVector@VCArc@@@@QAE@XZ proc near
.text:0000AA08                                         ; CODE XREF: CArchiveLink::CArchiveLink(void)+30p
.text:0000AA08
.text:0000AA08 var_4           = dword ptr -4
.text:0000AA08
.text:0000AA08                 push    ebp
.text:0000AA09                 mov     ebp, esp
.text:0000AA0B                 push    ecx
.text:0000AA0C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000AA13                 mov     [ebp+var_4], ecx
.text:0000AA16                 mov     ecx, [ebp+var_4]
.text:0000AA19                 call    ??0?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::CRecordVector<void *>(void)
.text:0000AA1E                 mov     eax, [ebp+var_4]
.text:0000AA21                 add     esp, 4
.text:0000AA24                 cmp     ebp, esp
.text:0000AA26                 call    __RTC_CheckEsp
.text:0000AA2B                 mov     esp, ebp
.text:0000AA2D                 pop     ebp
.text:0000AA2E                 retn
.text:0000AA2E ??0?$CObjectVector@VCArc@@@@QAE@XZ endp
.text:0000AA2E
.text:0000AA2E ; ---------------------------------------------------------------------------
.text:0000AA2F                 align 10h
.text:0000AA2F _text           ends
.text:0000AA2F
.text:0000AA30 ; ===========================================================================
.text:0000AA30
.text:0000AA30 ; Segment type: Pure code
.text:0000AA30 ; Segment permissions: Read/Execute
.text:0000AA30 _text           segment para public 'CODE' use32
.text:0000AA30                 assume cs:_text
.text:0000AA30                 ;org 0AA30h
.text:0000AA30 ; COMDAT (pick any)
.text:0000AA30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000AA30
.text:0000AA30 ; =============== S U B R O U T I N E =======================================
.text:0000AA30
.text:0000AA30 ; Attributes: bp-based frame
.text:0000AA30
.text:0000AA30 ; public: class CArc const & __thiscall CObjectVector<class CArc>::Back(void)const
.text:0000AA30                 public ?Back@?$CObjectVector@VCArc@@@@QBEABVCArc@@XZ
.text:0000AA30 ?Back@?$CObjectVector@VCArc@@@@QBEABVCArc@@XZ proc near
.text:0000AA30                                         ; CODE XREF: CArchiveLink::GetArc(void)+11p
.text:0000AA30
.text:0000AA30 var_4           = dword ptr -4
.text:0000AA30
.text:0000AA30                 push    ebp
.text:0000AA31                 mov     ebp, esp
.text:0000AA33                 push    ecx
.text:0000AA34                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000AA3B                 mov     [ebp+var_4], ecx
.text:0000AA3E                 mov     ecx, [ebp+var_4]
.text:0000AA41                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:0000AA46                 sub     eax, 1
.text:0000AA49                 push    eax
.text:0000AA4A                 mov     ecx, [ebp+var_4]
.text:0000AA4D                 call    ??A?$CObjectVector@VCArc@@@@QBEABVCArc@@I@Z ; CObjectVector<CArc>::operator[](uint)
.text:0000AA52                 add     esp, 4
.text:0000AA55                 cmp     ebp, esp
.text:0000AA57                 call    __RTC_CheckEsp
.text:0000AA5C                 mov     esp, ebp
.text:0000AA5E                 pop     ebp
.text:0000AA5F                 retn
.text:0000AA5F ?Back@?$CObjectVector@VCArc@@@@QBEABVCArc@@XZ endp
.text:0000AA5F
.text:0000AA5F _text           ends
.text:0000AA5F
.text:0000AA60 ; ===========================================================================
.text:0000AA60
.text:0000AA60 ; Segment type: Pure code
.text:0000AA60 ; Segment permissions: Read/Execute
.text:0000AA60 _text           segment para public 'CODE' use32
.text:0000AA60                 assume cs:_text
.text:0000AA60                 ;org 0AA60h
.text:0000AA60 ; COMDAT (pick any)
.text:0000AA60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000AA60
.text:0000AA60 ; =============== S U B R O U T I N E =======================================
.text:0000AA60
.text:0000AA60 ; Attributes: bp-based frame
.text:0000AA60
.text:0000AA60 ; public: class CArc & __thiscall CObjectVector<class CArc>::Back(void)
.text:0000AA60                 public ?Back@?$CObjectVector@VCArc@@@@QAEAAVCArc@@XZ
.text:0000AA60 ?Back@?$CObjectVector@VCArc@@@@QAEAAVCArc@@XZ proc near
.text:0000AA60                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+937p
.text:0000AA60                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+13CCp
.text:0000AA60
.text:0000AA60 var_4           = dword ptr -4
.text:0000AA60
.text:0000AA60                 push    ebp
.text:0000AA61                 mov     ebp, esp
.text:0000AA63                 push    ecx
.text:0000AA64                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000AA6B                 mov     [ebp+var_4], ecx
.text:0000AA6E                 mov     ecx, [ebp+var_4]
.text:0000AA71                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:0000AA76                 sub     eax, 1
.text:0000AA79                 push    eax
.text:0000AA7A                 mov     ecx, [ebp+var_4]
.text:0000AA7D                 call    ??A?$CObjectVector@VCArc@@@@QAEAAVCArc@@I@Z ; CObjectVector<CArc>::operator[](uint)
.text:0000AA82                 add     esp, 4
.text:0000AA85                 cmp     ebp, esp
.text:0000AA87                 call    __RTC_CheckEsp
.text:0000AA8C                 mov     esp, ebp
.text:0000AA8E                 pop     ebp
.text:0000AA8F                 retn
.text:0000AA8F ?Back@?$CObjectVector@VCArc@@@@QAEAAVCArc@@XZ endp
.text:0000AA8F
.text:0000AA8F _text           ends
.text:0000AA8F
.text:0000AA90 ; ===========================================================================
.text:0000AA90
.text:0000AA90 ; Segment type: Pure code
.text:0000AA90 ; Segment permissions: Read/Execute
.text:0000AA90 _text           segment para public 'CODE' use32
.text:0000AA90                 assume cs:_text
.text:0000AA90                 ;org 0AA90h
.text:0000AA90 ; COMDAT (pick any)
.text:0000AA90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000AA90
.text:0000AA90 ; =============== S U B R O U T I N E =======================================
.text:0000AA90
.text:0000AA90 ; Attributes: bp-based frame
.text:0000AA90
.text:0000AA90 ; public: __thiscall CObjectVector<class CArc>::~CObjectVector<class CArc>(void)
.text:0000AA90                 public ??1?$CObjectVector@VCArc@@@@QAE@XZ
.text:0000AA90 ??1?$CObjectVector@VCArc@@@@QAE@XZ proc near
.text:0000AA90                                         ; CODE XREF: __unwindfunclet$??0CArchiveLink@@QAE@XZ$0+3j
.text:0000AA90                                         ; CArchiveLink::~CArchiveLink(void)+73p ...
.text:0000AA90
.text:0000AA90 var_20          = dword ptr -20h
.text:0000AA90 var_1C          = dword ptr -1Ch
.text:0000AA90 var_18          = dword ptr -18h
.text:0000AA90 var_14          = dword ptr -14h
.text:0000AA90 var_10          = dword ptr -10h
.text:0000AA90 var_C           = dword ptr -0Ch
.text:0000AA90 var_4           = dword ptr -4
.text:0000AA90
.text:0000AA90                 push    ebp
.text:0000AA91                 mov     ebp, esp
.text:0000AA93                 push    0FFFFFFFFh
.text:0000AA95                 push    offset __ehhandler$??1?$CObjectVector@VCArc@@@@QAE@XZ
.text:0000AA9A                 mov     eax, large fs:0
.text:0000AAA0                 push    eax
.text:0000AAA1                 sub     esp, 14h
.text:0000AAA4                 mov     eax, 0CCCCCCCCh
.text:0000AAA9                 mov     [ebp+var_20], eax
.text:0000AAAC                 mov     [ebp+var_1C], eax
.text:0000AAAF                 mov     [ebp+var_18], eax
.text:0000AAB2                 mov     [ebp+var_14], eax
.text:0000AAB5                 mov     [ebp+var_10], eax
.text:0000AAB8                 mov     eax, dword ptr ds:___security_cookie
.text:0000AABD                 xor     eax, ebp
.text:0000AABF                 push    eax
.text:0000AAC0                 lea     eax, [ebp+var_C]
.text:0000AAC3                 mov     large fs:0, eax
.text:0000AAC9                 mov     [ebp+var_10], ecx
.text:0000AACC                 mov     [ebp+var_4], 0
.text:0000AAD3                 mov     ecx, [ebp+var_10]
.text:0000AAD6                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:0000AADB                 mov     [ebp+var_14], eax
.text:0000AADE
.text:0000AADE loc_AADE:                               ; CODE XREF: CObjectVector<CArc>::~CObjectVector<CArc>(void):loc_AB20j
.text:0000AADE                 cmp     [ebp+var_14], 0
.text:0000AAE2                 jz      short loc_AB22
.text:0000AAE4                 mov     eax, [ebp+var_14]
.text:0000AAE7                 sub     eax, 1
.text:0000AAEA                 mov     [ebp+var_14], eax
.text:0000AAED                 mov     ecx, [ebp+var_14]
.text:0000AAF0                 push    ecx
.text:0000AAF1                 mov     ecx, [ebp+var_10]
.text:0000AAF4                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:0000AAF9                 mov     edx, [eax]
.text:0000AAFB                 mov     [ebp+var_1C], edx
.text:0000AAFE                 mov     eax, [ebp+var_1C]
.text:0000AB01                 mov     [ebp+var_18], eax
.text:0000AB04                 cmp     [ebp+var_18], 0
.text:0000AB08                 jz      short loc_AB19
.text:0000AB0A                 push    1
.text:0000AB0C                 mov     ecx, [ebp+var_18]
.text:0000AB0F                 call    ??_GCArc@@QAEPAXI@Z ; CArc::`scalar deleting destructor'(uint)
.text:0000AB14                 mov     [ebp+var_20], eax
.text:0000AB17                 jmp     short loc_AB20
.text:0000AB19 ; ---------------------------------------------------------------------------
.text:0000AB19
.text:0000AB19 loc_AB19:                               ; CODE XREF: CObjectVector<CArc>::~CObjectVector<CArc>(void)+78j
.text:0000AB19                 mov     [ebp+var_20], 0
.text:0000AB20
.text:0000AB20 loc_AB20:                               ; CODE XREF: CObjectVector<CArc>::~CObjectVector<CArc>(void)+87j
.text:0000AB20                 jmp     short loc_AADE
.text:0000AB22 ; ---------------------------------------------------------------------------
.text:0000AB22
.text:0000AB22 loc_AB22:                               ; CODE XREF: CObjectVector<CArc>::~CObjectVector<CArc>(void)+52j
.text:0000AB22                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000AB29                 mov     ecx, [ebp+var_10]
.text:0000AB2C                 call    ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text:0000AB31                 mov     ecx, [ebp+var_C]
.text:0000AB34                 mov     large fs:0, ecx
.text:0000AB3B                 pop     ecx
.text:0000AB3C                 add     esp, 20h
.text:0000AB3F                 cmp     ebp, esp
.text:0000AB41                 call    __RTC_CheckEsp
.text:0000AB46                 mov     esp, ebp
.text:0000AB48                 pop     ebp
.text:0000AB49                 retn
.text:0000AB49 ??1?$CObjectVector@VCArc@@@@QAE@XZ endp
.text:0000AB49
.text:0000AB49 ; ---------------------------------------------------------------------------
.text:0000AB4A                 align 4
.text:0000AB4A _text           ends
.text:0000AB4A
.text$x:0000AB4C ; ===========================================================================
.text$x:0000AB4C
.text$x:0000AB4C ; Segment type: Pure code
.text$x:0000AB4C ; Segment permissions: Read/Execute
.text$x:0000AB4C _text$x         segment para public 'CODE' use32
.text$x:0000AB4C                 assume cs:_text$x
.text$x:0000AB4C                 ;org 0AB4Ch
.text$x:0000AB4C ; COMDAT (pick associative to section at AA90)
.text$x:0000AB4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000AB4C
.text$x:0000AB4C ; =============== S U B R O U T I N E =======================================
.text$x:0000AB4C
.text$x:0000AB4C
.text$x:0000AB4C __unwindfunclet$??1?$CObjectVector@VCArc@@@@QAE@XZ$0 proc near
.text$x:0000AB4C                                         ; DATA XREF: .xdata$x:0000AB74o
.text$x:0000AB4C                 mov     ecx, [ebp-10h]
.text$x:0000AB4F                 jmp     ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text$x:0000AB4F __unwindfunclet$??1?$CObjectVector@VCArc@@@@QAE@XZ$0 endp
.text$x:0000AB4F
.text$x:0000AB54
.text$x:0000AB54 ; =============== S U B R O U T I N E =======================================
.text$x:0000AB54
.text$x:0000AB54
.text$x:0000AB54 __ehhandler$??1?$CObjectVector@VCArc@@@@QAE@XZ proc near
.text$x:0000AB54                                         ; DATA XREF: CObjectVector<CArc>::~CObjectVector<CArc>(void)+5o
.text$x:0000AB54
.text$x:0000AB54 arg_4           = dword ptr  8
.text$x:0000AB54
.text$x:0000AB54                 mov     edx, [esp+arg_4]
.text$x:0000AB58                 lea     eax, [edx+0Ch]
.text$x:0000AB5B                 mov     ecx, [edx-18h]
.text$x:0000AB5E                 xor     ecx, eax
.text$x:0000AB60                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000AB65                 mov     eax, offset __ehfuncinfo$??1?$CObjectVector@VCArc@@@@QAE@XZ
.text$x:0000AB6A                 jmp     ___CxxFrameHandler3
.text$x:0000AB6A __ehhandler$??1?$CObjectVector@VCArc@@@@QAE@XZ endp
.text$x:0000AB6A
.text$x:0000AB6A ; ---------------------------------------------------------------------------
.text$x:0000AB6F                 align 10h
.text$x:0000AB6F _text$x         ends
.text$x:0000AB6F
.xdata$x:0000AB70 ; ===========================================================================
.xdata$x:0000AB70
.xdata$x:0000AB70 ; Segment type: Pure data
.xdata$x:0000AB70 ; Segment permissions: Read
.xdata$x:0000AB70 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000AB70                 assume cs:_xdata$x
.xdata$x:0000AB70                 ;org 0AB70h
.xdata$x:0000AB70 ; COMDAT (pick associative to section at AA90)
.xdata$x:0000AB70 __unwindtable$??1?$CObjectVector@VCArc@@@@QAE@XZ db 0FFh
.xdata$x:0000AB70                                         ; DATA XREF: .xdata$x:0000AB80o
.xdata$x:0000AB71                 db 0FFh
.xdata$x:0000AB72                 db 0FFh
.xdata$x:0000AB73                 db 0FFh
.xdata$x:0000AB74                 dd offset __unwindfunclet$??1?$CObjectVector@VCArc@@@@QAE@XZ$0
.xdata$x:0000AB78 __ehfuncinfo$??1?$CObjectVector@VCArc@@@@QAE@XZ db  22h ; "
.xdata$x:0000AB78                                         ; DATA XREF: __ehhandler$??1?$CObjectVector@VCArc@@@@QAE@XZ+11o
.xdata$x:0000AB79                 db    5
.xdata$x:0000AB7A                 db  93h ; 
.xdata$x:0000AB7B                 db  19h
.xdata$x:0000AB7C                 db    1
.xdata$x:0000AB7D                 db    0
.xdata$x:0000AB7E                 db    0
.xdata$x:0000AB7F                 db    0
.xdata$x:0000AB80                 dd offset __unwindtable$??1?$CObjectVector@VCArc@@@@QAE@XZ
.xdata$x:0000AB84                 db    0
.xdata$x:0000AB85                 db    0
.xdata$x:0000AB86                 db    0
.xdata$x:0000AB87                 db    0
.xdata$x:0000AB88                 db    0
.xdata$x:0000AB89                 db    0
.xdata$x:0000AB8A                 db    0
.xdata$x:0000AB8B                 db    0
.xdata$x:0000AB8C                 db    0
.xdata$x:0000AB8D                 db    0
.xdata$x:0000AB8E                 db    0
.xdata$x:0000AB8F                 db    0
.xdata$x:0000AB90                 db    0
.xdata$x:0000AB91                 db    0
.xdata$x:0000AB92                 db    0
.xdata$x:0000AB93                 db    0
.xdata$x:0000AB94                 db    0
.xdata$x:0000AB95                 db    0
.xdata$x:0000AB96                 db    0
.xdata$x:0000AB97                 db    0
.xdata$x:0000AB98                 db    1
.xdata$x:0000AB99                 db    0
.xdata$x:0000AB9A                 db    0
.xdata$x:0000AB9B                 db    0
.xdata$x:0000AB9B _xdata$x        ends
.xdata$x:0000AB9B
.text:0000AB9C ; ===========================================================================
.text:0000AB9C
.text:0000AB9C ; Segment type: Pure code
.text:0000AB9C ; Segment permissions: Read/Execute
.text:0000AB9C _text           segment para public 'CODE' use32
.text:0000AB9C                 assume cs:_text
.text:0000AB9C                 ;org 0AB9Ch
.text:0000AB9C ; COMDAT (pick any)
.text:0000AB9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000AB9C
.text:0000AB9C ; =============== S U B R O U T I N E =======================================
.text:0000AB9C
.text:0000AB9C ; Attributes: bp-based frame
.text:0000AB9C
.text:0000AB9C ; public: bool __thiscall CRecordVector<unsigned int>::IsEmpty(void)const
.text:0000AB9C                 public ?IsEmpty@?$CRecordVector@I@@QBE_NXZ
.text:0000AB9C ?IsEmpty@?$CRecordVector@I@@QBE_NXZ proc near
.text:0000AB9C                                         ; CODE XREF: CArchiveUpdateCallback::AreAllFilesClosed(void)+14p
.text:0000AB9C
.text:0000AB9C var_4           = dword ptr -4
.text:0000AB9C
.text:0000AB9C                 push    ebp
.text:0000AB9D                 mov     ebp, esp
.text:0000AB9F                 push    ecx
.text:0000ABA0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000ABA7                 mov     [ebp+var_4], ecx
.text:0000ABAA                 mov     eax, [ebp+var_4]
.text:0000ABAD                 xor     ecx, ecx
.text:0000ABAF                 cmp     dword ptr [eax+4], 0
.text:0000ABB3                 setz    cl
.text:0000ABB6                 mov     al, cl
.text:0000ABB8                 mov     esp, ebp
.text:0000ABBA                 pop     ebp
.text:0000ABBB                 retn
.text:0000ABBB ?IsEmpty@?$CRecordVector@I@@QBE_NXZ endp
.text:0000ABBB
.text:0000ABBB _text           ends
.text:0000ABBB
.text:0000ABBC ; ===========================================================================
.text:0000ABBC
.text:0000ABBC ; Segment type: Pure code
.text:0000ABBC ; Segment permissions: Read/Execute
.text:0000ABBC _text           segment para public 'CODE' use32
.text:0000ABBC                 assume cs:_text
.text:0000ABBC                 ;org 0ABBCh
.text:0000ABBC ; COMDAT (pick any)
.text:0000ABBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000ABBC
.text:0000ABBC ; =============== S U B R O U T I N E =======================================
.text:0000ABBC
.text:0000ABBC ; Attributes: bp-based frame
.text:0000ABBC
.text:0000ABBC ; public: __thiscall CRecordVector<unsigned int>::~CRecordVector<unsigned int>(void)
.text:0000ABBC                 public ??1?$CRecordVector@I@@QAE@XZ
.text:0000ABBC ??1?$CRecordVector@I@@QAE@XZ proc near  ; CODE XREF: CUniqBlocks::~CUniqBlocks(void)+3Ap
.text:0000ABBC                                         ; CUniqBlocks::~CUniqBlocks(void)+49p ...
.text:0000ABBC
.text:0000ABBC var_8           = dword ptr -8
.text:0000ABBC var_4           = dword ptr -4
.text:0000ABBC
.text:0000ABBC                 push    ebp
.text:0000ABBD                 mov     ebp, esp
.text:0000ABBF                 sub     esp, 8
.text:0000ABC2                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000ABC9                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000ABD0                 mov     [ebp+var_4], ecx
.text:0000ABD3                 mov     eax, [ebp+var_4]
.text:0000ABD6                 mov     ecx, [eax]
.text:0000ABD8                 mov     [ebp+var_8], ecx
.text:0000ABDB                 mov     edx, [ebp+var_8]
.text:0000ABDE                 push    edx             ; void *
.text:0000ABDF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000ABE4                 add     esp, 4
.text:0000ABE7                 add     esp, 8
.text:0000ABEA                 cmp     ebp, esp
.text:0000ABEC                 call    __RTC_CheckEsp
.text:0000ABF1                 mov     esp, ebp
.text:0000ABF3                 pop     ebp
.text:0000ABF4                 retn
.text:0000ABF4 ??1?$CRecordVector@I@@QAE@XZ endp
.text:0000ABF4
.text:0000ABF4 ; ---------------------------------------------------------------------------
.text:0000ABF5                 align 4
.text:0000ABF5 _text           ends
.text:0000ABF5
.text:0000ABF8 ; ===========================================================================
.text:0000ABF8
.text:0000ABF8 ; Segment type: Pure code
.text:0000ABF8 ; Segment permissions: Read/Execute
.text:0000ABF8 _text           segment para public 'CODE' use32
.text:0000ABF8                 assume cs:_text
.text:0000ABF8                 ;org 0ABF8h
.text:0000ABF8 ; COMDAT (pick any)
.text:0000ABF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000ABF8
.text:0000ABF8 ; =============== S U B R O U T I N E =======================================
.text:0000ABF8
.text:0000ABF8 ; Attributes: bp-based frame
.text:0000ABF8
.text:0000ABF8 ; public: __thiscall CBuffer<unsigned char>::CBuffer<unsigned char>(void)
.text:0000ABF8                 public ??0?$CBuffer@E@@QAE@XZ
.text:0000ABF8 ??0?$CBuffer@E@@QAE@XZ proc near        ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1486p
.text:0000ABF8                                         ; CDirItem::CDirItem(void)+45p ...
.text:0000ABF8
.text:0000ABF8 var_4           = dword ptr -4
.text:0000ABF8
.text:0000ABF8                 push    ebp
.text:0000ABF9                 mov     ebp, esp
.text:0000ABFB                 push    ecx
.text:0000ABFC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000AC03                 mov     [ebp+var_4], ecx
.text:0000AC06                 mov     eax, [ebp+var_4]
.text:0000AC09                 mov     dword ptr [eax], 0
.text:0000AC0F                 mov     ecx, [ebp+var_4]
.text:0000AC12                 mov     dword ptr [ecx+4], 0
.text:0000AC19                 mov     eax, [ebp+var_4]
.text:0000AC1C                 mov     esp, ebp
.text:0000AC1E                 pop     ebp
.text:0000AC1F                 retn
.text:0000AC1F ??0?$CBuffer@E@@QAE@XZ endp
.text:0000AC1F
.text:0000AC1F _text           ends
.text:0000AC1F
.text:0000AC20 ; ===========================================================================
.text:0000AC20
.text:0000AC20 ; Segment type: Pure code
.text:0000AC20 ; Segment permissions: Read/Execute
.text:0000AC20 _text           segment para public 'CODE' use32
.text:0000AC20                 assume cs:_text
.text:0000AC20                 ;org 0AC20h
.text:0000AC20 ; COMDAT (pick any)
.text:0000AC20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000AC20
.text:0000AC20 ; =============== S U B R O U T I N E =======================================
.text:0000AC20
.text:0000AC20 ; Attributes: bp-based frame
.text:0000AC20
.text:0000AC20 ; public: __thiscall CBuffer<unsigned char>::~CBuffer<unsigned char>(void)
.text:0000AC20                 public ??1?$CBuffer@E@@QAE@XZ
.text:0000AC20 ??1?$CBuffer@E@@QAE@XZ proc near        ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+16ABp
.text:0000AC20                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1806p ...
.text:0000AC20
.text:0000AC20 var_8           = dword ptr -8
.text:0000AC20 var_4           = dword ptr -4
.text:0000AC20
.text:0000AC20                 push    ebp
.text:0000AC21                 mov     ebp, esp
.text:0000AC23                 sub     esp, 8
.text:0000AC26                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000AC2D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000AC34                 mov     [ebp+var_4], ecx
.text:0000AC37                 mov     eax, [ebp+var_4]
.text:0000AC3A                 mov     ecx, [eax]
.text:0000AC3C                 mov     [ebp+var_8], ecx
.text:0000AC3F                 mov     edx, [ebp+var_8]
.text:0000AC42                 push    edx             ; void *
.text:0000AC43                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000AC48                 add     esp, 4
.text:0000AC4B                 add     esp, 8
.text:0000AC4E                 cmp     ebp, esp
.text:0000AC50                 call    __RTC_CheckEsp
.text:0000AC55                 mov     esp, ebp
.text:0000AC57                 pop     ebp
.text:0000AC58                 retn
.text:0000AC58 ??1?$CBuffer@E@@QAE@XZ endp
.text:0000AC58
.text:0000AC58 ; ---------------------------------------------------------------------------
.text:0000AC59                 align 4
.text:0000AC59 _text           ends
.text:0000AC59
.text:0000AC5C ; ===========================================================================
.text:0000AC5C
.text:0000AC5C ; Segment type: Pure code
.text:0000AC5C ; Segment permissions: Read/Execute
.text:0000AC5C _text           segment para public 'CODE' use32
.text:0000AC5C                 assume cs:_text
.text:0000AC5C                 ;org 0AC5Ch
.text:0000AC5C ; COMDAT (pick any)
.text:0000AC5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000AC5C
.text:0000AC5C ; =============== S U B R O U T I N E =======================================
.text:0000AC5C
.text:0000AC5C ; Attributes: bp-based frame
.text:0000AC5C
.text:0000AC5C ; public: __thiscall CBuffer<unsigned char>::operator unsigned char *(void)
.text:0000AC5C                 public ??B?$CBuffer@E@@QAEPAEXZ
.text:0000AC5C ??B?$CBuffer@E@@QAEPAEXZ proc near      ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+14EFp
.text:0000AC5C                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1755p ...
.text:0000AC5C
.text:0000AC5C var_4           = dword ptr -4
.text:0000AC5C
.text:0000AC5C                 push    ebp
.text:0000AC5D                 mov     ebp, esp
.text:0000AC5F                 push    ecx
.text:0000AC60                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000AC67                 mov     [ebp+var_4], ecx
.text:0000AC6A                 mov     eax, [ebp+var_4]
.text:0000AC6D                 mov     eax, [eax]
.text:0000AC6F                 mov     esp, ebp
.text:0000AC71                 pop     ebp
.text:0000AC72                 retn
.text:0000AC72 ??B?$CBuffer@E@@QAEPAEXZ endp
.text:0000AC72
.text:0000AC72 ; ---------------------------------------------------------------------------
.text:0000AC73                 align 4
.text:0000AC73 _text           ends
.text:0000AC73
.text:0000AC74 ; ===========================================================================
.text:0000AC74
.text:0000AC74 ; Segment type: Pure code
.text:0000AC74 ; Segment permissions: Read/Execute
.text:0000AC74 _text           segment para public 'CODE' use32
.text:0000AC74                 assume cs:_text
.text:0000AC74                 ;org 0AC74h
.text:0000AC74 ; COMDAT (pick any)
.text:0000AC74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000AC74
.text:0000AC74 ; =============== S U B R O U T I N E =======================================
.text:0000AC74
.text:0000AC74 ; Attributes: bp-based frame
.text:0000AC74
.text:0000AC74 ; public: void __thiscall CBuffer<unsigned char>::Alloc(unsigned int)
.text:0000AC74                 public ?Alloc@?$CBuffer@E@@QAEXI@Z
.text:0000AC74 ?Alloc@?$CBuffer@E@@QAEXI@Z proc near   ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+14BBp
.text:0000AC74
.text:0000AC74 var_8           = dword ptr -8
.text:0000AC74 var_4           = dword ptr -4
.text:0000AC74 arg_0           = dword ptr  8
.text:0000AC74
.text:0000AC74                 push    ebp
.text:0000AC75                 mov     ebp, esp
.text:0000AC77                 sub     esp, 8
.text:0000AC7A                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000AC81                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000AC88                 mov     [ebp+var_4], ecx
.text:0000AC8B                 mov     eax, [ebp+var_4]
.text:0000AC8E                 mov     ecx, [ebp+arg_0]
.text:0000AC91                 cmp     ecx, [eax+4]
.text:0000AC94                 jz      short loc_ACC4
.text:0000AC96                 mov     ecx, [ebp+var_4]
.text:0000AC99                 call    ?Free@?$CBuffer@E@@QAEXXZ ; CBuffer<uchar>::Free(void)
.text:0000AC9E                 cmp     [ebp+arg_0], 0
.text:0000ACA2                 jz      short loc_ACC4
.text:0000ACA4                 mov     edx, [ebp+arg_0]
.text:0000ACA7                 push    edx             ; unsigned int
.text:0000ACA8                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0000ACAD                 add     esp, 4
.text:0000ACB0                 mov     [ebp+var_8], eax
.text:0000ACB3                 mov     eax, [ebp+var_4]
.text:0000ACB6                 mov     ecx, [ebp+var_8]
.text:0000ACB9                 mov     [eax], ecx
.text:0000ACBB                 mov     edx, [ebp+var_4]
.text:0000ACBE                 mov     eax, [ebp+arg_0]
.text:0000ACC1                 mov     [edx+4], eax
.text:0000ACC4
.text:0000ACC4 loc_ACC4:                               ; CODE XREF: CBuffer<uchar>::Alloc(uint)+20j
.text:0000ACC4                                         ; CBuffer<uchar>::Alloc(uint)+2Ej
.text:0000ACC4                 add     esp, 8
.text:0000ACC7                 cmp     ebp, esp
.text:0000ACC9                 call    __RTC_CheckEsp
.text:0000ACCE                 mov     esp, ebp
.text:0000ACD0                 pop     ebp
.text:0000ACD1                 retn    4
.text:0000ACD1 ?Alloc@?$CBuffer@E@@QAEXI@Z endp
.text:0000ACD1
.text:0000ACD1 _text           ends
.text:0000ACD1
.text:0000ACD4 ; ===========================================================================
.text:0000ACD4
.text:0000ACD4 ; Segment type: Pure code
.text:0000ACD4 ; Segment permissions: Read/Execute
.text:0000ACD4 _text           segment para public 'CODE' use32
.text:0000ACD4                 assume cs:_text
.text:0000ACD4                 ;org 0ACD4h
.text:0000ACD4 ; COMDAT (pick any)
.text:0000ACD4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000ACD4
.text:0000ACD4 ; =============== S U B R O U T I N E =======================================
.text:0000ACD4
.text:0000ACD4 ; Attributes: bp-based frame
.text:0000ACD4
.text:0000ACD4 ; public: __thiscall CRecordVector<int>::CRecordVector<int>(void)
.text:0000ACD4                 public ??0?$CRecordVector@H@@QAE@XZ
.text:0000ACD4 ??0?$CRecordVector@H@@QAE@XZ proc near  ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+584p
.text:0000ACD4
.text:0000ACD4 var_4           = dword ptr -4
.text:0000ACD4
.text:0000ACD4                 push    ebp
.text:0000ACD5                 mov     ebp, esp
.text:0000ACD7                 push    ecx
.text:0000ACD8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000ACDF                 mov     [ebp+var_4], ecx
.text:0000ACE2                 mov     eax, [ebp+var_4]
.text:0000ACE5                 mov     dword ptr [eax], 0
.text:0000ACEB                 mov     ecx, [ebp+var_4]
.text:0000ACEE                 mov     dword ptr [ecx+4], 0
.text:0000ACF5                 mov     edx, [ebp+var_4]
.text:0000ACF8                 mov     dword ptr [edx+8], 0
.text:0000ACFF                 mov     eax, [ebp+var_4]
.text:0000AD02                 mov     esp, ebp
.text:0000AD04                 pop     ebp
.text:0000AD05                 retn
.text:0000AD05 ??0?$CRecordVector@H@@QAE@XZ endp
.text:0000AD05
.text:0000AD05 ; ---------------------------------------------------------------------------
.text:0000AD06                 align 4
.text:0000AD06 _text           ends
.text:0000AD06
.text:0000AD08 ; ===========================================================================
.text:0000AD08
.text:0000AD08 ; Segment type: Pure code
.text:0000AD08 ; Segment permissions: Read/Execute
.text:0000AD08 _text           segment para public 'CODE' use32
.text:0000AD08                 assume cs:_text
.text:0000AD08                 ;org 0AD08h
.text:0000AD08 ; COMDAT (pick any)
.text:0000AD08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000AD08
.text:0000AD08 ; =============== S U B R O U T I N E =======================================
.text:0000AD08
.text:0000AD08 ; Attributes: bp-based frame
.text:0000AD08
.text:0000AD08 ; public: __thiscall CRecordVector<int>::~CRecordVector<int>(void)
.text:0000AD08                 public ??1?$CRecordVector@H@@QAE@XZ
.text:0000AD08 ??1?$CRecordVector@H@@QAE@XZ proc near  ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+642p
.text:0000AD08                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+6DEp ...
.text:0000AD08
.text:0000AD08 var_8           = dword ptr -8
.text:0000AD08 var_4           = dword ptr -4
.text:0000AD08
.text:0000AD08                 push    ebp
.text:0000AD09                 mov     ebp, esp
.text:0000AD0B                 sub     esp, 8
.text:0000AD0E                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000AD15                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000AD1C                 mov     [ebp+var_4], ecx
.text:0000AD1F                 mov     eax, [ebp+var_4]
.text:0000AD22                 mov     ecx, [eax]
.text:0000AD24                 mov     [ebp+var_8], ecx
.text:0000AD27                 mov     edx, [ebp+var_8]
.text:0000AD2A                 push    edx             ; void *
.text:0000AD2B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000AD30                 add     esp, 4
.text:0000AD33                 add     esp, 8
.text:0000AD36                 cmp     ebp, esp
.text:0000AD38                 call    __RTC_CheckEsp
.text:0000AD3D                 mov     esp, ebp
.text:0000AD3F                 pop     ebp
.text:0000AD40                 retn
.text:0000AD40 ??1?$CRecordVector@H@@QAE@XZ endp
.text:0000AD40
.text:0000AD40 ; ---------------------------------------------------------------------------
.text:0000AD41                 align 4
.text:0000AD41 _text           ends
.text:0000AD41
.text:0000AD44 ; ===========================================================================
.text:0000AD44
.text:0000AD44 ; Segment type: Pure code
.text:0000AD44 ; Segment permissions: Read/Execute
.text:0000AD44 _text           segment para public 'CODE' use32
.text:0000AD44                 assume cs:_text
.text:0000AD44                 ;org 0AD44h
.text:0000AD44 ; COMDAT (pick any)
.text:0000AD44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000AD44
.text:0000AD44 ; =============== S U B R O U T I N E =======================================
.text:0000AD44
.text:0000AD44 ; Attributes: bp-based frame
.text:0000AD44
.text:0000AD44 ; public: unsigned int __thiscall CObjectVector<struct CDirItem>::Size(void)const
.text:0000AD44                 public ?Size@?$CObjectVector@UCDirItem@@@@QBEIXZ
.text:0000AD44 ?Size@?$CObjectVector@UCDirItem@@@@QBEIXZ proc near
.text:0000AD44                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+14A3p
.text:0000AD44                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+2339p
.text:0000AD44
.text:0000AD44 var_4           = dword ptr -4
.text:0000AD44
.text:0000AD44                 push    ebp
.text:0000AD45                 mov     ebp, esp
.text:0000AD47                 push    ecx
.text:0000AD48                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000AD4F                 mov     [ebp+var_4], ecx
.text:0000AD52                 mov     ecx, [ebp+var_4]
.text:0000AD55                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:0000AD5A                 add     esp, 4
.text:0000AD5D                 cmp     ebp, esp
.text:0000AD5F                 call    __RTC_CheckEsp
.text:0000AD64                 mov     esp, ebp
.text:0000AD66                 pop     ebp
.text:0000AD67                 retn
.text:0000AD67 ?Size@?$CObjectVector@UCDirItem@@@@QBEIXZ endp
.text:0000AD67
.text:0000AD67 _text           ends
.text:0000AD67
.text:0000AD68 ; ===========================================================================
.text:0000AD68
.text:0000AD68 ; Segment type: Pure code
.text:0000AD68 ; Segment permissions: Read/Execute
.text:0000AD68 _text           segment para public 'CODE' use32
.text:0000AD68                 assume cs:_text
.text:0000AD68                 ;org 0AD68h
.text:0000AD68 ; COMDAT (pick any)
.text:0000AD68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000AD68
.text:0000AD68 ; =============== S U B R O U T I N E =======================================
.text:0000AD68
.text:0000AD68 ; Attributes: bp-based frame
.text:0000AD68
.text:0000AD68 ; public: struct CDirItem const & __thiscall CObjectVector<struct CDirItem>::operator[](unsigned int)const
.text:0000AD68                 public ??A?$CObjectVector@UCDirItem@@@@QBEABUCDirItem@@I@Z
.text:0000AD68 ??A?$CObjectVector@UCDirItem@@@@QBEABUCDirItem@@I@Z proc near
.text:0000AD68                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+1989p
.text:0000AD68
.text:0000AD68 var_4           = dword ptr -4
.text:0000AD68 arg_0           = dword ptr  8
.text:0000AD68
.text:0000AD68                 push    ebp
.text:0000AD69                 mov     ebp, esp
.text:0000AD6B                 push    ecx
.text:0000AD6C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000AD73                 mov     [ebp+var_4], ecx
.text:0000AD76                 mov     eax, [ebp+arg_0]
.text:0000AD79                 push    eax
.text:0000AD7A                 mov     ecx, [ebp+var_4]
.text:0000AD7D                 call    ??A?$CRecordVector@PAX@@QBEABQAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:0000AD82                 mov     eax, [eax]
.text:0000AD84                 add     esp, 4
.text:0000AD87                 cmp     ebp, esp
.text:0000AD89                 call    __RTC_CheckEsp
.text:0000AD8E                 mov     esp, ebp
.text:0000AD90                 pop     ebp
.text:0000AD91                 retn    4
.text:0000AD91 ??A?$CObjectVector@UCDirItem@@@@QBEABUCDirItem@@I@Z endp
.text:0000AD91
.text:0000AD91 _text           ends
.text:0000AD91
.text:0000AD94 ; ===========================================================================
.text:0000AD94
.text:0000AD94 ; Segment type: Pure code
.text:0000AD94 ; Segment permissions: Read/Execute
.text:0000AD94 _text           segment para public 'CODE' use32
.text:0000AD94                 assume cs:_text
.text:0000AD94                 ;org 0AD94h
.text:0000AD94 ; COMDAT (pick any)
.text:0000AD94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000AD94
.text:0000AD94 ; =============== S U B R O U T I N E =======================================
.text:0000AD94
.text:0000AD94 ; Attributes: bp-based frame
.text:0000AD94
.text:0000AD94 ; public: struct CDirItem & __thiscall CObjectVector<struct CDirItem>::operator[](unsigned int)
.text:0000AD94                 public ??A?$CObjectVector@UCDirItem@@@@QAEAAUCDirItem@@I@Z
.text:0000AD94 ??A?$CObjectVector@UCDirItem@@@@QAEAAUCDirItem@@I@Z proc near
.text:0000AD94                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+2357p
.text:0000AD94
.text:0000AD94 var_4           = dword ptr -4
.text:0000AD94 arg_0           = dword ptr  8
.text:0000AD94
.text:0000AD94                 push    ebp
.text:0000AD95                 mov     ebp, esp
.text:0000AD97                 push    ecx
.text:0000AD98                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000AD9F                 mov     [ebp+var_4], ecx
.text:0000ADA2                 mov     eax, [ebp+arg_0]
.text:0000ADA5                 push    eax
.text:0000ADA6                 mov     ecx, [ebp+var_4]
.text:0000ADA9                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:0000ADAE                 mov     eax, [eax]
.text:0000ADB0                 add     esp, 4
.text:0000ADB3                 cmp     ebp, esp
.text:0000ADB5                 call    __RTC_CheckEsp
.text:0000ADBA                 mov     esp, ebp
.text:0000ADBC                 pop     ebp
.text:0000ADBD                 retn    4
.text:0000ADBD ??A?$CObjectVector@UCDirItem@@@@QAEAAUCDirItem@@I@Z endp
.text:0000ADBD
.text:0000ADBD _text           ends
.text:0000ADBD
.text:0000ADC0 ; ===========================================================================
.text:0000ADC0
.text:0000ADC0 ; Segment type: Pure code
.text:0000ADC0 ; Segment permissions: Read/Execute
.text:0000ADC0 _text           segment para public 'CODE' use32
.text:0000ADC0                 assume cs:_text
.text:0000ADC0                 ;org 0ADC0h
.text:0000ADC0 ; COMDAT (pick any)
.text:0000ADC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000ADC0
.text:0000ADC0 ; =============== S U B R O U T I N E =======================================
.text:0000ADC0
.text:0000ADC0 ; Attributes: bp-based frame
.text:0000ADC0
.text:0000ADC0 ; public: unsigned int __thiscall CObjectVector<struct CDirItem>::Add(struct CDirItem const &)
.text:0000ADC0                 public ?Add@?$CObjectVector@UCDirItem@@@@QAEIABUCDirItem@@@Z
.text:0000ADC0 ?Add@?$CObjectVector@UCDirItem@@@@QAEIABUCDirItem@@@Z proc near
.text:0000ADC0                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+CC6p
.text:0000ADC0
.text:0000ADC0 var_1C          = dword ptr -1Ch
.text:0000ADC0 var_18          = dword ptr -18h
.text:0000ADC0 var_14          = dword ptr -14h
.text:0000ADC0 var_10          = dword ptr -10h
.text:0000ADC0 var_C           = dword ptr -0Ch
.text:0000ADC0 var_4           = dword ptr -4
.text:0000ADC0 arg_0           = dword ptr  8
.text:0000ADC0
.text:0000ADC0                 push    ebp
.text:0000ADC1                 mov     ebp, esp
.text:0000ADC3                 push    0FFFFFFFFh
.text:0000ADC5                 push    offset __ehhandler$?Add@?$CObjectVector@UCDirItem@@@@QAEIABUCDirItem@@@Z
.text:0000ADCA                 mov     eax, large fs:0
.text:0000ADD0                 push    eax
.text:0000ADD1                 sub     esp, 10h
.text:0000ADD4                 mov     eax, 0CCCCCCCCh
.text:0000ADD9                 mov     [ebp+var_1C], eax
.text:0000ADDC                 mov     [ebp+var_18], eax
.text:0000ADDF                 mov     [ebp+var_14], eax
.text:0000ADE2                 mov     [ebp+var_10], eax
.text:0000ADE5                 mov     eax, dword ptr ds:___security_cookie
.text:0000ADEA                 xor     eax, ebp
.text:0000ADEC                 push    eax
.text:0000ADED                 lea     eax, [ebp+var_C]
.text:0000ADF0                 mov     large fs:0, eax
.text:0000ADF6                 mov     [ebp+var_10], ecx
.text:0000ADF9                 push    50h ; 'P'       ; unsigned int
.text:0000ADFB                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0000AE00                 add     esp, 4
.text:0000AE03                 mov     [ebp+var_18], eax
.text:0000AE06                 mov     [ebp+var_4], 0
.text:0000AE0D                 cmp     [ebp+var_18], 0
.text:0000AE11                 jz      short loc_AE24
.text:0000AE13                 mov     eax, [ebp+arg_0]
.text:0000AE16                 push    eax
.text:0000AE17                 mov     ecx, [ebp+var_18]
.text:0000AE1A                 call    ??0CDirItem@@QAE@ABU0@@Z ; CDirItem::CDirItem(CDirItem const &)
.text:0000AE1F                 mov     [ebp+var_1C], eax
.text:0000AE22                 jmp     short loc_AE2B
.text:0000AE24 ; ---------------------------------------------------------------------------
.text:0000AE24
.text:0000AE24 loc_AE24:                               ; CODE XREF: CObjectVector<CDirItem>::Add(CDirItem const &)+51j
.text:0000AE24                 mov     [ebp+var_1C], 0
.text:0000AE2B
.text:0000AE2B loc_AE2B:                               ; CODE XREF: CObjectVector<CDirItem>::Add(CDirItem const &)+62j
.text:0000AE2B                 mov     ecx, [ebp+var_1C]
.text:0000AE2E                 mov     [ebp+var_14], ecx
.text:0000AE31                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000AE38                 mov     edx, [ebp+var_14]
.text:0000AE3B                 push    edx
.text:0000AE3C                 mov     ecx, [ebp+var_10]
.text:0000AE3F                 call    ?Add@?$CRecordVector@PAX@@QAEIQAX@Z ; CRecordVector<void *>::Add(void * const)
.text:0000AE44                 mov     ecx, [ebp+var_C]
.text:0000AE47                 mov     large fs:0, ecx
.text:0000AE4E                 pop     ecx
.text:0000AE4F                 add     esp, 1Ch
.text:0000AE52                 cmp     ebp, esp
.text:0000AE54                 call    __RTC_CheckEsp
.text:0000AE59                 mov     esp, ebp
.text:0000AE5B                 pop     ebp
.text:0000AE5C                 retn    4
.text:0000AE5C ?Add@?$CObjectVector@UCDirItem@@@@QAEIABUCDirItem@@@Z endp
.text:0000AE5C
.text:0000AE5C ; ---------------------------------------------------------------------------
.text:0000AE5F                 align 10h
.text:0000AE5F _text           ends
.text:0000AE5F
.text$x:0000AE60 ; ===========================================================================
.text$x:0000AE60
.text$x:0000AE60 ; Segment type: Pure code
.text$x:0000AE60 ; Segment permissions: Read/Execute
.text$x:0000AE60 _text$x         segment para public 'CODE' use32
.text$x:0000AE60                 assume cs:_text$x
.text$x:0000AE60                 ;org 0AE60h
.text$x:0000AE60 ; COMDAT (pick associative to section at ADC0)
.text$x:0000AE60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000AE60
.text$x:0000AE60 ; =============== S U B R O U T I N E =======================================
.text$x:0000AE60
.text$x:0000AE60
.text$x:0000AE60 __unwindfunclet$?Add@?$CObjectVector@UCDirItem@@@@QAEIABUCDirItem@@@Z$0 proc near
.text$x:0000AE60                                         ; DATA XREF: .xdata$x:0000AE8Co
.text$x:0000AE60                 mov     eax, [ebp-18h]
.text$x:0000AE63                 push    eax             ; void *
.text$x:0000AE64                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:0000AE69                 pop     ecx
.text$x:0000AE6A                 retn
.text$x:0000AE6A __unwindfunclet$?Add@?$CObjectVector@UCDirItem@@@@QAEIABUCDirItem@@@Z$0 endp
.text$x:0000AE6A
.text$x:0000AE6B
.text$x:0000AE6B ; =============== S U B R O U T I N E =======================================
.text$x:0000AE6B
.text$x:0000AE6B
.text$x:0000AE6B __ehhandler$?Add@?$CObjectVector@UCDirItem@@@@QAEIABUCDirItem@@@Z proc near
.text$x:0000AE6B                                         ; DATA XREF: CObjectVector<CDirItem>::Add(CDirItem const &)+5o
.text$x:0000AE6B
.text$x:0000AE6B arg_4           = dword ptr  8
.text$x:0000AE6B
.text$x:0000AE6B                 mov     edx, [esp+arg_4]
.text$x:0000AE6F                 lea     eax, [edx+0Ch]
.text$x:0000AE72                 mov     ecx, [edx-14h]
.text$x:0000AE75                 xor     ecx, eax
.text$x:0000AE77                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000AE7C                 mov     eax, offset __ehfuncinfo$?Add@?$CObjectVector@UCDirItem@@@@QAEIABUCDirItem@@@Z
.text$x:0000AE81                 jmp     ___CxxFrameHandler3
.text$x:0000AE81 __ehhandler$?Add@?$CObjectVector@UCDirItem@@@@QAEIABUCDirItem@@@Z endp
.text$x:0000AE81
.text$x:0000AE81 ; ---------------------------------------------------------------------------
.text$x:0000AE86                 align 4
.text$x:0000AE86 _text$x         ends
.text$x:0000AE86
.xdata$x:0000AE88 ; ===========================================================================
.xdata$x:0000AE88
.xdata$x:0000AE88 ; Segment type: Pure data
.xdata$x:0000AE88 ; Segment permissions: Read
.xdata$x:0000AE88 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000AE88                 assume cs:_xdata$x
.xdata$x:0000AE88                 ;org 0AE88h
.xdata$x:0000AE88 ; COMDAT (pick associative to section at ADC0)
.xdata$x:0000AE88 __unwindtable$?Add@?$CObjectVector@UCDirItem@@@@QAEIABUCDirItem@@@Z db 0FFh
.xdata$x:0000AE88                                         ; DATA XREF: .xdata$x:0000AE98o
.xdata$x:0000AE89                 db 0FFh
.xdata$x:0000AE8A                 db 0FFh
.xdata$x:0000AE8B                 db 0FFh
.xdata$x:0000AE8C                 dd offset __unwindfunclet$?Add@?$CObjectVector@UCDirItem@@@@QAEIABUCDirItem@@@Z$0
.xdata$x:0000AE90 __ehfuncinfo$?Add@?$CObjectVector@UCDirItem@@@@QAEIABUCDirItem@@@Z db  22h ; "
.xdata$x:0000AE90                                         ; DATA XREF: __ehhandler$?Add@?$CObjectVector@UCDirItem@@@@QAEIABUCDirItem@@@Z+11o
.xdata$x:0000AE91                 db    5
.xdata$x:0000AE92                 db  93h ; 
.xdata$x:0000AE93                 db  19h
.xdata$x:0000AE94                 db    1
.xdata$x:0000AE95                 db    0
.xdata$x:0000AE96                 db    0
.xdata$x:0000AE97                 db    0
.xdata$x:0000AE98                 dd offset __unwindtable$?Add@?$CObjectVector@UCDirItem@@@@QAEIABUCDirItem@@@Z
.xdata$x:0000AE9C                 db    0
.xdata$x:0000AE9D                 db    0
.xdata$x:0000AE9E                 db    0
.xdata$x:0000AE9F                 db    0
.xdata$x:0000AEA0                 db    0
.xdata$x:0000AEA1                 db    0
.xdata$x:0000AEA2                 db    0
.xdata$x:0000AEA3                 db    0
.xdata$x:0000AEA4                 db    0
.xdata$x:0000AEA5                 db    0
.xdata$x:0000AEA6                 db    0
.xdata$x:0000AEA7                 db    0
.xdata$x:0000AEA8                 db    0
.xdata$x:0000AEA9                 db    0
.xdata$x:0000AEAA                 db    0
.xdata$x:0000AEAB                 db    0
.xdata$x:0000AEAC                 db    0
.xdata$x:0000AEAD                 db    0
.xdata$x:0000AEAE                 db    0
.xdata$x:0000AEAF                 db    0
.xdata$x:0000AEB0                 db    1
.xdata$x:0000AEB1                 db    0
.xdata$x:0000AEB2                 db    0
.xdata$x:0000AEB3                 db    0
.xdata$x:0000AEB3 _xdata$x        ends
.xdata$x:0000AEB3
.text:0000AEB4 ; ===========================================================================
.text:0000AEB4
.text:0000AEB4 ; Segment type: Pure code
.text:0000AEB4 ; Segment permissions: Read/Execute
.text:0000AEB4 _text           segment para public 'CODE' use32
.text:0000AEB4                 assume cs:_text
.text:0000AEB4                 ;org 0AEB4h
.text:0000AEB4 ; COMDAT (pick any)
.text:0000AEB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000AEB4
.text:0000AEB4 ; =============== S U B R O U T I N E =======================================
.text:0000AEB4
.text:0000AEB4 ; Attributes: bp-based frame
.text:0000AEB4
.text:0000AEB4 ; public: __thiscall CObjectVector<struct CDirItem>::~CObjectVector<struct CDirItem>(void)
.text:0000AEB4                 public ??1?$CObjectVector@UCDirItem@@@@QAE@XZ
.text:0000AEB4 ??1?$CObjectVector@UCDirItem@@@@QAE@XZ proc near
.text:0000AEB4                                         ; CODE XREF: CDirItems::~CDirItems(void)+5Bp
.text:0000AEB4                                         ; __unwindfunclet$??1CDirItems@@QAE@XZ$3+6j
.text:0000AEB4
.text:0000AEB4 var_20          = dword ptr -20h
.text:0000AEB4 var_1C          = dword ptr -1Ch
.text:0000AEB4 var_18          = dword ptr -18h
.text:0000AEB4 var_14          = dword ptr -14h
.text:0000AEB4 var_10          = dword ptr -10h
.text:0000AEB4 var_C           = dword ptr -0Ch
.text:0000AEB4 var_4           = dword ptr -4
.text:0000AEB4
.text:0000AEB4                 push    ebp
.text:0000AEB5                 mov     ebp, esp
.text:0000AEB7                 push    0FFFFFFFFh
.text:0000AEB9                 push    offset __ehhandler$??1?$CObjectVector@UCDirItem@@@@QAE@XZ
.text:0000AEBE                 mov     eax, large fs:0
.text:0000AEC4                 push    eax
.text:0000AEC5                 sub     esp, 14h
.text:0000AEC8                 mov     eax, 0CCCCCCCCh
.text:0000AECD                 mov     [ebp+var_20], eax
.text:0000AED0                 mov     [ebp+var_1C], eax
.text:0000AED3                 mov     [ebp+var_18], eax
.text:0000AED6                 mov     [ebp+var_14], eax
.text:0000AED9                 mov     [ebp+var_10], eax
.text:0000AEDC                 mov     eax, dword ptr ds:___security_cookie
.text:0000AEE1                 xor     eax, ebp
.text:0000AEE3                 push    eax
.text:0000AEE4                 lea     eax, [ebp+var_C]
.text:0000AEE7                 mov     large fs:0, eax
.text:0000AEED                 mov     [ebp+var_10], ecx
.text:0000AEF0                 mov     [ebp+var_4], 0
.text:0000AEF7                 mov     ecx, [ebp+var_10]
.text:0000AEFA                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:0000AEFF                 mov     [ebp+var_14], eax
.text:0000AF02
.text:0000AF02 loc_AF02:                               ; CODE XREF: CObjectVector<CDirItem>::~CObjectVector<CDirItem>(void):loc_AF44j
.text:0000AF02                 cmp     [ebp+var_14], 0
.text:0000AF06                 jz      short loc_AF46
.text:0000AF08                 mov     eax, [ebp+var_14]
.text:0000AF0B                 sub     eax, 1
.text:0000AF0E                 mov     [ebp+var_14], eax
.text:0000AF11                 mov     ecx, [ebp+var_14]
.text:0000AF14                 push    ecx
.text:0000AF15                 mov     ecx, [ebp+var_10]
.text:0000AF18                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:0000AF1D                 mov     edx, [eax]
.text:0000AF1F                 mov     [ebp+var_1C], edx
.text:0000AF22                 mov     eax, [ebp+var_1C]
.text:0000AF25                 mov     [ebp+var_18], eax
.text:0000AF28                 cmp     [ebp+var_18], 0
.text:0000AF2C                 jz      short loc_AF3D
.text:0000AF2E                 push    1
.text:0000AF30                 mov     ecx, [ebp+var_18]
.text:0000AF33                 call    ??_GCDirItem@@QAEPAXI@Z ; CDirItem::`scalar deleting destructor'(uint)
.text:0000AF38                 mov     [ebp+var_20], eax
.text:0000AF3B                 jmp     short loc_AF44
.text:0000AF3D ; ---------------------------------------------------------------------------
.text:0000AF3D
.text:0000AF3D loc_AF3D:                               ; CODE XREF: CObjectVector<CDirItem>::~CObjectVector<CDirItem>(void)+78j
.text:0000AF3D                 mov     [ebp+var_20], 0
.text:0000AF44
.text:0000AF44 loc_AF44:                               ; CODE XREF: CObjectVector<CDirItem>::~CObjectVector<CDirItem>(void)+87j
.text:0000AF44                 jmp     short loc_AF02
.text:0000AF46 ; ---------------------------------------------------------------------------
.text:0000AF46
.text:0000AF46 loc_AF46:                               ; CODE XREF: CObjectVector<CDirItem>::~CObjectVector<CDirItem>(void)+52j
.text:0000AF46                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000AF4D                 mov     ecx, [ebp+var_10]
.text:0000AF50                 call    ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text:0000AF55                 mov     ecx, [ebp+var_C]
.text:0000AF58                 mov     large fs:0, ecx
.text:0000AF5F                 pop     ecx
.text:0000AF60                 add     esp, 20h
.text:0000AF63                 cmp     ebp, esp
.text:0000AF65                 call    __RTC_CheckEsp
.text:0000AF6A                 mov     esp, ebp
.text:0000AF6C                 pop     ebp
.text:0000AF6D                 retn
.text:0000AF6D ??1?$CObjectVector@UCDirItem@@@@QAE@XZ endp
.text:0000AF6D
.text:0000AF6D ; ---------------------------------------------------------------------------
.text:0000AF6E                 align 10h
.text:0000AF6E _text           ends
.text:0000AF6E
.text$x:0000AF70 ; ===========================================================================
.text$x:0000AF70
.text$x:0000AF70 ; Segment type: Pure code
.text$x:0000AF70 ; Segment permissions: Read/Execute
.text$x:0000AF70 _text$x         segment para public 'CODE' use32
.text$x:0000AF70                 assume cs:_text$x
.text$x:0000AF70                 ;org 0AF70h
.text$x:0000AF70 ; COMDAT (pick associative to section at AEB4)
.text$x:0000AF70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000AF70
.text$x:0000AF70 ; =============== S U B R O U T I N E =======================================
.text$x:0000AF70
.text$x:0000AF70
.text$x:0000AF70 __unwindfunclet$??1?$CObjectVector@UCDirItem@@@@QAE@XZ$0 proc near
.text$x:0000AF70                                         ; DATA XREF: .xdata$x:0000AF98o
.text$x:0000AF70                 mov     ecx, [ebp-10h]
.text$x:0000AF73                 jmp     ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text$x:0000AF73 __unwindfunclet$??1?$CObjectVector@UCDirItem@@@@QAE@XZ$0 endp
.text$x:0000AF73
.text$x:0000AF78
.text$x:0000AF78 ; =============== S U B R O U T I N E =======================================
.text$x:0000AF78
.text$x:0000AF78
.text$x:0000AF78 __ehhandler$??1?$CObjectVector@UCDirItem@@@@QAE@XZ proc near
.text$x:0000AF78                                         ; DATA XREF: CObjectVector<CDirItem>::~CObjectVector<CDirItem>(void)+5o
.text$x:0000AF78
.text$x:0000AF78 arg_4           = dword ptr  8
.text$x:0000AF78
.text$x:0000AF78                 mov     edx, [esp+arg_4]
.text$x:0000AF7C                 lea     eax, [edx+0Ch]
.text$x:0000AF7F                 mov     ecx, [edx-18h]
.text$x:0000AF82                 xor     ecx, eax
.text$x:0000AF84                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000AF89                 mov     eax, offset __ehfuncinfo$??1?$CObjectVector@UCDirItem@@@@QAE@XZ
.text$x:0000AF8E                 jmp     ___CxxFrameHandler3
.text$x:0000AF8E __ehhandler$??1?$CObjectVector@UCDirItem@@@@QAE@XZ endp
.text$x:0000AF8E
.text$x:0000AF8E ; ---------------------------------------------------------------------------
.text$x:0000AF93                 align 4
.text$x:0000AF93 _text$x         ends
.text$x:0000AF93
.xdata$x:0000AF94 ; ===========================================================================
.xdata$x:0000AF94
.xdata$x:0000AF94 ; Segment type: Pure data
.xdata$x:0000AF94 ; Segment permissions: Read
.xdata$x:0000AF94 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000AF94                 assume cs:_xdata$x
.xdata$x:0000AF94                 ;org 0AF94h
.xdata$x:0000AF94 ; COMDAT (pick associative to section at AEB4)
.xdata$x:0000AF94 __unwindtable$??1?$CObjectVector@UCDirItem@@@@QAE@XZ db 0FFh
.xdata$x:0000AF94                                         ; DATA XREF: .xdata$x:0000AFA4o
.xdata$x:0000AF95                 db 0FFh
.xdata$x:0000AF96                 db 0FFh
.xdata$x:0000AF97                 db 0FFh
.xdata$x:0000AF98                 dd offset __unwindfunclet$??1?$CObjectVector@UCDirItem@@@@QAE@XZ$0
.xdata$x:0000AF9C __ehfuncinfo$??1?$CObjectVector@UCDirItem@@@@QAE@XZ db  22h ; "
.xdata$x:0000AF9C                                         ; DATA XREF: __ehhandler$??1?$CObjectVector@UCDirItem@@@@QAE@XZ+11o
.xdata$x:0000AF9D                 db    5
.xdata$x:0000AF9E                 db  93h ; 
.xdata$x:0000AF9F                 db  19h
.xdata$x:0000AFA0                 db    1
.xdata$x:0000AFA1                 db    0
.xdata$x:0000AFA2                 db    0
.xdata$x:0000AFA3                 db    0
.xdata$x:0000AFA4                 dd offset __unwindtable$??1?$CObjectVector@UCDirItem@@@@QAE@XZ
.xdata$x:0000AFA8                 db    0
.xdata$x:0000AFA9                 db    0
.xdata$x:0000AFAA                 db    0
.xdata$x:0000AFAB                 db    0
.xdata$x:0000AFAC                 db    0
.xdata$x:0000AFAD                 db    0
.xdata$x:0000AFAE                 db    0
.xdata$x:0000AFAF                 db    0
.xdata$x:0000AFB0                 db    0
.xdata$x:0000AFB1                 db    0
.xdata$x:0000AFB2                 db    0
.xdata$x:0000AFB3                 db    0
.xdata$x:0000AFB4                 db    0
.xdata$x:0000AFB5                 db    0
.xdata$x:0000AFB6                 db    0
.xdata$x:0000AFB7                 db    0
.xdata$x:0000AFB8                 db    0
.xdata$x:0000AFB9                 db    0
.xdata$x:0000AFBA                 db    0
.xdata$x:0000AFBB                 db    0
.xdata$x:0000AFBC                 db    1
.xdata$x:0000AFBD                 db    0
.xdata$x:0000AFBE                 db    0
.xdata$x:0000AFBF                 db    0
.xdata$x:0000AFBF _xdata$x        ends
.xdata$x:0000AFBF
.text:0000AFC0 ; ===========================================================================
.text:0000AFC0
.text:0000AFC0 ; Segment type: Pure code
.text:0000AFC0 ; Segment permissions: Read/Execute
.text:0000AFC0 _text           segment para public 'CODE' use32
.text:0000AFC0                 assume cs:_text
.text:0000AFC0                 ;org 0AFC0h
.text:0000AFC0 ; COMDAT (pick any)
.text:0000AFC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000AFC0
.text:0000AFC0 ; =============== S U B R O U T I N E =======================================
.text:0000AFC0
.text:0000AFC0 ; Attributes: bp-based frame
.text:0000AFC0
.text:0000AFC0 ; public: unsigned int __thiscall CObjectVector<struct CArcItem>::Size(void)const
.text:0000AFC0                 public ?Size@?$CObjectVector@UCArcItem@@@@QBEIXZ
.text:0000AFC0 ?Size@?$CObjectVector@UCArcItem@@@@QBEIXZ proc near
.text:0000AFC0                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+2D1p
.text:0000AFC0
.text:0000AFC0 var_4           = dword ptr -4
.text:0000AFC0
.text:0000AFC0                 push    ebp
.text:0000AFC1                 mov     ebp, esp
.text:0000AFC3                 push    ecx
.text:0000AFC4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000AFCB                 mov     [ebp+var_4], ecx
.text:0000AFCE                 mov     ecx, [ebp+var_4]
.text:0000AFD1                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:0000AFD6                 add     esp, 4
.text:0000AFD9                 cmp     ebp, esp
.text:0000AFDB                 call    __RTC_CheckEsp
.text:0000AFE0                 mov     esp, ebp
.text:0000AFE2                 pop     ebp
.text:0000AFE3                 retn
.text:0000AFE3 ?Size@?$CObjectVector@UCArcItem@@@@QBEIXZ endp
.text:0000AFE3
.text:0000AFE3 _text           ends
.text:0000AFE3
.text:0000AFE4 ; ===========================================================================
.text:0000AFE4
.text:0000AFE4 ; Segment type: Pure code
.text:0000AFE4 ; Segment permissions: Read/Execute
.text:0000AFE4 _text           segment para public 'CODE' use32
.text:0000AFE4                 assume cs:_text
.text:0000AFE4                 ;org 0AFE4h
.text:0000AFE4 ; COMDAT (pick any)
.text:0000AFE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000AFE4
.text:0000AFE4 ; =============== S U B R O U T I N E =======================================
.text:0000AFE4
.text:0000AFE4 ; Attributes: bp-based frame
.text:0000AFE4
.text:0000AFE4 ; public: void __thiscall CObjectVector<struct CArcItem>::ClearAndReserve(unsigned int)
.text:0000AFE4                 public ?ClearAndReserve@?$CObjectVector@UCArcItem@@@@QAEXI@Z
.text:0000AFE4 ?ClearAndReserve@?$CObjectVector@UCArcItem@@@@QAEXI@Z proc near
.text:0000AFE4                                         ; CODE XREF: EnumerateInArchiveItems(NWildcard::CCensor const &,CArc const &,CObjectVector<CArcItem> &)+82p
.text:0000AFE4
.text:0000AFE4 var_4           = dword ptr -4
.text:0000AFE4 arg_0           = dword ptr  8
.text:0000AFE4
.text:0000AFE4                 push    ebp
.text:0000AFE5                 mov     ebp, esp
.text:0000AFE7                 push    ecx
.text:0000AFE8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000AFEF                 mov     [ebp+var_4], ecx
.text:0000AFF2                 mov     ecx, [ebp+var_4]
.text:0000AFF5                 call    ?Clear@?$CObjectVector@UCArcItem@@@@QAEXXZ ; CObjectVector<CArcItem>::Clear(void)
.text:0000AFFA                 mov     eax, [ebp+arg_0]
.text:0000AFFD                 push    eax
.text:0000AFFE                 mov     ecx, [ebp+var_4]
.text:0000B001                 call    ?ClearAndReserve@?$CRecordVector@PAX@@QAEXI@Z ; CRecordVector<void *>::ClearAndReserve(uint)
.text:0000B006                 add     esp, 4
.text:0000B009                 cmp     ebp, esp
.text:0000B00B                 call    __RTC_CheckEsp
.text:0000B010                 mov     esp, ebp
.text:0000B012                 pop     ebp
.text:0000B013                 retn    4
.text:0000B013 ?ClearAndReserve@?$CObjectVector@UCArcItem@@@@QAEXI@Z endp
.text:0000B013
.text:0000B013 ; ---------------------------------------------------------------------------
.text:0000B016                 align 4
.text:0000B016 _text           ends
.text:0000B016
.text:0000B018 ; ===========================================================================
.text:0000B018
.text:0000B018 ; Segment type: Pure code
.text:0000B018 ; Segment permissions: Read/Execute
.text:0000B018 _text           segment para public 'CODE' use32
.text:0000B018                 assume cs:_text
.text:0000B018                 ;org 0B018h
.text:0000B018 ; COMDAT (pick any)
.text:0000B018                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B018
.text:0000B018 ; =============== S U B R O U T I N E =======================================
.text:0000B018
.text:0000B018 ; Attributes: bp-based frame
.text:0000B018
.text:0000B018 ; public: __thiscall CObjectVector<struct CArcItem>::CObjectVector<struct CArcItem>(void)
.text:0000B018                 public ??0?$CObjectVector@UCArcItem@@@@QAE@XZ
.text:0000B018 ??0?$CObjectVector@UCArcItem@@@@QAE@XZ proc near
.text:0000B018                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+13A7p
.text:0000B018
.text:0000B018 var_4           = dword ptr -4
.text:0000B018
.text:0000B018                 push    ebp
.text:0000B019                 mov     ebp, esp
.text:0000B01B                 push    ecx
.text:0000B01C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B023                 mov     [ebp+var_4], ecx
.text:0000B026                 mov     ecx, [ebp+var_4]
.text:0000B029                 call    ??0?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::CRecordVector<void *>(void)
.text:0000B02E                 mov     eax, [ebp+var_4]
.text:0000B031                 add     esp, 4
.text:0000B034                 cmp     ebp, esp
.text:0000B036                 call    __RTC_CheckEsp
.text:0000B03B                 mov     esp, ebp
.text:0000B03D                 pop     ebp
.text:0000B03E                 retn
.text:0000B03E ??0?$CObjectVector@UCArcItem@@@@QAE@XZ endp
.text:0000B03E
.text:0000B03E ; ---------------------------------------------------------------------------
.text:0000B03F                 align 10h
.text:0000B03F _text           ends
.text:0000B03F
.text:0000B040 ; ===========================================================================
.text:0000B040
.text:0000B040 ; Segment type: Pure code
.text:0000B040 ; Segment permissions: Read/Execute
.text:0000B040 _text           segment para public 'CODE' use32
.text:0000B040                 assume cs:_text
.text:0000B040                 ;org 0B040h
.text:0000B040 ; COMDAT (pick any)
.text:0000B040                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B040
.text:0000B040 ; =============== S U B R O U T I N E =======================================
.text:0000B040
.text:0000B040 ; Attributes: bp-based frame
.text:0000B040
.text:0000B040 ; public: struct CArcItem const & __thiscall CObjectVector<struct CArcItem>::operator[](unsigned int)const
.text:0000B040                 public ??A?$CObjectVector@UCArcItem@@@@QBEABUCArcItem@@I@Z
.text:0000B040 ??A?$CObjectVector@UCArcItem@@@@QBEABUCArcItem@@I@Z proc near
.text:0000B040                                         ; CODE XREF: CUpdateProduceCallbackImp::ShowDeleteFile(uint)+22p
.text:0000B040                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+2E6p ...
.text:0000B040
.text:0000B040 var_4           = dword ptr -4
.text:0000B040 arg_0           = dword ptr  8
.text:0000B040
.text:0000B040                 push    ebp
.text:0000B041                 mov     ebp, esp
.text:0000B043                 push    ecx
.text:0000B044                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B04B                 mov     [ebp+var_4], ecx
.text:0000B04E                 mov     eax, [ebp+arg_0]
.text:0000B051                 push    eax
.text:0000B052                 mov     ecx, [ebp+var_4]
.text:0000B055                 call    ??A?$CRecordVector@PAX@@QBEABQAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:0000B05A                 mov     eax, [eax]
.text:0000B05C                 add     esp, 4
.text:0000B05F                 cmp     ebp, esp
.text:0000B061                 call    __RTC_CheckEsp
.text:0000B066                 mov     esp, ebp
.text:0000B068                 pop     ebp
.text:0000B069                 retn    4
.text:0000B069 ??A?$CObjectVector@UCArcItem@@@@QBEABUCArcItem@@I@Z endp
.text:0000B069
.text:0000B069 _text           ends
.text:0000B069
.text:0000B06C ; ===========================================================================
.text:0000B06C
.text:0000B06C ; Segment type: Pure code
.text:0000B06C ; Segment permissions: Read/Execute
.text:0000B06C _text           segment para public 'CODE' use32
.text:0000B06C                 assume cs:_text
.text:0000B06C                 ;org 0B06Ch
.text:0000B06C ; COMDAT (pick any)
.text:0000B06C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B06C
.text:0000B06C ; =============== S U B R O U T I N E =======================================
.text:0000B06C
.text:0000B06C ; Attributes: bp-based frame
.text:0000B06C
.text:0000B06C ; public: void __thiscall CObjectVector<struct CArcItem>::AddInReserved(struct CArcItem const &)
.text:0000B06C                 public ?AddInReserved@?$CObjectVector@UCArcItem@@@@QAEXABUCArcItem@@@Z
.text:0000B06C ?AddInReserved@?$CObjectVector@UCArcItem@@@@QAEXABUCArcItem@@@Z proc near
.text:0000B06C                                         ; CODE XREF: EnumerateInArchiveItems(NWildcard::CCensor const &,CArc const &,CObjectVector<CArcItem> &)+31Cp
.text:0000B06C
.text:0000B06C var_1C          = dword ptr -1Ch
.text:0000B06C var_18          = dword ptr -18h
.text:0000B06C var_14          = dword ptr -14h
.text:0000B06C var_10          = dword ptr -10h
.text:0000B06C var_C           = dword ptr -0Ch
.text:0000B06C var_4           = dword ptr -4
.text:0000B06C arg_0           = dword ptr  8
.text:0000B06C
.text:0000B06C                 push    ebp
.text:0000B06D                 mov     ebp, esp
.text:0000B06F                 push    0FFFFFFFFh
.text:0000B071                 push    offset __ehhandler$?AddInReserved@?$CObjectVector@UCArcItem@@@@QAEXABUCArcItem@@@Z
.text:0000B076                 mov     eax, large fs:0
.text:0000B07C                 push    eax
.text:0000B07D                 sub     esp, 10h
.text:0000B080                 mov     eax, 0CCCCCCCCh
.text:0000B085                 mov     [ebp+var_1C], eax
.text:0000B088                 mov     [ebp+var_18], eax
.text:0000B08B                 mov     [ebp+var_14], eax
.text:0000B08E                 mov     [ebp+var_10], eax
.text:0000B091                 mov     eax, dword ptr ds:___security_cookie
.text:0000B096                 xor     eax, ebp
.text:0000B098                 push    eax
.text:0000B099                 lea     eax, [ebp+var_C]
.text:0000B09C                 mov     large fs:0, eax
.text:0000B0A2                 mov     [ebp+var_10], ecx
.text:0000B0A5                 push    30h ; '0'       ; unsigned int
.text:0000B0A7                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0000B0AC                 add     esp, 4
.text:0000B0AF                 mov     [ebp+var_18], eax
.text:0000B0B2                 mov     [ebp+var_4], 0
.text:0000B0B9                 cmp     [ebp+var_18], 0
.text:0000B0BD                 jz      short loc_B0D0
.text:0000B0BF                 mov     eax, [ebp+arg_0]
.text:0000B0C2                 push    eax
.text:0000B0C3                 mov     ecx, [ebp+var_18]
.text:0000B0C6                 call    ??0CArcItem@@QAE@ABU0@@Z ; CArcItem::CArcItem(CArcItem const &)
.text:0000B0CB                 mov     [ebp+var_1C], eax
.text:0000B0CE                 jmp     short loc_B0D7
.text:0000B0D0 ; ---------------------------------------------------------------------------
.text:0000B0D0
.text:0000B0D0 loc_B0D0:                               ; CODE XREF: CObjectVector<CArcItem>::AddInReserved(CArcItem const &)+51j
.text:0000B0D0                 mov     [ebp+var_1C], 0
.text:0000B0D7
.text:0000B0D7 loc_B0D7:                               ; CODE XREF: CObjectVector<CArcItem>::AddInReserved(CArcItem const &)+62j
.text:0000B0D7                 mov     ecx, [ebp+var_1C]
.text:0000B0DA                 mov     [ebp+var_14], ecx
.text:0000B0DD                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000B0E4                 mov     edx, [ebp+var_14]
.text:0000B0E7                 push    edx
.text:0000B0E8                 mov     ecx, [ebp+var_10]
.text:0000B0EB                 call    ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z ; CRecordVector<void *>::AddInReserved(void * const)
.text:0000B0F0                 mov     ecx, [ebp+var_C]
.text:0000B0F3                 mov     large fs:0, ecx
.text:0000B0FA                 pop     ecx
.text:0000B0FB                 add     esp, 1Ch
.text:0000B0FE                 cmp     ebp, esp
.text:0000B100                 call    __RTC_CheckEsp
.text:0000B105                 mov     esp, ebp
.text:0000B107                 pop     ebp
.text:0000B108                 retn    4
.text:0000B108 ?AddInReserved@?$CObjectVector@UCArcItem@@@@QAEXABUCArcItem@@@Z endp
.text:0000B108
.text:0000B108 ; ---------------------------------------------------------------------------
.text:0000B10B                 align 4
.text:0000B10B _text           ends
.text:0000B10B
.text$x:0000B10C ; ===========================================================================
.text$x:0000B10C
.text$x:0000B10C ; Segment type: Pure code
.text$x:0000B10C ; Segment permissions: Read/Execute
.text$x:0000B10C _text$x         segment para public 'CODE' use32
.text$x:0000B10C                 assume cs:_text$x
.text$x:0000B10C                 ;org 0B10Ch
.text$x:0000B10C ; COMDAT (pick associative to section at B06C)
.text$x:0000B10C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000B10C
.text$x:0000B10C ; =============== S U B R O U T I N E =======================================
.text$x:0000B10C
.text$x:0000B10C
.text$x:0000B10C __unwindfunclet$?AddInReserved@?$CObjectVector@UCArcItem@@@@QAEXABUCArcItem@@@Z$0 proc near
.text$x:0000B10C                                         ; DATA XREF: .xdata$x:0000B138o
.text$x:0000B10C                 mov     eax, [ebp-18h]
.text$x:0000B10F                 push    eax             ; void *
.text$x:0000B110                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:0000B115                 pop     ecx
.text$x:0000B116                 retn
.text$x:0000B116 __unwindfunclet$?AddInReserved@?$CObjectVector@UCArcItem@@@@QAEXABUCArcItem@@@Z$0 endp
.text$x:0000B116
.text$x:0000B117
.text$x:0000B117 ; =============== S U B R O U T I N E =======================================
.text$x:0000B117
.text$x:0000B117
.text$x:0000B117 __ehhandler$?AddInReserved@?$CObjectVector@UCArcItem@@@@QAEXABUCArcItem@@@Z proc near
.text$x:0000B117                                         ; DATA XREF: CObjectVector<CArcItem>::AddInReserved(CArcItem const &)+5o
.text$x:0000B117
.text$x:0000B117 arg_4           = dword ptr  8
.text$x:0000B117
.text$x:0000B117                 mov     edx, [esp+arg_4]
.text$x:0000B11B                 lea     eax, [edx+0Ch]
.text$x:0000B11E                 mov     ecx, [edx-14h]
.text$x:0000B121                 xor     ecx, eax
.text$x:0000B123                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B128                 mov     eax, offset __ehfuncinfo$?AddInReserved@?$CObjectVector@UCArcItem@@@@QAEXABUCArcItem@@@Z
.text$x:0000B12D                 jmp     ___CxxFrameHandler3
.text$x:0000B12D __ehhandler$?AddInReserved@?$CObjectVector@UCArcItem@@@@QAEXABUCArcItem@@@Z endp
.text$x:0000B12D
.text$x:0000B12D ; ---------------------------------------------------------------------------
.text$x:0000B132                 align 4
.text$x:0000B132 _text$x         ends
.text$x:0000B132
.xdata$x:0000B134 ; ===========================================================================
.xdata$x:0000B134
.xdata$x:0000B134 ; Segment type: Pure data
.xdata$x:0000B134 ; Segment permissions: Read
.xdata$x:0000B134 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000B134                 assume cs:_xdata$x
.xdata$x:0000B134                 ;org 0B134h
.xdata$x:0000B134 ; COMDAT (pick associative to section at B06C)
.xdata$x:0000B134 __unwindtable$?AddInReserved@?$CObjectVector@UCArcItem@@@@QAEXABUCArcItem@@@Z db 0FFh
.xdata$x:0000B134                                         ; DATA XREF: .xdata$x:0000B144o
.xdata$x:0000B135                 db 0FFh
.xdata$x:0000B136                 db 0FFh
.xdata$x:0000B137                 db 0FFh
.xdata$x:0000B138                 dd offset __unwindfunclet$?AddInReserved@?$CObjectVector@UCArcItem@@@@QAEXABUCArcItem@@@Z$0
.xdata$x:0000B13C __ehfuncinfo$?AddInReserved@?$CObjectVector@UCArcItem@@@@QAEXABUCArcItem@@@Z db  22h ; "
.xdata$x:0000B13C                                         ; DATA XREF: __ehhandler$?AddInReserved@?$CObjectVector@UCArcItem@@@@QAEXABUCArcItem@@@Z+11o
.xdata$x:0000B13D                 db    5
.xdata$x:0000B13E                 db  93h ; 
.xdata$x:0000B13F                 db  19h
.xdata$x:0000B140                 db    1
.xdata$x:0000B141                 db    0
.xdata$x:0000B142                 db    0
.xdata$x:0000B143                 db    0
.xdata$x:0000B144                 dd offset __unwindtable$?AddInReserved@?$CObjectVector@UCArcItem@@@@QAEXABUCArcItem@@@Z
.xdata$x:0000B148                 db    0
.xdata$x:0000B149                 db    0
.xdata$x:0000B14A                 db    0
.xdata$x:0000B14B                 db    0
.xdata$x:0000B14C                 db    0
.xdata$x:0000B14D                 db    0
.xdata$x:0000B14E                 db    0
.xdata$x:0000B14F                 db    0
.xdata$x:0000B150                 db    0
.xdata$x:0000B151                 db    0
.xdata$x:0000B152                 db    0
.xdata$x:0000B153                 db    0
.xdata$x:0000B154                 db    0
.xdata$x:0000B155                 db    0
.xdata$x:0000B156                 db    0
.xdata$x:0000B157                 db    0
.xdata$x:0000B158                 db    0
.xdata$x:0000B159                 db    0
.xdata$x:0000B15A                 db    0
.xdata$x:0000B15B                 db    0
.xdata$x:0000B15C                 db    1
.xdata$x:0000B15D                 db    0
.xdata$x:0000B15E                 db    0
.xdata$x:0000B15F                 db    0
.xdata$x:0000B15F _xdata$x        ends
.xdata$x:0000B15F
.text:0000B160 ; ===========================================================================
.text:0000B160
.text:0000B160 ; Segment type: Pure code
.text:0000B160 ; Segment permissions: Read/Execute
.text:0000B160 _text           segment para public 'CODE' use32
.text:0000B160                 assume cs:_text
.text:0000B160                 ;org 0B160h
.text:0000B160 ; COMDAT (pick any)
.text:0000B160                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B160
.text:0000B160 ; =============== S U B R O U T I N E =======================================
.text:0000B160
.text:0000B160 ; Attributes: bp-based frame
.text:0000B160
.text:0000B160 ; public: __thiscall CObjectVector<struct CArcItem>::~CObjectVector<struct CArcItem>(void)
.text:0000B160                 public ??1?$CObjectVector@UCArcItem@@@@QAE@XZ
.text:0000B160 ??1?$CObjectVector@UCArcItem@@@@QAE@XZ proc near
.text:0000B160                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1404p
.text:0000B160                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+16BAp ...
.text:0000B160
.text:0000B160 var_20          = dword ptr -20h
.text:0000B160 var_1C          = dword ptr -1Ch
.text:0000B160 var_18          = dword ptr -18h
.text:0000B160 var_14          = dword ptr -14h
.text:0000B160 var_10          = dword ptr -10h
.text:0000B160 var_C           = dword ptr -0Ch
.text:0000B160 var_4           = dword ptr -4
.text:0000B160
.text:0000B160                 push    ebp
.text:0000B161                 mov     ebp, esp
.text:0000B163                 push    0FFFFFFFFh
.text:0000B165                 push    offset __ehhandler$??1?$CObjectVector@UCArcItem@@@@QAE@XZ
.text:0000B16A                 mov     eax, large fs:0
.text:0000B170                 push    eax
.text:0000B171                 sub     esp, 14h
.text:0000B174                 mov     eax, 0CCCCCCCCh
.text:0000B179                 mov     [ebp+var_20], eax
.text:0000B17C                 mov     [ebp+var_1C], eax
.text:0000B17F                 mov     [ebp+var_18], eax
.text:0000B182                 mov     [ebp+var_14], eax
.text:0000B185                 mov     [ebp+var_10], eax
.text:0000B188                 mov     eax, dword ptr ds:___security_cookie
.text:0000B18D                 xor     eax, ebp
.text:0000B18F                 push    eax
.text:0000B190                 lea     eax, [ebp+var_C]
.text:0000B193                 mov     large fs:0, eax
.text:0000B199                 mov     [ebp+var_10], ecx
.text:0000B19C                 mov     [ebp+var_4], 0
.text:0000B1A3                 mov     ecx, [ebp+var_10]
.text:0000B1A6                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:0000B1AB                 mov     [ebp+var_14], eax
.text:0000B1AE
.text:0000B1AE loc_B1AE:                               ; CODE XREF: CObjectVector<CArcItem>::~CObjectVector<CArcItem>(void):loc_B1F0j
.text:0000B1AE                 cmp     [ebp+var_14], 0
.text:0000B1B2                 jz      short loc_B1F2
.text:0000B1B4                 mov     eax, [ebp+var_14]
.text:0000B1B7                 sub     eax, 1
.text:0000B1BA                 mov     [ebp+var_14], eax
.text:0000B1BD                 mov     ecx, [ebp+var_14]
.text:0000B1C0                 push    ecx
.text:0000B1C1                 mov     ecx, [ebp+var_10]
.text:0000B1C4                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:0000B1C9                 mov     edx, [eax]
.text:0000B1CB                 mov     [ebp+var_1C], edx
.text:0000B1CE                 mov     eax, [ebp+var_1C]
.text:0000B1D1                 mov     [ebp+var_18], eax
.text:0000B1D4                 cmp     [ebp+var_18], 0
.text:0000B1D8                 jz      short loc_B1E9
.text:0000B1DA                 push    1
.text:0000B1DC                 mov     ecx, [ebp+var_18]
.text:0000B1DF                 call    ??_GCArcItem@@QAEPAXI@Z ; CArcItem::`scalar deleting destructor'(uint)
.text:0000B1E4                 mov     [ebp+var_20], eax
.text:0000B1E7                 jmp     short loc_B1F0
.text:0000B1E9 ; ---------------------------------------------------------------------------
.text:0000B1E9
.text:0000B1E9 loc_B1E9:                               ; CODE XREF: CObjectVector<CArcItem>::~CObjectVector<CArcItem>(void)+78j
.text:0000B1E9                 mov     [ebp+var_20], 0
.text:0000B1F0
.text:0000B1F0 loc_B1F0:                               ; CODE XREF: CObjectVector<CArcItem>::~CObjectVector<CArcItem>(void)+87j
.text:0000B1F0                 jmp     short loc_B1AE
.text:0000B1F2 ; ---------------------------------------------------------------------------
.text:0000B1F2
.text:0000B1F2 loc_B1F2:                               ; CODE XREF: CObjectVector<CArcItem>::~CObjectVector<CArcItem>(void)+52j
.text:0000B1F2                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000B1F9                 mov     ecx, [ebp+var_10]
.text:0000B1FC                 call    ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text:0000B201                 mov     ecx, [ebp+var_C]
.text:0000B204                 mov     large fs:0, ecx
.text:0000B20B                 pop     ecx
.text:0000B20C                 add     esp, 20h
.text:0000B20F                 cmp     ebp, esp
.text:0000B211                 call    __RTC_CheckEsp
.text:0000B216                 mov     esp, ebp
.text:0000B218                 pop     ebp
.text:0000B219                 retn
.text:0000B219 ??1?$CObjectVector@UCArcItem@@@@QAE@XZ endp
.text:0000B219
.text:0000B219 ; ---------------------------------------------------------------------------
.text:0000B21A                 align 4
.text:0000B21A _text           ends
.text:0000B21A
.text$x:0000B21C ; ===========================================================================
.text$x:0000B21C
.text$x:0000B21C ; Segment type: Pure code
.text$x:0000B21C ; Segment permissions: Read/Execute
.text$x:0000B21C _text$x         segment para public 'CODE' use32
.text$x:0000B21C                 assume cs:_text$x
.text$x:0000B21C                 ;org 0B21Ch
.text$x:0000B21C ; COMDAT (pick associative to section at B160)
.text$x:0000B21C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000B21C
.text$x:0000B21C ; =============== S U B R O U T I N E =======================================
.text$x:0000B21C
.text$x:0000B21C
.text$x:0000B21C __unwindfunclet$??1?$CObjectVector@UCArcItem@@@@QAE@XZ$0 proc near
.text$x:0000B21C                                         ; DATA XREF: .xdata$x:0000B244o
.text$x:0000B21C                 mov     ecx, [ebp-10h]
.text$x:0000B21F                 jmp     ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text$x:0000B21F __unwindfunclet$??1?$CObjectVector@UCArcItem@@@@QAE@XZ$0 endp
.text$x:0000B21F
.text$x:0000B224
.text$x:0000B224 ; =============== S U B R O U T I N E =======================================
.text$x:0000B224
.text$x:0000B224
.text$x:0000B224 __ehhandler$??1?$CObjectVector@UCArcItem@@@@QAE@XZ proc near
.text$x:0000B224                                         ; DATA XREF: CObjectVector<CArcItem>::~CObjectVector<CArcItem>(void)+5o
.text$x:0000B224
.text$x:0000B224 arg_4           = dword ptr  8
.text$x:0000B224
.text$x:0000B224                 mov     edx, [esp+arg_4]
.text$x:0000B228                 lea     eax, [edx+0Ch]
.text$x:0000B22B                 mov     ecx, [edx-18h]
.text$x:0000B22E                 xor     ecx, eax
.text$x:0000B230                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B235                 mov     eax, offset __ehfuncinfo$??1?$CObjectVector@UCArcItem@@@@QAE@XZ
.text$x:0000B23A                 jmp     ___CxxFrameHandler3
.text$x:0000B23A __ehhandler$??1?$CObjectVector@UCArcItem@@@@QAE@XZ endp
.text$x:0000B23A
.text$x:0000B23A ; ---------------------------------------------------------------------------
.text$x:0000B23F                 align 10h
.text$x:0000B23F _text$x         ends
.text$x:0000B23F
.xdata$x:0000B240 ; ===========================================================================
.xdata$x:0000B240
.xdata$x:0000B240 ; Segment type: Pure data
.xdata$x:0000B240 ; Segment permissions: Read
.xdata$x:0000B240 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000B240                 assume cs:_xdata$x
.xdata$x:0000B240                 ;org 0B240h
.xdata$x:0000B240 ; COMDAT (pick associative to section at B160)
.xdata$x:0000B240 __unwindtable$??1?$CObjectVector@UCArcItem@@@@QAE@XZ db 0FFh
.xdata$x:0000B240                                         ; DATA XREF: .xdata$x:0000B250o
.xdata$x:0000B241                 db 0FFh
.xdata$x:0000B242                 db 0FFh
.xdata$x:0000B243                 db 0FFh
.xdata$x:0000B244                 dd offset __unwindfunclet$??1?$CObjectVector@UCArcItem@@@@QAE@XZ$0
.xdata$x:0000B248 __ehfuncinfo$??1?$CObjectVector@UCArcItem@@@@QAE@XZ db  22h ; "
.xdata$x:0000B248                                         ; DATA XREF: __ehhandler$??1?$CObjectVector@UCArcItem@@@@QAE@XZ+11o
.xdata$x:0000B249                 db    5
.xdata$x:0000B24A                 db  93h ; 
.xdata$x:0000B24B                 db  19h
.xdata$x:0000B24C                 db    1
.xdata$x:0000B24D                 db    0
.xdata$x:0000B24E                 db    0
.xdata$x:0000B24F                 db    0
.xdata$x:0000B250                 dd offset __unwindtable$??1?$CObjectVector@UCArcItem@@@@QAE@XZ
.xdata$x:0000B254                 db    0
.xdata$x:0000B255                 db    0
.xdata$x:0000B256                 db    0
.xdata$x:0000B257                 db    0
.xdata$x:0000B258                 db    0
.xdata$x:0000B259                 db    0
.xdata$x:0000B25A                 db    0
.xdata$x:0000B25B                 db    0
.xdata$x:0000B25C                 db    0
.xdata$x:0000B25D                 db    0
.xdata$x:0000B25E                 db    0
.xdata$x:0000B25F                 db    0
.xdata$x:0000B260                 db    0
.xdata$x:0000B261                 db    0
.xdata$x:0000B262                 db    0
.xdata$x:0000B263                 db    0
.xdata$x:0000B264                 db    0
.xdata$x:0000B265                 db    0
.xdata$x:0000B266                 db    0
.xdata$x:0000B267                 db    0
.xdata$x:0000B268                 db    1
.xdata$x:0000B269                 db    0
.xdata$x:0000B26A                 db    0
.xdata$x:0000B26B                 db    0
.xdata$x:0000B26B _xdata$x        ends
.xdata$x:0000B26B
.text:0000B26C ; ===========================================================================
.text:0000B26C
.text:0000B26C ; Segment type: Pure code
.text:0000B26C ; Segment permissions: Read/Execute
.text:0000B26C _text           segment para public 'CODE' use32
.text:0000B26C                 assume cs:_text
.text:0000B26C                 ;org 0B26Ch
.text:0000B26C ; COMDAT (pick any)
.text:0000B26C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B26C
.text:0000B26C ; =============== S U B R O U T I N E =======================================
.text:0000B26C
.text:0000B26C ; Attributes: bp-based frame
.text:0000B26C
.text:0000B26C ; public: void __thiscall CObjectVector<struct CArcItem>::Clear(void)
.text:0000B26C                 public ?Clear@?$CObjectVector@UCArcItem@@@@QAEXXZ
.text:0000B26C ?Clear@?$CObjectVector@UCArcItem@@@@QAEXXZ proc near
.text:0000B26C                                         ; CODE XREF: EnumerateInArchiveItems(NWildcard::CCensor const &,CArc const &,CObjectVector<CArcItem> &)+3Fp
.text:0000B26C                                         ; CObjectVector<CArcItem>::ClearAndReserve(uint)+11p
.text:0000B26C
.text:0000B26C var_14          = dword ptr -14h
.text:0000B26C var_10          = dword ptr -10h
.text:0000B26C var_C           = dword ptr -0Ch
.text:0000B26C var_8           = dword ptr -8
.text:0000B26C var_4           = dword ptr -4
.text:0000B26C
.text:0000B26C                 push    ebp
.text:0000B26D                 mov     ebp, esp
.text:0000B26F                 sub     esp, 14h
.text:0000B272                 mov     eax, 0CCCCCCCCh
.text:0000B277                 mov     [ebp+var_14], eax
.text:0000B27A                 mov     [ebp+var_10], eax
.text:0000B27D                 mov     [ebp+var_C], eax
.text:0000B280                 mov     [ebp+var_8], eax
.text:0000B283                 mov     [ebp+var_4], eax
.text:0000B286                 mov     [ebp+var_4], ecx
.text:0000B289                 mov     ecx, [ebp+var_4]
.text:0000B28C                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:0000B291                 mov     [ebp+var_8], eax
.text:0000B294
.text:0000B294 loc_B294:                               ; CODE XREF: CObjectVector<CArcItem>::Clear(void):loc_B2D6j
.text:0000B294                 cmp     [ebp+var_8], 0
.text:0000B298                 jz      short loc_B2D8
.text:0000B29A                 mov     eax, [ebp+var_8]
.text:0000B29D                 sub     eax, 1
.text:0000B2A0                 mov     [ebp+var_8], eax
.text:0000B2A3                 mov     ecx, [ebp+var_8]
.text:0000B2A6                 push    ecx
.text:0000B2A7                 mov     ecx, [ebp+var_4]
.text:0000B2AA                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:0000B2AF                 mov     edx, [eax]
.text:0000B2B1                 mov     [ebp+var_10], edx
.text:0000B2B4                 mov     eax, [ebp+var_10]
.text:0000B2B7                 mov     [ebp+var_C], eax
.text:0000B2BA                 cmp     [ebp+var_C], 0
.text:0000B2BE                 jz      short loc_B2CF
.text:0000B2C0                 push    1
.text:0000B2C2                 mov     ecx, [ebp+var_C]
.text:0000B2C5                 call    ??_GCArcItem@@QAEPAXI@Z ; CArcItem::`scalar deleting destructor'(uint)
.text:0000B2CA                 mov     [ebp+var_14], eax
.text:0000B2CD                 jmp     short loc_B2D6
.text:0000B2CF ; ---------------------------------------------------------------------------
.text:0000B2CF
.text:0000B2CF loc_B2CF:                               ; CODE XREF: CObjectVector<CArcItem>::Clear(void)+52j
.text:0000B2CF                 mov     [ebp+var_14], 0
.text:0000B2D6
.text:0000B2D6 loc_B2D6:                               ; CODE XREF: CObjectVector<CArcItem>::Clear(void)+61j
.text:0000B2D6                 jmp     short loc_B294
.text:0000B2D8 ; ---------------------------------------------------------------------------
.text:0000B2D8
.text:0000B2D8 loc_B2D8:                               ; CODE XREF: CObjectVector<CArcItem>::Clear(void)+2Cj
.text:0000B2D8                 mov     ecx, [ebp+var_4]
.text:0000B2DB                 call    ?Clear@?$CRecordVector@PAX@@QAEXXZ ; CRecordVector<void *>::Clear(void)
.text:0000B2E0                 add     esp, 14h
.text:0000B2E3                 cmp     ebp, esp
.text:0000B2E5                 call    __RTC_CheckEsp
.text:0000B2EA                 mov     esp, ebp
.text:0000B2EC                 pop     ebp
.text:0000B2ED                 retn
.text:0000B2ED ?Clear@?$CObjectVector@UCArcItem@@@@QAEXXZ endp
.text:0000B2ED
.text:0000B2ED ; ---------------------------------------------------------------------------
.text:0000B2EE                 align 10h
.text:0000B2EE _text           ends
.text:0000B2EE
.text:0000B2F0 ; ===========================================================================
.text:0000B2F0
.text:0000B2F0 ; Segment type: Pure code
.text:0000B2F0 ; Segment permissions: Read/Execute
.text:0000B2F0 _text           segment para public 'CODE' use32
.text:0000B2F0                 assume cs:_text
.text:0000B2F0                 ;org 0B2F0h
.text:0000B2F0 ; COMDAT (pick any)
.text:0000B2F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B2F0
.text:0000B2F0 ; =============== S U B R O U T I N E =======================================
.text:0000B2F0
.text:0000B2F0 ; Attributes: bp-based frame
.text:0000B2F0
.text:0000B2F0 ; public: unsigned int __thiscall CObjectVector<struct CProperty>::Add(struct CProperty const &)
.text:0000B2F0                 public ?Add@?$CObjectVector@UCProperty@@@@QAEIABUCProperty@@@Z
.text:0000B2F0 ?Add@?$CObjectVector@UCProperty@@@@QAEIABUCProperty@@@Z proc near
.text:0000B2F0                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1ABp
.text:0000B2F0
.text:0000B2F0 var_1C          = dword ptr -1Ch
.text:0000B2F0 var_18          = dword ptr -18h
.text:0000B2F0 var_14          = dword ptr -14h
.text:0000B2F0 var_10          = dword ptr -10h
.text:0000B2F0 var_C           = dword ptr -0Ch
.text:0000B2F0 var_4           = dword ptr -4
.text:0000B2F0 arg_0           = dword ptr  8
.text:0000B2F0
.text:0000B2F0                 push    ebp
.text:0000B2F1                 mov     ebp, esp
.text:0000B2F3                 push    0FFFFFFFFh
.text:0000B2F5                 push    offset __ehhandler$?Add@?$CObjectVector@UCProperty@@@@QAEIABUCProperty@@@Z
.text:0000B2FA                 mov     eax, large fs:0
.text:0000B300                 push    eax
.text:0000B301                 sub     esp, 10h
.text:0000B304                 mov     eax, 0CCCCCCCCh
.text:0000B309                 mov     [ebp+var_1C], eax
.text:0000B30C                 mov     [ebp+var_18], eax
.text:0000B30F                 mov     [ebp+var_14], eax
.text:0000B312                 mov     [ebp+var_10], eax
.text:0000B315                 mov     eax, dword ptr ds:___security_cookie
.text:0000B31A                 xor     eax, ebp
.text:0000B31C                 push    eax
.text:0000B31D                 lea     eax, [ebp+var_C]
.text:0000B320                 mov     large fs:0, eax
.text:0000B326                 mov     [ebp+var_10], ecx
.text:0000B329                 push    18h             ; unsigned int
.text:0000B32B                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0000B330                 add     esp, 4
.text:0000B333                 mov     [ebp+var_18], eax
.text:0000B336                 mov     [ebp+var_4], 0
.text:0000B33D                 cmp     [ebp+var_18], 0
.text:0000B341                 jz      short loc_B354
.text:0000B343                 mov     eax, [ebp+arg_0]
.text:0000B346                 push    eax
.text:0000B347                 mov     ecx, [ebp+var_18]
.text:0000B34A                 call    ??0CProperty@@QAE@ABU0@@Z ; CProperty::CProperty(CProperty const &)
.text:0000B34F                 mov     [ebp+var_1C], eax
.text:0000B352                 jmp     short loc_B35B
.text:0000B354 ; ---------------------------------------------------------------------------
.text:0000B354
.text:0000B354 loc_B354:                               ; CODE XREF: CObjectVector<CProperty>::Add(CProperty const &)+51j
.text:0000B354                 mov     [ebp+var_1C], 0
.text:0000B35B
.text:0000B35B loc_B35B:                               ; CODE XREF: CObjectVector<CProperty>::Add(CProperty const &)+62j
.text:0000B35B                 mov     ecx, [ebp+var_1C]
.text:0000B35E                 mov     [ebp+var_14], ecx
.text:0000B361                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000B368                 mov     edx, [ebp+var_14]
.text:0000B36B                 push    edx
.text:0000B36C                 mov     ecx, [ebp+var_10]
.text:0000B36F                 call    ?Add@?$CRecordVector@PAX@@QAEIQAX@Z ; CRecordVector<void *>::Add(void * const)
.text:0000B374                 mov     ecx, [ebp+var_C]
.text:0000B377                 mov     large fs:0, ecx
.text:0000B37E                 pop     ecx
.text:0000B37F                 add     esp, 1Ch
.text:0000B382                 cmp     ebp, esp
.text:0000B384                 call    __RTC_CheckEsp
.text:0000B389                 mov     esp, ebp
.text:0000B38B                 pop     ebp
.text:0000B38C                 retn    4
.text:0000B38C ?Add@?$CObjectVector@UCProperty@@@@QAEIABUCProperty@@@Z endp
.text:0000B38C
.text:0000B38C ; ---------------------------------------------------------------------------
.text:0000B38F                 align 10h
.text:0000B38F _text           ends
.text:0000B38F
.text$x:0000B390 ; ===========================================================================
.text$x:0000B390
.text$x:0000B390 ; Segment type: Pure code
.text$x:0000B390 ; Segment permissions: Read/Execute
.text$x:0000B390 _text$x         segment para public 'CODE' use32
.text$x:0000B390                 assume cs:_text$x
.text$x:0000B390                 ;org 0B390h
.text$x:0000B390 ; COMDAT (pick associative to section at B2F0)
.text$x:0000B390                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000B390
.text$x:0000B390 ; =============== S U B R O U T I N E =======================================
.text$x:0000B390
.text$x:0000B390
.text$x:0000B390 __unwindfunclet$?Add@?$CObjectVector@UCProperty@@@@QAEIABUCProperty@@@Z$0 proc near
.text$x:0000B390                                         ; DATA XREF: .xdata$x:0000B3BCo
.text$x:0000B390                 mov     eax, [ebp-18h]
.text$x:0000B393                 push    eax             ; void *
.text$x:0000B394                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:0000B399                 pop     ecx
.text$x:0000B39A                 retn
.text$x:0000B39A __unwindfunclet$?Add@?$CObjectVector@UCProperty@@@@QAEIABUCProperty@@@Z$0 endp
.text$x:0000B39A
.text$x:0000B39B
.text$x:0000B39B ; =============== S U B R O U T I N E =======================================
.text$x:0000B39B
.text$x:0000B39B
.text$x:0000B39B __ehhandler$?Add@?$CObjectVector@UCProperty@@@@QAEIABUCProperty@@@Z proc near
.text$x:0000B39B                                         ; DATA XREF: CObjectVector<CProperty>::Add(CProperty const &)+5o
.text$x:0000B39B
.text$x:0000B39B arg_4           = dword ptr  8
.text$x:0000B39B
.text$x:0000B39B                 mov     edx, [esp+arg_4]
.text$x:0000B39F                 lea     eax, [edx+0Ch]
.text$x:0000B3A2                 mov     ecx, [edx-14h]
.text$x:0000B3A5                 xor     ecx, eax
.text$x:0000B3A7                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B3AC                 mov     eax, offset __ehfuncinfo$?Add@?$CObjectVector@UCProperty@@@@QAEIABUCProperty@@@Z
.text$x:0000B3B1                 jmp     ___CxxFrameHandler3
.text$x:0000B3B1 __ehhandler$?Add@?$CObjectVector@UCProperty@@@@QAEIABUCProperty@@@Z endp
.text$x:0000B3B1
.text$x:0000B3B1 ; ---------------------------------------------------------------------------
.text$x:0000B3B6                 align 4
.text$x:0000B3B6 _text$x         ends
.text$x:0000B3B6
.xdata$x:0000B3B8 ; ===========================================================================
.xdata$x:0000B3B8
.xdata$x:0000B3B8 ; Segment type: Pure data
.xdata$x:0000B3B8 ; Segment permissions: Read
.xdata$x:0000B3B8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000B3B8                 assume cs:_xdata$x
.xdata$x:0000B3B8                 ;org 0B3B8h
.xdata$x:0000B3B8 ; COMDAT (pick associative to section at B2F0)
.xdata$x:0000B3B8 __unwindtable$?Add@?$CObjectVector@UCProperty@@@@QAEIABUCProperty@@@Z db 0FFh
.xdata$x:0000B3B8                                         ; DATA XREF: .xdata$x:0000B3C8o
.xdata$x:0000B3B9                 db 0FFh
.xdata$x:0000B3BA                 db 0FFh
.xdata$x:0000B3BB                 db 0FFh
.xdata$x:0000B3BC                 dd offset __unwindfunclet$?Add@?$CObjectVector@UCProperty@@@@QAEIABUCProperty@@@Z$0
.xdata$x:0000B3C0 __ehfuncinfo$?Add@?$CObjectVector@UCProperty@@@@QAEIABUCProperty@@@Z db  22h ; "
.xdata$x:0000B3C0                                         ; DATA XREF: __ehhandler$?Add@?$CObjectVector@UCProperty@@@@QAEIABUCProperty@@@Z+11o
.xdata$x:0000B3C1                 db    5
.xdata$x:0000B3C2                 db  93h ; 
.xdata$x:0000B3C3                 db  19h
.xdata$x:0000B3C4                 db    1
.xdata$x:0000B3C5                 db    0
.xdata$x:0000B3C6                 db    0
.xdata$x:0000B3C7                 db    0
.xdata$x:0000B3C8                 dd offset __unwindtable$?Add@?$CObjectVector@UCProperty@@@@QAEIABUCProperty@@@Z
.xdata$x:0000B3CC                 align 20h
.xdata$x:0000B3E0                 db    1
.xdata$x:0000B3E1                 db    0
.xdata$x:0000B3E2                 db    0
.xdata$x:0000B3E3                 db    0
.xdata$x:0000B3E3 _xdata$x        ends
.xdata$x:0000B3E3
.text:0000B3E4 ; ===========================================================================
.text:0000B3E4
.text:0000B3E4 ; Segment type: Pure code
.text:0000B3E4 ; Segment permissions: Read/Execute
.text:0000B3E4 _text           segment para public 'CODE' use32
.text:0000B3E4                 assume cs:_text
.text:0000B3E4                 ;org 0B3E4h
.text:0000B3E4 ; COMDAT (pick any)
.text:0000B3E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B3E4
.text:0000B3E4 ; =============== S U B R O U T I N E =======================================
.text:0000B3E4
.text:0000B3E4 ; Attributes: bp-based frame
.text:0000B3E4
.text:0000B3E4 ; public: unsigned int __thiscall CObjectVector<struct CUpdateArchiveCommand>::Size(void)const
.text:0000B3E4                 public ?Size@?$CObjectVector@UCUpdateArchiveCommand@@@@QBEIXZ
.text:0000B3E4 ?Size@?$CObjectVector@UCUpdateArchiveCommand@@@@QBEIXZ proc near
.text:0000B3E4                                         ; CODE XREF: CUpdateOptions::SetArcPath(CCodecs const *,UString const &)+14Dp
.text:0000B3E4                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+A7p ...
.text:0000B3E4
.text:0000B3E4 var_4           = dword ptr -4
.text:0000B3E4
.text:0000B3E4                 push    ebp
.text:0000B3E5                 mov     ebp, esp
.text:0000B3E7                 push    ecx
.text:0000B3E8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B3EF                 mov     [ebp+var_4], ecx
.text:0000B3F2                 mov     ecx, [ebp+var_4]
.text:0000B3F5                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:0000B3FA                 add     esp, 4
.text:0000B3FD                 cmp     ebp, esp
.text:0000B3FF                 call    __RTC_CheckEsp
.text:0000B404                 mov     esp, ebp
.text:0000B406                 pop     ebp
.text:0000B407                 retn
.text:0000B407 ?Size@?$CObjectVector@UCUpdateArchiveCommand@@@@QBEIXZ endp
.text:0000B407
.text:0000B407 _text           ends
.text:0000B407
.text:0000B408 ; ===========================================================================
.text:0000B408
.text:0000B408 ; Segment type: Pure code
.text:0000B408 ; Segment permissions: Read/Execute
.text:0000B408 _text           segment para public 'CODE' use32
.text:0000B408                 assume cs:_text
.text:0000B408                 ;org 0B408h
.text:0000B408 ; COMDAT (pick any)
.text:0000B408                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B408
.text:0000B408 ; =============== S U B R O U T I N E =======================================
.text:0000B408
.text:0000B408 ; Attributes: bp-based frame
.text:0000B408
.text:0000B408 ; public: struct CUpdateArchiveCommand & __thiscall CObjectVector<struct CUpdateArchiveCommand>::operator[](unsigned int)
.text:0000B408                 public ??A?$CObjectVector@UCUpdateArchiveCommand@@@@QAEAAUCUpdateArchiveCommand@@I@Z
.text:0000B408 ??A?$CObjectVector@UCUpdateArchiveCommand@@@@QAEAAUCUpdateArchiveCommand@@I@Z proc near
.text:0000B408                                         ; CODE XREF: CUpdateOptions::SetArcPath(CCodecs const *,UString const &)+161p
.text:0000B408                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+EBp ...
.text:0000B408
.text:0000B408 var_4           = dword ptr -4
.text:0000B408 arg_0           = dword ptr  8
.text:0000B408
.text:0000B408                 push    ebp
.text:0000B409                 mov     ebp, esp
.text:0000B40B                 push    ecx
.text:0000B40C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B413                 mov     [ebp+var_4], ecx
.text:0000B416                 mov     eax, [ebp+arg_0]
.text:0000B419                 push    eax
.text:0000B41A                 mov     ecx, [ebp+var_4]
.text:0000B41D                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:0000B422                 mov     eax, [eax]
.text:0000B424                 add     esp, 4
.text:0000B427                 cmp     ebp, esp
.text:0000B429                 call    __RTC_CheckEsp
.text:0000B42E                 mov     esp, ebp
.text:0000B430                 pop     ebp
.text:0000B431                 retn    4
.text:0000B431 ??A?$CObjectVector@UCUpdateArchiveCommand@@@@QAEAAUCUpdateArchiveCommand@@I@Z endp
.text:0000B431
.text:0000B431 _text           ends
.text:0000B431
.text:0000B434 ; ===========================================================================
.text:0000B434
.text:0000B434 ; Segment type: Pure code
.text:0000B434 ; Segment permissions: Read/Execute
.text:0000B434 _text           segment para public 'CODE' use32
.text:0000B434                 assume cs:_text
.text:0000B434                 ;org 0B434h
.text:0000B434 ; COMDAT (pick any)
.text:0000B434                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B434
.text:0000B434 ; =============== S U B R O U T I N E =======================================
.text:0000B434
.text:0000B434 ; Attributes: bp-based frame
.text:0000B434
.text:0000B434 ; public: unsigned int __thiscall CObjectVector<struct CRenamePair>::Size(void)const
.text:0000B434                 public ?Size@?$CObjectVector@UCRenamePair@@@@QBEIXZ
.text:0000B434 ?Size@?$CObjectVector@UCRenamePair@@@@QBEIXZ proc near
.text:0000B434                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+2AFp
.text:0000B434                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+334p ...
.text:0000B434
.text:0000B434 var_4           = dword ptr -4
.text:0000B434
.text:0000B434                 push    ebp
.text:0000B435                 mov     ebp, esp
.text:0000B437                 push    ecx
.text:0000B438                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B43F                 mov     [ebp+var_4], ecx
.text:0000B442                 mov     ecx, [ebp+var_4]
.text:0000B445                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:0000B44A                 add     esp, 4
.text:0000B44D                 cmp     ebp, esp
.text:0000B44F                 call    __RTC_CheckEsp
.text:0000B454                 mov     esp, ebp
.text:0000B456                 pop     ebp
.text:0000B457                 retn
.text:0000B457 ?Size@?$CObjectVector@UCRenamePair@@@@QBEIXZ endp
.text:0000B457
.text:0000B457 _text           ends
.text:0000B457
.text:0000B458 ; ===========================================================================
.text:0000B458
.text:0000B458 ; Segment type: Pure code
.text:0000B458 ; Segment permissions: Read/Execute
.text:0000B458 _text           segment para public 'CODE' use32
.text:0000B458                 assume cs:_text
.text:0000B458                 ;org 0B458h
.text:0000B458 ; COMDAT (pick any)
.text:0000B458                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B458
.text:0000B458 ; =============== S U B R O U T I N E =======================================
.text:0000B458
.text:0000B458 ; Attributes: bp-based frame
.text:0000B458
.text:0000B458 ; public: bool __thiscall CObjectVector<struct CRenamePair>::IsEmpty(void)const
.text:0000B458                 public ?IsEmpty@?$CObjectVector@UCRenamePair@@@@QBE_NXZ
.text:0000B458 ?IsEmpty@?$CObjectVector@UCRenamePair@@@@QBE_NXZ proc near
.text:0000B458                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+87p
.text:0000B458
.text:0000B458 var_4           = dword ptr -4
.text:0000B458
.text:0000B458                 push    ebp
.text:0000B459                 mov     ebp, esp
.text:0000B45B                 push    ecx
.text:0000B45C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B463                 mov     [ebp+var_4], ecx
.text:0000B466                 mov     ecx, [ebp+var_4]
.text:0000B469                 call    ?IsEmpty@?$CRecordVector@PAX@@QBE_NXZ ; CRecordVector<void *>::IsEmpty(void)
.text:0000B46E                 add     esp, 4
.text:0000B471                 cmp     ebp, esp
.text:0000B473                 call    __RTC_CheckEsp
.text:0000B478                 mov     esp, ebp
.text:0000B47A                 pop     ebp
.text:0000B47B                 retn
.text:0000B47B ?IsEmpty@?$CObjectVector@UCRenamePair@@@@QBE_NXZ endp
.text:0000B47B
.text:0000B47B _text           ends
.text:0000B47B
.text:0000B47C ; ===========================================================================
.text:0000B47C
.text:0000B47C ; Segment type: Pure code
.text:0000B47C ; Segment permissions: Read/Execute
.text:0000B47C _text           segment para public 'CODE' use32
.text:0000B47C                 assume cs:_text
.text:0000B47C                 ;org 0B47Ch
.text:0000B47C ; COMDAT (pick any)
.text:0000B47C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B47C
.text:0000B47C ; =============== S U B R O U T I N E =======================================
.text:0000B47C
.text:0000B47C ; Attributes: bp-based frame
.text:0000B47C
.text:0000B47C ; public: struct CRenamePair const & __thiscall CObjectVector<struct CRenamePair>::operator[](unsigned int)const
.text:0000B47C                 public ??A?$CObjectVector@UCRenamePair@@@@QBEABUCRenamePair@@I@Z
.text:0000B47C ??A?$CObjectVector@UCRenamePair@@@@QBEABUCRenamePair@@I@Z proc near
.text:0000B47C                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+355p
.text:0000B47C
.text:0000B47C var_4           = dword ptr -4
.text:0000B47C arg_0           = dword ptr  8
.text:0000B47C
.text:0000B47C                 push    ebp
.text:0000B47D                 mov     ebp, esp
.text:0000B47F                 push    ecx
.text:0000B480                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B487                 mov     [ebp+var_4], ecx
.text:0000B48A                 mov     eax, [ebp+arg_0]
.text:0000B48D                 push    eax
.text:0000B48E                 mov     ecx, [ebp+var_4]
.text:0000B491                 call    ??A?$CRecordVector@PAX@@QBEABQAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:0000B496                 mov     eax, [eax]
.text:0000B498                 add     esp, 4
.text:0000B49B                 cmp     ebp, esp
.text:0000B49D                 call    __RTC_CheckEsp
.text:0000B4A2                 mov     esp, ebp
.text:0000B4A4                 pop     ebp
.text:0000B4A5                 retn    4
.text:0000B4A5 ??A?$CObjectVector@UCRenamePair@@@@QBEABUCRenamePair@@I@Z endp
.text:0000B4A5
.text:0000B4A5 _text           ends
.text:0000B4A5
.text:0000B4A8 ; ===========================================================================
.text:0000B4A8
.text:0000B4A8 ; Segment type: Pure code
.text:0000B4A8 ; Segment permissions: Read/Execute
.text:0000B4A8 _text           segment para public 'CODE' use32
.text:0000B4A8                 assume cs:_text
.text:0000B4A8                 ;org 0B4A8h
.text:0000B4A8 ; COMDAT (pick any)
.text:0000B4A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B4A8
.text:0000B4A8 ; =============== S U B R O U T I N E =======================================
.text:0000B4A8
.text:0000B4A8 ; Attributes: bp-based frame
.text:0000B4A8
.text:0000B4A8 ; public: __thiscall CMyComPtr<struct ISequentialOutStream>::CMyComPtr<struct ISequentialOutStream>(void)
.text:0000B4A8                 public ??0?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ
.text:0000B4A8 ??0?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ proc near
.text:0000B4A8                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+823p
.text:0000B4A8                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+100Bp ...
.text:0000B4A8
.text:0000B4A8 var_4           = dword ptr -4
.text:0000B4A8
.text:0000B4A8                 push    ebp
.text:0000B4A9                 mov     ebp, esp
.text:0000B4AB                 push    ecx
.text:0000B4AC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B4B3                 mov     [ebp+var_4], ecx
.text:0000B4B6                 mov     eax, [ebp+var_4]
.text:0000B4B9                 mov     dword ptr [eax], 0
.text:0000B4BF                 mov     eax, [ebp+var_4]
.text:0000B4C2                 mov     esp, ebp
.text:0000B4C4                 pop     ebp
.text:0000B4C5                 retn
.text:0000B4C5 ??0?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ endp
.text:0000B4C5
.text:0000B4C5 ; ---------------------------------------------------------------------------
.text:0000B4C6                 align 4
.text:0000B4C6 _text           ends
.text:0000B4C6
.text:0000B4C8 ; ===========================================================================
.text:0000B4C8
.text:0000B4C8 ; Segment type: Pure code
.text:0000B4C8 ; Segment permissions: Read/Execute
.text:0000B4C8 _text           segment para public 'CODE' use32
.text:0000B4C8                 assume cs:_text
.text:0000B4C8                 ;org 0B4C8h
.text:0000B4C8 ; COMDAT (pick any)
.text:0000B4C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B4C8
.text:0000B4C8 ; =============== S U B R O U T I N E =======================================
.text:0000B4C8
.text:0000B4C8 ; Attributes: bp-based frame
.text:0000B4C8
.text:0000B4C8 ; public: __thiscall CMyComPtr<struct ISequentialOutStream>::~CMyComPtr<struct ISequentialOutStream>(void)
.text:0000B4C8                 public ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ
.text:0000B4C8 ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ proc near
.text:0000B4C8                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+BC7p
.text:0000B4C8                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+C52p ...
.text:0000B4C8
.text:0000B4C8 var_4           = dword ptr -4
.text:0000B4C8
.text:0000B4C8                 push    ebp
.text:0000B4C9                 mov     ebp, esp
.text:0000B4CB                 push    ecx
.text:0000B4CC                 push    esi
.text:0000B4CD                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B4D4                 mov     [ebp+var_4], ecx
.text:0000B4D7                 mov     eax, [ebp+var_4]
.text:0000B4DA                 cmp     dword ptr [eax], 0
.text:0000B4DD                 jz      short loc_B4FA
.text:0000B4DF                 mov     ecx, [ebp+var_4]
.text:0000B4E2                 mov     edx, [ecx]
.text:0000B4E4                 mov     eax, [ebp+var_4]
.text:0000B4E7                 mov     ecx, [eax]
.text:0000B4E9                 mov     edx, [edx]
.text:0000B4EB                 mov     esi, esp
.text:0000B4ED                 push    ecx
.text:0000B4EE                 mov     eax, [edx+8]
.text:0000B4F1                 call    eax
.text:0000B4F3                 cmp     esi, esp
.text:0000B4F5                 call    __RTC_CheckEsp
.text:0000B4FA
.text:0000B4FA loc_B4FA:                               ; CODE XREF: CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)+15j
.text:0000B4FA                 pop     esi
.text:0000B4FB                 add     esp, 4
.text:0000B4FE                 cmp     ebp, esp
.text:0000B500                 call    __RTC_CheckEsp
.text:0000B505                 mov     esp, ebp
.text:0000B507                 pop     ebp
.text:0000B508                 retn
.text:0000B508 ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ endp
.text:0000B508
.text:0000B508 ; ---------------------------------------------------------------------------
.text:0000B509                 align 4
.text:0000B509 _text           ends
.text:0000B509
.text:0000B50C ; ===========================================================================
.text:0000B50C
.text:0000B50C ; Segment type: Pure code
.text:0000B50C ; Segment permissions: Read/Execute
.text:0000B50C _text           segment para public 'CODE' use32
.text:0000B50C                 assume cs:_text
.text:0000B50C                 ;org 0B50Ch
.text:0000B50C ; COMDAT (pick any)
.text:0000B50C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B50C
.text:0000B50C ; =============== S U B R O U T I N E =======================================
.text:0000B50C
.text:0000B50C ; Attributes: bp-based frame
.text:0000B50C
.text:0000B50C ; public: __thiscall CMyComPtr<struct ISequentialOutStream>::operator struct ISequentialOutStream *(void)const
.text:0000B50C                 public ??B?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ
.text:0000B50C ??B?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ proc near
.text:0000B50C                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+1335p
.text:0000B50C                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+15EFp ...
.text:0000B50C
.text:0000B50C var_4           = dword ptr -4
.text:0000B50C
.text:0000B50C                 push    ebp
.text:0000B50D                 mov     ebp, esp
.text:0000B50F                 push    ecx
.text:0000B510                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B517                 mov     [ebp+var_4], ecx
.text:0000B51A                 mov     eax, [ebp+var_4]
.text:0000B51D                 mov     eax, [eax]
.text:0000B51F                 mov     esp, ebp
.text:0000B521                 pop     ebp
.text:0000B522                 retn
.text:0000B522 ??B?$CMyComPtr@UISequentialOutStream@@@@QBEPAUISequentialOutStream@@XZ endp
.text:0000B522
.text:0000B522 ; ---------------------------------------------------------------------------
.text:0000B523                 align 4
.text:0000B523 _text           ends
.text:0000B523
.text:0000B524 ; ===========================================================================
.text:0000B524
.text:0000B524 ; Segment type: Pure code
.text:0000B524 ; Segment permissions: Read/Execute
.text:0000B524 _text           segment para public 'CODE' use32
.text:0000B524                 assume cs:_text
.text:0000B524                 ;org 0B524h
.text:0000B524 ; COMDAT (pick any)
.text:0000B524                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B524
.text:0000B524 ; =============== S U B R O U T I N E =======================================
.text:0000B524
.text:0000B524 ; Attributes: bp-based frame
.text:0000B524
.text:0000B524 ; public: struct ISequentialOutStream * __thiscall CMyComPtr<struct ISequentialOutStream>::operator=(struct ISequentialOutStream *)
.text:0000B524                 public ??4?$CMyComPtr@UISequentialOutStream@@@@QAEPAUISequentialOutStream@@PAU1@@Z
.text:0000B524 ??4?$CMyComPtr@UISequentialOutStream@@@@QAEPAUISequentialOutStream@@PAU1@@Z proc near
.text:0000B524                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+994p
.text:0000B524                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+A18p ...
.text:0000B524
.text:0000B524 var_4           = dword ptr -4
.text:0000B524 arg_0           = dword ptr  8
.text:0000B524
.text:0000B524                 push    ebp
.text:0000B525                 mov     ebp, esp
.text:0000B527                 push    ecx
.text:0000B528                 push    esi
.text:0000B529                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B530                 mov     [ebp+var_4], ecx
.text:0000B533                 cmp     [ebp+arg_0], 0
.text:0000B537                 jz      short loc_B550
.text:0000B539                 mov     eax, [ebp+arg_0]
.text:0000B53C                 mov     ecx, [eax]
.text:0000B53E                 mov     esi, esp
.text:0000B540                 mov     edx, [ebp+arg_0]
.text:0000B543                 push    edx
.text:0000B544                 mov     eax, [ecx+4]
.text:0000B547                 call    eax
.text:0000B549                 cmp     esi, esp
.text:0000B54B                 call    __RTC_CheckEsp
.text:0000B550
.text:0000B550 loc_B550:                               ; CODE XREF: CMyComPtr<ISequentialOutStream>::operator=(ISequentialOutStream *)+13j
.text:0000B550                 mov     ecx, [ebp+var_4]
.text:0000B553                 cmp     dword ptr [ecx], 0
.text:0000B556                 jz      short loc_B573
.text:0000B558                 mov     edx, [ebp+var_4]
.text:0000B55B                 mov     eax, [edx]
.text:0000B55D                 mov     ecx, [ebp+var_4]
.text:0000B560                 mov     edx, [ecx]
.text:0000B562                 mov     eax, [eax]
.text:0000B564                 mov     esi, esp
.text:0000B566                 push    edx
.text:0000B567                 mov     ecx, [eax+8]
.text:0000B56A                 call    ecx
.text:0000B56C                 cmp     esi, esp
.text:0000B56E                 call    __RTC_CheckEsp
.text:0000B573
.text:0000B573 loc_B573:                               ; CODE XREF: CMyComPtr<ISequentialOutStream>::operator=(ISequentialOutStream *)+32j
.text:0000B573                 mov     edx, [ebp+var_4]
.text:0000B576                 mov     eax, [ebp+arg_0]
.text:0000B579                 mov     [edx], eax
.text:0000B57B                 mov     eax, [ebp+arg_0]
.text:0000B57E                 pop     esi
.text:0000B57F                 add     esp, 4
.text:0000B582                 cmp     ebp, esp
.text:0000B584                 call    __RTC_CheckEsp
.text:0000B589                 mov     esp, ebp
.text:0000B58B                 pop     ebp
.text:0000B58C                 retn    4
.text:0000B58C ??4?$CMyComPtr@UISequentialOutStream@@@@QAEPAUISequentialOutStream@@PAU1@@Z endp
.text:0000B58C
.text:0000B58C ; ---------------------------------------------------------------------------
.text:0000B58F                 align 10h
.text:0000B58F _text           ends
.text:0000B58F
.text:0000B590 ; ===========================================================================
.text:0000B590
.text:0000B590 ; Segment type: Pure code
.text:0000B590 ; Segment permissions: Read/Execute
.text:0000B590 _text           segment para public 'CODE' use32
.text:0000B590                 assume cs:_text
.text:0000B590                 ;org 0B590h
.text:0000B590 ; COMDAT (pick any)
.text:0000B590                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B590
.text:0000B590 ; =============== S U B R O U T I N E =======================================
.text:0000B590
.text:0000B590 ; Attributes: bp-based frame
.text:0000B590
.text:0000B590 ; public: struct ISequentialOutStream * __thiscall CMyComPtr<struct ISequentialOutStream>::operator=(class CMyComPtr<struct ISequentialOutStream> const &)
.text:0000B590                 public ??4?$CMyComPtr@UISequentialOutStream@@@@QAEPAUISequentialOutStream@@ABV0@@Z
.text:0000B590 ??4?$CMyComPtr@UISequentialOutStream@@@@QAEPAUISequentialOutStream@@ABV0@@Z proc near
.text:0000B590                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+103Dp
.text:0000B590                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+150Dp ...
.text:0000B590
.text:0000B590 var_4           = dword ptr -4
.text:0000B590 arg_0           = dword ptr  8
.text:0000B590
.text:0000B590                 push    ebp
.text:0000B591                 mov     ebp, esp
.text:0000B593                 push    ecx
.text:0000B594                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B59B                 mov     [ebp+var_4], ecx
.text:0000B59E                 mov     eax, [ebp+arg_0]
.text:0000B5A1                 mov     ecx, [eax]
.text:0000B5A3                 push    ecx
.text:0000B5A4                 mov     ecx, [ebp+var_4]
.text:0000B5A7                 call    ??4?$CMyComPtr@UISequentialOutStream@@@@QAEPAUISequentialOutStream@@PAU1@@Z ; CMyComPtr<ISequentialOutStream>::operator=(ISequentialOutStream *)
.text:0000B5AC                 add     esp, 4
.text:0000B5AF                 cmp     ebp, esp
.text:0000B5B1                 call    __RTC_CheckEsp
.text:0000B5B6                 mov     esp, ebp
.text:0000B5B8                 pop     ebp
.text:0000B5B9                 retn    4
.text:0000B5B9 ??4?$CMyComPtr@UISequentialOutStream@@@@QAEPAUISequentialOutStream@@ABV0@@Z endp
.text:0000B5B9
.text:0000B5B9 _text           ends
.text:0000B5B9
.text:0000B5BC ; ===========================================================================
.text:0000B5BC
.text:0000B5BC ; Segment type: Pure code
.text:0000B5BC ; Segment permissions: Read/Execute
.text:0000B5BC _text           segment para public 'CODE' use32
.text:0000B5BC                 assume cs:_text
.text:0000B5BC                 ;org 0B5BCh
.text:0000B5BC ; COMDAT (pick any)
.text:0000B5BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B5BC
.text:0000B5BC ; =============== S U B R O U T I N E =======================================
.text:0000B5BC
.text:0000B5BC ; Attributes: bp-based frame
.text:0000B5BC
.text:0000B5BC ; public: __thiscall CMyComPtr<struct IOutStream>::CMyComPtr<struct IOutStream>(void)
.text:0000B5BC                 public ??0?$CMyComPtr@UIOutStream@@@@QAE@XZ
.text:0000B5BC ??0?$CMyComPtr@UIOutStream@@@@QAE@XZ proc near
.text:0000B5BC                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+814p
.text:0000B5BC                                         ; COutMultiVolStream::CAltStreamInfo::CAltStreamInfo(void)+33p ...
.text:0000B5BC
.text:0000B5BC var_4           = dword ptr -4
.text:0000B5BC
.text:0000B5BC                 push    ebp
.text:0000B5BD                 mov     ebp, esp
.text:0000B5BF                 push    ecx
.text:0000B5C0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B5C7                 mov     [ebp+var_4], ecx
.text:0000B5CA                 mov     eax, [ebp+var_4]
.text:0000B5CD                 mov     dword ptr [eax], 0
.text:0000B5D3                 mov     eax, [ebp+var_4]
.text:0000B5D6                 mov     esp, ebp
.text:0000B5D8                 pop     ebp
.text:0000B5D9                 retn
.text:0000B5D9 ??0?$CMyComPtr@UIOutStream@@@@QAE@XZ endp
.text:0000B5D9
.text:0000B5D9 ; ---------------------------------------------------------------------------
.text:0000B5DA                 align 4
.text:0000B5DA _text           ends
.text:0000B5DA
.text:0000B5DC ; ===========================================================================
.text:0000B5DC
.text:0000B5DC ; Segment type: Pure code
.text:0000B5DC ; Segment permissions: Read/Execute
.text:0000B5DC _text           segment para public 'CODE' use32
.text:0000B5DC                 assume cs:_text
.text:0000B5DC                 ;org 0B5DCh
.text:0000B5DC ; COMDAT (pick any)
.text:0000B5DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B5DC
.text:0000B5DC ; =============== S U B R O U T I N E =======================================
.text:0000B5DC
.text:0000B5DC ; Attributes: bp-based frame
.text:0000B5DC
.text:0000B5DC ; public: __thiscall CMyComPtr<struct IOutStream>::~CMyComPtr<struct IOutStream>(void)
.text:0000B5DC                 public ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ
.text:0000B5DC ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ proc near
.text:0000B5DC                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+BD6p
.text:0000B5DC                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+C61p ...
.text:0000B5DC
.text:0000B5DC var_4           = dword ptr -4
.text:0000B5DC
.text:0000B5DC                 push    ebp
.text:0000B5DD                 mov     ebp, esp
.text:0000B5DF                 push    ecx
.text:0000B5E0                 push    esi
.text:0000B5E1                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B5E8                 mov     [ebp+var_4], ecx
.text:0000B5EB                 mov     eax, [ebp+var_4]
.text:0000B5EE                 cmp     dword ptr [eax], 0
.text:0000B5F1                 jz      short loc_B60E
.text:0000B5F3                 mov     ecx, [ebp+var_4]
.text:0000B5F6                 mov     edx, [ecx]
.text:0000B5F8                 mov     eax, [ebp+var_4]
.text:0000B5FB                 mov     ecx, [eax]
.text:0000B5FD                 mov     edx, [edx]
.text:0000B5FF                 mov     esi, esp
.text:0000B601                 push    ecx
.text:0000B602                 mov     eax, [edx+8]
.text:0000B605                 call    eax
.text:0000B607                 cmp     esi, esp
.text:0000B609                 call    __RTC_CheckEsp
.text:0000B60E
.text:0000B60E loc_B60E:                               ; CODE XREF: CMyComPtr<IOutStream>::~CMyComPtr<IOutStream>(void)+15j
.text:0000B60E                 pop     esi
.text:0000B60F                 add     esp, 4
.text:0000B612                 cmp     ebp, esp
.text:0000B614                 call    __RTC_CheckEsp
.text:0000B619                 mov     esp, ebp
.text:0000B61B                 pop     ebp
.text:0000B61C                 retn
.text:0000B61C ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ endp
.text:0000B61C
.text:0000B61C ; ---------------------------------------------------------------------------
.text:0000B61D                 align 10h
.text:0000B61D _text           ends
.text:0000B61D
.text:0000B620 ; ===========================================================================
.text:0000B620
.text:0000B620 ; Segment type: Pure code
.text:0000B620 ; Segment permissions: Read/Execute
.text:0000B620 _text           segment para public 'CODE' use32
.text:0000B620                 assume cs:_text
.text:0000B620                 ;org 0B620h
.text:0000B620 ; COMDAT (pick any)
.text:0000B620                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B620
.text:0000B620 ; =============== S U B R O U T I N E =======================================
.text:0000B620
.text:0000B620 ; Attributes: bp-based frame
.text:0000B620
.text:0000B620 ; public: void __thiscall CMyComPtr<struct IOutStream>::Release(void)
.text:0000B620                 public ?Release@?$CMyComPtr@UIOutStream@@@@QAEXXZ
.text:0000B620 ?Release@?$CMyComPtr@UIOutStream@@@@QAEXXZ proc near
.text:0000B620                                         ; CODE XREF: COutMultiVolStream::SetSize(unsigned __int64)+120p
.text:0000B620
.text:0000B620 var_4           = dword ptr -4
.text:0000B620
.text:0000B620                 push    ebp
.text:0000B621                 mov     ebp, esp
.text:0000B623                 push    ecx
.text:0000B624                 push    esi
.text:0000B625                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B62C                 mov     [ebp+var_4], ecx
.text:0000B62F                 mov     eax, [ebp+var_4]
.text:0000B632                 cmp     dword ptr [eax], 0
.text:0000B635                 jz      short loc_B65B
.text:0000B637                 mov     ecx, [ebp+var_4]
.text:0000B63A                 mov     edx, [ecx]
.text:0000B63C                 mov     eax, [ebp+var_4]
.text:0000B63F                 mov     ecx, [eax]
.text:0000B641                 mov     edx, [edx]
.text:0000B643                 mov     esi, esp
.text:0000B645                 push    ecx
.text:0000B646                 mov     eax, [edx+8]
.text:0000B649                 call    eax
.text:0000B64B                 cmp     esi, esp
.text:0000B64D                 call    __RTC_CheckEsp
.text:0000B652                 mov     ecx, [ebp+var_4]
.text:0000B655                 mov     dword ptr [ecx], 0
.text:0000B65B
.text:0000B65B loc_B65B:                               ; CODE XREF: CMyComPtr<IOutStream>::Release(void)+15j
.text:0000B65B                 pop     esi
.text:0000B65C                 add     esp, 4
.text:0000B65F                 cmp     ebp, esp
.text:0000B661                 call    __RTC_CheckEsp
.text:0000B666                 mov     esp, ebp
.text:0000B668                 pop     ebp
.text:0000B669                 retn
.text:0000B669 ?Release@?$CMyComPtr@UIOutStream@@@@QAEXXZ endp
.text:0000B669
.text:0000B669 ; ---------------------------------------------------------------------------
.text:0000B66A                 align 4
.text:0000B66A _text           ends
.text:0000B66A
.text:0000B66C ; ===========================================================================
.text:0000B66C
.text:0000B66C ; Segment type: Pure code
.text:0000B66C ; Segment permissions: Read/Execute
.text:0000B66C _text           segment para public 'CODE' use32
.text:0000B66C                 assume cs:_text
.text:0000B66C                 ;org 0B66Ch
.text:0000B66C ; COMDAT (pick any)
.text:0000B66C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B66C
.text:0000B66C ; =============== S U B R O U T I N E =======================================
.text:0000B66C
.text:0000B66C ; Attributes: bp-based frame
.text:0000B66C
.text:0000B66C ; public: __thiscall CMyComPtr<struct IOutStream>::operator struct IOutStream *(void)const
.text:0000B66C                 public ??B?$CMyComPtr@UIOutStream@@@@QBEPAUIOutStream@@XZ
.text:0000B66C ??B?$CMyComPtr@UIOutStream@@@@QBEPAUIOutStream@@XZ proc near
.text:0000B66C                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+A0Cp
.text:0000B66C                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+DB0p
.text:0000B66C
.text:0000B66C var_4           = dword ptr -4
.text:0000B66C
.text:0000B66C                 push    ebp
.text:0000B66D                 mov     ebp, esp
.text:0000B66F                 push    ecx
.text:0000B670                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B677                 mov     [ebp+var_4], ecx
.text:0000B67A                 mov     eax, [ebp+var_4]
.text:0000B67D                 mov     eax, [eax]
.text:0000B67F                 mov     esp, ebp
.text:0000B681                 pop     ebp
.text:0000B682                 retn
.text:0000B682 ??B?$CMyComPtr@UIOutStream@@@@QBEPAUIOutStream@@XZ endp
.text:0000B682
.text:0000B682 ; ---------------------------------------------------------------------------
.text:0000B683                 align 4
.text:0000B683 _text           ends
.text:0000B683
.text:0000B684 ; ===========================================================================
.text:0000B684
.text:0000B684 ; Segment type: Pure code
.text:0000B684 ; Segment permissions: Read/Execute
.text:0000B684 _text           segment para public 'CODE' use32
.text:0000B684                 assume cs:_text
.text:0000B684                 ;org 0B684h
.text:0000B684 ; COMDAT (pick any)
.text:0000B684                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B684
.text:0000B684 ; =============== S U B R O U T I N E =======================================
.text:0000B684
.text:0000B684 ; Attributes: bp-based frame
.text:0000B684
.text:0000B684 ; public: struct IOutStream * __thiscall CMyComPtr<struct IOutStream>::operator->(void)const
.text:0000B684                 public ??C?$CMyComPtr@UIOutStream@@@@QBEPAUIOutStream@@XZ
.text:0000B684 ??C?$CMyComPtr@UIOutStream@@@@QBEPAUIOutStream@@XZ proc near
.text:0000B684                                         ; CODE XREF: COutMultiVolStream::Write(void const *,uint,uint *)+290p
.text:0000B684                                         ; COutMultiVolStream::Write(void const *,uint,uint *)+31Cp ...
.text:0000B684
.text:0000B684 var_4           = dword ptr -4
.text:0000B684
.text:0000B684                 push    ebp
.text:0000B685                 mov     ebp, esp
.text:0000B687                 push    ecx
.text:0000B688                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B68F                 mov     [ebp+var_4], ecx
.text:0000B692                 mov     eax, [ebp+var_4]
.text:0000B695                 mov     eax, [eax]
.text:0000B697                 mov     esp, ebp
.text:0000B699                 pop     ebp
.text:0000B69A                 retn
.text:0000B69A ??C?$CMyComPtr@UIOutStream@@@@QBEPAUIOutStream@@XZ endp
.text:0000B69A
.text:0000B69A ; ---------------------------------------------------------------------------
.text:0000B69B                 align 4
.text:0000B69B _text           ends
.text:0000B69B
.text:0000B69C ; ===========================================================================
.text:0000B69C
.text:0000B69C ; Segment type: Pure code
.text:0000B69C ; Segment permissions: Read/Execute
.text:0000B69C _text           segment para public 'CODE' use32
.text:0000B69C                 assume cs:_text
.text:0000B69C                 ;org 0B69Ch
.text:0000B69C ; COMDAT (pick any)
.text:0000B69C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B69C
.text:0000B69C ; =============== S U B R O U T I N E =======================================
.text:0000B69C
.text:0000B69C ; Attributes: bp-based frame
.text:0000B69C
.text:0000B69C ; public: struct IOutStream * __thiscall CMyComPtr<struct IOutStream>::operator=(struct IOutStream *)
.text:0000B69C                 public ??4?$CMyComPtr@UIOutStream@@@@QAEPAUIOutStream@@PAU1@@Z
.text:0000B69C ??4?$CMyComPtr@UIOutStream@@@@QAEPAUIOutStream@@PAU1@@Z proc near
.text:0000B69C                                         ; CODE XREF: COutMultiVolStream::Write(void const *,uint,uint *)+FAp
.text:0000B69C                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+A01p ...
.text:0000B69C
.text:0000B69C var_4           = dword ptr -4
.text:0000B69C arg_0           = dword ptr  8
.text:0000B69C
.text:0000B69C                 push    ebp
.text:0000B69D                 mov     ebp, esp
.text:0000B69F                 push    ecx
.text:0000B6A0                 push    esi
.text:0000B6A1                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B6A8                 mov     [ebp+var_4], ecx
.text:0000B6AB                 cmp     [ebp+arg_0], 0
.text:0000B6AF                 jz      short loc_B6C8
.text:0000B6B1                 mov     eax, [ebp+arg_0]
.text:0000B6B4                 mov     ecx, [eax]
.text:0000B6B6                 mov     esi, esp
.text:0000B6B8                 mov     edx, [ebp+arg_0]
.text:0000B6BB                 push    edx
.text:0000B6BC                 mov     eax, [ecx+4]
.text:0000B6BF                 call    eax
.text:0000B6C1                 cmp     esi, esp
.text:0000B6C3                 call    __RTC_CheckEsp
.text:0000B6C8
.text:0000B6C8 loc_B6C8:                               ; CODE XREF: CMyComPtr<IOutStream>::operator=(IOutStream *)+13j
.text:0000B6C8                 mov     ecx, [ebp+var_4]
.text:0000B6CB                 cmp     dword ptr [ecx], 0
.text:0000B6CE                 jz      short loc_B6EB
.text:0000B6D0                 mov     edx, [ebp+var_4]
.text:0000B6D3                 mov     eax, [edx]
.text:0000B6D5                 mov     ecx, [ebp+var_4]
.text:0000B6D8                 mov     edx, [ecx]
.text:0000B6DA                 mov     eax, [eax]
.text:0000B6DC                 mov     esi, esp
.text:0000B6DE                 push    edx
.text:0000B6DF                 mov     ecx, [eax+8]
.text:0000B6E2                 call    ecx
.text:0000B6E4                 cmp     esi, esp
.text:0000B6E6                 call    __RTC_CheckEsp
.text:0000B6EB
.text:0000B6EB loc_B6EB:                               ; CODE XREF: CMyComPtr<IOutStream>::operator=(IOutStream *)+32j
.text:0000B6EB                 mov     edx, [ebp+var_4]
.text:0000B6EE                 mov     eax, [ebp+arg_0]
.text:0000B6F1                 mov     [edx], eax
.text:0000B6F3                 mov     eax, [ebp+arg_0]
.text:0000B6F6                 pop     esi
.text:0000B6F7                 add     esp, 4
.text:0000B6FA                 cmp     ebp, esp
.text:0000B6FC                 call    __RTC_CheckEsp
.text:0000B701                 mov     esp, ebp
.text:0000B703                 pop     ebp
.text:0000B704                 retn    4
.text:0000B704 ??4?$CMyComPtr@UIOutStream@@@@QAEPAUIOutStream@@PAU1@@Z endp
.text:0000B704
.text:0000B704 ; ---------------------------------------------------------------------------
.text:0000B707                 align 4
.text:0000B707 _text           ends
.text:0000B707
.text:0000B708 ; ===========================================================================
.text:0000B708
.text:0000B708 ; Segment type: Pure code
.text:0000B708 ; Segment permissions: Read/Execute
.text:0000B708 _text           segment para public 'CODE' use32
.text:0000B708                 assume cs:_text
.text:0000B708                 ;org 0B708h
.text:0000B708 ; COMDAT (pick any)
.text:0000B708                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B708
.text:0000B708 ; =============== S U B R O U T I N E =======================================
.text:0000B708
.text:0000B708 ; Attributes: bp-based frame
.text:0000B708
.text:0000B708 ; public: struct IOutStream * __thiscall CMyComPtr<struct IOutStream>::operator=(class CMyComPtr<struct IOutStream> const &)
.text:0000B708                 public ??4?$CMyComPtr@UIOutStream@@@@QAEPAUIOutStream@@ABV0@@Z
.text:0000B708 ??4?$CMyComPtr@UIOutStream@@@@QAEPAUIOutStream@@ABV0@@Z proc near
.text:0000B708                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+172Cp
.text:0000B708
.text:0000B708 var_4           = dword ptr -4
.text:0000B708 arg_0           = dword ptr  8
.text:0000B708
.text:0000B708                 push    ebp
.text:0000B709                 mov     ebp, esp
.text:0000B70B                 push    ecx
.text:0000B70C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B713                 mov     [ebp+var_4], ecx
.text:0000B716                 mov     eax, [ebp+arg_0]
.text:0000B719                 mov     ecx, [eax]
.text:0000B71B                 push    ecx
.text:0000B71C                 mov     ecx, [ebp+var_4]
.text:0000B71F                 call    ??4?$CMyComPtr@UIOutStream@@@@QAEPAUIOutStream@@PAU1@@Z ; CMyComPtr<IOutStream>::operator=(IOutStream *)
.text:0000B724                 add     esp, 4
.text:0000B727                 cmp     ebp, esp
.text:0000B729                 call    __RTC_CheckEsp
.text:0000B72E                 mov     esp, ebp
.text:0000B730                 pop     ebp
.text:0000B731                 retn    4
.text:0000B731 ??4?$CMyComPtr@UIOutStream@@@@QAEPAUIOutStream@@ABV0@@Z endp
.text:0000B731
.text:0000B731 _text           ends
.text:0000B731
.text:0000B734 ; ===========================================================================
.text:0000B734
.text:0000B734 ; Segment type: Pure code
.text:0000B734 ; Segment permissions: Read/Execute
.text:0000B734 _text           segment para public 'CODE' use32
.text:0000B734                 assume cs:_text
.text:0000B734                 ;org 0B734h
.text:0000B734 ; COMDAT (pick any)
.text:0000B734                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B734
.text:0000B734 ; =============== S U B R O U T I N E =======================================
.text:0000B734
.text:0000B734 ; Attributes: bp-based frame
.text:0000B734
.text:0000B734 ; public: unsigned int __thiscall CObjectVector<struct COutMultiVolStream::CAltStreamInfo>::Size(void)const
.text:0000B734                 public ?Size@?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QBEIXZ
.text:0000B734 ?Size@?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QBEIXZ proc near
.text:0000B734                                         ; CODE XREF: COutMultiVolStream::Close(void)+3Cp
.text:0000B734                                         ; COutMultiVolStream::SetMTime(_FILETIME const *)+36p ...
.text:0000B734
.text:0000B734 var_4           = dword ptr -4
.text:0000B734
.text:0000B734                 push    ebp
.text:0000B735                 mov     ebp, esp
.text:0000B737                 push    ecx
.text:0000B738                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B73F                 mov     [ebp+var_4], ecx
.text:0000B742                 mov     ecx, [ebp+var_4]
.text:0000B745                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:0000B74A                 add     esp, 4
.text:0000B74D                 cmp     ebp, esp
.text:0000B74F                 call    __RTC_CheckEsp
.text:0000B754                 mov     esp, ebp
.text:0000B756                 pop     ebp
.text:0000B757                 retn
.text:0000B757 ?Size@?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QBEIXZ endp
.text:0000B757
.text:0000B757 _text           ends
.text:0000B757
.text:0000B758 ; ===========================================================================
.text:0000B758
.text:0000B758 ; Segment type: Pure code
.text:0000B758 ; Segment permissions: Read/Execute
.text:0000B758 _text           segment para public 'CODE' use32
.text:0000B758                 assume cs:_text
.text:0000B758                 ;org 0B758h
.text:0000B758 ; COMDAT (pick any)
.text:0000B758                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B758
.text:0000B758 ; =============== S U B R O U T I N E =======================================
.text:0000B758
.text:0000B758 ; Attributes: bp-based frame
.text:0000B758
.text:0000B758 ; public: __thiscall CObjectVector<struct COutMultiVolStream::CAltStreamInfo>::CObjectVector<struct COutMultiVolStream::CAltStreamInfo>(void)
.text:0000B758                 public ??0?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAE@XZ
.text:0000B758 ??0?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAE@XZ proc near
.text:0000B758                                         ; CODE XREF: COutMultiVolStream::COutMultiVolStream(void)+4Fp
.text:0000B758
.text:0000B758 var_4           = dword ptr -4
.text:0000B758
.text:0000B758                 push    ebp
.text:0000B759                 mov     ebp, esp
.text:0000B75B                 push    ecx
.text:0000B75C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B763                 mov     [ebp+var_4], ecx
.text:0000B766                 mov     ecx, [ebp+var_4]
.text:0000B769                 call    ??0?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::CRecordVector<void *>(void)
.text:0000B76E                 mov     eax, [ebp+var_4]
.text:0000B771                 add     esp, 4
.text:0000B774                 cmp     ebp, esp
.text:0000B776                 call    __RTC_CheckEsp
.text:0000B77B                 mov     esp, ebp
.text:0000B77D                 pop     ebp
.text:0000B77E                 retn
.text:0000B77E ??0?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAE@XZ endp
.text:0000B77E
.text:0000B77E ; ---------------------------------------------------------------------------
.text:0000B77F                 align 10h
.text:0000B77F _text           ends
.text:0000B77F
.text:0000B780 ; ===========================================================================
.text:0000B780
.text:0000B780 ; Segment type: Pure code
.text:0000B780 ; Segment permissions: Read/Execute
.text:0000B780 _text           segment para public 'CODE' use32
.text:0000B780                 assume cs:_text
.text:0000B780                 ;org 0B780h
.text:0000B780 ; COMDAT (pick any)
.text:0000B780                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B780
.text:0000B780 ; =============== S U B R O U T I N E =======================================
.text:0000B780
.text:0000B780 ; Attributes: bp-based frame
.text:0000B780
.text:0000B780 ; public: struct COutMultiVolStream::CAltStreamInfo & __thiscall CObjectVector<struct COutMultiVolStream::CAltStreamInfo>::operator[](unsigned int)
.text:0000B780                 public ??A?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAEAAUCAltStreamInfo@COutMultiVolStream@@I@Z
.text:0000B780 ??A?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAEAAUCAltStreamInfo@COutMultiVolStream@@I@Z proc near
.text:0000B780                                         ; CODE XREF: COutMultiVolStream::Close(void)+50p
.text:0000B780                                         ; COutMultiVolStream::SetMTime(_FILETIME const *)+4Ap ...
.text:0000B780
.text:0000B780 var_4           = dword ptr -4
.text:0000B780 arg_0           = dword ptr  8
.text:0000B780
.text:0000B780                 push    ebp
.text:0000B781                 mov     ebp, esp
.text:0000B783                 push    ecx
.text:0000B784                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B78B                 mov     [ebp+var_4], ecx
.text:0000B78E                 mov     eax, [ebp+arg_0]
.text:0000B791                 push    eax
.text:0000B792                 mov     ecx, [ebp+var_4]
.text:0000B795                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:0000B79A                 mov     eax, [eax]
.text:0000B79C                 add     esp, 4
.text:0000B79F                 cmp     ebp, esp
.text:0000B7A1                 call    __RTC_CheckEsp
.text:0000B7A6                 mov     esp, ebp
.text:0000B7A8                 pop     ebp
.text:0000B7A9                 retn    4
.text:0000B7A9 ??A?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAEAAUCAltStreamInfo@COutMultiVolStream@@I@Z endp
.text:0000B7A9
.text:0000B7A9 _text           ends
.text:0000B7A9
.text:0000B7AC ; ===========================================================================
.text:0000B7AC
.text:0000B7AC ; Segment type: Pure code
.text:0000B7AC ; Segment permissions: Read/Execute
.text:0000B7AC _text           segment para public 'CODE' use32
.text:0000B7AC                 assume cs:_text
.text:0000B7AC                 ;org 0B7ACh
.text:0000B7AC ; COMDAT (pick any)
.text:0000B7AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B7AC
.text:0000B7AC ; =============== S U B R O U T I N E =======================================
.text:0000B7AC
.text:0000B7AC ; Attributes: bp-based frame
.text:0000B7AC
.text:0000B7AC ; public: struct COutMultiVolStream::CAltStreamInfo & __thiscall CObjectVector<struct COutMultiVolStream::CAltStreamInfo>::Back(void)
.text:0000B7AC                 public ?Back@?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAEAAUCAltStreamInfo@COutMultiVolStream@@XZ
.text:0000B7AC ?Back@?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAEAAUCAltStreamInfo@COutMultiVolStream@@XZ proc near
.text:0000B7AC                                         ; CODE XREF: COutMultiVolStream::SetSize(unsigned __int64)+112p
.text:0000B7AC
.text:0000B7AC var_4           = dword ptr -4
.text:0000B7AC
.text:0000B7AC                 push    ebp
.text:0000B7AD                 mov     ebp, esp
.text:0000B7AF                 push    ecx
.text:0000B7B0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000B7B7                 mov     [ebp+var_4], ecx
.text:0000B7BA                 mov     ecx, [ebp+var_4]
.text:0000B7BD                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:0000B7C2                 sub     eax, 1
.text:0000B7C5                 push    eax
.text:0000B7C6                 mov     ecx, [ebp+var_4]
.text:0000B7C9                 call    ??A?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAEAAUCAltStreamInfo@COutMultiVolStream@@I@Z ; CObjectVector<COutMultiVolStream::CAltStreamInfo>::operator[](uint)
.text:0000B7CE                 add     esp, 4
.text:0000B7D1                 cmp     ebp, esp
.text:0000B7D3                 call    __RTC_CheckEsp
.text:0000B7D8                 mov     esp, ebp
.text:0000B7DA                 pop     ebp
.text:0000B7DB                 retn
.text:0000B7DB ?Back@?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAEAAUCAltStreamInfo@COutMultiVolStream@@XZ endp
.text:0000B7DB
.text:0000B7DB _text           ends
.text:0000B7DB
.text:0000B7DC ; ===========================================================================
.text:0000B7DC
.text:0000B7DC ; Segment type: Pure code
.text:0000B7DC ; Segment permissions: Read/Execute
.text:0000B7DC _text           segment para public 'CODE' use32
.text:0000B7DC                 assume cs:_text
.text:0000B7DC                 ;org 0B7DCh
.text:0000B7DC ; COMDAT (pick any)
.text:0000B7DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B7DC
.text:0000B7DC ; =============== S U B R O U T I N E =======================================
.text:0000B7DC
.text:0000B7DC ; Attributes: bp-based frame
.text:0000B7DC
.text:0000B7DC ; int __stdcall CObjectVector<COutMultiVolStream::CAltStreamInfo>::Add(struct COutMultiVolStream::CAltStreamInfo *)
.text:0000B7DC                 public ?Add@?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAEIABUCAltStreamInfo@COutMultiVolStream@@@Z
.text:0000B7DC ?Add@?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAEIABUCAltStreamInfo@COutMultiVolStream@@@Z proc near
.text:0000B7DC                                         ; CODE XREF: COutMultiVolStream::Write(void const *,uint,uint *)+18Ap
.text:0000B7DC
.text:0000B7DC var_1C          = dword ptr -1Ch
.text:0000B7DC var_18          = dword ptr -18h
.text:0000B7DC var_14          = dword ptr -14h
.text:0000B7DC var_10          = dword ptr -10h
.text:0000B7DC var_C           = dword ptr -0Ch
.text:0000B7DC var_4           = dword ptr -4
.text:0000B7DC arg_0           = dword ptr  8
.text:0000B7DC
.text:0000B7DC                 push    ebp
.text:0000B7DD                 mov     ebp, esp
.text:0000B7DF                 push    0FFFFFFFFh
.text:0000B7E1                 push    offset __ehhandler$?Add@?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAEIABUCAltStreamInfo@COutMultiVolStream@@@Z
.text:0000B7E6                 mov     eax, large fs:0
.text:0000B7EC                 push    eax
.text:0000B7ED                 sub     esp, 10h
.text:0000B7F0                 mov     eax, 0CCCCCCCCh
.text:0000B7F5                 mov     [ebp+var_1C], eax
.text:0000B7F8                 mov     [ebp+var_18], eax
.text:0000B7FB                 mov     [ebp+var_14], eax
.text:0000B7FE                 mov     [ebp+var_10], eax
.text:0000B801                 mov     eax, dword ptr ds:___security_cookie
.text:0000B806                 xor     eax, ebp
.text:0000B808                 push    eax
.text:0000B809                 lea     eax, [ebp+var_C]
.text:0000B80C                 mov     large fs:0, eax
.text:0000B812                 mov     [ebp+var_10], ecx
.text:0000B815                 push    28h ; '('       ; unsigned int
.text:0000B817                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0000B81C                 add     esp, 4
.text:0000B81F                 mov     [ebp+var_18], eax
.text:0000B822                 mov     [ebp+var_4], 0
.text:0000B829                 cmp     [ebp+var_18], 0
.text:0000B82D                 jz      short loc_B840
.text:0000B82F                 mov     eax, [ebp+arg_0]
.text:0000B832                 push    eax             ; struct COutMultiVolStream::CAltStreamInfo *
.text:0000B833                 mov     ecx, [ebp+var_18] ; this
.text:0000B836                 call    ??0CAltStreamInfo@COutMultiVolStream@@QAE@ABU01@@Z ; COutMultiVolStream::CAltStreamInfo::CAltStreamInfo(COutMultiVolStream::CAltStreamInfo const &)
.text:0000B83B                 mov     [ebp+var_1C], eax
.text:0000B83E                 jmp     short loc_B847
.text:0000B840 ; ---------------------------------------------------------------------------
.text:0000B840
.text:0000B840 loc_B840:                               ; CODE XREF: CObjectVector<COutMultiVolStream::CAltStreamInfo>::Add(COutMultiVolStream::CAltStreamInfo const &)+51j
.text:0000B840                 mov     [ebp+var_1C], 0
.text:0000B847
.text:0000B847 loc_B847:                               ; CODE XREF: CObjectVector<COutMultiVolStream::CAltStreamInfo>::Add(COutMultiVolStream::CAltStreamInfo const &)+62j
.text:0000B847                 mov     ecx, [ebp+var_1C]
.text:0000B84A                 mov     [ebp+var_14], ecx
.text:0000B84D                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000B854                 mov     edx, [ebp+var_14]
.text:0000B857                 push    edx
.text:0000B858                 mov     ecx, [ebp+var_10]
.text:0000B85B                 call    ?Add@?$CRecordVector@PAX@@QAEIQAX@Z ; CRecordVector<void *>::Add(void * const)
.text:0000B860                 mov     ecx, [ebp+var_C]
.text:0000B863                 mov     large fs:0, ecx
.text:0000B86A                 pop     ecx
.text:0000B86B                 add     esp, 1Ch
.text:0000B86E                 cmp     ebp, esp
.text:0000B870                 call    __RTC_CheckEsp
.text:0000B875                 mov     esp, ebp
.text:0000B877                 pop     ebp
.text:0000B878                 retn    4
.text:0000B878 ?Add@?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAEIABUCAltStreamInfo@COutMultiVolStream@@@Z endp
.text:0000B878
.text:0000B878 ; ---------------------------------------------------------------------------
.text:0000B87B                 align 4
.text:0000B87B _text           ends
.text:0000B87B
.text$x:0000B87C ; ===========================================================================
.text$x:0000B87C
.text$x:0000B87C ; Segment type: Pure code
.text$x:0000B87C ; Segment permissions: Read/Execute
.text$x:0000B87C _text$x         segment para public 'CODE' use32
.text$x:0000B87C                 assume cs:_text$x
.text$x:0000B87C                 ;org 0B87Ch
.text$x:0000B87C ; COMDAT (pick associative to section at B7DC)
.text$x:0000B87C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000B87C
.text$x:0000B87C ; =============== S U B R O U T I N E =======================================
.text$x:0000B87C
.text$x:0000B87C
.text$x:0000B87C __unwindfunclet$?Add@?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAEIABUCAltStreamInfo@COutMultiVolStream@@@Z$0 proc near
.text$x:0000B87C                                         ; DATA XREF: .xdata$x:0000B8A8o
.text$x:0000B87C                 mov     eax, [ebp-18h]
.text$x:0000B87F                 push    eax             ; void *
.text$x:0000B880                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:0000B885                 pop     ecx
.text$x:0000B886                 retn
.text$x:0000B886 __unwindfunclet$?Add@?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAEIABUCAltStreamInfo@COutMultiVolStream@@@Z$0 endp
.text$x:0000B886
.text$x:0000B887
.text$x:0000B887 ; =============== S U B R O U T I N E =======================================
.text$x:0000B887
.text$x:0000B887
.text$x:0000B887 __ehhandler$?Add@?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAEIABUCAltStreamInfo@COutMultiVolStream@@@Z proc near
.text$x:0000B887                                         ; DATA XREF: CObjectVector<COutMultiVolStream::CAltStreamInfo>::Add(COutMultiVolStream::CAltStreamInfo const &)+5o
.text$x:0000B887
.text$x:0000B887 arg_4           = dword ptr  8
.text$x:0000B887
.text$x:0000B887                 mov     edx, [esp+arg_4]
.text$x:0000B88B                 lea     eax, [edx+0Ch]
.text$x:0000B88E                 mov     ecx, [edx-14h]
.text$x:0000B891                 xor     ecx, eax
.text$x:0000B893                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B898                 mov     eax, offset __ehfuncinfo$?Add@?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAEIABUCAltStreamInfo@COutMultiVolStream@@@Z
.text$x:0000B89D                 jmp     ___CxxFrameHandler3
.text$x:0000B89D __ehhandler$?Add@?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAEIABUCAltStreamInfo@COutMultiVolStream@@@Z endp
.text$x:0000B89D
.text$x:0000B89D ; ---------------------------------------------------------------------------
.text$x:0000B8A2                 align 4
.text$x:0000B8A2 _text$x         ends
.text$x:0000B8A2
.xdata$x:0000B8A4 ; ===========================================================================
.xdata$x:0000B8A4
.xdata$x:0000B8A4 ; Segment type: Pure data
.xdata$x:0000B8A4 ; Segment permissions: Read
.xdata$x:0000B8A4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000B8A4                 assume cs:_xdata$x
.xdata$x:0000B8A4                 ;org 0B8A4h
.xdata$x:0000B8A4 ; COMDAT (pick associative to section at B7DC)
.xdata$x:0000B8A4 __unwindtable$?Add@?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAEIABUCAltStreamInfo@COutMultiVolStream@@@Z db 0FFh
.xdata$x:0000B8A4                                         ; DATA XREF: .xdata$x:0000B8B4o
.xdata$x:0000B8A5                 db 0FFh
.xdata$x:0000B8A6                 db 0FFh
.xdata$x:0000B8A7                 db 0FFh
.xdata$x:0000B8A8                 dd offset __unwindfunclet$?Add@?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAEIABUCAltStreamInfo@COutMultiVolStream@@@Z$0
.xdata$x:0000B8AC __ehfuncinfo$?Add@?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAEIABUCAltStreamInfo@COutMultiVolStream@@@Z db  22h ; "
.xdata$x:0000B8AC                                         ; DATA XREF: __ehhandler$?Add@?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAEIABUCAltStreamInfo@COutMultiVolStream@@@Z+11o
.xdata$x:0000B8AD                 db    5
.xdata$x:0000B8AE                 db  93h ; 
.xdata$x:0000B8AF                 db  19h
.xdata$x:0000B8B0                 db    1
.xdata$x:0000B8B1                 db    0
.xdata$x:0000B8B2                 db    0
.xdata$x:0000B8B3                 db    0
.xdata$x:0000B8B4                 dd offset __unwindtable$?Add@?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAEIABUCAltStreamInfo@COutMultiVolStream@@@Z
.xdata$x:0000B8B8                 db    0
.xdata$x:0000B8B9                 db    0
.xdata$x:0000B8BA                 db    0
.xdata$x:0000B8BB                 db    0
.xdata$x:0000B8BC                 db    0
.xdata$x:0000B8BD                 db    0
.xdata$x:0000B8BE                 db    0
.xdata$x:0000B8BF                 db    0
.xdata$x:0000B8C0                 db    0
.xdata$x:0000B8C1                 db    0
.xdata$x:0000B8C2                 db    0
.xdata$x:0000B8C3                 db    0
.xdata$x:0000B8C4                 db    0
.xdata$x:0000B8C5                 db    0
.xdata$x:0000B8C6                 db    0
.xdata$x:0000B8C7                 db    0
.xdata$x:0000B8C8                 db    0
.xdata$x:0000B8C9                 db    0
.xdata$x:0000B8CA                 db    0
.xdata$x:0000B8CB                 db    0
.xdata$x:0000B8CC                 db    1
.xdata$x:0000B8CD                 db    0
.xdata$x:0000B8CE                 db    0
.xdata$x:0000B8CF                 db    0
.xdata$x:0000B8CF _xdata$x        ends
.xdata$x:0000B8CF
.text:0000B8D0 ; ===========================================================================
.text:0000B8D0
.text:0000B8D0 ; Segment type: Pure code
.text:0000B8D0 ; Segment permissions: Read/Execute
.text:0000B8D0 _text           segment para public 'CODE' use32
.text:0000B8D0                 assume cs:_text
.text:0000B8D0                 ;org 0B8D0h
.text:0000B8D0 ; COMDAT (pick any)
.text:0000B8D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B8D0
.text:0000B8D0 ; =============== S U B R O U T I N E =======================================
.text:0000B8D0
.text:0000B8D0 ; Attributes: bp-based frame
.text:0000B8D0
.text:0000B8D0 ; public: __thiscall CObjectVector<struct COutMultiVolStream::CAltStreamInfo>::~CObjectVector<struct COutMultiVolStream::CAltStreamInfo>(void)
.text:0000B8D0                 public ??1?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAE@XZ
.text:0000B8D0 ??1?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAE@XZ proc near
.text:0000B8D0                                         ; CODE XREF: __unwindfunclet$??0COutMultiVolStream@@QAE@XZ$0+6j
.text:0000B8D0                                         ; COutMultiVolStream::~COutMultiVolStream(void)+5Bp ...
.text:0000B8D0
.text:0000B8D0 var_20          = dword ptr -20h
.text:0000B8D0 var_1C          = dword ptr -1Ch
.text:0000B8D0 var_18          = dword ptr -18h
.text:0000B8D0 var_14          = dword ptr -14h
.text:0000B8D0 var_10          = dword ptr -10h
.text:0000B8D0 var_C           = dword ptr -0Ch
.text:0000B8D0 var_4           = dword ptr -4
.text:0000B8D0
.text:0000B8D0                 push    ebp
.text:0000B8D1                 mov     ebp, esp
.text:0000B8D3                 push    0FFFFFFFFh
.text:0000B8D5                 push    offset __ehhandler$??1?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAE@XZ
.text:0000B8DA                 mov     eax, large fs:0
.text:0000B8E0                 push    eax
.text:0000B8E1                 sub     esp, 14h
.text:0000B8E4                 mov     eax, 0CCCCCCCCh
.text:0000B8E9                 mov     [ebp+var_20], eax
.text:0000B8EC                 mov     [ebp+var_1C], eax
.text:0000B8EF                 mov     [ebp+var_18], eax
.text:0000B8F2                 mov     [ebp+var_14], eax
.text:0000B8F5                 mov     [ebp+var_10], eax
.text:0000B8F8                 mov     eax, dword ptr ds:___security_cookie
.text:0000B8FD                 xor     eax, ebp
.text:0000B8FF                 push    eax
.text:0000B900                 lea     eax, [ebp+var_C]
.text:0000B903                 mov     large fs:0, eax
.text:0000B909                 mov     [ebp+var_10], ecx
.text:0000B90C                 mov     [ebp+var_4], 0
.text:0000B913                 mov     ecx, [ebp+var_10]
.text:0000B916                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:0000B91B                 mov     [ebp+var_14], eax
.text:0000B91E
.text:0000B91E loc_B91E:                               ; CODE XREF: CObjectVector<COutMultiVolStream::CAltStreamInfo>::~CObjectVector<COutMultiVolStream::CAltStreamInfo>(void):loc_B960j
.text:0000B91E                 cmp     [ebp+var_14], 0
.text:0000B922                 jz      short loc_B962
.text:0000B924                 mov     eax, [ebp+var_14]
.text:0000B927                 sub     eax, 1
.text:0000B92A                 mov     [ebp+var_14], eax
.text:0000B92D                 mov     ecx, [ebp+var_14]
.text:0000B930                 push    ecx
.text:0000B931                 mov     ecx, [ebp+var_10]
.text:0000B934                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:0000B939                 mov     edx, [eax]
.text:0000B93B                 mov     [ebp+var_1C], edx
.text:0000B93E                 mov     eax, [ebp+var_1C]
.text:0000B941                 mov     [ebp+var_18], eax
.text:0000B944                 cmp     [ebp+var_18], 0
.text:0000B948                 jz      short loc_B959
.text:0000B94A                 push    1
.text:0000B94C                 mov     ecx, [ebp+var_18]
.text:0000B94F                 call    ??_GCAltStreamInfo@COutMultiVolStream@@QAEPAXI@Z ; COutMultiVolStream::CAltStreamInfo::`scalar deleting destructor'(uint)
.text:0000B954                 mov     [ebp+var_20], eax
.text:0000B957                 jmp     short loc_B960
.text:0000B959 ; ---------------------------------------------------------------------------
.text:0000B959
.text:0000B959 loc_B959:                               ; CODE XREF: CObjectVector<COutMultiVolStream::CAltStreamInfo>::~CObjectVector<COutMultiVolStream::CAltStreamInfo>(void)+78j
.text:0000B959                 mov     [ebp+var_20], 0
.text:0000B960
.text:0000B960 loc_B960:                               ; CODE XREF: CObjectVector<COutMultiVolStream::CAltStreamInfo>::~CObjectVector<COutMultiVolStream::CAltStreamInfo>(void)+87j
.text:0000B960                 jmp     short loc_B91E
.text:0000B962 ; ---------------------------------------------------------------------------
.text:0000B962
.text:0000B962 loc_B962:                               ; CODE XREF: CObjectVector<COutMultiVolStream::CAltStreamInfo>::~CObjectVector<COutMultiVolStream::CAltStreamInfo>(void)+52j
.text:0000B962                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000B969                 mov     ecx, [ebp+var_10]
.text:0000B96C                 call    ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text:0000B971                 mov     ecx, [ebp+var_C]
.text:0000B974                 mov     large fs:0, ecx
.text:0000B97B                 pop     ecx
.text:0000B97C                 add     esp, 20h
.text:0000B97F                 cmp     ebp, esp
.text:0000B981                 call    __RTC_CheckEsp
.text:0000B986                 mov     esp, ebp
.text:0000B988                 pop     ebp
.text:0000B989                 retn
.text:0000B989 ??1?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAE@XZ endp
.text:0000B989
.text:0000B989 ; ---------------------------------------------------------------------------
.text:0000B98A                 align 4
.text:0000B98A _text           ends
.text:0000B98A
.text$x:0000B98C ; ===========================================================================
.text$x:0000B98C
.text$x:0000B98C ; Segment type: Pure code
.text$x:0000B98C ; Segment permissions: Read/Execute
.text$x:0000B98C _text$x         segment para public 'CODE' use32
.text$x:0000B98C                 assume cs:_text$x
.text$x:0000B98C                 ;org 0B98Ch
.text$x:0000B98C ; COMDAT (pick associative to section at B8D0)
.text$x:0000B98C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000B98C
.text$x:0000B98C ; =============== S U B R O U T I N E =======================================
.text$x:0000B98C
.text$x:0000B98C
.text$x:0000B98C __unwindfunclet$??1?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAE@XZ$0 proc near
.text$x:0000B98C                                         ; DATA XREF: .xdata$x:0000B9B4o
.text$x:0000B98C                 mov     ecx, [ebp-10h]
.text$x:0000B98F                 jmp     ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text$x:0000B98F __unwindfunclet$??1?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAE@XZ$0 endp
.text$x:0000B98F
.text$x:0000B994
.text$x:0000B994 ; =============== S U B R O U T I N E =======================================
.text$x:0000B994
.text$x:0000B994
.text$x:0000B994 __ehhandler$??1?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAE@XZ proc near
.text$x:0000B994                                         ; DATA XREF: CObjectVector<COutMultiVolStream::CAltStreamInfo>::~CObjectVector<COutMultiVolStream::CAltStreamInfo>(void)+5o
.text$x:0000B994
.text$x:0000B994 arg_4           = dword ptr  8
.text$x:0000B994
.text$x:0000B994                 mov     edx, [esp+arg_4]
.text$x:0000B998                 lea     eax, [edx+0Ch]
.text$x:0000B99B                 mov     ecx, [edx-18h]
.text$x:0000B99E                 xor     ecx, eax
.text$x:0000B9A0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B9A5                 mov     eax, offset __ehfuncinfo$??1?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAE@XZ
.text$x:0000B9AA                 jmp     ___CxxFrameHandler3
.text$x:0000B9AA __ehhandler$??1?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAE@XZ endp
.text$x:0000B9AA
.text$x:0000B9AA ; ---------------------------------------------------------------------------
.text$x:0000B9AF                 align 10h
.text$x:0000B9AF _text$x         ends
.text$x:0000B9AF
.xdata$x:0000B9B0 ; ===========================================================================
.xdata$x:0000B9B0
.xdata$x:0000B9B0 ; Segment type: Pure data
.xdata$x:0000B9B0 ; Segment permissions: Read
.xdata$x:0000B9B0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000B9B0                 assume cs:_xdata$x
.xdata$x:0000B9B0                 ;org 0B9B0h
.xdata$x:0000B9B0 ; COMDAT (pick associative to section at B8D0)
.xdata$x:0000B9B0 __unwindtable$??1?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAE@XZ db 0FFh
.xdata$x:0000B9B0                                         ; DATA XREF: .xdata$x:0000B9C0o
.xdata$x:0000B9B1                 db 0FFh
.xdata$x:0000B9B2                 db 0FFh
.xdata$x:0000B9B3                 db 0FFh
.xdata$x:0000B9B4                 dd offset __unwindfunclet$??1?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAE@XZ$0
.xdata$x:0000B9B8 __ehfuncinfo$??1?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAE@XZ db  22h ; "
.xdata$x:0000B9B8                                         ; DATA XREF: __ehhandler$??1?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAE@XZ+11o
.xdata$x:0000B9B9                 db    5
.xdata$x:0000B9BA                 db  93h ; 
.xdata$x:0000B9BB                 db  19h
.xdata$x:0000B9BC                 db    1
.xdata$x:0000B9BD                 db    0
.xdata$x:0000B9BE                 db    0
.xdata$x:0000B9BF                 db    0
.xdata$x:0000B9C0                 dd offset __unwindtable$??1?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAE@XZ
.xdata$x:0000B9C4                 db    0
.xdata$x:0000B9C5                 db    0
.xdata$x:0000B9C6                 db    0
.xdata$x:0000B9C7                 db    0
.xdata$x:0000B9C8                 db    0
.xdata$x:0000B9C9                 db    0
.xdata$x:0000B9CA                 db    0
.xdata$x:0000B9CB                 db    0
.xdata$x:0000B9CC                 db    0
.xdata$x:0000B9CD                 db    0
.xdata$x:0000B9CE                 db    0
.xdata$x:0000B9CF                 db    0
.xdata$x:0000B9D0                 db    0
.xdata$x:0000B9D1                 db    0
.xdata$x:0000B9D2                 db    0
.xdata$x:0000B9D3                 db    0
.xdata$x:0000B9D4                 db    0
.xdata$x:0000B9D5                 db    0
.xdata$x:0000B9D6                 db    0
.xdata$x:0000B9D7                 db    0
.xdata$x:0000B9D8                 db    1
.xdata$x:0000B9D9                 db    0
.xdata$x:0000B9DA                 db    0
.xdata$x:0000B9DB                 db    0
.xdata$x:0000B9DB _xdata$x        ends
.xdata$x:0000B9DB
.text:0000B9DC ; ===========================================================================
.text:0000B9DC
.text:0000B9DC ; Segment type: Pure code
.text:0000B9DC ; Segment permissions: Read/Execute
.text:0000B9DC _text           segment para public 'CODE' use32
.text:0000B9DC                 assume cs:_text
.text:0000B9DC                 ;org 0B9DCh
.text:0000B9DC ; COMDAT (pick any)
.text:0000B9DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000B9DC
.text:0000B9DC ; =============== S U B R O U T I N E =======================================
.text:0000B9DC
.text:0000B9DC ; Attributes: bp-based frame
.text:0000B9DC
.text:0000B9DC ; public: void __thiscall CObjectVector<struct COutMultiVolStream::CAltStreamInfo>::DeleteBack(void)
.text:0000B9DC                 public ?DeleteBack@?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAEXXZ
.text:0000B9DC ?DeleteBack@?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAEXXZ proc near
.text:0000B9DC                                         ; CODE XREF: COutMultiVolStream::SetSize(unsigned __int64)+13Cp
.text:0000B9DC
.text:0000B9DC var_10          = dword ptr -10h
.text:0000B9DC var_C           = dword ptr -0Ch
.text:0000B9DC var_8           = dword ptr -8
.text:0000B9DC var_4           = dword ptr -4
.text:0000B9DC
.text:0000B9DC                 push    ebp
.text:0000B9DD                 mov     ebp, esp
.text:0000B9DF                 sub     esp, 10h
.text:0000B9E2                 mov     eax, 0CCCCCCCCh
.text:0000B9E7                 mov     [ebp+var_10], eax
.text:0000B9EA                 mov     [ebp+var_C], eax
.text:0000B9ED                 mov     [ebp+var_8], eax
.text:0000B9F0                 mov     [ebp+var_4], eax
.text:0000B9F3                 mov     [ebp+var_4], ecx
.text:0000B9F6                 mov     ecx, [ebp+var_4]
.text:0000B9F9                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:0000B9FE                 sub     eax, 1
.text:0000BA01                 push    eax
.text:0000BA02                 mov     ecx, [ebp+var_4]
.text:0000BA05                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:0000BA0A                 mov     eax, [eax]
.text:0000BA0C                 mov     [ebp+var_C], eax
.text:0000BA0F                 mov     ecx, [ebp+var_C]
.text:0000BA12                 mov     [ebp+var_8], ecx
.text:0000BA15                 cmp     [ebp+var_8], 0
.text:0000BA19                 jz      short loc_BA2A
.text:0000BA1B                 push    1
.text:0000BA1D                 mov     ecx, [ebp+var_8]
.text:0000BA20                 call    ??_GCAltStreamInfo@COutMultiVolStream@@QAEPAXI@Z ; COutMultiVolStream::CAltStreamInfo::`scalar deleting destructor'(uint)
.text:0000BA25                 mov     [ebp+var_10], eax
.text:0000BA28                 jmp     short loc_BA31
.text:0000BA2A ; ---------------------------------------------------------------------------
.text:0000BA2A
.text:0000BA2A loc_BA2A:                               ; CODE XREF: CObjectVector<COutMultiVolStream::CAltStreamInfo>::DeleteBack(void)+3Dj
.text:0000BA2A                 mov     [ebp+var_10], 0
.text:0000BA31
.text:0000BA31 loc_BA31:                               ; CODE XREF: CObjectVector<COutMultiVolStream::CAltStreamInfo>::DeleteBack(void)+4Cj
.text:0000BA31                 mov     ecx, [ebp+var_4]
.text:0000BA34                 call    ?DeleteBack@?$CRecordVector@PAX@@QAEXXZ ; CRecordVector<void *>::DeleteBack(void)
.text:0000BA39                 add     esp, 10h
.text:0000BA3C                 cmp     ebp, esp
.text:0000BA3E                 call    __RTC_CheckEsp
.text:0000BA43                 mov     esp, ebp
.text:0000BA45                 pop     ebp
.text:0000BA46                 retn
.text:0000BA46 ?DeleteBack@?$CObjectVector@UCAltStreamInfo@COutMultiVolStream@@@@QAEXXZ endp
.text:0000BA46
.text:0000BA46 ; ---------------------------------------------------------------------------
.text:0000BA47                 align 4
.text:0000BA47 _text           ends
.text:0000BA47
.text:0000BA48 ; ===========================================================================
.text:0000BA48
.text:0000BA48 ; Segment type: Pure code
.text:0000BA48 ; Segment permissions: Read/Execute
.text:0000BA48 _text           segment para public 'CODE' use32
.text:0000BA48                 assume cs:_text
.text:0000BA48                 ;org 0BA48h
.text:0000BA48 ; COMDAT (pick any)
.text:0000BA48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BA48
.text:0000BA48 ; =============== S U B R O U T I N E =======================================
.text:0000BA48
.text:0000BA48 ; Attributes: bp-based frame
.text:0000BA48
.text:0000BA48 ; public: unsigned int __thiscall CObjectVector<struct COpenType>::Size(void)const
.text:0000BA48                 public ?Size@?$CObjectVector@UCOpenType@@@@QBEIXZ
.text:0000BA48 ?Size@?$CObjectVector@UCOpenType@@@@QBEIXZ proc near
.text:0000BA48                                         ; CODE XREF: CUpdateOptions::InitFormatIndex(CCodecs const *,CObjectVector<COpenType> const &,UString const &)+2Ep
.text:0000BA48                                         ; CUpdateOptions::InitFormatIndex(CCodecs const *,CObjectVector<COpenType> const &,UString const &)+3Fp ...
.text:0000BA48
.text:0000BA48 var_4           = dword ptr -4
.text:0000BA48
.text:0000BA48                 push    ebp
.text:0000BA49                 mov     ebp, esp
.text:0000BA4B                 push    ecx
.text:0000BA4C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000BA53                 mov     [ebp+var_4], ecx
.text:0000BA56                 mov     ecx, [ebp+var_4]
.text:0000BA59                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:0000BA5E                 add     esp, 4
.text:0000BA61                 cmp     ebp, esp
.text:0000BA63                 call    __RTC_CheckEsp
.text:0000BA68                 mov     esp, ebp
.text:0000BA6A                 pop     ebp
.text:0000BA6B                 retn
.text:0000BA6B ?Size@?$CObjectVector@UCOpenType@@@@QBEIXZ endp
.text:0000BA6B
.text:0000BA6B _text           ends
.text:0000BA6B
.text:0000BA6C ; ===========================================================================
.text:0000BA6C
.text:0000BA6C ; Segment type: Pure code
.text:0000BA6C ; Segment permissions: Read/Execute
.text:0000BA6C _text           segment para public 'CODE' use32
.text:0000BA6C                 assume cs:_text
.text:0000BA6C                 ;org 0BA6Ch
.text:0000BA6C ; COMDAT (pick any)
.text:0000BA6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BA6C
.text:0000BA6C ; =============== S U B R O U T I N E =======================================
.text:0000BA6C
.text:0000BA6C ; Attributes: bp-based frame
.text:0000BA6C
.text:0000BA6C ; public: __thiscall CObjectVector<struct COpenType>::CObjectVector<struct COpenType>(void)
.text:0000BA6C                 public ??0?$CObjectVector@UCOpenType@@@@QAE@XZ
.text:0000BA6C ??0?$CObjectVector@UCOpenType@@@@QAE@XZ proc near
.text:0000BA6C                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+559p
.text:0000BA6C
.text:0000BA6C var_4           = dword ptr -4
.text:0000BA6C
.text:0000BA6C                 push    ebp
.text:0000BA6D                 mov     ebp, esp
.text:0000BA6F                 push    ecx
.text:0000BA70                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000BA77                 mov     [ebp+var_4], ecx
.text:0000BA7A                 mov     ecx, [ebp+var_4]
.text:0000BA7D                 call    ??0?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::CRecordVector<void *>(void)
.text:0000BA82                 mov     eax, [ebp+var_4]
.text:0000BA85                 add     esp, 4
.text:0000BA88                 cmp     ebp, esp
.text:0000BA8A                 call    __RTC_CheckEsp
.text:0000BA8F                 mov     esp, ebp
.text:0000BA91                 pop     ebp
.text:0000BA92                 retn
.text:0000BA92 ??0?$CObjectVector@UCOpenType@@@@QAE@XZ endp
.text:0000BA92
.text:0000BA92 ; ---------------------------------------------------------------------------
.text:0000BA93                 align 4
.text:0000BA93 _text           ends
.text:0000BA93
.text:0000BA94 ; ===========================================================================
.text:0000BA94
.text:0000BA94 ; Segment type: Pure code
.text:0000BA94 ; Segment permissions: Read/Execute
.text:0000BA94 _text           segment para public 'CODE' use32
.text:0000BA94                 assume cs:_text
.text:0000BA94                 ;org 0BA94h
.text:0000BA94 ; COMDAT (pick any)
.text:0000BA94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BA94
.text:0000BA94 ; =============== S U B R O U T I N E =======================================
.text:0000BA94
.text:0000BA94 ; Attributes: bp-based frame
.text:0000BA94
.text:0000BA94 ; public: struct COpenType const & __thiscall CObjectVector<struct COpenType>::operator[](unsigned int)const
.text:0000BA94                 public ??A?$CObjectVector@UCOpenType@@@@QBEABUCOpenType@@I@Z
.text:0000BA94 ??A?$CObjectVector@UCOpenType@@@@QBEABUCOpenType@@I@Z proc near
.text:0000BA94                                         ; CODE XREF: CUpdateOptions::InitFormatIndex(CCodecs const *,CObjectVector<COpenType> const &,UString const &)+4Dp
.text:0000BA94
.text:0000BA94 var_4           = dword ptr -4
.text:0000BA94 arg_0           = dword ptr  8
.text:0000BA94
.text:0000BA94                 push    ebp
.text:0000BA95                 mov     ebp, esp
.text:0000BA97                 push    ecx
.text:0000BA98                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000BA9F                 mov     [ebp+var_4], ecx
.text:0000BAA2                 mov     eax, [ebp+arg_0]
.text:0000BAA5                 push    eax
.text:0000BAA6                 mov     ecx, [ebp+var_4]
.text:0000BAA9                 call    ??A?$CRecordVector@PAX@@QBEABQAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:0000BAAE                 mov     eax, [eax]
.text:0000BAB0                 add     esp, 4
.text:0000BAB3                 cmp     ebp, esp
.text:0000BAB5                 call    __RTC_CheckEsp
.text:0000BABA                 mov     esp, ebp
.text:0000BABC                 pop     ebp
.text:0000BABD                 retn    4
.text:0000BABD ??A?$CObjectVector@UCOpenType@@@@QBEABUCOpenType@@I@Z endp
.text:0000BABD
.text:0000BABD _text           ends
.text:0000BABD
.text:0000BAC0 ; ===========================================================================
.text:0000BAC0
.text:0000BAC0 ; Segment type: Pure code
.text:0000BAC0 ; Segment permissions: Read/Execute
.text:0000BAC0 _text           segment para public 'CODE' use32
.text:0000BAC0                 assume cs:_text
.text:0000BAC0                 ;org 0BAC0h
.text:0000BAC0 ; COMDAT (pick any)
.text:0000BAC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BAC0
.text:0000BAC0 ; =============== S U B R O U T I N E =======================================
.text:0000BAC0
.text:0000BAC0 ; Attributes: bp-based frame
.text:0000BAC0
.text:0000BAC0 ; public: unsigned int __thiscall CObjectVector<struct COpenType>::Add(struct COpenType const &)
.text:0000BAC0                 public ?Add@?$CObjectVector@UCOpenType@@@@QAEIABUCOpenType@@@Z
.text:0000BAC0 ?Add@?$CObjectVector@UCOpenType@@@@QAEIABUCOpenType@@@Z proc near
.text:0000BAC0                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+579p
.text:0000BAC0
.text:0000BAC0 var_C           = dword ptr -0Ch
.text:0000BAC0 var_8           = dword ptr -8
.text:0000BAC0 var_4           = dword ptr -4
.text:0000BAC0 arg_0           = dword ptr  8
.text:0000BAC0
.text:0000BAC0                 push    ebp
.text:0000BAC1                 mov     ebp, esp
.text:0000BAC3                 sub     esp, 0Ch
.text:0000BAC6                 push    esi
.text:0000BAC7                 push    edi
.text:0000BAC8                 mov     [ebp+var_C], 0CCCCCCCCh
.text:0000BACF                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000BAD6                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000BADD                 mov     [ebp+var_4], ecx
.text:0000BAE0                 push    20h ; ' '       ; unsigned int
.text:0000BAE2                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0000BAE7                 add     esp, 4
.text:0000BAEA                 mov     [ebp+var_8], eax
.text:0000BAED                 cmp     [ebp+var_8], 0
.text:0000BAF1                 jz      short loc_BB08
.text:0000BAF3                 mov     esi, [ebp+arg_0]
.text:0000BAF6                 mov     ecx, 8
.text:0000BAFB                 mov     edi, [ebp+var_8]
.text:0000BAFE                 rep movsd
.text:0000BB00                 mov     eax, [ebp+var_8]
.text:0000BB03                 mov     [ebp+var_C], eax
.text:0000BB06                 jmp     short loc_BB0F
.text:0000BB08 ; ---------------------------------------------------------------------------
.text:0000BB08
.text:0000BB08 loc_BB08:                               ; CODE XREF: CObjectVector<COpenType>::Add(COpenType const &)+31j
.text:0000BB08                 mov     [ebp+var_C], 0
.text:0000BB0F
.text:0000BB0F loc_BB0F:                               ; CODE XREF: CObjectVector<COpenType>::Add(COpenType const &)+46j
.text:0000BB0F                 mov     ecx, [ebp+var_C]
.text:0000BB12                 push    ecx
.text:0000BB13                 mov     ecx, [ebp+var_4]
.text:0000BB16                 call    ?Add@?$CRecordVector@PAX@@QAEIQAX@Z ; CRecordVector<void *>::Add(void * const)
.text:0000BB1B                 pop     edi
.text:0000BB1C                 pop     esi
.text:0000BB1D                 add     esp, 0Ch
.text:0000BB20                 cmp     ebp, esp
.text:0000BB22                 call    __RTC_CheckEsp
.text:0000BB27                 mov     esp, ebp
.text:0000BB29                 pop     ebp
.text:0000BB2A                 retn    4
.text:0000BB2A ?Add@?$CObjectVector@UCOpenType@@@@QAEIABUCOpenType@@@Z endp
.text:0000BB2A
.text:0000BB2A ; ---------------------------------------------------------------------------
.text:0000BB2D                 align 10h
.text:0000BB2D _text           ends
.text:0000BB2D
.text:0000BB30 ; ===========================================================================
.text:0000BB30
.text:0000BB30 ; Segment type: Pure code
.text:0000BB30 ; Segment permissions: Read/Execute
.text:0000BB30 _text           segment para public 'CODE' use32
.text:0000BB30                 assume cs:_text
.text:0000BB30                 ;org 0BB30h
.text:0000BB30 ; COMDAT (pick any)
.text:0000BB30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BB30
.text:0000BB30 ; =============== S U B R O U T I N E =======================================
.text:0000BB30
.text:0000BB30 ; Attributes: bp-based frame
.text:0000BB30
.text:0000BB30 ; public: __thiscall CObjectVector<struct COpenType>::~CObjectVector<struct COpenType>(void)
.text:0000BB30                 public ??1?$CObjectVector@UCOpenType@@@@QAE@XZ
.text:0000BB30 ??1?$CObjectVector@UCOpenType@@@@QAE@XZ proc near
.text:0000BB30                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+651p
.text:0000BB30                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+6EDp ...
.text:0000BB30
.text:0000BB30 var_18          = dword ptr -18h
.text:0000BB30 var_14          = dword ptr -14h
.text:0000BB30 var_10          = dword ptr -10h
.text:0000BB30 var_C           = dword ptr -0Ch
.text:0000BB30 var_4           = dword ptr -4
.text:0000BB30
.text:0000BB30                 push    ebp
.text:0000BB31                 mov     ebp, esp
.text:0000BB33                 push    0FFFFFFFFh
.text:0000BB35                 push    offset __ehhandler$??1?$CObjectVector@UCOpenType@@@@QAE@XZ
.text:0000BB3A                 mov     eax, large fs:0
.text:0000BB40                 push    eax
.text:0000BB41                 sub     esp, 0Ch
.text:0000BB44                 mov     [ebp+var_18], 0CCCCCCCCh
.text:0000BB4B                 mov     [ebp+var_14], 0CCCCCCCCh
.text:0000BB52                 mov     [ebp+var_10], 0CCCCCCCCh
.text:0000BB59                 mov     eax, dword ptr ds:___security_cookie
.text:0000BB5E                 xor     eax, ebp
.text:0000BB60                 push    eax
.text:0000BB61                 lea     eax, [ebp+var_C]
.text:0000BB64                 mov     large fs:0, eax
.text:0000BB6A                 mov     [ebp+var_10], ecx
.text:0000BB6D                 mov     [ebp+var_4], 0
.text:0000BB74                 mov     ecx, [ebp+var_10]
.text:0000BB77                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:0000BB7C                 mov     [ebp+var_14], eax
.text:0000BB7F
.text:0000BB7F loc_BB7F:                               ; CODE XREF: CObjectVector<COpenType>::~CObjectVector<COpenType>(void)+7Bj
.text:0000BB7F                 cmp     [ebp+var_14], 0
.text:0000BB83                 jz      short loc_BBAD
.text:0000BB85                 mov     eax, [ebp+var_14]
.text:0000BB88                 sub     eax, 1
.text:0000BB8B                 mov     [ebp+var_14], eax
.text:0000BB8E                 mov     ecx, [ebp+var_14]
.text:0000BB91                 push    ecx
.text:0000BB92                 mov     ecx, [ebp+var_10]
.text:0000BB95                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:0000BB9A                 mov     edx, [eax]
.text:0000BB9C                 mov     [ebp+var_18], edx
.text:0000BB9F                 mov     eax, [ebp+var_18]
.text:0000BBA2                 push    eax             ; void *
.text:0000BBA3                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000BBA8                 add     esp, 4
.text:0000BBAB                 jmp     short loc_BB7F
.text:0000BBAD ; ---------------------------------------------------------------------------
.text:0000BBAD
.text:0000BBAD loc_BBAD:                               ; CODE XREF: CObjectVector<COpenType>::~CObjectVector<COpenType>(void)+53j
.text:0000BBAD                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000BBB4                 mov     ecx, [ebp+var_10]
.text:0000BBB7                 call    ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text:0000BBBC                 mov     ecx, [ebp+var_C]
.text:0000BBBF                 mov     large fs:0, ecx
.text:0000BBC6                 pop     ecx
.text:0000BBC7                 add     esp, 18h
.text:0000BBCA                 cmp     ebp, esp
.text:0000BBCC                 call    __RTC_CheckEsp
.text:0000BBD1                 mov     esp, ebp
.text:0000BBD3                 pop     ebp
.text:0000BBD4                 retn
.text:0000BBD4 ??1?$CObjectVector@UCOpenType@@@@QAE@XZ endp
.text:0000BBD4
.text:0000BBD4 ; ---------------------------------------------------------------------------
.text:0000BBD5                 align 4
.text:0000BBD5 _text           ends
.text:0000BBD5
.text$x:0000BBD8 ; ===========================================================================
.text$x:0000BBD8
.text$x:0000BBD8 ; Segment type: Pure code
.text$x:0000BBD8 ; Segment permissions: Read/Execute
.text$x:0000BBD8 _text$x         segment para public 'CODE' use32
.text$x:0000BBD8                 assume cs:_text$x
.text$x:0000BBD8                 ;org 0BBD8h
.text$x:0000BBD8 ; COMDAT (pick associative to section at BB30)
.text$x:0000BBD8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000BBD8
.text$x:0000BBD8 ; =============== S U B R O U T I N E =======================================
.text$x:0000BBD8
.text$x:0000BBD8
.text$x:0000BBD8 __unwindfunclet$??1?$CObjectVector@UCOpenType@@@@QAE@XZ$0 proc near
.text$x:0000BBD8                                         ; DATA XREF: .xdata$x:0000BC00o
.text$x:0000BBD8                 mov     ecx, [ebp-10h]
.text$x:0000BBDB                 jmp     ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text$x:0000BBDB __unwindfunclet$??1?$CObjectVector@UCOpenType@@@@QAE@XZ$0 endp
.text$x:0000BBDB
.text$x:0000BBE0
.text$x:0000BBE0 ; =============== S U B R O U T I N E =======================================
.text$x:0000BBE0
.text$x:0000BBE0
.text$x:0000BBE0 __ehhandler$??1?$CObjectVector@UCOpenType@@@@QAE@XZ proc near
.text$x:0000BBE0                                         ; DATA XREF: CObjectVector<COpenType>::~CObjectVector<COpenType>(void)+5o
.text$x:0000BBE0
.text$x:0000BBE0 arg_4           = dword ptr  8
.text$x:0000BBE0
.text$x:0000BBE0                 mov     edx, [esp+arg_4]
.text$x:0000BBE4                 lea     eax, [edx+0Ch]
.text$x:0000BBE7                 mov     ecx, [edx-10h]
.text$x:0000BBEA                 xor     ecx, eax
.text$x:0000BBEC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000BBF1                 mov     eax, offset __ehfuncinfo$??1?$CObjectVector@UCOpenType@@@@QAE@XZ
.text$x:0000BBF6                 jmp     ___CxxFrameHandler3
.text$x:0000BBF6 __ehhandler$??1?$CObjectVector@UCOpenType@@@@QAE@XZ endp
.text$x:0000BBF6
.text$x:0000BBF6 ; ---------------------------------------------------------------------------
.text$x:0000BBFB                 align 4
.text$x:0000BBFB _text$x         ends
.text$x:0000BBFB
.xdata$x:0000BBFC ; ===========================================================================
.xdata$x:0000BBFC
.xdata$x:0000BBFC ; Segment type: Pure data
.xdata$x:0000BBFC ; Segment permissions: Read
.xdata$x:0000BBFC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000BBFC                 assume cs:_xdata$x
.xdata$x:0000BBFC                 ;org 0BBFCh
.xdata$x:0000BBFC ; COMDAT (pick associative to section at BB30)
.xdata$x:0000BBFC __unwindtable$??1?$CObjectVector@UCOpenType@@@@QAE@XZ db 0FFh
.xdata$x:0000BBFC                                         ; DATA XREF: .xdata$x:0000BC0Co
.xdata$x:0000BBFD                 db 0FFh
.xdata$x:0000BBFE                 db 0FFh
.xdata$x:0000BBFF                 db 0FFh
.xdata$x:0000BC00                 dd offset __unwindfunclet$??1?$CObjectVector@UCOpenType@@@@QAE@XZ$0
.xdata$x:0000BC04 __ehfuncinfo$??1?$CObjectVector@UCOpenType@@@@QAE@XZ db  22h ; "
.xdata$x:0000BC04                                         ; DATA XREF: __ehhandler$??1?$CObjectVector@UCOpenType@@@@QAE@XZ+11o
.xdata$x:0000BC05                 db    5
.xdata$x:0000BC06                 db  93h ; 
.xdata$x:0000BC07                 db  19h
.xdata$x:0000BC08                 db    1
.xdata$x:0000BC09                 db    0
.xdata$x:0000BC0A                 db    0
.xdata$x:0000BC0B                 db    0
.xdata$x:0000BC0C                 dd offset __unwindtable$??1?$CObjectVector@UCOpenType@@@@QAE@XZ
.xdata$x:0000BC10                 db    0
.xdata$x:0000BC11                 db    0
.xdata$x:0000BC12                 db    0
.xdata$x:0000BC13                 db    0
.xdata$x:0000BC14                 db    0
.xdata$x:0000BC15                 db    0
.xdata$x:0000BC16                 db    0
.xdata$x:0000BC17                 db    0
.xdata$x:0000BC18                 db    0
.xdata$x:0000BC19                 db    0
.xdata$x:0000BC1A                 db    0
.xdata$x:0000BC1B                 db    0
.xdata$x:0000BC1C                 db    0
.xdata$x:0000BC1D                 db    0
.xdata$x:0000BC1E                 db    0
.xdata$x:0000BC1F                 db    0
.xdata$x:0000BC20                 db    0
.xdata$x:0000BC21                 db    0
.xdata$x:0000BC22                 db    0
.xdata$x:0000BC23                 db    0
.xdata$x:0000BC24                 db    1
.xdata$x:0000BC25                 db    0
.xdata$x:0000BC26                 db    0
.xdata$x:0000BC27                 db    0
.xdata$x:0000BC27 _xdata$x        ends
.xdata$x:0000BC27
.text:0000BC28 ; ===========================================================================
.text:0000BC28
.text:0000BC28 ; Segment type: Pure code
.text:0000BC28 ; Segment permissions: Read/Execute
.text:0000BC28 _text           segment para public 'CODE' use32
.text:0000BC28                 assume cs:_text
.text:0000BC28                 ;org 0BC28h
.text:0000BC28 ; COMDAT (pick any)
.text:0000BC28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BC28
.text:0000BC28 ; =============== S U B R O U T I N E =======================================
.text:0000BC28
.text:0000BC28 ; Attributes: bp-based frame
.text:0000BC28
.text:0000BC28 ; public: __thiscall CRecordVector<struct CUpdatePair2>::CRecordVector<struct CUpdatePair2>(void)
.text:0000BC28                 public ??0?$CRecordVector@UCUpdatePair2@@@@QAE@XZ
.text:0000BC28 ??0?$CRecordVector@UCUpdatePair2@@@@QAE@XZ proc near
.text:0000BC28                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+291p
.text:0000BC28
.text:0000BC28 var_4           = dword ptr -4
.text:0000BC28
.text:0000BC28                 push    ebp
.text:0000BC29                 mov     ebp, esp
.text:0000BC2B                 push    ecx
.text:0000BC2C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000BC33                 mov     [ebp+var_4], ecx
.text:0000BC36                 mov     eax, [ebp+var_4]
.text:0000BC39                 mov     dword ptr [eax], 0
.text:0000BC3F                 mov     ecx, [ebp+var_4]
.text:0000BC42                 mov     dword ptr [ecx+4], 0
.text:0000BC49                 mov     edx, [ebp+var_4]
.text:0000BC4C                 mov     dword ptr [edx+8], 0
.text:0000BC53                 mov     eax, [ebp+var_4]
.text:0000BC56                 mov     esp, ebp
.text:0000BC58                 pop     ebp
.text:0000BC59                 retn
.text:0000BC59 ??0?$CRecordVector@UCUpdatePair2@@@@QAE@XZ endp
.text:0000BC59
.text:0000BC59 ; ---------------------------------------------------------------------------
.text:0000BC5A                 align 4
.text:0000BC5A _text           ends
.text:0000BC5A
.text:0000BC5C ; ===========================================================================
.text:0000BC5C
.text:0000BC5C ; Segment type: Pure code
.text:0000BC5C ; Segment permissions: Read/Execute
.text:0000BC5C _text           segment para public 'CODE' use32
.text:0000BC5C                 assume cs:_text
.text:0000BC5C                 ;org 0BC5Ch
.text:0000BC5C ; COMDAT (pick any)
.text:0000BC5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BC5C
.text:0000BC5C ; =============== S U B R O U T I N E =======================================
.text:0000BC5C
.text:0000BC5C ; Attributes: bp-based frame
.text:0000BC5C
.text:0000BC5C ; public: unsigned int __thiscall CRecordVector<struct CUpdatePair2>::Size(void)const
.text:0000BC5C                 public ?Size@?$CRecordVector@UCUpdatePair2@@@@QBEIXZ
.text:0000BC5C ?Size@?$CRecordVector@UCUpdatePair2@@@@QBEIXZ proc near
.text:0000BC5C                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+5F3p
.text:0000BC5C                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+1776p ...
.text:0000BC5C
.text:0000BC5C var_4           = dword ptr -4
.text:0000BC5C
.text:0000BC5C                 push    ebp
.text:0000BC5D                 mov     ebp, esp
.text:0000BC5F                 push    ecx
.text:0000BC60                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000BC67                 mov     [ebp+var_4], ecx
.text:0000BC6A                 mov     eax, [ebp+var_4]
.text:0000BC6D                 mov     eax, [eax+4]
.text:0000BC70                 mov     esp, ebp
.text:0000BC72                 pop     ebp
.text:0000BC73                 retn
.text:0000BC73 ?Size@?$CRecordVector@UCUpdatePair2@@@@QBEIXZ endp
.text:0000BC73
.text:0000BC73 _text           ends
.text:0000BC73
.text:0000BC74 ; ===========================================================================
.text:0000BC74
.text:0000BC74 ; Segment type: Pure code
.text:0000BC74 ; Segment permissions: Read/Execute
.text:0000BC74 _text           segment para public 'CODE' use32
.text:0000BC74                 assume cs:_text
.text:0000BC74                 ;org 0BC74h
.text:0000BC74 ; COMDAT (pick any)
.text:0000BC74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BC74
.text:0000BC74 ; =============== S U B R O U T I N E =======================================
.text:0000BC74
.text:0000BC74 ; Attributes: bp-based frame
.text:0000BC74
.text:0000BC74 ; public: __thiscall CRecordVector<struct CUpdatePair2>::~CRecordVector<struct CUpdatePair2>(void)
.text:0000BC74                 public ??1?$CRecordVector@UCUpdatePair2@@@@QAE@XZ
.text:0000BC74 ??1?$CRecordVector@UCUpdatePair2@@@@QAE@XZ proc near
.text:0000BC74                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+4DAp
.text:0000BC74                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+675p ...
.text:0000BC74
.text:0000BC74 var_8           = dword ptr -8
.text:0000BC74 var_4           = dword ptr -4
.text:0000BC74
.text:0000BC74                 push    ebp
.text:0000BC75                 mov     ebp, esp
.text:0000BC77                 sub     esp, 8
.text:0000BC7A                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000BC81                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000BC88                 mov     [ebp+var_4], ecx
.text:0000BC8B                 mov     eax, [ebp+var_4]
.text:0000BC8E                 mov     ecx, [eax]
.text:0000BC90                 mov     [ebp+var_8], ecx
.text:0000BC93                 mov     edx, [ebp+var_8]
.text:0000BC96                 push    edx             ; void *
.text:0000BC97                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000BC9C                 add     esp, 4
.text:0000BC9F                 add     esp, 8
.text:0000BCA2                 cmp     ebp, esp
.text:0000BCA4                 call    __RTC_CheckEsp
.text:0000BCA9                 mov     esp, ebp
.text:0000BCAB                 pop     ebp
.text:0000BCAC                 retn
.text:0000BCAC ??1?$CRecordVector@UCUpdatePair2@@@@QAE@XZ endp
.text:0000BCAC
.text:0000BCAC ; ---------------------------------------------------------------------------
.text:0000BCAD                 align 10h
.text:0000BCAD _text           ends
.text:0000BCAD
.text:0000BCB0 ; ===========================================================================
.text:0000BCB0
.text:0000BCB0 ; Segment type: Pure code
.text:0000BCB0 ; Segment permissions: Read/Execute
.text:0000BCB0 _text           segment para public 'CODE' use32
.text:0000BCB0                 assume cs:_text
.text:0000BCB0                 ;org 0BCB0h
.text:0000BCB0 ; COMDAT (pick any)
.text:0000BCB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BCB0
.text:0000BCB0 ; =============== S U B R O U T I N E =======================================
.text:0000BCB0
.text:0000BCB0 ; Attributes: bp-based frame
.text:0000BCB0
.text:0000BCB0 ; public: unsigned int __thiscall CRecordVector<struct CUpdatePair2>::Add(struct CUpdatePair2)
.text:0000BCB0                 public ?Add@?$CRecordVector@UCUpdatePair2@@@@QAEIUCUpdatePair2@@@Z
.text:0000BCB0 ?Add@?$CRecordVector@UCUpdatePair2@@@@QAEIUCUpdatePair2@@@Z proc near
.text:0000BCB0                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+542p
.text:0000BCB0
.text:0000BCB0 var_8           = dword ptr -8
.text:0000BCB0 var_4           = dword ptr -4
.text:0000BCB0 arg_0           = dword ptr  8
.text:0000BCB0 arg_4           = dword ptr  0Ch
.text:0000BCB0 arg_8           = dword ptr  10h
.text:0000BCB0 arg_C           = dword ptr  14h
.text:0000BCB0 arg_10          = dword ptr  18h
.text:0000BCB0
.text:0000BCB0                 push    ebp
.text:0000BCB1                 mov     ebp, esp
.text:0000BCB3                 sub     esp, 8
.text:0000BCB6                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000BCBD                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000BCC4                 mov     [ebp+var_4], ecx
.text:0000BCC7                 mov     ecx, [ebp+var_4]
.text:0000BCCA                 call    ?ReserveOnePosition@?$CRecordVector@UCUpdatePair2@@@@AAEXXZ ; CRecordVector<CUpdatePair2>::ReserveOnePosition(void)
.text:0000BCCF                 mov     eax, [ebp+var_4]
.text:0000BCD2                 mov     ecx, [eax+4]
.text:0000BCD5                 imul    ecx, 14h
.text:0000BCD8                 mov     edx, [ebp+var_4]
.text:0000BCDB                 mov     eax, [edx]
.text:0000BCDD                 add     eax, ecx
.text:0000BCDF                 mov     ecx, [ebp+arg_0]
.text:0000BCE2                 mov     [eax], ecx
.text:0000BCE4                 mov     edx, [ebp+arg_4]
.text:0000BCE7                 mov     [eax+4], edx
.text:0000BCEA                 mov     ecx, [ebp+arg_8]
.text:0000BCED                 mov     [eax+8], ecx
.text:0000BCF0                 mov     edx, [ebp+arg_C]
.text:0000BCF3                 mov     [eax+0Ch], edx
.text:0000BCF6                 mov     ecx, [ebp+arg_10]
.text:0000BCF9                 mov     [eax+10h], ecx
.text:0000BCFC                 mov     edx, [ebp+var_4]
.text:0000BCFF                 mov     eax, [edx+4]
.text:0000BD02                 mov     [ebp+var_8], eax
.text:0000BD05                 mov     ecx, [ebp+var_4]
.text:0000BD08                 mov     edx, [ecx+4]
.text:0000BD0B                 add     edx, 1
.text:0000BD0E                 mov     eax, [ebp+var_4]
.text:0000BD11                 mov     [eax+4], edx
.text:0000BD14                 mov     eax, [ebp+var_8]
.text:0000BD17                 add     esp, 8
.text:0000BD1A                 cmp     ebp, esp
.text:0000BD1C                 call    __RTC_CheckEsp
.text:0000BD21                 mov     esp, ebp
.text:0000BD23                 pop     ebp
.text:0000BD24                 retn    14h
.text:0000BD24 ?Add@?$CRecordVector@UCUpdatePair2@@@@QAEIUCUpdatePair2@@@Z endp
.text:0000BD24
.text:0000BD24 ; ---------------------------------------------------------------------------
.text:0000BD27                 align 4
.text:0000BD27 _text           ends
.text:0000BD27
.text:0000BD28 ; ===========================================================================
.text:0000BD28
.text:0000BD28 ; Segment type: Pure code
.text:0000BD28 ; Segment permissions: Read/Execute
.text:0000BD28 _text           segment para public 'CODE' use32
.text:0000BD28                 assume cs:_text
.text:0000BD28                 ;org 0BD28h
.text:0000BD28 ; COMDAT (pick any)
.text:0000BD28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BD28
.text:0000BD28 ; =============== S U B R O U T I N E =======================================
.text:0000BD28
.text:0000BD28 ; Attributes: bp-based frame
.text:0000BD28
.text:0000BD28 ; public: struct CUpdatePair2 & __thiscall CRecordVector<struct CUpdatePair2>::operator[](unsigned int)
.text:0000BD28                 public ??A?$CRecordVector@UCUpdatePair2@@@@QAEAAUCUpdatePair2@@I@Z
.text:0000BD28 ??A?$CRecordVector@UCUpdatePair2@@@@QAEAAUCUpdatePair2@@I@Z proc near
.text:0000BD28                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+60Ap
.text:0000BD28                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+194Ap
.text:0000BD28
.text:0000BD28 var_4           = dword ptr -4
.text:0000BD28 arg_0           = dword ptr  8
.text:0000BD28
.text:0000BD28                 push    ebp
.text:0000BD29                 mov     ebp, esp
.text:0000BD2B                 push    ecx
.text:0000BD2C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000BD33                 mov     [ebp+var_4], ecx
.text:0000BD36                 mov     eax, [ebp+arg_0]
.text:0000BD39                 imul    eax, 14h
.text:0000BD3C                 mov     ecx, [ebp+var_4]
.text:0000BD3F                 add     eax, [ecx]
.text:0000BD41                 mov     esp, ebp
.text:0000BD43                 pop     ebp
.text:0000BD44                 retn    4
.text:0000BD44 ??A?$CRecordVector@UCUpdatePair2@@@@QAEAAUCUpdatePair2@@I@Z endp
.text:0000BD44
.text:0000BD44 ; ---------------------------------------------------------------------------
.text:0000BD47                 align 4
.text:0000BD47 _text           ends
.text:0000BD47
.text:0000BD48 ; ===========================================================================
.text:0000BD48
.text:0000BD48 ; Segment type: Pure code
.text:0000BD48 ; Segment permissions: Read/Execute
.text:0000BD48 _text           segment para public 'CODE' use32
.text:0000BD48                 assume cs:_text
.text:0000BD48                 ;org 0BD48h
.text:0000BD48 ; COMDAT (pick any)
.text:0000BD48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BD48
.text:0000BD48 ; =============== S U B R O U T I N E =======================================
.text:0000BD48
.text:0000BD48 ; Attributes: bp-based frame
.text:0000BD48
.text:0000BD48 ; public: __thiscall CRecordVector<struct CUpdatePair>::CRecordVector<struct CUpdatePair>(void)
.text:0000BD48                 public ??0?$CRecordVector@UCUpdatePair@@@@QAE@XZ
.text:0000BD48 ??0?$CRecordVector@UCUpdatePair@@@@QAE@XZ proc near
.text:0000BD48                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+563p
.text:0000BD48
.text:0000BD48 var_4           = dword ptr -4
.text:0000BD48
.text:0000BD48                 push    ebp
.text:0000BD49                 mov     ebp, esp
.text:0000BD4B                 push    ecx
.text:0000BD4C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000BD53                 mov     [ebp+var_4], ecx
.text:0000BD56                 mov     eax, [ebp+var_4]
.text:0000BD59                 mov     dword ptr [eax], 0
.text:0000BD5F                 mov     ecx, [ebp+var_4]
.text:0000BD62                 mov     dword ptr [ecx+4], 0
.text:0000BD69                 mov     edx, [ebp+var_4]
.text:0000BD6C                 mov     dword ptr [edx+8], 0
.text:0000BD73                 mov     eax, [ebp+var_4]
.text:0000BD76                 mov     esp, ebp
.text:0000BD78                 pop     ebp
.text:0000BD79                 retn
.text:0000BD79 ??0?$CRecordVector@UCUpdatePair@@@@QAE@XZ endp
.text:0000BD79
.text:0000BD79 ; ---------------------------------------------------------------------------
.text:0000BD7A                 align 4
.text:0000BD7A _text           ends
.text:0000BD7A
.text:0000BD7C ; ===========================================================================
.text:0000BD7C
.text:0000BD7C ; Segment type: Pure code
.text:0000BD7C ; Segment permissions: Read/Execute
.text:0000BD7C _text           segment para public 'CODE' use32
.text:0000BD7C                 assume cs:_text
.text:0000BD7C                 ;org 0BD7Ch
.text:0000BD7C ; COMDAT (pick any)
.text:0000BD7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BD7C
.text:0000BD7C ; =============== S U B R O U T I N E =======================================
.text:0000BD7C
.text:0000BD7C ; Attributes: bp-based frame
.text:0000BD7C
.text:0000BD7C ; public: __thiscall CRecordVector<struct CUpdatePair>::~CRecordVector<struct CUpdatePair>(void)
.text:0000BD7C                 public ??1?$CRecordVector@UCUpdatePair@@@@QAE@XZ
.text:0000BD7C ??1?$CRecordVector@UCUpdatePair@@@@QAE@XZ proc near
.text:0000BD7C                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+5C6p
.text:0000BD7C                                         ; __unwindfunclet$?Compress@@YGJABUCUpdateOptions@@_NPAVCCodecs@@ABUCActionSet@NUpdateArchive@@PBVCArc@@AAUCArchivePath@@ABV?$CObjectVector@UCArcItem@@@@PAEABVCDirItems@@PBUCDirItem@@AAVCTempFiles@@AAUCUpdateErrorInfo@@PAUIUpdateCallbackUI@@AAUCFinishArchiveStat@@@Z$6+6j
.text:0000BD7C
.text:0000BD7C var_8           = dword ptr -8
.text:0000BD7C var_4           = dword ptr -4
.text:0000BD7C
.text:0000BD7C                 push    ebp
.text:0000BD7D                 mov     ebp, esp
.text:0000BD7F                 sub     esp, 8
.text:0000BD82                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000BD89                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000BD90                 mov     [ebp+var_4], ecx
.text:0000BD93                 mov     eax, [ebp+var_4]
.text:0000BD96                 mov     ecx, [eax]
.text:0000BD98                 mov     [ebp+var_8], ecx
.text:0000BD9B                 mov     edx, [ebp+var_8]
.text:0000BD9E                 push    edx             ; void *
.text:0000BD9F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000BDA4                 add     esp, 4
.text:0000BDA7                 add     esp, 8
.text:0000BDAA                 cmp     ebp, esp
.text:0000BDAC                 call    __RTC_CheckEsp
.text:0000BDB1                 mov     esp, ebp
.text:0000BDB3                 pop     ebp
.text:0000BDB4                 retn
.text:0000BDB4 ??1?$CRecordVector@UCUpdatePair@@@@QAE@XZ endp
.text:0000BDB4
.text:0000BDB4 ; ---------------------------------------------------------------------------
.text:0000BDB5                 align 4
.text:0000BDB5 _text           ends
.text:0000BDB5
.text:0000BDB8 ; ===========================================================================
.text:0000BDB8
.text:0000BDB8 ; Segment type: Pure code
.text:0000BDB8 ; Segment permissions: Read/Execute
.text:0000BDB8 _text           segment para public 'CODE' use32
.text:0000BDB8                 assume cs:_text
.text:0000BDB8                 ;org 0BDB8h
.text:0000BDB8 ; COMDAT (pick any)
.text:0000BDB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BDB8
.text:0000BDB8 ; =============== S U B R O U T I N E =======================================
.text:0000BDB8
.text:0000BDB8 ; Attributes: bp-based frame
.text:0000BDB8
.text:0000BDB8 ; public: __thiscall CMyComPtr<struct IArchiveUpdateCallback>::CMyComPtr<struct IArchiveUpdateCallback>(struct IArchiveUpdateCallback *)
.text:0000BDB8                 public ??0?$CMyComPtr@UIArchiveUpdateCallback@@@@QAE@PAUIArchiveUpdateCallback@@@Z
.text:0000BDB8 ??0?$CMyComPtr@UIArchiveUpdateCallback@@@@QAE@PAUIArchiveUpdateCallback@@@Z proc near
.text:0000BDB8                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+6FAp
.text:0000BDB8
.text:0000BDB8 var_4           = dword ptr -4
.text:0000BDB8 arg_0           = dword ptr  8
.text:0000BDB8
.text:0000BDB8                 push    ebp
.text:0000BDB9                 mov     ebp, esp
.text:0000BDBB                 push    ecx
.text:0000BDBC                 push    esi
.text:0000BDBD                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000BDC4                 mov     [ebp+var_4], ecx
.text:0000BDC7                 mov     eax, [ebp+var_4]
.text:0000BDCA                 mov     ecx, [ebp+arg_0]
.text:0000BDCD                 mov     [eax], ecx
.text:0000BDCF                 cmp     [ebp+arg_0], 0
.text:0000BDD3                 jz      short loc_BDEC
.text:0000BDD5                 mov     edx, [ebp+arg_0]
.text:0000BDD8                 mov     eax, [edx]
.text:0000BDDA                 mov     esi, esp
.text:0000BDDC                 mov     ecx, [ebp+arg_0]
.text:0000BDDF                 push    ecx
.text:0000BDE0                 mov     edx, [eax+4]
.text:0000BDE3                 call    edx
.text:0000BDE5                 cmp     esi, esp
.text:0000BDE7                 call    __RTC_CheckEsp
.text:0000BDEC
.text:0000BDEC loc_BDEC:                               ; CODE XREF: CMyComPtr<IArchiveUpdateCallback>::CMyComPtr<IArchiveUpdateCallback>(IArchiveUpdateCallback *)+1Bj
.text:0000BDEC                 mov     eax, [ebp+var_4]
.text:0000BDEF                 pop     esi
.text:0000BDF0                 add     esp, 4
.text:0000BDF3                 cmp     ebp, esp
.text:0000BDF5                 call    __RTC_CheckEsp
.text:0000BDFA                 mov     esp, ebp
.text:0000BDFC                 pop     ebp
.text:0000BDFD                 retn    4
.text:0000BDFD ??0?$CMyComPtr@UIArchiveUpdateCallback@@@@QAE@PAUIArchiveUpdateCallback@@@Z endp
.text:0000BDFD
.text:0000BDFD _text           ends
.text:0000BDFD
.text:0000BE00 ; ===========================================================================
.text:0000BE00
.text:0000BE00 ; Segment type: Pure code
.text:0000BE00 ; Segment permissions: Read/Execute
.text:0000BE00 _text           segment para public 'CODE' use32
.text:0000BE00                 assume cs:_text
.text:0000BE00                 ;org 0BE00h
.text:0000BE00 ; COMDAT (pick any)
.text:0000BE00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BE00
.text:0000BE00 ; =============== S U B R O U T I N E =======================================
.text:0000BE00
.text:0000BE00 ; Attributes: bp-based frame
.text:0000BE00
.text:0000BE00 ; public: __thiscall CMyComPtr<struct IArchiveUpdateCallback>::~CMyComPtr<struct IArchiveUpdateCallback>(void)
.text:0000BE00                 public ??1?$CMyComPtr@UIArchiveUpdateCallback@@@@QAE@XZ
.text:0000BE00 ??1?$CMyComPtr@UIArchiveUpdateCallback@@@@QAE@XZ proc near
.text:0000BE00                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+BE5p
.text:0000BE00                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+C70p ...
.text:0000BE00
.text:0000BE00 var_4           = dword ptr -4
.text:0000BE00
.text:0000BE00                 push    ebp
.text:0000BE01                 mov     ebp, esp
.text:0000BE03                 push    ecx
.text:0000BE04                 push    esi
.text:0000BE05                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000BE0C                 mov     [ebp+var_4], ecx
.text:0000BE0F                 mov     eax, [ebp+var_4]
.text:0000BE12                 cmp     dword ptr [eax], 0
.text:0000BE15                 jz      short loc_BE32
.text:0000BE17                 mov     ecx, [ebp+var_4]
.text:0000BE1A                 mov     edx, [ecx]
.text:0000BE1C                 mov     eax, [ebp+var_4]
.text:0000BE1F                 mov     ecx, [eax]
.text:0000BE21                 mov     edx, [edx]
.text:0000BE23                 mov     esi, esp
.text:0000BE25                 push    ecx
.text:0000BE26                 mov     eax, [edx+8]
.text:0000BE29                 call    eax
.text:0000BE2B                 cmp     esi, esp
.text:0000BE2D                 call    __RTC_CheckEsp
.text:0000BE32
.text:0000BE32 loc_BE32:                               ; CODE XREF: CMyComPtr<IArchiveUpdateCallback>::~CMyComPtr<IArchiveUpdateCallback>(void)+15j
.text:0000BE32                 pop     esi
.text:0000BE33                 add     esp, 4
.text:0000BE36                 cmp     ebp, esp
.text:0000BE38                 call    __RTC_CheckEsp
.text:0000BE3D                 mov     esp, ebp
.text:0000BE3F                 pop     ebp
.text:0000BE40                 retn
.text:0000BE40 ??1?$CMyComPtr@UIArchiveUpdateCallback@@@@QAE@XZ endp
.text:0000BE40
.text:0000BE40 ; ---------------------------------------------------------------------------
.text:0000BE41                 align 4
.text:0000BE41 _text           ends
.text:0000BE41
.text:0000BE44 ; ===========================================================================
.text:0000BE44
.text:0000BE44 ; Segment type: Pure code
.text:0000BE44 ; Segment permissions: Read/Execute
.text:0000BE44 _text           segment para public 'CODE' use32
.text:0000BE44                 assume cs:_text
.text:0000BE44                 ;org 0BE44h
.text:0000BE44 ; COMDAT (pick any)
.text:0000BE44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BE44
.text:0000BE44 ; =============== S U B R O U T I N E =======================================
.text:0000BE44
.text:0000BE44 ; Attributes: bp-based frame
.text:0000BE44
.text:0000BE44 ; public: __thiscall CMyComPtr<struct IArchiveUpdateCallback>::operator struct IArchiveUpdateCallback *(void)const
.text:0000BE44                 public ??B?$CMyComPtr@UIArchiveUpdateCallback@@@@QBEPAUIArchiveUpdateCallback@@XZ
.text:0000BE44 ??B?$CMyComPtr@UIArchiveUpdateCallback@@@@QBEPAUIArchiveUpdateCallback@@XZ proc near
.text:0000BE44                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+176Bp
.text:0000BE44
.text:0000BE44 var_4           = dword ptr -4
.text:0000BE44
.text:0000BE44                 push    ebp
.text:0000BE45                 mov     ebp, esp
.text:0000BE47                 push    ecx
.text:0000BE48                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000BE4F                 mov     [ebp+var_4], ecx
.text:0000BE52                 mov     eax, [ebp+var_4]
.text:0000BE55                 mov     eax, [eax]
.text:0000BE57                 mov     esp, ebp
.text:0000BE59                 pop     ebp
.text:0000BE5A                 retn
.text:0000BE5A ??B?$CMyComPtr@UIArchiveUpdateCallback@@@@QBEPAUIArchiveUpdateCallback@@XZ endp
.text:0000BE5A
.text:0000BE5A ; ---------------------------------------------------------------------------
.text:0000BE5B                 align 4
.text:0000BE5B _text           ends
.text:0000BE5B
.text:0000BE5C ; ===========================================================================
.text:0000BE5C
.text:0000BE5C ; Segment type: Pure code
.text:0000BE5C ; Segment permissions: Read/Execute
.text:0000BE5C _text           segment para public 'CODE' use32
.text:0000BE5C                 assume cs:_text
.text:0000BE5C                 ;org 0BE5Ch
.text:0000BE5C ; COMDAT (pick any)
.text:0000BE5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BE5C
.text:0000BE5C ; =============== S U B R O U T I N E =======================================
.text:0000BE5C
.text:0000BE5C ; Attributes: bp-based frame
.text:0000BE5C
.text:0000BE5C ; public: __thiscall CRecordVector<struct CRefSortPair>::CRecordVector<struct CRefSortPair>(void)
.text:0000BE5C                 public ??0?$CRecordVector@UCRefSortPair@@@@QAE@XZ
.text:0000BE5C ??0?$CRecordVector@UCRefSortPair@@@@QAE@XZ proc near
.text:0000BE5C                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+2300p
.text:0000BE5C
.text:0000BE5C var_4           = dword ptr -4
.text:0000BE5C
.text:0000BE5C                 push    ebp
.text:0000BE5D                 mov     ebp, esp
.text:0000BE5F                 push    ecx
.text:0000BE60                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000BE67                 mov     [ebp+var_4], ecx
.text:0000BE6A                 mov     eax, [ebp+var_4]
.text:0000BE6D                 mov     dword ptr [eax], 0
.text:0000BE73                 mov     ecx, [ebp+var_4]
.text:0000BE76                 mov     dword ptr [ecx+4], 0
.text:0000BE7D                 mov     edx, [ebp+var_4]
.text:0000BE80                 mov     dword ptr [edx+8], 0
.text:0000BE87                 mov     eax, [ebp+var_4]
.text:0000BE8A                 mov     esp, ebp
.text:0000BE8C                 pop     ebp
.text:0000BE8D                 retn
.text:0000BE8D ??0?$CRecordVector@UCRefSortPair@@@@QAE@XZ endp
.text:0000BE8D
.text:0000BE8D ; ---------------------------------------------------------------------------
.text:0000BE8E                 align 10h
.text:0000BE8E _text           ends
.text:0000BE8E
.text:0000BE90 ; ===========================================================================
.text:0000BE90
.text:0000BE90 ; Segment type: Pure code
.text:0000BE90 ; Segment permissions: Read/Execute
.text:0000BE90 _text           segment para public 'CODE' use32
.text:0000BE90                 assume cs:_text
.text:0000BE90                 ;org 0BE90h
.text:0000BE90 ; COMDAT (pick any)
.text:0000BE90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BE90
.text:0000BE90 ; =============== S U B R O U T I N E =======================================
.text:0000BE90
.text:0000BE90 ; Attributes: bp-based frame
.text:0000BE90
.text:0000BE90 ; public: unsigned int __thiscall CRecordVector<struct CRefSortPair>::Size(void)const
.text:0000BE90                 public ?Size@?$CRecordVector@UCRefSortPair@@@@QBEIXZ
.text:0000BE90 ?Size@?$CRecordVector@UCRefSortPair@@@@QBEIXZ proc near
.text:0000BE90                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+2566p
.text:0000BE90
.text:0000BE90 var_4           = dword ptr -4
.text:0000BE90
.text:0000BE90                 push    ebp
.text:0000BE91                 mov     ebp, esp
.text:0000BE93                 push    ecx
.text:0000BE94                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000BE9B                 mov     [ebp+var_4], ecx
.text:0000BE9E                 mov     eax, [ebp+var_4]
.text:0000BEA1                 mov     eax, [eax+4]
.text:0000BEA4                 mov     esp, ebp
.text:0000BEA6                 pop     ebp
.text:0000BEA7                 retn
.text:0000BEA7 ?Size@?$CRecordVector@UCRefSortPair@@@@QBEIXZ endp
.text:0000BEA7
.text:0000BEA7 _text           ends
.text:0000BEA7
.text:0000BEA8 ; ===========================================================================
.text:0000BEA8
.text:0000BEA8 ; Segment type: Pure code
.text:0000BEA8 ; Segment permissions: Read/Execute
.text:0000BEA8 _text           segment para public 'CODE' use32
.text:0000BEA8                 assume cs:_text
.text:0000BEA8                 ;org 0BEA8h
.text:0000BEA8 ; COMDAT (pick any)
.text:0000BEA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BEA8
.text:0000BEA8 ; =============== S U B R O U T I N E =======================================
.text:0000BEA8
.text:0000BEA8 ; Attributes: bp-based frame
.text:0000BEA8
.text:0000BEA8 ; public: __thiscall CRecordVector<struct CRefSortPair>::~CRecordVector<struct CRefSortPair>(void)
.text:0000BEA8                 public ??1?$CRecordVector@UCRefSortPair@@@@QAE@XZ
.text:0000BEA8 ??1?$CRecordVector@UCRefSortPair@@@@QAE@XZ proc near
.text:0000BEA8                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+2474p
.text:0000BEA8                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+2625p ...
.text:0000BEA8
.text:0000BEA8 var_8           = dword ptr -8
.text:0000BEA8 var_4           = dword ptr -4
.text:0000BEA8
.text:0000BEA8                 push    ebp
.text:0000BEA9                 mov     ebp, esp
.text:0000BEAB                 sub     esp, 8
.text:0000BEAE                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000BEB5                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000BEBC                 mov     [ebp+var_4], ecx
.text:0000BEBF                 mov     eax, [ebp+var_4]
.text:0000BEC2                 mov     ecx, [eax]
.text:0000BEC4                 mov     [ebp+var_8], ecx
.text:0000BEC7                 mov     edx, [ebp+var_8]
.text:0000BECA                 push    edx             ; void *
.text:0000BECB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000BED0                 add     esp, 4
.text:0000BED3                 add     esp, 8
.text:0000BED6                 cmp     ebp, esp
.text:0000BED8                 call    __RTC_CheckEsp
.text:0000BEDD                 mov     esp, ebp
.text:0000BEDF                 pop     ebp
.text:0000BEE0                 retn
.text:0000BEE0 ??1?$CRecordVector@UCRefSortPair@@@@QAE@XZ endp
.text:0000BEE0
.text:0000BEE0 ; ---------------------------------------------------------------------------
.text:0000BEE1                 align 4
.text:0000BEE1 _text           ends
.text:0000BEE1
.text:0000BEE4 ; ===========================================================================
.text:0000BEE4
.text:0000BEE4 ; Segment type: Pure code
.text:0000BEE4 ; Segment permissions: Read/Execute
.text:0000BEE4 _text           segment para public 'CODE' use32
.text:0000BEE4                 assume cs:_text
.text:0000BEE4                 ;org 0BEE4h
.text:0000BEE4 ; COMDAT (pick any)
.text:0000BEE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BEE4
.text:0000BEE4 ; =============== S U B R O U T I N E =======================================
.text:0000BEE4
.text:0000BEE4 ; Attributes: bp-based frame
.text:0000BEE4
.text:0000BEE4 ; public: unsigned int __thiscall CRecordVector<struct CRefSortPair>::Add(struct CRefSortPair)
.text:0000BEE4                 public ?Add@?$CRecordVector@UCRefSortPair@@@@QAEIUCRefSortPair@@@Z
.text:0000BEE4 ?Add@?$CRecordVector@UCRefSortPair@@@@QAEIUCRefSortPair@@@Z proc near
.text:0000BEE4                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+23C8p
.text:0000BEE4
.text:0000BEE4 var_8           = dword ptr -8
.text:0000BEE4 var_4           = dword ptr -4
.text:0000BEE4 arg_0           = dword ptr  8
.text:0000BEE4 arg_4           = dword ptr  0Ch
.text:0000BEE4
.text:0000BEE4                 push    ebp
.text:0000BEE5                 mov     ebp, esp
.text:0000BEE7                 sub     esp, 8
.text:0000BEEA                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000BEF1                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000BEF8                 mov     [ebp+var_4], ecx
.text:0000BEFB                 mov     ecx, [ebp+var_4]
.text:0000BEFE                 call    ?ReserveOnePosition@?$CRecordVector@UCRefSortPair@@@@AAEXXZ ; CRecordVector<CRefSortPair>::ReserveOnePosition(void)
.text:0000BF03                 mov     eax, [ebp+var_4]
.text:0000BF06                 mov     ecx, [eax+4]
.text:0000BF09                 mov     edx, [ebp+var_4]
.text:0000BF0C                 mov     eax, [edx]
.text:0000BF0E                 mov     edx, [ebp+arg_0]
.text:0000BF11                 mov     [eax+ecx*8], edx
.text:0000BF14                 mov     edx, [ebp+arg_4]
.text:0000BF17                 mov     [eax+ecx*8+4], edx
.text:0000BF1B                 mov     eax, [ebp+var_4]
.text:0000BF1E                 mov     ecx, [eax+4]
.text:0000BF21                 mov     [ebp+var_8], ecx
.text:0000BF24                 mov     edx, [ebp+var_4]
.text:0000BF27                 mov     eax, [edx+4]
.text:0000BF2A                 add     eax, 1
.text:0000BF2D                 mov     ecx, [ebp+var_4]
.text:0000BF30                 mov     [ecx+4], eax
.text:0000BF33                 mov     eax, [ebp+var_8]
.text:0000BF36                 add     esp, 8
.text:0000BF39                 cmp     ebp, esp
.text:0000BF3B                 call    __RTC_CheckEsp
.text:0000BF40                 mov     esp, ebp
.text:0000BF42                 pop     ebp
.text:0000BF43                 retn    8
.text:0000BF43 ?Add@?$CRecordVector@UCRefSortPair@@@@QAEIUCRefSortPair@@@Z endp
.text:0000BF43
.text:0000BF43 ; ---------------------------------------------------------------------------
.text:0000BF46                 align 4
.text:0000BF46 _text           ends
.text:0000BF46
.text:0000BF48 ; ===========================================================================
.text:0000BF48
.text:0000BF48 ; Segment type: Pure code
.text:0000BF48 ; Segment permissions: Read/Execute
.text:0000BF48 _text           segment para public 'CODE' use32
.text:0000BF48                 assume cs:_text
.text:0000BF48                 ;org 0BF48h
.text:0000BF48 ; COMDAT (pick any)
.text:0000BF48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BF48
.text:0000BF48 ; =============== S U B R O U T I N E =======================================
.text:0000BF48
.text:0000BF48 ; Attributes: bp-based frame
.text:0000BF48
.text:0000BF48 ; public: struct CRefSortPair & __thiscall CRecordVector<struct CRefSortPair>::operator[](unsigned int)
.text:0000BF48                 public ??A?$CRecordVector@UCRefSortPair@@@@QAEAAUCRefSortPair@@I@Z
.text:0000BF48 ??A?$CRecordVector@UCRefSortPair@@@@QAEAAUCRefSortPair@@I@Z proc near
.text:0000BF48                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+2584p
.text:0000BF48
.text:0000BF48 var_4           = dword ptr -4
.text:0000BF48 arg_0           = dword ptr  8
.text:0000BF48
.text:0000BF48                 push    ebp
.text:0000BF49                 mov     ebp, esp
.text:0000BF4B                 push    ecx
.text:0000BF4C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000BF53                 mov     [ebp+var_4], ecx
.text:0000BF56                 mov     eax, [ebp+var_4]
.text:0000BF59                 mov     ecx, [eax]
.text:0000BF5B                 mov     edx, [ebp+arg_0]
.text:0000BF5E                 lea     eax, [ecx+edx*8]
.text:0000BF61                 mov     esp, ebp
.text:0000BF63                 pop     ebp
.text:0000BF64                 retn    4
.text:0000BF64 ??A?$CRecordVector@UCRefSortPair@@@@QAEAAUCRefSortPair@@I@Z endp
.text:0000BF64
.text:0000BF64 ; ---------------------------------------------------------------------------
.text:0000BF67                 align 4
.text:0000BF67 _text           ends
.text:0000BF67
.text:0000BF68 ; ===========================================================================
.text:0000BF68
.text:0000BF68 ; Segment type: Pure code
.text:0000BF68 ; Segment permissions: Read/Execute
.text:0000BF68 _text           segment para public 'CODE' use32
.text:0000BF68                 assume cs:_text
.text:0000BF68                 ;org 0BF68h
.text:0000BF68 ; COMDAT (pick any)
.text:0000BF68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000BF68
.text:0000BF68 ; =============== S U B R O U T I N E =======================================
.text:0000BF68
.text:0000BF68 ; Attributes: bp-based frame
.text:0000BF68
.text:0000BF68 ; public: void __thiscall CRecordVector<struct CRefSortPair>::Sort(int (__stdcall *)(struct CRefSortPair const *, struct CRefSortPair const *, void *), void *)
.text:0000BF68                 public ?Sort@?$CRecordVector@UCRefSortPair@@@@QAEXP6GHPBUCRefSortPair@@0PAX@Z1@Z
.text:0000BF68 ?Sort@?$CRecordVector@UCRefSortPair@@@@QAEXP6GHPBUCRefSortPair@@0PAX@Z1@Z proc near
.text:0000BF68                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+2540p
.text:0000BF68
.text:0000BF68 var_20          = dword ptr -20h
.text:0000BF68 var_1C          = dword ptr -1Ch
.text:0000BF68 var_18          = dword ptr -18h
.text:0000BF68 var_14          = dword ptr -14h
.text:0000BF68 var_10          = dword ptr -10h
.text:0000BF68 var_C           = dword ptr -0Ch
.text:0000BF68 var_8           = dword ptr -8
.text:0000BF68 var_4           = dword ptr -4
.text:0000BF68 arg_0           = dword ptr  8
.text:0000BF68 arg_4           = dword ptr  0Ch
.text:0000BF68
.text:0000BF68                 push    ebp
.text:0000BF69                 mov     ebp, esp
.text:0000BF6B                 sub     esp, 20h
.text:0000BF6E                 push    esi
.text:0000BF6F                 mov     eax, 0CCCCCCCCh
.text:0000BF74                 mov     [ebp+var_20], eax
.text:0000BF77                 mov     [ebp+var_1C], eax
.text:0000BF7A                 mov     [ebp+var_18], eax
.text:0000BF7D                 mov     [ebp+var_14], eax
.text:0000BF80                 mov     [ebp+var_10], eax
.text:0000BF83                 mov     [ebp+var_C], eax
.text:0000BF86                 mov     [ebp+var_8], eax
.text:0000BF89                 mov     [ebp+var_4], eax
.text:0000BF8C                 mov     [ebp+var_4], ecx
.text:0000BF8F                 mov     eax, [ebp+var_4]
.text:0000BF92                 mov     ecx, [eax+4]
.text:0000BF95                 mov     [ebp+var_8], ecx
.text:0000BF98                 cmp     [ebp+var_8], 1
.text:0000BF9C                 ja      short loc_BFA3
.text:0000BF9E                 jmp     loc_C03B
.text:0000BFA3 ; ---------------------------------------------------------------------------
.text:0000BFA3
.text:0000BFA3 loc_BFA3:                               ; CODE XREF: CRecordVector<CRefSortPair>::Sort(int (*)(CRefSortPair const *,CRefSortPair const *,void *),void *)+34j
.text:0000BFA3                 mov     ecx, [ebp+var_4]
.text:0000BFA6                 call    ?Front@?$CRecordVector@UCRefSortPair@@@@QAEAAUCRefSortPair@@XZ ; CRecordVector<CRefSortPair>::Front(void)
.text:0000BFAB                 sub     eax, 8
.text:0000BFAE                 mov     [ebp+var_C], eax
.text:0000BFB1                 mov     edx, [ebp+var_8]
.text:0000BFB4                 shr     edx, 1
.text:0000BFB6                 mov     [ebp+var_10], edx
.text:0000BFB9
.text:0000BFB9 loc_BFB9:                               ; CODE XREF: CRecordVector<CRefSortPair>::Sort(int (*)(CRefSortPair const *,CRefSortPair const *,void *),void *)+73j
.text:0000BFB9                 mov     eax, [ebp+arg_4]
.text:0000BFBC                 push    eax
.text:0000BFBD                 mov     ecx, [ebp+arg_0]
.text:0000BFC0                 push    ecx
.text:0000BFC1                 mov     edx, [ebp+var_8]
.text:0000BFC4                 push    edx
.text:0000BFC5                 mov     eax, [ebp+var_10]
.text:0000BFC8                 push    eax
.text:0000BFC9                 mov     ecx, [ebp+var_C]
.text:0000BFCC                 push    ecx
.text:0000BFCD                 call    ?SortRefDown@?$CRecordVector@UCRefSortPair@@@@SGXPAUCRefSortPair@@IIP6GHPBU2@1PAX@Z2@Z ; CRecordVector<CRefSortPair>::SortRefDown(CRefSortPair *,uint,uint,int (*)(CRefSortPair const *,CRefSortPair const *,void *),void *)
.text:0000BFD2                 mov     edx, [ebp+var_10]
.text:0000BFD5                 sub     edx, 1
.text:0000BFD8                 mov     [ebp+var_10], edx
.text:0000BFDB                 jnz     short loc_BFB9
.text:0000BFDD
.text:0000BFDD loc_BFDD:                               ; CODE XREF: CRecordVector<CRefSortPair>::Sort(int (*)(CRefSortPair const *,CRefSortPair const *,void *),void *)+D1j
.text:0000BFDD                 mov     eax, [ebp+var_8]
.text:0000BFE0                 mov     ecx, [ebp+var_C]
.text:0000BFE3                 mov     edx, [ecx+eax*8]
.text:0000BFE6                 mov     eax, [ecx+eax*8+4]
.text:0000BFEA                 mov     [ebp+var_1C], edx
.text:0000BFED                 mov     [ebp+var_18], eax
.text:0000BFF0                 mov     ecx, [ebp+var_C]
.text:0000BFF3                 mov     edx, [ecx+8]
.text:0000BFF6                 mov     eax, [ecx+0Ch]
.text:0000BFF9                 mov     ecx, [ebp+var_8]
.text:0000BFFC                 mov     esi, [ebp+var_C]
.text:0000BFFF                 mov     [esi+ecx*8], edx
.text:0000C002                 mov     [esi+ecx*8+4], eax
.text:0000C006                 mov     edx, [ebp+var_8]
.text:0000C009                 sub     edx, 1
.text:0000C00C                 mov     [ebp+var_8], edx
.text:0000C00F                 mov     eax, [ebp+var_C]
.text:0000C012                 mov     ecx, [ebp+var_1C]
.text:0000C015                 mov     [eax+8], ecx
.text:0000C018                 mov     edx, [ebp+var_18]
.text:0000C01B                 mov     [eax+0Ch], edx
.text:0000C01E                 mov     eax, [ebp+arg_4]
.text:0000C021                 push    eax
.text:0000C022                 mov     ecx, [ebp+arg_0]
.text:0000C025                 push    ecx
.text:0000C026                 mov     edx, [ebp+var_8]
.text:0000C029                 push    edx
.text:0000C02A                 push    1
.text:0000C02C                 mov     eax, [ebp+var_C]
.text:0000C02F                 push    eax
.text:0000C030                 call    ?SortRefDown@?$CRecordVector@UCRefSortPair@@@@SGXPAUCRefSortPair@@IIP6GHPBU2@1PAX@Z2@Z ; CRecordVector<CRefSortPair>::SortRefDown(CRefSortPair *,uint,uint,int (*)(CRefSortPair const *,CRefSortPair const *,void *),void *)
.text:0000C035                 cmp     [ebp+var_8], 1
.text:0000C039                 ja      short loc_BFDD
.text:0000C03B
.text:0000C03B loc_C03B:                               ; CODE XREF: CRecordVector<CRefSortPair>::Sort(int (*)(CRefSortPair const *,CRefSortPair const *,void *),void *)+36j
.text:0000C03B                 push    edx
.text:0000C03C                 mov     ecx, ebp
.text:0000C03E                 push    eax
.text:0000C03F                 lea     edx, $LN12_0
.text:0000C045                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:0000C04A                 pop     eax
.text:0000C04B                 pop     edx
.text:0000C04C                 pop     esi
.text:0000C04D                 add     esp, 20h
.text:0000C050                 cmp     ebp, esp
.text:0000C052                 call    __RTC_CheckEsp
.text:0000C057                 mov     esp, ebp
.text:0000C059                 pop     ebp
.text:0000C05A                 retn    8
.text:0000C05A ?Sort@?$CRecordVector@UCRefSortPair@@@@QAEXP6GHPBUCRefSortPair@@0PAX@Z1@Z endp
.text:0000C05A
.text:0000C05A ; ---------------------------------------------------------------------------
.text:0000C05D                 align 10h
.text:0000C060 $LN12_0         dd 1                    ; DATA XREF: CRecordVector<CRefSortPair>::Sort(int (*)(CRefSortPair const *,CRefSortPair const *,void *),void *)+D7o
.text:0000C064                 dd offset $LN11_0
.text:0000C068 $LN11_0         dd 0FFFFFFE4h, 8        ; DATA XREF: .text:0000C064o
.text:0000C070                 dd offset $LN10_5       ; "temp"
.text:0000C074 $LN10_5         db 'temp',0             ; DATA XREF: .text:0000C070o
.text:0000C079                 align 4
.text:0000C079 _text           ends
.text:0000C079
.text:0000C07C ; ===========================================================================
.text:0000C07C
.text:0000C07C ; Segment type: Pure code
.text:0000C07C ; Segment permissions: Read/Execute
.text:0000C07C _text           segment para public 'CODE' use32
.text:0000C07C                 assume cs:_text
.text:0000C07C                 ;org 0C07Ch
.text:0000C07C ; COMDAT (pick any)
.text:0000C07C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000C07C
.text:0000C07C ; =============== S U B R O U T I N E =======================================
.text:0000C07C
.text:0000C07C ; Attributes: bp-based frame
.text:0000C07C
.text:0000C07C ; public: void * __thiscall UString::`scalar deleting destructor'(unsigned int)
.text:0000C07C                 public ??_GUString@@QAEPAXI@Z
.text:0000C07C ??_GUString@@QAEPAXI@Z proc near        ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+7Fp
.text:0000C07C                                         ; CObjectVector<UString>::Clear(void)+59p
.text:0000C07C
.text:0000C07C var_4           = dword ptr -4
.text:0000C07C arg_0           = dword ptr  8
.text:0000C07C
.text:0000C07C                 push    ebp
.text:0000C07D                 mov     ebp, esp
.text:0000C07F                 push    ecx
.text:0000C080                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000C087                 mov     [ebp+var_4], ecx
.text:0000C08A                 mov     ecx, [ebp+var_4] ; this
.text:0000C08D                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000C092                 mov     eax, [ebp+arg_0]
.text:0000C095                 and     eax, 1
.text:0000C098                 jz      short loc_C0A6
.text:0000C09A                 mov     ecx, [ebp+var_4]
.text:0000C09D                 push    ecx             ; void *
.text:0000C09E                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000C0A3                 add     esp, 4
.text:0000C0A6
.text:0000C0A6 loc_C0A6:                               ; CODE XREF: UString::`scalar deleting destructor'(uint)+1Cj
.text:0000C0A6                 mov     eax, [ebp+var_4]
.text:0000C0A9                 add     esp, 4
.text:0000C0AC                 cmp     ebp, esp
.text:0000C0AE                 call    __RTC_CheckEsp
.text:0000C0B3                 mov     esp, ebp
.text:0000C0B5                 pop     ebp
.text:0000C0B6                 retn    4
.text:0000C0B6 ??_GUString@@QAEPAXI@Z endp
.text:0000C0B6
.text:0000C0B6 ; ---------------------------------------------------------------------------
.text:0000C0B9                 align 4
.text:0000C0B9 _text           ends
.text:0000C0B9
.text:0000C0BC ; ===========================================================================
.text:0000C0BC
.text:0000C0BC ; Segment type: Pure code
.text:0000C0BC ; Segment permissions: Read/Execute
.text:0000C0BC _text           segment para public 'CODE' use32
.text:0000C0BC                 assume cs:_text
.text:0000C0BC                 ;org 0C0BCh
.text:0000C0BC ; COMDAT (pick any)
.text:0000C0BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000C0BC
.text:0000C0BC ; =============== S U B R O U T I N E =======================================
.text:0000C0BC
.text:0000C0BC ; Attributes: bp-based frame
.text:0000C0BC
.text:0000C0BC ; public: void * __thiscall CBuffer<unsigned char>::`scalar deleting destructor'(unsigned int)
.text:0000C0BC                 public ??_G?$CBuffer@E@@QAEPAXI@Z
.text:0000C0BC ??_G?$CBuffer@E@@QAEPAXI@Z proc near    ; CODE XREF: CObjectVector<CBuffer<uchar>>::~CObjectVector<CBuffer<uchar>>(void)+7Fp
.text:0000C0BC
.text:0000C0BC var_4           = dword ptr -4
.text:0000C0BC arg_0           = dword ptr  8
.text:0000C0BC
.text:0000C0BC                 push    ebp
.text:0000C0BD                 mov     ebp, esp
.text:0000C0BF                 push    ecx
.text:0000C0C0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000C0C7                 mov     [ebp+var_4], ecx
.text:0000C0CA                 mov     ecx, [ebp+var_4]
.text:0000C0CD                 call    ??1?$CBuffer@E@@QAE@XZ ; CBuffer<uchar>::~CBuffer<uchar>(void)
.text:0000C0D2                 mov     eax, [ebp+arg_0]
.text:0000C0D5                 and     eax, 1
.text:0000C0D8                 jz      short loc_C0E6
.text:0000C0DA                 mov     ecx, [ebp+var_4]
.text:0000C0DD                 push    ecx             ; void *
.text:0000C0DE                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000C0E3                 add     esp, 4
.text:0000C0E6
.text:0000C0E6 loc_C0E6:                               ; CODE XREF: CBuffer<uchar>::`scalar deleting destructor'(uint)+1Cj
.text:0000C0E6                 mov     eax, [ebp+var_4]
.text:0000C0E9                 add     esp, 4
.text:0000C0EC                 cmp     ebp, esp
.text:0000C0EE                 call    __RTC_CheckEsp
.text:0000C0F3                 mov     esp, ebp
.text:0000C0F5                 pop     ebp
.text:0000C0F6                 retn    4
.text:0000C0F6 ??_G?$CBuffer@E@@QAEPAXI@Z endp
.text:0000C0F6
.text:0000C0F6 ; ---------------------------------------------------------------------------
.text:0000C0F9                 align 4
.text:0000C0F9 _text           ends
.text:0000C0F9
.text:0000C0FC ; ===========================================================================
.text:0000C0FC
.text:0000C0FC ; Segment type: Pure code
.text:0000C0FC ; Segment permissions: Read/Execute
.text:0000C0FC _text           segment para public 'CODE' use32
.text:0000C0FC                 assume cs:_text
.text:0000C0FC                 ;org 0C0FCh
.text:0000C0FC ; COMDAT (pick any)
.text:0000C0FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000C0FC
.text:0000C0FC ; =============== S U B R O U T I N E =======================================
.text:0000C0FC
.text:0000C0FC ; Attributes: bp-based frame
.text:0000C0FC
.text:0000C0FC ; public: void * __thiscall CArc::`scalar deleting destructor'(unsigned int)
.text:0000C0FC                 public ??_GCArc@@QAEPAXI@Z
.text:0000C0FC ??_GCArc@@QAEPAXI@Z proc near           ; CODE XREF: CObjectVector<CArc>::~CObjectVector<CArc>(void)+7Fp
.text:0000C0FC
.text:0000C0FC var_4           = dword ptr -4
.text:0000C0FC arg_0           = dword ptr  8
.text:0000C0FC
.text:0000C0FC                 push    ebp
.text:0000C0FD                 mov     ebp, esp
.text:0000C0FF                 push    ecx
.text:0000C100                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000C107                 mov     [ebp+var_4], ecx
.text:0000C10A                 mov     ecx, [ebp+var_4] ; this
.text:0000C10D                 call    ??1CArc@@QAE@XZ ; CArc::~CArc(void)
.text:0000C112                 mov     eax, [ebp+arg_0]
.text:0000C115                 and     eax, 1
.text:0000C118                 jz      short loc_C126
.text:0000C11A                 mov     ecx, [ebp+var_4]
.text:0000C11D                 push    ecx             ; void *
.text:0000C11E                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000C123                 add     esp, 4
.text:0000C126
.text:0000C126 loc_C126:                               ; CODE XREF: CArc::`scalar deleting destructor'(uint)+1Cj
.text:0000C126                 mov     eax, [ebp+var_4]
.text:0000C129                 add     esp, 4
.text:0000C12C                 cmp     ebp, esp
.text:0000C12E                 call    __RTC_CheckEsp
.text:0000C133                 mov     esp, ebp
.text:0000C135                 pop     ebp
.text:0000C136                 retn    4
.text:0000C136 ??_GCArc@@QAEPAXI@Z endp
.text:0000C136
.text:0000C136 ; ---------------------------------------------------------------------------
.text:0000C139                 align 4
.text:0000C139 _text           ends
.text:0000C139
.text:0000C13C ; ===========================================================================
.text:0000C13C
.text:0000C13C ; Segment type: Pure code
.text:0000C13C ; Segment permissions: Read/Execute
.text:0000C13C _text           segment para public 'CODE' use32
.text:0000C13C                 assume cs:_text
.text:0000C13C                 ;org 0C13Ch
.text:0000C13C ; COMDAT (pick any)
.text:0000C13C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000C13C
.text:0000C13C ; =============== S U B R O U T I N E =======================================
.text:0000C13C
.text:0000C13C ; Attributes: bp-based frame
.text:0000C13C
.text:0000C13C ; public: __thiscall CDirItem::CDirItem(struct CDirItem const &)
.text:0000C13C                 public ??0CDirItem@@QAE@ABU0@@Z
.text:0000C13C ??0CDirItem@@QAE@ABU0@@Z proc near      ; CODE XREF: CObjectVector<CDirItem>::Add(CDirItem const &)+5Ap
.text:0000C13C
.text:0000C13C var_10          = dword ptr -10h
.text:0000C13C var_C           = dword ptr -0Ch
.text:0000C13C var_4           = dword ptr -4
.text:0000C13C arg_0           = dword ptr  8
.text:0000C13C
.text:0000C13C                 push    ebp
.text:0000C13D                 mov     ebp, esp
.text:0000C13F                 push    0FFFFFFFFh
.text:0000C141                 push    offset __ehhandler$??0CDirItem@@QAE@ABU0@@Z
.text:0000C146                 mov     eax, large fs:0
.text:0000C14C                 push    eax
.text:0000C14D                 push    ecx
.text:0000C14E                 mov     [ebp+var_10], 0CCCCCCCCh
.text:0000C155                 mov     eax, dword ptr ds:___security_cookie
.text:0000C15A                 xor     eax, ebp
.text:0000C15C                 push    eax
.text:0000C15D                 lea     eax, [ebp+var_C]
.text:0000C160                 mov     large fs:0, eax
.text:0000C166                 mov     [ebp+var_10], ecx
.text:0000C169                 mov     eax, [ebp+var_10]
.text:0000C16C                 mov     ecx, [ebp+arg_0]
.text:0000C16F                 mov     edx, [ecx]
.text:0000C171                 mov     [eax], edx
.text:0000C173                 mov     ecx, [ecx+4]
.text:0000C176                 mov     [eax+4], ecx
.text:0000C179                 mov     edx, [ebp+arg_0]
.text:0000C17C                 mov     eax, [edx+8]
.text:0000C17F                 mov     ecx, [edx+0Ch]
.text:0000C182                 mov     edx, [ebp+var_10]
.text:0000C185                 mov     [edx+8], eax
.text:0000C188                 mov     [edx+0Ch], ecx
.text:0000C18B                 mov     eax, [ebp+arg_0]
.text:0000C18E                 mov     ecx, [eax+10h]
.text:0000C191                 mov     edx, [eax+14h]
.text:0000C194                 mov     eax, [ebp+var_10]
.text:0000C197                 mov     [eax+10h], ecx
.text:0000C19A                 mov     [eax+14h], edx
.text:0000C19D                 mov     ecx, [ebp+arg_0]
.text:0000C1A0                 mov     edx, [ecx+18h]
.text:0000C1A3                 mov     eax, [ecx+1Ch]
.text:0000C1A6                 mov     ecx, [ebp+var_10]
.text:0000C1A9                 mov     [ecx+18h], edx
.text:0000C1AC                 mov     [ecx+1Ch], eax
.text:0000C1AF                 mov     edx, [ebp+arg_0]
.text:0000C1B2                 add     edx, 20h ; ' '
.text:0000C1B5                 push    edx
.text:0000C1B6                 mov     ecx, [ebp+var_10]
.text:0000C1B9                 add     ecx, 20h ; ' '
.text:0000C1BC                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:0000C1C1                 mov     [ebp+var_4], 0
.text:0000C1C8                 mov     eax, [ebp+arg_0]
.text:0000C1CB                 add     eax, 2Ch ; ','
.text:0000C1CE                 push    eax
.text:0000C1CF                 mov     ecx, [ebp+var_10]
.text:0000C1D2                 add     ecx, 2Ch ; ','
.text:0000C1D5                 call    ??0?$CBuffer@E@@QAE@ABV0@@Z ; CBuffer<uchar>::CBuffer<uchar>(CBuffer<uchar> const &)
.text:0000C1DA                 mov     byte ptr [ebp+var_4], 1
.text:0000C1DE                 mov     ecx, [ebp+arg_0]
.text:0000C1E1                 add     ecx, 34h ; '4'
.text:0000C1E4                 push    ecx
.text:0000C1E5                 mov     ecx, [ebp+var_10]
.text:0000C1E8                 add     ecx, 34h ; '4'
.text:0000C1EB                 call    ??0?$CBuffer@E@@QAE@ABV0@@Z ; CBuffer<uchar>::CBuffer<uchar>(CBuffer<uchar> const &)
.text:0000C1F0                 mov     edx, [ebp+var_10]
.text:0000C1F3                 mov     eax, [ebp+arg_0]
.text:0000C1F6                 mov     ecx, [eax+3Ch]
.text:0000C1F9                 mov     [edx+3Ch], ecx
.text:0000C1FC                 mov     edx, [ebp+var_10]
.text:0000C1FF                 mov     eax, [ebp+arg_0]
.text:0000C202                 mov     ecx, [eax+40h]
.text:0000C205                 mov     [edx+40h], ecx
.text:0000C208                 mov     edx, [ebp+var_10]
.text:0000C20B                 mov     eax, [ebp+arg_0]
.text:0000C20E                 mov     ecx, [eax+44h]
.text:0000C211                 mov     [edx+44h], ecx
.text:0000C214                 mov     edx, [ebp+var_10]
.text:0000C217                 mov     eax, [ebp+arg_0]
.text:0000C21A                 mov     ecx, [eax+48h]
.text:0000C21D                 mov     [edx+48h], ecx
.text:0000C220                 mov     edx, [ebp+var_10]
.text:0000C223                 mov     eax, [ebp+arg_0]
.text:0000C226                 mov     cl, [eax+4Ch]
.text:0000C229                 mov     [edx+4Ch], cl
.text:0000C22C                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000C233                 mov     eax, [ebp+var_10]
.text:0000C236                 mov     ecx, [ebp+var_C]
.text:0000C239                 mov     large fs:0, ecx
.text:0000C240                 pop     ecx
.text:0000C241                 add     esp, 10h
.text:0000C244                 cmp     ebp, esp
.text:0000C246                 call    __RTC_CheckEsp
.text:0000C24B                 mov     esp, ebp
.text:0000C24D                 pop     ebp
.text:0000C24E                 retn    4
.text:0000C24E ??0CDirItem@@QAE@ABU0@@Z endp
.text:0000C24E
.text:0000C24E ; ---------------------------------------------------------------------------
.text:0000C251                 align 4
.text:0000C251 _text           ends
.text:0000C251
.text$x:0000C254 ; ===========================================================================
.text$x:0000C254
.text$x:0000C254 ; Segment type: Pure code
.text$x:0000C254 ; Segment permissions: Read/Execute
.text$x:0000C254 _text$x         segment para public 'CODE' use32
.text$x:0000C254                 assume cs:_text$x
.text$x:0000C254                 ;org 0C254h
.text$x:0000C254 ; COMDAT (pick associative to section at C13C)
.text$x:0000C254                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000C254
.text$x:0000C254 ; =============== S U B R O U T I N E =======================================
.text$x:0000C254
.text$x:0000C254
.text$x:0000C254 __unwindfunclet$??0CDirItem@@QAE@ABU0@@Z$0 proc near
.text$x:0000C254                                         ; DATA XREF: .xdata$x:0000C28Co
.text$x:0000C254                 mov     ecx, [ebp-10h]
.text$x:0000C257                 add     ecx, 20h ; ' '  ; this
.text$x:0000C25A                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:0000C25A __unwindfunclet$??0CDirItem@@QAE@ABU0@@Z$0 endp
.text$x:0000C25A
.text$x:0000C25F
.text$x:0000C25F ; =============== S U B R O U T I N E =======================================
.text$x:0000C25F
.text$x:0000C25F
.text$x:0000C25F __unwindfunclet$??0CDirItem@@QAE@ABU0@@Z$1 proc near
.text$x:0000C25F                                         ; DATA XREF: .xdata$x:0000C294o
.text$x:0000C25F                 mov     ecx, [ebp-10h]
.text$x:0000C262                 add     ecx, 2Ch ; ','
.text$x:0000C265                 jmp     ??1?$CBuffer@E@@QAE@XZ ; CBuffer<uchar>::~CBuffer<uchar>(void)
.text$x:0000C265 __unwindfunclet$??0CDirItem@@QAE@ABU0@@Z$1 endp
.text$x:0000C265
.text$x:0000C26A
.text$x:0000C26A ; =============== S U B R O U T I N E =======================================
.text$x:0000C26A
.text$x:0000C26A
.text$x:0000C26A __ehhandler$??0CDirItem@@QAE@ABU0@@Z proc near
.text$x:0000C26A                                         ; DATA XREF: CDirItem::CDirItem(CDirItem const &)+5o
.text$x:0000C26A
.text$x:0000C26A arg_4           = dword ptr  8
.text$x:0000C26A
.text$x:0000C26A                 mov     edx, [esp+arg_4]
.text$x:0000C26E                 lea     eax, [edx+0Ch]
.text$x:0000C271                 mov     ecx, [edx-8]
.text$x:0000C274                 xor     ecx, eax
.text$x:0000C276                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000C27B                 mov     eax, offset __ehfuncinfo$??0CDirItem@@QAE@ABU0@@Z
.text$x:0000C280                 jmp     ___CxxFrameHandler3
.text$x:0000C280 __ehhandler$??0CDirItem@@QAE@ABU0@@Z endp
.text$x:0000C280
.text$x:0000C280 ; ---------------------------------------------------------------------------
.text$x:0000C285                 align 4
.text$x:0000C285 _text$x         ends
.text$x:0000C285
.xdata$x:0000C288 ; ===========================================================================
.xdata$x:0000C288
.xdata$x:0000C288 ; Segment type: Pure data
.xdata$x:0000C288 ; Segment permissions: Read
.xdata$x:0000C288 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C288                 assume cs:_xdata$x
.xdata$x:0000C288                 ;org 0C288h
.xdata$x:0000C288 ; COMDAT (pick associative to section at C13C)
.xdata$x:0000C288 __unwindtable$??0CDirItem@@QAE@ABU0@@Z db 0FFh
.xdata$x:0000C288                                         ; DATA XREF: .xdata$x:0000C2A0o
.xdata$x:0000C289                 db 0FFh
.xdata$x:0000C28A                 db 0FFh
.xdata$x:0000C28B                 db 0FFh
.xdata$x:0000C28C                 dd offset __unwindfunclet$??0CDirItem@@QAE@ABU0@@Z$0
.xdata$x:0000C290                 db    0
.xdata$x:0000C291                 db    0
.xdata$x:0000C292                 db    0
.xdata$x:0000C293                 db    0
.xdata$x:0000C294                 dd offset __unwindfunclet$??0CDirItem@@QAE@ABU0@@Z$1
.xdata$x:0000C298 __ehfuncinfo$??0CDirItem@@QAE@ABU0@@Z db  22h ; "
.xdata$x:0000C298                                         ; DATA XREF: __ehhandler$??0CDirItem@@QAE@ABU0@@Z+11o
.xdata$x:0000C299                 db    5
.xdata$x:0000C29A                 db  93h ; 
.xdata$x:0000C29B                 db  19h
.xdata$x:0000C29C                 db    2
.xdata$x:0000C29D                 db    0
.xdata$x:0000C29E                 db    0
.xdata$x:0000C29F                 db    0
.xdata$x:0000C2A0                 dd offset __unwindtable$??0CDirItem@@QAE@ABU0@@Z
.xdata$x:0000C2A4                 db    0
.xdata$x:0000C2A5                 db    0
.xdata$x:0000C2A6                 db    0
.xdata$x:0000C2A7                 db    0
.xdata$x:0000C2A8                 db    0
.xdata$x:0000C2A9                 db    0
.xdata$x:0000C2AA                 db    0
.xdata$x:0000C2AB                 db    0
.xdata$x:0000C2AC                 db    0
.xdata$x:0000C2AD                 db    0
.xdata$x:0000C2AE                 db    0
.xdata$x:0000C2AF                 db    0
.xdata$x:0000C2B0                 db    0
.xdata$x:0000C2B1                 db    0
.xdata$x:0000C2B2                 db    0
.xdata$x:0000C2B3                 db    0
.xdata$x:0000C2B4                 db    0
.xdata$x:0000C2B5                 db    0
.xdata$x:0000C2B6                 db    0
.xdata$x:0000C2B7                 db    0
.xdata$x:0000C2B8                 db    1
.xdata$x:0000C2B9                 db    0
.xdata$x:0000C2BA                 db    0
.xdata$x:0000C2BB                 db    0
.xdata$x:0000C2BB _xdata$x        ends
.xdata$x:0000C2BB
.text:0000C2BC ; ===========================================================================
.text:0000C2BC
.text:0000C2BC ; Segment type: Pure code
.text:0000C2BC ; Segment permissions: Read/Execute
.text:0000C2BC _text           segment para public 'CODE' use32
.text:0000C2BC                 assume cs:_text
.text:0000C2BC                 ;org 0C2BCh
.text:0000C2BC ; COMDAT (pick any)
.text:0000C2BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000C2BC
.text:0000C2BC ; =============== S U B R O U T I N E =======================================
.text:0000C2BC
.text:0000C2BC ; Attributes: bp-based frame
.text:0000C2BC
.text:0000C2BC ; public: void * __thiscall CDirItem::`scalar deleting destructor'(unsigned int)
.text:0000C2BC                 public ??_GCDirItem@@QAEPAXI@Z
.text:0000C2BC ??_GCDirItem@@QAEPAXI@Z proc near       ; CODE XREF: CObjectVector<CDirItem>::~CObjectVector<CDirItem>(void)+7Fp
.text:0000C2BC
.text:0000C2BC var_4           = dword ptr -4
.text:0000C2BC arg_0           = dword ptr  8
.text:0000C2BC
.text:0000C2BC                 push    ebp
.text:0000C2BD                 mov     ebp, esp
.text:0000C2BF                 push    ecx
.text:0000C2C0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000C2C7                 mov     [ebp+var_4], ecx
.text:0000C2CA                 mov     ecx, [ebp+var_4] ; this
.text:0000C2CD                 call    ??1CDirItem@@QAE@XZ ; CDirItem::~CDirItem(void)
.text:0000C2D2                 mov     eax, [ebp+arg_0]
.text:0000C2D5                 and     eax, 1
.text:0000C2D8                 jz      short loc_C2E6
.text:0000C2DA                 mov     ecx, [ebp+var_4]
.text:0000C2DD                 push    ecx             ; void *
.text:0000C2DE                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000C2E3                 add     esp, 4
.text:0000C2E6
.text:0000C2E6 loc_C2E6:                               ; CODE XREF: CDirItem::`scalar deleting destructor'(uint)+1Cj
.text:0000C2E6                 mov     eax, [ebp+var_4]
.text:0000C2E9                 add     esp, 4
.text:0000C2EC                 cmp     ebp, esp
.text:0000C2EE                 call    __RTC_CheckEsp
.text:0000C2F3                 mov     esp, ebp
.text:0000C2F5                 pop     ebp
.text:0000C2F6                 retn    4
.text:0000C2F6 ??_GCDirItem@@QAEPAXI@Z endp
.text:0000C2F6
.text:0000C2F6 ; ---------------------------------------------------------------------------
.text:0000C2F9                 align 4
.text:0000C2F9 _text           ends
.text:0000C2F9
.text:0000C2FC ; ===========================================================================
.text:0000C2FC
.text:0000C2FC ; Segment type: Pure code
.text:0000C2FC ; Segment permissions: Read/Execute
.text:0000C2FC _text           segment para public 'CODE' use32
.text:0000C2FC                 assume cs:_text
.text:0000C2FC                 ;org 0C2FCh
.text:0000C2FC ; COMDAT (pick any)
.text:0000C2FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000C2FC
.text:0000C2FC ; =============== S U B R O U T I N E =======================================
.text:0000C2FC
.text:0000C2FC ; Attributes: bp-based frame
.text:0000C2FC
.text:0000C2FC ; public: __thiscall CArcItem::CArcItem(struct CArcItem const &)
.text:0000C2FC                 public ??0CArcItem@@QAE@ABU0@@Z
.text:0000C2FC ??0CArcItem@@QAE@ABU0@@Z proc near      ; CODE XREF: CObjectVector<CArcItem>::AddInReserved(CArcItem const &)+5Ap
.text:0000C2FC
.text:0000C2FC var_4           = dword ptr -4
.text:0000C2FC arg_0           = dword ptr  8
.text:0000C2FC
.text:0000C2FC                 push    ebp
.text:0000C2FD                 mov     ebp, esp
.text:0000C2FF                 push    ecx
.text:0000C300                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000C307                 mov     [ebp+var_4], ecx
.text:0000C30A                 mov     eax, [ebp+var_4]
.text:0000C30D                 mov     ecx, [ebp+arg_0]
.text:0000C310                 mov     edx, [ecx]
.text:0000C312                 mov     [eax], edx
.text:0000C314                 mov     ecx, [ecx+4]
.text:0000C317                 mov     [eax+4], ecx
.text:0000C31A                 mov     edx, [ebp+arg_0]
.text:0000C31D                 mov     eax, [edx+8]
.text:0000C320                 mov     ecx, [edx+0Ch]
.text:0000C323                 mov     edx, [ebp+var_4]
.text:0000C326                 mov     [edx+8], eax
.text:0000C329                 mov     [edx+0Ch], ecx
.text:0000C32C                 mov     eax, [ebp+arg_0]
.text:0000C32F                 add     eax, 10h
.text:0000C332                 push    eax
.text:0000C333                 mov     ecx, [ebp+var_4]
.text:0000C336                 add     ecx, 10h
.text:0000C339                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:0000C33E                 mov     ecx, [ebp+var_4]
.text:0000C341                 mov     edx, [ebp+arg_0]
.text:0000C344                 mov     al, [edx+1Ch]
.text:0000C347                 mov     [ecx+1Ch], al
.text:0000C34A                 mov     ecx, [ebp+var_4]
.text:0000C34D                 mov     edx, [ebp+arg_0]
.text:0000C350                 mov     al, [edx+1Dh]
.text:0000C353                 mov     [ecx+1Dh], al
.text:0000C356                 mov     ecx, [ebp+var_4]
.text:0000C359                 mov     edx, [ebp+arg_0]
.text:0000C35C                 mov     al, [edx+1Eh]
.text:0000C35F                 mov     [ecx+1Eh], al
.text:0000C362                 mov     ecx, [ebp+var_4]
.text:0000C365                 mov     edx, [ebp+arg_0]
.text:0000C368                 mov     al, [edx+1Fh]
.text:0000C36B                 mov     [ecx+1Fh], al
.text:0000C36E                 mov     ecx, [ebp+var_4]
.text:0000C371                 mov     edx, [ebp+arg_0]
.text:0000C374                 mov     al, [edx+20h]
.text:0000C377                 mov     [ecx+20h], al
.text:0000C37A                 mov     ecx, [ebp+var_4]
.text:0000C37D                 mov     edx, [ebp+arg_0]
.text:0000C380                 mov     eax, [edx+24h]
.text:0000C383                 mov     [ecx+24h], eax
.text:0000C386                 mov     ecx, [ebp+var_4]
.text:0000C389                 mov     edx, [ebp+arg_0]
.text:0000C38C                 mov     eax, [edx+28h]
.text:0000C38F                 mov     [ecx+28h], eax
.text:0000C392                 mov     eax, [ebp+var_4]
.text:0000C395                 add     esp, 4
.text:0000C398                 cmp     ebp, esp
.text:0000C39A                 call    __RTC_CheckEsp
.text:0000C39F                 mov     esp, ebp
.text:0000C3A1                 pop     ebp
.text:0000C3A2                 retn    4
.text:0000C3A2 ??0CArcItem@@QAE@ABU0@@Z endp
.text:0000C3A2
.text:0000C3A2 ; ---------------------------------------------------------------------------
.text:0000C3A5                 align 4
.text:0000C3A5 _text           ends
.text:0000C3A5
.text:0000C3A8 ; ===========================================================================
.text:0000C3A8
.text:0000C3A8 ; Segment type: Pure code
.text:0000C3A8 ; Segment permissions: Read/Execute
.text:0000C3A8 _text           segment para public 'CODE' use32
.text:0000C3A8                 assume cs:_text
.text:0000C3A8                 ;org 0C3A8h
.text:0000C3A8 ; COMDAT (pick any)
.text:0000C3A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000C3A8
.text:0000C3A8 ; =============== S U B R O U T I N E =======================================
.text:0000C3A8
.text:0000C3A8 ; Attributes: bp-based frame
.text:0000C3A8
.text:0000C3A8 ; public: void * __thiscall CArcItem::`scalar deleting destructor'(unsigned int)
.text:0000C3A8                 public ??_GCArcItem@@QAEPAXI@Z
.text:0000C3A8 ??_GCArcItem@@QAEPAXI@Z proc near       ; CODE XREF: CObjectVector<CArcItem>::~CObjectVector<CArcItem>(void)+7Fp
.text:0000C3A8                                         ; CObjectVector<CArcItem>::Clear(void)+59p
.text:0000C3A8
.text:0000C3A8 var_4           = dword ptr -4
.text:0000C3A8 arg_0           = dword ptr  8
.text:0000C3A8
.text:0000C3A8                 push    ebp
.text:0000C3A9                 mov     ebp, esp
.text:0000C3AB                 push    ecx
.text:0000C3AC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000C3B3                 mov     [ebp+var_4], ecx
.text:0000C3B6                 mov     ecx, [ebp+var_4] ; this
.text:0000C3B9                 call    ??1CArcItem@@QAE@XZ ; CArcItem::~CArcItem(void)
.text:0000C3BE                 mov     eax, [ebp+arg_0]
.text:0000C3C1                 and     eax, 1
.text:0000C3C4                 jz      short loc_C3D2
.text:0000C3C6                 mov     ecx, [ebp+var_4]
.text:0000C3C9                 push    ecx             ; void *
.text:0000C3CA                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000C3CF                 add     esp, 4
.text:0000C3D2
.text:0000C3D2 loc_C3D2:                               ; CODE XREF: CArcItem::`scalar deleting destructor'(uint)+1Cj
.text:0000C3D2                 mov     eax, [ebp+var_4]
.text:0000C3D5                 add     esp, 4
.text:0000C3D8                 cmp     ebp, esp
.text:0000C3DA                 call    __RTC_CheckEsp
.text:0000C3DF                 mov     esp, ebp
.text:0000C3E1                 pop     ebp
.text:0000C3E2                 retn    4
.text:0000C3E2 ??_GCArcItem@@QAEPAXI@Z endp
.text:0000C3E2
.text:0000C3E2 ; ---------------------------------------------------------------------------
.text:0000C3E5                 align 4
.text:0000C3E5 _text           ends
.text:0000C3E5
.text:0000C3E8 ; ===========================================================================
.text:0000C3E8
.text:0000C3E8 ; Segment type: Pure code
.text:0000C3E8 ; Segment permissions: Read/Execute
.text:0000C3E8 _text           segment para public 'CODE' use32
.text:0000C3E8                 assume cs:_text
.text:0000C3E8                 ;org 0C3E8h
.text:0000C3E8 ; COMDAT (pick any)
.text:0000C3E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000C3E8
.text:0000C3E8 ; =============== S U B R O U T I N E =======================================
.text:0000C3E8
.text:0000C3E8 ; Attributes: bp-based frame
.text:0000C3E8
.text:0000C3E8 ; public: __thiscall CProperty::CProperty(struct CProperty const &)
.text:0000C3E8                 public ??0CProperty@@QAE@ABU0@@Z
.text:0000C3E8 ??0CProperty@@QAE@ABU0@@Z proc near     ; CODE XREF: CObjectVector<CProperty>::Add(CProperty const &)+5Ap
.text:0000C3E8
.text:0000C3E8 var_10          = dword ptr -10h
.text:0000C3E8 var_C           = dword ptr -0Ch
.text:0000C3E8 var_4           = dword ptr -4
.text:0000C3E8 arg_0           = dword ptr  8
.text:0000C3E8
.text:0000C3E8                 push    ebp
.text:0000C3E9                 mov     ebp, esp
.text:0000C3EB                 push    0FFFFFFFFh
.text:0000C3ED                 push    offset __ehhandler$??0CProperty@@QAE@ABU0@@Z
.text:0000C3F2                 mov     eax, large fs:0
.text:0000C3F8                 push    eax
.text:0000C3F9                 push    ecx
.text:0000C3FA                 mov     [ebp+var_10], 0CCCCCCCCh
.text:0000C401                 mov     eax, dword ptr ds:___security_cookie
.text:0000C406                 xor     eax, ebp
.text:0000C408                 push    eax
.text:0000C409                 lea     eax, [ebp+var_C]
.text:0000C40C                 mov     large fs:0, eax
.text:0000C412                 mov     [ebp+var_10], ecx
.text:0000C415                 mov     eax, [ebp+arg_0]
.text:0000C418                 push    eax
.text:0000C419                 mov     ecx, [ebp+var_10]
.text:0000C41C                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:0000C421                 mov     [ebp+var_4], 0
.text:0000C428                 mov     ecx, [ebp+arg_0]
.text:0000C42B                 add     ecx, 0Ch
.text:0000C42E                 push    ecx
.text:0000C42F                 mov     ecx, [ebp+var_10]
.text:0000C432                 add     ecx, 0Ch
.text:0000C435                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:0000C43A                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000C441                 mov     eax, [ebp+var_10]
.text:0000C444                 mov     ecx, [ebp+var_C]
.text:0000C447                 mov     large fs:0, ecx
.text:0000C44E                 pop     ecx
.text:0000C44F                 add     esp, 10h
.text:0000C452                 cmp     ebp, esp
.text:0000C454                 call    __RTC_CheckEsp
.text:0000C459                 mov     esp, ebp
.text:0000C45B                 pop     ebp
.text:0000C45C                 retn    4
.text:0000C45C ??0CProperty@@QAE@ABU0@@Z endp
.text:0000C45C
.text:0000C45C ; ---------------------------------------------------------------------------
.text:0000C45F                 align 10h
.text:0000C45F _text           ends
.text:0000C45F
.text$x:0000C460 ; ===========================================================================
.text$x:0000C460
.text$x:0000C460 ; Segment type: Pure code
.text$x:0000C460 ; Segment permissions: Read/Execute
.text$x:0000C460 _text$x         segment para public 'CODE' use32
.text$x:0000C460                 assume cs:_text$x
.text$x:0000C460                 ;org 0C460h
.text$x:0000C460 ; COMDAT (pick associative to section at C3E8)
.text$x:0000C460                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000C460
.text$x:0000C460 ; =============== S U B R O U T I N E =======================================
.text$x:0000C460
.text$x:0000C460
.text$x:0000C460 __unwindfunclet$??0CProperty@@QAE@ABU0@@Z$0 proc near
.text$x:0000C460                                         ; DATA XREF: .xdata$x:0000C488o
.text$x:0000C460                 mov     ecx, [ebp-10h]  ; this
.text$x:0000C463                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:0000C463 __unwindfunclet$??0CProperty@@QAE@ABU0@@Z$0 endp
.text$x:0000C463
.text$x:0000C468
.text$x:0000C468 ; =============== S U B R O U T I N E =======================================
.text$x:0000C468
.text$x:0000C468
.text$x:0000C468 __ehhandler$??0CProperty@@QAE@ABU0@@Z proc near
.text$x:0000C468                                         ; DATA XREF: CProperty::CProperty(CProperty const &)+5o
.text$x:0000C468
.text$x:0000C468 arg_4           = dword ptr  8
.text$x:0000C468
.text$x:0000C468                 mov     edx, [esp+arg_4]
.text$x:0000C46C                 lea     eax, [edx+0Ch]
.text$x:0000C46F                 mov     ecx, [edx-8]
.text$x:0000C472                 xor     ecx, eax
.text$x:0000C474                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000C479                 mov     eax, offset __ehfuncinfo$??0CProperty@@QAE@ABU0@@Z
.text$x:0000C47E                 jmp     ___CxxFrameHandler3
.text$x:0000C47E __ehhandler$??0CProperty@@QAE@ABU0@@Z endp
.text$x:0000C47E
.text$x:0000C47E ; ---------------------------------------------------------------------------
.text$x:0000C483                 align 4
.text$x:0000C483 _text$x         ends
.text$x:0000C483
.xdata$x:0000C484 ; ===========================================================================
.xdata$x:0000C484
.xdata$x:0000C484 ; Segment type: Pure data
.xdata$x:0000C484 ; Segment permissions: Read
.xdata$x:0000C484 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C484                 assume cs:_xdata$x
.xdata$x:0000C484                 ;org 0C484h
.xdata$x:0000C484 ; COMDAT (pick associative to section at C3E8)
.xdata$x:0000C484 __unwindtable$??0CProperty@@QAE@ABU0@@Z db 0FFh
.xdata$x:0000C484                                         ; DATA XREF: .xdata$x:0000C494o
.xdata$x:0000C485                 db 0FFh
.xdata$x:0000C486                 db 0FFh
.xdata$x:0000C487                 db 0FFh
.xdata$x:0000C488                 dd offset __unwindfunclet$??0CProperty@@QAE@ABU0@@Z$0
.xdata$x:0000C48C __ehfuncinfo$??0CProperty@@QAE@ABU0@@Z db  22h ; "
.xdata$x:0000C48C                                         ; DATA XREF: __ehhandler$??0CProperty@@QAE@ABU0@@Z+11o
.xdata$x:0000C48D                 db    5
.xdata$x:0000C48E                 db  93h ; 
.xdata$x:0000C48F                 db  19h
.xdata$x:0000C490                 db    1
.xdata$x:0000C491                 db    0
.xdata$x:0000C492                 db    0
.xdata$x:0000C493                 db    0
.xdata$x:0000C494                 dd offset __unwindtable$??0CProperty@@QAE@ABU0@@Z
.xdata$x:0000C498                 db    0
.xdata$x:0000C499                 db    0
.xdata$x:0000C49A                 db    0
.xdata$x:0000C49B                 db    0
.xdata$x:0000C49C                 db    0
.xdata$x:0000C49D                 db    0
.xdata$x:0000C49E                 db    0
.xdata$x:0000C49F                 db    0
.xdata$x:0000C4A0                 db    0
.xdata$x:0000C4A1                 db    0
.xdata$x:0000C4A2                 db    0
.xdata$x:0000C4A3                 db    0
.xdata$x:0000C4A4                 db    0
.xdata$x:0000C4A5                 db    0
.xdata$x:0000C4A6                 db    0
.xdata$x:0000C4A7                 db    0
.xdata$x:0000C4A8                 db    0
.xdata$x:0000C4A9                 db    0
.xdata$x:0000C4AA                 db    0
.xdata$x:0000C4AB                 db    0
.xdata$x:0000C4AC                 db    1
.xdata$x:0000C4AD                 db    0
.xdata$x:0000C4AE                 db    0
.xdata$x:0000C4AF                 db    0
.xdata$x:0000C4AF _xdata$x        ends
.xdata$x:0000C4AF
.text:0000C4B0 ; ===========================================================================
.text:0000C4B0
.text:0000C4B0 ; Segment type: Pure code
.text:0000C4B0 ; Segment permissions: Read/Execute
.text:0000C4B0 _text           segment para public 'CODE' use32
.text:0000C4B0                 assume cs:_text
.text:0000C4B0                 ;org 0C4B0h
.text:0000C4B0 ; COMDAT (pick any)
.text:0000C4B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000C4B0
.text:0000C4B0 ; =============== S U B R O U T I N E =======================================
.text:0000C4B0
.text:0000C4B0 ; Attributes: bp-based frame
.text:0000C4B0
.text:0000C4B0 ; _DWORD __thiscall COutMultiVolStream::CAltStreamInfo::CAltStreamInfo(COutMultiVolStream::CAltStreamInfo *this, const struct COutMultiVolStream::CAltStreamInfo *)
.text:0000C4B0                 public ??0CAltStreamInfo@COutMultiVolStream@@QAE@ABU01@@Z
.text:0000C4B0 ??0CAltStreamInfo@COutMultiVolStream@@QAE@ABU01@@Z proc near
.text:0000C4B0                                         ; CODE XREF: CObjectVector<COutMultiVolStream::CAltStreamInfo>::Add(COutMultiVolStream::CAltStreamInfo const &)+5Ap
.text:0000C4B0
.text:0000C4B0 var_10          = dword ptr -10h
.text:0000C4B0 var_C           = dword ptr -0Ch
.text:0000C4B0 var_4           = dword ptr -4
.text:0000C4B0 arg_0           = dword ptr  8
.text:0000C4B0
.text:0000C4B0                 push    ebp
.text:0000C4B1                 mov     ebp, esp
.text:0000C4B3                 push    0FFFFFFFFh
.text:0000C4B5                 push    offset __ehhandler$??0CAltStreamInfo@COutMultiVolStream@@QAE@ABU01@@Z
.text:0000C4BA                 mov     eax, large fs:0
.text:0000C4C0                 push    eax
.text:0000C4C1                 push    ecx
.text:0000C4C2                 mov     [ebp+var_10], 0CCCCCCCCh
.text:0000C4C9                 mov     eax, dword ptr ds:___security_cookie
.text:0000C4CE                 xor     eax, ebp
.text:0000C4D0                 push    eax
.text:0000C4D1                 lea     eax, [ebp+var_C]
.text:0000C4D4                 mov     large fs:0, eax
.text:0000C4DA                 mov     [ebp+var_10], ecx
.text:0000C4DD                 mov     eax, [ebp+var_10]
.text:0000C4E0                 mov     ecx, [ebp+arg_0]
.text:0000C4E3                 mov     edx, [ecx]
.text:0000C4E5                 mov     [eax], edx
.text:0000C4E7                 mov     eax, [ebp+arg_0]
.text:0000C4EA                 add     eax, 4
.text:0000C4ED                 push    eax
.text:0000C4EE                 mov     ecx, [ebp+var_10]
.text:0000C4F1                 add     ecx, 4
.text:0000C4F4                 call    ??0?$CMyComPtr@UIOutStream@@@@QAE@ABV0@@Z ; CMyComPtr<IOutStream>::CMyComPtr<IOutStream>(CMyComPtr<IOutStream> const &)
.text:0000C4F9                 mov     [ebp+var_4], 0
.text:0000C500                 mov     ecx, [ebp+arg_0]
.text:0000C503                 add     ecx, 8
.text:0000C506                 push    ecx
.text:0000C507                 mov     ecx, [ebp+var_10]
.text:0000C50A                 add     ecx, 8
.text:0000C50D                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:0000C512                 mov     edx, [ebp+var_10]
.text:0000C515                 mov     eax, [ebp+arg_0]
.text:0000C518                 mov     ecx, [eax+18h]
.text:0000C51B                 mov     [edx+18h], ecx
.text:0000C51E                 mov     eax, [eax+1Ch]
.text:0000C521                 mov     [edx+1Ch], eax
.text:0000C524                 mov     ecx, [ebp+var_10]
.text:0000C527                 mov     edx, [ebp+arg_0]
.text:0000C52A                 mov     eax, [edx+20h]
.text:0000C52D                 mov     [ecx+20h], eax
.text:0000C530                 mov     edx, [edx+24h]
.text:0000C533                 mov     [ecx+24h], edx
.text:0000C536                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000C53D                 mov     eax, [ebp+var_10]
.text:0000C540                 mov     ecx, [ebp+var_C]
.text:0000C543                 mov     large fs:0, ecx
.text:0000C54A                 pop     ecx
.text:0000C54B                 add     esp, 10h
.text:0000C54E                 cmp     ebp, esp
.text:0000C550                 call    __RTC_CheckEsp
.text:0000C555                 mov     esp, ebp
.text:0000C557                 pop     ebp
.text:0000C558                 retn    4
.text:0000C558 ??0CAltStreamInfo@COutMultiVolStream@@QAE@ABU01@@Z endp
.text:0000C558
.text:0000C558 ; ---------------------------------------------------------------------------
.text:0000C55B                 align 4
.text:0000C55B _text           ends
.text:0000C55B
.text$x:0000C55C ; ===========================================================================
.text$x:0000C55C
.text$x:0000C55C ; Segment type: Pure code
.text$x:0000C55C ; Segment permissions: Read/Execute
.text$x:0000C55C _text$x         segment para public 'CODE' use32
.text$x:0000C55C                 assume cs:_text$x
.text$x:0000C55C                 ;org 0C55Ch
.text$x:0000C55C ; COMDAT (pick associative to section at C4B0)
.text$x:0000C55C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000C55C
.text$x:0000C55C ; =============== S U B R O U T I N E =======================================
.text$x:0000C55C
.text$x:0000C55C
.text$x:0000C55C __unwindfunclet$??0CAltStreamInfo@COutMultiVolStream@@QAE@ABU01@@Z$0 proc near
.text$x:0000C55C                                         ; DATA XREF: .xdata$x:0000C588o
.text$x:0000C55C                 mov     ecx, [ebp-10h]
.text$x:0000C55F                 add     ecx, 4
.text$x:0000C562                 jmp     ??1?$CMyComPtr@UIOutStream@@@@QAE@XZ ; CMyComPtr<IOutStream>::~CMyComPtr<IOutStream>(void)
.text$x:0000C562 __unwindfunclet$??0CAltStreamInfo@COutMultiVolStream@@QAE@ABU01@@Z$0 endp
.text$x:0000C562
.text$x:0000C567
.text$x:0000C567 ; =============== S U B R O U T I N E =======================================
.text$x:0000C567
.text$x:0000C567
.text$x:0000C567 __ehhandler$??0CAltStreamInfo@COutMultiVolStream@@QAE@ABU01@@Z proc near
.text$x:0000C567                                         ; DATA XREF: COutMultiVolStream::CAltStreamInfo::CAltStreamInfo(COutMultiVolStream::CAltStreamInfo const &)+5o
.text$x:0000C567
.text$x:0000C567 arg_4           = dword ptr  8
.text$x:0000C567
.text$x:0000C567                 mov     edx, [esp+arg_4]
.text$x:0000C56B                 lea     eax, [edx+0Ch]
.text$x:0000C56E                 mov     ecx, [edx-8]
.text$x:0000C571                 xor     ecx, eax
.text$x:0000C573                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000C578                 mov     eax, offset __ehfuncinfo$??0CAltStreamInfo@COutMultiVolStream@@QAE@ABU01@@Z
.text$x:0000C57D                 jmp     ___CxxFrameHandler3
.text$x:0000C57D __ehhandler$??0CAltStreamInfo@COutMultiVolStream@@QAE@ABU01@@Z endp
.text$x:0000C57D
.text$x:0000C57D ; ---------------------------------------------------------------------------
.text$x:0000C582                 align 4
.text$x:0000C582 _text$x         ends
.text$x:0000C582
.xdata$x:0000C584 ; ===========================================================================
.xdata$x:0000C584
.xdata$x:0000C584 ; Segment type: Pure data
.xdata$x:0000C584 ; Segment permissions: Read
.xdata$x:0000C584 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C584                 assume cs:_xdata$x
.xdata$x:0000C584                 ;org 0C584h
.xdata$x:0000C584 ; COMDAT (pick associative to section at C4B0)
.xdata$x:0000C584 __unwindtable$??0CAltStreamInfo@COutMultiVolStream@@QAE@ABU01@@Z db 0FFh
.xdata$x:0000C584                                         ; DATA XREF: .xdata$x:0000C594o
.xdata$x:0000C585                 db 0FFh
.xdata$x:0000C586                 db 0FFh
.xdata$x:0000C587                 db 0FFh
.xdata$x:0000C588                 dd offset __unwindfunclet$??0CAltStreamInfo@COutMultiVolStream@@QAE@ABU01@@Z$0
.xdata$x:0000C58C __ehfuncinfo$??0CAltStreamInfo@COutMultiVolStream@@QAE@ABU01@@Z db  22h ; "
.xdata$x:0000C58C                                         ; DATA XREF: __ehhandler$??0CAltStreamInfo@COutMultiVolStream@@QAE@ABU01@@Z+11o
.xdata$x:0000C58D                 db    5
.xdata$x:0000C58E                 db  93h ; 
.xdata$x:0000C58F                 db  19h
.xdata$x:0000C590                 db    1
.xdata$x:0000C591                 db    0
.xdata$x:0000C592                 db    0
.xdata$x:0000C593                 db    0
.xdata$x:0000C594                 dd offset __unwindtable$??0CAltStreamInfo@COutMultiVolStream@@QAE@ABU01@@Z
.xdata$x:0000C598                 db    0
.xdata$x:0000C599                 db    0
.xdata$x:0000C59A                 db    0
.xdata$x:0000C59B                 db    0
.xdata$x:0000C59C                 db    0
.xdata$x:0000C59D                 db    0
.xdata$x:0000C59E                 db    0
.xdata$x:0000C59F                 db    0
.xdata$x:0000C5A0                 db    0
.xdata$x:0000C5A1                 db    0
.xdata$x:0000C5A2                 db    0
.xdata$x:0000C5A3                 db    0
.xdata$x:0000C5A4                 db    0
.xdata$x:0000C5A5                 db    0
.xdata$x:0000C5A6                 db    0
.xdata$x:0000C5A7                 db    0
.xdata$x:0000C5A8                 db    0
.xdata$x:0000C5A9                 db    0
.xdata$x:0000C5AA                 db    0
.xdata$x:0000C5AB                 db    0
.xdata$x:0000C5AC                 db    1
.xdata$x:0000C5AD                 db    0
.xdata$x:0000C5AE                 db    0
.xdata$x:0000C5AF                 db    0
.xdata$x:0000C5AF _xdata$x        ends
.xdata$x:0000C5AF
.text:0000C5B0 ; ===========================================================================
.text:0000C5B0
.text:0000C5B0 ; Segment type: Pure code
.text:0000C5B0 ; Segment permissions: Read/Execute
.text:0000C5B0 _text           segment para public 'CODE' use32
.text:0000C5B0                 assume cs:_text
.text:0000C5B0                 ;org 0C5B0h
.text:0000C5B0 ; COMDAT (pick any)
.text:0000C5B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000C5B0
.text:0000C5B0 ; =============== S U B R O U T I N E =======================================
.text:0000C5B0
.text:0000C5B0 ; Attributes: bp-based frame
.text:0000C5B0
.text:0000C5B0 ; public: void * __thiscall COutMultiVolStream::CAltStreamInfo::`scalar deleting destructor'(unsigned int)
.text:0000C5B0                 public ??_GCAltStreamInfo@COutMultiVolStream@@QAEPAXI@Z
.text:0000C5B0 ??_GCAltStreamInfo@COutMultiVolStream@@QAEPAXI@Z proc near
.text:0000C5B0                                         ; CODE XREF: CObjectVector<COutMultiVolStream::CAltStreamInfo>::~CObjectVector<COutMultiVolStream::CAltStreamInfo>(void)+7Fp
.text:0000C5B0                                         ; CObjectVector<COutMultiVolStream::CAltStreamInfo>::DeleteBack(void)+44p
.text:0000C5B0
.text:0000C5B0 var_4           = dword ptr -4
.text:0000C5B0 arg_0           = dword ptr  8
.text:0000C5B0
.text:0000C5B0                 push    ebp
.text:0000C5B1                 mov     ebp, esp
.text:0000C5B3                 push    ecx
.text:0000C5B4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000C5BB                 mov     [ebp+var_4], ecx
.text:0000C5BE                 mov     ecx, [ebp+var_4] ; this
.text:0000C5C1                 call    ??1CAltStreamInfo@COutMultiVolStream@@QAE@XZ ; COutMultiVolStream::CAltStreamInfo::~CAltStreamInfo(void)
.text:0000C5C6                 mov     eax, [ebp+arg_0]
.text:0000C5C9                 and     eax, 1
.text:0000C5CC                 jz      short loc_C5DA
.text:0000C5CE                 mov     ecx, [ebp+var_4]
.text:0000C5D1                 push    ecx             ; void *
.text:0000C5D2                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000C5D7                 add     esp, 4
.text:0000C5DA
.text:0000C5DA loc_C5DA:                               ; CODE XREF: COutMultiVolStream::CAltStreamInfo::`scalar deleting destructor'(uint)+1Cj
.text:0000C5DA                 mov     eax, [ebp+var_4]
.text:0000C5DD                 add     esp, 4
.text:0000C5E0                 cmp     ebp, esp
.text:0000C5E2                 call    __RTC_CheckEsp
.text:0000C5E7                 mov     esp, ebp
.text:0000C5E9                 pop     ebp
.text:0000C5EA                 retn    4
.text:0000C5EA ??_GCAltStreamInfo@COutMultiVolStream@@QAEPAXI@Z endp
.text:0000C5EA
.text:0000C5EA ; ---------------------------------------------------------------------------
.text:0000C5ED                 align 10h
.text:0000C5ED _text           ends
.text:0000C5ED
.text:0000C5F0 ; ===========================================================================
.text:0000C5F0
.text:0000C5F0 ; Segment type: Pure code
.text:0000C5F0 ; Segment permissions: Read/Execute
.text:0000C5F0 _text           segment para public 'CODE' use32
.text:0000C5F0                 assume cs:_text
.text:0000C5F0                 ;org 0C5F0h
.text:0000C5F0 ; COMDAT (pick any)
.text:0000C5F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000C5F0
.text:0000C5F0 ; =============== S U B R O U T I N E =======================================
.text:0000C5F0
.text:0000C5F0 ; Attributes: bp-based frame
.text:0000C5F0
.text:0000C5F0 ; _DWORD __thiscall CArc::~CArc(CArc *__hidden this)
.text:0000C5F0                 public ??1CArc@@QAE@XZ
.text:0000C5F0 ??1CArc@@QAE@XZ proc near               ; CODE XREF: CArc::`scalar deleting destructor'(uint)+11p
.text:0000C5F0
.text:0000C5F0 var_10          = dword ptr -10h
.text:0000C5F0 var_C           = dword ptr -0Ch
.text:0000C5F0 var_4           = dword ptr -4
.text:0000C5F0
.text:0000C5F0                 push    ebp
.text:0000C5F1                 mov     ebp, esp
.text:0000C5F3                 push    0FFFFFFFFh
.text:0000C5F5                 push    offset __ehhandler$??1CArc@@QAE@XZ
.text:0000C5FA                 mov     eax, large fs:0
.text:0000C600                 push    eax
.text:0000C601                 push    ecx
.text:0000C602                 mov     [ebp+var_10], 0CCCCCCCCh
.text:0000C609                 mov     eax, dword ptr ds:___security_cookie
.text:0000C60E                 xor     eax, ebp
.text:0000C610                 push    eax
.text:0000C611                 lea     eax, [ebp+var_C]
.text:0000C614                 mov     large fs:0, eax
.text:0000C61A                 mov     [ebp+var_10], ecx
.text:0000C61D                 mov     [ebp+var_4], 7
.text:0000C624                 mov     ecx, [ebp+var_10]
.text:0000C627                 add     ecx, 88h ; ''  ; this
.text:0000C62D                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000C632                 mov     byte ptr [ebp+var_4], 6
.text:0000C636                 mov     ecx, [ebp+var_10]
.text:0000C639                 add     ecx, 7Ch ; '|'  ; this
.text:0000C63C                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000C641                 mov     byte ptr [ebp+var_4], 5
.text:0000C645                 mov     ecx, [ebp+var_10]
.text:0000C648                 add     ecx, 70h ; 'p'  ; this
.text:0000C64B                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000C650                 mov     byte ptr [ebp+var_4], 4
.text:0000C654                 mov     ecx, [ebp+var_10]
.text:0000C657                 add     ecx, 40h ; '@'  ; this
.text:0000C65A                 call    ??1CArcErrorInfo@@QAE@XZ ; CArcErrorInfo::~CArcErrorInfo(void)
.text:0000C65F                 mov     byte ptr [ebp+var_4], 3
.text:0000C663                 mov     ecx, [ebp+var_10]
.text:0000C666                 add     ecx, 10h        ; this
.text:0000C669                 call    ??1CArcErrorInfo@@QAE@XZ ; CArcErrorInfo::~CArcErrorInfo(void)
.text:0000C66E                 mov     byte ptr [ebp+var_4], 2
.text:0000C672                 mov     ecx, [ebp+var_10]
.text:0000C675                 add     ecx, 0Ch
.text:0000C678                 call    ??1?$CMyComPtr@UIArchiveGetRootProps@@@@QAE@XZ ; CMyComPtr<IArchiveGetRootProps>::~CMyComPtr<IArchiveGetRootProps>(void)
.text:0000C67D                 mov     byte ptr [ebp+var_4], 1
.text:0000C681                 mov     ecx, [ebp+var_10]
.text:0000C684                 add     ecx, 8
.text:0000C687                 call    ??1?$CMyComPtr@UIArchiveGetRawProps@@@@QAE@XZ ; CMyComPtr<IArchiveGetRawProps>::~CMyComPtr<IArchiveGetRawProps>(void)
.text:0000C68C                 mov     byte ptr [ebp+var_4], 0
.text:0000C690                 mov     ecx, [ebp+var_10]
.text:0000C693                 add     ecx, 4
.text:0000C696                 call    ??1?$CMyComPtr@UIInStream@@@@QAE@XZ ; CMyComPtr<IInStream>::~CMyComPtr<IInStream>(void)
.text:0000C69B                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000C6A2                 mov     ecx, [ebp+var_10]
.text:0000C6A5                 call    ??1?$CMyComPtr@UIInArchive@@@@QAE@XZ ; CMyComPtr<IInArchive>::~CMyComPtr<IInArchive>(void)
.text:0000C6AA                 mov     ecx, [ebp+var_C]
.text:0000C6AD                 mov     large fs:0, ecx
.text:0000C6B4                 pop     ecx
.text:0000C6B5                 add     esp, 10h
.text:0000C6B8                 cmp     ebp, esp
.text:0000C6BA                 call    __RTC_CheckEsp
.text:0000C6BF                 mov     esp, ebp
.text:0000C6C1                 pop     ebp
.text:0000C6C2                 retn
.text:0000C6C2 ??1CArc@@QAE@XZ endp
.text:0000C6C2
.text:0000C6C2 ; ---------------------------------------------------------------------------
.text:0000C6C3                 align 4
.text:0000C6C3 _text           ends
.text:0000C6C3
.text$x:0000C6C4 ; ===========================================================================
.text$x:0000C6C4
.text$x:0000C6C4 ; Segment type: Pure code
.text$x:0000C6C4 ; Segment permissions: Read/Execute
.text$x:0000C6C4 _text$x         segment para public 'CODE' use32
.text$x:0000C6C4                 assume cs:_text$x
.text$x:0000C6C4                 ;org 0C6C4h
.text$x:0000C6C4 ; COMDAT (pick associative to section at C5F0)
.text$x:0000C6C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000C6C4
.text$x:0000C6C4 ; =============== S U B R O U T I N E =======================================
.text$x:0000C6C4
.text$x:0000C6C4
.text$x:0000C6C4 __unwindfunclet$??1CArc@@QAE@XZ$0 proc near ; DATA XREF: .xdata$x:0000C75Co
.text$x:0000C6C4                 mov     ecx, [ebp-10h]
.text$x:0000C6C7                 jmp     ??1?$CMyComPtr@UIInArchive@@@@QAE@XZ ; CMyComPtr<IInArchive>::~CMyComPtr<IInArchive>(void)
.text$x:0000C6C7 __unwindfunclet$??1CArc@@QAE@XZ$0 endp
.text$x:0000C6C7
.text$x:0000C6CC
.text$x:0000C6CC ; =============== S U B R O U T I N E =======================================
.text$x:0000C6CC
.text$x:0000C6CC
.text$x:0000C6CC __unwindfunclet$??1CArc@@QAE@XZ$1 proc near ; DATA XREF: .xdata$x:0000C764o
.text$x:0000C6CC                 mov     ecx, [ebp-10h]
.text$x:0000C6CF                 add     ecx, 4
.text$x:0000C6D2                 jmp     ??1?$CMyComPtr@UIInStream@@@@QAE@XZ ; CMyComPtr<IInStream>::~CMyComPtr<IInStream>(void)
.text$x:0000C6D2 __unwindfunclet$??1CArc@@QAE@XZ$1 endp
.text$x:0000C6D2
.text$x:0000C6D7
.text$x:0000C6D7 ; =============== S U B R O U T I N E =======================================
.text$x:0000C6D7
.text$x:0000C6D7
.text$x:0000C6D7 __unwindfunclet$??1CArc@@QAE@XZ$2 proc near ; DATA XREF: .xdata$x:0000C76Co
.text$x:0000C6D7                 mov     ecx, [ebp-10h]
.text$x:0000C6DA                 add     ecx, 8
.text$x:0000C6DD                 jmp     ??1?$CMyComPtr@UIArchiveGetRawProps@@@@QAE@XZ ; CMyComPtr<IArchiveGetRawProps>::~CMyComPtr<IArchiveGetRawProps>(void)
.text$x:0000C6DD __unwindfunclet$??1CArc@@QAE@XZ$2 endp
.text$x:0000C6DD
.text$x:0000C6E2
.text$x:0000C6E2 ; =============== S U B R O U T I N E =======================================
.text$x:0000C6E2
.text$x:0000C6E2
.text$x:0000C6E2 __unwindfunclet$??1CArc@@QAE@XZ$3 proc near ; DATA XREF: .xdata$x:0000C774o
.text$x:0000C6E2                 mov     ecx, [ebp-10h]
.text$x:0000C6E5                 add     ecx, 0Ch
.text$x:0000C6E8                 jmp     ??1?$CMyComPtr@UIArchiveGetRootProps@@@@QAE@XZ ; CMyComPtr<IArchiveGetRootProps>::~CMyComPtr<IArchiveGetRootProps>(void)
.text$x:0000C6E8 __unwindfunclet$??1CArc@@QAE@XZ$3 endp
.text$x:0000C6E8
.text$x:0000C6ED
.text$x:0000C6ED ; =============== S U B R O U T I N E =======================================
.text$x:0000C6ED
.text$x:0000C6ED
.text$x:0000C6ED __unwindfunclet$??1CArc@@QAE@XZ$4 proc near ; DATA XREF: .xdata$x:0000C77Co
.text$x:0000C6ED                 mov     ecx, [ebp-10h]
.text$x:0000C6F0                 add     ecx, 10h        ; this
.text$x:0000C6F3                 jmp     ??1CArcErrorInfo@@QAE@XZ ; CArcErrorInfo::~CArcErrorInfo(void)
.text$x:0000C6F3 __unwindfunclet$??1CArc@@QAE@XZ$4 endp
.text$x:0000C6F3
.text$x:0000C6F8
.text$x:0000C6F8 ; =============== S U B R O U T I N E =======================================
.text$x:0000C6F8
.text$x:0000C6F8
.text$x:0000C6F8 __unwindfunclet$??1CArc@@QAE@XZ$5 proc near ; DATA XREF: .xdata$x:0000C784o
.text$x:0000C6F8                 mov     ecx, [ebp-10h]
.text$x:0000C6FB                 add     ecx, 40h ; '@'  ; this
.text$x:0000C6FE                 jmp     ??1CArcErrorInfo@@QAE@XZ ; CArcErrorInfo::~CArcErrorInfo(void)
.text$x:0000C6FE __unwindfunclet$??1CArc@@QAE@XZ$5 endp
.text$x:0000C6FE
.text$x:0000C703
.text$x:0000C703 ; =============== S U B R O U T I N E =======================================
.text$x:0000C703
.text$x:0000C703
.text$x:0000C703 __unwindfunclet$??1CArc@@QAE@XZ$6 proc near ; DATA XREF: .xdata$x:0000C78Co
.text$x:0000C703                 mov     ecx, [ebp-10h]
.text$x:0000C706                 add     ecx, 70h ; 'p'  ; this
.text$x:0000C709                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:0000C709 __unwindfunclet$??1CArc@@QAE@XZ$6 endp
.text$x:0000C709
.text$x:0000C70E
.text$x:0000C70E ; =============== S U B R O U T I N E =======================================
.text$x:0000C70E
.text$x:0000C70E
.text$x:0000C70E __unwindfunclet$??1CArc@@QAE@XZ$7 proc near ; DATA XREF: .xdata$x:0000C794o
.text$x:0000C70E                 mov     ecx, [ebp-10h]
.text$x:0000C711                 add     ecx, 7Ch ; '|'  ; this
.text$x:0000C714                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:0000C714 __unwindfunclet$??1CArc@@QAE@XZ$7 endp
.text$x:0000C714
.text$x:0000C719
.text$x:0000C719 ; =============== S U B R O U T I N E =======================================
.text$x:0000C719
.text$x:0000C719
.text$x:0000C719 __ehhandler$??1CArc@@QAE@XZ proc near   ; DATA XREF: CArc::~CArc(void)+5o
.text$x:0000C719
.text$x:0000C719 arg_4           = dword ptr  8
.text$x:0000C719
.text$x:0000C719                 mov     edx, [esp+arg_4]
.text$x:0000C71D                 lea     eax, [edx+0Ch]
.text$x:0000C720                 mov     ecx, [edx-8]
.text$x:0000C723                 xor     ecx, eax
.text$x:0000C725                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000C72A                 mov     eax, offset __ehfuncinfo$??1CArc@@QAE@XZ
.text$x:0000C72F                 jmp     ___CxxFrameHandler3
.text$x:0000C72F __ehhandler$??1CArc@@QAE@XZ endp
.text$x:0000C72F
.text$x:0000C72F _text$x         ends
.text$x:0000C72F
.xdata$x:0000C734 ; ===========================================================================
.xdata$x:0000C734
.xdata$x:0000C734 ; Segment type: Pure data
.xdata$x:0000C734 ; Segment permissions: Read
.xdata$x:0000C734 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C734                 assume cs:_xdata$x
.xdata$x:0000C734                 ;org 0C734h
.xdata$x:0000C734 ; COMDAT (pick associative to section at C5F0)
.xdata$x:0000C734 __ehfuncinfo$??1CArc@@QAE@XZ db  22h ; "
.xdata$x:0000C734                                         ; DATA XREF: __ehhandler$??1CArc@@QAE@XZ+11o
.xdata$x:0000C735                 db    5
.xdata$x:0000C736                 db  93h ; 
.xdata$x:0000C737                 db  19h
.xdata$x:0000C738                 db    8
.xdata$x:0000C739                 db    0
.xdata$x:0000C73A                 db    0
.xdata$x:0000C73B                 db    0
.xdata$x:0000C73C                 dd offset __unwindtable$??1CArc@@QAE@XZ
.xdata$x:0000C740                 db    0
.xdata$x:0000C741                 db    0
.xdata$x:0000C742                 db    0
.xdata$x:0000C743                 db    0
.xdata$x:0000C744                 db    0
.xdata$x:0000C745                 db    0
.xdata$x:0000C746                 db    0
.xdata$x:0000C747                 db    0
.xdata$x:0000C748                 db    0
.xdata$x:0000C749                 db    0
.xdata$x:0000C74A                 db    0
.xdata$x:0000C74B                 db    0
.xdata$x:0000C74C                 db    0
.xdata$x:0000C74D                 db    0
.xdata$x:0000C74E                 db    0
.xdata$x:0000C74F                 db    0
.xdata$x:0000C750                 db    0
.xdata$x:0000C751                 db    0
.xdata$x:0000C752                 db    0
.xdata$x:0000C753                 db    0
.xdata$x:0000C754                 db    1
.xdata$x:0000C755                 db    0
.xdata$x:0000C756                 db    0
.xdata$x:0000C757                 db    0
.xdata$x:0000C758 __unwindtable$??1CArc@@QAE@XZ db 0FFh   ; DATA XREF: .xdata$x:0000C73Co
.xdata$x:0000C759                 db 0FFh
.xdata$x:0000C75A                 db 0FFh
.xdata$x:0000C75B                 db 0FFh
.xdata$x:0000C75C                 dd offset __unwindfunclet$??1CArc@@QAE@XZ$0
.xdata$x:0000C760                 db    0
.xdata$x:0000C761                 db    0
.xdata$x:0000C762                 db    0
.xdata$x:0000C763                 db    0
.xdata$x:0000C764                 dd offset __unwindfunclet$??1CArc@@QAE@XZ$1
.xdata$x:0000C768                 db    1
.xdata$x:0000C769                 db    0
.xdata$x:0000C76A                 db    0
.xdata$x:0000C76B                 db    0
.xdata$x:0000C76C                 dd offset __unwindfunclet$??1CArc@@QAE@XZ$2
.xdata$x:0000C770                 db    2
.xdata$x:0000C771                 db    0
.xdata$x:0000C772                 db    0
.xdata$x:0000C773                 db    0
.xdata$x:0000C774                 dd offset __unwindfunclet$??1CArc@@QAE@XZ$3
.xdata$x:0000C778                 db    3
.xdata$x:0000C779                 db    0
.xdata$x:0000C77A                 db    0
.xdata$x:0000C77B                 db    0
.xdata$x:0000C77C                 dd offset __unwindfunclet$??1CArc@@QAE@XZ$4
.xdata$x:0000C780                 db    4
.xdata$x:0000C781                 db    0
.xdata$x:0000C782                 db    0
.xdata$x:0000C783                 db    0
.xdata$x:0000C784                 dd offset __unwindfunclet$??1CArc@@QAE@XZ$5
.xdata$x:0000C788                 db    5
.xdata$x:0000C789                 db    0
.xdata$x:0000C78A                 db    0
.xdata$x:0000C78B                 db    0
.xdata$x:0000C78C                 dd offset __unwindfunclet$??1CArc@@QAE@XZ$6
.xdata$x:0000C790                 db    6
.xdata$x:0000C791                 db    0
.xdata$x:0000C792                 db    0
.xdata$x:0000C793                 db    0
.xdata$x:0000C794                 dd offset __unwindfunclet$??1CArc@@QAE@XZ$7
.xdata$x:0000C794 _xdata$x        ends
.xdata$x:0000C794
.text:0000C798 ; ===========================================================================
.text:0000C798
.text:0000C798 ; Segment type: Pure code
.text:0000C798 ; Segment permissions: Read/Execute
.text:0000C798 _text           segment para public 'CODE' use32
.text:0000C798                 assume cs:_text
.text:0000C798                 ;org 0C798h
.text:0000C798 ; COMDAT (pick any)
.text:0000C798                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000C798
.text:0000C798 ; =============== S U B R O U T I N E =======================================
.text:0000C798
.text:0000C798 ; Attributes: bp-based frame
.text:0000C798
.text:0000C798 ; public: __thiscall CMyComPtr<struct IArchiveGetRawProps>::~CMyComPtr<struct IArchiveGetRawProps>(void)
.text:0000C798                 public ??1?$CMyComPtr@UIArchiveGetRawProps@@@@QAE@XZ
.text:0000C798 ??1?$CMyComPtr@UIArchiveGetRawProps@@@@QAE@XZ proc near
.text:0000C798                                         ; CODE XREF: CArc::~CArc(void)+97p
.text:0000C798                                         ; __unwindfunclet$??1CArc@@QAE@XZ$2+6j
.text:0000C798
.text:0000C798 var_4           = dword ptr -4
.text:0000C798
.text:0000C798                 push    ebp
.text:0000C799                 mov     ebp, esp
.text:0000C79B                 push    ecx
.text:0000C79C                 push    esi
.text:0000C79D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000C7A4                 mov     [ebp+var_4], ecx
.text:0000C7A7                 mov     eax, [ebp+var_4]
.text:0000C7AA                 cmp     dword ptr [eax], 0
.text:0000C7AD                 jz      short loc_C7CA
.text:0000C7AF                 mov     ecx, [ebp+var_4]
.text:0000C7B2                 mov     edx, [ecx]
.text:0000C7B4                 mov     eax, [ebp+var_4]
.text:0000C7B7                 mov     ecx, [eax]
.text:0000C7B9                 mov     edx, [edx]
.text:0000C7BB                 mov     esi, esp
.text:0000C7BD                 push    ecx
.text:0000C7BE                 mov     eax, [edx+8]
.text:0000C7C1                 call    eax
.text:0000C7C3                 cmp     esi, esp
.text:0000C7C5                 call    __RTC_CheckEsp
.text:0000C7CA
.text:0000C7CA loc_C7CA:                               ; CODE XREF: CMyComPtr<IArchiveGetRawProps>::~CMyComPtr<IArchiveGetRawProps>(void)+15j
.text:0000C7CA                 pop     esi
.text:0000C7CB                 add     esp, 4
.text:0000C7CE                 cmp     ebp, esp
.text:0000C7D0                 call    __RTC_CheckEsp
.text:0000C7D5                 mov     esp, ebp
.text:0000C7D7                 pop     ebp
.text:0000C7D8                 retn
.text:0000C7D8 ??1?$CMyComPtr@UIArchiveGetRawProps@@@@QAE@XZ endp
.text:0000C7D8
.text:0000C7D8 ; ---------------------------------------------------------------------------
.text:0000C7D9                 align 4
.text:0000C7D9 _text           ends
.text:0000C7D9
.text:0000C7DC ; ===========================================================================
.text:0000C7DC
.text:0000C7DC ; Segment type: Pure code
.text:0000C7DC ; Segment permissions: Read/Execute
.text:0000C7DC _text           segment para public 'CODE' use32
.text:0000C7DC                 assume cs:_text
.text:0000C7DC                 ;org 0C7DCh
.text:0000C7DC ; COMDAT (pick any)
.text:0000C7DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000C7DC
.text:0000C7DC ; =============== S U B R O U T I N E =======================================
.text:0000C7DC
.text:0000C7DC ; Attributes: bp-based frame
.text:0000C7DC
.text:0000C7DC ; public: __thiscall CMyComPtr<struct IArchiveGetRootProps>::~CMyComPtr<struct IArchiveGetRootProps>(void)
.text:0000C7DC                 public ??1?$CMyComPtr@UIArchiveGetRootProps@@@@QAE@XZ
.text:0000C7DC ??1?$CMyComPtr@UIArchiveGetRootProps@@@@QAE@XZ proc near
.text:0000C7DC                                         ; CODE XREF: CArc::~CArc(void)+88p
.text:0000C7DC                                         ; __unwindfunclet$??1CArc@@QAE@XZ$3+6j
.text:0000C7DC
.text:0000C7DC var_4           = dword ptr -4
.text:0000C7DC
.text:0000C7DC                 push    ebp
.text:0000C7DD                 mov     ebp, esp
.text:0000C7DF                 push    ecx
.text:0000C7E0                 push    esi
.text:0000C7E1                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000C7E8                 mov     [ebp+var_4], ecx
.text:0000C7EB                 mov     eax, [ebp+var_4]
.text:0000C7EE                 cmp     dword ptr [eax], 0
.text:0000C7F1                 jz      short loc_C80E
.text:0000C7F3                 mov     ecx, [ebp+var_4]
.text:0000C7F6                 mov     edx, [ecx]
.text:0000C7F8                 mov     eax, [ebp+var_4]
.text:0000C7FB                 mov     ecx, [eax]
.text:0000C7FD                 mov     edx, [edx]
.text:0000C7FF                 mov     esi, esp
.text:0000C801                 push    ecx
.text:0000C802                 mov     eax, [edx+8]
.text:0000C805                 call    eax
.text:0000C807                 cmp     esi, esp
.text:0000C809                 call    __RTC_CheckEsp
.text:0000C80E
.text:0000C80E loc_C80E:                               ; CODE XREF: CMyComPtr<IArchiveGetRootProps>::~CMyComPtr<IArchiveGetRootProps>(void)+15j
.text:0000C80E                 pop     esi
.text:0000C80F                 add     esp, 4
.text:0000C812                 cmp     ebp, esp
.text:0000C814                 call    __RTC_CheckEsp
.text:0000C819                 mov     esp, ebp
.text:0000C81B                 pop     ebp
.text:0000C81C                 retn
.text:0000C81C ??1?$CMyComPtr@UIArchiveGetRootProps@@@@QAE@XZ endp
.text:0000C81C
.text:0000C81C ; ---------------------------------------------------------------------------
.text:0000C81D                 align 10h
.text:0000C81D _text           ends
.text:0000C81D
.text:0000C820 ; ===========================================================================
.text:0000C820
.text:0000C820 ; Segment type: Pure code
.text:0000C820 ; Segment permissions: Read/Execute
.text:0000C820 _text           segment para public 'CODE' use32
.text:0000C820                 assume cs:_text
.text:0000C820                 ;org 0C820h
.text:0000C820 ; COMDAT (pick any)
.text:0000C820                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000C820
.text:0000C820 ; =============== S U B R O U T I N E =======================================
.text:0000C820
.text:0000C820 ; Attributes: bp-based frame
.text:0000C820
.text:0000C820 ; public: __thiscall CRecordVector<void *>::CRecordVector<void *>(void)
.text:0000C820                 public ??0?$CRecordVector@PAX@@QAE@XZ
.text:0000C820 ??0?$CRecordVector@PAX@@QAE@XZ proc near
.text:0000C820                                         ; CODE XREF: CObjectVector<UString>::CObjectVector<UString>(void)+11p
.text:0000C820                                         ; CObjectVector<CArc>::CObjectVector<CArc>(void)+11p ...
.text:0000C820
.text:0000C820 var_4           = dword ptr -4
.text:0000C820
.text:0000C820                 push    ebp
.text:0000C821                 mov     ebp, esp
.text:0000C823                 push    ecx
.text:0000C824                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000C82B                 mov     [ebp+var_4], ecx
.text:0000C82E                 mov     eax, [ebp+var_4]
.text:0000C831                 mov     dword ptr [eax], 0
.text:0000C837                 mov     ecx, [ebp+var_4]
.text:0000C83A                 mov     dword ptr [ecx+4], 0
.text:0000C841                 mov     edx, [ebp+var_4]
.text:0000C844                 mov     dword ptr [edx+8], 0
.text:0000C84B                 mov     eax, [ebp+var_4]
.text:0000C84E                 mov     esp, ebp
.text:0000C850                 pop     ebp
.text:0000C851                 retn
.text:0000C851 ??0?$CRecordVector@PAX@@QAE@XZ endp
.text:0000C851
.text:0000C851 ; ---------------------------------------------------------------------------
.text:0000C852                 align 4
.text:0000C852 _text           ends
.text:0000C852
.text:0000C854 ; ===========================================================================
.text:0000C854
.text:0000C854 ; Segment type: Pure code
.text:0000C854 ; Segment permissions: Read/Execute
.text:0000C854 _text           segment para public 'CODE' use32
.text:0000C854                 assume cs:_text
.text:0000C854                 ;org 0C854h
.text:0000C854 ; COMDAT (pick any)
.text:0000C854                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000C854
.text:0000C854 ; =============== S U B R O U T I N E =======================================
.text:0000C854
.text:0000C854 ; Attributes: bp-based frame
.text:0000C854
.text:0000C854 ; public: unsigned int __thiscall CRecordVector<void *>::Size(void)const
.text:0000C854                 public ?Size@?$CRecordVector@PAX@@QBEIXZ
.text:0000C854 ?Size@?$CRecordVector@PAX@@QBEIXZ proc near
.text:0000C854                                         ; CODE XREF: CObjectVector<UString>::Size(void)+11p
.text:0000C854                                         ; CObjectVector<UString>::~CObjectVector<UString>(void)+46p ...
.text:0000C854
.text:0000C854 var_4           = dword ptr -4
.text:0000C854
.text:0000C854                 push    ebp
.text:0000C855                 mov     ebp, esp
.text:0000C857                 push    ecx
.text:0000C858                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000C85F                 mov     [ebp+var_4], ecx
.text:0000C862                 mov     eax, [ebp+var_4]
.text:0000C865                 mov     eax, [eax+4]
.text:0000C868                 mov     esp, ebp
.text:0000C86A                 pop     ebp
.text:0000C86B                 retn
.text:0000C86B ?Size@?$CRecordVector@PAX@@QBEIXZ endp
.text:0000C86B
.text:0000C86B _text           ends
.text:0000C86B
.text:0000C86C ; ===========================================================================
.text:0000C86C
.text:0000C86C ; Segment type: Pure code
.text:0000C86C ; Segment permissions: Read/Execute
.text:0000C86C _text           segment para public 'CODE' use32
.text:0000C86C                 assume cs:_text
.text:0000C86C                 ;org 0C86Ch
.text:0000C86C ; COMDAT (pick any)
.text:0000C86C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000C86C
.text:0000C86C ; =============== S U B R O U T I N E =======================================
.text:0000C86C
.text:0000C86C ; Attributes: bp-based frame
.text:0000C86C
.text:0000C86C ; public: bool __thiscall CRecordVector<void *>::IsEmpty(void)const
.text:0000C86C                 public ?IsEmpty@?$CRecordVector@PAX@@QBE_NXZ
.text:0000C86C ?IsEmpty@?$CRecordVector@PAX@@QBE_NXZ proc near
.text:0000C86C                                         ; CODE XREF: CObjectVector<CArcExtInfo>::IsEmpty(void)+11p
.text:0000C86C                                         ; CObjectVector<CRenamePair>::IsEmpty(void)+11p
.text:0000C86C
.text:0000C86C var_4           = dword ptr -4
.text:0000C86C
.text:0000C86C                 push    ebp
.text:0000C86D                 mov     ebp, esp
.text:0000C86F                 push    ecx
.text:0000C870                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000C877                 mov     [ebp+var_4], ecx
.text:0000C87A                 mov     eax, [ebp+var_4]
.text:0000C87D                 xor     ecx, ecx
.text:0000C87F                 cmp     dword ptr [eax+4], 0
.text:0000C883                 setz    cl
.text:0000C886                 mov     al, cl
.text:0000C888                 mov     esp, ebp
.text:0000C88A                 pop     ebp
.text:0000C88B                 retn
.text:0000C88B ?IsEmpty@?$CRecordVector@PAX@@QBE_NXZ endp
.text:0000C88B
.text:0000C88B _text           ends
.text:0000C88B
.text:0000C88C ; ===========================================================================
.text:0000C88C
.text:0000C88C ; Segment type: Pure code
.text:0000C88C ; Segment permissions: Read/Execute
.text:0000C88C _text           segment para public 'CODE' use32
.text:0000C88C                 assume cs:_text
.text:0000C88C                 ;org 0C88Ch
.text:0000C88C ; COMDAT (pick any)
.text:0000C88C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000C88C
.text:0000C88C ; =============== S U B R O U T I N E =======================================
.text:0000C88C
.text:0000C88C ; Attributes: bp-based frame
.text:0000C88C
.text:0000C88C ; public: void __thiscall CRecordVector<void *>::Reserve(unsigned int)
.text:0000C88C                 public ?Reserve@?$CRecordVector@PAX@@QAEXI@Z
.text:0000C88C ?Reserve@?$CRecordVector@PAX@@QAEXI@Z proc near
.text:0000C88C                                         ; CODE XREF: CObjectVector<UString>::operator=(CObjectVector<UString> const &)+69p
.text:0000C88C
.text:0000C88C var_10          = dword ptr -10h
.text:0000C88C var_C           = dword ptr -0Ch
.text:0000C88C Dst             = dword ptr -8
.text:0000C88C var_4           = dword ptr -4
.text:0000C88C arg_0           = dword ptr  8
.text:0000C88C
.text:0000C88C                 push    ebp
.text:0000C88D                 mov     ebp, esp
.text:0000C88F                 sub     esp, 10h
.text:0000C892                 mov     eax, 0CCCCCCCCh
.text:0000C897                 mov     [ebp+var_10], eax
.text:0000C89A                 mov     [ebp+var_C], eax
.text:0000C89D                 mov     [ebp+Dst], eax
.text:0000C8A0                 mov     [ebp+var_4], eax
.text:0000C8A3                 mov     [ebp+var_4], ecx
.text:0000C8A6                 mov     eax, [ebp+var_4]
.text:0000C8A9                 mov     ecx, [ebp+arg_0]
.text:0000C8AC                 cmp     ecx, [eax+8]
.text:0000C8AF                 jbe     short loc_C920
.text:0000C8B1                 xor     ecx, ecx
.text:0000C8B3                 mov     eax, [ebp+arg_0]
.text:0000C8B6                 mov     edx, 4
.text:0000C8BB                 mul     edx
.text:0000C8BD                 seto    cl
.text:0000C8C0                 neg     ecx
.text:0000C8C2                 or      ecx, eax
.text:0000C8C4                 push    ecx             ; unsigned int
.text:0000C8C5                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0000C8CA                 add     esp, 4
.text:0000C8CD                 mov     [ebp+var_C], eax
.text:0000C8D0                 mov     eax, [ebp+var_C]
.text:0000C8D3                 mov     [ebp+Dst], eax
.text:0000C8D6                 mov     ecx, [ebp+var_4]
.text:0000C8D9                 cmp     dword ptr [ecx+4], 0
.text:0000C8DD                 jz      short loc_C8FB
.text:0000C8DF                 mov     edx, [ebp+var_4]
.text:0000C8E2                 mov     eax, [edx+4]
.text:0000C8E5                 shl     eax, 2
.text:0000C8E8                 push    eax             ; Size
.text:0000C8E9                 mov     ecx, [ebp+var_4]
.text:0000C8EC                 mov     edx, [ecx]
.text:0000C8EE                 push    edx             ; Src
.text:0000C8EF                 mov     eax, [ebp+Dst]
.text:0000C8F2                 push    eax             ; Dst
.text:0000C8F3                 call    _memcpy
.text:0000C8F8                 add     esp, 0Ch
.text:0000C8FB
.text:0000C8FB loc_C8FB:                               ; CODE XREF: CRecordVector<void *>::Reserve(uint)+51j
.text:0000C8FB                 mov     ecx, [ebp+var_4]
.text:0000C8FE                 mov     edx, [ecx]
.text:0000C900                 mov     [ebp+var_10], edx
.text:0000C903                 mov     eax, [ebp+var_10]
.text:0000C906                 push    eax             ; void *
.text:0000C907                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000C90C                 add     esp, 4
.text:0000C90F                 mov     ecx, [ebp+var_4]
.text:0000C912                 mov     edx, [ebp+Dst]
.text:0000C915                 mov     [ecx], edx
.text:0000C917                 mov     eax, [ebp+var_4]
.text:0000C91A                 mov     ecx, [ebp+arg_0]
.text:0000C91D                 mov     [eax+8], ecx
.text:0000C920
.text:0000C920 loc_C920:                               ; CODE XREF: CRecordVector<void *>::Reserve(uint)+23j
.text:0000C920                 add     esp, 10h
.text:0000C923                 cmp     ebp, esp
.text:0000C925                 call    __RTC_CheckEsp
.text:0000C92A                 mov     esp, ebp
.text:0000C92C                 pop     ebp
.text:0000C92D                 retn    4
.text:0000C92D ?Reserve@?$CRecordVector@PAX@@QAEXI@Z endp
.text:0000C92D
.text:0000C92D _text           ends
.text:0000C92D
.text:0000C930 ; ===========================================================================
.text:0000C930
.text:0000C930 ; Segment type: Pure code
.text:0000C930 ; Segment permissions: Read/Execute
.text:0000C930 _text           segment para public 'CODE' use32
.text:0000C930                 assume cs:_text
.text:0000C930                 ;org 0C930h
.text:0000C930 ; COMDAT (pick any)
.text:0000C930                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000C930
.text:0000C930 ; =============== S U B R O U T I N E =======================================
.text:0000C930
.text:0000C930 ; Attributes: bp-based frame
.text:0000C930
.text:0000C930 ; public: void __thiscall CRecordVector<void *>::ClearAndReserve(unsigned int)
.text:0000C930                 public ?ClearAndReserve@?$CRecordVector@PAX@@QAEXI@Z
.text:0000C930 ?ClearAndReserve@?$CRecordVector@PAX@@QAEXI@Z proc near
.text:0000C930                                         ; CODE XREF: CObjectVector<CArcItem>::ClearAndReserve(uint)+1Dp
.text:0000C930
.text:0000C930 var_C           = dword ptr -0Ch
.text:0000C930 var_8           = dword ptr -8
.text:0000C930 var_4           = dword ptr -4
.text:0000C930 arg_0           = dword ptr  8
.text:0000C930
.text:0000C930                 push    ebp
.text:0000C931                 mov     ebp, esp
.text:0000C933                 sub     esp, 0Ch
.text:0000C936                 mov     [ebp+var_C], 0CCCCCCCCh
.text:0000C93D                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000C944                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000C94B                 mov     [ebp+var_4], ecx
.text:0000C94E                 mov     ecx, [ebp+var_4]
.text:0000C951                 call    ?Clear@?$CRecordVector@PAX@@QAEXXZ ; CRecordVector<void *>::Clear(void)
.text:0000C956                 mov     eax, [ebp+var_4]
.text:0000C959                 mov     ecx, [ebp+arg_0]
.text:0000C95C                 cmp     ecx, [eax+8]
.text:0000C95F                 jbe     short loc_C9B8
.text:0000C961                 mov     edx, [ebp+var_4]
.text:0000C964                 mov     eax, [edx]
.text:0000C966                 mov     [ebp+var_8], eax
.text:0000C969                 mov     ecx, [ebp+var_8]
.text:0000C96C                 push    ecx             ; void *
.text:0000C96D                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000C972                 add     esp, 4
.text:0000C975                 mov     edx, [ebp+var_4]
.text:0000C978                 mov     dword ptr [edx], 0
.text:0000C97E                 mov     eax, [ebp+var_4]
.text:0000C981                 mov     dword ptr [eax+8], 0
.text:0000C988                 xor     ecx, ecx
.text:0000C98A                 mov     eax, [ebp+arg_0]
.text:0000C98D                 mov     edx, 4
.text:0000C992                 mul     edx
.text:0000C994                 seto    cl
.text:0000C997                 neg     ecx
.text:0000C999                 or      ecx, eax
.text:0000C99B                 push    ecx             ; unsigned int
.text:0000C99C                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0000C9A1                 add     esp, 4
.text:0000C9A4                 mov     [ebp+var_C], eax
.text:0000C9A7                 mov     eax, [ebp+var_4]
.text:0000C9AA                 mov     ecx, [ebp+var_C]
.text:0000C9AD                 mov     [eax], ecx
.text:0000C9AF                 mov     edx, [ebp+var_4]
.text:0000C9B2                 mov     eax, [ebp+arg_0]
.text:0000C9B5                 mov     [edx+8], eax
.text:0000C9B8
.text:0000C9B8 loc_C9B8:                               ; CODE XREF: CRecordVector<void *>::ClearAndReserve(uint)+2Fj
.text:0000C9B8                 add     esp, 0Ch
.text:0000C9BB                 cmp     ebp, esp
.text:0000C9BD                 call    __RTC_CheckEsp
.text:0000C9C2                 mov     esp, ebp
.text:0000C9C4                 pop     ebp
.text:0000C9C5                 retn    4
.text:0000C9C5 ?ClearAndReserve@?$CRecordVector@PAX@@QAEXI@Z endp
.text:0000C9C5
.text:0000C9C5 _text           ends
.text:0000C9C5
.text:0000C9C8 ; ===========================================================================
.text:0000C9C8
.text:0000C9C8 ; Segment type: Pure code
.text:0000C9C8 ; Segment permissions: Read/Execute
.text:0000C9C8 _text           segment para public 'CODE' use32
.text:0000C9C8                 assume cs:_text
.text:0000C9C8                 ;org 0C9C8h
.text:0000C9C8 ; COMDAT (pick any)
.text:0000C9C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000C9C8
.text:0000C9C8 ; =============== S U B R O U T I N E =======================================
.text:0000C9C8
.text:0000C9C8 ; Attributes: bp-based frame
.text:0000C9C8
.text:0000C9C8 ; public: __thiscall CRecordVector<void *>::~CRecordVector<void *>(void)
.text:0000C9C8                 public ??1?$CRecordVector@PAX@@QAE@XZ
.text:0000C9C8 ??1?$CRecordVector@PAX@@QAE@XZ proc near
.text:0000C9C8                                         ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+9Cp
.text:0000C9C8                                         ; __unwindfunclet$??1?$CObjectVector@VUString@@@@QAE@XZ$0+3j ...
.text:0000C9C8
.text:0000C9C8 var_8           = dword ptr -8
.text:0000C9C8 var_4           = dword ptr -4
.text:0000C9C8
.text:0000C9C8                 push    ebp
.text:0000C9C9                 mov     ebp, esp
.text:0000C9CB                 sub     esp, 8
.text:0000C9CE                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000C9D5                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000C9DC                 mov     [ebp+var_4], ecx
.text:0000C9DF                 mov     eax, [ebp+var_4]
.text:0000C9E2                 mov     ecx, [eax]
.text:0000C9E4                 mov     [ebp+var_8], ecx
.text:0000C9E7                 mov     edx, [ebp+var_8]
.text:0000C9EA                 push    edx             ; void *
.text:0000C9EB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000C9F0                 add     esp, 4
.text:0000C9F3                 add     esp, 8
.text:0000C9F6                 cmp     ebp, esp
.text:0000C9F8                 call    __RTC_CheckEsp
.text:0000C9FD                 mov     esp, ebp
.text:0000C9FF                 pop     ebp
.text:0000CA00                 retn
.text:0000CA00 ??1?$CRecordVector@PAX@@QAE@XZ endp
.text:0000CA00
.text:0000CA00 ; ---------------------------------------------------------------------------
.text:0000CA01                 align 4
.text:0000CA01 _text           ends
.text:0000CA01
.text:0000CA04 ; ===========================================================================
.text:0000CA04
.text:0000CA04 ; Segment type: Pure code
.text:0000CA04 ; Segment permissions: Read/Execute
.text:0000CA04 _text           segment para public 'CODE' use32
.text:0000CA04                 assume cs:_text
.text:0000CA04                 ;org 0CA04h
.text:0000CA04 ; COMDAT (pick any)
.text:0000CA04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000CA04
.text:0000CA04 ; =============== S U B R O U T I N E =======================================
.text:0000CA04
.text:0000CA04 ; Attributes: bp-based frame
.text:0000CA04
.text:0000CA04 ; public: void __thiscall CRecordVector<void *>::Clear(void)
.text:0000CA04                 public ?Clear@?$CRecordVector@PAX@@QAEXXZ
.text:0000CA04 ?Clear@?$CRecordVector@PAX@@QAEXXZ proc near
.text:0000CA04                                         ; CODE XREF: CObjectVector<UString>::Clear(void)+6Fp
.text:0000CA04                                         ; CObjectVector<CArcItem>::Clear(void)+6Fp ...
.text:0000CA04
.text:0000CA04 var_4           = dword ptr -4
.text:0000CA04
.text:0000CA04                 push    ebp
.text:0000CA05                 mov     ebp, esp
.text:0000CA07                 push    ecx
.text:0000CA08                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000CA0F                 mov     [ebp+var_4], ecx
.text:0000CA12                 mov     eax, [ebp+var_4]
.text:0000CA15                 mov     dword ptr [eax+4], 0
.text:0000CA1C                 mov     esp, ebp
.text:0000CA1E                 pop     ebp
.text:0000CA1F                 retn
.text:0000CA1F ?Clear@?$CRecordVector@PAX@@QAEXXZ endp
.text:0000CA1F
.text:0000CA1F _text           ends
.text:0000CA1F
.text:0000CA20 ; ===========================================================================
.text:0000CA20
.text:0000CA20 ; Segment type: Pure code
.text:0000CA20 ; Segment permissions: Read/Execute
.text:0000CA20 _text           segment para public 'CODE' use32
.text:0000CA20                 assume cs:_text
.text:0000CA20                 ;org 0CA20h
.text:0000CA20 ; COMDAT (pick any)
.text:0000CA20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000CA20
.text:0000CA20 ; =============== S U B R O U T I N E =======================================
.text:0000CA20
.text:0000CA20 ; Attributes: bp-based frame
.text:0000CA20
.text:0000CA20 ; public: void __thiscall CRecordVector<void *>::DeleteBack(void)
.text:0000CA20                 public ?DeleteBack@?$CRecordVector@PAX@@QAEXXZ
.text:0000CA20 ?DeleteBack@?$CRecordVector@PAX@@QAEXXZ proc near
.text:0000CA20                                         ; CODE XREF: CObjectVector<COutMultiVolStream::CAltStreamInfo>::DeleteBack(void)+58p
.text:0000CA20
.text:0000CA20 var_4           = dword ptr -4
.text:0000CA20
.text:0000CA20                 push    ebp
.text:0000CA21                 mov     ebp, esp
.text:0000CA23                 push    ecx
.text:0000CA24                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000CA2B                 mov     [ebp+var_4], ecx
.text:0000CA2E                 mov     eax, [ebp+var_4]
.text:0000CA31                 mov     ecx, [eax+4]
.text:0000CA34                 sub     ecx, 1
.text:0000CA37                 mov     edx, [ebp+var_4]
.text:0000CA3A                 mov     [edx+4], ecx
.text:0000CA3D                 mov     esp, ebp
.text:0000CA3F                 pop     ebp
.text:0000CA40                 retn
.text:0000CA40 ?DeleteBack@?$CRecordVector@PAX@@QAEXXZ endp
.text:0000CA40
.text:0000CA40 ; ---------------------------------------------------------------------------
.text:0000CA41                 align 4
.text:0000CA41 _text           ends
.text:0000CA41
.text:0000CA44 ; ===========================================================================
.text:0000CA44
.text:0000CA44 ; Segment type: Pure code
.text:0000CA44 ; Segment permissions: Read/Execute
.text:0000CA44 _text           segment para public 'CODE' use32
.text:0000CA44                 assume cs:_text
.text:0000CA44                 ;org 0CA44h
.text:0000CA44 ; COMDAT (pick any)
.text:0000CA44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000CA44
.text:0000CA44 ; =============== S U B R O U T I N E =======================================
.text:0000CA44
.text:0000CA44 ; Attributes: bp-based frame
.text:0000CA44
.text:0000CA44 ; public: unsigned int __thiscall CRecordVector<void *>::Add(void * const)
.text:0000CA44                 public ?Add@?$CRecordVector@PAX@@QAEIQAX@Z
.text:0000CA44 ?Add@?$CRecordVector@PAX@@QAEIQAX@Z proc near
.text:0000CA44                                         ; CODE XREF: CObjectVector<UString>::Add(UString const &)+7Fp
.text:0000CA44                                         ; CObjectVector<CDirItem>::Add(CDirItem const &)+7Fp ...
.text:0000CA44
.text:0000CA44 var_8           = dword ptr -8
.text:0000CA44 var_4           = dword ptr -4
.text:0000CA44 arg_0           = dword ptr  8
.text:0000CA44
.text:0000CA44                 push    ebp
.text:0000CA45                 mov     ebp, esp
.text:0000CA47                 sub     esp, 8
.text:0000CA4A                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000CA51                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000CA58                 mov     [ebp+var_4], ecx
.text:0000CA5B                 mov     ecx, [ebp+var_4]
.text:0000CA5E                 call    ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ ; CRecordVector<void *>::ReserveOnePosition(void)
.text:0000CA63                 mov     eax, [ebp+var_4]
.text:0000CA66                 mov     ecx, [eax+4]
.text:0000CA69                 mov     edx, [ebp+var_4]
.text:0000CA6C                 mov     eax, [edx]
.text:0000CA6E                 mov     edx, [ebp+arg_0]
.text:0000CA71                 mov     [eax+ecx*4], edx
.text:0000CA74                 mov     eax, [ebp+var_4]
.text:0000CA77                 mov     ecx, [eax+4]
.text:0000CA7A                 mov     [ebp+var_8], ecx
.text:0000CA7D                 mov     edx, [ebp+var_4]
.text:0000CA80                 mov     eax, [edx+4]
.text:0000CA83                 add     eax, 1
.text:0000CA86                 mov     ecx, [ebp+var_4]
.text:0000CA89                 mov     [ecx+4], eax
.text:0000CA8C                 mov     eax, [ebp+var_8]
.text:0000CA8F                 add     esp, 8
.text:0000CA92                 cmp     ebp, esp
.text:0000CA94                 call    __RTC_CheckEsp
.text:0000CA99                 mov     esp, ebp
.text:0000CA9B                 pop     ebp
.text:0000CA9C                 retn    4
.text:0000CA9C ?Add@?$CRecordVector@PAX@@QAEIQAX@Z endp
.text:0000CA9C
.text:0000CA9C ; ---------------------------------------------------------------------------
.text:0000CA9F                 align 10h
.text:0000CA9F _text           ends
.text:0000CA9F
.text:0000CAA0 ; ===========================================================================
.text:0000CAA0
.text:0000CAA0 ; Segment type: Pure code
.text:0000CAA0 ; Segment permissions: Read/Execute
.text:0000CAA0 _text           segment para public 'CODE' use32
.text:0000CAA0                 assume cs:_text
.text:0000CAA0                 ;org 0CAA0h
.text:0000CAA0 ; COMDAT (pick any)
.text:0000CAA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000CAA0
.text:0000CAA0 ; =============== S U B R O U T I N E =======================================
.text:0000CAA0
.text:0000CAA0 ; Attributes: bp-based frame
.text:0000CAA0
.text:0000CAA0 ; public: void __thiscall CRecordVector<void *>::AddInReserved(void * const)
.text:0000CAA0                 public ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z
.text:0000CAA0 ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z proc near
.text:0000CAA0                                         ; CODE XREF: CObjectVector<UString>::operator=(CObjectVector<UString> const &)+D7p
.text:0000CAA0                                         ; CObjectVector<CArcItem>::AddInReserved(CArcItem const &)+7Fp
.text:0000CAA0
.text:0000CAA0 var_4           = dword ptr -4
.text:0000CAA0 arg_0           = dword ptr  8
.text:0000CAA0
.text:0000CAA0                 push    ebp
.text:0000CAA1                 mov     ebp, esp
.text:0000CAA3                 push    ecx
.text:0000CAA4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000CAAB                 mov     [ebp+var_4], ecx
.text:0000CAAE                 mov     eax, [ebp+var_4]
.text:0000CAB1                 mov     ecx, [eax+4]
.text:0000CAB4                 mov     edx, [ebp+var_4]
.text:0000CAB7                 mov     eax, [edx]
.text:0000CAB9                 mov     edx, [ebp+arg_0]
.text:0000CABC                 mov     [eax+ecx*4], edx
.text:0000CABF                 mov     eax, [ebp+var_4]
.text:0000CAC2                 mov     ecx, [eax+4]
.text:0000CAC5                 add     ecx, 1
.text:0000CAC8                 mov     edx, [ebp+var_4]
.text:0000CACB                 mov     [edx+4], ecx
.text:0000CACE                 mov     esp, ebp
.text:0000CAD0                 pop     ebp
.text:0000CAD1                 retn    4
.text:0000CAD1 ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z endp
.text:0000CAD1
.text:0000CAD1 _text           ends
.text:0000CAD1
.text:0000CAD4 ; ===========================================================================
.text:0000CAD4
.text:0000CAD4 ; Segment type: Pure code
.text:0000CAD4 ; Segment permissions: Read/Execute
.text:0000CAD4 _text           segment para public 'CODE' use32
.text:0000CAD4                 assume cs:_text
.text:0000CAD4                 ;org 0CAD4h
.text:0000CAD4 ; COMDAT (pick any)
.text:0000CAD4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000CAD4
.text:0000CAD4 ; =============== S U B R O U T I N E =======================================
.text:0000CAD4
.text:0000CAD4 ; Attributes: bp-based frame
.text:0000CAD4
.text:0000CAD4 ; public: void * const & __thiscall CRecordVector<void *>::operator[](unsigned int)const
.text:0000CAD4                 public ??A?$CRecordVector@PAX@@QBEABQAXI@Z
.text:0000CAD4 ??A?$CRecordVector@PAX@@QBEABQAXI@Z proc near
.text:0000CAD4                                         ; CODE XREF: CObjectVector<UString>::operator[](uint)+15p
.text:0000CAD4                                         ; CObjectVector<NWildcard::CPair>::operator[](uint)+15p ...
.text:0000CAD4
.text:0000CAD4 var_4           = dword ptr -4
.text:0000CAD4 arg_0           = dword ptr  8
.text:0000CAD4
.text:0000CAD4                 push    ebp
.text:0000CAD5                 mov     ebp, esp
.text:0000CAD7                 push    ecx
.text:0000CAD8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000CADF                 mov     [ebp+var_4], ecx
.text:0000CAE2                 mov     eax, [ebp+var_4]
.text:0000CAE5                 mov     ecx, [eax]
.text:0000CAE7                 mov     edx, [ebp+arg_0]
.text:0000CAEA                 lea     eax, [ecx+edx*4]
.text:0000CAED                 mov     esp, ebp
.text:0000CAEF                 pop     ebp
.text:0000CAF0                 retn    4
.text:0000CAF0 ??A?$CRecordVector@PAX@@QBEABQAXI@Z endp
.text:0000CAF0
.text:0000CAF0 ; ---------------------------------------------------------------------------
.text:0000CAF3                 align 4
.text:0000CAF3 _text           ends
.text:0000CAF3
.text:0000CAF4 ; ===========================================================================
.text:0000CAF4
.text:0000CAF4 ; Segment type: Pure code
.text:0000CAF4 ; Segment permissions: Read/Execute
.text:0000CAF4 _text           segment para public 'CODE' use32
.text:0000CAF4                 assume cs:_text
.text:0000CAF4                 ;org 0CAF4h
.text:0000CAF4 ; COMDAT (pick any)
.text:0000CAF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000CAF4
.text:0000CAF4 ; =============== S U B R O U T I N E =======================================
.text:0000CAF4
.text:0000CAF4 ; Attributes: bp-based frame
.text:0000CAF4
.text:0000CAF4 ; public: void * & __thiscall CRecordVector<void *>::operator[](unsigned int)
.text:0000CAF4                 public ??A?$CRecordVector@PAX@@QAEAAPAXI@Z
.text:0000CAF4 ??A?$CRecordVector@PAX@@QAEAAPAXI@Z proc near
.text:0000CAF4                                         ; CODE XREF: CObjectVector<UString>::operator[](uint)+15p
.text:0000CAF4                                         ; CObjectVector<UString>::~CObjectVector<UString>(void)+64p ...
.text:0000CAF4
.text:0000CAF4 var_4           = dword ptr -4
.text:0000CAF4 arg_0           = dword ptr  8
.text:0000CAF4
.text:0000CAF4                 push    ebp
.text:0000CAF5                 mov     ebp, esp
.text:0000CAF7                 push    ecx
.text:0000CAF8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000CAFF                 mov     [ebp+var_4], ecx
.text:0000CB02                 mov     eax, [ebp+var_4]
.text:0000CB05                 mov     ecx, [eax]
.text:0000CB07                 mov     edx, [ebp+arg_0]
.text:0000CB0A                 lea     eax, [ecx+edx*4]
.text:0000CB0D                 mov     esp, ebp
.text:0000CB0F                 pop     ebp
.text:0000CB10                 retn    4
.text:0000CB10 ??A?$CRecordVector@PAX@@QAEAAPAXI@Z endp
.text:0000CB10
.text:0000CB10 ; ---------------------------------------------------------------------------
.text:0000CB13                 align 4
.text:0000CB13 _text           ends
.text:0000CB13
.text:0000CB14 ; ===========================================================================
.text:0000CB14
.text:0000CB14 ; Segment type: Pure code
.text:0000CB14 ; Segment permissions: Read/Execute
.text:0000CB14 _text           segment para public 'CODE' use32
.text:0000CB14                 assume cs:_text
.text:0000CB14                 ;org 0CB14h
.text:0000CB14 ; COMDAT (pick any)
.text:0000CB14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000CB14
.text:0000CB14 ; =============== S U B R O U T I N E =======================================
.text:0000CB14
.text:0000CB14 ; Attributes: bp-based frame
.text:0000CB14
.text:0000CB14 ; public: class CArc const & __thiscall CObjectVector<class CArc>::operator[](unsigned int)const
.text:0000CB14                 public ??A?$CObjectVector@VCArc@@@@QBEABVCArc@@I@Z
.text:0000CB14 ??A?$CObjectVector@VCArc@@@@QBEABVCArc@@I@Z proc near
.text:0000CB14                                         ; CODE XREF: CObjectVector<CArc>::Back(void)+1Dp
.text:0000CB14
.text:0000CB14 var_4           = dword ptr -4
.text:0000CB14 arg_0           = dword ptr  8
.text:0000CB14
.text:0000CB14                 push    ebp
.text:0000CB15                 mov     ebp, esp
.text:0000CB17                 push    ecx
.text:0000CB18                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000CB1F                 mov     [ebp+var_4], ecx
.text:0000CB22                 mov     eax, [ebp+arg_0]
.text:0000CB25                 push    eax
.text:0000CB26                 mov     ecx, [ebp+var_4]
.text:0000CB29                 call    ??A?$CRecordVector@PAX@@QBEABQAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:0000CB2E                 mov     eax, [eax]
.text:0000CB30                 add     esp, 4
.text:0000CB33                 cmp     ebp, esp
.text:0000CB35                 call    __RTC_CheckEsp
.text:0000CB3A                 mov     esp, ebp
.text:0000CB3C                 pop     ebp
.text:0000CB3D                 retn    4
.text:0000CB3D ??A?$CObjectVector@VCArc@@@@QBEABVCArc@@I@Z endp
.text:0000CB3D
.text:0000CB3D _text           ends
.text:0000CB3D
.text:0000CB40 ; ===========================================================================
.text:0000CB40
.text:0000CB40 ; Segment type: Pure code
.text:0000CB40 ; Segment permissions: Read/Execute
.text:0000CB40 _text           segment para public 'CODE' use32
.text:0000CB40                 assume cs:_text
.text:0000CB40                 ;org 0CB40h
.text:0000CB40 ; COMDAT (pick any)
.text:0000CB40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000CB40
.text:0000CB40 ; =============== S U B R O U T I N E =======================================
.text:0000CB40
.text:0000CB40 ; Attributes: bp-based frame
.text:0000CB40
.text:0000CB40 ; public: class CArc & __thiscall CObjectVector<class CArc>::operator[](unsigned int)
.text:0000CB40                 public ??A?$CObjectVector@VCArc@@@@QAEAAVCArc@@I@Z
.text:0000CB40 ??A?$CObjectVector@VCArc@@@@QAEAAVCArc@@I@Z proc near
.text:0000CB40                                         ; CODE XREF: CObjectVector<CArc>::Back(void)+1Dp
.text:0000CB40
.text:0000CB40 var_4           = dword ptr -4
.text:0000CB40 arg_0           = dword ptr  8
.text:0000CB40
.text:0000CB40                 push    ebp
.text:0000CB41                 mov     ebp, esp
.text:0000CB43                 push    ecx
.text:0000CB44                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000CB4B                 mov     [ebp+var_4], ecx
.text:0000CB4E                 mov     eax, [ebp+arg_0]
.text:0000CB51                 push    eax
.text:0000CB52                 mov     ecx, [ebp+var_4]
.text:0000CB55                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:0000CB5A                 mov     eax, [eax]
.text:0000CB5C                 add     esp, 4
.text:0000CB5F                 cmp     ebp, esp
.text:0000CB61                 call    __RTC_CheckEsp
.text:0000CB66                 mov     esp, ebp
.text:0000CB68                 pop     ebp
.text:0000CB69                 retn    4
.text:0000CB69 ??A?$CObjectVector@VCArc@@@@QAEAAVCArc@@I@Z endp
.text:0000CB69
.text:0000CB69 _text           ends
.text:0000CB69
.text:0000CB6C ; ===========================================================================
.text:0000CB6C
.text:0000CB6C ; Segment type: Pure code
.text:0000CB6C ; Segment permissions: Read/Execute
.text:0000CB6C _text           segment para public 'CODE' use32
.text:0000CB6C                 assume cs:_text
.text:0000CB6C                 ;org 0CB6Ch
.text:0000CB6C ; COMDAT (pick any)
.text:0000CB6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000CB6C
.text:0000CB6C ; =============== S U B R O U T I N E =======================================
.text:0000CB6C
.text:0000CB6C ; Attributes: bp-based frame
.text:0000CB6C
.text:0000CB6C ; public: void __thiscall CBuffer<unsigned char>::Free(void)
.text:0000CB6C                 public ?Free@?$CBuffer@E@@QAEXXZ
.text:0000CB6C ?Free@?$CBuffer@E@@QAEXXZ proc near     ; CODE XREF: CBuffer<uchar>::Alloc(uint)+25p
.text:0000CB6C
.text:0000CB6C var_8           = dword ptr -8
.text:0000CB6C var_4           = dword ptr -4
.text:0000CB6C
.text:0000CB6C                 push    ebp
.text:0000CB6D                 mov     ebp, esp
.text:0000CB6F                 sub     esp, 8
.text:0000CB72                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000CB79                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000CB80                 mov     [ebp+var_4], ecx
.text:0000CB83                 mov     eax, [ebp+var_4]
.text:0000CB86                 cmp     dword ptr [eax], 0
.text:0000CB89                 jz      short loc_CBA8
.text:0000CB8B                 mov     ecx, [ebp+var_4]
.text:0000CB8E                 mov     edx, [ecx]
.text:0000CB90                 mov     [ebp+var_8], edx
.text:0000CB93                 mov     eax, [ebp+var_8]
.text:0000CB96                 push    eax             ; void *
.text:0000CB97                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000CB9C                 add     esp, 4
.text:0000CB9F                 mov     ecx, [ebp+var_4]
.text:0000CBA2                 mov     dword ptr [ecx], 0
.text:0000CBA8
.text:0000CBA8 loc_CBA8:                               ; CODE XREF: CBuffer<uchar>::Free(void)+1Dj
.text:0000CBA8                 mov     edx, [ebp+var_4]
.text:0000CBAB                 mov     dword ptr [edx+4], 0
.text:0000CBB2                 add     esp, 8
.text:0000CBB5                 cmp     ebp, esp
.text:0000CBB7                 call    __RTC_CheckEsp
.text:0000CBBC                 mov     esp, ebp
.text:0000CBBE                 pop     ebp
.text:0000CBBF                 retn
.text:0000CBBF ?Free@?$CBuffer@E@@QAEXXZ endp
.text:0000CBBF
.text:0000CBBF _text           ends
.text:0000CBBF
.text:0000CBC0 ; ===========================================================================
.text:0000CBC0
.text:0000CBC0 ; Segment type: Pure code
.text:0000CBC0 ; Segment permissions: Read/Execute
.text:0000CBC0 _text           segment para public 'CODE' use32
.text:0000CBC0                 assume cs:_text
.text:0000CBC0                 ;org 0CBC0h
.text:0000CBC0 ; COMDAT (pick any)
.text:0000CBC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000CBC0
.text:0000CBC0 ; =============== S U B R O U T I N E =======================================
.text:0000CBC0
.text:0000CBC0 ; Attributes: bp-based frame
.text:0000CBC0
.text:0000CBC0 ; public: __thiscall CBuffer<unsigned char>::CBuffer<unsigned char>(class CBuffer<unsigned char> const &)
.text:0000CBC0                 public ??0?$CBuffer@E@@QAE@ABV0@@Z
.text:0000CBC0 ??0?$CBuffer@E@@QAE@ABV0@@Z proc near   ; CODE XREF: CDirItem::CDirItem(CDirItem const &)+99p
.text:0000CBC0                                         ; CDirItem::CDirItem(CDirItem const &)+AFp
.text:0000CBC0
.text:0000CBC0 var_C           = dword ptr -0Ch
.text:0000CBC0 Size            = dword ptr -8
.text:0000CBC0 var_4           = dword ptr -4
.text:0000CBC0 arg_0           = dword ptr  8
.text:0000CBC0
.text:0000CBC0                 push    ebp
.text:0000CBC1                 mov     ebp, esp
.text:0000CBC3                 sub     esp, 0Ch
.text:0000CBC6                 mov     [ebp+var_C], 0CCCCCCCCh
.text:0000CBCD                 mov     [ebp+Size], 0CCCCCCCCh
.text:0000CBD4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000CBDB                 mov     [ebp+var_4], ecx
.text:0000CBDE                 mov     eax, [ebp+var_4]
.text:0000CBE1                 mov     dword ptr [eax], 0
.text:0000CBE7                 mov     ecx, [ebp+var_4]
.text:0000CBEA                 mov     dword ptr [ecx+4], 0
.text:0000CBF1                 mov     edx, [ebp+arg_0]
.text:0000CBF4                 mov     eax, [edx+4]
.text:0000CBF7                 mov     [ebp+Size], eax
.text:0000CBFA                 cmp     [ebp+Size], 0
.text:0000CBFE                 jz      short loc_CC38
.text:0000CC00                 mov     ecx, [ebp+Size]
.text:0000CC03                 push    ecx             ; unsigned int
.text:0000CC04                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0000CC09                 add     esp, 4
.text:0000CC0C                 mov     [ebp+var_C], eax
.text:0000CC0F                 mov     edx, [ebp+var_4]
.text:0000CC12                 mov     eax, [ebp+var_C]
.text:0000CC15                 mov     [edx], eax
.text:0000CC17                 mov     ecx, [ebp+Size]
.text:0000CC1A                 push    ecx             ; Size
.text:0000CC1B                 mov     edx, [ebp+arg_0]
.text:0000CC1E                 mov     eax, [edx]
.text:0000CC20                 push    eax             ; Src
.text:0000CC21                 mov     ecx, [ebp+var_4]
.text:0000CC24                 mov     edx, [ecx]
.text:0000CC26                 push    edx             ; Dst
.text:0000CC27                 call    _memcpy
.text:0000CC2C                 add     esp, 0Ch
.text:0000CC2F                 mov     eax, [ebp+var_4]
.text:0000CC32                 mov     ecx, [ebp+Size]
.text:0000CC35                 mov     [eax+4], ecx
.text:0000CC38
.text:0000CC38 loc_CC38:                               ; CODE XREF: CBuffer<uchar>::CBuffer<uchar>(CBuffer<uchar> const &)+3Ej
.text:0000CC38                 mov     eax, [ebp+var_4]
.text:0000CC3B                 add     esp, 0Ch
.text:0000CC3E                 cmp     ebp, esp
.text:0000CC40                 call    __RTC_CheckEsp
.text:0000CC45                 mov     esp, ebp
.text:0000CC47                 pop     ebp
.text:0000CC48                 retn    4
.text:0000CC48 ??0?$CBuffer@E@@QAE@ABV0@@Z endp
.text:0000CC48
.text:0000CC48 ; ---------------------------------------------------------------------------
.text:0000CC4B                 align 4
.text:0000CC4B _text           ends
.text:0000CC4B
.text:0000CC4C ; ===========================================================================
.text:0000CC4C
.text:0000CC4C ; Segment type: Pure code
.text:0000CC4C ; Segment permissions: Read/Execute
.text:0000CC4C _text           segment para public 'CODE' use32
.text:0000CC4C                 assume cs:_text
.text:0000CC4C                 ;org 0CC4Ch
.text:0000CC4C ; COMDAT (pick any)
.text:0000CC4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000CC4C
.text:0000CC4C ; =============== S U B R O U T I N E =======================================
.text:0000CC4C
.text:0000CC4C ; Attributes: bp-based frame
.text:0000CC4C
.text:0000CC4C ; public: __thiscall CMyComPtr<struct IOutStream>::CMyComPtr<struct IOutStream>(class CMyComPtr<struct IOutStream> const &)
.text:0000CC4C                 public ??0?$CMyComPtr@UIOutStream@@@@QAE@ABV0@@Z
.text:0000CC4C ??0?$CMyComPtr@UIOutStream@@@@QAE@ABV0@@Z proc near
.text:0000CC4C                                         ; CODE XREF: COutMultiVolStream::CAltStreamInfo::CAltStreamInfo(COutMultiVolStream::CAltStreamInfo const &)+44p
.text:0000CC4C
.text:0000CC4C var_4           = dword ptr -4
.text:0000CC4C arg_0           = dword ptr  8
.text:0000CC4C
.text:0000CC4C                 push    ebp
.text:0000CC4D                 mov     ebp, esp
.text:0000CC4F                 push    ecx
.text:0000CC50                 push    esi
.text:0000CC51                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000CC58                 mov     [ebp+var_4], ecx
.text:0000CC5B                 mov     eax, [ebp+var_4]
.text:0000CC5E                 mov     ecx, [ebp+arg_0]
.text:0000CC61                 mov     edx, [ecx]
.text:0000CC63                 mov     [eax], edx
.text:0000CC65                 mov     eax, [ebp+var_4]
.text:0000CC68                 cmp     dword ptr [eax], 0
.text:0000CC6B                 jz      short loc_CC88
.text:0000CC6D                 mov     ecx, [ebp+var_4]
.text:0000CC70                 mov     edx, [ecx]
.text:0000CC72                 mov     eax, [ebp+var_4]
.text:0000CC75                 mov     ecx, [eax]
.text:0000CC77                 mov     edx, [edx]
.text:0000CC79                 mov     esi, esp
.text:0000CC7B                 push    ecx
.text:0000CC7C                 mov     eax, [edx+4]
.text:0000CC7F                 call    eax
.text:0000CC81                 cmp     esi, esp
.text:0000CC83                 call    __RTC_CheckEsp
.text:0000CC88
.text:0000CC88 loc_CC88:                               ; CODE XREF: CMyComPtr<IOutStream>::CMyComPtr<IOutStream>(CMyComPtr<IOutStream> const &)+1Fj
.text:0000CC88                 mov     eax, [ebp+var_4]
.text:0000CC8B                 pop     esi
.text:0000CC8C                 add     esp, 4
.text:0000CC8F                 cmp     ebp, esp
.text:0000CC91                 call    __RTC_CheckEsp
.text:0000CC96                 mov     esp, ebp
.text:0000CC98                 pop     ebp
.text:0000CC99                 retn    4
.text:0000CC99 ??0?$CMyComPtr@UIOutStream@@@@QAE@ABV0@@Z endp
.text:0000CC99
.text:0000CC99 _text           ends
.text:0000CC99
.text:0000CC9C ; ===========================================================================
.text:0000CC9C
.text:0000CC9C ; Segment type: Pure code
.text:0000CC9C ; Segment permissions: Read/Execute
.text:0000CC9C _text           segment para public 'CODE' use32
.text:0000CC9C                 assume cs:_text
.text:0000CC9C                 ;org 0CC9Ch
.text:0000CC9C ; COMDAT (pick any)
.text:0000CC9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000CC9C
.text:0000CC9C ; =============== S U B R O U T I N E =======================================
.text:0000CC9C
.text:0000CC9C ; Attributes: bp-based frame
.text:0000CC9C
.text:0000CC9C ; private: void __thiscall CRecordVector<struct CUpdatePair2>::ReserveOnePosition(void)
.text:0000CC9C                 public ?ReserveOnePosition@?$CRecordVector@UCUpdatePair2@@@@AAEXXZ
.text:0000CC9C ?ReserveOnePosition@?$CRecordVector@UCUpdatePair2@@@@AAEXXZ proc near
.text:0000CC9C                                         ; CODE XREF: CRecordVector<CUpdatePair2>::Add(CUpdatePair2)+1Ap
.text:0000CC9C
.text:0000CC9C var_2C          = dword ptr -2Ch
.text:0000CC9C var_28          = dword ptr -28h
.text:0000CC9C var_24          = dword ptr -24h
.text:0000CC9C var_20          = dword ptr -20h
.text:0000CC9C var_1C          = dword ptr -1Ch
.text:0000CC9C Dst             = dword ptr -18h
.text:0000CC9C var_14          = dword ptr -14h
.text:0000CC9C var_10          = dword ptr -10h
.text:0000CC9C var_C           = dword ptr -0Ch
.text:0000CC9C var_4           = dword ptr -4
.text:0000CC9C
.text:0000CC9C                 push    ebp
.text:0000CC9D                 mov     ebp, esp
.text:0000CC9F                 push    0FFFFFFFFh
.text:0000CCA1                 push    offset __ehhandler$?ReserveOnePosition@?$CRecordVector@UCUpdatePair2@@@@AAEXXZ
.text:0000CCA6                 mov     eax, large fs:0
.text:0000CCAC                 push    eax
.text:0000CCAD                 sub     esp, 20h
.text:0000CCB0                 mov     eax, 0CCCCCCCCh
.text:0000CCB5                 mov     [ebp+var_2C], eax
.text:0000CCB8                 mov     [ebp+var_28], eax
.text:0000CCBB                 mov     [ebp+var_24], eax
.text:0000CCBE                 mov     [ebp+var_20], eax
.text:0000CCC1                 mov     [ebp+var_1C], eax
.text:0000CCC4                 mov     [ebp+Dst], eax
.text:0000CCC7                 mov     [ebp+var_14], eax
.text:0000CCCA                 mov     [ebp+var_10], eax
.text:0000CCCD                 mov     eax, dword ptr ds:___security_cookie
.text:0000CCD2                 xor     eax, ebp
.text:0000CCD4                 push    eax
.text:0000CCD5                 lea     eax, [ebp+var_C]
.text:0000CCD8                 mov     large fs:0, eax
.text:0000CCDE                 mov     [ebp+var_10], ecx
.text:0000CCE1                 mov     eax, [ebp+var_10]
.text:0000CCE4                 mov     ecx, [ebp+var_10]
.text:0000CCE7                 mov     edx, [eax+4]
.text:0000CCEA                 cmp     edx, [ecx+8]
.text:0000CCED                 jnz     loc_CDBB
.text:0000CCF3                 mov     eax, [ebp+var_10]
.text:0000CCF6                 mov     ecx, [eax+8]
.text:0000CCF9                 shr     ecx, 2
.text:0000CCFC                 mov     edx, [ebp+var_10]
.text:0000CCFF                 mov     eax, [edx+8]
.text:0000CD02                 lea     ecx, [eax+ecx+1]
.text:0000CD06                 mov     [ebp+var_14], ecx
.text:0000CD09                 mov     edx, [ebp+var_14]
.text:0000CD0C                 mov     [ebp+var_1C], edx
.text:0000CD0F                 xor     ecx, ecx
.text:0000CD11                 mov     eax, [ebp+var_1C]
.text:0000CD14                 mov     edx, 14h
.text:0000CD19                 mul     edx
.text:0000CD1B                 seto    cl
.text:0000CD1E                 neg     ecx
.text:0000CD20                 or      ecx, eax
.text:0000CD22                 push    ecx             ; unsigned int
.text:0000CD23                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0000CD28                 add     esp, 4
.text:0000CD2B                 mov     [ebp+var_24], eax
.text:0000CD2E                 mov     [ebp+var_4], 0
.text:0000CD35                 cmp     [ebp+var_24], 0
.text:0000CD39                 jz      short loc_CD57
.text:0000CD3B                 push    offset ??0CUpdatePair2@@QAE@XZ ; CUpdatePair2::CUpdatePair2(void)
.text:0000CD40                 mov     eax, [ebp+var_1C]
.text:0000CD43                 push    eax
.text:0000CD44                 push    14h
.text:0000CD46                 mov     ecx, [ebp+var_24]
.text:0000CD49                 push    ecx
.text:0000CD4A                 call    ??_H@YGXPAXIHP6EPAX0@Z@Z ; `vector constructor iterator'(void *,uint,int,void * (*)(void *))
.text:0000CD4F                 mov     edx, [ebp+var_24]
.text:0000CD52                 mov     [ebp+var_2C], edx
.text:0000CD55                 jmp     short loc_CD5E
.text:0000CD57 ; ---------------------------------------------------------------------------
.text:0000CD57
.text:0000CD57 loc_CD57:                               ; CODE XREF: CRecordVector<CUpdatePair2>::ReserveOnePosition(void)+9Dj
.text:0000CD57                 mov     [ebp+var_2C], 0
.text:0000CD5E
.text:0000CD5E loc_CD5E:                               ; CODE XREF: CRecordVector<CUpdatePair2>::ReserveOnePosition(void)+B9j
.text:0000CD5E                 mov     eax, [ebp+var_2C]
.text:0000CD61                 mov     [ebp+var_20], eax
.text:0000CD64                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000CD6B                 mov     ecx, [ebp+var_20]
.text:0000CD6E                 mov     [ebp+Dst], ecx
.text:0000CD71                 mov     edx, [ebp+var_10]
.text:0000CD74                 cmp     dword ptr [edx+4], 0
.text:0000CD78                 jz      short loc_CD96
.text:0000CD7A                 mov     eax, [ebp+var_10]
.text:0000CD7D                 mov     ecx, [eax+4]
.text:0000CD80                 imul    ecx, 14h
.text:0000CD83                 push    ecx             ; Size
.text:0000CD84                 mov     edx, [ebp+var_10]
.text:0000CD87                 mov     eax, [edx]
.text:0000CD89                 push    eax             ; Src
.text:0000CD8A                 mov     ecx, [ebp+Dst]
.text:0000CD8D                 push    ecx             ; Dst
.text:0000CD8E                 call    _memcpy
.text:0000CD93                 add     esp, 0Ch
.text:0000CD96
.text:0000CD96 loc_CD96:                               ; CODE XREF: CRecordVector<CUpdatePair2>::ReserveOnePosition(void)+DCj
.text:0000CD96                 mov     edx, [ebp+var_10]
.text:0000CD99                 mov     eax, [edx]
.text:0000CD9B                 mov     [ebp+var_28], eax
.text:0000CD9E                 mov     ecx, [ebp+var_28]
.text:0000CDA1                 push    ecx             ; void *
.text:0000CDA2                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000CDA7                 add     esp, 4
.text:0000CDAA                 mov     edx, [ebp+var_10]
.text:0000CDAD                 mov     eax, [ebp+Dst]
.text:0000CDB0                 mov     [edx], eax
.text:0000CDB2                 mov     ecx, [ebp+var_10]
.text:0000CDB5                 mov     edx, [ebp+var_14]
.text:0000CDB8                 mov     [ecx+8], edx
.text:0000CDBB
.text:0000CDBB loc_CDBB:                               ; CODE XREF: CRecordVector<CUpdatePair2>::ReserveOnePosition(void)+51j
.text:0000CDBB                 mov     ecx, [ebp+var_C]
.text:0000CDBE                 mov     large fs:0, ecx
.text:0000CDC5                 pop     ecx
.text:0000CDC6                 add     esp, 2Ch
.text:0000CDC9                 cmp     ebp, esp
.text:0000CDCB                 call    __RTC_CheckEsp
.text:0000CDD0                 mov     esp, ebp
.text:0000CDD2                 pop     ebp
.text:0000CDD3                 retn
.text:0000CDD3 ?ReserveOnePosition@?$CRecordVector@UCUpdatePair2@@@@AAEXXZ endp
.text:0000CDD3
.text:0000CDD3 _text           ends
.text:0000CDD3
.text$x:0000CDD4 ; ===========================================================================
.text$x:0000CDD4
.text$x:0000CDD4 ; Segment type: Pure code
.text$x:0000CDD4 ; Segment permissions: Read/Execute
.text$x:0000CDD4 _text$x         segment para public 'CODE' use32
.text$x:0000CDD4                 assume cs:_text$x
.text$x:0000CDD4                 ;org 0CDD4h
.text$x:0000CDD4 ; COMDAT (pick associative to section at CC9C)
.text$x:0000CDD4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000CDD4
.text$x:0000CDD4 ; =============== S U B R O U T I N E =======================================
.text$x:0000CDD4
.text$x:0000CDD4
.text$x:0000CDD4 __unwindfunclet$?ReserveOnePosition@?$CRecordVector@UCUpdatePair2@@@@AAEXXZ$0 proc near
.text$x:0000CDD4                                         ; DATA XREF: .xdata$x:0000CE00o
.text$x:0000CDD4                 mov     eax, [ebp-24h]
.text$x:0000CDD7                 push    eax             ; void *
.text$x:0000CDD8                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:0000CDDD                 pop     ecx
.text$x:0000CDDE                 retn
.text$x:0000CDDE __unwindfunclet$?ReserveOnePosition@?$CRecordVector@UCUpdatePair2@@@@AAEXXZ$0 endp
.text$x:0000CDDE
.text$x:0000CDDF
.text$x:0000CDDF ; =============== S U B R O U T I N E =======================================
.text$x:0000CDDF
.text$x:0000CDDF
.text$x:0000CDDF __ehhandler$?ReserveOnePosition@?$CRecordVector@UCUpdatePair2@@@@AAEXXZ proc near
.text$x:0000CDDF                                         ; DATA XREF: CRecordVector<CUpdatePair2>::ReserveOnePosition(void)+5o
.text$x:0000CDDF
.text$x:0000CDDF arg_4           = dword ptr  8
.text$x:0000CDDF
.text$x:0000CDDF                 mov     edx, [esp+arg_4]
.text$x:0000CDE3                 lea     eax, [edx+0Ch]
.text$x:0000CDE6                 mov     ecx, [edx-24h]
.text$x:0000CDE9                 xor     ecx, eax
.text$x:0000CDEB                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000CDF0                 mov     eax, offset __ehfuncinfo$?ReserveOnePosition@?$CRecordVector@UCUpdatePair2@@@@AAEXXZ
.text$x:0000CDF5                 jmp     ___CxxFrameHandler3
.text$x:0000CDF5 __ehhandler$?ReserveOnePosition@?$CRecordVector@UCUpdatePair2@@@@AAEXXZ endp
.text$x:0000CDF5
.text$x:0000CDF5 ; ---------------------------------------------------------------------------
.text$x:0000CDFA                 align 4
.text$x:0000CDFA _text$x         ends
.text$x:0000CDFA
.xdata$x:0000CDFC ; ===========================================================================
.xdata$x:0000CDFC
.xdata$x:0000CDFC ; Segment type: Pure data
.xdata$x:0000CDFC ; Segment permissions: Read
.xdata$x:0000CDFC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CDFC                 assume cs:_xdata$x
.xdata$x:0000CDFC                 ;org 0CDFCh
.xdata$x:0000CDFC ; COMDAT (pick associative to section at CC9C)
.xdata$x:0000CDFC __unwindtable$?ReserveOnePosition@?$CRecordVector@UCUpdatePair2@@@@AAEXXZ db 0FFh
.xdata$x:0000CDFC                                         ; DATA XREF: .xdata$x:0000CE0Co
.xdata$x:0000CDFD                 db 0FFh
.xdata$x:0000CDFE                 db 0FFh
.xdata$x:0000CDFF                 db 0FFh
.xdata$x:0000CE00                 dd offset __unwindfunclet$?ReserveOnePosition@?$CRecordVector@UCUpdatePair2@@@@AAEXXZ$0
.xdata$x:0000CE04 __ehfuncinfo$?ReserveOnePosition@?$CRecordVector@UCUpdatePair2@@@@AAEXXZ db  22h ; "
.xdata$x:0000CE04                                         ; DATA XREF: __ehhandler$?ReserveOnePosition@?$CRecordVector@UCUpdatePair2@@@@AAEXXZ+11o
.xdata$x:0000CE05                 db    5
.xdata$x:0000CE06                 db  93h ; 
.xdata$x:0000CE07                 db  19h
.xdata$x:0000CE08                 db    1
.xdata$x:0000CE09                 db    0
.xdata$x:0000CE0A                 db    0
.xdata$x:0000CE0B                 db    0
.xdata$x:0000CE0C                 dd offset __unwindtable$?ReserveOnePosition@?$CRecordVector@UCUpdatePair2@@@@AAEXXZ
.xdata$x:0000CE10                 db    0
.xdata$x:0000CE11                 db    0
.xdata$x:0000CE12                 db    0
.xdata$x:0000CE13                 db    0
.xdata$x:0000CE14                 db    0
.xdata$x:0000CE15                 db    0
.xdata$x:0000CE16                 db    0
.xdata$x:0000CE17                 db    0
.xdata$x:0000CE18                 db    0
.xdata$x:0000CE19                 db    0
.xdata$x:0000CE1A                 db    0
.xdata$x:0000CE1B                 db    0
.xdata$x:0000CE1C                 db    0
.xdata$x:0000CE1D                 db    0
.xdata$x:0000CE1E                 db    0
.xdata$x:0000CE1F                 db    0
.xdata$x:0000CE20                 db    0
.xdata$x:0000CE21                 db    0
.xdata$x:0000CE22                 db    0
.xdata$x:0000CE23                 db    0
.xdata$x:0000CE24                 db    1
.xdata$x:0000CE25                 db    0
.xdata$x:0000CE26                 db    0
.xdata$x:0000CE27                 db    0
.xdata$x:0000CE27 _xdata$x        ends
.xdata$x:0000CE27
.text:0000CE28 ; ===========================================================================
.text:0000CE28
.text:0000CE28 ; Segment type: Pure code
.text:0000CE28 ; Segment permissions: Read/Execute
.text:0000CE28 _text           segment para public 'CODE' use32
.text:0000CE28                 assume cs:_text
.text:0000CE28                 ;org 0CE28h
.text:0000CE28 ; COMDAT (pick any)
.text:0000CE28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000CE28
.text:0000CE28 ; =============== S U B R O U T I N E =======================================
.text:0000CE28
.text:0000CE28 ; Attributes: bp-based frame
.text:0000CE28
.text:0000CE28 ; private: void __thiscall CRecordVector<struct CRefSortPair>::ReserveOnePosition(void)
.text:0000CE28                 public ?ReserveOnePosition@?$CRecordVector@UCRefSortPair@@@@AAEXXZ
.text:0000CE28 ?ReserveOnePosition@?$CRecordVector@UCRefSortPair@@@@AAEXXZ proc near
.text:0000CE28                                         ; CODE XREF: CRecordVector<CRefSortPair>::Add(CRefSortPair)+1Ap
.text:0000CE28
.text:0000CE28 var_14          = dword ptr -14h
.text:0000CE28 var_10          = dword ptr -10h
.text:0000CE28 Dst             = dword ptr -0Ch
.text:0000CE28 var_8           = dword ptr -8
.text:0000CE28 var_4           = dword ptr -4
.text:0000CE28
.text:0000CE28                 push    ebp
.text:0000CE29                 mov     ebp, esp
.text:0000CE2B                 sub     esp, 14h
.text:0000CE2E                 mov     eax, 0CCCCCCCCh
.text:0000CE33                 mov     [ebp+var_14], eax
.text:0000CE36                 mov     [ebp+var_10], eax
.text:0000CE39                 mov     [ebp+Dst], eax
.text:0000CE3C                 mov     [ebp+var_8], eax
.text:0000CE3F                 mov     [ebp+var_4], eax
.text:0000CE42                 mov     [ebp+var_4], ecx
.text:0000CE45                 mov     eax, [ebp+var_4]
.text:0000CE48                 mov     ecx, [ebp+var_4]
.text:0000CE4B                 mov     edx, [eax+4]
.text:0000CE4E                 cmp     edx, [ecx+8]
.text:0000CE51                 jnz     loc_CEDC
.text:0000CE57                 mov     eax, [ebp+var_4]
.text:0000CE5A                 mov     ecx, [eax+8]
.text:0000CE5D                 shr     ecx, 2
.text:0000CE60                 mov     edx, [ebp+var_4]
.text:0000CE63                 mov     eax, [edx+8]
.text:0000CE66                 lea     ecx, [eax+ecx+1]
.text:0000CE6A                 mov     [ebp+var_8], ecx
.text:0000CE6D                 xor     ecx, ecx
.text:0000CE6F                 mov     eax, [ebp+var_8]
.text:0000CE72                 mov     edx, 8
.text:0000CE77                 mul     edx
.text:0000CE79                 seto    cl
.text:0000CE7C                 neg     ecx
.text:0000CE7E                 or      ecx, eax
.text:0000CE80                 push    ecx             ; unsigned int
.text:0000CE81                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0000CE86                 add     esp, 4
.text:0000CE89                 mov     [ebp+var_10], eax
.text:0000CE8C                 mov     eax, [ebp+var_10]
.text:0000CE8F                 mov     [ebp+Dst], eax
.text:0000CE92                 mov     ecx, [ebp+var_4]
.text:0000CE95                 cmp     dword ptr [ecx+4], 0
.text:0000CE99                 jz      short loc_CEB7
.text:0000CE9B                 mov     edx, [ebp+var_4]
.text:0000CE9E                 mov     eax, [edx+4]
.text:0000CEA1                 shl     eax, 3
.text:0000CEA4                 push    eax             ; Size
.text:0000CEA5                 mov     ecx, [ebp+var_4]
.text:0000CEA8                 mov     edx, [ecx]
.text:0000CEAA                 push    edx             ; Src
.text:0000CEAB                 mov     eax, [ebp+Dst]
.text:0000CEAE                 push    eax             ; Dst
.text:0000CEAF                 call    _memcpy
.text:0000CEB4                 add     esp, 0Ch
.text:0000CEB7
.text:0000CEB7 loc_CEB7:                               ; CODE XREF: CRecordVector<CRefSortPair>::ReserveOnePosition(void)+71j
.text:0000CEB7                 mov     ecx, [ebp+var_4]
.text:0000CEBA                 mov     edx, [ecx]
.text:0000CEBC                 mov     [ebp+var_14], edx
.text:0000CEBF                 mov     eax, [ebp+var_14]
.text:0000CEC2                 push    eax             ; void *
.text:0000CEC3                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000CEC8                 add     esp, 4
.text:0000CECB                 mov     ecx, [ebp+var_4]
.text:0000CECE                 mov     edx, [ebp+Dst]
.text:0000CED1                 mov     [ecx], edx
.text:0000CED3                 mov     eax, [ebp+var_4]
.text:0000CED6                 mov     ecx, [ebp+var_8]
.text:0000CED9                 mov     [eax+8], ecx
.text:0000CEDC
.text:0000CEDC loc_CEDC:                               ; CODE XREF: CRecordVector<CRefSortPair>::ReserveOnePosition(void)+29j
.text:0000CEDC                 add     esp, 14h
.text:0000CEDF                 cmp     ebp, esp
.text:0000CEE1                 call    __RTC_CheckEsp
.text:0000CEE6                 mov     esp, ebp
.text:0000CEE8                 pop     ebp
.text:0000CEE9                 retn
.text:0000CEE9 ?ReserveOnePosition@?$CRecordVector@UCRefSortPair@@@@AAEXXZ endp
.text:0000CEE9
.text:0000CEE9 ; ---------------------------------------------------------------------------
.text:0000CEEA                 align 4
.text:0000CEEA _text           ends
.text:0000CEEA
.text:0000CEEC ; ===========================================================================
.text:0000CEEC
.text:0000CEEC ; Segment type: Pure code
.text:0000CEEC ; Segment permissions: Read/Execute
.text:0000CEEC _text           segment para public 'CODE' use32
.text:0000CEEC                 assume cs:_text
.text:0000CEEC                 ;org 0CEECh
.text:0000CEEC ; COMDAT (pick any)
.text:0000CEEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000CEEC
.text:0000CEEC ; =============== S U B R O U T I N E =======================================
.text:0000CEEC
.text:0000CEEC ; Attributes: bp-based frame
.text:0000CEEC
.text:0000CEEC ; public: struct CRefSortPair & __thiscall CRecordVector<struct CRefSortPair>::Front(void)
.text:0000CEEC                 public ?Front@?$CRecordVector@UCRefSortPair@@@@QAEAAUCRefSortPair@@XZ
.text:0000CEEC ?Front@?$CRecordVector@UCRefSortPair@@@@QAEAAUCRefSortPair@@XZ proc near
.text:0000CEEC                                         ; CODE XREF: CRecordVector<CRefSortPair>::Sort(int (*)(CRefSortPair const *,CRefSortPair const *,void *),void *)+3Ep
.text:0000CEEC
.text:0000CEEC var_4           = dword ptr -4
.text:0000CEEC
.text:0000CEEC                 push    ebp
.text:0000CEED                 mov     ebp, esp
.text:0000CEEF                 push    ecx
.text:0000CEF0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000CEF7                 mov     [ebp+var_4], ecx
.text:0000CEFA                 mov     eax, [ebp+var_4]
.text:0000CEFD                 mov     eax, [eax]
.text:0000CEFF                 mov     esp, ebp
.text:0000CF01                 pop     ebp
.text:0000CF02                 retn
.text:0000CF02 ?Front@?$CRecordVector@UCRefSortPair@@@@QAEAAUCRefSortPair@@XZ endp
.text:0000CF02
.text:0000CF02 ; ---------------------------------------------------------------------------
.text:0000CF03                 align 4
.text:0000CF03 _text           ends
.text:0000CF03
.text:0000CF04 ; ===========================================================================
.text:0000CF04
.text:0000CF04 ; Segment type: Pure code
.text:0000CF04 ; Segment permissions: Read/Execute
.text:0000CF04 _text           segment para public 'CODE' use32
.text:0000CF04                 assume cs:_text
.text:0000CF04                 ;org 0CF04h
.text:0000CF04 ; COMDAT (pick any)
.text:0000CF04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000CF04
.text:0000CF04 ; =============== S U B R O U T I N E =======================================
.text:0000CF04
.text:0000CF04 ; Attributes: bp-based frame
.text:0000CF04
.text:0000CF04 ; public: static void __stdcall CRecordVector<struct CRefSortPair>::SortRefDown(struct CRefSortPair *, unsigned int, unsigned int, int (__stdcall *)(struct CRefSortPair const *, struct CRefSortPair const *, void *), void *)
.text:0000CF04                 public ?SortRefDown@?$CRecordVector@UCRefSortPair@@@@SGXPAUCRefSortPair@@IIP6GHPBU2@1PAX@Z2@Z
.text:0000CF04 ?SortRefDown@?$CRecordVector@UCRefSortPair@@@@SGXPAUCRefSortPair@@IIP6GHPBU2@1PAX@Z2@Z proc near
.text:0000CF04                                         ; CODE XREF: CRecordVector<CRefSortPair>::Sort(int (*)(CRefSortPair const *,CRefSortPair const *,void *),void *)+65p
.text:0000CF04                                         ; CRecordVector<CRefSortPair>::Sort(int (*)(CRefSortPair const *,CRefSortPair const *,void *),void *)+C8p
.text:0000CF04
.text:0000CF04 var_14          = dword ptr -14h
.text:0000CF04 var_10          = dword ptr -10h
.text:0000CF04 var_C           = dword ptr -0Ch
.text:0000CF04 var_8           = dword ptr -8
.text:0000CF04 var_4           = dword ptr -4
.text:0000CF04 arg_0           = dword ptr  8
.text:0000CF04 arg_4           = dword ptr  0Ch
.text:0000CF04 arg_8           = dword ptr  10h
.text:0000CF04 arg_C           = dword ptr  14h
.text:0000CF04 arg_10          = dword ptr  18h
.text:0000CF04
.text:0000CF04                 push    ebp
.text:0000CF05                 mov     ebp, esp
.text:0000CF07                 sub     esp, 14h
.text:0000CF0A                 push    esi
.text:0000CF0B                 mov     eax, 0CCCCCCCCh
.text:0000CF10                 mov     [ebp+var_14], eax
.text:0000CF13                 mov     [ebp+var_10], eax
.text:0000CF16                 mov     [ebp+var_C], eax
.text:0000CF19                 mov     [ebp+var_8], eax
.text:0000CF1C                 mov     [ebp+var_4], eax
.text:0000CF1F                 mov     eax, [ebp+arg_4]
.text:0000CF22                 mov     ecx, [ebp+arg_0]
.text:0000CF25                 mov     edx, [ecx+eax*8]
.text:0000CF28                 mov     eax, [ecx+eax*8+4]
.text:0000CF2C                 mov     [ebp+var_C], edx
.text:0000CF2F                 mov     [ebp+var_8], eax
.text:0000CF32
.text:0000CF32 loc_CF32:                               ; CODE XREF: CRecordVector<CRefSortPair>::SortRefDown(CRefSortPair *,uint,uint,int (*)(CRefSortPair const *,CRefSortPair const *,void *),void *)+C1j
.text:0000CF32                 mov     ecx, [ebp+arg_4]
.text:0000CF35                 shl     ecx, 1
.text:0000CF37                 mov     [ebp+var_14], ecx
.text:0000CF3A                 mov     edx, [ebp+var_14]
.text:0000CF3D                 cmp     edx, [ebp+arg_8]
.text:0000CF40                 jbe     short loc_CF47
.text:0000CF42                 jmp     loc_CFCA
.text:0000CF47 ; ---------------------------------------------------------------------------
.text:0000CF47
.text:0000CF47 loc_CF47:                               ; CODE XREF: CRecordVector<CRefSortPair>::SortRefDown(CRefSortPair *,uint,uint,int (*)(CRefSortPair const *,CRefSortPair const *,void *),void *)+3Cj
.text:0000CF47                 mov     eax, [ebp+var_14]
.text:0000CF4A                 cmp     eax, [ebp+arg_8]
.text:0000CF4D                 jnb     short loc_CF81
.text:0000CF4F                 mov     esi, esp
.text:0000CF51                 mov     ecx, [ebp+arg_10]
.text:0000CF54                 push    ecx
.text:0000CF55                 mov     edx, [ebp+var_14]
.text:0000CF58                 mov     eax, [ebp+arg_0]
.text:0000CF5B                 lea     ecx, [eax+edx*8]
.text:0000CF5E                 push    ecx
.text:0000CF5F                 mov     edx, [ebp+var_14]
.text:0000CF62                 mov     eax, [ebp+arg_0]
.text:0000CF65                 lea     ecx, [eax+edx*8+8]
.text:0000CF69                 push    ecx
.text:0000CF6A                 call    [ebp+arg_C]
.text:0000CF6D                 cmp     esi, esp
.text:0000CF6F                 call    __RTC_CheckEsp
.text:0000CF74                 test    eax, eax
.text:0000CF76                 jle     short loc_CF81
.text:0000CF78                 mov     edx, [ebp+var_14]
.text:0000CF7B                 add     edx, 1
.text:0000CF7E                 mov     [ebp+var_14], edx
.text:0000CF81
.text:0000CF81 loc_CF81:                               ; CODE XREF: CRecordVector<CRefSortPair>::SortRefDown(CRefSortPair *,uint,uint,int (*)(CRefSortPair const *,CRefSortPair const *,void *),void *)+49j
.text:0000CF81                                         ; CRecordVector<CRefSortPair>::SortRefDown(CRefSortPair *,uint,uint,int (*)(CRefSortPair const *,CRefSortPair const *,void *),void *)+72j
.text:0000CF81                 mov     esi, esp
.text:0000CF83                 mov     eax, [ebp+arg_10]
.text:0000CF86                 push    eax
.text:0000CF87                 mov     ecx, [ebp+var_14]
.text:0000CF8A                 mov     edx, [ebp+arg_0]
.text:0000CF8D                 lea     eax, [edx+ecx*8]
.text:0000CF90                 push    eax
.text:0000CF91                 lea     ecx, [ebp+var_C]
.text:0000CF94                 push    ecx
.text:0000CF95                 call    [ebp+arg_C]
.text:0000CF98                 cmp     esi, esp
.text:0000CF9A                 call    __RTC_CheckEsp
.text:0000CF9F                 test    eax, eax
.text:0000CFA1                 jl      short loc_CFA5
.text:0000CFA3                 jmp     short loc_CFCA
.text:0000CFA5 ; ---------------------------------------------------------------------------
.text:0000CFA5
.text:0000CFA5 loc_CFA5:                               ; CODE XREF: CRecordVector<CRefSortPair>::SortRefDown(CRefSortPair *,uint,uint,int (*)(CRefSortPair const *,CRefSortPair const *,void *),void *)+9Dj
.text:0000CFA5                 mov     edx, [ebp+var_14]
.text:0000CFA8                 mov     eax, [ebp+arg_0]
.text:0000CFAB                 mov     ecx, [eax+edx*8]
.text:0000CFAE                 mov     edx, [eax+edx*8+4]
.text:0000CFB2                 mov     eax, [ebp+arg_4]
.text:0000CFB5                 mov     esi, [ebp+arg_0]
.text:0000CFB8                 mov     [esi+eax*8], ecx
.text:0000CFBB                 mov     [esi+eax*8+4], edx
.text:0000CFBF                 mov     ecx, [ebp+var_14]
.text:0000CFC2                 mov     [ebp+arg_4], ecx
.text:0000CFC5                 jmp     loc_CF32
.text:0000CFCA ; ---------------------------------------------------------------------------
.text:0000CFCA
.text:0000CFCA loc_CFCA:                               ; CODE XREF: CRecordVector<CRefSortPair>::SortRefDown(CRefSortPair *,uint,uint,int (*)(CRefSortPair const *,CRefSortPair const *,void *),void *)+3Ej
.text:0000CFCA                                         ; CRecordVector<CRefSortPair>::SortRefDown(CRefSortPair *,uint,uint,int (*)(CRefSortPair const *,CRefSortPair const *,void *),void *)+9Fj
.text:0000CFCA                 mov     edx, [ebp+arg_4]
.text:0000CFCD                 mov     eax, [ebp+arg_0]
.text:0000CFD0                 mov     ecx, [ebp+var_C]
.text:0000CFD3                 mov     [eax+edx*8], ecx
.text:0000CFD6                 mov     ecx, [ebp+var_8]
.text:0000CFD9                 mov     [eax+edx*8+4], ecx
.text:0000CFDD                 push    edx
.text:0000CFDE                 mov     ecx, ebp
.text:0000CFE0                 push    eax
.text:0000CFE1                 lea     edx, $LN10_6
.text:0000CFE7                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:0000CFEC                 pop     eax
.text:0000CFED                 pop     edx
.text:0000CFEE                 pop     esi
.text:0000CFEF                 add     esp, 14h
.text:0000CFF2                 cmp     ebp, esp
.text:0000CFF4                 call    __RTC_CheckEsp
.text:0000CFF9                 mov     esp, ebp
.text:0000CFFB                 pop     ebp
.text:0000CFFC                 retn    14h
.text:0000CFFC ?SortRefDown@?$CRecordVector@UCRefSortPair@@@@SGXPAUCRefSortPair@@IIP6GHPBU2@1PAX@Z2@Z endp
.text:0000CFFC
.text:0000CFFC ; ---------------------------------------------------------------------------
.text:0000CFFF                 align 10h
.text:0000D000 $LN10_6         dd 1                    ; DATA XREF: CRecordVector<CRefSortPair>::SortRefDown(CRefSortPair *,uint,uint,int (*)(CRefSortPair const *,CRefSortPair const *,void *),void *)+DDo
.text:0000D004                 dd offset $LN9_3
.text:0000D008 $LN9_3          dd 0FFFFFFF4h, 8        ; DATA XREF: .text:0000D004o
.text:0000D010                 dd offset $LN8_1        ; "temp"
.text:0000D014 $LN8_1          db 'temp',0             ; DATA XREF: .text:0000D010o
.text:0000D019                 align 4
.text:0000D019 _text           ends
.text:0000D019
.text:0000D01C ; ===========================================================================
.text:0000D01C
.text:0000D01C ; Segment type: Pure code
.text:0000D01C ; Segment permissions: Read/Execute
.text:0000D01C _text           segment para public 'CODE' use32
.text:0000D01C                 assume cs:_text
.text:0000D01C                 ;org 0D01Ch
.text:0000D01C ; COMDAT (pick any)
.text:0000D01C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000D01C
.text:0000D01C ; =============== S U B R O U T I N E =======================================
.text:0000D01C
.text:0000D01C ; Attributes: bp-based frame
.text:0000D01C
.text:0000D01C ; void __stdcall `vector constructor iterator'(void *, unsigned int, int, void * (__thiscall *)(void *))
.text:0000D01C                 public ??_H@YGXPAXIHP6EPAX0@Z@Z
.text:0000D01C ??_H@YGXPAXIHP6EPAX0@Z@Z proc near      ; CODE XREF: CRecordVector<CUpdatePair2>::ReserveOnePosition(void)+AEp
.text:0000D01C
.text:0000D01C arg_0           = dword ptr  8
.text:0000D01C arg_4           = dword ptr  0Ch
.text:0000D01C arg_8           = dword ptr  10h
.text:0000D01C arg_C           = dword ptr  14h
.text:0000D01C
.text:0000D01C                 push    ebp
.text:0000D01D                 mov     ebp, esp
.text:0000D01F                 push    esi
.text:0000D020
.text:0000D020 loc_D020:                               ; CODE XREF: `vector constructor iterator'(void *,uint,int,void * (*)(void *))+27j
.text:0000D020                 mov     eax, [ebp+arg_8]
.text:0000D023                 sub     eax, 1
.text:0000D026                 mov     [ebp+arg_8], eax
.text:0000D029                 js      short loc_D045
.text:0000D02B                 mov     esi, esp
.text:0000D02D                 mov     ecx, [ebp+arg_0]
.text:0000D030                 call    [ebp+arg_C]
.text:0000D033                 cmp     esi, esp
.text:0000D035                 call    __RTC_CheckEsp
.text:0000D03A                 mov     ecx, [ebp+arg_0]
.text:0000D03D                 add     ecx, [ebp+arg_4]
.text:0000D040                 mov     [ebp+arg_0], ecx
.text:0000D043                 jmp     short loc_D020
.text:0000D045 ; ---------------------------------------------------------------------------
.text:0000D045
.text:0000D045 loc_D045:                               ; CODE XREF: `vector constructor iterator'(void *,uint,int,void * (*)(void *))+Dj
.text:0000D045                 pop     esi
.text:0000D046                 cmp     ebp, esp
.text:0000D048                 call    __RTC_CheckEsp
.text:0000D04D                 pop     ebp
.text:0000D04E                 retn    10h
.text:0000D04E ??_H@YGXPAXIHP6EPAX0@Z@Z endp
.text:0000D04E
.text:0000D04E ; ---------------------------------------------------------------------------
.text:0000D051                 align 4
.text:0000D051 _text           ends
.text:0000D051
.text:0000D054 ; ===========================================================================
.text:0000D054
.text:0000D054 ; Segment type: Pure code
.text:0000D054 ; Segment permissions: Read/Execute
.text:0000D054 _text           segment para public 'CODE' use32
.text:0000D054                 assume cs:_text
.text:0000D054                 ;org 0D054h
.text:0000D054 ; COMDAT (pick any)
.text:0000D054                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000D054
.text:0000D054 ; =============== S U B R O U T I N E =======================================
.text:0000D054
.text:0000D054 ; Attributes: bp-based frame
.text:0000D054
.text:0000D054 ; private: void __thiscall CRecordVector<void *>::ReserveOnePosition(void)
.text:0000D054                 public ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ
.text:0000D054 ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ proc near
.text:0000D054                                         ; CODE XREF: CRecordVector<void *>::Add(void * const)+1Ap
.text:0000D054
.text:0000D054 var_14          = dword ptr -14h
.text:0000D054 var_10          = dword ptr -10h
.text:0000D054 Dst             = dword ptr -0Ch
.text:0000D054 var_8           = dword ptr -8
.text:0000D054 var_4           = dword ptr -4
.text:0000D054
.text:0000D054                 push    ebp
.text:0000D055                 mov     ebp, esp
.text:0000D057                 sub     esp, 14h
.text:0000D05A                 mov     eax, 0CCCCCCCCh
.text:0000D05F                 mov     [ebp+var_14], eax
.text:0000D062                 mov     [ebp+var_10], eax
.text:0000D065                 mov     [ebp+Dst], eax
.text:0000D068                 mov     [ebp+var_8], eax
.text:0000D06B                 mov     [ebp+var_4], eax
.text:0000D06E                 mov     [ebp+var_4], ecx
.text:0000D071                 mov     eax, [ebp+var_4]
.text:0000D074                 mov     ecx, [ebp+var_4]
.text:0000D077                 mov     edx, [eax+4]
.text:0000D07A                 cmp     edx, [ecx+8]
.text:0000D07D                 jnz     loc_D108
.text:0000D083                 mov     eax, [ebp+var_4]
.text:0000D086                 mov     ecx, [eax+8]
.text:0000D089                 shr     ecx, 2
.text:0000D08C                 mov     edx, [ebp+var_4]
.text:0000D08F                 mov     eax, [edx+8]
.text:0000D092                 lea     ecx, [eax+ecx+1]
.text:0000D096                 mov     [ebp+var_8], ecx
.text:0000D099                 xor     ecx, ecx
.text:0000D09B                 mov     eax, [ebp+var_8]
.text:0000D09E                 mov     edx, 4
.text:0000D0A3                 mul     edx
.text:0000D0A5                 seto    cl
.text:0000D0A8                 neg     ecx
.text:0000D0AA                 or      ecx, eax
.text:0000D0AC                 push    ecx             ; unsigned int
.text:0000D0AD                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0000D0B2                 add     esp, 4
.text:0000D0B5                 mov     [ebp+var_10], eax
.text:0000D0B8                 mov     eax, [ebp+var_10]
.text:0000D0BB                 mov     [ebp+Dst], eax
.text:0000D0BE                 mov     ecx, [ebp+var_4]
.text:0000D0C1                 cmp     dword ptr [ecx+4], 0
.text:0000D0C5                 jz      short loc_D0E3
.text:0000D0C7                 mov     edx, [ebp+var_4]
.text:0000D0CA                 mov     eax, [edx+4]
.text:0000D0CD                 shl     eax, 2
.text:0000D0D0                 push    eax             ; Size
.text:0000D0D1                 mov     ecx, [ebp+var_4]
.text:0000D0D4                 mov     edx, [ecx]
.text:0000D0D6                 push    edx             ; Src
.text:0000D0D7                 mov     eax, [ebp+Dst]
.text:0000D0DA                 push    eax             ; Dst
.text:0000D0DB                 call    _memcpy
.text:0000D0E0                 add     esp, 0Ch
.text:0000D0E3
.text:0000D0E3 loc_D0E3:                               ; CODE XREF: CRecordVector<void *>::ReserveOnePosition(void)+71j
.text:0000D0E3                 mov     ecx, [ebp+var_4]
.text:0000D0E6                 mov     edx, [ecx]
.text:0000D0E8                 mov     [ebp+var_14], edx
.text:0000D0EB                 mov     eax, [ebp+var_14]
.text:0000D0EE                 push    eax             ; void *
.text:0000D0EF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000D0F4                 add     esp, 4
.text:0000D0F7                 mov     ecx, [ebp+var_4]
.text:0000D0FA                 mov     edx, [ebp+Dst]
.text:0000D0FD                 mov     [ecx], edx
.text:0000D0FF                 mov     eax, [ebp+var_4]
.text:0000D102                 mov     ecx, [ebp+var_8]
.text:0000D105                 mov     [eax+8], ecx
.text:0000D108
.text:0000D108 loc_D108:                               ; CODE XREF: CRecordVector<void *>::ReserveOnePosition(void)+29j
.text:0000D108                 add     esp, 14h
.text:0000D10B                 cmp     ebp, esp
.text:0000D10D                 call    __RTC_CheckEsp
.text:0000D112                 mov     esp, ebp
.text:0000D114                 pop     ebp
.text:0000D115                 retn
.text:0000D115 ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ endp
.text:0000D115
.text:0000D115 ; ---------------------------------------------------------------------------
.text:0000D116                 align 4
.text:0000D116 _text           ends
.text:0000D116
.text:0000D118 ; ===========================================================================
.text:0000D118
.text:0000D118 ; Segment type: Pure code
.text:0000D118 ; Segment permissions: Read/Execute
.text:0000D118 _text           segment para public 'CODE' use32
.text:0000D118                 assume cs:_text
.text:0000D118                 ;org 0D118h
.text:0000D118 ; COMDAT (pick any)
.text:0000D118                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000D118
.text:0000D118 ; =============== S U B R O U T I N E =======================================
.text:0000D118
.text:0000D118 ; Attributes: bp-based frame
.text:0000D118
.text:0000D118 ; unsigned __int64 __stdcall MyMin<unsigned __int64>(unsigned __int64, unsigned __int64)
.text:0000D118                 public ??$MyMin@_K@@YG_K_K0@Z
.text:0000D118 ??$MyMin@_K@@YG_K_K0@Z proc near        ; CODE XREF: COutMultiVolStream::Write(void const *,uint,uint *)+30Bp
.text:0000D118
.text:0000D118 var_8           = dword ptr -8
.text:0000D118 var_4           = dword ptr -4
.text:0000D118 arg_0           = dword ptr  8
.text:0000D118 arg_4           = dword ptr  0Ch
.text:0000D118 arg_8           = dword ptr  10h
.text:0000D118 arg_C           = dword ptr  14h
.text:0000D118
.text:0000D118                 push    ebp
.text:0000D119                 mov     ebp, esp
.text:0000D11B                 sub     esp, 8
.text:0000D11E                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000D125                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000D12C                 mov     eax, [ebp+arg_4]
.text:0000D12F                 cmp     eax, [ebp+arg_C]
.text:0000D132                 ja      short loc_D14C
.text:0000D134                 jb      short loc_D13E
.text:0000D136                 mov     ecx, [ebp+arg_0]
.text:0000D139                 cmp     ecx, [ebp+arg_8]
.text:0000D13C                 jnb     short loc_D14C
.text:0000D13E
.text:0000D13E loc_D13E:                               ; CODE XREF: MyMin<unsigned __int64>(unsigned __int64,unsigned __int64)+1Cj
.text:0000D13E                 mov     edx, [ebp+arg_0]
.text:0000D141                 mov     [ebp+var_8], edx
.text:0000D144                 mov     eax, [ebp+arg_4]
.text:0000D147                 mov     [ebp+var_4], eax
.text:0000D14A                 jmp     short loc_D158
.text:0000D14C ; ---------------------------------------------------------------------------
.text:0000D14C
.text:0000D14C loc_D14C:                               ; CODE XREF: MyMin<unsigned __int64>(unsigned __int64,unsigned __int64)+1Aj
.text:0000D14C                                         ; MyMin<unsigned __int64>(unsigned __int64,unsigned __int64)+24j
.text:0000D14C                 mov     ecx, [ebp+arg_8]
.text:0000D14F                 mov     [ebp+var_8], ecx
.text:0000D152                 mov     edx, [ebp+arg_C]
.text:0000D155                 mov     [ebp+var_4], edx
.text:0000D158
.text:0000D158 loc_D158:                               ; CODE XREF: MyMin<unsigned __int64>(unsigned __int64,unsigned __int64)+32j
.text:0000D158                 mov     eax, [ebp+var_8]
.text:0000D15B                 mov     edx, [ebp+var_4]
.text:0000D15E                 mov     esp, ebp
.text:0000D160                 pop     ebp
.text:0000D161                 retn    10h
.text:0000D161 ??$MyMin@_K@@YG_K_K0@Z endp
.text:0000D161
.text:0000D161 _text           ends
.text:0000D161
.text:0000D164 ; ===========================================================================
.text:0000D164
.text:0000D164 ; Segment type: Pure code
.text:0000D164 ; Segment permissions: Read/Execute
.text:0000D164 _text           segment para public 'CODE' use32
.text:0000D164                 assume cs:_text
.text:0000D164                 ;org 0D164h
.text:0000D164 ; COMDAT (pick any)
.text:0000D164                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000D164
.text:0000D164 ; =============== S U B R O U T I N E =======================================
.text:0000D164
.text:0000D164 ; Attributes: bp-based frame
.text:0000D164
.text:0000D164 ; public: long __thiscall CMyComPtr<struct IInArchive>::QueryInterface<struct IOutArchive>(struct _GUID const &, struct IOutArchive * *)const
.text:0000D164                 public ??$QueryInterface@UIOutArchive@@@?$CMyComPtr@UIInArchive@@@@QBEJABU_GUID@@PAPAUIOutArchive@@@Z
.text:0000D164 ??$QueryInterface@UIOutArchive@@@?$CMyComPtr@UIInArchive@@@@QBEJABU_GUID@@PAPAUIOutArchive@@@Z proc near
.text:0000D164                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+B8p
.text:0000D164
.text:0000D164 var_4           = dword ptr -4
.text:0000D164 arg_0           = dword ptr  8
.text:0000D164 arg_4           = dword ptr  0Ch
.text:0000D164
.text:0000D164                 push    ebp
.text:0000D165                 mov     ebp, esp
.text:0000D167                 push    ecx
.text:0000D168                 push    esi
.text:0000D169                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000D170                 mov     [ebp+var_4], ecx
.text:0000D173                 mov     esi, esp
.text:0000D175                 mov     eax, [ebp+arg_4]
.text:0000D178                 push    eax
.text:0000D179                 mov     ecx, [ebp+arg_0]
.text:0000D17C                 push    ecx
.text:0000D17D                 mov     edx, [ebp+var_4]
.text:0000D180                 mov     eax, [edx]
.text:0000D182                 mov     ecx, [ebp+var_4]
.text:0000D185                 mov     edx, [ecx]
.text:0000D187                 mov     eax, [eax]
.text:0000D189                 push    edx
.text:0000D18A                 mov     ecx, [eax]
.text:0000D18C                 call    ecx
.text:0000D18E                 cmp     esi, esp
.text:0000D190                 call    __RTC_CheckEsp
.text:0000D195                 pop     esi
.text:0000D196                 add     esp, 4
.text:0000D199                 cmp     ebp, esp
.text:0000D19B                 call    __RTC_CheckEsp
.text:0000D1A0                 mov     esp, ebp
.text:0000D1A2                 pop     ebp
.text:0000D1A3                 retn    8
.text:0000D1A3 ??$QueryInterface@UIOutArchive@@@?$CMyComPtr@UIInArchive@@@@QBEJABU_GUID@@PAPAUIOutArchive@@@Z endp
.text:0000D1A3
.text:0000D1A3 ; ---------------------------------------------------------------------------
.text:0000D1A6                 align 4
.text:0000D1A6 _text           ends
.text:0000D1A6
.text:0000D1A8 ; ===========================================================================
.text:0000D1A8
.text:0000D1A8 ; Segment type: Pure code
.text:0000D1A8 ; Segment permissions: Read/Execute
.text:0000D1A8 _text           segment para public 'CODE' use32
.text:0000D1A8                 assume cs:_text
.text:0000D1A8                 ;org 0D1A8h
.text:0000D1A8 ; COMDAT (pick any)
.text:0000D1A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000D1A8
.text:0000D1A8 ; =============== S U B R O U T I N E =======================================
.text:0000D1A8
.text:0000D1A8 ; Attributes: bp-based frame
.text:0000D1A8
.text:0000D1A8 ; int __stdcall MyCompare<unsigned int>(unsigned int, unsigned int)
.text:0000D1A8                 public ??$MyCompare@I@@YGHII@Z
.text:0000D1A8 ??$MyCompare@I@@YGHII@Z proc near       ; CODE XREF: CompareRefSortPair(CRefSortPair const *,CRefSortPair const *,void *)+17p
.text:0000D1A8                                         ; CompareRefSortPair(CRefSortPair const *,CRefSortPair const *,void *)+36p
.text:0000D1A8
.text:0000D1A8 var_4           = dword ptr -4
.text:0000D1A8 arg_0           = dword ptr  8
.text:0000D1A8 arg_4           = dword ptr  0Ch
.text:0000D1A8
.text:0000D1A8                 push    ebp
.text:0000D1A9                 mov     ebp, esp
.text:0000D1AB                 push    ecx
.text:0000D1AC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000D1B3                 mov     eax, [ebp+arg_0]
.text:0000D1B6                 cmp     eax, [ebp+arg_4]
.text:0000D1B9                 jnb     short loc_D1C4
.text:0000D1BB                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000D1C2                 jmp     short loc_D1D2
.text:0000D1C4 ; ---------------------------------------------------------------------------
.text:0000D1C4
.text:0000D1C4 loc_D1C4:                               ; CODE XREF: MyCompare<uint>(uint,uint)+11j
.text:0000D1C4                 mov     ecx, [ebp+arg_0]
.text:0000D1C7                 xor     edx, edx
.text:0000D1C9                 cmp     ecx, [ebp+arg_4]
.text:0000D1CC                 setnz   dl
.text:0000D1CF                 mov     [ebp+var_4], edx
.text:0000D1D2
.text:0000D1D2 loc_D1D2:                               ; CODE XREF: MyCompare<uint>(uint,uint)+1Aj
.text:0000D1D2                 mov     eax, [ebp+var_4]
.text:0000D1D5                 mov     esp, ebp
.text:0000D1D7                 pop     ebp
.text:0000D1D8                 retn    8
.text:0000D1D8 ??$MyCompare@I@@YGHII@Z endp
.text:0000D1D8
.text:0000D1D8 _text           ends
.text:0000D1D8
UNDEF:0000D1E0 ; ===========================================================================
UNDEF:0000D1E0
UNDEF:0000D1E0 ; Segment type: Externs
UNDEF:0000D1E0 ; UNDEF
UNDEF:0000D1E0 ; public: class AString & __thiscall AString::operator=(char const *)
UNDEF:0000D1E0                 extrn ??4AString@@QAEAAV0@PBD@Z:near
UNDEF:0000D1E0                                         ; CODE XREF: CUpdateErrorInfo::SetFromLastError(char const *)+2Dp
UNDEF:0000D1E0                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1D0p ...
UNDEF:0000D1E4 ; DWORD __stdcall GetLastError()
UNDEF:0000D1E4                 extrn __imp__GetLastError@0:near
UNDEF:0000D1E4                                         ; CODE XREF: CUpdateErrorInfo::SetFromLastError(char const *)+11p
UNDEF:0000D1E4                                         ; COutMultiVolStream::Write(void const *,uint,uint *)+11Bp ...
UNDEF:0000D1E8                 extrn __RTC_CheckEsp:near
UNDEF:0000D1E8                                         ; CODE XREF: CUpdateErrorInfo::SetFromLastError(char const *)+19p
UNDEF:0000D1E8                                         ; CUpdateErrorInfo::SetFromLastError(char const *)+38p ...
UNDEF:0000D1EC                 extrn __RTC_Shutdown:near
UNDEF:0000D1EC                                         ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
UNDEF:0000D1F0                 extrn __RTC_InitBase:near
UNDEF:0000D1F0                                         ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
UNDEF:0000D1F4 ; __int32 __thiscall COutFileStream::Close(COutFileStream *__hidden this)
UNDEF:0000D1F4                 extrn ?Close@COutFileStream@@QAEJXZ:near
UNDEF:0000D1F4                                         ; CODE XREF: COutMultiVolStream::Close(void)+63p
UNDEF:0000D1F4                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+13FBp ...
UNDEF:0000D1F8 ; bool __thiscall NWindows::NFile::NIO::COutFile::SetMTime(NWindows::NFile::NIO::COutFile *__hidden this, const struct _FILETIME *)
UNDEF:0000D1F8                 extrn ?SetMTime@COutFile@NIO@NFile@NWindows@@QAE_NPBU_FILETIME@@@Z:near
UNDEF:0000D1F8                                         ; CODE XREF: COutFileStream::SetMTime(_FILETIME const *)+18p
UNDEF:0000D1FC ; public: class UString & __thiscall UString::operator=(class UString const &)
UNDEF:0000D1FC                 extrn ??4UString@@QAEAAV0@ABV0@@Z:near
UNDEF:0000D1FC                                         ; CODE XREF: COutMultiVolStream::Write(void const *,uint,uint *)+17Bp
UNDEF:0000D1FC                                         ; CArchivePath::ParseFromPath(UString const &,EArcNameMode)+49p ...
UNDEF:0000D200 ; void *__cdecl operator new(unsigned int)
UNDEF:0000D200                 extrn ??2@YAPAXI@Z:near ; CODE XREF: COutMultiVolStream::Write(void const *,uint,uint *)+AAp
UNDEF:0000D200                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+699p ...
UNDEF:0000D204 ; void __thiscall UString::Insert(UString *__hidden this, unsigned int, const struct UString *)
UNDEF:0000D204                 extrn ?Insert@UString@@QAEXIABV1@@Z:near
UNDEF:0000D204                                         ; CODE XREF: COutMultiVolStream::Write(void const *,uint,uint *)+A3p
UNDEF:0000D208 ; void __thiscall UString::InsertAtFront(UString *__hidden this, wchar_t)
UNDEF:0000D208                 extrn ?InsertAtFront@UString@@QAEX_W@Z:near
UNDEF:0000D208                                         ; CODE XREF: COutMultiVolStream::Write(void const *,uint,uint *)+90p
UNDEF:0000D20C ; public: __thiscall UString::UString(wchar_t const *)
UNDEF:0000D20C                 extrn ??0UString@@QAE@PB_W@Z:near
UNDEF:0000D20C                                         ; CODE XREF: COutMultiVolStream::Write(void const *,uint,uint *)+79p
UNDEF:0000D20C                                         ; CArchivePath::ParseFromPath(UString const &,EArcNameMode)+E0p ...
UNDEF:0000D210 ; void __stdcall ConvertUInt32ToString(unsigned int, wchar_t *)
UNDEF:0000D210                 extrn ?ConvertUInt32ToString@@YGXIPA_W@Z:near
UNDEF:0000D210                                         ; CODE XREF: COutMultiVolStream::Write(void const *,uint,uint *)+6Dp
UNDEF:0000D210                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+A80p
UNDEF:0000D214                 extrn ___security_cookie:near
UNDEF:0000D214                                         ; DATA XREF: COutMultiVolStream::Write(void const *,uint,uint *)+1Dr
UNDEF:0000D214                                         ; CArchivePath::ParseFromPath(UString const &,EArcNameMode)+2Er ...
UNDEF:0000D218 ; __fastcall __security_check_cookie(x)
UNDEF:0000D218                 extrn @__security_check_cookie@4:near
UNDEF:0000D218                                         ; CODE XREF: COutMultiVolStream::Write(void const *,uint,uint *)+507p
UNDEF:0000D218                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+1BB0p ...
UNDEF:0000D21C ; __fastcall _RTC_CheckStackVars(x, x)
UNDEF:0000D21C                 extrn @_RTC_CheckStackVars@8:near
UNDEF:0000D21C                                         ; CODE XREF: COutMultiVolStream::Write(void const *,uint,uint *)+4F9p
UNDEF:0000D21C                                         ; CArchivePath::ParseFromPath(UString const &,EArcNameMode)+14Bp ...
UNDEF:0000D220 ; void __cdecl operator delete(void *)
UNDEF:0000D220                 extrn ??3@YAXPAX@Z:near ; CODE XREF: UString::~UString(void)+23p
UNDEF:0000D220                                         ; COutFileStream::`scalar deleting destructor'(uint)+22p ...
UNDEF:0000D224 ; bool __thiscall NWindows::NFile::NIO::COutFile::Create(NWindows::NFile::NIO::COutFile *__hidden this, const wchar_t *, bool)
UNDEF:0000D224                 extrn ?Create@COutFile@NIO@NFile@NWindows@@QAE_NPB_W_N@Z:near
UNDEF:0000D224                                         ; CODE XREF: COutFileStream::Create(wchar_t const *,bool)+2Ep
UNDEF:0000D228 ; public: __thiscall UString::UString(void)
UNDEF:0000D228                 extrn ??0UString@@QAE@XZ:near
UNDEF:0000D228                                         ; CODE XREF: CUpdateOptions::SetArcPath(CCodecs const *,UString const &)+3Dp
UNDEF:0000D228                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1089p ...
UNDEF:0000D22C                 extrn ___CxxFrameHandler3:near
UNDEF:0000D22C                                         ; CODE XREF: __ehhandler$??0CAltStreamInfo@COutMultiVolStream@@QAE@XZ+16j
UNDEF:0000D22C                                         ; __ehhandler$??1CAltStreamInfo@COutMultiVolStream@@QAE@XZ+16j ...
UNDEF:0000D230 ; const type_info::`vftable'
UNDEF:0000D230                 extrn ??_7type_info@@6B@:near
UNDEF:0000D230                                         ; DATA XREF: .data:COutFileStream `RTTI Type Descriptor'o
UNDEF:0000D230                                         ; .data:IOutStream `RTTI Type Descriptor'o ...
UNDEF:0000D234 ; public: virtual long __stdcall COutFileStream::Write(void const *, unsigned int, unsigned int *)
UNDEF:0000D234                 extrn ?Write@COutFileStream@@UAGJPBXIPAI@Z:near
UNDEF:0000D234                                         ; DATA XREF: .rdata:00006964o
UNDEF:0000D238 ; public: virtual long __stdcall COutFileStream::Seek(__int64, unsigned int, unsigned __int64 *)
UNDEF:0000D238                 extrn ?Seek@COutFileStream@@UAGJ_JIPA_K@Z:near
UNDEF:0000D238                                         ; DATA XREF: .rdata:00006968o
UNDEF:0000D23C ; public: virtual long __stdcall COutFileStream::SetSize(unsigned __int64)
UNDEF:0000D23C                 extrn ?SetSize@COutFileStream@@UAGJ_K@Z:near
UNDEF:0000D23C                                         ; DATA XREF: .rdata:0000696Co
UNDEF:0000D240 ; public: virtual void * __thiscall COutFileStream::`scalar deleting destructor'(unsigned int)
UNDEF:0000D240                 extrn ??_GCOutFileStream@@UAEPAXI@Z_0:near
UNDEF:0000D244 ; public: virtual void * __thiscall COutFileStream::`vector deleting destructor'(unsigned int)
UNDEF:0000D244                 extrn ??_ECOutFileStream@@UAEPAXI@Z:near ; weak
UNDEF:0000D244                                         ; DATA XREF: .rdata:00006970o
UNDEF:0000D248                 extrn _IID_IOutStream:near
UNDEF:0000D248                                         ; DATA XREF: COutFileStream::QueryInterface(_GUID const &,void * *):loc_6BA0o
UNDEF:0000D248                                         ; COutMultiVolStream::QueryInterface(_GUID const &,void * *):loc_91DCo ...
UNDEF:0000D24C ; const IID IID_IUnknown
UNDEF:0000D24C                 extrn _IID_IUnknown:near
UNDEF:0000D24C                                         ; DATA XREF: COutFileStream::QueryInterface(_GUID const &,void * *)+Co
UNDEF:0000D24C                                         ; CStdOutFileStream::QueryInterface(_GUID const &,void * *)+Co ...
UNDEF:0000D250 ; int __cdecl memcmp(const void *Buf1, const void *Buf2, size_t Size)
UNDEF:0000D250                 extrn _memcmp:near      ; CODE XREF: IsEqualGUID(x,x)+Dp
UNDEF:0000D254 ; bool __thiscall NWindows::NFile::NIO::CFileBase::Close(NWindows::NFile::NIO::CFileBase *__hidden this)
UNDEF:0000D254                 extrn ?Close@CFileBase@NIO@NFile@NWindows@@QAE_NXZ:near
UNDEF:0000D254                                         ; CODE XREF: NWindows::NFile::NIO::CFileBase::~CFileBase(void)+11p
UNDEF:0000D258                 extrn __purecall:near   ; DATA XREF: .rdata:const IOutStream::`vftable'o
UNDEF:0000D258                                         ; .rdata:00006DC4o ...
UNDEF:0000D25C ; bool NWindows::NFile::NDir::DeleteFileAlways(NWindows::NFile::NDir *__hidden this, const wchar_t *)
UNDEF:0000D25C                 extrn ?DeleteFileAlways@NDir@NFile@NWindows@@YG_NPB_W@Z:near
UNDEF:0000D25C                                         ; CODE XREF: COutMultiVolStream::SetSize(unsigned __int64)+131p
UNDEF:0000D25C                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1AEDp ...
UNDEF:0000D260 ; void __stdcall SplitPathToParts_2(const struct UString *, struct UString *, struct UString *)
UNDEF:0000D260                 extrn ?SplitPathToParts_2@@YGXABVUString@@AAV1@1@Z:near
UNDEF:0000D260                                         ; CODE XREF: CArchivePath::ParseFromPath(UString const &,EArcNameMode)+60p
UNDEF:0000D264 ; bool __stdcall StringsAreEqualNoCase(const wchar_t *, const wchar_t *)
UNDEF:0000D264                 extrn ?StringsAreEqualNoCase@@YG_NPB_W0@Z:near
UNDEF:0000D264                                         ; CODE XREF: UString::IsEqualTo_NoCase(wchar_t const *)+18p
UNDEF:0000D268 ; int __thiscall UString::ReverseFind(UString *__hidden this, wchar_t)
UNDEF:0000D268                 extrn ?ReverseFind@UString@@QBEH_W@Z:near
UNDEF:0000D268                                         ; CODE XREF: UString::ReverseFind_Dot(void)+13p
UNDEF:0000D26C ; public: __thiscall UString::UString(class UString const &)
UNDEF:0000D26C                 extrn ??0UString@@QAE@ABV0@@Z:near
UNDEF:0000D26C                                         ; CODE XREF: CArchivePath::GetFinalPath(void)+8Ep
UNDEF:0000D26C                                         ; CArchivePath::GetFinalVolPath(void)+8Ep ...
UNDEF:0000D270 ; public: class UString & __thiscall UString::operator+=(class UString const &)
UNDEF:0000D270                 extrn ??YUString@@QAEAAV0@ABV0@@Z:near
UNDEF:0000D270                                         ; CODE XREF: CArchivePath::GetFinalPath(void)+82p
UNDEF:0000D270                                         ; CArchivePath::GetFinalVolPath(void)+82p ...
UNDEF:0000D274 ; void __thiscall UString::Grow_1(UString *__hidden this)
UNDEF:0000D274                 extrn ?Grow_1@UString@@AAEXXZ:near
UNDEF:0000D274                                         ; CODE XREF: UString::operator+=(wchar_t)+2Fp
UNDEF:0000D278 ; class UString __stdcall operator+(class UString const &, class UString const &)
UNDEF:0000D278                 extrn ??H@YG?AVUString@@ABV0@0@Z:near
UNDEF:0000D278                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+24Cp
UNDEF:0000D278                                         ; CArchivePath::GetPathWithoutExt(void)+30p
UNDEF:0000D27C ; void __thiscall UString::AddAscii(UString *__hidden this, const char *)
UNDEF:0000D27C                 extrn ?AddAscii@UString@@QAEXPBD@Z:near
UNDEF:0000D27C                                         ; CODE XREF: CArchivePath::GetTempPathA(void)+A1p
UNDEF:0000D280 ; int __thiscall CCodecs::FindFormatForArchiveName(CCodecs *__hidden this, const struct UString *)
UNDEF:0000D280                 extrn ?FindFormatForArchiveName@CCodecs@@QBEHABVUString@@@Z:near
UNDEF:0000D280                                         ; CODE XREF: CUpdateOptions::InitFormatIndex(CCodecs const *,CObjectVector<COpenType> const &,UString const &)+9Ap
UNDEF:0000D284 ; void __thiscall UString::SetFromAscii(UString *__hidden this, const char *)
UNDEF:0000D284                 extrn ?SetFromAscii@UString@@QAEXPBD@Z:near
UNDEF:0000D284                                         ; CODE XREF: CUpdateOptions::SetArcPath(CCodecs const *,UString const &)+F9p
UNDEF:0000D284                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+19Cp ...
UNDEF:0000D288 ; public: class UString & __thiscall UString::operator=(wchar_t const *)
UNDEF:0000D288                 extrn ??4UString@@QAEAAV0@PB_W@Z:near
UNDEF:0000D288                                         ; CODE XREF: CUpdateOptions::SetArcPath(CCodecs const *,UString const &)+62p
UNDEF:0000D288                                         ; Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+A92p
UNDEF:0000D28C ; bool __stdcall DoesNameContainWildcard(const struct UString *)
UNDEF:0000D28C                 extrn ?DoesNameContainWildcard@@YG_NABVUString@@@Z:near
UNDEF:0000D28C                                         ; CODE XREF: CRenamePair::Prepare(void)+2Ep
UNDEF:0000D290 ; class UString __stdcall operator+(class UString const &, wchar_t const *)
UNDEF:0000D290                 extrn ??H@YG?AVUString@@ABV0@PB_W@Z:near
UNDEF:0000D290                                         ; CODE XREF: CRenamePair::GetNewPath(bool,UString const &,UString &)+131p
UNDEF:0000D294 ; bool g_CaseSensitive
UNDEF:0000D294                 extrn ?g_CaseSensitive@@3_NA:near
UNDEF:0000D294                                         ; DATA XREF: CompareTwoNames(wchar_t const *,wchar_t const *):loc_16A9r
UNDEF:0000D298 ; wchar_t __stdcall MyCharUpper_WIN(wchar_t)
UNDEF:0000D298                 extrn ?MyCharUpper_WIN@@YG_W_W@Z:near
UNDEF:0000D298                                         ; CODE XREF: MyCharUpper(wchar_t)+38p
UNDEF:0000D29C ; bool NWindows::NFile::NDir::RemoveDir(NWindows::NFile::NDir *__hidden this, const wchar_t *)
UNDEF:0000D29C                 extrn ?RemoveDir@NDir@NFile@NWindows@@YG_NPB_W@Z:near
UNDEF:0000D29C                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+26CBp
UNDEF:0000D2A0 ; bool NWindows::NFile::NFind::DoesDirExist(NWindows::NFile::NFind *__hidden this, const wchar_t *)
UNDEF:0000D2A0                 extrn ?DoesDirExist@NFind@NFile@NWindows@@YG_NPB_W@Z:near
UNDEF:0000D2A0                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+25AFp
UNDEF:0000D2A4 ; struct UString __thiscall __high CDirItems::GetPhyPath(unsigned int)
UNDEF:0000D2A4                 extrn ?GetPhyPath@CDirItems@@QBE?AVUString@@I@Z:near
UNDEF:0000D2A4                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+2376p
UNDEF:0000D2A4                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+259Ap
UNDEF:0000D2A8 ; void *__cdecl memset(void *Dst, int Val, size_t Size)
UNDEF:0000D2A8                 extrn _memset:near      ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+2181p
UNDEF:0000D2A8                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+21C0p ...
UNDEF:0000D2AC ; struct UString __stdcall __high ExtractFileNameFromPath(const struct UString *)
UNDEF:0000D2AC                 extrn ?ExtractFileNameFromPath@@YG?AVUString@@ABV1@@Z:near
UNDEF:0000D2AC                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+213Fp
UNDEF:0000D2B0 ; bool NWindows::NFile::NDir::MyGetFullPathName(NWindows::NFile::NDir *__hidden this, const wchar_t *, struct UString *)
UNDEF:0000D2B0                 extrn ?MyGetFullPathName@NDir@NFile@NWindows@@YG_NPB_WAAVUString@@@Z:near
UNDEF:0000D2B0                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1F9Ep
UNDEF:0000D2B4 ; bool __thiscall NWindows::NDLL::CLibrary::Load(NWindows::NDLL::CLibrary *__hidden this, const wchar_t *)
UNDEF:0000D2B4                 extrn ?Load@CLibrary@NDLL@NWindows@@QAE_NPB_W@Z:near
UNDEF:0000D2B4                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1D59p
UNDEF:0000D2B8 ; bool NWindows::NFile::NDir::MyMoveFile(NWindows::NFile::NDir *__hidden this, const wchar_t *, const wchar_t *)
UNDEF:0000D2B8                 extrn ?MyMoveFile@NDir@NFile@NWindows@@YG_NPB_W0@Z:near
UNDEF:0000D2B8                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1C01p
UNDEF:0000D2BC ; void __thiscall CArchiveLink::Release(CArchiveLink *__hidden this)
UNDEF:0000D2BC                 extrn ?Release@CArchiveLink@@QAEXXZ:near
UNDEF:0000D2BC                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1A59p
UNDEF:0000D2BC                                         ; CArchiveLink::~CArchiveLink(void)+37p
UNDEF:0000D2C0 ; __int32 __thiscall CArchiveLink::Close(CArchiveLink *__hidden this)
UNDEF:0000D2C0                 extrn ?Close@CArchiveLink@@QAEJXZ:near
UNDEF:0000D2C0                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+199Ap
UNDEF:0000D2C4 ; bool NWindows::NFile::NFind::DoesFileOrDirExist(NWindows::NFile::NFind *__hidden this, const wchar_t *)
UNDEF:0000D2C4                 extrn ?DoesFileOrDirExist@NFind@NFile@NWindows@@YG_NPB_W@Z:near
UNDEF:0000D2C4                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+12BEp
UNDEF:0000D2C8 ; void NWindows::NFile::NName::NormalizeDirPathPrefix(NWindows::NFile::NName *__hidden this, struct UString *)
UNDEF:0000D2C8                 extrn ?NormalizeDirPathPrefix@NName@NFile@NWindows@@YGXAAVUString@@@Z:near
UNDEF:0000D2C8                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+10F3p
UNDEF:0000D2C8                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1200p
UNDEF:0000D2CC ; bool __thiscall NWindows::NFile::NDir::CTempDir::Create(NWindows::NFile::NDir::CTempDir *__hidden this, const wchar_t *)
UNDEF:0000D2CC                 extrn ?Create@CTempDir@NDir@NFile@NWindows@@QAE_NPB_W@Z:near
UNDEF:0000D2CC                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+10D0p
UNDEF:0000D2D0 ; __int32 __thiscall CDirItems::AddSecurityItem(CDirItems *__hidden this, const struct UString *, int *)
UNDEF:0000D2D0                 extrn ?AddSecurityItem@CDirItems@@QAEJABVUString@@AAH@Z:near
UNDEF:0000D2D0                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+1048p
UNDEF:0000D2D4 ; __int32 __stdcall __high EnumerateItems(const struct NWildcard::CCensor *, enum NWildcard::ECensorPathMode, const struct UString *, struct CDirItems *)
UNDEF:0000D2D4                 extrn ?EnumerateItems@@YGJABVCCensor@NWildcard@@W4ECensorPathMode@2@ABVUString@@AAVCDirItems@@@Z:near
UNDEF:0000D2D4                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+E1Dp
UNDEF:0000D2D8 ; void NWindows::NTime::GetCurUtcFileTime(NWindows::NTime *__hidden this, struct _FILETIME *)
UNDEF:0000D2D8                 extrn ?GetCurUtcFileTime@NTime@NWindows@@YGXAAU_FILETIME@@@Z:near
UNDEF:0000D2D8                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+C84p
UNDEF:0000D2DC ; public: __thiscall CDirItems::CDirItems(void)
UNDEF:0000D2DC                 extrn ??0CDirItems@@QAE@XZ:near
UNDEF:0000D2DC                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+BDDp
UNDEF:0000D2E0 ; int __thiscall CCodecs::FindFormatForArchiveType(CCodecs *__hidden this, const struct UString *)
UNDEF:0000D2E0                 extrn ?FindFormatForArchiveType@CCodecs@@QBEHABVUString@@@Z:near
UNDEF:0000D2E0                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+B29p
UNDEF:0000D2E4 ; __int32 __thiscall CArchiveLink::Open3(CArchiveLink *__hidden this, struct COpenOptions *, struct IOpenCallbackUI *)
UNDEF:0000D2E4                 extrn ?Open3@CArchiveLink@@QAEJAAUCOpenOptions@@PAUIOpenCallbackUI@@@Z:near
UNDEF:0000D2E4                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+6A2p
UNDEF:0000D2E8 ; bool __thiscall NWindows::NFile::NFind::CFileInfo::Find(NWindows::NFile::NFind::CFileInfo *__hidden this, const wchar_t *)
UNDEF:0000D2E8                 extrn ?Find@CFileInfo@NFind@NFile@NWindows@@QAE_NPB_W@Z:near
UNDEF:0000D2E8                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+3E2p
UNDEF:0000D2E8                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+F7Ep
UNDEF:0000D2EC ; bool NWindows::NFile::NFind::DoesFileExist(NWindows::NFile::NFind *__hidden this, const wchar_t *)
UNDEF:0000D2EC                 extrn ?DoesFileExist@NFind@NFile@NWindows@@YG_NPB_W@Z:near
UNDEF:0000D2EC                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+269p
UNDEF:0000D2EC                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+2AEp
UNDEF:0000D2F0 ; struct UString __stdcall __high NWindows::NDLL::GetModuleDirPrefix()
UNDEF:0000D2F0                 extrn ?GetModuleDirPrefix@NDLL@NWindows@@YG?AVUString@@XZ:near
UNDEF:0000D2F0                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+21Cp
UNDEF:0000D2F4 ; void __thiscall NWildcard::CCensor::ExtendExclude(NWildcard::CCensor *__hidden this)
UNDEF:0000D2F4                 extrn ?ExtendExclude@CCensor@NWildcard@@QAEXXZ:near
UNDEF:0000D2F4                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+144p
UNDEF:0000D2F8 ; void __stdcall ConvertToLongNames(struct NWildcard::CCensor *)
UNDEF:0000D2F8                 extrn ?ConvertToLongNames@@YGXAAVCCensor@NWildcard@@@Z:near
UNDEF:0000D2F8                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+13Cp
UNDEF:0000D2FC ; void __thiscall __high NWildcard::CCensor::AddPathsToCensor(enum NWildcard::ECensorPathMode)
UNDEF:0000D2FC                 extrn ?AddPathsToCensor@CCensor@NWildcard@@QAEXW4ECensorPathMode@2@@Z:near
UNDEF:0000D2FC                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+133p
UNDEF:0000D300 ; __stdcall _CxxThrowException(x, x)
UNDEF:0000D300                 extrn __CxxThrowException@8:near
UNDEF:0000D300                                         ; CODE XREF: UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+3B7p
UNDEF:0000D300                                         ; UpdateArchive(CCodecs *,CObjectVector<COpenType> const &,UString const &,NWildcard::CCensor &,CUpdateOptions &,CUpdateErrorInfo &,IOpenCallbackUI *,IUpdateCallbackUI2 *,bool)+410p ...
UNDEF:0000D304 ; int __stdcall FindCharPosInString(const wchar_t *, wchar_t)
UNDEF:0000D304                 extrn ?FindCharPosInString@@YGHPB_W_W@Z:near
UNDEF:0000D304                                         ; CODE XREF: UString::Find(wchar_t)+19p
UNDEF:0000D308 ; void __thiscall NWindows::NFile::NFind::CFileInfoBase::ClearBase(NWindows::NFile::NFind::CFileInfoBase *__hidden this)
UNDEF:0000D308                 extrn ?ClearBase@CFileInfoBase@NFind@NFile@NWindows@@QAEXXZ:near
UNDEF:0000D308                                         ; CODE XREF: NWindows::NFile::NFind::CFileInfoBase::CFileInfoBase(void)+11p
UNDEF:0000D30C ; struct AString __stdcall __high UnicodeStringToMultiByte(const struct UString *, unsigned int)
UNDEF:0000D30C                 extrn ?UnicodeStringToMultiByte@@YG?AVAString@@ABVUString@@I@Z:near
UNDEF:0000D30C                                         ; CODE XREF: GetAnsiString(UString const &)+1Cp
UNDEF:0000D310 ; bool __thiscall NWindows::NDLL::CLibrary::Free(NWindows::NDLL::CLibrary *__hidden this)
UNDEF:0000D310                 extrn ?Free@CLibrary@NDLL@NWindows@@QAE_NXZ:near
UNDEF:0000D310                                         ; CODE XREF: NWindows::NDLL::CLibrary::~CLibrary(void)+11p
UNDEF:0000D314 ; FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName)
UNDEF:0000D314                 extrn __imp__GetProcAddress@8:near
UNDEF:0000D314                                         ; CODE XREF: NWindows::NDLL::CLibrary::GetProc(char const *)+1Bp
UNDEF:0000D314                                         ; DATA XREF: NWindows::NDLL::CLibrary::GetProc(char const *)+1Br
UNDEF:0000D318 ; bool __thiscall NWindows::NFile::NDir::CTempDir::Remove(NWindows::NFile::NDir::CTempDir *__hidden this)
UNDEF:0000D318                 extrn ?Remove@CTempDir@NDir@NFile@NWindows@@QAE_NXZ:near
UNDEF:0000D318                                         ; CODE XREF: NWindows::NFile::NDir::CTempDir::~CTempDir(void)+37p
UNDEF:0000D31C ; bool NWindows::NFile::NDir::GetCurrentDir(NWindows::NFile::NDir *__hidden this, struct UString *)
UNDEF:0000D31C                 extrn ?GetCurrentDir@NDir@NFile@NWindows@@YG_NAAVUString@@@Z:near
UNDEF:0000D31C                                         ; CODE XREF: NWindows::NFile::NDir::CCurrentDirRestorer::CCurrentDirRestorer(void)+47p
UNDEF:0000D31C                                         ; NWindows::NFile::NDir::CCurrentDirRestorer::~CCurrentDirRestorer(void)+63p
UNDEF:0000D320 ; bool NWindows::NFile::NDir::SetCurrentDir(NWindows::NFile::NDir *__hidden this, const wchar_t *)
UNDEF:0000D320                 extrn ?SetCurrentDir@NDir@NFile@NWindows@@YG_NPB_W@Z:near
UNDEF:0000D320                                         ; CODE XREF: NWindows::NFile::NDir::CCurrentDirRestorer::~CCurrentDirRestorer(void)+8Cp
UNDEF:0000D324 ; int __cdecl _wcscmp(const wchar_t *Str1, const wchar_t *Str2)
UNDEF:0000D324                 extrn __imp__wcscmp:near
UNDEF:0000D324                                         ; CODE XREF: operator!=(UString const &,UString const &)+36p
UNDEF:0000D324                                         ; DATA XREF: operator!=(UString const &,UString const &)+36r
UNDEF:0000D328 ; void __thiscall CTempFiles::Clear(CTempFiles *__hidden this)
UNDEF:0000D328                 extrn ?Clear@CTempFiles@@AAEXXZ:near
UNDEF:0000D328                                         ; CODE XREF: CTempFiles::~CTempFiles(void)+37p
UNDEF:0000D32C ; __int32 __thiscall COutFileStream::GetSize(COutFileStream *__hidden this, unsigned __int64 *)
UNDEF:0000D32C                 extrn ?GetSize@COutFileStream@@QAEJPA_K@Z:near
UNDEF:0000D32C                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+1A8Ep
UNDEF:0000D330 ; LONG __stdcall CompareFileTime(const FILETIME *lpFileTime1, const FILETIME *lpFileTime2)
UNDEF:0000D330                 extrn __imp__CompareFileTime@8:near
UNDEF:0000D330                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+19E7p
UNDEF:0000D330                                         ; DATA XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+19E7r
UNDEF:0000D334 ; __int32 NCompress::CopyStream_ExactSize(NCompress *__hidden this, struct ISequentialInStream *, struct ISequentialOutStream *, unsigned __int64, struct ICompressProgressInfo *)
UNDEF:0000D334                 extrn ?CopyStream_ExactSize@NCompress@@YGJPAUISequentialInStream@@PAUISequentialOutStream@@_KPAUICompressProgressInfo@@@Z:near
UNDEF:0000D334                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+1601p
UNDEF:0000D338 ; __int32 NCompress::CopyStream(NCompress *__hidden this, struct ISequentialInStream *, struct ISequentialOutStream *, struct ICompressProgressInfo *)
UNDEF:0000D338                 extrn ?CopyStream@NCompress@@YGJPAUISequentialInStream@@PAUISequentialOutStream@@PAUICompressProgressInfo@@@Z:near
UNDEF:0000D338                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+1347p
UNDEF:0000D33C ; _DWORD __thiscall CInFileStream::CInFileStream(CInFileStream *__hidden this)
UNDEF:0000D33C                 extrn ??0CInFileStream@@QAE@XZ:near
UNDEF:0000D33C                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+F0Dp
UNDEF:0000D340 ; long __stdcall SetProperties(struct IUnknown *, class CObjectVector<struct CProperty> const &)
UNDEF:0000D340                 extrn ?SetProperties@@YGJPAUIUnknown@@ABV?$CObjectVector@UCProperty@@@@@Z:near
UNDEF:0000D340                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+E59p
UNDEF:0000D344 ; bool NWindows::NFile::NDir::CreateComplexDir(NWindows::NFile::NDir *__hidden this, const wchar_t *)
UNDEF:0000D344                 extrn ?CreateComplexDir@NDir@NFile@NWindows@@YG_NPB_W@Z:near
UNDEF:0000D344                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+8DBp
UNDEF:0000D348 ; bool NWindows::NFile::NDir::GetOnlyDirPrefix(NWindows::NFile::NDir *__hidden this, const wchar_t *, struct UString *)
UNDEF:0000D348                 extrn ?GetOnlyDirPrefix@NDir@NFile@NWindows@@YG_NPB_WAAVUString@@@Z:near
UNDEF:0000D348                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+885p
UNDEF:0000D34C ; _DWORD __thiscall CArchiveUpdateCallback::CArchiveUpdateCallback(CArchiveUpdateCallback *__hidden this)
UNDEF:0000D34C                 extrn ??0CArchiveUpdateCallback@@QAE@XZ:near
UNDEF:0000D34C                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+6BAp
UNDEF:0000D350 ; void __stdcall UpdateProduce(class CRecordVector<struct CUpdatePair> const &, struct NUpdateArchive::CActionSet const &, class CRecordVector<struct CUpdatePair2> &, struct IUpdateProduceCallback *)
UNDEF:0000D350                 extrn ?UpdateProduce@@YGXABV?$CRecordVector@UCUpdatePair@@@@ABUCActionSet@NUpdateArchive@@AAV?$CRecordVector@UCUpdatePair2@@@@PAUIUpdateProduceCallback@@@Z:near
UNDEF:0000D350                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+5B7p
UNDEF:0000D354 ; void __stdcall GetUpdatePairInfoList(class CDirItems const &, class CObjectVector<struct CArcItem> const &, enum  NFileTimeType::EEnum, class CRecordVector<struct CUpdatePair> &)
UNDEF:0000D354                 extrn ?GetUpdatePairInfoList@@YGXABVCDirItems@@ABV?$CObjectVector@UCArcItem@@@@W4EEnum@NFileTimeType@@AAV?$CRecordVector@UCUpdatePair@@@@@Z:near
UNDEF:0000D354                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+57Fp
UNDEF:0000D358 ; public: class UString & __thiscall UString::operator+=(wchar_t const *)
UNDEF:0000D358                 extrn ??YUString@@QAEAAV0@PB_W@Z:near
UNDEF:0000D358                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+430p
UNDEF:0000D35C ; int __stdcall FindAltStreamColon_in_Path(const wchar_t *)
UNDEF:0000D35C                 extrn ?FindAltStreamColon_in_Path@@YGHPB_W@Z:near
UNDEF:0000D35C                                         ; CODE XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+3ACp
UNDEF:0000D360                 extrn _IID_IOutArchive:near
UNDEF:0000D360                                         ; DATA XREF: Compress(CUpdateOptions const &,bool,CCodecs *,NUpdateArchive::CActionSet const &,CArc const *,CArchivePath &,CObjectVector<CArcItem> const &,uchar *,CDirItems const &,CDirItem const *,CTempFiles &,CUpdateErrorInfo &,IUpdateCallbackUI *,CFinishArchiveStat &)+B0o
UNDEF:0000D364 ; private: __thiscall UString::UString(unsigned int, class UString const &)
UNDEF:0000D364                 extrn ??0UString@@AAE@IABV0@@Z:near
UNDEF:0000D364                                         ; CODE XREF: UString::Left(uint)+29p
UNDEF:0000D368 ; __int32 __stdcall Archive_GetItemBoolProp(struct IInArchive *, unsigned int, unsigned __int32, bool *)
UNDEF:0000D368                 extrn ?Archive_GetItemBoolProp@@YGJPAUIInArchive@@IKAA_N@Z:near
UNDEF:0000D368                                         ; CODE XREF: CArc::IsItemAnti(uint,bool &)+21p
UNDEF:0000D36C ; bool __thiscall NWindows::NFile::NIO::CInFile::Open(NWindows::NFile::NIO::CInFile *__hidden this, const wchar_t *)
UNDEF:0000D36C                 extrn ?Open@CInFile@NIO@NFile@NWindows@@QAE_NPB_W@Z:near
UNDEF:0000D36C                                         ; CODE XREF: CInFileStream::Open(wchar_t const *)+18p
UNDEF:0000D370 ; public: virtual long __stdcall CStdOutFileStream::Write(void const *, unsigned int, unsigned int *)
UNDEF:0000D370                 extrn ?Write@CStdOutFileStream@@UAGJPBXIPAI@Z:near
UNDEF:0000D370                                         ; DATA XREF: .rdata:00008B98o
UNDEF:0000D374 ; public: virtual void * __thiscall CStdOutFileStream::`scalar deleting destructor'(unsigned int)
UNDEF:0000D374                 extrn ??_GCStdOutFileStream@@UAEPAXI@Z_0:near
UNDEF:0000D378 ; public: virtual void * __thiscall CStdOutFileStream::`vector deleting destructor'(unsigned int)
UNDEF:0000D378                 extrn ??_ECStdOutFileStream@@UAEPAXI@Z:near ; weak
UNDEF:0000D378                                         ; DATA XREF: .rdata:00008B9Co
UNDEF:0000D37C ; public: virtual long __stdcall CTailOutStream::Write(void const *, unsigned int, unsigned int *)
UNDEF:0000D37C                 extrn ?Write@CTailOutStream@@UAGJPBXIPAI@Z:near
UNDEF:0000D37C                                         ; DATA XREF: .rdata:00009438o
UNDEF:0000D380 ; public: virtual long __stdcall CTailOutStream::Seek(__int64, unsigned int, unsigned __int64 *)
UNDEF:0000D380                 extrn ?Seek@CTailOutStream@@UAGJ_JIPA_K@Z:near
UNDEF:0000D380                                         ; DATA XREF: .rdata:0000943Co
UNDEF:0000D384 ; public: virtual long __stdcall CTailOutStream::SetSize(unsigned __int64)
UNDEF:0000D384                 extrn ?SetSize@CTailOutStream@@UAGJ_K@Z:near
UNDEF:0000D384                                         ; DATA XREF: .rdata:00009440o
UNDEF:0000D388 ; public: virtual void * __thiscall CTailOutStream::`scalar deleting destructor'(unsigned int)
UNDEF:0000D388                 extrn ??_GCTailOutStream@@UAEPAXI@Z_0:near
UNDEF:0000D38C ; public: virtual void * __thiscall CTailOutStream::`vector deleting destructor'(unsigned int)
UNDEF:0000D38C                 extrn ??_ECTailOutStream@@UAEPAXI@Z:near ; weak
UNDEF:0000D38C                                         ; DATA XREF: .rdata:00009444o
UNDEF:0000D390                 extrn _IID_ISequentialOutStream:near
UNDEF:0000D390                                         ; DATA XREF: CTailOutStream::QueryInterface(_GUID const &,void * *):loc_94E8o
UNDEF:0000D394 ; __int32 __thiscall CArc::GetItemSize(CArc *__hidden this, unsigned int, unsigned __int64 *, bool *)
UNDEF:0000D394                 extrn ?GetItemSize@CArc@@QBEJIAA_KAA_N@Z:near
UNDEF:0000D394                                         ; CODE XREF: EnumerateInArchiveItems(NWildcard::CCensor const &,CArc const &,CObjectVector<CArcItem> &)+1BBp
UNDEF:0000D398 ; __int32 __thiscall CArc::GetItemMTime(CArc *__hidden this, unsigned int, struct _FILETIME *, bool *)
UNDEF:0000D398                 extrn ?GetItemMTime@CArc@@QBEJIAAU_FILETIME@@AA_N@Z:near
UNDEF:0000D398                                         ; CODE XREF: EnumerateInArchiveItems(NWildcard::CCensor const &,CArc const &,CObjectVector<CArcItem> &)+15Dp
UNDEF:0000D39C ; __int32 __thiscall CArc::GetItem(CArc *__hidden this, unsigned int, struct CReadArcItem *)
UNDEF:0000D39C                 extrn ?GetItem@CArc@@QBEJIAAUCReadArcItem@@@Z:near
UNDEF:0000D39C                                         ; CODE XREF: EnumerateInArchiveItems(NWildcard::CCensor const &,CArc const &,CObjectVector<CArcItem> &)+CEp
UNDEF:0000D3A0 ; __int32 __thiscall NWindows::NCOM::CPropVariant::Clear(NWindows::NCOM::CPropVariant *__hidden this)
UNDEF:0000D3A0                 extrn ?Clear@CPropVariant@NCOM@NWindows@@QAEJXZ:near
UNDEF:0000D3A0                                         ; CODE XREF: NWindows::NCOM::CPropVariant::~CPropVariant(void)+11p
UNDEF:0000D3A4 ; bool __stdcall CensorNode_CheckPath2(const struct NWildcard::CCensorNode *, const struct CReadArcItem *, bool *)
UNDEF:0000D3A4                 extrn ?CensorNode_CheckPath2@@YG_NABVCCensorNode@NWildcard@@ABUCReadArcItem@@AA_N@Z:near
UNDEF:0000D3A4                                         ; CODE XREF: Censor_CheckPath(NWildcard::CCensor const &,CReadArcItem const &)+55p
UNDEF:0000D3A8 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:0000D3A8                 extrn _memcpy:near      ; CODE XREF: CRecordVector<unsigned __int64>::operator=(CRecordVector<unsigned __int64> const &)+C3p
UNDEF:0000D3A8                                         ; CRecordVector<void *>::Reserve(uint)+67p ...
UNDEF:0000D3A8
UNDEF:0000D3A8
UNDEF:0000D3A8                 end