.rdata:00000000 ;
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.rdata:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.rdata:00000000 ; |                      License info: 48-3677-7074-51                      |
.rdata:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ;
.rdata:00000000 ; Input MD5   : D1323DEFECBBF940B01413E744E148EA
.rdata:00000000 ; Input CRC32 : 641CF20B
.rdata:00000000
.rdata:00000000 ; File Name   : C:\workspace\7z1505-src\CPP\7zip\Bundles\Alone\Debug\CommandLineParser.obj
.rdata:00000000 ; Format      : COFF (X386MAGIC)
.rdata:00000000 ; includelib "uuid.lib"
.rdata:00000000 ; includelib "MSVCRTD"
.rdata:00000000 ; includelib "OLDNAMES"
.rdata:00000000
.rdata:00000000                 .686p
.rdata:00000000                 .mmx
.rdata:00000000                 .model flat
.rdata:00000000
.rdata:00000000 ; ===========================================================================
.rdata:00000000
.rdata:00000000 ; Segment type: Pure data
.rdata:00000000 ; Segment permissions: Read
.rdata:00000000 _rdata          segment dword public 'DATA' use32
.rdata:00000000                 assume cs:_rdata
.rdata:00000000 $SG67228        db  2Dh ; -             ; DATA XREF: .data:_kStopSwitchParsingo
.rdata:00000001                 db  2Dh ; -
.rdata:00000002                 db    0
.rdata:00000003                 db    0
.rdata:00000004 $SG67279        db 'Unknown switch:',0  ; DATA XREF: NCommandLineParser::CParser::ParseString(UString const &,NCommandLineParser::CSwitchForm const *)+104o
.rdata:00000014 $SG67283        db 'Multiple instances for switch:',0
.rdata:00000014                                         ; DATA XREF: NCommandLineParser::CParser::ParseString(UString const &,NCommandLineParser::CSwitchForm const *)+154o
.rdata:00000033                 align 4
.rdata:00000034 $SG67286        db 'Too short switch:',0
.rdata:00000034                                         ; DATA XREF: NCommandLineParser::CParser::ParseString(UString const &,NCommandLineParser::CSwitchForm const *)+18Bo
.rdata:00000046                 align 4
.rdata:00000048 $SG67294        db 'Incorrect switch postfix:',0
.rdata:00000048                                         ; DATA XREF: NCommandLineParser::CParser::ParseString(UString const &,NCommandLineParser::CSwitchForm const *):loc_6E4o
.rdata:00000062                 align 4
.rdata:00000064 $SG67301        db 'Incorrect switch postfix:',0
.rdata:00000064                                         ; DATA XREF: NCommandLineParser::CParser::ParseString(UString const &,NCommandLineParser::CSwitchForm const *):loc_746o
.rdata:0000007E                 align 10h
.rdata:00000080 $SG67306        db 'Too long switch:',0 ; DATA XREF: NCommandLineParser::CParser::ParseString(UString const &,NCommandLineParser::CSwitchForm const *)+2D1o
.rdata:00000091                 align 4
.rdata:00000091 _rdata          ends
.rdata:00000091
.data:00000094 ; ===========================================================================
.data:00000094
.data:00000094 ; Segment type: Pure data
.data:00000094 ; Segment permissions: Read/Write
.data:00000094 _data           segment dword public 'DATA' use32
.data:00000094                 assume cs:_data
.data:00000094                 ;org 94h
.data:00000094 ; char *kStopSwitchParsing
.data:00000094 _kStopSwitchParsing dd offset $SG67228  ; DATA XREF: NCommandLineParser::CParser::ParseStrings(NCommandLineParser::CSwitchForm const *,CObjectVector<UString> const &)+63r
.data:00000094 _data           ends
.data:00000094
.text:00000098 ; ===========================================================================
.text:00000098
.text:00000098 ; Segment type: Pure code
.text:00000098 ; Segment permissions: Read/Execute
.text:00000098 _text           segment para public 'CODE' use32
.text:00000098                 assume cs:_text
.text:00000098                 ;org 98h
.text:00000098                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000098
.text:00000098 ; =============== S U B R O U T I N E =======================================
.text:00000098
.text:00000098 ; Attributes: bp-based frame
.text:00000098
.text:00000098 ; bool __stdcall NCommandLineParser::SplitCommandLine(NCommandLineParser *this, const struct UString *, struct UString *, struct UString *)
.text:00000098                 public ?SplitCommandLine@NCommandLineParser@@YG_NABVUString@@AAV2@1@Z
.text:00000098 ?SplitCommandLine@NCommandLineParser@@YG_NABVUString@@AAV2@1@Z proc near
.text:00000098                                         ; CODE XREF: NCommandLineParser::SplitCommandLine(UString const &,CObjectVector<UString> &)+7Cp
.text:00000098
.text:00000098 var_C           = dword ptr -0Ch
.text:00000098 var_8           = dword ptr -8
.text:00000098 var_4           = dword ptr -4
.text:00000098 this            = dword ptr  8
.text:00000098 arg_4           = dword ptr  0Ch
.text:00000098 arg_8           = dword ptr  10h
.text:00000098
.text:00000098                 push    ebp
.text:00000099                 mov     ebp, esp
.text:0000009B                 sub     esp, 0Ch
.text:0000009E                 mov     [ebp+var_C], 0CCCCCCCCh
.text:000000A5                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000000AC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000000B3                 mov     ecx, [ebp+arg_4] ; this
.text:000000B6                 call    ?Empty@UString@@QAEXXZ ; UString::Empty(void)
.text:000000BB                 mov     ecx, [ebp+arg_8] ; this
.text:000000BE                 call    ?Empty@UString@@QAEXXZ ; UString::Empty(void)
.text:000000C3                 mov     byte ptr [ebp+var_4+3], 0
.text:000000C7                 mov     [ebp+var_8], 0
.text:000000CE                 jmp     short loc_D9
.text:000000D0 ; ---------------------------------------------------------------------------
.text:000000D0
.text:000000D0 loc_D0:                                 ; CODE XREF: NCommandLineParser::SplitCommandLine(UString const &,UString &,UString &):loc_15Cj
.text:000000D0                 mov     eax, [ebp+var_8]
.text:000000D3                 add     eax, 1
.text:000000D6                 mov     [ebp+var_8], eax
.text:000000D9
.text:000000D9 loc_D9:                                 ; CODE XREF: NCommandLineParser::SplitCommandLine(UString const &,UString &,UString &)+36j
.text:000000D9                 mov     ecx, [ebp+this] ; this
.text:000000DC                 call    ?Len@UString@@QBEIXZ ; UString::Len(void)
.text:000000E1                 cmp     [ebp+var_8], eax
.text:000000E4                 jnb     short loc_161
.text:000000E6                 mov     ecx, [ebp+this]
.text:000000E9                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000000EE                 mov     ecx, [ebp+var_8]
.text:000000F1                 mov     dx, [eax+ecx*2]
.text:000000F5                 mov     word ptr [ebp+var_C], dx
.text:000000F9                 movzx   eax, word ptr [ebp+var_C]
.text:000000FD                 cmp     eax, 20h ; ' '
.text:00000100                 jz      short loc_10B
.text:00000102                 movzx   ecx, word ptr [ebp+var_C]
.text:00000106                 cmp     ecx, 9
.text:00000109                 jnz     short loc_136
.text:0000010B
.text:0000010B loc_10B:                                ; CODE XREF: NCommandLineParser::SplitCommandLine(UString const &,UString &,UString &)+68j
.text:0000010B                 movzx   edx, byte ptr [ebp+var_4+3]
.text:0000010F                 test    edx, edx
.text:00000111                 jnz     short loc_136
.text:00000113                 mov     eax, [ebp+var_8]
.text:00000116                 add     eax, 1
.text:00000119                 push    eax             ; unsigned int
.text:0000011A                 mov     ecx, [ebp+this] ; this
.text:0000011D                 call    ?Ptr@UString@@QBEPB_WI@Z ; UString::Ptr(uint)
.text:00000122                 push    eax
.text:00000123                 mov     ecx, [ebp+arg_8]
.text:00000126                 call    ??4UString@@QAEAAV0@PB_W@Z ; UString::operator=(wchar_t const *)
.text:0000012B                 xor     eax, eax
.text:0000012D                 cmp     [ebp+var_8], 0
.text:00000131                 setnz   al
.text:00000134                 jmp     short loc_16A
.text:00000136 ; ---------------------------------------------------------------------------
.text:00000136
.text:00000136 loc_136:                                ; CODE XREF: NCommandLineParser::SplitCommandLine(UString const &,UString &,UString &)+71j
.text:00000136                                         ; NCommandLineParser::SplitCommandLine(UString const &,UString &,UString &)+79j
.text:00000136                 movzx   ecx, word ptr [ebp+var_C]
.text:0000013A                 cmp     ecx, 22h ; '"'
.text:0000013D                 jnz     short loc_14F
.text:0000013F                 movzx   edx, byte ptr [ebp+var_4+3]
.text:00000143                 neg     edx
.text:00000145                 sbb     edx, edx
.text:00000147                 add     edx, 1
.text:0000014A                 mov     byte ptr [ebp+var_4+3], dl
.text:0000014D                 jmp     short loc_15C
.text:0000014F ; ---------------------------------------------------------------------------
.text:0000014F
.text:0000014F loc_14F:                                ; CODE XREF: NCommandLineParser::SplitCommandLine(UString const &,UString &,UString &)+A5j
.text:0000014F                 movzx   eax, word ptr [ebp+var_C]
.text:00000153                 push    eax
.text:00000154                 mov     ecx, [ebp+arg_4]
.text:00000157                 call    ??YUString@@QAEAAV0@_W@Z ; UString::operator+=(wchar_t)
.text:0000015C
.text:0000015C loc_15C:                                ; CODE XREF: NCommandLineParser::SplitCommandLine(UString const &,UString &,UString &)+B5j
.text:0000015C                 jmp     loc_D0
.text:00000161 ; ---------------------------------------------------------------------------
.text:00000161
.text:00000161 loc_161:                                ; CODE XREF: NCommandLineParser::SplitCommandLine(UString const &,UString &,UString &)+4Cj
.text:00000161                 xor     eax, eax
.text:00000163                 cmp     [ebp+var_8], 0
.text:00000167                 setnz   al
.text:0000016A
.text:0000016A loc_16A:                                ; CODE XREF: NCommandLineParser::SplitCommandLine(UString const &,UString &,UString &)+9Cj
.text:0000016A                 add     esp, 0Ch
.text:0000016D                 cmp     ebp, esp
.text:0000016F                 call    __RTC_CheckEsp
.text:00000174                 mov     esp, ebp
.text:00000176                 pop     ebp
.text:00000177                 retn    0Ch
.text:00000177 ?SplitCommandLine@NCommandLineParser@@YG_NABVUString@@AAV2@1@Z endp
.text:00000177
.text:00000177 ; ---------------------------------------------------------------------------
.text:0000017A                 db 0Eh dup(0CCh)
.text:00000188
.text:00000188 ; =============== S U B R O U T I N E =======================================
.text:00000188
.text:00000188 ; Attributes: bp-based frame
.text:00000188
.text:00000188 ; void __stdcall NCommandLineParser::SplitCommandLine(class UString const &, class CObjectVector<class UString> &)
.text:00000188                 public ?SplitCommandLine@NCommandLineParser@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z
.text:00000188 ?SplitCommandLine@NCommandLineParser@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z proc near
.text:00000188
.text:00000188 var_48          = byte ptr -48h
.text:00000188 var_44          = byte ptr -44h
.text:00000188 var_30          = byte ptr -30h
.text:00000188 var_1C          = byte ptr -1Ch
.text:00000188 var_C           = dword ptr -0Ch
.text:00000188 var_4           = dword ptr -4
.text:00000188 arg_0           = dword ptr  8
.text:00000188 arg_4           = dword ptr  0Ch
.text:00000188
.text:00000188                 push    ebp
.text:00000189                 mov     ebp, esp
.text:0000018B                 push    0FFFFFFFFh
.text:0000018D                 push    offset __ehhandler$?SplitCommandLine@NCommandLineParser@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z
.text:00000192                 mov     eax, large fs:0
.text:00000198                 push    eax
.text:00000199                 sub     esp, 3Ch
.text:0000019C                 push    edi
.text:0000019D                 lea     edi, [ebp+var_48]
.text:000001A0                 mov     ecx, 0Fh
.text:000001A5                 mov     eax, 0CCCCCCCCh
.text:000001AA                 rep stosd
.text:000001AC                 mov     eax, dword ptr ds:___security_cookie
.text:000001B1                 xor     eax, ebp
.text:000001B3                 push    eax             ; struct UString *
.text:000001B4                 lea     eax, [ebp+var_C]
.text:000001B7                 mov     large fs:0, eax
.text:000001BD                 mov     eax, [ebp+arg_0]
.text:000001C0                 push    eax
.text:000001C1                 lea     ecx, [ebp+var_1C]
.text:000001C4                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:000001C9                 mov     [ebp+var_4], 0
.text:000001D0                 lea     ecx, [ebp+var_1C] ; this
.text:000001D3                 call    ?Trim@UString@@QAEXXZ ; UString::Trim(void)
.text:000001D8                 mov     ecx, [ebp+arg_4]
.text:000001DB                 call    ?Clear@?$CObjectVector@VUString@@@@QAEXXZ ; CObjectVector<UString>::Clear(void)
.text:000001E0
.text:000001E0 loc_1E0:                                ; CODE XREF: NCommandLineParser::SplitCommandLine(UString const &,CObjectVector<UString> &)+E1j
.text:000001E0                 lea     ecx, [ebp+var_30]
.text:000001E3                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:000001E8                 mov     byte ptr [ebp+var_4], 1
.text:000001EC                 lea     ecx, [ebp+var_44]
.text:000001EF                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:000001F4                 mov     byte ptr [ebp+var_4], 2
.text:000001F8                 lea     ecx, [ebp+var_44]
.text:000001FB                 push    ecx             ; struct UString *
.text:000001FC                 lea     edx, [ebp+var_30]
.text:000001FF                 push    edx             ; struct UString *
.text:00000200                 lea     eax, [ebp+var_1C]
.text:00000203                 push    eax             ; this
.text:00000204                 call    ?SplitCommandLine@NCommandLineParser@@YG_NABVUString@@AAV2@1@Z ; NCommandLineParser::SplitCommandLine(UString const &,UString &,UString &)
.text:00000209                 movzx   ecx, al
.text:0000020C                 test    ecx, ecx
.text:0000020E                 jz      short loc_21C
.text:00000210                 lea     edx, [ebp+var_30]
.text:00000213                 push    edx
.text:00000214                 mov     ecx, [ebp+arg_4]
.text:00000217                 call    ?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z ; CObjectVector<UString>::Add(UString const &)
.text:0000021C
.text:0000021C loc_21C:                                ; CODE XREF: NCommandLineParser::SplitCommandLine(UString const &,CObjectVector<UString> &)+86j
.text:0000021C                 lea     ecx, [ebp+var_44] ; this
.text:0000021F                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:00000224                 movzx   eax, al
.text:00000227                 test    eax, eax
.text:00000229                 jz      short loc_245
.text:0000022B                 mov     byte ptr [ebp+var_4], 1
.text:0000022F                 lea     ecx, [ebp+var_44] ; this
.text:00000232                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000237                 mov     byte ptr [ebp+var_4], 0
.text:0000023B                 lea     ecx, [ebp+var_30] ; this
.text:0000023E                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000243                 jmp     short loc_26E
.text:00000245 ; ---------------------------------------------------------------------------
.text:00000245
.text:00000245 loc_245:                                ; CODE XREF: NCommandLineParser::SplitCommandLine(UString const &,CObjectVector<UString> &)+A1j
.text:00000245                 lea     ecx, [ebp+var_44]
.text:00000248                 push    ecx
.text:00000249                 lea     ecx, [ebp+var_1C]
.text:0000024C                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:00000251                 mov     byte ptr [ebp+var_4], 1
.text:00000255                 lea     ecx, [ebp+var_44] ; this
.text:00000258                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000025D                 mov     byte ptr [ebp+var_4], 0
.text:00000261                 lea     ecx, [ebp+var_30] ; this
.text:00000264                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000269                 jmp     loc_1E0
.text:0000026E ; ---------------------------------------------------------------------------
.text:0000026E
.text:0000026E loc_26E:                                ; CODE XREF: NCommandLineParser::SplitCommandLine(UString const &,CObjectVector<UString> &)+BBj
.text:0000026E                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000275                 lea     ecx, [ebp+var_1C] ; this
.text:00000278                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000027D                 push    edx
.text:0000027E                 mov     ecx, ebp
.text:00000280                 push    eax
.text:00000281                 lea     edx, $LN15
.text:00000287                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:0000028C                 pop     eax
.text:0000028D                 pop     edx
.text:0000028E                 mov     ecx, [ebp+var_C]
.text:00000291                 mov     large fs:0, ecx
.text:00000298                 pop     ecx
.text:00000299                 pop     edi
.text:0000029A                 add     esp, 48h
.text:0000029D                 cmp     ebp, esp
.text:0000029F                 call    __RTC_CheckEsp
.text:000002A4                 mov     esp, ebp
.text:000002A6                 pop     ebp
.text:000002A7                 retn    8
.text:000002A7 ?SplitCommandLine@NCommandLineParser@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z endp
.text:000002A7
.text:000002A7 ; ---------------------------------------------------------------------------
.text:000002AA                 align 4
.text:000002AC $LN15           dd 3                    ; DATA XREF: NCommandLineParser::SplitCommandLine(UString const &,CObjectVector<UString> &)+F9o
.text:000002B0                 dd offset $LN14
.text:000002B4 $LN14           dd 0FFFFFFE4h, 0Ch      ; DATA XREF: .text:000002B0o
.text:000002BC                 dd offset $LN10         ; "sTemp"
.text:000002C0                 dd 0FFFFFFD0h, 0Ch
.text:000002C8                 dd offset $LN11
.text:000002CC                 dd 0FFFFFFBCh, 0Ch
.text:000002D4                 dd offset $LN12
.text:000002D8 $LN12           db 73h, 32h, 0          ; DATA XREF: .text:000002D4o
.text:000002DB $LN11           db 73h                  ; DATA XREF: .text:000002C8o
.text:000002DC                 db 31h, 0
.text:000002DE $LN10           db 'sTemp',0            ; DATA XREF: .text:000002BCo
.text:000002E4                 align 8
.text:000002E8
.text:000002E8 ; =============== S U B R O U T I N E =======================================
.text:000002E8
.text:000002E8 ; Attributes: bp-based frame
.text:000002E8
.text:000002E8 ; _DWORD __thiscall NCommandLineParser::CParser::CParser(NCommandLineParser::CParser *this, unsigned int)
.text:000002E8                 public ??0CParser@NCommandLineParser@@QAE@I@Z
.text:000002E8 ??0CParser@NCommandLineParser@@QAE@I@Z proc near
.text:000002E8
.text:000002E8 var_20          = dword ptr -20h
.text:000002E8 var_1C          = dword ptr -1Ch
.text:000002E8 var_18          = dword ptr -18h
.text:000002E8 var_14          = dword ptr -14h
.text:000002E8 var_10          = dword ptr -10h
.text:000002E8 var_C           = dword ptr -0Ch
.text:000002E8 var_4           = dword ptr -4
.text:000002E8 arg_0           = dword ptr  8
.text:000002E8
.text:000002E8                 push    ebp
.text:000002E9                 mov     ebp, esp
.text:000002EB                 push    0FFFFFFFFh
.text:000002ED                 push    offset __ehhandler$??0CParser@NCommandLineParser@@QAE@I@Z
.text:000002F2                 mov     eax, large fs:0
.text:000002F8                 push    eax
.text:000002F9                 sub     esp, 14h
.text:000002FC                 mov     eax, 0CCCCCCCCh
.text:00000301                 mov     [ebp+var_20], eax
.text:00000304                 mov     [ebp+var_1C], eax
.text:00000307                 mov     [ebp+var_18], eax
.text:0000030A                 mov     [ebp+var_14], eax
.text:0000030D                 mov     [ebp+var_10], eax
.text:00000310                 mov     eax, dword ptr ds:___security_cookie
.text:00000315                 xor     eax, ebp
.text:00000317                 push    eax
.text:00000318                 lea     eax, [ebp+var_C]
.text:0000031B                 mov     large fs:0, eax
.text:00000321                 mov     [ebp+var_10], ecx
.text:00000324                 mov     eax, [ebp+var_10]
.text:00000327                 mov     ecx, [ebp+arg_0]
.text:0000032A                 mov     [eax], ecx
.text:0000032C                 mov     edx, [ebp+var_10]
.text:0000032F                 mov     dword ptr [edx+4], 0
.text:00000336                 mov     ecx, [ebp+var_10]
.text:00000339                 add     ecx, 8
.text:0000033C                 call    ??0?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::CObjectVector<UString>(void)
.text:00000341                 mov     [ebp+var_4], 0
.text:00000348                 mov     ecx, [ebp+var_10]
.text:0000034B                 add     ecx, 14h        ; this
.text:0000034E                 call    ??0AString@@QAE@XZ ; AString::AString(void)
.text:00000353                 mov     byte ptr [ebp+var_4], 1
.text:00000357                 mov     ecx, [ebp+var_10]
.text:0000035A                 add     ecx, 20h ; ' '
.text:0000035D                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00000362                 mov     byte ptr [ebp+var_4], 2
.text:00000366                 mov     eax, [ebp+arg_0]
.text:00000369                 mov     [ebp+var_14], eax
.text:0000036C                 xor     ecx, ecx
.text:0000036E                 mov     eax, [ebp+var_14]
.text:00000371                 mov     edx, 14h
.text:00000376                 mul     edx
.text:00000378                 seto    cl
.text:0000037B                 neg     ecx
.text:0000037D                 or      ecx, eax
.text:0000037F                 xor     eax, eax
.text:00000381                 add     ecx, 4
.text:00000384                 setb    al
.text:00000387                 neg     eax
.text:00000389                 or      eax, ecx
.text:0000038B                 push    eax             ; unsigned int
.text:0000038C                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00000391                 add     esp, 4
.text:00000394                 mov     [ebp+var_1C], eax
.text:00000397                 mov     byte ptr [ebp+var_4], 3
.text:0000039B                 cmp     [ebp+var_1C], 0
.text:0000039F                 jz      short loc_3D0
.text:000003A1                 mov     ecx, [ebp+var_1C]
.text:000003A4                 mov     edx, [ebp+var_14]
.text:000003A7                 mov     [ecx], edx
.text:000003A9                 push    offset ??1CSwitchResult@NCommandLineParser@@QAE@XZ ; NCommandLineParser::CSwitchResult::~CSwitchResult(void)
.text:000003AE                 push    offset ??0CSwitchResult@NCommandLineParser@@QAE@XZ ; NCommandLineParser::CSwitchResult::CSwitchResult(void)
.text:000003B3                 mov     eax, [ebp+var_14]
.text:000003B6                 push    eax
.text:000003B7                 push    14h
.text:000003B9                 mov     ecx, [ebp+var_1C]
.text:000003BC                 add     ecx, 4
.text:000003BF                 push    ecx
.text:000003C0                 call    ??_L@YGXPAXIHP6EX0@Z1@Z ; `eh vector constructor iterator'(void *,uint,int,void (*)(void *),void (*)(void *))
.text:000003C5                 mov     edx, [ebp+var_1C]
.text:000003C8                 add     edx, 4
.text:000003CB                 mov     [ebp+var_20], edx
.text:000003CE                 jmp     short loc_3D7
.text:000003D0 ; ---------------------------------------------------------------------------
.text:000003D0
.text:000003D0 loc_3D0:                                ; CODE XREF: NCommandLineParser::CParser::CParser(uint)+B7j
.text:000003D0                 mov     [ebp+var_20], 0
.text:000003D7
.text:000003D7 loc_3D7:                                ; CODE XREF: NCommandLineParser::CParser::CParser(uint)+E6j
.text:000003D7                 mov     eax, [ebp+var_20]
.text:000003DA                 mov     [ebp+var_18], eax
.text:000003DD                 mov     byte ptr [ebp+var_4], 2
.text:000003E1                 mov     ecx, [ebp+var_10]
.text:000003E4                 mov     edx, [ebp+var_18]
.text:000003E7                 mov     [ecx+4], edx
.text:000003EA                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000003F1                 mov     eax, [ebp+var_10]
.text:000003F4                 mov     ecx, [ebp+var_C]
.text:000003F7                 mov     large fs:0, ecx
.text:000003FE                 pop     ecx
.text:000003FF                 add     esp, 20h
.text:00000402                 cmp     ebp, esp
.text:00000404                 call    __RTC_CheckEsp
.text:00000409                 mov     esp, ebp
.text:0000040B                 pop     ebp
.text:0000040C                 retn    4
.text:0000040C ??0CParser@NCommandLineParser@@QAE@I@Z endp
.text:0000040C
.text:0000040C ; ---------------------------------------------------------------------------
.text:0000040F                 db 9 dup(0CCh)
.text:00000418
.text:00000418 ; =============== S U B R O U T I N E =======================================
.text:00000418
.text:00000418 ; Attributes: bp-based frame
.text:00000418
.text:00000418 ; _DWORD __thiscall NCommandLineParser::CParser::~CParser(NCommandLineParser::CParser *__hidden this)
.text:00000418                 public ??1CParser@NCommandLineParser@@QAE@XZ
.text:00000418 ??1CParser@NCommandLineParser@@QAE@XZ proc near
.text:00000418
.text:00000418 var_1C          = dword ptr -1Ch
.text:00000418 var_18          = dword ptr -18h
.text:00000418 var_14          = dword ptr -14h
.text:00000418 var_10          = dword ptr -10h
.text:00000418 var_C           = dword ptr -0Ch
.text:00000418 var_4           = dword ptr -4
.text:00000418
.text:00000418                 push    ebp
.text:00000419                 mov     ebp, esp
.text:0000041B                 push    0FFFFFFFFh
.text:0000041D                 push    offset __ehhandler$??1CParser@NCommandLineParser@@QAE@XZ
.text:00000422                 mov     eax, large fs:0
.text:00000428                 push    eax
.text:00000429                 sub     esp, 10h
.text:0000042C                 mov     eax, 0CCCCCCCCh
.text:00000431                 mov     [ebp+var_1C], eax
.text:00000434                 mov     [ebp+var_18], eax
.text:00000437                 mov     [ebp+var_14], eax
.text:0000043A                 mov     [ebp+var_10], eax
.text:0000043D                 mov     eax, dword ptr ds:___security_cookie
.text:00000442                 xor     eax, ebp
.text:00000444                 push    eax
.text:00000445                 lea     eax, [ebp+var_C]
.text:00000448                 mov     large fs:0, eax
.text:0000044E                 mov     [ebp+var_10], ecx
.text:00000451                 mov     [ebp+var_4], 2
.text:00000458                 mov     eax, [ebp+var_10]
.text:0000045B                 mov     ecx, [eax+4]
.text:0000045E                 mov     [ebp+var_18], ecx
.text:00000461                 mov     edx, [ebp+var_18]
.text:00000464                 mov     [ebp+var_14], edx
.text:00000467                 cmp     [ebp+var_14], 0
.text:0000046B                 jz      short loc_47C
.text:0000046D                 push    3
.text:0000046F                 mov     ecx, [ebp+var_14]
.text:00000472                 call    ??_ECSwitchResult@NCommandLineParser@@QAEPAXI@Z ; NCommandLineParser::CSwitchResult::`vector deleting destructor'(uint)
.text:00000477                 mov     [ebp+var_1C], eax
.text:0000047A                 jmp     short loc_483
.text:0000047C ; ---------------------------------------------------------------------------
.text:0000047C
.text:0000047C loc_47C:                                ; CODE XREF: NCommandLineParser::CParser::~CParser(void)+53j
.text:0000047C                 mov     [ebp+var_1C], 0
.text:00000483
.text:00000483 loc_483:                                ; CODE XREF: NCommandLineParser::CParser::~CParser(void)+62j
.text:00000483                 mov     byte ptr [ebp+var_4], 1
.text:00000487                 mov     ecx, [ebp+var_10]
.text:0000048A                 add     ecx, 20h ; ' '  ; this
.text:0000048D                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000492                 mov     byte ptr [ebp+var_4], 0
.text:00000496                 mov     ecx, [ebp+var_10]
.text:00000499                 add     ecx, 14h        ; this
.text:0000049C                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:000004A1                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000004A8                 mov     ecx, [ebp+var_10]
.text:000004AB                 add     ecx, 8
.text:000004AE                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:000004B3                 mov     ecx, [ebp+var_C]
.text:000004B6                 mov     large fs:0, ecx
.text:000004BD                 pop     ecx
.text:000004BE                 add     esp, 1Ch
.text:000004C1                 cmp     ebp, esp
.text:000004C3                 call    __RTC_CheckEsp
.text:000004C8                 mov     esp, ebp
.text:000004CA                 pop     ebp
.text:000004CB                 retn
.text:000004CB ??1CParser@NCommandLineParser@@QAE@XZ endp
.text:000004CB
.text:000004CB ; ---------------------------------------------------------------------------
.text:000004CC                 db 0Ch dup(0CCh)
.text:000004D8
.text:000004D8 ; =============== S U B R O U T I N E =======================================
.text:000004D8
.text:000004D8 ; Attributes: bp-based frame
.text:000004D8
.text:000004D8 ; bool __thiscall NCommandLineParser::CParser::ParseString(NCommandLineParser::CParser *this, const struct UString *, const struct NCommandLineParser::CSwitchForm *)
.text:000004D8                 public ?ParseString@CParser@NCommandLineParser@@AAE_NABVUString@@PBUCSwitchForm@2@@Z
.text:000004D8 ?ParseString@CParser@NCommandLineParser@@AAE_NABVUString@@PBUCSwitchForm@2@@Z proc near
.text:000004D8                                         ; CODE XREF: NCommandLineParser::CParser::ParseStrings(NCommandLineParser::CSwitchForm const *,CObjectVector<UString> const &)+B0p
.text:000004D8
.text:000004D8 var_48          = byte ptr -48h
.text:000004D8 var_44          = byte ptr -44h
.text:000004D8 var_38          = word ptr -38h
.text:000004D8 var_34          = dword ptr -34h
.text:000004D8 var_30          = dword ptr -30h
.text:000004D8 var_2C          = dword ptr -2Ch
.text:000004D8 var_28          = dword ptr -28h
.text:000004D8 var_24          = dword ptr -24h
.text:000004D8 var_20          = dword ptr -20h
.text:000004D8 var_1C          = dword ptr -1Ch
.text:000004D8 var_18          = dword ptr -18h
.text:000004D8 var_14          = dword ptr -14h
.text:000004D8 var_10          = dword ptr -10h
.text:000004D8 var_C           = dword ptr -0Ch
.text:000004D8 var_4           = dword ptr -4
.text:000004D8 arg_0           = dword ptr  8
.text:000004D8 arg_4           = dword ptr  0Ch
.text:000004D8
.text:000004D8                 push    ebp
.text:000004D9                 mov     ebp, esp
.text:000004DB                 push    0FFFFFFFFh
.text:000004DD                 push    offset __ehhandler$?ParseString@CParser@NCommandLineParser@@AAE_NABVUString@@PBUCSwitchForm@2@@Z
.text:000004E2                 mov     eax, large fs:0
.text:000004E8                 push    eax
.text:000004E9                 sub     esp, 3Ch
.text:000004EC                 push    esi
.text:000004ED                 push    edi
.text:000004EE                 push    ecx
.text:000004EF                 lea     edi, [ebp+var_48]
.text:000004F2                 mov     ecx, 0Fh
.text:000004F7                 mov     eax, 0CCCCCCCCh
.text:000004FC                 rep stosd
.text:000004FE                 pop     ecx
.text:000004FF                 mov     eax, dword ptr ds:___security_cookie
.text:00000504                 xor     eax, ebp
.text:00000506                 push    eax
.text:00000507                 lea     eax, [ebp+var_C]
.text:0000050A                 mov     large fs:0, eax
.text:00000510                 mov     [ebp+var_10], ecx
.text:00000513                 mov     ecx, [ebp+arg_0] ; this
.text:00000516                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:0000051B                 movzx   eax, al
.text:0000051E                 test    eax, eax
.text:00000520                 jnz     short loc_53A
.text:00000522                 mov     ecx, [ebp+arg_0]
.text:00000525                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:0000052A                 movzx   ecx, word ptr [eax]
.text:0000052D                 push    ecx
.text:0000052E                 call    ?IsItSwitchChar@NCommandLineParser@@YG_N_W@Z ; NCommandLineParser::IsItSwitchChar(wchar_t)
.text:00000533                 movzx   edx, al
.text:00000536                 test    edx, edx
.text:00000538                 jnz     short loc_541
.text:0000053A
.text:0000053A loc_53A:                                ; CODE XREF: NCommandLineParser::CParser::ParseString(UString const &,NCommandLineParser::CSwitchForm const *)+48j
.text:0000053A                 xor     al, al
.text:0000053C                 jmp     loc_7BF
.text:00000541 ; ---------------------------------------------------------------------------
.text:00000541
.text:00000541 loc_541:                                ; CODE XREF: NCommandLineParser::CParser::ParseString(UString const &,NCommandLineParser::CSwitchForm const *)+60j
.text:00000541                 mov     [ebp+var_14], 1
.text:00000548                 mov     [ebp+var_18], 0
.text:0000054F                 mov     [ebp+var_1C], 0FFFFFFFFh
.text:00000556                 mov     [ebp+var_20], 0
.text:0000055D                 jmp     short loc_568
.text:0000055F ; ---------------------------------------------------------------------------
.text:0000055F
.text:0000055F loc_55F:                                ; CODE XREF: NCommandLineParser::CParser::ParseString(UString const &,NCommandLineParser::CSwitchForm const *):loc_5A7j
.text:0000055F                                         ; NCommandLineParser::CParser::ParseString(UString const &,NCommandLineParser::CSwitchForm const *):loc_5D4j
.text:0000055F                 mov     eax, [ebp+var_20]
.text:00000562                 add     eax, 1
.text:00000565                 mov     [ebp+var_20], eax
.text:00000568
.text:00000568 loc_568:                                ; CODE XREF: NCommandLineParser::CParser::ParseString(UString const &,NCommandLineParser::CSwitchForm const *)+85j
.text:00000568                 mov     ecx, [ebp+var_10]
.text:0000056B                 mov     edx, [ebp+var_20]
.text:0000056E                 cmp     edx, [ecx]
.text:00000570                 jnb     short loc_5D6
.text:00000572                 mov     eax, [ebp+var_20]
.text:00000575                 imul    eax, 0Ch
.text:00000578                 mov     ecx, [ebp+arg_4]
.text:0000057B                 mov     edx, [ecx+eax]
.text:0000057E                 mov     [ebp+var_24], edx
.text:00000581                 mov     eax, [ebp+var_24]
.text:00000584                 push    eax             ; char *
.text:00000585                 call    ?MyStringLen@@YGIPBD@Z ; MyStringLen(char const *)
.text:0000058A                 mov     [ebp+var_28], eax
.text:0000058D                 mov     ecx, [ebp+var_28]
.text:00000590                 cmp     ecx, [ebp+var_1C]
.text:00000593                 jle     short loc_5A7
.text:00000595                 mov     esi, [ebp+var_14]
.text:00000598                 add     esi, [ebp+var_28]
.text:0000059B                 mov     ecx, [ebp+arg_0] ; this
.text:0000059E                 call    ?Len@UString@@QBEIXZ ; UString::Len(void)
.text:000005A3                 cmp     esi, eax
.text:000005A5                 jbe     short loc_5A9
.text:000005A7
.text:000005A7 loc_5A7:                                ; CODE XREF: NCommandLineParser::CParser::ParseString(UString const &,NCommandLineParser::CSwitchForm const *)+BBj
.text:000005A7                 jmp     short loc_55F
.text:000005A9 ; ---------------------------------------------------------------------------
.text:000005A9
.text:000005A9 loc_5A9:                                ; CODE XREF: NCommandLineParser::CParser::ParseString(UString const &,NCommandLineParser::CSwitchForm const *)+CDj
.text:000005A9                 mov     edx, [ebp+var_24]
.text:000005AC                 push    edx
.text:000005AD                 mov     ecx, [ebp+arg_0]
.text:000005B0                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000005B5                 mov     ecx, [ebp+var_14]
.text:000005B8                 lea     edx, [eax+ecx*2]
.text:000005BB                 push    edx
.text:000005BC                 call    ?IsString1PrefixedByString2_NoCase@@YG_NPB_WPBD@Z ; IsString1PrefixedByString2_NoCase(wchar_t const *,char const *)
.text:000005C1                 movzx   eax, al
.text:000005C4                 test    eax, eax
.text:000005C6                 jz      short loc_5D4
.text:000005C8                 mov     ecx, [ebp+var_20]
.text:000005CB                 mov     [ebp+var_18], ecx
.text:000005CE                 mov     edx, [ebp+var_28]
.text:000005D1                 mov     [ebp+var_1C], edx
.text:000005D4
.text:000005D4 loc_5D4:                                ; CODE XREF: NCommandLineParser::CParser::ParseString(UString const &,NCommandLineParser::CSwitchForm const *)+EEj
.text:000005D4                 jmp     short loc_55F
.text:000005D6 ; ---------------------------------------------------------------------------
.text:000005D6
.text:000005D6 loc_5D6:                                ; CODE XREF: NCommandLineParser::CParser::ParseString(UString const &,NCommandLineParser::CSwitchForm const *)+98j
.text:000005D6                 cmp     [ebp+var_1C], 0
.text:000005DA                 jge     short loc_5F3
.text:000005DC                 push    offset $SG67279 ; "Unknown switch:"
.text:000005E1                 mov     ecx, [ebp+var_10]
.text:000005E4                 add     ecx, 14h
.text:000005E7                 call    ??4AString@@QAEAAV0@PBD@Z ; AString::operator=(char const *)
.text:000005EC                 xor     al, al
.text:000005EE                 jmp     loc_7BF
.text:000005F3 ; ---------------------------------------------------------------------------
.text:000005F3
.text:000005F3 loc_5F3:                                ; CODE XREF: NCommandLineParser::CParser::ParseString(UString const &,NCommandLineParser::CSwitchForm const *)+102j
.text:000005F3                 mov     eax, [ebp+var_14]
.text:000005F6                 add     eax, [ebp+var_1C]
.text:000005F9                 mov     [ebp+var_14], eax
.text:000005FC                 mov     ecx, [ebp+var_18]
.text:000005FF                 imul    ecx, 14h
.text:00000602                 mov     edx, [ebp+var_10]
.text:00000605                 add     ecx, [edx+4]
.text:00000608                 mov     [ebp+var_2C], ecx
.text:0000060B                 mov     eax, [ebp+var_18]
.text:0000060E                 imul    eax, 0Ch
.text:00000611                 add     eax, [ebp+arg_4]
.text:00000614                 mov     [ebp+var_30], eax
.text:00000617                 mov     ecx, [ebp+var_30]
.text:0000061A                 movzx   edx, byte ptr [ecx+5]
.text:0000061E                 test    edx, edx
.text:00000620                 jnz     short loc_643
.text:00000622                 mov     eax, [ebp+var_2C]
.text:00000625                 movzx   ecx, byte ptr [eax]
.text:00000628                 test    ecx, ecx
.text:0000062A                 jz      short loc_643
.text:0000062C                 push    offset $SG67283 ; "Multiple instances for switch:"
.text:00000631                 mov     ecx, [ebp+var_10]
.text:00000634                 add     ecx, 14h
.text:00000637                 call    ??4AString@@QAEAAV0@PBD@Z ; AString::operator=(char const *)
.text:0000063C                 xor     al, al
.text:0000063E                 jmp     loc_7BF
.text:00000643 ; ---------------------------------------------------------------------------
.text:00000643
.text:00000643 loc_643:                                ; CODE XREF: NCommandLineParser::CParser::ParseString(UString const &,NCommandLineParser::CSwitchForm const *)+148j
.text:00000643                                         ; NCommandLineParser::CParser::ParseString(UString const &,NCommandLineParser::CSwitchForm const *)+152j
.text:00000643                 mov     edx, [ebp+var_2C]
.text:00000646                 mov     byte ptr [edx], 1
.text:00000649                 mov     ecx, [ebp+arg_0] ; this
.text:0000064C                 call    ?Len@UString@@QBEIXZ ; UString::Len(void)
.text:00000651                 sub     eax, [ebp+var_14]
.text:00000654                 mov     [ebp+var_34], eax
.text:00000657                 mov     eax, [ebp+var_30]
.text:0000065A                 movzx   ecx, byte ptr [eax+6]
.text:0000065E                 cmp     [ebp+var_34], ecx
.text:00000661                 jge     short loc_67A
.text:00000663                 push    offset $SG67286 ; "Too short switch:"
.text:00000668                 mov     ecx, [ebp+var_10]
.text:0000066B                 add     ecx, 14h
.text:0000066E                 call    ??4AString@@QAEAAV0@PBD@Z ; AString::operator=(char const *)
.text:00000673                 xor     al, al
.text:00000675                 jmp     loc_7BF
.text:0000067A ; ---------------------------------------------------------------------------
.text:0000067A
.text:0000067A loc_67A:                                ; CODE XREF: NCommandLineParser::CParser::ParseString(UString const &,NCommandLineParser::CSwitchForm const *)+189j
.text:0000067A                 mov     edx, [ebp+var_2C]
.text:0000067D                 mov     byte ptr [edx+1], 0
.text:00000681                 mov     eax, [ebp+var_2C]
.text:00000684                 mov     dword ptr [eax+4], 0FFFFFFFFh
.text:0000068B                 mov     ecx, [ebp+var_30]
.text:0000068E                 mov     dl, [ecx+4]
.text:00000691                 mov     [ebp+var_48], dl
.text:00000694                 cmp     [ebp+var_48], 1
.text:00000698                 jz      short loc_6AF
.text:0000069A                 cmp     [ebp+var_48], 2
.text:0000069E                 jz      loc_75C
.text:000006A4                 cmp     [ebp+var_48], 3
.text:000006A8                 jz      short loc_700
.text:000006AA                 jmp     loc_79C
.text:000006AF ; ---------------------------------------------------------------------------
.text:000006AF
.text:000006AF loc_6AF:                                ; CODE XREF: NCommandLineParser::CParser::ParseString(UString const &,NCommandLineParser::CSwitchForm const *)+1C0j
.text:000006AF                 cmp     [ebp+var_34], 1
.text:000006B3                 jnz     short loc_6FB
.text:000006B5                 mov     ecx, [ebp+arg_0]
.text:000006B8                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000006BD                 mov     ecx, [ebp+var_14]
.text:000006C0                 movzx   edx, word ptr [eax+ecx*2]
.text:000006C4                 xor     eax, eax
.text:000006C6                 cmp     edx, 2Dh ; '-'
.text:000006C9                 setz    al
.text:000006CC                 mov     ecx, [ebp+var_2C]
.text:000006CF                 mov     [ecx+1], al
.text:000006D2                 mov     edx, [ebp+var_2C]
.text:000006D5                 movzx   eax, byte ptr [edx+1]
.text:000006D9                 test    eax, eax
.text:000006DB                 jz      short loc_6E4
.text:000006DD                 mov     al, 1
.text:000006DF                 jmp     loc_7BF
.text:000006E4 ; ---------------------------------------------------------------------------
.text:000006E4
.text:000006E4 loc_6E4:                                ; CODE XREF: NCommandLineParser::CParser::ParseString(UString const &,NCommandLineParser::CSwitchForm const *)+203j
.text:000006E4                 push    offset $SG67294 ; "Incorrect switch postfix:"
.text:000006E9                 mov     ecx, [ebp+var_10]
.text:000006EC                 add     ecx, 14h
.text:000006EF                 call    ??4AString@@QAEAAV0@PBD@Z ; AString::operator=(char const *)
.text:000006F4                 xor     al, al
.text:000006F6                 jmp     loc_7BF
.text:000006FB ; ---------------------------------------------------------------------------
.text:000006FB
.text:000006FB loc_6FB:                                ; CODE XREF: NCommandLineParser::CParser::ParseString(UString const &,NCommandLineParser::CSwitchForm const *)+1DBj
.text:000006FB                 jmp     loc_79C
.text:00000700 ; ---------------------------------------------------------------------------
.text:00000700
.text:00000700 loc_700:                                ; CODE XREF: NCommandLineParser::CParser::ParseString(UString const &,NCommandLineParser::CSwitchForm const *)+1D0j
.text:00000700                 cmp     [ebp+var_34], 1
.text:00000704                 jnz     short loc_75A
.text:00000706                 mov     ecx, [ebp+arg_0]
.text:00000709                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:0000070E                 mov     ecx, [ebp+var_14]
.text:00000711                 mov     dx, [eax+ecx*2]
.text:00000715                 mov     [ebp+var_38], dx
.text:00000719                 movzx   eax, [ebp+var_38]
.text:0000071D                 cmp     eax, 7Fh ; ''
.text:00000720                 jg      short loc_746
.text:00000722                 movzx   ecx, byte ptr [ebp+var_38]
.text:00000726                 push    ecx             ; char
.text:00000727                 mov     edx, [ebp+var_30]
.text:0000072A                 mov     eax, [edx+8]
.text:0000072D                 push    eax             ; char *
.text:0000072E                 call    ?FindCharPosInString@@YGHPBDD@Z ; FindCharPosInString(char const *,char)
.text:00000733                 mov     ecx, [ebp+var_2C]
.text:00000736                 mov     [ecx+4], eax
.text:00000739                 mov     edx, [ebp+var_2C]
.text:0000073C                 cmp     dword ptr [edx+4], 0
.text:00000740                 jl      short loc_746
.text:00000742                 mov     al, 1
.text:00000744                 jmp     short loc_7BF
.text:00000746 ; ---------------------------------------------------------------------------
.text:00000746
.text:00000746 loc_746:                                ; CODE XREF: NCommandLineParser::CParser::ParseString(UString const &,NCommandLineParser::CSwitchForm const *)+248j
.text:00000746                                         ; NCommandLineParser::CParser::ParseString(UString const &,NCommandLineParser::CSwitchForm const *)+268j
.text:00000746                 push    offset $SG67301 ; "Incorrect switch postfix:"
.text:0000074B                 mov     ecx, [ebp+var_10]
.text:0000074E                 add     ecx, 14h
.text:00000751                 call    ??4AString@@QAEAAV0@PBD@Z ; AString::operator=(char const *)
.text:00000756                 xor     al, al
.text:00000758                 jmp     short loc_7BF
.text:0000075A ; ---------------------------------------------------------------------------
.text:0000075A
.text:0000075A loc_75A:                                ; CODE XREF: NCommandLineParser::CParser::ParseString(UString const &,NCommandLineParser::CSwitchForm const *)+22Cj
.text:0000075A                 jmp     short loc_79C
.text:0000075C ; ---------------------------------------------------------------------------
.text:0000075C
.text:0000075C loc_75C:                                ; CODE XREF: NCommandLineParser::CParser::ParseString(UString const &,NCommandLineParser::CSwitchForm const *)+1C6j
.text:0000075C                 mov     ecx, [ebp+arg_0]
.text:0000075F                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00000764                 mov     ecx, [ebp+var_14]
.text:00000767                 lea     edx, [eax+ecx*2]
.text:0000076A                 push    edx
.text:0000076B                 lea     ecx, [ebp+var_44]
.text:0000076E                 call    ??0UString@@QAE@PB_W@Z ; UString::UString(wchar_t const *)
.text:00000773                 mov     [ebp+var_4], 0
.text:0000077A                 lea     eax, [ebp+var_44]
.text:0000077D                 push    eax
.text:0000077E                 mov     ecx, [ebp+var_2C]
.text:00000781                 add     ecx, 8
.text:00000784                 call    ?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z ; CObjectVector<UString>::Add(UString const &)
.text:00000789                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000790                 lea     ecx, [ebp+var_44] ; this
.text:00000793                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000798                 mov     al, 1
.text:0000079A                 jmp     short loc_7BF
.text:0000079C ; ---------------------------------------------------------------------------
.text:0000079C
.text:0000079C loc_79C:                                ; CODE XREF: NCommandLineParser::CParser::ParseString(UString const &,NCommandLineParser::CSwitchForm const *)+1D2j
.text:0000079C                                         ; NCommandLineParser::CParser::ParseString(UString const &,NCommandLineParser::CSwitchForm const *):loc_6FBj ...
.text:0000079C                 mov     ecx, [ebp+arg_0] ; this
.text:0000079F                 call    ?Len@UString@@QBEIXZ ; UString::Len(void)
.text:000007A4                 cmp     [ebp+var_14], eax
.text:000007A7                 jz      short loc_7BD
.text:000007A9                 push    offset $SG67306 ; "Too long switch:"
.text:000007AE                 mov     ecx, [ebp+var_10]
.text:000007B1                 add     ecx, 14h
.text:000007B4                 call    ??4AString@@QAEAAV0@PBD@Z ; AString::operator=(char const *)
.text:000007B9                 xor     al, al
.text:000007BB                 jmp     short loc_7BF
.text:000007BD ; ---------------------------------------------------------------------------
.text:000007BD
.text:000007BD loc_7BD:                                ; CODE XREF: NCommandLineParser::CParser::ParseString(UString const &,NCommandLineParser::CSwitchForm const *)+2CFj
.text:000007BD                 mov     al, 1
.text:000007BF
.text:000007BF loc_7BF:                                ; CODE XREF: NCommandLineParser::CParser::ParseString(UString const &,NCommandLineParser::CSwitchForm const *)+64j
.text:000007BF                                         ; NCommandLineParser::CParser::ParseString(UString const &,NCommandLineParser::CSwitchForm const *)+116j ...
.text:000007BF                 mov     ecx, [ebp+var_C]
.text:000007C2                 mov     large fs:0, ecx
.text:000007C9                 pop     ecx
.text:000007CA                 pop     edi
.text:000007CB                 pop     esi
.text:000007CC                 add     esp, 48h
.text:000007CF                 cmp     ebp, esp
.text:000007D1                 call    __RTC_CheckEsp
.text:000007D6                 mov     esp, ebp
.text:000007D8                 pop     ebp
.text:000007D9                 retn    8
.text:000007D9 ?ParseString@CParser@NCommandLineParser@@AAE_NABVUString@@PBUCSwitchForm@2@@Z endp
.text:000007D9
.text:000007D9 ; ---------------------------------------------------------------------------
.text:000007DC                 db 0Ch dup(0CCh)
.text:000007E8
.text:000007E8 ; =============== S U B R O U T I N E =======================================
.text:000007E8
.text:000007E8 ; Attributes: bp-based frame
.text:000007E8
.text:000007E8 ; bool __stdcall IsString1PrefixedByString2_NoCase(wchar_t const *, char const *)
.text:000007E8 ?IsString1PrefixedByString2_NoCase@@YG_NPB_WPBD@Z proc near
.text:000007E8                                         ; CODE XREF: NCommandLineParser::CParser::ParseString(UString const &,NCommandLineParser::CSwitchForm const *)+E4p
.text:000007E8
.text:000007E8 var_4           = dword ptr -4
.text:000007E8 arg_0           = dword ptr  8
.text:000007E8 arg_4           = dword ptr  0Ch
.text:000007E8
.text:000007E8                 push    ebp
.text:000007E9                 mov     ebp, esp
.text:000007EB                 push    ecx
.text:000007EC                 push    esi
.text:000007ED                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000007F4
.text:000007F4 loc_7F4:                                ; CODE XREF: IsString1PrefixedByString2_NoCase(wchar_t const *,char const *)+56j
.text:000007F4                 mov     eax, [ebp+arg_4]
.text:000007F7                 mov     cl, [eax]
.text:000007F9                 mov     byte ptr [ebp+var_4+3], cl
.text:000007FC                 movsx   edx, byte ptr [ebp+var_4+3]
.text:00000800                 test    edx, edx
.text:00000802                 jnz     short loc_808
.text:00000804                 mov     al, 1
.text:00000806                 jmp     short loc_840
.text:00000808 ; ---------------------------------------------------------------------------
.text:00000808
.text:00000808 loc_808:                                ; CODE XREF: IsString1PrefixedByString2_NoCase(wchar_t const *,char const *)+1Aj
.text:00000808                 movzx   eax, byte ptr [ebp+var_4+3]
.text:0000080C                 push    eax             ; char
.text:0000080D                 call    ?MyCharLower_Ascii@@YGDD@Z ; MyCharLower_Ascii(char)
.text:00000812                 movzx   esi, al
.text:00000815                 mov     ecx, [ebp+arg_0]
.text:00000818                 movzx   edx, word ptr [ecx]
.text:0000081B                 push    edx             ; wchar_t
.text:0000081C                 call    ?MyCharLower_Ascii@@YG_W_W@Z ; MyCharLower_Ascii(wchar_t)
.text:00000821                 movzx   eax, ax
.text:00000824                 cmp     esi, eax
.text:00000826                 jz      short loc_82C
.text:00000828                 xor     al, al
.text:0000082A                 jmp     short loc_840
.text:0000082C ; ---------------------------------------------------------------------------
.text:0000082C
.text:0000082C loc_82C:                                ; CODE XREF: IsString1PrefixedByString2_NoCase(wchar_t const *,char const *)+3Ej
.text:0000082C                 mov     ecx, [ebp+arg_4]
.text:0000082F                 add     ecx, 1
.text:00000832                 mov     [ebp+arg_4], ecx
.text:00000835                 mov     edx, [ebp+arg_0]
.text:00000838                 add     edx, 2
.text:0000083B                 mov     [ebp+arg_0], edx
.text:0000083E                 jmp     short loc_7F4
.text:00000840 ; ---------------------------------------------------------------------------
.text:00000840
.text:00000840 loc_840:                                ; CODE XREF: IsString1PrefixedByString2_NoCase(wchar_t const *,char const *)+1Ej
.text:00000840                                         ; IsString1PrefixedByString2_NoCase(wchar_t const *,char const *)+42j
.text:00000840                 pop     esi
.text:00000841                 add     esp, 4
.text:00000844                 cmp     ebp, esp
.text:00000846                 call    __RTC_CheckEsp
.text:0000084B                 mov     esp, ebp
.text:0000084D                 pop     ebp
.text:0000084E                 retn    8
.text:0000084E ?IsString1PrefixedByString2_NoCase@@YG_NPB_WPBD@Z endp
.text:0000084E
.text:0000084E ; ---------------------------------------------------------------------------
.text:00000851                 align 8
.text:00000858
.text:00000858 ; =============== S U B R O U T I N E =======================================
.text:00000858
.text:00000858 ; Attributes: bp-based frame
.text:00000858
.text:00000858 ; bool __stdcall NCommandLineParser::IsItSwitchChar(wchar_t)
.text:00000858 ?IsItSwitchChar@NCommandLineParser@@YG_N_W@Z proc near
.text:00000858                                         ; CODE XREF: NCommandLineParser::CParser::ParseString(UString const &,NCommandLineParser::CSwitchForm const *)+56p
.text:00000858                                         ; NCommandLineParser::CParser::ParseStrings(NCommandLineParser::CSwitchForm const *,CObjectVector<UString> const &)+99p
.text:00000858
.text:00000858 arg_0           = word ptr  8
.text:00000858
.text:00000858                 push    ebp
.text:00000859                 mov     ebp, esp
.text:0000085B                 movzx   eax, [ebp+arg_0]
.text:0000085F                 xor     ecx, ecx
.text:00000861                 cmp     eax, 2Dh ; '-'
.text:00000864                 setz    cl
.text:00000867                 mov     al, cl
.text:00000869                 pop     ebp
.text:0000086A                 retn    4
.text:0000086A ?IsItSwitchChar@NCommandLineParser@@YG_N_W@Z endp
.text:0000086A
.text:0000086A ; ---------------------------------------------------------------------------
.text:0000086D                 db 0Bh dup(0CCh)
.text:00000878
.text:00000878 ; =============== S U B R O U T I N E =======================================
.text:00000878
.text:00000878 ; Attributes: bp-based frame
.text:00000878
.text:00000878 ; int __stdcall NCommandLineParser::CParser::ParseStrings(struct NCommandLineParser::CSwitchForm *, int)
.text:00000878                 public ?ParseStrings@CParser@NCommandLineParser@@QAE_NPBUCSwitchForm@2@ABV?$CObjectVector@VUString@@@@@Z
.text:00000878 ?ParseStrings@CParser@NCommandLineParser@@QAE_NPBUCSwitchForm@2@ABV?$CObjectVector@VUString@@@@@Z proc near
.text:00000878
.text:00000878 var_10          = dword ptr -10h
.text:00000878 var_C           = dword ptr -0Ch
.text:00000878 var_8           = dword ptr -8
.text:00000878 var_4           = dword ptr -4
.text:00000878 arg_0           = dword ptr  8
.text:00000878 arg_4           = dword ptr  0Ch
.text:00000878
.text:00000878                 push    ebp
.text:00000879                 mov     ebp, esp
.text:0000087B                 sub     esp, 10h
.text:0000087E                 mov     eax, 0CCCCCCCCh
.text:00000883                 mov     [ebp+var_10], eax
.text:00000886                 mov     [ebp+var_C], eax
.text:00000889                 mov     [ebp+var_8], eax
.text:0000088C                 mov     [ebp+var_4], eax
.text:0000088F                 mov     [ebp+var_4], ecx
.text:00000892                 mov     ecx, [ebp+var_4]
.text:00000895                 add     ecx, 20h ; ' '  ; this
.text:00000898                 call    ?Empty@UString@@QAEXXZ ; UString::Empty(void)
.text:0000089D                 mov     byte ptr [ebp+var_8+3], 0
.text:000008A1                 mov     [ebp+var_C], 0
.text:000008A8                 jmp     short loc_8B3
.text:000008AA ; ---------------------------------------------------------------------------
.text:000008AA
.text:000008AA loc_8AA:                                ; CODE XREF: NCommandLineParser::CParser::ParseStrings(NCommandLineParser::CSwitchForm const *,CObjectVector<UString> const &)+7Cj
.text:000008AA                                         ; NCommandLineParser::CParser::ParseStrings(NCommandLineParser::CSwitchForm const *,CObjectVector<UString> const &)+BCj ...
.text:000008AA                 mov     eax, [ebp+var_C]
.text:000008AD                 add     eax, 1
.text:000008B0                 mov     [ebp+var_C], eax
.text:000008B3
.text:000008B3 loc_8B3:                                ; CODE XREF: NCommandLineParser::CParser::ParseStrings(NCommandLineParser::CSwitchForm const *,CObjectVector<UString> const &)+30j
.text:000008B3                 mov     ecx, [ebp+arg_4]
.text:000008B6                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:000008BB                 cmp     [ebp+var_C], eax
.text:000008BE                 jnb     loc_960
.text:000008C4                 mov     ecx, [ebp+var_C]
.text:000008C7                 push    ecx
.text:000008C8                 mov     ecx, [ebp+arg_4]
.text:000008CB                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:000008D0                 mov     [ebp+var_10], eax
.text:000008D3                 movzx   edx, byte ptr [ebp+var_8+3]
.text:000008D7                 test    edx, edx
.text:000008D9                 jnz     short loc_94C
.text:000008DB                 mov     eax, ds:_kStopSwitchParsing
.text:000008E0                 push    eax             ; char *
.text:000008E1                 mov     ecx, [ebp+var_10] ; this
.text:000008E4                 call    ?IsEqualTo@UString@@QBE_NPBD@Z ; UString::IsEqualTo(char const *)
.text:000008E9                 movzx   ecx, al
.text:000008EC                 test    ecx, ecx
.text:000008EE                 jz      short loc_8F6
.text:000008F0                 mov     byte ptr [ebp+var_8+3], 1
.text:000008F4                 jmp     short loc_8AA
.text:000008F6 ; ---------------------------------------------------------------------------
.text:000008F6
.text:000008F6 loc_8F6:                                ; CODE XREF: NCommandLineParser::CParser::ParseStrings(NCommandLineParser::CSwitchForm const *,CObjectVector<UString> const &)+76j
.text:000008F6                 mov     ecx, [ebp+var_10] ; this
.text:000008F9                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:000008FE                 movzx   edx, al
.text:00000901                 test    edx, edx
.text:00000903                 jnz     short loc_94C
.text:00000905                 mov     ecx, [ebp+var_10]
.text:00000908                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:0000090D                 movzx   eax, word ptr [eax]
.text:00000910                 push    eax
.text:00000911                 call    ?IsItSwitchChar@NCommandLineParser@@YG_N_W@Z ; NCommandLineParser::IsItSwitchChar(wchar_t)
.text:00000916                 movzx   ecx, al
.text:00000919                 test    ecx, ecx
.text:0000091B                 jz      short loc_94C
.text:0000091D                 mov     edx, [ebp+arg_0]
.text:00000920                 push    edx             ; struct NCommandLineParser::CSwitchForm *
.text:00000921                 mov     eax, [ebp+var_10]
.text:00000924                 push    eax             ; struct UString *
.text:00000925                 mov     ecx, [ebp+var_4] ; this
.text:00000928                 call    ?ParseString@CParser@NCommandLineParser@@AAE_NABVUString@@PBUCSwitchForm@2@@Z ; NCommandLineParser::CParser::ParseString(UString const &,NCommandLineParser::CSwitchForm const *)
.text:0000092D                 movzx   ecx, al
.text:00000930                 test    ecx, ecx
.text:00000932                 jz      short loc_939
.text:00000934                 jmp     loc_8AA
.text:00000939 ; ---------------------------------------------------------------------------
.text:00000939
.text:00000939 loc_939:                                ; CODE XREF: NCommandLineParser::CParser::ParseStrings(NCommandLineParser::CSwitchForm const *,CObjectVector<UString> const &)+BAj
.text:00000939                 mov     edx, [ebp+var_10]
.text:0000093C                 push    edx
.text:0000093D                 mov     ecx, [ebp+var_4]
.text:00000940                 add     ecx, 20h ; ' '
.text:00000943                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:00000948                 xor     al, al
.text:0000094A                 jmp     short loc_962
.text:0000094C ; ---------------------------------------------------------------------------
.text:0000094C
.text:0000094C loc_94C:                                ; CODE XREF: NCommandLineParser::CParser::ParseStrings(NCommandLineParser::CSwitchForm const *,CObjectVector<UString> const &)+61j
.text:0000094C                                         ; NCommandLineParser::CParser::ParseStrings(NCommandLineParser::CSwitchForm const *,CObjectVector<UString> const &)+8Bj ...
.text:0000094C                 mov     eax, [ebp+var_10]
.text:0000094F                 push    eax
.text:00000950                 mov     ecx, [ebp+var_4]
.text:00000953                 add     ecx, 8
.text:00000956                 call    ?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z ; CObjectVector<UString>::Add(UString const &)
.text:0000095B                 jmp     loc_8AA
.text:00000960 ; ---------------------------------------------------------------------------
.text:00000960
.text:00000960 loc_960:                                ; CODE XREF: NCommandLineParser::CParser::ParseStrings(NCommandLineParser::CSwitchForm const *,CObjectVector<UString> const &)+46j
.text:00000960                 mov     al, 1
.text:00000962
.text:00000962 loc_962:                                ; CODE XREF: NCommandLineParser::CParser::ParseStrings(NCommandLineParser::CSwitchForm const *,CObjectVector<UString> const &)+D2j
.text:00000962                 add     esp, 10h
.text:00000965                 cmp     ebp, esp
.text:00000967                 call    __RTC_CheckEsp
.text:0000096C                 mov     esp, ebp
.text:0000096E                 pop     ebp
.text:0000096F                 retn    8
.text:0000096F ?ParseStrings@CParser@NCommandLineParser@@QAE_NPBUCSwitchForm@2@ABV?$CObjectVector@VUString@@@@@Z endp
.text:0000096F
.text:0000096F ; ---------------------------------------------------------------------------
.text:00000972                 align 4
.text:00000972 _text           ends
.text:00000972
.rtc$TMZ:00000974 ; ===========================================================================
.rtc$TMZ:00000974
.rtc$TMZ:00000974 ; Segment type: Pure data
.rtc$TMZ:00000974 ; Segment permissions: Read
.rtc$TMZ:00000974 _rtc$TMZ        segment dword public 'DATA' use32
.rtc$TMZ:00000974                 assume cs:_rtc$TMZ
.rtc$TMZ:00000974                 ;org 974h
.rtc$TMZ:00000974 ; COMDAT (pick any)
.rtc$TMZ:00000974 __RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
.rtc$TMZ:00000974 _rtc$TMZ        ends
.rtc$TMZ:00000974
.rtc$IMZ:00000978 ; ===========================================================================
.rtc$IMZ:00000978
.rtc$IMZ:00000978 ; Segment type: Pure data
.rtc$IMZ:00000978 ; Segment permissions: Read
.rtc$IMZ:00000978 _rtc$IMZ        segment dword public 'DATA' use32
.rtc$IMZ:00000978                 assume cs:_rtc$IMZ
.rtc$IMZ:00000978                 ;org 978h
.rtc$IMZ:00000978 ; COMDAT (pick any)
.rtc$IMZ:00000978 __RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
.rtc$IMZ:00000978 _rtc$IMZ        ends
.rtc$IMZ:00000978
.text:0000097C ; ===========================================================================
.text:0000097C
.text:0000097C ; Segment type: Pure code
.text:0000097C ; Segment permissions: Read/Execute
.text:0000097C _text           segment para public 'CODE' use32
.text:0000097C                 assume cs:_text
.text:0000097C                 ;org 97Ch
.text:0000097C ; COMDAT (pick any)
.text:0000097C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000097C
.text:0000097C ; =============== S U B R O U T I N E =======================================
.text:0000097C
.text:0000097C ; Attributes: bp-based frame
.text:0000097C
.text:0000097C ; unsigned int __thiscall UString::Len(UString *__hidden this)
.text:0000097C                 public ?Len@UString@@QBEIXZ
.text:0000097C ?Len@UString@@QBEIXZ proc near          ; CODE XREF: NCommandLineParser::SplitCommandLine(UString const &,UString &,UString &)+44p
.text:0000097C                                         ; NCommandLineParser::CParser::ParseString(UString const &,NCommandLineParser::CSwitchForm const *)+C6p ...
.text:0000097C
.text:0000097C var_4           = dword ptr -4
.text:0000097C
.text:0000097C                 push    ebp
.text:0000097D                 mov     ebp, esp
.text:0000097F                 push    ecx
.text:00000980                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000987                 mov     [ebp+var_4], ecx
.text:0000098A                 mov     eax, [ebp+var_4]
.text:0000098D                 mov     eax, [eax+4]
.text:00000990                 mov     esp, ebp
.text:00000992                 pop     ebp
.text:00000993                 retn
.text:00000993 ?Len@UString@@QBEIXZ endp
.text:00000993
.text:00000993 _text           ends
.text:00000993
.text:00000994 ; ===========================================================================
.text:00000994
.text:00000994 ; Segment type: Pure code
.text:00000994 ; Segment permissions: Read/Execute
.text:00000994 _text           segment para public 'CODE' use32
.text:00000994                 assume cs:_text
.text:00000994                 ;org 994h
.text:00000994 ; COMDAT (pick any)
.text:00000994                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000994
.text:00000994 ; =============== S U B R O U T I N E =======================================
.text:00000994
.text:00000994 ; Attributes: bp-based frame
.text:00000994
.text:00000994 ; void __thiscall UString::Empty(UString *__hidden this)
.text:00000994                 public ?Empty@UString@@QAEXXZ
.text:00000994 ?Empty@UString@@QAEXXZ proc near        ; CODE XREF: NCommandLineParser::SplitCommandLine(UString const &,UString &,UString &)+1Ep
.text:00000994                                         ; NCommandLineParser::SplitCommandLine(UString const &,UString &,UString &)+26p ...
.text:00000994
.text:00000994 var_4           = dword ptr -4
.text:00000994
.text:00000994                 push    ebp
.text:00000995                 mov     ebp, esp
.text:00000997                 push    ecx
.text:00000998                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000099F                 mov     [ebp+var_4], ecx
.text:000009A2                 mov     eax, [ebp+var_4]
.text:000009A5                 mov     dword ptr [eax+4], 0
.text:000009AC                 mov     ecx, [ebp+var_4]
.text:000009AF                 mov     edx, [ecx]
.text:000009B1                 xor     eax, eax
.text:000009B3                 mov     [edx], ax
.text:000009B6                 mov     esp, ebp
.text:000009B8                 pop     ebp
.text:000009B9                 retn
.text:000009B9 ?Empty@UString@@QAEXXZ endp
.text:000009B9
.text:000009B9 ; ---------------------------------------------------------------------------
.text:000009BA                 align 4
.text:000009BA _text           ends
.text:000009BA
.text:000009BC ; ===========================================================================
.text:000009BC
.text:000009BC ; Segment type: Pure code
.text:000009BC ; Segment permissions: Read/Execute
.text:000009BC _text           segment para public 'CODE' use32
.text:000009BC                 assume cs:_text
.text:000009BC                 ;org 9BCh
.text:000009BC ; COMDAT (pick any)
.text:000009BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000009BC
.text:000009BC ; =============== S U B R O U T I N E =======================================
.text:000009BC
.text:000009BC ; Attributes: bp-based frame
.text:000009BC
.text:000009BC ; public: __thiscall UString::operator wchar_t const *(void)const
.text:000009BC                 public ??BUString@@QBEPB_WXZ
.text:000009BC ??BUString@@QBEPB_WXZ proc near         ; CODE XREF: NCommandLineParser::SplitCommandLine(UString const &,UString &,UString &)+51p
.text:000009BC                                         ; NCommandLineParser::CParser::ParseString(UString const &,NCommandLineParser::CSwitchForm const *)+4Dp ...
.text:000009BC
.text:000009BC var_4           = dword ptr -4
.text:000009BC
.text:000009BC                 push    ebp
.text:000009BD                 mov     ebp, esp
.text:000009BF                 push    ecx
.text:000009C0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000009C7                 mov     [ebp+var_4], ecx
.text:000009CA                 mov     eax, [ebp+var_4]
.text:000009CD                 mov     eax, [eax]
.text:000009CF                 mov     esp, ebp
.text:000009D1                 pop     ebp
.text:000009D2                 retn
.text:000009D2 ??BUString@@QBEPB_WXZ endp
.text:000009D2
.text:000009D2 ; ---------------------------------------------------------------------------
.text:000009D3                 align 4
.text:000009D3 _text           ends
.text:000009D3
.text:000009D4 ; ===========================================================================
.text:000009D4
.text:000009D4 ; Segment type: Pure code
.text:000009D4 ; Segment permissions: Read/Execute
.text:000009D4 _text           segment para public 'CODE' use32
.text:000009D4                 assume cs:_text
.text:000009D4                 ;org 9D4h
.text:000009D4 ; COMDAT (pick any)
.text:000009D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000009D4
.text:000009D4 ; =============== S U B R O U T I N E =======================================
.text:000009D4
.text:000009D4 ; Attributes: bp-based frame
.text:000009D4
.text:000009D4 ; const wchar_t *__thiscall UString::Ptr(UString *this, unsigned int)
.text:000009D4                 public ?Ptr@UString@@QBEPB_WI@Z
.text:000009D4 ?Ptr@UString@@QBEPB_WI@Z proc near      ; CODE XREF: NCommandLineParser::SplitCommandLine(UString const &,UString &,UString &)+85p
.text:000009D4
.text:000009D4 var_4           = dword ptr -4
.text:000009D4 arg_0           = dword ptr  8
.text:000009D4
.text:000009D4                 push    ebp
.text:000009D5                 mov     ebp, esp
.text:000009D7                 push    ecx
.text:000009D8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000009DF                 mov     [ebp+var_4], ecx
.text:000009E2                 mov     eax, [ebp+var_4]
.text:000009E5                 mov     ecx, [eax]
.text:000009E7                 mov     edx, [ebp+arg_0]
.text:000009EA                 lea     eax, [ecx+edx*2]
.text:000009ED                 mov     esp, ebp
.text:000009EF                 pop     ebp
.text:000009F0                 retn    4
.text:000009F0 ?Ptr@UString@@QBEPB_WI@Z endp
.text:000009F0
.text:000009F0 ; ---------------------------------------------------------------------------
.text:000009F3                 align 4
.text:000009F3 _text           ends
.text:000009F3
.text:000009F4 ; ===========================================================================
.text:000009F4
.text:000009F4 ; Segment type: Pure code
.text:000009F4 ; Segment permissions: Read/Execute
.text:000009F4 _text           segment para public 'CODE' use32
.text:000009F4                 assume cs:_text
.text:000009F4                 ;org 9F4h
.text:000009F4 ; COMDAT (pick any)
.text:000009F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000009F4
.text:000009F4 ; =============== S U B R O U T I N E =======================================
.text:000009F4
.text:000009F4 ; Attributes: bp-based frame
.text:000009F4
.text:000009F4 ; public: class UString & __thiscall UString::operator+=(wchar_t)
.text:000009F4                 public ??YUString@@QAEAAV0@_W@Z
.text:000009F4 ??YUString@@QAEAAV0@_W@Z proc near      ; CODE XREF: NCommandLineParser::SplitCommandLine(UString const &,UString &,UString &)+BFp
.text:000009F4
.text:000009F4 var_C           = dword ptr -0Ch
.text:000009F4 var_8           = dword ptr -8
.text:000009F4 var_4           = dword ptr -4
.text:000009F4 arg_0           = word ptr  8
.text:000009F4
.text:000009F4                 push    ebp
.text:000009F5                 mov     ebp, esp
.text:000009F7                 sub     esp, 0Ch
.text:000009FA                 mov     [ebp+var_C], 0CCCCCCCCh
.text:00000A01                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00000A08                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000A0F                 mov     [ebp+var_4], ecx
.text:00000A12                 mov     eax, [ebp+var_4]
.text:00000A15                 mov     ecx, [ebp+var_4]
.text:00000A18                 mov     edx, [eax+8]
.text:00000A1B                 cmp     edx, [ecx+4]
.text:00000A1E                 jnz     short loc_A28
.text:00000A20                 mov     ecx, [ebp+var_4] ; this
.text:00000A23                 call    ?Grow_1@UString@@AAEXXZ ; UString::Grow_1(void)
.text:00000A28
.text:00000A28 loc_A28:                                ; CODE XREF: UString::operator+=(wchar_t)+2Aj
.text:00000A28                 mov     eax, [ebp+var_4]
.text:00000A2B                 mov     ecx, [eax+4]
.text:00000A2E                 mov     [ebp+var_8], ecx
.text:00000A31                 mov     edx, [ebp+var_4]
.text:00000A34                 mov     eax, [edx]
.text:00000A36                 mov     [ebp+var_C], eax
.text:00000A39                 mov     ecx, [ebp+var_8]
.text:00000A3C                 mov     edx, [ebp+var_C]
.text:00000A3F                 mov     ax, [ebp+arg_0]
.text:00000A43                 mov     [edx+ecx*2], ax
.text:00000A47                 mov     ecx, [ebp+var_8]
.text:00000A4A                 add     ecx, 1
.text:00000A4D                 mov     [ebp+var_8], ecx
.text:00000A50                 xor     edx, edx
.text:00000A52                 mov     eax, [ebp+var_8]
.text:00000A55                 mov     ecx, [ebp+var_C]
.text:00000A58                 mov     [ecx+eax*2], dx
.text:00000A5C                 mov     edx, [ebp+var_4]
.text:00000A5F                 mov     eax, [ebp+var_8]
.text:00000A62                 mov     [edx+4], eax
.text:00000A65                 mov     eax, [ebp+var_4]
.text:00000A68                 add     esp, 0Ch
.text:00000A6B                 cmp     ebp, esp
.text:00000A6D                 call    __RTC_CheckEsp
.text:00000A72                 mov     esp, ebp
.text:00000A74                 pop     ebp
.text:00000A75                 retn    4
.text:00000A75 ??YUString@@QAEAAV0@_W@Z endp
.text:00000A75
.text:00000A75 _text           ends
.text:00000A75
.text$x:00000A78 ; ===========================================================================
.text$x:00000A78
.text$x:00000A78 ; Segment type: Pure code
.text$x:00000A78 ; Segment permissions: Read/Execute
.text$x:00000A78 _text$x         segment para public 'CODE' use32
.text$x:00000A78                 assume cs:_text$x
.text$x:00000A78                 ;org 0A78h
.text$x:00000A78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000A78
.text$x:00000A78 ; =============== S U B R O U T I N E =======================================
.text$x:00000A78
.text$x:00000A78
.text$x:00000A78 __unwindfunclet$?SplitCommandLine@NCommandLineParser@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z$0 proc near
.text$x:00000A78                                         ; DATA XREF: .xdata$x:00000B58o
.text$x:00000A78                 lea     ecx, [ebp-1Ch]  ; this
.text$x:00000A7B                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00000A7B __unwindfunclet$?SplitCommandLine@NCommandLineParser@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z$0 endp
.text$x:00000A7B
.text$x:00000A80
.text$x:00000A80 ; =============== S U B R O U T I N E =======================================
.text$x:00000A80
.text$x:00000A80
.text$x:00000A80 __unwindfunclet$?SplitCommandLine@NCommandLineParser@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z$1 proc near
.text$x:00000A80                                         ; DATA XREF: .xdata$x:00000B60o
.text$x:00000A80                 lea     ecx, [ebp-30h]  ; this
.text$x:00000A83                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00000A83 __unwindfunclet$?SplitCommandLine@NCommandLineParser@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z$1 endp
.text$x:00000A83
.text$x:00000A88
.text$x:00000A88 ; =============== S U B R O U T I N E =======================================
.text$x:00000A88
.text$x:00000A88
.text$x:00000A88 __unwindfunclet$?SplitCommandLine@NCommandLineParser@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z$2 proc near
.text$x:00000A88                                         ; DATA XREF: .xdata$x:00000B68o
.text$x:00000A88                 lea     ecx, [ebp-44h]  ; this
.text$x:00000A8B                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00000A8B __unwindfunclet$?SplitCommandLine@NCommandLineParser@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z$2 endp
.text$x:00000A8B
.text$x:00000A90
.text$x:00000A90 ; =============== S U B R O U T I N E =======================================
.text$x:00000A90
.text$x:00000A90
.text$x:00000A90 __ehhandler$?SplitCommandLine@NCommandLineParser@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z proc near
.text$x:00000A90                                         ; DATA XREF: NCommandLineParser::SplitCommandLine(UString const &,CObjectVector<UString> &)+5o
.text$x:00000A90
.text$x:00000A90 arg_4           = dword ptr  8
.text$x:00000A90
.text$x:00000A90                 mov     edx, [esp+arg_4]
.text$x:00000A94                 lea     eax, [edx+0Ch]
.text$x:00000A97                 mov     ecx, [edx-44h]
.text$x:00000A9A                 xor     ecx, eax
.text$x:00000A9C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000AA1                 mov     eax, offset __ehfuncinfo$?SplitCommandLine@NCommandLineParser@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z
.text$x:00000AA6                 jmp     ___CxxFrameHandler3
.text$x:00000AA6 __ehhandler$?SplitCommandLine@NCommandLineParser@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z endp
.text$x:00000AA6
.text$x:00000AAB
.text$x:00000AAB ; =============== S U B R O U T I N E =======================================
.text$x:00000AAB
.text$x:00000AAB
.text$x:00000AAB __unwindfunclet$??0CParser@NCommandLineParser@@QAE@I@Z$0 proc near
.text$x:00000AAB                                         ; DATA XREF: .xdata$x:00000B94o
.text$x:00000AAB                 mov     ecx, [ebp-10h]
.text$x:00000AAE                 add     ecx, 8
.text$x:00000AB1                 jmp     ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text$x:00000AB1 __unwindfunclet$??0CParser@NCommandLineParser@@QAE@I@Z$0 endp
.text$x:00000AB1
.text$x:00000AB6
.text$x:00000AB6 ; =============== S U B R O U T I N E =======================================
.text$x:00000AB6
.text$x:00000AB6
.text$x:00000AB6 __unwindfunclet$??0CParser@NCommandLineParser@@QAE@I@Z$1 proc near
.text$x:00000AB6                                         ; DATA XREF: .xdata$x:00000B9Co
.text$x:00000AB6                 mov     ecx, [ebp-10h]
.text$x:00000AB9                 add     ecx, 14h        ; this
.text$x:00000ABC                 jmp     ??1AString@@QAE@XZ ; AString::~AString(void)
.text$x:00000ABC __unwindfunclet$??0CParser@NCommandLineParser@@QAE@I@Z$1 endp
.text$x:00000ABC
.text$x:00000AC1
.text$x:00000AC1 ; =============== S U B R O U T I N E =======================================
.text$x:00000AC1
.text$x:00000AC1
.text$x:00000AC1 __unwindfunclet$??0CParser@NCommandLineParser@@QAE@I@Z$2 proc near
.text$x:00000AC1                                         ; DATA XREF: .xdata$x:00000BA4o
.text$x:00000AC1                 mov     ecx, [ebp-10h]
.text$x:00000AC4                 add     ecx, 20h ; ' '  ; this
.text$x:00000AC7                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00000AC7 __unwindfunclet$??0CParser@NCommandLineParser@@QAE@I@Z$2 endp
.text$x:00000AC7
.text$x:00000ACC
.text$x:00000ACC ; =============== S U B R O U T I N E =======================================
.text$x:00000ACC
.text$x:00000ACC
.text$x:00000ACC __unwindfunclet$??0CParser@NCommandLineParser@@QAE@I@Z$3 proc near
.text$x:00000ACC                                         ; DATA XREF: .xdata$x:00000BACo
.text$x:00000ACC                 mov     eax, [ebp-1Ch]
.text$x:00000ACF                 push    eax             ; void *
.text$x:00000AD0                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00000AD5                 pop     ecx
.text$x:00000AD6                 retn
.text$x:00000AD6 __unwindfunclet$??0CParser@NCommandLineParser@@QAE@I@Z$3 endp
.text$x:00000AD6
.text$x:00000AD7
.text$x:00000AD7 ; =============== S U B R O U T I N E =======================================
.text$x:00000AD7
.text$x:00000AD7
.text$x:00000AD7 __ehhandler$??0CParser@NCommandLineParser@@QAE@I@Z proc near
.text$x:00000AD7                                         ; DATA XREF: NCommandLineParser::CParser::CParser(uint)+5o
.text$x:00000AD7
.text$x:00000AD7 arg_4           = dword ptr  8
.text$x:00000AD7
.text$x:00000AD7                 mov     edx, [esp+arg_4]
.text$x:00000ADB                 lea     eax, [edx+0Ch]
.text$x:00000ADE                 mov     ecx, [edx-18h]
.text$x:00000AE1                 xor     ecx, eax
.text$x:00000AE3                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000AE8                 mov     eax, offset __ehfuncinfo$??0CParser@NCommandLineParser@@QAE@I@Z
.text$x:00000AED                 jmp     ___CxxFrameHandler3
.text$x:00000AED __ehhandler$??0CParser@NCommandLineParser@@QAE@I@Z endp
.text$x:00000AED
.text$x:00000AF2
.text$x:00000AF2 ; =============== S U B R O U T I N E =======================================
.text$x:00000AF2
.text$x:00000AF2
.text$x:00000AF2 __unwindfunclet$??1CParser@NCommandLineParser@@QAE@XZ$0 proc near
.text$x:00000AF2                                         ; DATA XREF: .xdata$x:00000BD8o
.text$x:00000AF2                 mov     ecx, [ebp-10h]
.text$x:00000AF5                 add     ecx, 8
.text$x:00000AF8                 jmp     ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text$x:00000AF8 __unwindfunclet$??1CParser@NCommandLineParser@@QAE@XZ$0 endp
.text$x:00000AF8
.text$x:00000AFD
.text$x:00000AFD ; =============== S U B R O U T I N E =======================================
.text$x:00000AFD
.text$x:00000AFD
.text$x:00000AFD __unwindfunclet$??1CParser@NCommandLineParser@@QAE@XZ$1 proc near
.text$x:00000AFD                                         ; DATA XREF: .xdata$x:00000BE0o
.text$x:00000AFD                 mov     ecx, [ebp-10h]
.text$x:00000B00                 add     ecx, 14h        ; this
.text$x:00000B03                 jmp     ??1AString@@QAE@XZ ; AString::~AString(void)
.text$x:00000B03 __unwindfunclet$??1CParser@NCommandLineParser@@QAE@XZ$1 endp
.text$x:00000B03
.text$x:00000B08
.text$x:00000B08 ; =============== S U B R O U T I N E =======================================
.text$x:00000B08
.text$x:00000B08
.text$x:00000B08 __unwindfunclet$??1CParser@NCommandLineParser@@QAE@XZ$2 proc near
.text$x:00000B08                                         ; DATA XREF: .xdata$x:00000BE8o
.text$x:00000B08                 mov     ecx, [ebp-10h]
.text$x:00000B0B                 add     ecx, 20h ; ' '  ; this
.text$x:00000B0E                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00000B0E __unwindfunclet$??1CParser@NCommandLineParser@@QAE@XZ$2 endp
.text$x:00000B0E
.text$x:00000B13
.text$x:00000B13 ; =============== S U B R O U T I N E =======================================
.text$x:00000B13
.text$x:00000B13
.text$x:00000B13 __ehhandler$??1CParser@NCommandLineParser@@QAE@XZ proc near
.text$x:00000B13                                         ; DATA XREF: NCommandLineParser::CParser::~CParser(void)+5o
.text$x:00000B13
.text$x:00000B13 arg_4           = dword ptr  8
.text$x:00000B13
.text$x:00000B13                 mov     edx, [esp+arg_4]
.text$x:00000B17                 lea     eax, [edx+0Ch]
.text$x:00000B1A                 mov     ecx, [edx-14h]
.text$x:00000B1D                 xor     ecx, eax
.text$x:00000B1F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000B24                 mov     eax, offset __ehfuncinfo$??1CParser@NCommandLineParser@@QAE@XZ
.text$x:00000B29                 jmp     ___CxxFrameHandler3
.text$x:00000B29 __ehhandler$??1CParser@NCommandLineParser@@QAE@XZ endp
.text$x:00000B29
.text$x:00000B2E
.text$x:00000B2E ; =============== S U B R O U T I N E =======================================
.text$x:00000B2E
.text$x:00000B2E
.text$x:00000B2E __unwindfunclet$?ParseString@CParser@NCommandLineParser@@AAE_NABVUString@@PBUCSwitchForm@2@@Z$0 proc near
.text$x:00000B2E                                         ; DATA XREF: .xdata$x:00000C14o
.text$x:00000B2E                 lea     ecx, [ebp-44h]  ; this
.text$x:00000B31                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00000B31 __unwindfunclet$?ParseString@CParser@NCommandLineParser@@AAE_NABVUString@@PBUCSwitchForm@2@@Z$0 endp
.text$x:00000B31
.text$x:00000B36
.text$x:00000B36 ; =============== S U B R O U T I N E =======================================
.text$x:00000B36
.text$x:00000B36
.text$x:00000B36 __ehhandler$?ParseString@CParser@NCommandLineParser@@AAE_NABVUString@@PBUCSwitchForm@2@@Z proc near
.text$x:00000B36                                         ; DATA XREF: NCommandLineParser::CParser::ParseString(UString const &,NCommandLineParser::CSwitchForm const *)+5o
.text$x:00000B36
.text$x:00000B36 arg_4           = dword ptr  8
.text$x:00000B36
.text$x:00000B36                 mov     edx, [esp+arg_4]
.text$x:00000B3A                 lea     eax, [edx+0Ch]
.text$x:00000B3D                 mov     ecx, [edx-48h]
.text$x:00000B40                 xor     ecx, eax
.text$x:00000B42                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000B47                 mov     eax, offset __ehfuncinfo$?ParseString@CParser@NCommandLineParser@@AAE_NABVUString@@PBUCSwitchForm@2@@Z
.text$x:00000B4C                 jmp     ___CxxFrameHandler3
.text$x:00000B4C __ehhandler$?ParseString@CParser@NCommandLineParser@@AAE_NABVUString@@PBUCSwitchForm@2@@Z endp
.text$x:00000B4C
.text$x:00000B4C ; ---------------------------------------------------------------------------
.text$x:00000B51                 align 4
.text$x:00000B51 _text$x         ends
.text$x:00000B51
.xdata$x:00000B54 ; ===========================================================================
.xdata$x:00000B54
.xdata$x:00000B54 ; Segment type: Pure data
.xdata$x:00000B54 ; Segment permissions: Read
.xdata$x:00000B54 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00000B54                 assume cs:_xdata$x
.xdata$x:00000B54                 ;org 0B54h
.xdata$x:00000B54 __unwindtable$?SplitCommandLine@NCommandLineParser@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z db 0FFh
.xdata$x:00000B54                                         ; DATA XREF: .xdata$x:00000B74o
.xdata$x:00000B55                 db 0FFh
.xdata$x:00000B56                 db 0FFh
.xdata$x:00000B57                 db 0FFh
.xdata$x:00000B58                 dd offset __unwindfunclet$?SplitCommandLine@NCommandLineParser@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z$0
.xdata$x:00000B5C                 align 10h
.xdata$x:00000B60                 dd offset __unwindfunclet$?SplitCommandLine@NCommandLineParser@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z$1
.xdata$x:00000B64                 db    1
.xdata$x:00000B65                 db    0
.xdata$x:00000B66                 db    0
.xdata$x:00000B67                 db    0
.xdata$x:00000B68                 dd offset __unwindfunclet$?SplitCommandLine@NCommandLineParser@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z$2
.xdata$x:00000B6C __ehfuncinfo$?SplitCommandLine@NCommandLineParser@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z db  22h ; "
.xdata$x:00000B6C                                         ; DATA XREF: __ehhandler$?SplitCommandLine@NCommandLineParser@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z+11o
.xdata$x:00000B6D                 db    5
.xdata$x:00000B6E                 db  93h ; ô
.xdata$x:00000B6F                 db  19h
.xdata$x:00000B70                 db    3
.xdata$x:00000B71                 db    0
.xdata$x:00000B72                 db    0
.xdata$x:00000B73                 db    0
.xdata$x:00000B74                 dd offset __unwindtable$?SplitCommandLine@NCommandLineParser@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z
.xdata$x:00000B78                 db    0
.xdata$x:00000B79                 db    0
.xdata$x:00000B7A                 db    0
.xdata$x:00000B7B                 db    0
.xdata$x:00000B7C                 db    0
.xdata$x:00000B7D                 db    0
.xdata$x:00000B7E                 db    0
.xdata$x:00000B7F                 db    0
.xdata$x:00000B80                 db    0
.xdata$x:00000B81                 db    0
.xdata$x:00000B82                 db    0
.xdata$x:00000B83                 db    0
.xdata$x:00000B84                 db    0
.xdata$x:00000B85                 db    0
.xdata$x:00000B86                 db    0
.xdata$x:00000B87                 db    0
.xdata$x:00000B88                 db    0
.xdata$x:00000B89                 db    0
.xdata$x:00000B8A                 db    0
.xdata$x:00000B8B                 db    0
.xdata$x:00000B8C                 db    1
.xdata$x:00000B8D                 db    0
.xdata$x:00000B8E                 db    0
.xdata$x:00000B8F                 db    0
.xdata$x:00000B90 __unwindtable$??0CParser@NCommandLineParser@@QAE@I@Z db 0FFh
.xdata$x:00000B90                                         ; DATA XREF: .xdata$x:00000BB8o
.xdata$x:00000B91                 db 0FFh
.xdata$x:00000B92                 db 0FFh
.xdata$x:00000B93                 db 0FFh
.xdata$x:00000B94                 dd offset __unwindfunclet$??0CParser@NCommandLineParser@@QAE@I@Z$0
.xdata$x:00000B98                 db    0
.xdata$x:00000B99                 db    0
.xdata$x:00000B9A                 db    0
.xdata$x:00000B9B                 db    0
.xdata$x:00000B9C                 dd offset __unwindfunclet$??0CParser@NCommandLineParser@@QAE@I@Z$1
.xdata$x:00000BA0                 db    1
.xdata$x:00000BA1                 db    0
.xdata$x:00000BA2                 db    0
.xdata$x:00000BA3                 db    0
.xdata$x:00000BA4                 dd offset __unwindfunclet$??0CParser@NCommandLineParser@@QAE@I@Z$2
.xdata$x:00000BA8                 db    2
.xdata$x:00000BA9                 db    0
.xdata$x:00000BAA                 db    0
.xdata$x:00000BAB                 db    0
.xdata$x:00000BAC                 dd offset __unwindfunclet$??0CParser@NCommandLineParser@@QAE@I@Z$3
.xdata$x:00000BB0 __ehfuncinfo$??0CParser@NCommandLineParser@@QAE@I@Z db  22h ; "
.xdata$x:00000BB0                                         ; DATA XREF: __ehhandler$??0CParser@NCommandLineParser@@QAE@I@Z+11o
.xdata$x:00000BB1                 db    5
.xdata$x:00000BB2                 db  93h ; ô
.xdata$x:00000BB3                 db  19h
.xdata$x:00000BB4                 db    4
.xdata$x:00000BB5                 db    0
.xdata$x:00000BB6                 db    0
.xdata$x:00000BB7                 db    0
.xdata$x:00000BB8                 dd offset __unwindtable$??0CParser@NCommandLineParser@@QAE@I@Z
.xdata$x:00000BBC                 db    0
.xdata$x:00000BBD                 db    0
.xdata$x:00000BBE                 db    0
.xdata$x:00000BBF                 db    0
.xdata$x:00000BC0                 db    0
.xdata$x:00000BC1                 db    0
.xdata$x:00000BC2                 db    0
.xdata$x:00000BC3                 db    0
.xdata$x:00000BC4                 db    0
.xdata$x:00000BC5                 db    0
.xdata$x:00000BC6                 db    0
.xdata$x:00000BC7                 db    0
.xdata$x:00000BC8                 db    0
.xdata$x:00000BC9                 db    0
.xdata$x:00000BCA                 db    0
.xdata$x:00000BCB                 db    0
.xdata$x:00000BCC                 db    0
.xdata$x:00000BCD                 db    0
.xdata$x:00000BCE                 db    0
.xdata$x:00000BCF                 db    0
.xdata$x:00000BD0                 db    1
.xdata$x:00000BD1                 db    0
.xdata$x:00000BD2                 db    0
.xdata$x:00000BD3                 db    0
.xdata$x:00000BD4 __unwindtable$??1CParser@NCommandLineParser@@QAE@XZ db 0FFh
.xdata$x:00000BD4                                         ; DATA XREF: .xdata$x:00000BF4o
.xdata$x:00000BD5                 db 0FFh
.xdata$x:00000BD6                 db 0FFh
.xdata$x:00000BD7                 db 0FFh
.xdata$x:00000BD8                 dd offset __unwindfunclet$??1CParser@NCommandLineParser@@QAE@XZ$0
.xdata$x:00000BDC                 align 10h
.xdata$x:00000BE0                 dd offset __unwindfunclet$??1CParser@NCommandLineParser@@QAE@XZ$1
.xdata$x:00000BE4                 db    1
.xdata$x:00000BE5                 db    0
.xdata$x:00000BE6                 db    0
.xdata$x:00000BE7                 db    0
.xdata$x:00000BE8                 dd offset __unwindfunclet$??1CParser@NCommandLineParser@@QAE@XZ$2
.xdata$x:00000BEC __ehfuncinfo$??1CParser@NCommandLineParser@@QAE@XZ db  22h ; "
.xdata$x:00000BEC                                         ; DATA XREF: __ehhandler$??1CParser@NCommandLineParser@@QAE@XZ+11o
.xdata$x:00000BED                 db    5
.xdata$x:00000BEE                 db  93h ; ô
.xdata$x:00000BEF                 db  19h
.xdata$x:00000BF0                 db    3
.xdata$x:00000BF1                 db    0
.xdata$x:00000BF2                 db    0
.xdata$x:00000BF3                 db    0
.xdata$x:00000BF4                 dd offset __unwindtable$??1CParser@NCommandLineParser@@QAE@XZ
.xdata$x:00000BF8                 db    0
.xdata$x:00000BF9                 db    0
.xdata$x:00000BFA                 db    0
.xdata$x:00000BFB                 db    0
.xdata$x:00000BFC                 db    0
.xdata$x:00000BFD                 db    0
.xdata$x:00000BFE                 db    0
.xdata$x:00000BFF                 db    0
.xdata$x:00000C00                 db    0
.xdata$x:00000C01                 db    0
.xdata$x:00000C02                 db    0
.xdata$x:00000C03                 db    0
.xdata$x:00000C04                 db    0
.xdata$x:00000C05                 db    0
.xdata$x:00000C06                 db    0
.xdata$x:00000C07                 db    0
.xdata$x:00000C08                 db    0
.xdata$x:00000C09                 db    0
.xdata$x:00000C0A                 db    0
.xdata$x:00000C0B                 db    0
.xdata$x:00000C0C                 db    1
.xdata$x:00000C0D                 db    0
.xdata$x:00000C0E                 db    0
.xdata$x:00000C0F                 db    0
.xdata$x:00000C10 __unwindtable$?ParseString@CParser@NCommandLineParser@@AAE_NABVUString@@PBUCSwitchForm@2@@Z db 0FFh
.xdata$x:00000C10                                         ; DATA XREF: .xdata$x:00000C20o
.xdata$x:00000C11                 db 0FFh
.xdata$x:00000C12                 db 0FFh
.xdata$x:00000C13                 db 0FFh
.xdata$x:00000C14                 dd offset __unwindfunclet$?ParseString@CParser@NCommandLineParser@@AAE_NABVUString@@PBUCSwitchForm@2@@Z$0
.xdata$x:00000C18 __ehfuncinfo$?ParseString@CParser@NCommandLineParser@@AAE_NABVUString@@PBUCSwitchForm@2@@Z db  22h ; "
.xdata$x:00000C18                                         ; DATA XREF: __ehhandler$?ParseString@CParser@NCommandLineParser@@AAE_NABVUString@@PBUCSwitchForm@2@@Z+11o
.xdata$x:00000C19                 db    5
.xdata$x:00000C1A                 db  93h ; ô
.xdata$x:00000C1B                 db  19h
.xdata$x:00000C1C                 db    1
.xdata$x:00000C1D                 db    0
.xdata$x:00000C1E                 db    0
.xdata$x:00000C1F                 db    0
.xdata$x:00000C20                 dd offset __unwindtable$?ParseString@CParser@NCommandLineParser@@AAE_NABVUString@@PBUCSwitchForm@2@@Z
.xdata$x:00000C24                 db    0
.xdata$x:00000C25                 db    0
.xdata$x:00000C26                 db    0
.xdata$x:00000C27                 db    0
.xdata$x:00000C28                 db    0
.xdata$x:00000C29                 db    0
.xdata$x:00000C2A                 db    0
.xdata$x:00000C2B                 db    0
.xdata$x:00000C2C                 db    0
.xdata$x:00000C2D                 db    0
.xdata$x:00000C2E                 db    0
.xdata$x:00000C2F                 db    0
.xdata$x:00000C30                 db    0
.xdata$x:00000C31                 db    0
.xdata$x:00000C32                 db    0
.xdata$x:00000C33                 db    0
.xdata$x:00000C34                 db    0
.xdata$x:00000C35                 db    0
.xdata$x:00000C36                 db    0
.xdata$x:00000C37                 db    0
.xdata$x:00000C38                 db    1
.xdata$x:00000C39                 db    0
.xdata$x:00000C3A                 db    0
.xdata$x:00000C3B                 db    0
.xdata$x:00000C3B _xdata$x        ends
.xdata$x:00000C3B
.text:00000C3C ; ===========================================================================
.text:00000C3C
.text:00000C3C ; Segment type: Pure code
.text:00000C3C ; Segment permissions: Read/Execute
.text:00000C3C _text           segment para public 'CODE' use32
.text:00000C3C                 assume cs:_text
.text:00000C3C                 ;org 0C3Ch
.text:00000C3C ; COMDAT (pick any)
.text:00000C3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000C3C
.text:00000C3C ; =============== S U B R O U T I N E =======================================
.text:00000C3C
.text:00000C3C ; Attributes: bp-based frame
.text:00000C3C
.text:00000C3C ; _DWORD __thiscall UString::~UString(UString *__hidden this)
.text:00000C3C                 public ??1UString@@QAE@XZ
.text:00000C3C ??1UString@@QAE@XZ proc near            ; CODE XREF: NCommandLineParser::SplitCommandLine(UString const &,CObjectVector<UString> &)+AAp
.text:00000C3C                                         ; NCommandLineParser::SplitCommandLine(UString const &,CObjectVector<UString> &)+B6p ...
.text:00000C3C
.text:00000C3C var_8           = dword ptr -8
.text:00000C3C var_4           = dword ptr -4
.text:00000C3C
.text:00000C3C                 push    ebp
.text:00000C3D                 mov     ebp, esp
.text:00000C3F                 sub     esp, 8
.text:00000C42                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00000C49                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000C50                 mov     [ebp+var_4], ecx
.text:00000C53                 mov     eax, [ebp+var_4]
.text:00000C56                 mov     ecx, [eax]
.text:00000C58                 mov     [ebp+var_8], ecx
.text:00000C5B                 mov     edx, [ebp+var_8]
.text:00000C5E                 push    edx             ; void *
.text:00000C5F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00000C64                 add     esp, 4
.text:00000C67                 add     esp, 8
.text:00000C6A                 cmp     ebp, esp
.text:00000C6C                 call    __RTC_CheckEsp
.text:00000C71                 mov     esp, ebp
.text:00000C73                 pop     ebp
.text:00000C74                 retn
.text:00000C74 ??1UString@@QAE@XZ endp
.text:00000C74
.text:00000C74 ; ---------------------------------------------------------------------------
.text:00000C75                 align 4
.text:00000C75 _text           ends
.text:00000C75
.text:00000C78 ; ===========================================================================
.text:00000C78
.text:00000C78 ; Segment type: Pure code
.text:00000C78 ; Segment permissions: Read/Execute
.text:00000C78 _text           segment para public 'CODE' use32
.text:00000C78                 assume cs:_text
.text:00000C78                 ;org 0C78h
.text:00000C78 ; COMDAT (pick any)
.text:00000C78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000C78
.text:00000C78 ; =============== S U B R O U T I N E =======================================
.text:00000C78
.text:00000C78 ; Attributes: bp-based frame
.text:00000C78
.text:00000C78 ; bool __thiscall UString::IsEmpty(UString *__hidden this)
.text:00000C78                 public ?IsEmpty@UString@@QBE_NXZ
.text:00000C78 ?IsEmpty@UString@@QBE_NXZ proc near     ; CODE XREF: NCommandLineParser::SplitCommandLine(UString const &,CObjectVector<UString> &)+97p
.text:00000C78                                         ; NCommandLineParser::CParser::ParseString(UString const &,NCommandLineParser::CSwitchForm const *)+3Ep ...
.text:00000C78
.text:00000C78 var_4           = dword ptr -4
.text:00000C78
.text:00000C78                 push    ebp
.text:00000C79                 mov     ebp, esp
.text:00000C7B                 push    ecx
.text:00000C7C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000C83                 mov     [ebp+var_4], ecx
.text:00000C86                 mov     eax, [ebp+var_4]
.text:00000C89                 xor     ecx, ecx
.text:00000C8B                 cmp     dword ptr [eax+4], 0
.text:00000C8F                 setz    cl
.text:00000C92                 mov     al, cl
.text:00000C94                 mov     esp, ebp
.text:00000C96                 pop     ebp
.text:00000C97                 retn
.text:00000C97 ?IsEmpty@UString@@QBE_NXZ endp
.text:00000C97
.text:00000C97 _text           ends
.text:00000C97
.text:00000C98 ; ===========================================================================
.text:00000C98
.text:00000C98 ; Segment type: Pure code
.text:00000C98 ; Segment permissions: Read/Execute
.text:00000C98 _text           segment para public 'CODE' use32
.text:00000C98                 assume cs:_text
.text:00000C98                 ;org 0C98h
.text:00000C98 ; COMDAT (pick any)
.text:00000C98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000C98
.text:00000C98 ; =============== S U B R O U T I N E =======================================
.text:00000C98
.text:00000C98 ; Attributes: bp-based frame
.text:00000C98
.text:00000C98 ; void __thiscall UString::Trim(UString *__hidden this)
.text:00000C98                 public ?Trim@UString@@QAEXXZ
.text:00000C98 ?Trim@UString@@QAEXXZ proc near         ; CODE XREF: NCommandLineParser::SplitCommandLine(UString const &,CObjectVector<UString> &)+4Bp
.text:00000C98
.text:00000C98 var_4           = dword ptr -4
.text:00000C98
.text:00000C98                 push    ebp
.text:00000C99                 mov     ebp, esp
.text:00000C9B                 push    ecx
.text:00000C9C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000CA3                 mov     [ebp+var_4], ecx
.text:00000CA6                 mov     ecx, [ebp+var_4] ; this
.text:00000CA9                 call    ?TrimRight@UString@@QAEXXZ ; UString::TrimRight(void)
.text:00000CAE                 mov     ecx, [ebp+var_4] ; this
.text:00000CB1                 call    ?TrimLeft@UString@@QAEXXZ ; UString::TrimLeft(void)
.text:00000CB6                 add     esp, 4
.text:00000CB9                 cmp     ebp, esp
.text:00000CBB                 call    __RTC_CheckEsp
.text:00000CC0                 mov     esp, ebp
.text:00000CC2                 pop     ebp
.text:00000CC3                 retn
.text:00000CC3 ?Trim@UString@@QAEXXZ endp
.text:00000CC3
.text:00000CC3 _text           ends
.text:00000CC3
.text:00000CC4 ; ===========================================================================
.text:00000CC4
.text:00000CC4 ; Segment type: Pure code
.text:00000CC4 ; Segment permissions: Read/Execute
.text:00000CC4 _text           segment para public 'CODE' use32
.text:00000CC4                 assume cs:_text
.text:00000CC4                 ;org 0CC4h
.text:00000CC4 ; COMDAT (pick any)
.text:00000CC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000CC4
.text:00000CC4 ; =============== S U B R O U T I N E =======================================
.text:00000CC4
.text:00000CC4 ; Attributes: bp-based frame
.text:00000CC4
.text:00000CC4 ; _DWORD __thiscall AString::~AString(AString *__hidden this)
.text:00000CC4                 public ??1AString@@QAE@XZ
.text:00000CC4 ??1AString@@QAE@XZ proc near            ; CODE XREF: NCommandLineParser::CParser::~CParser(void)+84p
.text:00000CC4                                         ; __unwindfunclet$??0CParser@NCommandLineParser@@QAE@I@Z$1+6j ...
.text:00000CC4
.text:00000CC4 var_8           = dword ptr -8
.text:00000CC4 var_4           = dword ptr -4
.text:00000CC4
.text:00000CC4                 push    ebp
.text:00000CC5                 mov     ebp, esp
.text:00000CC7                 sub     esp, 8
.text:00000CCA                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00000CD1                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000CD8                 mov     [ebp+var_4], ecx
.text:00000CDB                 mov     eax, [ebp+var_4]
.text:00000CDE                 mov     ecx, [eax]
.text:00000CE0                 mov     [ebp+var_8], ecx
.text:00000CE3                 mov     edx, [ebp+var_8]
.text:00000CE6                 push    edx             ; void *
.text:00000CE7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00000CEC                 add     esp, 4
.text:00000CEF                 add     esp, 8
.text:00000CF2                 cmp     ebp, esp
.text:00000CF4                 call    __RTC_CheckEsp
.text:00000CF9                 mov     esp, ebp
.text:00000CFB                 pop     ebp
.text:00000CFC                 retn
.text:00000CFC ??1AString@@QAE@XZ endp
.text:00000CFC
.text:00000CFC ; ---------------------------------------------------------------------------
.text:00000CFD                 align 10h
.text:00000CFD _text           ends
.text:00000CFD
.text:00000D00 ; ===========================================================================
.text:00000D00
.text:00000D00 ; Segment type: Pure code
.text:00000D00 ; Segment permissions: Read/Execute
.text:00000D00 _text           segment para public 'CODE' use32
.text:00000D00                 assume cs:_text
.text:00000D00                 ;org 0D00h
.text:00000D00 ; COMDAT (pick any)
.text:00000D00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000D00
.text:00000D00 ; =============== S U B R O U T I N E =======================================
.text:00000D00
.text:00000D00 ; Attributes: bp-based frame
.text:00000D00
.text:00000D00 ; _DWORD __thiscall NCommandLineParser::CSwitchResult::CSwitchResult(NCommandLineParser::CSwitchResult *__hidden this)
.text:00000D00                 public ??0CSwitchResult@NCommandLineParser@@QAE@XZ
.text:00000D00 ??0CSwitchResult@NCommandLineParser@@QAE@XZ proc near
.text:00000D00                                         ; DATA XREF: NCommandLineParser::CParser::CParser(uint)+C6o
.text:00000D00
.text:00000D00 var_4           = dword ptr -4
.text:00000D00
.text:00000D00                 push    ebp
.text:00000D01                 mov     ebp, esp
.text:00000D03                 push    ecx
.text:00000D04                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000D0B                 mov     [ebp+var_4], ecx
.text:00000D0E                 mov     eax, [ebp+var_4]
.text:00000D11                 mov     byte ptr [eax], 0
.text:00000D14                 mov     ecx, [ebp+var_4]
.text:00000D17                 add     ecx, 8
.text:00000D1A                 call    ??0?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::CObjectVector<UString>(void)
.text:00000D1F                 mov     eax, [ebp+var_4]
.text:00000D22                 add     esp, 4
.text:00000D25                 cmp     ebp, esp
.text:00000D27                 call    __RTC_CheckEsp
.text:00000D2C                 mov     esp, ebp
.text:00000D2E                 pop     ebp
.text:00000D2F                 retn
.text:00000D2F ??0CSwitchResult@NCommandLineParser@@QAE@XZ endp
.text:00000D2F
.text:00000D2F _text           ends
.text:00000D2F
.text:00000D30 ; ===========================================================================
.text:00000D30
.text:00000D30 ; Segment type: Pure code
.text:00000D30 ; Segment permissions: Read/Execute
.text:00000D30 _text           segment para public 'CODE' use32
.text:00000D30                 assume cs:_text
.text:00000D30                 ;org 0D30h
.text:00000D30 ; COMDAT (pick any)
.text:00000D30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000D30
.text:00000D30 ; =============== S U B R O U T I N E =======================================
.text:00000D30
.text:00000D30 ; Attributes: bp-based frame
.text:00000D30
.text:00000D30 ; public: void * __thiscall NCommandLineParser::CSwitchResult::`vector deleting destructor'(unsigned int)
.text:00000D30                 public ??_ECSwitchResult@NCommandLineParser@@QAEPAXI@Z
.text:00000D30 ??_ECSwitchResult@NCommandLineParser@@QAEPAXI@Z proc near
.text:00000D30                                         ; CODE XREF: NCommandLineParser::CParser::~CParser(void)+5Ap
.text:00000D30
.text:00000D30 var_4           = dword ptr -4
.text:00000D30 arg_0           = dword ptr  8
.text:00000D30
.text:00000D30                 push    ebp
.text:00000D31                 mov     ebp, esp
.text:00000D33                 push    ecx
.text:00000D34                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000D3B                 mov     [ebp+var_4], ecx
.text:00000D3E                 mov     eax, [ebp+arg_0]
.text:00000D41                 and     eax, 2
.text:00000D44                 jz      short loc_D7C
.text:00000D46                 push    offset ??1CSwitchResult@NCommandLineParser@@QAE@XZ ; NCommandLineParser::CSwitchResult::~CSwitchResult(void)
.text:00000D4B                 mov     ecx, [ebp+var_4]
.text:00000D4E                 mov     edx, [ecx-4]
.text:00000D51                 push    edx
.text:00000D52                 push    14h
.text:00000D54                 mov     eax, [ebp+var_4]
.text:00000D57                 push    eax
.text:00000D58                 call    ??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
.text:00000D5D                 mov     ecx, [ebp+arg_0]
.text:00000D60                 and     ecx, 1
.text:00000D63                 jz      short loc_D74
.text:00000D65                 mov     edx, [ebp+var_4]
.text:00000D68                 sub     edx, 4
.text:00000D6B                 push    edx             ; void *
.text:00000D6C                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00000D71                 add     esp, 4
.text:00000D74
.text:00000D74 loc_D74:                                ; CODE XREF: NCommandLineParser::CSwitchResult::`vector deleting destructor'(uint)+33j
.text:00000D74                 mov     eax, [ebp+var_4]
.text:00000D77                 sub     eax, 4
.text:00000D7A                 jmp     short loc_D9B
.text:00000D7C ; ---------------------------------------------------------------------------
.text:00000D7C
.text:00000D7C loc_D7C:                                ; CODE XREF: NCommandLineParser::CSwitchResult::`vector deleting destructor'(uint)+14j
.text:00000D7C                 mov     ecx, [ebp+var_4] ; this
.text:00000D7F                 call    ??1CSwitchResult@NCommandLineParser@@QAE@XZ ; NCommandLineParser::CSwitchResult::~CSwitchResult(void)
.text:00000D84                 mov     eax, [ebp+arg_0]
.text:00000D87                 and     eax, 1
.text:00000D8A                 jz      short loc_D98
.text:00000D8C                 mov     ecx, [ebp+var_4]
.text:00000D8F                 push    ecx             ; void *
.text:00000D90                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00000D95                 add     esp, 4
.text:00000D98
.text:00000D98 loc_D98:                                ; CODE XREF: NCommandLineParser::CSwitchResult::`vector deleting destructor'(uint)+5Aj
.text:00000D98                 mov     eax, [ebp+var_4]
.text:00000D9B
.text:00000D9B loc_D9B:                                ; CODE XREF: NCommandLineParser::CSwitchResult::`vector deleting destructor'(uint)+4Aj
.text:00000D9B                 add     esp, 4
.text:00000D9E                 cmp     ebp, esp
.text:00000DA0                 call    __RTC_CheckEsp
.text:00000DA5                 mov     esp, ebp
.text:00000DA7                 pop     ebp
.text:00000DA8                 retn    4
.text:00000DA8 ??_ECSwitchResult@NCommandLineParser@@QAEPAXI@Z endp
.text:00000DA8
.text:00000DA8 ; ---------------------------------------------------------------------------
.text:00000DAB                 align 4
.text:00000DAB _text           ends
.text:00000DAB
.text:00000DAC ; ===========================================================================
.text:00000DAC
.text:00000DAC ; Segment type: Pure code
.text:00000DAC ; Segment permissions: Read/Execute
.text:00000DAC _text           segment para public 'CODE' use32
.text:00000DAC                 assume cs:_text
.text:00000DAC                 ;org 0DACh
.text:00000DAC ; COMDAT (pick any)
.text:00000DAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000DAC
.text:00000DAC ; =============== S U B R O U T I N E =======================================
.text:00000DAC
.text:00000DAC ; Attributes: bp-based frame
.text:00000DAC
.text:00000DAC ; _DWORD __thiscall NCommandLineParser::CSwitchResult::~CSwitchResult(NCommandLineParser::CSwitchResult *__hidden this)
.text:00000DAC                 public ??1CSwitchResult@NCommandLineParser@@QAE@XZ
.text:00000DAC ??1CSwitchResult@NCommandLineParser@@QAE@XZ proc near
.text:00000DAC                                         ; CODE XREF: NCommandLineParser::CSwitchResult::`vector deleting destructor'(uint)+4Fp
.text:00000DAC                                         ; DATA XREF: NCommandLineParser::CParser::CParser(uint)+C1o ...
.text:00000DAC
.text:00000DAC var_4           = dword ptr -4
.text:00000DAC
.text:00000DAC                 push    ebp
.text:00000DAD                 mov     ebp, esp
.text:00000DAF                 push    ecx
.text:00000DB0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000DB7                 mov     [ebp+var_4], ecx
.text:00000DBA                 mov     ecx, [ebp+var_4]
.text:00000DBD                 add     ecx, 8
.text:00000DC0                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:00000DC5                 add     esp, 4
.text:00000DC8                 cmp     ebp, esp
.text:00000DCA                 call    __RTC_CheckEsp
.text:00000DCF                 mov     esp, ebp
.text:00000DD1                 pop     ebp
.text:00000DD2                 retn
.text:00000DD2 ??1CSwitchResult@NCommandLineParser@@QAE@XZ endp
.text:00000DD2
.text:00000DD2 ; ---------------------------------------------------------------------------
.text:00000DD3                 align 4
.text:00000DD3 _text           ends
.text:00000DD3
.text:00000DD4 ; ===========================================================================
.text:00000DD4
.text:00000DD4 ; Segment type: Pure code
.text:00000DD4 ; Segment permissions: Read/Execute
.text:00000DD4 _text           segment para public 'CODE' use32
.text:00000DD4                 assume cs:_text
.text:00000DD4                 ;org 0DD4h
.text:00000DD4 ; COMDAT (pick any)
.text:00000DD4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000DD4
.text:00000DD4 ; =============== S U B R O U T I N E =======================================
.text:00000DD4
.text:00000DD4 ; Attributes: bp-based frame
.text:00000DD4
.text:00000DD4 ; unsigned int __stdcall MyStringLen(const char *)
.text:00000DD4                 public ?MyStringLen@@YGIPBD@Z
.text:00000DD4 ?MyStringLen@@YGIPBD@Z proc near        ; CODE XREF: NCommandLineParser::CParser::ParseString(UString const &,NCommandLineParser::CSwitchForm const *)+ADp
.text:00000DD4
.text:00000DD4 var_4           = dword ptr -4
.text:00000DD4 arg_0           = dword ptr  8
.text:00000DD4
.text:00000DD4                 push    ebp
.text:00000DD5                 mov     ebp, esp
.text:00000DD7                 push    ecx
.text:00000DD8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000DDF                 mov     [ebp+var_4], 0
.text:00000DE6                 jmp     short loc_DF1
.text:00000DE8 ; ---------------------------------------------------------------------------
.text:00000DE8
.text:00000DE8 loc_DE8:                                ; CODE XREF: MyStringLen(char const *)+2Aj
.text:00000DE8                 mov     eax, [ebp+var_4]
.text:00000DEB                 add     eax, 1
.text:00000DEE                 mov     [ebp+var_4], eax
.text:00000DF1
.text:00000DF1 loc_DF1:                                ; CODE XREF: MyStringLen(char const *)+12j
.text:00000DF1                 mov     ecx, [ebp+arg_0]
.text:00000DF4                 add     ecx, [ebp+var_4]
.text:00000DF7                 movsx   edx, byte ptr [ecx]
.text:00000DFA                 test    edx, edx
.text:00000DFC                 jz      short loc_E00
.text:00000DFE                 jmp     short loc_DE8
.text:00000E00 ; ---------------------------------------------------------------------------
.text:00000E00
.text:00000E00 loc_E00:                                ; CODE XREF: MyStringLen(char const *)+28j
.text:00000E00                 mov     eax, [ebp+var_4]
.text:00000E03                 mov     esp, ebp
.text:00000E05                 pop     ebp
.text:00000E06                 retn    4
.text:00000E06 ?MyStringLen@@YGIPBD@Z endp
.text:00000E06
.text:00000E06 ; ---------------------------------------------------------------------------
.text:00000E09                 align 4
.text:00000E09 _text           ends
.text:00000E09
.text:00000E0C ; ===========================================================================
.text:00000E0C
.text:00000E0C ; Segment type: Pure code
.text:00000E0C ; Segment permissions: Read/Execute
.text:00000E0C _text           segment para public 'CODE' use32
.text:00000E0C                 assume cs:_text
.text:00000E0C                 ;org 0E0Ch
.text:00000E0C ; COMDAT (pick any)
.text:00000E0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000E0C
.text:00000E0C ; =============== S U B R O U T I N E =======================================
.text:00000E0C
.text:00000E0C ; Attributes: bp-based frame
.text:00000E0C
.text:00000E0C ; char __stdcall MyCharLower_Ascii(char)
.text:00000E0C                 public ?MyCharLower_Ascii@@YGDD@Z
.text:00000E0C ?MyCharLower_Ascii@@YGDD@Z proc near    ; CODE XREF: IsString1PrefixedByString2_NoCase(wchar_t const *,char const *)+25p
.text:00000E0C
.text:00000E0C arg_0           = byte ptr  8
.text:00000E0C
.text:00000E0C                 push    ebp
.text:00000E0D                 mov     ebp, esp
.text:00000E0F                 movsx   eax, [ebp+arg_0]
.text:00000E13                 cmp     eax, 41h ; 'A'
.text:00000E16                 jl      short loc_E2A
.text:00000E18                 movsx   ecx, [ebp+arg_0]
.text:00000E1C                 cmp     ecx, 5Ah ; 'Z'
.text:00000E1F                 jg      short loc_E2A
.text:00000E21                 movzx   eax, [ebp+arg_0]
.text:00000E25                 add     eax, 20h ; ' '
.text:00000E28                 jmp     short loc_E2D
.text:00000E2A ; ---------------------------------------------------------------------------
.text:00000E2A
.text:00000E2A loc_E2A:                                ; CODE XREF: MyCharLower_Ascii(char)+Aj
.text:00000E2A                                         ; MyCharLower_Ascii(char)+13j
.text:00000E2A                 mov     al, [ebp+arg_0]
.text:00000E2D
.text:00000E2D loc_E2D:                                ; CODE XREF: MyCharLower_Ascii(char)+1Cj
.text:00000E2D                 pop     ebp
.text:00000E2E                 retn    4
.text:00000E2E ?MyCharLower_Ascii@@YGDD@Z endp
.text:00000E2E
.text:00000E2E ; ---------------------------------------------------------------------------
.text:00000E31                 align 4
.text:00000E31 _text           ends
.text:00000E31
.text:00000E34 ; ===========================================================================
.text:00000E34
.text:00000E34 ; Segment type: Pure code
.text:00000E34 ; Segment permissions: Read/Execute
.text:00000E34 _text           segment para public 'CODE' use32
.text:00000E34                 assume cs:_text
.text:00000E34                 ;org 0E34h
.text:00000E34 ; COMDAT (pick any)
.text:00000E34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000E34
.text:00000E34 ; =============== S U B R O U T I N E =======================================
.text:00000E34
.text:00000E34 ; Attributes: bp-based frame
.text:00000E34
.text:00000E34 ; wchar_t __stdcall MyCharLower_Ascii(wchar_t)
.text:00000E34                 public ?MyCharLower_Ascii@@YG_W_W@Z
.text:00000E34 ?MyCharLower_Ascii@@YG_W_W@Z proc near  ; CODE XREF: IsString1PrefixedByString2_NoCase(wchar_t const *,char const *)+34p
.text:00000E34
.text:00000E34 arg_0           = word ptr  8
.text:00000E34
.text:00000E34                 push    ebp
.text:00000E35                 mov     ebp, esp
.text:00000E37                 movzx   eax, [ebp+arg_0]
.text:00000E3B                 cmp     eax, 41h ; 'A'
.text:00000E3E                 jl      short loc_E52
.text:00000E40                 movzx   ecx, [ebp+arg_0]
.text:00000E44                 cmp     ecx, 5Ah ; 'Z'
.text:00000E47                 jg      short loc_E52
.text:00000E49                 movzx   eax, [ebp+arg_0]
.text:00000E4D                 add     eax, 20h ; ' '
.text:00000E50                 jmp     short loc_E56
.text:00000E52 ; ---------------------------------------------------------------------------
.text:00000E52
.text:00000E52 loc_E52:                                ; CODE XREF: MyCharLower_Ascii(wchar_t)+Aj
.text:00000E52                                         ; MyCharLower_Ascii(wchar_t)+13j
.text:00000E52                 mov     ax, [ebp+arg_0]
.text:00000E56
.text:00000E56 loc_E56:                                ; CODE XREF: MyCharLower_Ascii(wchar_t)+1Cj
.text:00000E56                 pop     ebp
.text:00000E57                 retn    4
.text:00000E57 ?MyCharLower_Ascii@@YG_W_W@Z endp
.text:00000E57
.text:00000E57 ; ---------------------------------------------------------------------------
.text:00000E5A                 align 4
.text:00000E5A _text           ends
.text:00000E5A
.text:00000E5C ; ===========================================================================
.text:00000E5C
.text:00000E5C ; Segment type: Pure code
.text:00000E5C ; Segment permissions: Read/Execute
.text:00000E5C _text           segment para public 'CODE' use32
.text:00000E5C                 assume cs:_text
.text:00000E5C                 ;org 0E5Ch
.text:00000E5C ; COMDAT (pick any)
.text:00000E5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000E5C
.text:00000E5C ; =============== S U B R O U T I N E =======================================
.text:00000E5C
.text:00000E5C ; Attributes: bp-based frame
.text:00000E5C
.text:00000E5C ; bool __thiscall UString::IsEqualTo(UString *this, const char *)
.text:00000E5C                 public ?IsEqualTo@UString@@QBE_NPBD@Z
.text:00000E5C ?IsEqualTo@UString@@QBE_NPBD@Z proc near
.text:00000E5C                                         ; CODE XREF: NCommandLineParser::CParser::ParseStrings(NCommandLineParser::CSwitchForm const *,CObjectVector<UString> const &)+6Cp
.text:00000E5C
.text:00000E5C var_4           = dword ptr -4
.text:00000E5C arg_0           = dword ptr  8
.text:00000E5C
.text:00000E5C                 push    ebp
.text:00000E5D                 mov     ebp, esp
.text:00000E5F                 push    ecx
.text:00000E60                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000E67                 mov     [ebp+var_4], ecx
.text:00000E6A                 mov     eax, [ebp+arg_0]
.text:00000E6D                 push    eax             ; char *
.text:00000E6E                 mov     ecx, [ebp+var_4]
.text:00000E71                 mov     edx, [ecx]
.text:00000E73                 push    edx             ; wchar_t *
.text:00000E74                 call    ?StringsAreEqual_Ascii@@YG_NPB_WPBD@Z ; StringsAreEqual_Ascii(wchar_t const *,char const *)
.text:00000E79                 add     esp, 4
.text:00000E7C                 cmp     ebp, esp
.text:00000E7E                 call    __RTC_CheckEsp
.text:00000E83                 mov     esp, ebp
.text:00000E85                 pop     ebp
.text:00000E86                 retn    4
.text:00000E86 ?IsEqualTo@UString@@QBE_NPBD@Z endp
.text:00000E86
.text:00000E86 ; ---------------------------------------------------------------------------
.text:00000E89                 align 4
.text:00000E89 _text           ends
.text:00000E89
.text:00000E8C ; ===========================================================================
.text:00000E8C
.text:00000E8C ; Segment type: Pure code
.text:00000E8C ; Segment permissions: Read/Execute
.text:00000E8C _text           segment para public 'CODE' use32
.text:00000E8C                 assume cs:_text
.text:00000E8C                 ;org 0E8Ch
.text:00000E8C ; COMDAT (pick any)
.text:00000E8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000E8C
.text:00000E8C ; =============== S U B R O U T I N E =======================================
.text:00000E8C
.text:00000E8C ; Attributes: bp-based frame
.text:00000E8C
.text:00000E8C ; public: unsigned int __thiscall CObjectVector<class UString>::Size(void)const
.text:00000E8C                 public ?Size@?$CObjectVector@VUString@@@@QBEIXZ
.text:00000E8C ?Size@?$CObjectVector@VUString@@@@QBEIXZ proc near
.text:00000E8C                                         ; CODE XREF: NCommandLineParser::CParser::ParseStrings(NCommandLineParser::CSwitchForm const *,CObjectVector<UString> const &)+3Ep
.text:00000E8C
.text:00000E8C var_4           = dword ptr -4
.text:00000E8C
.text:00000E8C                 push    ebp
.text:00000E8D                 mov     ebp, esp
.text:00000E8F                 push    ecx
.text:00000E90                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000E97                 mov     [ebp+var_4], ecx
.text:00000E9A                 mov     ecx, [ebp+var_4]
.text:00000E9D                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00000EA2                 add     esp, 4
.text:00000EA5                 cmp     ebp, esp
.text:00000EA7                 call    __RTC_CheckEsp
.text:00000EAC                 mov     esp, ebp
.text:00000EAE                 pop     ebp
.text:00000EAF                 retn
.text:00000EAF ?Size@?$CObjectVector@VUString@@@@QBEIXZ endp
.text:00000EAF
.text:00000EAF _text           ends
.text:00000EAF
.text:00000EB0 ; ===========================================================================
.text:00000EB0
.text:00000EB0 ; Segment type: Pure code
.text:00000EB0 ; Segment permissions: Read/Execute
.text:00000EB0 _text           segment para public 'CODE' use32
.text:00000EB0                 assume cs:_text
.text:00000EB0                 ;org 0EB0h
.text:00000EB0 ; COMDAT (pick any)
.text:00000EB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000EB0
.text:00000EB0 ; =============== S U B R O U T I N E =======================================
.text:00000EB0
.text:00000EB0 ; Attributes: bp-based frame
.text:00000EB0
.text:00000EB0 ; public: __thiscall CObjectVector<class UString>::CObjectVector<class UString>(void)
.text:00000EB0                 public ??0?$CObjectVector@VUString@@@@QAE@XZ
.text:00000EB0 ??0?$CObjectVector@VUString@@@@QAE@XZ proc near
.text:00000EB0                                         ; CODE XREF: NCommandLineParser::CParser::CParser(uint)+54p
.text:00000EB0                                         ; NCommandLineParser::CSwitchResult::CSwitchResult(void)+1Ap
.text:00000EB0
.text:00000EB0 var_4           = dword ptr -4
.text:00000EB0
.text:00000EB0                 push    ebp
.text:00000EB1                 mov     ebp, esp
.text:00000EB3                 push    ecx
.text:00000EB4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000EBB                 mov     [ebp+var_4], ecx
.text:00000EBE                 mov     ecx, [ebp+var_4]
.text:00000EC1                 call    ??0?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::CRecordVector<void *>(void)
.text:00000EC6                 mov     eax, [ebp+var_4]
.text:00000EC9                 add     esp, 4
.text:00000ECC                 cmp     ebp, esp
.text:00000ECE                 call    __RTC_CheckEsp
.text:00000ED3                 mov     esp, ebp
.text:00000ED5                 pop     ebp
.text:00000ED6                 retn
.text:00000ED6 ??0?$CObjectVector@VUString@@@@QAE@XZ endp
.text:00000ED6
.text:00000ED6 ; ---------------------------------------------------------------------------
.text:00000ED7                 align 4
.text:00000ED7 _text           ends
.text:00000ED7
.text:00000ED8 ; ===========================================================================
.text:00000ED8
.text:00000ED8 ; Segment type: Pure code
.text:00000ED8 ; Segment permissions: Read/Execute
.text:00000ED8 _text           segment para public 'CODE' use32
.text:00000ED8                 assume cs:_text
.text:00000ED8                 ;org 0ED8h
.text:00000ED8 ; COMDAT (pick any)
.text:00000ED8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000ED8
.text:00000ED8 ; =============== S U B R O U T I N E =======================================
.text:00000ED8
.text:00000ED8 ; Attributes: bp-based frame
.text:00000ED8
.text:00000ED8 ; public: class UString const & __thiscall CObjectVector<class UString>::operator[](unsigned int)const
.text:00000ED8                 public ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z
.text:00000ED8 ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z proc near
.text:00000ED8                                         ; CODE XREF: NCommandLineParser::CParser::ParseStrings(NCommandLineParser::CSwitchForm const *,CObjectVector<UString> const &)+53p
.text:00000ED8
.text:00000ED8 var_4           = dword ptr -4
.text:00000ED8 arg_0           = dword ptr  8
.text:00000ED8
.text:00000ED8                 push    ebp
.text:00000ED9                 mov     ebp, esp
.text:00000EDB                 push    ecx
.text:00000EDC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000EE3                 mov     [ebp+var_4], ecx
.text:00000EE6                 mov     eax, [ebp+arg_0]
.text:00000EE9                 push    eax
.text:00000EEA                 mov     ecx, [ebp+var_4]
.text:00000EED                 call    ??A?$CRecordVector@PAX@@QBEABQAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00000EF2                 mov     eax, [eax]
.text:00000EF4                 add     esp, 4
.text:00000EF7                 cmp     ebp, esp
.text:00000EF9                 call    __RTC_CheckEsp
.text:00000EFE                 mov     esp, ebp
.text:00000F00                 pop     ebp
.text:00000F01                 retn    4
.text:00000F01 ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z endp
.text:00000F01
.text:00000F01 _text           ends
.text:00000F01
.text:00000F04 ; ===========================================================================
.text:00000F04
.text:00000F04 ; Segment type: Pure code
.text:00000F04 ; Segment permissions: Read/Execute
.text:00000F04 _text           segment para public 'CODE' use32
.text:00000F04                 assume cs:_text
.text:00000F04                 ;org 0F04h
.text:00000F04 ; COMDAT (pick any)
.text:00000F04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000F04
.text:00000F04 ; =============== S U B R O U T I N E =======================================
.text:00000F04
.text:00000F04 ; Attributes: bp-based frame
.text:00000F04
.text:00000F04 ; public: unsigned int __thiscall CObjectVector<class UString>::Add(class UString const &)
.text:00000F04                 public ?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z
.text:00000F04 ?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z proc near
.text:00000F04                                         ; CODE XREF: NCommandLineParser::SplitCommandLine(UString const &,CObjectVector<UString> &)+8Fp
.text:00000F04                                         ; NCommandLineParser::CParser::ParseString(UString const &,NCommandLineParser::CSwitchForm const *)+2ACp ...
.text:00000F04
.text:00000F04 var_1C          = dword ptr -1Ch
.text:00000F04 var_18          = dword ptr -18h
.text:00000F04 var_14          = dword ptr -14h
.text:00000F04 var_10          = dword ptr -10h
.text:00000F04 var_C           = dword ptr -0Ch
.text:00000F04 var_4           = dword ptr -4
.text:00000F04 arg_0           = dword ptr  8
.text:00000F04
.text:00000F04                 push    ebp
.text:00000F05                 mov     ebp, esp
.text:00000F07                 push    0FFFFFFFFh
.text:00000F09                 push    offset __ehhandler$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z
.text:00000F0E                 mov     eax, large fs:0
.text:00000F14                 push    eax
.text:00000F15                 sub     esp, 10h
.text:00000F18                 mov     eax, 0CCCCCCCCh
.text:00000F1D                 mov     [ebp+var_1C], eax
.text:00000F20                 mov     [ebp+var_18], eax
.text:00000F23                 mov     [ebp+var_14], eax
.text:00000F26                 mov     [ebp+var_10], eax
.text:00000F29                 mov     eax, dword ptr ds:___security_cookie
.text:00000F2E                 xor     eax, ebp
.text:00000F30                 push    eax
.text:00000F31                 lea     eax, [ebp+var_C]
.text:00000F34                 mov     large fs:0, eax
.text:00000F3A                 mov     [ebp+var_10], ecx
.text:00000F3D                 push    0Ch             ; unsigned int
.text:00000F3F                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00000F44                 add     esp, 4
.text:00000F47                 mov     [ebp+var_18], eax
.text:00000F4A                 mov     [ebp+var_4], 0
.text:00000F51                 cmp     [ebp+var_18], 0
.text:00000F55                 jz      short loc_F68
.text:00000F57                 mov     eax, [ebp+arg_0]
.text:00000F5A                 push    eax
.text:00000F5B                 mov     ecx, [ebp+var_18]
.text:00000F5E                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00000F63                 mov     [ebp+var_1C], eax
.text:00000F66                 jmp     short loc_F6F
.text:00000F68 ; ---------------------------------------------------------------------------
.text:00000F68
.text:00000F68 loc_F68:                                ; CODE XREF: CObjectVector<UString>::Add(UString const &)+51j
.text:00000F68                 mov     [ebp+var_1C], 0
.text:00000F6F
.text:00000F6F loc_F6F:                                ; CODE XREF: CObjectVector<UString>::Add(UString const &)+62j
.text:00000F6F                 mov     ecx, [ebp+var_1C]
.text:00000F72                 mov     [ebp+var_14], ecx
.text:00000F75                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000F7C                 mov     edx, [ebp+var_14]
.text:00000F7F                 push    edx
.text:00000F80                 mov     ecx, [ebp+var_10]
.text:00000F83                 call    ?Add@?$CRecordVector@PAX@@QAEIQAX@Z ; CRecordVector<void *>::Add(void * const)
.text:00000F88                 mov     ecx, [ebp+var_C]
.text:00000F8B                 mov     large fs:0, ecx
.text:00000F92                 pop     ecx
.text:00000F93                 add     esp, 1Ch
.text:00000F96                 cmp     ebp, esp
.text:00000F98                 call    __RTC_CheckEsp
.text:00000F9D                 mov     esp, ebp
.text:00000F9F                 pop     ebp
.text:00000FA0                 retn    4
.text:00000FA0 ?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z endp
.text:00000FA0
.text:00000FA0 ; ---------------------------------------------------------------------------
.text:00000FA3                 align 4
.text:00000FA3 _text           ends
.text:00000FA3
.text$x:00000FA4 ; ===========================================================================
.text$x:00000FA4
.text$x:00000FA4 ; Segment type: Pure code
.text$x:00000FA4 ; Segment permissions: Read/Execute
.text$x:00000FA4 _text$x         segment para public 'CODE' use32
.text$x:00000FA4                 assume cs:_text$x
.text$x:00000FA4                 ;org 0FA4h
.text$x:00000FA4 ; COMDAT (pick associative to section at F04)
.text$x:00000FA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000FA4
.text$x:00000FA4 ; =============== S U B R O U T I N E =======================================
.text$x:00000FA4
.text$x:00000FA4
.text$x:00000FA4 __unwindfunclet$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z$0 proc near
.text$x:00000FA4                                         ; DATA XREF: .xdata$x:00000FD0o
.text$x:00000FA4                 mov     eax, [ebp-18h]
.text$x:00000FA7                 push    eax             ; void *
.text$x:00000FA8                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00000FAD                 pop     ecx
.text$x:00000FAE                 retn
.text$x:00000FAE __unwindfunclet$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z$0 endp
.text$x:00000FAE
.text$x:00000FAF
.text$x:00000FAF ; =============== S U B R O U T I N E =======================================
.text$x:00000FAF
.text$x:00000FAF
.text$x:00000FAF __ehhandler$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z proc near
.text$x:00000FAF                                         ; DATA XREF: CObjectVector<UString>::Add(UString const &)+5o
.text$x:00000FAF
.text$x:00000FAF arg_4           = dword ptr  8
.text$x:00000FAF
.text$x:00000FAF                 mov     edx, [esp+arg_4]
.text$x:00000FB3                 lea     eax, [edx+0Ch]
.text$x:00000FB6                 mov     ecx, [edx-14h]
.text$x:00000FB9                 xor     ecx, eax
.text$x:00000FBB                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000FC0                 mov     eax, offset __ehfuncinfo$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z
.text$x:00000FC5                 jmp     ___CxxFrameHandler3
.text$x:00000FC5 __ehhandler$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z endp
.text$x:00000FC5
.text$x:00000FC5 ; ---------------------------------------------------------------------------
.text$x:00000FCA                 align 4
.text$x:00000FCA _text$x         ends
.text$x:00000FCA
.xdata$x:00000FCC ; ===========================================================================
.xdata$x:00000FCC
.xdata$x:00000FCC ; Segment type: Pure data
.xdata$x:00000FCC ; Segment permissions: Read
.xdata$x:00000FCC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00000FCC                 assume cs:_xdata$x
.xdata$x:00000FCC                 ;org 0FCCh
.xdata$x:00000FCC ; COMDAT (pick associative to section at F04)
.xdata$x:00000FCC __unwindtable$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z db 0FFh
.xdata$x:00000FCC                                         ; DATA XREF: .xdata$x:00000FDCo
.xdata$x:00000FCD                 db 0FFh
.xdata$x:00000FCE                 db 0FFh
.xdata$x:00000FCF                 db 0FFh
.xdata$x:00000FD0                 dd offset __unwindfunclet$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z$0
.xdata$x:00000FD4 __ehfuncinfo$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z db  22h ; "
.xdata$x:00000FD4                                         ; DATA XREF: __ehhandler$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z+11o
.xdata$x:00000FD5                 db    5
.xdata$x:00000FD6                 db  93h ; ô
.xdata$x:00000FD7                 db  19h
.xdata$x:00000FD8                 db    1
.xdata$x:00000FD9                 db    0
.xdata$x:00000FDA                 db    0
.xdata$x:00000FDB                 db    0
.xdata$x:00000FDC                 dd offset __unwindtable$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z
.xdata$x:00000FE0                 db    0
.xdata$x:00000FE1                 db    0
.xdata$x:00000FE2                 db    0
.xdata$x:00000FE3                 db    0
.xdata$x:00000FE4                 db    0
.xdata$x:00000FE5                 db    0
.xdata$x:00000FE6                 db    0
.xdata$x:00000FE7                 db    0
.xdata$x:00000FE8                 db    0
.xdata$x:00000FE9                 db    0
.xdata$x:00000FEA                 db    0
.xdata$x:00000FEB                 db    0
.xdata$x:00000FEC                 db    0
.xdata$x:00000FED                 db    0
.xdata$x:00000FEE                 db    0
.xdata$x:00000FEF                 db    0
.xdata$x:00000FF0                 db    0
.xdata$x:00000FF1                 db    0
.xdata$x:00000FF2                 db    0
.xdata$x:00000FF3                 db    0
.xdata$x:00000FF4                 db    1
.xdata$x:00000FF5                 db    0
.xdata$x:00000FF6                 db    0
.xdata$x:00000FF7                 db    0
.xdata$x:00000FF7 _xdata$x        ends
.xdata$x:00000FF7
.text:00000FF8 ; ===========================================================================
.text:00000FF8
.text:00000FF8 ; Segment type: Pure code
.text:00000FF8 ; Segment permissions: Read/Execute
.text:00000FF8 _text           segment para public 'CODE' use32
.text:00000FF8                 assume cs:_text
.text:00000FF8                 ;org 0FF8h
.text:00000FF8 ; COMDAT (pick any)
.text:00000FF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000FF8
.text:00000FF8 ; =============== S U B R O U T I N E =======================================
.text:00000FF8
.text:00000FF8 ; Attributes: bp-based frame
.text:00000FF8
.text:00000FF8 ; public: __thiscall CObjectVector<class UString>::~CObjectVector<class UString>(void)
.text:00000FF8                 public ??1?$CObjectVector@VUString@@@@QAE@XZ
.text:00000FF8 ??1?$CObjectVector@VUString@@@@QAE@XZ proc near
.text:00000FF8                                         ; CODE XREF: NCommandLineParser::CParser::~CParser(void)+96p
.text:00000FF8                                         ; __unwindfunclet$??0CParser@NCommandLineParser@@QAE@I@Z$0+6j ...
.text:00000FF8
.text:00000FF8 var_20          = dword ptr -20h
.text:00000FF8 var_1C          = dword ptr -1Ch
.text:00000FF8 var_18          = dword ptr -18h
.text:00000FF8 var_14          = dword ptr -14h
.text:00000FF8 var_10          = dword ptr -10h
.text:00000FF8 var_C           = dword ptr -0Ch
.text:00000FF8 var_4           = dword ptr -4
.text:00000FF8
.text:00000FF8                 push    ebp
.text:00000FF9                 mov     ebp, esp
.text:00000FFB                 push    0FFFFFFFFh
.text:00000FFD                 push    offset __ehhandler$??1?$CObjectVector@VUString@@@@QAE@XZ
.text:00001002                 mov     eax, large fs:0
.text:00001008                 push    eax
.text:00001009                 sub     esp, 14h
.text:0000100C                 mov     eax, 0CCCCCCCCh
.text:00001011                 mov     [ebp+var_20], eax
.text:00001014                 mov     [ebp+var_1C], eax
.text:00001017                 mov     [ebp+var_18], eax
.text:0000101A                 mov     [ebp+var_14], eax
.text:0000101D                 mov     [ebp+var_10], eax
.text:00001020                 mov     eax, dword ptr ds:___security_cookie
.text:00001025                 xor     eax, ebp
.text:00001027                 push    eax
.text:00001028                 lea     eax, [ebp+var_C]
.text:0000102B                 mov     large fs:0, eax
.text:00001031                 mov     [ebp+var_10], ecx
.text:00001034                 mov     [ebp+var_4], 0
.text:0000103B                 mov     ecx, [ebp+var_10]
.text:0000103E                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00001043                 mov     [ebp+var_14], eax
.text:00001046
.text:00001046 loc_1046:                               ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void):loc_1088j
.text:00001046                 cmp     [ebp+var_14], 0
.text:0000104A                 jz      short loc_108A
.text:0000104C                 mov     eax, [ebp+var_14]
.text:0000104F                 sub     eax, 1
.text:00001052                 mov     [ebp+var_14], eax
.text:00001055                 mov     ecx, [ebp+var_14]
.text:00001058                 push    ecx
.text:00001059                 mov     ecx, [ebp+var_10]
.text:0000105C                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00001061                 mov     edx, [eax]
.text:00001063                 mov     [ebp+var_1C], edx
.text:00001066                 mov     eax, [ebp+var_1C]
.text:00001069                 mov     [ebp+var_18], eax
.text:0000106C                 cmp     [ebp+var_18], 0
.text:00001070                 jz      short loc_1081
.text:00001072                 push    1
.text:00001074                 mov     ecx, [ebp+var_18]
.text:00001077                 call    ??_GUString@@QAEPAXI@Z ; UString::`scalar deleting destructor'(uint)
.text:0000107C                 mov     [ebp+var_20], eax
.text:0000107F                 jmp     short loc_1088
.text:00001081 ; ---------------------------------------------------------------------------
.text:00001081
.text:00001081 loc_1081:                               ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+78j
.text:00001081                 mov     [ebp+var_20], 0
.text:00001088
.text:00001088 loc_1088:                               ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+87j
.text:00001088                 jmp     short loc_1046
.text:0000108A ; ---------------------------------------------------------------------------
.text:0000108A
.text:0000108A loc_108A:                               ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+52j
.text:0000108A                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001091                 mov     ecx, [ebp+var_10]
.text:00001094                 call    ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text:00001099                 mov     ecx, [ebp+var_C]
.text:0000109C                 mov     large fs:0, ecx
.text:000010A3                 pop     ecx
.text:000010A4                 add     esp, 20h
.text:000010A7                 cmp     ebp, esp
.text:000010A9                 call    __RTC_CheckEsp
.text:000010AE                 mov     esp, ebp
.text:000010B0                 pop     ebp
.text:000010B1                 retn
.text:000010B1 ??1?$CObjectVector@VUString@@@@QAE@XZ endp
.text:000010B1
.text:000010B1 ; ---------------------------------------------------------------------------
.text:000010B2                 align 4
.text:000010B2 _text           ends
.text:000010B2
.text$x:000010B4 ; ===========================================================================
.text$x:000010B4
.text$x:000010B4 ; Segment type: Pure code
.text$x:000010B4 ; Segment permissions: Read/Execute
.text$x:000010B4 _text$x         segment para public 'CODE' use32
.text$x:000010B4                 assume cs:_text$x
.text$x:000010B4                 ;org 10B4h
.text$x:000010B4 ; COMDAT (pick associative to section at FF8)
.text$x:000010B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000010B4
.text$x:000010B4 ; =============== S U B R O U T I N E =======================================
.text$x:000010B4
.text$x:000010B4
.text$x:000010B4 __unwindfunclet$??1?$CObjectVector@VUString@@@@QAE@XZ$0 proc near
.text$x:000010B4                                         ; DATA XREF: .xdata$x:000010DCo
.text$x:000010B4                 mov     ecx, [ebp-10h]
.text$x:000010B7                 jmp     ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text$x:000010B7 __unwindfunclet$??1?$CObjectVector@VUString@@@@QAE@XZ$0 endp
.text$x:000010B7
.text$x:000010BC
.text$x:000010BC ; =============== S U B R O U T I N E =======================================
.text$x:000010BC
.text$x:000010BC
.text$x:000010BC __ehhandler$??1?$CObjectVector@VUString@@@@QAE@XZ proc near
.text$x:000010BC                                         ; DATA XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+5o
.text$x:000010BC
.text$x:000010BC arg_4           = dword ptr  8
.text$x:000010BC
.text$x:000010BC                 mov     edx, [esp+arg_4]
.text$x:000010C0                 lea     eax, [edx+0Ch]
.text$x:000010C3                 mov     ecx, [edx-18h]
.text$x:000010C6                 xor     ecx, eax
.text$x:000010C8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000010CD                 mov     eax, offset __ehfuncinfo$??1?$CObjectVector@VUString@@@@QAE@XZ
.text$x:000010D2                 jmp     ___CxxFrameHandler3
.text$x:000010D2 __ehhandler$??1?$CObjectVector@VUString@@@@QAE@XZ endp
.text$x:000010D2
.text$x:000010D2 ; ---------------------------------------------------------------------------
.text$x:000010D7                 align 4
.text$x:000010D7 _text$x         ends
.text$x:000010D7
.xdata$x:000010D8 ; ===========================================================================
.xdata$x:000010D8
.xdata$x:000010D8 ; Segment type: Pure data
.xdata$x:000010D8 ; Segment permissions: Read
.xdata$x:000010D8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000010D8                 assume cs:_xdata$x
.xdata$x:000010D8                 ;org 10D8h
.xdata$x:000010D8 ; COMDAT (pick associative to section at FF8)
.xdata$x:000010D8 __unwindtable$??1?$CObjectVector@VUString@@@@QAE@XZ db 0FFh
.xdata$x:000010D8                                         ; DATA XREF: .xdata$x:000010E8o
.xdata$x:000010D9                 db 0FFh
.xdata$x:000010DA                 db 0FFh
.xdata$x:000010DB                 db 0FFh
.xdata$x:000010DC                 dd offset __unwindfunclet$??1?$CObjectVector@VUString@@@@QAE@XZ$0
.xdata$x:000010E0 __ehfuncinfo$??1?$CObjectVector@VUString@@@@QAE@XZ db  22h ; "
.xdata$x:000010E0                                         ; DATA XREF: __ehhandler$??1?$CObjectVector@VUString@@@@QAE@XZ+11o
.xdata$x:000010E1                 db    5
.xdata$x:000010E2                 db  93h ; ô
.xdata$x:000010E3                 db  19h
.xdata$x:000010E4                 db    1
.xdata$x:000010E5                 db    0
.xdata$x:000010E6                 db    0
.xdata$x:000010E7                 db    0
.xdata$x:000010E8                 dd offset __unwindtable$??1?$CObjectVector@VUString@@@@QAE@XZ
.xdata$x:000010EC                 align 20h
.xdata$x:00001100                 db    1
.xdata$x:00001101                 db    0
.xdata$x:00001102                 db    0
.xdata$x:00001103                 db    0
.xdata$x:00001103 _xdata$x        ends
.xdata$x:00001103
.text:00001104 ; ===========================================================================
.text:00001104
.text:00001104 ; Segment type: Pure code
.text:00001104 ; Segment permissions: Read/Execute
.text:00001104 _text           segment para public 'CODE' use32
.text:00001104                 assume cs:_text
.text:00001104                 ;org 1104h
.text:00001104 ; COMDAT (pick any)
.text:00001104                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001104
.text:00001104 ; =============== S U B R O U T I N E =======================================
.text:00001104
.text:00001104 ; Attributes: bp-based frame
.text:00001104
.text:00001104 ; public: void __thiscall CObjectVector<class UString>::Clear(void)
.text:00001104                 public ?Clear@?$CObjectVector@VUString@@@@QAEXXZ
.text:00001104 ?Clear@?$CObjectVector@VUString@@@@QAEXXZ proc near
.text:00001104                                         ; CODE XREF: NCommandLineParser::SplitCommandLine(UString const &,CObjectVector<UString> &)+53p
.text:00001104
.text:00001104 var_14          = dword ptr -14h
.text:00001104 var_10          = dword ptr -10h
.text:00001104 var_C           = dword ptr -0Ch
.text:00001104 var_8           = dword ptr -8
.text:00001104 var_4           = dword ptr -4
.text:00001104
.text:00001104                 push    ebp
.text:00001105                 mov     ebp, esp
.text:00001107                 sub     esp, 14h
.text:0000110A                 mov     eax, 0CCCCCCCCh
.text:0000110F                 mov     [ebp+var_14], eax
.text:00001112                 mov     [ebp+var_10], eax
.text:00001115                 mov     [ebp+var_C], eax
.text:00001118                 mov     [ebp+var_8], eax
.text:0000111B                 mov     [ebp+var_4], eax
.text:0000111E                 mov     [ebp+var_4], ecx
.text:00001121                 mov     ecx, [ebp+var_4]
.text:00001124                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00001129                 mov     [ebp+var_8], eax
.text:0000112C
.text:0000112C loc_112C:                               ; CODE XREF: CObjectVector<UString>::Clear(void):loc_116Ej
.text:0000112C                 cmp     [ebp+var_8], 0
.text:00001130                 jz      short loc_1170
.text:00001132                 mov     eax, [ebp+var_8]
.text:00001135                 sub     eax, 1
.text:00001138                 mov     [ebp+var_8], eax
.text:0000113B                 mov     ecx, [ebp+var_8]
.text:0000113E                 push    ecx
.text:0000113F                 mov     ecx, [ebp+var_4]
.text:00001142                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00001147                 mov     edx, [eax]
.text:00001149                 mov     [ebp+var_10], edx
.text:0000114C                 mov     eax, [ebp+var_10]
.text:0000114F                 mov     [ebp+var_C], eax
.text:00001152                 cmp     [ebp+var_C], 0
.text:00001156                 jz      short loc_1167
.text:00001158                 push    1
.text:0000115A                 mov     ecx, [ebp+var_C]
.text:0000115D                 call    ??_GUString@@QAEPAXI@Z ; UString::`scalar deleting destructor'(uint)
.text:00001162                 mov     [ebp+var_14], eax
.text:00001165                 jmp     short loc_116E
.text:00001167 ; ---------------------------------------------------------------------------
.text:00001167
.text:00001167 loc_1167:                               ; CODE XREF: CObjectVector<UString>::Clear(void)+52j
.text:00001167                 mov     [ebp+var_14], 0
.text:0000116E
.text:0000116E loc_116E:                               ; CODE XREF: CObjectVector<UString>::Clear(void)+61j
.text:0000116E                 jmp     short loc_112C
.text:00001170 ; ---------------------------------------------------------------------------
.text:00001170
.text:00001170 loc_1170:                               ; CODE XREF: CObjectVector<UString>::Clear(void)+2Cj
.text:00001170                 mov     ecx, [ebp+var_4]
.text:00001173                 call    ?Clear@?$CRecordVector@PAX@@QAEXXZ ; CRecordVector<void *>::Clear(void)
.text:00001178                 add     esp, 14h
.text:0000117B                 cmp     ebp, esp
.text:0000117D                 call    __RTC_CheckEsp
.text:00001182                 mov     esp, ebp
.text:00001184                 pop     ebp
.text:00001185                 retn
.text:00001185 ?Clear@?$CObjectVector@VUString@@@@QAEXXZ endp
.text:00001185
.text:00001185 ; ---------------------------------------------------------------------------
.text:00001186                 align 4
.text:00001186 _text           ends
.text:00001186
.text:00001188 ; ===========================================================================
.text:00001188
.text:00001188 ; Segment type: Pure code
.text:00001188 ; Segment permissions: Read/Execute
.text:00001188 _text           segment para public 'CODE' use32
.text:00001188                 assume cs:_text
.text:00001188                 ;org 1188h
.text:00001188 ; COMDAT (pick any)
.text:00001188                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001188
.text:00001188 ; =============== S U B R O U T I N E =======================================
.text:00001188
.text:00001188 ; Attributes: bp-based frame
.text:00001188
.text:00001188 ; public: void * __thiscall UString::`scalar deleting destructor'(unsigned int)
.text:00001188                 public ??_GUString@@QAEPAXI@Z
.text:00001188 ??_GUString@@QAEPAXI@Z proc near        ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+7Fp
.text:00001188                                         ; CObjectVector<UString>::Clear(void)+59p
.text:00001188
.text:00001188 var_4           = dword ptr -4
.text:00001188 arg_0           = dword ptr  8
.text:00001188
.text:00001188                 push    ebp
.text:00001189                 mov     ebp, esp
.text:0000118B                 push    ecx
.text:0000118C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001193                 mov     [ebp+var_4], ecx
.text:00001196                 mov     ecx, [ebp+var_4] ; this
.text:00001199                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000119E                 mov     eax, [ebp+arg_0]
.text:000011A1                 and     eax, 1
.text:000011A4                 jz      short loc_11B2
.text:000011A6                 mov     ecx, [ebp+var_4]
.text:000011A9                 push    ecx             ; void *
.text:000011AA                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:000011AF                 add     esp, 4
.text:000011B2
.text:000011B2 loc_11B2:                               ; CODE XREF: UString::`scalar deleting destructor'(uint)+1Cj
.text:000011B2                 mov     eax, [ebp+var_4]
.text:000011B5                 add     esp, 4
.text:000011B8                 cmp     ebp, esp
.text:000011BA                 call    __RTC_CheckEsp
.text:000011BF                 mov     esp, ebp
.text:000011C1                 pop     ebp
.text:000011C2                 retn    4
.text:000011C2 ??_GUString@@QAEPAXI@Z endp
.text:000011C2
.text:000011C2 ; ---------------------------------------------------------------------------
.text:000011C5                 align 4
.text:000011C5 _text           ends
.text:000011C5
.text:000011C8 ; ===========================================================================
.text:000011C8
.text:000011C8 ; Segment type: Pure code
.text:000011C8 ; Segment permissions: Read/Execute
.text:000011C8 _text           segment para public 'CODE' use32
.text:000011C8                 assume cs:_text
.text:000011C8                 ;org 11C8h
.text:000011C8 ; COMDAT (pick any)
.text:000011C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000011C8
.text:000011C8 ; =============== S U B R O U T I N E =======================================
.text:000011C8
.text:000011C8 ; Attributes: bp-based frame
.text:000011C8
.text:000011C8 ; public: __thiscall CRecordVector<void *>::CRecordVector<void *>(void)
.text:000011C8                 public ??0?$CRecordVector@PAX@@QAE@XZ
.text:000011C8 ??0?$CRecordVector@PAX@@QAE@XZ proc near
.text:000011C8                                         ; CODE XREF: CObjectVector<UString>::CObjectVector<UString>(void)+11p
.text:000011C8
.text:000011C8 var_4           = dword ptr -4
.text:000011C8
.text:000011C8                 push    ebp
.text:000011C9                 mov     ebp, esp
.text:000011CB                 push    ecx
.text:000011CC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000011D3                 mov     [ebp+var_4], ecx
.text:000011D6                 mov     eax, [ebp+var_4]
.text:000011D9                 mov     dword ptr [eax], 0
.text:000011DF                 mov     ecx, [ebp+var_4]
.text:000011E2                 mov     dword ptr [ecx+4], 0
.text:000011E9                 mov     edx, [ebp+var_4]
.text:000011EC                 mov     dword ptr [edx+8], 0
.text:000011F3                 mov     eax, [ebp+var_4]
.text:000011F6                 mov     esp, ebp
.text:000011F8                 pop     ebp
.text:000011F9                 retn
.text:000011F9 ??0?$CRecordVector@PAX@@QAE@XZ endp
.text:000011F9
.text:000011F9 ; ---------------------------------------------------------------------------
.text:000011FA                 align 4
.text:000011FA _text           ends
.text:000011FA
.text:000011FC ; ===========================================================================
.text:000011FC
.text:000011FC ; Segment type: Pure code
.text:000011FC ; Segment permissions: Read/Execute
.text:000011FC _text           segment para public 'CODE' use32
.text:000011FC                 assume cs:_text
.text:000011FC                 ;org 11FCh
.text:000011FC ; COMDAT (pick any)
.text:000011FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000011FC
.text:000011FC ; =============== S U B R O U T I N E =======================================
.text:000011FC
.text:000011FC ; Attributes: bp-based frame
.text:000011FC
.text:000011FC ; public: unsigned int __thiscall CRecordVector<void *>::Size(void)const
.text:000011FC                 public ?Size@?$CRecordVector@PAX@@QBEIXZ
.text:000011FC ?Size@?$CRecordVector@PAX@@QBEIXZ proc near
.text:000011FC                                         ; CODE XREF: CObjectVector<UString>::Size(void)+11p
.text:000011FC                                         ; CObjectVector<UString>::~CObjectVector<UString>(void)+46p ...
.text:000011FC
.text:000011FC var_4           = dword ptr -4
.text:000011FC
.text:000011FC                 push    ebp
.text:000011FD                 mov     ebp, esp
.text:000011FF                 push    ecx
.text:00001200                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001207                 mov     [ebp+var_4], ecx
.text:0000120A                 mov     eax, [ebp+var_4]
.text:0000120D                 mov     eax, [eax+4]
.text:00001210                 mov     esp, ebp
.text:00001212                 pop     ebp
.text:00001213                 retn
.text:00001213 ?Size@?$CRecordVector@PAX@@QBEIXZ endp
.text:00001213
.text:00001213 _text           ends
.text:00001213
.text:00001214 ; ===========================================================================
.text:00001214
.text:00001214 ; Segment type: Pure code
.text:00001214 ; Segment permissions: Read/Execute
.text:00001214 _text           segment para public 'CODE' use32
.text:00001214                 assume cs:_text
.text:00001214                 ;org 1214h
.text:00001214 ; COMDAT (pick any)
.text:00001214                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001214
.text:00001214 ; =============== S U B R O U T I N E =======================================
.text:00001214
.text:00001214 ; Attributes: bp-based frame
.text:00001214
.text:00001214 ; public: __thiscall CRecordVector<void *>::~CRecordVector<void *>(void)
.text:00001214                 public ??1?$CRecordVector@PAX@@QAE@XZ
.text:00001214 ??1?$CRecordVector@PAX@@QAE@XZ proc near
.text:00001214                                         ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+9Cp
.text:00001214                                         ; __unwindfunclet$??1?$CObjectVector@VUString@@@@QAE@XZ$0+3j
.text:00001214
.text:00001214 var_8           = dword ptr -8
.text:00001214 var_4           = dword ptr -4
.text:00001214
.text:00001214                 push    ebp
.text:00001215                 mov     ebp, esp
.text:00001217                 sub     esp, 8
.text:0000121A                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00001221                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001228                 mov     [ebp+var_4], ecx
.text:0000122B                 mov     eax, [ebp+var_4]
.text:0000122E                 mov     ecx, [eax]
.text:00001230                 mov     [ebp+var_8], ecx
.text:00001233                 mov     edx, [ebp+var_8]
.text:00001236                 push    edx             ; void *
.text:00001237                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000123C                 add     esp, 4
.text:0000123F                 add     esp, 8
.text:00001242                 cmp     ebp, esp
.text:00001244                 call    __RTC_CheckEsp
.text:00001249                 mov     esp, ebp
.text:0000124B                 pop     ebp
.text:0000124C                 retn
.text:0000124C ??1?$CRecordVector@PAX@@QAE@XZ endp
.text:0000124C
.text:0000124C ; ---------------------------------------------------------------------------
.text:0000124D                 align 10h
.text:0000124D _text           ends
.text:0000124D
.text:00001250 ; ===========================================================================
.text:00001250
.text:00001250 ; Segment type: Pure code
.text:00001250 ; Segment permissions: Read/Execute
.text:00001250 _text           segment para public 'CODE' use32
.text:00001250                 assume cs:_text
.text:00001250                 ;org 1250h
.text:00001250 ; COMDAT (pick any)
.text:00001250                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001250
.text:00001250 ; =============== S U B R O U T I N E =======================================
.text:00001250
.text:00001250 ; Attributes: bp-based frame
.text:00001250
.text:00001250 ; public: void __thiscall CRecordVector<void *>::Clear(void)
.text:00001250                 public ?Clear@?$CRecordVector@PAX@@QAEXXZ
.text:00001250 ?Clear@?$CRecordVector@PAX@@QAEXXZ proc near
.text:00001250                                         ; CODE XREF: CObjectVector<UString>::Clear(void)+6Fp
.text:00001250
.text:00001250 var_4           = dword ptr -4
.text:00001250
.text:00001250                 push    ebp
.text:00001251                 mov     ebp, esp
.text:00001253                 push    ecx
.text:00001254                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000125B                 mov     [ebp+var_4], ecx
.text:0000125E                 mov     eax, [ebp+var_4]
.text:00001261                 mov     dword ptr [eax+4], 0
.text:00001268                 mov     esp, ebp
.text:0000126A                 pop     ebp
.text:0000126B                 retn
.text:0000126B ?Clear@?$CRecordVector@PAX@@QAEXXZ endp
.text:0000126B
.text:0000126B _text           ends
.text:0000126B
.text:0000126C ; ===========================================================================
.text:0000126C
.text:0000126C ; Segment type: Pure code
.text:0000126C ; Segment permissions: Read/Execute
.text:0000126C _text           segment para public 'CODE' use32
.text:0000126C                 assume cs:_text
.text:0000126C                 ;org 126Ch
.text:0000126C ; COMDAT (pick any)
.text:0000126C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000126C
.text:0000126C ; =============== S U B R O U T I N E =======================================
.text:0000126C
.text:0000126C ; Attributes: bp-based frame
.text:0000126C
.text:0000126C ; public: unsigned int __thiscall CRecordVector<void *>::Add(void * const)
.text:0000126C                 public ?Add@?$CRecordVector@PAX@@QAEIQAX@Z
.text:0000126C ?Add@?$CRecordVector@PAX@@QAEIQAX@Z proc near
.text:0000126C                                         ; CODE XREF: CObjectVector<UString>::Add(UString const &)+7Fp
.text:0000126C
.text:0000126C var_8           = dword ptr -8
.text:0000126C var_4           = dword ptr -4
.text:0000126C arg_0           = dword ptr  8
.text:0000126C
.text:0000126C                 push    ebp
.text:0000126D                 mov     ebp, esp
.text:0000126F                 sub     esp, 8
.text:00001272                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00001279                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001280                 mov     [ebp+var_4], ecx
.text:00001283                 mov     ecx, [ebp+var_4]
.text:00001286                 call    ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ ; CRecordVector<void *>::ReserveOnePosition(void)
.text:0000128B                 mov     eax, [ebp+var_4]
.text:0000128E                 mov     ecx, [eax+4]
.text:00001291                 mov     edx, [ebp+var_4]
.text:00001294                 mov     eax, [edx]
.text:00001296                 mov     edx, [ebp+arg_0]
.text:00001299                 mov     [eax+ecx*4], edx
.text:0000129C                 mov     eax, [ebp+var_4]
.text:0000129F                 mov     ecx, [eax+4]
.text:000012A2                 mov     [ebp+var_8], ecx
.text:000012A5                 mov     edx, [ebp+var_4]
.text:000012A8                 mov     eax, [edx+4]
.text:000012AB                 add     eax, 1
.text:000012AE                 mov     ecx, [ebp+var_4]
.text:000012B1                 mov     [ecx+4], eax
.text:000012B4                 mov     eax, [ebp+var_8]
.text:000012B7                 add     esp, 8
.text:000012BA                 cmp     ebp, esp
.text:000012BC                 call    __RTC_CheckEsp
.text:000012C1                 mov     esp, ebp
.text:000012C3                 pop     ebp
.text:000012C4                 retn    4
.text:000012C4 ?Add@?$CRecordVector@PAX@@QAEIQAX@Z endp
.text:000012C4
.text:000012C4 ; ---------------------------------------------------------------------------
.text:000012C7                 align 4
.text:000012C7 _text           ends
.text:000012C7
.text:000012C8 ; ===========================================================================
.text:000012C8
.text:000012C8 ; Segment type: Pure code
.text:000012C8 ; Segment permissions: Read/Execute
.text:000012C8 _text           segment para public 'CODE' use32
.text:000012C8                 assume cs:_text
.text:000012C8                 ;org 12C8h
.text:000012C8 ; COMDAT (pick any)
.text:000012C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000012C8
.text:000012C8 ; =============== S U B R O U T I N E =======================================
.text:000012C8
.text:000012C8 ; Attributes: bp-based frame
.text:000012C8
.text:000012C8 ; public: void * const & __thiscall CRecordVector<void *>::operator[](unsigned int)const
.text:000012C8                 public ??A?$CRecordVector@PAX@@QBEABQAXI@Z
.text:000012C8 ??A?$CRecordVector@PAX@@QBEABQAXI@Z proc near
.text:000012C8                                         ; CODE XREF: CObjectVector<UString>::operator[](uint)+15p
.text:000012C8
.text:000012C8 var_4           = dword ptr -4
.text:000012C8 arg_0           = dword ptr  8
.text:000012C8
.text:000012C8                 push    ebp
.text:000012C9                 mov     ebp, esp
.text:000012CB                 push    ecx
.text:000012CC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000012D3                 mov     [ebp+var_4], ecx
.text:000012D6                 mov     eax, [ebp+var_4]
.text:000012D9                 mov     ecx, [eax]
.text:000012DB                 mov     edx, [ebp+arg_0]
.text:000012DE                 lea     eax, [ecx+edx*4]
.text:000012E1                 mov     esp, ebp
.text:000012E3                 pop     ebp
.text:000012E4                 retn    4
.text:000012E4 ??A?$CRecordVector@PAX@@QBEABQAXI@Z endp
.text:000012E4
.text:000012E4 ; ---------------------------------------------------------------------------
.text:000012E7                 align 4
.text:000012E7 _text           ends
.text:000012E7
.text:000012E8 ; ===========================================================================
.text:000012E8
.text:000012E8 ; Segment type: Pure code
.text:000012E8 ; Segment permissions: Read/Execute
.text:000012E8 _text           segment para public 'CODE' use32
.text:000012E8                 assume cs:_text
.text:000012E8                 ;org 12E8h
.text:000012E8 ; COMDAT (pick any)
.text:000012E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000012E8
.text:000012E8 ; =============== S U B R O U T I N E =======================================
.text:000012E8
.text:000012E8 ; Attributes: bp-based frame
.text:000012E8
.text:000012E8 ; public: void * & __thiscall CRecordVector<void *>::operator[](unsigned int)
.text:000012E8                 public ??A?$CRecordVector@PAX@@QAEAAPAXI@Z
.text:000012E8 ??A?$CRecordVector@PAX@@QAEAAPAXI@Z proc near
.text:000012E8                                         ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+64p
.text:000012E8                                         ; CObjectVector<UString>::Clear(void)+3Ep
.text:000012E8
.text:000012E8 var_4           = dword ptr -4
.text:000012E8 arg_0           = dword ptr  8
.text:000012E8
.text:000012E8                 push    ebp
.text:000012E9                 mov     ebp, esp
.text:000012EB                 push    ecx
.text:000012EC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000012F3                 mov     [ebp+var_4], ecx
.text:000012F6                 mov     eax, [ebp+var_4]
.text:000012F9                 mov     ecx, [eax]
.text:000012FB                 mov     edx, [ebp+arg_0]
.text:000012FE                 lea     eax, [ecx+edx*4]
.text:00001301                 mov     esp, ebp
.text:00001303                 pop     ebp
.text:00001304                 retn    4
.text:00001304 ??A?$CRecordVector@PAX@@QAEAAPAXI@Z endp
.text:00001304
.text:00001304 ; ---------------------------------------------------------------------------
.text:00001307                 align 4
.text:00001307 _text           ends
.text:00001307
.text:00001308 ; ===========================================================================
.text:00001308
.text:00001308 ; Segment type: Pure code
.text:00001308 ; Segment permissions: Read/Execute
.text:00001308 _text           segment para public 'CODE' use32
.text:00001308                 assume cs:_text
.text:00001308                 ;org 1308h
.text:00001308 ; COMDAT (pick any)
.text:00001308                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001308
.text:00001308 ; =============== S U B R O U T I N E =======================================
.text:00001308
.text:00001308 ; Attributes: bp-based frame
.text:00001308
.text:00001308 ; private: void __thiscall CRecordVector<void *>::ReserveOnePosition(void)
.text:00001308                 public ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ
.text:00001308 ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ proc near
.text:00001308                                         ; CODE XREF: CRecordVector<void *>::Add(void * const)+1Ap
.text:00001308
.text:00001308 var_14          = dword ptr -14h
.text:00001308 var_10          = dword ptr -10h
.text:00001308 Dst             = dword ptr -0Ch
.text:00001308 var_8           = dword ptr -8
.text:00001308 var_4           = dword ptr -4
.text:00001308
.text:00001308                 push    ebp
.text:00001309                 mov     ebp, esp
.text:0000130B                 sub     esp, 14h
.text:0000130E                 mov     eax, 0CCCCCCCCh
.text:00001313                 mov     [ebp+var_14], eax
.text:00001316                 mov     [ebp+var_10], eax
.text:00001319                 mov     [ebp+Dst], eax
.text:0000131C                 mov     [ebp+var_8], eax
.text:0000131F                 mov     [ebp+var_4], eax
.text:00001322                 mov     [ebp+var_4], ecx
.text:00001325                 mov     eax, [ebp+var_4]
.text:00001328                 mov     ecx, [ebp+var_4]
.text:0000132B                 mov     edx, [eax+4]
.text:0000132E                 cmp     edx, [ecx+8]
.text:00001331                 jnz     loc_13BC
.text:00001337                 mov     eax, [ebp+var_4]
.text:0000133A                 mov     ecx, [eax+8]
.text:0000133D                 shr     ecx, 2
.text:00001340                 mov     edx, [ebp+var_4]
.text:00001343                 mov     eax, [edx+8]
.text:00001346                 lea     ecx, [eax+ecx+1]
.text:0000134A                 mov     [ebp+var_8], ecx
.text:0000134D                 xor     ecx, ecx
.text:0000134F                 mov     eax, [ebp+var_8]
.text:00001352                 mov     edx, 4
.text:00001357                 mul     edx
.text:00001359                 seto    cl
.text:0000135C                 neg     ecx
.text:0000135E                 or      ecx, eax
.text:00001360                 push    ecx             ; unsigned int
.text:00001361                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00001366                 add     esp, 4
.text:00001369                 mov     [ebp+var_10], eax
.text:0000136C                 mov     eax, [ebp+var_10]
.text:0000136F                 mov     [ebp+Dst], eax
.text:00001372                 mov     ecx, [ebp+var_4]
.text:00001375                 cmp     dword ptr [ecx+4], 0
.text:00001379                 jz      short loc_1397
.text:0000137B                 mov     edx, [ebp+var_4]
.text:0000137E                 mov     eax, [edx+4]
.text:00001381                 shl     eax, 2
.text:00001384                 push    eax             ; Size
.text:00001385                 mov     ecx, [ebp+var_4]
.text:00001388                 mov     edx, [ecx]
.text:0000138A                 push    edx             ; Src
.text:0000138B                 mov     eax, [ebp+Dst]
.text:0000138E                 push    eax             ; Dst
.text:0000138F                 call    _memcpy
.text:00001394                 add     esp, 0Ch
.text:00001397
.text:00001397 loc_1397:                               ; CODE XREF: CRecordVector<void *>::ReserveOnePosition(void)+71j
.text:00001397                 mov     ecx, [ebp+var_4]
.text:0000139A                 mov     edx, [ecx]
.text:0000139C                 mov     [ebp+var_14], edx
.text:0000139F                 mov     eax, [ebp+var_14]
.text:000013A2                 push    eax             ; void *
.text:000013A3                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:000013A8                 add     esp, 4
.text:000013AB                 mov     ecx, [ebp+var_4]
.text:000013AE                 mov     edx, [ebp+Dst]
.text:000013B1                 mov     [ecx], edx
.text:000013B3                 mov     eax, [ebp+var_4]
.text:000013B6                 mov     ecx, [ebp+var_8]
.text:000013B9                 mov     [eax+8], ecx
.text:000013BC
.text:000013BC loc_13BC:                               ; CODE XREF: CRecordVector<void *>::ReserveOnePosition(void)+29j
.text:000013BC                 add     esp, 14h
.text:000013BF                 cmp     ebp, esp
.text:000013C1                 call    __RTC_CheckEsp
.text:000013C6                 mov     esp, ebp
.text:000013C8                 pop     ebp
.text:000013C9                 retn
.text:000013C9 ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ endp
.text:000013C9
.text:000013C9 _text           ends
.text:000013C9
UNDEF:000013D0 ; ===========================================================================
UNDEF:000013D0
UNDEF:000013D0 ; Segment type: Externs
UNDEF:000013D0 ; UNDEF
UNDEF:000013D0 ; public: class UString & __thiscall UString::operator=(wchar_t const *)
UNDEF:000013D0                 extrn ??4UString@@QAEAAV0@PB_W@Z:near
UNDEF:000013D0                                         ; CODE XREF: NCommandLineParser::SplitCommandLine(UString const &,UString &,UString &)+8Ep
UNDEF:000013D4                 extrn __RTC_CheckEsp:near
UNDEF:000013D4                                         ; CODE XREF: NCommandLineParser::SplitCommandLine(UString const &,UString &,UString &)+D7p
UNDEF:000013D4                                         ; NCommandLineParser::SplitCommandLine(UString const &,CObjectVector<UString> &)+117p ...
UNDEF:000013D8                 extrn __RTC_Shutdown:near
UNDEF:000013D8                                         ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
UNDEF:000013DC                 extrn __RTC_InitBase:near
UNDEF:000013DC                                         ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
UNDEF:000013E0 ; void __thiscall UString::Grow_1(UString *__hidden this)
UNDEF:000013E0                 extrn ?Grow_1@UString@@AAEXXZ:near
UNDEF:000013E0                                         ; CODE XREF: UString::operator+=(wchar_t)+2Fp
UNDEF:000013E4 ; public: class UString & __thiscall UString::operator=(class UString const &)
UNDEF:000013E4                 extrn ??4UString@@QAEAAV0@ABV0@@Z:near
UNDEF:000013E4                                         ; CODE XREF: NCommandLineParser::SplitCommandLine(UString const &,CObjectVector<UString> &)+C4p
UNDEF:000013E4                                         ; NCommandLineParser::CParser::ParseStrings(NCommandLineParser::CSwitchForm const *,CObjectVector<UString> const &)+CBp
UNDEF:000013E8 ; public: __thiscall UString::UString(void)
UNDEF:000013E8                 extrn ??0UString@@QAE@XZ:near
UNDEF:000013E8                                         ; CODE XREF: NCommandLineParser::SplitCommandLine(UString const &,CObjectVector<UString> &)+5Bp
UNDEF:000013E8                                         ; NCommandLineParser::SplitCommandLine(UString const &,CObjectVector<UString> &)+67p ...
UNDEF:000013EC ; public: __thiscall UString::UString(class UString const &)
UNDEF:000013EC                 extrn ??0UString@@QAE@ABV0@@Z:near
UNDEF:000013EC                                         ; CODE XREF: NCommandLineParser::SplitCommandLine(UString const &,CObjectVector<UString> &)+3Cp
UNDEF:000013EC                                         ; CObjectVector<UString>::Add(UString const &)+5Ap
UNDEF:000013F0                 extrn ___security_cookie:near
UNDEF:000013F0                                         ; DATA XREF: NCommandLineParser::SplitCommandLine(UString const &,CObjectVector<UString> &)+24r
UNDEF:000013F0                                         ; NCommandLineParser::CParser::CParser(uint)+28r ...
UNDEF:000013F4                 extrn ___CxxFrameHandler3:near
UNDEF:000013F4                                         ; CODE XREF: __ehhandler$?SplitCommandLine@NCommandLineParser@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z+16j
UNDEF:000013F4                                         ; __ehhandler$??0CParser@NCommandLineParser@@QAE@I@Z+16j ...
UNDEF:000013F8 ; __fastcall __security_check_cookie(x)
UNDEF:000013F8                 extrn @__security_check_cookie@4:near
UNDEF:000013F8                                         ; CODE XREF: __ehhandler$?SplitCommandLine@NCommandLineParser@@YGXABVUString@@AAV?$CObjectVector@VUString@@@@@Z+Cp
UNDEF:000013F8                                         ; __ehhandler$??0CParser@NCommandLineParser@@QAE@I@Z+Cp ...
UNDEF:000013FC ; __fastcall _RTC_CheckStackVars(x, x)
UNDEF:000013FC                 extrn @_RTC_CheckStackVars@8:near
UNDEF:000013FC                                         ; CODE XREF: NCommandLineParser::SplitCommandLine(UString const &,CObjectVector<UString> &)+FFp
UNDEF:00001400 ; void __cdecl operator delete(void *)
UNDEF:00001400                 extrn ??3@YAXPAX@Z:near ; CODE XREF: __unwindfunclet$??0CParser@NCommandLineParser@@QAE@I@Z$3+4p
UNDEF:00001400                                         ; UString::~UString(void)+23p ...
UNDEF:00001404 ; void __thiscall UString::TrimLeft(UString *__hidden this)
UNDEF:00001404                 extrn ?TrimLeft@UString@@QAEXXZ:near
UNDEF:00001404                                         ; CODE XREF: UString::Trim(void)+19p
UNDEF:00001408 ; void __thiscall UString::TrimRight(UString *__hidden this)
UNDEF:00001408                 extrn ?TrimRight@UString@@QAEXXZ:near
UNDEF:00001408                                         ; CODE XREF: UString::Trim(void)+11p
UNDEF:0000140C ; void __stdcall `eh vector constructor iterator'(void *, unsigned int, int, void (__thiscall *)(void *), void (__thiscall *)(void *))
UNDEF:0000140C                 extrn ??_L@YGXPAXIHP6EX0@Z1@Z:near
UNDEF:0000140C                                         ; CODE XREF: NCommandLineParser::CParser::CParser(uint)+D8p
UNDEF:00001410 ; void *__cdecl operator new(unsigned int)
UNDEF:00001410                 extrn ??2@YAPAXI@Z:near ; CODE XREF: NCommandLineParser::CParser::CParser(uint)+A4p
UNDEF:00001410                                         ; CObjectVector<UString>::Add(UString const &)+3Bp ...
UNDEF:00001414 ; _DWORD __thiscall AString::AString(AString *__hidden this)
UNDEF:00001414                 extrn ??0AString@@QAE@XZ:near
UNDEF:00001414                                         ; CODE XREF: NCommandLineParser::CParser::CParser(uint)+66p
UNDEF:00001418 ; void __stdcall `eh vector destructor iterator'(void *, unsigned int, int, void (__thiscall *)(void *))
UNDEF:00001418                 extrn ??_M@YGXPAXIHP6EX0@Z@Z:near
UNDEF:00001418                                         ; CODE XREF: NCommandLineParser::CSwitchResult::`vector deleting destructor'(uint)+28p
UNDEF:0000141C ; public: __thiscall UString::UString(wchar_t const *)
UNDEF:0000141C                 extrn ??0UString@@QAE@PB_W@Z:near
UNDEF:0000141C                                         ; CODE XREF: NCommandLineParser::CParser::ParseString(UString const &,NCommandLineParser::CSwitchForm const *)+296p
UNDEF:00001420 ; int __stdcall FindCharPosInString(const char *, char)
UNDEF:00001420                 extrn ?FindCharPosInString@@YGHPBDD@Z:near
UNDEF:00001420                                         ; CODE XREF: NCommandLineParser::CParser::ParseString(UString const &,NCommandLineParser::CSwitchForm const *)+256p
UNDEF:00001424 ; public: class AString & __thiscall AString::operator=(char const *)
UNDEF:00001424                 extrn ??4AString@@QAEAAV0@PBD@Z:near
UNDEF:00001424                                         ; CODE XREF: NCommandLineParser::CParser::ParseString(UString const &,NCommandLineParser::CSwitchForm const *)+10Fp
UNDEF:00001424                                         ; NCommandLineParser::CParser::ParseString(UString const &,NCommandLineParser::CSwitchForm const *)+15Fp ...
UNDEF:00001428 ; bool __stdcall StringsAreEqual_Ascii(const wchar_t *, const char *)
UNDEF:00001428                 extrn ?StringsAreEqual_Ascii@@YG_NPB_WPBD@Z:near
UNDEF:00001428                                         ; CODE XREF: UString::IsEqualTo(char const *)+18p
UNDEF:0000142C ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:0000142C                 extrn _memcpy:near      ; CODE XREF: CRecordVector<void *>::ReserveOnePosition(void)+87p
UNDEF:0000142C
UNDEF:0000142C