.rdata:00000000 ;
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.rdata:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.rdata:00000000 ; |                      License info: 48-3677-7074-51                      |
.rdata:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ;
.rdata:00000000 ; Input MD5   : A9CC42730D2593F820DF491F2E7A0671
.rdata:00000000 ; Input CRC32 : D66E3C2F
.rdata:00000000
.rdata:00000000 ; File Name   : C:\workspace\7z1505-src\CPP\7zip\Bundles\Alone\Debug\StdOutStream.obj
.rdata:00000000 ; Format      : COFF (X386MAGIC)
.rdata:00000000 ; includelib "uuid.lib"
.rdata:00000000 ; includelib "MSVCRTD"
.rdata:00000000 ; includelib "OLDNAMES"
.rdata:00000000
.rdata:00000000                 .686p
.rdata:00000000                 .mmx
.rdata:00000000                 .model flat
.rdata:00000000
.rdata:00000000 ; ===========================================================================
.rdata:00000000
.rdata:00000000 ; Segment type: Pure data
.rdata:00000000 ; Segment permissions: Read
.rdata:00000000 _rdata          segment dword public 'DATA' use32
.rdata:00000000                 assume cs:_rdata
.rdata:00000000 $SG69876        db  77h ; w             ; DATA XREF: .data:_kFileOpenModeo
.rdata:00000001                 db  74h ; t
.rdata:00000002                 db    0
.rdata:00000003                 align 4
.rdata:00000003 _rdata          ends
.rdata:00000003
.data:00000004 ; ===========================================================================
.data:00000004
.data:00000004 ; Segment type: Pure data
.data:00000004 ; Segment permissions: Read/Write
.data:00000004 _data           segment dword public 'DATA' use32
.data:00000004                 assume cs:_data
.data:00000004                 ;org 4
.data:00000004 ; char *kFileOpenMode
.data:00000004 _kFileOpenMode  dd offset $SG69876      ; DATA XREF: CStdOutStream::Open(char const *)+19r
.data:00000004 _data           ends
.data:00000004
.text:00000008 ; ===========================================================================
.text:00000008
.text:00000008 ; Segment type: Pure code
.text:00000008 ; Segment permissions: Read/Execute
.text:00000008 _text           segment para public 'CODE' use32
.text:00000008                 assume cs:_text
.text:00000008                 ;org 8
.text:00000008                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000008
.text:00000008 ; =============== S U B R O U T I N E =======================================
.text:00000008
.text:00000008 ; Attributes: bp-based frame
.text:00000008
.text:00000008 ; bool __thiscall CStdOutStream::Open(CStdOutStream *this, const char *)
.text:00000008                 public ?Open@CStdOutStream@@QAE_NPBD@Z
.text:00000008 ?Open@CStdOutStream@@QAE_NPBD@Z proc near
.text:00000008
.text:00000008 var_4           = dword ptr -4
.text:00000008 Filename        = dword ptr  8
.text:00000008
.text:00000008                 push    ebp
.text:00000009                 mov     ebp, esp
.text:0000000B                 push    ecx
.text:0000000C                 push    esi
.text:0000000D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000014                 mov     [ebp+var_4], ecx
.text:00000017                 mov     ecx, [ebp+var_4] ; this
.text:0000001A                 call    ?Close@CStdOutStream@@QAE_NXZ ; CStdOutStream::Close(void)
.text:0000001F                 mov     esi, esp
.text:00000021                 mov     eax, ds:_kFileOpenMode
.text:00000026                 push    eax             ; Mode
.text:00000027                 mov     ecx, [ebp+Filename]
.text:0000002A                 push    ecx             ; Filename
.text:0000002B                 call    dword ptr ds:__imp__fopen
.text:00000031                 add     esp, 8
.text:00000034                 cmp     esi, esp
.text:00000036                 call    __RTC_CheckEsp
.text:0000003B                 mov     edx, [ebp+var_4]
.text:0000003E                 mov     [edx], eax
.text:00000040                 mov     eax, [ebp+var_4]
.text:00000043                 xor     ecx, ecx
.text:00000045                 cmp     dword ptr [eax], 0
.text:00000048                 setnz   cl
.text:0000004B                 mov     edx, [ebp+var_4]
.text:0000004E                 mov     [edx+4], cl
.text:00000051                 mov     eax, [ebp+var_4]
.text:00000054                 mov     al, [eax+4]
.text:00000057                 pop     esi
.text:00000058                 add     esp, 4
.text:0000005B                 cmp     ebp, esp
.text:0000005D                 call    __RTC_CheckEsp
.text:00000062                 mov     esp, ebp
.text:00000064                 pop     ebp
.text:00000065                 retn    4
.text:00000065 ?Open@CStdOutStream@@QAE_NPBD@Z endp
.text:00000065
.text:00000068
.text:00000068 ; =============== S U B R O U T I N E =======================================
.text:00000068
.text:00000068 ; Attributes: bp-based frame
.text:00000068
.text:00000068 ; bool __thiscall CStdOutStream::Close(CStdOutStream *__hidden this)
.text:00000068                 public ?Close@CStdOutStream@@QAE_NXZ
.text:00000068 ?Close@CStdOutStream@@QAE_NXZ proc near ; CODE XREF: CStdOutStream::Open(char const *)+12p
.text:00000068                                         ; CStdOutStream::~CStdOutStream(void)+11p
.text:00000068
.text:00000068 var_4           = dword ptr -4
.text:00000068
.text:00000068                 push    ebp
.text:00000069                 mov     ebp, esp
.text:0000006B                 push    ecx
.text:0000006C                 push    esi
.text:0000006D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000074                 mov     [ebp+var_4], ecx
.text:00000077                 mov     eax, [ebp+var_4]
.text:0000007A                 movzx   ecx, byte ptr [eax+4]
.text:0000007E                 test    ecx, ecx
.text:00000080                 jnz     short loc_86
.text:00000082                 mov     al, 1
.text:00000084                 jmp     short loc_B8
.text:00000086 ; ---------------------------------------------------------------------------
.text:00000086
.text:00000086 loc_86:                                 ; CODE XREF: CStdOutStream::Close(void)+18j
.text:00000086                 mov     esi, esp
.text:00000088                 mov     edx, [ebp+var_4]
.text:0000008B                 mov     eax, [edx]
.text:0000008D                 push    eax             ; File
.text:0000008E                 call    dword ptr ds:__imp__fclose
.text:00000094                 add     esp, 4
.text:00000097                 cmp     esi, esp
.text:00000099                 call    __RTC_CheckEsp
.text:0000009E                 test    eax, eax
.text:000000A0                 jz      short loc_A6
.text:000000A2                 xor     al, al
.text:000000A4                 jmp     short loc_B8
.text:000000A6 ; ---------------------------------------------------------------------------
.text:000000A6
.text:000000A6 loc_A6:                                 ; CODE XREF: CStdOutStream::Close(void)+38j
.text:000000A6                 mov     ecx, [ebp+var_4]
.text:000000A9                 mov     dword ptr [ecx], 0
.text:000000AF                 mov     edx, [ebp+var_4]
.text:000000B2                 mov     byte ptr [edx+4], 0
.text:000000B6                 mov     al, 1
.text:000000B8
.text:000000B8 loc_B8:                                 ; CODE XREF: CStdOutStream::Close(void)+1Cj
.text:000000B8                                         ; CStdOutStream::Close(void)+3Cj
.text:000000B8                 pop     esi
.text:000000B9                 add     esp, 4
.text:000000BC                 cmp     ebp, esp
.text:000000BE                 call    __RTC_CheckEsp
.text:000000C3                 mov     esp, ebp
.text:000000C5                 pop     ebp
.text:000000C6                 retn
.text:000000C6 ?Close@CStdOutStream@@QAE_NXZ endp
.text:000000C6
.text:000000C6 ; ---------------------------------------------------------------------------
.text:000000C7                 align 4
.text:000000C8
.text:000000C8 ; =============== S U B R O U T I N E =======================================
.text:000000C8
.text:000000C8 ; Attributes: bp-based frame
.text:000000C8
.text:000000C8 ; bool __thiscall CStdOutStream::Flush(CStdOutStream *__hidden this)
.text:000000C8                 public ?Flush@CStdOutStream@@QAE_NXZ
.text:000000C8 ?Flush@CStdOutStream@@QAE_NXZ proc near
.text:000000C8
.text:000000C8 var_4           = dword ptr -4
.text:000000C8
.text:000000C8                 push    ebp
.text:000000C9                 mov     ebp, esp
.text:000000CB                 push    ecx
.text:000000CC                 push    esi
.text:000000CD                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000000D4                 mov     [ebp+var_4], ecx
.text:000000D7                 mov     esi, esp
.text:000000D9                 mov     eax, [ebp+var_4]
.text:000000DC                 mov     ecx, [eax]
.text:000000DE                 push    ecx             ; File
.text:000000DF                 call    dword ptr ds:__imp__fflush
.text:000000E5                 add     esp, 4
.text:000000E8                 cmp     esi, esp
.text:000000EA                 call    __RTC_CheckEsp
.text:000000EF                 neg     eax
.text:000000F1                 sbb     eax, eax
.text:000000F3                 add     eax, 1
.text:000000F6                 pop     esi
.text:000000F7                 add     esp, 4
.text:000000FA                 cmp     ebp, esp
.text:000000FC                 call    __RTC_CheckEsp
.text:00000101                 mov     esp, ebp
.text:00000103                 pop     ebp
.text:00000104                 retn
.text:00000104 ?Flush@CStdOutStream@@QAE_NXZ endp
.text:00000104
.text:00000104 ; ---------------------------------------------------------------------------
.text:00000105                 align 4
.text:00000108
.text:00000108 ; =============== S U B R O U T I N E =======================================
.text:00000108
.text:00000108 ; Attributes: bp-based frame
.text:00000108
.text:00000108 ; struct CStdOutStream *__stdcall endl(struct CStdOutStream *)
.text:00000108                 public ?endl@@YGAAVCStdOutStream@@AAV1@@Z
.text:00000108 ?endl@@YGAAVCStdOutStream@@AAV1@@Z proc near
.text:00000108
.text:00000108 arg_0           = dword ptr  8
.text:00000108
.text:00000108                 push    ebp
.text:00000109                 mov     ebp, esp
.text:0000010B                 push    0Ah
.text:0000010D                 mov     ecx, [ebp+arg_0]
.text:00000110                 call    ??6CStdOutStream@@QAEAAV0@D@Z ; CStdOutStream::operator<<(char)
.text:00000115                 cmp     ebp, esp
.text:00000117                 call    __RTC_CheckEsp
.text:0000011C                 pop     ebp
.text:0000011D                 retn    4
.text:0000011D ?endl@@YGAAVCStdOutStream@@AAV1@@Z endp
.text:0000011D
.text:0000011D ; ---------------------------------------------------------------------------
.text:00000120                 db 8 dup(0CCh)
.text:00000128
.text:00000128 ; =============== S U B R O U T I N E =======================================
.text:00000128
.text:00000128 ; Attributes: bp-based frame
.text:00000128
.text:00000128 ; int __stdcall CStdOutStream::operator<<(wchar_t *)
.text:00000128                 public ??6CStdOutStream@@QAEAAV0@PB_W@Z
.text:00000128 ??6CStdOutStream@@QAEAAV0@PB_W@Z proc near
.text:00000128
.text:00000128 var_44          = dword ptr -44h
.text:00000128 var_40          = byte ptr -40h
.text:00000128 var_34          = byte ptr -34h
.text:00000128 var_24          = byte ptr -24h
.text:00000128 var_14          = dword ptr -14h
.text:00000128 var_10          = dword ptr -10h
.text:00000128 var_C           = dword ptr -0Ch
.text:00000128 var_4           = dword ptr -4
.text:00000128 arg_0           = dword ptr  8
.text:00000128
.text:00000128                 push    ebp
.text:00000129                 mov     ebp, esp
.text:0000012B                 push    0FFFFFFFFh
.text:0000012D                 push    offset __ehhandler$??6CStdOutStream@@QAEAAV0@PB_W@Z
.text:00000132                 mov     eax, large fs:0
.text:00000138                 push    eax
.text:00000139                 sub     esp, 38h
.text:0000013C                 push    edi
.text:0000013D                 push    ecx
.text:0000013E                 lea     edi, [ebp+var_44]
.text:00000141                 mov     ecx, 0Eh
.text:00000146                 mov     eax, 0CCCCCCCCh
.text:0000014B                 rep stosd
.text:0000014D                 pop     ecx
.text:0000014E                 mov     eax, dword ptr ds:___security_cookie
.text:00000153                 xor     eax, ebp
.text:00000155                 push    eax
.text:00000156                 lea     eax, [ebp+var_C]
.text:00000159                 mov     large fs:0, eax
.text:0000015F                 mov     [ebp+var_10], ecx
.text:00000162                 mov     eax, dword ptr ds:?g_CodePage@@3HA ; int g_CodePage
.text:00000167                 mov     [ebp+var_14], eax
.text:0000016A                 cmp     [ebp+var_14], 0FFFFFFFFh
.text:0000016E                 jnz     short loc_177
.text:00000170                 mov     [ebp+var_14], 1
.text:00000177
.text:00000177 loc_177:                                ; CODE XREF: CStdOutStream::operator<<(wchar_t const *)+46j
.text:00000177                 lea     ecx, [ebp+var_24] ; this
.text:0000017A                 call    ??0AString@@QAE@XZ ; AString::AString(void)
.text:0000017F                 mov     [ebp+var_4], 0
.text:00000186                 cmp     [ebp+var_14], 0FDE9h
.text:0000018D                 jnz     short loc_1BA
.text:0000018F                 mov     ecx, [ebp+arg_0]
.text:00000192                 push    ecx             ; wchar_t *
.text:00000193                 lea     ecx, [ebp+var_34] ; this
.text:00000196                 call    ??0UString@@QAE@PB_W@Z ; UString::UString(wchar_t const *)
.text:0000019B                 mov     byte ptr [ebp+var_4], 1
.text:0000019F                 lea     edx, [ebp+var_24]
.text:000001A2                 push    edx             ; struct AString *
.text:000001A3                 lea     eax, [ebp+var_34]
.text:000001A6                 push    eax             ; struct UString *
.text:000001A7                 call    ?ConvertUnicodeToUTF8@@YGXABVUString@@AAVAString@@@Z ; ConvertUnicodeToUTF8(UString const &,AString &)
.text:000001AC                 mov     byte ptr [ebp+var_4], 0
.text:000001B0                 lea     ecx, [ebp+var_34] ; this
.text:000001B3                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000001B8                 jmp     short loc_1E7
.text:000001BA ; ---------------------------------------------------------------------------
.text:000001BA
.text:000001BA loc_1BA:                                ; CODE XREF: CStdOutStream::operator<<(wchar_t const *)+65j
.text:000001BA                 mov     ecx, [ebp+arg_0]
.text:000001BD                 push    ecx             ; wchar_t *
.text:000001BE                 lea     ecx, [ebp+var_40] ; this
.text:000001C1                 call    ??0UString@@QAE@PB_W@Z ; UString::UString(wchar_t const *)
.text:000001C6                 mov     byte ptr [ebp+var_4], 2
.text:000001CA                 mov     edx, [ebp+var_14]
.text:000001CD                 push    edx             ; unsigned int
.text:000001CE                 lea     eax, [ebp+var_40]
.text:000001D1                 push    eax             ; struct UString *
.text:000001D2                 lea     ecx, [ebp+var_24]
.text:000001D5                 push    ecx             ; struct AString *
.text:000001D6                 call    ?UnicodeStringToMultiByte2@@YGXAAVAString@@ABVUString@@I@Z ; UnicodeStringToMultiByte2(AString &,UString const &,uint)
.text:000001DB                 mov     byte ptr [ebp+var_4], 0
.text:000001DF                 lea     ecx, [ebp+var_40] ; this
.text:000001E2                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000001E7
.text:000001E7 loc_1E7:                                ; CODE XREF: CStdOutStream::operator<<(wchar_t const *)+90j
.text:000001E7                 lea     ecx, [ebp+var_24]
.text:000001EA                 call    ??BAString@@QBEPBDXZ ; AString::operator char const *(void)
.text:000001EF                 push    eax             ; Str
.text:000001F0                 mov     ecx, [ebp+var_10]
.text:000001F3                 call    ??6CStdOutStream@@QAEAAV0@PBD@Z ; CStdOutStream::operator<<(char const *)
.text:000001F8                 mov     [ebp+var_44], eax
.text:000001FB                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000202                 lea     ecx, [ebp+var_24] ; this
.text:00000205                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:0000020A                 mov     eax, [ebp+var_44]
.text:0000020D                 push    edx
.text:0000020E                 mov     ecx, ebp
.text:00000210                 push    eax
.text:00000211                 lea     edx, $LN12
.text:00000217                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:0000021C                 pop     eax
.text:0000021D                 pop     edx
.text:0000021E                 mov     ecx, [ebp+var_C]
.text:00000221                 mov     large fs:0, ecx
.text:00000228                 pop     ecx
.text:00000229                 pop     edi
.text:0000022A                 add     esp, 44h
.text:0000022D                 cmp     ebp, esp
.text:0000022F                 call    __RTC_CheckEsp
.text:00000234                 mov     esp, ebp
.text:00000236                 pop     ebp
.text:00000237                 retn    4
.text:00000237 ??6CStdOutStream@@QAEAAV0@PB_W@Z endp
.text:00000237
.text:00000237 ; ---------------------------------------------------------------------------
.text:0000023A                 align 4
.text:0000023C $LN12           dd 1                    ; DATA XREF: CStdOutStream::operator<<(wchar_t const *)+E9o
.text:00000240                 dd offset $LN11
.text:00000244 $LN11           dd 0FFFFFFDCh, 0Ch      ; DATA XREF: .text:00000240o
.text:0000024C                 dd offset $LN9          ; "dest"
.text:00000250 $LN9            db 'dest',0             ; DATA XREF: .text:0000024Co
.text:00000255                 align 4
.text:00000258
.text:00000258 ; =============== S U B R O U T I N E =======================================
.text:00000258
.text:00000258 ; Attributes: bp-based frame
.text:00000258
.text:00000258 ; void __stdcall StdOut_Convert_UString_to_AString(const struct UString *, struct AString *)
.text:00000258                 public ?StdOut_Convert_UString_to_AString@@YGXABVUString@@AAVAString@@@Z
.text:00000258 ?StdOut_Convert_UString_to_AString@@YGXABVUString@@AAVAString@@@Z proc near
.text:00000258                                         ; CODE XREF: CStdOutStream::PrintUString(UString const &,AString &)+16p
.text:00000258
.text:00000258 var_4           = dword ptr -4
.text:00000258 arg_0           = dword ptr  8
.text:00000258 arg_4           = dword ptr  0Ch
.text:00000258
.text:00000258                 push    ebp
.text:00000259                 mov     ebp, esp
.text:0000025B                 push    ecx
.text:0000025C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000263                 mov     eax, dword ptr ds:?g_CodePage@@3HA ; int g_CodePage
.text:00000268                 mov     [ebp+var_4], eax
.text:0000026B                 cmp     [ebp+var_4], 0FFFFFFFFh
.text:0000026F                 jnz     short loc_278
.text:00000271                 mov     [ebp+var_4], 1
.text:00000278
.text:00000278 loc_278:                                ; CODE XREF: StdOut_Convert_UString_to_AString(UString const &,AString &)+17j
.text:00000278                 cmp     [ebp+var_4], 0FDE9h
.text:0000027F                 jnz     short loc_290
.text:00000281                 mov     ecx, [ebp+arg_4]
.text:00000284                 push    ecx             ; struct AString *
.text:00000285                 mov     edx, [ebp+arg_0]
.text:00000288                 push    edx             ; struct UString *
.text:00000289                 call    ?ConvertUnicodeToUTF8@@YGXABVUString@@AAVAString@@@Z ; ConvertUnicodeToUTF8(UString const &,AString &)
.text:0000028E                 jmp     short loc_2A1
.text:00000290 ; ---------------------------------------------------------------------------
.text:00000290
.text:00000290 loc_290:                                ; CODE XREF: StdOut_Convert_UString_to_AString(UString const &,AString &)+27j
.text:00000290                 mov     eax, [ebp+var_4]
.text:00000293                 push    eax             ; unsigned int
.text:00000294                 mov     ecx, [ebp+arg_0]
.text:00000297                 push    ecx             ; struct UString *
.text:00000298                 mov     edx, [ebp+arg_4]
.text:0000029B                 push    edx             ; struct AString *
.text:0000029C                 call    ?UnicodeStringToMultiByte2@@YGXAAVAString@@ABVUString@@I@Z ; UnicodeStringToMultiByte2(AString &,UString const &,uint)
.text:000002A1
.text:000002A1 loc_2A1:                                ; CODE XREF: StdOut_Convert_UString_to_AString(UString const &,AString &)+36j
.text:000002A1                 add     esp, 4
.text:000002A4                 cmp     ebp, esp
.text:000002A6                 call    __RTC_CheckEsp
.text:000002AB                 mov     esp, ebp
.text:000002AD                 pop     ebp
.text:000002AE                 retn    8
.text:000002AE ?StdOut_Convert_UString_to_AString@@YGXABVUString@@AAVAString@@@Z endp
.text:000002AE
.text:000002AE ; ---------------------------------------------------------------------------
.text:000002B1                 align 8
.text:000002B8
.text:000002B8 ; =============== S U B R O U T I N E =======================================
.text:000002B8
.text:000002B8 ; Attributes: bp-based frame
.text:000002B8
.text:000002B8 ; void __thiscall CStdOutStream::PrintUString(CStdOutStream *this, const struct UString *, struct AString *)
.text:000002B8                 public ?PrintUString@CStdOutStream@@QAEXABVUString@@AAVAString@@@Z
.text:000002B8 ?PrintUString@CStdOutStream@@QAEXABVUString@@AAVAString@@@Z proc near
.text:000002B8
.text:000002B8 var_4           = dword ptr -4
.text:000002B8 arg_0           = dword ptr  8
.text:000002B8 arg_4           = dword ptr  0Ch
.text:000002B8
.text:000002B8                 push    ebp
.text:000002B9                 mov     ebp, esp
.text:000002BB                 push    ecx
.text:000002BC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000002C3                 mov     [ebp+var_4], ecx
.text:000002C6                 mov     eax, [ebp+arg_4]
.text:000002C9                 push    eax             ; struct AString *
.text:000002CA                 mov     ecx, [ebp+arg_0]
.text:000002CD                 push    ecx             ; struct UString *
.text:000002CE                 call    ?StdOut_Convert_UString_to_AString@@YGXABVUString@@AAVAString@@@Z ; StdOut_Convert_UString_to_AString(UString const &,AString &)
.text:000002D3                 mov     ecx, [ebp+arg_4]
.text:000002D6                 call    ??BAString@@QBEPBDXZ ; AString::operator char const *(void)
.text:000002DB                 push    eax             ; Str
.text:000002DC                 mov     ecx, [ebp+var_4]
.text:000002DF                 call    ??6CStdOutStream@@QAEAAV0@PBD@Z ; CStdOutStream::operator<<(char const *)
.text:000002E4                 add     esp, 4
.text:000002E7                 cmp     ebp, esp
.text:000002E9                 call    __RTC_CheckEsp
.text:000002EE                 mov     esp, ebp
.text:000002F0                 pop     ebp
.text:000002F1                 retn    8
.text:000002F1 ?PrintUString@CStdOutStream@@QAEXABVUString@@AAVAString@@@Z endp
.text:000002F1
.text:000002F1 ; ---------------------------------------------------------------------------
.text:000002F4                 align 8
.text:000002F8
.text:000002F8 ; =============== S U B R O U T I N E =======================================
.text:000002F8
.text:000002F8 ; Attributes: bp-based frame
.text:000002F8
.text:000002F8 ; public: class CStdOutStream & __thiscall CStdOutStream::operator<<(int)
.text:000002F8                 public ??6CStdOutStream@@QAEAAV0@H@Z
.text:000002F8 ??6CStdOutStream@@QAEAAV0@H@Z proc near
.text:000002F8
.text:000002F8 var_30          = byte ptr -30h
.text:000002F8 Str             = byte ptr -2Ch
.text:000002F8 var_8           = dword ptr -8
.text:000002F8 var_4           = dword ptr -4
.text:000002F8 arg_0           = qword ptr  8
.text:000002F8
.text:000002F8                 push    ebp
.text:000002F9                 mov     ebp, esp
.text:000002FB                 sub     esp, 30h
.text:000002FE                 push    edi
.text:000002FF                 push    ecx
.text:00000300                 lea     edi, [ebp+var_30]
.text:00000303                 mov     ecx, 0Ch
.text:00000308                 mov     eax, 0CCCCCCCCh
.text:0000030D                 rep stosd
.text:0000030F                 pop     ecx
.text:00000310                 mov     eax, dword ptr ds:___security_cookie
.text:00000315                 xor     eax, ebp
.text:00000317                 mov     [ebp+var_4], eax
.text:0000031A                 mov     [ebp+var_8], ecx
.text:0000031D                 lea     eax, [ebp+Str]
.text:00000320                 push    eax             ; char *
.text:00000321                 mov     eax, dword ptr [ebp+arg_0]
.text:00000324                 cdq
.text:00000325                 push    edx
.text:00000326                 push    eax             ; __int64
.text:00000327                 call    ?ConvertInt64ToString@@YGX_JPAD@Z ; ConvertInt64ToString(__int64,char *)
.text:0000032C                 lea     ecx, [ebp+Str]
.text:0000032F                 push    ecx             ; Str
.text:00000330                 mov     ecx, [ebp+var_8]
.text:00000333                 call    ??6CStdOutStream@@QAEAAV0@PBD@Z ; CStdOutStream::operator<<(char const *)
.text:00000338                 push    edx
.text:00000339                 mov     ecx, ebp
.text:0000033B                 push    eax
.text:0000033C                 lea     edx, $LN5
.text:00000342                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00000347                 pop     eax
.text:00000348                 pop     edx
.text:00000349                 pop     edi
.text:0000034A                 mov     ecx, [ebp+var_4]
.text:0000034D                 xor     ecx, ebp
.text:0000034F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text:00000354                 add     esp, 30h
.text:00000357                 cmp     ebp, esp
.text:00000359                 call    __RTC_CheckEsp
.text:0000035E                 mov     esp, ebp
.text:00000360                 pop     ebp
.text:00000361                 retn    4
.text:00000361 ??6CStdOutStream@@QAEAAV0@H@Z endp
.text:00000361
.text:00000361 ; ---------------------------------------------------------------------------
.text:00000364 $LN5            dd 1                    ; DATA XREF: CStdOutStream::operator<<(int)+44o
.text:00000368                 dd offset $LN4
.text:0000036C $LN4            dd 0FFFFFFD4h, 20h      ; DATA XREF: .text:00000368o
.text:00000374                 dd offset $LN3
.text:00000378 $LN3            dd 0CCCC0073h, 3 dup(0CCCCCCCCh) ; DATA XREF: .text:00000374o
.text:00000388
.text:00000388 ; =============== S U B R O U T I N E =======================================
.text:00000388
.text:00000388 ; Attributes: bp-based frame
.text:00000388
.text:00000388 ; public: class CStdOutStream & __thiscall CStdOutStream::operator<<(__int64)
.text:00000388                 public ??6CStdOutStream@@QAEAAV0@_J@Z
.text:00000388 ??6CStdOutStream@@QAEAAV0@_J@Z proc near
.text:00000388
.text:00000388 var_30          = byte ptr -30h
.text:00000388 Str             = byte ptr -2Ch
.text:00000388 var_8           = dword ptr -8
.text:00000388 var_4           = dword ptr -4
.text:00000388 arg_0           = qword ptr  8
.text:00000388
.text:00000388                 push    ebp
.text:00000389                 mov     ebp, esp
.text:0000038B                 sub     esp, 30h
.text:0000038E                 push    edi
.text:0000038F                 push    ecx
.text:00000390                 lea     edi, [ebp+var_30]
.text:00000393                 mov     ecx, 0Ch
.text:00000398                 mov     eax, 0CCCCCCCCh
.text:0000039D                 rep stosd
.text:0000039F                 pop     ecx
.text:000003A0                 mov     eax, dword ptr ds:___security_cookie
.text:000003A5                 xor     eax, ebp
.text:000003A7                 mov     [ebp+var_4], eax
.text:000003AA                 mov     [ebp+var_8], ecx
.text:000003AD                 lea     eax, [ebp+Str]
.text:000003B0                 push    eax             ; char *
.text:000003B1                 mov     ecx, dword ptr [ebp+arg_0+4]
.text:000003B4                 push    ecx
.text:000003B5                 mov     edx, dword ptr [ebp+arg_0]
.text:000003B8                 push    edx             ; __int64
.text:000003B9                 call    ?ConvertInt64ToString@@YGX_JPAD@Z ; ConvertInt64ToString(__int64,char *)
.text:000003BE                 lea     eax, [ebp+Str]
.text:000003C1                 push    eax             ; Str
.text:000003C2                 mov     ecx, [ebp+var_8]
.text:000003C5                 call    ??6CStdOutStream@@QAEAAV0@PBD@Z ; CStdOutStream::operator<<(char const *)
.text:000003CA                 push    edx
.text:000003CB                 mov     ecx, ebp
.text:000003CD                 push    eax
.text:000003CE                 lea     edx, $LN5_0
.text:000003D4                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:000003D9                 pop     eax
.text:000003DA                 pop     edx
.text:000003DB                 pop     edi
.text:000003DC                 mov     ecx, [ebp+var_4]
.text:000003DF                 xor     ecx, ebp
.text:000003E1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text:000003E6                 add     esp, 30h
.text:000003E9                 cmp     ebp, esp
.text:000003EB                 call    __RTC_CheckEsp
.text:000003F0                 mov     esp, ebp
.text:000003F2                 pop     ebp
.text:000003F3                 retn    8
.text:000003F3 ??6CStdOutStream@@QAEAAV0@_J@Z endp
.text:000003F3
.text:000003F3 ; ---------------------------------------------------------------------------
.text:000003F6                 align 4
.text:000003F8 $LN5_0          dd 1                    ; DATA XREF: CStdOutStream::operator<<(__int64)+46o
.text:000003FC                 dd offset $LN4_0
.text:00000400 $LN4_0          dd 0FFFFFFD4h, 20h      ; DATA XREF: .text:000003FCo
.text:00000408                 dd offset $LN3_0
.text:0000040C $LN3_0          dd 0CCCC0073h, 2 dup(0CCCCCCCCh) ; DATA XREF: .text:00000408o
.text:00000418
.text:00000418 ; =============== S U B R O U T I N E =======================================
.text:00000418
.text:00000418 ; Attributes: bp-based frame
.text:00000418
.text:00000418 ; public: class CStdOutStream & __thiscall CStdOutStream::operator<<(unsigned int)
.text:00000418                 public ??6CStdOutStream@@QAEAAV0@I@Z
.text:00000418 ??6CStdOutStream@@QAEAAV0@I@Z proc near
.text:00000418
.text:00000418 var_20          = dword ptr -20h
.text:00000418 Str             = byte ptr -1Ch
.text:00000418 var_18          = dword ptr -18h
.text:00000418 var_14          = dword ptr -14h
.text:00000418 var_10          = dword ptr -10h
.text:00000418 var_C           = dword ptr -0Ch
.text:00000418 var_8           = dword ptr -8
.text:00000418 var_4           = dword ptr -4
.text:00000418 arg_0           = dword ptr  8
.text:00000418
.text:00000418                 push    ebp
.text:00000419                 mov     ebp, esp
.text:0000041B                 sub     esp, 20h
.text:0000041E                 mov     eax, 0CCCCCCCCh
.text:00000423                 mov     [ebp+var_20], eax
.text:00000426                 mov     dword ptr [ebp+Str], eax
.text:00000429                 mov     [ebp+var_18], eax
.text:0000042C                 mov     [ebp+var_14], eax
.text:0000042F                 mov     [ebp+var_10], eax
.text:00000432                 mov     [ebp+var_C], eax
.text:00000435                 mov     [ebp+var_8], eax
.text:00000438                 mov     [ebp+var_4], eax
.text:0000043B                 mov     eax, dword ptr ds:___security_cookie
.text:00000440                 xor     eax, ebp
.text:00000442                 mov     [ebp+var_4], eax
.text:00000445                 mov     [ebp+var_8], ecx
.text:00000448                 lea     eax, [ebp+Str]
.text:0000044B                 push    eax             ; char *
.text:0000044C                 mov     ecx, [ebp+arg_0]
.text:0000044F                 push    ecx             ; unsigned int
.text:00000450                 call    ?ConvertUInt32ToString@@YGXIPAD@Z ; ConvertUInt32ToString(uint,char *)
.text:00000455                 lea     edx, [ebp+Str]
.text:00000458                 push    edx             ; Str
.text:00000459                 mov     ecx, [ebp+var_8]
.text:0000045C                 call    ??6CStdOutStream@@QAEAAV0@PBD@Z ; CStdOutStream::operator<<(char const *)
.text:00000461                 push    edx
.text:00000462                 mov     ecx, ebp
.text:00000464                 push    eax
.text:00000465                 lea     edx, $LN5_1
.text:0000046B                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00000470                 pop     eax
.text:00000471                 pop     edx
.text:00000472                 mov     ecx, [ebp+var_4]
.text:00000475                 xor     ecx, ebp
.text:00000477                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text:0000047C                 add     esp, 20h
.text:0000047F                 cmp     ebp, esp
.text:00000481                 call    __RTC_CheckEsp
.text:00000486                 mov     esp, ebp
.text:00000488                 pop     ebp
.text:00000489                 retn    4
.text:00000489 ??6CStdOutStream@@QAEAAV0@I@Z endp
.text:00000489
.text:00000489 ; ---------------------------------------------------------------------------
.text:0000048C $LN5_1          dd 1                    ; DATA XREF: CStdOutStream::operator<<(uint)+4Do
.text:00000490                 dd offset $LN4_1
.text:00000494 $LN4_1          dd 0FFFFFFE4h, 10h      ; DATA XREF: .text:00000490o
.text:0000049C                 dd offset $LN3_1
.text:000004A0 $LN3_1          dd 0CCCC0073h, 0CCCCCCCCh ; DATA XREF: .text:0000049Co
.text:000004A8
.text:000004A8 ; =============== S U B R O U T I N E =======================================
.text:000004A8
.text:000004A8 ; Attributes: bp-based frame
.text:000004A8
.text:000004A8 ; public: class CStdOutStream & __thiscall CStdOutStream::operator<<(unsigned __int64)
.text:000004A8                 public ??6CStdOutStream@@QAEAAV0@_K@Z
.text:000004A8 ??6CStdOutStream@@QAEAAV0@_K@Z proc near
.text:000004A8
.text:000004A8 var_30          = byte ptr -30h
.text:000004A8 Str             = byte ptr -2Ch
.text:000004A8 var_8           = dword ptr -8
.text:000004A8 var_4           = dword ptr -4
.text:000004A8 arg_0           = qword ptr  8
.text:000004A8
.text:000004A8                 push    ebp
.text:000004A9                 mov     ebp, esp
.text:000004AB                 sub     esp, 30h
.text:000004AE                 push    edi
.text:000004AF                 push    ecx
.text:000004B0                 lea     edi, [ebp+var_30]
.text:000004B3                 mov     ecx, 0Ch
.text:000004B8                 mov     eax, 0CCCCCCCCh
.text:000004BD                 rep stosd
.text:000004BF                 pop     ecx
.text:000004C0                 mov     eax, dword ptr ds:___security_cookie
.text:000004C5                 xor     eax, ebp
.text:000004C7                 mov     [ebp+var_4], eax
.text:000004CA                 mov     [ebp+var_8], ecx
.text:000004CD                 lea     eax, [ebp+Str]
.text:000004D0                 push    eax             ; char *
.text:000004D1                 mov     ecx, dword ptr [ebp+arg_0+4]
.text:000004D4                 push    ecx
.text:000004D5                 mov     edx, dword ptr [ebp+arg_0]
.text:000004D8                 push    edx             ; unsigned __int64
.text:000004D9                 call    ?ConvertUInt64ToString@@YGX_KPAD@Z ; ConvertUInt64ToString(unsigned __int64,char *)
.text:000004DE                 lea     eax, [ebp+Str]
.text:000004E1                 push    eax             ; Str
.text:000004E2                 mov     ecx, [ebp+var_8]
.text:000004E5                 call    ??6CStdOutStream@@QAEAAV0@PBD@Z ; CStdOutStream::operator<<(char const *)
.text:000004EA                 push    edx
.text:000004EB                 mov     ecx, ebp
.text:000004ED                 push    eax
.text:000004EE                 lea     edx, $LN5_2
.text:000004F4                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:000004F9                 pop     eax
.text:000004FA                 pop     edx
.text:000004FB                 pop     edi
.text:000004FC                 mov     ecx, [ebp+var_4]
.text:000004FF                 xor     ecx, ebp
.text:00000501                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text:00000506                 add     esp, 30h
.text:00000509                 cmp     ebp, esp
.text:0000050B                 call    __RTC_CheckEsp
.text:00000510                 mov     esp, ebp
.text:00000512                 pop     ebp
.text:00000513                 retn    8
.text:00000513 ??6CStdOutStream@@QAEAAV0@_K@Z endp
.text:00000513
.text:00000513 ; ---------------------------------------------------------------------------
.text:00000516                 align 4
.text:00000518 $LN5_2          dd 1                    ; DATA XREF: CStdOutStream::operator<<(unsigned __int64)+46o
.text:0000051C                 dd offset $LN4_2
.text:00000520 $LN4_2          dd 0FFFFFFD4h, 20h      ; DATA XREF: .text:0000051Co
.text:00000528                 dd offset $LN3_2
.text:0000052C $LN3_2          db 73h, 0               ; DATA XREF: .text:00000528o
.text:0000052E                 align 10h
.text:0000052E _text           ends
.text:0000052E
.rtc$TMZ:00000530 ; ===========================================================================
.rtc$TMZ:00000530
.rtc$TMZ:00000530 ; Segment type: Pure data
.rtc$TMZ:00000530 ; Segment permissions: Read
.rtc$TMZ:00000530 _rtc$TMZ        segment dword public 'DATA' use32
.rtc$TMZ:00000530                 assume cs:_rtc$TMZ
.rtc$TMZ:00000530                 ;org 530h
.rtc$TMZ:00000530 ; COMDAT (pick any)
.rtc$TMZ:00000530 __RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
.rtc$TMZ:00000530 _rtc$TMZ        ends
.rtc$TMZ:00000530
.rtc$IMZ:00000534 ; ===========================================================================
.rtc$IMZ:00000534
.rtc$IMZ:00000534 ; Segment type: Pure data
.rtc$IMZ:00000534 ; Segment permissions: Read
.rtc$IMZ:00000534 _rtc$IMZ        segment dword public 'DATA' use32
.rtc$IMZ:00000534                 assume cs:_rtc$IMZ
.rtc$IMZ:00000534                 ;org 534h
.rtc$IMZ:00000534 ; COMDAT (pick any)
.rtc$IMZ:00000534 __RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
.rtc$IMZ:00000534 _rtc$IMZ        ends
.rtc$IMZ:00000534
.text:00000538 ; ===========================================================================
.text:00000538
.text:00000538 ; Segment type: Pure code
.text:00000538 ; Segment permissions: Read/Execute
.text:00000538 _text           segment para public 'CODE' use32
.text:00000538                 assume cs:_text
.text:00000538                 ;org 538h
.text:00000538 ; COMDAT (pick any)
.text:00000538                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000538
.text:00000538 ; =============== S U B R O U T I N E =======================================
.text:00000538
.text:00000538 ; Attributes: bp-based frame
.text:00000538
.text:00000538 ; public: class CStdOutStream & __thiscall CStdOutStream::operator<<(char)
.text:00000538                 public ??6CStdOutStream@@QAEAAV0@D@Z
.text:00000538 ??6CStdOutStream@@QAEAAV0@D@Z proc near ; CODE XREF: endl(CStdOutStream &)+8p
.text:00000538
.text:00000538 var_4           = dword ptr -4
.text:00000538 arg_0           = byte ptr  8
.text:00000538
.text:00000538                 push    ebp
.text:00000539                 mov     ebp, esp
.text:0000053B                 push    ecx
.text:0000053C                 push    esi
.text:0000053D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000544                 mov     [ebp+var_4], ecx
.text:00000547                 mov     esi, esp
.text:00000549                 mov     eax, [ebp+var_4]
.text:0000054C                 mov     ecx, [eax]
.text:0000054E                 push    ecx             ; File
.text:0000054F                 movzx   edx, [ebp+arg_0]
.text:00000553                 push    edx             ; Ch
.text:00000554                 call    dword ptr ds:__imp__fputc
.text:0000055A                 add     esp, 8
.text:0000055D                 cmp     esi, esp
.text:0000055F                 call    __RTC_CheckEsp
.text:00000564                 mov     eax, [ebp+var_4]
.text:00000567                 pop     esi
.text:00000568                 add     esp, 4
.text:0000056B                 cmp     ebp, esp
.text:0000056D                 call    __RTC_CheckEsp
.text:00000572                 mov     esp, ebp
.text:00000574                 pop     ebp
.text:00000575                 retn    4
.text:00000575 ??6CStdOutStream@@QAEAAV0@D@Z endp
.text:00000575
.text:00000575 _text           ends
.text:00000575
.text$x:00000578 ; ===========================================================================
.text$x:00000578
.text$x:00000578 ; Segment type: Pure code
.text$x:00000578 ; Segment permissions: Read/Execute
.text$x:00000578 _text$x         segment para public 'CODE' use32
.text$x:00000578                 assume cs:_text$x
.text$x:00000578                 ;org 578h
.text$x:00000578                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000578
.text$x:00000578 ; =============== S U B R O U T I N E =======================================
.text$x:00000578
.text$x:00000578
.text$x:00000578 __unwindfunclet$??6CStdOutStream@@QAEAAV0@PB_W@Z$0 proc near
.text$x:00000578                                         ; DATA XREF: .xdata$x:000005B0o
.text$x:00000578                 lea     ecx, [ebp-24h]  ; this
.text$x:0000057B                 jmp     ??1AString@@QAE@XZ ; AString::~AString(void)
.text$x:0000057B __unwindfunclet$??6CStdOutStream@@QAEAAV0@PB_W@Z$0 endp
.text$x:0000057B
.text$x:00000580
.text$x:00000580 ; =============== S U B R O U T I N E =======================================
.text$x:00000580
.text$x:00000580
.text$x:00000580 __unwindfunclet$??6CStdOutStream@@QAEAAV0@PB_W@Z$1 proc near
.text$x:00000580                                         ; DATA XREF: .xdata$x:000005B8o
.text$x:00000580                 lea     ecx, [ebp-34h]  ; this
.text$x:00000583                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00000583 __unwindfunclet$??6CStdOutStream@@QAEAAV0@PB_W@Z$1 endp
.text$x:00000583
.text$x:00000588
.text$x:00000588 ; =============== S U B R O U T I N E =======================================
.text$x:00000588
.text$x:00000588
.text$x:00000588 __unwindfunclet$??6CStdOutStream@@QAEAAV0@PB_W@Z$2 proc near
.text$x:00000588                                         ; DATA XREF: .xdata$x:000005C0o
.text$x:00000588                 lea     ecx, [ebp-40h]  ; this
.text$x:0000058B                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:0000058B __unwindfunclet$??6CStdOutStream@@QAEAAV0@PB_W@Z$2 endp
.text$x:0000058B
.text$x:00000590
.text$x:00000590 ; =============== S U B R O U T I N E =======================================
.text$x:00000590
.text$x:00000590
.text$x:00000590 __ehhandler$??6CStdOutStream@@QAEAAV0@PB_W@Z proc near
.text$x:00000590                                         ; DATA XREF: CStdOutStream::operator<<(wchar_t const *)+5o
.text$x:00000590
.text$x:00000590 arg_4           = dword ptr  8
.text$x:00000590
.text$x:00000590                 mov     edx, [esp+arg_4]
.text$x:00000594                 lea     eax, [edx+0Ch]
.text$x:00000597                 mov     ecx, [edx-40h]
.text$x:0000059A                 xor     ecx, eax
.text$x:0000059C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000005A1                 mov     eax, offset __ehfuncinfo$??6CStdOutStream@@QAEAAV0@PB_W@Z
.text$x:000005A6                 jmp     ___CxxFrameHandler3
.text$x:000005A6 __ehhandler$??6CStdOutStream@@QAEAAV0@PB_W@Z endp
.text$x:000005A6
.text$x:000005A6 ; ---------------------------------------------------------------------------
.text$x:000005AB                 align 4
.text$x:000005AB _text$x         ends
.text$x:000005AB
.xdata$x:000005AC ; ===========================================================================
.xdata$x:000005AC
.xdata$x:000005AC ; Segment type: Pure data
.xdata$x:000005AC ; Segment permissions: Read
.xdata$x:000005AC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000005AC                 assume cs:_xdata$x
.xdata$x:000005AC                 ;org 5ACh
.xdata$x:000005AC __unwindtable$??6CStdOutStream@@QAEAAV0@PB_W@Z db 0FFh
.xdata$x:000005AC                                         ; DATA XREF: .xdata$x:000005CCo
.xdata$x:000005AD                 db 0FFh
.xdata$x:000005AE                 db 0FFh
.xdata$x:000005AF                 db 0FFh
.xdata$x:000005B0                 dd offset __unwindfunclet$??6CStdOutStream@@QAEAAV0@PB_W@Z$0
.xdata$x:000005B4                 align 8
.xdata$x:000005B8                 dd offset __unwindfunclet$??6CStdOutStream@@QAEAAV0@PB_W@Z$1
.xdata$x:000005BC                 align 10h
.xdata$x:000005C0                 dd offset __unwindfunclet$??6CStdOutStream@@QAEAAV0@PB_W@Z$2
.xdata$x:000005C4 __ehfuncinfo$??6CStdOutStream@@QAEAAV0@PB_W@Z db  22h ; "
.xdata$x:000005C4                                         ; DATA XREF: __ehhandler$??6CStdOutStream@@QAEAAV0@PB_W@Z+11o
.xdata$x:000005C5                 db    5
.xdata$x:000005C6                 db  93h ; Ã´
.xdata$x:000005C7                 db  19h
.xdata$x:000005C8                 db    3
.xdata$x:000005C9                 db    0
.xdata$x:000005CA                 db    0
.xdata$x:000005CB                 db    0
.xdata$x:000005CC                 dd offset __unwindtable$??6CStdOutStream@@QAEAAV0@PB_W@Z
.xdata$x:000005D0                 db    0
.xdata$x:000005D1                 db    0
.xdata$x:000005D2                 db    0
.xdata$x:000005D3                 db    0
.xdata$x:000005D4                 db    0
.xdata$x:000005D5                 db    0
.xdata$x:000005D6                 db    0
.xdata$x:000005D7                 db    0
.xdata$x:000005D8                 db    0
.xdata$x:000005D9                 db    0
.xdata$x:000005DA                 db    0
.xdata$x:000005DB                 db    0
.xdata$x:000005DC                 db    0
.xdata$x:000005DD                 db    0
.xdata$x:000005DE                 db    0
.xdata$x:000005DF                 db    0
.xdata$x:000005E0                 db    0
.xdata$x:000005E1                 db    0
.xdata$x:000005E2                 db    0
.xdata$x:000005E3                 db    0
.xdata$x:000005E4                 db    1
.xdata$x:000005E5                 db    0
.xdata$x:000005E6                 db    0
.xdata$x:000005E7                 db    0
.xdata$x:000005E7 _xdata$x        ends
.xdata$x:000005E7
.text:000005E8 ; ===========================================================================
.text:000005E8
.text:000005E8 ; Segment type: Pure code
.text:000005E8 ; Segment permissions: Read/Execute
.text:000005E8 _text           segment para public 'CODE' use32
.text:000005E8                 assume cs:_text
.text:000005E8                 ;org 5E8h
.text:000005E8 ; COMDAT (pick any)
.text:000005E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000005E8
.text:000005E8 ; =============== S U B R O U T I N E =======================================
.text:000005E8
.text:000005E8 ; Attributes: bp-based frame
.text:000005E8
.text:000005E8 ; _DWORD __thiscall AString::~AString(AString *__hidden this)
.text:000005E8                 public ??1AString@@QAE@XZ
.text:000005E8 ??1AString@@QAE@XZ proc near            ; CODE XREF: CStdOutStream::operator<<(wchar_t const *)+DDp
.text:000005E8                                         ; __unwindfunclet$??6CStdOutStream@@QAEAAV0@PB_W@Z$0+3j
.text:000005E8
.text:000005E8 var_8           = dword ptr -8
.text:000005E8 var_4           = dword ptr -4
.text:000005E8
.text:000005E8                 push    ebp
.text:000005E9                 mov     ebp, esp
.text:000005EB                 sub     esp, 8
.text:000005EE                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000005F5                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000005FC                 mov     [ebp+var_4], ecx
.text:000005FF                 mov     eax, [ebp+var_4]
.text:00000602                 mov     ecx, [eax]
.text:00000604                 mov     [ebp+var_8], ecx
.text:00000607                 mov     edx, [ebp+var_8]
.text:0000060A                 push    edx             ; void *
.text:0000060B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00000610                 add     esp, 4
.text:00000613                 add     esp, 8
.text:00000616                 cmp     ebp, esp
.text:00000618                 call    __RTC_CheckEsp
.text:0000061D                 mov     esp, ebp
.text:0000061F                 pop     ebp
.text:00000620                 retn
.text:00000620 ??1AString@@QAE@XZ endp
.text:00000620
.text:00000620 ; ---------------------------------------------------------------------------
.text:00000621                 align 4
.text:00000621 _text           ends
.text:00000621
.text:00000624 ; ===========================================================================
.text:00000624
.text:00000624 ; Segment type: Pure code
.text:00000624 ; Segment permissions: Read/Execute
.text:00000624 _text           segment para public 'CODE' use32
.text:00000624                 assume cs:_text
.text:00000624                 ;org 624h
.text:00000624 ; COMDAT (pick any)
.text:00000624                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000624
.text:00000624 ; =============== S U B R O U T I N E =======================================
.text:00000624
.text:00000624 ; Attributes: bp-based frame
.text:00000624
.text:00000624 ; public: __thiscall AString::operator char const *(void)const
.text:00000624                 public ??BAString@@QBEPBDXZ
.text:00000624 ??BAString@@QBEPBDXZ proc near          ; CODE XREF: CStdOutStream::operator<<(wchar_t const *)+C2p
.text:00000624                                         ; CStdOutStream::PrintUString(UString const &,AString &)+1Ep
.text:00000624
.text:00000624 var_4           = dword ptr -4
.text:00000624
.text:00000624                 push    ebp
.text:00000625                 mov     ebp, esp
.text:00000627                 push    ecx
.text:00000628                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000062F                 mov     [ebp+var_4], ecx
.text:00000632                 mov     eax, [ebp+var_4]
.text:00000635                 mov     eax, [eax]
.text:00000637                 mov     esp, ebp
.text:00000639                 pop     ebp
.text:0000063A                 retn
.text:0000063A ??BAString@@QBEPBDXZ endp
.text:0000063A
.text:0000063A ; ---------------------------------------------------------------------------
.text:0000063B                 align 4
.text:0000063B _text           ends
.text:0000063B
.text:0000063C ; ===========================================================================
.text:0000063C
.text:0000063C ; Segment type: Pure code
.text:0000063C ; Segment permissions: Read/Execute
.text:0000063C _text           segment para public 'CODE' use32
.text:0000063C                 assume cs:_text
.text:0000063C                 ;org 63Ch
.text:0000063C ; COMDAT (pick any)
.text:0000063C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000063C
.text:0000063C ; =============== S U B R O U T I N E =======================================
.text:0000063C
.text:0000063C ; Attributes: bp-based frame
.text:0000063C
.text:0000063C ; _DWORD __thiscall UString::~UString(UString *__hidden this)
.text:0000063C                 public ??1UString@@QAE@XZ
.text:0000063C ??1UString@@QAE@XZ proc near            ; CODE XREF: CStdOutStream::operator<<(wchar_t const *)+8Bp
.text:0000063C                                         ; CStdOutStream::operator<<(wchar_t const *)+BAp ...
.text:0000063C
.text:0000063C var_8           = dword ptr -8
.text:0000063C var_4           = dword ptr -4
.text:0000063C
.text:0000063C                 push    ebp
.text:0000063D                 mov     ebp, esp
.text:0000063F                 sub     esp, 8
.text:00000642                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00000649                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000650                 mov     [ebp+var_4], ecx
.text:00000653                 mov     eax, [ebp+var_4]
.text:00000656                 mov     ecx, [eax]
.text:00000658                 mov     [ebp+var_8], ecx
.text:0000065B                 mov     edx, [ebp+var_8]
.text:0000065E                 push    edx             ; void *
.text:0000065F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00000664                 add     esp, 4
.text:00000667                 add     esp, 8
.text:0000066A                 cmp     ebp, esp
.text:0000066C                 call    __RTC_CheckEsp
.text:00000671                 mov     esp, ebp
.text:00000673                 pop     ebp
.text:00000674                 retn
.text:00000674 ??1UString@@QAE@XZ endp
.text:00000674
.text:00000674 ; ---------------------------------------------------------------------------
.text:00000675                 align 4
.text:00000675 _text           ends
.text:00000675
.text:00000678 ; ===========================================================================
.text:00000678
.text:00000678 ; Segment type: Pure code
.text:00000678 ; Segment permissions: Read/Execute
.text:00000678 _text           segment para public 'CODE' use32
.text:00000678                 assume cs:_text
.text:00000678                 ;org 678h
.text:00000678 ; COMDAT (pick any)
.text:00000678                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000678
.text:00000678 ; =============== S U B R O U T I N E =======================================
.text:00000678
.text:00000678 ; Attributes: bp-based frame
.text:00000678
.text:00000678 ; int __stdcall CStdOutStream::operator<<(char *Str)
.text:00000678                 public ??6CStdOutStream@@QAEAAV0@PBD@Z
.text:00000678 ??6CStdOutStream@@QAEAAV0@PBD@Z proc near
.text:00000678                                         ; CODE XREF: CStdOutStream::operator<<(wchar_t const *)+CBp
.text:00000678                                         ; CStdOutStream::PrintUString(UString const &,AString &)+27p ...
.text:00000678
.text:00000678 var_4           = dword ptr -4
.text:00000678 Str             = dword ptr  8
.text:00000678
.text:00000678                 push    ebp
.text:00000679                 mov     ebp, esp
.text:0000067B                 push    ecx
.text:0000067C                 push    esi
.text:0000067D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000684                 mov     [ebp+var_4], ecx
.text:00000687                 mov     esi, esp
.text:00000689                 mov     eax, [ebp+var_4]
.text:0000068C                 mov     ecx, [eax]
.text:0000068E                 push    ecx             ; File
.text:0000068F                 mov     edx, [ebp+Str]
.text:00000692                 push    edx             ; Str
.text:00000693                 call    dword ptr ds:__imp__fputs
.text:00000699                 add     esp, 8
.text:0000069C                 cmp     esi, esp
.text:0000069E                 call    __RTC_CheckEsp
.text:000006A3                 mov     eax, [ebp+var_4]
.text:000006A6                 pop     esi
.text:000006A7                 add     esp, 4
.text:000006AA                 cmp     ebp, esp
.text:000006AC                 call    __RTC_CheckEsp
.text:000006B1                 mov     esp, ebp
.text:000006B3                 pop     ebp
.text:000006B4                 retn    4
.text:000006B4 ??6CStdOutStream@@QAEAAV0@PBD@Z endp
.text:000006B4
.text:000006B4 ; ---------------------------------------------------------------------------
.text:000006B7                 align 4
.text:000006B7 _text           ends
.text:000006B7
.text$yc:000006B8 ; ===========================================================================
.text$yc:000006B8
.text$yc:000006B8 ; Segment type: Pure code
.text$yc:000006B8 ; Segment permissions: Read/Execute
.text$yc:000006B8 _text$yc        segment para public 'CODE' use32
.text$yc:000006B8                 assume cs:_text$yc
.text$yc:000006B8                 ;org 6B8h
.text$yc:000006B8 ; COMDAT (pick any)
.text$yc:000006B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yc:000006B8
.text$yc:000006B8 ; =============== S U B R O U T I N E =======================================
.text$yc:000006B8
.text$yc:000006B8 ; Attributes: bp-based frame
.text$yc:000006B8
.text$yc:000006B8 ; void __cdecl `dynamic initializer for 'g_StdOut''(void)
.text$yc:000006B8 ??__Eg_StdOut@@YAXXZ proc near          ; DATA XREF: .CRT$XCU:_g_StdOut$initializer$o
.text$yc:000006B8                 push    ebp
.text$yc:000006B9                 mov     ebp, esp
.text$yc:000006BB                 push    esi
.text$yc:000006BC                 mov     esi, esp
.text$yc:000006BE                 call    dword ptr ds:__imp____iob_func
.text$yc:000006C4                 cmp     esi, esp
.text$yc:000006C6                 call    __RTC_CheckEsp
.text$yc:000006CB                 add     eax, 20h ; ' '
.text$yc:000006CE                 push    eax             ; struct _iobuf *
.text$yc:000006CF                 mov     ecx, offset ?g_StdOut@@3VCStdOutStream@@A ; this
.text$yc:000006D4                 call    ??0CStdOutStream@@QAE@PAU_iobuf@@@Z ; CStdOutStream::CStdOutStream(_iobuf *)
.text$yc:000006D9                 push    offset ??__Fg_StdOut@@YAXXZ ; void (__cdecl *)()
.text$yc:000006DE                 call    _atexit
.text$yc:000006E3                 add     esp, 4
.text$yc:000006E6                 pop     esi
.text$yc:000006E7                 cmp     ebp, esp
.text$yc:000006E9                 call    __RTC_CheckEsp
.text$yc:000006EE                 pop     ebp
.text$yc:000006EF                 retn
.text$yc:000006EF ??__Eg_StdOut@@YAXXZ endp
.text$yc:000006EF
.text$yc:000006EF _text$yc        ends
.text$yc:000006EF
.text:000006F0 ; ===========================================================================
.text:000006F0
.text:000006F0 ; Segment type: Pure code
.text:000006F0 ; Segment permissions: Read/Execute
.text:000006F0 _text           segment para public 'CODE' use32
.text:000006F0                 assume cs:_text
.text:000006F0                 ;org 6F0h
.text:000006F0 ; COMDAT (pick any)
.text:000006F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000006F0
.text:000006F0 ; =============== S U B R O U T I N E =======================================
.text:000006F0
.text:000006F0 ; Attributes: bp-based frame
.text:000006F0
.text:000006F0 ; _DWORD __thiscall CStdOutStream::CStdOutStream(CStdOutStream *this, struct _iobuf *)
.text:000006F0                 public ??0CStdOutStream@@QAE@PAU_iobuf@@@Z
.text:000006F0 ??0CStdOutStream@@QAE@PAU_iobuf@@@Z proc near
.text:000006F0                                         ; CODE XREF: `dynamic initializer for 'g_StdOut''(void)+1Cp
.text:000006F0                                         ; `dynamic initializer for 'g_StdErr''(void)+1Cp
.text:000006F0
.text:000006F0 var_4           = dword ptr -4
.text:000006F0 arg_0           = dword ptr  8
.text:000006F0
.text:000006F0                 push    ebp
.text:000006F1                 mov     ebp, esp
.text:000006F3                 push    ecx
.text:000006F4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000006FB                 mov     [ebp+var_4], ecx
.text:000006FE                 mov     eax, [ebp+var_4]
.text:00000701                 mov     ecx, [ebp+arg_0]
.text:00000704                 mov     [eax], ecx
.text:00000706                 mov     edx, [ebp+var_4]
.text:00000709                 mov     byte ptr [edx+4], 0
.text:0000070D                 mov     eax, [ebp+var_4]
.text:00000710                 mov     esp, ebp
.text:00000712                 pop     ebp
.text:00000713                 retn    4
.text:00000713 ??0CStdOutStream@@QAE@PAU_iobuf@@@Z endp
.text:00000713
.text:00000713 ; ---------------------------------------------------------------------------
.text:00000716                 align 4
.text:00000716 _text           ends
.text:00000716
.text$yc:00000718 ; ===========================================================================
.text$yc:00000718
.text$yc:00000718 ; Segment type: Pure code
.text$yc:00000718 ; Segment permissions: Read/Execute
.text$yc:00000718 _text$yc        segment para public 'CODE' use32
.text$yc:00000718                 assume cs:_text$yc
.text$yc:00000718                 ;org 718h
.text$yc:00000718 ; COMDAT (pick any)
.text$yc:00000718                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yc:00000718
.text$yc:00000718 ; =============== S U B R O U T I N E =======================================
.text$yc:00000718
.text$yc:00000718 ; Attributes: bp-based frame
.text$yc:00000718
.text$yc:00000718 ; void __cdecl `dynamic initializer for 'g_StdErr''(void)
.text$yc:00000718 ??__Eg_StdErr@@YAXXZ proc near          ; DATA XREF: .CRT$XCU:_g_StdErr$initializer$o
.text$yc:00000718                 push    ebp
.text$yc:00000719                 mov     ebp, esp
.text$yc:0000071B                 push    esi
.text$yc:0000071C                 mov     esi, esp
.text$yc:0000071E                 call    dword ptr ds:__imp____iob_func
.text$yc:00000724                 cmp     esi, esp
.text$yc:00000726                 call    __RTC_CheckEsp
.text$yc:0000072B                 add     eax, 40h ; '@'
.text$yc:0000072E                 push    eax             ; struct _iobuf *
.text$yc:0000072F                 mov     ecx, offset ?g_StdErr@@3VCStdOutStream@@A ; this
.text$yc:00000734                 call    ??0CStdOutStream@@QAE@PAU_iobuf@@@Z ; CStdOutStream::CStdOutStream(_iobuf *)
.text$yc:00000739                 push    offset ??__Fg_StdErr@@YAXXZ ; void (__cdecl *)()
.text$yc:0000073E                 call    _atexit
.text$yc:00000743                 add     esp, 4
.text$yc:00000746                 pop     esi
.text$yc:00000747                 cmp     ebp, esp
.text$yc:00000749                 call    __RTC_CheckEsp
.text$yc:0000074E                 pop     ebp
.text$yc:0000074F                 retn
.text$yc:0000074F ??__Eg_StdErr@@YAXXZ endp
.text$yc:0000074F
.text$yc:0000074F _text$yc        ends
.text$yc:0000074F
.text$yd:00000750 ; ===========================================================================
.text$yd:00000750
.text$yd:00000750 ; Segment type: Pure code
.text$yd:00000750 ; Segment permissions: Read/Execute
.text$yd:00000750 _text$yd        segment para public 'CODE' use32
.text$yd:00000750                 assume cs:_text$yd
.text$yd:00000750                 ;org 750h
.text$yd:00000750 ; COMDAT (pick any)
.text$yd:00000750                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00000750
.text$yd:00000750 ; =============== S U B R O U T I N E =======================================
.text$yd:00000750
.text$yd:00000750 ; Attributes: bp-based frame
.text$yd:00000750
.text$yd:00000750 ; void __cdecl `dynamic atexit destructor for 'g_StdOut''()
.text$yd:00000750 ??__Fg_StdOut@@YAXXZ proc near          ; DATA XREF: `dynamic initializer for 'g_StdOut''(void)+21o
.text$yd:00000750                 push    ebp
.text$yd:00000751                 mov     ebp, esp
.text$yd:00000753                 mov     ecx, offset ?g_StdOut@@3VCStdOutStream@@A ; this
.text$yd:00000758                 call    ??1CStdOutStream@@QAE@XZ ; CStdOutStream::~CStdOutStream(void)
.text$yd:0000075D                 cmp     ebp, esp
.text$yd:0000075F                 call    __RTC_CheckEsp
.text$yd:00000764                 pop     ebp
.text$yd:00000765                 retn
.text$yd:00000765 ??__Fg_StdOut@@YAXXZ endp
.text$yd:00000765
.text$yd:00000765 ; ---------------------------------------------------------------------------
.text$yd:00000766                 align 4
.text$yd:00000766 _text$yd        ends
.text$yd:00000766
.text:00000768 ; ===========================================================================
.text:00000768
.text:00000768 ; Segment type: Pure code
.text:00000768 ; Segment permissions: Read/Execute
.text:00000768 _text           segment para public 'CODE' use32
.text:00000768                 assume cs:_text
.text:00000768                 ;org 768h
.text:00000768 ; COMDAT (pick any)
.text:00000768                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000768
.text:00000768 ; =============== S U B R O U T I N E =======================================
.text:00000768
.text:00000768 ; Attributes: bp-based frame
.text:00000768
.text:00000768 ; _DWORD __thiscall CStdOutStream::~CStdOutStream(CStdOutStream *__hidden this)
.text:00000768                 public ??1CStdOutStream@@QAE@XZ
.text:00000768 ??1CStdOutStream@@QAE@XZ proc near      ; CODE XREF: `dynamic atexit destructor for 'g_StdOut''(void)+8p
.text:00000768                                         ; `dynamic atexit destructor for 'g_StdErr''(void)+8p
.text:00000768
.text:00000768 var_4           = dword ptr -4
.text:00000768
.text:00000768                 push    ebp
.text:00000769                 mov     ebp, esp
.text:0000076B                 push    ecx
.text:0000076C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000773                 mov     [ebp+var_4], ecx
.text:00000776                 mov     ecx, [ebp+var_4] ; this
.text:00000779                 call    ?Close@CStdOutStream@@QAE_NXZ ; CStdOutStream::Close(void)
.text:0000077E                 add     esp, 4
.text:00000781                 cmp     ebp, esp
.text:00000783                 call    __RTC_CheckEsp
.text:00000788                 mov     esp, ebp
.text:0000078A                 pop     ebp
.text:0000078B                 retn
.text:0000078B ??1CStdOutStream@@QAE@XZ endp
.text:0000078B
.text:0000078B _text           ends
.text:0000078B
.text$yd:0000078C ; ===========================================================================
.text$yd:0000078C
.text$yd:0000078C ; Segment type: Pure code
.text$yd:0000078C ; Segment permissions: Read/Execute
.text$yd:0000078C _text$yd        segment para public 'CODE' use32
.text$yd:0000078C                 assume cs:_text$yd
.text$yd:0000078C                 ;org 78Ch
.text$yd:0000078C ; COMDAT (pick any)
.text$yd:0000078C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:0000078C
.text$yd:0000078C ; =============== S U B R O U T I N E =======================================
.text$yd:0000078C
.text$yd:0000078C ; Attributes: bp-based frame
.text$yd:0000078C
.text$yd:0000078C ; void __cdecl `dynamic atexit destructor for 'g_StdErr''()
.text$yd:0000078C ??__Fg_StdErr@@YAXXZ proc near          ; DATA XREF: `dynamic initializer for 'g_StdErr''(void)+21o
.text$yd:0000078C                 push    ebp
.text$yd:0000078D                 mov     ebp, esp
.text$yd:0000078F                 mov     ecx, offset ?g_StdErr@@3VCStdOutStream@@A ; this
.text$yd:00000794                 call    ??1CStdOutStream@@QAE@XZ ; CStdOutStream::~CStdOutStream(void)
.text$yd:00000799                 cmp     ebp, esp
.text$yd:0000079B                 call    __RTC_CheckEsp
.text$yd:000007A0                 pop     ebp
.text$yd:000007A1                 retn
.text$yd:000007A1 ??__Fg_StdErr@@YAXXZ endp
.text$yd:000007A1
.text$yd:000007A1 ; ---------------------------------------------------------------------------
.text$yd:000007A2                 align 4
.text$yd:000007A2 _text$yd        ends
.text$yd:000007A2
.bss:000007A4 ; ===========================================================================
.bss:000007A4
.bss:000007A4 ; Segment type: Uninitialized
.bss:000007A4 ; Segment permissions: Read/Write
.bss:000007A4 _bss            segment dword public 'BSS' use32
.bss:000007A4                 assume cs:_bss
.bss:000007A4                 ;org 7A4h
.bss:000007A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:000007A4                 public ?g_StdOut@@3VCStdOutStream@@A
.bss:000007A4 ; CStdOutStream g_StdOut
.bss:000007A4 ?g_StdOut@@3VCStdOutStream@@A db    ? ; ; DATA XREF: `dynamic initializer for 'g_StdOut''(void)+17o
.bss:000007A4                                         ; `dynamic atexit destructor for 'g_StdOut''(void)+3o
.bss:000007A5                 db    ? ;
.bss:000007A6                 db    ? ;
.bss:000007A7                 db    ? ;
.bss:000007A8                 db    ? ;
.bss:000007A9                 db    ? ;
.bss:000007AA                 db    ? ;
.bss:000007AB                 db    ? ;
.bss:000007AC                 public ?g_StdErr@@3VCStdOutStream@@A
.bss:000007AC ; CStdOutStream g_StdErr
.bss:000007AC ?g_StdErr@@3VCStdOutStream@@A db    ? ; ; DATA XREF: `dynamic initializer for 'g_StdErr''(void)+17o
.bss:000007AC                                         ; `dynamic atexit destructor for 'g_StdErr''(void)+3o
.bss:000007AD                 db    ? ;
.bss:000007AE                 db    ? ;
.bss:000007AF                 db    ? ;
.bss:000007B0                 db    ? ;
.bss:000007B1                 db    ? ;
.bss:000007B2                 db    ? ;
.bss:000007B3                 db    ? ;
.bss:000007B3 _bss            ends
.bss:000007B3
.CRT$XCU:000007B4 ; ===========================================================================
.CRT$XCU:000007B4
.CRT$XCU:000007B4 ; Segment type: Pure data
.CRT$XCU:000007B4 ; Segment permissions: Read
.CRT$XCU:000007B4 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000007B4                 assume cs:_CRT$XCU
.CRT$XCU:000007B4                 ;org 7B4h
.CRT$XCU:000007B4 _g_StdOut$initializer$ dd offset ??__Eg_StdOut@@YAXXZ ; `dynamic initializer for 'g_StdOut''(void)
.CRT$XCU:000007B8 _g_StdErr$initializer$ dd offset ??__Eg_StdErr@@YAXXZ ; `dynamic initializer for 'g_StdErr''(void)
.CRT$XCU:000007B8 _CRT$XCU        ends
.CRT$XCU:000007B8
UNDEF:000007C0 ; ===========================================================================
UNDEF:000007C0
UNDEF:000007C0 ; Segment type: Externs
UNDEF:000007C0 ; UNDEF
UNDEF:000007C0 ; FILE *__cdecl _fopen(const char *Filename, const char *Mode)
UNDEF:000007C0                 extrn __imp__fopen:near ; CODE XREF: CStdOutStream::Open(char const *)+23p
UNDEF:000007C0                                         ; DATA XREF: CStdOutStream::Open(char const *)+23r
UNDEF:000007C4                 extrn __RTC_CheckEsp:near
UNDEF:000007C4                                         ; CODE XREF: CStdOutStream::Open(char const *)+2Ep
UNDEF:000007C4                                         ; CStdOutStream::Open(char const *)+55p ...
UNDEF:000007C8                 extrn __RTC_Shutdown:near
UNDEF:000007C8                                         ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
UNDEF:000007CC                 extrn __RTC_InitBase:near
UNDEF:000007CC                                         ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
UNDEF:000007D0 ; int __cdecl _fclose(FILE *File)
UNDEF:000007D0                 extrn __imp__fclose:near
UNDEF:000007D0                                         ; CODE XREF: CStdOutStream::Close(void)+26p
UNDEF:000007D0                                         ; DATA XREF: CStdOutStream::Close(void)+26r
UNDEF:000007D4 ; int __cdecl _fflush(FILE *File)
UNDEF:000007D4                 extrn __imp__fflush:near
UNDEF:000007D4                                         ; CODE XREF: CStdOutStream::Flush(void)+17p
UNDEF:000007D4                                         ; DATA XREF: CStdOutStream::Flush(void)+17r
UNDEF:000007D8 ; int __cdecl _fputc(int Ch, FILE *File)
UNDEF:000007D8                 extrn __imp__fputc:near ; CODE XREF: CStdOutStream::operator<<(char)+1Cp
UNDEF:000007D8                                         ; DATA XREF: CStdOutStream::operator<<(char)+1Cr
UNDEF:000007DC ; void __stdcall UnicodeStringToMultiByte2(struct AString *, const struct UString *, unsigned int)
UNDEF:000007DC                 extrn ?UnicodeStringToMultiByte2@@YGXAAVAString@@ABVUString@@I@Z:near
UNDEF:000007DC                                         ; CODE XREF: CStdOutStream::operator<<(wchar_t const *)+AEp
UNDEF:000007DC                                         ; StdOut_Convert_UString_to_AString(UString const &,AString &)+44p
UNDEF:000007E0 ; void __stdcall ConvertUnicodeToUTF8(const struct UString *, struct AString *)
UNDEF:000007E0                 extrn ?ConvertUnicodeToUTF8@@YGXABVUString@@AAVAString@@@Z:near
UNDEF:000007E0                                         ; CODE XREF: CStdOutStream::operator<<(wchar_t const *)+7Fp
UNDEF:000007E0                                         ; StdOut_Convert_UString_to_AString(UString const &,AString &)+31p
UNDEF:000007E4 ; _DWORD __thiscall UString::UString(UString *__hidden this, const wchar_t *)
UNDEF:000007E4                 extrn ??0UString@@QAE@PB_W@Z:near
UNDEF:000007E4                                         ; CODE XREF: CStdOutStream::operator<<(wchar_t const *)+6Ep
UNDEF:000007E4                                         ; CStdOutStream::operator<<(wchar_t const *)+99p
UNDEF:000007E8 ; _DWORD __thiscall AString::AString(AString *__hidden this)
UNDEF:000007E8                 extrn ??0AString@@QAE@XZ:near
UNDEF:000007E8                                         ; CODE XREF: CStdOutStream::operator<<(wchar_t const *)+52p
UNDEF:000007EC ; int g_CodePage
UNDEF:000007EC                 extrn ?g_CodePage@@3HA:near
UNDEF:000007EC                                         ; DATA XREF: CStdOutStream::operator<<(wchar_t const *)+3Ar
UNDEF:000007EC                                         ; StdOut_Convert_UString_to_AString(UString const &,AString &)+Br
UNDEF:000007F0                 extrn ___security_cookie:near
UNDEF:000007F0                                         ; DATA XREF: CStdOutStream::operator<<(wchar_t const *)+26r
UNDEF:000007F0                                         ; CStdOutStream::operator<<(int)+18r ...
UNDEF:000007F4                 extrn ___CxxFrameHandler3:near
UNDEF:000007F4                                         ; CODE XREF: __ehhandler$??6CStdOutStream@@QAEAAV0@PB_W@Z+16j
UNDEF:000007F8 ; __fastcall __security_check_cookie(x)
UNDEF:000007F8                 extrn @__security_check_cookie@4:near
UNDEF:000007F8                                         ; CODE XREF: CStdOutStream::operator<<(int)+57p
UNDEF:000007F8                                         ; CStdOutStream::operator<<(__int64)+59p ...
UNDEF:000007FC ; __fastcall _RTC_CheckStackVars(x, x)
UNDEF:000007FC                 extrn @_RTC_CheckStackVars@8:near
UNDEF:000007FC                                         ; CODE XREF: CStdOutStream::operator<<(wchar_t const *)+EFp
UNDEF:000007FC                                         ; CStdOutStream::operator<<(int)+4Ap ...
UNDEF:00000800 ; void __cdecl operator delete(void *)
UNDEF:00000800                 extrn ??3@YAXPAX@Z:near ; CODE XREF: AString::~AString(void)+23p
UNDEF:00000800                                         ; UString::~UString(void)+23p
UNDEF:00000804 ; int __cdecl _fputs(const char *Str, FILE *File)
UNDEF:00000804                 extrn __imp__fputs:near ; CODE XREF: CStdOutStream::operator<<(char const *)+1Bp
UNDEF:00000804                                         ; DATA XREF: CStdOutStream::operator<<(char const *)+1Br
UNDEF:00000808 ; void __stdcall ConvertInt64ToString(__int64, char *)
UNDEF:00000808                 extrn ?ConvertInt64ToString@@YGX_JPAD@Z:near
UNDEF:00000808                                         ; CODE XREF: CStdOutStream::operator<<(int)+2Fp
UNDEF:00000808                                         ; CStdOutStream::operator<<(__int64)+31p
UNDEF:0000080C ; void __stdcall ConvertUInt32ToString(unsigned int, char *)
UNDEF:0000080C                 extrn ?ConvertUInt32ToString@@YGXIPAD@Z:near
UNDEF:0000080C                                         ; CODE XREF: CStdOutStream::operator<<(uint)+38p
UNDEF:00000810 ; void __stdcall ConvertUInt64ToString(unsigned __int64, char *)
UNDEF:00000810                 extrn ?ConvertUInt64ToString@@YGX_KPAD@Z:near
UNDEF:00000810                                         ; CODE XREF: CStdOutStream::operator<<(unsigned __int64)+31p
UNDEF:00000814 ; int __cdecl atexit(void (__cdecl *)())
UNDEF:00000814                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'g_StdOut''(void)+26p
UNDEF:00000814                                         ; `dynamic initializer for 'g_StdErr''(void)+26p
UNDEF:00000818 ; FILE *__cdecl ___iob_func()
UNDEF:00000818                 extrn __imp____iob_func:near
UNDEF:00000818                                         ; CODE XREF: `dynamic initializer for 'g_StdOut''(void)+6p
UNDEF:00000818                                         ; `dynamic initializer for 'g_StdErr''(void)+6p
UNDEF:00000818                                         ; DATA XREF: ...
UNDEF:00000818
UNDEF:00000818
UNDEF:00000818                 end