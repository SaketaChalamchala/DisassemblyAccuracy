.rdata:00000000 ;
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.rdata:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.rdata:00000000 ; |                      License info: 48-3677-7074-51                      |
.rdata:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ;
.rdata:00000000 ; Input MD5   : 5C5EAE0256AD0E9DF53A63D11C963B40
.rdata:00000000 ; Input CRC32 : B3E12DCB
.rdata:00000000
.rdata:00000000 ; File Name   : C:\workspace\7z1505-src\CPP\7zip\Bundles\Alone\Debug\UserInputUtils.obj
.rdata:00000000 ; Format      : COFF (X386MAGIC)
.rdata:00000000 ; includelib "uuid.lib"
.rdata:00000000 ; includelib "MSVCRTD"
.rdata:00000000 ; includelib "OLDNAMES"
.rdata:00000000
.rdata:00000000                 .686p
.rdata:00000000                 .mmx
.rdata:00000000                 .model flat
.rdata:00000000
.rdata:00000000 ; ===========================================================================
.rdata:00000000
.rdata:00000000 ; Segment type: Pure data
.rdata:00000000 ; Segment permissions: Read
.rdata:00000000 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00000000 _rdata          segment para public 'DATA' use32
.rdata:00000000                 assume cs:_rdata
.rdata:00000000 $SG68337        db  3Fh ; ?             ; DATA XREF: .data:_kFirstQuestionMessageo
.rdata:00000001                 db  20h
.rdata:00000002                 db    0
.rdata:00000003                 db    0
.rdata:00000004                 db    0
.rdata:00000005                 db    0
.rdata:00000006                 db    0
.rdata:00000007                 db    0
.rdata:00000008 $SG68339        db '(Y)es / (N)o / (A)lways / (S)kip all / A(u)to rename all / (Q)uit'
.rdata:00000008                                         ; DATA XREF: .data:_kHelpQuestionMessageo
.rdata:00000008                 db '? ',0
.rdata:0000004C ; char _SG68372[]
.rdata:0000004C $SG68372        db 0Ah                  ; DATA XREF: GetPassword(CStdOutStream *)+43o
.rdata:0000004C                 db 'Enter password (will not be echoed):',0
.rdata:00000072                 align 4
.rdata:00000072 _rdata          ends
.rdata:00000072
.data:00000074 ; ===========================================================================
.data:00000074
.data:00000074 ; Segment type: Pure data
.data:00000074 ; Segment permissions: Read/Write
.data:00000074 _data           segment dword public 'DATA' use32
.data:00000074                 assume cs:_data
.data:00000074                 ;org 74h
.data:00000074 ; char *kFirstQuestionMessage
.data:00000074 _kFirstQuestionMessage dd offset $SG68337
.data:00000074                                         ; DATA XREF: ScanUserYesNoAllQuit(CStdOutStream *)+3Br
.data:00000078 ; char *kHelpQuestionMessage
.data:00000078 _kHelpQuestionMessage dd offset $SG68339
.data:00000078                                         ; DATA XREF: ScanUserYesNoAllQuit(CStdOutStream *)+4Fr
.data:00000078 _data           ends                    ; "(Y)es / (N)o / (A)lways / (S)kip all / "...
.data:00000078
.text:0000007C ; ===========================================================================
.text:0000007C
.text:0000007C ; Segment type: Pure code
.text:0000007C ; Segment permissions: Read/Execute
.text:0000007C _text           segment para public 'CODE' use32
.text:0000007C                 assume cs:_text
.text:0000007C                 ;org 7Ch
.text:0000007C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000007C
.text:0000007C ; =============== S U B R O U T I N E =======================================
.text:0000007C
.text:0000007C ; Attributes: bp-based frame
.text:0000007C
.text:0000007C ; enum  NUserAnswerMode::EEnum __stdcall ScanUserYesNoAllQuit(class CStdOutStream *)
.text:0000007C                 public ?ScanUserYesNoAllQuit@@YG?AW4EEnum@NUserAnswerMode@@PAVCStdOutStream@@@Z
.text:0000007C ?ScanUserYesNoAllQuit@@YG?AW4EEnum@NUserAnswerMode@@PAVCStdOutStream@@@Z proc near
.text:0000007C
.text:0000007C var_3C          = dword ptr -3Ch
.text:0000007C var_38          = dword ptr -38h
.text:0000007C var_34          = dword ptr -34h
.text:0000007C var_30          = dword ptr -30h
.text:0000007C var_2C          = dword ptr -2Ch
.text:0000007C var_28          = dword ptr -28h
.text:0000007C var_24          = dword ptr -24h
.text:0000007C var_1C          = byte ptr -1Ch
.text:0000007C var_C           = dword ptr -0Ch
.text:0000007C var_4           = dword ptr -4
.text:0000007C arg_0           = dword ptr  8
.text:0000007C
.text:0000007C                 push    ebp
.text:0000007D                 mov     ebp, esp
.text:0000007F                 push    0FFFFFFFFh
.text:00000081                 push    offset __ehhandler$?ScanUserYesNoAllQuit@@YG?AW4EEnum@NUserAnswerMode@@PAVCStdOutStream@@@Z
.text:00000086                 mov     eax, large fs:0
.text:0000008C                 push    eax
.text:0000008D                 sub     esp, 30h
.text:00000090                 push    edi
.text:00000091                 lea     edi, [ebp+var_3C]
.text:00000094                 mov     ecx, 0Ch
.text:00000099                 mov     eax, 0CCCCCCCCh
.text:0000009E                 rep stosd
.text:000000A0                 mov     eax, dword ptr ds:___security_cookie
.text:000000A5                 xor     eax, ebp
.text:000000A7                 push    eax
.text:000000A8                 lea     eax, [ebp+var_C]
.text:000000AB                 mov     large fs:0, eax
.text:000000B1                 cmp     [ebp+arg_0], 0
.text:000000B5                 jz      short loc_C5
.text:000000B7                 mov     eax, ds:_kFirstQuestionMessage
.text:000000BC                 push    eax             ; Str
.text:000000BD                 mov     ecx, [ebp+arg_0]
.text:000000C0                 call    ??6CStdOutStream@@QAEAAV0@PBD@Z ; CStdOutStream::operator<<(char const *)
.text:000000C5
.text:000000C5 loc_C5:                                 ; CODE XREF: ScanUserYesNoAllQuit(CStdOutStream *)+39j
.text:000000C5                                         ; ScanUserYesNoAllQuit(CStdOutStream *)+18Aj
.text:000000C5                 cmp     [ebp+arg_0], 0
.text:000000C9                 jz      short loc_E2
.text:000000CB                 mov     ecx, ds:_kHelpQuestionMessage
.text:000000D1                 push    ecx             ; Str
.text:000000D2                 mov     ecx, [ebp+arg_0]
.text:000000D5                 call    ??6CStdOutStream@@QAEAAV0@PBD@Z ; CStdOutStream::operator<<(char const *)
.text:000000DA                 mov     ecx, [ebp+arg_0] ; this
.text:000000DD                 call    ?Flush@CStdOutStream@@QAE_NXZ ; CStdOutStream::Flush(void)
.text:000000E2
.text:000000E2 loc_E2:                                 ; CODE XREF: ScanUserYesNoAllQuit(CStdOutStream *)+4Dj
.text:000000E2                 push    0
.text:000000E4                 lea     edx, [ebp+var_1C]
.text:000000E7                 push    edx
.text:000000E8                 mov     ecx, offset ?g_StdIn@@3VCStdInStream@@A ; CStdInStream g_StdIn
.text:000000ED                 call    ?ScanStringUntilNewLine@CStdInStream@@QAE?AVAString@@_N@Z ; CStdInStream::ScanStringUntilNewLine(bool)
.text:000000F2                 mov     [ebp+var_4], 0
.text:000000F9                 lea     ecx, [ebp+var_1C] ; this
.text:000000FC                 call    ?Trim@AString@@QAEXXZ ; AString::Trim(void)
.text:00000101                 lea     ecx, [ebp+var_1C] ; this
.text:00000104                 call    ?IsEmpty@AString@@QBE_NXZ ; AString::IsEmpty(void)
.text:00000109                 movzx   eax, al
.text:0000010C                 test    eax, eax
.text:0000010E                 jnz     $LN9            ; jumptable 00000148 default case
.text:00000114                 lea     ecx, [ebp+var_1C]
.text:00000117                 call    ??BAString@@QBEPBDXZ ; AString::operator char const *(void)
.text:0000011C                 movzx   ecx, byte ptr [eax]
.text:0000011F                 push    ecx             ; char
.text:00000120                 call    ?MyCharLower_Ascii@@YGDD@Z ; MyCharLower_Ascii(char)
.text:00000125                 movsx   edx, al
.text:00000128                 mov     [ebp+var_3C], edx
.text:0000012B                 mov     eax, [ebp+var_3C]
.text:0000012E                 sub     eax, 61h ; 'a'
.text:00000131                 mov     [ebp+var_3C], eax
.text:00000134                 cmp     [ebp+var_3C], 18h ; switch 25 cases
.text:00000138                 ja      $LN9            ; jumptable 00000148 default case
.text:0000013E                 mov     ecx, [ebp+var_3C]
.text:00000141                 movzx   edx, ds:$LN17[ecx]
.text:00000148                 jmp     ds:$LN22[edx*4] ; switch jump
.text:0000014F ; ---------------------------------------------------------------------------
.text:0000014F
.text:0000014F $LN6:                                   ; CODE XREF: ScanUserYesNoAllQuit(CStdOutStream *)+CCj
.text:0000014F                                         ; DATA XREF: .text:$LN22o
.text:0000014F                 mov     [ebp+var_24], 0 ; jumptable 00000148 case 24
.text:00000156                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000015D                 lea     ecx, [ebp+var_1C] ; this
.text:00000160                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00000165                 mov     eax, [ebp+var_24]
.text:00000168                 jmp     loc_20B
.text:0000016D ; ---------------------------------------------------------------------------
.text:0000016D
.text:0000016D $LN5:                                   ; CODE XREF: ScanUserYesNoAllQuit(CStdOutStream *)+CCj
.text:0000016D                                         ; DATA XREF: .text:$LN22o
.text:0000016D                 mov     [ebp+var_28], 1 ; jumptable 00000148 case 13
.text:00000174                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000017B                 lea     ecx, [ebp+var_1C] ; this
.text:0000017E                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00000183                 mov     eax, [ebp+var_28]
.text:00000186                 jmp     loc_20B
.text:0000018B ; ---------------------------------------------------------------------------
.text:0000018B
.text:0000018B $LN4:                                   ; CODE XREF: ScanUserYesNoAllQuit(CStdOutStream *)+CCj
.text:0000018B                                         ; DATA XREF: .text:$LN22o
.text:0000018B                 mov     [ebp+var_2C], 2 ; jumptable 00000148 case 0
.text:00000192                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000199                 lea     ecx, [ebp+var_1C] ; this
.text:0000019C                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:000001A1                 mov     eax, [ebp+var_2C]
.text:000001A4                 jmp     short loc_20B
.text:000001A6 ; ---------------------------------------------------------------------------
.text:000001A6
.text:000001A6 $LN3:                                   ; CODE XREF: ScanUserYesNoAllQuit(CStdOutStream *)+CCj
.text:000001A6                                         ; DATA XREF: .text:$LN22o
.text:000001A6                 mov     [ebp+var_30], 3 ; jumptable 00000148 case 18
.text:000001AD                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000001B4                 lea     ecx, [ebp+var_1C] ; this
.text:000001B7                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:000001BC                 mov     eax, [ebp+var_30]
.text:000001BF                 jmp     short loc_20B
.text:000001C1 ; ---------------------------------------------------------------------------
.text:000001C1
.text:000001C1 $LN2:                                   ; CODE XREF: ScanUserYesNoAllQuit(CStdOutStream *)+CCj
.text:000001C1                                         ; DATA XREF: .text:$LN22o
.text:000001C1                 mov     [ebp+var_34], 4 ; jumptable 00000148 case 20
.text:000001C8                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000001CF                 lea     ecx, [ebp+var_1C] ; this
.text:000001D2                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:000001D7                 mov     eax, [ebp+var_34]
.text:000001DA                 jmp     short loc_20B
.text:000001DC ; ---------------------------------------------------------------------------
.text:000001DC
.text:000001DC $LN1:                                   ; CODE XREF: ScanUserYesNoAllQuit(CStdOutStream *)+CCj
.text:000001DC                                         ; DATA XREF: .text:$LN22o
.text:000001DC                 mov     [ebp+var_38], 5 ; jumptable 00000148 case 16
.text:000001E3                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000001EA                 lea     ecx, [ebp+var_1C] ; this
.text:000001ED                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:000001F2                 mov     eax, [ebp+var_38]
.text:000001F5                 jmp     short loc_20B
.text:000001F7 ; ---------------------------------------------------------------------------
.text:000001F7
.text:000001F7 $LN9:                                   ; CODE XREF: ScanUserYesNoAllQuit(CStdOutStream *)+92j
.text:000001F7                                         ; ScanUserYesNoAllQuit(CStdOutStream *)+BCj ...
.text:000001F7                 mov     [ebp+var_4], 0FFFFFFFFh ; jumptable 00000148 default case
.text:000001FE                 lea     ecx, [ebp+var_1C] ; this
.text:00000201                 call    ??1AString@@QAE@XZ ; AString::~AString(void)
.text:00000206                 jmp     loc_C5
.text:0000020B ; ---------------------------------------------------------------------------
.text:0000020B
.text:0000020B loc_20B:                                ; CODE XREF: ScanUserYesNoAllQuit(CStdOutStream *)+ECj
.text:0000020B                                         ; ScanUserYesNoAllQuit(CStdOutStream *)+10Aj ...
.text:0000020B                 push    edx
.text:0000020C                 mov     ecx, ebp
.text:0000020E                 push    eax
.text:0000020F                 lea     edx, $LN21
.text:00000215                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:0000021A                 pop     eax
.text:0000021B                 pop     edx
.text:0000021C                 mov     ecx, [ebp+var_C]
.text:0000021F                 mov     large fs:0, ecx
.text:00000226                 pop     ecx
.text:00000227                 pop     edi
.text:00000228                 add     esp, 3Ch
.text:0000022B                 cmp     ebp, esp
.text:0000022D                 call    __RTC_CheckEsp
.text:00000232                 mov     esp, ebp
.text:00000234                 pop     ebp
.text:00000235                 retn    4
.text:00000235 ?ScanUserYesNoAllQuit@@YG?AW4EEnum@NUserAnswerMode@@PAVCStdOutStream@@@Z endp ; sp-analysis failed
.text:00000235
.text:00000235 ; ---------------------------------------------------------------------------
.text:00000238 $LN21           dd 1                    ; DATA XREF: ScanUserYesNoAllQuit(CStdOutStream *)+193o
.text:0000023C                 dd offset $LN20
.text:00000240 $LN20           dd 0FFFFFFE4h, 0Ch      ; DATA XREF: .text:0000023Co
.text:00000248                 dd offset $LN18         ; "scannedString"
.text:0000024C $LN18           db 'scannedString',0    ; DATA XREF: .text:00000248o
.text:0000025A                 align 4
.text:0000025C $LN22           dd offset $LN4          ; DATA XREF: ScanUserYesNoAllQuit(CStdOutStream *)+CCr
.text:0000025C                 dd offset $LN5          ; jump table for switch statement
.text:0000025C                 dd offset $LN1
.text:0000025C                 dd offset $LN3
.text:0000025C                 dd offset $LN2
.text:0000025C                 dd offset $LN6
.text:0000025C                 dd offset $LN9
.text:00000278 $LN17           db      0,     6,     6,     6
.text:00000278                                         ; DATA XREF: ScanUserYesNoAllQuit(CStdOutStream *)+C5r
.text:00000278                 db      6,     6,     6,     6 ; indirect table for switch statement
.text:00000278                 db      6,     6,     6,     6
.text:00000278                 db      6,     1,     6,     6
.text:00000278                 db      2,     6,     3,     6
.text:00000278                 db      4,     6,     6,     6
.text:00000278                 db      5
.text:00000291                 db 0Bh dup(0CCh)
.text:0000029C
.text:0000029C ; =============== S U B R O U T I N E =======================================
.text:0000029C
.text:0000029C ; Attributes: bp-based frame
.text:0000029C
.text:0000029C ; class UString __stdcall GetPassword(class CStdOutStream *)
.text:0000029C                 public ?GetPassword@@YG?AVUString@@PAVCStdOutStream@@@Z
.text:0000029C ?GetPassword@@YG?AVUString@@PAVCStdOutStream@@@Z proc near
.text:0000029C
.text:0000029C var_38          = dword ptr -38h
.text:0000029C var_30          = byte ptr -30h
.text:0000029C Mode            = dword ptr -1Ch
.text:0000029C var_11          = byte ptr -11h
.text:0000029C hConsoleHandle  = dword ptr -10h
.text:0000029C var_C           = dword ptr -0Ch
.text:0000029C var_4           = dword ptr -4
.text:0000029C arg_0           = dword ptr  8
.text:0000029C arg_4           = dword ptr  0Ch
.text:0000029C
.text:0000029C                 push    ebp
.text:0000029D                 mov     ebp, esp
.text:0000029F                 push    0FFFFFFFFh
.text:000002A1                 push    offset __ehhandler$?GetPassword@@YG?AVUString@@PAVCStdOutStream@@@Z
.text:000002A6                 mov     eax, large fs:0
.text:000002AC                 push    eax
.text:000002AD                 sub     esp, 2Ch
.text:000002B0                 push    esi
.text:000002B1                 push    edi
.text:000002B2                 lea     edi, [ebp+var_38]
.text:000002B5                 mov     ecx, 0Bh
.text:000002BA                 mov     eax, 0CCCCCCCCh
.text:000002BF                 rep stosd
.text:000002C1                 mov     eax, dword ptr ds:___security_cookie
.text:000002C6                 xor     eax, ebp
.text:000002C8                 push    eax
.text:000002C9                 lea     eax, [ebp+var_C]
.text:000002CC                 mov     large fs:0, eax
.text:000002D2                 mov     [ebp+var_38], 0
.text:000002D9                 cmp     [ebp+arg_4], 0
.text:000002DD                 jz      short loc_2F4
.text:000002DF                 push    offset $SG68372 ; "\nEnter password (will not be echoed):"
.text:000002E4                 mov     ecx, [ebp+arg_4]
.text:000002E7                 call    ??6CStdOutStream@@QAEAAV0@PBD@Z ; CStdOutStream::operator<<(char const *)
.text:000002EC                 mov     ecx, [ebp+arg_4] ; this
.text:000002EF                 call    ?Flush@CStdOutStream@@QAE_NXZ ; CStdOutStream::Flush(void)
.text:000002F4
.text:000002F4 loc_2F4:                                ; CODE XREF: GetPassword(CStdOutStream *)+41j
.text:000002F4                 mov     esi, esp
.text:000002F6                 push    0FFFFFFF6h      ; nStdHandle
.text:000002F8                 call    dword ptr ds:__imp__GetStdHandle@4 ; GetStdHandle(x)
.text:000002FE                 cmp     esi, esp
.text:00000300                 call    __RTC_CheckEsp
.text:00000305                 mov     [ebp+hConsoleHandle], eax
.text:00000308                 mov     [ebp+var_11], 0
.text:0000030C                 mov     [ebp+Mode], 0
.text:00000313                 cmp     [ebp+hConsoleHandle], 0FFFFFFFFh
.text:00000317                 jz      short loc_35D
.text:00000319                 cmp     [ebp+hConsoleHandle], 0
.text:0000031D                 jz      short loc_35D
.text:0000031F                 mov     esi, esp
.text:00000321                 lea     eax, [ebp+Mode]
.text:00000324                 push    eax             ; lpMode
.text:00000325                 mov     ecx, [ebp+hConsoleHandle]
.text:00000328                 push    ecx             ; hConsoleHandle
.text:00000329                 call    dword ptr ds:__imp__GetConsoleMode@8 ; GetConsoleMode(x,x)
.text:0000032F                 cmp     esi, esp
.text:00000331                 call    __RTC_CheckEsp
.text:00000336                 test    eax, eax
.text:00000338                 jz      short loc_35D
.text:0000033A                 mov     edx, [ebp+Mode]
.text:0000033D                 and     edx, 0FFFFFFFBh
.text:00000340                 mov     esi, esp
.text:00000342                 push    edx             ; dwMode
.text:00000343                 mov     eax, [ebp+hConsoleHandle]
.text:00000346                 push    eax             ; hConsoleHandle
.text:00000347                 call    dword ptr ds:__imp__SetConsoleMode@8 ; SetConsoleMode(x,x)
.text:0000034D                 cmp     esi, esp
.text:0000034F                 call    __RTC_CheckEsp
.text:00000354                 neg     eax
.text:00000356                 sbb     eax, eax
.text:00000358                 neg     eax
.text:0000035A                 mov     [ebp+var_11], al
.text:0000035D
.text:0000035D loc_35D:                                ; CODE XREF: GetPassword(CStdOutStream *)+7Bj
.text:0000035D                                         ; GetPassword(CStdOutStream *)+81j ...
.text:0000035D                 lea     ecx, [ebp+var_30]
.text:00000360                 push    ecx
.text:00000361                 mov     ecx, offset ?g_StdIn@@3VCStdInStream@@A ; CStdInStream g_StdIn
.text:00000366                 call    ?ScanUStringUntilNewLine@CStdInStream@@QAE?AVUString@@XZ ; CStdInStream::ScanUStringUntilNewLine(void)
.text:0000036B                 mov     [ebp+var_4], 1
.text:00000372                 movzx   edx, [ebp+var_11]
.text:00000376                 test    edx, edx
.text:00000378                 jz      short loc_391
.text:0000037A                 mov     esi, esp
.text:0000037C                 mov     eax, [ebp+Mode]
.text:0000037F                 push    eax             ; dwMode
.text:00000380                 mov     ecx, [ebp+hConsoleHandle]
.text:00000383                 push    ecx             ; hConsoleHandle
.text:00000384                 call    dword ptr ds:__imp__SetConsoleMode@8 ; SetConsoleMode(x,x)
.text:0000038A                 cmp     esi, esp
.text:0000038C                 call    __RTC_CheckEsp
.text:00000391
.text:00000391 loc_391:                                ; CODE XREF: GetPassword(CStdOutStream *)+DCj
.text:00000391                 cmp     [ebp+arg_4], 0
.text:00000395                 jz      short loc_3AC
.text:00000397                 push    offset ?endl@@YGAAVCStdOutStream@@AAV1@@Z ; endl(CStdOutStream &)
.text:0000039C                 mov     ecx, [ebp+arg_4]
.text:0000039F                 call    ??6CStdOutStream@@QAEAAV0@P6GAAV0@AAV0@@Z@Z ; CStdOutStream::operator<<(CStdOutStream & (*)(CStdOutStream &))
.text:000003A4                 mov     ecx, [ebp+arg_4] ; this
.text:000003A7                 call    ?Flush@CStdOutStream@@QAE_NXZ ; CStdOutStream::Flush(void)
.text:000003AC
.text:000003AC loc_3AC:                                ; CODE XREF: GetPassword(CStdOutStream *)+F9j
.text:000003AC                 lea     edx, [ebp+var_30]
.text:000003AF                 push    edx             ; struct UString *
.text:000003B0                 mov     ecx, [ebp+arg_0] ; this
.text:000003B3                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:000003B8                 mov     eax, [ebp+var_38]
.text:000003BB                 or      eax, 1
.text:000003BE                 mov     [ebp+var_38], eax
.text:000003C1                 mov     byte ptr [ebp+var_4], 0
.text:000003C5                 lea     ecx, [ebp+var_30] ; this
.text:000003C8                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000003CD                 mov     eax, [ebp+arg_0]
.text:000003D0                 push    edx
.text:000003D1                 mov     ecx, ebp
.text:000003D3                 push    eax
.text:000003D4                 lea     edx, $LN15
.text:000003DA                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:000003DF                 pop     eax
.text:000003E0                 pop     edx
.text:000003E1                 mov     ecx, [ebp+var_C]
.text:000003E4                 mov     large fs:0, ecx
.text:000003EB                 pop     ecx
.text:000003EC                 pop     edi
.text:000003ED                 pop     esi
.text:000003EE                 add     esp, 38h
.text:000003F1                 cmp     ebp, esp
.text:000003F3                 call    __RTC_CheckEsp
.text:000003F8                 mov     esp, ebp
.text:000003FA                 pop     ebp
.text:000003FB                 retn    8
.text:000003FB ?GetPassword@@YG?AVUString@@PAVCStdOutStream@@@Z endp
.text:000003FB
.text:000003FB ; ---------------------------------------------------------------------------
.text:000003FE                 align 10h
.text:00000400 $LN15           dd 2                    ; DATA XREF: GetPassword(CStdOutStream *)+138o
.text:00000404                 dd offset $LN14
.text:00000408 $LN14           dd 0FFFFFFE4h, 4        ; DATA XREF: .text:00000404o
.text:00000410                 dd offset $LN11         ; "mode"
.text:00000414                 dd 0FFFFFFD0h, 0Ch
.text:0000041C                 dd offset $LN12
.text:00000420 $LN12           dd 736572h              ; DATA XREF: .text:0000041Co
.text:00000424 $LN11           db 'mode',0             ; DATA XREF: .text:00000410o
.text:00000429                 align 4
.text:00000429 _text           ends
.text:00000429
.text$x:0000042C ; ===========================================================================
.text$x:0000042C
.text$x:0000042C ; Segment type: Pure code
.text$x:0000042C ; Segment permissions: Read/Execute
.text$x:0000042C _text$x         segment para public 'CODE' use32
.text$x:0000042C                 assume cs:_text$x
.text$x:0000042C                 ;org 42Ch
.text$x:0000042C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000042C
.text$x:0000042C ; =============== S U B R O U T I N E =======================================
.text$x:0000042C
.text$x:0000042C
.text$x:0000042C __unwindfunclet$?ScanUserYesNoAllQuit@@YG?AW4EEnum@NUserAnswerMode@@PAVCStdOutStream@@@Z$0 proc near
.text$x:0000042C                                         ; DATA XREF: .xdata$x:00000490o
.text$x:0000042C                 lea     ecx, [ebp-1Ch]  ; this
.text$x:0000042F                 jmp     ??1AString@@QAE@XZ ; AString::~AString(void)
.text$x:0000042F __unwindfunclet$?ScanUserYesNoAllQuit@@YG?AW4EEnum@NUserAnswerMode@@PAVCStdOutStream@@@Z$0 endp
.text$x:0000042F
.text$x:00000434
.text$x:00000434 ; =============== S U B R O U T I N E =======================================
.text$x:00000434
.text$x:00000434
.text$x:00000434 __ehhandler$?ScanUserYesNoAllQuit@@YG?AW4EEnum@NUserAnswerMode@@PAVCStdOutStream@@@Z proc near
.text$x:00000434                                         ; DATA XREF: ScanUserYesNoAllQuit(CStdOutStream *)+5o
.text$x:00000434
.text$x:00000434 arg_4           = dword ptr  8
.text$x:00000434
.text$x:00000434                 mov     edx, [esp+arg_4]
.text$x:00000438                 lea     eax, [edx+0Ch]
.text$x:0000043B                 mov     ecx, [edx-38h]
.text$x:0000043E                 xor     ecx, eax
.text$x:00000440                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000445                 mov     eax, offset __ehfuncinfo$?ScanUserYesNoAllQuit@@YG?AW4EEnum@NUserAnswerMode@@PAVCStdOutStream@@@Z
.text$x:0000044A                 jmp     ___CxxFrameHandler3
.text$x:0000044A __ehhandler$?ScanUserYesNoAllQuit@@YG?AW4EEnum@NUserAnswerMode@@PAVCStdOutStream@@@Z endp
.text$x:0000044A
.text$x:0000044F
.text$x:0000044F ; =============== S U B R O U T I N E =======================================
.text$x:0000044F
.text$x:0000044F
.text$x:0000044F __unwindfunclet$?GetPassword@@YG?AVUString@@PAVCStdOutStream@@@Z$0 proc near
.text$x:0000044F                                         ; DATA XREF: .xdata$x:000004C4o
.text$x:0000044F                 lea     ecx, [ebp-30h]  ; this
.text$x:00000452                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00000452 __unwindfunclet$?GetPassword@@YG?AVUString@@PAVCStdOutStream@@@Z$0 endp
.text$x:00000452
.text$x:00000457
.text$x:00000457 ; =============== S U B R O U T I N E =======================================
.text$x:00000457
.text$x:00000457
.text$x:00000457 __unwindfunclet$?GetPassword@@YG?AVUString@@PAVCStdOutStream@@@Z$1 proc near
.text$x:00000457                                         ; DATA XREF: .xdata$x:000004BCo
.text$x:00000457                 mov     eax, [ebp-38h]
.text$x:0000045A                 and     eax, 1
.text$x:0000045D                 jz      locret_46F
.text$x:00000463                 and     dword ptr [ebp-38h], 0FFFFFFFEh
.text$x:00000467                 mov     ecx, [ebp+8]    ; this
.text$x:0000046A                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:0000046F ; ---------------------------------------------------------------------------
.text$x:0000046F
.text$x:0000046F locret_46F:                             ; CODE XREF: __unwindfunclet$?GetPassword@@YG?AVUString@@PAVCStdOutStream@@@Z$1+6j
.text$x:0000046F                 retn
.text$x:0000046F __unwindfunclet$?GetPassword@@YG?AVUString@@PAVCStdOutStream@@@Z$1 endp
.text$x:0000046F
.text$x:00000470
.text$x:00000470 ; =============== S U B R O U T I N E =======================================
.text$x:00000470
.text$x:00000470
.text$x:00000470 __ehhandler$?GetPassword@@YG?AVUString@@PAVCStdOutStream@@@Z proc near
.text$x:00000470                                         ; DATA XREF: GetPassword(CStdOutStream *)+5o
.text$x:00000470
.text$x:00000470 arg_4           = dword ptr  8
.text$x:00000470
.text$x:00000470                 mov     edx, [esp+arg_4]
.text$x:00000474                 lea     eax, [edx+0Ch]
.text$x:00000477                 mov     ecx, [edx-38h]
.text$x:0000047A                 xor     ecx, eax
.text$x:0000047C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000481                 mov     eax, offset __ehfuncinfo$?GetPassword@@YG?AVUString@@PAVCStdOutStream@@@Z
.text$x:00000486                 jmp     ___CxxFrameHandler3
.text$x:00000486 __ehhandler$?GetPassword@@YG?AVUString@@PAVCStdOutStream@@@Z endp
.text$x:00000486
.text$x:00000486 ; ---------------------------------------------------------------------------
.text$x:0000048B                 align 4
.text$x:0000048B _text$x         ends
.text$x:0000048B
.xdata$x:0000048C ; ===========================================================================
.xdata$x:0000048C
.xdata$x:0000048C ; Segment type: Pure data
.xdata$x:0000048C ; Segment permissions: Read
.xdata$x:0000048C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000048C                 assume cs:_xdata$x
.xdata$x:0000048C                 ;org 48Ch
.xdata$x:0000048C __unwindtable$?ScanUserYesNoAllQuit@@YG?AW4EEnum@NUserAnswerMode@@PAVCStdOutStream@@@Z db 0FFh
.xdata$x:0000048C                                         ; DATA XREF: .xdata$x:0000049Co
.xdata$x:0000048D                 db 0FFh
.xdata$x:0000048E                 db 0FFh
.xdata$x:0000048F                 db 0FFh
.xdata$x:00000490                 dd offset __unwindfunclet$?ScanUserYesNoAllQuit@@YG?AW4EEnum@NUserAnswerMode@@PAVCStdOutStream@@@Z$0
.xdata$x:00000494 __ehfuncinfo$?ScanUserYesNoAllQuit@@YG?AW4EEnum@NUserAnswerMode@@PAVCStdOutStream@@@Z db  22h ; "
.xdata$x:00000494                                         ; DATA XREF: __ehhandler$?ScanUserYesNoAllQuit@@YG?AW4EEnum@NUserAnswerMode@@PAVCStdOutStream@@@Z+11o
.xdata$x:00000495                 db    5
.xdata$x:00000496                 db  93h ; ô
.xdata$x:00000497                 db  19h
.xdata$x:00000498                 db    1
.xdata$x:00000499                 db    0
.xdata$x:0000049A                 db    0
.xdata$x:0000049B                 db    0
.xdata$x:0000049C                 dd offset __unwindtable$?ScanUserYesNoAllQuit@@YG?AW4EEnum@NUserAnswerMode@@PAVCStdOutStream@@@Z
.xdata$x:000004A0                 db    0
.xdata$x:000004A1                 db    0
.xdata$x:000004A2                 db    0
.xdata$x:000004A3                 db    0
.xdata$x:000004A4                 db    0
.xdata$x:000004A5                 db    0
.xdata$x:000004A6                 db    0
.xdata$x:000004A7                 db    0
.xdata$x:000004A8                 db    0
.xdata$x:000004A9                 db    0
.xdata$x:000004AA                 db    0
.xdata$x:000004AB                 db    0
.xdata$x:000004AC                 db    0
.xdata$x:000004AD                 db    0
.xdata$x:000004AE                 db    0
.xdata$x:000004AF                 db    0
.xdata$x:000004B0                 db    0
.xdata$x:000004B1                 db    0
.xdata$x:000004B2                 db    0
.xdata$x:000004B3                 db    0
.xdata$x:000004B4                 db    1
.xdata$x:000004B5                 db    0
.xdata$x:000004B6                 db    0
.xdata$x:000004B7                 db    0
.xdata$x:000004B8 __unwindtable$?GetPassword@@YG?AVUString@@PAVCStdOutStream@@@Z db 0FFh
.xdata$x:000004B8                                         ; DATA XREF: .xdata$x:000004D0o
.xdata$x:000004B9                 db 0FFh
.xdata$x:000004BA                 db 0FFh
.xdata$x:000004BB                 db 0FFh
.xdata$x:000004BC                 dd offset __unwindfunclet$?GetPassword@@YG?AVUString@@PAVCStdOutStream@@@Z$1
.xdata$x:000004C0                 db    0
.xdata$x:000004C1                 db    0
.xdata$x:000004C2                 db    0
.xdata$x:000004C3                 db    0
.xdata$x:000004C4                 dd offset __unwindfunclet$?GetPassword@@YG?AVUString@@PAVCStdOutStream@@@Z$0
.xdata$x:000004C8 __ehfuncinfo$?GetPassword@@YG?AVUString@@PAVCStdOutStream@@@Z db  22h ; "
.xdata$x:000004C8                                         ; DATA XREF: __ehhandler$?GetPassword@@YG?AVUString@@PAVCStdOutStream@@@Z+11o
.xdata$x:000004C9                 db    5
.xdata$x:000004CA                 db  93h ; ô
.xdata$x:000004CB                 db  19h
.xdata$x:000004CC                 db    2
.xdata$x:000004CD                 db    0
.xdata$x:000004CE                 db    0
.xdata$x:000004CF                 db    0
.xdata$x:000004D0                 dd offset __unwindtable$?GetPassword@@YG?AVUString@@PAVCStdOutStream@@@Z
.xdata$x:000004D4                 db    0
.xdata$x:000004D5                 db    0
.xdata$x:000004D6                 db    0
.xdata$x:000004D7                 db    0
.xdata$x:000004D8                 db    0
.xdata$x:000004D9                 db    0
.xdata$x:000004DA                 db    0
.xdata$x:000004DB                 db    0
.xdata$x:000004DC                 db    0
.xdata$x:000004DD                 db    0
.xdata$x:000004DE                 db    0
.xdata$x:000004DF                 db    0
.xdata$x:000004E0                 db    0
.xdata$x:000004E1                 db    0
.xdata$x:000004E2                 db    0
.xdata$x:000004E3                 db    0
.xdata$x:000004E4                 db    0
.xdata$x:000004E5                 db    0
.xdata$x:000004E6                 db    0
.xdata$x:000004E7                 db    0
.xdata$x:000004E8                 db    1
.xdata$x:000004E9                 db    0
.xdata$x:000004EA                 db    0
.xdata$x:000004EB                 db    0
.xdata$x:000004EB _xdata$x        ends
.xdata$x:000004EB
.rtc$TMZ:000004EC ; ===========================================================================
.rtc$TMZ:000004EC
.rtc$TMZ:000004EC ; Segment type: Pure data
.rtc$TMZ:000004EC ; Segment permissions: Read
.rtc$TMZ:000004EC _rtc$TMZ        segment dword public 'DATA' use32
.rtc$TMZ:000004EC                 assume cs:_rtc$TMZ
.rtc$TMZ:000004EC                 ;org 4ECh
.rtc$TMZ:000004EC ; COMDAT (pick any)
.rtc$TMZ:000004EC __RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
.rtc$TMZ:000004EC _rtc$TMZ        ends
.rtc$TMZ:000004EC
.rtc$IMZ:000004F0 ; ===========================================================================
.rtc$IMZ:000004F0
.rtc$IMZ:000004F0 ; Segment type: Pure data
.rtc$IMZ:000004F0 ; Segment permissions: Read
.rtc$IMZ:000004F0 _rtc$IMZ        segment dword public 'DATA' use32
.rtc$IMZ:000004F0                 assume cs:_rtc$IMZ
.rtc$IMZ:000004F0                 ;org 4F0h
.rtc$IMZ:000004F0 ; COMDAT (pick any)
.rtc$IMZ:000004F0 __RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
.rtc$IMZ:000004F0 _rtc$IMZ        ends
.rtc$IMZ:000004F0
.text:000004F4 ; ===========================================================================
.text:000004F4
.text:000004F4 ; Segment type: Pure code
.text:000004F4 ; Segment permissions: Read/Execute
.text:000004F4 _text           segment para public 'CODE' use32
.text:000004F4                 assume cs:_text
.text:000004F4                 ;org 4F4h
.text:000004F4 ; COMDAT (pick any)
.text:000004F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000004F4
.text:000004F4 ; =============== S U B R O U T I N E =======================================
.text:000004F4
.text:000004F4 ; Attributes: bp-based frame
.text:000004F4
.text:000004F4 ; char __stdcall MyCharLower_Ascii(char)
.text:000004F4                 public ?MyCharLower_Ascii@@YGDD@Z
.text:000004F4 ?MyCharLower_Ascii@@YGDD@Z proc near    ; CODE XREF: ScanUserYesNoAllQuit(CStdOutStream *)+A4p
.text:000004F4
.text:000004F4 arg_0           = byte ptr  8
.text:000004F4
.text:000004F4                 push    ebp
.text:000004F5                 mov     ebp, esp
.text:000004F7                 movsx   eax, [ebp+arg_0]
.text:000004FB                 cmp     eax, 41h ; 'A'
.text:000004FE                 jl      short loc_512
.text:00000500                 movsx   ecx, [ebp+arg_0]
.text:00000504                 cmp     ecx, 5Ah ; 'Z'
.text:00000507                 jg      short loc_512
.text:00000509                 movzx   eax, [ebp+arg_0]
.text:0000050D                 add     eax, 20h ; ' '
.text:00000510                 jmp     short loc_515
.text:00000512 ; ---------------------------------------------------------------------------
.text:00000512
.text:00000512 loc_512:                                ; CODE XREF: MyCharLower_Ascii(char)+Aj
.text:00000512                                         ; MyCharLower_Ascii(char)+13j
.text:00000512                 mov     al, [ebp+arg_0]
.text:00000515
.text:00000515 loc_515:                                ; CODE XREF: MyCharLower_Ascii(char)+1Cj
.text:00000515                 pop     ebp
.text:00000516                 retn    4
.text:00000516 ?MyCharLower_Ascii@@YGDD@Z endp
.text:00000516
.text:00000516 ; ---------------------------------------------------------------------------
.text:00000519                 align 4
.text:00000519 _text           ends
.text:00000519
.text:0000051C ; ===========================================================================
.text:0000051C
.text:0000051C ; Segment type: Pure code
.text:0000051C ; Segment permissions: Read/Execute
.text:0000051C _text           segment para public 'CODE' use32
.text:0000051C                 assume cs:_text
.text:0000051C                 ;org 51Ch
.text:0000051C ; COMDAT (pick any)
.text:0000051C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000051C
.text:0000051C ; =============== S U B R O U T I N E =======================================
.text:0000051C
.text:0000051C ; Attributes: bp-based frame
.text:0000051C
.text:0000051C ; _DWORD __thiscall AString::~AString(AString *__hidden this)
.text:0000051C                 public ??1AString@@QAE@XZ
.text:0000051C ??1AString@@QAE@XZ proc near            ; CODE XREF: ScanUserYesNoAllQuit(CStdOutStream *)+E4p
.text:0000051C                                         ; ScanUserYesNoAllQuit(CStdOutStream *)+102p ...
.text:0000051C
.text:0000051C var_8           = dword ptr -8
.text:0000051C var_4           = dword ptr -4
.text:0000051C
.text:0000051C                 push    ebp
.text:0000051D                 mov     ebp, esp
.text:0000051F                 sub     esp, 8
.text:00000522                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00000529                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000530                 mov     [ebp+var_4], ecx
.text:00000533                 mov     eax, [ebp+var_4]
.text:00000536                 mov     ecx, [eax]
.text:00000538                 mov     [ebp+var_8], ecx
.text:0000053B                 mov     edx, [ebp+var_8]
.text:0000053E                 push    edx             ; void *
.text:0000053F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00000544                 add     esp, 4
.text:00000547                 add     esp, 8
.text:0000054A                 cmp     ebp, esp
.text:0000054C                 call    __RTC_CheckEsp
.text:00000551                 mov     esp, ebp
.text:00000553                 pop     ebp
.text:00000554                 retn
.text:00000554 ??1AString@@QAE@XZ endp
.text:00000554
.text:00000554 ; ---------------------------------------------------------------------------
.text:00000555                 align 4
.text:00000555 _text           ends
.text:00000555
.text:00000558 ; ===========================================================================
.text:00000558
.text:00000558 ; Segment type: Pure code
.text:00000558 ; Segment permissions: Read/Execute
.text:00000558 _text           segment para public 'CODE' use32
.text:00000558                 assume cs:_text
.text:00000558                 ;org 558h
.text:00000558 ; COMDAT (pick any)
.text:00000558                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000558
.text:00000558 ; =============== S U B R O U T I N E =======================================
.text:00000558
.text:00000558 ; Attributes: bp-based frame
.text:00000558
.text:00000558 ; bool __thiscall AString::IsEmpty(AString *__hidden this)
.text:00000558                 public ?IsEmpty@AString@@QBE_NXZ
.text:00000558 ?IsEmpty@AString@@QBE_NXZ proc near     ; CODE XREF: ScanUserYesNoAllQuit(CStdOutStream *)+88p
.text:00000558
.text:00000558 var_4           = dword ptr -4
.text:00000558
.text:00000558                 push    ebp
.text:00000559                 mov     ebp, esp
.text:0000055B                 push    ecx
.text:0000055C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000563                 mov     [ebp+var_4], ecx
.text:00000566                 mov     eax, [ebp+var_4]
.text:00000569                 xor     ecx, ecx
.text:0000056B                 cmp     dword ptr [eax+4], 0
.text:0000056F                 setz    cl
.text:00000572                 mov     al, cl
.text:00000574                 mov     esp, ebp
.text:00000576                 pop     ebp
.text:00000577                 retn
.text:00000577 ?IsEmpty@AString@@QBE_NXZ endp
.text:00000577
.text:00000577 _text           ends
.text:00000577
.text:00000578 ; ===========================================================================
.text:00000578
.text:00000578 ; Segment type: Pure code
.text:00000578 ; Segment permissions: Read/Execute
.text:00000578 _text           segment para public 'CODE' use32
.text:00000578                 assume cs:_text
.text:00000578                 ;org 578h
.text:00000578 ; COMDAT (pick any)
.text:00000578                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000578
.text:00000578 ; =============== S U B R O U T I N E =======================================
.text:00000578
.text:00000578 ; Attributes: bp-based frame
.text:00000578
.text:00000578 ; public: __thiscall AString::operator char const *(void)const
.text:00000578                 public ??BAString@@QBEPBDXZ
.text:00000578 ??BAString@@QBEPBDXZ proc near          ; CODE XREF: ScanUserYesNoAllQuit(CStdOutStream *)+9Bp
.text:00000578
.text:00000578 var_4           = dword ptr -4
.text:00000578
.text:00000578                 push    ebp
.text:00000579                 mov     ebp, esp
.text:0000057B                 push    ecx
.text:0000057C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000583                 mov     [ebp+var_4], ecx
.text:00000586                 mov     eax, [ebp+var_4]
.text:00000589                 mov     eax, [eax]
.text:0000058B                 mov     esp, ebp
.text:0000058D                 pop     ebp
.text:0000058E                 retn
.text:0000058E ??BAString@@QBEPBDXZ endp
.text:0000058E
.text:0000058E ; ---------------------------------------------------------------------------
.text:0000058F                 align 10h
.text:0000058F _text           ends
.text:0000058F
.text:00000590 ; ===========================================================================
.text:00000590
.text:00000590 ; Segment type: Pure code
.text:00000590 ; Segment permissions: Read/Execute
.text:00000590 _text           segment para public 'CODE' use32
.text:00000590                 assume cs:_text
.text:00000590                 ;org 590h
.text:00000590 ; COMDAT (pick any)
.text:00000590                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000590
.text:00000590 ; =============== S U B R O U T I N E =======================================
.text:00000590
.text:00000590 ; Attributes: bp-based frame
.text:00000590
.text:00000590 ; void __thiscall AString::Trim(AString *__hidden this)
.text:00000590                 public ?Trim@AString@@QAEXXZ
.text:00000590 ?Trim@AString@@QAEXXZ proc near         ; CODE XREF: ScanUserYesNoAllQuit(CStdOutStream *)+80p
.text:00000590
.text:00000590 var_4           = dword ptr -4
.text:00000590
.text:00000590                 push    ebp
.text:00000591                 mov     ebp, esp
.text:00000593                 push    ecx
.text:00000594                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000059B                 mov     [ebp+var_4], ecx
.text:0000059E                 mov     ecx, [ebp+var_4] ; this
.text:000005A1                 call    ?TrimRight@AString@@QAEXXZ ; AString::TrimRight(void)
.text:000005A6                 mov     ecx, [ebp+var_4] ; this
.text:000005A9                 call    ?TrimLeft@AString@@QAEXXZ ; AString::TrimLeft(void)
.text:000005AE                 add     esp, 4
.text:000005B1                 cmp     ebp, esp
.text:000005B3                 call    __RTC_CheckEsp
.text:000005B8                 mov     esp, ebp
.text:000005BA                 pop     ebp
.text:000005BB                 retn
.text:000005BB ?Trim@AString@@QAEXXZ endp
.text:000005BB
.text:000005BB _text           ends
.text:000005BB
.text:000005BC ; ===========================================================================
.text:000005BC
.text:000005BC ; Segment type: Pure code
.text:000005BC ; Segment permissions: Read/Execute
.text:000005BC _text           segment para public 'CODE' use32
.text:000005BC                 assume cs:_text
.text:000005BC                 ;org 5BCh
.text:000005BC ; COMDAT (pick any)
.text:000005BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000005BC
.text:000005BC ; =============== S U B R O U T I N E =======================================
.text:000005BC
.text:000005BC ; Attributes: bp-based frame
.text:000005BC
.text:000005BC ; int __stdcall CStdOutStream::operator<<(char *Str)
.text:000005BC                 public ??6CStdOutStream@@QAEAAV0@PBD@Z
.text:000005BC ??6CStdOutStream@@QAEAAV0@PBD@Z proc near
.text:000005BC                                         ; CODE XREF: ScanUserYesNoAllQuit(CStdOutStream *)+44p
.text:000005BC                                         ; ScanUserYesNoAllQuit(CStdOutStream *)+59p ...
.text:000005BC
.text:000005BC var_4           = dword ptr -4
.text:000005BC Str             = dword ptr  8
.text:000005BC
.text:000005BC                 push    ebp
.text:000005BD                 mov     ebp, esp
.text:000005BF                 push    ecx
.text:000005C0                 push    esi
.text:000005C1                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000005C8                 mov     [ebp+var_4], ecx
.text:000005CB                 mov     esi, esp
.text:000005CD                 mov     eax, [ebp+var_4]
.text:000005D0                 mov     ecx, [eax]
.text:000005D2                 push    ecx             ; File
.text:000005D3                 mov     edx, [ebp+Str]
.text:000005D6                 push    edx             ; Str
.text:000005D7                 call    dword ptr ds:__imp__fputs
.text:000005DD                 add     esp, 8
.text:000005E0                 cmp     esi, esp
.text:000005E2                 call    __RTC_CheckEsp
.text:000005E7                 mov     eax, [ebp+var_4]
.text:000005EA                 pop     esi
.text:000005EB                 add     esp, 4
.text:000005EE                 cmp     ebp, esp
.text:000005F0                 call    __RTC_CheckEsp
.text:000005F5                 mov     esp, ebp
.text:000005F7                 pop     ebp
.text:000005F8                 retn    4
.text:000005F8 ??6CStdOutStream@@QAEAAV0@PBD@Z endp
.text:000005F8
.text:000005F8 ; ---------------------------------------------------------------------------
.text:000005FB                 align 4
.text:000005FB _text           ends
.text:000005FB
.text:000005FC ; ===========================================================================
.text:000005FC
.text:000005FC ; Segment type: Pure code
.text:000005FC ; Segment permissions: Read/Execute
.text:000005FC _text           segment para public 'CODE' use32
.text:000005FC                 assume cs:_text
.text:000005FC                 ;org 5FCh
.text:000005FC ; COMDAT (pick any)
.text:000005FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000005FC
.text:000005FC ; =============== S U B R O U T I N E =======================================
.text:000005FC
.text:000005FC ; Attributes: bp-based frame
.text:000005FC
.text:000005FC ; _DWORD __thiscall UString::~UString(UString *__hidden this)
.text:000005FC                 public ??1UString@@QAE@XZ
.text:000005FC ??1UString@@QAE@XZ proc near            ; CODE XREF: GetPassword(CStdOutStream *)+12Cp
.text:000005FC                                         ; __unwindfunclet$?GetPassword@@YG?AVUString@@PAVCStdOutStream@@@Z$0+3j ...
.text:000005FC
.text:000005FC var_8           = dword ptr -8
.text:000005FC var_4           = dword ptr -4
.text:000005FC
.text:000005FC                 push    ebp
.text:000005FD                 mov     ebp, esp
.text:000005FF                 sub     esp, 8
.text:00000602                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00000609                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000610                 mov     [ebp+var_4], ecx
.text:00000613                 mov     eax, [ebp+var_4]
.text:00000616                 mov     ecx, [eax]
.text:00000618                 mov     [ebp+var_8], ecx
.text:0000061B                 mov     edx, [ebp+var_8]
.text:0000061E                 push    edx             ; void *
.text:0000061F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00000624                 add     esp, 4
.text:00000627                 add     esp, 8
.text:0000062A                 cmp     ebp, esp
.text:0000062C                 call    __RTC_CheckEsp
.text:00000631                 mov     esp, ebp
.text:00000633                 pop     ebp
.text:00000634                 retn
.text:00000634 ??1UString@@QAE@XZ endp
.text:00000634
.text:00000634 ; ---------------------------------------------------------------------------
.text:00000635                 align 4
.text:00000635 _text           ends
.text:00000635
.text:00000638 ; ===========================================================================
.text:00000638
.text:00000638 ; Segment type: Pure code
.text:00000638 ; Segment permissions: Read/Execute
.text:00000638 _text           segment para public 'CODE' use32
.text:00000638                 assume cs:_text
.text:00000638                 ;org 638h
.text:00000638 ; COMDAT (pick any)
.text:00000638                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000638
.text:00000638 ; =============== S U B R O U T I N E =======================================
.text:00000638
.text:00000638 ; Attributes: bp-based frame
.text:00000638
.text:00000638 ; public: class CStdOutStream & __thiscall CStdOutStream::operator<<(class CStdOutStream & (__stdcall *)(class CStdOutStream &))
.text:00000638                 public ??6CStdOutStream@@QAEAAV0@P6GAAV0@AAV0@@Z@Z
.text:00000638 ??6CStdOutStream@@QAEAAV0@P6GAAV0@AAV0@@Z@Z proc near
.text:00000638                                         ; CODE XREF: GetPassword(CStdOutStream *)+103p
.text:00000638
.text:00000638 var_4           = dword ptr -4
.text:00000638 arg_0           = dword ptr  8
.text:00000638
.text:00000638                 push    ebp
.text:00000639                 mov     ebp, esp
.text:0000063B                 push    ecx
.text:0000063C                 push    esi
.text:0000063D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000644                 mov     [ebp+var_4], ecx
.text:00000647                 mov     esi, esp
.text:00000649                 mov     eax, [ebp+var_4]
.text:0000064C                 push    eax
.text:0000064D                 call    [ebp+arg_0]
.text:00000650                 cmp     esi, esp
.text:00000652                 call    __RTC_CheckEsp
.text:00000657                 mov     eax, [ebp+var_4]
.text:0000065A                 pop     esi
.text:0000065B                 add     esp, 4
.text:0000065E                 cmp     ebp, esp
.text:00000660                 call    __RTC_CheckEsp
.text:00000665                 mov     esp, ebp
.text:00000667                 pop     ebp
.text:00000668                 retn    4
.text:00000668 ??6CStdOutStream@@QAEAAV0@P6GAAV0@AAV0@@Z@Z endp
.text:00000668
.text:00000668 _text           ends
.text:00000668
UNDEF:00000670 ; ===========================================================================
UNDEF:00000670
UNDEF:00000670 ; Segment type: Externs
UNDEF:00000670 ; UNDEF
UNDEF:00000670 ; struct AString __thiscall __high CStdInStream::ScanStringUntilNewLine(bool)
UNDEF:00000670                 extrn ?ScanStringUntilNewLine@CStdInStream@@QAE?AVAString@@_N@Z:near
UNDEF:00000670                                         ; CODE XREF: ScanUserYesNoAllQuit(CStdOutStream *)+71p
UNDEF:00000674 ; class CStdInStream g_StdIn
UNDEF:00000674                 extrn ?g_StdIn@@3VCStdInStream@@A:near
UNDEF:00000674                                         ; DATA XREF: ScanUserYesNoAllQuit(CStdOutStream *)+6Co
UNDEF:00000674                                         ; GetPassword(CStdOutStream *)+C5o
UNDEF:00000678 ; bool __thiscall CStdOutStream::Flush(CStdOutStream *__hidden this)
UNDEF:00000678                 extrn ?Flush@CStdOutStream@@QAE_NXZ:near
UNDEF:00000678                                         ; CODE XREF: ScanUserYesNoAllQuit(CStdOutStream *)+61p
UNDEF:00000678                                         ; GetPassword(CStdOutStream *)+53p ...
UNDEF:0000067C                 extrn ___security_cookie:near
UNDEF:0000067C                                         ; DATA XREF: ScanUserYesNoAllQuit(CStdOutStream *)+24r
UNDEF:0000067C                                         ; GetPassword(CStdOutStream *)+25r
UNDEF:00000680                 extrn ___CxxFrameHandler3:near
UNDEF:00000680                                         ; CODE XREF: __ehhandler$?ScanUserYesNoAllQuit@@YG?AW4EEnum@NUserAnswerMode@@PAVCStdOutStream@@@Z+16j
UNDEF:00000680                                         ; __ehhandler$?GetPassword@@YG?AVUString@@PAVCStdOutStream@@@Z+16j
UNDEF:00000684 ; __fastcall __security_check_cookie(x)
UNDEF:00000684                 extrn @__security_check_cookie@4:near
UNDEF:00000684                                         ; CODE XREF: __ehhandler$?ScanUserYesNoAllQuit@@YG?AW4EEnum@NUserAnswerMode@@PAVCStdOutStream@@@Z+Cp
UNDEF:00000684                                         ; __ehhandler$?GetPassword@@YG?AVUString@@PAVCStdOutStream@@@Z+Cp
UNDEF:00000688                 extrn __RTC_CheckEsp:near
UNDEF:00000688                                         ; CODE XREF: ScanUserYesNoAllQuit(CStdOutStream *)+1B1p
UNDEF:00000688                                         ; GetPassword(CStdOutStream *)+64p ...
UNDEF:0000068C ; __fastcall _RTC_CheckStackVars(x, x)
UNDEF:0000068C                 extrn @_RTC_CheckStackVars@8:near
UNDEF:0000068C                                         ; CODE XREF: ScanUserYesNoAllQuit(CStdOutStream *)+199p
UNDEF:0000068C                                         ; GetPassword(CStdOutStream *)+13Ep
UNDEF:00000690                 extrn __RTC_Shutdown:near
UNDEF:00000690                                         ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
UNDEF:00000694                 extrn __RTC_InitBase:near
UNDEF:00000694                                         ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
UNDEF:00000698 ; void __cdecl operator delete(void *)
UNDEF:00000698                 extrn ??3@YAXPAX@Z:near ; CODE XREF: AString::~AString(void)+23p
UNDEF:00000698                                         ; UString::~UString(void)+23p
UNDEF:0000069C ; void __thiscall AString::TrimLeft(AString *__hidden this)
UNDEF:0000069C                 extrn ?TrimLeft@AString@@QAEXXZ:near
UNDEF:0000069C                                         ; CODE XREF: AString::Trim(void)+19p
UNDEF:000006A0 ; void __thiscall AString::TrimRight(AString *__hidden this)
UNDEF:000006A0                 extrn ?TrimRight@AString@@QAEXXZ:near
UNDEF:000006A0                                         ; CODE XREF: AString::Trim(void)+11p
UNDEF:000006A4 ; int __cdecl _fputs(const char *Str, FILE *File)
UNDEF:000006A4                 extrn __imp__fputs:near ; CODE XREF: CStdOutStream::operator<<(char const *)+1Bp
UNDEF:000006A4                                         ; DATA XREF: CStdOutStream::operator<<(char const *)+1Br
UNDEF:000006A8 ; _DWORD __thiscall UString::UString(UString *__hidden this, const struct UString *)
UNDEF:000006A8                 extrn ??0UString@@QAE@ABV0@@Z:near
UNDEF:000006A8                                         ; CODE XREF: GetPassword(CStdOutStream *)+117p
UNDEF:000006AC ; class CStdOutStream & __stdcall endl(class CStdOutStream &)
UNDEF:000006AC                 extrn ?endl@@YGAAVCStdOutStream@@AAV1@@Z:near
UNDEF:000006AC                                         ; DATA XREF: GetPassword(CStdOutStream *)+FBo
UNDEF:000006B0 ; struct UString __thiscall __high CStdInStream::ScanUStringUntilNewLine()
UNDEF:000006B0                 extrn ?ScanUStringUntilNewLine@CStdInStream@@QAE?AVUString@@XZ:near
UNDEF:000006B0                                         ; CODE XREF: GetPassword(CStdOutStream *)+CAp
UNDEF:000006B4 ; BOOL __stdcall SetConsoleMode(HANDLE hConsoleHandle, DWORD dwMode)
UNDEF:000006B4                 extrn __imp__SetConsoleMode@8:near
UNDEF:000006B4                                         ; CODE XREF: GetPassword(CStdOutStream *)+ABp
UNDEF:000006B4                                         ; GetPassword(CStdOutStream *)+E8p
UNDEF:000006B4                                         ; DATA XREF: ...
UNDEF:000006B8 ; BOOL __stdcall GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode)
UNDEF:000006B8                 extrn __imp__GetConsoleMode@8:near
UNDEF:000006B8                                         ; CODE XREF: GetPassword(CStdOutStream *)+8Dp
UNDEF:000006B8                                         ; DATA XREF: GetPassword(CStdOutStream *)+8Dr
UNDEF:000006BC ; HANDLE __stdcall GetStdHandle(DWORD nStdHandle)
UNDEF:000006BC                 extrn __imp__GetStdHandle@4:near
UNDEF:000006BC                                         ; CODE XREF: GetPassword(CStdOutStream *)+5Cp
UNDEF:000006BC                                         ; DATA XREF: GetPassword(CStdOutStream *)+5Cr
UNDEF:000006BC
UNDEF:000006BC
UNDEF:000006BC                 end