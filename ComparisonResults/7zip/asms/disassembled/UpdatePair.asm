.rdata:00000000 ;
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.rdata:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.rdata:00000000 ; |                      License info: 48-3677-7074-51                      |
.rdata:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ;
.rdata:00000000 ; Input MD5   : B7EE75D26407B3EABB8E5CA88D197F84
.rdata:00000000 ; Input CRC32 : DF9105EC
.rdata:00000000
.rdata:00000000 ; File Name   : C:\workspace\7z1505-src\CPP\7zip\Bundles\Alone\Debug\UpdatePair.obj
.rdata:00000000 ; Format      : COFF (X386MAGIC)
.rdata:00000000 ; includelib "uuid.lib"
.rdata:00000000 ; includelib "MSVCRTD"
.rdata:00000000 ; includelib "OLDNAMES"
.rdata:00000000
.rdata:00000000                 .686p
.rdata:00000000                 .mmx
.rdata:00000000                 .model flat
.rdata:00000000
.rdata:00000000 ; ===========================================================================
.rdata:00000000
.rdata:00000000 ; Segment type: Pure data
.rdata:00000000 ; Segment permissions: Read
.rdata:00000000 _rdata          segment dword public 'DATA' use32
.rdata:00000000                 assume cs:_rdata
.rdata:00000000 $SG69563        db 'Duplicate filename in archive:',0
.rdata:00000000                                         ; DATA XREF: .data:_k_Duplicate_inArc_Messageo
.rdata:0000001F                 align 10h
.rdata:00000020 $SG69565        db 'Duplicate filename on disk:',0
.rdata:00000020                                         ; DATA XREF: .data:_k_Duplicate_inDir_Messageo
.rdata:0000003C $SG69567        db 'Internal file name collision (file on disk, file in archive):',0
.rdata:0000003C                                         ; DATA XREF: .data:_k_NotCensoredCollision_Messageo
.rdata:0000007A                 align 4
.rdata:0000007A _rdata          ends
.rdata:0000007A
.data:0000007C ; ===========================================================================
.data:0000007C
.data:0000007C ; Segment type: Pure data
.data:0000007C ; Segment permissions: Read/Write
.data:0000007C _data           segment dword public 'DATA' use32
.data:0000007C                 assume cs:_data
.data:0000007C                 ;org 7Ch
.data:0000007C ; char *k_Duplicate_inArc_Message
.data:0000007C _k_Duplicate_inArc_Message dd offset $SG69563
.data:0000007C                                         ; DATA XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+4EEr
.data:0000007C                                         ; "Duplicate filename in archive:"
.data:00000080 ; char *k_Duplicate_inDir_Message
.data:00000080 _k_Duplicate_inDir_Message dd offset $SG69565
.data:00000080                                         ; DATA XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+28Er
.data:00000080                                         ; "Duplicate filename on disk:"
.data:00000084 ; char *k_NotCensoredCollision_Message
.data:00000084 _k_NotCensoredCollision_Message dd offset $SG69567
.data:00000084                                         ; DATA XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+52Dr
.data:00000084 _data           ends                    ; "Internal file name collision (file on d"...
.data:00000084
.text:00000088 ; ===========================================================================
.text:00000088
.text:00000088 ; Segment type: Pure code
.text:00000088 ; Segment permissions: Read/Execute
.text:00000088 _text           segment para public 'CODE' use32
.text:00000088                 assume cs:_text
.text:00000088                 ;org 88h
.text:00000088                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000088
.text:00000088 ; =============== S U B R O U T I N E =======================================
.text:00000088
.text:00000088 ; Attributes: bp-based frame
.text:00000088
.text:00000088 ; void __stdcall GetUpdatePairInfoList(class CDirItems const &, class CObjectVector<struct CArcItem> const &, enum  NFileTimeType::EEnum, class CRecordVector<struct CUpdatePair> &)
.text:00000088                 public ?GetUpdatePairInfoList@@YGXABVCDirItems@@ABV?$CObjectVector@UCArcItem@@@@W4EEnum@NFileTimeType@@AAV?$CRecordVector@UCUpdatePair@@@@@Z
.text:00000088 ?GetUpdatePairInfoList@@YGXABVCDirItems@@ABV?$CObjectVector@UCArcItem@@@@W4EEnum@NFileTimeType@@AAV?$CRecordVector@UCUpdatePair@@@@@Z proc near
.text:00000088
.text:00000088 var_110         = dword ptr -110h
.text:00000088 var_10C         = dword ptr -10Ch
.text:00000088 var_108         = dword ptr -108h
.text:00000088 var_104         = dword ptr -104h
.text:00000088 var_100         = dword ptr -100h
.text:00000088 var_FC          = dword ptr -0FCh
.text:00000088 var_F8          = dword ptr -0F8h
.text:00000088 var_F4          = dword ptr -0F4h
.text:00000088 var_F0          = dword ptr -0F0h
.text:00000088 var_EC          = dword ptr -0ECh
.text:00000088 var_E8          = dword ptr -0E8h
.text:00000088 var_E4          = dword ptr -0E4h
.text:00000088 var_E0          = byte ptr -0E0h
.text:00000088 var_D1          = byte ptr -0D1h
.text:00000088 var_D0          = byte ptr -0D0h
.text:00000088 var_C4          = dword ptr -0C4h
.text:00000088 var_C0          = dword ptr -0C0h
.text:00000088 var_BC          = dword ptr -0BCh
.text:00000088 var_B8          = dword ptr -0B8h
.text:00000088 var_B4          = dword ptr -0B4h
.text:00000088 var_B0          = dword ptr -0B0h
.text:00000088 var_AC          = dword ptr -0ACh
.text:00000088 var_A8          = dword ptr -0A8h
.text:00000088 var_A0          = dword ptr -0A0h
.text:00000088 var_9C          = dword ptr -9Ch
.text:00000088 var_98          = dword ptr -98h
.text:00000088 var_94          = dword ptr -94h
.text:00000088 var_8C          = dword ptr -8Ch
.text:00000088 var_88          = dword ptr -88h
.text:00000088 var_84          = dword ptr -84h
.text:00000088 var_80          = dword ptr -80h
.text:00000088 var_7C          = dword ptr -7Ch
.text:00000088 var_78          = dword ptr -78h
.text:00000088 var_74          = dword ptr -74h
.text:00000088 var_6C          = byte ptr -6Ch
.text:00000088 var_5C          = dword ptr -5Ch
.text:00000088 var_58          = dword ptr -58h
.text:00000088 var_54          = dword ptr -54h
.text:00000088 var_50          = dword ptr -50h
.text:00000088 var_4C          = dword ptr -4Ch
.text:00000088 var_44          = byte ptr -44h
.text:00000088 var_3C          = dword ptr -3Ch
.text:00000088 var_38          = dword ptr -38h
.text:00000088 var_30          = byte ptr -30h
.text:00000088 var_1C          = byte ptr -1Ch
.text:00000088 var_C           = dword ptr -0Ch
.text:00000088 var_4           = dword ptr -4
.text:00000088 arg_0           = dword ptr  8
.text:00000088 arg_4           = dword ptr  0Ch
.text:00000088 arg_8           = dword ptr  10h
.text:00000088 arg_C           = dword ptr  14h
.text:00000088
.text:00000088                 push    ebp
.text:00000089                 mov     ebp, esp
.text:0000008B                 push    0FFFFFFFFh
.text:0000008D                 push    offset __ehhandler$?GetUpdatePairInfoList@@YGXABVCDirItems@@ABV?$CObjectVector@UCArcItem@@@@W4EEnum@NFileTimeType@@AAV?$CRecordVector@UCUpdatePair@@@@@Z
.text:00000092                 mov     eax, large fs:0
.text:00000098                 push    eax
.text:00000099                 sub     esp, 104h
.text:0000009F                 push    edi
.text:000000A0                 lea     edi, [ebp+var_110]
.text:000000A6                 mov     ecx, 41h ; 'A'
.text:000000AB                 mov     eax, 0CCCCCCCCh
.text:000000B0                 rep stosd
.text:000000B2                 mov     eax, dword ptr ds:___security_cookie
.text:000000B7                 xor     eax, ebp
.text:000000B9                 push    eax
.text:000000BA                 lea     eax, [ebp+var_C]
.text:000000BD                 mov     large fs:0, eax
.text:000000C3                 mov     [ebp+var_E4], 0
.text:000000CD                 lea     ecx, [ebp+var_1C]
.text:000000D0                 call    ??0?$CRecordVector@I@@QAE@XZ ; CRecordVector<uint>::CRecordVector<uint>(void)
.text:000000D5                 mov     [ebp+var_4], 0
.text:000000DC                 lea     ecx, [ebp+var_30]
.text:000000DF                 call    ??0?$CRecordVector@I@@QAE@XZ ; CRecordVector<uint>::CRecordVector<uint>(void)
.text:000000E4                 mov     byte ptr [ebp+var_4], 1
.text:000000E8                 mov     ecx, [ebp+arg_0]
.text:000000EB                 add     ecx, 24h ; '$'
.text:000000EE                 call    ?Size@?$CObjectVector@UCDirItem@@@@QBEIXZ ; CObjectVector<CDirItem>::Size(void)
.text:000000F3                 mov     [ebp+var_38], eax
.text:000000F6                 mov     ecx, [ebp+arg_4]
.text:000000F9                 call    ?Size@?$CObjectVector@UCArcItem@@@@QBEIXZ ; CObjectVector<CArcItem>::Size(void)
.text:000000FE                 mov     [ebp+var_3C], eax
.text:00000101                 mov     eax, [ebp+var_3C]
.text:00000104                 push    eax
.text:00000105                 lea     ecx, [ebp+var_44]
.text:00000108                 call    ??0?$CObjArray@H@@QAE@I@Z ; CObjArray<int>::CObjArray<int>(uint)
.text:0000010D                 mov     byte ptr [ebp+var_4], 2
.text:00000111                 lea     ecx, [ebp+var_44]
.text:00000114                 call    ??B?$CObjArray@H@@QAEPAHXZ ; CObjArray<int>::operator int *(void)
.text:00000119                 mov     [ebp+var_4C], eax
.text:0000011C                 mov     [ebp+var_50], 0
.text:00000123                 jmp     short loc_12E
.text:00000125 ; ---------------------------------------------------------------------------
.text:00000125
.text:00000125 loc_125:                                ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+BBj
.text:00000125                 mov     ecx, [ebp+var_50]
.text:00000128                 add     ecx, 1
.text:0000012B                 mov     [ebp+var_50], ecx
.text:0000012E
.text:0000012E loc_12E:                                ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+9Bj
.text:0000012E                 mov     edx, [ebp+var_50]
.text:00000131                 cmp     edx, [ebp+var_3C]
.text:00000134                 jnb     short loc_145
.text:00000136                 mov     eax, [ebp+var_50]
.text:00000139                 mov     ecx, [ebp+var_4C]
.text:0000013C                 mov     dword ptr [ecx+eax*4], 0
.text:00000143                 jmp     short loc_125
.text:00000145 ; ---------------------------------------------------------------------------
.text:00000145
.text:00000145 loc_145:                                ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+ACj
.text:00000145                 mov     edx, [ebp+var_3C]
.text:00000148                 push    edx
.text:00000149                 lea     ecx, [ebp+var_30]
.text:0000014C                 call    ?ClearAndSetSize@?$CRecordVector@I@@QAEXI@Z ; CRecordVector<uint>::ClearAndSetSize(uint)
.text:00000151                 push    0
.text:00000153                 lea     ecx, [ebp+var_30]
.text:00000156                 call    ??A?$CRecordVector@I@@QAEAAII@Z ; CRecordVector<uint>::operator[](uint)
.text:0000015B                 mov     [ebp+var_54], eax
.text:0000015E                 mov     [ebp+var_58], 0
.text:00000165                 jmp     short loc_170
.text:00000167 ; ---------------------------------------------------------------------------
.text:00000167
.text:00000167 loc_167:                                ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+FCj
.text:00000167                 mov     eax, [ebp+var_58]
.text:0000016A                 add     eax, 1
.text:0000016D                 mov     [ebp+var_58], eax
.text:00000170
.text:00000170 loc_170:                                ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+DDj
.text:00000170                 mov     ecx, [ebp+var_58]
.text:00000173                 cmp     ecx, [ebp+var_3C]
.text:00000176                 jnb     short loc_186
.text:00000178                 mov     edx, [ebp+var_58]
.text:0000017B                 mov     eax, [ebp+var_54]
.text:0000017E                 mov     ecx, [ebp+var_58]
.text:00000181                 mov     [eax+edx*4], ecx
.text:00000184                 jmp     short loc_167
.text:00000186 ; ---------------------------------------------------------------------------
.text:00000186
.text:00000186 loc_186:                                ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+EEj
.text:00000186                 mov     edx, [ebp+arg_4]
.text:00000189                 push    edx
.text:0000018A                 push    offset ?CompareArcItems@@YGHPBI0PAX@Z ; CompareArcItems(uint const *,uint const *,void *)
.text:0000018F                 lea     ecx, [ebp+var_30]
.text:00000192                 call    ?Sort@?$CRecordVector@I@@QAEXP6GHPBI0PAX@Z1@Z ; CRecordVector<uint>::Sort(int (*)(uint const *,uint const *,void *),void *)
.text:00000197                 mov     [ebp+var_5C], 0
.text:0000019E                 jmp     short loc_1A9
.text:000001A0 ; ---------------------------------------------------------------------------
.text:000001A0
.text:000001A0 loc_1A0:                                ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &):loc_215j
.text:000001A0                 mov     eax, [ebp+var_5C]
.text:000001A3                 add     eax, 1
.text:000001A6                 mov     [ebp+var_5C], eax
.text:000001A9
.text:000001A9 loc_1A9:                                ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+116j
.text:000001A9                 mov     ecx, [ebp+var_5C]
.text:000001AC                 add     ecx, 1
.text:000001AF                 cmp     ecx, [ebp+var_3C]
.text:000001B2                 jnb     short loc_217
.text:000001B4                 mov     edx, [ebp+var_5C]
.text:000001B7                 add     edx, 1
.text:000001BA                 push    edx
.text:000001BB                 lea     ecx, [ebp+var_30]
.text:000001BE                 call    ??A?$CRecordVector@I@@QAEAAII@Z ; CRecordVector<uint>::operator[](uint)
.text:000001C3                 mov     eax, [eax]
.text:000001C5                 push    eax
.text:000001C6                 mov     ecx, [ebp+arg_4]
.text:000001C9                 call    ??A?$CObjectVector@UCArcItem@@@@QBEABUCArcItem@@I@Z ; CObjectVector<CArcItem>::operator[](uint)
.text:000001CE                 push    eax
.text:000001CF                 mov     ecx, [ebp+var_5C]
.text:000001D2                 push    ecx
.text:000001D3                 lea     ecx, [ebp+var_30]
.text:000001D6                 call    ??A?$CRecordVector@I@@QAEAAII@Z ; CRecordVector<uint>::operator[](uint)
.text:000001DB                 mov     edx, [eax]
.text:000001DD                 push    edx
.text:000001DE                 mov     ecx, [ebp+arg_4]
.text:000001E1                 call    ??A?$CObjectVector@UCArcItem@@@@QBEABUCArcItem@@I@Z ; CObjectVector<CArcItem>::operator[](uint)
.text:000001E6                 push    eax
.text:000001E7                 call    ?CompareArcItemsBase@@YGHABUCArcItem@@0@Z ; CompareArcItemsBase(CArcItem const &,CArcItem const &)
.text:000001EC                 test    eax, eax
.text:000001EE                 jnz     short loc_215
.text:000001F0                 lea     ecx, [ebp+var_44]
.text:000001F3                 call    ??B?$CObjArray@H@@QAEPAHXZ ; CObjArray<int>::operator int *(void)
.text:000001F8                 mov     ecx, [ebp+var_5C]
.text:000001FB                 mov     dword ptr [eax+ecx*4], 1
.text:00000202                 lea     ecx, [ebp+var_44]
.text:00000205                 call    ??B?$CObjArray@H@@QAEPAHXZ ; CObjArray<int>::operator int *(void)
.text:0000020A                 mov     edx, [ebp+var_5C]
.text:0000020D                 mov     dword ptr [eax+edx*4+4], 0FFFFFFFFh
.text:00000215
.text:00000215 loc_215:                                ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+166j
.text:00000215                 jmp     short loc_1A0
.text:00000217 ; ---------------------------------------------------------------------------
.text:00000217
.text:00000217 loc_217:                                ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+12Aj
.text:00000217                 lea     ecx, [ebp+var_6C]
.text:0000021A                 call    ??0?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::CObjectVector<UString>(void)
.text:0000021F                 mov     byte ptr [ebp+var_4], 3
.text:00000223                 mov     eax, [ebp+var_38]
.text:00000226                 push    eax
.text:00000227                 lea     ecx, [ebp+var_6C]
.text:0000022A                 call    ?ClearAndReserve@?$CObjectVector@VUString@@@@QAEXI@Z ; CObjectVector<UString>::ClearAndReserve(uint)
.text:0000022F                 mov     [ebp+var_74], 0
.text:00000236                 jmp     short loc_241
.text:00000238 ; ---------------------------------------------------------------------------
.text:00000238
.text:00000238 loc_238:                                ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+208j
.text:00000238                 mov     ecx, [ebp+var_74]
.text:0000023B                 add     ecx, 1
.text:0000023E                 mov     [ebp+var_74], ecx
.text:00000241
.text:00000241 loc_241:                                ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+1AEj
.text:00000241                 mov     edx, [ebp+var_74]
.text:00000244                 cmp     edx, [ebp+var_38]
.text:00000247                 jnb     short loc_292
.text:00000249                 mov     eax, [ebp+var_74]
.text:0000024C                 push    eax
.text:0000024D                 lea     ecx, [ebp+var_D0]
.text:00000253                 push    ecx
.text:00000254                 mov     ecx, [ebp+arg_0]
.text:00000257                 call    ?GetLogPath@CDirItems@@QBE?AVUString@@I@Z ; CDirItems::GetLogPath(uint)
.text:0000025C                 mov     [ebp+var_E8], eax
.text:00000262                 mov     edx, [ebp+var_E8]
.text:00000268                 mov     [ebp+var_EC], edx
.text:0000026E                 mov     byte ptr [ebp+var_4], 4
.text:00000272                 mov     eax, [ebp+var_EC]
.text:00000278                 push    eax
.text:00000279                 lea     ecx, [ebp+var_6C]
.text:0000027C                 call    ?AddInReserved@?$CObjectVector@VUString@@@@QAEXABVUString@@@Z ; CObjectVector<UString>::AddInReserved(UString const &)
.text:00000281                 mov     byte ptr [ebp+var_4], 3
.text:00000285                 lea     ecx, [ebp+var_D0] ; this
.text:0000028B                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000290                 jmp     short loc_238
.text:00000292 ; ---------------------------------------------------------------------------
.text:00000292
.text:00000292 loc_292:                                ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+1BFj
.text:00000292                 lea     ecx, [ebp+var_1C]
.text:00000295                 push    ecx
.text:00000296                 lea     edx, [ebp+var_6C]
.text:00000299                 push    edx
.text:0000029A                 call    ?SortFileNames@@YGXABV?$CObjectVector@VUString@@@@AAV?$CRecordVector@I@@@Z ; SortFileNames(CObjectVector<UString> const &,CRecordVector<uint> &)
.text:0000029F                 mov     [ebp+var_74], 0
.text:000002A6                 jmp     short loc_2B1
.text:000002A8 ; ---------------------------------------------------------------------------
.text:000002A8
.text:000002A8 loc_2A8:                                ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &):loc_322j
.text:000002A8                 mov     eax, [ebp+var_74]
.text:000002AB                 add     eax, 1
.text:000002AE                 mov     [ebp+var_74], eax
.text:000002B1
.text:000002B1 loc_2B1:                                ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+21Ej
.text:000002B1                 mov     ecx, [ebp+var_74]
.text:000002B4                 add     ecx, 1
.text:000002B7                 cmp     ecx, [ebp+var_38]
.text:000002BA                 jnb     short loc_324
.text:000002BC                 mov     edx, [ebp+var_74]
.text:000002BF                 push    edx
.text:000002C0                 lea     ecx, [ebp+var_1C]
.text:000002C3                 call    ??A?$CRecordVector@I@@QAEAAII@Z ; CRecordVector<uint>::operator[](uint)
.text:000002C8                 mov     eax, [eax]
.text:000002CA                 push    eax
.text:000002CB                 lea     ecx, [ebp+var_6C]
.text:000002CE                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:000002D3                 mov     [ebp+var_78], eax
.text:000002D6                 mov     ecx, [ebp+var_74]
.text:000002D9                 add     ecx, 1
.text:000002DC                 push    ecx
.text:000002DD                 lea     ecx, [ebp+var_1C]
.text:000002E0                 call    ??A?$CRecordVector@I@@QAEAAII@Z ; CRecordVector<uint>::operator[](uint)
.text:000002E5                 mov     edx, [eax]
.text:000002E7                 push    edx
.text:000002E8                 lea     ecx, [ebp+var_6C]
.text:000002EB                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:000002F0                 mov     [ebp+var_7C], eax
.text:000002F3                 mov     ecx, [ebp+var_7C]
.text:000002F6                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000002FB                 push    eax             ; wchar_t *
.text:000002FC                 mov     ecx, [ebp+var_78]
.text:000002FF                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00000304                 push    eax             ; wchar_t *
.text:00000305                 call    ?CompareFileNames@@YGHPB_W0@Z ; CompareFileNames(wchar_t const *,wchar_t const *)
.text:0000030A                 test    eax, eax
.text:0000030C                 jnz     short loc_322
.text:0000030E                 mov     eax, [ebp+var_7C]
.text:00000311                 push    eax             ; int
.text:00000312                 mov     ecx, [ebp+var_78]
.text:00000315                 push    ecx             ; int
.text:00000316                 mov     edx, ds:_k_Duplicate_inDir_Message
.text:0000031C                 push    edx             ; char *
.text:0000031D                 call    ?ThrowError@@YGXPBDABVUString@@1@Z ; ThrowError(char const *,UString const &,UString const &)
.text:00000322 ; ---------------------------------------------------------------------------
.text:00000322
.text:00000322 loc_322:                                ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+284j
.text:00000322                 jmp     short loc_2A8
.text:00000324 ; ---------------------------------------------------------------------------
.text:00000324
.text:00000324 loc_324:                                ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+232j
.text:00000324                 mov     [ebp+var_80], 0
.text:0000032B                 mov     [ebp+var_84], 0
.text:00000335                 mov     [ebp+var_88], 0FFFFFFFFh
.text:0000033F                 mov     [ebp+var_8C], 0
.text:00000349
.text:00000349 loc_349:                                ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+801j
.text:00000349                 mov     eax, [ebp+var_80]
.text:0000034C                 cmp     eax, [ebp+var_38]
.text:0000034F                 jb      short loc_360
.text:00000351                 mov     ecx, [ebp+var_84]
.text:00000357                 cmp     ecx, [ebp+var_3C]
.text:0000035A                 jnb     loc_88E
.text:00000360
.text:00000360 loc_360:                                ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+2C7j
.text:00000360                 lea     ecx, [ebp+var_A0] ; this
.text:00000366                 call    ??0CUpdatePair@@QAE@XZ ; CUpdatePair::CUpdatePair(void)
.text:0000036B                 mov     [ebp+var_A8], 0FFFFFFFFh
.text:00000375                 mov     [ebp+var_AC], 0FFFFFFFFh
.text:0000037F                 mov     [ebp+var_B0], 0
.text:00000389                 mov     [ebp+var_B4], 0
.text:00000393                 mov     [ebp+var_B8], 0FFFFFFFFh
.text:0000039D                 mov     [ebp+var_BC], 0
.text:000003A7                 mov     edx, [ebp+var_80]
.text:000003AA                 cmp     edx, [ebp+var_38]
.text:000003AD                 jnb     short loc_3DB
.text:000003AF                 mov     eax, [ebp+var_80]
.text:000003B2                 push    eax
.text:000003B3                 lea     ecx, [ebp+var_1C]
.text:000003B6                 call    ??A?$CRecordVector@I@@QAEAAII@Z ; CRecordVector<uint>::operator[](uint)
.text:000003BB                 mov     ecx, [eax]
.text:000003BD                 mov     [ebp+var_A8], ecx
.text:000003C3                 mov     edx, [ebp+var_A8]
.text:000003C9                 push    edx
.text:000003CA                 mov     ecx, [ebp+arg_0]
.text:000003CD                 add     ecx, 24h ; '$'
.text:000003D0                 call    ??A?$CObjectVector@UCDirItem@@@@QBEABUCDirItem@@I@Z ; CObjectVector<CDirItem>::operator[](uint)
.text:000003D5                 mov     [ebp+var_B0], eax
.text:000003DB
.text:000003DB loc_3DB:                                ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+325j
.text:000003DB                 mov     eax, [ebp+var_84]
.text:000003E1                 cmp     eax, [ebp+var_3C]
.text:000003E4                 jnb     loc_498
.text:000003EA                 mov     ecx, [ebp+var_84]
.text:000003F0                 push    ecx
.text:000003F1                 lea     ecx, [ebp+var_30]
.text:000003F4                 call    ??A?$CRecordVector@I@@QAEAAII@Z ; CRecordVector<uint>::operator[](uint)
.text:000003F9                 mov     edx, [eax]
.text:000003FB                 mov     [ebp+var_AC], edx
.text:00000401                 mov     eax, [ebp+var_AC]
.text:00000407                 push    eax
.text:00000408                 mov     ecx, [ebp+arg_4]
.text:0000040B                 call    ??A?$CObjectVector@UCArcItem@@@@QBEABUCArcItem@@I@Z ; CObjectVector<CArcItem>::operator[](uint)
.text:00000410                 mov     [ebp+var_B4], eax
.text:00000416                 mov     [ebp+var_B8], 1
.text:00000420                 mov     ecx, [ebp+var_80]
.text:00000423                 cmp     ecx, [ebp+var_38]
.text:00000426                 jnb     short loc_498
.text:00000428                 mov     ecx, [ebp+var_B4]
.text:0000042E                 add     ecx, 10h
.text:00000431                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00000436                 push    eax             ; wchar_t *
.text:00000437                 mov     edx, [ebp+var_A8]
.text:0000043D                 push    edx
.text:0000043E                 lea     ecx, [ebp+var_6C]
.text:00000441                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00000446                 mov     ecx, eax
.text:00000448                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:0000044D                 push    eax             ; wchar_t *
.text:0000044E                 call    ?CompareFileNames@@YGHPB_W0@Z ; CompareFileNames(wchar_t const *,wchar_t const *)
.text:00000453                 mov     [ebp+var_B8], eax
.text:00000459                 cmp     [ebp+var_B8], 0
.text:00000460                 jnz     short loc_498
.text:00000462                 mov     ecx, [ebp+var_B0] ; this
.text:00000468                 call    ?IsDir@CDirItem@@QBE_NXZ ; CDirItem::IsDir(void)
.text:0000046D                 movzx   eax, al
.text:00000470                 mov     ecx, [ebp+var_B4]
.text:00000476                 movzx   edx, byte ptr [ecx+1Ch]
.text:0000047A                 cmp     eax, edx
.text:0000047C                 jz      short loc_498
.text:0000047E                 mov     eax, [ebp+var_B4]
.text:00000484                 movzx   ecx, byte ptr [eax+1Ch]
.text:00000488                 neg     ecx
.text:0000048A                 sbb     ecx, ecx
.text:0000048C                 and     ecx, 2
.text:0000048F                 add     ecx, 0FFFFFFFFh
.text:00000492                 mov     [ebp+var_B8], ecx
.text:00000498
.text:00000498 loc_498:                                ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+35Cj
.text:00000498                                         ; GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+39Ej ...
.text:00000498                 cmp     [ebp+var_B8], 0
.text:0000049F                 jge     short loc_4DA
.text:000004A1                 mov     edx, [ebp+var_A8]
.text:000004A7                 push    edx
.text:000004A8                 lea     ecx, [ebp+var_6C]
.text:000004AB                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:000004B0                 mov     [ebp+var_BC], eax
.text:000004B6                 mov     [ebp+var_A0], 2
.text:000004C0                 mov     eax, [ebp+var_A8]
.text:000004C6                 mov     [ebp+var_98], eax
.text:000004CC                 mov     ecx, [ebp+var_80]
.text:000004CF                 add     ecx, 1
.text:000004D2                 mov     [ebp+var_80], ecx
.text:000004D5                 jmp     loc_6FC
.text:000004DA ; ---------------------------------------------------------------------------
.text:000004DA
.text:000004DA loc_4DA:                                ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+417j
.text:000004DA                 cmp     [ebp+var_B8], 0
.text:000004E1                 jle     short loc_528
.text:000004E3                 mov     edx, [ebp+var_B4]
.text:000004E9                 add     edx, 10h
.text:000004EC                 mov     [ebp+var_BC], edx
.text:000004F2                 mov     eax, [ebp+var_B4]
.text:000004F8                 movzx   ecx, byte ptr [eax+20h]
.text:000004FC                 neg     ecx
.text:000004FE                 sbb     ecx, ecx
.text:00000500                 neg     ecx
.text:00000502                 mov     [ebp+var_A0], ecx
.text:00000508                 mov     edx, [ebp+var_AC]
.text:0000050E                 mov     [ebp+var_9C], edx
.text:00000514                 mov     eax, [ebp+var_84]
.text:0000051A                 add     eax, 1
.text:0000051D                 mov     [ebp+var_84], eax
.text:00000523                 jmp     loc_6FC
.text:00000528 ; ---------------------------------------------------------------------------
.text:00000528
.text:00000528 loc_528:                                ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+459j
.text:00000528                 lea     ecx, [ebp+var_44]
.text:0000052B                 call    ??B?$CObjArray@H@@QAEPAHXZ ; CObjArray<int>::operator int *(void)
.text:00000530                 mov     ecx, [ebp+var_84]
.text:00000536                 mov     edx, [eax+ecx*4]
.text:00000539                 mov     [ebp+var_C0], edx
.text:0000053F                 cmp     [ebp+var_C0], 0
.text:00000546                 jz      short loc_581
.text:00000548                 mov     eax, [ebp+var_84]
.text:0000054E                 add     eax, [ebp+var_C0]
.text:00000554                 push    eax
.text:00000555                 lea     ecx, [ebp+var_30]
.text:00000558                 call    ??A?$CRecordVector@I@@QAEAAII@Z ; CRecordVector<uint>::operator[](uint)
.text:0000055D                 mov     ecx, [eax]
.text:0000055F                 push    ecx
.text:00000560                 mov     ecx, [ebp+arg_4]
.text:00000563                 call    ??A?$CObjectVector@UCArcItem@@@@QBEABUCArcItem@@I@Z ; CObjectVector<CArcItem>::operator[](uint)
.text:00000568                 add     eax, 10h
.text:0000056B                 push    eax             ; int
.text:0000056C                 mov     edx, [ebp+var_B4]
.text:00000572                 add     edx, 10h
.text:00000575                 push    edx             ; int
.text:00000576                 mov     eax, ds:_k_Duplicate_inArc_Message
.text:0000057B                 push    eax             ; char *
.text:0000057C                 call    ?ThrowError@@YGXPBDABVUString@@1@Z ; ThrowError(char const *,UString const &,UString const &)
.text:00000581 ; ---------------------------------------------------------------------------
.text:00000581
.text:00000581 loc_581:                                ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+4BEj
.text:00000581                 mov     ecx, [ebp+var_A8]
.text:00000587                 push    ecx
.text:00000588                 lea     ecx, [ebp+var_6C]
.text:0000058B                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00000590                 mov     [ebp+var_BC], eax
.text:00000596                 mov     edx, [ebp+var_B4]
.text:0000059C                 movzx   eax, byte ptr [edx+20h]
.text:000005A0                 test    eax, eax
.text:000005A2                 jnz     short loc_5C0
.text:000005A4                 mov     ecx, [ebp+var_B4]
.text:000005AA                 add     ecx, 10h
.text:000005AD                 push    ecx             ; int
.text:000005AE                 mov     edx, [ebp+var_BC]
.text:000005B4                 push    edx             ; int
.text:000005B5                 mov     eax, ds:_k_NotCensoredCollision_Message
.text:000005BA                 push    eax             ; char *
.text:000005BB                 call    ?ThrowError@@YGXPBDABVUString@@1@Z ; ThrowError(char const *,UString const &,UString const &)
.text:000005C0 ; ---------------------------------------------------------------------------
.text:000005C0
.text:000005C0 loc_5C0:                                ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+51Aj
.text:000005C0                 mov     ecx, [ebp+var_A8]
.text:000005C6                 mov     [ebp+var_98], ecx
.text:000005CC                 mov     edx, [ebp+var_AC]
.text:000005D2                 mov     [ebp+var_9C], edx
.text:000005D8                 mov     eax, [ebp+var_B4]
.text:000005DE                 movzx   ecx, byte ptr [eax+1Fh]
.text:000005E2                 test    ecx, ecx
.text:000005E4                 jz      short loc_634
.text:000005E6                 mov     edx, [ebp+var_B4]
.text:000005EC                 cmp     dword ptr [edx+28h], 0FFFFFFFFh
.text:000005F0                 jz      short loc_603
.text:000005F2                 mov     eax, [ebp+var_B4]
.text:000005F8                 mov     ecx, [eax+28h]
.text:000005FB                 mov     [ebp+var_F0], ecx
.text:00000601                 jmp     short loc_60C
.text:00000603 ; ---------------------------------------------------------------------------
.text:00000603
.text:00000603 loc_603:                                ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+568j
.text:00000603                 mov     edx, [ebp+arg_8]
.text:00000606                 mov     [ebp+var_F0], edx
.text:0000060C
.text:0000060C loc_60C:                                ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+579j
.text:0000060C                 mov     eax, [ebp+var_B4]
.text:00000612                 add     eax, 8
.text:00000615                 push    eax
.text:00000616                 mov     ecx, [ebp+var_B0]
.text:0000061C                 add     ecx, 18h
.text:0000061F                 push    ecx
.text:00000620                 mov     edx, [ebp+var_F0]
.text:00000626                 push    edx
.text:00000627                 call    ?MyCompareTime@@YGHW4EEnum@NFileTimeType@@ABU_FILETIME@@1@Z ; MyCompareTime(NFileTimeType::EEnum,_FILETIME const &,_FILETIME const &)
.text:0000062C                 mov     [ebp+var_F4], eax
.text:00000632                 jmp     short loc_63E
.text:00000634 ; ---------------------------------------------------------------------------
.text:00000634
.text:00000634 loc_634:                                ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+55Cj
.text:00000634                 mov     [ebp+var_F4], 0
.text:0000063E
.text:0000063E loc_63E:                                ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+5AAj
.text:0000063E                 mov     eax, [ebp+var_F4]
.text:00000644                 mov     [ebp+var_F8], eax
.text:0000064A                 cmp     [ebp+var_F8], 0FFFFFFFFh
.text:00000651                 jz      short loc_65E
.text:00000653                 cmp     [ebp+var_F8], 1
.text:0000065A                 jz      short loc_66A
.text:0000065C                 jmp     short loc_676
.text:0000065E ; ---------------------------------------------------------------------------
.text:0000065E
.text:0000065E loc_65E:                                ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+5C9j
.text:0000065E                 mov     [ebp+var_A0], 3
.text:00000668                 jmp     short loc_6E4
.text:0000066A ; ---------------------------------------------------------------------------
.text:0000066A
.text:0000066A loc_66A:                                ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+5D2j
.text:0000066A                 mov     [ebp+var_A0], 4
.text:00000674                 jmp     short loc_6E4
.text:00000676 ; ---------------------------------------------------------------------------
.text:00000676
.text:00000676 loc_676:                                ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+5D4j
.text:00000676                 mov     ecx, [ebp+var_B4]
.text:0000067C                 movzx   edx, byte ptr [ecx+1Eh]
.text:00000680                 test    edx, edx
.text:00000682                 jz      short loc_6CE
.text:00000684                 mov     eax, [ebp+var_B0]
.text:0000068A                 mov     ecx, [ebp+var_B4]
.text:00000690                 mov     [ebp+var_FC], eax
.text:00000696                 mov     [ebp+var_100], ecx
.text:0000069C                 mov     edx, [ebp+var_FC]
.text:000006A2                 mov     eax, [ebp+var_100]
.text:000006A8                 mov     ecx, [edx]
.text:000006AA                 cmp     ecx, [eax]
.text:000006AC                 jnz     short loc_6CE
.text:000006AE                 mov     edx, [ebp+var_FC]
.text:000006B4                 mov     eax, [ebp+var_100]
.text:000006BA                 mov     ecx, [edx+4]
.text:000006BD                 cmp     ecx, [eax+4]
.text:000006C0                 jnz     short loc_6CE
.text:000006C2                 mov     [ebp+var_104], 5
.text:000006CC                 jmp     short loc_6D8
.text:000006CE ; ---------------------------------------------------------------------------
.text:000006CE
.text:000006CE loc_6CE:                                ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+5FAj
.text:000006CE                                         ; GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+624j ...
.text:000006CE                 mov     [ebp+var_104], 6
.text:000006D8
.text:000006D8 loc_6D8:                                ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+644j
.text:000006D8                 mov     edx, [ebp+var_104]
.text:000006DE                 mov     [ebp+var_A0], edx
.text:000006E4
.text:000006E4 loc_6E4:                                ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+5E0j
.text:000006E4                                         ; GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+5ECj
.text:000006E4                 mov     eax, [ebp+var_80]
.text:000006E7                 add     eax, 1
.text:000006EA                 mov     [ebp+var_80], eax
.text:000006ED                 mov     ecx, [ebp+var_84]
.text:000006F3                 add     ecx, 1
.text:000006F6                 mov     [ebp+var_84], ecx
.text:000006FC
.text:000006FC loc_6FC:                                ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+44Dj
.text:000006FC                                         ; GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+49Bj
.text:000006FC                 cmp     [ebp+var_B0], 0
.text:00000703                 jz      short loc_713
.text:00000705                 mov     edx, [ebp+var_B0]
.text:0000070B                 movzx   eax, byte ptr [edx+4Ch]
.text:0000070F                 test    eax, eax
.text:00000711                 jnz     short loc_732
.text:00000713
.text:00000713 loc_713:                                ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+67Bj
.text:00000713                 cmp     [ebp+var_B4], 0
.text:0000071A                 jz      loc_83F
.text:00000720                 mov     ecx, [ebp+var_B4]
.text:00000726                 movzx   edx, byte ptr [ecx+1Dh]
.text:0000072A                 test    edx, edx
.text:0000072C                 jz      loc_83F
.text:00000732
.text:00000732 loc_732:                                ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+689j
.text:00000732                 cmp     [ebp+var_8C], 0
.text:00000739                 jz      loc_83D
.text:0000073F                 mov     ecx, [ebp+var_8C] ; this
.text:00000745                 call    ?Len@UString@@QBEIXZ ; UString::Len(void)
.text:0000074A                 mov     [ebp+var_C4], eax
.text:00000750                 mov     ecx, [ebp+var_BC] ; this
.text:00000756                 call    ?Len@UString@@QBEIXZ ; UString::Len(void)
.text:0000075B                 cmp     eax, [ebp+var_C4]
.text:00000761                 jbe     loc_83D
.text:00000767                 mov     ecx, [ebp+var_BC]
.text:0000076D                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00000772                 mov     ecx, [ebp+var_C4]
.text:00000778                 movzx   edx, word ptr [eax+ecx*2]
.text:0000077C                 cmp     edx, 3Ah ; ':'
.text:0000077F                 jnz     short loc_7EC
.text:00000781                 mov     eax, [ebp+var_C4]
.text:00000787                 push    eax
.text:00000788                 lea     ecx, [ebp+var_E0]
.text:0000078E                 push    ecx
.text:0000078F                 mov     ecx, [ebp+var_BC]
.text:00000795                 call    ?Left@UString@@QBE?AV1@I@Z ; UString::Left(uint)
.text:0000079A                 mov     [ebp+var_108], eax
.text:000007A0                 mov     edx, [ebp+var_108]
.text:000007A6                 mov     [ebp+var_10C], edx
.text:000007AC                 mov     byte ptr [ebp+var_4], 5
.text:000007B0                 mov     eax, [ebp+var_E4]
.text:000007B6                 or      eax, 1
.text:000007B9                 mov     [ebp+var_E4], eax
.text:000007BF                 mov     ecx, [ebp+var_10C]
.text:000007C5                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000007CA                 push    eax             ; wchar_t *
.text:000007CB                 mov     ecx, [ebp+var_8C]
.text:000007D1                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000007D6                 push    eax             ; wchar_t *
.text:000007D7                 call    ?CompareFileNames@@YGHPB_W0@Z ; CompareFileNames(wchar_t const *,wchar_t const *)
.text:000007DC                 test    eax, eax
.text:000007DE                 jnz     short loc_7EC
.text:000007E0                 mov     [ebp+var_110], 1
.text:000007EA                 jmp     short loc_7F6
.text:000007EC ; ---------------------------------------------------------------------------
.text:000007EC
.text:000007EC loc_7EC:                                ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+6F7j
.text:000007EC                                         ; GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+756j
.text:000007EC                 mov     [ebp+var_110], 0
.text:000007F6
.text:000007F6 loc_7F6:                                ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+762j
.text:000007F6                 mov     cl, byte ptr [ebp+var_110]
.text:000007FC                 mov     [ebp+var_D1], cl
.text:00000802                 mov     [ebp+var_4], 3
.text:00000809                 mov     edx, [ebp+var_E4]
.text:0000080F                 and     edx, 1
.text:00000812                 jz      short loc_826
.text:00000814                 and     [ebp+var_E4], 0FFFFFFFEh
.text:0000081B                 lea     ecx, [ebp+var_E0] ; this
.text:00000821                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000826
.text:00000826 loc_826:                                ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+78Aj
.text:00000826                 movzx   eax, [ebp+var_D1]
.text:0000082D                 test    eax, eax
.text:0000082F                 jz      short loc_83D
.text:00000831                 mov     ecx, [ebp+var_88]
.text:00000837                 mov     [ebp+var_94], ecx
.text:0000083D
.text:0000083D loc_83D:                                ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+6B1j
.text:0000083D                                         ; GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+6D9j ...
.text:0000083D                 jmp     short loc_859
.text:0000083F ; ---------------------------------------------------------------------------
.text:0000083F
.text:0000083F loc_83F:                                ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+692j
.text:0000083F                                         ; GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+6A4j
.text:0000083F                 mov     ecx, [ebp+arg_C]
.text:00000842                 call    ?Size@?$CRecordVector@UCUpdatePair@@@@QBEIXZ ; CRecordVector<CUpdatePair>::Size(void)
.text:00000847                 mov     [ebp+var_88], eax
.text:0000084D                 mov     edx, [ebp+var_BC]
.text:00000853                 mov     [ebp+var_8C], edx
.text:00000859
.text:00000859 loc_859:                                ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &):loc_83Dj
.text:00000859                 sub     esp, 10h
.text:0000085C                 mov     eax, esp
.text:0000085E                 mov     ecx, [ebp+var_A0]
.text:00000864                 mov     [eax], ecx
.text:00000866                 mov     edx, [ebp+var_9C]
.text:0000086C                 mov     [eax+4], edx
.text:0000086F                 mov     ecx, [ebp+var_98]
.text:00000875                 mov     [eax+8], ecx
.text:00000878                 mov     edx, [ebp+var_94]
.text:0000087E                 mov     [eax+0Ch], edx
.text:00000881                 mov     ecx, [ebp+arg_C]
.text:00000884                 call    ?Add@?$CRecordVector@UCUpdatePair@@@@QAEIUCUpdatePair@@@Z ; CRecordVector<CUpdatePair>::Add(CUpdatePair)
.text:00000889                 jmp     loc_349
.text:0000088E ; ---------------------------------------------------------------------------
.text:0000088E
.text:0000088E loc_88E:                                ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+2D2j
.text:0000088E                 mov     ecx, [ebp+arg_C]
.text:00000891                 call    ?ReserveDown@?$CRecordVector@UCUpdatePair@@@@QAEXXZ ; CRecordVector<CUpdatePair>::ReserveDown(void)
.text:00000896                 mov     byte ptr [ebp+var_4], 2
.text:0000089A                 lea     ecx, [ebp+var_6C]
.text:0000089D                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:000008A2                 mov     byte ptr [ebp+var_4], 1
.text:000008A6                 lea     ecx, [ebp+var_44]
.text:000008A9                 call    ??1?$CObjArray@H@@QAE@XZ ; CObjArray<int>::~CObjArray<int>(void)
.text:000008AE                 mov     byte ptr [ebp+var_4], 0
.text:000008B2                 lea     ecx, [ebp+var_30]
.text:000008B5                 call    ??1?$CRecordVector@I@@QAE@XZ ; CRecordVector<uint>::~CRecordVector<uint>(void)
.text:000008BA                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000008C1                 lea     ecx, [ebp+var_1C]
.text:000008C4                 call    ??1?$CRecordVector@I@@QAE@XZ ; CRecordVector<uint>::~CRecordVector<uint>(void)
.text:000008C9                 push    edx
.text:000008CA                 mov     ecx, ebp
.text:000008CC                 push    eax
.text:000008CD                 lea     edx, $LN69
.text:000008D3                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:000008D8                 pop     eax
.text:000008D9                 pop     edx
.text:000008DA                 mov     ecx, [ebp+var_C]
.text:000008DD                 mov     large fs:0, ecx
.text:000008E4                 pop     ecx
.text:000008E5                 pop     edi
.text:000008E6                 add     esp, 110h
.text:000008EC                 cmp     ebp, esp
.text:000008EE                 call    __RTC_CheckEsp
.text:000008F3                 mov     esp, ebp
.text:000008F5                 pop     ebp
.text:000008F6                 retn    10h
.text:000008F6 ?GetUpdatePairInfoList@@YGXABVCDirItems@@ABV?$CObjectVector@UCArcItem@@@@W4EEnum@NFileTimeType@@AAV?$CRecordVector@UCUpdatePair@@@@@Z endp ; sp-analysis failed
.text:000008F6
.text:000008F6 ; ---------------------------------------------------------------------------
.text:000008F9                 align 4
.text:000008FC $LN69           dd 5                    ; DATA XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+845o
.text:00000900                 dd offset $LN68
.text:00000904 $LN68           dd 0FFFFFFE4h, 0Ch      ; DATA XREF: .text:00000900o
.text:0000090C                 dd offset $LN62         ; "dirIndices"
.text:00000910                 dd 0FFFFFFD0h, 0Ch
.text:00000918                 dd offset $LN63         ; "arcIndices"
.text:0000091C                 dd 0FFFFFFBCh, 4
.text:00000924                 dd offset $LN64         ; "duplicatedArcItem"
.text:00000928                 dd 0FFFFFF94h, 0Ch
.text:00000930                 dd offset $LN65         ; "dirNames"
.text:00000934                 dd 0FFFFFF60h, 10h
.text:0000093C                 dd offset $LN66         ; "pair"
.text:00000940 $LN66           db 'pair',0             ; DATA XREF: .text:0000093Co
.text:00000945 $LN65           db 'dirNames',0         ; DATA XREF: .text:00000930o
.text:0000094E $LN64           db 'duplicatedArcItem',0 ; DATA XREF: .text:00000924o
.text:00000960 $LN63           db 'arcIndices',0       ; DATA XREF: .text:00000918o
.text:0000096B $LN62           db 'dirIndices',0       ; DATA XREF: .text:0000090Co
.text:00000976                 align 4
.text:00000978
.text:00000978 ; =============== S U B R O U T I N E =======================================
.text:00000978
.text:00000978 ; Attributes: bp-based frame
.text:00000978
.text:00000978 ; int __stdcall MyCompareTime(enum  NFileTimeType::EEnum, struct _FILETIME const &, struct _FILETIME const &)
.text:00000978 ?MyCompareTime@@YGHW4EEnum@NFileTimeType@@ABU_FILETIME@@1@Z proc near
.text:00000978                                         ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+59Fp
.text:00000978
.text:00000978 var_38          = dword ptr -38h
.text:00000978 var_34          = dword ptr -34h
.text:00000978 var_2C          = _FILETIME ptr -2Ch
.text:00000978 var_20          = _FILETIME ptr -20h
.text:00000978 var_14          = _FILETIME ptr -14h
.text:00000978 var_8           = _FILETIME ptr -8
.text:00000978 arg_0           = dword ptr  8
.text:00000978 lpFileTime1     = dword ptr  0Ch
.text:00000978 lpFileTime2     = dword ptr  10h
.text:00000978
.text:00000978                 push    ebp
.text:00000979                 mov     ebp, esp
.text:0000097B                 sub     esp, 38h
.text:0000097E                 push    esi
.text:0000097F                 push    edi             ; unsigned int *
.text:00000980                 lea     edi, [ebp+var_38]
.text:00000983                 mov     ecx, 0Eh
.text:00000988                 mov     eax, 0CCCCCCCCh
.text:0000098D                 rep stosd
.text:0000098F                 mov     eax, [ebp+arg_0]
.text:00000992                 mov     [ebp+var_38], eax
.text:00000995                 cmp     [ebp+var_38], 0
.text:00000999                 jz      short loc_9A9
.text:0000099B                 cmp     [ebp+var_38], 1
.text:0000099F                 jz      short loc_9C2
.text:000009A1                 cmp     [ebp+var_38], 2
.text:000009A5                 jz      short loc_9EB
.text:000009A7                 jmp     short loc_A14
.text:000009A9 ; ---------------------------------------------------------------------------
.text:000009A9
.text:000009A9 loc_9A9:                                ; CODE XREF: MyCompareTime(NFileTimeType::EEnum,_FILETIME const &,_FILETIME const &)+21j
.text:000009A9                 mov     esi, esp
.text:000009AB                 mov     ecx, [ebp+lpFileTime2]
.text:000009AE                 push    ecx             ; lpFileTime2
.text:000009AF                 mov     edx, [ebp+lpFileTime1]
.text:000009B2                 push    edx             ; lpFileTime1
.text:000009B3                 call    dword ptr ds:__imp__CompareFileTime@8 ; CompareFileTime(x,x)
.text:000009B9                 cmp     esi, esp
.text:000009BB                 call    __RTC_CheckEsp
.text:000009C0                 jmp     short loc_A29
.text:000009C2 ; ---------------------------------------------------------------------------
.text:000009C2
.text:000009C2 loc_9C2:                                ; CODE XREF: MyCompareTime(NFileTimeType::EEnum,_FILETIME const &,_FILETIME const &)+27j
.text:000009C2                 lea     eax, [ebp+var_8]
.text:000009C5                 push    eax             ; struct _FILETIME *
.text:000009C6                 mov     ecx, [ebp+lpFileTime1]
.text:000009C9                 push    ecx             ; unsigned int *
.text:000009CA                 call    ?FileTimeToUnixTime@NTime@NWindows@@YG_NABU_FILETIME@@AAI@Z ; NWindows::NTime::FileTimeToUnixTime(_FILETIME const &,uint &)
.text:000009CF                 lea     edx, [ebp+var_14]
.text:000009D2                 push    edx             ; struct _FILETIME *
.text:000009D3                 mov     eax, [ebp+lpFileTime2]
.text:000009D6                 push    eax             ; this
.text:000009D7                 call    ?FileTimeToUnixTime@NTime@NWindows@@YG_NABU_FILETIME@@AAI@Z ; NWindows::NTime::FileTimeToUnixTime(_FILETIME const &,uint &)
.text:000009DC                 mov     ecx, [ebp+var_14.dwLowDateTime]
.text:000009DF                 push    ecx
.text:000009E0                 mov     edx, [ebp+var_8.dwLowDateTime]
.text:000009E3                 push    edx
.text:000009E4                 call    ??$MyCompare@I@@YGHII@Z ; MyCompare<uint>(uint,uint)
.text:000009E9                 jmp     short loc_A29
.text:000009EB ; ---------------------------------------------------------------------------
.text:000009EB
.text:000009EB loc_9EB:                                ; CODE XREF: MyCompareTime(NFileTimeType::EEnum,_FILETIME const &,_FILETIME const &)+2Dj
.text:000009EB                 lea     eax, [ebp+var_20]
.text:000009EE                 push    eax             ; struct _FILETIME *
.text:000009EF                 mov     ecx, [ebp+lpFileTime1]
.text:000009F2                 push    ecx             ; unsigned int *
.text:000009F3                 call    ?FileTimeToDosTime@NTime@NWindows@@YG_NABU_FILETIME@@AAI@Z ; NWindows::NTime::FileTimeToDosTime(_FILETIME const &,uint &)
.text:000009F8                 lea     edx, [ebp+var_2C]
.text:000009FB                 push    edx             ; struct _FILETIME *
.text:000009FC                 mov     eax, [ebp+lpFileTime2]
.text:000009FF                 push    eax             ; this
.text:00000A00                 call    ?FileTimeToDosTime@NTime@NWindows@@YG_NABU_FILETIME@@AAI@Z ; NWindows::NTime::FileTimeToDosTime(_FILETIME const &,uint &)
.text:00000A05                 mov     ecx, [ebp+var_2C.dwLowDateTime]
.text:00000A08                 push    ecx
.text:00000A09                 mov     edx, [ebp+var_20.dwLowDateTime]
.text:00000A0C                 push    edx
.text:00000A0D                 call    ??$MyCompare@I@@YGHII@Z ; MyCompare<uint>(uint,uint)
.text:00000A12                 jmp     short loc_A29
.text:00000A14 ; ---------------------------------------------------------------------------
.text:00000A14
.text:00000A14 loc_A14:                                ; CODE XREF: MyCompareTime(NFileTimeType::EEnum,_FILETIME const &,_FILETIME const &)+2Fj
.text:00000A14                 mov     [ebp+var_34], 3FF582h
.text:00000A1B                 push    offset __TI1H
.text:00000A20                 lea     eax, [ebp+var_34]
.text:00000A23                 push    eax
.text:00000A24                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:00000A29 ; ---------------------------------------------------------------------------
.text:00000A29
.text:00000A29 loc_A29:                                ; CODE XREF: MyCompareTime(NFileTimeType::EEnum,_FILETIME const &,_FILETIME const &)+48j
.text:00000A29                                         ; MyCompareTime(NFileTimeType::EEnum,_FILETIME const &,_FILETIME const &)+71j ...
.text:00000A29                 push    edx
.text:00000A2A                 mov     ecx, ebp
.text:00000A2C                 push    eax
.text:00000A2D                 lea     edx, $LN13
.text:00000A33                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00000A38                 pop     eax
.text:00000A39                 pop     edx
.text:00000A3A                 pop     edi
.text:00000A3B                 pop     esi
.text:00000A3C                 add     esp, 38h
.text:00000A3F                 cmp     ebp, esp
.text:00000A41                 call    __RTC_CheckEsp
.text:00000A46                 mov     esp, ebp
.text:00000A48                 pop     ebp
.text:00000A49                 retn    0Ch
.text:00000A49 ?MyCompareTime@@YGHW4EEnum@NFileTimeType@@ABU_FILETIME@@1@Z endp ; sp-analysis failed
.text:00000A49
.text:00000A49 ; ---------------------------------------------------------------------------
.text:00000A4C $LN13           dd 4                    ; DATA XREF: MyCompareTime(NFileTimeType::EEnum,_FILETIME const &,_FILETIME const &)+B5o
.text:00000A50                 dd offset $LN12
.text:00000A54 $LN12           dd 0FFFFFFF8h, 4        ; DATA XREF: .text:00000A50o
.text:00000A5C                 dd offset $LN8          ; "unixTime1"
.text:00000A60                 dd 0FFFFFFECh, 4
.text:00000A68                 dd offset $LN9          ; "unixTime2"
.text:00000A6C                 dd 0FFFFFFE0h, 4
.text:00000A74                 dd offset $LN10         ; "dosTime1"
.text:00000A78                 dd 0FFFFFFD4h, 4
.text:00000A80                 dd offset $LN11         ; "dosTime2"
.text:00000A84 $LN11           db 'dosTime2',0         ; DATA XREF: .text:00000A80o
.text:00000A8D $LN10           db 'dosTime1',0         ; DATA XREF: .text:00000A74o
.text:00000A96 $LN9            db 'unixTime2',0        ; DATA XREF: .text:00000A68o
.text:00000AA0 $LN8            db 'unixTime1',0        ; DATA XREF: .text:00000A5Co
.text:00000AAA                 db 0Eh dup(0CCh)
.text:00000AB8
.text:00000AB8 ; =============== S U B R O U T I N E =======================================
.text:00000AB8
.text:00000AB8 ; Attributes: noreturn bp-based frame
.text:00000AB8
.text:00000AB8 ; int __cdecl ThrowError(char *, int, int)
.text:00000AB8 ?ThrowError@@YGXPBDABVUString@@1@Z proc near
.text:00000AB8                                         ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+295p
.text:00000AB8                                         ; GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+4F4p ...
.text:00000AB8
.text:00000AB8 var_2C          = dword ptr -2Ch
.text:00000AB8 var_28          = dword ptr -28h
.text:00000AB8 var_24          = dword ptr -24h
.text:00000AB8 var_20          = dword ptr -20h
.text:00000AB8 var_1C          = dword ptr -1Ch
.text:00000AB8 var_18          = dword ptr -18h
.text:00000AB8 var_14          = dword ptr -14h
.text:00000AB8 var_10          = dword ptr -10h
.text:00000AB8 var_C           = byte ptr -0Ch
.text:00000AB8 var_4           = dword ptr -4
.text:00000AB8 arg_0           = dword ptr  8
.text:00000AB8 arg_4           = dword ptr  0Ch
.text:00000AB8 arg_8           = dword ptr  10h
.text:00000AB8
.text:00000AB8                 push    ebp
.text:00000AB9                 mov     ebp, esp
.text:00000ABB                 push    0FFFFFFFFh
.text:00000ABD                 push    offset __ehhandler$?ThrowError@@YGXPBDABVUString@@1@Z
.text:00000AC2                 mov     eax, large fs:0
.text:00000AC8                 push    eax
.text:00000AC9                 sub     esp, 20h
.text:00000ACC                 mov     eax, 0CCCCCCCCh
.text:00000AD1                 mov     [ebp+var_2C], eax
.text:00000AD4                 mov     [ebp+var_28], eax
.text:00000AD7                 mov     [ebp+var_24], eax
.text:00000ADA                 mov     [ebp+var_20], eax
.text:00000ADD                 mov     [ebp+var_1C], eax
.text:00000AE0                 mov     [ebp+var_18], eax
.text:00000AE3                 mov     [ebp+var_14], eax
.text:00000AE6                 mov     [ebp+var_10], eax
.text:00000AE9                 mov     eax, dword ptr ds:___security_cookie
.text:00000AEE                 xor     eax, ebp
.text:00000AF0                 push    eax
.text:00000AF1                 lea     eax, [ebp+var_C]
.text:00000AF4                 mov     large fs:0, eax
.text:00000AFA                 lea     ecx, [ebp+var_1C]
.text:00000AFD                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00000B02                 mov     [ebp+var_4], 0
.text:00000B09                 mov     eax, [ebp+arg_0]
.text:00000B0C                 push    eax             ; char *
.text:00000B0D                 lea     ecx, [ebp+var_1C] ; this
.text:00000B10                 call    ?SetFromAscii@UString@@QAEXPBD@Z ; UString::SetFromAscii(char const *)
.text:00000B15                 lea     ecx, [ebp+var_1C] ; this
.text:00000B18                 call    ?Add_LF@UString@@QAEXXZ ; UString::Add_LF(void)
.text:00000B1D                 mov     ecx, [ebp+arg_4]
.text:00000B20                 push    ecx
.text:00000B21                 lea     ecx, [ebp+var_1C]
.text:00000B24                 call    ??YUString@@QAEAAV0@ABV0@@Z ; UString::operator+=(UString const &)
.text:00000B29                 lea     ecx, [ebp+var_1C] ; this
.text:00000B2C                 call    ?Add_LF@UString@@QAEXXZ ; UString::Add_LF(void)
.text:00000B31                 mov     edx, [ebp+arg_8]
.text:00000B34                 push    edx
.text:00000B35                 lea     ecx, [ebp+var_1C]
.text:00000B38                 call    ??YUString@@QAEAAV0@ABV0@@Z ; UString::operator+=(UString const &)
.text:00000B3D                 lea     eax, [ebp+var_1C]
.text:00000B40                 push    eax
.text:00000B41                 lea     ecx, [ebp+var_2C]
.text:00000B44                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00000B49                 push    offset __TI1?AVUString@@
.text:00000B4E                 lea     ecx, [ebp+var_2C]
.text:00000B51                 push    ecx
.text:00000B52                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:00000B52 ?ThrowError@@YGXPBDABVUString@@1@Z endp
.text:00000B52
.text:00000B57 ; ---------------------------------------------------------------------------
.text:00000B57                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text:00000B5E                 lea     ecx, [ebp-1Ch]
.text:00000B61                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00000B66                 push    edx
.text:00000B67                 mov     ecx, ebp
.text:00000B69                 push    eax
.text:00000B6A                 lea     edx, $LN7
.text:00000B70                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00000B75                 pop     eax
.text:00000B76                 pop     edx
.text:00000B77                 mov     ecx, [ebp-0Ch]
.text:00000B7A                 mov     large fs:0, ecx
.text:00000B81                 pop     ecx
.text:00000B82                 add     esp, 2Ch
.text:00000B85                 cmp     ebp, esp
.text:00000B87                 call    __RTC_CheckEsp
.text:00000B8C                 mov     esp, ebp
.text:00000B8E                 pop     ebp
.text:00000B8F                 retn    0Ch
.text:00000B8F ; ---------------------------------------------------------------------------
.text:00000B92                 align 4
.text:00000B94 $LN7            dd 1                    ; DATA XREF: .text:00000B6Ao
.text:00000B98                 dd offset $LN6
.text:00000B9C $LN6            dd 0FFFFFFE4h, 0Ch      ; DATA XREF: .text:00000B98o
.text:00000BA4                 dd offset $LN4
.text:00000BA8 $LN4            dd 0CCCC006Dh, 3 dup(0CCCCCCCCh) ; DATA XREF: .text:00000BA4o
.text:00000BB8
.text:00000BB8 ; =============== S U B R O U T I N E =======================================
.text:00000BB8
.text:00000BB8 ; Attributes: bp-based frame
.text:00000BB8
.text:00000BB8 ; int __stdcall CompareArcItemsBase(struct CArcItem const &, struct CArcItem const &)
.text:00000BB8 ?CompareArcItemsBase@@YGHABUCArcItem@@0@Z proc near
.text:00000BB8                                         ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+15Fp
.text:00000BB8                                         ; CompareArcItems(uint const *,uint const *,void *)+47p
.text:00000BB8
.text:00000BB8 var_4           = dword ptr -4
.text:00000BB8 arg_0           = dword ptr  8
.text:00000BB8 arg_4           = dword ptr  0Ch
.text:00000BB8
.text:00000BB8                 push    ebp
.text:00000BB9                 mov     ebp, esp
.text:00000BBB                 push    ecx
.text:00000BBC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000BC3                 mov     ecx, [ebp+arg_4]
.text:00000BC6                 add     ecx, 10h
.text:00000BC9                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00000BCE                 push    eax             ; wchar_t *
.text:00000BCF                 mov     ecx, [ebp+arg_0]
.text:00000BD2                 add     ecx, 10h
.text:00000BD5                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00000BDA                 push    eax             ; wchar_t *
.text:00000BDB                 call    ?CompareFileNames@@YGHPB_W0@Z ; CompareFileNames(wchar_t const *,wchar_t const *)
.text:00000BE0                 mov     [ebp+var_4], eax
.text:00000BE3                 cmp     [ebp+var_4], 0
.text:00000BE7                 jz      short loc_BEE
.text:00000BE9                 mov     eax, [ebp+var_4]
.text:00000BEC                 jmp     short loc_C15
.text:00000BEE ; ---------------------------------------------------------------------------
.text:00000BEE
.text:00000BEE loc_BEE:                                ; CODE XREF: CompareArcItemsBase(CArcItem const &,CArcItem const &)+2Fj
.text:00000BEE                 mov     eax, [ebp+arg_0]
.text:00000BF1                 movzx   ecx, byte ptr [eax+1Ch]
.text:00000BF5                 mov     edx, [ebp+arg_4]
.text:00000BF8                 movzx   eax, byte ptr [edx+1Ch]
.text:00000BFC                 cmp     ecx, eax
.text:00000BFE                 jz      short loc_C13
.text:00000C00                 mov     ecx, [ebp+arg_0]
.text:00000C03                 movzx   eax, byte ptr [ecx+1Ch]
.text:00000C07                 neg     eax
.text:00000C09                 sbb     eax, eax
.text:00000C0B                 and     eax, 0FFFFFFFEh
.text:00000C0E                 add     eax, 1
.text:00000C11                 jmp     short loc_C15
.text:00000C13 ; ---------------------------------------------------------------------------
.text:00000C13
.text:00000C13 loc_C13:                                ; CODE XREF: CompareArcItemsBase(CArcItem const &,CArcItem const &)+46j
.text:00000C13                 xor     eax, eax
.text:00000C15
.text:00000C15 loc_C15:                                ; CODE XREF: CompareArcItemsBase(CArcItem const &,CArcItem const &)+34j
.text:00000C15                                         ; CompareArcItemsBase(CArcItem const &,CArcItem const &)+59j
.text:00000C15                 add     esp, 4
.text:00000C18                 cmp     ebp, esp
.text:00000C1A                 call    __RTC_CheckEsp
.text:00000C1F                 mov     esp, ebp
.text:00000C21                 pop     ebp
.text:00000C22                 retn    8
.text:00000C22 ?CompareArcItemsBase@@YGHABUCArcItem@@0@Z endp
.text:00000C22
.text:00000C22 ; ---------------------------------------------------------------------------
.text:00000C25                 align 4
.text:00000C28
.text:00000C28 ; =============== S U B R O U T I N E =======================================
.text:00000C28
.text:00000C28 ; Attributes: bp-based frame
.text:00000C28
.text:00000C28 ; int __stdcall CompareArcItems(unsigned int const *, unsigned int const *, void *)
.text:00000C28 ?CompareArcItems@@YGHPBI0PAX@Z proc near
.text:00000C28                                         ; DATA XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+102o
.text:00000C28
.text:00000C28 var_10          = dword ptr -10h
.text:00000C28 var_C           = dword ptr -0Ch
.text:00000C28 var_8           = dword ptr -8
.text:00000C28 var_4           = dword ptr -4
.text:00000C28 arg_0           = dword ptr  8
.text:00000C28 arg_4           = dword ptr  0Ch
.text:00000C28 arg_8           = dword ptr  10h
.text:00000C28
.text:00000C28                 push    ebp
.text:00000C29                 mov     ebp, esp
.text:00000C2B                 sub     esp, 10h
.text:00000C2E                 mov     eax, 0CCCCCCCCh
.text:00000C33                 mov     [ebp+var_10], eax
.text:00000C36                 mov     [ebp+var_C], eax
.text:00000C39                 mov     [ebp+var_8], eax
.text:00000C3C                 mov     [ebp+var_4], eax
.text:00000C3F                 mov     eax, [ebp+arg_0]
.text:00000C42                 mov     ecx, [eax]
.text:00000C44                 mov     [ebp+var_4], ecx
.text:00000C47                 mov     edx, [ebp+arg_4]
.text:00000C4A                 mov     eax, [edx]
.text:00000C4C                 mov     [ebp+var_8], eax
.text:00000C4F                 mov     ecx, [ebp+arg_8]
.text:00000C52                 mov     [ebp+var_C], ecx
.text:00000C55                 mov     edx, [ebp+var_8]
.text:00000C58                 push    edx
.text:00000C59                 mov     ecx, [ebp+var_C]
.text:00000C5C                 call    ??A?$CObjectVector@UCArcItem@@@@QBEABUCArcItem@@I@Z ; CObjectVector<CArcItem>::operator[](uint)
.text:00000C61                 push    eax
.text:00000C62                 mov     eax, [ebp+var_4]
.text:00000C65                 push    eax
.text:00000C66                 mov     ecx, [ebp+var_C]
.text:00000C69                 call    ??A?$CObjectVector@UCArcItem@@@@QBEABUCArcItem@@I@Z ; CObjectVector<CArcItem>::operator[](uint)
.text:00000C6E                 push    eax
.text:00000C6F                 call    ?CompareArcItemsBase@@YGHABUCArcItem@@0@Z ; CompareArcItemsBase(CArcItem const &,CArcItem const &)
.text:00000C74                 mov     [ebp+var_10], eax
.text:00000C77                 cmp     [ebp+var_10], 0
.text:00000C7B                 jz      short loc_C82
.text:00000C7D                 mov     eax, [ebp+var_10]
.text:00000C80                 jmp     short loc_C8F
.text:00000C82 ; ---------------------------------------------------------------------------
.text:00000C82
.text:00000C82 loc_C82:                                ; CODE XREF: CompareArcItems(uint const *,uint const *,void *)+53j
.text:00000C82                 mov     ecx, [ebp+var_8]
.text:00000C85                 push    ecx
.text:00000C86                 mov     edx, [ebp+var_4]
.text:00000C89                 push    edx
.text:00000C8A                 call    ??$MyCompare@I@@YGHII@Z ; MyCompare<uint>(uint,uint)
.text:00000C8F
.text:00000C8F loc_C8F:                                ; CODE XREF: CompareArcItems(uint const *,uint const *,void *)+58j
.text:00000C8F                 add     esp, 10h
.text:00000C92                 cmp     ebp, esp
.text:00000C94                 call    __RTC_CheckEsp
.text:00000C99                 mov     esp, ebp
.text:00000C9B                 pop     ebp
.text:00000C9C                 retn    0Ch
.text:00000C9C ?CompareArcItems@@YGHPBI0PAX@Z endp
.text:00000C9C
.text:00000C9C ; ---------------------------------------------------------------------------
.text:00000C9F                 align 10h
.text:00000C9F _text           ends
.text:00000C9F
.text$x:00000CA0 ; ===========================================================================
.text$x:00000CA0
.text$x:00000CA0 ; Segment type: Pure code
.text$x:00000CA0 ; Segment permissions: Read/Execute
.text$x:00000CA0 _text$x         segment para public 'CODE' use32
.text$x:00000CA0                 assume cs:_text$x
.text$x:00000CA0                 ;org 0CA0h
.text$x:00000CA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000CA0
.text$x:00000CA0 ; =============== S U B R O U T I N E =======================================
.text$x:00000CA0
.text$x:00000CA0
.text$x:00000CA0 __unwindfunclet$?GetUpdatePairInfoList@@YGXABVCDirItems@@ABV?$CObjectVector@UCArcItem@@@@W4EEnum@NFileTimeType@@AAV?$CRecordVector@UCUpdatePair@@@@@Z$0 proc near
.text$x:00000CA0                                         ; DATA XREF: .xdata$x:00000D58o
.text$x:00000CA0                 lea     ecx, [ebp-1Ch]
.text$x:00000CA3                 jmp     ??1?$CRecordVector@I@@QAE@XZ ; CRecordVector<uint>::~CRecordVector<uint>(void)
.text$x:00000CA3 __unwindfunclet$?GetUpdatePairInfoList@@YGXABVCDirItems@@ABV?$CObjectVector@UCArcItem@@@@W4EEnum@NFileTimeType@@AAV?$CRecordVector@UCUpdatePair@@@@@Z$0 endp
.text$x:00000CA3
.text$x:00000CA8
.text$x:00000CA8 ; =============== S U B R O U T I N E =======================================
.text$x:00000CA8
.text$x:00000CA8
.text$x:00000CA8 __unwindfunclet$?GetUpdatePairInfoList@@YGXABVCDirItems@@ABV?$CObjectVector@UCArcItem@@@@W4EEnum@NFileTimeType@@AAV?$CRecordVector@UCUpdatePair@@@@@Z$1 proc near
.text$x:00000CA8                                         ; DATA XREF: .xdata$x:00000D60o
.text$x:00000CA8                 lea     ecx, [ebp-30h]
.text$x:00000CAB                 jmp     ??1?$CRecordVector@I@@QAE@XZ ; CRecordVector<uint>::~CRecordVector<uint>(void)
.text$x:00000CAB __unwindfunclet$?GetUpdatePairInfoList@@YGXABVCDirItems@@ABV?$CObjectVector@UCArcItem@@@@W4EEnum@NFileTimeType@@AAV?$CRecordVector@UCUpdatePair@@@@@Z$1 endp
.text$x:00000CAB
.text$x:00000CB0
.text$x:00000CB0 ; =============== S U B R O U T I N E =======================================
.text$x:00000CB0
.text$x:00000CB0
.text$x:00000CB0 __unwindfunclet$?GetUpdatePairInfoList@@YGXABVCDirItems@@ABV?$CObjectVector@UCArcItem@@@@W4EEnum@NFileTimeType@@AAV?$CRecordVector@UCUpdatePair@@@@@Z$2 proc near
.text$x:00000CB0                                         ; DATA XREF: .xdata$x:00000D68o
.text$x:00000CB0                 lea     ecx, [ebp-44h]
.text$x:00000CB3                 jmp     ??1?$CObjArray@H@@QAE@XZ ; CObjArray<int>::~CObjArray<int>(void)
.text$x:00000CB3 __unwindfunclet$?GetUpdatePairInfoList@@YGXABVCDirItems@@ABV?$CObjectVector@UCArcItem@@@@W4EEnum@NFileTimeType@@AAV?$CRecordVector@UCUpdatePair@@@@@Z$2 endp
.text$x:00000CB3
.text$x:00000CB8
.text$x:00000CB8 ; =============== S U B R O U T I N E =======================================
.text$x:00000CB8
.text$x:00000CB8
.text$x:00000CB8 __unwindfunclet$?GetUpdatePairInfoList@@YGXABVCDirItems@@ABV?$CObjectVector@UCArcItem@@@@W4EEnum@NFileTimeType@@AAV?$CRecordVector@UCUpdatePair@@@@@Z$3 proc near
.text$x:00000CB8                                         ; DATA XREF: .xdata$x:00000D70o
.text$x:00000CB8                 lea     ecx, [ebp-6Ch]
.text$x:00000CBB                 jmp     ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text$x:00000CBB __unwindfunclet$?GetUpdatePairInfoList@@YGXABVCDirItems@@ABV?$CObjectVector@UCArcItem@@@@W4EEnum@NFileTimeType@@AAV?$CRecordVector@UCUpdatePair@@@@@Z$3 endp
.text$x:00000CBB
.text$x:00000CC0
.text$x:00000CC0 ; =============== S U B R O U T I N E =======================================
.text$x:00000CC0
.text$x:00000CC0
.text$x:00000CC0 __unwindfunclet$?GetUpdatePairInfoList@@YGXABVCDirItems@@ABV?$CObjectVector@UCArcItem@@@@W4EEnum@NFileTimeType@@AAV?$CRecordVector@UCUpdatePair@@@@@Z$4 proc near
.text$x:00000CC0                                         ; DATA XREF: .xdata$x:00000D78o
.text$x:00000CC0                 lea     ecx, [ebp-0D0h] ; this
.text$x:00000CC6                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00000CC6 __unwindfunclet$?GetUpdatePairInfoList@@YGXABVCDirItems@@ABV?$CObjectVector@UCArcItem@@@@W4EEnum@NFileTimeType@@AAV?$CRecordVector@UCUpdatePair@@@@@Z$4 endp
.text$x:00000CC6
.text$x:00000CCB
.text$x:00000CCB ; =============== S U B R O U T I N E =======================================
.text$x:00000CCB
.text$x:00000CCB
.text$x:00000CCB __unwindfunclet$?GetUpdatePairInfoList@@YGXABVCDirItems@@ABV?$CObjectVector@UCArcItem@@@@W4EEnum@NFileTimeType@@AAV?$CRecordVector@UCUpdatePair@@@@@Z$5 proc near
.text$x:00000CCB                                         ; DATA XREF: .xdata$x:00000D80o
.text$x:00000CCB                 mov     eax, [ebp-0E4h]
.text$x:00000CD1                 and     eax, 1
.text$x:00000CD4                 jz      locret_CEC
.text$x:00000CDA                 and     dword ptr [ebp-0E4h], 0FFFFFFFEh
.text$x:00000CE1                 lea     ecx, [ebp-0E0h] ; this
.text$x:00000CE7                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00000CEC ; ---------------------------------------------------------------------------
.text$x:00000CEC
.text$x:00000CEC locret_CEC:                             ; CODE XREF: __unwindfunclet$?GetUpdatePairInfoList@@YGXABVCDirItems@@ABV?$CObjectVector@UCArcItem@@@@W4EEnum@NFileTimeType@@AAV?$CRecordVector@UCUpdatePair@@@@@Z$5+9j
.text$x:00000CEC                 retn
.text$x:00000CEC __unwindfunclet$?GetUpdatePairInfoList@@YGXABVCDirItems@@ABV?$CObjectVector@UCArcItem@@@@W4EEnum@NFileTimeType@@AAV?$CRecordVector@UCUpdatePair@@@@@Z$5 endp
.text$x:00000CEC
.text$x:00000CED
.text$x:00000CED ; =============== S U B R O U T I N E =======================================
.text$x:00000CED
.text$x:00000CED
.text$x:00000CED __ehhandler$?GetUpdatePairInfoList@@YGXABVCDirItems@@ABV?$CObjectVector@UCArcItem@@@@W4EEnum@NFileTimeType@@AAV?$CRecordVector@UCUpdatePair@@@@@Z proc near
.text$x:00000CED                                         ; DATA XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+5o
.text$x:00000CED
.text$x:00000CED arg_4           = dword ptr  8
.text$x:00000CED
.text$x:00000CED                 mov     edx, [esp+arg_4]
.text$x:00000CF1                 lea     eax, [edx+0Ch]
.text$x:00000CF4                 mov     ecx, [edx-10Ch]
.text$x:00000CFA                 xor     ecx, eax
.text$x:00000CFC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000D01                 mov     eax, offset __ehfuncinfo$?GetUpdatePairInfoList@@YGXABVCDirItems@@ABV?$CObjectVector@UCArcItem@@@@W4EEnum@NFileTimeType@@AAV?$CRecordVector@UCUpdatePair@@@@@Z
.text$x:00000D06                 jmp     ___CxxFrameHandler3
.text$x:00000D06 __ehhandler$?GetUpdatePairInfoList@@YGXABVCDirItems@@ABV?$CObjectVector@UCArcItem@@@@W4EEnum@NFileTimeType@@AAV?$CRecordVector@UCUpdatePair@@@@@Z endp
.text$x:00000D06
.text$x:00000D0B
.text$x:00000D0B ; =============== S U B R O U T I N E =======================================
.text$x:00000D0B
.text$x:00000D0B
.text$x:00000D0B __unwindfunclet$?ThrowError@@YGXPBDABVUString@@1@Z$0 proc near
.text$x:00000D0B                                         ; DATA XREF: .xdata$x:00000D88o
.text$x:00000D0B                 lea     ecx, [ebp-1Ch]  ; this
.text$x:00000D0E                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00000D0E __unwindfunclet$?ThrowError@@YGXPBDABVUString@@1@Z$0 endp
.text$x:00000D0E
.text$x:00000D13
.text$x:00000D13 ; =============== S U B R O U T I N E =======================================
.text$x:00000D13
.text$x:00000D13
.text$x:00000D13 __ehhandler$?ThrowError@@YGXPBDABVUString@@1@Z proc near
.text$x:00000D13                                         ; DATA XREF: ThrowError(char const *,UString const &,UString const &)+5o
.text$x:00000D13
.text$x:00000D13 arg_4           = dword ptr  8
.text$x:00000D13
.text$x:00000D13                 mov     edx, [esp+arg_4]
.text$x:00000D17                 lea     eax, [edx+0Ch]
.text$x:00000D1A                 mov     ecx, [edx-24h]
.text$x:00000D1D                 xor     ecx, eax
.text$x:00000D1F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000D24                 mov     eax, offset __ehfuncinfo$?ThrowError@@YGXPBDABVUString@@1@Z
.text$x:00000D29                 jmp     ___CxxFrameHandler3
.text$x:00000D29 __ehhandler$?ThrowError@@YGXPBDABVUString@@1@Z endp
.text$x:00000D29
.text$x:00000D29 ; ---------------------------------------------------------------------------
.text$x:00000D2E                 align 10h
.text$x:00000D2E _text$x         ends
.text$x:00000D2E
.xdata$x:00000D30 ; ===========================================================================
.xdata$x:00000D30
.xdata$x:00000D30 ; Segment type: Pure data
.xdata$x:00000D30 ; Segment permissions: Read
.xdata$x:00000D30 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00000D30                 assume cs:_xdata$x
.xdata$x:00000D30                 ;org 0D30h
.xdata$x:00000D30 __ehfuncinfo$?GetUpdatePairInfoList@@YGXABVCDirItems@@ABV?$CObjectVector@UCArcItem@@@@W4EEnum@NFileTimeType@@AAV?$CRecordVector@UCUpdatePair@@@@@Z db  22h ; "
.xdata$x:00000D30                                         ; DATA XREF: __ehhandler$?GetUpdatePairInfoList@@YGXABVCDirItems@@ABV?$CObjectVector@UCArcItem@@@@W4EEnum@NFileTimeType@@AAV?$CRecordVector@UCUpdatePair@@@@@Z+14o
.xdata$x:00000D31                 db    5
.xdata$x:00000D32                 db  93h ; ô
.xdata$x:00000D33                 db  19h
.xdata$x:00000D34                 db    6
.xdata$x:00000D35                 db    0
.xdata$x:00000D36                 db    0
.xdata$x:00000D37                 db    0
.xdata$x:00000D38                 dd offset __unwindtable$?GetUpdatePairInfoList@@YGXABVCDirItems@@ABV?$CObjectVector@UCArcItem@@@@W4EEnum@NFileTimeType@@AAV?$CRecordVector@UCUpdatePair@@@@@Z
.xdata$x:00000D3C                 db    0
.xdata$x:00000D3D                 db    0
.xdata$x:00000D3E                 db    0
.xdata$x:00000D3F                 db    0
.xdata$x:00000D40                 db    0
.xdata$x:00000D41                 db    0
.xdata$x:00000D42                 db    0
.xdata$x:00000D43                 db    0
.xdata$x:00000D44                 db    0
.xdata$x:00000D45                 db    0
.xdata$x:00000D46                 db    0
.xdata$x:00000D47                 db    0
.xdata$x:00000D48                 db    0
.xdata$x:00000D49                 db    0
.xdata$x:00000D4A                 db    0
.xdata$x:00000D4B                 db    0
.xdata$x:00000D4C                 db    0
.xdata$x:00000D4D                 db    0
.xdata$x:00000D4E                 db    0
.xdata$x:00000D4F                 db    0
.xdata$x:00000D50                 db    1
.xdata$x:00000D51                 db    0
.xdata$x:00000D52                 db    0
.xdata$x:00000D53                 db    0
.xdata$x:00000D54 __unwindtable$?GetUpdatePairInfoList@@YGXABVCDirItems@@ABV?$CObjectVector@UCArcItem@@@@W4EEnum@NFileTimeType@@AAV?$CRecordVector@UCUpdatePair@@@@@Z db 0FFh
.xdata$x:00000D54                                         ; DATA XREF: .xdata$x:00000D38o
.xdata$x:00000D55                 db 0FFh
.xdata$x:00000D56                 db 0FFh
.xdata$x:00000D57                 db 0FFh
.xdata$x:00000D58                 dd offset __unwindfunclet$?GetUpdatePairInfoList@@YGXABVCDirItems@@ABV?$CObjectVector@UCArcItem@@@@W4EEnum@NFileTimeType@@AAV?$CRecordVector@UCUpdatePair@@@@@Z$0
.xdata$x:00000D5C                 align 10h
.xdata$x:00000D60                 dd offset __unwindfunclet$?GetUpdatePairInfoList@@YGXABVCDirItems@@ABV?$CObjectVector@UCArcItem@@@@W4EEnum@NFileTimeType@@AAV?$CRecordVector@UCUpdatePair@@@@@Z$1
.xdata$x:00000D64                 db    1
.xdata$x:00000D65                 db    0
.xdata$x:00000D66                 db    0
.xdata$x:00000D67                 db    0
.xdata$x:00000D68                 dd offset __unwindfunclet$?GetUpdatePairInfoList@@YGXABVCDirItems@@ABV?$CObjectVector@UCArcItem@@@@W4EEnum@NFileTimeType@@AAV?$CRecordVector@UCUpdatePair@@@@@Z$2
.xdata$x:00000D6C                 db    2
.xdata$x:00000D6D                 db    0
.xdata$x:00000D6E                 db    0
.xdata$x:00000D6F                 db    0
.xdata$x:00000D70                 dd offset __unwindfunclet$?GetUpdatePairInfoList@@YGXABVCDirItems@@ABV?$CObjectVector@UCArcItem@@@@W4EEnum@NFileTimeType@@AAV?$CRecordVector@UCUpdatePair@@@@@Z$3
.xdata$x:00000D74                 db    3
.xdata$x:00000D75                 db    0
.xdata$x:00000D76                 db    0
.xdata$x:00000D77                 db    0
.xdata$x:00000D78                 dd offset __unwindfunclet$?GetUpdatePairInfoList@@YGXABVCDirItems@@ABV?$CObjectVector@UCArcItem@@@@W4EEnum@NFileTimeType@@AAV?$CRecordVector@UCUpdatePair@@@@@Z$4
.xdata$x:00000D7C                 db    3
.xdata$x:00000D7D                 db    0
.xdata$x:00000D7E                 db    0
.xdata$x:00000D7F                 db    0
.xdata$x:00000D80                 dd offset __unwindfunclet$?GetUpdatePairInfoList@@YGXABVCDirItems@@ABV?$CObjectVector@UCArcItem@@@@W4EEnum@NFileTimeType@@AAV?$CRecordVector@UCUpdatePair@@@@@Z$5
.xdata$x:00000D84 __unwindtable$?ThrowError@@YGXPBDABVUString@@1@Z db 0FFh
.xdata$x:00000D84                                         ; DATA XREF: .xdata$x:00000D94o
.xdata$x:00000D85                 db 0FFh
.xdata$x:00000D86                 db 0FFh
.xdata$x:00000D87                 db 0FFh
.xdata$x:00000D88                 dd offset __unwindfunclet$?ThrowError@@YGXPBDABVUString@@1@Z$0
.xdata$x:00000D8C __ehfuncinfo$?ThrowError@@YGXPBDABVUString@@1@Z db  22h ; "
.xdata$x:00000D8C                                         ; DATA XREF: __ehhandler$?ThrowError@@YGXPBDABVUString@@1@Z+11o
.xdata$x:00000D8D                 db    5
.xdata$x:00000D8E                 db  93h ; ô
.xdata$x:00000D8F                 db  19h
.xdata$x:00000D90                 db    1
.xdata$x:00000D91                 db    0
.xdata$x:00000D92                 db    0
.xdata$x:00000D93                 db    0
.xdata$x:00000D94                 dd offset __unwindtable$?ThrowError@@YGXPBDABVUString@@1@Z
.xdata$x:00000D98                 db    0
.xdata$x:00000D99                 db    0
.xdata$x:00000D9A                 db    0
.xdata$x:00000D9B                 db    0
.xdata$x:00000D9C                 db    0
.xdata$x:00000D9D                 db    0
.xdata$x:00000D9E                 db    0
.xdata$x:00000D9F                 db    0
.xdata$x:00000DA0                 db    0
.xdata$x:00000DA1                 db    0
.xdata$x:00000DA2                 db    0
.xdata$x:00000DA3                 db    0
.xdata$x:00000DA4                 db    0
.xdata$x:00000DA5                 db    0
.xdata$x:00000DA6                 db    0
.xdata$x:00000DA7                 db    0
.xdata$x:00000DA8                 db    0
.xdata$x:00000DA9                 db    0
.xdata$x:00000DAA                 db    0
.xdata$x:00000DAB                 db    0
.xdata$x:00000DAC                 db    1
.xdata$x:00000DAD                 db    0
.xdata$x:00000DAE                 db    0
.xdata$x:00000DAF                 db    0
.xdata$x:00000DAF _xdata$x        ends
.xdata$x:00000DAF
.rtc$TMZ:00000DB0 ; ===========================================================================
.rtc$TMZ:00000DB0
.rtc$TMZ:00000DB0 ; Segment type: Pure data
.rtc$TMZ:00000DB0 ; Segment permissions: Read
.rtc$TMZ:00000DB0 _rtc$TMZ        segment dword public 'DATA' use32
.rtc$TMZ:00000DB0                 assume cs:_rtc$TMZ
.rtc$TMZ:00000DB0                 ;org 0DB0h
.rtc$TMZ:00000DB0 ; COMDAT (pick any)
.rtc$TMZ:00000DB0 __RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
.rtc$TMZ:00000DB0 _rtc$TMZ        ends
.rtc$TMZ:00000DB0
.rtc$IMZ:00000DB4 ; ===========================================================================
.rtc$IMZ:00000DB4
.rtc$IMZ:00000DB4 ; Segment type: Pure data
.rtc$IMZ:00000DB4 ; Segment permissions: Read
.rtc$IMZ:00000DB4 _rtc$IMZ        segment dword public 'DATA' use32
.rtc$IMZ:00000DB4                 assume cs:_rtc$IMZ
.rtc$IMZ:00000DB4                 ;org 0DB4h
.rtc$IMZ:00000DB4 ; COMDAT (pick any)
.rtc$IMZ:00000DB4 __RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
.rtc$IMZ:00000DB4 _rtc$IMZ        ends
.rtc$IMZ:00000DB4
.text:00000DB8 ; ===========================================================================
.text:00000DB8
.text:00000DB8 ; Segment type: Pure code
.text:00000DB8 ; Segment permissions: Read/Execute
.text:00000DB8 _text           segment para public 'CODE' use32
.text:00000DB8                 assume cs:_text
.text:00000DB8                 ;org 0DB8h
.text:00000DB8 ; COMDAT (pick any)
.text:00000DB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000DB8
.text:00000DB8 ; =============== S U B R O U T I N E =======================================
.text:00000DB8
.text:00000DB8 ; Attributes: bp-based frame
.text:00000DB8
.text:00000DB8 ; _DWORD __thiscall UString::~UString(UString *__hidden this)
.text:00000DB8                 public ??1UString@@QAE@XZ
.text:00000DB8 ??1UString@@QAE@XZ proc near            ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+203p
.text:00000DB8                                         ; GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+799p ...
.text:00000DB8
.text:00000DB8 var_8           = dword ptr -8
.text:00000DB8 var_4           = dword ptr -4
.text:00000DB8
.text:00000DB8                 push    ebp
.text:00000DB9                 mov     ebp, esp
.text:00000DBB                 sub     esp, 8
.text:00000DBE                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00000DC5                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000DCC                 mov     [ebp+var_4], ecx
.text:00000DCF                 mov     eax, [ebp+var_4]
.text:00000DD2                 mov     ecx, [eax]
.text:00000DD4                 mov     [ebp+var_8], ecx
.text:00000DD7                 mov     edx, [ebp+var_8]
.text:00000DDA                 push    edx             ; void *
.text:00000DDB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00000DE0                 add     esp, 4
.text:00000DE3                 add     esp, 8
.text:00000DE6                 cmp     ebp, esp
.text:00000DE8                 call    __RTC_CheckEsp
.text:00000DED                 mov     esp, ebp
.text:00000DEF                 pop     ebp
.text:00000DF0                 retn
.text:00000DF0 ??1UString@@QAE@XZ endp
.text:00000DF0
.text:00000DF0 ; ---------------------------------------------------------------------------
.text:00000DF1                 align 4
.text:00000DF1 _text           ends
.text:00000DF1
.text:00000DF4 ; ===========================================================================
.text:00000DF4
.text:00000DF4 ; Segment type: Pure code
.text:00000DF4 ; Segment permissions: Read/Execute
.text:00000DF4 _text           segment para public 'CODE' use32
.text:00000DF4                 assume cs:_text
.text:00000DF4                 ;org 0DF4h
.text:00000DF4 ; COMDAT (pick any)
.text:00000DF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000DF4
.text:00000DF4 ; =============== S U B R O U T I N E =======================================
.text:00000DF4
.text:00000DF4 ; Attributes: bp-based frame
.text:00000DF4
.text:00000DF4 ; unsigned int __thiscall UString::Len(UString *__hidden this)
.text:00000DF4                 public ?Len@UString@@QBEIXZ
.text:00000DF4 ?Len@UString@@QBEIXZ proc near          ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+6BDp
.text:00000DF4                                         ; GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+6CEp
.text:00000DF4
.text:00000DF4 var_4           = dword ptr -4
.text:00000DF4
.text:00000DF4                 push    ebp
.text:00000DF5                 mov     ebp, esp
.text:00000DF7                 push    ecx
.text:00000DF8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000DFF                 mov     [ebp+var_4], ecx
.text:00000E02                 mov     eax, [ebp+var_4]
.text:00000E05                 mov     eax, [eax+4]
.text:00000E08                 mov     esp, ebp
.text:00000E0A                 pop     ebp
.text:00000E0B                 retn
.text:00000E0B ?Len@UString@@QBEIXZ endp
.text:00000E0B
.text:00000E0B _text           ends
.text:00000E0B
.text:00000E0C ; ===========================================================================
.text:00000E0C
.text:00000E0C ; Segment type: Pure code
.text:00000E0C ; Segment permissions: Read/Execute
.text:00000E0C _text           segment para public 'CODE' use32
.text:00000E0C                 assume cs:_text
.text:00000E0C                 ;org 0E0Ch
.text:00000E0C ; COMDAT (pick any)
.text:00000E0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000E0C
.text:00000E0C ; =============== S U B R O U T I N E =======================================
.text:00000E0C
.text:00000E0C ; Attributes: bp-based frame
.text:00000E0C
.text:00000E0C ; public: __thiscall UString::operator wchar_t const *(void)const
.text:00000E0C                 public ??BUString@@QBEPB_WXZ
.text:00000E0C ??BUString@@QBEPB_WXZ proc near         ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+26Ep
.text:00000E0C                                         ; GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+277p ...
.text:00000E0C
.text:00000E0C var_4           = dword ptr -4
.text:00000E0C
.text:00000E0C                 push    ebp
.text:00000E0D                 mov     ebp, esp
.text:00000E0F                 push    ecx
.text:00000E10                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000E17                 mov     [ebp+var_4], ecx
.text:00000E1A                 mov     eax, [ebp+var_4]
.text:00000E1D                 mov     eax, [eax]
.text:00000E1F                 mov     esp, ebp
.text:00000E21                 pop     ebp
.text:00000E22                 retn
.text:00000E22 ??BUString@@QBEPB_WXZ endp
.text:00000E22
.text:00000E22 ; ---------------------------------------------------------------------------
.text:00000E23                 align 4
.text:00000E23 _text           ends
.text:00000E23
.text:00000E24 ; ===========================================================================
.text:00000E24
.text:00000E24 ; Segment type: Pure code
.text:00000E24 ; Segment permissions: Read/Execute
.text:00000E24 _text           segment para public 'CODE' use32
.text:00000E24                 assume cs:_text
.text:00000E24                 ;org 0E24h
.text:00000E24 ; COMDAT (pick any)
.text:00000E24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000E24
.text:00000E24 ; =============== S U B R O U T I N E =======================================
.text:00000E24
.text:00000E24 ; Attributes: bp-based frame
.text:00000E24
.text:00000E24 ; public: class UString __thiscall UString::Left(unsigned int)const
.text:00000E24                 public ?Left@UString@@QBE?AV1@I@Z
.text:00000E24 ?Left@UString@@QBE?AV1@I@Z proc near    ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+70Dp
.text:00000E24
.text:00000E24 var_8           = dword ptr -8
.text:00000E24 var_4           = dword ptr -4
.text:00000E24 arg_0           = dword ptr  8
.text:00000E24 arg_4           = dword ptr  0Ch
.text:00000E24
.text:00000E24                 push    ebp
.text:00000E25                 mov     ebp, esp
.text:00000E27                 sub     esp, 8
.text:00000E2A                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00000E31                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000E38                 mov     [ebp+var_4], ecx
.text:00000E3B                 mov     [ebp+var_8], 0
.text:00000E42                 mov     eax, [ebp+var_4]
.text:00000E45                 push    eax
.text:00000E46                 mov     ecx, [ebp+arg_4]
.text:00000E49                 push    ecx
.text:00000E4A                 mov     ecx, [ebp+arg_0]
.text:00000E4D                 call    ??0UString@@AAE@IABV0@@Z ; UString::UString(uint,UString const &)
.text:00000E52                 mov     edx, [ebp+var_8]
.text:00000E55                 or      edx, 1
.text:00000E58                 mov     [ebp+var_8], edx
.text:00000E5B                 mov     eax, [ebp+arg_0]
.text:00000E5E                 add     esp, 8
.text:00000E61                 cmp     ebp, esp
.text:00000E63                 call    __RTC_CheckEsp
.text:00000E68                 mov     esp, ebp
.text:00000E6A                 pop     ebp
.text:00000E6B                 retn    8
.text:00000E6B ?Left@UString@@QBE?AV1@I@Z endp
.text:00000E6B
.text:00000E6B ; ---------------------------------------------------------------------------
.text:00000E6E                 align 10h
.text:00000E6E _text           ends
.text:00000E6E
.text:00000E70 ; ===========================================================================
.text:00000E70
.text:00000E70 ; Segment type: Pure code
.text:00000E70 ; Segment permissions: Read/Execute
.text:00000E70 _text           segment para public 'CODE' use32
.text:00000E70                 assume cs:_text
.text:00000E70                 ;org 0E70h
.text:00000E70 ; COMDAT (pick any)
.text:00000E70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000E70
.text:00000E70 ; =============== S U B R O U T I N E =======================================
.text:00000E70
.text:00000E70 ; Attributes: bp-based frame
.text:00000E70
.text:00000E70 ; bool __thiscall CDirItem::IsDir(CDirItem *__hidden this)
.text:00000E70                 public ?IsDir@CDirItem@@QBE_NXZ
.text:00000E70 ?IsDir@CDirItem@@QBE_NXZ proc near      ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+3E0p
.text:00000E70
.text:00000E70 var_4           = dword ptr -4
.text:00000E70
.text:00000E70                 push    ebp
.text:00000E71                 mov     ebp, esp
.text:00000E73                 push    ecx
.text:00000E74                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000E7B                 mov     [ebp+var_4], ecx
.text:00000E7E                 mov     eax, [ebp+var_4]
.text:00000E81                 mov     eax, [eax+3Ch]
.text:00000E84                 and     eax, 10h
.text:00000E87                 neg     eax
.text:00000E89                 sbb     eax, eax
.text:00000E8B                 neg     eax
.text:00000E8D                 mov     esp, ebp
.text:00000E8F                 pop     ebp
.text:00000E90                 retn
.text:00000E90 ?IsDir@CDirItem@@QBE_NXZ endp
.text:00000E90
.text:00000E90 ; ---------------------------------------------------------------------------
.text:00000E91                 align 4
.text:00000E91 _text           ends
.text:00000E91
.text:00000E94 ; ===========================================================================
.text:00000E94
.text:00000E94 ; Segment type: Pure code
.text:00000E94 ; Segment permissions: Read/Execute
.text:00000E94 _text           segment para public 'CODE' use32
.text:00000E94                 assume cs:_text
.text:00000E94                 ;org 0E94h
.text:00000E94 ; COMDAT (pick any)
.text:00000E94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000E94
.text:00000E94 ; =============== S U B R O U T I N E =======================================
.text:00000E94
.text:00000E94 ; Attributes: bp-based frame
.text:00000E94
.text:00000E94 ; _DWORD __thiscall CUpdatePair::CUpdatePair(CUpdatePair *__hidden this)
.text:00000E94                 public ??0CUpdatePair@@QAE@XZ
.text:00000E94 ??0CUpdatePair@@QAE@XZ proc near        ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+2DEp
.text:00000E94                                         ; DATA XREF: CRecordVector<CUpdatePair>::ReserveDown(void)+9Eo ...
.text:00000E94
.text:00000E94 var_4           = dword ptr -4
.text:00000E94
.text:00000E94                 push    ebp
.text:00000E95                 mov     ebp, esp
.text:00000E97                 push    ecx
.text:00000E98                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000E9F                 mov     [ebp+var_4], ecx
.text:00000EA2                 mov     eax, [ebp+var_4]
.text:00000EA5                 mov     dword ptr [eax+4], 0FFFFFFFFh
.text:00000EAC                 mov     ecx, [ebp+var_4]
.text:00000EAF                 mov     dword ptr [ecx+8], 0FFFFFFFFh
.text:00000EB6                 mov     edx, [ebp+var_4]
.text:00000EB9                 mov     dword ptr [edx+0Ch], 0FFFFFFFFh
.text:00000EC0                 mov     eax, [ebp+var_4]
.text:00000EC3                 mov     esp, ebp
.text:00000EC5                 pop     ebp
.text:00000EC6                 retn
.text:00000EC6 ??0CUpdatePair@@QAE@XZ endp
.text:00000EC6
.text:00000EC6 ; ---------------------------------------------------------------------------
.text:00000EC7                 align 4
.text:00000EC7 _text           ends
.text:00000EC7
.xdata$x:00000EC8 ; ===========================================================================
.xdata$x:00000EC8
.xdata$x:00000EC8 ; Segment type: Pure data
.xdata$x:00000EC8 ; Segment permissions: Read
.xdata$x:00000EC8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00000EC8                 assume cs:_xdata$x
.xdata$x:00000EC8                 ;org 0EC8h
.xdata$x:00000EC8 ; COMDAT (pick any)
.xdata$x:00000EC8                 public __TI1H
.xdata$x:00000EC8 __TI1H          db    0                 ; DATA XREF: MyCompareTime(NFileTimeType::EEnum,_FILETIME const &,_FILETIME const &)+A3o
.xdata$x:00000EC9                 db    0
.xdata$x:00000ECA                 db    0
.xdata$x:00000ECB                 db    0
.xdata$x:00000ECC                 db    0
.xdata$x:00000ECD                 db    0
.xdata$x:00000ECE                 db    0
.xdata$x:00000ECF                 db    0
.xdata$x:00000ED0                 db    0
.xdata$x:00000ED1                 db    0
.xdata$x:00000ED2                 db    0
.xdata$x:00000ED3                 db    0
.xdata$x:00000ED4                 dd offset __CTA1H
.xdata$x:00000ED4 _xdata$x        ends
.xdata$x:00000ED4
.xdata$x:00000ED8 ; ===========================================================================
.xdata$x:00000ED8
.xdata$x:00000ED8 ; Segment type: Pure data
.xdata$x:00000ED8 ; Segment permissions: Read
.xdata$x:00000ED8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00000ED8                 assume cs:_xdata$x
.xdata$x:00000ED8                 ;org 0ED8h
.xdata$x:00000ED8 ; COMDAT (pick any)
.xdata$x:00000ED8                 public __CTA1H
.xdata$x:00000ED8 __CTA1H         db    1                 ; DATA XREF: .xdata$x:00000ED4o
.xdata$x:00000ED9                 db    0
.xdata$x:00000EDA                 db    0
.xdata$x:00000EDB                 db    0
.xdata$x:00000EDC                 dd offset __CT??_R0H@84
.xdata$x:00000EDC _xdata$x        ends
.xdata$x:00000EDC
.xdata$x:00000EE0 ; ===========================================================================
.xdata$x:00000EE0
.xdata$x:00000EE0 ; Segment type: Pure data
.xdata$x:00000EE0 ; Segment permissions: Read
.xdata$x:00000EE0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00000EE0                 assume cs:_xdata$x
.xdata$x:00000EE0                 ;org 0EE0h
.xdata$x:00000EE0 ; COMDAT (pick any)
.xdata$x:00000EE0                 public __CT??_R0H@84
.xdata$x:00000EE0 __CT??_R0H@84   db    1                 ; DATA XREF: .xdata$x:00000EDCo
.xdata$x:00000EE1                 db    0
.xdata$x:00000EE2                 db    0
.xdata$x:00000EE3                 db    0
.xdata$x:00000EE4                 dd offset ??_R0H@8      ; int `RTTI Type Descriptor'
.xdata$x:00000EE8                 db    0
.xdata$x:00000EE9                 db    0
.xdata$x:00000EEA                 db    0
.xdata$x:00000EEB                 db    0
.xdata$x:00000EEC                 db 0FFh
.xdata$x:00000EED                 db 0FFh
.xdata$x:00000EEE                 db 0FFh
.xdata$x:00000EEF                 db 0FFh
.xdata$x:00000EF0                 db    0
.xdata$x:00000EF1                 db    0
.xdata$x:00000EF2                 db    0
.xdata$x:00000EF3                 db    0
.xdata$x:00000EF4                 db    4
.xdata$x:00000EF5                 db    0
.xdata$x:00000EF6                 db    0
.xdata$x:00000EF7                 db    0
.xdata$x:00000EF8                 db    0
.xdata$x:00000EF9                 db    0
.xdata$x:00000EFA                 db    0
.xdata$x:00000EFB                 db    0
.xdata$x:00000EFB _xdata$x        ends
.xdata$x:00000EFB
.data:00000EFC ; ===========================================================================
.data:00000EFC
.data:00000EFC ; Segment type: Pure data
.data:00000EFC ; Segment permissions: Read/Write
.data:00000EFC _data           segment dword public 'DATA' use32
.data:00000EFC                 assume cs:_data
.data:00000EFC                 ;org 0EFCh
.data:00000EFC ; COMDAT (pick any)
.data:00000EFC                 public ??_R0H@8
.data:00000EFC ; int `RTTI Type Descriptor'
.data:00000EFC ??_R0H@8        dd offset ??_7type_info@@6B@ ; DATA XREF: .xdata$x:00000EE4o
.data:00000EFC                                         ; const type_info::`vftable'
.data:00000F00                 db    0
.data:00000F01                 db    0
.data:00000F02                 db    0
.data:00000F03                 db    0
.data:00000F04                 db  2Eh ; .
.data:00000F05                 db  48h ; H
.data:00000F06                 db    0
.data:00000F07                 align 4
.data:00000F07 _data           ends
.data:00000F07
.xdata$x:00000F08 ; ===========================================================================
.xdata$x:00000F08
.xdata$x:00000F08 ; Segment type: Pure data
.xdata$x:00000F08 ; Segment permissions: Read
.xdata$x:00000F08 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00000F08                 assume cs:_xdata$x
.xdata$x:00000F08                 ;org 0F08h
.xdata$x:00000F08 ; COMDAT (pick any)
.xdata$x:00000F08                 public __TI1?AVUString@@
.xdata$x:00000F08 __TI1?AVUString@@ db    0               ; DATA XREF: ThrowError(char const *,UString const &,UString const &)+91o
.xdata$x:00000F09                 db    0
.xdata$x:00000F0A                 db    0
.xdata$x:00000F0B                 db    0
.xdata$x:00000F0C                 dd offset ??1UString@@QAE@XZ ; UString::~UString(void)
.xdata$x:00000F10                 db    0
.xdata$x:00000F11                 db    0
.xdata$x:00000F12                 db    0
.xdata$x:00000F13                 db    0
.xdata$x:00000F14                 dd offset __CTA1?AVUString@@
.xdata$x:00000F14 _xdata$x        ends
.xdata$x:00000F14
.xdata$x:00000F18 ; ===========================================================================
.xdata$x:00000F18
.xdata$x:00000F18 ; Segment type: Pure data
.xdata$x:00000F18 ; Segment permissions: Read
.xdata$x:00000F18 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00000F18                 assume cs:_xdata$x
.xdata$x:00000F18                 ;org 0F18h
.xdata$x:00000F18 ; COMDAT (pick any)
.xdata$x:00000F18                 public __CTA1?AVUString@@
.xdata$x:00000F18 __CTA1?AVUString@@ db    1              ; DATA XREF: .xdata$x:00000F14o
.xdata$x:00000F19                 db    0
.xdata$x:00000F1A                 db    0
.xdata$x:00000F1B                 db    0
.xdata$x:00000F1C                 dd offset __CT??_R0?AVUString@@@8??0UString@@QAE@ABV0@@Z12
.xdata$x:00000F1C _xdata$x        ends
.xdata$x:00000F1C
.xdata$x:00000F20 ; ===========================================================================
.xdata$x:00000F20
.xdata$x:00000F20 ; Segment type: Pure data
.xdata$x:00000F20 ; Segment permissions: Read
.xdata$x:00000F20 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00000F20                 assume cs:_xdata$x
.xdata$x:00000F20                 ;org 0F20h
.xdata$x:00000F20 ; COMDAT (pick any)
.xdata$x:00000F20                 public __CT??_R0?AVUString@@@8??0UString@@QAE@ABV0@@Z12
.xdata$x:00000F20 __CT??_R0?AVUString@@@8??0UString@@QAE@ABV0@@Z12 db    0
.xdata$x:00000F20                                         ; DATA XREF: .xdata$x:00000F1Co
.xdata$x:00000F21                 db    0
.xdata$x:00000F22                 db    0
.xdata$x:00000F23                 db    0
.xdata$x:00000F24                 dd offset ??_R0?AVUString@@@8 ; UString `RTTI Type Descriptor'
.xdata$x:00000F28                 db    0
.xdata$x:00000F29                 db    0
.xdata$x:00000F2A                 db    0
.xdata$x:00000F2B                 db    0
.xdata$x:00000F2C                 db 0FFh
.xdata$x:00000F2D                 db 0FFh
.xdata$x:00000F2E                 db 0FFh
.xdata$x:00000F2F                 db 0FFh
.xdata$x:00000F30                 db    0
.xdata$x:00000F31                 db    0
.xdata$x:00000F32                 db    0
.xdata$x:00000F33                 db    0
.xdata$x:00000F34                 db  0Ch
.xdata$x:00000F35                 db    0
.xdata$x:00000F36                 db    0
.xdata$x:00000F37                 db    0
.xdata$x:00000F38                 dd offset ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.xdata$x:00000F38 _xdata$x        ends
.xdata$x:00000F38
.data:00000F3C ; ===========================================================================
.data:00000F3C
.data:00000F3C ; Segment type: Pure data
.data:00000F3C ; Segment permissions: Read/Write
.data:00000F3C _data           segment dword public 'DATA' use32
.data:00000F3C                 assume cs:_data
.data:00000F3C                 ;org 0F3Ch
.data:00000F3C ; COMDAT (pick any)
.data:00000F3C                 public ??_R0?AVUString@@@8
.data:00000F3C ; class UString `RTTI Type Descriptor'
.data:00000F3C ??_R0?AVUString@@@8 dd offset ??_7type_info@@6B@
.data:00000F3C                                         ; DATA XREF: .xdata$x:00000F24o
.data:00000F3C                                         ; const type_info::`vftable'
.data:00000F40                 db    0
.data:00000F41                 db    0
.data:00000F42                 db    0
.data:00000F43                 db    0
.data:00000F44                 db  2Eh ; .
.data:00000F45                 db  3Fh ; ?
.data:00000F46                 db  41h ; A
.data:00000F47                 db  56h ; V
.data:00000F48                 db  55h ; U
.data:00000F49                 db  53h ; S
.data:00000F4A                 db  74h ; t
.data:00000F4B                 db  72h ; r
.data:00000F4C                 db  69h ; i
.data:00000F4D                 db  6Eh ; n
.data:00000F4E                 db  67h ; g
.data:00000F4F                 db  40h ; @
.data:00000F50                 db  40h ; @
.data:00000F51                 db    0
.data:00000F52                 align 4
.data:00000F52 _data           ends
.data:00000F52
.text:00000F54 ; ===========================================================================
.text:00000F54
.text:00000F54 ; Segment type: Pure code
.text:00000F54 ; Segment permissions: Read/Execute
.text:00000F54 _text           segment para public 'CODE' use32
.text:00000F54                 assume cs:_text
.text:00000F54                 ;org 0F54h
.text:00000F54 ; COMDAT (pick any)
.text:00000F54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000F54
.text:00000F54 ; =============== S U B R O U T I N E =======================================
.text:00000F54
.text:00000F54 ; Attributes: bp-based frame
.text:00000F54
.text:00000F54 ; public: void __thiscall CObjectVector<class UString>::ClearAndReserve(unsigned int)
.text:00000F54                 public ?ClearAndReserve@?$CObjectVector@VUString@@@@QAEXI@Z
.text:00000F54 ?ClearAndReserve@?$CObjectVector@VUString@@@@QAEXI@Z proc near
.text:00000F54                                         ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+1A2p
.text:00000F54
.text:00000F54 var_4           = dword ptr -4
.text:00000F54 arg_0           = dword ptr  8
.text:00000F54
.text:00000F54                 push    ebp
.text:00000F55                 mov     ebp, esp
.text:00000F57                 push    ecx
.text:00000F58                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000F5F                 mov     [ebp+var_4], ecx
.text:00000F62                 mov     ecx, [ebp+var_4]
.text:00000F65                 call    ?Clear@?$CObjectVector@VUString@@@@QAEXXZ ; CObjectVector<UString>::Clear(void)
.text:00000F6A                 mov     eax, [ebp+arg_0]
.text:00000F6D                 push    eax
.text:00000F6E                 mov     ecx, [ebp+var_4]
.text:00000F71                 call    ?ClearAndReserve@?$CRecordVector@PAX@@QAEXI@Z ; CRecordVector<void *>::ClearAndReserve(uint)
.text:00000F76                 add     esp, 4
.text:00000F79                 cmp     ebp, esp
.text:00000F7B                 call    __RTC_CheckEsp
.text:00000F80                 mov     esp, ebp
.text:00000F82                 pop     ebp
.text:00000F83                 retn    4
.text:00000F83 ?ClearAndReserve@?$CObjectVector@VUString@@@@QAEXI@Z endp
.text:00000F83
.text:00000F83 ; ---------------------------------------------------------------------------
.text:00000F86                 align 4
.text:00000F86 _text           ends
.text:00000F86
.text:00000F88 ; ===========================================================================
.text:00000F88
.text:00000F88 ; Segment type: Pure code
.text:00000F88 ; Segment permissions: Read/Execute
.text:00000F88 _text           segment para public 'CODE' use32
.text:00000F88                 assume cs:_text
.text:00000F88                 ;org 0F88h
.text:00000F88 ; COMDAT (pick any)
.text:00000F88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000F88
.text:00000F88 ; =============== S U B R O U T I N E =======================================
.text:00000F88
.text:00000F88 ; Attributes: bp-based frame
.text:00000F88
.text:00000F88 ; public: __thiscall CObjectVector<class UString>::CObjectVector<class UString>(void)
.text:00000F88                 public ??0?$CObjectVector@VUString@@@@QAE@XZ
.text:00000F88 ??0?$CObjectVector@VUString@@@@QAE@XZ proc near
.text:00000F88                                         ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+192p
.text:00000F88
.text:00000F88 var_4           = dword ptr -4
.text:00000F88
.text:00000F88                 push    ebp
.text:00000F89                 mov     ebp, esp
.text:00000F8B                 push    ecx
.text:00000F8C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000F93                 mov     [ebp+var_4], ecx
.text:00000F96                 mov     ecx, [ebp+var_4]
.text:00000F99                 call    ??0?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::CRecordVector<void *>(void)
.text:00000F9E                 mov     eax, [ebp+var_4]
.text:00000FA1                 add     esp, 4
.text:00000FA4                 cmp     ebp, esp
.text:00000FA6                 call    __RTC_CheckEsp
.text:00000FAB                 mov     esp, ebp
.text:00000FAD                 pop     ebp
.text:00000FAE                 retn
.text:00000FAE ??0?$CObjectVector@VUString@@@@QAE@XZ endp
.text:00000FAE
.text:00000FAE ; ---------------------------------------------------------------------------
.text:00000FAF                 align 10h
.text:00000FAF _text           ends
.text:00000FAF
.text:00000FB0 ; ===========================================================================
.text:00000FB0
.text:00000FB0 ; Segment type: Pure code
.text:00000FB0 ; Segment permissions: Read/Execute
.text:00000FB0 _text           segment para public 'CODE' use32
.text:00000FB0                 assume cs:_text
.text:00000FB0                 ;org 0FB0h
.text:00000FB0 ; COMDAT (pick any)
.text:00000FB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000FB0
.text:00000FB0 ; =============== S U B R O U T I N E =======================================
.text:00000FB0
.text:00000FB0 ; Attributes: bp-based frame
.text:00000FB0
.text:00000FB0 ; public: class UString & __thiscall CObjectVector<class UString>::operator[](unsigned int)
.text:00000FB0                 public ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z
.text:00000FB0 ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z proc near
.text:00000FB0                                         ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+246p
.text:00000FB0                                         ; GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+263p ...
.text:00000FB0
.text:00000FB0 var_4           = dword ptr -4
.text:00000FB0 arg_0           = dword ptr  8
.text:00000FB0
.text:00000FB0                 push    ebp
.text:00000FB1                 mov     ebp, esp
.text:00000FB3                 push    ecx
.text:00000FB4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000FBB                 mov     [ebp+var_4], ecx
.text:00000FBE                 mov     eax, [ebp+arg_0]
.text:00000FC1                 push    eax
.text:00000FC2                 mov     ecx, [ebp+var_4]
.text:00000FC5                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00000FCA                 mov     eax, [eax]
.text:00000FCC                 add     esp, 4
.text:00000FCF                 cmp     ebp, esp
.text:00000FD1                 call    __RTC_CheckEsp
.text:00000FD6                 mov     esp, ebp
.text:00000FD8                 pop     ebp
.text:00000FD9                 retn    4
.text:00000FD9 ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z endp
.text:00000FD9
.text:00000FD9 _text           ends
.text:00000FD9
.text:00000FDC ; ===========================================================================
.text:00000FDC
.text:00000FDC ; Segment type: Pure code
.text:00000FDC ; Segment permissions: Read/Execute
.text:00000FDC _text           segment para public 'CODE' use32
.text:00000FDC                 assume cs:_text
.text:00000FDC                 ;org 0FDCh
.text:00000FDC ; COMDAT (pick any)
.text:00000FDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000FDC
.text:00000FDC ; =============== S U B R O U T I N E =======================================
.text:00000FDC
.text:00000FDC ; Attributes: bp-based frame
.text:00000FDC
.text:00000FDC ; public: void __thiscall CObjectVector<class UString>::AddInReserved(class UString const &)
.text:00000FDC                 public ?AddInReserved@?$CObjectVector@VUString@@@@QAEXABVUString@@@Z
.text:00000FDC ?AddInReserved@?$CObjectVector@VUString@@@@QAEXABVUString@@@Z proc near
.text:00000FDC                                         ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+1F4p
.text:00000FDC
.text:00000FDC var_1C          = dword ptr -1Ch
.text:00000FDC var_18          = dword ptr -18h
.text:00000FDC var_14          = dword ptr -14h
.text:00000FDC var_10          = dword ptr -10h
.text:00000FDC var_C           = dword ptr -0Ch
.text:00000FDC var_4           = dword ptr -4
.text:00000FDC arg_0           = dword ptr  8
.text:00000FDC
.text:00000FDC                 push    ebp
.text:00000FDD                 mov     ebp, esp
.text:00000FDF                 push    0FFFFFFFFh
.text:00000FE1                 push    offset __ehhandler$?AddInReserved@?$CObjectVector@VUString@@@@QAEXABVUString@@@Z
.text:00000FE6                 mov     eax, large fs:0
.text:00000FEC                 push    eax
.text:00000FED                 sub     esp, 10h
.text:00000FF0                 mov     eax, 0CCCCCCCCh
.text:00000FF5                 mov     [ebp+var_1C], eax
.text:00000FF8                 mov     [ebp+var_18], eax
.text:00000FFB                 mov     [ebp+var_14], eax
.text:00000FFE                 mov     [ebp+var_10], eax
.text:00001001                 mov     eax, dword ptr ds:___security_cookie
.text:00001006                 xor     eax, ebp
.text:00001008                 push    eax
.text:00001009                 lea     eax, [ebp+var_C]
.text:0000100C                 mov     large fs:0, eax
.text:00001012                 mov     [ebp+var_10], ecx
.text:00001015                 push    0Ch             ; unsigned int
.text:00001017                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0000101C                 add     esp, 4
.text:0000101F                 mov     [ebp+var_18], eax
.text:00001022                 mov     [ebp+var_4], 0
.text:00001029                 cmp     [ebp+var_18], 0
.text:0000102D                 jz      short loc_1040
.text:0000102F                 mov     eax, [ebp+arg_0]
.text:00001032                 push    eax
.text:00001033                 mov     ecx, [ebp+var_18]
.text:00001036                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:0000103B                 mov     [ebp+var_1C], eax
.text:0000103E                 jmp     short loc_1047
.text:00001040 ; ---------------------------------------------------------------------------
.text:00001040
.text:00001040 loc_1040:                               ; CODE XREF: CObjectVector<UString>::AddInReserved(UString const &)+51j
.text:00001040                 mov     [ebp+var_1C], 0
.text:00001047
.text:00001047 loc_1047:                               ; CODE XREF: CObjectVector<UString>::AddInReserved(UString const &)+62j
.text:00001047                 mov     ecx, [ebp+var_1C]
.text:0000104A                 mov     [ebp+var_14], ecx
.text:0000104D                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001054                 mov     edx, [ebp+var_14]
.text:00001057                 push    edx
.text:00001058                 mov     ecx, [ebp+var_10]
.text:0000105B                 call    ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z ; CRecordVector<void *>::AddInReserved(void * const)
.text:00001060                 mov     ecx, [ebp+var_C]
.text:00001063                 mov     large fs:0, ecx
.text:0000106A                 pop     ecx
.text:0000106B                 add     esp, 1Ch
.text:0000106E                 cmp     ebp, esp
.text:00001070                 call    __RTC_CheckEsp
.text:00001075                 mov     esp, ebp
.text:00001077                 pop     ebp
.text:00001078                 retn    4
.text:00001078 ?AddInReserved@?$CObjectVector@VUString@@@@QAEXABVUString@@@Z endp
.text:00001078
.text:00001078 ; ---------------------------------------------------------------------------
.text:0000107B                 align 4
.text:0000107B _text           ends
.text:0000107B
.text$x:0000107C ; ===========================================================================
.text$x:0000107C
.text$x:0000107C ; Segment type: Pure code
.text$x:0000107C ; Segment permissions: Read/Execute
.text$x:0000107C _text$x         segment para public 'CODE' use32
.text$x:0000107C                 assume cs:_text$x
.text$x:0000107C                 ;org 107Ch
.text$x:0000107C ; COMDAT (pick associative to section at FDC)
.text$x:0000107C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000107C
.text$x:0000107C ; =============== S U B R O U T I N E =======================================
.text$x:0000107C
.text$x:0000107C
.text$x:0000107C __unwindfunclet$?AddInReserved@?$CObjectVector@VUString@@@@QAEXABVUString@@@Z$0 proc near
.text$x:0000107C                                         ; DATA XREF: .xdata$x:000010A8o
.text$x:0000107C                 mov     eax, [ebp-18h]
.text$x:0000107F                 push    eax             ; void *
.text$x:00001080                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00001085                 pop     ecx
.text$x:00001086                 retn
.text$x:00001086 __unwindfunclet$?AddInReserved@?$CObjectVector@VUString@@@@QAEXABVUString@@@Z$0 endp
.text$x:00001086
.text$x:00001087
.text$x:00001087 ; =============== S U B R O U T I N E =======================================
.text$x:00001087
.text$x:00001087
.text$x:00001087 __ehhandler$?AddInReserved@?$CObjectVector@VUString@@@@QAEXABVUString@@@Z proc near
.text$x:00001087                                         ; DATA XREF: CObjectVector<UString>::AddInReserved(UString const &)+5o
.text$x:00001087
.text$x:00001087 arg_4           = dword ptr  8
.text$x:00001087
.text$x:00001087                 mov     edx, [esp+arg_4]
.text$x:0000108B                 lea     eax, [edx+0Ch]
.text$x:0000108E                 mov     ecx, [edx-14h]
.text$x:00001091                 xor     ecx, eax
.text$x:00001093                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001098                 mov     eax, offset __ehfuncinfo$?AddInReserved@?$CObjectVector@VUString@@@@QAEXABVUString@@@Z
.text$x:0000109D                 jmp     ___CxxFrameHandler3
.text$x:0000109D __ehhandler$?AddInReserved@?$CObjectVector@VUString@@@@QAEXABVUString@@@Z endp
.text$x:0000109D
.text$x:0000109D ; ---------------------------------------------------------------------------
.text$x:000010A2                 align 4
.text$x:000010A2 _text$x         ends
.text$x:000010A2
.xdata$x:000010A4 ; ===========================================================================
.xdata$x:000010A4
.xdata$x:000010A4 ; Segment type: Pure data
.xdata$x:000010A4 ; Segment permissions: Read
.xdata$x:000010A4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000010A4                 assume cs:_xdata$x
.xdata$x:000010A4                 ;org 10A4h
.xdata$x:000010A4 ; COMDAT (pick associative to section at FDC)
.xdata$x:000010A4 __unwindtable$?AddInReserved@?$CObjectVector@VUString@@@@QAEXABVUString@@@Z db 0FFh
.xdata$x:000010A4                                         ; DATA XREF: .xdata$x:000010B4o
.xdata$x:000010A5                 db 0FFh
.xdata$x:000010A6                 db 0FFh
.xdata$x:000010A7                 db 0FFh
.xdata$x:000010A8                 dd offset __unwindfunclet$?AddInReserved@?$CObjectVector@VUString@@@@QAEXABVUString@@@Z$0
.xdata$x:000010AC __ehfuncinfo$?AddInReserved@?$CObjectVector@VUString@@@@QAEXABVUString@@@Z db  22h ; "
.xdata$x:000010AC                                         ; DATA XREF: __ehhandler$?AddInReserved@?$CObjectVector@VUString@@@@QAEXABVUString@@@Z+11o
.xdata$x:000010AD                 db    5
.xdata$x:000010AE                 db  93h ; ô
.xdata$x:000010AF                 db  19h
.xdata$x:000010B0                 db    1
.xdata$x:000010B1                 db    0
.xdata$x:000010B2                 db    0
.xdata$x:000010B3                 db    0
.xdata$x:000010B4                 dd offset __unwindtable$?AddInReserved@?$CObjectVector@VUString@@@@QAEXABVUString@@@Z
.xdata$x:000010B8                 db    0
.xdata$x:000010B9                 db    0
.xdata$x:000010BA                 db    0
.xdata$x:000010BB                 db    0
.xdata$x:000010BC                 db    0
.xdata$x:000010BD                 db    0
.xdata$x:000010BE                 db    0
.xdata$x:000010BF                 db    0
.xdata$x:000010C0                 db    0
.xdata$x:000010C1                 db    0
.xdata$x:000010C2                 db    0
.xdata$x:000010C3                 db    0
.xdata$x:000010C4                 db    0
.xdata$x:000010C5                 db    0
.xdata$x:000010C6                 db    0
.xdata$x:000010C7                 db    0
.xdata$x:000010C8                 db    0
.xdata$x:000010C9                 db    0
.xdata$x:000010CA                 db    0
.xdata$x:000010CB                 db    0
.xdata$x:000010CC                 db    1
.xdata$x:000010CD                 db    0
.xdata$x:000010CE                 db    0
.xdata$x:000010CF                 db    0
.xdata$x:000010CF _xdata$x        ends
.xdata$x:000010CF
.text:000010D0 ; ===========================================================================
.text:000010D0
.text:000010D0 ; Segment type: Pure code
.text:000010D0 ; Segment permissions: Read/Execute
.text:000010D0 _text           segment para public 'CODE' use32
.text:000010D0                 assume cs:_text
.text:000010D0                 ;org 10D0h
.text:000010D0 ; COMDAT (pick any)
.text:000010D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000010D0
.text:000010D0 ; =============== S U B R O U T I N E =======================================
.text:000010D0
.text:000010D0 ; Attributes: bp-based frame
.text:000010D0
.text:000010D0 ; public: __thiscall CObjectVector<class UString>::~CObjectVector<class UString>(void)
.text:000010D0                 public ??1?$CObjectVector@VUString@@@@QAE@XZ
.text:000010D0 ??1?$CObjectVector@VUString@@@@QAE@XZ proc near
.text:000010D0                                         ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+815p
.text:000010D0                                         ; __unwindfunclet$?GetUpdatePairInfoList@@YGXABVCDirItems@@ABV?$CObjectVector@UCArcItem@@@@W4EEnum@NFileTimeType@@AAV?$CRecordVector@UCUpdatePair@@@@@Z$3+3j
.text:000010D0
.text:000010D0 var_20          = dword ptr -20h
.text:000010D0 var_1C          = dword ptr -1Ch
.text:000010D0 var_18          = dword ptr -18h
.text:000010D0 var_14          = dword ptr -14h
.text:000010D0 var_10          = dword ptr -10h
.text:000010D0 var_C           = dword ptr -0Ch
.text:000010D0 var_4           = dword ptr -4
.text:000010D0
.text:000010D0                 push    ebp
.text:000010D1                 mov     ebp, esp
.text:000010D3                 push    0FFFFFFFFh
.text:000010D5                 push    offset __ehhandler$??1?$CObjectVector@VUString@@@@QAE@XZ
.text:000010DA                 mov     eax, large fs:0
.text:000010E0                 push    eax
.text:000010E1                 sub     esp, 14h
.text:000010E4                 mov     eax, 0CCCCCCCCh
.text:000010E9                 mov     [ebp+var_20], eax
.text:000010EC                 mov     [ebp+var_1C], eax
.text:000010EF                 mov     [ebp+var_18], eax
.text:000010F2                 mov     [ebp+var_14], eax
.text:000010F5                 mov     [ebp+var_10], eax
.text:000010F8                 mov     eax, dword ptr ds:___security_cookie
.text:000010FD                 xor     eax, ebp
.text:000010FF                 push    eax
.text:00001100                 lea     eax, [ebp+var_C]
.text:00001103                 mov     large fs:0, eax
.text:00001109                 mov     [ebp+var_10], ecx
.text:0000110C                 mov     [ebp+var_4], 0
.text:00001113                 mov     ecx, [ebp+var_10]
.text:00001116                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:0000111B                 mov     [ebp+var_14], eax
.text:0000111E
.text:0000111E loc_111E:                               ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void):loc_1160j
.text:0000111E                 cmp     [ebp+var_14], 0
.text:00001122                 jz      short loc_1162
.text:00001124                 mov     eax, [ebp+var_14]
.text:00001127                 sub     eax, 1
.text:0000112A                 mov     [ebp+var_14], eax
.text:0000112D                 mov     ecx, [ebp+var_14]
.text:00001130                 push    ecx
.text:00001131                 mov     ecx, [ebp+var_10]
.text:00001134                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00001139                 mov     edx, [eax]
.text:0000113B                 mov     [ebp+var_1C], edx
.text:0000113E                 mov     eax, [ebp+var_1C]
.text:00001141                 mov     [ebp+var_18], eax
.text:00001144                 cmp     [ebp+var_18], 0
.text:00001148                 jz      short loc_1159
.text:0000114A                 push    1
.text:0000114C                 mov     ecx, [ebp+var_18]
.text:0000114F                 call    ??_GUString@@QAEPAXI@Z ; UString::`scalar deleting destructor'(uint)
.text:00001154                 mov     [ebp+var_20], eax
.text:00001157                 jmp     short loc_1160
.text:00001159 ; ---------------------------------------------------------------------------
.text:00001159
.text:00001159 loc_1159:                               ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+78j
.text:00001159                 mov     [ebp+var_20], 0
.text:00001160
.text:00001160 loc_1160:                               ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+87j
.text:00001160                 jmp     short loc_111E
.text:00001162 ; ---------------------------------------------------------------------------
.text:00001162
.text:00001162 loc_1162:                               ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+52j
.text:00001162                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001169                 mov     ecx, [ebp+var_10]
.text:0000116C                 call    ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text:00001171                 mov     ecx, [ebp+var_C]
.text:00001174                 mov     large fs:0, ecx
.text:0000117B                 pop     ecx
.text:0000117C                 add     esp, 20h
.text:0000117F                 cmp     ebp, esp
.text:00001181                 call    __RTC_CheckEsp
.text:00001186                 mov     esp, ebp
.text:00001188                 pop     ebp
.text:00001189                 retn
.text:00001189 ??1?$CObjectVector@VUString@@@@QAE@XZ endp
.text:00001189
.text:00001189 ; ---------------------------------------------------------------------------
.text:0000118A                 align 4
.text:0000118A _text           ends
.text:0000118A
.text$x:0000118C ; ===========================================================================
.text$x:0000118C
.text$x:0000118C ; Segment type: Pure code
.text$x:0000118C ; Segment permissions: Read/Execute
.text$x:0000118C _text$x         segment para public 'CODE' use32
.text$x:0000118C                 assume cs:_text$x
.text$x:0000118C                 ;org 118Ch
.text$x:0000118C ; COMDAT (pick associative to section at 10D0)
.text$x:0000118C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000118C
.text$x:0000118C ; =============== S U B R O U T I N E =======================================
.text$x:0000118C
.text$x:0000118C
.text$x:0000118C __unwindfunclet$??1?$CObjectVector@VUString@@@@QAE@XZ$0 proc near
.text$x:0000118C                                         ; DATA XREF: .xdata$x:000011B4o
.text$x:0000118C                 mov     ecx, [ebp-10h]
.text$x:0000118F                 jmp     ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text$x:0000118F __unwindfunclet$??1?$CObjectVector@VUString@@@@QAE@XZ$0 endp
.text$x:0000118F
.text$x:00001194
.text$x:00001194 ; =============== S U B R O U T I N E =======================================
.text$x:00001194
.text$x:00001194
.text$x:00001194 __ehhandler$??1?$CObjectVector@VUString@@@@QAE@XZ proc near
.text$x:00001194                                         ; DATA XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+5o
.text$x:00001194
.text$x:00001194 arg_4           = dword ptr  8
.text$x:00001194
.text$x:00001194                 mov     edx, [esp+arg_4]
.text$x:00001198                 lea     eax, [edx+0Ch]
.text$x:0000119B                 mov     ecx, [edx-18h]
.text$x:0000119E                 xor     ecx, eax
.text$x:000011A0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000011A5                 mov     eax, offset __ehfuncinfo$??1?$CObjectVector@VUString@@@@QAE@XZ
.text$x:000011AA                 jmp     ___CxxFrameHandler3
.text$x:000011AA __ehhandler$??1?$CObjectVector@VUString@@@@QAE@XZ endp
.text$x:000011AA
.text$x:000011AA ; ---------------------------------------------------------------------------
.text$x:000011AF                 align 10h
.text$x:000011AF _text$x         ends
.text$x:000011AF
.xdata$x:000011B0 ; ===========================================================================
.xdata$x:000011B0
.xdata$x:000011B0 ; Segment type: Pure data
.xdata$x:000011B0 ; Segment permissions: Read
.xdata$x:000011B0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000011B0                 assume cs:_xdata$x
.xdata$x:000011B0                 ;org 11B0h
.xdata$x:000011B0 ; COMDAT (pick associative to section at 10D0)
.xdata$x:000011B0 __unwindtable$??1?$CObjectVector@VUString@@@@QAE@XZ db 0FFh
.xdata$x:000011B0                                         ; DATA XREF: .xdata$x:000011C0o
.xdata$x:000011B1                 db 0FFh
.xdata$x:000011B2                 db 0FFh
.xdata$x:000011B3                 db 0FFh
.xdata$x:000011B4                 dd offset __unwindfunclet$??1?$CObjectVector@VUString@@@@QAE@XZ$0
.xdata$x:000011B8 __ehfuncinfo$??1?$CObjectVector@VUString@@@@QAE@XZ db  22h ; "
.xdata$x:000011B8                                         ; DATA XREF: __ehhandler$??1?$CObjectVector@VUString@@@@QAE@XZ+11o
.xdata$x:000011B9                 db    5
.xdata$x:000011BA                 db  93h ; ô
.xdata$x:000011BB                 db  19h
.xdata$x:000011BC                 db    1
.xdata$x:000011BD                 db    0
.xdata$x:000011BE                 db    0
.xdata$x:000011BF                 db    0
.xdata$x:000011C0                 dd offset __unwindtable$??1?$CObjectVector@VUString@@@@QAE@XZ
.xdata$x:000011C4                 db    0
.xdata$x:000011C5                 db    0
.xdata$x:000011C6                 db    0
.xdata$x:000011C7                 db    0
.xdata$x:000011C8                 db    0
.xdata$x:000011C9                 db    0
.xdata$x:000011CA                 db    0
.xdata$x:000011CB                 db    0
.xdata$x:000011CC                 db    0
.xdata$x:000011CD                 db    0
.xdata$x:000011CE                 db    0
.xdata$x:000011CF                 db    0
.xdata$x:000011D0                 db    0
.xdata$x:000011D1                 db    0
.xdata$x:000011D2                 db    0
.xdata$x:000011D3                 db    0
.xdata$x:000011D4                 db    0
.xdata$x:000011D5                 db    0
.xdata$x:000011D6                 db    0
.xdata$x:000011D7                 db    0
.xdata$x:000011D8                 db    1
.xdata$x:000011D9                 db    0
.xdata$x:000011DA                 db    0
.xdata$x:000011DB                 db    0
.xdata$x:000011DB _xdata$x        ends
.xdata$x:000011DB
.text:000011DC ; ===========================================================================
.text:000011DC
.text:000011DC ; Segment type: Pure code
.text:000011DC ; Segment permissions: Read/Execute
.text:000011DC _text           segment para public 'CODE' use32
.text:000011DC                 assume cs:_text
.text:000011DC                 ;org 11DCh
.text:000011DC ; COMDAT (pick any)
.text:000011DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000011DC
.text:000011DC ; =============== S U B R O U T I N E =======================================
.text:000011DC
.text:000011DC ; Attributes: bp-based frame
.text:000011DC
.text:000011DC ; public: __thiscall CRecordVector<unsigned int>::CRecordVector<unsigned int>(void)
.text:000011DC                 public ??0?$CRecordVector@I@@QAE@XZ
.text:000011DC ??0?$CRecordVector@I@@QAE@XZ proc near  ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+48p
.text:000011DC                                         ; GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+57p
.text:000011DC
.text:000011DC var_4           = dword ptr -4
.text:000011DC
.text:000011DC                 push    ebp
.text:000011DD                 mov     ebp, esp
.text:000011DF                 push    ecx
.text:000011E0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000011E7                 mov     [ebp+var_4], ecx
.text:000011EA                 mov     eax, [ebp+var_4]
.text:000011ED                 mov     dword ptr [eax], 0
.text:000011F3                 mov     ecx, [ebp+var_4]
.text:000011F6                 mov     dword ptr [ecx+4], 0
.text:000011FD                 mov     edx, [ebp+var_4]
.text:00001200                 mov     dword ptr [edx+8], 0
.text:00001207                 mov     eax, [ebp+var_4]
.text:0000120A                 mov     esp, ebp
.text:0000120C                 pop     ebp
.text:0000120D                 retn
.text:0000120D ??0?$CRecordVector@I@@QAE@XZ endp
.text:0000120D
.text:0000120D ; ---------------------------------------------------------------------------
.text:0000120E                 align 10h
.text:0000120E _text           ends
.text:0000120E
.text:00001210 ; ===========================================================================
.text:00001210
.text:00001210 ; Segment type: Pure code
.text:00001210 ; Segment permissions: Read/Execute
.text:00001210 _text           segment para public 'CODE' use32
.text:00001210                 assume cs:_text
.text:00001210                 ;org 1210h
.text:00001210 ; COMDAT (pick any)
.text:00001210                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001210
.text:00001210 ; =============== S U B R O U T I N E =======================================
.text:00001210
.text:00001210 ; Attributes: bp-based frame
.text:00001210
.text:00001210 ; public: void __thiscall CRecordVector<unsigned int>::ClearAndSetSize(unsigned int)
.text:00001210                 public ?ClearAndSetSize@?$CRecordVector@I@@QAEXI@Z
.text:00001210 ?ClearAndSetSize@?$CRecordVector@I@@QAEXI@Z proc near
.text:00001210                                         ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+C4p
.text:00001210
.text:00001210 var_4           = dword ptr -4
.text:00001210 arg_0           = dword ptr  8
.text:00001210
.text:00001210                 push    ebp
.text:00001211                 mov     ebp, esp
.text:00001213                 push    ecx
.text:00001214                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000121B                 mov     [ebp+var_4], ecx
.text:0000121E                 mov     eax, [ebp+arg_0]
.text:00001221                 push    eax
.text:00001222                 mov     ecx, [ebp+var_4]
.text:00001225                 call    ?ClearAndReserve@?$CRecordVector@I@@QAEXI@Z ; CRecordVector<uint>::ClearAndReserve(uint)
.text:0000122A                 mov     ecx, [ebp+var_4]
.text:0000122D                 mov     edx, [ebp+arg_0]
.text:00001230                 mov     [ecx+4], edx
.text:00001233                 add     esp, 4
.text:00001236                 cmp     ebp, esp
.text:00001238                 call    __RTC_CheckEsp
.text:0000123D                 mov     esp, ebp
.text:0000123F                 pop     ebp
.text:00001240                 retn    4
.text:00001240 ?ClearAndSetSize@?$CRecordVector@I@@QAEXI@Z endp
.text:00001240
.text:00001240 ; ---------------------------------------------------------------------------
.text:00001243                 align 4
.text:00001243 _text           ends
.text:00001243
.text:00001244 ; ===========================================================================
.text:00001244
.text:00001244 ; Segment type: Pure code
.text:00001244 ; Segment permissions: Read/Execute
.text:00001244 _text           segment para public 'CODE' use32
.text:00001244                 assume cs:_text
.text:00001244                 ;org 1244h
.text:00001244 ; COMDAT (pick any)
.text:00001244                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001244
.text:00001244 ; =============== S U B R O U T I N E =======================================
.text:00001244
.text:00001244 ; Attributes: bp-based frame
.text:00001244
.text:00001244 ; public: __thiscall CRecordVector<unsigned int>::~CRecordVector<unsigned int>(void)
.text:00001244                 public ??1?$CRecordVector@I@@QAE@XZ
.text:00001244 ??1?$CRecordVector@I@@QAE@XZ proc near  ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+82Dp
.text:00001244                                         ; GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+83Cp ...
.text:00001244
.text:00001244 var_8           = dword ptr -8
.text:00001244 var_4           = dword ptr -4
.text:00001244
.text:00001244                 push    ebp
.text:00001245                 mov     ebp, esp
.text:00001247                 sub     esp, 8
.text:0000124A                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00001251                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001258                 mov     [ebp+var_4], ecx
.text:0000125B                 mov     eax, [ebp+var_4]
.text:0000125E                 mov     ecx, [eax]
.text:00001260                 mov     [ebp+var_8], ecx
.text:00001263                 mov     edx, [ebp+var_8]
.text:00001266                 push    edx             ; void *
.text:00001267                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:0000126C                 add     esp, 4
.text:0000126F                 add     esp, 8
.text:00001272                 cmp     ebp, esp
.text:00001274                 call    __RTC_CheckEsp
.text:00001279                 mov     esp, ebp
.text:0000127B                 pop     ebp
.text:0000127C                 retn
.text:0000127C ??1?$CRecordVector@I@@QAE@XZ endp
.text:0000127C
.text:0000127C ; ---------------------------------------------------------------------------
.text:0000127D                 align 10h
.text:0000127D _text           ends
.text:0000127D
.text:00001280 ; ===========================================================================
.text:00001280
.text:00001280 ; Segment type: Pure code
.text:00001280 ; Segment permissions: Read/Execute
.text:00001280 _text           segment para public 'CODE' use32
.text:00001280                 assume cs:_text
.text:00001280                 ;org 1280h
.text:00001280 ; COMDAT (pick any)
.text:00001280                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001280
.text:00001280 ; =============== S U B R O U T I N E =======================================
.text:00001280
.text:00001280 ; Attributes: bp-based frame
.text:00001280
.text:00001280 ; public: unsigned int & __thiscall CRecordVector<unsigned int>::operator[](unsigned int)
.text:00001280                 public ??A?$CRecordVector@I@@QAEAAII@Z
.text:00001280 ??A?$CRecordVector@I@@QAEAAII@Z proc near
.text:00001280                                         ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+CEp
.text:00001280                                         ; GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+136p ...
.text:00001280
.text:00001280 var_4           = dword ptr -4
.text:00001280 arg_0           = dword ptr  8
.text:00001280
.text:00001280                 push    ebp
.text:00001281                 mov     ebp, esp
.text:00001283                 push    ecx
.text:00001284                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000128B                 mov     [ebp+var_4], ecx
.text:0000128E                 mov     eax, [ebp+var_4]
.text:00001291                 mov     ecx, [eax]
.text:00001293                 mov     edx, [ebp+arg_0]
.text:00001296                 lea     eax, [ecx+edx*4]
.text:00001299                 mov     esp, ebp
.text:0000129B                 pop     ebp
.text:0000129C                 retn    4
.text:0000129C ??A?$CRecordVector@I@@QAEAAII@Z endp
.text:0000129C
.text:0000129C ; ---------------------------------------------------------------------------
.text:0000129F                 align 10h
.text:0000129F _text           ends
.text:0000129F
.text:000012A0 ; ===========================================================================
.text:000012A0
.text:000012A0 ; Segment type: Pure code
.text:000012A0 ; Segment permissions: Read/Execute
.text:000012A0 _text           segment para public 'CODE' use32
.text:000012A0                 assume cs:_text
.text:000012A0                 ;org 12A0h
.text:000012A0 ; COMDAT (pick any)
.text:000012A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000012A0
.text:000012A0 ; =============== S U B R O U T I N E =======================================
.text:000012A0
.text:000012A0 ; Attributes: bp-based frame
.text:000012A0
.text:000012A0 ; public: void __thiscall CRecordVector<unsigned int>::Sort(int (__stdcall *)(unsigned int const *, unsigned int const *, void *), void *)
.text:000012A0                 public ?Sort@?$CRecordVector@I@@QAEXP6GHPBI0PAX@Z1@Z
.text:000012A0 ?Sort@?$CRecordVector@I@@QAEXP6GHPBI0PAX@Z1@Z proc near
.text:000012A0                                         ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+10Ap
.text:000012A0
.text:000012A0 var_14          = dword ptr -14h
.text:000012A0 var_10          = dword ptr -10h
.text:000012A0 var_C           = dword ptr -0Ch
.text:000012A0 var_8           = dword ptr -8
.text:000012A0 var_4           = dword ptr -4
.text:000012A0 arg_0           = dword ptr  8
.text:000012A0 arg_4           = dword ptr  0Ch
.text:000012A0
.text:000012A0                 push    ebp
.text:000012A1                 mov     ebp, esp
.text:000012A3                 sub     esp, 14h
.text:000012A6                 mov     eax, 0CCCCCCCCh
.text:000012AB                 mov     [ebp+var_14], eax
.text:000012AE                 mov     [ebp+var_10], eax
.text:000012B1                 mov     [ebp+var_C], eax
.text:000012B4                 mov     [ebp+var_8], eax
.text:000012B7                 mov     [ebp+var_4], eax
.text:000012BA                 mov     [ebp+var_4], ecx
.text:000012BD                 mov     eax, [ebp+var_4]
.text:000012C0                 mov     ecx, [eax+4]
.text:000012C3                 mov     [ebp+var_8], ecx
.text:000012C6                 cmp     [ebp+var_8], 1
.text:000012CA                 ja      short loc_12D1
.text:000012CC                 jmp     loc_1355
.text:000012D1 ; ---------------------------------------------------------------------------
.text:000012D1
.text:000012D1 loc_12D1:                               ; CODE XREF: CRecordVector<uint>::Sort(int (*)(uint const *,uint const *,void *),void *)+2Aj
.text:000012D1                 mov     ecx, [ebp+var_4]
.text:000012D4                 call    ?Front@?$CRecordVector@I@@QAEAAIXZ ; CRecordVector<uint>::Front(void)
.text:000012D9                 sub     eax, 4
.text:000012DC                 mov     [ebp+var_C], eax
.text:000012DF                 mov     edx, [ebp+var_8]
.text:000012E2                 shr     edx, 1
.text:000012E4                 mov     [ebp+var_10], edx
.text:000012E7
.text:000012E7 loc_12E7:                               ; CODE XREF: CRecordVector<uint>::Sort(int (*)(uint const *,uint const *,void *),void *)+69j
.text:000012E7                 mov     eax, [ebp+arg_4]
.text:000012EA                 push    eax
.text:000012EB                 mov     ecx, [ebp+arg_0]
.text:000012EE                 push    ecx
.text:000012EF                 mov     edx, [ebp+var_8]
.text:000012F2                 push    edx
.text:000012F3                 mov     eax, [ebp+var_10]
.text:000012F6                 push    eax
.text:000012F7                 mov     ecx, [ebp+var_C]
.text:000012FA                 push    ecx
.text:000012FB                 call    ?SortRefDown@?$CRecordVector@I@@SGXPAIIIP6GHPBI1PAX@Z2@Z ; CRecordVector<uint>::SortRefDown(uint *,uint,uint,int (*)(uint const *,uint const *,void *),void *)
.text:00001300                 mov     edx, [ebp+var_10]
.text:00001303                 sub     edx, 1
.text:00001306                 mov     [ebp+var_10], edx
.text:00001309                 jnz     short loc_12E7
.text:0000130B
.text:0000130B loc_130B:                               ; CODE XREF: CRecordVector<uint>::Sort(int (*)(uint const *,uint const *,void *),void *)+B3j
.text:0000130B                 mov     eax, [ebp+var_8]
.text:0000130E                 mov     ecx, [ebp+var_C]
.text:00001311                 mov     edx, [ecx+eax*4]
.text:00001314                 mov     [ebp+var_14], edx
.text:00001317                 mov     eax, [ebp+var_8]
.text:0000131A                 mov     ecx, [ebp+var_C]
.text:0000131D                 mov     edx, [ebp+var_C]
.text:00001320                 mov     edx, [edx+4]
.text:00001323                 mov     [ecx+eax*4], edx
.text:00001326                 mov     eax, [ebp+var_8]
.text:00001329                 sub     eax, 1
.text:0000132C                 mov     [ebp+var_8], eax
.text:0000132F                 mov     ecx, [ebp+var_C]
.text:00001332                 mov     edx, [ebp+var_14]
.text:00001335                 mov     [ecx+4], edx
.text:00001338                 mov     eax, [ebp+arg_4]
.text:0000133B                 push    eax
.text:0000133C                 mov     ecx, [ebp+arg_0]
.text:0000133F                 push    ecx
.text:00001340                 mov     edx, [ebp+var_8]
.text:00001343                 push    edx
.text:00001344                 push    1
.text:00001346                 mov     eax, [ebp+var_C]
.text:00001349                 push    eax
.text:0000134A                 call    ?SortRefDown@?$CRecordVector@I@@SGXPAIIIP6GHPBI1PAX@Z2@Z ; CRecordVector<uint>::SortRefDown(uint *,uint,uint,int (*)(uint const *,uint const *,void *),void *)
.text:0000134F                 cmp     [ebp+var_8], 1
.text:00001353                 ja      short loc_130B
.text:00001355
.text:00001355 loc_1355:                               ; CODE XREF: CRecordVector<uint>::Sort(int (*)(uint const *,uint const *,void *),void *)+2Cj
.text:00001355                 add     esp, 14h
.text:00001358                 cmp     ebp, esp
.text:0000135A                 call    __RTC_CheckEsp
.text:0000135F                 mov     esp, ebp
.text:00001361                 pop     ebp
.text:00001362                 retn    8
.text:00001362 ?Sort@?$CRecordVector@I@@QAEXP6GHPBI0PAX@Z1@Z endp
.text:00001362
.text:00001362 ; ---------------------------------------------------------------------------
.text:00001365                 align 4
.text:00001365 _text           ends
.text:00001365
.text:00001368 ; ===========================================================================
.text:00001368
.text:00001368 ; Segment type: Pure code
.text:00001368 ; Segment permissions: Read/Execute
.text:00001368 _text           segment para public 'CODE' use32
.text:00001368                 assume cs:_text
.text:00001368                 ;org 1368h
.text:00001368 ; COMDAT (pick any)
.text:00001368                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001368
.text:00001368 ; =============== S U B R O U T I N E =======================================
.text:00001368
.text:00001368 ; Attributes: bp-based frame
.text:00001368
.text:00001368 ; public: unsigned int __thiscall CObjectVector<struct CDirItem>::Size(void)const
.text:00001368                 public ?Size@?$CObjectVector@UCDirItem@@@@QBEIXZ
.text:00001368 ?Size@?$CObjectVector@UCDirItem@@@@QBEIXZ proc near
.text:00001368                                         ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+66p
.text:00001368
.text:00001368 var_4           = dword ptr -4
.text:00001368
.text:00001368                 push    ebp
.text:00001369                 mov     ebp, esp
.text:0000136B                 push    ecx
.text:0000136C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001373                 mov     [ebp+var_4], ecx
.text:00001376                 mov     ecx, [ebp+var_4]
.text:00001379                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:0000137E                 add     esp, 4
.text:00001381                 cmp     ebp, esp
.text:00001383                 call    __RTC_CheckEsp
.text:00001388                 mov     esp, ebp
.text:0000138A                 pop     ebp
.text:0000138B                 retn
.text:0000138B ?Size@?$CObjectVector@UCDirItem@@@@QBEIXZ endp
.text:0000138B
.text:0000138B _text           ends
.text:0000138B
.text:0000138C ; ===========================================================================
.text:0000138C
.text:0000138C ; Segment type: Pure code
.text:0000138C ; Segment permissions: Read/Execute
.text:0000138C _text           segment para public 'CODE' use32
.text:0000138C                 assume cs:_text
.text:0000138C                 ;org 138Ch
.text:0000138C ; COMDAT (pick any)
.text:0000138C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000138C
.text:0000138C ; =============== S U B R O U T I N E =======================================
.text:0000138C
.text:0000138C ; Attributes: bp-based frame
.text:0000138C
.text:0000138C ; public: struct CDirItem const & __thiscall CObjectVector<struct CDirItem>::operator[](unsigned int)const
.text:0000138C                 public ??A?$CObjectVector@UCDirItem@@@@QBEABUCDirItem@@I@Z
.text:0000138C ??A?$CObjectVector@UCDirItem@@@@QBEABUCDirItem@@I@Z proc near
.text:0000138C                                         ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+348p
.text:0000138C
.text:0000138C var_4           = dword ptr -4
.text:0000138C arg_0           = dword ptr  8
.text:0000138C
.text:0000138C                 push    ebp
.text:0000138D                 mov     ebp, esp
.text:0000138F                 push    ecx
.text:00001390                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001397                 mov     [ebp+var_4], ecx
.text:0000139A                 mov     eax, [ebp+arg_0]
.text:0000139D                 push    eax
.text:0000139E                 mov     ecx, [ebp+var_4]
.text:000013A1                 call    ??A?$CRecordVector@PAX@@QBEABQAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:000013A6                 mov     eax, [eax]
.text:000013A8                 add     esp, 4
.text:000013AB                 cmp     ebp, esp
.text:000013AD                 call    __RTC_CheckEsp
.text:000013B2                 mov     esp, ebp
.text:000013B4                 pop     ebp
.text:000013B5                 retn    4
.text:000013B5 ??A?$CObjectVector@UCDirItem@@@@QBEABUCDirItem@@I@Z endp
.text:000013B5
.text:000013B5 _text           ends
.text:000013B5
.text:000013B8 ; ===========================================================================
.text:000013B8
.text:000013B8 ; Segment type: Pure code
.text:000013B8 ; Segment permissions: Read/Execute
.text:000013B8 _text           segment para public 'CODE' use32
.text:000013B8                 assume cs:_text
.text:000013B8                 ;org 13B8h
.text:000013B8 ; COMDAT (pick any)
.text:000013B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000013B8
.text:000013B8 ; =============== S U B R O U T I N E =======================================
.text:000013B8
.text:000013B8 ; Attributes: bp-based frame
.text:000013B8
.text:000013B8 ; public: unsigned int __thiscall CObjectVector<struct CArcItem>::Size(void)const
.text:000013B8                 public ?Size@?$CObjectVector@UCArcItem@@@@QBEIXZ
.text:000013B8 ?Size@?$CObjectVector@UCArcItem@@@@QBEIXZ proc near
.text:000013B8                                         ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+71p
.text:000013B8
.text:000013B8 var_4           = dword ptr -4
.text:000013B8
.text:000013B8                 push    ebp
.text:000013B9                 mov     ebp, esp
.text:000013BB                 push    ecx
.text:000013BC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000013C3                 mov     [ebp+var_4], ecx
.text:000013C6                 mov     ecx, [ebp+var_4]
.text:000013C9                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:000013CE                 add     esp, 4
.text:000013D1                 cmp     ebp, esp
.text:000013D3                 call    __RTC_CheckEsp
.text:000013D8                 mov     esp, ebp
.text:000013DA                 pop     ebp
.text:000013DB                 retn
.text:000013DB ?Size@?$CObjectVector@UCArcItem@@@@QBEIXZ endp
.text:000013DB
.text:000013DB _text           ends
.text:000013DB
.text:000013DC ; ===========================================================================
.text:000013DC
.text:000013DC ; Segment type: Pure code
.text:000013DC ; Segment permissions: Read/Execute
.text:000013DC _text           segment para public 'CODE' use32
.text:000013DC                 assume cs:_text
.text:000013DC                 ;org 13DCh
.text:000013DC ; COMDAT (pick any)
.text:000013DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000013DC
.text:000013DC ; =============== S U B R O U T I N E =======================================
.text:000013DC
.text:000013DC ; Attributes: bp-based frame
.text:000013DC
.text:000013DC ; public: struct CArcItem const & __thiscall CObjectVector<struct CArcItem>::operator[](unsigned int)const
.text:000013DC                 public ??A?$CObjectVector@UCArcItem@@@@QBEABUCArcItem@@I@Z
.text:000013DC ??A?$CObjectVector@UCArcItem@@@@QBEABUCArcItem@@I@Z proc near
.text:000013DC                                         ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+141p
.text:000013DC                                         ; GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+159p ...
.text:000013DC
.text:000013DC var_4           = dword ptr -4
.text:000013DC arg_0           = dword ptr  8
.text:000013DC
.text:000013DC                 push    ebp
.text:000013DD                 mov     ebp, esp
.text:000013DF                 push    ecx
.text:000013E0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000013E7                 mov     [ebp+var_4], ecx
.text:000013EA                 mov     eax, [ebp+arg_0]
.text:000013ED                 push    eax
.text:000013EE                 mov     ecx, [ebp+var_4]
.text:000013F1                 call    ??A?$CRecordVector@PAX@@QBEABQAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:000013F6                 mov     eax, [eax]
.text:000013F8                 add     esp, 4
.text:000013FB                 cmp     ebp, esp
.text:000013FD                 call    __RTC_CheckEsp
.text:00001402                 mov     esp, ebp
.text:00001404                 pop     ebp
.text:00001405                 retn    4
.text:00001405 ??A?$CObjectVector@UCArcItem@@@@QBEABUCArcItem@@I@Z endp
.text:00001405
.text:00001405 _text           ends
.text:00001405
.text:00001408 ; ===========================================================================
.text:00001408
.text:00001408 ; Segment type: Pure code
.text:00001408 ; Segment permissions: Read/Execute
.text:00001408 _text           segment para public 'CODE' use32
.text:00001408                 assume cs:_text
.text:00001408                 ;org 1408h
.text:00001408 ; COMDAT (pick any)
.text:00001408                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001408
.text:00001408 ; =============== S U B R O U T I N E =======================================
.text:00001408
.text:00001408 ; Attributes: bp-based frame
.text:00001408
.text:00001408 ; public: __thiscall CObjArray<int>::CObjArray<int>(unsigned int)
.text:00001408                 public ??0?$CObjArray@H@@QAE@I@Z
.text:00001408 ??0?$CObjArray@H@@QAE@I@Z proc near     ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+80p
.text:00001408
.text:00001408 var_8           = dword ptr -8
.text:00001408 var_4           = dword ptr -4
.text:00001408 arg_0           = dword ptr  8
.text:00001408
.text:00001408                 push    ebp
.text:00001409                 mov     ebp, esp
.text:0000140B                 sub     esp, 8
.text:0000140E                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00001415                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000141C                 mov     [ebp+var_4], ecx
.text:0000141F                 mov     eax, [ebp+var_4]
.text:00001422                 mov     dword ptr [eax], 0
.text:00001428                 cmp     [ebp+arg_0], 0
.text:0000142C                 jz      short loc_1455
.text:0000142E                 xor     ecx, ecx
.text:00001430                 mov     eax, [ebp+arg_0]
.text:00001433                 mov     edx, 4
.text:00001438                 mul     edx
.text:0000143A                 seto    cl
.text:0000143D                 neg     ecx
.text:0000143F                 or      ecx, eax
.text:00001441                 push    ecx             ; unsigned int
.text:00001442                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00001447                 add     esp, 4
.text:0000144A                 mov     [ebp+var_8], eax
.text:0000144D                 mov     eax, [ebp+var_4]
.text:00001450                 mov     ecx, [ebp+var_8]
.text:00001453                 mov     [eax], ecx
.text:00001455
.text:00001455 loc_1455:                               ; CODE XREF: CObjArray<int>::CObjArray<int>(uint)+24j
.text:00001455                 mov     eax, [ebp+var_4]
.text:00001458                 add     esp, 8
.text:0000145B                 cmp     ebp, esp
.text:0000145D                 call    __RTC_CheckEsp
.text:00001462                 mov     esp, ebp
.text:00001464                 pop     ebp
.text:00001465                 retn    4
.text:00001465 ??0?$CObjArray@H@@QAE@I@Z endp
.text:00001465
.text:00001465 _text           ends
.text:00001465
.text:00001468 ; ===========================================================================
.text:00001468
.text:00001468 ; Segment type: Pure code
.text:00001468 ; Segment permissions: Read/Execute
.text:00001468 _text           segment para public 'CODE' use32
.text:00001468                 assume cs:_text
.text:00001468                 ;org 1468h
.text:00001468 ; COMDAT (pick any)
.text:00001468                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001468
.text:00001468 ; =============== S U B R O U T I N E =======================================
.text:00001468
.text:00001468 ; Attributes: bp-based frame
.text:00001468
.text:00001468 ; public: __thiscall CObjArray<int>::~CObjArray<int>(void)
.text:00001468                 public ??1?$CObjArray@H@@QAE@XZ
.text:00001468 ??1?$CObjArray@H@@QAE@XZ proc near      ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+821p
.text:00001468                                         ; __unwindfunclet$?GetUpdatePairInfoList@@YGXABVCDirItems@@ABV?$CObjectVector@UCArcItem@@@@W4EEnum@NFileTimeType@@AAV?$CRecordVector@UCUpdatePair@@@@@Z$2+3j
.text:00001468
.text:00001468 var_8           = dword ptr -8
.text:00001468 var_4           = dword ptr -4
.text:00001468
.text:00001468                 push    ebp
.text:00001469                 mov     ebp, esp
.text:0000146B                 sub     esp, 8
.text:0000146E                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00001475                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000147C                 mov     [ebp+var_4], ecx
.text:0000147F                 mov     eax, [ebp+var_4]
.text:00001482                 mov     ecx, [eax]
.text:00001484                 mov     [ebp+var_8], ecx
.text:00001487                 mov     edx, [ebp+var_8]
.text:0000148A                 push    edx             ; void *
.text:0000148B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00001490                 add     esp, 4
.text:00001493                 add     esp, 8
.text:00001496                 cmp     ebp, esp
.text:00001498                 call    __RTC_CheckEsp
.text:0000149D                 mov     esp, ebp
.text:0000149F                 pop     ebp
.text:000014A0                 retn
.text:000014A0 ??1?$CObjArray@H@@QAE@XZ endp
.text:000014A0
.text:000014A0 ; ---------------------------------------------------------------------------
.text:000014A1                 align 4
.text:000014A1 _text           ends
.text:000014A1
.text:000014A4 ; ===========================================================================
.text:000014A4
.text:000014A4 ; Segment type: Pure code
.text:000014A4 ; Segment permissions: Read/Execute
.text:000014A4 _text           segment para public 'CODE' use32
.text:000014A4                 assume cs:_text
.text:000014A4                 ;org 14A4h
.text:000014A4 ; COMDAT (pick any)
.text:000014A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000014A4
.text:000014A4 ; =============== S U B R O U T I N E =======================================
.text:000014A4
.text:000014A4 ; Attributes: bp-based frame
.text:000014A4
.text:000014A4 ; public: __thiscall CObjArray<int>::operator int *(void)
.text:000014A4                 public ??B?$CObjArray@H@@QAEPAHXZ
.text:000014A4 ??B?$CObjArray@H@@QAEPAHXZ proc near    ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+8Cp
.text:000014A4                                         ; GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+16Bp ...
.text:000014A4
.text:000014A4 var_4           = dword ptr -4
.text:000014A4
.text:000014A4                 push    ebp
.text:000014A5                 mov     ebp, esp
.text:000014A7                 push    ecx
.text:000014A8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000014AF                 mov     [ebp+var_4], ecx
.text:000014B2                 mov     eax, [ebp+var_4]
.text:000014B5                 mov     eax, [eax]
.text:000014B7                 mov     esp, ebp
.text:000014B9                 pop     ebp
.text:000014BA                 retn
.text:000014BA ??B?$CObjArray@H@@QAEPAHXZ endp
.text:000014BA
.text:000014BA ; ---------------------------------------------------------------------------
.text:000014BB                 align 4
.text:000014BB _text           ends
.text:000014BB
.text:000014BC ; ===========================================================================
.text:000014BC
.text:000014BC ; Segment type: Pure code
.text:000014BC ; Segment permissions: Read/Execute
.text:000014BC _text           segment para public 'CODE' use32
.text:000014BC                 assume cs:_text
.text:000014BC                 ;org 14BCh
.text:000014BC ; COMDAT (pick any)
.text:000014BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000014BC
.text:000014BC ; =============== S U B R O U T I N E =======================================
.text:000014BC
.text:000014BC ; Attributes: bp-based frame
.text:000014BC
.text:000014BC ; public: unsigned int __thiscall CRecordVector<struct CUpdatePair>::Size(void)const
.text:000014BC                 public ?Size@?$CRecordVector@UCUpdatePair@@@@QBEIXZ
.text:000014BC ?Size@?$CRecordVector@UCUpdatePair@@@@QBEIXZ proc near
.text:000014BC                                         ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+7BAp
.text:000014BC
.text:000014BC var_4           = dword ptr -4
.text:000014BC
.text:000014BC                 push    ebp
.text:000014BD                 mov     ebp, esp
.text:000014BF                 push    ecx
.text:000014C0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000014C7                 mov     [ebp+var_4], ecx
.text:000014CA                 mov     eax, [ebp+var_4]
.text:000014CD                 mov     eax, [eax+4]
.text:000014D0                 mov     esp, ebp
.text:000014D2                 pop     ebp
.text:000014D3                 retn
.text:000014D3 ?Size@?$CRecordVector@UCUpdatePair@@@@QBEIXZ endp
.text:000014D3
.text:000014D3 _text           ends
.text:000014D3
.text:000014D4 ; ===========================================================================
.text:000014D4
.text:000014D4 ; Segment type: Pure code
.text:000014D4 ; Segment permissions: Read/Execute
.text:000014D4 _text           segment para public 'CODE' use32
.text:000014D4                 assume cs:_text
.text:000014D4                 ;org 14D4h
.text:000014D4 ; COMDAT (pick any)
.text:000014D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000014D4
.text:000014D4 ; =============== S U B R O U T I N E =======================================
.text:000014D4
.text:000014D4 ; Attributes: bp-based frame
.text:000014D4
.text:000014D4 ; public: void __thiscall CRecordVector<struct CUpdatePair>::ReserveDown(void)
.text:000014D4                 public ?ReserveDown@?$CRecordVector@UCUpdatePair@@@@QAEXXZ
.text:000014D4 ?ReserveDown@?$CRecordVector@UCUpdatePair@@@@QAEXXZ proc near
.text:000014D4                                         ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+809p
.text:000014D4
.text:000014D4 var_28          = dword ptr -28h
.text:000014D4 var_24          = dword ptr -24h
.text:000014D4 var_20          = dword ptr -20h
.text:000014D4 var_1C          = dword ptr -1Ch
.text:000014D4 var_18          = dword ptr -18h
.text:000014D4 Dst             = dword ptr -14h
.text:000014D4 var_10          = dword ptr -10h
.text:000014D4 var_C           = dword ptr -0Ch
.text:000014D4 var_4           = dword ptr -4
.text:000014D4
.text:000014D4                 push    ebp
.text:000014D5                 mov     ebp, esp
.text:000014D7                 push    0FFFFFFFFh
.text:000014D9                 push    offset __ehhandler$?ReserveDown@?$CRecordVector@UCUpdatePair@@@@QAEXXZ
.text:000014DE                 mov     eax, large fs:0
.text:000014E4                 push    eax
.text:000014E5                 sub     esp, 1Ch
.text:000014E8                 mov     eax, 0CCCCCCCCh
.text:000014ED                 mov     [ebp+var_28], eax
.text:000014F0                 mov     [ebp+var_24], eax
.text:000014F3                 mov     [ebp+var_20], eax
.text:000014F6                 mov     [ebp+var_1C], eax
.text:000014F9                 mov     [ebp+var_18], eax
.text:000014FC                 mov     [ebp+Dst], eax
.text:000014FF                 mov     [ebp+var_10], eax
.text:00001502                 mov     eax, dword ptr ds:___security_cookie
.text:00001507                 xor     eax, ebp
.text:00001509                 push    eax
.text:0000150A                 lea     eax, [ebp+var_C]
.text:0000150D                 mov     large fs:0, eax
.text:00001513                 mov     [ebp+var_10], ecx
.text:00001516                 mov     eax, [ebp+var_10]
.text:00001519                 mov     ecx, [ebp+var_10]
.text:0000151C                 mov     edx, [eax+4]
.text:0000151F                 cmp     edx, [ecx+8]
.text:00001522                 jnz     short loc_1529
.text:00001524                 jmp     loc_15EC
.text:00001529 ; ---------------------------------------------------------------------------
.text:00001529
.text:00001529 loc_1529:                               ; CODE XREF: CRecordVector<CUpdatePair>::ReserveDown(void)+4Ej
.text:00001529                 mov     [ebp+Dst], 0
.text:00001530                 mov     eax, [ebp+var_10]
.text:00001533                 cmp     dword ptr [eax+4], 0
.text:00001537                 jz      loc_15C4
.text:0000153D                 mov     ecx, [ebp+var_10]
.text:00001540                 mov     edx, [ecx+4]
.text:00001543                 mov     [ebp+var_18], edx
.text:00001546                 xor     ecx, ecx
.text:00001548                 mov     eax, [ebp+var_18]
.text:0000154B                 mov     edx, 10h
.text:00001550                 mul     edx
.text:00001552                 seto    cl
.text:00001555                 neg     ecx
.text:00001557                 or      ecx, eax
.text:00001559                 push    ecx             ; unsigned int
.text:0000155A                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0000155F                 add     esp, 4
.text:00001562                 mov     [ebp+var_20], eax
.text:00001565                 mov     [ebp+var_4], 0
.text:0000156C                 cmp     [ebp+var_20], 0
.text:00001570                 jz      short loc_158E
.text:00001572                 push    offset ??0CUpdatePair@@QAE@XZ ; CUpdatePair::CUpdatePair(void)
.text:00001577                 mov     eax, [ebp+var_18]
.text:0000157A                 push    eax
.text:0000157B                 push    10h
.text:0000157D                 mov     ecx, [ebp+var_20]
.text:00001580                 push    ecx
.text:00001581                 call    ??_H@YGXPAXIHP6EPAX0@Z@Z ; `vector constructor iterator'(void *,uint,int,void * (*)(void *))
.text:00001586                 mov     edx, [ebp+var_20]
.text:00001589                 mov     [ebp+var_28], edx
.text:0000158C                 jmp     short loc_1595
.text:0000158E ; ---------------------------------------------------------------------------
.text:0000158E
.text:0000158E loc_158E:                               ; CODE XREF: CRecordVector<CUpdatePair>::ReserveDown(void)+9Cj
.text:0000158E                 mov     [ebp+var_28], 0
.text:00001595
.text:00001595 loc_1595:                               ; CODE XREF: CRecordVector<CUpdatePair>::ReserveDown(void)+B8j
.text:00001595                 mov     eax, [ebp+var_28]
.text:00001598                 mov     [ebp+var_1C], eax
.text:0000159B                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000015A2                 mov     ecx, [ebp+var_1C]
.text:000015A5                 mov     [ebp+Dst], ecx
.text:000015A8                 mov     edx, [ebp+var_10]
.text:000015AB                 mov     eax, [edx+4]
.text:000015AE                 shl     eax, 4
.text:000015B1                 push    eax             ; Size
.text:000015B2                 mov     ecx, [ebp+var_10]
.text:000015B5                 mov     edx, [ecx]
.text:000015B7                 push    edx             ; Src
.text:000015B8                 mov     eax, [ebp+Dst]
.text:000015BB                 push    eax             ; Dst
.text:000015BC                 call    _memcpy
.text:000015C1                 add     esp, 0Ch
.text:000015C4
.text:000015C4 loc_15C4:                               ; CODE XREF: CRecordVector<CUpdatePair>::ReserveDown(void)+63j
.text:000015C4                 mov     ecx, [ebp+var_10]
.text:000015C7                 mov     edx, [ecx]
.text:000015C9                 mov     [ebp+var_24], edx
.text:000015CC                 mov     eax, [ebp+var_24]
.text:000015CF                 push    eax             ; void *
.text:000015D0                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:000015D5                 add     esp, 4
.text:000015D8                 mov     ecx, [ebp+var_10]
.text:000015DB                 mov     edx, [ebp+Dst]
.text:000015DE                 mov     [ecx], edx
.text:000015E0                 mov     eax, [ebp+var_10]
.text:000015E3                 mov     ecx, [ebp+var_10]
.text:000015E6                 mov     edx, [ecx+4]
.text:000015E9                 mov     [eax+8], edx
.text:000015EC
.text:000015EC loc_15EC:                               ; CODE XREF: CRecordVector<CUpdatePair>::ReserveDown(void)+50j
.text:000015EC                 mov     ecx, [ebp+var_C]
.text:000015EF                 mov     large fs:0, ecx
.text:000015F6                 pop     ecx
.text:000015F7                 add     esp, 28h
.text:000015FA                 cmp     ebp, esp
.text:000015FC                 call    __RTC_CheckEsp
.text:00001601                 mov     esp, ebp
.text:00001603                 pop     ebp
.text:00001604                 retn
.text:00001604 ?ReserveDown@?$CRecordVector@UCUpdatePair@@@@QAEXXZ endp
.text:00001604
.text:00001604 ; ---------------------------------------------------------------------------
.text:00001605                 align 4
.text:00001605 _text           ends
.text:00001605
.text$x:00001608 ; ===========================================================================
.text$x:00001608
.text$x:00001608 ; Segment type: Pure code
.text$x:00001608 ; Segment permissions: Read/Execute
.text$x:00001608 _text$x         segment para public 'CODE' use32
.text$x:00001608                 assume cs:_text$x
.text$x:00001608                 ;org 1608h
.text$x:00001608 ; COMDAT (pick associative to section at 14D4)
.text$x:00001608                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001608
.text$x:00001608 ; =============== S U B R O U T I N E =======================================
.text$x:00001608
.text$x:00001608
.text$x:00001608 __unwindfunclet$?ReserveDown@?$CRecordVector@UCUpdatePair@@@@QAEXXZ$0 proc near
.text$x:00001608                                         ; DATA XREF: .xdata$x:00001634o
.text$x:00001608                 mov     eax, [ebp-20h]
.text$x:0000160B                 push    eax             ; void *
.text$x:0000160C                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00001611                 pop     ecx
.text$x:00001612                 retn
.text$x:00001612 __unwindfunclet$?ReserveDown@?$CRecordVector@UCUpdatePair@@@@QAEXXZ$0 endp
.text$x:00001612
.text$x:00001613
.text$x:00001613 ; =============== S U B R O U T I N E =======================================
.text$x:00001613
.text$x:00001613
.text$x:00001613 __ehhandler$?ReserveDown@?$CRecordVector@UCUpdatePair@@@@QAEXXZ proc near
.text$x:00001613                                         ; DATA XREF: CRecordVector<CUpdatePair>::ReserveDown(void)+5o
.text$x:00001613
.text$x:00001613 arg_4           = dword ptr  8
.text$x:00001613
.text$x:00001613                 mov     edx, [esp+arg_4]
.text$x:00001617                 lea     eax, [edx+0Ch]
.text$x:0000161A                 mov     ecx, [edx-20h]
.text$x:0000161D                 xor     ecx, eax
.text$x:0000161F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001624                 mov     eax, offset __ehfuncinfo$?ReserveDown@?$CRecordVector@UCUpdatePair@@@@QAEXXZ
.text$x:00001629                 jmp     ___CxxFrameHandler3
.text$x:00001629 __ehhandler$?ReserveDown@?$CRecordVector@UCUpdatePair@@@@QAEXXZ endp
.text$x:00001629
.text$x:00001629 ; ---------------------------------------------------------------------------
.text$x:0000162E                 align 10h
.text$x:0000162E _text$x         ends
.text$x:0000162E
.xdata$x:00001630 ; ===========================================================================
.xdata$x:00001630
.xdata$x:00001630 ; Segment type: Pure data
.xdata$x:00001630 ; Segment permissions: Read
.xdata$x:00001630 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001630                 assume cs:_xdata$x
.xdata$x:00001630                 ;org 1630h
.xdata$x:00001630 ; COMDAT (pick associative to section at 14D4)
.xdata$x:00001630 __unwindtable$?ReserveDown@?$CRecordVector@UCUpdatePair@@@@QAEXXZ db 0FFh
.xdata$x:00001630                                         ; DATA XREF: .xdata$x:00001640o
.xdata$x:00001631                 db 0FFh
.xdata$x:00001632                 db 0FFh
.xdata$x:00001633                 db 0FFh
.xdata$x:00001634                 dd offset __unwindfunclet$?ReserveDown@?$CRecordVector@UCUpdatePair@@@@QAEXXZ$0
.xdata$x:00001638 __ehfuncinfo$?ReserveDown@?$CRecordVector@UCUpdatePair@@@@QAEXXZ db  22h ; "
.xdata$x:00001638                                         ; DATA XREF: __ehhandler$?ReserveDown@?$CRecordVector@UCUpdatePair@@@@QAEXXZ+11o
.xdata$x:00001639                 db    5
.xdata$x:0000163A                 db  93h ; ô
.xdata$x:0000163B                 db  19h
.xdata$x:0000163C                 db    1
.xdata$x:0000163D                 db    0
.xdata$x:0000163E                 db    0
.xdata$x:0000163F                 db    0
.xdata$x:00001640                 dd offset __unwindtable$?ReserveDown@?$CRecordVector@UCUpdatePair@@@@QAEXXZ
.xdata$x:00001644                 db    0
.xdata$x:00001645                 db    0
.xdata$x:00001646                 db    0
.xdata$x:00001647                 db    0
.xdata$x:00001648                 db    0
.xdata$x:00001649                 db    0
.xdata$x:0000164A                 db    0
.xdata$x:0000164B                 db    0
.xdata$x:0000164C                 db    0
.xdata$x:0000164D                 db    0
.xdata$x:0000164E                 db    0
.xdata$x:0000164F                 db    0
.xdata$x:00001650                 db    0
.xdata$x:00001651                 db    0
.xdata$x:00001652                 db    0
.xdata$x:00001653                 db    0
.xdata$x:00001654                 db    0
.xdata$x:00001655                 db    0
.xdata$x:00001656                 db    0
.xdata$x:00001657                 db    0
.xdata$x:00001658                 db    1
.xdata$x:00001659                 db    0
.xdata$x:0000165A                 db    0
.xdata$x:0000165B                 db    0
.xdata$x:0000165B _xdata$x        ends
.xdata$x:0000165B
.text:0000165C ; ===========================================================================
.text:0000165C
.text:0000165C ; Segment type: Pure code
.text:0000165C ; Segment permissions: Read/Execute
.text:0000165C _text           segment para public 'CODE' use32
.text:0000165C                 assume cs:_text
.text:0000165C                 ;org 165Ch
.text:0000165C ; COMDAT (pick any)
.text:0000165C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000165C
.text:0000165C ; =============== S U B R O U T I N E =======================================
.text:0000165C
.text:0000165C ; Attributes: bp-based frame
.text:0000165C
.text:0000165C ; public: unsigned int __thiscall CRecordVector<struct CUpdatePair>::Add(struct CUpdatePair)
.text:0000165C                 public ?Add@?$CRecordVector@UCUpdatePair@@@@QAEIUCUpdatePair@@@Z
.text:0000165C ?Add@?$CRecordVector@UCUpdatePair@@@@QAEIUCUpdatePair@@@Z proc near
.text:0000165C                                         ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+7FCp
.text:0000165C
.text:0000165C var_8           = dword ptr -8
.text:0000165C var_4           = dword ptr -4
.text:0000165C arg_0           = dword ptr  8
.text:0000165C arg_4           = dword ptr  0Ch
.text:0000165C arg_8           = dword ptr  10h
.text:0000165C arg_C           = dword ptr  14h
.text:0000165C
.text:0000165C                 push    ebp
.text:0000165D                 mov     ebp, esp
.text:0000165F                 sub     esp, 8
.text:00001662                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00001669                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001670                 mov     [ebp+var_4], ecx
.text:00001673                 mov     ecx, [ebp+var_4]
.text:00001676                 call    ?ReserveOnePosition@?$CRecordVector@UCUpdatePair@@@@AAEXXZ ; CRecordVector<CUpdatePair>::ReserveOnePosition(void)
.text:0000167B                 mov     eax, [ebp+var_4]
.text:0000167E                 mov     ecx, [eax+4]
.text:00001681                 shl     ecx, 4
.text:00001684                 mov     edx, [ebp+var_4]
.text:00001687                 mov     eax, [edx]
.text:00001689                 add     eax, ecx
.text:0000168B                 mov     ecx, [ebp+arg_0]
.text:0000168E                 mov     [eax], ecx
.text:00001690                 mov     edx, [ebp+arg_4]
.text:00001693                 mov     [eax+4], edx
.text:00001696                 mov     ecx, [ebp+arg_8]
.text:00001699                 mov     [eax+8], ecx
.text:0000169C                 mov     edx, [ebp+arg_C]
.text:0000169F                 mov     [eax+0Ch], edx
.text:000016A2                 mov     eax, [ebp+var_4]
.text:000016A5                 mov     ecx, [eax+4]
.text:000016A8                 mov     [ebp+var_8], ecx
.text:000016AB                 mov     edx, [ebp+var_4]
.text:000016AE                 mov     eax, [edx+4]
.text:000016B1                 add     eax, 1
.text:000016B4                 mov     ecx, [ebp+var_4]
.text:000016B7                 mov     [ecx+4], eax
.text:000016BA                 mov     eax, [ebp+var_8]
.text:000016BD                 add     esp, 8
.text:000016C0                 cmp     ebp, esp
.text:000016C2                 call    __RTC_CheckEsp
.text:000016C7                 mov     esp, ebp
.text:000016C9                 pop     ebp
.text:000016CA                 retn    10h
.text:000016CA ?Add@?$CRecordVector@UCUpdatePair@@@@QAEIUCUpdatePair@@@Z endp
.text:000016CA
.text:000016CA ; ---------------------------------------------------------------------------
.text:000016CD                 align 10h
.text:000016CD _text           ends
.text:000016CD
.text:000016D0 ; ===========================================================================
.text:000016D0
.text:000016D0 ; Segment type: Pure code
.text:000016D0 ; Segment permissions: Read/Execute
.text:000016D0 _text           segment para public 'CODE' use32
.text:000016D0                 assume cs:_text
.text:000016D0                 ;org 16D0h
.text:000016D0 ; COMDAT (pick any)
.text:000016D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000016D0
.text:000016D0 ; =============== S U B R O U T I N E =======================================
.text:000016D0
.text:000016D0 ; Attributes: bp-based frame
.text:000016D0
.text:000016D0 ; public: void * __thiscall UString::`scalar deleting destructor'(unsigned int)
.text:000016D0                 public ??_GUString@@QAEPAXI@Z
.text:000016D0 ??_GUString@@QAEPAXI@Z proc near        ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+7Fp
.text:000016D0                                         ; CObjectVector<UString>::Clear(void)+59p
.text:000016D0
.text:000016D0 var_4           = dword ptr -4
.text:000016D0 arg_0           = dword ptr  8
.text:000016D0
.text:000016D0                 push    ebp
.text:000016D1                 mov     ebp, esp
.text:000016D3                 push    ecx
.text:000016D4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000016DB                 mov     [ebp+var_4], ecx
.text:000016DE                 mov     ecx, [ebp+var_4] ; this
.text:000016E1                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000016E6                 mov     eax, [ebp+arg_0]
.text:000016E9                 and     eax, 1
.text:000016EC                 jz      short loc_16FA
.text:000016EE                 mov     ecx, [ebp+var_4]
.text:000016F1                 push    ecx             ; void *
.text:000016F2                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:000016F7                 add     esp, 4
.text:000016FA
.text:000016FA loc_16FA:                               ; CODE XREF: UString::`scalar deleting destructor'(uint)+1Cj
.text:000016FA                 mov     eax, [ebp+var_4]
.text:000016FD                 add     esp, 4
.text:00001700                 cmp     ebp, esp
.text:00001702                 call    __RTC_CheckEsp
.text:00001707                 mov     esp, ebp
.text:00001709                 pop     ebp
.text:0000170A                 retn    4
.text:0000170A ??_GUString@@QAEPAXI@Z endp
.text:0000170A
.text:0000170A ; ---------------------------------------------------------------------------
.text:0000170D                 align 10h
.text:0000170D _text           ends
.text:0000170D
.text:00001710 ; ===========================================================================
.text:00001710
.text:00001710 ; Segment type: Pure code
.text:00001710 ; Segment permissions: Read/Execute
.text:00001710 _text           segment para public 'CODE' use32
.text:00001710                 assume cs:_text
.text:00001710                 ;org 1710h
.text:00001710 ; COMDAT (pick any)
.text:00001710                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001710
.text:00001710 ; =============== S U B R O U T I N E =======================================
.text:00001710
.text:00001710 ; Attributes: bp-based frame
.text:00001710
.text:00001710 ; void __stdcall `vector constructor iterator'(void *, unsigned int, int, void * (__thiscall *)(void *))
.text:00001710                 public ??_H@YGXPAXIHP6EPAX0@Z@Z
.text:00001710 ??_H@YGXPAXIHP6EPAX0@Z@Z proc near      ; CODE XREF: CRecordVector<CUpdatePair>::ReserveDown(void)+ADp
.text:00001710                                         ; CRecordVector<CUpdatePair>::ReserveOnePosition(void)+AEp
.text:00001710
.text:00001710 arg_0           = dword ptr  8
.text:00001710 arg_4           = dword ptr  0Ch
.text:00001710 arg_8           = dword ptr  10h
.text:00001710 arg_C           = dword ptr  14h
.text:00001710
.text:00001710                 push    ebp
.text:00001711                 mov     ebp, esp
.text:00001713                 push    esi
.text:00001714
.text:00001714 loc_1714:                               ; CODE XREF: `vector constructor iterator'(void *,uint,int,void * (*)(void *))+27j
.text:00001714                 mov     eax, [ebp+arg_8]
.text:00001717                 sub     eax, 1
.text:0000171A                 mov     [ebp+arg_8], eax
.text:0000171D                 js      short loc_1739
.text:0000171F                 mov     esi, esp
.text:00001721                 mov     ecx, [ebp+arg_0]
.text:00001724                 call    [ebp+arg_C]
.text:00001727                 cmp     esi, esp
.text:00001729                 call    __RTC_CheckEsp
.text:0000172E                 mov     ecx, [ebp+arg_0]
.text:00001731                 add     ecx, [ebp+arg_4]
.text:00001734                 mov     [ebp+arg_0], ecx
.text:00001737                 jmp     short loc_1714
.text:00001739 ; ---------------------------------------------------------------------------
.text:00001739
.text:00001739 loc_1739:                               ; CODE XREF: `vector constructor iterator'(void *,uint,int,void * (*)(void *))+Dj
.text:00001739                 pop     esi
.text:0000173A                 cmp     ebp, esp
.text:0000173C                 call    __RTC_CheckEsp
.text:00001741                 pop     ebp
.text:00001742                 retn    10h
.text:00001742 ??_H@YGXPAXIHP6EPAX0@Z@Z endp
.text:00001742
.text:00001742 ; ---------------------------------------------------------------------------
.text:00001745                 align 4
.text:00001745 _text           ends
.text:00001745
.text:00001748 ; ===========================================================================
.text:00001748
.text:00001748 ; Segment type: Pure code
.text:00001748 ; Segment permissions: Read/Execute
.text:00001748 _text           segment para public 'CODE' use32
.text:00001748                 assume cs:_text
.text:00001748                 ;org 1748h
.text:00001748 ; COMDAT (pick any)
.text:00001748                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001748
.text:00001748 ; =============== S U B R O U T I N E =======================================
.text:00001748
.text:00001748 ; Attributes: bp-based frame
.text:00001748
.text:00001748 ; public: __thiscall CRecordVector<void *>::CRecordVector<void *>(void)
.text:00001748                 public ??0?$CRecordVector@PAX@@QAE@XZ
.text:00001748 ??0?$CRecordVector@PAX@@QAE@XZ proc near
.text:00001748                                         ; CODE XREF: CObjectVector<UString>::CObjectVector<UString>(void)+11p
.text:00001748
.text:00001748 var_4           = dword ptr -4
.text:00001748
.text:00001748                 push    ebp
.text:00001749                 mov     ebp, esp
.text:0000174B                 push    ecx
.text:0000174C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001753                 mov     [ebp+var_4], ecx
.text:00001756                 mov     eax, [ebp+var_4]
.text:00001759                 mov     dword ptr [eax], 0
.text:0000175F                 mov     ecx, [ebp+var_4]
.text:00001762                 mov     dword ptr [ecx+4], 0
.text:00001769                 mov     edx, [ebp+var_4]
.text:0000176C                 mov     dword ptr [edx+8], 0
.text:00001773                 mov     eax, [ebp+var_4]
.text:00001776                 mov     esp, ebp
.text:00001778                 pop     ebp
.text:00001779                 retn
.text:00001779 ??0?$CRecordVector@PAX@@QAE@XZ endp
.text:00001779
.text:00001779 ; ---------------------------------------------------------------------------
.text:0000177A                 align 4
.text:0000177A _text           ends
.text:0000177A
.text:0000177C ; ===========================================================================
.text:0000177C
.text:0000177C ; Segment type: Pure code
.text:0000177C ; Segment permissions: Read/Execute
.text:0000177C _text           segment para public 'CODE' use32
.text:0000177C                 assume cs:_text
.text:0000177C                 ;org 177Ch
.text:0000177C ; COMDAT (pick any)
.text:0000177C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000177C
.text:0000177C ; =============== S U B R O U T I N E =======================================
.text:0000177C
.text:0000177C ; Attributes: bp-based frame
.text:0000177C
.text:0000177C ; public: unsigned int __thiscall CRecordVector<void *>::Size(void)const
.text:0000177C                 public ?Size@?$CRecordVector@PAX@@QBEIXZ
.text:0000177C ?Size@?$CRecordVector@PAX@@QBEIXZ proc near
.text:0000177C                                         ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+46p
.text:0000177C                                         ; CObjectVector<CDirItem>::Size(void)+11p ...
.text:0000177C
.text:0000177C var_4           = dword ptr -4
.text:0000177C
.text:0000177C                 push    ebp
.text:0000177D                 mov     ebp, esp
.text:0000177F                 push    ecx
.text:00001780                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001787                 mov     [ebp+var_4], ecx
.text:0000178A                 mov     eax, [ebp+var_4]
.text:0000178D                 mov     eax, [eax+4]
.text:00001790                 mov     esp, ebp
.text:00001792                 pop     ebp
.text:00001793                 retn
.text:00001793 ?Size@?$CRecordVector@PAX@@QBEIXZ endp
.text:00001793
.text:00001793 _text           ends
.text:00001793
.text:00001794 ; ===========================================================================
.text:00001794
.text:00001794 ; Segment type: Pure code
.text:00001794 ; Segment permissions: Read/Execute
.text:00001794 _text           segment para public 'CODE' use32
.text:00001794                 assume cs:_text
.text:00001794                 ;org 1794h
.text:00001794 ; COMDAT (pick any)
.text:00001794                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001794
.text:00001794 ; =============== S U B R O U T I N E =======================================
.text:00001794
.text:00001794 ; Attributes: bp-based frame
.text:00001794
.text:00001794 ; public: void __thiscall CRecordVector<void *>::ClearAndReserve(unsigned int)
.text:00001794                 public ?ClearAndReserve@?$CRecordVector@PAX@@QAEXI@Z
.text:00001794 ?ClearAndReserve@?$CRecordVector@PAX@@QAEXI@Z proc near
.text:00001794                                         ; CODE XREF: CObjectVector<UString>::ClearAndReserve(uint)+1Dp
.text:00001794
.text:00001794 var_C           = dword ptr -0Ch
.text:00001794 var_8           = dword ptr -8
.text:00001794 var_4           = dword ptr -4
.text:00001794 arg_0           = dword ptr  8
.text:00001794
.text:00001794                 push    ebp
.text:00001795                 mov     ebp, esp
.text:00001797                 sub     esp, 0Ch
.text:0000179A                 mov     [ebp+var_C], 0CCCCCCCCh
.text:000017A1                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000017A8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000017AF                 mov     [ebp+var_4], ecx
.text:000017B2                 mov     ecx, [ebp+var_4]
.text:000017B5                 call    ?Clear@?$CRecordVector@PAX@@QAEXXZ ; CRecordVector<void *>::Clear(void)
.text:000017BA                 mov     eax, [ebp+var_4]
.text:000017BD                 mov     ecx, [ebp+arg_0]
.text:000017C0                 cmp     ecx, [eax+8]
.text:000017C3                 jbe     short loc_181C
.text:000017C5                 mov     edx, [ebp+var_4]
.text:000017C8                 mov     eax, [edx]
.text:000017CA                 mov     [ebp+var_8], eax
.text:000017CD                 mov     ecx, [ebp+var_8]
.text:000017D0                 push    ecx             ; void *
.text:000017D1                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:000017D6                 add     esp, 4
.text:000017D9                 mov     edx, [ebp+var_4]
.text:000017DC                 mov     dword ptr [edx], 0
.text:000017E2                 mov     eax, [ebp+var_4]
.text:000017E5                 mov     dword ptr [eax+8], 0
.text:000017EC                 xor     ecx, ecx
.text:000017EE                 mov     eax, [ebp+arg_0]
.text:000017F1                 mov     edx, 4
.text:000017F6                 mul     edx
.text:000017F8                 seto    cl
.text:000017FB                 neg     ecx
.text:000017FD                 or      ecx, eax
.text:000017FF                 push    ecx             ; unsigned int
.text:00001800                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00001805                 add     esp, 4
.text:00001808                 mov     [ebp+var_C], eax
.text:0000180B                 mov     eax, [ebp+var_4]
.text:0000180E                 mov     ecx, [ebp+var_C]
.text:00001811                 mov     [eax], ecx
.text:00001813                 mov     edx, [ebp+var_4]
.text:00001816                 mov     eax, [ebp+arg_0]
.text:00001819                 mov     [edx+8], eax
.text:0000181C
.text:0000181C loc_181C:                               ; CODE XREF: CRecordVector<void *>::ClearAndReserve(uint)+2Fj
.text:0000181C                 add     esp, 0Ch
.text:0000181F                 cmp     ebp, esp
.text:00001821                 call    __RTC_CheckEsp
.text:00001826                 mov     esp, ebp
.text:00001828                 pop     ebp
.text:00001829                 retn    4
.text:00001829 ?ClearAndReserve@?$CRecordVector@PAX@@QAEXI@Z endp
.text:00001829
.text:00001829 _text           ends
.text:00001829
.text:0000182C ; ===========================================================================
.text:0000182C
.text:0000182C ; Segment type: Pure code
.text:0000182C ; Segment permissions: Read/Execute
.text:0000182C _text           segment para public 'CODE' use32
.text:0000182C                 assume cs:_text
.text:0000182C                 ;org 182Ch
.text:0000182C ; COMDAT (pick any)
.text:0000182C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000182C
.text:0000182C ; =============== S U B R O U T I N E =======================================
.text:0000182C
.text:0000182C ; Attributes: bp-based frame
.text:0000182C
.text:0000182C ; public: __thiscall CRecordVector<void *>::~CRecordVector<void *>(void)
.text:0000182C                 public ??1?$CRecordVector@PAX@@QAE@XZ
.text:0000182C ??1?$CRecordVector@PAX@@QAE@XZ proc near
.text:0000182C                                         ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+9Cp
.text:0000182C                                         ; __unwindfunclet$??1?$CObjectVector@VUString@@@@QAE@XZ$0+3j
.text:0000182C
.text:0000182C var_8           = dword ptr -8
.text:0000182C var_4           = dword ptr -4
.text:0000182C
.text:0000182C                 push    ebp
.text:0000182D                 mov     ebp, esp
.text:0000182F                 sub     esp, 8
.text:00001832                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00001839                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001840                 mov     [ebp+var_4], ecx
.text:00001843                 mov     eax, [ebp+var_4]
.text:00001846                 mov     ecx, [eax]
.text:00001848                 mov     [ebp+var_8], ecx
.text:0000184B                 mov     edx, [ebp+var_8]
.text:0000184E                 push    edx             ; void *
.text:0000184F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00001854                 add     esp, 4
.text:00001857                 add     esp, 8
.text:0000185A                 cmp     ebp, esp
.text:0000185C                 call    __RTC_CheckEsp
.text:00001861                 mov     esp, ebp
.text:00001863                 pop     ebp
.text:00001864                 retn
.text:00001864 ??1?$CRecordVector@PAX@@QAE@XZ endp
.text:00001864
.text:00001864 ; ---------------------------------------------------------------------------
.text:00001865                 align 4
.text:00001865 _text           ends
.text:00001865
.text:00001868 ; ===========================================================================
.text:00001868
.text:00001868 ; Segment type: Pure code
.text:00001868 ; Segment permissions: Read/Execute
.text:00001868 _text           segment para public 'CODE' use32
.text:00001868                 assume cs:_text
.text:00001868                 ;org 1868h
.text:00001868 ; COMDAT (pick any)
.text:00001868                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001868
.text:00001868 ; =============== S U B R O U T I N E =======================================
.text:00001868
.text:00001868 ; Attributes: bp-based frame
.text:00001868
.text:00001868 ; public: void __thiscall CRecordVector<void *>::AddInReserved(void * const)
.text:00001868                 public ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z
.text:00001868 ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z proc near
.text:00001868                                         ; CODE XREF: CObjectVector<UString>::AddInReserved(UString const &)+7Fp
.text:00001868
.text:00001868 var_4           = dword ptr -4
.text:00001868 arg_0           = dword ptr  8
.text:00001868
.text:00001868                 push    ebp
.text:00001869                 mov     ebp, esp
.text:0000186B                 push    ecx
.text:0000186C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001873                 mov     [ebp+var_4], ecx
.text:00001876                 mov     eax, [ebp+var_4]
.text:00001879                 mov     ecx, [eax+4]
.text:0000187C                 mov     edx, [ebp+var_4]
.text:0000187F                 mov     eax, [edx]
.text:00001881                 mov     edx, [ebp+arg_0]
.text:00001884                 mov     [eax+ecx*4], edx
.text:00001887                 mov     eax, [ebp+var_4]
.text:0000188A                 mov     ecx, [eax+4]
.text:0000188D                 add     ecx, 1
.text:00001890                 mov     edx, [ebp+var_4]
.text:00001893                 mov     [edx+4], ecx
.text:00001896                 mov     esp, ebp
.text:00001898                 pop     ebp
.text:00001899                 retn    4
.text:00001899 ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z endp
.text:00001899
.text:00001899 _text           ends
.text:00001899
.text:0000189C ; ===========================================================================
.text:0000189C
.text:0000189C ; Segment type: Pure code
.text:0000189C ; Segment permissions: Read/Execute
.text:0000189C _text           segment para public 'CODE' use32
.text:0000189C                 assume cs:_text
.text:0000189C                 ;org 189Ch
.text:0000189C ; COMDAT (pick any)
.text:0000189C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000189C
.text:0000189C ; =============== S U B R O U T I N E =======================================
.text:0000189C
.text:0000189C ; Attributes: bp-based frame
.text:0000189C
.text:0000189C ; public: void * const & __thiscall CRecordVector<void *>::operator[](unsigned int)const
.text:0000189C                 public ??A?$CRecordVector@PAX@@QBEABQAXI@Z
.text:0000189C ??A?$CRecordVector@PAX@@QBEABQAXI@Z proc near
.text:0000189C                                         ; CODE XREF: CObjectVector<CDirItem>::operator[](uint)+15p
.text:0000189C                                         ; CObjectVector<CArcItem>::operator[](uint)+15p
.text:0000189C
.text:0000189C var_4           = dword ptr -4
.text:0000189C arg_0           = dword ptr  8
.text:0000189C
.text:0000189C                 push    ebp
.text:0000189D                 mov     ebp, esp
.text:0000189F                 push    ecx
.text:000018A0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000018A7                 mov     [ebp+var_4], ecx
.text:000018AA                 mov     eax, [ebp+var_4]
.text:000018AD                 mov     ecx, [eax]
.text:000018AF                 mov     edx, [ebp+arg_0]
.text:000018B2                 lea     eax, [ecx+edx*4]
.text:000018B5                 mov     esp, ebp
.text:000018B7                 pop     ebp
.text:000018B8                 retn    4
.text:000018B8 ??A?$CRecordVector@PAX@@QBEABQAXI@Z endp
.text:000018B8
.text:000018B8 ; ---------------------------------------------------------------------------
.text:000018BB                 align 4
.text:000018BB _text           ends
.text:000018BB
.text:000018BC ; ===========================================================================
.text:000018BC
.text:000018BC ; Segment type: Pure code
.text:000018BC ; Segment permissions: Read/Execute
.text:000018BC _text           segment para public 'CODE' use32
.text:000018BC                 assume cs:_text
.text:000018BC                 ;org 18BCh
.text:000018BC ; COMDAT (pick any)
.text:000018BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000018BC
.text:000018BC ; =============== S U B R O U T I N E =======================================
.text:000018BC
.text:000018BC ; Attributes: bp-based frame
.text:000018BC
.text:000018BC ; public: void * & __thiscall CRecordVector<void *>::operator[](unsigned int)
.text:000018BC                 public ??A?$CRecordVector@PAX@@QAEAAPAXI@Z
.text:000018BC ??A?$CRecordVector@PAX@@QAEAAPAXI@Z proc near
.text:000018BC                                         ; CODE XREF: CObjectVector<UString>::operator[](uint)+15p
.text:000018BC                                         ; CObjectVector<UString>::~CObjectVector<UString>(void)+64p ...
.text:000018BC
.text:000018BC var_4           = dword ptr -4
.text:000018BC arg_0           = dword ptr  8
.text:000018BC
.text:000018BC                 push    ebp
.text:000018BD                 mov     ebp, esp
.text:000018BF                 push    ecx
.text:000018C0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000018C7                 mov     [ebp+var_4], ecx
.text:000018CA                 mov     eax, [ebp+var_4]
.text:000018CD                 mov     ecx, [eax]
.text:000018CF                 mov     edx, [ebp+arg_0]
.text:000018D2                 lea     eax, [ecx+edx*4]
.text:000018D5                 mov     esp, ebp
.text:000018D7                 pop     ebp
.text:000018D8                 retn    4
.text:000018D8 ??A?$CRecordVector@PAX@@QAEAAPAXI@Z endp
.text:000018D8
.text:000018D8 ; ---------------------------------------------------------------------------
.text:000018DB                 align 4
.text:000018DB _text           ends
.text:000018DB
.text:000018DC ; ===========================================================================
.text:000018DC
.text:000018DC ; Segment type: Pure code
.text:000018DC ; Segment permissions: Read/Execute
.text:000018DC _text           segment para public 'CODE' use32
.text:000018DC                 assume cs:_text
.text:000018DC                 ;org 18DCh
.text:000018DC ; COMDAT (pick any)
.text:000018DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000018DC
.text:000018DC ; =============== S U B R O U T I N E =======================================
.text:000018DC
.text:000018DC ; Attributes: bp-based frame
.text:000018DC
.text:000018DC ; public: void __thiscall CObjectVector<class UString>::Clear(void)
.text:000018DC                 public ?Clear@?$CObjectVector@VUString@@@@QAEXXZ
.text:000018DC ?Clear@?$CObjectVector@VUString@@@@QAEXXZ proc near
.text:000018DC                                         ; CODE XREF: CObjectVector<UString>::ClearAndReserve(uint)+11p
.text:000018DC
.text:000018DC var_14          = dword ptr -14h
.text:000018DC var_10          = dword ptr -10h
.text:000018DC var_C           = dword ptr -0Ch
.text:000018DC var_8           = dword ptr -8
.text:000018DC var_4           = dword ptr -4
.text:000018DC
.text:000018DC                 push    ebp
.text:000018DD                 mov     ebp, esp
.text:000018DF                 sub     esp, 14h
.text:000018E2                 mov     eax, 0CCCCCCCCh
.text:000018E7                 mov     [ebp+var_14], eax
.text:000018EA                 mov     [ebp+var_10], eax
.text:000018ED                 mov     [ebp+var_C], eax
.text:000018F0                 mov     [ebp+var_8], eax
.text:000018F3                 mov     [ebp+var_4], eax
.text:000018F6                 mov     [ebp+var_4], ecx
.text:000018F9                 mov     ecx, [ebp+var_4]
.text:000018FC                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00001901                 mov     [ebp+var_8], eax
.text:00001904
.text:00001904 loc_1904:                               ; CODE XREF: CObjectVector<UString>::Clear(void):loc_1946j
.text:00001904                 cmp     [ebp+var_8], 0
.text:00001908                 jz      short loc_1948
.text:0000190A                 mov     eax, [ebp+var_8]
.text:0000190D                 sub     eax, 1
.text:00001910                 mov     [ebp+var_8], eax
.text:00001913                 mov     ecx, [ebp+var_8]
.text:00001916                 push    ecx
.text:00001917                 mov     ecx, [ebp+var_4]
.text:0000191A                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:0000191F                 mov     edx, [eax]
.text:00001921                 mov     [ebp+var_10], edx
.text:00001924                 mov     eax, [ebp+var_10]
.text:00001927                 mov     [ebp+var_C], eax
.text:0000192A                 cmp     [ebp+var_C], 0
.text:0000192E                 jz      short loc_193F
.text:00001930                 push    1
.text:00001932                 mov     ecx, [ebp+var_C]
.text:00001935                 call    ??_GUString@@QAEPAXI@Z ; UString::`scalar deleting destructor'(uint)
.text:0000193A                 mov     [ebp+var_14], eax
.text:0000193D                 jmp     short loc_1946
.text:0000193F ; ---------------------------------------------------------------------------
.text:0000193F
.text:0000193F loc_193F:                               ; CODE XREF: CObjectVector<UString>::Clear(void)+52j
.text:0000193F                 mov     [ebp+var_14], 0
.text:00001946
.text:00001946 loc_1946:                               ; CODE XREF: CObjectVector<UString>::Clear(void)+61j
.text:00001946                 jmp     short loc_1904
.text:00001948 ; ---------------------------------------------------------------------------
.text:00001948
.text:00001948 loc_1948:                               ; CODE XREF: CObjectVector<UString>::Clear(void)+2Cj
.text:00001948                 mov     ecx, [ebp+var_4]
.text:0000194B                 call    ?Clear@?$CRecordVector@PAX@@QAEXXZ ; CRecordVector<void *>::Clear(void)
.text:00001950                 add     esp, 14h
.text:00001953                 cmp     ebp, esp
.text:00001955                 call    __RTC_CheckEsp
.text:0000195A                 mov     esp, ebp
.text:0000195C                 pop     ebp
.text:0000195D                 retn
.text:0000195D ?Clear@?$CObjectVector@VUString@@@@QAEXXZ endp
.text:0000195D
.text:0000195D ; ---------------------------------------------------------------------------
.text:0000195E                 align 10h
.text:0000195E _text           ends
.text:0000195E
.text:00001960 ; ===========================================================================
.text:00001960
.text:00001960 ; Segment type: Pure code
.text:00001960 ; Segment permissions: Read/Execute
.text:00001960 _text           segment para public 'CODE' use32
.text:00001960                 assume cs:_text
.text:00001960                 ;org 1960h
.text:00001960 ; COMDAT (pick any)
.text:00001960                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001960
.text:00001960 ; =============== S U B R O U T I N E =======================================
.text:00001960
.text:00001960 ; Attributes: bp-based frame
.text:00001960
.text:00001960 ; public: void __thiscall CRecordVector<unsigned int>::ClearAndReserve(unsigned int)
.text:00001960                 public ?ClearAndReserve@?$CRecordVector@I@@QAEXI@Z
.text:00001960 ?ClearAndReserve@?$CRecordVector@I@@QAEXI@Z proc near
.text:00001960                                         ; CODE XREF: CRecordVector<uint>::ClearAndSetSize(uint)+15p
.text:00001960
.text:00001960 var_C           = dword ptr -0Ch
.text:00001960 var_8           = dword ptr -8
.text:00001960 var_4           = dword ptr -4
.text:00001960 arg_0           = dword ptr  8
.text:00001960
.text:00001960                 push    ebp
.text:00001961                 mov     ebp, esp
.text:00001963                 sub     esp, 0Ch
.text:00001966                 mov     [ebp+var_C], 0CCCCCCCCh
.text:0000196D                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00001974                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000197B                 mov     [ebp+var_4], ecx
.text:0000197E                 mov     ecx, [ebp+var_4]
.text:00001981                 call    ?Clear@?$CRecordVector@I@@QAEXXZ ; CRecordVector<uint>::Clear(void)
.text:00001986                 mov     eax, [ebp+var_4]
.text:00001989                 mov     ecx, [ebp+arg_0]
.text:0000198C                 cmp     ecx, [eax+8]
.text:0000198F                 jbe     short loc_19E8
.text:00001991                 mov     edx, [ebp+var_4]
.text:00001994                 mov     eax, [edx]
.text:00001996                 mov     [ebp+var_8], eax
.text:00001999                 mov     ecx, [ebp+var_8]
.text:0000199C                 push    ecx             ; void *
.text:0000199D                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:000019A2                 add     esp, 4
.text:000019A5                 mov     edx, [ebp+var_4]
.text:000019A8                 mov     dword ptr [edx], 0
.text:000019AE                 mov     eax, [ebp+var_4]
.text:000019B1                 mov     dword ptr [eax+8], 0
.text:000019B8                 xor     ecx, ecx
.text:000019BA                 mov     eax, [ebp+arg_0]
.text:000019BD                 mov     edx, 4
.text:000019C2                 mul     edx
.text:000019C4                 seto    cl
.text:000019C7                 neg     ecx
.text:000019C9                 or      ecx, eax
.text:000019CB                 push    ecx             ; unsigned int
.text:000019CC                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:000019D1                 add     esp, 4
.text:000019D4                 mov     [ebp+var_C], eax
.text:000019D7                 mov     eax, [ebp+var_4]
.text:000019DA                 mov     ecx, [ebp+var_C]
.text:000019DD                 mov     [eax], ecx
.text:000019DF                 mov     edx, [ebp+var_4]
.text:000019E2                 mov     eax, [ebp+arg_0]
.text:000019E5                 mov     [edx+8], eax
.text:000019E8
.text:000019E8 loc_19E8:                               ; CODE XREF: CRecordVector<uint>::ClearAndReserve(uint)+2Fj
.text:000019E8                 add     esp, 0Ch
.text:000019EB                 cmp     ebp, esp
.text:000019ED                 call    __RTC_CheckEsp
.text:000019F2                 mov     esp, ebp
.text:000019F4                 pop     ebp
.text:000019F5                 retn    4
.text:000019F5 ?ClearAndReserve@?$CRecordVector@I@@QAEXI@Z endp
.text:000019F5
.text:000019F5 _text           ends
.text:000019F5
.text:000019F8 ; ===========================================================================
.text:000019F8
.text:000019F8 ; Segment type: Pure code
.text:000019F8 ; Segment permissions: Read/Execute
.text:000019F8 _text           segment para public 'CODE' use32
.text:000019F8                 assume cs:_text
.text:000019F8                 ;org 19F8h
.text:000019F8 ; COMDAT (pick any)
.text:000019F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000019F8
.text:000019F8 ; =============== S U B R O U T I N E =======================================
.text:000019F8
.text:000019F8 ; Attributes: bp-based frame
.text:000019F8
.text:000019F8 ; public: unsigned int & __thiscall CRecordVector<unsigned int>::Front(void)
.text:000019F8                 public ?Front@?$CRecordVector@I@@QAEAAIXZ
.text:000019F8 ?Front@?$CRecordVector@I@@QAEAAIXZ proc near
.text:000019F8                                         ; CODE XREF: CRecordVector<uint>::Sort(int (*)(uint const *,uint const *,void *),void *)+34p
.text:000019F8
.text:000019F8 var_4           = dword ptr -4
.text:000019F8
.text:000019F8                 push    ebp
.text:000019F9                 mov     ebp, esp
.text:000019FB                 push    ecx
.text:000019FC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001A03                 mov     [ebp+var_4], ecx
.text:00001A06                 mov     eax, [ebp+var_4]
.text:00001A09                 mov     eax, [eax]
.text:00001A0B                 mov     esp, ebp
.text:00001A0D                 pop     ebp
.text:00001A0E                 retn
.text:00001A0E ?Front@?$CRecordVector@I@@QAEAAIXZ endp
.text:00001A0E
.text:00001A0E ; ---------------------------------------------------------------------------
.text:00001A0F                 align 10h
.text:00001A0F _text           ends
.text:00001A0F
.text:00001A10 ; ===========================================================================
.text:00001A10
.text:00001A10 ; Segment type: Pure code
.text:00001A10 ; Segment permissions: Read/Execute
.text:00001A10 _text           segment para public 'CODE' use32
.text:00001A10                 assume cs:_text
.text:00001A10                 ;org 1A10h
.text:00001A10 ; COMDAT (pick any)
.text:00001A10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001A10
.text:00001A10 ; =============== S U B R O U T I N E =======================================
.text:00001A10
.text:00001A10 ; Attributes: bp-based frame
.text:00001A10
.text:00001A10 ; public: static void __stdcall CRecordVector<unsigned int>::SortRefDown(unsigned int *, unsigned int, unsigned int, int (__stdcall *)(unsigned int const *, unsigned int const *, void *), void *)
.text:00001A10                 public ?SortRefDown@?$CRecordVector@I@@SGXPAIIIP6GHPBI1PAX@Z2@Z
.text:00001A10 ?SortRefDown@?$CRecordVector@I@@SGXPAIIIP6GHPBI1PAX@Z2@Z proc near
.text:00001A10                                         ; CODE XREF: CRecordVector<uint>::Sort(int (*)(uint const *,uint const *,void *),void *)+5Bp
.text:00001A10                                         ; CRecordVector<uint>::Sort(int (*)(uint const *,uint const *,void *),void *)+AAp
.text:00001A10
.text:00001A10 var_10          = dword ptr -10h
.text:00001A10 var_C           = dword ptr -0Ch
.text:00001A10 var_8           = dword ptr -8
.text:00001A10 var_4           = dword ptr -4
.text:00001A10 arg_0           = dword ptr  8
.text:00001A10 arg_4           = dword ptr  0Ch
.text:00001A10 arg_8           = dword ptr  10h
.text:00001A10 arg_C           = dword ptr  14h
.text:00001A10 arg_10          = dword ptr  18h
.text:00001A10
.text:00001A10                 push    ebp
.text:00001A11                 mov     ebp, esp
.text:00001A13                 sub     esp, 10h
.text:00001A16                 push    esi
.text:00001A17                 mov     eax, 0CCCCCCCCh
.text:00001A1C                 mov     [ebp+var_10], eax
.text:00001A1F                 mov     [ebp+var_C], eax
.text:00001A22                 mov     [ebp+var_8], eax
.text:00001A25                 mov     [ebp+var_4], eax
.text:00001A28                 mov     eax, [ebp+arg_4]
.text:00001A2B                 mov     ecx, [ebp+arg_0]
.text:00001A2E                 mov     edx, [ecx+eax*4]
.text:00001A31                 mov     [ebp+var_8], edx
.text:00001A34
.text:00001A34 loc_1A34:                               ; CODE XREF: CRecordVector<uint>::SortRefDown(uint *,uint,uint,int (*)(uint const *,uint const *,void *),void *)+ACj
.text:00001A34                 mov     eax, [ebp+arg_4]
.text:00001A37                 shl     eax, 1
.text:00001A39                 mov     [ebp+var_10], eax
.text:00001A3C                 mov     ecx, [ebp+var_10]
.text:00001A3F                 cmp     ecx, [ebp+arg_8]
.text:00001A42                 jbe     short loc_1A46
.text:00001A44                 jmp     short loc_1AC1
.text:00001A46 ; ---------------------------------------------------------------------------
.text:00001A46
.text:00001A46 loc_1A46:                               ; CODE XREF: CRecordVector<uint>::SortRefDown(uint *,uint,uint,int (*)(uint const *,uint const *,void *),void *)+32j
.text:00001A46                 mov     edx, [ebp+var_10]
.text:00001A49                 cmp     edx, [ebp+arg_8]
.text:00001A4C                 jnb     short loc_1A80
.text:00001A4E                 mov     esi, esp
.text:00001A50                 mov     eax, [ebp+arg_10]
.text:00001A53                 push    eax
.text:00001A54                 mov     ecx, [ebp+var_10]
.text:00001A57                 mov     edx, [ebp+arg_0]
.text:00001A5A                 lea     eax, [edx+ecx*4]
.text:00001A5D                 push    eax
.text:00001A5E                 mov     ecx, [ebp+var_10]
.text:00001A61                 mov     edx, [ebp+arg_0]
.text:00001A64                 lea     eax, [edx+ecx*4+4]
.text:00001A68                 push    eax
.text:00001A69                 call    [ebp+arg_C]
.text:00001A6C                 cmp     esi, esp
.text:00001A6E                 call    __RTC_CheckEsp
.text:00001A73                 test    eax, eax
.text:00001A75                 jle     short loc_1A80
.text:00001A77                 mov     ecx, [ebp+var_10]
.text:00001A7A                 add     ecx, 1
.text:00001A7D                 mov     [ebp+var_10], ecx
.text:00001A80
.text:00001A80 loc_1A80:                               ; CODE XREF: CRecordVector<uint>::SortRefDown(uint *,uint,uint,int (*)(uint const *,uint const *,void *),void *)+3Cj
.text:00001A80                                         ; CRecordVector<uint>::SortRefDown(uint *,uint,uint,int (*)(uint const *,uint const *,void *),void *)+65j
.text:00001A80                 mov     esi, esp
.text:00001A82                 mov     edx, [ebp+arg_10]
.text:00001A85                 push    edx
.text:00001A86                 mov     eax, [ebp+var_10]
.text:00001A89                 mov     ecx, [ebp+arg_0]
.text:00001A8C                 lea     edx, [ecx+eax*4]
.text:00001A8F                 push    edx
.text:00001A90                 lea     eax, [ebp+var_8]
.text:00001A93                 push    eax
.text:00001A94                 call    [ebp+arg_C]
.text:00001A97                 cmp     esi, esp
.text:00001A99                 call    __RTC_CheckEsp
.text:00001A9E                 test    eax, eax
.text:00001AA0                 jl      short loc_1AA4
.text:00001AA2                 jmp     short loc_1AC1
.text:00001AA4 ; ---------------------------------------------------------------------------
.text:00001AA4
.text:00001AA4 loc_1AA4:                               ; CODE XREF: CRecordVector<uint>::SortRefDown(uint *,uint,uint,int (*)(uint const *,uint const *,void *),void *)+90j
.text:00001AA4                 mov     ecx, [ebp+arg_4]
.text:00001AA7                 mov     edx, [ebp+arg_0]
.text:00001AAA                 mov     eax, [ebp+var_10]
.text:00001AAD                 mov     esi, [ebp+arg_0]
.text:00001AB0                 mov     eax, [esi+eax*4]
.text:00001AB3                 mov     [edx+ecx*4], eax
.text:00001AB6                 mov     ecx, [ebp+var_10]
.text:00001AB9                 mov     [ebp+arg_4], ecx
.text:00001ABC                 jmp     loc_1A34
.text:00001AC1 ; ---------------------------------------------------------------------------
.text:00001AC1
.text:00001AC1 loc_1AC1:                               ; CODE XREF: CRecordVector<uint>::SortRefDown(uint *,uint,uint,int (*)(uint const *,uint const *,void *),void *)+34j
.text:00001AC1                                         ; CRecordVector<uint>::SortRefDown(uint *,uint,uint,int (*)(uint const *,uint const *,void *),void *)+92j
.text:00001AC1                 mov     edx, [ebp+arg_4]
.text:00001AC4                 mov     eax, [ebp+arg_0]
.text:00001AC7                 mov     ecx, [ebp+var_8]
.text:00001ACA                 mov     [eax+edx*4], ecx
.text:00001ACD                 push    edx
.text:00001ACE                 mov     ecx, ebp
.text:00001AD0                 push    eax
.text:00001AD1                 lea     edx, $LN10_0
.text:00001AD7                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00001ADC                 pop     eax
.text:00001ADD                 pop     edx
.text:00001ADE                 pop     esi
.text:00001ADF                 add     esp, 10h
.text:00001AE2                 cmp     ebp, esp
.text:00001AE4                 call    __RTC_CheckEsp
.text:00001AE9                 mov     esp, ebp
.text:00001AEB                 pop     ebp
.text:00001AEC                 retn    14h
.text:00001AEC ?SortRefDown@?$CRecordVector@I@@SGXPAIIIP6GHPBI1PAX@Z2@Z endp
.text:00001AEC
.text:00001AEC ; ---------------------------------------------------------------------------
.text:00001AEF                 align 10h
.text:00001AF0 $LN10_0         dd 1                    ; DATA XREF: CRecordVector<uint>::SortRefDown(uint *,uint,uint,int (*)(uint const *,uint const *,void *),void *)+C1o
.text:00001AF4                 dd offset $LN9_0
.text:00001AF8 $LN9_0          dd 0FFFFFFF8h, 4        ; DATA XREF: .text:00001AF4o
.text:00001B00                 dd offset $LN8_0        ; "temp"
.text:00001B04 $LN8_0          db 'temp',0             ; DATA XREF: .text:00001B00o
.text:00001B09                 align 4
.text:00001B09 _text           ends
.text:00001B09
.text:00001B0C ; ===========================================================================
.text:00001B0C
.text:00001B0C ; Segment type: Pure code
.text:00001B0C ; Segment permissions: Read/Execute
.text:00001B0C _text           segment para public 'CODE' use32
.text:00001B0C                 assume cs:_text
.text:00001B0C                 ;org 1B0Ch
.text:00001B0C ; COMDAT (pick any)
.text:00001B0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001B0C
.text:00001B0C ; =============== S U B R O U T I N E =======================================
.text:00001B0C
.text:00001B0C ; Attributes: bp-based frame
.text:00001B0C
.text:00001B0C ; private: void __thiscall CRecordVector<struct CUpdatePair>::ReserveOnePosition(void)
.text:00001B0C                 public ?ReserveOnePosition@?$CRecordVector@UCUpdatePair@@@@AAEXXZ
.text:00001B0C ?ReserveOnePosition@?$CRecordVector@UCUpdatePair@@@@AAEXXZ proc near
.text:00001B0C                                         ; CODE XREF: CRecordVector<CUpdatePair>::Add(CUpdatePair)+1Ap
.text:00001B0C
.text:00001B0C var_2C          = dword ptr -2Ch
.text:00001B0C var_28          = dword ptr -28h
.text:00001B0C var_24          = dword ptr -24h
.text:00001B0C var_20          = dword ptr -20h
.text:00001B0C var_1C          = dword ptr -1Ch
.text:00001B0C Dst             = dword ptr -18h
.text:00001B0C var_14          = dword ptr -14h
.text:00001B0C var_10          = dword ptr -10h
.text:00001B0C var_C           = dword ptr -0Ch
.text:00001B0C var_4           = dword ptr -4
.text:00001B0C
.text:00001B0C                 push    ebp
.text:00001B0D                 mov     ebp, esp
.text:00001B0F                 push    0FFFFFFFFh
.text:00001B11                 push    offset __ehhandler$?ReserveOnePosition@?$CRecordVector@UCUpdatePair@@@@AAEXXZ
.text:00001B16                 mov     eax, large fs:0
.text:00001B1C                 push    eax
.text:00001B1D                 sub     esp, 20h
.text:00001B20                 mov     eax, 0CCCCCCCCh
.text:00001B25                 mov     [ebp+var_2C], eax
.text:00001B28                 mov     [ebp+var_28], eax
.text:00001B2B                 mov     [ebp+var_24], eax
.text:00001B2E                 mov     [ebp+var_20], eax
.text:00001B31                 mov     [ebp+var_1C], eax
.text:00001B34                 mov     [ebp+Dst], eax
.text:00001B37                 mov     [ebp+var_14], eax
.text:00001B3A                 mov     [ebp+var_10], eax
.text:00001B3D                 mov     eax, dword ptr ds:___security_cookie
.text:00001B42                 xor     eax, ebp
.text:00001B44                 push    eax
.text:00001B45                 lea     eax, [ebp+var_C]
.text:00001B48                 mov     large fs:0, eax
.text:00001B4E                 mov     [ebp+var_10], ecx
.text:00001B51                 mov     eax, [ebp+var_10]
.text:00001B54                 mov     ecx, [ebp+var_10]
.text:00001B57                 mov     edx, [eax+4]
.text:00001B5A                 cmp     edx, [ecx+8]
.text:00001B5D                 jnz     loc_1C2B
.text:00001B63                 mov     eax, [ebp+var_10]
.text:00001B66                 mov     ecx, [eax+8]
.text:00001B69                 shr     ecx, 2
.text:00001B6C                 mov     edx, [ebp+var_10]
.text:00001B6F                 mov     eax, [edx+8]
.text:00001B72                 lea     ecx, [eax+ecx+1]
.text:00001B76                 mov     [ebp+var_14], ecx
.text:00001B79                 mov     edx, [ebp+var_14]
.text:00001B7C                 mov     [ebp+var_1C], edx
.text:00001B7F                 xor     ecx, ecx
.text:00001B81                 mov     eax, [ebp+var_1C]
.text:00001B84                 mov     edx, 10h
.text:00001B89                 mul     edx
.text:00001B8B                 seto    cl
.text:00001B8E                 neg     ecx
.text:00001B90                 or      ecx, eax
.text:00001B92                 push    ecx             ; unsigned int
.text:00001B93                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00001B98                 add     esp, 4
.text:00001B9B                 mov     [ebp+var_24], eax
.text:00001B9E                 mov     [ebp+var_4], 0
.text:00001BA5                 cmp     [ebp+var_24], 0
.text:00001BA9                 jz      short loc_1BC7
.text:00001BAB                 push    offset ??0CUpdatePair@@QAE@XZ ; CUpdatePair::CUpdatePair(void)
.text:00001BB0                 mov     eax, [ebp+var_1C]
.text:00001BB3                 push    eax
.text:00001BB4                 push    10h
.text:00001BB6                 mov     ecx, [ebp+var_24]
.text:00001BB9                 push    ecx
.text:00001BBA                 call    ??_H@YGXPAXIHP6EPAX0@Z@Z ; `vector constructor iterator'(void *,uint,int,void * (*)(void *))
.text:00001BBF                 mov     edx, [ebp+var_24]
.text:00001BC2                 mov     [ebp+var_2C], edx
.text:00001BC5                 jmp     short loc_1BCE
.text:00001BC7 ; ---------------------------------------------------------------------------
.text:00001BC7
.text:00001BC7 loc_1BC7:                               ; CODE XREF: CRecordVector<CUpdatePair>::ReserveOnePosition(void)+9Dj
.text:00001BC7                 mov     [ebp+var_2C], 0
.text:00001BCE
.text:00001BCE loc_1BCE:                               ; CODE XREF: CRecordVector<CUpdatePair>::ReserveOnePosition(void)+B9j
.text:00001BCE                 mov     eax, [ebp+var_2C]
.text:00001BD1                 mov     [ebp+var_20], eax
.text:00001BD4                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001BDB                 mov     ecx, [ebp+var_20]
.text:00001BDE                 mov     [ebp+Dst], ecx
.text:00001BE1                 mov     edx, [ebp+var_10]
.text:00001BE4                 cmp     dword ptr [edx+4], 0
.text:00001BE8                 jz      short loc_1C06
.text:00001BEA                 mov     eax, [ebp+var_10]
.text:00001BED                 mov     ecx, [eax+4]
.text:00001BF0                 shl     ecx, 4
.text:00001BF3                 push    ecx             ; Size
.text:00001BF4                 mov     edx, [ebp+var_10]
.text:00001BF7                 mov     eax, [edx]
.text:00001BF9                 push    eax             ; Src
.text:00001BFA                 mov     ecx, [ebp+Dst]
.text:00001BFD                 push    ecx             ; Dst
.text:00001BFE                 call    _memcpy
.text:00001C03                 add     esp, 0Ch
.text:00001C06
.text:00001C06 loc_1C06:                               ; CODE XREF: CRecordVector<CUpdatePair>::ReserveOnePosition(void)+DCj
.text:00001C06                 mov     edx, [ebp+var_10]
.text:00001C09                 mov     eax, [edx]
.text:00001C0B                 mov     [ebp+var_28], eax
.text:00001C0E                 mov     ecx, [ebp+var_28]
.text:00001C11                 push    ecx             ; void *
.text:00001C12                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00001C17                 add     esp, 4
.text:00001C1A                 mov     edx, [ebp+var_10]
.text:00001C1D                 mov     eax, [ebp+Dst]
.text:00001C20                 mov     [edx], eax
.text:00001C22                 mov     ecx, [ebp+var_10]
.text:00001C25                 mov     edx, [ebp+var_14]
.text:00001C28                 mov     [ecx+8], edx
.text:00001C2B
.text:00001C2B loc_1C2B:                               ; CODE XREF: CRecordVector<CUpdatePair>::ReserveOnePosition(void)+51j
.text:00001C2B                 mov     ecx, [ebp+var_C]
.text:00001C2E                 mov     large fs:0, ecx
.text:00001C35                 pop     ecx
.text:00001C36                 add     esp, 2Ch
.text:00001C39                 cmp     ebp, esp
.text:00001C3B                 call    __RTC_CheckEsp
.text:00001C40                 mov     esp, ebp
.text:00001C42                 pop     ebp
.text:00001C43                 retn
.text:00001C43 ?ReserveOnePosition@?$CRecordVector@UCUpdatePair@@@@AAEXXZ endp
.text:00001C43
.text:00001C43 _text           ends
.text:00001C43
.text$x:00001C44 ; ===========================================================================
.text$x:00001C44
.text$x:00001C44 ; Segment type: Pure code
.text$x:00001C44 ; Segment permissions: Read/Execute
.text$x:00001C44 _text$x         segment para public 'CODE' use32
.text$x:00001C44                 assume cs:_text$x
.text$x:00001C44                 ;org 1C44h
.text$x:00001C44 ; COMDAT (pick associative to section at 1B0C)
.text$x:00001C44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001C44
.text$x:00001C44 ; =============== S U B R O U T I N E =======================================
.text$x:00001C44
.text$x:00001C44
.text$x:00001C44 __unwindfunclet$?ReserveOnePosition@?$CRecordVector@UCUpdatePair@@@@AAEXXZ$0 proc near
.text$x:00001C44                                         ; DATA XREF: .xdata$x:00001C70o
.text$x:00001C44                 mov     eax, [ebp-24h]
.text$x:00001C47                 push    eax             ; void *
.text$x:00001C48                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00001C4D                 pop     ecx
.text$x:00001C4E                 retn
.text$x:00001C4E __unwindfunclet$?ReserveOnePosition@?$CRecordVector@UCUpdatePair@@@@AAEXXZ$0 endp
.text$x:00001C4E
.text$x:00001C4F
.text$x:00001C4F ; =============== S U B R O U T I N E =======================================
.text$x:00001C4F
.text$x:00001C4F
.text$x:00001C4F __ehhandler$?ReserveOnePosition@?$CRecordVector@UCUpdatePair@@@@AAEXXZ proc near
.text$x:00001C4F                                         ; DATA XREF: CRecordVector<CUpdatePair>::ReserveOnePosition(void)+5o
.text$x:00001C4F
.text$x:00001C4F arg_4           = dword ptr  8
.text$x:00001C4F
.text$x:00001C4F                 mov     edx, [esp+arg_4]
.text$x:00001C53                 lea     eax, [edx+0Ch]
.text$x:00001C56                 mov     ecx, [edx-24h]
.text$x:00001C59                 xor     ecx, eax
.text$x:00001C5B                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001C60                 mov     eax, offset __ehfuncinfo$?ReserveOnePosition@?$CRecordVector@UCUpdatePair@@@@AAEXXZ
.text$x:00001C65                 jmp     ___CxxFrameHandler3
.text$x:00001C65 __ehhandler$?ReserveOnePosition@?$CRecordVector@UCUpdatePair@@@@AAEXXZ endp
.text$x:00001C65
.text$x:00001C65 ; ---------------------------------------------------------------------------
.text$x:00001C6A                 align 4
.text$x:00001C6A _text$x         ends
.text$x:00001C6A
.xdata$x:00001C6C ; ===========================================================================
.xdata$x:00001C6C
.xdata$x:00001C6C ; Segment type: Pure data
.xdata$x:00001C6C ; Segment permissions: Read
.xdata$x:00001C6C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001C6C                 assume cs:_xdata$x
.xdata$x:00001C6C                 ;org 1C6Ch
.xdata$x:00001C6C ; COMDAT (pick associative to section at 1B0C)
.xdata$x:00001C6C __unwindtable$?ReserveOnePosition@?$CRecordVector@UCUpdatePair@@@@AAEXXZ db 0FFh
.xdata$x:00001C6C                                         ; DATA XREF: .xdata$x:00001C7Co
.xdata$x:00001C6D                 db 0FFh
.xdata$x:00001C6E                 db 0FFh
.xdata$x:00001C6F                 db 0FFh
.xdata$x:00001C70                 dd offset __unwindfunclet$?ReserveOnePosition@?$CRecordVector@UCUpdatePair@@@@AAEXXZ$0
.xdata$x:00001C74 __ehfuncinfo$?ReserveOnePosition@?$CRecordVector@UCUpdatePair@@@@AAEXXZ db  22h ; "
.xdata$x:00001C74                                         ; DATA XREF: __ehhandler$?ReserveOnePosition@?$CRecordVector@UCUpdatePair@@@@AAEXXZ+11o
.xdata$x:00001C75                 db    5
.xdata$x:00001C76                 db  93h ; ô
.xdata$x:00001C77                 db  19h
.xdata$x:00001C78                 db    1
.xdata$x:00001C79                 db    0
.xdata$x:00001C7A                 db    0
.xdata$x:00001C7B                 db    0
.xdata$x:00001C7C                 dd offset __unwindtable$?ReserveOnePosition@?$CRecordVector@UCUpdatePair@@@@AAEXXZ
.xdata$x:00001C80                 db    0
.xdata$x:00001C81                 db    0
.xdata$x:00001C82                 db    0
.xdata$x:00001C83                 db    0
.xdata$x:00001C84                 db    0
.xdata$x:00001C85                 db    0
.xdata$x:00001C86                 db    0
.xdata$x:00001C87                 db    0
.xdata$x:00001C88                 db    0
.xdata$x:00001C89                 db    0
.xdata$x:00001C8A                 db    0
.xdata$x:00001C8B                 db    0
.xdata$x:00001C8C                 db    0
.xdata$x:00001C8D                 db    0
.xdata$x:00001C8E                 db    0
.xdata$x:00001C8F                 db    0
.xdata$x:00001C90                 db    0
.xdata$x:00001C91                 db    0
.xdata$x:00001C92                 db    0
.xdata$x:00001C93                 db    0
.xdata$x:00001C94                 db    1
.xdata$x:00001C95                 db    0
.xdata$x:00001C96                 db    0
.xdata$x:00001C97                 db    0
.xdata$x:00001C97 _xdata$x        ends
.xdata$x:00001C97
.text:00001C98 ; ===========================================================================
.text:00001C98
.text:00001C98 ; Segment type: Pure code
.text:00001C98 ; Segment permissions: Read/Execute
.text:00001C98 _text           segment para public 'CODE' use32
.text:00001C98                 assume cs:_text
.text:00001C98                 ;org 1C98h
.text:00001C98 ; COMDAT (pick any)
.text:00001C98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001C98
.text:00001C98 ; =============== S U B R O U T I N E =======================================
.text:00001C98
.text:00001C98 ; Attributes: bp-based frame
.text:00001C98
.text:00001C98 ; public: void __thiscall CRecordVector<void *>::Clear(void)
.text:00001C98                 public ?Clear@?$CRecordVector@PAX@@QAEXXZ
.text:00001C98 ?Clear@?$CRecordVector@PAX@@QAEXXZ proc near
.text:00001C98                                         ; CODE XREF: CRecordVector<void *>::ClearAndReserve(uint)+21p
.text:00001C98                                         ; CObjectVector<UString>::Clear(void)+6Fp
.text:00001C98
.text:00001C98 var_4           = dword ptr -4
.text:00001C98
.text:00001C98                 push    ebp
.text:00001C99                 mov     ebp, esp
.text:00001C9B                 push    ecx
.text:00001C9C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001CA3                 mov     [ebp+var_4], ecx
.text:00001CA6                 mov     eax, [ebp+var_4]
.text:00001CA9                 mov     dword ptr [eax+4], 0
.text:00001CB0                 mov     esp, ebp
.text:00001CB2                 pop     ebp
.text:00001CB3                 retn
.text:00001CB3 ?Clear@?$CRecordVector@PAX@@QAEXXZ endp
.text:00001CB3
.text:00001CB3 _text           ends
.text:00001CB3
.text:00001CB4 ; ===========================================================================
.text:00001CB4
.text:00001CB4 ; Segment type: Pure code
.text:00001CB4 ; Segment permissions: Read/Execute
.text:00001CB4 _text           segment para public 'CODE' use32
.text:00001CB4                 assume cs:_text
.text:00001CB4                 ;org 1CB4h
.text:00001CB4 ; COMDAT (pick any)
.text:00001CB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001CB4
.text:00001CB4 ; =============== S U B R O U T I N E =======================================
.text:00001CB4
.text:00001CB4 ; Attributes: bp-based frame
.text:00001CB4
.text:00001CB4 ; public: void __thiscall CRecordVector<unsigned int>::Clear(void)
.text:00001CB4                 public ?Clear@?$CRecordVector@I@@QAEXXZ
.text:00001CB4 ?Clear@?$CRecordVector@I@@QAEXXZ proc near
.text:00001CB4                                         ; CODE XREF: CRecordVector<uint>::ClearAndReserve(uint)+21p
.text:00001CB4
.text:00001CB4 var_4           = dword ptr -4
.text:00001CB4
.text:00001CB4                 push    ebp
.text:00001CB5                 mov     ebp, esp
.text:00001CB7                 push    ecx
.text:00001CB8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001CBF                 mov     [ebp+var_4], ecx
.text:00001CC2                 mov     eax, [ebp+var_4]
.text:00001CC5                 mov     dword ptr [eax+4], 0
.text:00001CCC                 mov     esp, ebp
.text:00001CCE                 pop     ebp
.text:00001CCF                 retn
.text:00001CCF ?Clear@?$CRecordVector@I@@QAEXXZ endp
.text:00001CCF
.text:00001CCF _text           ends
.text:00001CCF
.text:00001CD0 ; ===========================================================================
.text:00001CD0
.text:00001CD0 ; Segment type: Pure code
.text:00001CD0 ; Segment permissions: Read/Execute
.text:00001CD0 _text           segment para public 'CODE' use32
.text:00001CD0                 assume cs:_text
.text:00001CD0                 ;org 1CD0h
.text:00001CD0 ; COMDAT (pick any)
.text:00001CD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001CD0
.text:00001CD0 ; =============== S U B R O U T I N E =======================================
.text:00001CD0
.text:00001CD0 ; Attributes: bp-based frame
.text:00001CD0
.text:00001CD0 ; int __stdcall MyCompare<unsigned int>(unsigned int, unsigned int)
.text:00001CD0                 public ??$MyCompare@I@@YGHII@Z
.text:00001CD0 ??$MyCompare@I@@YGHII@Z proc near       ; CODE XREF: MyCompareTime(NFileTimeType::EEnum,_FILETIME const &,_FILETIME const &)+6Cp
.text:00001CD0                                         ; MyCompareTime(NFileTimeType::EEnum,_FILETIME const &,_FILETIME const &)+95p ...
.text:00001CD0
.text:00001CD0 var_4           = dword ptr -4
.text:00001CD0 arg_0           = dword ptr  8
.text:00001CD0 arg_4           = dword ptr  0Ch
.text:00001CD0
.text:00001CD0                 push    ebp
.text:00001CD1                 mov     ebp, esp
.text:00001CD3                 push    ecx
.text:00001CD4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001CDB                 mov     eax, [ebp+arg_0]
.text:00001CDE                 cmp     eax, [ebp+arg_4]
.text:00001CE1                 jnb     short loc_1CEC
.text:00001CE3                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001CEA                 jmp     short loc_1CFA
.text:00001CEC ; ---------------------------------------------------------------------------
.text:00001CEC
.text:00001CEC loc_1CEC:                               ; CODE XREF: MyCompare<uint>(uint,uint)+11j
.text:00001CEC                 mov     ecx, [ebp+arg_0]
.text:00001CEF                 xor     edx, edx
.text:00001CF1                 cmp     ecx, [ebp+arg_4]
.text:00001CF4                 setnz   dl
.text:00001CF7                 mov     [ebp+var_4], edx
.text:00001CFA
.text:00001CFA loc_1CFA:                               ; CODE XREF: MyCompare<uint>(uint,uint)+1Aj
.text:00001CFA                 mov     eax, [ebp+var_4]
.text:00001CFD                 mov     esp, ebp
.text:00001CFF                 pop     ebp
.text:00001D00                 retn    8
.text:00001D00 ??$MyCompare@I@@YGHII@Z endp
.text:00001D00
.text:00001D00 _text           ends
.text:00001D00
UNDEF:00001D10 ; ===========================================================================
UNDEF:00001D10
UNDEF:00001D10 ; Segment type: Externs
UNDEF:00001D10 ; UNDEF
UNDEF:00001D10 ; int __stdcall CompareFileNames(const wchar_t *, const wchar_t *)
UNDEF:00001D10                 extrn ?CompareFileNames@@YGHPB_W0@Z:near
UNDEF:00001D10                                         ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+27Dp
UNDEF:00001D10                                         ; GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+3C6p ...
UNDEF:00001D14 ; void __stdcall SortFileNames(class CObjectVector<class UString> const &, class CRecordVector<unsigned int> &)
UNDEF:00001D14                 extrn ?SortFileNames@@YGXABV?$CObjectVector@VUString@@@@AAV?$CRecordVector@I@@@Z:near
UNDEF:00001D14                                         ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+212p
UNDEF:00001D18 ; struct UString __thiscall __high CDirItems::GetLogPath(unsigned int)
UNDEF:00001D18                 extrn ?GetLogPath@CDirItems@@QBE?AVUString@@I@Z:near
UNDEF:00001D18                                         ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+1CFp
UNDEF:00001D1C                 extrn ___security_cookie:near
UNDEF:00001D1C                                         ; DATA XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+2Ar
UNDEF:00001D1C                                         ; ThrowError(char const *,UString const &,UString const &)+31r ...
UNDEF:00001D20                 extrn ___CxxFrameHandler3:near
UNDEF:00001D20                                         ; CODE XREF: __ehhandler$?GetUpdatePairInfoList@@YGXABVCDirItems@@ABV?$CObjectVector@UCArcItem@@@@W4EEnum@NFileTimeType@@AAV?$CRecordVector@UCUpdatePair@@@@@Z+19j
UNDEF:00001D20                                         ; __ehhandler$?ThrowError@@YGXPBDABVUString@@1@Z+16j ...
UNDEF:00001D24 ; __fastcall __security_check_cookie(x)
UNDEF:00001D24                 extrn @__security_check_cookie@4:near
UNDEF:00001D24                                         ; CODE XREF: __ehhandler$?GetUpdatePairInfoList@@YGXABVCDirItems@@ABV?$CObjectVector@UCArcItem@@@@W4EEnum@NFileTimeType@@AAV?$CRecordVector@UCUpdatePair@@@@@Z+Fp
UNDEF:00001D24                                         ; __ehhandler$?ThrowError@@YGXPBDABVUString@@1@Z+Cp ...
UNDEF:00001D28                 extrn __RTC_CheckEsp:near
UNDEF:00001D28                                         ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+866p
UNDEF:00001D28                                         ; MyCompareTime(NFileTimeType::EEnum,_FILETIME const &,_FILETIME const &)+43p ...
UNDEF:00001D2C ; __fastcall _RTC_CheckStackVars(x, x)
UNDEF:00001D2C                 extrn @_RTC_CheckStackVars@8:near
UNDEF:00001D2C                                         ; CODE XREF: GetUpdatePairInfoList(CDirItems const &,CObjectVector<CArcItem> const &,NFileTimeType::EEnum,CRecordVector<CUpdatePair> &)+84Bp
UNDEF:00001D2C                                         ; MyCompareTime(NFileTimeType::EEnum,_FILETIME const &,_FILETIME const &)+BBp ...
UNDEF:00001D30                 extrn __RTC_Shutdown:near
UNDEF:00001D30                                         ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
UNDEF:00001D34                 extrn __RTC_InitBase:near
UNDEF:00001D34                                         ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
UNDEF:00001D38 ; void __cdecl operator delete(void *)
UNDEF:00001D38                 extrn ??3@YAXPAX@Z:near ; CODE XREF: UString::~UString(void)+23p
UNDEF:00001D38                                         ; __unwindfunclet$?AddInReserved@?$CObjectVector@VUString@@@@QAEXABVUString@@@Z$0+4p ...
UNDEF:00001D3C ; private: __thiscall UString::UString(unsigned int, class UString const &)
UNDEF:00001D3C                 extrn ??0UString@@AAE@IABV0@@Z:near
UNDEF:00001D3C                                         ; CODE XREF: UString::Left(uint)+29p
UNDEF:00001D40 ; bool NWindows::NTime::FileTimeToDosTime(NWindows::NTime *__hidden this, const struct _FILETIME *, unsigned int *)
UNDEF:00001D40                 extrn ?FileTimeToDosTime@NTime@NWindows@@YG_NABU_FILETIME@@AAI@Z:near
UNDEF:00001D40                                         ; CODE XREF: MyCompareTime(NFileTimeType::EEnum,_FILETIME const &,_FILETIME const &)+7Bp
UNDEF:00001D40                                         ; MyCompareTime(NFileTimeType::EEnum,_FILETIME const &,_FILETIME const &)+88p
UNDEF:00001D44 ; bool NWindows::NTime::FileTimeToUnixTime(NWindows::NTime *__hidden this, const struct _FILETIME *, unsigned int *)
UNDEF:00001D44                 extrn ?FileTimeToUnixTime@NTime@NWindows@@YG_NABU_FILETIME@@AAI@Z:near
UNDEF:00001D44                                         ; CODE XREF: MyCompareTime(NFileTimeType::EEnum,_FILETIME const &,_FILETIME const &)+52p
UNDEF:00001D44                                         ; MyCompareTime(NFileTimeType::EEnum,_FILETIME const &,_FILETIME const &)+5Fp
UNDEF:00001D48 ; LONG __stdcall CompareFileTime(const FILETIME *lpFileTime1, const FILETIME *lpFileTime2)
UNDEF:00001D48                 extrn __imp__CompareFileTime@8:near
UNDEF:00001D48                                         ; CODE XREF: MyCompareTime(NFileTimeType::EEnum,_FILETIME const &,_FILETIME const &)+3Bp
UNDEF:00001D48                                         ; DATA XREF: MyCompareTime(NFileTimeType::EEnum,_FILETIME const &,_FILETIME const &)+3Br
UNDEF:00001D4C ; __stdcall _CxxThrowException(x, x)
UNDEF:00001D4C                 extrn __CxxThrowException@8:near
UNDEF:00001D4C                                         ; CODE XREF: MyCompareTime(NFileTimeType::EEnum,_FILETIME const &,_FILETIME const &)+ACp
UNDEF:00001D4C                                         ; ThrowError(char const *,UString const &,UString const &)+9Ap
UNDEF:00001D50 ; const type_info::`vftable'
UNDEF:00001D50                 extrn ??_7type_info@@6B@:near
UNDEF:00001D50                                         ; DATA XREF: .data:int `RTTI Type Descriptor'o
UNDEF:00001D50                                         ; .data:UString `RTTI Type Descriptor'o
UNDEF:00001D54 ; public: __thiscall UString::UString(class UString const &)
UNDEF:00001D54                 extrn ??0UString@@QAE@ABV0@@Z:near
UNDEF:00001D54                                         ; CODE XREF: ThrowError(char const *,UString const &,UString const &)+8Cp
UNDEF:00001D54                                         ; CObjectVector<UString>::AddInReserved(UString const &)+5Ap
UNDEF:00001D54                                         ; DATA XREF: ...
UNDEF:00001D58 ; public: class UString & __thiscall UString::operator+=(class UString const &)
UNDEF:00001D58                 extrn ??YUString@@QAEAAV0@ABV0@@Z:near
UNDEF:00001D58                                         ; CODE XREF: ThrowError(char const *,UString const &,UString const &)+6Cp
UNDEF:00001D58                                         ; ThrowError(char const *,UString const &,UString const &)+80p
UNDEF:00001D5C ; void __thiscall UString::Add_LF(UString *__hidden this)
UNDEF:00001D5C                 extrn ?Add_LF@UString@@QAEXXZ:near
UNDEF:00001D5C                                         ; CODE XREF: ThrowError(char const *,UString const &,UString const &)+60p
UNDEF:00001D5C                                         ; ThrowError(char const *,UString const &,UString const &)+74p
UNDEF:00001D60 ; void __thiscall UString::SetFromAscii(UString *__hidden this, const char *)
UNDEF:00001D60                 extrn ?SetFromAscii@UString@@QAEXPBD@Z:near
UNDEF:00001D60                                         ; CODE XREF: ThrowError(char const *,UString const &,UString const &)+58p
UNDEF:00001D64 ; public: __thiscall UString::UString(void)
UNDEF:00001D64                 extrn ??0UString@@QAE@XZ:near
UNDEF:00001D64                                         ; CODE XREF: ThrowError(char const *,UString const &,UString const &)+45p
UNDEF:00001D68 ; void *__cdecl operator new(unsigned int)
UNDEF:00001D68                 extrn ??2@YAPAXI@Z:near ; CODE XREF: CObjectVector<UString>::AddInReserved(UString const &)+3Bp
UNDEF:00001D68                                         ; CObjArray<int>::CObjArray<int>(uint)+3Ap ...
UNDEF:00001D6C ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:00001D6C                 extrn _memcpy:near      ; CODE XREF: CRecordVector<CUpdatePair>::ReserveDown(void)+E8p
UNDEF:00001D6C                                         ; CRecordVector<CUpdatePair>::ReserveOnePosition(void)+F2p
UNDEF:00001D6C
UNDEF:00001D6C
UNDEF:00001D6C                 end