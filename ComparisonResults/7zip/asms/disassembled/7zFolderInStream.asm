.text:00000000 ;
.text:00000000 ; +-------------------------------------------------------------------------+
.text:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.text:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.text:00000000 ; |                      License info: 48-3677-7074-51                      |
.text:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.text:00000000 ; +-------------------------------------------------------------------------+
.text:00000000 ;
.text:00000000 ; Input MD5   : 7C571ADF3E4314A86AD343B614B97BB0
.text:00000000 ; Input CRC32 : 76B2C5A9
.text:00000000
.text:00000000 ; File Name   : C:\workspace\7z1505-src\CPP\7zip\Bundles\Alone\Debug\7zFolderInStream.obj
.text:00000000 ; Format      : COFF (X386MAGIC)
.text:00000000 ; includelib "uuid.lib"
.text:00000000 ; includelib "MSVCRTD"
.text:00000000 ; includelib "OLDNAMES"
.text:00000000
.text:00000000                 .686p
.text:00000000                 .mmx
.text:00000000                 .model flat
.text:00000000
.text:00000000 ; ===========================================================================
.text:00000000
.text:00000000 ; Segment type: Pure code
.text:00000000 ; Segment permissions: Read/Execute
.text:00000000 _text           segment para public 'CODE' use32
.text:00000000                 assume cs:_text
.text:00000000                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000000
.text:00000000 ; =============== S U B R O U T I N E =======================================
.text:00000000
.text:00000000 ; Attributes: bp-based frame
.text:00000000
.text:00000000 ; void __thiscall NArchive::N7z::CFolderInStream::Init(NArchive::N7z::CFolderInStream *this, struct IArchiveUpdateCallback *, const unsigned int *, unsigned int)
.text:00000000                 public ?Init@CFolderInStream@N7z@NArchive@@QAEXPAUIArchiveUpdateCallback@@PBII@Z
.text:00000000 ?Init@CFolderInStream@N7z@NArchive@@QAEXPAUIArchiveUpdateCallback@@PBII@Z proc near
.text:00000000
.text:00000000 var_4           = dword ptr -4
.text:00000000 arg_0           = dword ptr  8
.text:00000000 arg_4           = dword ptr  0Ch
.text:00000000 arg_8           = dword ptr  10h
.text:00000000
.text:00000000                 push    ebp
.text:00000001                 mov     ebp, esp
.text:00000003                 push    ecx
.text:00000004                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000000B                 mov     [ebp+var_4], ecx
.text:0000000E                 mov     eax, [ebp+arg_0]
.text:00000011                 push    eax
.text:00000012                 mov     ecx, [ebp+var_4]
.text:00000015                 add     ecx, 34h ; '4'
.text:00000018                 call    ??4?$CMyComPtr@UIArchiveUpdateCallback@@@@QAEPAUIArchiveUpdateCallback@@PAU1@@Z ; CMyComPtr<IArchiveUpdateCallback>::operator=(IArchiveUpdateCallback *)
.text:0000001D                 mov     ecx, [ebp+var_4]
.text:00000020                 mov     edx, [ebp+arg_4]
.text:00000023                 mov     [ecx+28h], edx
.text:00000026                 mov     eax, [ebp+var_4]
.text:00000029                 mov     ecx, [ebp+arg_8]
.text:0000002C                 mov     [eax+2Ch], ecx
.text:0000002F                 mov     edx, [ebp+var_4]
.text:00000032                 mov     dword ptr [edx+30h], 0
.text:00000039                 mov     eax, [ebp+arg_8]
.text:0000003C                 push    eax
.text:0000003D                 mov     ecx, [ebp+var_4]
.text:00000040                 add     ecx, 38h ; '8'
.text:00000043                 call    ?ClearAndReserve@?$CRecordVector@_N@@QAEXI@Z ; CRecordVector<bool>::ClearAndReserve(uint)
.text:00000048                 mov     ecx, [ebp+arg_8]
.text:0000004B                 push    ecx
.text:0000004C                 mov     ecx, [ebp+var_4]
.text:0000004F                 add     ecx, 44h ; 'D'
.text:00000052                 call    ?ClearAndReserve@?$CRecordVector@I@@QAEXI@Z ; CRecordVector<uint>::ClearAndReserve(uint)
.text:00000057                 mov     edx, [ebp+arg_8]
.text:0000005A                 push    edx
.text:0000005B                 mov     ecx, [ebp+var_4]
.text:0000005E                 add     ecx, 50h ; 'P'
.text:00000061                 call    ?ClearAndReserve@?$CRecordVector@_K@@QAEXI@Z ; CRecordVector<unsigned __int64>::ClearAndReserve(uint)
.text:00000066                 mov     eax, [ebp+var_4]
.text:00000069                 mov     dword ptr [eax+10h], 0
.text:00000070                 mov     dword ptr [eax+14h], 0
.text:00000077                 mov     ecx, [ebp+var_4]
.text:0000007A                 mov     dword ptr [ecx+18h], 0FFFFFFFFh
.text:00000081                 mov     edx, [ebp+var_4]
.text:00000084                 mov     byte ptr [edx+1Ch], 0
.text:00000088                 mov     eax, [ebp+var_4]
.text:0000008B                 mov     dword ptr [eax+20h], 0
.text:00000092                 mov     dword ptr [eax+24h], 0
.text:00000099                 mov     ecx, [ebp+var_4]
.text:0000009C                 add     ecx, 0Ch
.text:0000009F                 call    ?Release@?$CMyComPtr@UISequentialInStream@@@@QAEXXZ ; CMyComPtr<ISequentialInStream>::Release(void)
.text:000000A4                 add     esp, 4
.text:000000A7                 cmp     ebp, esp
.text:000000A9                 call    __RTC_CheckEsp
.text:000000AE                 mov     esp, ebp
.text:000000B0                 pop     ebp
.text:000000B1                 retn    0Ch
.text:000000B1 ?Init@CFolderInStream@N7z@NArchive@@QAEXPAUIArchiveUpdateCallback@@PBII@Z endp
.text:000000B1
.text:000000B1 ; ---------------------------------------------------------------------------
.text:000000B4                 align 10h
.text:000000C0
.text:000000C0 ; =============== S U B R O U T I N E =======================================
.text:000000C0
.text:000000C0 ; Attributes: bp-based frame
.text:000000C0
.text:000000C0 ; __int32 __thiscall NArchive::N7z::CFolderInStream::OpenStream(NArchive::N7z::CFolderInStream *__hidden this)
.text:000000C0                 public ?OpenStream@CFolderInStream@N7z@NArchive@@AAEJXZ
.text:000000C0 ?OpenStream@CFolderInStream@N7z@NArchive@@AAEJXZ proc near
.text:000000C0                                         ; CODE XREF: NArchive::N7z::CFolderInStream::Read(void *,uint,uint *)+17Bp
.text:000000C0
.text:000000C0 var_48          = dword ptr -48h
.text:000000C0 var_44          = dword ptr -44h
.text:000000C0 var_40          = dword ptr -40h
.text:000000C0 var_3C          = dword ptr -3Ch
.text:000000C0 var_38          = dword ptr -38h
.text:000000C0 var_34          = dword ptr -34h
.text:000000C0 var_30          = dword ptr -30h
.text:000000C0 var_28          = byte ptr -28h
.text:000000C0 var_20          = dword ptr -20h
.text:000000C0 var_18          = byte ptr -18h
.text:000000C0 var_10          = dword ptr -10h
.text:000000C0 var_C           = dword ptr -0Ch
.text:000000C0 var_4           = dword ptr -4
.text:000000C0
.text:000000C0                 push    ebp
.text:000000C1                 mov     ebp, esp
.text:000000C3                 push    0FFFFFFFFh
.text:000000C5                 push    offset __ehhandler$?OpenStream@CFolderInStream@N7z@NArchive@@AAEJXZ
.text:000000CA                 mov     eax, large fs:0
.text:000000D0                 push    eax
.text:000000D1                 sub     esp, 3Ch
.text:000000D4                 push    esi
.text:000000D5                 push    edi
.text:000000D6                 push    ecx
.text:000000D7                 lea     edi, [ebp+var_48]
.text:000000DA                 mov     ecx, 0Fh
.text:000000DF                 mov     eax, 0CCCCCCCCh
.text:000000E4                 rep stosd
.text:000000E6                 pop     ecx
.text:000000E7                 mov     eax, dword ptr ds:___security_cookie
.text:000000EC                 xor     eax, ebp
.text:000000EE                 push    eax
.text:000000EF                 lea     eax, [ebp+var_C]
.text:000000F2                 mov     large fs:0, eax
.text:000000F8                 mov     [ebp+var_10], ecx
.text:000000FB                 mov     eax, [ebp+var_10]
.text:000000FE                 mov     dword ptr [eax+10h], 0
.text:00000105                 mov     dword ptr [eax+14h], 0
.text:0000010C                 mov     ecx, [ebp+var_10]
.text:0000010F                 mov     dword ptr [ecx+18h], 0FFFFFFFFh
.text:00000116                 mov     edx, [ebp+var_10]
.text:00000119                 mov     byte ptr [edx+1Ch], 0
.text:0000011D                 mov     eax, [ebp+var_10]
.text:00000120                 mov     dword ptr [eax+20h], 0
.text:00000127                 mov     dword ptr [eax+24h], 0
.text:0000012E
.text:0000012E loc_12E:                                ; CODE XREF: NArchive::N7z::CFolderInStream::OpenStream(void)+21Fj
.text:0000012E                 mov     ecx, [ebp+var_10]
.text:00000131                 mov     edx, [ebp+var_10]
.text:00000134                 mov     eax, [ecx+30h]
.text:00000137                 cmp     eax, [edx+2Ch]
.text:0000013A                 jnb     loc_2E4
.text:00000140                 lea     ecx, [ebp+var_18]
.text:00000143                 call    ??0?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::CMyComPtr<ISequentialInStream>(void)
.text:00000148                 mov     [ebp+var_4], 0
.text:0000014F                 mov     ecx, [ebp+var_10]
.text:00000152                 add     ecx, 34h ; '4'
.text:00000155                 call    ??C?$CMyComPtr@UIArchiveUpdateCallback@@@@QBEPAUIArchiveUpdateCallback@@XZ ; CMyComPtr<IArchiveUpdateCallback>::operator->(void)
.text:0000015A                 mov     [ebp+var_40], eax
.text:0000015D                 lea     ecx, [ebp+var_18]
.text:00000160                 call    ??I?$CMyComPtr@UISequentialInStream@@@@QAEPAPAUISequentialInStream@@XZ ; CMyComPtr<ISequentialInStream>::operator&(void)
.text:00000165                 mov     esi, esp
.text:00000167                 push    eax
.text:00000168                 mov     ecx, [ebp+var_10]
.text:0000016B                 mov     edx, [ecx+30h]
.text:0000016E                 mov     eax, [ebp+var_10]
.text:00000171                 mov     ecx, [eax+28h]
.text:00000174                 mov     edx, [ecx+edx*4]
.text:00000177                 push    edx
.text:00000178                 mov     eax, [ebp+var_40]
.text:0000017B                 push    eax
.text:0000017C                 mov     ecx, [ebp+var_40]
.text:0000017F                 mov     edx, [ecx]
.text:00000181                 mov     eax, [edx+1Ch]
.text:00000184                 call    eax
.text:00000186                 cmp     esi, esp
.text:00000188                 call    __RTC_CheckEsp
.text:0000018D                 mov     [ebp+var_20], eax
.text:00000190                 cmp     [ebp+var_20], 0
.text:00000194                 jz      short loc_1B9
.text:00000196                 cmp     [ebp+var_20], 1
.text:0000019A                 jz      short loc_1B9
.text:0000019C                 mov     ecx, [ebp+var_20]
.text:0000019F                 mov     [ebp+var_34], ecx
.text:000001A2                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000001A9                 lea     ecx, [ebp+var_18]
.text:000001AC                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:000001B1                 mov     eax, [ebp+var_34]
.text:000001B4                 jmp     loc_2E6
.text:000001B9 ; ---------------------------------------------------------------------------
.text:000001B9
.text:000001B9 loc_1B9:                                ; CODE XREF: NArchive::N7z::CFolderInStream::OpenStream(void)+D4j
.text:000001B9                                         ; NArchive::N7z::CFolderInStream::OpenStream(void)+DAj
.text:000001B9                 lea     edx, [ebp+var_18]
.text:000001BC                 push    edx
.text:000001BD                 mov     ecx, [ebp+var_10]
.text:000001C0                 add     ecx, 0Ch
.text:000001C3                 call    ??4?$CMyComPtr@UISequentialInStream@@@@QAEPAUISequentialInStream@@ABV0@@Z ; CMyComPtr<ISequentialInStream>::operator=(CMyComPtr<ISequentialInStream> const &)
.text:000001C8                 lea     ecx, [ebp+var_18]
.text:000001CB                 call    ??B?$CMyComPtr@UISequentialInStream@@@@QBEPAUISequentialInStream@@XZ ; CMyComPtr<ISequentialInStream>::operator ISequentialInStream *(void)
.text:000001D0                 test    eax, eax
.text:000001D2                 jz      loc_264
.text:000001D8                 lea     ecx, [ebp+var_28]
.text:000001DB                 call    ??0?$CMyComPtr@UIStreamGetSize@@@@QAE@XZ ; CMyComPtr<IStreamGetSize>::CMyComPtr<IStreamGetSize>(void)
.text:000001E0                 mov     byte ptr [ebp+var_4], 1
.text:000001E4                 lea     ecx, [ebp+var_28]
.text:000001E7                 call    ??I?$CMyComPtr@UIStreamGetSize@@@@QAEPAPAUIStreamGetSize@@XZ ; CMyComPtr<IStreamGetSize>::operator&(void)
.text:000001EC                 push    eax
.text:000001ED                 push    offset _IID_IStreamGetSize
.text:000001F2                 lea     ecx, [ebp+var_18]
.text:000001F5                 call    ??$QueryInterface@UIStreamGetSize@@@?$CMyComPtr@UISequentialInStream@@@@QBEJABU_GUID@@PAPAUIStreamGetSize@@@Z ; CMyComPtr<ISequentialInStream>::QueryInterface<IStreamGetSize>(_GUID const &,IStreamGetSize * *)
.text:000001FA                 lea     ecx, [ebp+var_28]
.text:000001FD                 call    ??B?$CMyComPtr@UIStreamGetSize@@@@QBEPAUIStreamGetSize@@XZ ; CMyComPtr<IStreamGetSize>::operator IStreamGetSize *(void)
.text:00000202                 test    eax, eax
.text:00000204                 jz      short loc_23A
.text:00000206                 lea     ecx, [ebp+var_28]
.text:00000209                 call    ??C?$CMyComPtr@UIStreamGetSize@@@@QBEPAUIStreamGetSize@@XZ ; CMyComPtr<IStreamGetSize>::operator->(void)
.text:0000020E                 mov     [ebp+var_44], eax
.text:00000211                 mov     eax, [ebp+var_10]
.text:00000214                 add     eax, 20h ; ' '
.text:00000217                 mov     esi, esp
.text:00000219                 push    eax
.text:0000021A                 mov     ecx, [ebp+var_44]
.text:0000021D                 push    ecx
.text:0000021E                 mov     edx, [ebp+var_44]
.text:00000221                 mov     eax, [edx]
.text:00000223                 mov     ecx, [eax+0Ch]
.text:00000226                 call    ecx
.text:00000228                 cmp     esi, esp
.text:0000022A                 call    __RTC_CheckEsp
.text:0000022F                 test    eax, eax
.text:00000231                 jnz     short loc_23A
.text:00000233                 mov     edx, [ebp+var_10]
.text:00000236                 mov     byte ptr [edx+1Ch], 1
.text:0000023A
.text:0000023A loc_23A:                                ; CODE XREF: NArchive::N7z::CFolderInStream::OpenStream(void)+144j
.text:0000023A                                         ; NArchive::N7z::CFolderInStream::OpenStream(void)+171j
.text:0000023A                 mov     [ebp+var_38], 0
.text:00000241                 mov     byte ptr [ebp+var_4], 0
.text:00000245                 lea     ecx, [ebp+var_28]
.text:00000248                 call    ??1?$CMyComPtr@UIStreamGetSize@@@@QAE@XZ ; CMyComPtr<IStreamGetSize>::~CMyComPtr<IStreamGetSize>(void)
.text:0000024D                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000254                 lea     ecx, [ebp+var_18]
.text:00000257                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:0000025C                 mov     eax, [ebp+var_38]
.text:0000025F                 jmp     loc_2E6
.text:00000264 ; ---------------------------------------------------------------------------
.text:00000264
.text:00000264 loc_264:                                ; CODE XREF: NArchive::N7z::CFolderInStream::OpenStream(void)+112j
.text:00000264                 mov     eax, [ebp+var_10]
.text:00000267                 mov     ecx, [eax+30h]
.text:0000026A                 add     ecx, 1
.text:0000026D                 mov     edx, [ebp+var_10]
.text:00000270                 mov     [edx+30h], ecx
.text:00000273                 mov     ecx, [ebp+var_10]
.text:00000276                 add     ecx, 34h ; '4'
.text:00000279                 call    ??C?$CMyComPtr@UIArchiveUpdateCallback@@@@QBEPAUIArchiveUpdateCallback@@XZ ; CMyComPtr<IArchiveUpdateCallback>::operator->(void)
.text:0000027E                 mov     [ebp+var_48], eax
.text:00000281                 mov     esi, esp
.text:00000283                 push    0
.text:00000285                 mov     eax, [ebp+var_48]
.text:00000288                 push    eax
.text:00000289                 mov     ecx, [ebp+var_48]
.text:0000028C                 mov     edx, [ecx]
.text:0000028E                 mov     eax, [edx+20h]
.text:00000291                 call    eax
.text:00000293                 cmp     esi, esp
.text:00000295                 call    __RTC_CheckEsp
.text:0000029A                 mov     [ebp+var_30], eax
.text:0000029D                 cmp     [ebp+var_30], 0
.text:000002A1                 jz      short loc_2BD
.text:000002A3                 mov     ecx, [ebp+var_30]
.text:000002A6                 mov     [ebp+var_3C], ecx
.text:000002A9                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000002B0                 lea     ecx, [ebp+var_18]
.text:000002B3                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:000002B8                 mov     eax, [ebp+var_3C]
.text:000002BB                 jmp     short loc_2E6
.text:000002BD ; ---------------------------------------------------------------------------
.text:000002BD
.text:000002BD loc_2BD:                                ; CODE XREF: NArchive::N7z::CFolderInStream::OpenStream(void)+1E1j
.text:000002BD                 cmp     [ebp+var_20], 0
.text:000002C1                 setz    dl
.text:000002C4                 movzx   eax, dl
.text:000002C7                 push    eax             ; bool
.text:000002C8                 mov     ecx, [ebp+var_10] ; this
.text:000002CB                 call    ?AddFileInfo@CFolderInStream@N7z@NArchive@@AAEX_N@Z ; NArchive::N7z::CFolderInStream::AddFileInfo(bool)
.text:000002D0                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000002D7                 lea     ecx, [ebp+var_18]
.text:000002DA                 call    ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text:000002DF                 jmp     loc_12E
.text:000002E4 ; ---------------------------------------------------------------------------
.text:000002E4
.text:000002E4 loc_2E4:                                ; CODE XREF: NArchive::N7z::CFolderInStream::OpenStream(void)+7Aj
.text:000002E4                 xor     eax, eax
.text:000002E6
.text:000002E6 loc_2E6:                                ; CODE XREF: NArchive::N7z::CFolderInStream::OpenStream(void)+F4j
.text:000002E6                                         ; NArchive::N7z::CFolderInStream::OpenStream(void)+19Fj ...
.text:000002E6                 push    edx
.text:000002E7                 mov     ecx, ebp
.text:000002E9                 push    eax
.text:000002EA                 lea     edx, $LN17
.text:000002F0                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:000002F5                 pop     eax
.text:000002F6                 pop     edx
.text:000002F7                 mov     ecx, [ebp+var_C]
.text:000002FA                 mov     large fs:0, ecx
.text:00000301                 pop     ecx
.text:00000302                 pop     edi
.text:00000303                 pop     esi
.text:00000304                 add     esp, 48h
.text:00000307                 cmp     ebp, esp
.text:00000309                 call    __RTC_CheckEsp
.text:0000030E                 mov     esp, ebp
.text:00000310                 pop     ebp
.text:00000311                 retn
.text:00000311 ?OpenStream@CFolderInStream@N7z@NArchive@@AAEJXZ endp
.text:00000311
.text:00000311 ; ---------------------------------------------------------------------------
.text:00000312                 align 4
.text:00000314 $LN17           dd 2                    ; DATA XREF: NArchive::N7z::CFolderInStream::OpenStream(void)+22Ao
.text:00000318                 dd offset $LN16
.text:0000031C $LN16           dd 0FFFFFFE8h, 4        ; DATA XREF: .text:00000318o
.text:00000324                 dd offset $LN13         ; "stream"
.text:00000328                 dd 0FFFFFFD8h, 4
.text:00000330                 dd offset $LN14         ; "streamGetSize"
.text:00000334 $LN14           db 'streamGetSize',0    ; DATA XREF: .text:00000330o
.text:00000342 $LN13           db 'stream',0           ; DATA XREF: .text:00000324o
.text:00000349                 align 10h
.text:00000350
.text:00000350 ; =============== S U B R O U T I N E =======================================
.text:00000350
.text:00000350 ; Attributes: bp-based frame
.text:00000350
.text:00000350 ; void __thiscall NArchive::N7z::CFolderInStream::AddFileInfo(NArchive::N7z::CFolderInStream *this, bool)
.text:00000350                 public ?AddFileInfo@CFolderInStream@N7z@NArchive@@AAEX_N@Z
.text:00000350 ?AddFileInfo@CFolderInStream@N7z@NArchive@@AAEX_N@Z proc near
.text:00000350                                         ; CODE XREF: NArchive::N7z::CFolderInStream::OpenStream(void)+20Bp
.text:00000350                                         ; NArchive::N7z::CFolderInStream::Read(void *,uint,uint *)+FBp
.text:00000350
.text:00000350 var_4           = dword ptr -4
.text:00000350 arg_0           = byte ptr  8
.text:00000350
.text:00000350                 push    ebp
.text:00000351                 mov     ebp, esp
.text:00000353                 push    ecx
.text:00000354                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000035B                 mov     [ebp+var_4], ecx
.text:0000035E                 movzx   eax, [ebp+arg_0]
.text:00000362                 push    eax
.text:00000363                 mov     ecx, [ebp+var_4]
.text:00000366                 add     ecx, 38h ; '8'
.text:00000369                 call    ?Add@?$CRecordVector@_N@@QAEI_N@Z ; CRecordVector<bool>::Add(bool)
.text:0000036E                 mov     ecx, [ebp+var_4]
.text:00000371                 mov     edx, [ecx+14h]
.text:00000374                 push    edx
.text:00000375                 mov     eax, [ecx+10h]
.text:00000378                 push    eax
.text:00000379                 mov     ecx, [ebp+var_4]
.text:0000037C                 add     ecx, 50h ; 'P'
.text:0000037F                 call    ?Add@?$CRecordVector@_K@@QAEI_K@Z ; CRecordVector<unsigned __int64>::Add(unsigned __int64)
.text:00000384                 mov     ecx, [ebp+var_4]
.text:00000387                 mov     edx, [ecx+18h]
.text:0000038A                 xor     edx, 0FFFFFFFFh
.text:0000038D                 push    edx
.text:0000038E                 mov     ecx, [ebp+var_4]
.text:00000391                 add     ecx, 44h ; 'D'
.text:00000394                 call    ?Add@?$CRecordVector@I@@QAEII@Z ; CRecordVector<uint>::Add(uint)
.text:00000399                 add     esp, 4
.text:0000039C                 cmp     ebp, esp
.text:0000039E                 call    __RTC_CheckEsp
.text:000003A3                 mov     esp, ebp
.text:000003A5                 pop     ebp
.text:000003A6                 retn    4
.text:000003A6 ?AddFileInfo@CFolderInStream@N7z@NArchive@@AAEX_N@Z endp
.text:000003A6
.text:000003A6 ; ---------------------------------------------------------------------------
.text:000003A9                 align 10h
.text:000003B0
.text:000003B0 ; =============== S U B R O U T I N E =======================================
.text:000003B0
.text:000003B0 ; Attributes: bp-based frame
.text:000003B0
.text:000003B0 ; __int32 __stdcall NArchive::N7z::CFolderInStream::Read(NArchive::N7z::CFolderInStream *this, void *, unsigned int, unsigned int *)
.text:000003B0                 public ?Read@CFolderInStream@N7z@NArchive@@UAGJPAXIPAI@Z
.text:000003B0 ?Read@CFolderInStream@N7z@NArchive@@UAGJPAXIPAI@Z proc near
.text:000003B0
.text:000003B0 var_20          = dword ptr -20h
.text:000003B0 var_1C          = dword ptr -1Ch
.text:000003B0 var_18          = dword ptr -18h
.text:000003B0 var_14          = dword ptr -14h
.text:000003B0 var_10          = dword ptr -10h
.text:000003B0 var_C           = dword ptr -0Ch
.text:000003B0 var_8           = dword ptr -8
.text:000003B0 var_4           = dword ptr -4
.text:000003B0 this            = dword ptr  8
.text:000003B0 arg_4           = dword ptr  0Ch
.text:000003B0 arg_8           = dword ptr  10h
.text:000003B0 arg_C           = dword ptr  14h
.text:000003B0
.text:000003B0                 push    ebp
.text:000003B1                 mov     ebp, esp
.text:000003B3                 sub     esp, 20h
.text:000003B6                 push    esi
.text:000003B7                 mov     eax, 0CCCCCCCCh
.text:000003BC                 mov     [ebp+var_20], eax
.text:000003BF                 mov     [ebp+var_1C], eax
.text:000003C2                 mov     [ebp+var_18], eax
.text:000003C5                 mov     [ebp+var_14], eax
.text:000003C8                 mov     [ebp+var_10], eax
.text:000003CB                 mov     [ebp+var_C], eax
.text:000003CE                 mov     [ebp+var_8], eax
.text:000003D1                 mov     [ebp+var_4], eax
.text:000003D4                 cmp     [ebp+arg_C], 0
.text:000003D8                 jz      short loc_3E3
.text:000003DA                 mov     eax, [ebp+arg_C]
.text:000003DD                 mov     dword ptr [eax], 0
.text:000003E3
.text:000003E3 loc_3E3:                                ; CODE XREF: NArchive::N7z::CFolderInStream::Read(void *,uint,uint *)+28j
.text:000003E3                                         ; NArchive::N7z::CFolderInStream::Read(void *,uint,uint *):loc_53Ej
.text:000003E3                 cmp     [ebp+arg_8], 0
.text:000003E7                 jz      loc_543
.text:000003ED                 mov     ecx, [ebp+this]
.text:000003F0                 add     ecx, 0Ch
.text:000003F3                 call    ??B?$CMyComPtr@UISequentialInStream@@@@QBEPAUISequentialInStream@@XZ ; CMyComPtr<ISequentialInStream>::operator ISequentialInStream *(void)
.text:000003F8                 test    eax, eax
.text:000003FA                 jz      loc_518
.text:00000400                 mov     ecx, [ebp+this]
.text:00000403                 add     ecx, 0Ch
.text:00000406                 call    ??C?$CMyComPtr@UISequentialInStream@@@@QBEPAUISequentialInStream@@XZ ; CMyComPtr<ISequentialInStream>::operator->(void)
.text:0000040B                 mov     [ebp+var_1C], eax
.text:0000040E                 mov     esi, esp
.text:00000410                 lea     ecx, [ebp+var_8]
.text:00000413                 push    ecx
.text:00000414                 mov     edx, [ebp+arg_8]
.text:00000417                 push    edx
.text:00000418                 mov     eax, [ebp+arg_4]
.text:0000041B                 push    eax
.text:0000041C                 mov     ecx, [ebp+var_1C]
.text:0000041F                 push    ecx
.text:00000420                 mov     edx, [ebp+var_1C]
.text:00000423                 mov     eax, [edx]
.text:00000425                 mov     ecx, [eax+0Ch]
.text:00000428                 call    ecx
.text:0000042A                 cmp     esi, esp
.text:0000042C                 call    __RTC_CheckEsp
.text:00000431                 mov     [ebp+var_10], eax
.text:00000434                 cmp     [ebp+var_10], 0
.text:00000438                 jz      short loc_442
.text:0000043A                 mov     eax, [ebp+var_10]
.text:0000043D                 jmp     loc_545
.text:00000442 ; ---------------------------------------------------------------------------
.text:00000442
.text:00000442 loc_442:                                ; CODE XREF: NArchive::N7z::CFolderInStream::Read(void *,uint,uint *)+88j
.text:00000442                 cmp     [ebp+var_8], 0
.text:00000446                 jz      short loc_48C
.text:00000448                 mov     edx, [ebp+var_8]
.text:0000044B                 push    edx
.text:0000044C                 mov     edx, [ebp+arg_4]
.text:0000044F                 mov     eax, [ebp+this]
.text:00000452                 mov     ecx, [eax+18h]
.text:00000455                 call    @CrcUpdate@12   ; CrcUpdate(x,x,x)
.text:0000045A                 mov     ecx, [ebp+this]
.text:0000045D                 mov     [ecx+18h], eax
.text:00000460                 mov     edx, [ebp+var_8]
.text:00000463                 xor     eax, eax
.text:00000465                 mov     ecx, [ebp+this]
.text:00000468                 add     edx, [ecx+10h]
.text:0000046B                 adc     eax, [ecx+14h]
.text:0000046E                 mov     ecx, [ebp+this]
.text:00000471                 mov     [ecx+10h], edx
.text:00000474                 mov     [ecx+14h], eax
.text:00000477                 cmp     [ebp+arg_C], 0
.text:0000047B                 jz      short loc_485
.text:0000047D                 mov     edx, [ebp+arg_C]
.text:00000480                 mov     eax, [ebp+var_8]
.text:00000483                 mov     [edx], eax
.text:00000485
.text:00000485 loc_485:                                ; CODE XREF: NArchive::N7z::CFolderInStream::Read(void *,uint,uint *)+CBj
.text:00000485                 xor     eax, eax
.text:00000487                 jmp     loc_545
.text:0000048C ; ---------------------------------------------------------------------------
.text:0000048C
.text:0000048C loc_48C:                                ; CODE XREF: NArchive::N7z::CFolderInStream::Read(void *,uint,uint *)+96j
.text:0000048C                 mov     ecx, [ebp+this]
.text:0000048F                 add     ecx, 0Ch
.text:00000492                 call    ?Release@?$CMyComPtr@UISequentialInStream@@@@QAEXXZ ; CMyComPtr<ISequentialInStream>::Release(void)
.text:00000497                 mov     ecx, [ebp+this]
.text:0000049A                 mov     edx, [ecx+30h]
.text:0000049D                 add     edx, 1
.text:000004A0                 mov     eax, [ebp+this]
.text:000004A3                 mov     [eax+30h], edx
.text:000004A6                 push    1               ; bool
.text:000004A8                 mov     ecx, [ebp+this] ; this
.text:000004AB                 call    ?AddFileInfo@CFolderInStream@N7z@NArchive@@AAEX_N@Z ; NArchive::N7z::CFolderInStream::AddFileInfo(bool)
.text:000004B0                 mov     ecx, [ebp+this]
.text:000004B3                 mov     dword ptr [ecx+10h], 0
.text:000004BA                 mov     dword ptr [ecx+14h], 0
.text:000004C1                 mov     edx, [ebp+this]
.text:000004C4                 mov     dword ptr [edx+18h], 0FFFFFFFFh
.text:000004CB                 mov     eax, [ebp+this]
.text:000004CE                 mov     byte ptr [eax+1Ch], 0
.text:000004D2                 mov     ecx, [ebp+this]
.text:000004D5                 mov     dword ptr [ecx+20h], 0
.text:000004DC                 mov     dword ptr [ecx+24h], 0
.text:000004E3                 mov     ecx, [ebp+this]
.text:000004E6                 add     ecx, 34h ; '4'
.text:000004E9                 call    ??C?$CMyComPtr@UIArchiveUpdateCallback@@@@QBEPAUIArchiveUpdateCallback@@XZ ; CMyComPtr<IArchiveUpdateCallback>::operator->(void)
.text:000004EE                 mov     [ebp+var_20], eax
.text:000004F1                 mov     esi, esp
.text:000004F3                 push    0
.text:000004F5                 mov     edx, [ebp+var_20]
.text:000004F8                 push    edx
.text:000004F9                 mov     eax, [ebp+var_20]
.text:000004FC                 mov     ecx, [eax]
.text:000004FE                 mov     edx, [ecx+20h]
.text:00000501                 call    edx
.text:00000503                 cmp     esi, esp
.text:00000505                 call    __RTC_CheckEsp
.text:0000050A                 mov     [ebp+var_14], eax
.text:0000050D                 cmp     [ebp+var_14], 0
.text:00000511                 jz      short loc_518
.text:00000513                 mov     eax, [ebp+var_14]
.text:00000516                 jmp     short loc_545
.text:00000518 ; ---------------------------------------------------------------------------
.text:00000518
.text:00000518 loc_518:                                ; CODE XREF: NArchive::N7z::CFolderInStream::Read(void *,uint,uint *)+4Aj
.text:00000518                                         ; NArchive::N7z::CFolderInStream::Read(void *,uint,uint *)+161j
.text:00000518                 mov     eax, [ebp+this]
.text:0000051B                 mov     ecx, [ebp+this]
.text:0000051E                 mov     edx, [eax+30h]
.text:00000521                 cmp     edx, [ecx+2Ch]
.text:00000524                 jb      short loc_528
.text:00000526                 jmp     short loc_543
.text:00000528 ; ---------------------------------------------------------------------------
.text:00000528
.text:00000528 loc_528:                                ; CODE XREF: NArchive::N7z::CFolderInStream::Read(void *,uint,uint *)+174j
.text:00000528                 mov     ecx, [ebp+this] ; this
.text:0000052B                 call    ?OpenStream@CFolderInStream@N7z@NArchive@@AAEJXZ ; NArchive::N7z::CFolderInStream::OpenStream(void)
.text:00000530                 mov     [ebp+var_18], eax
.text:00000533                 cmp     [ebp+var_18], 0
.text:00000537                 jz      short loc_53E
.text:00000539                 mov     eax, [ebp+var_18]
.text:0000053C                 jmp     short loc_545
.text:0000053E ; ---------------------------------------------------------------------------
.text:0000053E
.text:0000053E loc_53E:                                ; CODE XREF: NArchive::N7z::CFolderInStream::Read(void *,uint,uint *)+187j
.text:0000053E                 jmp     loc_3E3
.text:00000543 ; ---------------------------------------------------------------------------
.text:00000543
.text:00000543 loc_543:                                ; CODE XREF: NArchive::N7z::CFolderInStream::Read(void *,uint,uint *)+37j
.text:00000543                                         ; NArchive::N7z::CFolderInStream::Read(void *,uint,uint *)+176j
.text:00000543                 xor     eax, eax
.text:00000545
.text:00000545 loc_545:                                ; CODE XREF: NArchive::N7z::CFolderInStream::Read(void *,uint,uint *)+8Dj
.text:00000545                                         ; NArchive::N7z::CFolderInStream::Read(void *,uint,uint *)+D7j ...
.text:00000545                 push    edx
.text:00000546                 mov     ecx, ebp
.text:00000548                 push    eax
.text:00000549                 lea     edx, $LN15
.text:0000054F                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00000554                 pop     eax
.text:00000555                 pop     edx
.text:00000556                 pop     esi
.text:00000557                 add     esp, 20h
.text:0000055A                 cmp     ebp, esp
.text:0000055C                 call    __RTC_CheckEsp
.text:00000561                 mov     esp, ebp
.text:00000563                 pop     ebp
.text:00000564                 retn    10h
.text:00000564 ?Read@CFolderInStream@N7z@NArchive@@UAGJPAXIPAI@Z endp
.text:00000564
.text:00000564 ; ---------------------------------------------------------------------------
.text:00000567                 align 4
.text:00000568 $LN15           dd 1                    ; DATA XREF: NArchive::N7z::CFolderInStream::Read(void *,uint,uint *)+199o
.text:0000056C                 dd offset $LN14_0
.text:00000570 $LN14_0         dd 0FFFFFFF8h, 4        ; DATA XREF: .text:0000056Co
.text:00000578                 dd offset $LN13_0       ; "processed2"
.text:0000057C $LN13_0         db 'processed2',0       ; DATA XREF: .text:00000578o
.text:00000587                 align 10h
.text:00000590
.text:00000590 ; =============== S U B R O U T I N E =======================================
.text:00000590
.text:00000590 ; Attributes: bp-based frame
.text:00000590
.text:00000590 ; __int32 __stdcall NArchive::N7z::CFolderInStream::GetSubStreamSize(NArchive::N7z::CFolderInStream *this, unsigned __int64, unsigned __int64 *)
.text:00000590                 public ?GetSubStreamSize@CFolderInStream@N7z@NArchive@@UAGJ_KPA_K@Z
.text:00000590 ?GetSubStreamSize@CFolderInStream@N7z@NArchive@@UAGJ_KPA_K@Z proc near
.text:00000590
.text:00000590 var_1C          = dword ptr -1Ch
.text:00000590 var_18          = dword ptr -18h
.text:00000590 var_14          = dword ptr -14h
.text:00000590 var_10          = dword ptr -10h
.text:00000590 var_C           = dword ptr -0Ch
.text:00000590 var_8           = dword ptr -8
.text:00000590 var_4           = dword ptr -4
.text:00000590 this            = dword ptr  8
.text:00000590 arg_4           = qword ptr  0Ch
.text:00000590 arg_C           = dword ptr  14h
.text:00000590
.text:00000590                 push    ebp
.text:00000591                 mov     ebp, esp
.text:00000593                 sub     esp, 1Ch
.text:00000596                 mov     eax, 0CCCCCCCCh
.text:0000059B                 mov     [ebp+var_1C], eax
.text:0000059E                 mov     [ebp+var_18], eax
.text:000005A1                 mov     [ebp+var_14], eax
.text:000005A4                 mov     [ebp+var_10], eax
.text:000005A7                 mov     [ebp+var_C], eax
.text:000005AA                 mov     [ebp+var_8], eax
.text:000005AD                 mov     [ebp+var_4], eax
.text:000005B0                 mov     eax, [ebp+arg_C]
.text:000005B3                 mov     dword ptr [eax], 0
.text:000005B9                 mov     dword ptr [eax+4], 0
.text:000005C0                 mov     ecx, [ebp+this]
.text:000005C3                 add     ecx, 4Ch ; 'L'
.text:000005C6                 call    ?Size@?$CRecordVector@_K@@QBEIXZ ; CRecordVector<unsigned __int64>::Size(void)
.text:000005CB                 xor     ecx, ecx
.text:000005CD                 mov     [ebp+var_C], eax
.text:000005D0                 mov     [ebp+var_8], ecx
.text:000005D3                 mov     edx, dword ptr [ebp+arg_4+4]
.text:000005D6                 cmp     edx, [ebp+var_8]
.text:000005D9                 jb      short loc_5EF
.text:000005DB                 ja      short loc_5E5
.text:000005DD                 mov     eax, dword ptr [ebp+arg_4]
.text:000005E0                 cmp     eax, [ebp+var_C]
.text:000005E3                 jbe     short loc_5EF
.text:000005E5
.text:000005E5 loc_5E5:                                ; CODE XREF: NArchive::N7z::CFolderInStream::GetSubStreamSize(unsigned __int64,unsigned __int64 *)+4Bj
.text:000005E5                 mov     eax, 1
.text:000005EA                 jmp     loc_6A2
.text:000005EF ; ---------------------------------------------------------------------------
.text:000005EF
.text:000005EF loc_5EF:                                ; CODE XREF: NArchive::N7z::CFolderInStream::GetSubStreamSize(unsigned __int64,unsigned __int64 *)+49j
.text:000005EF                                         ; NArchive::N7z::CFolderInStream::GetSubStreamSize(unsigned __int64,unsigned __int64 *)+53j
.text:000005EF                 mov     ecx, dword ptr [ebp+arg_4]
.text:000005F2                 mov     [ebp+var_4], ecx
.text:000005F5                 mov     ecx, [ebp+this]
.text:000005F8                 add     ecx, 4Ch ; 'L'
.text:000005FB                 call    ?Size@?$CRecordVector@_K@@QBEIXZ ; CRecordVector<unsigned __int64>::Size(void)
.text:00000600                 cmp     [ebp+var_4], eax
.text:00000603                 jnb     short loc_625
.text:00000605                 mov     edx, [ebp+var_4]
.text:00000608                 push    edx
.text:00000609                 mov     ecx, [ebp+this]
.text:0000060C                 add     ecx, 4Ch ; 'L'
.text:0000060F                 call    ??A?$CRecordVector@_K@@QAEAA_KI@Z ; CRecordVector<unsigned __int64>::operator[](uint)
.text:00000614                 mov     ecx, [ebp+arg_C]
.text:00000617                 mov     edx, [eax]
.text:00000619                 mov     [ecx], edx
.text:0000061B                 mov     eax, [eax+4]
.text:0000061E                 mov     [ecx+4], eax
.text:00000621                 xor     eax, eax
.text:00000623                 jmp     short loc_6A2
.text:00000625 ; ---------------------------------------------------------------------------
.text:00000625
.text:00000625 loc_625:                                ; CODE XREF: NArchive::N7z::CFolderInStream::GetSubStreamSize(unsigned __int64,unsigned __int64 *)+73j
.text:00000625                 mov     ecx, [ebp+this]
.text:00000628                 movzx   edx, byte ptr [ecx+18h]
.text:0000062C                 test    edx, edx
.text:0000062E                 jnz     short loc_648
.text:00000630                 mov     eax, [ebp+arg_C]
.text:00000633                 mov     ecx, [ebp+this]
.text:00000636                 mov     edx, [ecx+0Ch]
.text:00000639                 mov     [eax], edx
.text:0000063B                 mov     ecx, [ecx+10h]
.text:0000063E                 mov     [eax+4], ecx
.text:00000641                 mov     eax, 1
.text:00000646                 jmp     short loc_6A2
.text:00000648 ; ---------------------------------------------------------------------------
.text:00000648
.text:00000648 loc_648:                                ; CODE XREF: NArchive::N7z::CFolderInStream::GetSubStreamSize(unsigned __int64,unsigned __int64 *)+9Ej
.text:00000648                 mov     edx, [ebp+this]
.text:0000064B                 mov     eax, [ebp+this]
.text:0000064E                 mov     [ebp+var_10], edx
.text:00000651                 mov     [ebp+var_14], eax
.text:00000654                 mov     ecx, [ebp+var_10]
.text:00000657                 mov     edx, [ebp+var_14]
.text:0000065A                 mov     eax, [ecx+10h]
.text:0000065D                 cmp     eax, [edx+20h]
.text:00000660                 jb      short loc_683
.text:00000662                 ja      short loc_672
.text:00000664                 mov     ecx, [ebp+var_10]
.text:00000667                 mov     edx, [ebp+var_14]
.text:0000066A                 mov     eax, [ecx+0Ch]
.text:0000066D                 cmp     eax, [edx+1Ch]
.text:00000670                 jbe     short loc_683
.text:00000672
.text:00000672 loc_672:                                ; CODE XREF: NArchive::N7z::CFolderInStream::GetSubStreamSize(unsigned __int64,unsigned __int64 *)+D2j
.text:00000672                 mov     ecx, [ebp+this]
.text:00000675                 mov     edx, [ecx+0Ch]
.text:00000678                 mov     [ebp+var_1C], edx
.text:0000067B                 mov     eax, [ecx+10h]
.text:0000067E                 mov     [ebp+var_18], eax
.text:00000681                 jmp     short loc_692
.text:00000683 ; ---------------------------------------------------------------------------
.text:00000683
.text:00000683 loc_683:                                ; CODE XREF: NArchive::N7z::CFolderInStream::GetSubStreamSize(unsigned __int64,unsigned __int64 *)+D0j
.text:00000683                                         ; NArchive::N7z::CFolderInStream::GetSubStreamSize(unsigned __int64,unsigned __int64 *)+E0j
.text:00000683                 mov     ecx, [ebp+this]
.text:00000686                 mov     edx, [ecx+1Ch]
.text:00000689                 mov     [ebp+var_1C], edx
.text:0000068C                 mov     eax, [ecx+20h]
.text:0000068F                 mov     [ebp+var_18], eax
.text:00000692
.text:00000692 loc_692:                                ; CODE XREF: NArchive::N7z::CFolderInStream::GetSubStreamSize(unsigned __int64,unsigned __int64 *)+F1j
.text:00000692                 mov     ecx, [ebp+arg_C]
.text:00000695                 mov     edx, [ebp+var_1C]
.text:00000698                 mov     [ecx], edx
.text:0000069A                 mov     eax, [ebp+var_18]
.text:0000069D                 mov     [ecx+4], eax
.text:000006A0                 xor     eax, eax
.text:000006A2
.text:000006A2 loc_6A2:                                ; CODE XREF: NArchive::N7z::CFolderInStream::GetSubStreamSize(unsigned __int64,unsigned __int64 *)+5Aj
.text:000006A2                                         ; NArchive::N7z::CFolderInStream::GetSubStreamSize(unsigned __int64,unsigned __int64 *)+93j ...
.text:000006A2                 add     esp, 1Ch
.text:000006A5                 cmp     ebp, esp
.text:000006A7                 call    __RTC_CheckEsp
.text:000006AC                 mov     esp, ebp
.text:000006AE                 pop     ebp
.text:000006AF                 retn    10h
.text:000006AF ?GetSubStreamSize@CFolderInStream@N7z@NArchive@@UAGJ_KPA_K@Z endp
.text:000006AF
.text:000006AF ; ---------------------------------------------------------------------------
.text:000006B2                 align 4
.text:000006B2 _text           ends
.text:000006B2
.rtc$TMZ:000006B4 ; ===========================================================================
.rtc$TMZ:000006B4
.rtc$TMZ:000006B4 ; Segment type: Pure data
.rtc$TMZ:000006B4 ; Segment permissions: Read
.rtc$TMZ:000006B4 _rtc$TMZ        segment dword public 'DATA' use32
.rtc$TMZ:000006B4                 assume cs:_rtc$TMZ
.rtc$TMZ:000006B4                 ;org 6B4h
.rtc$TMZ:000006B4 ; COMDAT (pick any)
.rtc$TMZ:000006B4 __RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
.rtc$TMZ:000006B4 _rtc$TMZ        ends
.rtc$TMZ:000006B4
.rtc$IMZ:000006B8 ; ===========================================================================
.rtc$IMZ:000006B8
.rtc$IMZ:000006B8 ; Segment type: Pure data
.rtc$IMZ:000006B8 ; Segment permissions: Read
.rtc$IMZ:000006B8 _rtc$IMZ        segment dword public 'DATA' use32
.rtc$IMZ:000006B8                 assume cs:_rtc$IMZ
.rtc$IMZ:000006B8                 ;org 6B8h
.rtc$IMZ:000006B8 ; COMDAT (pick any)
.rtc$IMZ:000006B8 __RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
.rtc$IMZ:000006B8 _rtc$IMZ        ends
.rtc$IMZ:000006B8
.text$x:000006BC ; ===========================================================================
.text$x:000006BC
.text$x:000006BC ; Segment type: Pure code
.text$x:000006BC ; Segment permissions: Read/Execute
.text$x:000006BC _text$x         segment para public 'CODE' use32
.text$x:000006BC                 assume cs:_text$x
.text$x:000006BC                 ;org 6BCh
.text$x:000006BC                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text$x:000006BC
.text$x:000006BC ; =============== S U B R O U T I N E =======================================
.text$x:000006BC
.text$x:000006BC
.text$x:000006BC __unwindfunclet$?OpenStream@CFolderInStream@N7z@NArchive@@AAEJXZ$0 proc near
.text$x:000006BC                                         ; DATA XREF: .xdata$x:000006ECo
.text$x:000006BC                 lea     ecx, [ebp-18h]
.text$x:000006BF                 jmp     ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ ; CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)
.text$x:000006BF __unwindfunclet$?OpenStream@CFolderInStream@N7z@NArchive@@AAEJXZ$0 endp
.text$x:000006BF
.text$x:000006C4
.text$x:000006C4 ; =============== S U B R O U T I N E =======================================
.text$x:000006C4
.text$x:000006C4
.text$x:000006C4 __unwindfunclet$?OpenStream@CFolderInStream@N7z@NArchive@@AAEJXZ$1 proc near
.text$x:000006C4                                         ; DATA XREF: .xdata$x:000006F4o
.text$x:000006C4                 lea     ecx, [ebp-28h]
.text$x:000006C7                 jmp     ??1?$CMyComPtr@UIStreamGetSize@@@@QAE@XZ ; CMyComPtr<IStreamGetSize>::~CMyComPtr<IStreamGetSize>(void)
.text$x:000006C7 __unwindfunclet$?OpenStream@CFolderInStream@N7z@NArchive@@AAEJXZ$1 endp
.text$x:000006C7
.text$x:000006CC
.text$x:000006CC ; =============== S U B R O U T I N E =======================================
.text$x:000006CC
.text$x:000006CC
.text$x:000006CC __ehhandler$?OpenStream@CFolderInStream@N7z@NArchive@@AAEJXZ proc near
.text$x:000006CC                                         ; DATA XREF: NArchive::N7z::CFolderInStream::OpenStream(void)+5o
.text$x:000006CC
.text$x:000006CC arg_4           = dword ptr  8
.text$x:000006CC
.text$x:000006CC                 mov     edx, [esp+arg_4]
.text$x:000006D0                 lea     eax, [edx+0Ch]
.text$x:000006D3                 mov     ecx, [edx-48h]
.text$x:000006D6                 xor     ecx, eax
.text$x:000006D8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000006DD                 mov     eax, offset __ehfuncinfo$?OpenStream@CFolderInStream@N7z@NArchive@@AAEJXZ
.text$x:000006E2                 jmp     ___CxxFrameHandler3
.text$x:000006E2 __ehhandler$?OpenStream@CFolderInStream@N7z@NArchive@@AAEJXZ endp
.text$x:000006E2
.text$x:000006E2 ; ---------------------------------------------------------------------------
.text$x:000006E7                 align 4
.text$x:000006E7 _text$x         ends
.text$x:000006E7
.xdata$x:000006E8 ; ===========================================================================
.xdata$x:000006E8
.xdata$x:000006E8 ; Segment type: Pure data
.xdata$x:000006E8 ; Segment permissions: Read
.xdata$x:000006E8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000006E8                 assume cs:_xdata$x
.xdata$x:000006E8                 ;org 6E8h
.xdata$x:000006E8 __unwindtable$?OpenStream@CFolderInStream@N7z@NArchive@@AAEJXZ db 0FFh
.xdata$x:000006E8                                         ; DATA XREF: .xdata$x:00000700o
.xdata$x:000006E9                 db 0FFh
.xdata$x:000006EA                 db 0FFh
.xdata$x:000006EB                 db 0FFh
.xdata$x:000006EC                 dd offset __unwindfunclet$?OpenStream@CFolderInStream@N7z@NArchive@@AAEJXZ$0
.xdata$x:000006F0                 db    0
.xdata$x:000006F1                 db    0
.xdata$x:000006F2                 db    0
.xdata$x:000006F3                 db    0
.xdata$x:000006F4                 dd offset __unwindfunclet$?OpenStream@CFolderInStream@N7z@NArchive@@AAEJXZ$1
.xdata$x:000006F8 __ehfuncinfo$?OpenStream@CFolderInStream@N7z@NArchive@@AAEJXZ db  22h ; "
.xdata$x:000006F8                                         ; DATA XREF: __ehhandler$?OpenStream@CFolderInStream@N7z@NArchive@@AAEJXZ+11o
.xdata$x:000006F9                 db    5
.xdata$x:000006FA                 db  93h ; ô
.xdata$x:000006FB                 db  19h
.xdata$x:000006FC                 db    2
.xdata$x:000006FD                 db    0
.xdata$x:000006FE                 db    0
.xdata$x:000006FF                 db    0
.xdata$x:00000700                 dd offset __unwindtable$?OpenStream@CFolderInStream@N7z@NArchive@@AAEJXZ
.xdata$x:00000704                 db    0
.xdata$x:00000705                 db    0
.xdata$x:00000706                 db    0
.xdata$x:00000707                 db    0
.xdata$x:00000708                 db    0
.xdata$x:00000709                 db    0
.xdata$x:0000070A                 db    0
.xdata$x:0000070B                 db    0
.xdata$x:0000070C                 db    0
.xdata$x:0000070D                 db    0
.xdata$x:0000070E                 db    0
.xdata$x:0000070F                 db    0
.xdata$x:00000710                 db    0
.xdata$x:00000711                 db    0
.xdata$x:00000712                 db    0
.xdata$x:00000713                 db    0
.xdata$x:00000714                 db    0
.xdata$x:00000715                 db    0
.xdata$x:00000716                 db    0
.xdata$x:00000717                 db    0
.xdata$x:00000718                 db    1
.xdata$x:00000719                 db    0
.xdata$x:0000071A                 db    0
.xdata$x:0000071B                 db    0
.xdata$x:0000071B _xdata$x        ends
.xdata$x:0000071B
.text:0000071C ; ===========================================================================
.text:0000071C
.text:0000071C ; Segment type: Pure code
.text:0000071C ; Segment permissions: Read/Execute
.text:0000071C _text           segment para public 'CODE' use32
.text:0000071C                 assume cs:_text
.text:0000071C                 ;org 71Ch
.text:0000071C ; COMDAT (pick any)
.text:0000071C                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:0000071C
.text:0000071C ; =============== S U B R O U T I N E =======================================
.text:0000071C
.text:0000071C ; Attributes: bp-based frame
.text:0000071C
.text:0000071C ; public: __thiscall CMyComPtr<struct ISequentialInStream>::CMyComPtr<struct ISequentialInStream>(void)
.text:0000071C                 public ??0?$CMyComPtr@UISequentialInStream@@@@QAE@XZ
.text:0000071C ??0?$CMyComPtr@UISequentialInStream@@@@QAE@XZ proc near
.text:0000071C                                         ; CODE XREF: NArchive::N7z::CFolderInStream::OpenStream(void)+83p
.text:0000071C
.text:0000071C var_4           = dword ptr -4
.text:0000071C
.text:0000071C                 push    ebp
.text:0000071D                 mov     ebp, esp
.text:0000071F                 push    ecx
.text:00000720                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000727                 mov     [ebp+var_4], ecx
.text:0000072A                 mov     eax, [ebp+var_4]
.text:0000072D                 mov     dword ptr [eax], 0
.text:00000733                 mov     eax, [ebp+var_4]
.text:00000736                 mov     esp, ebp
.text:00000738                 pop     ebp
.text:00000739                 retn
.text:00000739 ??0?$CMyComPtr@UISequentialInStream@@@@QAE@XZ endp
.text:00000739
.text:00000739 ; ---------------------------------------------------------------------------
.text:0000073A                 align 4
.text:0000073A _text           ends
.text:0000073A
.text:0000073C ; ===========================================================================
.text:0000073C
.text:0000073C ; Segment type: Pure code
.text:0000073C ; Segment permissions: Read/Execute
.text:0000073C _text           segment para public 'CODE' use32
.text:0000073C                 assume cs:_text
.text:0000073C                 ;org 73Ch
.text:0000073C ; COMDAT (pick any)
.text:0000073C                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:0000073C
.text:0000073C ; =============== S U B R O U T I N E =======================================
.text:0000073C
.text:0000073C ; Attributes: bp-based frame
.text:0000073C
.text:0000073C ; public: __thiscall CMyComPtr<struct ISequentialInStream>::~CMyComPtr<struct ISequentialInStream>(void)
.text:0000073C                 public ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ
.text:0000073C ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ proc near
.text:0000073C                                         ; CODE XREF: NArchive::N7z::CFolderInStream::OpenStream(void)+ECp
.text:0000073C                                         ; NArchive::N7z::CFolderInStream::OpenStream(void)+197p ...
.text:0000073C
.text:0000073C var_4           = dword ptr -4
.text:0000073C
.text:0000073C                 push    ebp
.text:0000073D                 mov     ebp, esp
.text:0000073F                 push    ecx
.text:00000740                 push    esi
.text:00000741                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000748                 mov     [ebp+var_4], ecx
.text:0000074B                 mov     eax, [ebp+var_4]
.text:0000074E                 cmp     dword ptr [eax], 0
.text:00000751                 jz      short loc_76E
.text:00000753                 mov     ecx, [ebp+var_4]
.text:00000756                 mov     edx, [ecx]
.text:00000758                 mov     eax, [ebp+var_4]
.text:0000075B                 mov     ecx, [eax]
.text:0000075D                 mov     edx, [edx]
.text:0000075F                 mov     esi, esp
.text:00000761                 push    ecx
.text:00000762                 mov     eax, [edx+8]
.text:00000765                 call    eax
.text:00000767                 cmp     esi, esp
.text:00000769                 call    __RTC_CheckEsp
.text:0000076E
.text:0000076E loc_76E:                                ; CODE XREF: CMyComPtr<ISequentialInStream>::~CMyComPtr<ISequentialInStream>(void)+15j
.text:0000076E                 pop     esi
.text:0000076F                 add     esp, 4
.text:00000772                 cmp     ebp, esp
.text:00000774                 call    __RTC_CheckEsp
.text:00000779                 mov     esp, ebp
.text:0000077B                 pop     ebp
.text:0000077C                 retn
.text:0000077C ??1?$CMyComPtr@UISequentialInStream@@@@QAE@XZ endp
.text:0000077C
.text:0000077C ; ---------------------------------------------------------------------------
.text:0000077D                 align 10h
.text:0000077D _text           ends
.text:0000077D
.text:00000780 ; ===========================================================================
.text:00000780
.text:00000780 ; Segment type: Pure code
.text:00000780 ; Segment permissions: Read/Execute
.text:00000780 _text           segment para public 'CODE' use32
.text:00000780                 assume cs:_text
.text:00000780                 ;org 780h
.text:00000780 ; COMDAT (pick any)
.text:00000780                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000780
.text:00000780 ; =============== S U B R O U T I N E =======================================
.text:00000780
.text:00000780 ; Attributes: bp-based frame
.text:00000780
.text:00000780 ; public: void __thiscall CMyComPtr<struct ISequentialInStream>::Release(void)
.text:00000780                 public ?Release@?$CMyComPtr@UISequentialInStream@@@@QAEXXZ
.text:00000780 ?Release@?$CMyComPtr@UISequentialInStream@@@@QAEXXZ proc near
.text:00000780                                         ; CODE XREF: NArchive::N7z::CFolderInStream::Init(IArchiveUpdateCallback *,uint const *,uint)+9Fp
.text:00000780                                         ; NArchive::N7z::CFolderInStream::Read(void *,uint,uint *)+E2p
.text:00000780
.text:00000780 var_4           = dword ptr -4
.text:00000780
.text:00000780                 push    ebp
.text:00000781                 mov     ebp, esp
.text:00000783                 push    ecx
.text:00000784                 push    esi
.text:00000785                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000078C                 mov     [ebp+var_4], ecx
.text:0000078F                 mov     eax, [ebp+var_4]
.text:00000792                 cmp     dword ptr [eax], 0
.text:00000795                 jz      short loc_7BB
.text:00000797                 mov     ecx, [ebp+var_4]
.text:0000079A                 mov     edx, [ecx]
.text:0000079C                 mov     eax, [ebp+var_4]
.text:0000079F                 mov     ecx, [eax]
.text:000007A1                 mov     edx, [edx]
.text:000007A3                 mov     esi, esp
.text:000007A5                 push    ecx
.text:000007A6                 mov     eax, [edx+8]
.text:000007A9                 call    eax
.text:000007AB                 cmp     esi, esp
.text:000007AD                 call    __RTC_CheckEsp
.text:000007B2                 mov     ecx, [ebp+var_4]
.text:000007B5                 mov     dword ptr [ecx], 0
.text:000007BB
.text:000007BB loc_7BB:                                ; CODE XREF: CMyComPtr<ISequentialInStream>::Release(void)+15j
.text:000007BB                 pop     esi
.text:000007BC                 add     esp, 4
.text:000007BF                 cmp     ebp, esp
.text:000007C1                 call    __RTC_CheckEsp
.text:000007C6                 mov     esp, ebp
.text:000007C8                 pop     ebp
.text:000007C9                 retn
.text:000007C9 ?Release@?$CMyComPtr@UISequentialInStream@@@@QAEXXZ endp
.text:000007C9
.text:000007C9 ; ---------------------------------------------------------------------------
.text:000007CA                 align 4
.text:000007CA _text           ends
.text:000007CA
.text:000007CC ; ===========================================================================
.text:000007CC
.text:000007CC ; Segment type: Pure code
.text:000007CC ; Segment permissions: Read/Execute
.text:000007CC _text           segment para public 'CODE' use32
.text:000007CC                 assume cs:_text
.text:000007CC                 ;org 7CCh
.text:000007CC ; COMDAT (pick any)
.text:000007CC                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000007CC
.text:000007CC ; =============== S U B R O U T I N E =======================================
.text:000007CC
.text:000007CC ; Attributes: bp-based frame
.text:000007CC
.text:000007CC ; public: __thiscall CMyComPtr<struct ISequentialInStream>::operator struct ISequentialInStream *(void)const
.text:000007CC                 public ??B?$CMyComPtr@UISequentialInStream@@@@QBEPAUISequentialInStream@@XZ
.text:000007CC ??B?$CMyComPtr@UISequentialInStream@@@@QBEPAUISequentialInStream@@XZ proc near
.text:000007CC                                         ; CODE XREF: NArchive::N7z::CFolderInStream::OpenStream(void)+10Bp
.text:000007CC                                         ; NArchive::N7z::CFolderInStream::Read(void *,uint,uint *)+43p
.text:000007CC
.text:000007CC var_4           = dword ptr -4
.text:000007CC
.text:000007CC                 push    ebp
.text:000007CD                 mov     ebp, esp
.text:000007CF                 push    ecx
.text:000007D0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000007D7                 mov     [ebp+var_4], ecx
.text:000007DA                 mov     eax, [ebp+var_4]
.text:000007DD                 mov     eax, [eax]
.text:000007DF                 mov     esp, ebp
.text:000007E1                 pop     ebp
.text:000007E2                 retn
.text:000007E2 ??B?$CMyComPtr@UISequentialInStream@@@@QBEPAUISequentialInStream@@XZ endp
.text:000007E2
.text:000007E2 ; ---------------------------------------------------------------------------
.text:000007E3                 align 4
.text:000007E3 _text           ends
.text:000007E3
.text:000007E4 ; ===========================================================================
.text:000007E4
.text:000007E4 ; Segment type: Pure code
.text:000007E4 ; Segment permissions: Read/Execute
.text:000007E4 _text           segment para public 'CODE' use32
.text:000007E4                 assume cs:_text
.text:000007E4                 ;org 7E4h
.text:000007E4 ; COMDAT (pick any)
.text:000007E4                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000007E4
.text:000007E4 ; =============== S U B R O U T I N E =======================================
.text:000007E4
.text:000007E4 ; Attributes: bp-based frame
.text:000007E4
.text:000007E4 ; public: struct ISequentialInStream * * __thiscall CMyComPtr<struct ISequentialInStream>::operator&(void)
.text:000007E4                 public ??I?$CMyComPtr@UISequentialInStream@@@@QAEPAPAUISequentialInStream@@XZ
.text:000007E4 ??I?$CMyComPtr@UISequentialInStream@@@@QAEPAPAUISequentialInStream@@XZ proc near
.text:000007E4                                         ; CODE XREF: NArchive::N7z::CFolderInStream::OpenStream(void)+A0p
.text:000007E4
.text:000007E4 var_4           = dword ptr -4
.text:000007E4
.text:000007E4                 push    ebp
.text:000007E5                 mov     ebp, esp
.text:000007E7                 push    ecx
.text:000007E8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000007EF                 mov     [ebp+var_4], ecx
.text:000007F2                 mov     eax, [ebp+var_4]
.text:000007F5                 mov     esp, ebp
.text:000007F7                 pop     ebp
.text:000007F8                 retn
.text:000007F8 ??I?$CMyComPtr@UISequentialInStream@@@@QAEPAPAUISequentialInStream@@XZ endp
.text:000007F8
.text:000007F8 ; ---------------------------------------------------------------------------
.text:000007F9                 align 4
.text:000007F9 _text           ends
.text:000007F9
.text:000007FC ; ===========================================================================
.text:000007FC
.text:000007FC ; Segment type: Pure code
.text:000007FC ; Segment permissions: Read/Execute
.text:000007FC _text           segment para public 'CODE' use32
.text:000007FC                 assume cs:_text
.text:000007FC                 ;org 7FCh
.text:000007FC ; COMDAT (pick any)
.text:000007FC                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000007FC
.text:000007FC ; =============== S U B R O U T I N E =======================================
.text:000007FC
.text:000007FC ; Attributes: bp-based frame
.text:000007FC
.text:000007FC ; public: struct ISequentialInStream * __thiscall CMyComPtr<struct ISequentialInStream>::operator->(void)const
.text:000007FC                 public ??C?$CMyComPtr@UISequentialInStream@@@@QBEPAUISequentialInStream@@XZ
.text:000007FC ??C?$CMyComPtr@UISequentialInStream@@@@QBEPAUISequentialInStream@@XZ proc near
.text:000007FC                                         ; CODE XREF: NArchive::N7z::CFolderInStream::Read(void *,uint,uint *)+56p
.text:000007FC
.text:000007FC var_4           = dword ptr -4
.text:000007FC
.text:000007FC                 push    ebp
.text:000007FD                 mov     ebp, esp
.text:000007FF                 push    ecx
.text:00000800                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000807                 mov     [ebp+var_4], ecx
.text:0000080A                 mov     eax, [ebp+var_4]
.text:0000080D                 mov     eax, [eax]
.text:0000080F                 mov     esp, ebp
.text:00000811                 pop     ebp
.text:00000812                 retn
.text:00000812 ??C?$CMyComPtr@UISequentialInStream@@@@QBEPAUISequentialInStream@@XZ endp
.text:00000812
.text:00000812 ; ---------------------------------------------------------------------------
.text:00000813                 align 4
.text:00000813 _text           ends
.text:00000813
.text:00000814 ; ===========================================================================
.text:00000814
.text:00000814 ; Segment type: Pure code
.text:00000814 ; Segment permissions: Read/Execute
.text:00000814 _text           segment para public 'CODE' use32
.text:00000814                 assume cs:_text
.text:00000814                 ;org 814h
.text:00000814 ; COMDAT (pick any)
.text:00000814                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000814
.text:00000814 ; =============== S U B R O U T I N E =======================================
.text:00000814
.text:00000814 ; Attributes: bp-based frame
.text:00000814
.text:00000814 ; public: struct ISequentialInStream * __thiscall CMyComPtr<struct ISequentialInStream>::operator=(class CMyComPtr<struct ISequentialInStream> const &)
.text:00000814                 public ??4?$CMyComPtr@UISequentialInStream@@@@QAEPAUISequentialInStream@@ABV0@@Z
.text:00000814 ??4?$CMyComPtr@UISequentialInStream@@@@QAEPAUISequentialInStream@@ABV0@@Z proc near
.text:00000814                                         ; CODE XREF: NArchive::N7z::CFolderInStream::OpenStream(void)+103p
.text:00000814
.text:00000814 var_4           = dword ptr -4
.text:00000814 arg_0           = dword ptr  8
.text:00000814
.text:00000814                 push    ebp
.text:00000815                 mov     ebp, esp
.text:00000817                 push    ecx
.text:00000818                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000081F                 mov     [ebp+var_4], ecx
.text:00000822                 mov     eax, [ebp+arg_0]
.text:00000825                 mov     ecx, [eax]
.text:00000827                 push    ecx
.text:00000828                 mov     ecx, [ebp+var_4]
.text:0000082B                 call    ??4?$CMyComPtr@UISequentialInStream@@@@QAEPAUISequentialInStream@@PAU1@@Z ; CMyComPtr<ISequentialInStream>::operator=(ISequentialInStream *)
.text:00000830                 add     esp, 4
.text:00000833                 cmp     ebp, esp
.text:00000835                 call    __RTC_CheckEsp
.text:0000083A                 mov     esp, ebp
.text:0000083C                 pop     ebp
.text:0000083D                 retn    4
.text:0000083D ??4?$CMyComPtr@UISequentialInStream@@@@QAEPAUISequentialInStream@@ABV0@@Z endp
.text:0000083D
.text:0000083D _text           ends
.text:0000083D
.text:00000840 ; ===========================================================================
.text:00000840
.text:00000840 ; Segment type: Pure code
.text:00000840 ; Segment permissions: Read/Execute
.text:00000840 _text           segment para public 'CODE' use32
.text:00000840                 assume cs:_text
.text:00000840                 ;org 840h
.text:00000840 ; COMDAT (pick any)
.text:00000840                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000840
.text:00000840 ; =============== S U B R O U T I N E =======================================
.text:00000840
.text:00000840 ; Attributes: bp-based frame
.text:00000840
.text:00000840 ; public: struct IArchiveUpdateCallback * __thiscall CMyComPtr<struct IArchiveUpdateCallback>::operator->(void)const
.text:00000840                 public ??C?$CMyComPtr@UIArchiveUpdateCallback@@@@QBEPAUIArchiveUpdateCallback@@XZ
.text:00000840 ??C?$CMyComPtr@UIArchiveUpdateCallback@@@@QBEPAUIArchiveUpdateCallback@@XZ proc near
.text:00000840                                         ; CODE XREF: NArchive::N7z::CFolderInStream::OpenStream(void)+95p
.text:00000840                                         ; NArchive::N7z::CFolderInStream::OpenStream(void)+1B9p ...
.text:00000840
.text:00000840 var_4           = dword ptr -4
.text:00000840
.text:00000840                 push    ebp
.text:00000841                 mov     ebp, esp
.text:00000843                 push    ecx
.text:00000844                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000084B                 mov     [ebp+var_4], ecx
.text:0000084E                 mov     eax, [ebp+var_4]
.text:00000851                 mov     eax, [eax]
.text:00000853                 mov     esp, ebp
.text:00000855                 pop     ebp
.text:00000856                 retn
.text:00000856 ??C?$CMyComPtr@UIArchiveUpdateCallback@@@@QBEPAUIArchiveUpdateCallback@@XZ endp
.text:00000856
.text:00000856 ; ---------------------------------------------------------------------------
.text:00000857                 align 4
.text:00000857 _text           ends
.text:00000857
.text:00000858 ; ===========================================================================
.text:00000858
.text:00000858 ; Segment type: Pure code
.text:00000858 ; Segment permissions: Read/Execute
.text:00000858 _text           segment para public 'CODE' use32
.text:00000858                 assume cs:_text
.text:00000858                 ;org 858h
.text:00000858 ; COMDAT (pick any)
.text:00000858                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000858
.text:00000858 ; =============== S U B R O U T I N E =======================================
.text:00000858
.text:00000858 ; Attributes: bp-based frame
.text:00000858
.text:00000858 ; public: struct IArchiveUpdateCallback * __thiscall CMyComPtr<struct IArchiveUpdateCallback>::operator=(struct IArchiveUpdateCallback *)
.text:00000858                 public ??4?$CMyComPtr@UIArchiveUpdateCallback@@@@QAEPAUIArchiveUpdateCallback@@PAU1@@Z
.text:00000858 ??4?$CMyComPtr@UIArchiveUpdateCallback@@@@QAEPAUIArchiveUpdateCallback@@PAU1@@Z proc near
.text:00000858                                         ; CODE XREF: NArchive::N7z::CFolderInStream::Init(IArchiveUpdateCallback *,uint const *,uint)+18p
.text:00000858
.text:00000858 var_4           = dword ptr -4
.text:00000858 arg_0           = dword ptr  8
.text:00000858
.text:00000858                 push    ebp
.text:00000859                 mov     ebp, esp
.text:0000085B                 push    ecx
.text:0000085C                 push    esi
.text:0000085D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000864                 mov     [ebp+var_4], ecx
.text:00000867                 cmp     [ebp+arg_0], 0
.text:0000086B                 jz      short loc_884
.text:0000086D                 mov     eax, [ebp+arg_0]
.text:00000870                 mov     ecx, [eax]
.text:00000872                 mov     esi, esp
.text:00000874                 mov     edx, [ebp+arg_0]
.text:00000877                 push    edx
.text:00000878                 mov     eax, [ecx+4]
.text:0000087B                 call    eax
.text:0000087D                 cmp     esi, esp
.text:0000087F                 call    __RTC_CheckEsp
.text:00000884
.text:00000884 loc_884:                                ; CODE XREF: CMyComPtr<IArchiveUpdateCallback>::operator=(IArchiveUpdateCallback *)+13j
.text:00000884                 mov     ecx, [ebp+var_4]
.text:00000887                 cmp     dword ptr [ecx], 0
.text:0000088A                 jz      short loc_8A7
.text:0000088C                 mov     edx, [ebp+var_4]
.text:0000088F                 mov     eax, [edx]
.text:00000891                 mov     ecx, [ebp+var_4]
.text:00000894                 mov     edx, [ecx]
.text:00000896                 mov     eax, [eax]
.text:00000898                 mov     esi, esp
.text:0000089A                 push    edx
.text:0000089B                 mov     ecx, [eax+8]
.text:0000089E                 call    ecx
.text:000008A0                 cmp     esi, esp
.text:000008A2                 call    __RTC_CheckEsp
.text:000008A7
.text:000008A7 loc_8A7:                                ; CODE XREF: CMyComPtr<IArchiveUpdateCallback>::operator=(IArchiveUpdateCallback *)+32j
.text:000008A7                 mov     edx, [ebp+var_4]
.text:000008AA                 mov     eax, [ebp+arg_0]
.text:000008AD                 mov     [edx], eax
.text:000008AF                 mov     eax, [ebp+arg_0]
.text:000008B2                 pop     esi
.text:000008B3                 add     esp, 4
.text:000008B6                 cmp     ebp, esp
.text:000008B8                 call    __RTC_CheckEsp
.text:000008BD                 mov     esp, ebp
.text:000008BF                 pop     ebp
.text:000008C0                 retn    4
.text:000008C0 ??4?$CMyComPtr@UIArchiveUpdateCallback@@@@QAEPAUIArchiveUpdateCallback@@PAU1@@Z endp
.text:000008C0
.text:000008C0 ; ---------------------------------------------------------------------------
.text:000008C3                 align 4
.text:000008C3 _text           ends
.text:000008C3
.text:000008C4 ; ===========================================================================
.text:000008C4
.text:000008C4 ; Segment type: Pure code
.text:000008C4 ; Segment permissions: Read/Execute
.text:000008C4 _text           segment para public 'CODE' use32
.text:000008C4                 assume cs:_text
.text:000008C4                 ;org 8C4h
.text:000008C4 ; COMDAT (pick any)
.text:000008C4                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000008C4
.text:000008C4 ; =============== S U B R O U T I N E =======================================
.text:000008C4
.text:000008C4 ; Attributes: bp-based frame
.text:000008C4
.text:000008C4 ; public: void __thiscall CRecordVector<bool>::ClearAndReserve(unsigned int)
.text:000008C4                 public ?ClearAndReserve@?$CRecordVector@_N@@QAEXI@Z
.text:000008C4 ?ClearAndReserve@?$CRecordVector@_N@@QAEXI@Z proc near
.text:000008C4                                         ; CODE XREF: NArchive::N7z::CFolderInStream::Init(IArchiveUpdateCallback *,uint const *,uint)+43p
.text:000008C4
.text:000008C4 var_C           = dword ptr -0Ch
.text:000008C4 var_8           = dword ptr -8
.text:000008C4 var_4           = dword ptr -4
.text:000008C4 arg_0           = dword ptr  8
.text:000008C4
.text:000008C4                 push    ebp
.text:000008C5                 mov     ebp, esp
.text:000008C7                 sub     esp, 0Ch
.text:000008CA                 mov     [ebp+var_C], 0CCCCCCCCh
.text:000008D1                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000008D8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000008DF                 mov     [ebp+var_4], ecx
.text:000008E2                 mov     ecx, [ebp+var_4]
.text:000008E5                 call    ?Clear@?$CRecordVector@_N@@QAEXXZ ; CRecordVector<bool>::Clear(void)
.text:000008EA                 mov     eax, [ebp+var_4]
.text:000008ED                 mov     ecx, [ebp+arg_0]
.text:000008F0                 cmp     ecx, [eax+8]
.text:000008F3                 jbe     short loc_93C
.text:000008F5                 mov     edx, [ebp+var_4]
.text:000008F8                 mov     eax, [edx]
.text:000008FA                 mov     [ebp+var_8], eax
.text:000008FD                 mov     ecx, [ebp+var_8]
.text:00000900                 push    ecx             ; void *
.text:00000901                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00000906                 add     esp, 4
.text:00000909                 mov     edx, [ebp+var_4]
.text:0000090C                 mov     dword ptr [edx], 0
.text:00000912                 mov     eax, [ebp+var_4]
.text:00000915                 mov     dword ptr [eax+8], 0
.text:0000091C                 mov     ecx, [ebp+arg_0]
.text:0000091F                 push    ecx             ; unsigned int
.text:00000920                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00000925                 add     esp, 4
.text:00000928                 mov     [ebp+var_C], eax
.text:0000092B                 mov     edx, [ebp+var_4]
.text:0000092E                 mov     eax, [ebp+var_C]
.text:00000931                 mov     [edx], eax
.text:00000933                 mov     ecx, [ebp+var_4]
.text:00000936                 mov     edx, [ebp+arg_0]
.text:00000939                 mov     [ecx+8], edx
.text:0000093C
.text:0000093C loc_93C:                                ; CODE XREF: CRecordVector<bool>::ClearAndReserve(uint)+2Fj
.text:0000093C                 add     esp, 0Ch
.text:0000093F                 cmp     ebp, esp
.text:00000941                 call    __RTC_CheckEsp
.text:00000946                 mov     esp, ebp
.text:00000948                 pop     ebp
.text:00000949                 retn    4
.text:00000949 ?ClearAndReserve@?$CRecordVector@_N@@QAEXI@Z endp
.text:00000949
.text:00000949 _text           ends
.text:00000949
.text:0000094C ; ===========================================================================
.text:0000094C
.text:0000094C ; Segment type: Pure code
.text:0000094C ; Segment permissions: Read/Execute
.text:0000094C _text           segment para public 'CODE' use32
.text:0000094C                 assume cs:_text
.text:0000094C                 ;org 94Ch
.text:0000094C ; COMDAT (pick any)
.text:0000094C                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:0000094C
.text:0000094C ; =============== S U B R O U T I N E =======================================
.text:0000094C
.text:0000094C ; Attributes: bp-based frame
.text:0000094C
.text:0000094C ; public: unsigned int __thiscall CRecordVector<bool>::Add(bool)
.text:0000094C                 public ?Add@?$CRecordVector@_N@@QAEI_N@Z
.text:0000094C ?Add@?$CRecordVector@_N@@QAEI_N@Z proc near
.text:0000094C                                         ; CODE XREF: NArchive::N7z::CFolderInStream::AddFileInfo(bool)+19p
.text:0000094C
.text:0000094C var_8           = dword ptr -8
.text:0000094C var_4           = dword ptr -4
.text:0000094C arg_0           = byte ptr  8
.text:0000094C
.text:0000094C                 push    ebp
.text:0000094D                 mov     ebp, esp
.text:0000094F                 sub     esp, 8
.text:00000952                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00000959                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000960                 mov     [ebp+var_4], ecx
.text:00000963                 mov     ecx, [ebp+var_4]
.text:00000966                 call    ?ReserveOnePosition@?$CRecordVector@_N@@AAEXXZ ; CRecordVector<bool>::ReserveOnePosition(void)
.text:0000096B                 mov     eax, [ebp+var_4]
.text:0000096E                 mov     ecx, [eax]
.text:00000970                 mov     edx, [ebp+var_4]
.text:00000973                 mov     eax, [edx+4]
.text:00000976                 mov     dl, [ebp+arg_0]
.text:00000979                 mov     [ecx+eax], dl
.text:0000097C                 mov     eax, [ebp+var_4]
.text:0000097F                 mov     ecx, [eax+4]
.text:00000982                 mov     [ebp+var_8], ecx
.text:00000985                 mov     edx, [ebp+var_4]
.text:00000988                 mov     eax, [edx+4]
.text:0000098B                 add     eax, 1
.text:0000098E                 mov     ecx, [ebp+var_4]
.text:00000991                 mov     [ecx+4], eax
.text:00000994                 mov     eax, [ebp+var_8]
.text:00000997                 add     esp, 8
.text:0000099A                 cmp     ebp, esp
.text:0000099C                 call    __RTC_CheckEsp
.text:000009A1                 mov     esp, ebp
.text:000009A3                 pop     ebp
.text:000009A4                 retn    4
.text:000009A4 ?Add@?$CRecordVector@_N@@QAEI_N@Z endp
.text:000009A4
.text:000009A4 ; ---------------------------------------------------------------------------
.text:000009A7                 align 4
.text:000009A7 _text           ends
.text:000009A7
.text:000009A8 ; ===========================================================================
.text:000009A8
.text:000009A8 ; Segment type: Pure code
.text:000009A8 ; Segment permissions: Read/Execute
.text:000009A8 _text           segment para public 'CODE' use32
.text:000009A8                 assume cs:_text
.text:000009A8                 ;org 9A8h
.text:000009A8 ; COMDAT (pick any)
.text:000009A8                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000009A8
.text:000009A8 ; =============== S U B R O U T I N E =======================================
.text:000009A8
.text:000009A8 ; Attributes: bp-based frame
.text:000009A8
.text:000009A8 ; public: void __thiscall CRecordVector<unsigned int>::ClearAndReserve(unsigned int)
.text:000009A8                 public ?ClearAndReserve@?$CRecordVector@I@@QAEXI@Z
.text:000009A8 ?ClearAndReserve@?$CRecordVector@I@@QAEXI@Z proc near
.text:000009A8                                         ; CODE XREF: NArchive::N7z::CFolderInStream::Init(IArchiveUpdateCallback *,uint const *,uint)+52p
.text:000009A8
.text:000009A8 var_C           = dword ptr -0Ch
.text:000009A8 var_8           = dword ptr -8
.text:000009A8 var_4           = dword ptr -4
.text:000009A8 arg_0           = dword ptr  8
.text:000009A8
.text:000009A8                 push    ebp
.text:000009A9                 mov     ebp, esp
.text:000009AB                 sub     esp, 0Ch
.text:000009AE                 mov     [ebp+var_C], 0CCCCCCCCh
.text:000009B5                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000009BC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000009C3                 mov     [ebp+var_4], ecx
.text:000009C6                 mov     ecx, [ebp+var_4]
.text:000009C9                 call    ?Clear@?$CRecordVector@I@@QAEXXZ ; CRecordVector<uint>::Clear(void)
.text:000009CE                 mov     eax, [ebp+var_4]
.text:000009D1                 mov     ecx, [ebp+arg_0]
.text:000009D4                 cmp     ecx, [eax+8]
.text:000009D7                 jbe     short loc_A30
.text:000009D9                 mov     edx, [ebp+var_4]
.text:000009DC                 mov     eax, [edx]
.text:000009DE                 mov     [ebp+var_8], eax
.text:000009E1                 mov     ecx, [ebp+var_8]
.text:000009E4                 push    ecx             ; void *
.text:000009E5                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:000009EA                 add     esp, 4
.text:000009ED                 mov     edx, [ebp+var_4]
.text:000009F0                 mov     dword ptr [edx], 0
.text:000009F6                 mov     eax, [ebp+var_4]
.text:000009F9                 mov     dword ptr [eax+8], 0
.text:00000A00                 xor     ecx, ecx
.text:00000A02                 mov     eax, [ebp+arg_0]
.text:00000A05                 mov     edx, 4
.text:00000A0A                 mul     edx
.text:00000A0C                 seto    cl
.text:00000A0F                 neg     ecx
.text:00000A11                 or      ecx, eax
.text:00000A13                 push    ecx             ; unsigned int
.text:00000A14                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00000A19                 add     esp, 4
.text:00000A1C                 mov     [ebp+var_C], eax
.text:00000A1F                 mov     eax, [ebp+var_4]
.text:00000A22                 mov     ecx, [ebp+var_C]
.text:00000A25                 mov     [eax], ecx
.text:00000A27                 mov     edx, [ebp+var_4]
.text:00000A2A                 mov     eax, [ebp+arg_0]
.text:00000A2D                 mov     [edx+8], eax
.text:00000A30
.text:00000A30 loc_A30:                                ; CODE XREF: CRecordVector<uint>::ClearAndReserve(uint)+2Fj
.text:00000A30                 add     esp, 0Ch
.text:00000A33                 cmp     ebp, esp
.text:00000A35                 call    __RTC_CheckEsp
.text:00000A3A                 mov     esp, ebp
.text:00000A3C                 pop     ebp
.text:00000A3D                 retn    4
.text:00000A3D ?ClearAndReserve@?$CRecordVector@I@@QAEXI@Z endp
.text:00000A3D
.text:00000A3D _text           ends
.text:00000A3D
.text:00000A40 ; ===========================================================================
.text:00000A40
.text:00000A40 ; Segment type: Pure code
.text:00000A40 ; Segment permissions: Read/Execute
.text:00000A40 _text           segment para public 'CODE' use32
.text:00000A40                 assume cs:_text
.text:00000A40                 ;org 0A40h
.text:00000A40 ; COMDAT (pick any)
.text:00000A40                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000A40
.text:00000A40 ; =============== S U B R O U T I N E =======================================
.text:00000A40
.text:00000A40 ; Attributes: bp-based frame
.text:00000A40
.text:00000A40 ; public: unsigned int __thiscall CRecordVector<unsigned int>::Add(unsigned int)
.text:00000A40                 public ?Add@?$CRecordVector@I@@QAEII@Z
.text:00000A40 ?Add@?$CRecordVector@I@@QAEII@Z proc near
.text:00000A40                                         ; CODE XREF: NArchive::N7z::CFolderInStream::AddFileInfo(bool)+44p
.text:00000A40
.text:00000A40 var_8           = dword ptr -8
.text:00000A40 var_4           = dword ptr -4
.text:00000A40 arg_0           = dword ptr  8
.text:00000A40
.text:00000A40                 push    ebp
.text:00000A41                 mov     ebp, esp
.text:00000A43                 sub     esp, 8
.text:00000A46                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00000A4D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000A54                 mov     [ebp+var_4], ecx
.text:00000A57                 mov     ecx, [ebp+var_4]
.text:00000A5A                 call    ?ReserveOnePosition@?$CRecordVector@I@@AAEXXZ ; CRecordVector<uint>::ReserveOnePosition(void)
.text:00000A5F                 mov     eax, [ebp+var_4]
.text:00000A62                 mov     ecx, [eax+4]
.text:00000A65                 mov     edx, [ebp+var_4]
.text:00000A68                 mov     eax, [edx]
.text:00000A6A                 mov     edx, [ebp+arg_0]
.text:00000A6D                 mov     [eax+ecx*4], edx
.text:00000A70                 mov     eax, [ebp+var_4]
.text:00000A73                 mov     ecx, [eax+4]
.text:00000A76                 mov     [ebp+var_8], ecx
.text:00000A79                 mov     edx, [ebp+var_4]
.text:00000A7C                 mov     eax, [edx+4]
.text:00000A7F                 add     eax, 1
.text:00000A82                 mov     ecx, [ebp+var_4]
.text:00000A85                 mov     [ecx+4], eax
.text:00000A88                 mov     eax, [ebp+var_8]
.text:00000A8B                 add     esp, 8
.text:00000A8E                 cmp     ebp, esp
.text:00000A90                 call    __RTC_CheckEsp
.text:00000A95                 mov     esp, ebp
.text:00000A97                 pop     ebp
.text:00000A98                 retn    4
.text:00000A98 ?Add@?$CRecordVector@I@@QAEII@Z endp
.text:00000A98
.text:00000A98 ; ---------------------------------------------------------------------------
.text:00000A9B                 align 4
.text:00000A9B _text           ends
.text:00000A9B
.text:00000A9C ; ===========================================================================
.text:00000A9C
.text:00000A9C ; Segment type: Pure code
.text:00000A9C ; Segment permissions: Read/Execute
.text:00000A9C _text           segment para public 'CODE' use32
.text:00000A9C                 assume cs:_text
.text:00000A9C                 ;org 0A9Ch
.text:00000A9C ; COMDAT (pick any)
.text:00000A9C                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000A9C
.text:00000A9C ; =============== S U B R O U T I N E =======================================
.text:00000A9C
.text:00000A9C ; Attributes: bp-based frame
.text:00000A9C
.text:00000A9C ; public: unsigned int __thiscall CRecordVector<unsigned __int64>::Size(void)const
.text:00000A9C                 public ?Size@?$CRecordVector@_K@@QBEIXZ
.text:00000A9C ?Size@?$CRecordVector@_K@@QBEIXZ proc near
.text:00000A9C                                         ; CODE XREF: NArchive::N7z::CFolderInStream::GetSubStreamSize(unsigned __int64,unsigned __int64 *)+36p
.text:00000A9C                                         ; NArchive::N7z::CFolderInStream::GetSubStreamSize(unsigned __int64,unsigned __int64 *)+6Bp
.text:00000A9C
.text:00000A9C var_4           = dword ptr -4
.text:00000A9C
.text:00000A9C                 push    ebp
.text:00000A9D                 mov     ebp, esp
.text:00000A9F                 push    ecx
.text:00000AA0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000AA7                 mov     [ebp+var_4], ecx
.text:00000AAA                 mov     eax, [ebp+var_4]
.text:00000AAD                 mov     eax, [eax+4]
.text:00000AB0                 mov     esp, ebp
.text:00000AB2                 pop     ebp
.text:00000AB3                 retn
.text:00000AB3 ?Size@?$CRecordVector@_K@@QBEIXZ endp
.text:00000AB3
.text:00000AB3 _text           ends
.text:00000AB3
.text:00000AB4 ; ===========================================================================
.text:00000AB4
.text:00000AB4 ; Segment type: Pure code
.text:00000AB4 ; Segment permissions: Read/Execute
.text:00000AB4 _text           segment para public 'CODE' use32
.text:00000AB4                 assume cs:_text
.text:00000AB4                 ;org 0AB4h
.text:00000AB4 ; COMDAT (pick any)
.text:00000AB4                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000AB4
.text:00000AB4 ; =============== S U B R O U T I N E =======================================
.text:00000AB4
.text:00000AB4 ; Attributes: bp-based frame
.text:00000AB4
.text:00000AB4 ; public: void __thiscall CRecordVector<unsigned __int64>::ClearAndReserve(unsigned int)
.text:00000AB4                 public ?ClearAndReserve@?$CRecordVector@_K@@QAEXI@Z
.text:00000AB4 ?ClearAndReserve@?$CRecordVector@_K@@QAEXI@Z proc near
.text:00000AB4                                         ; CODE XREF: NArchive::N7z::CFolderInStream::Init(IArchiveUpdateCallback *,uint const *,uint)+61p
.text:00000AB4
.text:00000AB4 var_C           = dword ptr -0Ch
.text:00000AB4 var_8           = dword ptr -8
.text:00000AB4 var_4           = dword ptr -4
.text:00000AB4 arg_0           = dword ptr  8
.text:00000AB4
.text:00000AB4                 push    ebp
.text:00000AB5                 mov     ebp, esp
.text:00000AB7                 sub     esp, 0Ch
.text:00000ABA                 mov     [ebp+var_C], 0CCCCCCCCh
.text:00000AC1                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00000AC8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000ACF                 mov     [ebp+var_4], ecx
.text:00000AD2                 mov     ecx, [ebp+var_4]
.text:00000AD5                 call    ?Clear@?$CRecordVector@_K@@QAEXXZ ; CRecordVector<unsigned __int64>::Clear(void)
.text:00000ADA                 mov     eax, [ebp+var_4]
.text:00000ADD                 mov     ecx, [ebp+arg_0]
.text:00000AE0                 cmp     ecx, [eax+8]
.text:00000AE3                 jbe     short loc_B3C
.text:00000AE5                 mov     edx, [ebp+var_4]
.text:00000AE8                 mov     eax, [edx]
.text:00000AEA                 mov     [ebp+var_8], eax
.text:00000AED                 mov     ecx, [ebp+var_8]
.text:00000AF0                 push    ecx             ; void *
.text:00000AF1                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00000AF6                 add     esp, 4
.text:00000AF9                 mov     edx, [ebp+var_4]
.text:00000AFC                 mov     dword ptr [edx], 0
.text:00000B02                 mov     eax, [ebp+var_4]
.text:00000B05                 mov     dword ptr [eax+8], 0
.text:00000B0C                 xor     ecx, ecx
.text:00000B0E                 mov     eax, [ebp+arg_0]
.text:00000B11                 mov     edx, 8
.text:00000B16                 mul     edx
.text:00000B18                 seto    cl
.text:00000B1B                 neg     ecx
.text:00000B1D                 or      ecx, eax
.text:00000B1F                 push    ecx             ; unsigned int
.text:00000B20                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00000B25                 add     esp, 4
.text:00000B28                 mov     [ebp+var_C], eax
.text:00000B2B                 mov     eax, [ebp+var_4]
.text:00000B2E                 mov     ecx, [ebp+var_C]
.text:00000B31                 mov     [eax], ecx
.text:00000B33                 mov     edx, [ebp+var_4]
.text:00000B36                 mov     eax, [ebp+arg_0]
.text:00000B39                 mov     [edx+8], eax
.text:00000B3C
.text:00000B3C loc_B3C:                                ; CODE XREF: CRecordVector<unsigned __int64>::ClearAndReserve(uint)+2Fj
.text:00000B3C                 add     esp, 0Ch
.text:00000B3F                 cmp     ebp, esp
.text:00000B41                 call    __RTC_CheckEsp
.text:00000B46                 mov     esp, ebp
.text:00000B48                 pop     ebp
.text:00000B49                 retn    4
.text:00000B49 ?ClearAndReserve@?$CRecordVector@_K@@QAEXI@Z endp
.text:00000B49
.text:00000B49 _text           ends
.text:00000B49
.text:00000B4C ; ===========================================================================
.text:00000B4C
.text:00000B4C ; Segment type: Pure code
.text:00000B4C ; Segment permissions: Read/Execute
.text:00000B4C _text           segment para public 'CODE' use32
.text:00000B4C                 assume cs:_text
.text:00000B4C                 ;org 0B4Ch
.text:00000B4C ; COMDAT (pick any)
.text:00000B4C                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000B4C
.text:00000B4C ; =============== S U B R O U T I N E =======================================
.text:00000B4C
.text:00000B4C ; Attributes: bp-based frame
.text:00000B4C
.text:00000B4C ; public: unsigned int __thiscall CRecordVector<unsigned __int64>::Add(unsigned __int64)
.text:00000B4C                 public ?Add@?$CRecordVector@_K@@QAEI_K@Z
.text:00000B4C ?Add@?$CRecordVector@_K@@QAEI_K@Z proc near
.text:00000B4C                                         ; CODE XREF: NArchive::N7z::CFolderInStream::AddFileInfo(bool)+2Fp
.text:00000B4C
.text:00000B4C var_8           = dword ptr -8
.text:00000B4C var_4           = dword ptr -4
.text:00000B4C arg_0           = dword ptr  8
.text:00000B4C arg_4           = dword ptr  0Ch
.text:00000B4C
.text:00000B4C                 push    ebp
.text:00000B4D                 mov     ebp, esp
.text:00000B4F                 sub     esp, 8
.text:00000B52                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00000B59                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000B60                 mov     [ebp+var_4], ecx
.text:00000B63                 mov     ecx, [ebp+var_4]
.text:00000B66                 call    ?ReserveOnePosition@?$CRecordVector@_K@@AAEXXZ ; CRecordVector<unsigned __int64>::ReserveOnePosition(void)
.text:00000B6B                 mov     eax, [ebp+var_4]
.text:00000B6E                 mov     ecx, [eax+4]
.text:00000B71                 mov     edx, [ebp+var_4]
.text:00000B74                 mov     eax, [edx]
.text:00000B76                 mov     edx, [ebp+arg_0]
.text:00000B79                 mov     [eax+ecx*8], edx
.text:00000B7C                 mov     edx, [ebp+arg_4]
.text:00000B7F                 mov     [eax+ecx*8+4], edx
.text:00000B83                 mov     eax, [ebp+var_4]
.text:00000B86                 mov     ecx, [eax+4]
.text:00000B89                 mov     [ebp+var_8], ecx
.text:00000B8C                 mov     edx, [ebp+var_4]
.text:00000B8F                 mov     eax, [edx+4]
.text:00000B92                 add     eax, 1
.text:00000B95                 mov     ecx, [ebp+var_4]
.text:00000B98                 mov     [ecx+4], eax
.text:00000B9B                 mov     eax, [ebp+var_8]
.text:00000B9E                 add     esp, 8
.text:00000BA1                 cmp     ebp, esp
.text:00000BA3                 call    __RTC_CheckEsp
.text:00000BA8                 mov     esp, ebp
.text:00000BAA                 pop     ebp
.text:00000BAB                 retn    8
.text:00000BAB ?Add@?$CRecordVector@_K@@QAEI_K@Z endp
.text:00000BAB
.text:00000BAB ; ---------------------------------------------------------------------------
.text:00000BAE                 align 10h
.text:00000BAE _text           ends
.text:00000BAE
.text:00000BB0 ; ===========================================================================
.text:00000BB0
.text:00000BB0 ; Segment type: Pure code
.text:00000BB0 ; Segment permissions: Read/Execute
.text:00000BB0 _text           segment para public 'CODE' use32
.text:00000BB0                 assume cs:_text
.text:00000BB0                 ;org 0BB0h
.text:00000BB0 ; COMDAT (pick any)
.text:00000BB0                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000BB0
.text:00000BB0 ; =============== S U B R O U T I N E =======================================
.text:00000BB0
.text:00000BB0 ; Attributes: bp-based frame
.text:00000BB0
.text:00000BB0 ; public: unsigned __int64 & __thiscall CRecordVector<unsigned __int64>::operator[](unsigned int)
.text:00000BB0                 public ??A?$CRecordVector@_K@@QAEAA_KI@Z
.text:00000BB0 ??A?$CRecordVector@_K@@QAEAA_KI@Z proc near
.text:00000BB0                                         ; CODE XREF: NArchive::N7z::CFolderInStream::GetSubStreamSize(unsigned __int64,unsigned __int64 *)+7Fp
.text:00000BB0
.text:00000BB0 var_4           = dword ptr -4
.text:00000BB0 arg_0           = dword ptr  8
.text:00000BB0
.text:00000BB0                 push    ebp
.text:00000BB1                 mov     ebp, esp
.text:00000BB3                 push    ecx
.text:00000BB4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000BBB                 mov     [ebp+var_4], ecx
.text:00000BBE                 mov     eax, [ebp+var_4]
.text:00000BC1                 mov     ecx, [eax]
.text:00000BC3                 mov     edx, [ebp+arg_0]
.text:00000BC6                 lea     eax, [ecx+edx*8]
.text:00000BC9                 mov     esp, ebp
.text:00000BCB                 pop     ebp
.text:00000BCC                 retn    4
.text:00000BCC ??A?$CRecordVector@_K@@QAEAA_KI@Z endp
.text:00000BCC
.text:00000BCC ; ---------------------------------------------------------------------------
.text:00000BCF                 align 10h
.text:00000BCF _text           ends
.text:00000BCF
.text:00000BD0 ; ===========================================================================
.text:00000BD0
.text:00000BD0 ; Segment type: Pure code
.text:00000BD0 ; Segment permissions: Read/Execute
.text:00000BD0 _text           segment para public 'CODE' use32
.text:00000BD0                 assume cs:_text
.text:00000BD0                 ;org 0BD0h
.text:00000BD0 ; COMDAT (pick any)
.text:00000BD0                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000BD0
.text:00000BD0 ; =============== S U B R O U T I N E =======================================
.text:00000BD0
.text:00000BD0 ; Attributes: bp-based frame
.text:00000BD0
.text:00000BD0 ; public: __thiscall CMyComPtr<struct IStreamGetSize>::CMyComPtr<struct IStreamGetSize>(void)
.text:00000BD0                 public ??0?$CMyComPtr@UIStreamGetSize@@@@QAE@XZ
.text:00000BD0 ??0?$CMyComPtr@UIStreamGetSize@@@@QAE@XZ proc near
.text:00000BD0                                         ; CODE XREF: NArchive::N7z::CFolderInStream::OpenStream(void)+11Bp
.text:00000BD0
.text:00000BD0 var_4           = dword ptr -4
.text:00000BD0
.text:00000BD0                 push    ebp
.text:00000BD1                 mov     ebp, esp
.text:00000BD3                 push    ecx
.text:00000BD4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000BDB                 mov     [ebp+var_4], ecx
.text:00000BDE                 mov     eax, [ebp+var_4]
.text:00000BE1                 mov     dword ptr [eax], 0
.text:00000BE7                 mov     eax, [ebp+var_4]
.text:00000BEA                 mov     esp, ebp
.text:00000BEC                 pop     ebp
.text:00000BED                 retn
.text:00000BED ??0?$CMyComPtr@UIStreamGetSize@@@@QAE@XZ endp
.text:00000BED
.text:00000BED ; ---------------------------------------------------------------------------
.text:00000BEE                 align 10h
.text:00000BEE _text           ends
.text:00000BEE
.text:00000BF0 ; ===========================================================================
.text:00000BF0
.text:00000BF0 ; Segment type: Pure code
.text:00000BF0 ; Segment permissions: Read/Execute
.text:00000BF0 _text           segment para public 'CODE' use32
.text:00000BF0                 assume cs:_text
.text:00000BF0                 ;org 0BF0h
.text:00000BF0 ; COMDAT (pick any)
.text:00000BF0                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000BF0
.text:00000BF0 ; =============== S U B R O U T I N E =======================================
.text:00000BF0
.text:00000BF0 ; Attributes: bp-based frame
.text:00000BF0
.text:00000BF0 ; public: __thiscall CMyComPtr<struct IStreamGetSize>::~CMyComPtr<struct IStreamGetSize>(void)
.text:00000BF0                 public ??1?$CMyComPtr@UIStreamGetSize@@@@QAE@XZ
.text:00000BF0 ??1?$CMyComPtr@UIStreamGetSize@@@@QAE@XZ proc near
.text:00000BF0                                         ; CODE XREF: NArchive::N7z::CFolderInStream::OpenStream(void)+188p
.text:00000BF0                                         ; __unwindfunclet$?OpenStream@CFolderInStream@N7z@NArchive@@AAEJXZ$1+3j
.text:00000BF0
.text:00000BF0 var_4           = dword ptr -4
.text:00000BF0
.text:00000BF0                 push    ebp
.text:00000BF1                 mov     ebp, esp
.text:00000BF3                 push    ecx
.text:00000BF4                 push    esi
.text:00000BF5                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000BFC                 mov     [ebp+var_4], ecx
.text:00000BFF                 mov     eax, [ebp+var_4]
.text:00000C02                 cmp     dword ptr [eax], 0
.text:00000C05                 jz      short loc_C22
.text:00000C07                 mov     ecx, [ebp+var_4]
.text:00000C0A                 mov     edx, [ecx]
.text:00000C0C                 mov     eax, [ebp+var_4]
.text:00000C0F                 mov     ecx, [eax]
.text:00000C11                 mov     edx, [edx]
.text:00000C13                 mov     esi, esp
.text:00000C15                 push    ecx
.text:00000C16                 mov     eax, [edx+8]
.text:00000C19                 call    eax
.text:00000C1B                 cmp     esi, esp
.text:00000C1D                 call    __RTC_CheckEsp
.text:00000C22
.text:00000C22 loc_C22:                                ; CODE XREF: CMyComPtr<IStreamGetSize>::~CMyComPtr<IStreamGetSize>(void)+15j
.text:00000C22                 pop     esi
.text:00000C23                 add     esp, 4
.text:00000C26                 cmp     ebp, esp
.text:00000C28                 call    __RTC_CheckEsp
.text:00000C2D                 mov     esp, ebp
.text:00000C2F                 pop     ebp
.text:00000C30                 retn
.text:00000C30 ??1?$CMyComPtr@UIStreamGetSize@@@@QAE@XZ endp
.text:00000C30
.text:00000C30 ; ---------------------------------------------------------------------------
.text:00000C31                 align 4
.text:00000C31 _text           ends
.text:00000C31
.text:00000C34 ; ===========================================================================
.text:00000C34
.text:00000C34 ; Segment type: Pure code
.text:00000C34 ; Segment permissions: Read/Execute
.text:00000C34 _text           segment para public 'CODE' use32
.text:00000C34                 assume cs:_text
.text:00000C34                 ;org 0C34h
.text:00000C34 ; COMDAT (pick any)
.text:00000C34                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000C34
.text:00000C34 ; =============== S U B R O U T I N E =======================================
.text:00000C34
.text:00000C34 ; Attributes: bp-based frame
.text:00000C34
.text:00000C34 ; public: __thiscall CMyComPtr<struct IStreamGetSize>::operator struct IStreamGetSize *(void)const
.text:00000C34                 public ??B?$CMyComPtr@UIStreamGetSize@@@@QBEPAUIStreamGetSize@@XZ
.text:00000C34 ??B?$CMyComPtr@UIStreamGetSize@@@@QBEPAUIStreamGetSize@@XZ proc near
.text:00000C34                                         ; CODE XREF: NArchive::N7z::CFolderInStream::OpenStream(void)+13Dp
.text:00000C34
.text:00000C34 var_4           = dword ptr -4
.text:00000C34
.text:00000C34                 push    ebp
.text:00000C35                 mov     ebp, esp
.text:00000C37                 push    ecx
.text:00000C38                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000C3F                 mov     [ebp+var_4], ecx
.text:00000C42                 mov     eax, [ebp+var_4]
.text:00000C45                 mov     eax, [eax]
.text:00000C47                 mov     esp, ebp
.text:00000C49                 pop     ebp
.text:00000C4A                 retn
.text:00000C4A ??B?$CMyComPtr@UIStreamGetSize@@@@QBEPAUIStreamGetSize@@XZ endp
.text:00000C4A
.text:00000C4A ; ---------------------------------------------------------------------------
.text:00000C4B                 align 4
.text:00000C4B _text           ends
.text:00000C4B
.text:00000C4C ; ===========================================================================
.text:00000C4C
.text:00000C4C ; Segment type: Pure code
.text:00000C4C ; Segment permissions: Read/Execute
.text:00000C4C _text           segment para public 'CODE' use32
.text:00000C4C                 assume cs:_text
.text:00000C4C                 ;org 0C4Ch
.text:00000C4C ; COMDAT (pick any)
.text:00000C4C                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000C4C
.text:00000C4C ; =============== S U B R O U T I N E =======================================
.text:00000C4C
.text:00000C4C ; Attributes: bp-based frame
.text:00000C4C
.text:00000C4C ; public: struct IStreamGetSize * * __thiscall CMyComPtr<struct IStreamGetSize>::operator&(void)
.text:00000C4C                 public ??I?$CMyComPtr@UIStreamGetSize@@@@QAEPAPAUIStreamGetSize@@XZ
.text:00000C4C ??I?$CMyComPtr@UIStreamGetSize@@@@QAEPAPAUIStreamGetSize@@XZ proc near
.text:00000C4C                                         ; CODE XREF: NArchive::N7z::CFolderInStream::OpenStream(void)+127p
.text:00000C4C
.text:00000C4C var_4           = dword ptr -4
.text:00000C4C
.text:00000C4C                 push    ebp
.text:00000C4D                 mov     ebp, esp
.text:00000C4F                 push    ecx
.text:00000C50                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000C57                 mov     [ebp+var_4], ecx
.text:00000C5A                 mov     eax, [ebp+var_4]
.text:00000C5D                 mov     esp, ebp
.text:00000C5F                 pop     ebp
.text:00000C60                 retn
.text:00000C60 ??I?$CMyComPtr@UIStreamGetSize@@@@QAEPAPAUIStreamGetSize@@XZ endp
.text:00000C60
.text:00000C60 ; ---------------------------------------------------------------------------
.text:00000C61                 align 4
.text:00000C61 _text           ends
.text:00000C61
.text:00000C64 ; ===========================================================================
.text:00000C64
.text:00000C64 ; Segment type: Pure code
.text:00000C64 ; Segment permissions: Read/Execute
.text:00000C64 _text           segment para public 'CODE' use32
.text:00000C64                 assume cs:_text
.text:00000C64                 ;org 0C64h
.text:00000C64 ; COMDAT (pick any)
.text:00000C64                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000C64
.text:00000C64 ; =============== S U B R O U T I N E =======================================
.text:00000C64
.text:00000C64 ; Attributes: bp-based frame
.text:00000C64
.text:00000C64 ; public: struct IStreamGetSize * __thiscall CMyComPtr<struct IStreamGetSize>::operator->(void)const
.text:00000C64                 public ??C?$CMyComPtr@UIStreamGetSize@@@@QBEPAUIStreamGetSize@@XZ
.text:00000C64 ??C?$CMyComPtr@UIStreamGetSize@@@@QBEPAUIStreamGetSize@@XZ proc near
.text:00000C64                                         ; CODE XREF: NArchive::N7z::CFolderInStream::OpenStream(void)+149p
.text:00000C64
.text:00000C64 var_4           = dword ptr -4
.text:00000C64
.text:00000C64                 push    ebp
.text:00000C65                 mov     ebp, esp
.text:00000C67                 push    ecx
.text:00000C68                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000C6F                 mov     [ebp+var_4], ecx
.text:00000C72                 mov     eax, [ebp+var_4]
.text:00000C75                 mov     eax, [eax]
.text:00000C77                 mov     esp, ebp
.text:00000C79                 pop     ebp
.text:00000C7A                 retn
.text:00000C7A ??C?$CMyComPtr@UIStreamGetSize@@@@QBEPAUIStreamGetSize@@XZ endp
.text:00000C7A
.text:00000C7A ; ---------------------------------------------------------------------------
.text:00000C7B                 align 4
.text:00000C7B _text           ends
.text:00000C7B
.text:00000C7C ; ===========================================================================
.text:00000C7C
.text:00000C7C ; Segment type: Pure code
.text:00000C7C ; Segment permissions: Read/Execute
.text:00000C7C _text           segment para public 'CODE' use32
.text:00000C7C                 assume cs:_text
.text:00000C7C                 ;org 0C7Ch
.text:00000C7C ; COMDAT (pick any)
.text:00000C7C                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000C7C
.text:00000C7C ; =============== S U B R O U T I N E =======================================
.text:00000C7C
.text:00000C7C ; Attributes: bp-based frame
.text:00000C7C
.text:00000C7C ; public: struct ISequentialInStream * __thiscall CMyComPtr<struct ISequentialInStream>::operator=(struct ISequentialInStream *)
.text:00000C7C                 public ??4?$CMyComPtr@UISequentialInStream@@@@QAEPAUISequentialInStream@@PAU1@@Z
.text:00000C7C ??4?$CMyComPtr@UISequentialInStream@@@@QAEPAUISequentialInStream@@PAU1@@Z proc near
.text:00000C7C                                         ; CODE XREF: CMyComPtr<ISequentialInStream>::operator=(CMyComPtr<ISequentialInStream> const &)+17p
.text:00000C7C
.text:00000C7C var_4           = dword ptr -4
.text:00000C7C arg_0           = dword ptr  8
.text:00000C7C
.text:00000C7C                 push    ebp
.text:00000C7D                 mov     ebp, esp
.text:00000C7F                 push    ecx
.text:00000C80                 push    esi
.text:00000C81                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000C88                 mov     [ebp+var_4], ecx
.text:00000C8B                 cmp     [ebp+arg_0], 0
.text:00000C8F                 jz      short loc_CA8
.text:00000C91                 mov     eax, [ebp+arg_0]
.text:00000C94                 mov     ecx, [eax]
.text:00000C96                 mov     esi, esp
.text:00000C98                 mov     edx, [ebp+arg_0]
.text:00000C9B                 push    edx
.text:00000C9C                 mov     eax, [ecx+4]
.text:00000C9F                 call    eax
.text:00000CA1                 cmp     esi, esp
.text:00000CA3                 call    __RTC_CheckEsp
.text:00000CA8
.text:00000CA8 loc_CA8:                                ; CODE XREF: CMyComPtr<ISequentialInStream>::operator=(ISequentialInStream *)+13j
.text:00000CA8                 mov     ecx, [ebp+var_4]
.text:00000CAB                 cmp     dword ptr [ecx], 0
.text:00000CAE                 jz      short loc_CCB
.text:00000CB0                 mov     edx, [ebp+var_4]
.text:00000CB3                 mov     eax, [edx]
.text:00000CB5                 mov     ecx, [ebp+var_4]
.text:00000CB8                 mov     edx, [ecx]
.text:00000CBA                 mov     eax, [eax]
.text:00000CBC                 mov     esi, esp
.text:00000CBE                 push    edx
.text:00000CBF                 mov     ecx, [eax+8]
.text:00000CC2                 call    ecx
.text:00000CC4                 cmp     esi, esp
.text:00000CC6                 call    __RTC_CheckEsp
.text:00000CCB
.text:00000CCB loc_CCB:                                ; CODE XREF: CMyComPtr<ISequentialInStream>::operator=(ISequentialInStream *)+32j
.text:00000CCB                 mov     edx, [ebp+var_4]
.text:00000CCE                 mov     eax, [ebp+arg_0]
.text:00000CD1                 mov     [edx], eax
.text:00000CD3                 mov     eax, [ebp+arg_0]
.text:00000CD6                 pop     esi
.text:00000CD7                 add     esp, 4
.text:00000CDA                 cmp     ebp, esp
.text:00000CDC                 call    __RTC_CheckEsp
.text:00000CE1                 mov     esp, ebp
.text:00000CE3                 pop     ebp
.text:00000CE4                 retn    4
.text:00000CE4 ??4?$CMyComPtr@UISequentialInStream@@@@QAEPAUISequentialInStream@@PAU1@@Z endp
.text:00000CE4
.text:00000CE4 ; ---------------------------------------------------------------------------
.text:00000CE7                 align 4
.text:00000CE7 _text           ends
.text:00000CE7
.text:00000CE8 ; ===========================================================================
.text:00000CE8
.text:00000CE8 ; Segment type: Pure code
.text:00000CE8 ; Segment permissions: Read/Execute
.text:00000CE8 _text           segment para public 'CODE' use32
.text:00000CE8                 assume cs:_text
.text:00000CE8                 ;org 0CE8h
.text:00000CE8 ; COMDAT (pick any)
.text:00000CE8                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000CE8
.text:00000CE8 ; =============== S U B R O U T I N E =======================================
.text:00000CE8
.text:00000CE8 ; Attributes: bp-based frame
.text:00000CE8
.text:00000CE8 ; private: void __thiscall CRecordVector<bool>::ReserveOnePosition(void)
.text:00000CE8                 public ?ReserveOnePosition@?$CRecordVector@_N@@AAEXXZ
.text:00000CE8 ?ReserveOnePosition@?$CRecordVector@_N@@AAEXXZ proc near
.text:00000CE8                                         ; CODE XREF: CRecordVector<bool>::Add(bool)+1Ap
.text:00000CE8
.text:00000CE8 var_14          = dword ptr -14h
.text:00000CE8 var_10          = dword ptr -10h
.text:00000CE8 Dst             = dword ptr -0Ch
.text:00000CE8 var_8           = dword ptr -8
.text:00000CE8 var_4           = dword ptr -4
.text:00000CE8
.text:00000CE8                 push    ebp
.text:00000CE9                 mov     ebp, esp
.text:00000CEB                 sub     esp, 14h
.text:00000CEE                 mov     eax, 0CCCCCCCCh
.text:00000CF3                 mov     [ebp+var_14], eax
.text:00000CF6                 mov     [ebp+var_10], eax
.text:00000CF9                 mov     [ebp+Dst], eax
.text:00000CFC                 mov     [ebp+var_8], eax
.text:00000CFF                 mov     [ebp+var_4], eax
.text:00000D02                 mov     [ebp+var_4], ecx
.text:00000D05                 mov     eax, [ebp+var_4]
.text:00000D08                 mov     ecx, [ebp+var_4]
.text:00000D0B                 mov     edx, [eax+4]
.text:00000D0E                 cmp     edx, [ecx+8]
.text:00000D11                 jnz     short loc_D85
.text:00000D13                 mov     eax, [ebp+var_4]
.text:00000D16                 mov     ecx, [eax+8]
.text:00000D19                 shr     ecx, 2
.text:00000D1C                 mov     edx, [ebp+var_4]
.text:00000D1F                 mov     eax, [edx+8]
.text:00000D22                 lea     ecx, [eax+ecx+1]
.text:00000D26                 mov     [ebp+var_8], ecx
.text:00000D29                 mov     edx, [ebp+var_8]
.text:00000D2C                 push    edx             ; unsigned int
.text:00000D2D                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00000D32                 add     esp, 4
.text:00000D35                 mov     [ebp+var_10], eax
.text:00000D38                 mov     eax, [ebp+var_10]
.text:00000D3B                 mov     [ebp+Dst], eax
.text:00000D3E                 mov     ecx, [ebp+var_4]
.text:00000D41                 cmp     dword ptr [ecx+4], 0
.text:00000D45                 jz      short loc_D60
.text:00000D47                 mov     edx, [ebp+var_4]
.text:00000D4A                 mov     eax, [edx+4]
.text:00000D4D                 push    eax             ; Size
.text:00000D4E                 mov     ecx, [ebp+var_4]
.text:00000D51                 mov     edx, [ecx]
.text:00000D53                 push    edx             ; Src
.text:00000D54                 mov     eax, [ebp+Dst]
.text:00000D57                 push    eax             ; Dst
.text:00000D58                 call    _memcpy
.text:00000D5D                 add     esp, 0Ch
.text:00000D60
.text:00000D60 loc_D60:                                ; CODE XREF: CRecordVector<bool>::ReserveOnePosition(void)+5Dj
.text:00000D60                 mov     ecx, [ebp+var_4]
.text:00000D63                 mov     edx, [ecx]
.text:00000D65                 mov     [ebp+var_14], edx
.text:00000D68                 mov     eax, [ebp+var_14]
.text:00000D6B                 push    eax             ; void *
.text:00000D6C                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00000D71                 add     esp, 4
.text:00000D74                 mov     ecx, [ebp+var_4]
.text:00000D77                 mov     edx, [ebp+Dst]
.text:00000D7A                 mov     [ecx], edx
.text:00000D7C                 mov     eax, [ebp+var_4]
.text:00000D7F                 mov     ecx, [ebp+var_8]
.text:00000D82                 mov     [eax+8], ecx
.text:00000D85
.text:00000D85 loc_D85:                                ; CODE XREF: CRecordVector<bool>::ReserveOnePosition(void)+29j
.text:00000D85                 add     esp, 14h
.text:00000D88                 cmp     ebp, esp
.text:00000D8A                 call    __RTC_CheckEsp
.text:00000D8F                 mov     esp, ebp
.text:00000D91                 pop     ebp
.text:00000D92                 retn
.text:00000D92 ?ReserveOnePosition@?$CRecordVector@_N@@AAEXXZ endp
.text:00000D92
.text:00000D92 ; ---------------------------------------------------------------------------
.text:00000D93                 align 4
.text:00000D93 _text           ends
.text:00000D93
.text:00000D94 ; ===========================================================================
.text:00000D94
.text:00000D94 ; Segment type: Pure code
.text:00000D94 ; Segment permissions: Read/Execute
.text:00000D94 _text           segment para public 'CODE' use32
.text:00000D94                 assume cs:_text
.text:00000D94                 ;org 0D94h
.text:00000D94 ; COMDAT (pick any)
.text:00000D94                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000D94
.text:00000D94 ; =============== S U B R O U T I N E =======================================
.text:00000D94
.text:00000D94 ; Attributes: bp-based frame
.text:00000D94
.text:00000D94 ; public: void __thiscall CRecordVector<bool>::Clear(void)
.text:00000D94                 public ?Clear@?$CRecordVector@_N@@QAEXXZ
.text:00000D94 ?Clear@?$CRecordVector@_N@@QAEXXZ proc near
.text:00000D94                                         ; CODE XREF: CRecordVector<bool>::ClearAndReserve(uint)+21p
.text:00000D94
.text:00000D94 var_4           = dword ptr -4
.text:00000D94
.text:00000D94                 push    ebp
.text:00000D95                 mov     ebp, esp
.text:00000D97                 push    ecx
.text:00000D98                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000D9F                 mov     [ebp+var_4], ecx
.text:00000DA2                 mov     eax, [ebp+var_4]
.text:00000DA5                 mov     dword ptr [eax+4], 0
.text:00000DAC                 mov     esp, ebp
.text:00000DAE                 pop     ebp
.text:00000DAF                 retn
.text:00000DAF ?Clear@?$CRecordVector@_N@@QAEXXZ endp
.text:00000DAF
.text:00000DAF _text           ends
.text:00000DAF
.text:00000DB0 ; ===========================================================================
.text:00000DB0
.text:00000DB0 ; Segment type: Pure code
.text:00000DB0 ; Segment permissions: Read/Execute
.text:00000DB0 _text           segment para public 'CODE' use32
.text:00000DB0                 assume cs:_text
.text:00000DB0                 ;org 0DB0h
.text:00000DB0 ; COMDAT (pick any)
.text:00000DB0                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000DB0
.text:00000DB0 ; =============== S U B R O U T I N E =======================================
.text:00000DB0
.text:00000DB0 ; Attributes: bp-based frame
.text:00000DB0
.text:00000DB0 ; private: void __thiscall CRecordVector<unsigned int>::ReserveOnePosition(void)
.text:00000DB0                 public ?ReserveOnePosition@?$CRecordVector@I@@AAEXXZ
.text:00000DB0 ?ReserveOnePosition@?$CRecordVector@I@@AAEXXZ proc near
.text:00000DB0                                         ; CODE XREF: CRecordVector<uint>::Add(uint)+1Ap
.text:00000DB0
.text:00000DB0 var_14          = dword ptr -14h
.text:00000DB0 var_10          = dword ptr -10h
.text:00000DB0 Dst             = dword ptr -0Ch
.text:00000DB0 var_8           = dword ptr -8
.text:00000DB0 var_4           = dword ptr -4
.text:00000DB0
.text:00000DB0                 push    ebp
.text:00000DB1                 mov     ebp, esp
.text:00000DB3                 sub     esp, 14h
.text:00000DB6                 mov     eax, 0CCCCCCCCh
.text:00000DBB                 mov     [ebp+var_14], eax
.text:00000DBE                 mov     [ebp+var_10], eax
.text:00000DC1                 mov     [ebp+Dst], eax
.text:00000DC4                 mov     [ebp+var_8], eax
.text:00000DC7                 mov     [ebp+var_4], eax
.text:00000DCA                 mov     [ebp+var_4], ecx
.text:00000DCD                 mov     eax, [ebp+var_4]
.text:00000DD0                 mov     ecx, [ebp+var_4]
.text:00000DD3                 mov     edx, [eax+4]
.text:00000DD6                 cmp     edx, [ecx+8]
.text:00000DD9                 jnz     loc_E64
.text:00000DDF                 mov     eax, [ebp+var_4]
.text:00000DE2                 mov     ecx, [eax+8]
.text:00000DE5                 shr     ecx, 2
.text:00000DE8                 mov     edx, [ebp+var_4]
.text:00000DEB                 mov     eax, [edx+8]
.text:00000DEE                 lea     ecx, [eax+ecx+1]
.text:00000DF2                 mov     [ebp+var_8], ecx
.text:00000DF5                 xor     ecx, ecx
.text:00000DF7                 mov     eax, [ebp+var_8]
.text:00000DFA                 mov     edx, 4
.text:00000DFF                 mul     edx
.text:00000E01                 seto    cl
.text:00000E04                 neg     ecx
.text:00000E06                 or      ecx, eax
.text:00000E08                 push    ecx             ; unsigned int
.text:00000E09                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00000E0E                 add     esp, 4
.text:00000E11                 mov     [ebp+var_10], eax
.text:00000E14                 mov     eax, [ebp+var_10]
.text:00000E17                 mov     [ebp+Dst], eax
.text:00000E1A                 mov     ecx, [ebp+var_4]
.text:00000E1D                 cmp     dword ptr [ecx+4], 0
.text:00000E21                 jz      short loc_E3F
.text:00000E23                 mov     edx, [ebp+var_4]
.text:00000E26                 mov     eax, [edx+4]
.text:00000E29                 shl     eax, 2
.text:00000E2C                 push    eax             ; Size
.text:00000E2D                 mov     ecx, [ebp+var_4]
.text:00000E30                 mov     edx, [ecx]
.text:00000E32                 push    edx             ; Src
.text:00000E33                 mov     eax, [ebp+Dst]
.text:00000E36                 push    eax             ; Dst
.text:00000E37                 call    _memcpy
.text:00000E3C                 add     esp, 0Ch
.text:00000E3F
.text:00000E3F loc_E3F:                                ; CODE XREF: CRecordVector<uint>::ReserveOnePosition(void)+71j
.text:00000E3F                 mov     ecx, [ebp+var_4]
.text:00000E42                 mov     edx, [ecx]
.text:00000E44                 mov     [ebp+var_14], edx
.text:00000E47                 mov     eax, [ebp+var_14]
.text:00000E4A                 push    eax             ; void *
.text:00000E4B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00000E50                 add     esp, 4
.text:00000E53                 mov     ecx, [ebp+var_4]
.text:00000E56                 mov     edx, [ebp+Dst]
.text:00000E59                 mov     [ecx], edx
.text:00000E5B                 mov     eax, [ebp+var_4]
.text:00000E5E                 mov     ecx, [ebp+var_8]
.text:00000E61                 mov     [eax+8], ecx
.text:00000E64
.text:00000E64 loc_E64:                                ; CODE XREF: CRecordVector<uint>::ReserveOnePosition(void)+29j
.text:00000E64                 add     esp, 14h
.text:00000E67                 cmp     ebp, esp
.text:00000E69                 call    __RTC_CheckEsp
.text:00000E6E                 mov     esp, ebp
.text:00000E70                 pop     ebp
.text:00000E71                 retn
.text:00000E71 ?ReserveOnePosition@?$CRecordVector@I@@AAEXXZ endp
.text:00000E71
.text:00000E71 ; ---------------------------------------------------------------------------
.text:00000E72                 align 4
.text:00000E72 _text           ends
.text:00000E72
.text:00000E74 ; ===========================================================================
.text:00000E74
.text:00000E74 ; Segment type: Pure code
.text:00000E74 ; Segment permissions: Read/Execute
.text:00000E74 _text           segment para public 'CODE' use32
.text:00000E74                 assume cs:_text
.text:00000E74                 ;org 0E74h
.text:00000E74 ; COMDAT (pick any)
.text:00000E74                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000E74
.text:00000E74 ; =============== S U B R O U T I N E =======================================
.text:00000E74
.text:00000E74 ; Attributes: bp-based frame
.text:00000E74
.text:00000E74 ; public: void __thiscall CRecordVector<unsigned int>::Clear(void)
.text:00000E74                 public ?Clear@?$CRecordVector@I@@QAEXXZ
.text:00000E74 ?Clear@?$CRecordVector@I@@QAEXXZ proc near
.text:00000E74                                         ; CODE XREF: CRecordVector<uint>::ClearAndReserve(uint)+21p
.text:00000E74
.text:00000E74 var_4           = dword ptr -4
.text:00000E74
.text:00000E74                 push    ebp
.text:00000E75                 mov     ebp, esp
.text:00000E77                 push    ecx
.text:00000E78                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000E7F                 mov     [ebp+var_4], ecx
.text:00000E82                 mov     eax, [ebp+var_4]
.text:00000E85                 mov     dword ptr [eax+4], 0
.text:00000E8C                 mov     esp, ebp
.text:00000E8E                 pop     ebp
.text:00000E8F                 retn
.text:00000E8F ?Clear@?$CRecordVector@I@@QAEXXZ endp
.text:00000E8F
.text:00000E8F _text           ends
.text:00000E8F
.text:00000E90 ; ===========================================================================
.text:00000E90
.text:00000E90 ; Segment type: Pure code
.text:00000E90 ; Segment permissions: Read/Execute
.text:00000E90 _text           segment para public 'CODE' use32
.text:00000E90                 assume cs:_text
.text:00000E90                 ;org 0E90h
.text:00000E90 ; COMDAT (pick any)
.text:00000E90                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000E90
.text:00000E90 ; =============== S U B R O U T I N E =======================================
.text:00000E90
.text:00000E90 ; Attributes: bp-based frame
.text:00000E90
.text:00000E90 ; private: void __thiscall CRecordVector<unsigned __int64>::ReserveOnePosition(void)
.text:00000E90                 public ?ReserveOnePosition@?$CRecordVector@_K@@AAEXXZ
.text:00000E90 ?ReserveOnePosition@?$CRecordVector@_K@@AAEXXZ proc near
.text:00000E90                                         ; CODE XREF: CRecordVector<unsigned __int64>::Add(unsigned __int64)+1Ap
.text:00000E90
.text:00000E90 var_14          = dword ptr -14h
.text:00000E90 var_10          = dword ptr -10h
.text:00000E90 Dst             = dword ptr -0Ch
.text:00000E90 var_8           = dword ptr -8
.text:00000E90 var_4           = dword ptr -4
.text:00000E90
.text:00000E90                 push    ebp
.text:00000E91                 mov     ebp, esp
.text:00000E93                 sub     esp, 14h
.text:00000E96                 mov     eax, 0CCCCCCCCh
.text:00000E9B                 mov     [ebp+var_14], eax
.text:00000E9E                 mov     [ebp+var_10], eax
.text:00000EA1                 mov     [ebp+Dst], eax
.text:00000EA4                 mov     [ebp+var_8], eax
.text:00000EA7                 mov     [ebp+var_4], eax
.text:00000EAA                 mov     [ebp+var_4], ecx
.text:00000EAD                 mov     eax, [ebp+var_4]
.text:00000EB0                 mov     ecx, [ebp+var_4]
.text:00000EB3                 mov     edx, [eax+4]
.text:00000EB6                 cmp     edx, [ecx+8]
.text:00000EB9                 jnz     loc_F44
.text:00000EBF                 mov     eax, [ebp+var_4]
.text:00000EC2                 mov     ecx, [eax+8]
.text:00000EC5                 shr     ecx, 2
.text:00000EC8                 mov     edx, [ebp+var_4]
.text:00000ECB                 mov     eax, [edx+8]
.text:00000ECE                 lea     ecx, [eax+ecx+1]
.text:00000ED2                 mov     [ebp+var_8], ecx
.text:00000ED5                 xor     ecx, ecx
.text:00000ED7                 mov     eax, [ebp+var_8]
.text:00000EDA                 mov     edx, 8
.text:00000EDF                 mul     edx
.text:00000EE1                 seto    cl
.text:00000EE4                 neg     ecx
.text:00000EE6                 or      ecx, eax
.text:00000EE8                 push    ecx             ; unsigned int
.text:00000EE9                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00000EEE                 add     esp, 4
.text:00000EF1                 mov     [ebp+var_10], eax
.text:00000EF4                 mov     eax, [ebp+var_10]
.text:00000EF7                 mov     [ebp+Dst], eax
.text:00000EFA                 mov     ecx, [ebp+var_4]
.text:00000EFD                 cmp     dword ptr [ecx+4], 0
.text:00000F01                 jz      short loc_F1F
.text:00000F03                 mov     edx, [ebp+var_4]
.text:00000F06                 mov     eax, [edx+4]
.text:00000F09                 shl     eax, 3
.text:00000F0C                 push    eax             ; Size
.text:00000F0D                 mov     ecx, [ebp+var_4]
.text:00000F10                 mov     edx, [ecx]
.text:00000F12                 push    edx             ; Src
.text:00000F13                 mov     eax, [ebp+Dst]
.text:00000F16                 push    eax             ; Dst
.text:00000F17                 call    _memcpy
.text:00000F1C                 add     esp, 0Ch
.text:00000F1F
.text:00000F1F loc_F1F:                                ; CODE XREF: CRecordVector<unsigned __int64>::ReserveOnePosition(void)+71j
.text:00000F1F                 mov     ecx, [ebp+var_4]
.text:00000F22                 mov     edx, [ecx]
.text:00000F24                 mov     [ebp+var_14], edx
.text:00000F27                 mov     eax, [ebp+var_14]
.text:00000F2A                 push    eax             ; void *
.text:00000F2B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00000F30                 add     esp, 4
.text:00000F33                 mov     ecx, [ebp+var_4]
.text:00000F36                 mov     edx, [ebp+Dst]
.text:00000F39                 mov     [ecx], edx
.text:00000F3B                 mov     eax, [ebp+var_4]
.text:00000F3E                 mov     ecx, [ebp+var_8]
.text:00000F41                 mov     [eax+8], ecx
.text:00000F44
.text:00000F44 loc_F44:                                ; CODE XREF: CRecordVector<unsigned __int64>::ReserveOnePosition(void)+29j
.text:00000F44                 add     esp, 14h
.text:00000F47                 cmp     ebp, esp
.text:00000F49                 call    __RTC_CheckEsp
.text:00000F4E                 mov     esp, ebp
.text:00000F50                 pop     ebp
.text:00000F51                 retn
.text:00000F51 ?ReserveOnePosition@?$CRecordVector@_K@@AAEXXZ endp
.text:00000F51
.text:00000F51 ; ---------------------------------------------------------------------------
.text:00000F52                 align 4
.text:00000F52 _text           ends
.text:00000F52
.text:00000F54 ; ===========================================================================
.text:00000F54
.text:00000F54 ; Segment type: Pure code
.text:00000F54 ; Segment permissions: Read/Execute
.text:00000F54 _text           segment para public 'CODE' use32
.text:00000F54                 assume cs:_text
.text:00000F54                 ;org 0F54h
.text:00000F54 ; COMDAT (pick any)
.text:00000F54                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000F54
.text:00000F54 ; =============== S U B R O U T I N E =======================================
.text:00000F54
.text:00000F54 ; Attributes: bp-based frame
.text:00000F54
.text:00000F54 ; public: void __thiscall CRecordVector<unsigned __int64>::Clear(void)
.text:00000F54                 public ?Clear@?$CRecordVector@_K@@QAEXXZ
.text:00000F54 ?Clear@?$CRecordVector@_K@@QAEXXZ proc near
.text:00000F54                                         ; CODE XREF: CRecordVector<unsigned __int64>::ClearAndReserve(uint)+21p
.text:00000F54
.text:00000F54 var_4           = dword ptr -4
.text:00000F54
.text:00000F54                 push    ebp
.text:00000F55                 mov     ebp, esp
.text:00000F57                 push    ecx
.text:00000F58                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000F5F                 mov     [ebp+var_4], ecx
.text:00000F62                 mov     eax, [ebp+var_4]
.text:00000F65                 mov     dword ptr [eax+4], 0
.text:00000F6C                 mov     esp, ebp
.text:00000F6E                 pop     ebp
.text:00000F6F                 retn
.text:00000F6F ?Clear@?$CRecordVector@_K@@QAEXXZ endp
.text:00000F6F
.text:00000F6F _text           ends
.text:00000F6F
.text:00000F70 ; ===========================================================================
.text:00000F70
.text:00000F70 ; Segment type: Pure code
.text:00000F70 ; Segment permissions: Read/Execute
.text:00000F70 _text           segment para public 'CODE' use32
.text:00000F70                 assume cs:_text
.text:00000F70                 ;org 0F70h
.text:00000F70 ; COMDAT (pick any)
.text:00000F70                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000F70
.text:00000F70 ; =============== S U B R O U T I N E =======================================
.text:00000F70
.text:00000F70 ; Attributes: bp-based frame
.text:00000F70
.text:00000F70 ; public: long __thiscall CMyComPtr<struct ISequentialInStream>::QueryInterface<struct IStreamGetSize>(struct _GUID const &, struct IStreamGetSize * *)const
.text:00000F70                 public ??$QueryInterface@UIStreamGetSize@@@?$CMyComPtr@UISequentialInStream@@@@QBEJABU_GUID@@PAPAUIStreamGetSize@@@Z
.text:00000F70 ??$QueryInterface@UIStreamGetSize@@@?$CMyComPtr@UISequentialInStream@@@@QBEJABU_GUID@@PAPAUIStreamGetSize@@@Z proc near
.text:00000F70                                         ; CODE XREF: NArchive::N7z::CFolderInStream::OpenStream(void)+135p
.text:00000F70
.text:00000F70 var_4           = dword ptr -4
.text:00000F70 arg_0           = dword ptr  8
.text:00000F70 arg_4           = dword ptr  0Ch
.text:00000F70
.text:00000F70                 push    ebp
.text:00000F71                 mov     ebp, esp
.text:00000F73                 push    ecx
.text:00000F74                 push    esi
.text:00000F75                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000F7C                 mov     [ebp+var_4], ecx
.text:00000F7F                 mov     esi, esp
.text:00000F81                 mov     eax, [ebp+arg_4]
.text:00000F84                 push    eax
.text:00000F85                 mov     ecx, [ebp+arg_0]
.text:00000F88                 push    ecx
.text:00000F89                 mov     edx, [ebp+var_4]
.text:00000F8C                 mov     eax, [edx]
.text:00000F8E                 mov     ecx, [ebp+var_4]
.text:00000F91                 mov     edx, [ecx]
.text:00000F93                 mov     eax, [eax]
.text:00000F95                 push    edx
.text:00000F96                 mov     ecx, [eax]
.text:00000F98                 call    ecx
.text:00000F9A                 cmp     esi, esp
.text:00000F9C                 call    __RTC_CheckEsp
.text:00000FA1                 pop     esi
.text:00000FA2                 add     esp, 4
.text:00000FA5                 cmp     ebp, esp
.text:00000FA7                 call    __RTC_CheckEsp
.text:00000FAC                 mov     esp, ebp
.text:00000FAE                 pop     ebp
.text:00000FAF                 retn    8
.text:00000FAF ??$QueryInterface@UIStreamGetSize@@@?$CMyComPtr@UISequentialInStream@@@@QBEJABU_GUID@@PAPAUIStreamGetSize@@@Z endp
.text:00000FAF
.text:00000FAF _text           ends
.text:00000FAF
UNDEF:00000FC0 ; ===========================================================================
UNDEF:00000FC0
UNDEF:00000FC0 ; Segment type: Externs
UNDEF:00000FC0 ; UNDEF
UNDEF:00000FC0                 extrn __RTC_CheckEsp:near
UNDEF:00000FC0                                         ; CODE XREF: NArchive::N7z::CFolderInStream::Init(IArchiveUpdateCallback *,uint const *,uint)+A9p
UNDEF:00000FC0                                         ; NArchive::N7z::CFolderInStream::OpenStream(void)+C8p ...
UNDEF:00000FC4                 extrn __RTC_Shutdown:near
UNDEF:00000FC4                                         ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
UNDEF:00000FC8                 extrn __RTC_InitBase:near
UNDEF:00000FC8                                         ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
UNDEF:00000FCC                 extrn _IID_IStreamGetSize:near
UNDEF:00000FCC                                         ; DATA XREF: NArchive::N7z::CFolderInStream::OpenStream(void)+12Do
UNDEF:00000FD0                 extrn ___security_cookie:near
UNDEF:00000FD0                                         ; DATA XREF: NArchive::N7z::CFolderInStream::OpenStream(void)+27r
UNDEF:00000FD4                 extrn ___CxxFrameHandler3:near
UNDEF:00000FD4                                         ; CODE XREF: __ehhandler$?OpenStream@CFolderInStream@N7z@NArchive@@AAEJXZ+16j
UNDEF:00000FD8 ; __fastcall __security_check_cookie(x)
UNDEF:00000FD8                 extrn @__security_check_cookie@4:near
UNDEF:00000FD8                                         ; CODE XREF: __ehhandler$?OpenStream@CFolderInStream@N7z@NArchive@@AAEJXZ+Cp
UNDEF:00000FDC ; __fastcall _RTC_CheckStackVars(x, x)
UNDEF:00000FDC                 extrn @_RTC_CheckStackVars@8:near
UNDEF:00000FDC                                         ; CODE XREF: NArchive::N7z::CFolderInStream::OpenStream(void)+230p
UNDEF:00000FDC                                         ; NArchive::N7z::CFolderInStream::Read(void *,uint,uint *)+19Fp
UNDEF:00000FE0 ; __fastcall CrcUpdate(x, x, x)
UNDEF:00000FE0                 extrn @CrcUpdate@12:near
UNDEF:00000FE0                                         ; CODE XREF: NArchive::N7z::CFolderInStream::Read(void *,uint,uint *)+A5p
UNDEF:00000FE4 ; void *__cdecl operator new(unsigned int)
UNDEF:00000FE4                 extrn ??2@YAPAXI@Z:near ; CODE XREF: CRecordVector<bool>::ClearAndReserve(uint)+5Cp
UNDEF:00000FE4                                         ; CRecordVector<uint>::ClearAndReserve(uint)+6Cp ...
UNDEF:00000FE8 ; void __cdecl operator delete(void *)
UNDEF:00000FE8                 extrn ??3@YAXPAX@Z:near ; CODE XREF: CRecordVector<bool>::ClearAndReserve(uint)+3Dp
UNDEF:00000FE8                                         ; CRecordVector<uint>::ClearAndReserve(uint)+3Dp ...
UNDEF:00000FEC ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:00000FEC                 extrn _memcpy:near      ; CODE XREF: CRecordVector<bool>::ReserveOnePosition(void)+70p
UNDEF:00000FEC                                         ; CRecordVector<uint>::ReserveOnePosition(void)+87p ...
UNDEF:00000FEC
UNDEF:00000FEC
UNDEF:00000FEC                 end