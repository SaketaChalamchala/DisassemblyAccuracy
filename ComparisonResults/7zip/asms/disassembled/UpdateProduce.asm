.rdata:00000000 ;
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.rdata:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.rdata:00000000 ; |                      License info: 48-3677-7074-51                      |
.rdata:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ;
.rdata:00000000 ; Input MD5   : 8CA6F31C19CCC2A858F7B3FDD28B8E29
.rdata:00000000 ; Input CRC32 : 016E1121
.rdata:00000000
.rdata:00000000 ; File Name   : C:\workspace\7z1505-src\CPP\7zip\Bundles\Alone\Debug\UpdateProduce.obj
.rdata:00000000 ; Format      : COFF (X386MAGIC)
.rdata:00000000 ; includelib "uuid.lib"
.rdata:00000000 ; includelib "MSVCRTD"
.rdata:00000000 ; includelib "OLDNAMES"
.rdata:00000000
.rdata:00000000                 .686p
.rdata:00000000                 .mmx
.rdata:00000000                 .model flat
.rdata:00000000
.rdata:00000000 ; ===========================================================================
.rdata:00000000
.rdata:00000000 ; Segment type: Pure data
.rdata:00000000 ; Segment permissions: Read
.rdata:00000000 _rdata          segment dword public 'DATA' use32
.rdata:00000000                 assume cs:_rdata
.rdata:00000000 $SG68833        db 'Internal collision in update action set',0
.rdata:00000000                                         ; DATA XREF: .data:_kUpdateActionSetCollisiono
.rdata:00000000 _rdata          ends
.rdata:00000000
.data:00000028 ; ===========================================================================
.data:00000028
.data:00000028 ; Segment type: Pure data
.data:00000028 ; Segment permissions: Read/Write
.data:00000028 _data           segment dword public 'DATA' use32
.data:00000028                 assume cs:_data
.data:00000028                 ;org 28h
.data:00000028 _kUpdateActionSetCollision dd offset $SG68833
.data:00000028                                         ; DATA XREF: UpdateProduce(CRecordVector<CUpdatePair> const &,NUpdateArchive::CActionSet const &,CRecordVector<CUpdatePair2> &,IUpdateProduceCallback *)+CBr
.data:00000028                                         ; UpdateProduce(CRecordVector<CUpdatePair> const &,NUpdateArchive::CActionSet const &,CRecordVector<CUpdatePair2> &,IUpdateProduceCallback *):loc_159r
.data:00000028 _data           ends                    ; "Internal collision in update action set"
.data:00000028
.text:0000002C ; ===========================================================================
.text:0000002C
.text:0000002C ; Segment type: Pure code
.text:0000002C ; Segment permissions: Read/Execute
.text:0000002C _text           segment para public 'CODE' use32
.text:0000002C                 assume cs:_text
.text:0000002C                 ;org 2Ch
.text:0000002C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000002C
.text:0000002C ; =============== S U B R O U T I N E =======================================
.text:0000002C
.text:0000002C ; Attributes: bp-based frame
.text:0000002C
.text:0000002C ; void __stdcall UpdateProduce(class CRecordVector<struct CUpdatePair> const &, struct NUpdateArchive::CActionSet const &, class CRecordVector<struct CUpdatePair2> &, struct IUpdateProduceCallback *)
.text:0000002C                 public ?UpdateProduce@@YGXABV?$CRecordVector@UCUpdatePair@@@@ABUCActionSet@NUpdateArchive@@AAV?$CRecordVector@UCUpdatePair2@@@@PAUIUpdateProduceCallback@@@Z
.text:0000002C ?UpdateProduce@@YGXABV?$CRecordVector@UCUpdatePair@@@@ABUCActionSet@NUpdateArchive@@AAV?$CRecordVector@UCUpdatePair2@@@@PAUIUpdateProduceCallback@@@Z proc near
.text:0000002C
.text:0000002C var_30          = dword ptr -30h
.text:0000002C var_2C          = dword ptr -2Ch
.text:0000002C var_28          = dword ptr -28h
.text:0000002C var_20          = dword ptr -20h
.text:0000002C var_1C          = dword ptr -1Ch
.text:0000002C var_18          = dword ptr -18h
.text:0000002C var_14          = dword ptr -14h
.text:0000002C var_10          = dword ptr -10h
.text:0000002C var_8           = dword ptr -8
.text:0000002C var_4           = dword ptr -4
.text:0000002C arg_0           = dword ptr  8
.text:0000002C arg_4           = dword ptr  0Ch
.text:0000002C arg_8           = dword ptr  10h
.text:0000002C arg_C           = dword ptr  14h
.text:0000002C
.text:0000002C                 push    ebp
.text:0000002D                 mov     ebp, esp
.text:0000002F                 sub     esp, 30h
.text:00000032                 push    esi
.text:00000033                 push    edi
.text:00000034                 lea     edi, [ebp+var_30]
.text:00000037                 mov     ecx, 0Ch
.text:0000003C                 mov     eax, 0CCCCCCCCh
.text:00000041                 rep stosd
.text:00000043                 mov     [ebp+var_4], 0
.text:0000004A                 jmp     short loc_55
.text:0000004C ; ---------------------------------------------------------------------------
.text:0000004C
.text:0000004C loc_4C:                                 ; CODE XREF: UpdateProduce(CRecordVector<CUpdatePair> const &,NUpdateArchive::CActionSet const &,CRecordVector<CUpdatePair2> &,IUpdateProduceCallback *):loc_EAj
.text:0000004C                                         ; UpdateProduce(CRecordVector<CUpdatePair> const &,NUpdateArchive::CActionSet const &,CRecordVector<CUpdatePair2> &,IUpdateProduceCallback *)+108j ...
.text:0000004C                 mov     eax, [ebp+var_4]
.text:0000004F                 add     eax, 1
.text:00000052                 mov     [ebp+var_4], eax
.text:00000055
.text:00000055 loc_55:                                 ; CODE XREF: UpdateProduce(CRecordVector<CUpdatePair> const &,NUpdateArchive::CActionSet const &,CRecordVector<CUpdatePair2> &,IUpdateProduceCallback *)+1Ej
.text:00000055                 mov     ecx, [ebp+arg_0]
.text:00000058                 call    ?Size@?$CRecordVector@UCUpdatePair@@@@QBEIXZ ; CRecordVector<CUpdatePair>::Size(void)
.text:0000005D                 cmp     [ebp+var_4], eax
.text:00000060                 jnb     loc_1B4
.text:00000066                 mov     ecx, [ebp+var_4]
.text:00000069                 push    ecx
.text:0000006A                 mov     ecx, [ebp+arg_0]
.text:0000006D                 call    ??A?$CRecordVector@UCUpdatePair@@@@QBEABUCUpdatePair@@I@Z ; CRecordVector<CUpdatePair>::operator[](uint)
.text:00000072                 mov     [ebp+var_8], eax
.text:00000075                 lea     ecx, [ebp+var_20] ; this
.text:00000078                 call    ??0CUpdatePair2@@QAE@XZ ; CUpdatePair2::CUpdatePair2(void)
.text:0000007D                 mov     edx, [ebp+var_8]
.text:00000080                 mov     eax, [edx+8]
.text:00000083                 mov     [ebp+var_1C], eax
.text:00000086                 mov     ecx, [ebp+var_8]
.text:00000089                 mov     edx, [ecx+4]
.text:0000008C                 mov     [ebp+var_18], edx
.text:0000008F                 mov     byte ptr [ebp+var_20+1], 1
.text:00000093                 mov     al, byte ptr [ebp+var_20+1]
.text:00000096                 mov     byte ptr [ebp+var_20], al
.text:00000099                 mov     byte ptr [ebp+var_20+2], 0
.text:0000009D                 mov     ecx, [ebp+var_8]
.text:000000A0                 mov     edx, [ecx]
.text:000000A2                 mov     eax, [ebp+arg_4]
.text:000000A5                 mov     ecx, [eax+edx*4]
.text:000000A8                 mov     [ebp+var_30], ecx
.text:000000AB                 cmp     [ebp+var_30], 3 ; switch 4 cases
.text:000000AF                 ja      loc_185         ; jumptable 000000B8 default case
.text:000000B5                 mov     edx, [ebp+var_30]
.text:000000B8                 jmp     ds:$LN22[edx*4] ; switch jump
.text:000000BF ; ---------------------------------------------------------------------------
.text:000000BF
.text:000000BF $LN11:                                  ; CODE XREF: UpdateProduce(CRecordVector<CUpdatePair> const &,NUpdateArchive::CActionSet const &,CRecordVector<CUpdatePair2> &,IUpdateProduceCallback *)+8Cj
.text:000000BF                                         ; DATA XREF: .text:$LN22o
.text:000000BF                 mov     eax, [ebp+var_8] ; jumptable 000000B8 case 0
.text:000000C2                 cmp     dword ptr [eax+4], 0
.text:000000C6                 jl      short loc_EA
.text:000000C8                 cmp     [ebp+arg_C], 0
.text:000000CC                 jz      short loc_EA
.text:000000CE                 mov     esi, esp
.text:000000D0                 mov     ecx, [ebp+var_8]
.text:000000D3                 mov     edx, [ecx+4]
.text:000000D6                 push    edx
.text:000000D7                 mov     eax, [ebp+arg_C]
.text:000000DA                 mov     edx, [eax]
.text:000000DC                 mov     ecx, [ebp+arg_C]
.text:000000DF                 mov     eax, [edx]
.text:000000E1                 call    eax
.text:000000E3                 cmp     esi, esp
.text:000000E5                 call    __RTC_CheckEsp
.text:000000EA
.text:000000EA loc_EA:                                 ; CODE XREF: UpdateProduce(CRecordVector<CUpdatePair> const &,NUpdateArchive::CActionSet const &,CRecordVector<CUpdatePair2> &,IUpdateProduceCallback *)+9Aj
.text:000000EA                                         ; UpdateProduce(CRecordVector<CUpdatePair> const &,NUpdateArchive::CActionSet const &,CRecordVector<CUpdatePair2> &,IUpdateProduceCallback *)+A0j
.text:000000EA                 jmp     loc_4C
.text:000000EF ; ---------------------------------------------------------------------------
.text:000000EF
.text:000000EF $LN9:                                   ; CODE XREF: UpdateProduce(CRecordVector<CUpdatePair> const &,NUpdateArchive::CActionSet const &,CRecordVector<CUpdatePair2> &,IUpdateProduceCallback *)+8Cj
.text:000000EF                                         ; DATA XREF: .text:$LN22o
.text:000000EF                 mov     ecx, [ebp+var_8] ; jumptable 000000B8 case 1
.text:000000F2                 cmp     dword ptr [ecx], 2
.text:000000F5                 jnz     short loc_10E
.text:000000F7                 mov     edx, ds:_kUpdateActionSetCollision
.text:000000FD                 mov     [ebp+var_28], edx
.text:00000100                 push    offset __TI2CPAD
.text:00000105                 lea     eax, [ebp+var_28]
.text:00000108                 push    eax
.text:00000109                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:0000010E ; ---------------------------------------------------------------------------
.text:0000010E
.text:0000010E loc_10E:                                ; CODE XREF: UpdateProduce(CRecordVector<CUpdatePair> const &,NUpdateArchive::CActionSet const &,CRecordVector<CUpdatePair2> &,IUpdateProduceCallback *)+C9j
.text:0000010E                 mov     ecx, [ebp+var_8]
.text:00000111                 cmp     dword ptr [ecx], 1
.text:00000114                 jnz     short loc_139
.text:00000116                 mov     edx, [ebp+var_8]
.text:00000119                 cmp     dword ptr [edx+0Ch], 0
.text:0000011D                 jl      short loc_139
.text:0000011F                 mov     eax, [ebp+var_8]
.text:00000122                 mov     ecx, [eax+0Ch]
.text:00000125                 push    ecx
.text:00000126                 mov     ecx, [ebp+arg_0]
.text:00000129                 call    ??A?$CRecordVector@UCUpdatePair@@@@QBEABUCUpdatePair@@I@Z ; CRecordVector<CUpdatePair>::operator[](uint)
.text:0000012E                 cmp     dword ptr [eax+8], 0
.text:00000132                 jl      short loc_139
.text:00000134                 jmp     loc_4C
.text:00000139 ; ---------------------------------------------------------------------------
.text:00000139
.text:00000139 loc_139:                                ; CODE XREF: UpdateProduce(CRecordVector<CUpdatePair> const &,NUpdateArchive::CActionSet const &,CRecordVector<CUpdatePair2> &,IUpdateProduceCallback *)+E8j
.text:00000139                                         ; UpdateProduce(CRecordVector<CUpdatePair> const &,NUpdateArchive::CActionSet const &,CRecordVector<CUpdatePair2> &,IUpdateProduceCallback *)+F1j ...
.text:00000139                 mov     byte ptr [ebp+var_20+1], 0
.text:0000013D                 mov     dl, byte ptr [ebp+var_20+1]
.text:00000140                 mov     byte ptr [ebp+var_20], dl
.text:00000143                 mov     byte ptr [ebp+var_20+2], 1
.text:00000147                 jmp     short loc_185   ; jumptable 000000B8 default case
.text:00000149 ; ---------------------------------------------------------------------------
.text:00000149
.text:00000149 $LN4:                                   ; CODE XREF: UpdateProduce(CRecordVector<CUpdatePair> const &,NUpdateArchive::CActionSet const &,CRecordVector<CUpdatePair2> &,IUpdateProduceCallback *)+8Cj
.text:00000149                                         ; DATA XREF: .text:$LN22o
.text:00000149                 mov     eax, [ebp+var_8] ; jumptable 000000B8 case 2
.text:0000014C                 cmp     dword ptr [eax], 1
.text:0000014F                 jz      short loc_159
.text:00000151                 mov     ecx, [ebp+var_8]
.text:00000154                 cmp     dword ptr [ecx], 0
.text:00000157                 jnz     short loc_170
.text:00000159
.text:00000159 loc_159:                                ; CODE XREF: UpdateProduce(CRecordVector<CUpdatePair> const &,NUpdateArchive::CActionSet const &,CRecordVector<CUpdatePair2> &,IUpdateProduceCallback *)+123j
.text:00000159                 mov     edx, ds:_kUpdateActionSetCollision
.text:0000015F                 mov     [ebp+var_2C], edx
.text:00000162                 push    offset __TI2CPAD
.text:00000167                 lea     eax, [ebp+var_2C]
.text:0000016A                 push    eax
.text:0000016B                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:00000170 ; ---------------------------------------------------------------------------
.text:00000170
.text:00000170 loc_170:                                ; CODE XREF: UpdateProduce(CRecordVector<CUpdatePair> const &,NUpdateArchive::CActionSet const &,CRecordVector<CUpdatePair2> &,IUpdateProduceCallback *)+12Bj
.text:00000170                 jmp     short loc_185   ; jumptable 000000B8 default case
.text:00000172 ; ---------------------------------------------------------------------------
.text:00000172
.text:00000172 $LN1:                                   ; CODE XREF: UpdateProduce(CRecordVector<CUpdatePair> const &,NUpdateArchive::CActionSet const &,CRecordVector<CUpdatePair2> &,IUpdateProduceCallback *)+8Cj
.text:00000172                                         ; DATA XREF: .text:$LN22o
.text:00000172                 mov     byte ptr [ebp+var_20+3], 1 ; jumptable 000000B8 case 3
.text:00000176                 mov     ecx, [ebp+var_8]
.text:00000179                 xor     edx, edx
.text:0000017B                 cmp     dword ptr [ecx+4], 0
.text:0000017F                 setnl   dl
.text:00000182                 mov     byte ptr [ebp+var_20+2], dl
.text:00000185
.text:00000185 loc_185:                                ; CODE XREF: UpdateProduce(CRecordVector<CUpdatePair> const &,NUpdateArchive::CActionSet const &,CRecordVector<CUpdatePair2> &,IUpdateProduceCallback *)+83j
.text:00000185                                         ; UpdateProduce(CRecordVector<CUpdatePair> const &,NUpdateArchive::CActionSet const &,CRecordVector<CUpdatePair2> &,IUpdateProduceCallback *)+11Bj ...
.text:00000185                 sub     esp, 14h        ; jumptable 000000B8 default case
.text:00000188                 mov     eax, esp
.text:0000018A                 mov     ecx, [ebp+var_20]
.text:0000018D                 mov     [eax], ecx
.text:0000018F                 mov     edx, [ebp+var_1C]
.text:00000192                 mov     [eax+4], edx
.text:00000195                 mov     ecx, [ebp+var_18]
.text:00000198                 mov     [eax+8], ecx
.text:0000019B                 mov     edx, [ebp+var_14]
.text:0000019E                 mov     [eax+0Ch], edx
.text:000001A1                 mov     ecx, [ebp+var_10]
.text:000001A4                 mov     [eax+10h], ecx
.text:000001A7                 mov     ecx, [ebp+arg_8]
.text:000001AA                 call    ?Add@?$CRecordVector@UCUpdatePair2@@@@QAEIUCUpdatePair2@@@Z ; CRecordVector<CUpdatePair2>::Add(CUpdatePair2)
.text:000001AF                 jmp     loc_4C
.text:000001B4 ; ---------------------------------------------------------------------------
.text:000001B4
.text:000001B4 loc_1B4:                                ; CODE XREF: UpdateProduce(CRecordVector<CUpdatePair> const &,NUpdateArchive::CActionSet const &,CRecordVector<CUpdatePair2> &,IUpdateProduceCallback *)+34j
.text:000001B4                 mov     ecx, [ebp+arg_8]
.text:000001B7                 call    ?ReserveDown@?$CRecordVector@UCUpdatePair2@@@@QAEXXZ ; CRecordVector<CUpdatePair2>::ReserveDown(void)
.text:000001BC                 push    edx
.text:000001BD                 mov     ecx, ebp
.text:000001BF                 push    eax
.text:000001C0                 lea     edx, $LN21
.text:000001C6                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:000001CB                 pop     eax
.text:000001CC                 pop     edx
.text:000001CD                 pop     edi
.text:000001CE                 pop     esi
.text:000001CF                 add     esp, 30h
.text:000001D2                 cmp     ebp, esp
.text:000001D4                 call    __RTC_CheckEsp
.text:000001D9                 mov     esp, ebp
.text:000001DB                 pop     ebp
.text:000001DC                 retn    10h
.text:000001DC ?UpdateProduce@@YGXABV?$CRecordVector@UCUpdatePair@@@@ABUCActionSet@NUpdateArchive@@AAV?$CRecordVector@UCUpdatePair2@@@@PAUIUpdateProduceCallback@@@Z endp
.text:000001DC
.text:000001DC ; ---------------------------------------------------------------------------
.text:000001DF                 align 10h
.text:000001E0 $LN21           dd 1                    ; DATA XREF: UpdateProduce(CRecordVector<CUpdatePair> const &,NUpdateArchive::CActionSet const &,CRecordVector<CUpdatePair2> &,IUpdateProduceCallback *)+194o
.text:000001E4                 dd offset $LN20
.text:000001E8 $LN20           dd 0FFFFFFE0h, 14h      ; DATA XREF: .text:000001E4o
.text:000001F0                 dd offset $LN19
.text:000001F4 $LN19           dd 327075h              ; DATA XREF: .text:000001F0o
.text:000001F8 $LN22           dd offset $LN11         ; DATA XREF: UpdateProduce(CRecordVector<CUpdatePair> const &,NUpdateArchive::CActionSet const &,CRecordVector<CUpdatePair2> &,IUpdateProduceCallback *)+8Cr
.text:000001F8                 dd offset $LN9          ; jump table for switch statement
.text:000001F8                 dd offset $LN4
.text:000001F8                 dd offset $LN1
.text:000001F8 _text           ends
.text:000001F8
.xdata$x:00000208 ; ===========================================================================
.xdata$x:00000208
.xdata$x:00000208 ; Segment type: Pure data
.xdata$x:00000208 ; Segment permissions: Read
.xdata$x:00000208 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00000208                 assume cs:_xdata$x
.xdata$x:00000208                 ;org 208h
.xdata$x:00000208 ; COMDAT (pick any)
.xdata$x:00000208                 public __TI2CPAD
.xdata$x:00000208 __TI2CPAD       db    1                 ; DATA XREF: UpdateProduce(CRecordVector<CUpdatePair> const &,NUpdateArchive::CActionSet const &,CRecordVector<CUpdatePair2> &,IUpdateProduceCallback *)+D4o
.xdata$x:00000208                                         ; UpdateProduce(CRecordVector<CUpdatePair> const &,NUpdateArchive::CActionSet const &,CRecordVector<CUpdatePair2> &,IUpdateProduceCallback *)+136o
.xdata$x:00000209                 db    0
.xdata$x:0000020A                 db    0
.xdata$x:0000020B                 db    0
.xdata$x:0000020C                 db    0
.xdata$x:0000020D                 db    0
.xdata$x:0000020E                 db    0
.xdata$x:0000020F                 db    0
.xdata$x:00000210                 db    0
.xdata$x:00000211                 db    0
.xdata$x:00000212                 db    0
.xdata$x:00000213                 db    0
.xdata$x:00000214                 dd offset __CTA2PAD
.xdata$x:00000214 _xdata$x        ends
.xdata$x:00000214
.rtc$TMZ:00000218 ; ===========================================================================
.rtc$TMZ:00000218
.rtc$TMZ:00000218 ; Segment type: Pure data
.rtc$TMZ:00000218 ; Segment permissions: Read
.rtc$TMZ:00000218 _rtc$TMZ        segment dword public 'DATA' use32
.rtc$TMZ:00000218                 assume cs:_rtc$TMZ
.rtc$TMZ:00000218                 ;org 218h
.rtc$TMZ:00000218 ; COMDAT (pick any)
.rtc$TMZ:00000218 __RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
.rtc$TMZ:00000218 _rtc$TMZ        ends
.rtc$TMZ:00000218
.rtc$IMZ:0000021C ; ===========================================================================
.rtc$IMZ:0000021C
.rtc$IMZ:0000021C ; Segment type: Pure data
.rtc$IMZ:0000021C ; Segment permissions: Read
.rtc$IMZ:0000021C _rtc$IMZ        segment dword public 'DATA' use32
.rtc$IMZ:0000021C                 assume cs:_rtc$IMZ
.rtc$IMZ:0000021C                 ;org 21Ch
.rtc$IMZ:0000021C ; COMDAT (pick any)
.rtc$IMZ:0000021C __RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
.rtc$IMZ:0000021C _rtc$IMZ        ends
.rtc$IMZ:0000021C
.xdata$x:00000220 ; ===========================================================================
.xdata$x:00000220
.xdata$x:00000220 ; Segment type: Pure data
.xdata$x:00000220 ; Segment permissions: Read
.xdata$x:00000220 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00000220                 assume cs:_xdata$x
.xdata$x:00000220                 ;org 220h
.xdata$x:00000220 ; COMDAT (pick any)
.xdata$x:00000220                 public __CTA2PAD
.xdata$x:00000220 __CTA2PAD       db    2                 ; DATA XREF: .xdata$x:00000214o
.xdata$x:00000221                 db    0
.xdata$x:00000222                 db    0
.xdata$x:00000223                 db    0
.xdata$x:00000224                 dd offset __CT??_R0PAD@84
.xdata$x:00000228                 dd offset __CT??_R0PAX@84
.xdata$x:00000228 _xdata$x        ends
.xdata$x:00000228
.xdata$x:0000022C ; ===========================================================================
.xdata$x:0000022C
.xdata$x:0000022C ; Segment type: Pure data
.xdata$x:0000022C ; Segment permissions: Read
.xdata$x:0000022C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000022C                 assume cs:_xdata$x
.xdata$x:0000022C                 ;org 22Ch
.xdata$x:0000022C ; COMDAT (pick any)
.xdata$x:0000022C                 public __CT??_R0PAD@84
.xdata$x:0000022C __CT??_R0PAD@84 db    1                 ; DATA XREF: .xdata$x:00000224o
.xdata$x:0000022D                 db    0
.xdata$x:0000022E                 db    0
.xdata$x:0000022F                 db    0
.xdata$x:00000230                 dd offset ??_R0PAD@8    ; char * `RTTI Type Descriptor'
.xdata$x:00000234                 align 8
.xdata$x:00000238                 db 0FFh
.xdata$x:00000239                 db 0FFh
.xdata$x:0000023A                 db 0FFh
.xdata$x:0000023B                 db 0FFh
.xdata$x:0000023C                 db    0
.xdata$x:0000023D                 db    0
.xdata$x:0000023E                 db    0
.xdata$x:0000023F                 db    0
.xdata$x:00000240                 db    4
.xdata$x:00000241                 db    0
.xdata$x:00000242                 db    0
.xdata$x:00000243                 db    0
.xdata$x:00000244                 db    0
.xdata$x:00000245                 db    0
.xdata$x:00000246                 db    0
.xdata$x:00000247                 db    0
.xdata$x:00000247 _xdata$x        ends
.xdata$x:00000247
.data:00000248 ; ===========================================================================
.data:00000248
.data:00000248 ; Segment type: Pure data
.data:00000248 ; Segment permissions: Read/Write
.data:00000248 _data           segment dword public 'DATA' use32
.data:00000248                 assume cs:_data
.data:00000248                 ;org 248h
.data:00000248 ; COMDAT (pick any)
.data:00000248                 public ??_R0PAD@8
.data:00000248 ; char * `RTTI Type Descriptor'
.data:00000248 ??_R0PAD@8      dd offset ??_7type_info@@6B@ ; DATA XREF: .xdata$x:00000230o
.data:00000248                                         ; const type_info::`vftable'
.data:0000024C                 align 10h
.data:00000250 a_pad           db '.PAD',0
.data:00000255                 align 4
.data:00000255 _data           ends
.data:00000255
.xdata$x:00000258 ; ===========================================================================
.xdata$x:00000258
.xdata$x:00000258 ; Segment type: Pure data
.xdata$x:00000258 ; Segment permissions: Read
.xdata$x:00000258 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00000258                 assume cs:_xdata$x
.xdata$x:00000258                 ;org 258h
.xdata$x:00000258 ; COMDAT (pick any)
.xdata$x:00000258                 public __CT??_R0PAX@84
.xdata$x:00000258 __CT??_R0PAX@84 db    1                 ; DATA XREF: .xdata$x:00000228o
.xdata$x:00000259                 db    0
.xdata$x:0000025A                 db    0
.xdata$x:0000025B                 db    0
.xdata$x:0000025C                 dd offset ??_R0PAX@8    ; void * `RTTI Type Descriptor'
.xdata$x:00000260                 db    0
.xdata$x:00000261                 db    0
.xdata$x:00000262                 db    0
.xdata$x:00000263                 db    0
.xdata$x:00000264                 db 0FFh
.xdata$x:00000265                 db 0FFh
.xdata$x:00000266                 db 0FFh
.xdata$x:00000267                 db 0FFh
.xdata$x:00000268                 db    0
.xdata$x:00000269                 db    0
.xdata$x:0000026A                 db    0
.xdata$x:0000026B                 db    0
.xdata$x:0000026C                 db    4
.xdata$x:0000026D                 db    0
.xdata$x:0000026E                 db    0
.xdata$x:0000026F                 db    0
.xdata$x:00000270                 db    0
.xdata$x:00000271                 db    0
.xdata$x:00000272                 db    0
.xdata$x:00000273                 db    0
.xdata$x:00000273 _xdata$x        ends
.xdata$x:00000273
.data:00000274 ; ===========================================================================
.data:00000274
.data:00000274 ; Segment type: Pure data
.data:00000274 ; Segment permissions: Read/Write
.data:00000274 _data           segment dword public 'DATA' use32
.data:00000274                 assume cs:_data
.data:00000274                 ;org 274h
.data:00000274 ; COMDAT (pick any)
.data:00000274                 public ??_R0PAX@8
.data:00000274 ; void * `RTTI Type Descriptor'
.data:00000274 ??_R0PAX@8      dd offset ??_7type_info@@6B@ ; DATA XREF: .xdata$x:0000025Co
.data:00000274                                         ; const type_info::`vftable'
.data:00000278                 db    0
.data:00000279                 db    0
.data:0000027A                 db    0
.data:0000027B                 db    0
.data:0000027C                 db  2Eh ; .
.data:0000027D                 db  50h ; P
.data:0000027E                 db  41h ; A
.data:0000027F                 db  58h ; X
.data:00000280                 db    0
.data:00000281                 align 4
.data:00000281 _data           ends
.data:00000281
.text:00000284 ; ===========================================================================
.text:00000284
.text:00000284 ; Segment type: Pure code
.text:00000284 ; Segment permissions: Read/Execute
.text:00000284 _text           segment para public 'CODE' use32
.text:00000284                 assume cs:_text
.text:00000284                 ;org 284h
.text:00000284 ; COMDAT (pick any)
.text:00000284                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000284
.text:00000284 ; =============== S U B R O U T I N E =======================================
.text:00000284
.text:00000284 ; Attributes: bp-based frame
.text:00000284
.text:00000284 ; _DWORD __thiscall CUpdatePair2::CUpdatePair2(CUpdatePair2 *__hidden this)
.text:00000284                 public ??0CUpdatePair2@@QAE@XZ
.text:00000284 ??0CUpdatePair2@@QAE@XZ proc near       ; CODE XREF: UpdateProduce(CRecordVector<CUpdatePair> const &,NUpdateArchive::CActionSet const &,CRecordVector<CUpdatePair2> &,IUpdateProduceCallback *)+4Cp
.text:00000284                                         ; DATA XREF: CRecordVector<CUpdatePair2>::ReserveDown(void)+9Eo ...
.text:00000284
.text:00000284 var_4           = dword ptr -4
.text:00000284
.text:00000284                 push    ebp
.text:00000285                 mov     ebp, esp
.text:00000287                 push    ecx
.text:00000288                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000028F                 mov     [ebp+var_4], ecx
.text:00000292                 mov     eax, [ebp+var_4]
.text:00000295                 mov     byte ptr [eax], 0
.text:00000298                 mov     ecx, [ebp+var_4]
.text:0000029B                 mov     byte ptr [ecx+1], 0
.text:0000029F                 mov     edx, [ebp+var_4]
.text:000002A2                 mov     byte ptr [edx+2], 0
.text:000002A6                 mov     eax, [ebp+var_4]
.text:000002A9                 mov     byte ptr [eax+3], 0
.text:000002AD                 mov     ecx, [ebp+var_4]
.text:000002B0                 mov     dword ptr [ecx+4], 0FFFFFFFFh
.text:000002B7                 mov     edx, [ebp+var_4]
.text:000002BA                 mov     dword ptr [edx+8], 0FFFFFFFFh
.text:000002C1                 mov     eax, [ebp+var_4]
.text:000002C4                 mov     dword ptr [eax+0Ch], 0FFFFFFFFh
.text:000002CB                 mov     ecx, [ebp+var_4]
.text:000002CE                 mov     byte ptr [ecx+10h], 0
.text:000002D2                 mov     eax, [ebp+var_4]
.text:000002D5                 mov     esp, ebp
.text:000002D7                 pop     ebp
.text:000002D8                 retn
.text:000002D8 ??0CUpdatePair2@@QAE@XZ endp
.text:000002D8
.text:000002D8 ; ---------------------------------------------------------------------------
.text:000002D9                 align 4
.text:000002D9 _text           ends
.text:000002D9
.text:000002DC ; ===========================================================================
.text:000002DC
.text:000002DC ; Segment type: Pure code
.text:000002DC ; Segment permissions: Read/Execute
.text:000002DC _text           segment para public 'CODE' use32
.text:000002DC                 assume cs:_text
.text:000002DC                 ;org 2DCh
.text:000002DC ; COMDAT (pick any)
.text:000002DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000002DC
.text:000002DC ; =============== S U B R O U T I N E =======================================
.text:000002DC
.text:000002DC ; Attributes: bp-based frame
.text:000002DC
.text:000002DC ; public: unsigned int __thiscall CRecordVector<struct CUpdatePair>::Size(void)const
.text:000002DC                 public ?Size@?$CRecordVector@UCUpdatePair@@@@QBEIXZ
.text:000002DC ?Size@?$CRecordVector@UCUpdatePair@@@@QBEIXZ proc near
.text:000002DC                                         ; CODE XREF: UpdateProduce(CRecordVector<CUpdatePair> const &,NUpdateArchive::CActionSet const &,CRecordVector<CUpdatePair2> &,IUpdateProduceCallback *)+2Cp
.text:000002DC
.text:000002DC var_4           = dword ptr -4
.text:000002DC
.text:000002DC                 push    ebp
.text:000002DD                 mov     ebp, esp
.text:000002DF                 push    ecx
.text:000002E0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000002E7                 mov     [ebp+var_4], ecx
.text:000002EA                 mov     eax, [ebp+var_4]
.text:000002ED                 mov     eax, [eax+4]
.text:000002F0                 mov     esp, ebp
.text:000002F2                 pop     ebp
.text:000002F3                 retn
.text:000002F3 ?Size@?$CRecordVector@UCUpdatePair@@@@QBEIXZ endp
.text:000002F3
.text:000002F3 _text           ends
.text:000002F3
.text:000002F4 ; ===========================================================================
.text:000002F4
.text:000002F4 ; Segment type: Pure code
.text:000002F4 ; Segment permissions: Read/Execute
.text:000002F4 _text           segment para public 'CODE' use32
.text:000002F4                 assume cs:_text
.text:000002F4                 ;org 2F4h
.text:000002F4 ; COMDAT (pick any)
.text:000002F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000002F4
.text:000002F4 ; =============== S U B R O U T I N E =======================================
.text:000002F4
.text:000002F4 ; Attributes: bp-based frame
.text:000002F4
.text:000002F4 ; public: struct CUpdatePair const & __thiscall CRecordVector<struct CUpdatePair>::operator[](unsigned int)const
.text:000002F4                 public ??A?$CRecordVector@UCUpdatePair@@@@QBEABUCUpdatePair@@I@Z
.text:000002F4 ??A?$CRecordVector@UCUpdatePair@@@@QBEABUCUpdatePair@@I@Z proc near
.text:000002F4                                         ; CODE XREF: UpdateProduce(CRecordVector<CUpdatePair> const &,NUpdateArchive::CActionSet const &,CRecordVector<CUpdatePair2> &,IUpdateProduceCallback *)+41p
.text:000002F4                                         ; UpdateProduce(CRecordVector<CUpdatePair> const &,NUpdateArchive::CActionSet const &,CRecordVector<CUpdatePair2> &,IUpdateProduceCallback *)+FDp
.text:000002F4
.text:000002F4 var_4           = dword ptr -4
.text:000002F4 arg_0           = dword ptr  8
.text:000002F4
.text:000002F4                 push    ebp
.text:000002F5                 mov     ebp, esp
.text:000002F7                 push    ecx
.text:000002F8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000002FF                 mov     [ebp+var_4], ecx
.text:00000302                 mov     eax, [ebp+arg_0]
.text:00000305                 shl     eax, 4
.text:00000308                 mov     ecx, [ebp+var_4]
.text:0000030B                 add     eax, [ecx]
.text:0000030D                 mov     esp, ebp
.text:0000030F                 pop     ebp
.text:00000310                 retn    4
.text:00000310 ??A?$CRecordVector@UCUpdatePair@@@@QBEABUCUpdatePair@@I@Z endp
.text:00000310
.text:00000310 ; ---------------------------------------------------------------------------
.text:00000313                 align 4
.text:00000313 _text           ends
.text:00000313
.text:00000314 ; ===========================================================================
.text:00000314
.text:00000314 ; Segment type: Pure code
.text:00000314 ; Segment permissions: Read/Execute
.text:00000314 _text           segment para public 'CODE' use32
.text:00000314                 assume cs:_text
.text:00000314                 ;org 314h
.text:00000314 ; COMDAT (pick any)
.text:00000314                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000314
.text:00000314 ; =============== S U B R O U T I N E =======================================
.text:00000314
.text:00000314 ; Attributes: bp-based frame
.text:00000314
.text:00000314 ; public: void __thiscall CRecordVector<struct CUpdatePair2>::ReserveDown(void)
.text:00000314                 public ?ReserveDown@?$CRecordVector@UCUpdatePair2@@@@QAEXXZ
.text:00000314 ?ReserveDown@?$CRecordVector@UCUpdatePair2@@@@QAEXXZ proc near
.text:00000314                                         ; CODE XREF: UpdateProduce(CRecordVector<CUpdatePair> const &,NUpdateArchive::CActionSet const &,CRecordVector<CUpdatePair2> &,IUpdateProduceCallback *)+18Bp
.text:00000314
.text:00000314 var_28          = dword ptr -28h
.text:00000314 var_24          = dword ptr -24h
.text:00000314 var_20          = dword ptr -20h
.text:00000314 var_1C          = dword ptr -1Ch
.text:00000314 var_18          = dword ptr -18h
.text:00000314 Dst             = dword ptr -14h
.text:00000314 var_10          = dword ptr -10h
.text:00000314 var_C           = dword ptr -0Ch
.text:00000314 var_4           = dword ptr -4
.text:00000314
.text:00000314                 push    ebp
.text:00000315                 mov     ebp, esp
.text:00000317                 push    0FFFFFFFFh
.text:00000319                 push    offset __ehhandler$?ReserveDown@?$CRecordVector@UCUpdatePair2@@@@QAEXXZ
.text:0000031E                 mov     eax, large fs:0
.text:00000324                 push    eax
.text:00000325                 sub     esp, 1Ch
.text:00000328                 mov     eax, 0CCCCCCCCh
.text:0000032D                 mov     [ebp+var_28], eax
.text:00000330                 mov     [ebp+var_24], eax
.text:00000333                 mov     [ebp+var_20], eax
.text:00000336                 mov     [ebp+var_1C], eax
.text:00000339                 mov     [ebp+var_18], eax
.text:0000033C                 mov     [ebp+Dst], eax
.text:0000033F                 mov     [ebp+var_10], eax
.text:00000342                 mov     eax, dword ptr ds:___security_cookie
.text:00000347                 xor     eax, ebp
.text:00000349                 push    eax
.text:0000034A                 lea     eax, [ebp+var_C]
.text:0000034D                 mov     large fs:0, eax
.text:00000353                 mov     [ebp+var_10], ecx
.text:00000356                 mov     eax, [ebp+var_10]
.text:00000359                 mov     ecx, [ebp+var_10]
.text:0000035C                 mov     edx, [eax+4]
.text:0000035F                 cmp     edx, [ecx+8]
.text:00000362                 jnz     short loc_369
.text:00000364                 jmp     loc_42C
.text:00000369 ; ---------------------------------------------------------------------------
.text:00000369
.text:00000369 loc_369:                                ; CODE XREF: CRecordVector<CUpdatePair2>::ReserveDown(void)+4Ej
.text:00000369                 mov     [ebp+Dst], 0
.text:00000370                 mov     eax, [ebp+var_10]
.text:00000373                 cmp     dword ptr [eax+4], 0
.text:00000377                 jz      loc_404
.text:0000037D                 mov     ecx, [ebp+var_10]
.text:00000380                 mov     edx, [ecx+4]
.text:00000383                 mov     [ebp+var_18], edx
.text:00000386                 xor     ecx, ecx
.text:00000388                 mov     eax, [ebp+var_18]
.text:0000038B                 mov     edx, 14h
.text:00000390                 mul     edx
.text:00000392                 seto    cl
.text:00000395                 neg     ecx
.text:00000397                 or      ecx, eax
.text:00000399                 push    ecx             ; unsigned int
.text:0000039A                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0000039F                 add     esp, 4
.text:000003A2                 mov     [ebp+var_20], eax
.text:000003A5                 mov     [ebp+var_4], 0
.text:000003AC                 cmp     [ebp+var_20], 0
.text:000003B0                 jz      short loc_3CE
.text:000003B2                 push    offset ??0CUpdatePair2@@QAE@XZ ; CUpdatePair2::CUpdatePair2(void)
.text:000003B7                 mov     eax, [ebp+var_18]
.text:000003BA                 push    eax
.text:000003BB                 push    14h
.text:000003BD                 mov     ecx, [ebp+var_20]
.text:000003C0                 push    ecx
.text:000003C1                 call    ??_H@YGXPAXIHP6EPAX0@Z@Z ; `vector constructor iterator'(void *,uint,int,void * (*)(void *))
.text:000003C6                 mov     edx, [ebp+var_20]
.text:000003C9                 mov     [ebp+var_28], edx
.text:000003CC                 jmp     short loc_3D5
.text:000003CE ; ---------------------------------------------------------------------------
.text:000003CE
.text:000003CE loc_3CE:                                ; CODE XREF: CRecordVector<CUpdatePair2>::ReserveDown(void)+9Cj
.text:000003CE                 mov     [ebp+var_28], 0
.text:000003D5
.text:000003D5 loc_3D5:                                ; CODE XREF: CRecordVector<CUpdatePair2>::ReserveDown(void)+B8j
.text:000003D5                 mov     eax, [ebp+var_28]
.text:000003D8                 mov     [ebp+var_1C], eax
.text:000003DB                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000003E2                 mov     ecx, [ebp+var_1C]
.text:000003E5                 mov     [ebp+Dst], ecx
.text:000003E8                 mov     edx, [ebp+var_10]
.text:000003EB                 mov     eax, [edx+4]
.text:000003EE                 imul    eax, 14h
.text:000003F1                 push    eax             ; Size
.text:000003F2                 mov     ecx, [ebp+var_10]
.text:000003F5                 mov     edx, [ecx]
.text:000003F7                 push    edx             ; Src
.text:000003F8                 mov     eax, [ebp+Dst]
.text:000003FB                 push    eax             ; Dst
.text:000003FC                 call    _memcpy
.text:00000401                 add     esp, 0Ch
.text:00000404
.text:00000404 loc_404:                                ; CODE XREF: CRecordVector<CUpdatePair2>::ReserveDown(void)+63j
.text:00000404                 mov     ecx, [ebp+var_10]
.text:00000407                 mov     edx, [ecx]
.text:00000409                 mov     [ebp+var_24], edx
.text:0000040C                 mov     eax, [ebp+var_24]
.text:0000040F                 push    eax             ; void *
.text:00000410                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00000415                 add     esp, 4
.text:00000418                 mov     ecx, [ebp+var_10]
.text:0000041B                 mov     edx, [ebp+Dst]
.text:0000041E                 mov     [ecx], edx
.text:00000420                 mov     eax, [ebp+var_10]
.text:00000423                 mov     ecx, [ebp+var_10]
.text:00000426                 mov     edx, [ecx+4]
.text:00000429                 mov     [eax+8], edx
.text:0000042C
.text:0000042C loc_42C:                                ; CODE XREF: CRecordVector<CUpdatePair2>::ReserveDown(void)+50j
.text:0000042C                 mov     ecx, [ebp+var_C]
.text:0000042F                 mov     large fs:0, ecx
.text:00000436                 pop     ecx
.text:00000437                 add     esp, 28h
.text:0000043A                 cmp     ebp, esp
.text:0000043C                 call    __RTC_CheckEsp
.text:00000441                 mov     esp, ebp
.text:00000443                 pop     ebp
.text:00000444                 retn
.text:00000444 ?ReserveDown@?$CRecordVector@UCUpdatePair2@@@@QAEXXZ endp
.text:00000444
.text:00000444 ; ---------------------------------------------------------------------------
.text:00000445                 align 4
.text:00000445 _text           ends
.text:00000445
.text$x:00000448 ; ===========================================================================
.text$x:00000448
.text$x:00000448 ; Segment type: Pure code
.text$x:00000448 ; Segment permissions: Read/Execute
.text$x:00000448 _text$x         segment para public 'CODE' use32
.text$x:00000448                 assume cs:_text$x
.text$x:00000448                 ;org 448h
.text$x:00000448 ; COMDAT (pick associative to section at 314)
.text$x:00000448                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000448
.text$x:00000448 ; =============== S U B R O U T I N E =======================================
.text$x:00000448
.text$x:00000448
.text$x:00000448 __unwindfunclet$?ReserveDown@?$CRecordVector@UCUpdatePair2@@@@QAEXXZ$0 proc near
.text$x:00000448                                         ; DATA XREF: .xdata$x:00000474o
.text$x:00000448                 mov     eax, [ebp-20h]
.text$x:0000044B                 push    eax             ; void *
.text$x:0000044C                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00000451                 pop     ecx
.text$x:00000452                 retn
.text$x:00000452 __unwindfunclet$?ReserveDown@?$CRecordVector@UCUpdatePair2@@@@QAEXXZ$0 endp
.text$x:00000452
.text$x:00000453
.text$x:00000453 ; =============== S U B R O U T I N E =======================================
.text$x:00000453
.text$x:00000453
.text$x:00000453 __ehhandler$?ReserveDown@?$CRecordVector@UCUpdatePair2@@@@QAEXXZ proc near
.text$x:00000453                                         ; DATA XREF: CRecordVector<CUpdatePair2>::ReserveDown(void)+5o
.text$x:00000453
.text$x:00000453 arg_4           = dword ptr  8
.text$x:00000453
.text$x:00000453                 mov     edx, [esp+arg_4]
.text$x:00000457                 lea     eax, [edx+0Ch]
.text$x:0000045A                 mov     ecx, [edx-20h]
.text$x:0000045D                 xor     ecx, eax
.text$x:0000045F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000464                 mov     eax, offset __ehfuncinfo$?ReserveDown@?$CRecordVector@UCUpdatePair2@@@@QAEXXZ
.text$x:00000469                 jmp     ___CxxFrameHandler3
.text$x:00000469 __ehhandler$?ReserveDown@?$CRecordVector@UCUpdatePair2@@@@QAEXXZ endp
.text$x:00000469
.text$x:00000469 ; ---------------------------------------------------------------------------
.text$x:0000046E                 align 10h
.text$x:0000046E _text$x         ends
.text$x:0000046E
.xdata$x:00000470 ; ===========================================================================
.xdata$x:00000470
.xdata$x:00000470 ; Segment type: Pure data
.xdata$x:00000470 ; Segment permissions: Read
.xdata$x:00000470 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00000470                 assume cs:_xdata$x
.xdata$x:00000470                 ;org 470h
.xdata$x:00000470 ; COMDAT (pick associative to section at 314)
.xdata$x:00000470 __unwindtable$?ReserveDown@?$CRecordVector@UCUpdatePair2@@@@QAEXXZ db 0FFh
.xdata$x:00000470                                         ; DATA XREF: .xdata$x:00000480o
.xdata$x:00000471                 db 0FFh
.xdata$x:00000472                 db 0FFh
.xdata$x:00000473                 db 0FFh
.xdata$x:00000474                 dd offset __unwindfunclet$?ReserveDown@?$CRecordVector@UCUpdatePair2@@@@QAEXXZ$0
.xdata$x:00000478 __ehfuncinfo$?ReserveDown@?$CRecordVector@UCUpdatePair2@@@@QAEXXZ db  22h ; "
.xdata$x:00000478                                         ; DATA XREF: __ehhandler$?ReserveDown@?$CRecordVector@UCUpdatePair2@@@@QAEXXZ+11o
.xdata$x:00000479                 db    5
.xdata$x:0000047A                 db  93h ; ô
.xdata$x:0000047B                 db  19h
.xdata$x:0000047C                 db    1
.xdata$x:0000047D                 db    0
.xdata$x:0000047E                 db    0
.xdata$x:0000047F                 db    0
.xdata$x:00000480                 dd offset __unwindtable$?ReserveDown@?$CRecordVector@UCUpdatePair2@@@@QAEXXZ
.xdata$x:00000484                 db    0
.xdata$x:00000485                 db    0
.xdata$x:00000486                 db    0
.xdata$x:00000487                 db    0
.xdata$x:00000488                 db    0
.xdata$x:00000489                 db    0
.xdata$x:0000048A                 db    0
.xdata$x:0000048B                 db    0
.xdata$x:0000048C                 db    0
.xdata$x:0000048D                 db    0
.xdata$x:0000048E                 db    0
.xdata$x:0000048F                 db    0
.xdata$x:00000490                 db    0
.xdata$x:00000491                 db    0
.xdata$x:00000492                 db    0
.xdata$x:00000493                 db    0
.xdata$x:00000494                 db    0
.xdata$x:00000495                 db    0
.xdata$x:00000496                 db    0
.xdata$x:00000497                 db    0
.xdata$x:00000498                 db    1
.xdata$x:00000499                 db    0
.xdata$x:0000049A                 db    0
.xdata$x:0000049B                 db    0
.xdata$x:0000049B _xdata$x        ends
.xdata$x:0000049B
.text:0000049C ; ===========================================================================
.text:0000049C
.text:0000049C ; Segment type: Pure code
.text:0000049C ; Segment permissions: Read/Execute
.text:0000049C _text           segment para public 'CODE' use32
.text:0000049C                 assume cs:_text
.text:0000049C                 ;org 49Ch
.text:0000049C ; COMDAT (pick any)
.text:0000049C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000049C
.text:0000049C ; =============== S U B R O U T I N E =======================================
.text:0000049C
.text:0000049C ; Attributes: bp-based frame
.text:0000049C
.text:0000049C ; public: unsigned int __thiscall CRecordVector<struct CUpdatePair2>::Add(struct CUpdatePair2)
.text:0000049C                 public ?Add@?$CRecordVector@UCUpdatePair2@@@@QAEIUCUpdatePair2@@@Z
.text:0000049C ?Add@?$CRecordVector@UCUpdatePair2@@@@QAEIUCUpdatePair2@@@Z proc near
.text:0000049C                                         ; CODE XREF: UpdateProduce(CRecordVector<CUpdatePair> const &,NUpdateArchive::CActionSet const &,CRecordVector<CUpdatePair2> &,IUpdateProduceCallback *)+17Ep
.text:0000049C
.text:0000049C var_8           = dword ptr -8
.text:0000049C var_4           = dword ptr -4
.text:0000049C arg_0           = dword ptr  8
.text:0000049C arg_4           = dword ptr  0Ch
.text:0000049C arg_8           = dword ptr  10h
.text:0000049C arg_C           = dword ptr  14h
.text:0000049C arg_10          = dword ptr  18h
.text:0000049C
.text:0000049C                 push    ebp
.text:0000049D                 mov     ebp, esp
.text:0000049F                 sub     esp, 8
.text:000004A2                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000004A9                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000004B0                 mov     [ebp+var_4], ecx
.text:000004B3                 mov     ecx, [ebp+var_4]
.text:000004B6                 call    ?ReserveOnePosition@?$CRecordVector@UCUpdatePair2@@@@AAEXXZ ; CRecordVector<CUpdatePair2>::ReserveOnePosition(void)
.text:000004BB                 mov     eax, [ebp+var_4]
.text:000004BE                 mov     ecx, [eax+4]
.text:000004C1                 imul    ecx, 14h
.text:000004C4                 mov     edx, [ebp+var_4]
.text:000004C7                 mov     eax, [edx]
.text:000004C9                 add     eax, ecx
.text:000004CB                 mov     ecx, [ebp+arg_0]
.text:000004CE                 mov     [eax], ecx
.text:000004D0                 mov     edx, [ebp+arg_4]
.text:000004D3                 mov     [eax+4], edx
.text:000004D6                 mov     ecx, [ebp+arg_8]
.text:000004D9                 mov     [eax+8], ecx
.text:000004DC                 mov     edx, [ebp+arg_C]
.text:000004DF                 mov     [eax+0Ch], edx
.text:000004E2                 mov     ecx, [ebp+arg_10]
.text:000004E5                 mov     [eax+10h], ecx
.text:000004E8                 mov     edx, [ebp+var_4]
.text:000004EB                 mov     eax, [edx+4]
.text:000004EE                 mov     [ebp+var_8], eax
.text:000004F1                 mov     ecx, [ebp+var_4]
.text:000004F4                 mov     edx, [ecx+4]
.text:000004F7                 add     edx, 1
.text:000004FA                 mov     eax, [ebp+var_4]
.text:000004FD                 mov     [eax+4], edx
.text:00000500                 mov     eax, [ebp+var_8]
.text:00000503                 add     esp, 8
.text:00000506                 cmp     ebp, esp
.text:00000508                 call    __RTC_CheckEsp
.text:0000050D                 mov     esp, ebp
.text:0000050F                 pop     ebp
.text:00000510                 retn    14h
.text:00000510 ?Add@?$CRecordVector@UCUpdatePair2@@@@QAEIUCUpdatePair2@@@Z endp
.text:00000510
.text:00000510 ; ---------------------------------------------------------------------------
.text:00000513                 align 4
.text:00000513 _text           ends
.text:00000513
.text:00000514 ; ===========================================================================
.text:00000514
.text:00000514 ; Segment type: Pure code
.text:00000514 ; Segment permissions: Read/Execute
.text:00000514 _text           segment para public 'CODE' use32
.text:00000514                 assume cs:_text
.text:00000514                 ;org 514h
.text:00000514 ; COMDAT (pick any)
.text:00000514                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000514
.text:00000514 ; =============== S U B R O U T I N E =======================================
.text:00000514
.text:00000514 ; Attributes: bp-based frame
.text:00000514
.text:00000514 ; void __stdcall `vector constructor iterator'(void *, unsigned int, int, void * (__thiscall *)(void *))
.text:00000514                 public ??_H@YGXPAXIHP6EPAX0@Z@Z
.text:00000514 ??_H@YGXPAXIHP6EPAX0@Z@Z proc near      ; CODE XREF: CRecordVector<CUpdatePair2>::ReserveDown(void)+ADp
.text:00000514                                         ; CRecordVector<CUpdatePair2>::ReserveOnePosition(void)+AEp
.text:00000514
.text:00000514 arg_0           = dword ptr  8
.text:00000514 arg_4           = dword ptr  0Ch
.text:00000514 arg_8           = dword ptr  10h
.text:00000514 arg_C           = dword ptr  14h
.text:00000514
.text:00000514                 push    ebp
.text:00000515                 mov     ebp, esp
.text:00000517                 push    esi
.text:00000518
.text:00000518 loc_518:                                ; CODE XREF: `vector constructor iterator'(void *,uint,int,void * (*)(void *))+27j
.text:00000518                 mov     eax, [ebp+arg_8]
.text:0000051B                 sub     eax, 1
.text:0000051E                 mov     [ebp+arg_8], eax
.text:00000521                 js      short loc_53D
.text:00000523                 mov     esi, esp
.text:00000525                 mov     ecx, [ebp+arg_0]
.text:00000528                 call    [ebp+arg_C]
.text:0000052B                 cmp     esi, esp
.text:0000052D                 call    __RTC_CheckEsp
.text:00000532                 mov     ecx, [ebp+arg_0]
.text:00000535                 add     ecx, [ebp+arg_4]
.text:00000538                 mov     [ebp+arg_0], ecx
.text:0000053B                 jmp     short loc_518
.text:0000053D ; ---------------------------------------------------------------------------
.text:0000053D
.text:0000053D loc_53D:                                ; CODE XREF: `vector constructor iterator'(void *,uint,int,void * (*)(void *))+Dj
.text:0000053D                 pop     esi
.text:0000053E                 cmp     ebp, esp
.text:00000540                 call    __RTC_CheckEsp
.text:00000545                 pop     ebp
.text:00000546                 retn    10h
.text:00000546 ??_H@YGXPAXIHP6EPAX0@Z@Z endp
.text:00000546
.text:00000546 ; ---------------------------------------------------------------------------
.text:00000549                 align 4
.text:00000549 _text           ends
.text:00000549
.text:0000054C ; ===========================================================================
.text:0000054C
.text:0000054C ; Segment type: Pure code
.text:0000054C ; Segment permissions: Read/Execute
.text:0000054C _text           segment para public 'CODE' use32
.text:0000054C                 assume cs:_text
.text:0000054C                 ;org 54Ch
.text:0000054C ; COMDAT (pick any)
.text:0000054C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000054C
.text:0000054C ; =============== S U B R O U T I N E =======================================
.text:0000054C
.text:0000054C ; Attributes: bp-based frame
.text:0000054C
.text:0000054C ; private: void __thiscall CRecordVector<struct CUpdatePair2>::ReserveOnePosition(void)
.text:0000054C                 public ?ReserveOnePosition@?$CRecordVector@UCUpdatePair2@@@@AAEXXZ
.text:0000054C ?ReserveOnePosition@?$CRecordVector@UCUpdatePair2@@@@AAEXXZ proc near
.text:0000054C                                         ; CODE XREF: CRecordVector<CUpdatePair2>::Add(CUpdatePair2)+1Ap
.text:0000054C
.text:0000054C var_2C          = dword ptr -2Ch
.text:0000054C var_28          = dword ptr -28h
.text:0000054C var_24          = dword ptr -24h
.text:0000054C var_20          = dword ptr -20h
.text:0000054C var_1C          = dword ptr -1Ch
.text:0000054C Dst             = dword ptr -18h
.text:0000054C var_14          = dword ptr -14h
.text:0000054C var_10          = dword ptr -10h
.text:0000054C var_C           = dword ptr -0Ch
.text:0000054C var_4           = dword ptr -4
.text:0000054C
.text:0000054C                 push    ebp
.text:0000054D                 mov     ebp, esp
.text:0000054F                 push    0FFFFFFFFh
.text:00000551                 push    offset __ehhandler$?ReserveOnePosition@?$CRecordVector@UCUpdatePair2@@@@AAEXXZ
.text:00000556                 mov     eax, large fs:0
.text:0000055C                 push    eax
.text:0000055D                 sub     esp, 20h
.text:00000560                 mov     eax, 0CCCCCCCCh
.text:00000565                 mov     [ebp+var_2C], eax
.text:00000568                 mov     [ebp+var_28], eax
.text:0000056B                 mov     [ebp+var_24], eax
.text:0000056E                 mov     [ebp+var_20], eax
.text:00000571                 mov     [ebp+var_1C], eax
.text:00000574                 mov     [ebp+Dst], eax
.text:00000577                 mov     [ebp+var_14], eax
.text:0000057A                 mov     [ebp+var_10], eax
.text:0000057D                 mov     eax, dword ptr ds:___security_cookie
.text:00000582                 xor     eax, ebp
.text:00000584                 push    eax
.text:00000585                 lea     eax, [ebp+var_C]
.text:00000588                 mov     large fs:0, eax
.text:0000058E                 mov     [ebp+var_10], ecx
.text:00000591                 mov     eax, [ebp+var_10]
.text:00000594                 mov     ecx, [ebp+var_10]
.text:00000597                 mov     edx, [eax+4]
.text:0000059A                 cmp     edx, [ecx+8]
.text:0000059D                 jnz     loc_66B
.text:000005A3                 mov     eax, [ebp+var_10]
.text:000005A6                 mov     ecx, [eax+8]
.text:000005A9                 shr     ecx, 2
.text:000005AC                 mov     edx, [ebp+var_10]
.text:000005AF                 mov     eax, [edx+8]
.text:000005B2                 lea     ecx, [eax+ecx+1]
.text:000005B6                 mov     [ebp+var_14], ecx
.text:000005B9                 mov     edx, [ebp+var_14]
.text:000005BC                 mov     [ebp+var_1C], edx
.text:000005BF                 xor     ecx, ecx
.text:000005C1                 mov     eax, [ebp+var_1C]
.text:000005C4                 mov     edx, 14h
.text:000005C9                 mul     edx
.text:000005CB                 seto    cl
.text:000005CE                 neg     ecx
.text:000005D0                 or      ecx, eax
.text:000005D2                 push    ecx             ; unsigned int
.text:000005D3                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:000005D8                 add     esp, 4
.text:000005DB                 mov     [ebp+var_24], eax
.text:000005DE                 mov     [ebp+var_4], 0
.text:000005E5                 cmp     [ebp+var_24], 0
.text:000005E9                 jz      short loc_607
.text:000005EB                 push    offset ??0CUpdatePair2@@QAE@XZ ; CUpdatePair2::CUpdatePair2(void)
.text:000005F0                 mov     eax, [ebp+var_1C]
.text:000005F3                 push    eax
.text:000005F4                 push    14h
.text:000005F6                 mov     ecx, [ebp+var_24]
.text:000005F9                 push    ecx
.text:000005FA                 call    ??_H@YGXPAXIHP6EPAX0@Z@Z ; `vector constructor iterator'(void *,uint,int,void * (*)(void *))
.text:000005FF                 mov     edx, [ebp+var_24]
.text:00000602                 mov     [ebp+var_2C], edx
.text:00000605                 jmp     short loc_60E
.text:00000607 ; ---------------------------------------------------------------------------
.text:00000607
.text:00000607 loc_607:                                ; CODE XREF: CRecordVector<CUpdatePair2>::ReserveOnePosition(void)+9Dj
.text:00000607                 mov     [ebp+var_2C], 0
.text:0000060E
.text:0000060E loc_60E:                                ; CODE XREF: CRecordVector<CUpdatePair2>::ReserveOnePosition(void)+B9j
.text:0000060E                 mov     eax, [ebp+var_2C]
.text:00000611                 mov     [ebp+var_20], eax
.text:00000614                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000061B                 mov     ecx, [ebp+var_20]
.text:0000061E                 mov     [ebp+Dst], ecx
.text:00000621                 mov     edx, [ebp+var_10]
.text:00000624                 cmp     dword ptr [edx+4], 0
.text:00000628                 jz      short loc_646
.text:0000062A                 mov     eax, [ebp+var_10]
.text:0000062D                 mov     ecx, [eax+4]
.text:00000630                 imul    ecx, 14h
.text:00000633                 push    ecx             ; Size
.text:00000634                 mov     edx, [ebp+var_10]
.text:00000637                 mov     eax, [edx]
.text:00000639                 push    eax             ; Src
.text:0000063A                 mov     ecx, [ebp+Dst]
.text:0000063D                 push    ecx             ; Dst
.text:0000063E                 call    _memcpy
.text:00000643                 add     esp, 0Ch
.text:00000646
.text:00000646 loc_646:                                ; CODE XREF: CRecordVector<CUpdatePair2>::ReserveOnePosition(void)+DCj
.text:00000646                 mov     edx, [ebp+var_10]
.text:00000649                 mov     eax, [edx]
.text:0000064B                 mov     [ebp+var_28], eax
.text:0000064E                 mov     ecx, [ebp+var_28]
.text:00000651                 push    ecx             ; void *
.text:00000652                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00000657                 add     esp, 4
.text:0000065A                 mov     edx, [ebp+var_10]
.text:0000065D                 mov     eax, [ebp+Dst]
.text:00000660                 mov     [edx], eax
.text:00000662                 mov     ecx, [ebp+var_10]
.text:00000665                 mov     edx, [ebp+var_14]
.text:00000668                 mov     [ecx+8], edx
.text:0000066B
.text:0000066B loc_66B:                                ; CODE XREF: CRecordVector<CUpdatePair2>::ReserveOnePosition(void)+51j
.text:0000066B                 mov     ecx, [ebp+var_C]
.text:0000066E                 mov     large fs:0, ecx
.text:00000675                 pop     ecx
.text:00000676                 add     esp, 2Ch
.text:00000679                 cmp     ebp, esp
.text:0000067B                 call    __RTC_CheckEsp
.text:00000680                 mov     esp, ebp
.text:00000682                 pop     ebp
.text:00000683                 retn
.text:00000683 ?ReserveOnePosition@?$CRecordVector@UCUpdatePair2@@@@AAEXXZ endp
.text:00000683
.text:00000683 _text           ends
.text:00000683
.text$x:00000684 ; ===========================================================================
.text$x:00000684
.text$x:00000684 ; Segment type: Pure code
.text$x:00000684 ; Segment permissions: Read/Execute
.text$x:00000684 _text$x         segment para public 'CODE' use32
.text$x:00000684                 assume cs:_text$x
.text$x:00000684                 ;org 684h
.text$x:00000684 ; COMDAT (pick associative to section at 54C)
.text$x:00000684                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000684
.text$x:00000684 ; =============== S U B R O U T I N E =======================================
.text$x:00000684
.text$x:00000684
.text$x:00000684 __unwindfunclet$?ReserveOnePosition@?$CRecordVector@UCUpdatePair2@@@@AAEXXZ$0 proc near
.text$x:00000684                                         ; DATA XREF: .xdata$x:000006B0o
.text$x:00000684                 mov     eax, [ebp-24h]
.text$x:00000687                 push    eax             ; void *
.text$x:00000688                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:0000068D                 pop     ecx
.text$x:0000068E                 retn
.text$x:0000068E __unwindfunclet$?ReserveOnePosition@?$CRecordVector@UCUpdatePair2@@@@AAEXXZ$0 endp
.text$x:0000068E
.text$x:0000068F
.text$x:0000068F ; =============== S U B R O U T I N E =======================================
.text$x:0000068F
.text$x:0000068F
.text$x:0000068F __ehhandler$?ReserveOnePosition@?$CRecordVector@UCUpdatePair2@@@@AAEXXZ proc near
.text$x:0000068F                                         ; DATA XREF: CRecordVector<CUpdatePair2>::ReserveOnePosition(void)+5o
.text$x:0000068F
.text$x:0000068F arg_4           = dword ptr  8
.text$x:0000068F
.text$x:0000068F                 mov     edx, [esp+arg_4]
.text$x:00000693                 lea     eax, [edx+0Ch]
.text$x:00000696                 mov     ecx, [edx-24h]
.text$x:00000699                 xor     ecx, eax
.text$x:0000069B                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000006A0                 mov     eax, offset __ehfuncinfo$?ReserveOnePosition@?$CRecordVector@UCUpdatePair2@@@@AAEXXZ
.text$x:000006A5                 jmp     ___CxxFrameHandler3
.text$x:000006A5 __ehhandler$?ReserveOnePosition@?$CRecordVector@UCUpdatePair2@@@@AAEXXZ endp
.text$x:000006A5
.text$x:000006A5 ; ---------------------------------------------------------------------------
.text$x:000006AA                 align 4
.text$x:000006AA _text$x         ends
.text$x:000006AA
.xdata$x:000006AC ; ===========================================================================
.xdata$x:000006AC
.xdata$x:000006AC ; Segment type: Pure data
.xdata$x:000006AC ; Segment permissions: Read
.xdata$x:000006AC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000006AC                 assume cs:_xdata$x
.xdata$x:000006AC                 ;org 6ACh
.xdata$x:000006AC ; COMDAT (pick associative to section at 54C)
.xdata$x:000006AC __unwindtable$?ReserveOnePosition@?$CRecordVector@UCUpdatePair2@@@@AAEXXZ db 0FFh
.xdata$x:000006AC                                         ; DATA XREF: .xdata$x:000006BCo
.xdata$x:000006AD                 db 0FFh
.xdata$x:000006AE                 db 0FFh
.xdata$x:000006AF                 db 0FFh
.xdata$x:000006B0                 dd offset __unwindfunclet$?ReserveOnePosition@?$CRecordVector@UCUpdatePair2@@@@AAEXXZ$0
.xdata$x:000006B4 __ehfuncinfo$?ReserveOnePosition@?$CRecordVector@UCUpdatePair2@@@@AAEXXZ db  22h ; "
.xdata$x:000006B4                                         ; DATA XREF: __ehhandler$?ReserveOnePosition@?$CRecordVector@UCUpdatePair2@@@@AAEXXZ+11o
.xdata$x:000006B5                 db    5
.xdata$x:000006B6                 db  93h ; ô
.xdata$x:000006B7                 db  19h
.xdata$x:000006B8                 db    1
.xdata$x:000006B9                 db    0
.xdata$x:000006BA                 db    0
.xdata$x:000006BB                 db    0
.xdata$x:000006BC                 dd offset __unwindtable$?ReserveOnePosition@?$CRecordVector@UCUpdatePair2@@@@AAEXXZ
.xdata$x:000006C0                 db    0
.xdata$x:000006C1                 db    0
.xdata$x:000006C2                 db    0
.xdata$x:000006C3                 db    0
.xdata$x:000006C4                 db    0
.xdata$x:000006C5                 db    0
.xdata$x:000006C6                 db    0
.xdata$x:000006C7                 db    0
.xdata$x:000006C8                 db    0
.xdata$x:000006C9                 db    0
.xdata$x:000006CA                 db    0
.xdata$x:000006CB                 db    0
.xdata$x:000006CC                 db    0
.xdata$x:000006CD                 db    0
.xdata$x:000006CE                 db    0
.xdata$x:000006CF                 db    0
.xdata$x:000006D0                 db    0
.xdata$x:000006D1                 db    0
.xdata$x:000006D2                 db    0
.xdata$x:000006D3                 db    0
.xdata$x:000006D4                 db    1
.xdata$x:000006D5                 db    0
.xdata$x:000006D6                 db    0
.xdata$x:000006D7                 db    0
.xdata$x:000006D7 _xdata$x        ends
.xdata$x:000006D7
UNDEF:000006E0 ; ===========================================================================
UNDEF:000006E0
UNDEF:000006E0 ; Segment type: Externs
UNDEF:000006E0 ; UNDEF
UNDEF:000006E0 ; __fastcall _RTC_CheckStackVars(x, x)
UNDEF:000006E0                 extrn @_RTC_CheckStackVars@8:near
UNDEF:000006E0                                         ; CODE XREF: UpdateProduce(CRecordVector<CUpdatePair> const &,NUpdateArchive::CActionSet const &,CRecordVector<CUpdatePair2> &,IUpdateProduceCallback *)+19Ap
UNDEF:000006E4                 extrn __RTC_CheckEsp:near
UNDEF:000006E4                                         ; CODE XREF: UpdateProduce(CRecordVector<CUpdatePair> const &,NUpdateArchive::CActionSet const &,CRecordVector<CUpdatePair2> &,IUpdateProduceCallback *)+B9p
UNDEF:000006E4                                         ; UpdateProduce(CRecordVector<CUpdatePair> const &,NUpdateArchive::CActionSet const &,CRecordVector<CUpdatePair2> &,IUpdateProduceCallback *)+1A8p ...
UNDEF:000006E8                 extrn __RTC_Shutdown:near
UNDEF:000006E8                                         ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
UNDEF:000006EC                 extrn __RTC_InitBase:near
UNDEF:000006EC                                         ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
UNDEF:000006F0 ; __stdcall _CxxThrowException(x, x)
UNDEF:000006F0                 extrn __CxxThrowException@8:near
UNDEF:000006F0                                         ; CODE XREF: UpdateProduce(CRecordVector<CUpdatePair> const &,NUpdateArchive::CActionSet const &,CRecordVector<CUpdatePair2> &,IUpdateProduceCallback *)+DDp
UNDEF:000006F0                                         ; UpdateProduce(CRecordVector<CUpdatePair> const &,NUpdateArchive::CActionSet const &,CRecordVector<CUpdatePair2> &,IUpdateProduceCallback *)+13Fp
UNDEF:000006F4 ; const type_info::`vftable'
UNDEF:000006F4                 extrn ??_7type_info@@6B@:near
UNDEF:000006F4                                         ; DATA XREF: .data:char * `RTTI Type Descriptor'o
UNDEF:000006F4                                         ; .data:void * `RTTI Type Descriptor'o
UNDEF:000006F8 ; void __cdecl operator delete(void *)
UNDEF:000006F8                 extrn ??3@YAXPAX@Z:near ; CODE XREF: CRecordVector<CUpdatePair2>::ReserveDown(void)+FCp
UNDEF:000006F8                                         ; __unwindfunclet$?ReserveDown@?$CRecordVector@UCUpdatePair2@@@@QAEXXZ$0+4p ...
UNDEF:000006FC ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:000006FC                 extrn _memcpy:near      ; CODE XREF: CRecordVector<CUpdatePair2>::ReserveDown(void)+E8p
UNDEF:000006FC                                         ; CRecordVector<CUpdatePair2>::ReserveOnePosition(void)+F2p
UNDEF:00000700 ; void *__cdecl operator new(unsigned int)
UNDEF:00000700                 extrn ??2@YAPAXI@Z:near ; CODE XREF: CRecordVector<CUpdatePair2>::ReserveDown(void)+86p
UNDEF:00000700                                         ; CRecordVector<CUpdatePair2>::ReserveOnePosition(void)+87p
UNDEF:00000704                 extrn ___security_cookie:near
UNDEF:00000704                                         ; DATA XREF: CRecordVector<CUpdatePair2>::ReserveDown(void)+2Er
UNDEF:00000704                                         ; CRecordVector<CUpdatePair2>::ReserveOnePosition(void)+31r
UNDEF:00000708                 extrn ___CxxFrameHandler3:near
UNDEF:00000708                                         ; CODE XREF: __ehhandler$?ReserveDown@?$CRecordVector@UCUpdatePair2@@@@QAEXXZ+16j
UNDEF:00000708                                         ; __ehhandler$?ReserveOnePosition@?$CRecordVector@UCUpdatePair2@@@@AAEXXZ+16j
UNDEF:0000070C ; __fastcall __security_check_cookie(x)
UNDEF:0000070C                 extrn @__security_check_cookie@4:near
UNDEF:0000070C                                         ; CODE XREF: __ehhandler$?ReserveDown@?$CRecordVector@UCUpdatePair2@@@@QAEXXZ+Cp
UNDEF:0000070C                                         ; __ehhandler$?ReserveOnePosition@?$CRecordVector@UCUpdatePair2@@@@AAEXXZ+Cp
UNDEF:0000070C
UNDEF:0000070C
UNDEF:0000070C                 end