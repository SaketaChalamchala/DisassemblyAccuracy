.rdata:00000000 ;
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.rdata:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.rdata:00000000 ; |                      License info: 48-3677-7074-51                      |
.rdata:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ;
.rdata:00000000 ; Input MD5   : 88F3F2539C46B2CED6599C26B27F98F6
.rdata:00000000 ; Input CRC32 : D9E74F35
.rdata:00000000
.rdata:00000000 ; File Name   : C:\workspace\7z1505-src\CPP\7zip\Bundles\Alone\Debug\Extract.obj
.rdata:00000000 ; Format      : COFF (X386MAGIC)
.rdata:00000000 ; includelib "uuid.lib"
.rdata:00000000 ; includelib "MSVCRTD"
.rdata:00000000 ; includelib "OLDNAMES"
.rdata:00000000
.rdata:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.rdata:00000000
.rdata:00000000                 .686p
.rdata:00000000                 .mmx
.rdata:00000000                 .model flat
.rdata:00000000
.rdata:00000000 ; ===========================================================================
.rdata:00000000
.rdata:00000000 ; Segment type: Pure data
.rdata:00000000 ; Segment permissions: Read
.rdata:00000000 _rdata          segment dword public 'DATA' use32
.rdata:00000000                 assume cs:_rdata
.rdata:00000000 ; char _SG73813[3]
.rdata:00000000 $SG73813        db 'pe',0               ; DATA XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+C0o
.rdata:00000003                 db    0
.rdata:00000004 ; wchar_t _SG73816
.rdata:00000004 $SG73816        dd offset $SG73870+1Ah  ; DATA XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &):loc_1106o
.rdata:00000004                                         ; "ctory: "
.rdata:00000008 $SG73863:                               ; DATA XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+662o
.rdata:00000008                 unicode 0, <.\>,0
.rdata:0000000E                 align 10h
.rdata:00000010 ; char _SG73870[]
.rdata:00000010 $SG73870        db 'Can not create output directory: ',0
.rdata:00000010                                         ; DATA XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &):loc_16B9o
.rdata:00000032                 align 4
.rdata:00000034 $SG73937        db 'there is no such archive',0
.rdata:00000034                                         ; DATA XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+F9o
.rdata:0000004D                 align 10h
.rdata:00000050 $SG73940        db 'can',27h,'t decompress folder',0
.rdata:00000050                                         ; DATA XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+123o
.rdata:00000068 $SG74025        db 'there is no such archive',0
.rdata:00000068                                         ; DATA XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &):loc_4C5o
.rdata:00000081                 align 4
.rdata:00000081 _rdata          ends
.rdata:00000081
.text:00000084 ; ===========================================================================
.text:00000084
.text:00000084 ; Segment type: Pure code
.text:00000084 ; Segment permissions: Read/Execute
.text:00000084 _text           segment para public 'CODE' use32
.text:00000084                 assume cs:_text
.text:00000084                 ;org 84h
.text:00000084                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00000084
.text:00000084 ; =============== S U B R O U T I N E =======================================
.text:00000084
.text:00000084 ; Attributes: bp-based frame
.text:00000084
.text:00000084 ; int __stdcall Find_FileName_InSortedVector(class CObjectVector<class UString> const &, class UString const &)
.text:00000084                 public ?Find_FileName_InSortedVector@@YGHABV?$CObjectVector@VUString@@@@ABVUString@@@Z
.text:00000084 ?Find_FileName_InSortedVector@@YGHABV?$CObjectVector@VUString@@@@ABVUString@@@Z proc near
.text:00000084                                         ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+79Ap
.text:00000084
.text:00000084 var_14          = dword ptr -14h
.text:00000084 var_10          = dword ptr -10h
.text:00000084 var_C           = dword ptr -0Ch
.text:00000084 var_8           = dword ptr -8
.text:00000084 var_4           = dword ptr -4
.text:00000084 arg_0           = dword ptr  8
.text:00000084 arg_4           = dword ptr  0Ch
.text:00000084
.text:00000084                 push    ebp
.text:00000085                 mov     ebp, esp
.text:00000087                 sub     esp, 14h
.text:0000008A                 mov     eax, 0CCCCCCCCh
.text:0000008F                 mov     [ebp+var_14], eax
.text:00000092                 mov     [ebp+var_10], eax
.text:00000095                 mov     [ebp+var_C], eax
.text:00000098                 mov     [ebp+var_8], eax
.text:0000009B                 mov     [ebp+var_4], eax
.text:0000009E                 mov     [ebp+var_4], 0
.text:000000A5                 mov     ecx, [ebp+arg_0]
.text:000000A8                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:000000AD                 mov     [ebp+var_8], eax
.text:000000B0
.text:000000B0 loc_B0:                                 ; CODE XREF: Find_FileName_InSortedVector(CObjectVector<UString> const &,UString const &):loc_10Ej
.text:000000B0                 mov     eax, [ebp+var_4]
.text:000000B3                 cmp     eax, [ebp+var_8]
.text:000000B6                 jz      short loc_110
.text:000000B8                 mov     ecx, [ebp+var_4]
.text:000000BB                 add     ecx, [ebp+var_8]
.text:000000BE                 shr     ecx, 1
.text:000000C0                 mov     [ebp+var_C], ecx
.text:000000C3                 mov     edx, [ebp+var_C]
.text:000000C6                 push    edx
.text:000000C7                 mov     ecx, [ebp+arg_0]
.text:000000CA                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:000000CF                 mov     [ebp+var_10], eax
.text:000000D2                 mov     ecx, [ebp+var_10]
.text:000000D5                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000000DA                 push    eax             ; wchar_t *
.text:000000DB                 mov     ecx, [ebp+arg_4]
.text:000000DE                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000000E3                 push    eax             ; wchar_t *
.text:000000E4                 call    ?CompareFileNames@@YGHPB_W0@Z ; CompareFileNames(wchar_t const *,wchar_t const *)
.text:000000E9                 mov     [ebp+var_14], eax
.text:000000EC                 cmp     [ebp+var_14], 0
.text:000000F0                 jnz     short loc_F7
.text:000000F2                 mov     eax, [ebp+var_C]
.text:000000F5                 jmp     short loc_113
.text:000000F7 ; ---------------------------------------------------------------------------
.text:000000F7
.text:000000F7 loc_F7:                                 ; CODE XREF: Find_FileName_InSortedVector(CObjectVector<UString> const &,UString const &)+6Cj
.text:000000F7                 cmp     [ebp+var_14], 0
.text:000000FB                 jge     short loc_105
.text:000000FD                 mov     eax, [ebp+var_C]
.text:00000100                 mov     [ebp+var_8], eax
.text:00000103                 jmp     short loc_10E
.text:00000105 ; ---------------------------------------------------------------------------
.text:00000105
.text:00000105 loc_105:                                ; CODE XREF: Find_FileName_InSortedVector(CObjectVector<UString> const &,UString const &)+77j
.text:00000105                 mov     ecx, [ebp+var_C]
.text:00000108                 add     ecx, 1
.text:0000010B                 mov     [ebp+var_4], ecx
.text:0000010E
.text:0000010E loc_10E:                                ; CODE XREF: Find_FileName_InSortedVector(CObjectVector<UString> const &,UString const &)+7Fj
.text:0000010E                 jmp     short loc_B0
.text:00000110 ; ---------------------------------------------------------------------------
.text:00000110
.text:00000110 loc_110:                                ; CODE XREF: Find_FileName_InSortedVector(CObjectVector<UString> const &,UString const &)+32j
.text:00000110                 or      eax, 0FFFFFFFFh
.text:00000113
.text:00000113 loc_113:                                ; CODE XREF: Find_FileName_InSortedVector(CObjectVector<UString> const &,UString const &)+71j
.text:00000113                 add     esp, 14h
.text:00000116                 cmp     ebp, esp
.text:00000118                 call    __RTC_CheckEsp
.text:0000011D                 mov     esp, ebp
.text:0000011F                 pop     ebp
.text:00000120                 retn    8
.text:00000120 ?Find_FileName_InSortedVector@@YGHABV?$CObjectVector@VUString@@@@ABVUString@@@Z endp
.text:00000120
.text:00000120 ; ---------------------------------------------------------------------------
.text:00000123                 align 4
.text:00000124
.text:00000124 ; =============== S U B R O U T I N E =======================================
.text:00000124
.text:00000124 ; Attributes: bp-based frame
.text:00000124
.text:00000124 ; int __stdcall Extract(int, int, int, int, int, struct NWildcard::CCensorNode *, int, struct IOpenCallbackUI *, int, struct IHashCalc *, UString *, CDecompressStat *)
.text:00000124                 public ?Extract@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABV?$CRecordVector@H@@AAV?$CObjectVector@VUString@@@@3ABVCCensorNode@NWildcard@@ABUCExtractOptions@@PAUIOpenCallbackUI@@PAUIExtractCallbackUI@@PAUIHashCalc@@AAVUString@@AAUCDecompressStat@@@Z
.text:00000124 ?Extract@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABV?$CRecordVector@H@@AAV?$CObjectVector@VUString@@@@3ABVCCensorNode@NWildcard@@ABUCExtractOptions@@PAUIOpenCallbackUI@@PAUIExtractCallbackUI@@PAUIHashCalc@@AAVUString@@AAUCDecompressStat@@@Z proc near
.text:00000124
.text:00000124 var_2A0         = dword ptr -2A0h
.text:00000124 var_29C         = dword ptr -29Ch
.text:00000124 var_298         = dword ptr -298h
.text:00000124 var_294         = dword ptr -294h
.text:00000124 var_290         = dword ptr -290h
.text:00000124 var_28C         = dword ptr -28Ch
.text:00000124 var_288         = dword ptr -288h
.text:00000124 var_284         = dword ptr -284h
.text:00000124 var_280         = dword ptr -280h
.text:00000124 var_27C         = dword ptr -27Ch
.text:00000124 var_278         = dword ptr -278h
.text:00000124 var_274         = dword ptr -274h
.text:00000124 var_270         = dword ptr -270h
.text:00000124 var_26C         = dword ptr -26Ch
.text:00000124 var_268         = dword ptr -268h
.text:00000124 var_264         = dword ptr -264h
.text:00000124 var_260         = dword ptr -260h
.text:00000124 var_25C         = dword ptr -25Ch
.text:00000124 var_258         = dword ptr -258h
.text:00000124 var_254         = dword ptr -254h
.text:00000124 var_250         = dword ptr -250h
.text:00000124 var_249         = byte ptr -249h
.text:00000124 var_244         = qword ptr -244h
.text:00000124 var_238         = dword ptr -238h
.text:00000124 var_234         = dword ptr -234h
.text:00000124 var_230         = dword ptr -230h
.text:00000124 var_22C         = dword ptr -22Ch
.text:00000124 var_228         = dword ptr -228h
.text:00000124 var_224         = dword ptr -224h
.text:00000124 var_220         = dword ptr -220h
.text:00000124 var_21C         = dword ptr -21Ch
.text:00000124 var_214         = dword ptr -214h
.text:00000124 var_210         = dword ptr -210h
.text:00000124 var_1D8         = dword ptr -1D8h
.text:00000124 var_1D4         = dword ptr -1D4h
.text:00000124 var_1CC         = dword ptr -1CCh
.text:00000124 var_1A4         = dword ptr -1A4h
.text:00000124 var_1A0         = dword ptr -1A0h
.text:00000124 var_19C         = dword ptr -19Ch
.text:00000124 var_18C         = dword ptr -18Ch
.text:00000124 var_188         = byte ptr -188h
.text:00000124 var_184         = byte ptr -184h
.text:00000124 var_16C         = byte ptr -16Ch
.text:00000124 var_158         = dword ptr -158h
.text:00000124 var_14C         = byte ptr -14Ch
.text:00000124 var_140         = dword ptr -140h
.text:00000124 var_13C         = dword ptr -13Ch
.text:00000124 var_11C         = dword ptr -11Ch
.text:00000124 var_F4          = dword ptr -0F4h
.text:00000124 var_EC          = dword ptr -0ECh
.text:00000124 var_E8          = dword ptr -0E8h
.text:00000124 var_D4          = dword ptr -0D4h
.text:00000124 var_D0          = dword ptr -0D0h
.text:00000124 var_CC          = dword ptr -0CCh
.text:00000124 var_C7          = byte ptr -0C7h
.text:00000124 var_B0          = dword ptr -0B0h
.text:00000124 var_A9          = byte ptr -0A9h
.text:00000124 var_A4          = dword ptr -0A4h
.text:00000124 var_A0          = dword ptr -0A0h
.text:00000124 var_98          = dword ptr -98h
.text:00000124 var_91          = byte ptr -91h
.text:00000124 var_8C          = byte ptr -8Ch
.text:00000124 var_84          = dword ptr -84h
.text:00000124 var_7C          = byte ptr -7Ch
.text:00000124 var_74          = dword ptr -74h
.text:00000124 var_6C          = dword ptr -6Ch
.text:00000124 var_68          = dword ptr -68h
.text:00000124 var_30          = dword ptr -30h
.text:00000124 var_2C          = dword ptr -2Ch
.text:00000124 var_24          = byte ptr -24h
.text:00000124 var_14          = dword ptr -14h
.text:00000124 var_10          = dword ptr -10h
.text:00000124 var_C           = dword ptr -0Ch
.text:00000124 var_4           = dword ptr -4
.text:00000124 arg_0           = dword ptr  8
.text:00000124 arg_4           = dword ptr  0Ch
.text:00000124 arg_8           = dword ptr  10h
.text:00000124 arg_C           = dword ptr  14h
.text:00000124 arg_10          = dword ptr  18h
.text:00000124 arg_14          = dword ptr  1Ch
.text:00000124 arg_18          = dword ptr  20h
.text:00000124 arg_1C          = dword ptr  24h
.text:00000124 arg_20          = dword ptr  28h
.text:00000124 arg_24          = dword ptr  2Ch
.text:00000124 arg_28          = dword ptr  30h
.text:00000124 arg_2C          = dword ptr  34h
.text:00000124
.text:00000124                 push    ebp
.text:00000125                 mov     ebp, esp
.text:00000127                 push    0FFFFFFFFh
.text:00000129                 push    offset __ehhandler$?Extract@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABV?$CRecordVector@H@@AAV?$CObjectVector@VUString@@@@3ABVCCensorNode@NWildcard@@ABUCExtractOptions@@PAUIOpenCallbackUI@@PAUIExtractCallbackUI@@PAUIHashCalc@@AAVUString@@AAUCDecompressStat@@@Z
.text:0000012E                 mov     eax, large fs:0
.text:00000134                 push    eax
.text:00000135                 sub     esp, 294h
.text:0000013B                 push    esi
.text:0000013C                 push    edi
.text:0000013D                 lea     edi, [ebp+var_2A0]
.text:00000143                 mov     ecx, 0A5h ; 'Ã‘'
.text:00000148                 mov     eax, 0CCCCCCCCh
.text:0000014D                 rep stosd
.text:0000014F                 mov     eax, dword ptr ds:___security_cookie
.text:00000154                 xor     eax, ebp
.text:00000156                 push    eax
.text:00000157                 lea     eax, [ebp+var_C]
.text:0000015A                 mov     large fs:0, eax
.text:00000160                 mov     ecx, [ebp+arg_2C] ; this
.text:00000163                 call    ?Clear@CDecompressStat@@QAEXXZ ; CDecompressStat::Clear(void)
.text:00000168                 mov     [ebp+var_14], 0
.text:0000016F                 mov     [ebp+var_10], 0
.text:00000176                 lea     ecx, [ebp+var_24]
.text:00000179                 call    ??0?$CRecordVector@_K@@QAE@XZ ; CRecordVector<unsigned __int64>::CRecordVector<unsigned __int64>(void)
.text:0000017E                 mov     [ebp+var_4], 0
.text:00000185                 mov     eax, [ebp+arg_18]
.text:00000188                 movzx   ecx, byte ptr [eax+24h]
.text:0000018C                 test    ecx, ecx
.text:0000018E                 jz      short loc_19C
.text:00000190                 mov     [ebp+var_298], 1
.text:0000019A                 jmp     short loc_1AA
.text:0000019C ; ---------------------------------------------------------------------------
.text:0000019C
.text:0000019C loc_19C:                                ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+6Aj
.text:0000019C                 mov     ecx, [ebp+arg_C]
.text:0000019F                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:000001A4                 mov     [ebp+var_298], eax
.text:000001AA
.text:000001AA loc_1AA:                                ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+76j
.text:000001AA                 mov     edx, [ebp+var_298]
.text:000001B0                 mov     [ebp+var_2C], edx
.text:000001B3                 mov     [ebp+var_30], 0
.text:000001BA                 jmp     short loc_1C5
.text:000001BC ; ---------------------------------------------------------------------------
.text:000001BC
.text:000001BC loc_1BC:                                ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+16Cj
.text:000001BC                 mov     eax, [ebp+var_30]
.text:000001BF                 add     eax, 1
.text:000001C2                 mov     [ebp+var_30], eax
.text:000001C5
.text:000001C5 loc_1C5:                                ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+96j
.text:000001C5                 mov     ecx, [ebp+var_30]
.text:000001C8                 cmp     ecx, [ebp+var_2C]
.text:000001CB                 jnb     loc_295
.text:000001D1                 lea     ecx, [ebp+var_6C] ; this
.text:000001D4                 call    ??0CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::CFileInfo(void)
.text:000001D9                 mov     byte ptr [ebp+var_4], 1
.text:000001DD                 mov     [ebp+var_6C], 0
.text:000001E4                 mov     [ebp+var_68], 0
.text:000001EB                 mov     edx, [ebp+arg_18]
.text:000001EE                 movzx   eax, byte ptr [edx+24h]
.text:000001F2                 test    eax, eax
.text:000001F4                 jnz     short loc_262
.text:000001F6                 mov     ecx, [ebp+var_30]
.text:000001F9                 push    ecx
.text:000001FA                 mov     ecx, [ebp+arg_C]
.text:000001FD                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00000202                 mov     [ebp+var_74], eax
.text:00000205                 mov     ecx, [ebp+var_74]
.text:00000208                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:0000020D                 push    eax             ; wchar_t *
.text:0000020E                 lea     ecx, [ebp+var_6C] ; this
.text:00000211                 call    ?Find@CFileInfo@NFind@NFile@NWindows@@QAE_NPB_W@Z ; NWindows::NFile::NFind::CFileInfo::Find(wchar_t const *)
.text:00000216                 movzx   edx, al
.text:00000219                 test    edx, edx
.text:0000021B                 jnz     short loc_238
.text:0000021D                 mov     [ebp+var_25C], offset $SG73937 ; "there is no such archive"
.text:00000227                 push    offset __TI2PAD
.text:0000022C                 lea     eax, [ebp+var_25C]
.text:00000232                 push    eax
.text:00000233                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:00000238 ; ---------------------------------------------------------------------------
.text:00000238
.text:00000238 loc_238:                                ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+F7j
.text:00000238                 lea     ecx, [ebp+var_6C] ; this
.text:0000023B                 call    ?IsDir@CFileInfoBase@NFind@NFile@NWindows@@QBE_NXZ ; NWindows::NFile::NFind::CFileInfoBase::IsDir(void)
.text:00000240                 movzx   ecx, al
.text:00000243                 test    ecx, ecx
.text:00000245                 jz      short loc_262
.text:00000247                 mov     [ebp+var_260], offset $SG73940 ; "can't decompress folder"
.text:00000251                 push    offset __TI2PAD
.text:00000256                 lea     edx, [ebp+var_260]
.text:0000025C                 push    edx
.text:0000025D                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:00000262 ; ---------------------------------------------------------------------------
.text:00000262
.text:00000262 loc_262:                                ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+D0j
.text:00000262                                         ; Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+121j
.text:00000262                 mov     eax, [ebp+var_68]
.text:00000265                 push    eax
.text:00000266                 mov     ecx, [ebp+var_6C]
.text:00000269                 push    ecx
.text:0000026A                 lea     ecx, [ebp+var_24]
.text:0000026D                 call    ?Add@?$CRecordVector@_K@@QAEI_K@Z ; CRecordVector<unsigned __int64>::Add(unsigned __int64)
.text:00000272                 mov     edx, [ebp+var_14]
.text:00000275                 add     edx, [ebp+var_6C]
.text:00000278                 mov     eax, [ebp+var_10]
.text:0000027B                 adc     eax, [ebp+var_68]
.text:0000027E                 mov     [ebp+var_14], edx
.text:00000281                 mov     [ebp+var_10], eax
.text:00000284                 mov     byte ptr [ebp+var_4], 0
.text:00000288                 lea     ecx, [ebp+var_6C] ; this
.text:0000028B                 call    ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text:00000290                 jmp     loc_1BC
.text:00000295 ; ---------------------------------------------------------------------------
.text:00000295
.text:00000295 loc_295:                                ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+A7j
.text:00000295                 mov     ecx, [ebp+var_2C]
.text:00000298                 push    ecx
.text:00000299                 lea     ecx, [ebp+var_7C]
.text:0000029C                 call    ??0?$CObjArray@_N@@QAE@I@Z ; CObjArray<bool>::CObjArray<bool>(uint)
.text:000002A1                 mov     byte ptr [ebp+var_4], 2
.text:000002A5                 mov     [ebp+var_30], 0
.text:000002AC                 jmp     short loc_2B7
.text:000002AE ; ---------------------------------------------------------------------------
.text:000002AE
.text:000002AE loc_2AE:                                ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+1AAj
.text:000002AE                 mov     edx, [ebp+var_30]
.text:000002B1                 add     edx, 1
.text:000002B4                 mov     [ebp+var_30], edx
.text:000002B7
.text:000002B7 loc_2B7:                                ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+188j
.text:000002B7                 mov     eax, [ebp+var_30]
.text:000002BA                 cmp     eax, [ebp+var_2C]
.text:000002BD                 jnb     short loc_2D0
.text:000002BF                 lea     ecx, [ebp+var_7C]
.text:000002C2                 call    ??B?$CObjArray@_N@@QAEPA_NXZ ; CObjArray<bool>::operator bool *(void)
.text:000002C7                 mov     ecx, [ebp+var_30]
.text:000002CA                 mov     byte ptr [eax+ecx], 0
.text:000002CE                 jmp     short loc_2AE
.text:000002D0 ; ---------------------------------------------------------------------------
.text:000002D0
.text:000002D0 loc_2D0:                                ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+199j
.text:000002D0                 push    1B8h            ; unsigned int
.text:000002D5                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:000002DA                 add     esp, 4
.text:000002DD                 mov     [ebp+var_268], eax
.text:000002E3                 mov     byte ptr [ebp+var_4], 3
.text:000002E7                 cmp     [ebp+var_268], 0
.text:000002EE                 jz      short loc_303
.text:000002F0                 mov     ecx, [ebp+var_268] ; this
.text:000002F6                 call    ??0CArchiveExtractCallback@@QAE@XZ ; CArchiveExtractCallback::CArchiveExtractCallback(void)
.text:000002FB                 mov     [ebp+var_29C], eax
.text:00000301                 jmp     short loc_30D
.text:00000303 ; ---------------------------------------------------------------------------
.text:00000303
.text:00000303 loc_303:                                ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+1CAj
.text:00000303                 mov     [ebp+var_29C], 0
.text:0000030D
.text:0000030D loc_30D:                                ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+1DDj
.text:0000030D                 mov     edx, [ebp+var_29C]
.text:00000313                 mov     [ebp+var_264], edx
.text:00000319                 mov     byte ptr [ebp+var_4], 2
.text:0000031D                 mov     eax, [ebp+var_264]
.text:00000323                 mov     [ebp+var_84], eax
.text:00000329                 mov     ecx, [ebp+var_84]
.text:0000032F                 push    ecx
.text:00000330                 lea     ecx, [ebp+var_8C]
.text:00000336                 call    ??0?$CMyComPtr@UIArchiveExtractCallback@@@@QAE@PAUIArchiveExtractCallback@@@Z ; CMyComPtr<IArchiveExtractCallback>::CMyComPtr<IArchiveExtractCallback>(IArchiveExtractCallback *)
.text:0000033B                 mov     byte ptr [ebp+var_4], 4
.text:0000033F                 mov     edx, 1
.text:00000344                 cmp     edx, [ebp+var_2C]
.text:00000347                 sbb     eax, eax
.text:00000349                 neg     eax
.text:0000034B                 mov     [ebp+var_91], al
.text:00000351                 mov     ecx, [ebp+arg_18]
.text:00000354                 mov     edx, [ecx+8]
.text:00000357                 push    edx
.text:00000358                 mov     eax, [ebp+arg_18]
.text:0000035B                 mov     ecx, [eax+4]
.text:0000035E                 push    ecx
.text:0000035F                 movzx   edx, [ebp+var_91]
.text:00000366                 push    edx
.text:00000367                 mov     ecx, [ebp+var_84]
.text:0000036D                 call    ?InitForMulti@CArchiveExtractCallback@@QAEX_NW4EEnum@NPathMode@NExtract@@W42NOverwriteMode@4@@Z ; CArchiveExtractCallback::InitForMulti(bool,NExtract::NPathMode::EEnum,NExtract::NOverwriteMode::EEnum)
.text:00000372                 mov     eax, [ebp+arg_24]
.text:00000375                 push    eax             ; struct IHashCalc *
.text:00000376                 mov     ecx, [ebp+var_84] ; this
.text:0000037C                 call    ?SetHashMethods@CArchiveExtractCallback@@QAEXPAUIHashCalc@@@Z ; CArchiveExtractCallback::SetHashMethods(IHashCalc *)
.text:00000381                 movzx   ecx, [ebp+var_91]
.text:00000388                 test    ecx, ecx
.text:0000038A                 jz      short loc_3FB
.text:0000038C                 mov     esi, esp
.text:0000038E                 mov     edx, [ebp+var_10]
.text:00000391                 push    edx
.text:00000392                 mov     eax, [ebp+var_14]
.text:00000395                 push    eax
.text:00000396                 mov     ecx, [ebp+arg_20]
.text:00000399                 mov     edx, [ecx]
.text:0000039B                 mov     eax, [ebp+arg_20]
.text:0000039E                 push    eax
.text:0000039F                 mov     ecx, [edx+0Ch]
.text:000003A2                 call    ecx
.text:000003A4                 cmp     esi, esp
.text:000003A6                 call    __RTC_CheckEsp
.text:000003AB                 mov     [ebp+var_98], eax
.text:000003B1                 cmp     [ebp+var_98], 0
.text:000003B8                 jz      short loc_3FB
.text:000003BA                 mov     edx, [ebp+var_98]
.text:000003C0                 mov     [ebp+var_26C], edx
.text:000003C6                 mov     byte ptr [ebp+var_4], 2
.text:000003CA                 lea     ecx, [ebp+var_8C]
.text:000003D0                 call    ??1?$CMyComPtr@UIArchiveExtractCallback@@@@QAE@XZ ; CMyComPtr<IArchiveExtractCallback>::~CMyComPtr<IArchiveExtractCallback>(void)
.text:000003D5                 mov     byte ptr [ebp+var_4], 0
.text:000003D9                 lea     ecx, [ebp+var_7C]
.text:000003DC                 call    ??1?$CObjArray@_N@@QAE@XZ ; CObjArray<bool>::~CObjArray<bool>(void)
.text:000003E1                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000003E8                 lea     ecx, [ebp+var_24]
.text:000003EB                 call    ??1?$CRecordVector@_K@@QAE@XZ ; CRecordVector<unsigned __int64>::~CRecordVector<unsigned __int64>(void)
.text:000003F0                 mov     eax, [ebp+var_26C]
.text:000003F6                 jmp     loc_EE4
.text:000003FB ; ---------------------------------------------------------------------------
.text:000003FB
.text:000003FB loc_3FB:                                ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+266j
.text:000003FB                                         ; Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+294j
.text:000003FB                 mov     [ebp+var_A4], 0
.text:00000405                 mov     [ebp+var_A0], 0
.text:0000040F                 mov     [ebp+var_A9], 0
.text:00000416                 mov     [ebp+var_30], 0
.text:0000041D                 jmp     short loc_428
.text:0000041F ; ---------------------------------------------------------------------------
.text:0000041F
.text:0000041F loc_41F:                                ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+323j
.text:0000041F                                         ; Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+716j ...
.text:0000041F                 mov     eax, [ebp+var_30]
.text:00000422                 add     eax, 1
.text:00000425                 mov     [ebp+var_30], eax
.text:00000428
.text:00000428 loc_428:                                ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+2F9j
.text:00000428                 mov     ecx, [ebp+var_30]
.text:0000042B                 cmp     ecx, [ebp+var_2C]
.text:0000042E                 jnb     loc_CFF
.text:00000434                 lea     ecx, [ebp+var_7C]
.text:00000437                 call    ??B?$CObjArray@_N@@QAEPA_NXZ ; CObjArray<bool>::operator bool *(void)
.text:0000043C                 mov     edx, [ebp+var_30]
.text:0000043F                 movzx   eax, byte ptr [eax+edx]
.text:00000443                 test    eax, eax
.text:00000445                 jz      short loc_449
.text:00000447                 jmp     short loc_41F
.text:00000449 ; ---------------------------------------------------------------------------
.text:00000449
.text:00000449 loc_449:                                ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+321j
.text:00000449                 mov     ecx, [ebp+var_30]
.text:0000044C                 push    ecx
.text:0000044D                 mov     ecx, [ebp+arg_C]
.text:00000450                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:00000455                 mov     [ebp+var_B0], eax
.text:0000045B                 lea     ecx, [ebp+var_EC] ; this
.text:00000461                 call    ??0CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::CFileInfo(void)
.text:00000466                 mov     byte ptr [ebp+var_4], 5
.text:0000046A                 mov     edx, [ebp+arg_18]
.text:0000046D                 movzx   eax, byte ptr [edx+24h]
.text:00000471                 test    eax, eax
.text:00000473                 jz      short loc_495
.text:00000475                 mov     [ebp+var_EC], 0
.text:0000047F                 mov     [ebp+var_E8], 0
.text:00000489                 mov     [ebp+var_CC], 0
.text:00000493                 jmp     short loc_4E0
.text:00000495 ; ---------------------------------------------------------------------------
.text:00000495
.text:00000495 loc_495:                                ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+34Fj
.text:00000495                 mov     ecx, [ebp+var_B0]
.text:0000049B                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000004A0                 push    eax             ; wchar_t *
.text:000004A1                 lea     ecx, [ebp+var_EC] ; this
.text:000004A7                 call    ?Find@CFileInfo@NFind@NFile@NWindows@@QAE_NPB_W@Z ; NWindows::NFile::NFind::CFileInfo::Find(wchar_t const *)
.text:000004AC                 movzx   ecx, al
.text:000004AF                 test    ecx, ecx
.text:000004B1                 jz      short loc_4C5
.text:000004B3                 lea     ecx, [ebp+var_EC] ; this
.text:000004B9                 call    ?IsDir@CFileInfoBase@NFind@NFile@NWindows@@QBE_NXZ ; NWindows::NFile::NFind::CFileInfoBase::IsDir(void)
.text:000004BE                 movzx   edx, al
.text:000004C1                 test    edx, edx
.text:000004C3                 jz      short loc_4E0
.text:000004C5
.text:000004C5 loc_4C5:                                ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+38Dj
.text:000004C5                 mov     [ebp+var_270], offset $SG74025 ; "there is no such archive"
.text:000004CF                 push    offset __TI2PAD
.text:000004D4                 lea     eax, [ebp+var_270]
.text:000004DA                 push    eax
.text:000004DB                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:000004E0 ; ---------------------------------------------------------------------------
.text:000004E0
.text:000004E0 loc_4E0:                                ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+36Fj
.text:000004E0                                         ; Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+39Fj
.text:000004E0                 mov     esi, esp
.text:000004E2                 mov     ecx, [ebp+arg_18]
.text:000004E5                 movzx   edx, byte ptr [ecx+27h]
.text:000004E9                 push    edx
.text:000004EA                 mov     ecx, [ebp+var_B0]
.text:000004F0                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000004F5                 push    eax
.text:000004F6                 mov     eax, [ebp+arg_20]
.text:000004F9                 mov     edx, [eax]
.text:000004FB                 mov     ecx, [ebp+arg_20]
.text:000004FE                 mov     eax, [edx+24h]
.text:00000501                 call    eax
.text:00000503                 cmp     esi, esp
.text:00000505                 call    __RTC_CheckEsp
.text:0000050A                 mov     [ebp+var_F4], eax
.text:00000510                 cmp     [ebp+var_F4], 0
.text:00000517                 jz      short loc_569
.text:00000519                 mov     ecx, [ebp+var_F4]
.text:0000051F                 mov     [ebp+var_274], ecx
.text:00000525                 mov     byte ptr [ebp+var_4], 4
.text:00000529                 lea     ecx, [ebp+var_EC] ; this
.text:0000052F                 call    ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text:00000534                 mov     byte ptr [ebp+var_4], 2
.text:00000538                 lea     ecx, [ebp+var_8C]
.text:0000053E                 call    ??1?$CMyComPtr@UIArchiveExtractCallback@@@@QAE@XZ ; CMyComPtr<IArchiveExtractCallback>::~CMyComPtr<IArchiveExtractCallback>(void)
.text:00000543                 mov     byte ptr [ebp+var_4], 0
.text:00000547                 lea     ecx, [ebp+var_7C]
.text:0000054A                 call    ??1?$CObjArray@_N@@QAE@XZ ; CObjArray<bool>::~CObjArray<bool>(void)
.text:0000054F                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000556                 lea     ecx, [ebp+var_24]
.text:00000559                 call    ??1?$CRecordVector@_K@@QAE@XZ ; CRecordVector<unsigned __int64>::~CRecordVector<unsigned __int64>(void)
.text:0000055E                 mov     eax, [ebp+var_274]
.text:00000564                 jmp     loc_EE4
.text:00000569 ; ---------------------------------------------------------------------------
.text:00000569
.text:00000569 loc_569:                                ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+3F3j
.text:00000569                 lea     ecx, [ebp+var_158]
.text:0000056F                 call    ??0CArchiveLink@@QAE@XZ ; CArchiveLink::CArchiveLink(void)
.text:00000574                 mov     byte ptr [ebp+var_4], 6
.text:00000578                 mov     edx, [ebp+arg_4]
.text:0000057B                 push    edx
.text:0000057C                 lea     ecx, [ebp+var_16C]
.text:00000582                 call    ??0?$CObjectVector@UCOpenType@@@@QAE@ABV0@@Z ; CObjectVector<COpenType>::CObjectVector<COpenType>(CObjectVector<COpenType> const &)
.text:00000587                 mov     byte ptr [ebp+var_4], 7
.text:0000058B                 lea     ecx, [ebp+var_1CC]
.text:00000591                 call    ??0COpenOptions@@QAE@XZ ; COpenOptions::COpenOptions(void)
.text:00000596                 mov     byte ptr [ebp+var_4], 8
.text:0000059A                 mov     eax, [ebp+arg_18]
.text:0000059D                 add     eax, 28h ; '('
.text:000005A0                 mov     [ebp+var_18C], eax
.text:000005A6                 mov     ecx, [ebp+arg_0]
.text:000005A9                 mov     [ebp+var_1CC], ecx
.text:000005AF                 lea     edx, [ebp+var_16C]
.text:000005B5                 mov     [ebp+var_1A4], edx
.text:000005BB                 mov     eax, [ebp+arg_8]
.text:000005BE                 mov     [ebp+var_1A0], eax
.text:000005C4                 mov     ecx, [ebp+arg_18]
.text:000005C7                 mov     dl, [ecx+24h]
.text:000005CA                 mov     [ebp+var_188], dl
.text:000005D0                 mov     [ebp+var_19C], 0
.text:000005DA                 mov     eax, [ebp+var_B0]
.text:000005E0                 push    eax
.text:000005E1                 lea     ecx, [ebp+var_184]
.text:000005E7                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:000005EC                 mov     ecx, [ebp+arg_1C]
.text:000005EF                 push    ecx             ; struct IOpenCallbackUI *
.text:000005F0                 lea     edx, [ebp+var_1CC]
.text:000005F6                 push    edx             ; struct COpenOptions *
.text:000005F7                 lea     ecx, [ebp+var_158] ; this
.text:000005FD                 call    ?Open3@CArchiveLink@@QAEJAAUCOpenOptions@@PAUIOpenCallbackUI@@@Z ; CArchiveLink::Open3(COpenOptions &,IOpenCallbackUI *)
.text:00000602                 mov     [ebp+var_1D4], eax
.text:00000608                 cmp     [ebp+var_1D4], 80004004h
.text:00000612                 jnz     short loc_691
.text:00000614                 mov     eax, [ebp+var_1D4]
.text:0000061A                 mov     [ebp+var_278], eax
.text:00000620                 mov     byte ptr [ebp+var_4], 7
.text:00000624                 lea     ecx, [ebp+var_1CC] ; this
.text:0000062A                 call    ??1COpenOptions@@QAE@XZ ; COpenOptions::~COpenOptions(void)
.text:0000062F                 mov     byte ptr [ebp+var_4], 6
.text:00000633                 lea     ecx, [ebp+var_16C]
.text:00000639                 call    ??1?$CObjectVector@UCOpenType@@@@QAE@XZ ; CObjectVector<COpenType>::~CObjectVector<COpenType>(void)
.text:0000063E                 mov     byte ptr [ebp+var_4], 5
.text:00000642                 lea     ecx, [ebp+var_158] ; this
.text:00000648                 call    ??1CArchiveLink@@QAE@XZ ; CArchiveLink::~CArchiveLink(void)
.text:0000064D                 mov     byte ptr [ebp+var_4], 4
.text:00000651                 lea     ecx, [ebp+var_EC] ; this
.text:00000657                 call    ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text:0000065C                 mov     byte ptr [ebp+var_4], 2
.text:00000660                 lea     ecx, [ebp+var_8C]
.text:00000666                 call    ??1?$CMyComPtr@UIArchiveExtractCallback@@@@QAE@XZ ; CMyComPtr<IArchiveExtractCallback>::~CMyComPtr<IArchiveExtractCallback>(void)
.text:0000066B                 mov     byte ptr [ebp+var_4], 0
.text:0000066F                 lea     ecx, [ebp+var_7C]
.text:00000672                 call    ??1?$CObjArray@_N@@QAE@XZ ; CObjArray<bool>::~CObjArray<bool>(void)
.text:00000677                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000067E                 lea     ecx, [ebp+var_24]
.text:00000681                 call    ??1?$CRecordVector@_K@@QAE@XZ ; CRecordVector<unsigned __int64>::~CRecordVector<unsigned __int64>(void)
.text:00000686                 mov     eax, [ebp+var_278]
.text:0000068C                 jmp     loc_EE4
.text:00000691 ; ---------------------------------------------------------------------------
.text:00000691
.text:00000691 loc_691:                                ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+4EEj
.text:00000691                 cmp     [ebp+var_1D4], 0
.text:00000698                 jnz     short loc_6AD
.text:0000069A                 cmp     [ebp+var_11C], 0
.text:000006A1                 jl      short loc_6AD
.text:000006A3                 mov     [ebp+var_1D4], 1
.text:000006AD
.text:000006AD loc_6AD:                                ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+574j
.text:000006AD                                         ; Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+57Dj
.text:000006AD                 mov     esi, esp
.text:000006AF                 mov     ecx, [ebp+var_1D4]
.text:000006B5                 push    ecx
.text:000006B6                 mov     ecx, [ebp+var_B0]
.text:000006BC                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000006C1                 push    eax
.text:000006C2                 lea     edx, [ebp+var_158]
.text:000006C8                 push    edx
.text:000006C9                 mov     eax, [ebp+arg_0]
.text:000006CC                 push    eax
.text:000006CD                 mov     ecx, [ebp+arg_20]
.text:000006D0                 mov     edx, [ecx]
.text:000006D2                 mov     ecx, [ebp+arg_20]
.text:000006D5                 mov     eax, [edx+28h]
.text:000006D8                 call    eax
.text:000006DA                 cmp     esi, esp
.text:000006DC                 call    __RTC_CheckEsp
.text:000006E1                 mov     [ebp+var_1D8], eax
.text:000006E7                 cmp     [ebp+var_1D8], 0
.text:000006EE                 jz      short loc_76D
.text:000006F0                 mov     ecx, [ebp+var_1D8]
.text:000006F6                 mov     [ebp+var_27C], ecx
.text:000006FC                 mov     byte ptr [ebp+var_4], 7
.text:00000700                 lea     ecx, [ebp+var_1CC] ; this
.text:00000706                 call    ??1COpenOptions@@QAE@XZ ; COpenOptions::~COpenOptions(void)
.text:0000070B                 mov     byte ptr [ebp+var_4], 6
.text:0000070F                 lea     ecx, [ebp+var_16C]
.text:00000715                 call    ??1?$CObjectVector@UCOpenType@@@@QAE@XZ ; CObjectVector<COpenType>::~CObjectVector<COpenType>(void)
.text:0000071A                 mov     byte ptr [ebp+var_4], 5
.text:0000071E                 lea     ecx, [ebp+var_158] ; this
.text:00000724                 call    ??1CArchiveLink@@QAE@XZ ; CArchiveLink::~CArchiveLink(void)
.text:00000729                 mov     byte ptr [ebp+var_4], 4
.text:0000072D                 lea     ecx, [ebp+var_EC] ; this
.text:00000733                 call    ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text:00000738                 mov     byte ptr [ebp+var_4], 2
.text:0000073C                 lea     ecx, [ebp+var_8C]
.text:00000742                 call    ??1?$CMyComPtr@UIArchiveExtractCallback@@@@QAE@XZ ; CMyComPtr<IArchiveExtractCallback>::~CMyComPtr<IArchiveExtractCallback>(void)
.text:00000747                 mov     byte ptr [ebp+var_4], 0
.text:0000074B                 lea     ecx, [ebp+var_7C]
.text:0000074E                 call    ??1?$CObjArray@_N@@QAE@XZ ; CObjArray<bool>::~CObjArray<bool>(void)
.text:00000753                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000075A                 lea     ecx, [ebp+var_24]
.text:0000075D                 call    ??1?$CRecordVector@_K@@QAE@XZ ; CRecordVector<unsigned __int64>::~CRecordVector<unsigned __int64>(void)
.text:00000762                 mov     eax, [ebp+var_27C]
.text:00000768                 jmp     loc_EE4
.text:0000076D ; ---------------------------------------------------------------------------
.text:0000076D
.text:0000076D loc_76D:                                ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+5CAj
.text:0000076D                 cmp     [ebp+var_1D4], 0
.text:00000774                 jz      loc_83F
.text:0000077A                 mov     [ebp+var_A9], 1
.text:00000781                 mov     edx, [ebp+arg_18]
.text:00000784                 movzx   eax, byte ptr [edx+24h]
.text:00000788                 test    eax, eax
.text:0000078A                 jnz     short loc_7FE
.text:0000078C                 lea     ecx, [ebp+var_214] ; this
.text:00000792                 call    ??0CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::CFileInfo(void)
.text:00000797                 mov     byte ptr [ebp+var_4], 9
.text:0000079B                 mov     ecx, [ebp+var_B0]
.text:000007A1                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000007A6                 push    eax             ; wchar_t *
.text:000007A7                 lea     ecx, [ebp+var_214] ; this
.text:000007AD                 call    ?Find@CFileInfo@NFind@NFile@NWindows@@QAE_NPB_W@Z ; NWindows::NFile::NFind::CFileInfo::Find(wchar_t const *)
.text:000007B2                 movzx   ecx, al
.text:000007B5                 test    ecx, ecx
.text:000007B7                 jz      short loc_7EF
.text:000007B9                 lea     ecx, [ebp+var_214] ; this
.text:000007BF                 call    ?IsDir@CFileInfoBase@NFind@NFile@NWindows@@QBE_NXZ ; NWindows::NFile::NFind::CFileInfoBase::IsDir(void)
.text:000007C4                 movzx   edx, al
.text:000007C7                 test    edx, edx
.text:000007C9                 jnz     short loc_7EF
.text:000007CB                 mov     eax, [ebp+var_A4]
.text:000007D1                 add     eax, [ebp+var_214]
.text:000007D7                 mov     ecx, [ebp+var_A0]
.text:000007DD                 adc     ecx, [ebp+var_210]
.text:000007E3                 mov     [ebp+var_A4], eax
.text:000007E9                 mov     [ebp+var_A0], ecx
.text:000007EF
.text:000007EF loc_7EF:                                ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+693j
.text:000007EF                                         ; Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+6A5j
.text:000007EF                 mov     byte ptr [ebp+var_4], 8
.text:000007F3                 lea     ecx, [ebp+var_214] ; this
.text:000007F9                 call    ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text:000007FE
.text:000007FE loc_7FE:                                ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+666j
.text:000007FE                 mov     byte ptr [ebp+var_4], 7
.text:00000802                 lea     ecx, [ebp+var_1CC] ; this
.text:00000808                 call    ??1COpenOptions@@QAE@XZ ; COpenOptions::~COpenOptions(void)
.text:0000080D                 mov     byte ptr [ebp+var_4], 6
.text:00000811                 lea     ecx, [ebp+var_16C]
.text:00000817                 call    ??1?$CObjectVector@UCOpenType@@@@QAE@XZ ; CObjectVector<COpenType>::~CObjectVector<COpenType>(void)
.text:0000081C                 mov     byte ptr [ebp+var_4], 5
.text:00000820                 lea     ecx, [ebp+var_158] ; this
.text:00000826                 call    ??1CArchiveLink@@QAE@XZ ; CArchiveLink::~CArchiveLink(void)
.text:0000082B                 mov     byte ptr [ebp+var_4], 4
.text:0000082F                 lea     ecx, [ebp+var_EC] ; this
.text:00000835                 call    ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text:0000083A                 jmp     loc_41F
.text:0000083F ; ---------------------------------------------------------------------------
.text:0000083F
.text:0000083F loc_83F:                                ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+650j
.text:0000083F                 mov     edx, [ebp+arg_18]
.text:00000842                 movzx   eax, byte ptr [edx+24h]
.text:00000846                 test    eax, eax
.text:00000848                 jnz     loc_A35
.text:0000084E                 lea     ecx, [ebp+var_14C]
.text:00000854                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:00000859                 test    eax, eax
.text:0000085B                 jz      loc_A35
.text:00000861                 mov     ecx, [ebp+var_140]
.text:00000867                 mov     [ebp+var_220], ecx
.text:0000086D                 mov     edx, [ebp+var_13C]
.text:00000873                 mov     [ebp+var_21C], edx
.text:00000879                 mov     [ebp+var_224], 0
.text:00000883                 jmp     short loc_894
.text:00000885 ; ---------------------------------------------------------------------------
.text:00000885
.text:00000885 loc_885:                                ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &):loc_91Bj
.text:00000885                 mov     eax, [ebp+var_224]
.text:0000088B                 add     eax, 1
.text:0000088E                 mov     [ebp+var_224], eax
.text:00000894
.text:00000894 loc_894:                                ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+75Fj
.text:00000894                 lea     ecx, [ebp+var_14C]
.text:0000089A                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:0000089F                 cmp     [ebp+var_224], eax
.text:000008A5                 jnb     short loc_920
.text:000008A7                 mov     ecx, [ebp+var_224]
.text:000008AD                 push    ecx
.text:000008AE                 lea     ecx, [ebp+var_14C]
.text:000008B4                 call    ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:000008B9                 push    eax
.text:000008BA                 mov     edx, [ebp+arg_10]
.text:000008BD                 push    edx
.text:000008BE                 call    ?Find_FileName_InSortedVector@@YGHABV?$CObjectVector@VUString@@@@ABVUString@@@Z ; Find_FileName_InSortedVector(CObjectVector<UString> const &,UString const &)
.text:000008C3                 mov     [ebp+var_228], eax
.text:000008C9                 cmp     [ebp+var_228], 0
.text:000008D0                 jl      short loc_91B
.text:000008D2                 mov     eax, [ebp+var_228]
.text:000008D8                 cmp     eax, [ebp+var_30]
.text:000008DB                 jbe     short loc_91B
.text:000008DD                 lea     ecx, [ebp+var_7C]
.text:000008E0                 call    ??B?$CObjArray@_N@@QAEPA_NXZ ; CObjArray<bool>::operator bool *(void)
.text:000008E5                 mov     ecx, [ebp+var_228]
.text:000008EB                 mov     byte ptr [eax+ecx], 1
.text:000008EF                 mov     edx, [ebp+var_228]
.text:000008F5                 push    edx
.text:000008F6                 lea     ecx, [ebp+var_24]
.text:000008F9                 call    ??A?$CRecordVector@_K@@QAEAA_KI@Z ; CRecordVector<unsigned __int64>::operator[](uint)
.text:000008FE                 mov     ecx, [ebp+var_220]
.text:00000904                 sub     ecx, [eax]
.text:00000906                 mov     edx, [ebp+var_21C]
.text:0000090C                 sbb     edx, [eax+4]
.text:0000090F                 mov     [ebp+var_220], ecx
.text:00000915                 mov     [ebp+var_21C], edx
.text:0000091B
.text:0000091B loc_91B:                                ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+7ACj
.text:0000091B                                         ; Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+7B7j
.text:0000091B                 jmp     loc_885
.text:00000920 ; ---------------------------------------------------------------------------
.text:00000920
.text:00000920 loc_920:                                ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+781j
.text:00000920                 mov     eax, [ebp+var_220]
.text:00000926                 or      eax, [ebp+var_21C]
.text:0000092C                 jz      loc_A35
.text:00000932                 mov     ecx, [ebp+var_14]
.text:00000935                 add     ecx, [ebp+var_220]
.text:0000093B                 mov     edx, [ebp+var_10]
.text:0000093E                 adc     edx, [ebp+var_21C]
.text:00000944                 mov     [ebp+var_230], ecx
.text:0000094A                 mov     [ebp+var_22C], edx
.text:00000950                 cmp     [ebp+var_22C], 0
.text:00000957                 jg      short loc_978
.text:00000959                 jl      short loc_964
.text:0000095B                 cmp     [ebp+var_230], 0
.text:00000962                 jnb     short loc_978
.text:00000964
.text:00000964 loc_964:                                ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+835j
.text:00000964                 mov     [ebp+var_230], 0
.text:0000096E                 mov     [ebp+var_22C], 0
.text:00000978
.text:00000978 loc_978:                                ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+833j
.text:00000978                                         ; Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+83Ej
.text:00000978                 mov     eax, [ebp+var_230]
.text:0000097E                 mov     [ebp+var_14], eax
.text:00000981                 mov     ecx, [ebp+var_22C]
.text:00000987                 mov     [ebp+var_10], ecx
.text:0000098A                 mov     esi, esp
.text:0000098C                 mov     edx, [ebp+var_10]
.text:0000098F                 push    edx
.text:00000990                 mov     eax, [ebp+var_14]
.text:00000993                 push    eax
.text:00000994                 mov     ecx, [ebp+arg_20]
.text:00000997                 mov     edx, [ecx]
.text:00000999                 mov     eax, [ebp+arg_20]
.text:0000099C                 push    eax
.text:0000099D                 mov     ecx, [edx+0Ch]
.text:000009A0                 call    ecx
.text:000009A2                 cmp     esi, esp
.text:000009A4                 call    __RTC_CheckEsp
.text:000009A9                 mov     [ebp+var_234], eax
.text:000009AF                 cmp     [ebp+var_234], 0
.text:000009B6                 jz      short loc_A35
.text:000009B8                 mov     edx, [ebp+var_234]
.text:000009BE                 mov     [ebp+var_280], edx
.text:000009C4                 mov     byte ptr [ebp+var_4], 7
.text:000009C8                 lea     ecx, [ebp+var_1CC] ; this
.text:000009CE                 call    ??1COpenOptions@@QAE@XZ ; COpenOptions::~COpenOptions(void)
.text:000009D3                 mov     byte ptr [ebp+var_4], 6
.text:000009D7                 lea     ecx, [ebp+var_16C]
.text:000009DD                 call    ??1?$CObjectVector@UCOpenType@@@@QAE@XZ ; CObjectVector<COpenType>::~CObjectVector<COpenType>(void)
.text:000009E2                 mov     byte ptr [ebp+var_4], 5
.text:000009E6                 lea     ecx, [ebp+var_158] ; this
.text:000009EC                 call    ??1CArchiveLink@@QAE@XZ ; CArchiveLink::~CArchiveLink(void)
.text:000009F1                 mov     byte ptr [ebp+var_4], 4
.text:000009F5                 lea     ecx, [ebp+var_EC] ; this
.text:000009FB                 call    ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text:00000A00                 mov     byte ptr [ebp+var_4], 2
.text:00000A04                 lea     ecx, [ebp+var_8C]
.text:00000A0A                 call    ??1?$CMyComPtr@UIArchiveExtractCallback@@@@QAE@XZ ; CMyComPtr<IArchiveExtractCallback>::~CMyComPtr<IArchiveExtractCallback>(void)
.text:00000A0F                 mov     byte ptr [ebp+var_4], 0
.text:00000A13                 lea     ecx, [ebp+var_7C]
.text:00000A16                 call    ??1?$CObjArray@_N@@QAE@XZ ; CObjArray<bool>::~CObjArray<bool>(void)
.text:00000A1B                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000A22                 lea     ecx, [ebp+var_24]
.text:00000A25                 call    ??1?$CRecordVector@_K@@QAE@XZ ; CRecordVector<unsigned __int64>::~CRecordVector<unsigned __int64>(void)
.text:00000A2A                 mov     eax, [ebp+var_280]
.text:00000A30                 jmp     loc_EE4
.text:00000A35 ; ---------------------------------------------------------------------------
.text:00000A35
.text:00000A35 loc_A35:                                ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+724j
.text:00000A35                                         ; Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+737j ...
.text:00000A35                 lea     ecx, [ebp+var_158]
.text:00000A3B                 call    ?Back@?$CObjectVector@VCArc@@@@QAEAAVCArc@@XZ ; CObjectVector<CArc>::Back(void)
.text:00000A40                 mov     [ebp+var_238], eax
.text:00000A46                 mov     eax, [ebp+arg_18]
.text:00000A49                 movzx   ecx, byte ptr [eax+24h]
.text:00000A4D                 test    ecx, ecx
.text:00000A4F                 jnz     short loc_A68
.text:00000A51                 movzx   edx, [ebp+var_C7]
.text:00000A58                 test    edx, edx
.text:00000A5A                 jnz     short loc_A68
.text:00000A5C                 mov     [ebp+var_2A0], 1
.text:00000A66                 jmp     short loc_A72
.text:00000A68 ; ---------------------------------------------------------------------------
.text:00000A68
.text:00000A68 loc_A68:                                ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+92Bj
.text:00000A68                                         ; Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+936j
.text:00000A68                 mov     [ebp+var_2A0], 0
.text:00000A72
.text:00000A72 loc_A72:                                ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+942j
.text:00000A72                 mov     eax, [ebp+var_238]
.text:00000A78                 mov     cl, byte ptr [ebp+var_2A0]
.text:00000A7E                 mov     [eax+0A4h], cl
.text:00000A84                 mov     edx, [ebp+var_238]
.text:00000A8A                 mov     eax, [ebp+var_D4]
.text:00000A90                 mov     [edx+9Ch], eax
.text:00000A96                 mov     ecx, [ebp+var_D0]
.text:00000A9C                 mov     [edx+0A0h], ecx
.text:00000AA2                 xor     edx, edx
.text:00000AA4                 cmp     [ebp+arg_24], 0
.text:00000AA8                 setnz   dl
.text:00000AAB                 mov     [ebp+var_249], dl
.text:00000AB1                 lea     eax, [ebp+var_244]
.text:00000AB7                 push    eax             ; unsigned __int64 *
.text:00000AB8                 mov     ecx, [ebp+arg_28]
.text:00000ABB                 push    ecx             ; UString *
.text:00000ABC                 mov     edx, [ebp+var_84]
.text:00000AC2                 push    edx             ; CArchiveExtractCallback *
.text:00000AC3                 mov     eax, [ebp+arg_20]
.text:00000AC6                 push    eax             ; int
.text:00000AC7                 movzx   ecx, [ebp+var_249]
.text:00000ACE                 push    ecx             ; char
.text:00000ACF                 mov     edx, [ebp+arg_18]
.text:00000AD2                 push    edx             ; int
.text:00000AD3                 mov     eax, [ebp+arg_14]
.text:00000AD6                 push    eax             ; struct NWildcard::CCensorNode *
.text:00000AD7                 mov     ecx, [ebp+var_EC]
.text:00000ADD                 add     ecx, [ebp+var_140]
.text:00000AE3                 mov     edx, [ebp+var_E8]
.text:00000AE9                 adc     edx, [ebp+var_13C]
.text:00000AEF                 push    edx             ; int
.text:00000AF0                 push    ecx             ; int
.text:00000AF1                 lea     eax, [ebp+var_158]
.text:00000AF7                 push    eax             ; int
.text:00000AF8                 mov     ecx, [ebp+arg_0]
.text:00000AFB                 push    ecx             ; int
.text:00000AFC                 call    ?DecompressArchive@@YGJPAVCCodecs@@ABUCArchiveLink@@_KABVCCensorNode@NWildcard@@ABUCExtractOptions@@_NPAUIExtractCallbackUI@@PAVCArchiveExtractCallback@@AAVUString@@AA_K@Z ; DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)
.text:00000B01                 mov     [ebp+var_250], eax
.text:00000B07                 cmp     [ebp+var_250], 0
.text:00000B0E                 jz      short loc_B8D
.text:00000B10                 mov     edx, [ebp+var_250]
.text:00000B16                 mov     [ebp+var_284], edx
.text:00000B1C                 mov     byte ptr [ebp+var_4], 7
.text:00000B20                 lea     ecx, [ebp+var_1CC] ; this
.text:00000B26                 call    ??1COpenOptions@@QAE@XZ ; COpenOptions::~COpenOptions(void)
.text:00000B2B                 mov     byte ptr [ebp+var_4], 6
.text:00000B2F                 lea     ecx, [ebp+var_16C]
.text:00000B35                 call    ??1?$CObjectVector@UCOpenType@@@@QAE@XZ ; CObjectVector<COpenType>::~CObjectVector<COpenType>(void)
.text:00000B3A                 mov     byte ptr [ebp+var_4], 5
.text:00000B3E                 lea     ecx, [ebp+var_158] ; this
.text:00000B44                 call    ??1CArchiveLink@@QAE@XZ ; CArchiveLink::~CArchiveLink(void)
.text:00000B49                 mov     byte ptr [ebp+var_4], 4
.text:00000B4D                 lea     ecx, [ebp+var_EC] ; this
.text:00000B53                 call    ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text:00000B58                 mov     byte ptr [ebp+var_4], 2
.text:00000B5C                 lea     ecx, [ebp+var_8C]
.text:00000B62                 call    ??1?$CMyComPtr@UIArchiveExtractCallback@@@@QAE@XZ ; CMyComPtr<IArchiveExtractCallback>::~CMyComPtr<IArchiveExtractCallback>(void)
.text:00000B67                 mov     byte ptr [ebp+var_4], 0
.text:00000B6B                 lea     ecx, [ebp+var_7C]
.text:00000B6E                 call    ??1?$CObjArray@_N@@QAE@XZ ; CObjArray<bool>::~CObjArray<bool>(void)
.text:00000B73                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000B7A                 lea     ecx, [ebp+var_24]
.text:00000B7D                 call    ??1?$CRecordVector@_K@@QAE@XZ ; CRecordVector<unsigned __int64>::~CRecordVector<unsigned __int64>(void)
.text:00000B82                 mov     eax, [ebp+var_284]
.text:00000B88                 jmp     loc_EE4
.text:00000B8D ; ---------------------------------------------------------------------------
.text:00000B8D
.text:00000B8D loc_B8D:                                ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+9EAj
.text:00000B8D                 mov     eax, [ebp+arg_18]
.text:00000B90                 movzx   ecx, byte ptr [eax+24h]
.text:00000B94                 test    ecx, ecx
.text:00000B96                 jnz     short loc_BBC
.text:00000B98                 mov     edx, [ebp+var_EC]
.text:00000B9E                 add     edx, [ebp+var_140]
.text:00000BA4                 mov     eax, [ebp+var_E8]
.text:00000BAA                 adc     eax, [ebp+var_13C]
.text:00000BB0                 mov     dword ptr [ebp+var_244], edx
.text:00000BB6                 mov     dword ptr [ebp+var_244+4], eax
.text:00000BBC
.text:00000BBC loc_BBC:                                ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+A72j
.text:00000BBC                 mov     ecx, [ebp+var_A4]
.text:00000BC2                 add     ecx, dword ptr [ebp+var_244]
.text:00000BC8                 mov     edx, [ebp+var_A0]
.text:00000BCE                 adc     edx, dword ptr [ebp+var_244+4]
.text:00000BD4                 mov     [ebp+var_A4], ecx
.text:00000BDA                 mov     [ebp+var_A0], edx
.text:00000BE0                 mov     eax, [ebp+var_84]
.text:00000BE6                 mov     ecx, [eax+160h]
.text:00000BEC                 mov     edx, [ecx+20h]
.text:00000BEF                 add     edx, dword ptr [ebp+var_244]
.text:00000BF5                 mov     eax, [ecx+24h]
.text:00000BF8                 adc     eax, dword ptr [ebp+var_244+4]
.text:00000BFE                 mov     ecx, [ebp+var_84]
.text:00000C04                 mov     ecx, [ecx+160h]
.text:00000C0A                 mov     [ecx+20h], edx
.text:00000C0D                 mov     [ecx+24h], eax
.text:00000C10                 mov     edx, [ebp+var_84]
.text:00000C16                 mov     eax, [edx+160h]
.text:00000C1C                 mov     ecx, [ebp+var_84]
.text:00000C22                 mov     edx, [ecx+180h]
.text:00000C28                 mov     [eax+28h], edx
.text:00000C2B                 mov     ecx, [ecx+184h]
.text:00000C31                 mov     [eax+2Ch], ecx
.text:00000C34                 mov     ecx, [ebp+arg_28] ; this
.text:00000C37                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:00000C3C                 movzx   edx, al
.text:00000C3F                 test    edx, edx
.text:00000C41                 jnz     short loc_CBE
.text:00000C43                 mov     [ebp+var_288], 80004005h
.text:00000C4D                 mov     byte ptr [ebp+var_4], 7
.text:00000C51                 lea     ecx, [ebp+var_1CC] ; this
.text:00000C57                 call    ??1COpenOptions@@QAE@XZ ; COpenOptions::~COpenOptions(void)
.text:00000C5C                 mov     byte ptr [ebp+var_4], 6
.text:00000C60                 lea     ecx, [ebp+var_16C]
.text:00000C66                 call    ??1?$CObjectVector@UCOpenType@@@@QAE@XZ ; CObjectVector<COpenType>::~CObjectVector<COpenType>(void)
.text:00000C6B                 mov     byte ptr [ebp+var_4], 5
.text:00000C6F                 lea     ecx, [ebp+var_158] ; this
.text:00000C75                 call    ??1CArchiveLink@@QAE@XZ ; CArchiveLink::~CArchiveLink(void)
.text:00000C7A                 mov     byte ptr [ebp+var_4], 4
.text:00000C7E                 lea     ecx, [ebp+var_EC] ; this
.text:00000C84                 call    ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text:00000C89                 mov     byte ptr [ebp+var_4], 2
.text:00000C8D                 lea     ecx, [ebp+var_8C]
.text:00000C93                 call    ??1?$CMyComPtr@UIArchiveExtractCallback@@@@QAE@XZ ; CMyComPtr<IArchiveExtractCallback>::~CMyComPtr<IArchiveExtractCallback>(void)
.text:00000C98                 mov     byte ptr [ebp+var_4], 0
.text:00000C9C                 lea     ecx, [ebp+var_7C]
.text:00000C9F                 call    ??1?$CObjArray@_N@@QAE@XZ ; CObjArray<bool>::~CObjArray<bool>(void)
.text:00000CA4                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000CAB                 lea     ecx, [ebp+var_24]
.text:00000CAE                 call    ??1?$CRecordVector@_K@@QAE@XZ ; CRecordVector<unsigned __int64>::~CRecordVector<unsigned __int64>(void)
.text:00000CB3                 mov     eax, [ebp+var_288]
.text:00000CB9                 jmp     loc_EE4
.text:00000CBE ; ---------------------------------------------------------------------------
.text:00000CBE
.text:00000CBE loc_CBE:                                ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+B1Dj
.text:00000CBE                 mov     byte ptr [ebp+var_4], 7
.text:00000CC2                 lea     ecx, [ebp+var_1CC] ; this
.text:00000CC8                 call    ??1COpenOptions@@QAE@XZ ; COpenOptions::~COpenOptions(void)
.text:00000CCD                 mov     byte ptr [ebp+var_4], 6
.text:00000CD1                 lea     ecx, [ebp+var_16C]
.text:00000CD7                 call    ??1?$CObjectVector@UCOpenType@@@@QAE@XZ ; CObjectVector<COpenType>::~CObjectVector<COpenType>(void)
.text:00000CDC                 mov     byte ptr [ebp+var_4], 5
.text:00000CE0                 lea     ecx, [ebp+var_158] ; this
.text:00000CE6                 call    ??1CArchiveLink@@QAE@XZ ; CArchiveLink::~CArchiveLink(void)
.text:00000CEB                 mov     byte ptr [ebp+var_4], 4
.text:00000CEF                 lea     ecx, [ebp+var_EC] ; this
.text:00000CF5                 call    ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text:00000CFA                 jmp     loc_41F
.text:00000CFF ; ---------------------------------------------------------------------------
.text:00000CFF
.text:00000CFF loc_CFF:                                ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+30Aj
.text:00000CFF                 movzx   eax, [ebp+var_91]
.text:00000D06                 test    eax, eax
.text:00000D08                 jnz     short loc_D19
.text:00000D0A                 movzx   ecx, [ebp+var_A9]
.text:00000D11                 test    ecx, ecx
.text:00000D13                 jz      loc_DF6
.text:00000D19
.text:00000D19 loc_D19:                                ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+BE4j
.text:00000D19                 mov     esi, esp
.text:00000D1B                 mov     edx, [ebp+var_10]
.text:00000D1E                 push    edx
.text:00000D1F                 mov     eax, [ebp+var_14]
.text:00000D22                 push    eax
.text:00000D23                 mov     ecx, [ebp+arg_20]
.text:00000D26                 mov     edx, [ecx]
.text:00000D28                 mov     eax, [ebp+arg_20]
.text:00000D2B                 push    eax
.text:00000D2C                 mov     ecx, [edx+0Ch]
.text:00000D2F                 call    ecx
.text:00000D31                 cmp     esi, esp
.text:00000D33                 call    __RTC_CheckEsp
.text:00000D38                 mov     [ebp+var_254], eax
.text:00000D3E                 cmp     [ebp+var_254], 0
.text:00000D45                 jz      short loc_D88
.text:00000D47                 mov     edx, [ebp+var_254]
.text:00000D4D                 mov     [ebp+var_28C], edx
.text:00000D53                 mov     byte ptr [ebp+var_4], 2
.text:00000D57                 lea     ecx, [ebp+var_8C]
.text:00000D5D                 call    ??1?$CMyComPtr@UIArchiveExtractCallback@@@@QAE@XZ ; CMyComPtr<IArchiveExtractCallback>::~CMyComPtr<IArchiveExtractCallback>(void)
.text:00000D62                 mov     byte ptr [ebp+var_4], 0
.text:00000D66                 lea     ecx, [ebp+var_7C]
.text:00000D69                 call    ??1?$CObjArray@_N@@QAE@XZ ; CObjArray<bool>::~CObjArray<bool>(void)
.text:00000D6E                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000D75                 lea     ecx, [ebp+var_24]
.text:00000D78                 call    ??1?$CRecordVector@_K@@QAE@XZ ; CRecordVector<unsigned __int64>::~CRecordVector<unsigned __int64>(void)
.text:00000D7D                 mov     eax, [ebp+var_28C]
.text:00000D83                 jmp     loc_EE4
.text:00000D88 ; ---------------------------------------------------------------------------
.text:00000D88
.text:00000D88 loc_D88:                                ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+C21j
.text:00000D88                 mov     esi, esp
.text:00000D8A                 lea     eax, [ebp+var_A4]
.text:00000D90                 push    eax
.text:00000D91                 mov     ecx, [ebp+arg_20]
.text:00000D94                 mov     edx, [ecx]
.text:00000D96                 mov     eax, [ebp+arg_20]
.text:00000D99                 push    eax
.text:00000D9A                 mov     ecx, [edx+10h]
.text:00000D9D                 call    ecx
.text:00000D9F                 cmp     esi, esp
.text:00000DA1                 call    __RTC_CheckEsp
.text:00000DA6                 mov     [ebp+var_258], eax
.text:00000DAC                 cmp     [ebp+var_258], 0
.text:00000DB3                 jz      short loc_DF6
.text:00000DB5                 mov     edx, [ebp+var_258]
.text:00000DBB                 mov     [ebp+var_290], edx
.text:00000DC1                 mov     byte ptr [ebp+var_4], 2
.text:00000DC5                 lea     ecx, [ebp+var_8C]
.text:00000DCB                 call    ??1?$CMyComPtr@UIArchiveExtractCallback@@@@QAE@XZ ; CMyComPtr<IArchiveExtractCallback>::~CMyComPtr<IArchiveExtractCallback>(void)
.text:00000DD0                 mov     byte ptr [ebp+var_4], 0
.text:00000DD4                 lea     ecx, [ebp+var_7C]
.text:00000DD7                 call    ??1?$CObjArray@_N@@QAE@XZ ; CObjArray<bool>::~CObjArray<bool>(void)
.text:00000DDC                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000DE3                 lea     ecx, [ebp+var_24]
.text:00000DE6                 call    ??1?$CRecordVector@_K@@QAE@XZ ; CRecordVector<unsigned __int64>::~CRecordVector<unsigned __int64>(void)
.text:00000DEB                 mov     eax, [ebp+var_290]
.text:00000DF1                 jmp     loc_EE4
.text:00000DF6 ; ---------------------------------------------------------------------------
.text:00000DF6
.text:00000DF6 loc_DF6:                                ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+BEFj
.text:00000DF6                                         ; Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+C8Fj
.text:00000DF6                 mov     eax, [ebp+arg_2C]
.text:00000DF9                 mov     ecx, [ebp+var_84]
.text:00000DFF                 mov     edx, [ecx+168h]
.text:00000E05                 mov     [eax+20h], edx
.text:00000E08                 mov     ecx, [ecx+16Ch]
.text:00000E0E                 mov     [eax+24h], ecx
.text:00000E11                 mov     edx, [ebp+arg_2C]
.text:00000E14                 mov     eax, [ebp+var_84]
.text:00000E1A                 mov     ecx, [eax+170h]
.text:00000E20                 mov     [edx+28h], ecx
.text:00000E23                 mov     eax, [eax+174h]
.text:00000E29                 mov     [edx+2Ch], eax
.text:00000E2C                 mov     ecx, [ebp+arg_2C]
.text:00000E2F                 mov     edx, [ebp+var_84]
.text:00000E35                 mov     eax, [edx+178h]
.text:00000E3B                 mov     [ecx+30h], eax
.text:00000E3E                 mov     edx, [edx+17Ch]
.text:00000E44                 mov     [ecx+34h], edx
.text:00000E47                 mov     eax, [ebp+arg_2C]
.text:00000E4A                 mov     ecx, [ebp+var_84]
.text:00000E50                 mov     edx, [ecx+180h]
.text:00000E56                 mov     [eax+8], edx
.text:00000E59                 mov     ecx, [ecx+184h]
.text:00000E5F                 mov     [eax+0Ch], ecx
.text:00000E62                 mov     edx, [ebp+arg_2C]
.text:00000E65                 mov     eax, [ebp+var_84]
.text:00000E6B                 mov     ecx, [eax+188h]
.text:00000E71                 mov     [edx+10h], ecx
.text:00000E74                 mov     eax, [eax+18Ch]
.text:00000E7A                 mov     [edx+14h], eax
.text:00000E7D                 mov     ecx, [ebp+arg_C]
.text:00000E80                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:00000E85                 xor     ecx, ecx
.text:00000E87                 mov     edx, [ebp+arg_2C]
.text:00000E8A                 mov     [edx], eax
.text:00000E8C                 mov     [edx+4], ecx
.text:00000E8F                 mov     eax, [ebp+var_84]
.text:00000E95                 mov     ecx, [eax+160h]
.text:00000E9B                 mov     edx, [ebp+arg_2C]
.text:00000E9E                 mov     eax, [ecx+20h]
.text:00000EA1                 mov     [edx+18h], eax
.text:00000EA4                 mov     ecx, [ecx+24h]
.text:00000EA7                 mov     [edx+1Ch], ecx
.text:00000EAA                 mov     [ebp+var_294], 0
.text:00000EB4                 mov     byte ptr [ebp+var_4], 2
.text:00000EB8                 lea     ecx, [ebp+var_8C]
.text:00000EBE                 call    ??1?$CMyComPtr@UIArchiveExtractCallback@@@@QAE@XZ ; CMyComPtr<IArchiveExtractCallback>::~CMyComPtr<IArchiveExtractCallback>(void)
.text:00000EC3                 mov     byte ptr [ebp+var_4], 0
.text:00000EC7                 lea     ecx, [ebp+var_7C]
.text:00000ECA                 call    ??1?$CObjArray@_N@@QAE@XZ ; CObjArray<bool>::~CObjArray<bool>(void)
.text:00000ECF                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000ED6                 lea     ecx, [ebp+var_24]
.text:00000ED9                 call    ??1?$CRecordVector@_K@@QAE@XZ ; CRecordVector<unsigned __int64>::~CRecordVector<unsigned __int64>(void)
.text:00000EDE                 mov     eax, [ebp+var_294]
.text:00000EE4
.text:00000EE4 loc_EE4:                                ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+2D2j
.text:00000EE4                                         ; Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+440j ...
.text:00000EE4                 push    edx
.text:00000EE5                 mov     ecx, ebp
.text:00000EE7                 push    eax
.text:00000EE8                 lea     edx, $LN77
.text:00000EEE                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00000EF3                 pop     eax
.text:00000EF4                 pop     edx
.text:00000EF5                 mov     ecx, [ebp+var_C]
.text:00000EF8                 mov     large fs:0, ecx
.text:00000EFF                 pop     ecx
.text:00000F00                 pop     edi
.text:00000F01                 pop     esi
.text:00000F02                 add     esp, 2A0h
.text:00000F08                 cmp     ebp, esp
.text:00000F0A                 call    __RTC_CheckEsp
.text:00000F0F                 mov     esp, ebp
.text:00000F11                 pop     ebp
.text:00000F12                 retn    30h
.text:00000F12 ?Extract@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABV?$CRecordVector@H@@AAV?$CObjectVector@VUString@@@@3ABVCCensorNode@NWildcard@@ABUCExtractOptions@@PAUIOpenCallbackUI@@PAUIExtractCallbackUI@@PAUIHashCalc@@AAVUString@@AAUCDecompressStat@@@Z endp
.text:00000F12
.text:00000F12 ; ---------------------------------------------------------------------------
.text:00000F15                 align 4
.text:00000F18 $LN77           dd 0Bh                  ; DATA XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+DC4o
.text:00000F1C                 dd offset $LN76
.text:00000F20 $LN76           dd 0FFFFFFDCh, 0Ch      ; DATA XREF: .text:00000F1Co
.text:00000F28                 dd offset $LN64         ; "arcSizes"
.text:00000F2C                 dd 0FFFFFF94h, 38h
.text:00000F34                 dd offset $LN65         ; "fi"
.text:00000F38                 dd 0FFFFFF84h, 4
.text:00000F40                 dd offset $LN66         ; "skipArcs"
.text:00000F44                 dd 0FFFFFF74h, 4
.text:00000F4C                 dd offset $LN67         ; "ec"
.text:00000F50                 dd 0FFFFFF5Ch, 8
.text:00000F58                 dd offset $LN68         ; "totalPackProcessed"
.text:00000F5C                 dd 0FFFFFF14h, 38h
.text:00000F64                 dd offset $LN69         ; "fi"
.text:00000F68                 dd 0FFFFFEA8h, 60h
.text:00000F70                 dd offset $LN70         ; "arcLink"
.text:00000F74                 dd 0FFFFFE94h, 0Ch
.text:00000F7C                 dd offset $LN71         ; "types2"
.text:00000F80                 dd 0FFFFFE34h, 58h
.text:00000F88                 dd offset $LN72         ; "op"
.text:00000F8C                 dd 0FFFFFDECh, 38h
.text:00000F94                 dd offset $LN73         ; "fi"
.text:00000F98                 dd 0FFFFFDBCh, 8
.text:00000FA0                 dd offset $LN74         ; "packProcessed"
.text:00000FA4 $LN74           db 'packProcessed',0    ; DATA XREF: .text:00000FA0o
.text:00000FB2 $LN73           db 'fi',0               ; DATA XREF: .text:00000F94o
.text:00000FB5 $LN72           db 'op',0               ; DATA XREF: .text:00000F88o
.text:00000FB8 $LN71           db 'types2',0           ; DATA XREF: .text:00000F7Co
.text:00000FBF $LN70           db 'arcLink',0          ; DATA XREF: .text:00000F70o
.text:00000FC7 $LN69           db 'fi',0               ; DATA XREF: .text:00000F64o
.text:00000FCA $LN68           db 'totalPackProcessed',0 ; DATA XREF: .text:00000F58o
.text:00000FDD $LN67           db 'ec',0               ; DATA XREF: .text:00000F4Co
.text:00000FE0 $LN66           db 'skipArcs',0         ; DATA XREF: .text:00000F40o
.text:00000FE9 $LN65           db 'fi',0               ; DATA XREF: .text:00000F34o
.text:00000FEC $LN64           db 'arcSizes',0         ; DATA XREF: .text:00000F28o
.text:00000FF5                 db 0Fh dup(0CCh)
.text:00001004
.text:00001004 ; =============== S U B R O U T I N E =======================================
.text:00001004
.text:00001004 ; Attributes: bp-based frame
.text:00001004
.text:00001004 ; int __stdcall DecompressArchive(int, int, int, int, struct NWildcard::CCensorNode *, int, char, int, CArchiveExtractCallback *, UString *, unsigned __int64 *)
.text:00001004 ?DecompressArchive@@YGJPAVCCodecs@@ABUCArchiveLink@@_KABVCCensorNode@NWildcard@@ABUCExtractOptions@@_NPAUIExtractCallbackUI@@PAVCArchiveExtractCallback@@AAVUString@@AA_K@Z proc near
.text:00001004                                         ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+9D8p
.text:00001004
.text:00001004 var_180         = dword ptr -180h
.text:00001004 var_17C         = dword ptr -17Ch
.text:00001004 var_178         = dword ptr -178h
.text:00001004 var_174         = dword ptr -174h
.text:00001004 var_170         = dword ptr -170h
.text:00001004 var_16C         = dword ptr -16Ch
.text:00001004 var_168         = dword ptr -168h
.text:00001004 var_164         = dword ptr -164h
.text:00001004 var_160         = dword ptr -160h
.text:00001004 var_15C         = dword ptr -15Ch
.text:00001004 var_158         = byte ptr -158h
.text:00001004 var_14C         = byte ptr -14Ch
.text:00001004 var_13C         = tagPROPVARIANT ptr -13Ch
.text:00001004 var_128         = dword ptr -128h
.text:00001004 var_124         = dword ptr -124h
.text:00001004 var_120         = dword ptr -120h
.text:00001004 var_11C         = dword ptr -11Ch
.text:00001004 var_118         = word ptr -118h
.text:00001004 var_114         = dword ptr -114h
.text:00001004 var_110         = dword ptr -110h
.text:00001004 var_10C         = dword ptr -10Ch
.text:00001004 var_108         = dword ptr -108h
.text:00001004 var_100         = byte ptr -100h
.text:00001004 var_E8          = byte ptr -0E8h
.text:00001004 var_D0          = byte ptr -0D0h
.text:00001004 var_CD          = byte ptr -0CDh
.text:00001004 var_BC          = dword ptr -0BCh
.text:00001004 var_B4          = dword ptr -0B4h
.text:00001004 var_A9          = byte ptr -0A9h
.text:00001004 var_A4          = byte ptr -0A4h
.text:00001004 var_90          = byte ptr -90h
.text:00001004 var_7C          = byte ptr -7Ch
.text:00001004 var_69          = byte ptr -69h
.text:00001004 var_68          = dword ptr -68h
.text:00001004 var_60          = byte ptr -60h
.text:00001004 var_4C          = byte ptr -4Ch
.text:00001004 var_38          = byte ptr -38h
.text:00001004 var_24          = byte ptr -24h
.text:00001004 var_14          = dword ptr -14h
.text:00001004 var_10          = dword ptr -10h
.text:00001004 var_C           = dword ptr -0Ch
.text:00001004 var_4           = dword ptr -4
.text:00001004 arg_0           = dword ptr  8
.text:00001004 arg_4           = dword ptr  0Ch
.text:00001004 arg_8           = dword ptr  10h
.text:00001004 arg_C           = dword ptr  14h
.text:00001004 arg_10          = dword ptr  18h
.text:00001004 arg_14          = dword ptr  1Ch
.text:00001004 arg_18          = byte ptr  20h
.text:00001004 arg_1C          = dword ptr  24h
.text:00001004 arg_20          = dword ptr  28h
.text:00001004 arg_24          = dword ptr  2Ch
.text:00001004 arg_28          = dword ptr  30h
.text:00001004
.text:00001004                 push    ebp
.text:00001005                 mov     ebp, esp
.text:00001007                 push    0FFFFFFFFh
.text:00001009                 push    offset __ehhandler$?DecompressArchive@@YGJPAVCCodecs@@ABUCArchiveLink@@_KABVCCensorNode@NWildcard@@ABUCExtractOptions@@_NPAUIExtractCallbackUI@@PAVCArchiveExtractCallback@@AAVUString@@AA_K@Z
.text:0000100E                 mov     eax, large fs:0
.text:00001014                 push    eax
.text:00001015                 sub     esp, 174h
.text:0000101B                 push    esi
.text:0000101C                 push    edi
.text:0000101D                 lea     edi, [ebp+var_180]
.text:00001023                 mov     ecx, 5Dh ; ']'
.text:00001028                 mov     eax, 0CCCCCCCCh
.text:0000102D                 rep stosd
.text:0000102F                 mov     eax, dword ptr ds:___security_cookie
.text:00001034                 xor     eax, ebp
.text:00001036                 push    eax
.text:00001037                 lea     eax, [ebp+var_C]
.text:0000103A                 mov     large fs:0, eax
.text:00001040                 mov     ecx, [ebp+arg_4]
.text:00001043                 call    ?Back@?$CObjectVector@VCArc@@@@QBEABVCArc@@XZ ; CObjectVector<CArc>::Back(void)
.text:00001048                 mov     [ebp+var_10], eax
.text:0000104B                 mov     eax, [ebp+arg_28]
.text:0000104E                 mov     dword ptr [eax], 0
.text:00001054                 mov     dword ptr [eax+4], 0
.text:0000105B                 mov     ecx, [ebp+var_10]
.text:0000105E                 call    ??B?$CMyComPtr@UIInArchive@@@@QBEPAUIInArchive@@XZ ; CMyComPtr<IInArchive>::operator IInArchive *(void)
.text:00001063                 mov     [ebp+var_14], eax
.text:00001066                 lea     ecx, [ebp+var_24]
.text:00001069                 call    ??0?$CRecordVector@I@@QAE@XZ ; CRecordVector<uint>::CRecordVector<uint>(void)
.text:0000106E                 mov     [ebp+var_4], 0
.text:00001075                 lea     ecx, [ebp+var_38]
.text:00001078                 call    ??0?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::CObjectVector<UString>(void)
.text:0000107D                 mov     byte ptr [ebp+var_4], 1
.text:00001081                 mov     ecx, [ebp+arg_14]
.text:00001084                 add     ecx, 0Ch
.text:00001087                 push    ecx
.text:00001088                 lea     ecx, [ebp+var_4C]
.text:0000108B                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00001090                 mov     byte ptr [ebp+var_4], 2
.text:00001094                 mov     edx, [ebp+var_10]
.text:00001097                 add     edx, 88h ; 'Ãª'
.text:0000109D                 push    edx
.text:0000109E                 lea     ecx, [ebp+var_60]
.text:000010A1                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:000010A6                 mov     byte ptr [ebp+var_4], 3
.text:000010AA                 mov     ecx, [ebp+arg_4]
.text:000010AD                 call    ?Size@?$CObjectVector@VCArc@@@@QBEIXZ ; CObjectVector<CArc>::Size(void)
.text:000010B2                 cmp     eax, 1
.text:000010B5                 jbe     short loc_1106
.text:000010B7                 push    0
.text:000010B9                 mov     ecx, [ebp+arg_4]
.text:000010BC                 call    ??A?$CObjectVector@VCArc@@@@QBEABVCArc@@I@Z ; CObjectVector<CArc>::operator[](uint)
.text:000010C1                 mov     [ebp+var_68], eax
.text:000010C4                 push    offset $SG73813 ; "pe"
.text:000010C9                 mov     eax, [ebp+var_68]
.text:000010CC                 mov     ecx, [eax+94h]
.text:000010D2                 push    ecx
.text:000010D3                 mov     ecx, [ebp+arg_0]
.text:000010D6                 add     ecx, 8
.text:000010D9                 call    ??A?$CObjectVector@UCArcInfoEx@@@@QAEAAUCArcInfoEx@@I@Z ; CObjectVector<CArcInfoEx>::operator[](uint)
.text:000010DE                 add     eax, 0Ch
.text:000010E1                 mov     ecx, eax
.text:000010E3                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000010E8                 push    eax             ; wchar_t *
.text:000010E9                 call    ?StringsAreEqualNoCase_Ascii@@YG_NPB_WPBD@Z ; StringsAreEqualNoCase_Ascii(wchar_t const *,char const *)
.text:000010EE                 movzx   edx, al
.text:000010F1                 test    edx, edx
.text:000010F3                 jz      short loc_1106
.text:000010F5                 mov     eax, [ebp+var_68]
.text:000010F8                 add     eax, 88h ; 'Ãª'
.text:000010FD                 push    eax
.text:000010FE                 lea     ecx, [ebp+var_60]
.text:00001101                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:00001106
.text:00001106 loc_1106:                               ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+B1j
.text:00001106                                         ; DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+EFj
.text:00001106                 push    offset $SG73816 ; wchar_t *
.text:0000110B                 lea     ecx, [ebp+var_158]
.text:00001111                 call    ??0UString@@QAE@PB_W@Z ; UString::UString(wchar_t const *)
.text:00001116                 mov     byte ptr [ebp+var_4], 4
.text:0000111A                 lea     ecx, [ebp+var_60]
.text:0000111D                 push    ecx
.text:0000111E                 lea     edx, [ebp+var_14C]
.text:00001124                 push    edx
.text:00001125                 call    ?Get_Correct_FsFile_Name@@YG?AVUString@@ABV1@@Z ; Get_Correct_FsFile_Name(UString const &)
.text:0000112A                 mov     [ebp+var_178], eax
.text:00001130                 mov     eax, [ebp+var_178]
.text:00001136                 mov     [ebp+var_17C], eax
.text:0000113C                 mov     byte ptr [ebp+var_4], 5
.text:00001140                 mov     ecx, [ebp+var_17C]
.text:00001146                 push    ecx             ; struct UString *
.text:00001147                 lea     edx, [ebp+var_158]
.text:0000114D                 push    edx             ; struct UString *
.text:0000114E                 lea     ecx, [ebp+var_4C] ; this
.text:00001151                 call    ?Replace@UString@@QAEXABV1@0@Z ; UString::Replace(UString const &,UString const &)
.text:00001156                 mov     byte ptr [ebp+var_4], 4
.text:0000115A                 lea     ecx, [ebp+var_14C] ; this
.text:00001160                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00001165                 mov     byte ptr [ebp+var_4], 3
.text:00001169                 lea     ecx, [ebp+var_158] ; this
.text:0000116F                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00001174                 mov     [ebp+var_69], 0
.text:00001178                 lea     ecx, [ebp+var_7C]
.text:0000117B                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00001180                 mov     byte ptr [ebp+var_4], 6
.text:00001184                 lea     eax, [ebp+var_4C]
.text:00001187                 push    eax
.text:00001188                 lea     ecx, [ebp+var_90]
.text:0000118E                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00001193                 mov     byte ptr [ebp+var_4], 7
.text:00001197                 mov     ecx, [ebp+arg_14]
.text:0000119A                 movzx   edx, byte ptr [ecx]
.text:0000119D                 test    edx, edx
.text:0000119F                 jz      loc_1238
.text:000011A5                 mov     eax, [ebp+arg_14]
.text:000011A8                 cmp     dword ptr [eax+4], 3
.text:000011AC                 jz      loc_1238
.text:000011B2                 lea     ecx, [ebp+var_A4]
.text:000011B8                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:000011BD                 mov     byte ptr [ebp+var_4], 8
.text:000011C1                 lea     ecx, [ebp+var_7C]
.text:000011C4                 push    ecx             ; struct UString *
.text:000011C5                 lea     edx, [ebp+var_A4]
.text:000011CB                 push    edx             ; struct UString *
.text:000011CC                 lea     eax, [ebp+var_4C]
.text:000011CF                 push    eax             ; struct UString *
.text:000011D0                 call    ?SplitPathToParts_Smart@@YGXABVUString@@AAV1@1@Z ; SplitPathToParts_Smart(UString const &,UString &,UString &)
.text:000011D5                 lea     ecx, [ebp+var_7C] ; this
.text:000011D8                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:000011DD                 movzx   ecx, al
.text:000011E0                 test    ecx, ecx
.text:000011E2                 jnz     short loc_1229
.text:000011E4                 lea     ecx, [ebp+var_7C] ; this
.text:000011E7                 call    ?Back@UString@@QBE_WXZ ; UString::Back(void)
.text:000011EC                 movzx   edx, ax
.text:000011EF                 push    edx             ; wchar_t
.text:000011F0                 call    ?IsPathSepar@@YG_N_W@Z ; IsPathSepar(wchar_t)
.text:000011F5                 movzx   eax, al
.text:000011F8                 test    eax, eax
.text:000011FA                 jz      short loc_1204
.text:000011FC                 lea     ecx, [ebp+var_7C] ; this
.text:000011FF                 call    ?DeleteBack@UString@@QAEXXZ ; UString::DeleteBack(void)
.text:00001204
.text:00001204 loc_1204:                               ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+1F6j
.text:00001204                 lea     ecx, [ebp+var_7C] ; this
.text:00001207                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:0000120C                 movzx   ecx, al
.text:0000120F                 test    ecx, ecx
.text:00001211                 jnz     short loc_1229
.text:00001213                 lea     edx, [ebp+var_A4]
.text:00001219                 push    edx
.text:0000121A                 lea     ecx, [ebp+var_90]
.text:00001220                 call    ??4UString@@QAEAAV0@ABV0@@Z ; UString::operator=(UString const &)
.text:00001225                 mov     [ebp+var_69], 1
.text:00001229
.text:00001229 loc_1229:                               ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+1DEj
.text:00001229                                         ; DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+20Dj
.text:00001229                 mov     byte ptr [ebp+var_4], 7
.text:0000122D                 lea     ecx, [ebp+var_A4] ; this
.text:00001233                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00001238
.text:00001238 loc_1238:                               ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+19Bj
.text:00001238                                         ; DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+1A8j
.text:00001238                 mov     ecx, [ebp+arg_10] ; this
.text:0000123B                 call    ?AreAllAllowed@CCensorNode@NWildcard@@QBE_NXZ ; NWildcard::CCensorNode::AreAllAllowed(void)
.text:00001240                 mov     [ebp+var_A9], al
.text:00001246                 mov     eax, [ebp+arg_14]
.text:00001249                 movzx   ecx, byte ptr [eax+24h]
.text:0000124D                 test    ecx, ecx
.text:0000124F                 jnz     loc_1643
.text:00001255                 mov     esi, esp
.text:00001257                 lea     edx, [ebp+var_B4]
.text:0000125D                 push    edx
.text:0000125E                 mov     eax, [ebp+var_14]
.text:00001261                 mov     ecx, [eax]
.text:00001263                 mov     edx, [ebp+var_14]
.text:00001266                 push    edx
.text:00001267                 mov     eax, [ecx+14h]
.text:0000126A                 call    eax
.text:0000126C                 cmp     esi, esp
.text:0000126E                 call    __RTC_CheckEsp
.text:00001273                 mov     [ebp+var_BC], eax
.text:00001279                 cmp     [ebp+var_BC], 0
.text:00001280                 jz      short loc_12E7
.text:00001282                 mov     ecx, [ebp+var_BC]
.text:00001288                 mov     [ebp+var_15C], ecx
.text:0000128E                 mov     byte ptr [ebp+var_4], 6
.text:00001292                 lea     ecx, [ebp+var_90] ; this
.text:00001298                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000129D                 mov     byte ptr [ebp+var_4], 3
.text:000012A1                 lea     ecx, [ebp+var_7C] ; this
.text:000012A4                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000012A9                 mov     byte ptr [ebp+var_4], 2
.text:000012AD                 lea     ecx, [ebp+var_60] ; this
.text:000012B0                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000012B5                 mov     byte ptr [ebp+var_4], 1
.text:000012B9                 lea     ecx, [ebp+var_4C] ; this
.text:000012BC                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000012C1                 mov     byte ptr [ebp+var_4], 0
.text:000012C5                 lea     ecx, [ebp+var_38]
.text:000012C8                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:000012CD                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000012D4                 lea     ecx, [ebp+var_24]
.text:000012D7                 call    ??1?$CRecordVector@I@@QAE@XZ ; CRecordVector<uint>::~CRecordVector<uint>(void)
.text:000012DC                 mov     eax, [ebp+var_15C]
.text:000012E2                 jmp     loc_19C3
.text:000012E7 ; ---------------------------------------------------------------------------
.text:000012E7
.text:000012E7 loc_12E7:                               ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+27Cj
.text:000012E7                 lea     ecx, [ebp+var_100] ; this
.text:000012ED                 call    ??0CReadArcItem@@QAE@XZ ; CReadArcItem::CReadArcItem(void)
.text:000012F2                 mov     byte ptr [ebp+var_4], 9
.text:000012F6                 mov     [ebp+var_108], 0
.text:00001300                 jmp     short loc_1311
.text:00001302 ; ---------------------------------------------------------------------------
.text:00001302
.text:00001302 loc_1302:                               ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+4B1j
.text:00001302                                         ; DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+56Bj ...
.text:00001302                 mov     edx, [ebp+var_108]
.text:00001308                 add     edx, 1
.text:0000130B                 mov     [ebp+var_108], edx
.text:00001311
.text:00001311 loc_1311:                               ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+2FCj
.text:00001311                 mov     eax, [ebp+var_108]
.text:00001317                 cmp     eax, [ebp+var_B4]
.text:0000131D                 jnb     loc_1588
.text:00001323                 movzx   ecx, [ebp+var_69]
.text:00001327                 test    ecx, ecx
.text:00001329                 jnz     short loc_133A
.text:0000132B                 movzx   edx, [ebp+var_A9]
.text:00001332                 test    edx, edx
.text:00001334                 jnz     loc_13D8
.text:0000133A
.text:0000133A loc_133A:                               ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+325j
.text:0000133A                 lea     eax, [ebp+var_100]
.text:00001340                 push    eax             ; struct CReadArcItem *
.text:00001341                 mov     ecx, [ebp+var_108]
.text:00001347                 push    ecx             ; unsigned int
.text:00001348                 mov     ecx, [ebp+var_10] ; this
.text:0000134B                 call    ?GetItem@CArc@@QBEJIAAUCReadArcItem@@@Z ; CArc::GetItem(uint,CReadArcItem &)
.text:00001350                 mov     [ebp+var_10C], eax
.text:00001356                 cmp     [ebp+var_10C], 0
.text:0000135D                 jz      short loc_13D3
.text:0000135F                 mov     edx, [ebp+var_10C]
.text:00001365                 mov     [ebp+var_160], edx
.text:0000136B                 mov     byte ptr [ebp+var_4], 7
.text:0000136F                 lea     ecx, [ebp+var_100] ; this
.text:00001375                 call    ??1CReadArcItem@@QAE@XZ ; CReadArcItem::~CReadArcItem(void)
.text:0000137A                 mov     byte ptr [ebp+var_4], 6
.text:0000137E                 lea     ecx, [ebp+var_90] ; this
.text:00001384                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00001389                 mov     byte ptr [ebp+var_4], 3
.text:0000138D                 lea     ecx, [ebp+var_7C] ; this
.text:00001390                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00001395                 mov     byte ptr [ebp+var_4], 2
.text:00001399                 lea     ecx, [ebp+var_60] ; this
.text:0000139C                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000013A1                 mov     byte ptr [ebp+var_4], 1
.text:000013A5                 lea     ecx, [ebp+var_4C] ; this
.text:000013A8                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000013AD                 mov     byte ptr [ebp+var_4], 0
.text:000013B1                 lea     ecx, [ebp+var_38]
.text:000013B4                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:000013B9                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000013C0                 lea     ecx, [ebp+var_24]
.text:000013C3                 call    ??1?$CRecordVector@I@@QAE@XZ ; CRecordVector<uint>::~CRecordVector<uint>(void)
.text:000013C8                 mov     eax, [ebp+var_160]
.text:000013CE                 jmp     loc_19C3
.text:000013D3 ; ---------------------------------------------------------------------------
.text:000013D3
.text:000013D3 loc_13D3:                               ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+359j
.text:000013D3                 jmp     loc_149F
.text:000013D8 ; ---------------------------------------------------------------------------
.text:000013D8
.text:000013D8 loc_13D8:                               ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+330j
.text:000013D8                 mov     [ebp+var_D0], 0
.text:000013DF                 mov     eax, [ebp+arg_14]
.text:000013E2                 movzx   ecx, byte ptr [eax+1Eh]
.text:000013E6                 test    ecx, ecx
.text:000013E8                 jnz     loc_149F
.text:000013EE                 mov     edx, [ebp+var_10]
.text:000013F1                 movzx   eax, byte ptr [edx+0DCh]
.text:000013F8                 test    eax, eax
.text:000013FA                 jz      loc_149F
.text:00001400                 lea     ecx, [ebp+var_D0]
.text:00001406                 push    ecx             ; bool *
.text:00001407                 mov     edx, [ebp+var_108]
.text:0000140D                 push    edx             ; unsigned int
.text:0000140E                 mov     ecx, [ebp+var_10]
.text:00001411                 call    ??B?$CMyComPtr@UIInArchive@@@@QBEPAUIInArchive@@XZ ; CMyComPtr<IInArchive>::operator IInArchive *(void)
.text:00001416                 push    eax             ; struct IInArchive *
.text:00001417                 call    ?Archive_IsItem_AltStream@@YGJPAUIInArchive@@IAA_N@Z ; Archive_IsItem_AltStream(IInArchive *,uint,bool &)
.text:0000141C                 mov     [ebp+var_110], eax
.text:00001422                 cmp     [ebp+var_110], 0
.text:00001429                 jz      short loc_149F
.text:0000142B                 mov     eax, [ebp+var_110]
.text:00001431                 mov     [ebp+var_164], eax
.text:00001437                 mov     byte ptr [ebp+var_4], 7
.text:0000143B                 lea     ecx, [ebp+var_100] ; this
.text:00001441                 call    ??1CReadArcItem@@QAE@XZ ; CReadArcItem::~CReadArcItem(void)
.text:00001446                 mov     byte ptr [ebp+var_4], 6
.text:0000144A                 lea     ecx, [ebp+var_90] ; this
.text:00001450                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00001455                 mov     byte ptr [ebp+var_4], 3
.text:00001459                 lea     ecx, [ebp+var_7C] ; this
.text:0000145C                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00001461                 mov     byte ptr [ebp+var_4], 2
.text:00001465                 lea     ecx, [ebp+var_60] ; this
.text:00001468                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000146D                 mov     byte ptr [ebp+var_4], 1
.text:00001471                 lea     ecx, [ebp+var_4C] ; this
.text:00001474                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00001479                 mov     byte ptr [ebp+var_4], 0
.text:0000147D                 lea     ecx, [ebp+var_38]
.text:00001480                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:00001485                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000148C                 lea     ecx, [ebp+var_24]
.text:0000148F                 call    ??1?$CRecordVector@I@@QAE@XZ ; CRecordVector<uint>::~CRecordVector<uint>(void)
.text:00001494                 mov     eax, [ebp+var_164]
.text:0000149A                 jmp     loc_19C3
.text:0000149F ; ---------------------------------------------------------------------------
.text:0000149F
.text:0000149F loc_149F:                               ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &):loc_13D3j
.text:0000149F                                         ; DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+3E4j ...
.text:0000149F                 mov     ecx, [ebp+arg_14]
.text:000014A2                 movzx   edx, byte ptr [ecx+1Eh]
.text:000014A6                 test    edx, edx
.text:000014A8                 jnz     short loc_14BA
.text:000014AA                 movzx   eax, [ebp+var_D0]
.text:000014B1                 test    eax, eax
.text:000014B3                 jz      short loc_14BA
.text:000014B5                 jmp     loc_1302
.text:000014BA ; ---------------------------------------------------------------------------
.text:000014BA
.text:000014BA loc_14BA:                               ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+4A4j
.text:000014BA                                         ; DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+4AFj
.text:000014BA                 movzx   ecx, [ebp+var_69]
.text:000014BE                 test    ecx, ecx
.text:000014C0                 jz      loc_154D
.text:000014C6                 lea     edx, [ebp+var_E8]
.text:000014CC                 mov     [ebp+var_114], edx
.text:000014D2                 lea     ecx, [ebp+var_7C]
.text:000014D5                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000014DA                 push    eax             ; wchar_t *
.text:000014DB                 mov     ecx, [ebp+var_114]
.text:000014E1                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000014E6                 push    eax             ; wchar_t *
.text:000014E7                 call    ?IsPath1PrefixedByPath2@@YG_NPB_W0@Z ; IsPath1PrefixedByPath2(wchar_t const *,wchar_t const *)
.text:000014EC                 movzx   eax, al
.text:000014EF                 test    eax, eax
.text:000014F1                 jnz     short loc_14F9
.text:000014F3                 mov     [ebp+var_69], 0
.text:000014F7                 jmp     short loc_154D
.text:000014F9 ; ---------------------------------------------------------------------------
.text:000014F9
.text:000014F9 loc_14F9:                               ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+4EDj
.text:000014F9                 mov     ecx, [ebp+var_114]
.text:000014FF                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00001504                 mov     esi, eax
.text:00001506                 lea     ecx, [ebp+var_7C] ; this
.text:00001509                 call    ?Len@UString@@QBEIXZ ; UString::Len(void)
.text:0000150E                 mov     cx, [esi+eax*2]
.text:00001512                 mov     [ebp+var_118], cx
.text:00001519                 movzx   edx, [ebp+var_118]
.text:00001520                 test    edx, edx
.text:00001522                 jnz     short loc_1535
.text:00001524                 movzx   eax, [ebp+var_CD]
.text:0000152B                 test    eax, eax
.text:0000152D                 jnz     short loc_1533
.text:0000152F                 mov     [ebp+var_69], 0
.text:00001533
.text:00001533 loc_1533:                               ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+529j
.text:00001533                 jmp     short loc_154D
.text:00001535 ; ---------------------------------------------------------------------------
.text:00001535
.text:00001535 loc_1535:                               ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+51Ej
.text:00001535                 movzx   ecx, [ebp+var_118]
.text:0000153C                 push    ecx             ; wchar_t
.text:0000153D                 call    ?IsPathSepar@@YG_N_W@Z ; IsPathSepar(wchar_t)
.text:00001542                 movzx   edx, al
.text:00001545                 test    edx, edx
.text:00001547                 jnz     short loc_154D
.text:00001549                 mov     [ebp+var_69], 0
.text:0000154D
.text:0000154D loc_154D:                               ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+4BCj
.text:0000154D                                         ; DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+4F3j ...
.text:0000154D                 movzx   eax, [ebp+var_A9]
.text:00001554                 test    eax, eax
.text:00001556                 jnz     short loc_1574
.text:00001558                 lea     ecx, [ebp+var_100]
.text:0000155E                 push    ecx             ; struct CReadArcItem *
.text:0000155F                 mov     edx, [ebp+arg_10]
.text:00001562                 push    edx             ; struct NWildcard::CCensorNode *
.text:00001563                 call    ?CensorNode_CheckPath@@YG_NABVCCensorNode@NWildcard@@ABUCReadArcItem@@@Z ; CensorNode_CheckPath(NWildcard::CCensorNode const &,CReadArcItem const &)
.text:00001568                 movzx   eax, al
.text:0000156B                 test    eax, eax
.text:0000156D                 jnz     short loc_1574
.text:0000156F                 jmp     loc_1302
.text:00001574 ; ---------------------------------------------------------------------------
.text:00001574
.text:00001574 loc_1574:                               ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+552j
.text:00001574                                         ; DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+569j
.text:00001574                 mov     ecx, [ebp+var_108]
.text:0000157A                 push    ecx
.text:0000157B                 lea     ecx, [ebp+var_24]
.text:0000157E                 call    ?Add@?$CRecordVector@I@@QAEII@Z ; CRecordVector<uint>::Add(uint)
.text:00001583                 jmp     loc_1302
.text:00001588 ; ---------------------------------------------------------------------------
.text:00001588
.text:00001588 loc_1588:                               ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+319j
.text:00001588                 lea     ecx, [ebp+var_24]
.text:0000158B                 call    ?Size@?$CRecordVector@I@@QBEIXZ ; CRecordVector<uint>::Size(void)
.text:00001590                 test    eax, eax
.text:00001592                 jnz     loc_1634
.text:00001598                 mov     edx, [ebp+arg_1C]
.text:0000159B                 mov     eax, [edx]
.text:0000159D                 mov     esi, esp
.text:0000159F                 mov     ecx, [ebp+arg_1C]
.text:000015A2                 mov     edx, [eax+2Ch]
.text:000015A5                 call    edx
.text:000015A7                 cmp     esi, esp
.text:000015A9                 call    __RTC_CheckEsp
.text:000015AE                 mov     esi, esp
.text:000015B0                 push    0
.text:000015B2                 mov     eax, [ebp+arg_1C]
.text:000015B5                 mov     edx, [eax]
.text:000015B7                 mov     ecx, [ebp+arg_1C]
.text:000015BA                 mov     eax, [edx+30h]
.text:000015BD                 call    eax
.text:000015BF                 cmp     esi, esp
.text:000015C1                 call    __RTC_CheckEsp
.text:000015C6                 mov     [ebp+var_168], eax
.text:000015CC                 mov     byte ptr [ebp+var_4], 7
.text:000015D0                 lea     ecx, [ebp+var_100] ; this
.text:000015D6                 call    ??1CReadArcItem@@QAE@XZ ; CReadArcItem::~CReadArcItem(void)
.text:000015DB                 mov     byte ptr [ebp+var_4], 6
.text:000015DF                 lea     ecx, [ebp+var_90] ; this
.text:000015E5                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000015EA                 mov     byte ptr [ebp+var_4], 3
.text:000015EE                 lea     ecx, [ebp+var_7C] ; this
.text:000015F1                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000015F6                 mov     byte ptr [ebp+var_4], 2
.text:000015FA                 lea     ecx, [ebp+var_60] ; this
.text:000015FD                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00001602                 mov     byte ptr [ebp+var_4], 1
.text:00001606                 lea     ecx, [ebp+var_4C] ; this
.text:00001609                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000160E                 mov     byte ptr [ebp+var_4], 0
.text:00001612                 lea     ecx, [ebp+var_38]
.text:00001615                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:0000161A                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001621                 lea     ecx, [ebp+var_24]
.text:00001624                 call    ??1?$CRecordVector@I@@QAE@XZ ; CRecordVector<uint>::~CRecordVector<uint>(void)
.text:00001629                 mov     eax, [ebp+var_168]
.text:0000162F                 jmp     loc_19C3
.text:00001634 ; ---------------------------------------------------------------------------
.text:00001634
.text:00001634 loc_1634:                               ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+58Ej
.text:00001634                 mov     byte ptr [ebp+var_4], 7
.text:00001638                 lea     ecx, [ebp+var_100] ; this
.text:0000163E                 call    ??1CReadArcItem@@QAE@XZ ; CReadArcItem::~CReadArcItem(void)
.text:00001643
.text:00001643 loc_1643:                               ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+24Bj
.text:00001643                 movzx   ecx, [ebp+var_69]
.text:00001647                 test    ecx, ecx
.text:00001649                 jz      short loc_1657
.text:0000164B                 lea     edx, [ebp+var_7C]
.text:0000164E                 push    edx
.text:0000164F                 lea     ecx, [ebp+var_38]
.text:00001652                 call    ?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z ; CObjectVector<UString>::Add(UString const &)
.text:00001657
.text:00001657 loc_1657:                               ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+645j
.text:00001657                 lea     ecx, [ebp+var_4C] ; this
.text:0000165A                 call    ?IsEmpty@UString@@QBE_NXZ ; UString::IsEmpty(void)
.text:0000165F                 movzx   eax, al
.text:00001662                 test    eax, eax
.text:00001664                 jz      short loc_1678
.text:00001666                 push    offset $SG73863 ; ".\\"
.text:0000166B                 lea     ecx, [ebp+var_4C]
.text:0000166E                 call    ??4UString@@QAEAAV0@PB_W@Z ; UString::operator=(wchar_t const *)
.text:00001673                 jmp     loc_1737
.text:00001678 ; ---------------------------------------------------------------------------
.text:00001678
.text:00001678 loc_1678:                               ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+660j
.text:00001678                 lea     ecx, [ebp+var_4C]
.text:0000167B                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:00001680                 push    eax             ; this
.text:00001681                 call    ?CreateComplexDir@NDir@NFile@NWindows@@YG_NPB_W@Z ; NWindows::NFile::NDir::CreateComplexDir(wchar_t const *)
.text:00001686                 movzx   ecx, al
.text:00001689                 test    ecx, ecx
.text:0000168B                 jnz     loc_1737
.text:00001691                 mov     esi, esp
.text:00001693                 call    dword ptr ds:__imp__GetLastError@0 ; GetLastError()
.text:00001699                 cmp     esi, esp
.text:0000169B                 call    __RTC_CheckEsp
.text:000016A0                 mov     [ebp+var_11C], eax
.text:000016A6                 cmp     [ebp+var_11C], 0
.text:000016AD                 jnz     short loc_16B9
.text:000016AF                 mov     [ebp+var_11C], 80004005h
.text:000016B9
.text:000016B9 loc_16B9:                               ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+6A9j
.text:000016B9                 push    offset $SG73870 ; "Can not create output directory: "
.text:000016BE                 mov     ecx, [ebp+arg_24] ; this
.text:000016C1                 call    ?SetFromAscii@UString@@QAEXPBD@Z ; UString::SetFromAscii(char const *)
.text:000016C6                 lea     edx, [ebp+var_4C]
.text:000016C9                 push    edx
.text:000016CA                 mov     ecx, [ebp+arg_24]
.text:000016CD                 call    ??YUString@@QAEAAV0@ABV0@@Z ; UString::operator+=(UString const &)
.text:000016D2                 mov     eax, [ebp+var_11C]
.text:000016D8                 mov     [ebp+var_16C], eax
.text:000016DE                 mov     byte ptr [ebp+var_4], 6
.text:000016E2                 lea     ecx, [ebp+var_90] ; this
.text:000016E8                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000016ED                 mov     byte ptr [ebp+var_4], 3
.text:000016F1                 lea     ecx, [ebp+var_7C] ; this
.text:000016F4                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000016F9                 mov     byte ptr [ebp+var_4], 2
.text:000016FD                 lea     ecx, [ebp+var_60] ; this
.text:00001700                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00001705                 mov     byte ptr [ebp+var_4], 1
.text:00001709                 lea     ecx, [ebp+var_4C] ; this
.text:0000170C                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00001711                 mov     byte ptr [ebp+var_4], 0
.text:00001715                 lea     ecx, [ebp+var_38]
.text:00001718                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:0000171D                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001724                 lea     ecx, [ebp+var_24]
.text:00001727                 call    ??1?$CRecordVector@I@@QAE@XZ ; CRecordVector<uint>::~CRecordVector<uint>(void)
.text:0000172C                 mov     eax, [ebp+var_16C]
.text:00001732                 jmp     loc_19C3
.text:00001737 ; ---------------------------------------------------------------------------
.text:00001737
.text:00001737 loc_1737:                               ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+66Fj
.text:00001737                                         ; DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+687j
.text:00001737                 mov     ecx, [ebp+arg_C]
.text:0000173A                 push    ecx
.text:0000173B                 mov     edx, [ebp+arg_8]
.text:0000173E                 push    edx
.text:0000173F                 push    0
.text:00001741                 lea     eax, [ebp+var_38]
.text:00001744                 push    eax
.text:00001745                 lea     ecx, [ebp+var_4C]
.text:00001748                 push    ecx
.text:00001749                 mov     edx, [ebp+arg_14]
.text:0000174C                 movzx   eax, byte ptr [edx+27h]
.text:00001750                 push    eax
.text:00001751                 mov     ecx, [ebp+arg_14]
.text:00001754                 movzx   edx, byte ptr [ecx+25h]
.text:00001758                 push    edx
.text:00001759                 mov     eax, [ebp+arg_1C]
.text:0000175C                 push    eax
.text:0000175D                 mov     ecx, [ebp+var_10]
.text:00001760                 push    ecx
.text:00001761                 mov     edx, [ebp+arg_14]
.text:00001764                 movzx   eax, byte ptr [edx+24h]
.text:00001768                 neg     eax
.text:0000176A                 sbb     eax, eax
.text:0000176C                 and     eax, [ebp+arg_10]
.text:0000176F                 push    eax
.text:00001770                 mov     ecx, [ebp+arg_14]
.text:00001773                 add     ecx, 18h
.text:00001776                 push    ecx
.text:00001777                 mov     ecx, [ebp+arg_20]
.text:0000177A                 call    ?Init@CArchiveExtractCallback@@QAEXABUCExtractNtOptions@@PBVCCensorNode@NWildcard@@PBVCArc@@PAUIFolderArchiveExtractCallback@@_N4ABVUString@@ABV?$CObjectVector@VUString@@@@4_K@Z ; CArchiveExtractCallback::Init(CExtractNtOptions const &,NWildcard::CCensorNode const *,CArc const *,IFolderArchiveExtractCallback *,bool,bool,UString const &,CObjectVector<UString> const &,bool,unsigned __int64)
.text:0000177F                 mov     edx, [ebp+arg_14]
.text:00001782                 movzx   eax, byte ptr [edx+24h]
.text:00001786                 test    eax, eax
.text:00001788                 jnz     loc_182C
.text:0000178E                 mov     ecx, [ebp+arg_14]
.text:00001791                 movzx   edx, byte ptr [ecx+27h]
.text:00001795                 test    edx, edx
.text:00001797                 jnz     loc_182C
.text:0000179D                 mov     eax, [ebp+arg_14]
.text:000017A0                 movzx   ecx, byte ptr [eax+1Ch]
.text:000017A4                 test    ecx, ecx
.text:000017A6                 jz      loc_182C
.text:000017AC                 lea     edx, [ebp+var_24]
.text:000017AF                 push    edx
.text:000017B0                 mov     ecx, [ebp+arg_20]
.text:000017B3                 call    ?PrepareHardLinks@CArchiveExtractCallback@@QAEJPBV?$CRecordVector@I@@@Z ; CArchiveExtractCallback::PrepareHardLinks(CRecordVector<uint> const *)
.text:000017B8                 mov     [ebp+var_120], eax
.text:000017BE                 cmp     [ebp+var_120], 0
.text:000017C5                 jz      short loc_182C
.text:000017C7                 mov     eax, [ebp+var_120]
.text:000017CD                 mov     [ebp+var_170], eax
.text:000017D3                 mov     byte ptr [ebp+var_4], 6
.text:000017D7                 lea     ecx, [ebp+var_90] ; this
.text:000017DD                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000017E2                 mov     byte ptr [ebp+var_4], 3
.text:000017E6                 lea     ecx, [ebp+var_7C] ; this
.text:000017E9                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000017EE                 mov     byte ptr [ebp+var_4], 2
.text:000017F2                 lea     ecx, [ebp+var_60] ; this
.text:000017F5                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000017FA                 mov     byte ptr [ebp+var_4], 1
.text:000017FE                 lea     ecx, [ebp+var_4C] ; this
.text:00001801                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00001806                 mov     byte ptr [ebp+var_4], 0
.text:0000180A                 lea     ecx, [ebp+var_38]
.text:0000180D                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:00001812                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00001819                 lea     ecx, [ebp+var_24]
.text:0000181C                 call    ??1?$CRecordVector@I@@QAE@XZ ; CRecordVector<uint>::~CRecordVector<uint>(void)
.text:00001821                 mov     eax, [ebp+var_170]
.text:00001827                 jmp     loc_19C3
.text:0000182C ; ---------------------------------------------------------------------------
.text:0000182C
.text:0000182C loc_182C:                               ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+784j
.text:0000182C                                         ; DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+793j ...
.text:0000182C                 mov     ecx, [ebp+arg_14]
.text:0000182F                 movzx   edx, byte ptr [ecx+27h]
.text:00001833                 test    edx, edx
.text:00001835                 jz      short loc_184B
.text:00001837                 movzx   eax, [ebp+arg_18]
.text:0000183B                 test    eax, eax
.text:0000183D                 jnz     short loc_184B
.text:0000183F                 mov     [ebp+var_180], 1
.text:00001849                 jmp     short loc_1855
.text:0000184B ; ---------------------------------------------------------------------------
.text:0000184B
.text:0000184B loc_184B:                               ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+831j
.text:0000184B                                         ; DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+839j
.text:0000184B                 mov     [ebp+var_180], 0
.text:00001855
.text:00001855 loc_1855:                               ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+845j
.text:00001855                 mov     ecx, [ebp+var_180]
.text:0000185B                 mov     [ebp+var_128], ecx
.text:00001861                 mov     edx, [ebp+arg_14]
.text:00001864                 movzx   eax, byte ptr [edx+24h]
.text:00001868                 test    eax, eax
.text:0000186A                 jz      loc_18F0
.text:00001870                 mov     esi, esp
.text:00001872                 mov     ecx, [ebp+arg_20]
.text:00001875                 push    ecx
.text:00001876                 mov     edx, [ebp+var_128]
.text:0000187C                 push    edx
.text:0000187D                 push    0FFFFFFFFh
.text:0000187F                 push    0
.text:00001881                 mov     eax, [ebp+var_14]
.text:00001884                 mov     ecx, [eax]
.text:00001886                 mov     edx, [ebp+var_14]
.text:00001889                 push    edx
.text:0000188A                 mov     eax, [ecx+1Ch]
.text:0000188D                 call    eax
.text:0000188F                 cmp     esi, esp
.text:00001891                 call    __RTC_CheckEsp
.text:00001896                 mov     [ebp+var_124], eax
.text:0000189C                 lea     ecx, [ebp+var_13C] ; this
.text:000018A2                 call    ??0CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::CPropVariant(void)
.text:000018A7                 mov     byte ptr [ebp+var_4], 0Ah
.text:000018AB                 mov     esi, esp
.text:000018AD                 lea     ecx, [ebp+var_13C]
.text:000018B3                 push    ecx
.text:000018B4                 push    2Ch ; ','
.text:000018B6                 mov     edx, [ebp+var_14]
.text:000018B9                 mov     eax, [edx]
.text:000018BB                 mov     ecx, [ebp+var_14]
.text:000018BE                 push    ecx
.text:000018BF                 mov     edx, [eax+20h]
.text:000018C2                 call    edx
.text:000018C4                 cmp     esi, esp
.text:000018C6                 call    __RTC_CheckEsp
.text:000018CB                 test    eax, eax
.text:000018CD                 jnz     short loc_18DF
.text:000018CF                 mov     eax, [ebp+arg_28]
.text:000018D2                 push    eax             ; unsigned __int64 *
.text:000018D3                 lea     ecx, [ebp+var_13C]
.text:000018D9                 push    ecx             ; struct tagPROPVARIANT *
.text:000018DA                 call    ?ConvertPropVariantToUInt64@@YG_NABUtagPROPVARIANT@@AA_K@Z ; ConvertPropVariantToUInt64(tagPROPVARIANT const &,unsigned __int64 &)
.text:000018DF
.text:000018DF loc_18DF:                               ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+8C9j
.text:000018DF                 mov     byte ptr [ebp+var_4], 7
.text:000018E3                 lea     ecx, [ebp+var_13C] ; this
.text:000018E9                 call    ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text:000018EE                 jmp     short loc_192A
.text:000018F0 ; ---------------------------------------------------------------------------
.text:000018F0
.text:000018F0 loc_18F0:                               ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+866j
.text:000018F0                 mov     esi, esp
.text:000018F2                 mov     edx, [ebp+arg_20]
.text:000018F5                 push    edx
.text:000018F6                 mov     eax, [ebp+var_128]
.text:000018FC                 push    eax
.text:000018FD                 lea     ecx, [ebp+var_24]
.text:00001900                 call    ?Size@?$CRecordVector@I@@QBEIXZ ; CRecordVector<uint>::Size(void)
.text:00001905                 push    eax
.text:00001906                 lea     ecx, [ebp+var_24]
.text:00001909                 call    ?Front@?$CRecordVector@I@@QAEAAIXZ ; CRecordVector<uint>::Front(void)
.text:0000190E                 push    eax
.text:0000190F                 mov     ecx, [ebp+var_14]
.text:00001912                 mov     edx, [ecx]
.text:00001914                 mov     eax, [ebp+var_14]
.text:00001917                 push    eax
.text:00001918                 mov     ecx, [edx+1Ch]
.text:0000191B                 call    ecx
.text:0000191D                 cmp     esi, esp
.text:0000191F                 call    __RTC_CheckEsp
.text:00001924                 mov     [ebp+var_124], eax
.text:0000192A
.text:0000192A loc_192A:                               ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+8EAj
.text:0000192A                 cmp     [ebp+var_124], 0
.text:00001931                 jnz     short loc_194C
.text:00001933                 mov     edx, [ebp+arg_14]
.text:00001936                 movzx   eax, byte ptr [edx+24h]
.text:0000193A                 test    eax, eax
.text:0000193C                 jnz     short loc_194C
.text:0000193E                 mov     ecx, [ebp+arg_20] ; this
.text:00001941                 call    ?SetDirsTimes@CArchiveExtractCallback@@QAEJXZ ; CArchiveExtractCallback::SetDirsTimes(void)
.text:00001946                 mov     [ebp+var_124], eax
.text:0000194C
.text:0000194C loc_194C:                               ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+92Dj
.text:0000194C                                         ; DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+938j
.text:0000194C                 mov     esi, esp
.text:0000194E                 mov     ecx, [ebp+var_124]
.text:00001954                 push    ecx
.text:00001955                 mov     edx, [ebp+arg_1C]
.text:00001958                 mov     eax, [edx]
.text:0000195A                 mov     ecx, [ebp+arg_1C]
.text:0000195D                 mov     edx, [eax+30h]
.text:00001960                 call    edx
.text:00001962                 cmp     esi, esp
.text:00001964                 call    __RTC_CheckEsp
.text:00001969                 mov     [ebp+var_174], eax
.text:0000196F                 mov     byte ptr [ebp+var_4], 6
.text:00001973                 lea     ecx, [ebp+var_90] ; this
.text:00001979                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000197E                 mov     byte ptr [ebp+var_4], 3
.text:00001982                 lea     ecx, [ebp+var_7C] ; this
.text:00001985                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:0000198A                 mov     byte ptr [ebp+var_4], 2
.text:0000198E                 lea     ecx, [ebp+var_60] ; this
.text:00001991                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00001996                 mov     byte ptr [ebp+var_4], 1
.text:0000199A                 lea     ecx, [ebp+var_4C] ; this
.text:0000199D                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000019A2                 mov     byte ptr [ebp+var_4], 0
.text:000019A6                 lea     ecx, [ebp+var_38]
.text:000019A9                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:000019AE                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000019B5                 lea     ecx, [ebp+var_24]
.text:000019B8                 call    ??1?$CRecordVector@I@@QAE@XZ ; CRecordVector<uint>::~CRecordVector<uint>(void)
.text:000019BD                 mov     eax, [ebp+var_174]
.text:000019C3
.text:000019C3 loc_19C3:                               ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+2DEj
.text:000019C3                                         ; DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+3CAj ...
.text:000019C3                 push    edx
.text:000019C4                 mov     ecx, ebp
.text:000019C6                 push    eax
.text:000019C7                 lea     edx, $LN67_0
.text:000019CD                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:000019D2                 pop     eax
.text:000019D3                 pop     edx
.text:000019D4                 mov     ecx, [ebp+var_C]
.text:000019D7                 mov     large fs:0, ecx
.text:000019DE                 pop     ecx
.text:000019DF                 pop     edi
.text:000019E0                 pop     esi
.text:000019E1                 add     esp, 180h
.text:000019E7                 cmp     ebp, esp
.text:000019E9                 call    __RTC_CheckEsp
.text:000019EE                 mov     esp, ebp
.text:000019F0                 pop     ebp
.text:000019F1                 retn    2Ch
.text:000019F1 ?DecompressArchive@@YGJPAVCCodecs@@ABUCArchiveLink@@_KABVCCensorNode@NWildcard@@ABUCExtractOptions@@_NPAUIExtractCallbackUI@@PAVCArchiveExtractCallback@@AAVUString@@AA_K@Z endp
.text:000019F1
.text:000019F1 ; ---------------------------------------------------------------------------
.text:000019F4 $LN67_0         dd 0Ah                  ; DATA XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+9C3o
.text:000019F8                 dd offset $LN66_0
.text:000019FC $LN66_0         dd 0FFFFFFDCh, 0Ch      ; DATA XREF: .text:000019F8o
.text:00001A04                 dd offset $LN55         ; "realIndices"
.text:00001A08                 dd 0FFFFFFC8h, 0Ch
.text:00001A10                 dd offset $LN56         ; "removePathParts"
.text:00001A14                 dd 0FFFFFFB4h, 0Ch
.text:00001A1C                 dd offset $LN57         ; "outDir"
.text:00001A20                 dd 0FFFFFFA0h, 0Ch
.text:00001A28                 dd offset $LN58         ; "replaceName"
.text:00001A2C                 dd 0FFFFFF84h, 0Ch
.text:00001A34                 dd offset $LN59         ; "elimPrefix"
.text:00001A38                 dd 0FFFFFF70h, 0Ch
.text:00001A40                 dd offset $LN60         ; "outDirReduced"
.text:00001A44                 dd 0FFFFFF5Ch, 0Ch
.text:00001A4C                 dd offset $LN61         ; "dirPrefix"
.text:00001A50                 dd 0FFFFFF4Ch, 4
.text:00001A58                 dd offset $LN62         ; "numItems"
.text:00001A5C                 dd 0FFFFFF00h, 40h
.text:00001A64                 dd offset $LN63         ; "item"
.text:00001A68                 dd 0FFFFFEC4h, 10h
.text:00001A70                 dd offset $LN64_0       ; "prop"
.text:00001A74 $LN64_0         db 'prop',0             ; DATA XREF: .text:00001A70o
.text:00001A79 $LN63           db 'item',0             ; DATA XREF: .text:00001A64o
.text:00001A7E $LN62           db 'numItems',0         ; DATA XREF: .text:00001A58o
.text:00001A87 $LN61           db 'dirPrefix',0        ; DATA XREF: .text:00001A4Co
.text:00001A91 $LN60           db 'outDirReduced',0    ; DATA XREF: .text:00001A40o
.text:00001A9F $LN59           db 'elimPrefix',0       ; DATA XREF: .text:00001A34o
.text:00001AAA $LN58           db 'replaceName',0      ; DATA XREF: .text:00001A28o
.text:00001AB6 $LN57           db 'outDir',0           ; DATA XREF: .text:00001A1Co
.text:00001ABD $LN56           db 'removePathParts',0  ; DATA XREF: .text:00001A10o
.text:00001ACD $LN55           db 'realIndices',0      ; DATA XREF: .text:00001A04o
.text:00001AD9                 align 4
.text:00001AD9 _text           ends
.text:00001AD9
.rtc$TMZ:00001ADC ; ===========================================================================
.rtc$TMZ:00001ADC
.rtc$TMZ:00001ADC ; Segment type: Pure data
.rtc$TMZ:00001ADC ; Segment permissions: Read
.rtc$TMZ:00001ADC _rtc$TMZ        segment dword public 'DATA' use32
.rtc$TMZ:00001ADC                 assume cs:_rtc$TMZ
.rtc$TMZ:00001ADC                 ;org 1ADCh
.rtc$TMZ:00001ADC ; COMDAT (pick any)
.rtc$TMZ:00001ADC __RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
.rtc$TMZ:00001ADC _rtc$TMZ        ends
.rtc$TMZ:00001ADC
.rtc$IMZ:00001AE0 ; ===========================================================================
.rtc$IMZ:00001AE0
.rtc$IMZ:00001AE0 ; Segment type: Pure data
.rtc$IMZ:00001AE0 ; Segment permissions: Read
.rtc$IMZ:00001AE0 _rtc$IMZ        segment dword public 'DATA' use32
.rtc$IMZ:00001AE0                 assume cs:_rtc$IMZ
.rtc$IMZ:00001AE0                 ;org 1AE0h
.rtc$IMZ:00001AE0 ; COMDAT (pick any)
.rtc$IMZ:00001AE0 __RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
.rtc$IMZ:00001AE0 _rtc$IMZ        ends
.rtc$IMZ:00001AE0
.text:00001AE4 ; ===========================================================================
.text:00001AE4
.text:00001AE4 ; Segment type: Pure code
.text:00001AE4 ; Segment permissions: Read/Execute
.text:00001AE4 _text           segment para public 'CODE' use32
.text:00001AE4                 assume cs:_text
.text:00001AE4                 ;org 1AE4h
.text:00001AE4 ; COMDAT (pick any)
.text:00001AE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001AE4
.text:00001AE4 ; =============== S U B R O U T I N E =======================================
.text:00001AE4
.text:00001AE4 ; Attributes: bp-based frame
.text:00001AE4
.text:00001AE4 ; public: __thiscall UString::operator wchar_t const *(void)const
.text:00001AE4                 public ??BUString@@QBEPB_WXZ
.text:00001AE4 ??BUString@@QBEPB_WXZ proc near         ; CODE XREF: Find_FileName_InSortedVector(CObjectVector<UString> const &,UString const &)+51p
.text:00001AE4                                         ; Find_FileName_InSortedVector(CObjectVector<UString> const &,UString const &)+5Ap ...
.text:00001AE4
.text:00001AE4 var_4           = dword ptr -4
.text:00001AE4
.text:00001AE4                 push    ebp
.text:00001AE5                 mov     ebp, esp
.text:00001AE7                 push    ecx
.text:00001AE8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001AEF                 mov     [ebp+var_4], ecx
.text:00001AF2                 mov     eax, [ebp+var_4]
.text:00001AF5                 mov     eax, [eax]
.text:00001AF7                 mov     esp, ebp
.text:00001AF9                 pop     ebp
.text:00001AFA                 retn
.text:00001AFA ??BUString@@QBEPB_WXZ endp
.text:00001AFA
.text:00001AFA ; ---------------------------------------------------------------------------
.text:00001AFB                 align 4
.text:00001AFB _text           ends
.text:00001AFB
.text$x:00001AFC ; ===========================================================================
.text$x:00001AFC
.text$x:00001AFC ; Segment type: Pure code
.text$x:00001AFC ; Segment permissions: Read/Execute
.text$x:00001AFC _text$x         segment para public 'CODE' use32
.text$x:00001AFC                 assume cs:_text$x
.text$x:00001AFC                 ;org 1AFCh
.text$x:00001AFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001AFC
.text$x:00001AFC ; =============== S U B R O U T I N E =======================================
.text$x:00001AFC
.text$x:00001AFC
.text$x:00001AFC __unwindfunclet$?Extract@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABV?$CRecordVector@H@@AAV?$CObjectVector@VUString@@@@3ABVCCensorNode@NWildcard@@ABUCExtractOptions@@PAUIOpenCallbackUI@@PAUIExtractCallbackUI@@PAUIHashCalc@@AAVUString@@AAUCDecompressStat@@@Z$0 proc near
.text$x:00001AFC                                         ; DATA XREF: .xdata$x:00001C44o
.text$x:00001AFC                 lea     ecx, [ebp-24h]
.text$x:00001AFF                 jmp     ??1?$CRecordVector@_K@@QAE@XZ ; CRecordVector<unsigned __int64>::~CRecordVector<unsigned __int64>(void)
.text$x:00001AFF __unwindfunclet$?Extract@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABV?$CRecordVector@H@@AAV?$CObjectVector@VUString@@@@3ABVCCensorNode@NWildcard@@ABUCExtractOptions@@PAUIOpenCallbackUI@@PAUIExtractCallbackUI@@PAUIHashCalc@@AAVUString@@AAUCDecompressStat@@@Z$0 endp
.text$x:00001AFF
.text$x:00001B04
.text$x:00001B04 ; =============== S U B R O U T I N E =======================================
.text$x:00001B04
.text$x:00001B04
.text$x:00001B04 __unwindfunclet$?Extract@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABV?$CRecordVector@H@@AAV?$CObjectVector@VUString@@@@3ABVCCensorNode@NWildcard@@ABUCExtractOptions@@PAUIOpenCallbackUI@@PAUIExtractCallbackUI@@PAUIHashCalc@@AAVUString@@AAUCDecompressStat@@@Z$1 proc near
.text$x:00001B04                                         ; DATA XREF: .xdata$x:00001C4Co
.text$x:00001B04                 lea     ecx, [ebp-6Ch]  ; this
.text$x:00001B07                 jmp     ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text$x:00001B07 __unwindfunclet$?Extract@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABV?$CRecordVector@H@@AAV?$CObjectVector@VUString@@@@3ABVCCensorNode@NWildcard@@ABUCExtractOptions@@PAUIOpenCallbackUI@@PAUIExtractCallbackUI@@PAUIHashCalc@@AAVUString@@AAUCDecompressStat@@@Z$1 endp
.text$x:00001B07
.text$x:00001B0C
.text$x:00001B0C ; =============== S U B R O U T I N E =======================================
.text$x:00001B0C
.text$x:00001B0C
.text$x:00001B0C __unwindfunclet$?Extract@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABV?$CRecordVector@H@@AAV?$CObjectVector@VUString@@@@3ABVCCensorNode@NWildcard@@ABUCExtractOptions@@PAUIOpenCallbackUI@@PAUIExtractCallbackUI@@PAUIHashCalc@@AAVUString@@AAUCDecompressStat@@@Z$2 proc near
.text$x:00001B0C                                         ; DATA XREF: .xdata$x:00001C54o
.text$x:00001B0C                 lea     ecx, [ebp-7Ch]
.text$x:00001B0F                 jmp     ??1?$CObjArray@_N@@QAE@XZ ; CObjArray<bool>::~CObjArray<bool>(void)
.text$x:00001B0F __unwindfunclet$?Extract@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABV?$CRecordVector@H@@AAV?$CObjectVector@VUString@@@@3ABVCCensorNode@NWildcard@@ABUCExtractOptions@@PAUIOpenCallbackUI@@PAUIExtractCallbackUI@@PAUIHashCalc@@AAVUString@@AAUCDecompressStat@@@Z$2 endp
.text$x:00001B0F
.text$x:00001B14
.text$x:00001B14 ; =============== S U B R O U T I N E =======================================
.text$x:00001B14
.text$x:00001B14
.text$x:00001B14 __unwindfunclet$?Extract@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABV?$CRecordVector@H@@AAV?$CObjectVector@VUString@@@@3ABVCCensorNode@NWildcard@@ABUCExtractOptions@@PAUIOpenCallbackUI@@PAUIExtractCallbackUI@@PAUIHashCalc@@AAVUString@@AAUCDecompressStat@@@Z$3 proc near
.text$x:00001B14                                         ; DATA XREF: .xdata$x:00001C5Co
.text$x:00001B14                 mov     eax, [ebp-268h]
.text$x:00001B1A                 push    eax             ; void *
.text$x:00001B1B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00001B20                 pop     ecx
.text$x:00001B21                 retn
.text$x:00001B21 __unwindfunclet$?Extract@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABV?$CRecordVector@H@@AAV?$CObjectVector@VUString@@@@3ABVCCensorNode@NWildcard@@ABUCExtractOptions@@PAUIOpenCallbackUI@@PAUIExtractCallbackUI@@PAUIHashCalc@@AAVUString@@AAUCDecompressStat@@@Z$3 endp
.text$x:00001B21
.text$x:00001B22
.text$x:00001B22 ; =============== S U B R O U T I N E =======================================
.text$x:00001B22
.text$x:00001B22
.text$x:00001B22 __unwindfunclet$?Extract@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABV?$CRecordVector@H@@AAV?$CObjectVector@VUString@@@@3ABVCCensorNode@NWildcard@@ABUCExtractOptions@@PAUIOpenCallbackUI@@PAUIExtractCallbackUI@@PAUIHashCalc@@AAVUString@@AAUCDecompressStat@@@Z$4 proc near
.text$x:00001B22                                         ; DATA XREF: .xdata$x:00001C64o
.text$x:00001B22                 lea     ecx, [ebp-8Ch]
.text$x:00001B28                 jmp     ??1?$CMyComPtr@UIArchiveExtractCallback@@@@QAE@XZ ; CMyComPtr<IArchiveExtractCallback>::~CMyComPtr<IArchiveExtractCallback>(void)
.text$x:00001B28 __unwindfunclet$?Extract@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABV?$CRecordVector@H@@AAV?$CObjectVector@VUString@@@@3ABVCCensorNode@NWildcard@@ABUCExtractOptions@@PAUIOpenCallbackUI@@PAUIExtractCallbackUI@@PAUIHashCalc@@AAVUString@@AAUCDecompressStat@@@Z$4 endp
.text$x:00001B28
.text$x:00001B2D
.text$x:00001B2D ; =============== S U B R O U T I N E =======================================
.text$x:00001B2D
.text$x:00001B2D
.text$x:00001B2D __unwindfunclet$?Extract@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABV?$CRecordVector@H@@AAV?$CObjectVector@VUString@@@@3ABVCCensorNode@NWildcard@@ABUCExtractOptions@@PAUIOpenCallbackUI@@PAUIExtractCallbackUI@@PAUIHashCalc@@AAVUString@@AAUCDecompressStat@@@Z$5 proc near
.text$x:00001B2D                                         ; DATA XREF: .xdata$x:00001C6Co
.text$x:00001B2D                 lea     ecx, [ebp-0ECh] ; this
.text$x:00001B33                 jmp     ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text$x:00001B33 __unwindfunclet$?Extract@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABV?$CRecordVector@H@@AAV?$CObjectVector@VUString@@@@3ABVCCensorNode@NWildcard@@ABUCExtractOptions@@PAUIOpenCallbackUI@@PAUIExtractCallbackUI@@PAUIHashCalc@@AAVUString@@AAUCDecompressStat@@@Z$5 endp
.text$x:00001B33
.text$x:00001B38
.text$x:00001B38 ; =============== S U B R O U T I N E =======================================
.text$x:00001B38
.text$x:00001B38
.text$x:00001B38 __unwindfunclet$?Extract@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABV?$CRecordVector@H@@AAV?$CObjectVector@VUString@@@@3ABVCCensorNode@NWildcard@@ABUCExtractOptions@@PAUIOpenCallbackUI@@PAUIExtractCallbackUI@@PAUIHashCalc@@AAVUString@@AAUCDecompressStat@@@Z$6 proc near
.text$x:00001B38                                         ; DATA XREF: .xdata$x:00001C74o
.text$x:00001B38                 lea     ecx, [ebp-158h] ; this
.text$x:00001B3E                 jmp     ??1CArchiveLink@@QAE@XZ ; CArchiveLink::~CArchiveLink(void)
.text$x:00001B3E __unwindfunclet$?Extract@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABV?$CRecordVector@H@@AAV?$CObjectVector@VUString@@@@3ABVCCensorNode@NWildcard@@ABUCExtractOptions@@PAUIOpenCallbackUI@@PAUIExtractCallbackUI@@PAUIHashCalc@@AAVUString@@AAUCDecompressStat@@@Z$6 endp
.text$x:00001B3E
.text$x:00001B43
.text$x:00001B43 ; =============== S U B R O U T I N E =======================================
.text$x:00001B43
.text$x:00001B43
.text$x:00001B43 __unwindfunclet$?Extract@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABV?$CRecordVector@H@@AAV?$CObjectVector@VUString@@@@3ABVCCensorNode@NWildcard@@ABUCExtractOptions@@PAUIOpenCallbackUI@@PAUIExtractCallbackUI@@PAUIHashCalc@@AAVUString@@AAUCDecompressStat@@@Z$7 proc near
.text$x:00001B43                                         ; DATA XREF: .xdata$x:00001C7Co
.text$x:00001B43                 lea     ecx, [ebp-16Ch]
.text$x:00001B49                 jmp     ??1?$CObjectVector@UCOpenType@@@@QAE@XZ ; CObjectVector<COpenType>::~CObjectVector<COpenType>(void)
.text$x:00001B49 __unwindfunclet$?Extract@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABV?$CRecordVector@H@@AAV?$CObjectVector@VUString@@@@3ABVCCensorNode@NWildcard@@ABUCExtractOptions@@PAUIOpenCallbackUI@@PAUIExtractCallbackUI@@PAUIHashCalc@@AAVUString@@AAUCDecompressStat@@@Z$7 endp
.text$x:00001B49
.text$x:00001B4E
.text$x:00001B4E ; =============== S U B R O U T I N E =======================================
.text$x:00001B4E
.text$x:00001B4E
.text$x:00001B4E __unwindfunclet$?Extract@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABV?$CRecordVector@H@@AAV?$CObjectVector@VUString@@@@3ABVCCensorNode@NWildcard@@ABUCExtractOptions@@PAUIOpenCallbackUI@@PAUIExtractCallbackUI@@PAUIHashCalc@@AAVUString@@AAUCDecompressStat@@@Z$8 proc near
.text$x:00001B4E                                         ; DATA XREF: .xdata$x:00001C84o
.text$x:00001B4E                 lea     ecx, [ebp-1CCh] ; this
.text$x:00001B54                 jmp     ??1COpenOptions@@QAE@XZ ; COpenOptions::~COpenOptions(void)
.text$x:00001B54 __unwindfunclet$?Extract@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABV?$CRecordVector@H@@AAV?$CObjectVector@VUString@@@@3ABVCCensorNode@NWildcard@@ABUCExtractOptions@@PAUIOpenCallbackUI@@PAUIExtractCallbackUI@@PAUIHashCalc@@AAVUString@@AAUCDecompressStat@@@Z$8 endp
.text$x:00001B54
.text$x:00001B59
.text$x:00001B59 ; =============== S U B R O U T I N E =======================================
.text$x:00001B59
.text$x:00001B59
.text$x:00001B59 __unwindfunclet$?Extract@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABV?$CRecordVector@H@@AAV?$CObjectVector@VUString@@@@3ABVCCensorNode@NWildcard@@ABUCExtractOptions@@PAUIOpenCallbackUI@@PAUIExtractCallbackUI@@PAUIHashCalc@@AAVUString@@AAUCDecompressStat@@@Z$9 proc near
.text$x:00001B59                                         ; DATA XREF: .xdata$x:00001C8Co
.text$x:00001B59                 lea     ecx, [ebp-214h] ; this
.text$x:00001B5F                 jmp     ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfo::~CFileInfo(void)
.text$x:00001B5F __unwindfunclet$?Extract@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABV?$CRecordVector@H@@AAV?$CObjectVector@VUString@@@@3ABVCCensorNode@NWildcard@@ABUCExtractOptions@@PAUIOpenCallbackUI@@PAUIExtractCallbackUI@@PAUIHashCalc@@AAVUString@@AAUCDecompressStat@@@Z$9 endp
.text$x:00001B5F
.text$x:00001B64
.text$x:00001B64 ; =============== S U B R O U T I N E =======================================
.text$x:00001B64
.text$x:00001B64
.text$x:00001B64 __ehhandler$?Extract@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABV?$CRecordVector@H@@AAV?$CObjectVector@VUString@@@@3ABVCCensorNode@NWildcard@@ABUCExtractOptions@@PAUIOpenCallbackUI@@PAUIExtractCallbackUI@@PAUIHashCalc@@AAVUString@@AAUCDecompressStat@@@Z proc near
.text$x:00001B64                                         ; DATA XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+5o
.text$x:00001B64
.text$x:00001B64 arg_4           = dword ptr  8
.text$x:00001B64
.text$x:00001B64                 mov     edx, [esp+arg_4]
.text$x:00001B68                 lea     eax, [edx+0Ch]
.text$x:00001B6B                 mov     ecx, [edx-2A0h]
.text$x:00001B71                 xor     ecx, eax
.text$x:00001B73                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001B78                 mov     eax, offset __ehfuncinfo$?Extract@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABV?$CRecordVector@H@@AAV?$CObjectVector@VUString@@@@3ABVCCensorNode@NWildcard@@ABUCExtractOptions@@PAUIOpenCallbackUI@@PAUIExtractCallbackUI@@PAUIHashCalc@@AAVUString@@AAUCDecompressStat@@@Z
.text$x:00001B7D                 jmp     ___CxxFrameHandler3
.text$x:00001B7D __ehhandler$?Extract@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABV?$CRecordVector@H@@AAV?$CObjectVector@VUString@@@@3ABVCCensorNode@NWildcard@@ABUCExtractOptions@@PAUIOpenCallbackUI@@PAUIExtractCallbackUI@@PAUIHashCalc@@AAVUString@@AAUCDecompressStat@@@Z endp
.text$x:00001B7D
.text$x:00001B82
.text$x:00001B82 ; =============== S U B R O U T I N E =======================================
.text$x:00001B82
.text$x:00001B82
.text$x:00001B82 __unwindfunclet$?DecompressArchive@@YGJPAVCCodecs@@ABUCArchiveLink@@_KABVCCensorNode@NWildcard@@ABUCExtractOptions@@_NPAUIExtractCallbackUI@@PAVCArchiveExtractCallback@@AAVUString@@AA_K@Z$0 proc near
.text$x:00001B82                                         ; DATA XREF: .xdata$x:00001CB8o
.text$x:00001B82                 lea     ecx, [ebp-24h]
.text$x:00001B85                 jmp     ??1?$CRecordVector@I@@QAE@XZ ; CRecordVector<uint>::~CRecordVector<uint>(void)
.text$x:00001B85 __unwindfunclet$?DecompressArchive@@YGJPAVCCodecs@@ABUCArchiveLink@@_KABVCCensorNode@NWildcard@@ABUCExtractOptions@@_NPAUIExtractCallbackUI@@PAVCArchiveExtractCallback@@AAVUString@@AA_K@Z$0 endp
.text$x:00001B85
.text$x:00001B8A
.text$x:00001B8A ; =============== S U B R O U T I N E =======================================
.text$x:00001B8A
.text$x:00001B8A
.text$x:00001B8A __unwindfunclet$?DecompressArchive@@YGJPAVCCodecs@@ABUCArchiveLink@@_KABVCCensorNode@NWildcard@@ABUCExtractOptions@@_NPAUIExtractCallbackUI@@PAVCArchiveExtractCallback@@AAVUString@@AA_K@Z$1 proc near
.text$x:00001B8A                                         ; DATA XREF: .xdata$x:00001CC0o
.text$x:00001B8A                 lea     ecx, [ebp-38h]
.text$x:00001B8D                 jmp     ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text$x:00001B8D __unwindfunclet$?DecompressArchive@@YGJPAVCCodecs@@ABUCArchiveLink@@_KABVCCensorNode@NWildcard@@ABUCExtractOptions@@_NPAUIExtractCallbackUI@@PAVCArchiveExtractCallback@@AAVUString@@AA_K@Z$1 endp
.text$x:00001B8D
.text$x:00001B92
.text$x:00001B92 ; =============== S U B R O U T I N E =======================================
.text$x:00001B92
.text$x:00001B92
.text$x:00001B92 __unwindfunclet$?DecompressArchive@@YGJPAVCCodecs@@ABUCArchiveLink@@_KABVCCensorNode@NWildcard@@ABUCExtractOptions@@_NPAUIExtractCallbackUI@@PAVCArchiveExtractCallback@@AAVUString@@AA_K@Z$2 proc near
.text$x:00001B92                                         ; DATA XREF: .xdata$x:00001CC8o
.text$x:00001B92                 lea     ecx, [ebp-4Ch]  ; this
.text$x:00001B95                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00001B95 __unwindfunclet$?DecompressArchive@@YGJPAVCCodecs@@ABUCArchiveLink@@_KABVCCensorNode@NWildcard@@ABUCExtractOptions@@_NPAUIExtractCallbackUI@@PAVCArchiveExtractCallback@@AAVUString@@AA_K@Z$2 endp
.text$x:00001B95
.text$x:00001B9A
.text$x:00001B9A ; =============== S U B R O U T I N E =======================================
.text$x:00001B9A
.text$x:00001B9A
.text$x:00001B9A __unwindfunclet$?DecompressArchive@@YGJPAVCCodecs@@ABUCArchiveLink@@_KABVCCensorNode@NWildcard@@ABUCExtractOptions@@_NPAUIExtractCallbackUI@@PAVCArchiveExtractCallback@@AAVUString@@AA_K@Z$3 proc near
.text$x:00001B9A                                         ; DATA XREF: .xdata$x:00001CD0o
.text$x:00001B9A                 lea     ecx, [ebp-60h]  ; this
.text$x:00001B9D                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00001B9D __unwindfunclet$?DecompressArchive@@YGJPAVCCodecs@@ABUCArchiveLink@@_KABVCCensorNode@NWildcard@@ABUCExtractOptions@@_NPAUIExtractCallbackUI@@PAVCArchiveExtractCallback@@AAVUString@@AA_K@Z$3 endp
.text$x:00001B9D
.text$x:00001BA2
.text$x:00001BA2 ; =============== S U B R O U T I N E =======================================
.text$x:00001BA2
.text$x:00001BA2
.text$x:00001BA2 __unwindfunclet$?DecompressArchive@@YGJPAVCCodecs@@ABUCArchiveLink@@_KABVCCensorNode@NWildcard@@ABUCExtractOptions@@_NPAUIExtractCallbackUI@@PAVCArchiveExtractCallback@@AAVUString@@AA_K@Z$4 proc near
.text$x:00001BA2                                         ; DATA XREF: .xdata$x:00001CD8o
.text$x:00001BA2                 lea     ecx, [ebp-158h] ; this
.text$x:00001BA8                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00001BA8 __unwindfunclet$?DecompressArchive@@YGJPAVCCodecs@@ABUCArchiveLink@@_KABVCCensorNode@NWildcard@@ABUCExtractOptions@@_NPAUIExtractCallbackUI@@PAVCArchiveExtractCallback@@AAVUString@@AA_K@Z$4 endp
.text$x:00001BA8
.text$x:00001BAD
.text$x:00001BAD ; =============== S U B R O U T I N E =======================================
.text$x:00001BAD
.text$x:00001BAD
.text$x:00001BAD __unwindfunclet$?DecompressArchive@@YGJPAVCCodecs@@ABUCArchiveLink@@_KABVCCensorNode@NWildcard@@ABUCExtractOptions@@_NPAUIExtractCallbackUI@@PAVCArchiveExtractCallback@@AAVUString@@AA_K@Z$5 proc near
.text$x:00001BAD                                         ; DATA XREF: .xdata$x:00001CE0o
.text$x:00001BAD                 lea     ecx, [ebp-14Ch] ; this
.text$x:00001BB3                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00001BB3 __unwindfunclet$?DecompressArchive@@YGJPAVCCodecs@@ABUCArchiveLink@@_KABVCCensorNode@NWildcard@@ABUCExtractOptions@@_NPAUIExtractCallbackUI@@PAVCArchiveExtractCallback@@AAVUString@@AA_K@Z$5 endp
.text$x:00001BB3
.text$x:00001BB8
.text$x:00001BB8 ; =============== S U B R O U T I N E =======================================
.text$x:00001BB8
.text$x:00001BB8
.text$x:00001BB8 __unwindfunclet$?DecompressArchive@@YGJPAVCCodecs@@ABUCArchiveLink@@_KABVCCensorNode@NWildcard@@ABUCExtractOptions@@_NPAUIExtractCallbackUI@@PAVCArchiveExtractCallback@@AAVUString@@AA_K@Z$6 proc near
.text$x:00001BB8                                         ; DATA XREF: .xdata$x:00001CE8o
.text$x:00001BB8                 lea     ecx, [ebp-7Ch]  ; this
.text$x:00001BBB                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00001BBB __unwindfunclet$?DecompressArchive@@YGJPAVCCodecs@@ABUCArchiveLink@@_KABVCCensorNode@NWildcard@@ABUCExtractOptions@@_NPAUIExtractCallbackUI@@PAVCArchiveExtractCallback@@AAVUString@@AA_K@Z$6 endp
.text$x:00001BBB
.text$x:00001BC0
.text$x:00001BC0 ; =============== S U B R O U T I N E =======================================
.text$x:00001BC0
.text$x:00001BC0
.text$x:00001BC0 __unwindfunclet$?DecompressArchive@@YGJPAVCCodecs@@ABUCArchiveLink@@_KABVCCensorNode@NWildcard@@ABUCExtractOptions@@_NPAUIExtractCallbackUI@@PAVCArchiveExtractCallback@@AAVUString@@AA_K@Z$7 proc near
.text$x:00001BC0                                         ; DATA XREF: .xdata$x:00001CF0o
.text$x:00001BC0                 lea     ecx, [ebp-90h]  ; this
.text$x:00001BC6                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00001BC6 __unwindfunclet$?DecompressArchive@@YGJPAVCCodecs@@ABUCArchiveLink@@_KABVCCensorNode@NWildcard@@ABUCExtractOptions@@_NPAUIExtractCallbackUI@@PAVCArchiveExtractCallback@@AAVUString@@AA_K@Z$7 endp
.text$x:00001BC6
.text$x:00001BCB
.text$x:00001BCB ; =============== S U B R O U T I N E =======================================
.text$x:00001BCB
.text$x:00001BCB
.text$x:00001BCB __unwindfunclet$?DecompressArchive@@YGJPAVCCodecs@@ABUCArchiveLink@@_KABVCCensorNode@NWildcard@@ABUCExtractOptions@@_NPAUIExtractCallbackUI@@PAVCArchiveExtractCallback@@AAVUString@@AA_K@Z$8 proc near
.text$x:00001BCB                                         ; DATA XREF: .xdata$x:00001CF8o
.text$x:00001BCB                 lea     ecx, [ebp-0A4h] ; this
.text$x:00001BD1                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00001BD1 __unwindfunclet$?DecompressArchive@@YGJPAVCCodecs@@ABUCArchiveLink@@_KABVCCensorNode@NWildcard@@ABUCExtractOptions@@_NPAUIExtractCallbackUI@@PAVCArchiveExtractCallback@@AAVUString@@AA_K@Z$8 endp
.text$x:00001BD1
.text$x:00001BD6
.text$x:00001BD6 ; =============== S U B R O U T I N E =======================================
.text$x:00001BD6
.text$x:00001BD6
.text$x:00001BD6 __unwindfunclet$?DecompressArchive@@YGJPAVCCodecs@@ABUCArchiveLink@@_KABVCCensorNode@NWildcard@@ABUCExtractOptions@@_NPAUIExtractCallbackUI@@PAVCArchiveExtractCallback@@AAVUString@@AA_K@Z$9 proc near
.text$x:00001BD6                                         ; DATA XREF: .xdata$x:00001D00o
.text$x:00001BD6                 lea     ecx, [ebp-100h] ; this
.text$x:00001BDC                 jmp     ??1CReadArcItem@@QAE@XZ ; CReadArcItem::~CReadArcItem(void)
.text$x:00001BDC __unwindfunclet$?DecompressArchive@@YGJPAVCCodecs@@ABUCArchiveLink@@_KABVCCensorNode@NWildcard@@ABUCExtractOptions@@_NPAUIExtractCallbackUI@@PAVCArchiveExtractCallback@@AAVUString@@AA_K@Z$9 endp
.text$x:00001BDC
.text$x:00001BE1
.text$x:00001BE1 ; =============== S U B R O U T I N E =======================================
.text$x:00001BE1
.text$x:00001BE1
.text$x:00001BE1 __unwindfunclet$?DecompressArchive@@YGJPAVCCodecs@@ABUCArchiveLink@@_KABVCCensorNode@NWildcard@@ABUCExtractOptions@@_NPAUIExtractCallbackUI@@PAVCArchiveExtractCallback@@AAVUString@@AA_K@Z$10 proc near
.text$x:00001BE1                                         ; DATA XREF: .xdata$x:00001D08o
.text$x:00001BE1                 lea     ecx, [ebp-13Ch] ; this
.text$x:00001BE7                 jmp     ??1CPropVariant@NCOM@NWindows@@QAE@XZ ; NWindows::NCOM::CPropVariant::~CPropVariant(void)
.text$x:00001BE7 __unwindfunclet$?DecompressArchive@@YGJPAVCCodecs@@ABUCArchiveLink@@_KABVCCensorNode@NWildcard@@ABUCExtractOptions@@_NPAUIExtractCallbackUI@@PAVCArchiveExtractCallback@@AAVUString@@AA_K@Z$10 endp
.text$x:00001BE7
.text$x:00001BEC
.text$x:00001BEC ; =============== S U B R O U T I N E =======================================
.text$x:00001BEC
.text$x:00001BEC
.text$x:00001BEC __ehhandler$?DecompressArchive@@YGJPAVCCodecs@@ABUCArchiveLink@@_KABVCCensorNode@NWildcard@@ABUCExtractOptions@@_NPAUIExtractCallbackUI@@PAVCArchiveExtractCallback@@AAVUString@@AA_K@Z proc near
.text$x:00001BEC                                         ; DATA XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+5o
.text$x:00001BEC
.text$x:00001BEC arg_4           = dword ptr  8
.text$x:00001BEC
.text$x:00001BEC                 mov     edx, [esp+arg_4]
.text$x:00001BF0                 lea     eax, [edx+0Ch]
.text$x:00001BF3                 mov     ecx, [edx-180h]
.text$x:00001BF9                 xor     ecx, eax
.text$x:00001BFB                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001C00                 mov     eax, offset __ehfuncinfo$?DecompressArchive@@YGJPAVCCodecs@@ABUCArchiveLink@@_KABVCCensorNode@NWildcard@@ABUCExtractOptions@@_NPAUIExtractCallbackUI@@PAVCArchiveExtractCallback@@AAVUString@@AA_K@Z
.text$x:00001C05                 jmp     ___CxxFrameHandler3
.text$x:00001C05 __ehhandler$?DecompressArchive@@YGJPAVCCodecs@@ABUCArchiveLink@@_KABVCCensorNode@NWildcard@@ABUCExtractOptions@@_NPAUIExtractCallbackUI@@PAVCArchiveExtractCallback@@AAVUString@@AA_K@Z endp
.text$x:00001C05
.text$x:00001C05 ; ---------------------------------------------------------------------------
.text$x:00001C0A                 align 4
.text$x:00001C0A _text$x         ends
.text$x:00001C0A
.xdata$x:00001C0C ; ===========================================================================
.xdata$x:00001C0C
.xdata$x:00001C0C ; Segment type: Pure data
.xdata$x:00001C0C ; Segment permissions: Read
.xdata$x:00001C0C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001C0C                 assume cs:_xdata$x
.xdata$x:00001C0C                 ;org 1C0Ch
.xdata$x:00001C0C ; COMDAT (pick any)
.xdata$x:00001C0C                 public __TI2PAD
.xdata$x:00001C0C __TI2PAD        db    0                 ; DATA XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+103o
.xdata$x:00001C0C                                         ; Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+12Do ...
.xdata$x:00001C0D                 db    0
.xdata$x:00001C0E                 db    0
.xdata$x:00001C0F                 db    0
.xdata$x:00001C10                 db    0
.xdata$x:00001C11                 db    0
.xdata$x:00001C12                 db    0
.xdata$x:00001C13                 db    0
.xdata$x:00001C14                 db    0
.xdata$x:00001C15                 db    0
.xdata$x:00001C16                 db    0
.xdata$x:00001C17                 db    0
.xdata$x:00001C18                 dd offset __CTA2PAD
.xdata$x:00001C18 _xdata$x        ends
.xdata$x:00001C18
.xdata$x:00001C1C ; ===========================================================================
.xdata$x:00001C1C
.xdata$x:00001C1C ; Segment type: Pure data
.xdata$x:00001C1C ; Segment permissions: Read
.xdata$x:00001C1C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001C1C                 assume cs:_xdata$x
.xdata$x:00001C1C                 ;org 1C1Ch
.xdata$x:00001C1C __ehfuncinfo$?Extract@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABV?$CRecordVector@H@@AAV?$CObjectVector@VUString@@@@3ABVCCensorNode@NWildcard@@ABUCExtractOptions@@PAUIOpenCallbackUI@@PAUIExtractCallbackUI@@PAUIHashCalc@@AAVUString@@AAUCDecompressStat@@@Z db  22h ; "
.xdata$x:00001C1C                                         ; DATA XREF: __ehhandler$?Extract@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABV?$CRecordVector@H@@AAV?$CObjectVector@VUString@@@@3ABVCCensorNode@NWildcard@@ABUCExtractOptions@@PAUIOpenCallbackUI@@PAUIExtractCallbackUI@@PAUIHashCalc@@AAVUString@@AAUCDecompressStat@@@Z+14o
.xdata$x:00001C1D                 db    5
.xdata$x:00001C1E                 db  93h ; Ã´
.xdata$x:00001C1F                 db  19h
.xdata$x:00001C20                 db  0Ah
.xdata$x:00001C21                 db    0
.xdata$x:00001C22                 db    0
.xdata$x:00001C23                 db    0
.xdata$x:00001C24                 dd offset __unwindtable$?Extract@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABV?$CRecordVector@H@@AAV?$CObjectVector@VUString@@@@3ABVCCensorNode@NWildcard@@ABUCExtractOptions@@PAUIOpenCallbackUI@@PAUIExtractCallbackUI@@PAUIHashCalc@@AAVUString@@AAUCDecompressStat@@@Z
.xdata$x:00001C28                 db    0
.xdata$x:00001C29                 db    0
.xdata$x:00001C2A                 db    0
.xdata$x:00001C2B                 db    0
.xdata$x:00001C2C                 db    0
.xdata$x:00001C2D                 db    0
.xdata$x:00001C2E                 db    0
.xdata$x:00001C2F                 db    0
.xdata$x:00001C30                 db    0
.xdata$x:00001C31                 db    0
.xdata$x:00001C32                 db    0
.xdata$x:00001C33                 db    0
.xdata$x:00001C34                 db    0
.xdata$x:00001C35                 db    0
.xdata$x:00001C36                 db    0
.xdata$x:00001C37                 db    0
.xdata$x:00001C38                 db    0
.xdata$x:00001C39                 db    0
.xdata$x:00001C3A                 db    0
.xdata$x:00001C3B                 db    0
.xdata$x:00001C3C                 db    1
.xdata$x:00001C3D                 db    0
.xdata$x:00001C3E                 db    0
.xdata$x:00001C3F                 db    0
.xdata$x:00001C40 __unwindtable$?Extract@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABV?$CRecordVector@H@@AAV?$CObjectVector@VUString@@@@3ABVCCensorNode@NWildcard@@ABUCExtractOptions@@PAUIOpenCallbackUI@@PAUIExtractCallbackUI@@PAUIHashCalc@@AAVUString@@AAUCDecompressStat@@@Z db 0FFh
.xdata$x:00001C40                                         ; DATA XREF: .xdata$x:00001C24o
.xdata$x:00001C41                 db 0FFh
.xdata$x:00001C42                 db 0FFh
.xdata$x:00001C43                 db 0FFh
.xdata$x:00001C44                 dd offset __unwindfunclet$?Extract@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABV?$CRecordVector@H@@AAV?$CObjectVector@VUString@@@@3ABVCCensorNode@NWildcard@@ABUCExtractOptions@@PAUIOpenCallbackUI@@PAUIExtractCallbackUI@@PAUIHashCalc@@AAVUString@@AAUCDecompressStat@@@Z$0
.xdata$x:00001C48                 db    0
.xdata$x:00001C49                 db    0
.xdata$x:00001C4A                 db    0
.xdata$x:00001C4B                 db    0
.xdata$x:00001C4C                 dd offset __unwindfunclet$?Extract@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABV?$CRecordVector@H@@AAV?$CObjectVector@VUString@@@@3ABVCCensorNode@NWildcard@@ABUCExtractOptions@@PAUIOpenCallbackUI@@PAUIExtractCallbackUI@@PAUIHashCalc@@AAVUString@@AAUCDecompressStat@@@Z$1
.xdata$x:00001C50                 db    0
.xdata$x:00001C51                 db    0
.xdata$x:00001C52                 db    0
.xdata$x:00001C53                 db    0
.xdata$x:00001C54                 dd offset __unwindfunclet$?Extract@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABV?$CRecordVector@H@@AAV?$CObjectVector@VUString@@@@3ABVCCensorNode@NWildcard@@ABUCExtractOptions@@PAUIOpenCallbackUI@@PAUIExtractCallbackUI@@PAUIHashCalc@@AAVUString@@AAUCDecompressStat@@@Z$2
.xdata$x:00001C58                 db    2
.xdata$x:00001C59                 db    0
.xdata$x:00001C5A                 db    0
.xdata$x:00001C5B                 db    0
.xdata$x:00001C5C                 dd offset __unwindfunclet$?Extract@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABV?$CRecordVector@H@@AAV?$CObjectVector@VUString@@@@3ABVCCensorNode@NWildcard@@ABUCExtractOptions@@PAUIOpenCallbackUI@@PAUIExtractCallbackUI@@PAUIHashCalc@@AAVUString@@AAUCDecompressStat@@@Z$3
.xdata$x:00001C60                 db    2
.xdata$x:00001C61                 db    0
.xdata$x:00001C62                 db    0
.xdata$x:00001C63                 db    0
.xdata$x:00001C64                 dd offset __unwindfunclet$?Extract@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABV?$CRecordVector@H@@AAV?$CObjectVector@VUString@@@@3ABVCCensorNode@NWildcard@@ABUCExtractOptions@@PAUIOpenCallbackUI@@PAUIExtractCallbackUI@@PAUIHashCalc@@AAVUString@@AAUCDecompressStat@@@Z$4
.xdata$x:00001C68                 db    4
.xdata$x:00001C69                 db    0
.xdata$x:00001C6A                 db    0
.xdata$x:00001C6B                 db    0
.xdata$x:00001C6C                 dd offset __unwindfunclet$?Extract@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABV?$CRecordVector@H@@AAV?$CObjectVector@VUString@@@@3ABVCCensorNode@NWildcard@@ABUCExtractOptions@@PAUIOpenCallbackUI@@PAUIExtractCallbackUI@@PAUIHashCalc@@AAVUString@@AAUCDecompressStat@@@Z$5
.xdata$x:00001C70                 db    5
.xdata$x:00001C71                 db    0
.xdata$x:00001C72                 db    0
.xdata$x:00001C73                 db    0
.xdata$x:00001C74                 dd offset __unwindfunclet$?Extract@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABV?$CRecordVector@H@@AAV?$CObjectVector@VUString@@@@3ABVCCensorNode@NWildcard@@ABUCExtractOptions@@PAUIOpenCallbackUI@@PAUIExtractCallbackUI@@PAUIHashCalc@@AAVUString@@AAUCDecompressStat@@@Z$6
.xdata$x:00001C78                 db    6
.xdata$x:00001C79                 db    0
.xdata$x:00001C7A                 db    0
.xdata$x:00001C7B                 db    0
.xdata$x:00001C7C                 dd offset __unwindfunclet$?Extract@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABV?$CRecordVector@H@@AAV?$CObjectVector@VUString@@@@3ABVCCensorNode@NWildcard@@ABUCExtractOptions@@PAUIOpenCallbackUI@@PAUIExtractCallbackUI@@PAUIHashCalc@@AAVUString@@AAUCDecompressStat@@@Z$7
.xdata$x:00001C80                 db    7
.xdata$x:00001C81                 db    0
.xdata$x:00001C82                 db    0
.xdata$x:00001C83                 db    0
.xdata$x:00001C84                 dd offset __unwindfunclet$?Extract@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABV?$CRecordVector@H@@AAV?$CObjectVector@VUString@@@@3ABVCCensorNode@NWildcard@@ABUCExtractOptions@@PAUIOpenCallbackUI@@PAUIExtractCallbackUI@@PAUIHashCalc@@AAVUString@@AAUCDecompressStat@@@Z$8
.xdata$x:00001C88                 db    8
.xdata$x:00001C89                 db    0
.xdata$x:00001C8A                 db    0
.xdata$x:00001C8B                 db    0
.xdata$x:00001C8C                 dd offset __unwindfunclet$?Extract@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABV?$CRecordVector@H@@AAV?$CObjectVector@VUString@@@@3ABVCCensorNode@NWildcard@@ABUCExtractOptions@@PAUIOpenCallbackUI@@PAUIExtractCallbackUI@@PAUIHashCalc@@AAVUString@@AAUCDecompressStat@@@Z$9
.xdata$x:00001C90 __ehfuncinfo$?DecompressArchive@@YGJPAVCCodecs@@ABUCArchiveLink@@_KABVCCensorNode@NWildcard@@ABUCExtractOptions@@_NPAUIExtractCallbackUI@@PAVCArchiveExtractCallback@@AAVUString@@AA_K@Z db  22h ; "
.xdata$x:00001C90                                         ; DATA XREF: __ehhandler$?DecompressArchive@@YGJPAVCCodecs@@ABUCArchiveLink@@_KABVCCensorNode@NWildcard@@ABUCExtractOptions@@_NPAUIExtractCallbackUI@@PAVCArchiveExtractCallback@@AAVUString@@AA_K@Z+14o
.xdata$x:00001C91                 db    5
.xdata$x:00001C92                 db  93h ; Ã´
.xdata$x:00001C93                 db  19h
.xdata$x:00001C94                 db  0Bh
.xdata$x:00001C95                 db    0
.xdata$x:00001C96                 db    0
.xdata$x:00001C97                 db    0
.xdata$x:00001C98                 dd offset __unwindtable$?DecompressArchive@@YGJPAVCCodecs@@ABUCArchiveLink@@_KABVCCensorNode@NWildcard@@ABUCExtractOptions@@_NPAUIExtractCallbackUI@@PAVCArchiveExtractCallback@@AAVUString@@AA_K@Z
.xdata$x:00001C9C                 db    0
.xdata$x:00001C9D                 db    0
.xdata$x:00001C9E                 db    0
.xdata$x:00001C9F                 db    0
.xdata$x:00001CA0                 db    0
.xdata$x:00001CA1                 db    0
.xdata$x:00001CA2                 db    0
.xdata$x:00001CA3                 db    0
.xdata$x:00001CA4                 db    0
.xdata$x:00001CA5                 db    0
.xdata$x:00001CA6                 db    0
.xdata$x:00001CA7                 db    0
.xdata$x:00001CA8                 db    0
.xdata$x:00001CA9                 db    0
.xdata$x:00001CAA                 db    0
.xdata$x:00001CAB                 db    0
.xdata$x:00001CAC                 db    0
.xdata$x:00001CAD                 db    0
.xdata$x:00001CAE                 db    0
.xdata$x:00001CAF                 db    0
.xdata$x:00001CB0                 db    1
.xdata$x:00001CB1                 db    0
.xdata$x:00001CB2                 db    0
.xdata$x:00001CB3                 db    0
.xdata$x:00001CB4 __unwindtable$?DecompressArchive@@YGJPAVCCodecs@@ABUCArchiveLink@@_KABVCCensorNode@NWildcard@@ABUCExtractOptions@@_NPAUIExtractCallbackUI@@PAVCArchiveExtractCallback@@AAVUString@@AA_K@Z db 0FFh
.xdata$x:00001CB4                                         ; DATA XREF: .xdata$x:00001C98o
.xdata$x:00001CB5                 db 0FFh
.xdata$x:00001CB6                 db 0FFh
.xdata$x:00001CB7                 db 0FFh
.xdata$x:00001CB8                 dd offset __unwindfunclet$?DecompressArchive@@YGJPAVCCodecs@@ABUCArchiveLink@@_KABVCCensorNode@NWildcard@@ABUCExtractOptions@@_NPAUIExtractCallbackUI@@PAVCArchiveExtractCallback@@AAVUString@@AA_K@Z$0
.xdata$x:00001CBC                 align 10h
.xdata$x:00001CC0                 dd offset __unwindfunclet$?DecompressArchive@@YGJPAVCCodecs@@ABUCArchiveLink@@_KABVCCensorNode@NWildcard@@ABUCExtractOptions@@_NPAUIExtractCallbackUI@@PAVCArchiveExtractCallback@@AAVUString@@AA_K@Z$1
.xdata$x:00001CC4                 db    1
.xdata$x:00001CC5                 db    0
.xdata$x:00001CC6                 db    0
.xdata$x:00001CC7                 db    0
.xdata$x:00001CC8                 dd offset __unwindfunclet$?DecompressArchive@@YGJPAVCCodecs@@ABUCArchiveLink@@_KABVCCensorNode@NWildcard@@ABUCExtractOptions@@_NPAUIExtractCallbackUI@@PAVCArchiveExtractCallback@@AAVUString@@AA_K@Z$2
.xdata$x:00001CCC                 db    2
.xdata$x:00001CCD                 db    0
.xdata$x:00001CCE                 db    0
.xdata$x:00001CCF                 db    0
.xdata$x:00001CD0                 dd offset __unwindfunclet$?DecompressArchive@@YGJPAVCCodecs@@ABUCArchiveLink@@_KABVCCensorNode@NWildcard@@ABUCExtractOptions@@_NPAUIExtractCallbackUI@@PAVCArchiveExtractCallback@@AAVUString@@AA_K@Z$3
.xdata$x:00001CD4                 db    3
.xdata$x:00001CD5                 db    0
.xdata$x:00001CD6                 db    0
.xdata$x:00001CD7                 db    0
.xdata$x:00001CD8                 dd offset __unwindfunclet$?DecompressArchive@@YGJPAVCCodecs@@ABUCArchiveLink@@_KABVCCensorNode@NWildcard@@ABUCExtractOptions@@_NPAUIExtractCallbackUI@@PAVCArchiveExtractCallback@@AAVUString@@AA_K@Z$4
.xdata$x:00001CDC                 db    4
.xdata$x:00001CDD                 db    0
.xdata$x:00001CDE                 db    0
.xdata$x:00001CDF                 db    0
.xdata$x:00001CE0                 dd offset __unwindfunclet$?DecompressArchive@@YGJPAVCCodecs@@ABUCArchiveLink@@_KABVCCensorNode@NWildcard@@ABUCExtractOptions@@_NPAUIExtractCallbackUI@@PAVCArchiveExtractCallback@@AAVUString@@AA_K@Z$5
.xdata$x:00001CE4                 db    3
.xdata$x:00001CE5                 db    0
.xdata$x:00001CE6                 db    0
.xdata$x:00001CE7                 db    0
.xdata$x:00001CE8                 dd offset __unwindfunclet$?DecompressArchive@@YGJPAVCCodecs@@ABUCArchiveLink@@_KABVCCensorNode@NWildcard@@ABUCExtractOptions@@_NPAUIExtractCallbackUI@@PAVCArchiveExtractCallback@@AAVUString@@AA_K@Z$6
.xdata$x:00001CEC                 db    6
.xdata$x:00001CED                 db    0
.xdata$x:00001CEE                 db    0
.xdata$x:00001CEF                 db    0
.xdata$x:00001CF0                 dd offset __unwindfunclet$?DecompressArchive@@YGJPAVCCodecs@@ABUCArchiveLink@@_KABVCCensorNode@NWildcard@@ABUCExtractOptions@@_NPAUIExtractCallbackUI@@PAVCArchiveExtractCallback@@AAVUString@@AA_K@Z$7
.xdata$x:00001CF4                 db    7
.xdata$x:00001CF5                 db    0
.xdata$x:00001CF6                 db    0
.xdata$x:00001CF7                 db    0
.xdata$x:00001CF8                 dd offset __unwindfunclet$?DecompressArchive@@YGJPAVCCodecs@@ABUCArchiveLink@@_KABVCCensorNode@NWildcard@@ABUCExtractOptions@@_NPAUIExtractCallbackUI@@PAVCArchiveExtractCallback@@AAVUString@@AA_K@Z$8
.xdata$x:00001CFC                 db    7
.xdata$x:00001CFD                 db    0
.xdata$x:00001CFE                 db    0
.xdata$x:00001CFF                 db    0
.xdata$x:00001D00                 dd offset __unwindfunclet$?DecompressArchive@@YGJPAVCCodecs@@ABUCArchiveLink@@_KABVCCensorNode@NWildcard@@ABUCExtractOptions@@_NPAUIExtractCallbackUI@@PAVCArchiveExtractCallback@@AAVUString@@AA_K@Z$9
.xdata$x:00001D04                 db    7
.xdata$x:00001D05                 db    0
.xdata$x:00001D06                 db    0
.xdata$x:00001D07                 db    0
.xdata$x:00001D08                 dd offset __unwindfunclet$?DecompressArchive@@YGJPAVCCodecs@@ABUCArchiveLink@@_KABVCCensorNode@NWildcard@@ABUCExtractOptions@@_NPAUIExtractCallbackUI@@PAVCArchiveExtractCallback@@AAVUString@@AA_K@Z$10
.xdata$x:00001D08 _xdata$x        ends
.xdata$x:00001D08
.xdata$x:00001D0C ; ===========================================================================
.xdata$x:00001D0C
.xdata$x:00001D0C ; Segment type: Pure data
.xdata$x:00001D0C ; Segment permissions: Read
.xdata$x:00001D0C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001D0C                 assume cs:_xdata$x
.xdata$x:00001D0C                 ;org 1D0Ch
.xdata$x:00001D0C ; COMDAT (pick any)
.xdata$x:00001D0C                 public __CTA2PAD
.xdata$x:00001D0C __CTA2PAD       db    2                 ; DATA XREF: .xdata$x:00001C18o
.xdata$x:00001D0D                 db    0
.xdata$x:00001D0E                 db    0
.xdata$x:00001D0F                 db    0
.xdata$x:00001D10                 dd offset __CT??_R0PAD@84
.xdata$x:00001D14                 dd offset __CT??_R0PAX@84
.xdata$x:00001D14 _xdata$x        ends
.xdata$x:00001D14
.xdata$x:00001D18 ; ===========================================================================
.xdata$x:00001D18
.xdata$x:00001D18 ; Segment type: Pure data
.xdata$x:00001D18 ; Segment permissions: Read
.xdata$x:00001D18 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001D18                 assume cs:_xdata$x
.xdata$x:00001D18                 ;org 1D18h
.xdata$x:00001D18 ; COMDAT (pick any)
.xdata$x:00001D18                 public __CT??_R0PAD@84
.xdata$x:00001D18 __CT??_R0PAD@84 db    1                 ; DATA XREF: .xdata$x:00001D10o
.xdata$x:00001D19                 db    0
.xdata$x:00001D1A                 db    0
.xdata$x:00001D1B                 db    0
.xdata$x:00001D1C                 dd offset ??_R0PAD@8    ; char * `RTTI Type Descriptor'
.xdata$x:00001D20                 db    0
.xdata$x:00001D21                 db    0
.xdata$x:00001D22                 db    0
.xdata$x:00001D23                 db    0
.xdata$x:00001D24                 db 0FFh
.xdata$x:00001D25                 db 0FFh
.xdata$x:00001D26                 db 0FFh
.xdata$x:00001D27                 db 0FFh
.xdata$x:00001D28                 db    0
.xdata$x:00001D29                 db    0
.xdata$x:00001D2A                 db    0
.xdata$x:00001D2B                 db    0
.xdata$x:00001D2C                 db    4
.xdata$x:00001D2D                 db    0
.xdata$x:00001D2E                 db    0
.xdata$x:00001D2F                 db    0
.xdata$x:00001D30                 db    0
.xdata$x:00001D31                 db    0
.xdata$x:00001D32                 db    0
.xdata$x:00001D33                 db    0
.xdata$x:00001D33 _xdata$x        ends
.xdata$x:00001D33
.data:00001D34 ; ===========================================================================
.data:00001D34
.data:00001D34 ; Segment type: Pure data
.data:00001D34 ; Segment permissions: Read/Write
.data:00001D34 _data           segment dword public 'DATA' use32
.data:00001D34                 assume cs:_data
.data:00001D34                 ;org 1D34h
.data:00001D34 ; COMDAT (pick any)
.data:00001D34                 public ??_R0PAD@8
.data:00001D34 ; char * `RTTI Type Descriptor'
.data:00001D34 ??_R0PAD@8      dd offset ??_7type_info@@6B@ ; DATA XREF: .xdata$x:00001D1Co
.data:00001D34                                         ; const type_info::`vftable'
.data:00001D38                 db    0
.data:00001D39                 db    0
.data:00001D3A                 db    0
.data:00001D3B                 db    0
.data:00001D3C                 db  2Eh ; .
.data:00001D3D                 db  50h ; P
.data:00001D3E                 db  41h ; A
.data:00001D3F                 db  44h ; D
.data:00001D40                 db    0
.data:00001D41                 align 4
.data:00001D41 _data           ends
.data:00001D41
.xdata$x:00001D44 ; ===========================================================================
.xdata$x:00001D44
.xdata$x:00001D44 ; Segment type: Pure data
.xdata$x:00001D44 ; Segment permissions: Read
.xdata$x:00001D44 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001D44                 assume cs:_xdata$x
.xdata$x:00001D44                 ;org 1D44h
.xdata$x:00001D44 ; COMDAT (pick any)
.xdata$x:00001D44                 public __CT??_R0PAX@84
.xdata$x:00001D44 __CT??_R0PAX@84 db    1                 ; DATA XREF: .xdata$x:00001D14o
.xdata$x:00001D45                 db    0
.xdata$x:00001D46                 db    0
.xdata$x:00001D47                 db    0
.xdata$x:00001D48                 dd offset ??_R0PAX@8    ; void * `RTTI Type Descriptor'
.xdata$x:00001D4C                 align 10h
.xdata$x:00001D50                 db 0FFh
.xdata$x:00001D51                 db 0FFh
.xdata$x:00001D52                 db 0FFh
.xdata$x:00001D53                 db 0FFh
.xdata$x:00001D54                 db    0
.xdata$x:00001D55                 db    0
.xdata$x:00001D56                 db    0
.xdata$x:00001D57                 db    0
.xdata$x:00001D58                 db    4
.xdata$x:00001D59                 db    0
.xdata$x:00001D5A                 db    0
.xdata$x:00001D5B                 db    0
.xdata$x:00001D5C                 db    0
.xdata$x:00001D5D                 db    0
.xdata$x:00001D5E                 db    0
.xdata$x:00001D5F                 db    0
.xdata$x:00001D5F _xdata$x        ends
.xdata$x:00001D5F
.data:00001D60 ; ===========================================================================
.data:00001D60
.data:00001D60 ; Segment type: Pure data
.data:00001D60 ; Segment permissions: Read/Write
.data:00001D60 _data           segment dword public 'DATA' use32
.data:00001D60                 assume cs:_data
.data:00001D60                 ;org 1D60h
.data:00001D60 ; COMDAT (pick any)
.data:00001D60                 public ??_R0PAX@8
.data:00001D60 ; void * `RTTI Type Descriptor'
.data:00001D60 ??_R0PAX@8      dd offset ??_7type_info@@6B@ ; DATA XREF: .xdata$x:00001D48o
.data:00001D60                                         ; const type_info::`vftable'
.data:00001D64                 align 8
.data:00001D68 a_pax           db '.PAX',0
.data:00001D6D                 align 10h
.data:00001D6D _data           ends
.data:00001D6D
.text:00001D70 ; ===========================================================================
.text:00001D70
.text:00001D70 ; Segment type: Pure code
.text:00001D70 ; Segment permissions: Read/Execute
.text:00001D70 _text           segment para public 'CODE' use32
.text:00001D70                 assume cs:_text
.text:00001D70                 ;org 1D70h
.text:00001D70 ; COMDAT (pick any)
.text:00001D70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001D70
.text:00001D70 ; =============== S U B R O U T I N E =======================================
.text:00001D70
.text:00001D70 ; Attributes: bp-based frame
.text:00001D70
.text:00001D70 ; bool __thiscall UString::IsEmpty(UString *__hidden this)
.text:00001D70                 public ?IsEmpty@UString@@QBE_NXZ
.text:00001D70 ?IsEmpty@UString@@QBE_NXZ proc near     ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+B13p
.text:00001D70                                         ; DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+1D4p ...
.text:00001D70
.text:00001D70 var_4           = dword ptr -4
.text:00001D70
.text:00001D70                 push    ebp
.text:00001D71                 mov     ebp, esp
.text:00001D73                 push    ecx
.text:00001D74                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001D7B                 mov     [ebp+var_4], ecx
.text:00001D7E                 mov     eax, [ebp+var_4]
.text:00001D81                 xor     ecx, ecx
.text:00001D83                 cmp     dword ptr [eax+4], 0
.text:00001D87                 setz    cl
.text:00001D8A                 mov     al, cl
.text:00001D8C                 mov     esp, ebp
.text:00001D8E                 pop     ebp
.text:00001D8F                 retn
.text:00001D8F ?IsEmpty@UString@@QBE_NXZ endp
.text:00001D8F
.text:00001D8F _text           ends
.text:00001D8F
.text:00001D90 ; ===========================================================================
.text:00001D90
.text:00001D90 ; Segment type: Pure code
.text:00001D90 ; Segment permissions: Read/Execute
.text:00001D90 _text           segment para public 'CODE' use32
.text:00001D90                 assume cs:_text
.text:00001D90                 ;org 1D90h
.text:00001D90 ; COMDAT (pick any)
.text:00001D90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001D90
.text:00001D90 ; =============== S U B R O U T I N E =======================================
.text:00001D90
.text:00001D90 ; Attributes: bp-based frame
.text:00001D90
.text:00001D90 ; bool __thiscall NWindows::NFile::NFind::CFileInfoBase::IsDir(NWindows::NFile::NFind::CFileInfoBase *__hidden this)
.text:00001D90                 public ?IsDir@CFileInfoBase@NFind@NFile@NWindows@@QBE_NXZ
.text:00001D90 ?IsDir@CFileInfoBase@NFind@NFile@NWindows@@QBE_NXZ proc near
.text:00001D90                                         ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+117p
.text:00001D90                                         ; Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+395p ...
.text:00001D90
.text:00001D90 var_4           = dword ptr -4
.text:00001D90
.text:00001D90                 push    ebp
.text:00001D91                 mov     ebp, esp
.text:00001D93                 push    ecx
.text:00001D94                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001D9B                 mov     [ebp+var_4], ecx
.text:00001D9E                 push    10h             ; unsigned int
.text:00001DA0                 mov     ecx, [ebp+var_4] ; this
.text:00001DA3                 call    ?MatchesMask@CFileInfoBase@NFind@NFile@NWindows@@ABE_NI@Z ; NWindows::NFile::NFind::CFileInfoBase::MatchesMask(uint)
.text:00001DA8                 add     esp, 4
.text:00001DAB                 cmp     ebp, esp
.text:00001DAD                 call    __RTC_CheckEsp
.text:00001DB2                 mov     esp, ebp
.text:00001DB4                 pop     ebp
.text:00001DB5                 retn
.text:00001DB5 ?IsDir@CFileInfoBase@NFind@NFile@NWindows@@QBE_NXZ endp
.text:00001DB5
.text:00001DB5 ; ---------------------------------------------------------------------------
.text:00001DB6                 align 4
.text:00001DB6 _text           ends
.text:00001DB6
.text:00001DB8 ; ===========================================================================
.text:00001DB8
.text:00001DB8 ; Segment type: Pure code
.text:00001DB8 ; Segment permissions: Read/Execute
.text:00001DB8 _text           segment para public 'CODE' use32
.text:00001DB8                 assume cs:_text
.text:00001DB8                 ;org 1DB8h
.text:00001DB8 ; COMDAT (pick any)
.text:00001DB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001DB8
.text:00001DB8 ; =============== S U B R O U T I N E =======================================
.text:00001DB8
.text:00001DB8 ; Attributes: bp-based frame
.text:00001DB8
.text:00001DB8 ; bool __thiscall NWindows::NFile::NFind::CFileInfoBase::MatchesMask(NWindows::NFile::NFind::CFileInfoBase *this, unsigned int)
.text:00001DB8                 public ?MatchesMask@CFileInfoBase@NFind@NFile@NWindows@@ABE_NI@Z
.text:00001DB8 ?MatchesMask@CFileInfoBase@NFind@NFile@NWindows@@ABE_NI@Z proc near
.text:00001DB8                                         ; CODE XREF: NWindows::NFile::NFind::CFileInfoBase::IsDir(void)+13p
.text:00001DB8
.text:00001DB8 var_4           = dword ptr -4
.text:00001DB8 arg_0           = dword ptr  8
.text:00001DB8
.text:00001DB8                 push    ebp
.text:00001DB9                 mov     ebp, esp
.text:00001DBB                 push    ecx
.text:00001DBC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001DC3                 mov     [ebp+var_4], ecx
.text:00001DC6                 mov     eax, [ebp+var_4]
.text:00001DC9                 mov     eax, [eax+20h]
.text:00001DCC                 and     eax, [ebp+arg_0]
.text:00001DCF                 neg     eax
.text:00001DD1                 sbb     eax, eax
.text:00001DD3                 neg     eax
.text:00001DD5                 mov     esp, ebp
.text:00001DD7                 pop     ebp
.text:00001DD8                 retn    4
.text:00001DD8 ?MatchesMask@CFileInfoBase@NFind@NFile@NWindows@@ABE_NI@Z endp
.text:00001DD8
.text:00001DD8 ; ---------------------------------------------------------------------------
.text:00001DDB                 align 4
.text:00001DDB _text           ends
.text:00001DDB
.text:00001DDC ; ===========================================================================
.text:00001DDC
.text:00001DDC ; Segment type: Pure code
.text:00001DDC ; Segment permissions: Read/Execute
.text:00001DDC _text           segment para public 'CODE' use32
.text:00001DDC                 assume cs:_text
.text:00001DDC                 ;org 1DDCh
.text:00001DDC ; COMDAT (pick any)
.text:00001DDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001DDC
.text:00001DDC ; =============== S U B R O U T I N E =======================================
.text:00001DDC
.text:00001DDC ; Attributes: bp-based frame
.text:00001DDC
.text:00001DDC ; _DWORD __thiscall NWindows::NFile::NFind::CFileInfo::CFileInfo(NWindows::NFile::NFind::CFileInfo *__hidden this)
.text:00001DDC                 public ??0CFileInfo@NFind@NFile@NWindows@@QAE@XZ
.text:00001DDC ??0CFileInfo@NFind@NFile@NWindows@@QAE@XZ proc near
.text:00001DDC                                         ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+B0p
.text:00001DDC                                         ; Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+33Dp ...
.text:00001DDC
.text:00001DDC var_4           = dword ptr -4
.text:00001DDC
.text:00001DDC                 push    ebp
.text:00001DDD                 mov     ebp, esp
.text:00001DDF                 push    ecx
.text:00001DE0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001DE7                 mov     [ebp+var_4], ecx
.text:00001DEA                 mov     ecx, [ebp+var_4] ; this
.text:00001DED                 call    ??0CFileInfoBase@NFind@NFile@NWindows@@QAE@XZ ; NWindows::NFile::NFind::CFileInfoBase::CFileInfoBase(void)
.text:00001DF2                 mov     ecx, [ebp+var_4]
.text:00001DF5                 add     ecx, 28h ; '('
.text:00001DF8                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00001DFD                 mov     eax, [ebp+var_4]
.text:00001E00                 add     esp, 4
.text:00001E03                 cmp     ebp, esp
.text:00001E05                 call    __RTC_CheckEsp
.text:00001E0A                 mov     esp, ebp
.text:00001E0C                 pop     ebp
.text:00001E0D                 retn
.text:00001E0D ??0CFileInfo@NFind@NFile@NWindows@@QAE@XZ endp
.text:00001E0D
.text:00001E0D ; ---------------------------------------------------------------------------
.text:00001E0E                 align 10h
.text:00001E0E _text           ends
.text:00001E0E
.text:00001E10 ; ===========================================================================
.text:00001E10
.text:00001E10 ; Segment type: Pure code
.text:00001E10 ; Segment permissions: Read/Execute
.text:00001E10 _text           segment para public 'CODE' use32
.text:00001E10                 assume cs:_text
.text:00001E10                 ;org 1E10h
.text:00001E10 ; COMDAT (pick any)
.text:00001E10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001E10
.text:00001E10 ; =============== S U B R O U T I N E =======================================
.text:00001E10
.text:00001E10 ; Attributes: bp-based frame
.text:00001E10
.text:00001E10 ; _DWORD __thiscall NWindows::NFile::NFind::CFileInfoBase::CFileInfoBase(NWindows::NFile::NFind::CFileInfoBase *__hidden this)
.text:00001E10                 public ??0CFileInfoBase@NFind@NFile@NWindows@@QAE@XZ
.text:00001E10 ??0CFileInfoBase@NFind@NFile@NWindows@@QAE@XZ proc near
.text:00001E10                                         ; CODE XREF: NWindows::NFile::NFind::CFileInfo::CFileInfo(void)+11p
.text:00001E10
.text:00001E10 var_4           = dword ptr -4
.text:00001E10
.text:00001E10                 push    ebp
.text:00001E11                 mov     ebp, esp
.text:00001E13                 push    ecx
.text:00001E14                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001E1B                 mov     [ebp+var_4], ecx
.text:00001E1E                 mov     ecx, [ebp+var_4] ; this
.text:00001E21                 call    ?ClearBase@CFileInfoBase@NFind@NFile@NWindows@@QAEXXZ ; NWindows::NFile::NFind::CFileInfoBase::ClearBase(void)
.text:00001E26                 mov     eax, [ebp+var_4]
.text:00001E29                 add     esp, 4
.text:00001E2C                 cmp     ebp, esp
.text:00001E2E                 call    __RTC_CheckEsp
.text:00001E33                 mov     esp, ebp
.text:00001E35                 pop     ebp
.text:00001E36                 retn
.text:00001E36 ??0CFileInfoBase@NFind@NFile@NWindows@@QAE@XZ endp
.text:00001E36
.text:00001E36 ; ---------------------------------------------------------------------------
.text:00001E37                 align 4
.text:00001E37 _text           ends
.text:00001E37
.text:00001E38 ; ===========================================================================
.text:00001E38
.text:00001E38 ; Segment type: Pure code
.text:00001E38 ; Segment permissions: Read/Execute
.text:00001E38 _text           segment para public 'CODE' use32
.text:00001E38                 assume cs:_text
.text:00001E38                 ;org 1E38h
.text:00001E38 ; COMDAT (pick any)
.text:00001E38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001E38
.text:00001E38 ; =============== S U B R O U T I N E =======================================
.text:00001E38
.text:00001E38 ; Attributes: bp-based frame
.text:00001E38
.text:00001E38 ; _DWORD __thiscall NWindows::NFile::NFind::CFileInfo::~CFileInfo(NWindows::NFile::NFind::CFileInfo *__hidden this)
.text:00001E38                 public ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ
.text:00001E38 ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ proc near
.text:00001E38                                         ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+167p
.text:00001E38                                         ; Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+40Bp ...
.text:00001E38
.text:00001E38 var_4           = dword ptr -4
.text:00001E38
.text:00001E38                 push    ebp
.text:00001E39                 mov     ebp, esp
.text:00001E3B                 push    ecx
.text:00001E3C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001E43                 mov     [ebp+var_4], ecx
.text:00001E46                 mov     ecx, [ebp+var_4]
.text:00001E49                 add     ecx, 28h ; '('  ; this
.text:00001E4C                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00001E51                 add     esp, 4
.text:00001E54                 cmp     ebp, esp
.text:00001E56                 call    __RTC_CheckEsp
.text:00001E5B                 mov     esp, ebp
.text:00001E5D                 pop     ebp
.text:00001E5E                 retn
.text:00001E5E ??1CFileInfo@NFind@NFile@NWindows@@QAE@XZ endp
.text:00001E5E
.text:00001E5E ; ---------------------------------------------------------------------------
.text:00001E5F                 align 10h
.text:00001E5F _text           ends
.text:00001E5F
.text:00001E60 ; ===========================================================================
.text:00001E60
.text:00001E60 ; Segment type: Pure code
.text:00001E60 ; Segment permissions: Read/Execute
.text:00001E60 _text           segment para public 'CODE' use32
.text:00001E60                 assume cs:_text
.text:00001E60                 ;org 1E60h
.text:00001E60 ; COMDAT (pick any)
.text:00001E60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001E60
.text:00001E60 ; =============== S U B R O U T I N E =======================================
.text:00001E60
.text:00001E60 ; Attributes: bp-based frame
.text:00001E60
.text:00001E60 ; _DWORD __thiscall UString::~UString(UString *__hidden this)
.text:00001E60                 public ??1UString@@QAE@XZ
.text:00001E60 ??1UString@@QAE@XZ proc near            ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+15Cp
.text:00001E60                                         ; DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+16Bp ...
.text:00001E60
.text:00001E60 var_8           = dword ptr -8
.text:00001E60 var_4           = dword ptr -4
.text:00001E60
.text:00001E60                 push    ebp
.text:00001E61                 mov     ebp, esp
.text:00001E63                 sub     esp, 8
.text:00001E66                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00001E6D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001E74                 mov     [ebp+var_4], ecx
.text:00001E77                 mov     eax, [ebp+var_4]
.text:00001E7A                 mov     ecx, [eax]
.text:00001E7C                 mov     [ebp+var_8], ecx
.text:00001E7F                 mov     edx, [ebp+var_8]
.text:00001E82                 push    edx             ; void *
.text:00001E83                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00001E88                 add     esp, 4
.text:00001E8B                 add     esp, 8
.text:00001E8E                 cmp     ebp, esp
.text:00001E90                 call    __RTC_CheckEsp
.text:00001E95                 mov     esp, ebp
.text:00001E97                 pop     ebp
.text:00001E98                 retn
.text:00001E98 ??1UString@@QAE@XZ endp
.text:00001E98
.text:00001E98 ; ---------------------------------------------------------------------------
.text:00001E99                 align 4
.text:00001E99 _text           ends
.text:00001E99
.text:00001E9C ; ===========================================================================
.text:00001E9C
.text:00001E9C ; Segment type: Pure code
.text:00001E9C ; Segment permissions: Read/Execute
.text:00001E9C _text           segment para public 'CODE' use32
.text:00001E9C                 assume cs:_text
.text:00001E9C                 ;org 1E9Ch
.text:00001E9C ; COMDAT (pick any)
.text:00001E9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001E9C
.text:00001E9C ; =============== S U B R O U T I N E =======================================
.text:00001E9C
.text:00001E9C ; Attributes: bp-based frame
.text:00001E9C
.text:00001E9C ; public: __thiscall COpenOptions::COpenOptions(void)
.text:00001E9C                 public ??0COpenOptions@@QAE@XZ
.text:00001E9C ??0COpenOptions@@QAE@XZ proc near       ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+46Dp
.text:00001E9C
.text:00001E9C var_4           = dword ptr -4
.text:00001E9C
.text:00001E9C                 push    ebp
.text:00001E9D                 mov     ebp, esp
.text:00001E9F                 push    ecx
.text:00001EA0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001EA7                 mov     [ebp+var_4], ecx
.text:00001EAA                 mov     eax, [ebp+var_4]
.text:00001EAD                 mov     dword ptr [eax], 0
.text:00001EB3                 mov     ecx, [ebp+var_4]
.text:00001EB6                 add     ecx, 8          ; this
.text:00001EB9                 call    ??0COpenType@@QAE@XZ ; COpenType::COpenType(void)
.text:00001EBE                 mov     ecx, [ebp+var_4]
.text:00001EC1                 mov     dword ptr [ecx+28h], 0
.text:00001EC8                 mov     edx, [ebp+var_4]
.text:00001ECB                 mov     dword ptr [edx+2Ch], 0
.text:00001ED2                 mov     eax, [ebp+var_4]
.text:00001ED5                 mov     dword ptr [eax+30h], 0
.text:00001EDC                 mov     ecx, [ebp+var_4]
.text:00001EDF                 mov     dword ptr [ecx+34h], 0
.text:00001EE6                 mov     edx, [ebp+var_4]
.text:00001EE9                 mov     dword ptr [edx+38h], 0
.text:00001EF0                 mov     eax, [ebp+var_4]
.text:00001EF3                 mov     dword ptr [eax+3Ch], 0
.text:00001EFA                 mov     ecx, [ebp+var_4]
.text:00001EFD                 mov     byte ptr [ecx+44h], 0
.text:00001F01                 mov     ecx, [ebp+var_4]
.text:00001F04                 add     ecx, 48h ; 'H'
.text:00001F07                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00001F0C                 mov     eax, [ebp+var_4]
.text:00001F0F                 add     esp, 4
.text:00001F12                 cmp     ebp, esp
.text:00001F14                 call    __RTC_CheckEsp
.text:00001F19                 mov     esp, ebp
.text:00001F1B                 pop     ebp
.text:00001F1C                 retn
.text:00001F1C ??0COpenOptions@@QAE@XZ endp
.text:00001F1C
.text:00001F1C ; ---------------------------------------------------------------------------
.text:00001F1D                 align 10h
.text:00001F1D _text           ends
.text:00001F1D
.text:00001F20 ; ===========================================================================
.text:00001F20
.text:00001F20 ; Segment type: Pure code
.text:00001F20 ; Segment permissions: Read/Execute
.text:00001F20 _text           segment para public 'CODE' use32
.text:00001F20                 assume cs:_text
.text:00001F20                 ;org 1F20h
.text:00001F20 ; COMDAT (pick any)
.text:00001F20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001F20
.text:00001F20 ; =============== S U B R O U T I N E =======================================
.text:00001F20
.text:00001F20 ; Attributes: bp-based frame
.text:00001F20
.text:00001F20 ; _DWORD __thiscall COpenType::COpenType(COpenType *__hidden this)
.text:00001F20                 public ??0COpenType@@QAE@XZ
.text:00001F20 ??0COpenType@@QAE@XZ proc near          ; CODE XREF: COpenOptions::COpenOptions(void)+1Dp
.text:00001F20
.text:00001F20 var_4           = dword ptr -4
.text:00001F20
.text:00001F20                 push    ebp
.text:00001F21                 mov     ebp, esp
.text:00001F23                 push    ecx
.text:00001F24                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001F2B                 mov     [ebp+var_4], ecx
.text:00001F2E                 mov     eax, [ebp+var_4]
.text:00001F31                 mov     dword ptr [eax], 0FFFFFFFFh
.text:00001F37                 mov     ecx, [ebp+var_4]
.text:00001F3A                 add     ecx, 4          ; this
.text:00001F3D                 call    ??0COpenSpecFlags@@QAE@XZ ; COpenSpecFlags::COpenSpecFlags(void)
.text:00001F42                 mov     ecx, [ebp+var_4]
.text:00001F45                 add     ecx, 7          ; this
.text:00001F48                 call    ??0COpenSpecFlags@@QAE@XZ ; COpenSpecFlags::COpenSpecFlags(void)
.text:00001F4D                 mov     ecx, [ebp+var_4]
.text:00001F50                 add     ecx, 0Ah        ; this
.text:00001F53                 call    ??0COpenSpecFlags@@QAE@XZ ; COpenSpecFlags::COpenSpecFlags(void)
.text:00001F58                 mov     ecx, [ebp+var_4]
.text:00001F5B                 add     ecx, 0Dh        ; this
.text:00001F5E                 call    ??0COpenSpecFlags@@QAE@XZ ; COpenSpecFlags::COpenSpecFlags(void)
.text:00001F63                 mov     ecx, [ebp+var_4]
.text:00001F66                 mov     byte ptr [ecx+10h], 1
.text:00001F6A                 mov     edx, [ebp+var_4]
.text:00001F6D                 mov     byte ptr [edx+11h], 1
.text:00001F71                 mov     eax, [ebp+var_4]
.text:00001F74                 mov     byte ptr [eax+12h], 0
.text:00001F78                 mov     ecx, [ebp+var_4]
.text:00001F7B                 mov     byte ptr [ecx+13h], 0
.text:00001F7F                 mov     edx, [ebp+var_4]
.text:00001F82                 mov     byte ptr [edx+14h], 0
.text:00001F86                 mov     eax, [ebp+var_4]
.text:00001F89                 mov     byte ptr [eax+15h], 0
.text:00001F8D                 mov     ecx, [ebp+var_4]
.text:00001F90                 mov     dword ptr [ecx+18h], 0
.text:00001F97                 mov     dword ptr [ecx+1Ch], 0
.text:00001F9E                 mov     edx, [ebp+var_4]
.text:00001FA1                 mov     byte ptr [edx+4], 1
.text:00001FA5                 mov     eax, [ebp+var_4]
.text:00001FA8                 mov     byte ptr [eax+5], 1
.text:00001FAC                 mov     ecx, [ebp+var_4]
.text:00001FAF                 mov     byte ptr [ecx+6], 1
.text:00001FB3                 mov     edx, [ebp+var_4]
.text:00001FB6                 mov     byte ptr [edx+7], 1
.text:00001FBA                 mov     eax, [ebp+var_4]
.text:00001FBD                 mov     byte ptr [eax+0Eh], 1
.text:00001FC1                 mov     ecx, [ebp+var_4]
.text:00001FC4                 mov     byte ptr [ecx+0Fh], 1
.text:00001FC8                 mov     edx, [ebp+var_4]
.text:00001FCB                 mov     byte ptr [edx+0Dh], 1
.text:00001FCF                 mov     eax, [ebp+var_4]
.text:00001FD2                 add     esp, 4
.text:00001FD5                 cmp     ebp, esp
.text:00001FD7                 call    __RTC_CheckEsp
.text:00001FDC                 mov     esp, ebp
.text:00001FDE                 pop     ebp
.text:00001FDF                 retn
.text:00001FDF ??0COpenType@@QAE@XZ endp
.text:00001FDF
.text:00001FDF _text           ends
.text:00001FDF
.text:00001FE0 ; ===========================================================================
.text:00001FE0
.text:00001FE0 ; Segment type: Pure code
.text:00001FE0 ; Segment permissions: Read/Execute
.text:00001FE0 _text           segment para public 'CODE' use32
.text:00001FE0                 assume cs:_text
.text:00001FE0                 ;org 1FE0h
.text:00001FE0 ; COMDAT (pick any)
.text:00001FE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00001FE0
.text:00001FE0 ; =============== S U B R O U T I N E =======================================
.text:00001FE0
.text:00001FE0 ; Attributes: bp-based frame
.text:00001FE0
.text:00001FE0 ; _DWORD __thiscall COpenSpecFlags::COpenSpecFlags(COpenSpecFlags *__hidden this)
.text:00001FE0                 public ??0COpenSpecFlags@@QAE@XZ
.text:00001FE0 ??0COpenSpecFlags@@QAE@XZ proc near     ; CODE XREF: COpenType::COpenType(void)+1Dp
.text:00001FE0                                         ; COpenType::COpenType(void)+28p ...
.text:00001FE0
.text:00001FE0 var_4           = dword ptr -4
.text:00001FE0
.text:00001FE0                 push    ebp
.text:00001FE1                 mov     ebp, esp
.text:00001FE3                 push    ecx
.text:00001FE4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00001FEB                 mov     [ebp+var_4], ecx
.text:00001FEE                 mov     eax, [ebp+var_4]
.text:00001FF1                 mov     byte ptr [eax], 0
.text:00001FF4                 mov     ecx, [ebp+var_4]
.text:00001FF7                 mov     byte ptr [ecx+1], 0
.text:00001FFB                 mov     edx, [ebp+var_4]
.text:00001FFE                 mov     byte ptr [edx+2], 0
.text:00002002                 mov     eax, [ebp+var_4]
.text:00002005                 mov     esp, ebp
.text:00002007                 pop     ebp
.text:00002008                 retn
.text:00002008 ??0COpenSpecFlags@@QAE@XZ endp
.text:00002008
.text:00002008 ; ---------------------------------------------------------------------------
.text:00002009                 align 4
.text:00002009 _text           ends
.text:00002009
.text:0000200C ; ===========================================================================
.text:0000200C
.text:0000200C ; Segment type: Pure code
.text:0000200C ; Segment permissions: Read/Execute
.text:0000200C _text           segment para public 'CODE' use32
.text:0000200C                 assume cs:_text
.text:0000200C                 ;org 200Ch
.text:0000200C ; COMDAT (pick any)
.text:0000200C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000200C
.text:0000200C ; =============== S U B R O U T I N E =======================================
.text:0000200C
.text:0000200C ; Attributes: bp-based frame
.text:0000200C
.text:0000200C ; public: __thiscall CArchiveLink::CArchiveLink(void)
.text:0000200C                 public ??0CArchiveLink@@QAE@XZ
.text:0000200C ??0CArchiveLink@@QAE@XZ proc near       ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+44Bp
.text:0000200C
.text:0000200C var_10          = dword ptr -10h
.text:0000200C var_C           = dword ptr -0Ch
.text:0000200C var_4           = dword ptr -4
.text:0000200C
.text:0000200C                 push    ebp
.text:0000200D                 mov     ebp, esp
.text:0000200F                 push    0FFFFFFFFh
.text:00002011                 push    offset __ehhandler$??0CArchiveLink@@QAE@XZ
.text:00002016                 mov     eax, large fs:0
.text:0000201C                 push    eax
.text:0000201D                 push    ecx
.text:0000201E                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00002025                 mov     eax, dword ptr ds:___security_cookie
.text:0000202A                 xor     eax, ebp
.text:0000202C                 push    eax
.text:0000202D                 lea     eax, [ebp+var_C]
.text:00002030                 mov     large fs:0, eax
.text:00002036                 mov     [ebp+var_10], ecx
.text:00002039                 mov     ecx, [ebp+var_10]
.text:0000203C                 call    ??0?$CObjectVector@VCArc@@@@QAE@XZ ; CObjectVector<CArc>::CObjectVector<CArc>(void)
.text:00002041                 mov     [ebp+var_4], 0
.text:00002048                 mov     ecx, [ebp+var_10]
.text:0000204B                 add     ecx, 0Ch
.text:0000204E                 call    ??0?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::CObjectVector<UString>(void)
.text:00002053                 mov     byte ptr [ebp+var_4], 1
.text:00002057                 mov     eax, [ebp+var_10]
.text:0000205A                 mov     dword ptr [eax+18h], 0
.text:00002061                 mov     dword ptr [eax+1Ch], 0
.text:00002068                 mov     ecx, [ebp+var_10]
.text:0000206B                 mov     byte ptr [ecx+20h], 0
.text:0000206F                 mov     edx, [ebp+var_10]
.text:00002072                 mov     byte ptr [edx+21h], 0
.text:00002076                 mov     ecx, [ebp+var_10]
.text:00002079                 add     ecx, 24h ; '$'
.text:0000207C                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00002081                 mov     byte ptr [ebp+var_4], 2
.text:00002085                 mov     ecx, [ebp+var_10]
.text:00002088                 add     ecx, 30h ; '0'  ; this
.text:0000208B                 call    ??0CArcErrorInfo@@QAE@XZ ; CArcErrorInfo::CArcErrorInfo(void)
.text:00002090                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00002097                 mov     eax, [ebp+var_10]
.text:0000209A                 mov     ecx, [ebp+var_C]
.text:0000209D                 mov     large fs:0, ecx
.text:000020A4                 pop     ecx
.text:000020A5                 add     esp, 10h
.text:000020A8                 cmp     ebp, esp
.text:000020AA                 call    __RTC_CheckEsp
.text:000020AF                 mov     esp, ebp
.text:000020B1                 pop     ebp
.text:000020B2                 retn
.text:000020B2 ??0CArchiveLink@@QAE@XZ endp
.text:000020B2
.text:000020B2 ; ---------------------------------------------------------------------------
.text:000020B3                 align 4
.text:000020B3 _text           ends
.text:000020B3
.text$x:000020B4 ; ===========================================================================
.text$x:000020B4
.text$x:000020B4 ; Segment type: Pure code
.text$x:000020B4 ; Segment permissions: Read/Execute
.text$x:000020B4 _text$x         segment para public 'CODE' use32
.text$x:000020B4                 assume cs:_text$x
.text$x:000020B4                 ;org 20B4h
.text$x:000020B4 ; COMDAT (pick associative to section at 200C)
.text$x:000020B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000020B4
.text$x:000020B4 ; =============== S U B R O U T I N E =======================================
.text$x:000020B4
.text$x:000020B4
.text$x:000020B4 __unwindfunclet$??0CArchiveLink@@QAE@XZ$0 proc near
.text$x:000020B4                                         ; DATA XREF: .xdata$x:000020F4o
.text$x:000020B4                 mov     ecx, [ebp-10h]
.text$x:000020B7                 jmp     ??1?$CObjectVector@VCArc@@@@QAE@XZ ; CObjectVector<CArc>::~CObjectVector<CArc>(void)
.text$x:000020B7 __unwindfunclet$??0CArchiveLink@@QAE@XZ$0 endp
.text$x:000020B7
.text$x:000020BC
.text$x:000020BC ; =============== S U B R O U T I N E =======================================
.text$x:000020BC
.text$x:000020BC
.text$x:000020BC __unwindfunclet$??0CArchiveLink@@QAE@XZ$1 proc near
.text$x:000020BC                                         ; DATA XREF: .xdata$x:000020FCo
.text$x:000020BC                 mov     ecx, [ebp-10h]
.text$x:000020BF                 add     ecx, 0Ch
.text$x:000020C2                 jmp     ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text$x:000020C2 __unwindfunclet$??0CArchiveLink@@QAE@XZ$1 endp
.text$x:000020C2
.text$x:000020C7
.text$x:000020C7 ; =============== S U B R O U T I N E =======================================
.text$x:000020C7
.text$x:000020C7
.text$x:000020C7 __unwindfunclet$??0CArchiveLink@@QAE@XZ$2 proc near
.text$x:000020C7                                         ; DATA XREF: .xdata$x:00002104o
.text$x:000020C7                 mov     ecx, [ebp-10h]
.text$x:000020CA                 add     ecx, 24h ; '$'  ; this
.text$x:000020CD                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000020CD __unwindfunclet$??0CArchiveLink@@QAE@XZ$2 endp
.text$x:000020CD
.text$x:000020D2
.text$x:000020D2 ; =============== S U B R O U T I N E =======================================
.text$x:000020D2
.text$x:000020D2
.text$x:000020D2 __ehhandler$??0CArchiveLink@@QAE@XZ proc near
.text$x:000020D2                                         ; DATA XREF: CArchiveLink::CArchiveLink(void)+5o
.text$x:000020D2
.text$x:000020D2 arg_4           = dword ptr  8
.text$x:000020D2
.text$x:000020D2                 mov     edx, [esp+arg_4]
.text$x:000020D6                 lea     eax, [edx+0Ch]
.text$x:000020D9                 mov     ecx, [edx-8]
.text$x:000020DC                 xor     ecx, eax
.text$x:000020DE                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000020E3                 mov     eax, offset __ehfuncinfo$??0CArchiveLink@@QAE@XZ
.text$x:000020E8                 jmp     ___CxxFrameHandler3
.text$x:000020E8 __ehhandler$??0CArchiveLink@@QAE@XZ endp
.text$x:000020E8
.text$x:000020E8 ; ---------------------------------------------------------------------------
.text$x:000020ED                 align 10h
.text$x:000020ED _text$x         ends
.text$x:000020ED
.xdata$x:000020F0 ; ===========================================================================
.xdata$x:000020F0
.xdata$x:000020F0 ; Segment type: Pure data
.xdata$x:000020F0 ; Segment permissions: Read
.xdata$x:000020F0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000020F0                 assume cs:_xdata$x
.xdata$x:000020F0                 ;org 20F0h
.xdata$x:000020F0 ; COMDAT (pick associative to section at 200C)
.xdata$x:000020F0 __unwindtable$??0CArchiveLink@@QAE@XZ db 0FFh
.xdata$x:000020F0                                         ; DATA XREF: .xdata$x:00002110o
.xdata$x:000020F1                 db 0FFh
.xdata$x:000020F2                 db 0FFh
.xdata$x:000020F3                 db 0FFh
.xdata$x:000020F4                 dd offset __unwindfunclet$??0CArchiveLink@@QAE@XZ$0
.xdata$x:000020F8                 db    0
.xdata$x:000020F9                 db    0
.xdata$x:000020FA                 db    0
.xdata$x:000020FB                 db    0
.xdata$x:000020FC                 dd offset __unwindfunclet$??0CArchiveLink@@QAE@XZ$1
.xdata$x:00002100                 db    1
.xdata$x:00002101                 db    0
.xdata$x:00002102                 db    0
.xdata$x:00002103                 db    0
.xdata$x:00002104                 dd offset __unwindfunclet$??0CArchiveLink@@QAE@XZ$2
.xdata$x:00002108 __ehfuncinfo$??0CArchiveLink@@QAE@XZ db  22h ; "
.xdata$x:00002108                                         ; DATA XREF: __ehhandler$??0CArchiveLink@@QAE@XZ+11o
.xdata$x:00002109                 db    5
.xdata$x:0000210A                 db  93h ; Ã´
.xdata$x:0000210B                 db  19h
.xdata$x:0000210C                 db    3
.xdata$x:0000210D                 db    0
.xdata$x:0000210E                 db    0
.xdata$x:0000210F                 db    0
.xdata$x:00002110                 dd offset __unwindtable$??0CArchiveLink@@QAE@XZ
.xdata$x:00002114                 db    0
.xdata$x:00002115                 db    0
.xdata$x:00002116                 db    0
.xdata$x:00002117                 db    0
.xdata$x:00002118                 db    0
.xdata$x:00002119                 db    0
.xdata$x:0000211A                 db    0
.xdata$x:0000211B                 db    0
.xdata$x:0000211C                 db    0
.xdata$x:0000211D                 db    0
.xdata$x:0000211E                 db    0
.xdata$x:0000211F                 db    0
.xdata$x:00002120                 db    0
.xdata$x:00002121                 db    0
.xdata$x:00002122                 db    0
.xdata$x:00002123                 db    0
.xdata$x:00002124                 db    0
.xdata$x:00002125                 db    0
.xdata$x:00002126                 db    0
.xdata$x:00002127                 db    0
.xdata$x:00002128                 db    1
.xdata$x:00002129                 db    0
.xdata$x:0000212A                 db    0
.xdata$x:0000212B                 db    0
.xdata$x:0000212B _xdata$x        ends
.xdata$x:0000212B
.text:0000212C ; ===========================================================================
.text:0000212C
.text:0000212C ; Segment type: Pure code
.text:0000212C ; Segment permissions: Read/Execute
.text:0000212C _text           segment para public 'CODE' use32
.text:0000212C                 assume cs:_text
.text:0000212C                 ;org 212Ch
.text:0000212C ; COMDAT (pick any)
.text:0000212C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000212C
.text:0000212C ; =============== S U B R O U T I N E =======================================
.text:0000212C
.text:0000212C ; Attributes: bp-based frame
.text:0000212C
.text:0000212C ; _DWORD __thiscall CArcErrorInfo::CArcErrorInfo(CArcErrorInfo *__hidden this)
.text:0000212C                 public ??0CArcErrorInfo@@QAE@XZ
.text:0000212C ??0CArcErrorInfo@@QAE@XZ proc near      ; CODE XREF: CArchiveLink::CArchiveLink(void)+7Fp
.text:0000212C
.text:0000212C var_10          = dword ptr -10h
.text:0000212C var_C           = dword ptr -0Ch
.text:0000212C var_4           = dword ptr -4
.text:0000212C
.text:0000212C                 push    ebp
.text:0000212D                 mov     ebp, esp
.text:0000212F                 push    0FFFFFFFFh
.text:00002131                 push    offset __ehhandler$??0CArcErrorInfo@@QAE@XZ
.text:00002136                 mov     eax, large fs:0
.text:0000213C                 push    eax
.text:0000213D                 push    ecx
.text:0000213E                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00002145                 mov     eax, dword ptr ds:___security_cookie
.text:0000214A                 xor     eax, ebp
.text:0000214C                 push    eax
.text:0000214D                 lea     eax, [ebp+var_C]
.text:00002150                 mov     large fs:0, eax
.text:00002156                 mov     [ebp+var_10], ecx
.text:00002159                 mov     eax, [ebp+var_10]
.text:0000215C                 mov     byte ptr [eax], 0
.text:0000215F                 mov     ecx, [ebp+var_10]
.text:00002162                 mov     byte ptr [ecx+1], 0
.text:00002166                 mov     edx, [ebp+var_10]
.text:00002169                 mov     byte ptr [edx+2], 0
.text:0000216D                 mov     eax, [ebp+var_10]
.text:00002170                 mov     byte ptr [eax+3], 0
.text:00002174                 mov     ecx, [ebp+var_10]
.text:00002177                 mov     dword ptr [ecx+4], 0
.text:0000217E                 mov     edx, [ebp+var_10]
.text:00002181                 mov     dword ptr [edx+8], 0
.text:00002188                 mov     eax, [ebp+var_10]
.text:0000218B                 mov     dword ptr [eax+0Ch], 0FFFFFFFFh
.text:00002192                 mov     ecx, [ebp+var_10]
.text:00002195                 mov     dword ptr [ecx+10h], 0
.text:0000219C                 mov     dword ptr [ecx+14h], 0
.text:000021A3                 mov     ecx, [ebp+var_10]
.text:000021A6                 add     ecx, 18h
.text:000021A9                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:000021AE                 mov     [ebp+var_4], 0
.text:000021B5                 mov     ecx, [ebp+var_10]
.text:000021B8                 add     ecx, 24h ; '$'
.text:000021BB                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:000021C0                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000021C7                 mov     eax, [ebp+var_10]
.text:000021CA                 mov     ecx, [ebp+var_C]
.text:000021CD                 mov     large fs:0, ecx
.text:000021D4                 pop     ecx
.text:000021D5                 add     esp, 10h
.text:000021D8                 cmp     ebp, esp
.text:000021DA                 call    __RTC_CheckEsp
.text:000021DF                 mov     esp, ebp
.text:000021E1                 pop     ebp
.text:000021E2                 retn
.text:000021E2 ??0CArcErrorInfo@@QAE@XZ endp
.text:000021E2
.text:000021E2 ; ---------------------------------------------------------------------------
.text:000021E3                 align 4
.text:000021E3 _text           ends
.text:000021E3
.text$x:000021E4 ; ===========================================================================
.text$x:000021E4
.text$x:000021E4 ; Segment type: Pure code
.text$x:000021E4 ; Segment permissions: Read/Execute
.text$x:000021E4 _text$x         segment para public 'CODE' use32
.text$x:000021E4                 assume cs:_text$x
.text$x:000021E4                 ;org 21E4h
.text$x:000021E4 ; COMDAT (pick associative to section at 212C)
.text$x:000021E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000021E4
.text$x:000021E4 ; =============== S U B R O U T I N E =======================================
.text$x:000021E4
.text$x:000021E4
.text$x:000021E4 __unwindfunclet$??0CArcErrorInfo@@QAE@XZ$0 proc near
.text$x:000021E4                                         ; DATA XREF: .xdata$x:00002210o
.text$x:000021E4                 mov     ecx, [ebp-10h]
.text$x:000021E7                 add     ecx, 18h        ; this
.text$x:000021EA                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000021EA __unwindfunclet$??0CArcErrorInfo@@QAE@XZ$0 endp
.text$x:000021EA
.text$x:000021EF
.text$x:000021EF ; =============== S U B R O U T I N E =======================================
.text$x:000021EF
.text$x:000021EF
.text$x:000021EF __ehhandler$??0CArcErrorInfo@@QAE@XZ proc near
.text$x:000021EF                                         ; DATA XREF: CArcErrorInfo::CArcErrorInfo(void)+5o
.text$x:000021EF
.text$x:000021EF arg_4           = dword ptr  8
.text$x:000021EF
.text$x:000021EF                 mov     edx, [esp+arg_4]
.text$x:000021F3                 lea     eax, [edx+0Ch]
.text$x:000021F6                 mov     ecx, [edx-8]
.text$x:000021F9                 xor     ecx, eax
.text$x:000021FB                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002200                 mov     eax, offset __ehfuncinfo$??0CArcErrorInfo@@QAE@XZ
.text$x:00002205                 jmp     ___CxxFrameHandler3
.text$x:00002205 __ehhandler$??0CArcErrorInfo@@QAE@XZ endp
.text$x:00002205
.text$x:00002205 ; ---------------------------------------------------------------------------
.text$x:0000220A                 align 4
.text$x:0000220A _text$x         ends
.text$x:0000220A
.xdata$x:0000220C ; ===========================================================================
.xdata$x:0000220C
.xdata$x:0000220C ; Segment type: Pure data
.xdata$x:0000220C ; Segment permissions: Read
.xdata$x:0000220C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000220C                 assume cs:_xdata$x
.xdata$x:0000220C                 ;org 220Ch
.xdata$x:0000220C ; COMDAT (pick associative to section at 212C)
.xdata$x:0000220C __unwindtable$??0CArcErrorInfo@@QAE@XZ db 0FFh
.xdata$x:0000220C                                         ; DATA XREF: .xdata$x:0000221Co
.xdata$x:0000220D                 db 0FFh
.xdata$x:0000220E                 db 0FFh
.xdata$x:0000220F                 db 0FFh
.xdata$x:00002210                 dd offset __unwindfunclet$??0CArcErrorInfo@@QAE@XZ$0
.xdata$x:00002214 __ehfuncinfo$??0CArcErrorInfo@@QAE@XZ db  22h ; "
.xdata$x:00002214                                         ; DATA XREF: __ehhandler$??0CArcErrorInfo@@QAE@XZ+11o
.xdata$x:00002215                 db    5
.xdata$x:00002216                 db  93h ; Ã´
.xdata$x:00002217                 db  19h
.xdata$x:00002218                 db    1
.xdata$x:00002219                 db    0
.xdata$x:0000221A                 db    0
.xdata$x:0000221B                 db    0
.xdata$x:0000221C                 dd offset __unwindtable$??0CArcErrorInfo@@QAE@XZ
.xdata$x:00002220                 db    0
.xdata$x:00002221                 db    0
.xdata$x:00002222                 db    0
.xdata$x:00002223                 db    0
.xdata$x:00002224                 db    0
.xdata$x:00002225                 db    0
.xdata$x:00002226                 db    0
.xdata$x:00002227                 db    0
.xdata$x:00002228                 db    0
.xdata$x:00002229                 db    0
.xdata$x:0000222A                 db    0
.xdata$x:0000222B                 db    0
.xdata$x:0000222C                 db    0
.xdata$x:0000222D                 db    0
.xdata$x:0000222E                 db    0
.xdata$x:0000222F                 db    0
.xdata$x:00002230                 db    0
.xdata$x:00002231                 db    0
.xdata$x:00002232                 db    0
.xdata$x:00002233                 db    0
.xdata$x:00002234                 db    1
.xdata$x:00002235                 db    0
.xdata$x:00002236                 db    0
.xdata$x:00002237                 db    0
.xdata$x:00002237 _xdata$x        ends
.xdata$x:00002237
.text:00002238 ; ===========================================================================
.text:00002238
.text:00002238 ; Segment type: Pure code
.text:00002238 ; Segment permissions: Read/Execute
.text:00002238 _text           segment para public 'CODE' use32
.text:00002238                 assume cs:_text
.text:00002238                 ;org 2238h
.text:00002238 ; COMDAT (pick any)
.text:00002238                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002238
.text:00002238 ; =============== S U B R O U T I N E =======================================
.text:00002238
.text:00002238 ; Attributes: bp-based frame
.text:00002238
.text:00002238 ; _DWORD __thiscall CArchiveLink::~CArchiveLink(CArchiveLink *__hidden this)
.text:00002238                 public ??1CArchiveLink@@QAE@XZ
.text:00002238 ??1CArchiveLink@@QAE@XZ proc near       ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+524p
.text:00002238                                         ; Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+600p ...
.text:00002238
.text:00002238 var_10          = dword ptr -10h
.text:00002238 var_C           = dword ptr -0Ch
.text:00002238 var_4           = dword ptr -4
.text:00002238
.text:00002238                 push    ebp
.text:00002239                 mov     ebp, esp
.text:0000223B                 push    0FFFFFFFFh
.text:0000223D                 push    offset __ehhandler$??1CArchiveLink@@QAE@XZ
.text:00002242                 mov     eax, large fs:0
.text:00002248                 push    eax
.text:00002249                 push    ecx
.text:0000224A                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00002251                 mov     eax, dword ptr ds:___security_cookie
.text:00002256                 xor     eax, ebp
.text:00002258                 push    eax
.text:00002259                 lea     eax, [ebp+var_C]
.text:0000225C                 mov     large fs:0, eax
.text:00002262                 mov     [ebp+var_10], ecx
.text:00002265                 mov     [ebp+var_4], 3
.text:0000226C                 mov     ecx, [ebp+var_10] ; this
.text:0000226F                 call    ?Release@CArchiveLink@@QAEXXZ ; CArchiveLink::Release(void)
.text:00002274                 mov     byte ptr [ebp+var_4], 2
.text:00002278                 mov     ecx, [ebp+var_10]
.text:0000227B                 add     ecx, 30h ; '0'  ; this
.text:0000227E                 call    ??1CArcErrorInfo@@QAE@XZ ; CArcErrorInfo::~CArcErrorInfo(void)
.text:00002283                 mov     byte ptr [ebp+var_4], 1
.text:00002287                 mov     ecx, [ebp+var_10]
.text:0000228A                 add     ecx, 24h ; '$'  ; this
.text:0000228D                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00002292                 mov     byte ptr [ebp+var_4], 0
.text:00002296                 mov     ecx, [ebp+var_10]
.text:00002299                 add     ecx, 0Ch
.text:0000229C                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:000022A1                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000022A8                 mov     ecx, [ebp+var_10]
.text:000022AB                 call    ??1?$CObjectVector@VCArc@@@@QAE@XZ ; CObjectVector<CArc>::~CObjectVector<CArc>(void)
.text:000022B0                 mov     ecx, [ebp+var_C]
.text:000022B3                 mov     large fs:0, ecx
.text:000022BA                 pop     ecx
.text:000022BB                 add     esp, 10h
.text:000022BE                 cmp     ebp, esp
.text:000022C0                 call    __RTC_CheckEsp
.text:000022C5                 mov     esp, ebp
.text:000022C7                 pop     ebp
.text:000022C8                 retn
.text:000022C8 ??1CArchiveLink@@QAE@XZ endp
.text:000022C8
.text:000022C8 ; ---------------------------------------------------------------------------
.text:000022C9                 align 4
.text:000022C9 _text           ends
.text:000022C9
.text$x:000022CC ; ===========================================================================
.text$x:000022CC
.text$x:000022CC ; Segment type: Pure code
.text$x:000022CC ; Segment permissions: Read/Execute
.text$x:000022CC _text$x         segment para public 'CODE' use32
.text$x:000022CC                 assume cs:_text$x
.text$x:000022CC                 ;org 22CCh
.text$x:000022CC ; COMDAT (pick associative to section at 2238)
.text$x:000022CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000022CC
.text$x:000022CC ; =============== S U B R O U T I N E =======================================
.text$x:000022CC
.text$x:000022CC
.text$x:000022CC __unwindfunclet$??1CArchiveLink@@QAE@XZ$0 proc near
.text$x:000022CC                                         ; DATA XREF: .xdata$x:00002314o
.text$x:000022CC                 mov     ecx, [ebp-10h]
.text$x:000022CF                 jmp     ??1?$CObjectVector@VCArc@@@@QAE@XZ ; CObjectVector<CArc>::~CObjectVector<CArc>(void)
.text$x:000022CF __unwindfunclet$??1CArchiveLink@@QAE@XZ$0 endp
.text$x:000022CF
.text$x:000022D4
.text$x:000022D4 ; =============== S U B R O U T I N E =======================================
.text$x:000022D4
.text$x:000022D4
.text$x:000022D4 __unwindfunclet$??1CArchiveLink@@QAE@XZ$1 proc near
.text$x:000022D4                                         ; DATA XREF: .xdata$x:0000231Co
.text$x:000022D4                 mov     ecx, [ebp-10h]
.text$x:000022D7                 add     ecx, 0Ch
.text$x:000022DA                 jmp     ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text$x:000022DA __unwindfunclet$??1CArchiveLink@@QAE@XZ$1 endp
.text$x:000022DA
.text$x:000022DF
.text$x:000022DF ; =============== S U B R O U T I N E =======================================
.text$x:000022DF
.text$x:000022DF
.text$x:000022DF __unwindfunclet$??1CArchiveLink@@QAE@XZ$2 proc near
.text$x:000022DF                                         ; DATA XREF: .xdata$x:00002324o
.text$x:000022DF                 mov     ecx, [ebp-10h]
.text$x:000022E2                 add     ecx, 24h ; '$'  ; this
.text$x:000022E5                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000022E5 __unwindfunclet$??1CArchiveLink@@QAE@XZ$2 endp
.text$x:000022E5
.text$x:000022EA
.text$x:000022EA ; =============== S U B R O U T I N E =======================================
.text$x:000022EA
.text$x:000022EA
.text$x:000022EA __unwindfunclet$??1CArchiveLink@@QAE@XZ$3 proc near
.text$x:000022EA                                         ; DATA XREF: .xdata$x:0000232Co
.text$x:000022EA                 mov     ecx, [ebp-10h]
.text$x:000022ED                 add     ecx, 30h ; '0'  ; this
.text$x:000022F0                 jmp     ??1CArcErrorInfo@@QAE@XZ ; CArcErrorInfo::~CArcErrorInfo(void)
.text$x:000022F0 __unwindfunclet$??1CArchiveLink@@QAE@XZ$3 endp
.text$x:000022F0
.text$x:000022F5
.text$x:000022F5 ; =============== S U B R O U T I N E =======================================
.text$x:000022F5
.text$x:000022F5
.text$x:000022F5 __ehhandler$??1CArchiveLink@@QAE@XZ proc near
.text$x:000022F5                                         ; DATA XREF: CArchiveLink::~CArchiveLink(void)+5o
.text$x:000022F5
.text$x:000022F5 arg_4           = dword ptr  8
.text$x:000022F5
.text$x:000022F5                 mov     edx, [esp+arg_4]
.text$x:000022F9                 lea     eax, [edx+0Ch]
.text$x:000022FC                 mov     ecx, [edx-8]
.text$x:000022FF                 xor     ecx, eax
.text$x:00002301                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002306                 mov     eax, offset __ehfuncinfo$??1CArchiveLink@@QAE@XZ
.text$x:0000230B                 jmp     ___CxxFrameHandler3
.text$x:0000230B __ehhandler$??1CArchiveLink@@QAE@XZ endp
.text$x:0000230B
.text$x:0000230B _text$x         ends
.text$x:0000230B
.xdata$x:00002310 ; ===========================================================================
.xdata$x:00002310
.xdata$x:00002310 ; Segment type: Pure data
.xdata$x:00002310 ; Segment permissions: Read
.xdata$x:00002310 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002310                 assume cs:_xdata$x
.xdata$x:00002310                 ;org 2310h
.xdata$x:00002310 ; COMDAT (pick associative to section at 2238)
.xdata$x:00002310 __unwindtable$??1CArchiveLink@@QAE@XZ db 0FFh
.xdata$x:00002310                                         ; DATA XREF: .xdata$x:00002338o
.xdata$x:00002311                 db 0FFh
.xdata$x:00002312                 db 0FFh
.xdata$x:00002313                 db 0FFh
.xdata$x:00002314                 dd offset __unwindfunclet$??1CArchiveLink@@QAE@XZ$0
.xdata$x:00002318                 db    0
.xdata$x:00002319                 db    0
.xdata$x:0000231A                 db    0
.xdata$x:0000231B                 db    0
.xdata$x:0000231C                 dd offset __unwindfunclet$??1CArchiveLink@@QAE@XZ$1
.xdata$x:00002320                 db    1
.xdata$x:00002321                 db    0
.xdata$x:00002322                 db    0
.xdata$x:00002323                 db    0
.xdata$x:00002324                 dd offset __unwindfunclet$??1CArchiveLink@@QAE@XZ$2
.xdata$x:00002328                 db    2
.xdata$x:00002329                 db    0
.xdata$x:0000232A                 db    0
.xdata$x:0000232B                 db    0
.xdata$x:0000232C                 dd offset __unwindfunclet$??1CArchiveLink@@QAE@XZ$3
.xdata$x:00002330 __ehfuncinfo$??1CArchiveLink@@QAE@XZ db  22h ; "
.xdata$x:00002330                                         ; DATA XREF: __ehhandler$??1CArchiveLink@@QAE@XZ+11o
.xdata$x:00002331                 db    5
.xdata$x:00002332                 db  93h ; Ã´
.xdata$x:00002333                 db  19h
.xdata$x:00002334                 db    4
.xdata$x:00002335                 db    0
.xdata$x:00002336                 db    0
.xdata$x:00002337                 db    0
.xdata$x:00002338                 dd offset __unwindtable$??1CArchiveLink@@QAE@XZ
.xdata$x:0000233C                 db    0
.xdata$x:0000233D                 db    0
.xdata$x:0000233E                 db    0
.xdata$x:0000233F                 db    0
.xdata$x:00002340                 db    0
.xdata$x:00002341                 db    0
.xdata$x:00002342                 db    0
.xdata$x:00002343                 db    0
.xdata$x:00002344                 db    0
.xdata$x:00002345                 db    0
.xdata$x:00002346                 db    0
.xdata$x:00002347                 db    0
.xdata$x:00002348                 db    0
.xdata$x:00002349                 db    0
.xdata$x:0000234A                 db    0
.xdata$x:0000234B                 db    0
.xdata$x:0000234C                 db    0
.xdata$x:0000234D                 db    0
.xdata$x:0000234E                 db    0
.xdata$x:0000234F                 db    0
.xdata$x:00002350                 db    1
.xdata$x:00002351                 db    0
.xdata$x:00002352                 db    0
.xdata$x:00002353                 db    0
.xdata$x:00002353 _xdata$x        ends
.xdata$x:00002353
.text:00002354 ; ===========================================================================
.text:00002354
.text:00002354 ; Segment type: Pure code
.text:00002354 ; Segment permissions: Read/Execute
.text:00002354 _text           segment para public 'CODE' use32
.text:00002354                 assume cs:_text
.text:00002354                 ;org 2354h
.text:00002354 ; COMDAT (pick any)
.text:00002354                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002354
.text:00002354 ; =============== S U B R O U T I N E =======================================
.text:00002354
.text:00002354 ; Attributes: bp-based frame
.text:00002354
.text:00002354 ; _DWORD __thiscall CArcErrorInfo::~CArcErrorInfo(CArcErrorInfo *__hidden this)
.text:00002354                 public ??1CArcErrorInfo@@QAE@XZ
.text:00002354 ??1CArcErrorInfo@@QAE@XZ proc near      ; CODE XREF: CArchiveLink::~CArchiveLink(void)+46p
.text:00002354                                         ; __unwindfunclet$??1CArchiveLink@@QAE@XZ$3+6j ...
.text:00002354
.text:00002354 var_10          = dword ptr -10h
.text:00002354 var_C           = dword ptr -0Ch
.text:00002354 var_4           = dword ptr -4
.text:00002354
.text:00002354                 push    ebp
.text:00002355                 mov     ebp, esp
.text:00002357                 push    0FFFFFFFFh
.text:00002359                 push    offset __ehhandler$??1CArcErrorInfo@@QAE@XZ
.text:0000235E                 mov     eax, large fs:0
.text:00002364                 push    eax
.text:00002365                 push    ecx
.text:00002366                 mov     [ebp+var_10], 0CCCCCCCCh
.text:0000236D                 mov     eax, dword ptr ds:___security_cookie
.text:00002372                 xor     eax, ebp
.text:00002374                 push    eax
.text:00002375                 lea     eax, [ebp+var_C]
.text:00002378                 mov     large fs:0, eax
.text:0000237E                 mov     [ebp+var_10], ecx
.text:00002381                 mov     [ebp+var_4], 0
.text:00002388                 mov     ecx, [ebp+var_10]
.text:0000238B                 add     ecx, 24h ; '$'  ; this
.text:0000238E                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00002393                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000239A                 mov     ecx, [ebp+var_10]
.text:0000239D                 add     ecx, 18h        ; this
.text:000023A0                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:000023A5                 mov     ecx, [ebp+var_C]
.text:000023A8                 mov     large fs:0, ecx
.text:000023AF                 pop     ecx
.text:000023B0                 add     esp, 10h
.text:000023B3                 cmp     ebp, esp
.text:000023B5                 call    __RTC_CheckEsp
.text:000023BA                 mov     esp, ebp
.text:000023BC                 pop     ebp
.text:000023BD                 retn
.text:000023BD ??1CArcErrorInfo@@QAE@XZ endp
.text:000023BD
.text:000023BD ; ---------------------------------------------------------------------------
.text:000023BE                 align 10h
.text:000023BE _text           ends
.text:000023BE
.text$x:000023C0 ; ===========================================================================
.text$x:000023C0
.text$x:000023C0 ; Segment type: Pure code
.text$x:000023C0 ; Segment permissions: Read/Execute
.text$x:000023C0 _text$x         segment para public 'CODE' use32
.text$x:000023C0                 assume cs:_text$x
.text$x:000023C0                 ;org 23C0h
.text$x:000023C0 ; COMDAT (pick associative to section at 2354)
.text$x:000023C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000023C0
.text$x:000023C0 ; =============== S U B R O U T I N E =======================================
.text$x:000023C0
.text$x:000023C0
.text$x:000023C0 __unwindfunclet$??1CArcErrorInfo@@QAE@XZ$0 proc near
.text$x:000023C0                                         ; DATA XREF: .xdata$x:000023ECo
.text$x:000023C0                 mov     ecx, [ebp-10h]
.text$x:000023C3                 add     ecx, 18h        ; this
.text$x:000023C6                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:000023C6 __unwindfunclet$??1CArcErrorInfo@@QAE@XZ$0 endp
.text$x:000023C6
.text$x:000023CB
.text$x:000023CB ; =============== S U B R O U T I N E =======================================
.text$x:000023CB
.text$x:000023CB
.text$x:000023CB __ehhandler$??1CArcErrorInfo@@QAE@XZ proc near
.text$x:000023CB                                         ; DATA XREF: CArcErrorInfo::~CArcErrorInfo(void)+5o
.text$x:000023CB
.text$x:000023CB arg_4           = dword ptr  8
.text$x:000023CB
.text$x:000023CB                 mov     edx, [esp+arg_4]
.text$x:000023CF                 lea     eax, [edx+0Ch]
.text$x:000023D2                 mov     ecx, [edx-8]
.text$x:000023D5                 xor     ecx, eax
.text$x:000023D7                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000023DC                 mov     eax, offset __ehfuncinfo$??1CArcErrorInfo@@QAE@XZ
.text$x:000023E1                 jmp     ___CxxFrameHandler3
.text$x:000023E1 __ehhandler$??1CArcErrorInfo@@QAE@XZ endp
.text$x:000023E1
.text$x:000023E1 ; ---------------------------------------------------------------------------
.text$x:000023E6                 align 4
.text$x:000023E6 _text$x         ends
.text$x:000023E6
.xdata$x:000023E8 ; ===========================================================================
.xdata$x:000023E8
.xdata$x:000023E8 ; Segment type: Pure data
.xdata$x:000023E8 ; Segment permissions: Read
.xdata$x:000023E8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000023E8                 assume cs:_xdata$x
.xdata$x:000023E8                 ;org 23E8h
.xdata$x:000023E8 ; COMDAT (pick associative to section at 2354)
.xdata$x:000023E8 __unwindtable$??1CArcErrorInfo@@QAE@XZ db 0FFh
.xdata$x:000023E8                                         ; DATA XREF: .xdata$x:000023F8o
.xdata$x:000023E9                 db 0FFh
.xdata$x:000023EA                 db 0FFh
.xdata$x:000023EB                 db 0FFh
.xdata$x:000023EC                 dd offset __unwindfunclet$??1CArcErrorInfo@@QAE@XZ$0
.xdata$x:000023F0 __ehfuncinfo$??1CArcErrorInfo@@QAE@XZ db  22h ; "
.xdata$x:000023F0                                         ; DATA XREF: __ehhandler$??1CArcErrorInfo@@QAE@XZ+11o
.xdata$x:000023F1                 db    5
.xdata$x:000023F2                 db  93h ; Ã´
.xdata$x:000023F3                 db  19h
.xdata$x:000023F4                 db    1
.xdata$x:000023F5                 db    0
.xdata$x:000023F6                 db    0
.xdata$x:000023F7                 db    0
.xdata$x:000023F8                 dd offset __unwindtable$??1CArcErrorInfo@@QAE@XZ
.xdata$x:000023FC                 db    0
.xdata$x:000023FD                 db    0
.xdata$x:000023FE                 db    0
.xdata$x:000023FF                 db    0
.xdata$x:00002400                 db    0
.xdata$x:00002401                 db    0
.xdata$x:00002402                 db    0
.xdata$x:00002403                 db    0
.xdata$x:00002404                 db    0
.xdata$x:00002405                 db    0
.xdata$x:00002406                 db    0
.xdata$x:00002407                 db    0
.xdata$x:00002408                 db    0
.xdata$x:00002409                 db    0
.xdata$x:0000240A                 db    0
.xdata$x:0000240B                 db    0
.xdata$x:0000240C                 db    0
.xdata$x:0000240D                 db    0
.xdata$x:0000240E                 db    0
.xdata$x:0000240F                 db    0
.xdata$x:00002410                 db    1
.xdata$x:00002411                 db    0
.xdata$x:00002412                 db    0
.xdata$x:00002413                 db    0
.xdata$x:00002413 _xdata$x        ends
.xdata$x:00002413
.text:00002414 ; ===========================================================================
.text:00002414
.text:00002414 ; Segment type: Pure code
.text:00002414 ; Segment permissions: Read/Execute
.text:00002414 _text           segment para public 'CODE' use32
.text:00002414                 assume cs:_text
.text:00002414                 ;org 2414h
.text:00002414 ; COMDAT (pick any)
.text:00002414                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002414
.text:00002414 ; =============== S U B R O U T I N E =======================================
.text:00002414
.text:00002414 ; Attributes: bp-based frame
.text:00002414
.text:00002414 ; public: void __thiscall CArchiveExtractCallback::InitForMulti(bool, enum  NExtract::NPathMode::EEnum, enum  NExtract::NOverwriteMode::EEnum)
.text:00002414                 public ?InitForMulti@CArchiveExtractCallback@@QAEX_NW4EEnum@NPathMode@NExtract@@W42NOverwriteMode@4@@Z
.text:00002414 ?InitForMulti@CArchiveExtractCallback@@QAEX_NW4EEnum@NPathMode@NExtract@@W42NOverwriteMode@4@@Z proc near
.text:00002414                                         ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+249p
.text:00002414
.text:00002414 var_4           = dword ptr -4
.text:00002414 arg_0           = byte ptr  8
.text:00002414 arg_4           = dword ptr  0Ch
.text:00002414 arg_8           = dword ptr  10h
.text:00002414
.text:00002414                 push    ebp
.text:00002415                 mov     ebp, esp
.text:00002417                 push    ecx
.text:00002418                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000241F                 mov     [ebp+var_4], ecx
.text:00002422                 mov     eax, [ebp+var_4]
.text:00002425                 mov     cl, [ebp+arg_0]
.text:00002428                 mov     [eax+126h], cl
.text:0000242E                 mov     edx, [ebp+var_4]
.text:00002431                 mov     eax, [ebp+arg_4]
.text:00002434                 mov     [edx+54h], eax
.text:00002437                 mov     ecx, [ebp+var_4]
.text:0000243A                 mov     edx, [ebp+arg_8]
.text:0000243D                 mov     [ecx+58h], edx
.text:00002440                 mov     eax, [ebp+var_4]
.text:00002443                 mov     dword ptr [eax+188h], 0
.text:0000244D                 mov     dword ptr [eax+18Ch], 0
.text:00002457                 mov     ecx, [ebp+var_4]
.text:0000245A                 mov     dword ptr [ecx+180h], 0
.text:00002464                 mov     dword ptr [ecx+184h], 0
.text:0000246E                 mov     edx, [ebp+var_4]
.text:00002471                 mov     dword ptr [edx+178h], 0
.text:0000247B                 mov     dword ptr [edx+17Ch], 0
.text:00002485                 mov     eax, [ebp+var_4]
.text:00002488                 mov     dword ptr [eax+170h], 0
.text:00002492                 mov     dword ptr [eax+174h], 0
.text:0000249C                 mov     ecx, [ebp+var_4]
.text:0000249F                 mov     dword ptr [ecx+168h], 0
.text:000024A9                 mov     dword ptr [ecx+16Ch], 0
.text:000024B3                 mov     esp, ebp
.text:000024B5                 pop     ebp
.text:000024B6                 retn    0Ch
.text:000024B6 ?InitForMulti@CArchiveExtractCallback@@QAEX_NW4EEnum@NPathMode@NExtract@@W42NOverwriteMode@4@@Z endp
.text:000024B6
.text:000024B6 ; ---------------------------------------------------------------------------
.text:000024B9                 align 4
.text:000024B9 _text           ends
.text:000024B9
.text:000024BC ; ===========================================================================
.text:000024BC
.text:000024BC ; Segment type: Pure code
.text:000024BC ; Segment permissions: Read/Execute
.text:000024BC _text           segment para public 'CODE' use32
.text:000024BC                 assume cs:_text
.text:000024BC                 ;org 24BCh
.text:000024BC ; COMDAT (pick any)
.text:000024BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000024BC
.text:000024BC ; =============== S U B R O U T I N E =======================================
.text:000024BC
.text:000024BC ; Attributes: bp-based frame
.text:000024BC
.text:000024BC ; void __thiscall CArchiveExtractCallback::SetHashMethods(CArchiveExtractCallback *this, struct IHashCalc *)
.text:000024BC                 public ?SetHashMethods@CArchiveExtractCallback@@QAEXPAUIHashCalc@@@Z
.text:000024BC ?SetHashMethods@CArchiveExtractCallback@@QAEXPAUIHashCalc@@@Z proc near
.text:000024BC                                         ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+258p
.text:000024BC
.text:000024BC var_1C          = dword ptr -1Ch
.text:000024BC var_18          = dword ptr -18h
.text:000024BC var_14          = dword ptr -14h
.text:000024BC var_10          = dword ptr -10h
.text:000024BC var_C           = dword ptr -0Ch
.text:000024BC var_4           = dword ptr -4
.text:000024BC arg_0           = dword ptr  8
.text:000024BC
.text:000024BC                 push    ebp
.text:000024BD                 mov     ebp, esp
.text:000024BF                 push    0FFFFFFFFh
.text:000024C1                 push    offset __ehhandler$?SetHashMethods@CArchiveExtractCallback@@QAEXPAUIHashCalc@@@Z
.text:000024C6                 mov     eax, large fs:0
.text:000024CC                 push    eax
.text:000024CD                 sub     esp, 10h
.text:000024D0                 mov     eax, 0CCCCCCCCh
.text:000024D5                 mov     [ebp+var_1C], eax
.text:000024D8                 mov     [ebp+var_18], eax
.text:000024DB                 mov     [ebp+var_14], eax
.text:000024DE                 mov     [ebp+var_10], eax
.text:000024E1                 mov     eax, dword ptr ds:___security_cookie
.text:000024E6                 xor     eax, ebp
.text:000024E8                 push    eax
.text:000024E9                 lea     eax, [ebp+var_C]
.text:000024EC                 mov     large fs:0, eax
.text:000024F2                 mov     [ebp+var_10], ecx
.text:000024F5                 cmp     [ebp+arg_0], 0
.text:000024F9                 jnz     short loc_24FD
.text:000024FB                 jmp     short loc_256B
.text:000024FD ; ---------------------------------------------------------------------------
.text:000024FD
.text:000024FD loc_24FD:                               ; CODE XREF: CArchiveExtractCallback::SetHashMethods(IHashCalc *)+3Dj
.text:000024FD                 push    20h ; ' '       ; unsigned int
.text:000024FF                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00002504                 add     esp, 4
.text:00002507                 mov     [ebp+var_18], eax
.text:0000250A                 mov     [ebp+var_4], 0
.text:00002511                 cmp     [ebp+var_18], 0
.text:00002515                 jz      short loc_2524
.text:00002517                 mov     ecx, [ebp+var_18]
.text:0000251A                 call    ??0COutStreamWithHash@@QAE@XZ ; COutStreamWithHash::COutStreamWithHash(void)
.text:0000251F                 mov     [ebp+var_1C], eax
.text:00002522                 jmp     short loc_252B
.text:00002524 ; ---------------------------------------------------------------------------
.text:00002524
.text:00002524 loc_2524:                               ; CODE XREF: CArchiveExtractCallback::SetHashMethods(IHashCalc *)+59j
.text:00002524                 mov     [ebp+var_1C], 0
.text:0000252B
.text:0000252B loc_252B:                               ; CODE XREF: CArchiveExtractCallback::SetHashMethods(IHashCalc *)+66j
.text:0000252B                 mov     eax, [ebp+var_1C]
.text:0000252E                 mov     [ebp+var_14], eax
.text:00002531                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00002538                 mov     ecx, [ebp+var_10]
.text:0000253B                 mov     edx, [ebp+var_14]
.text:0000253E                 mov     [ecx+104h], edx
.text:00002544                 mov     eax, [ebp+var_10]
.text:00002547                 mov     ecx, [eax+104h]
.text:0000254D                 push    ecx
.text:0000254E                 mov     ecx, [ebp+var_10]
.text:00002551                 add     ecx, 108h
.text:00002557                 call    ??4?$CMyComPtr@UISequentialOutStream@@@@QAEPAUISequentialOutStream@@PAU1@@Z ; CMyComPtr<ISequentialOutStream>::operator=(ISequentialOutStream *)
.text:0000255C                 mov     edx, [ebp+var_10]
.text:0000255F                 mov     eax, [edx+104h]
.text:00002565                 mov     ecx, [ebp+arg_0]
.text:00002568                 mov     [eax+1Ch], ecx
.text:0000256B
.text:0000256B loc_256B:                               ; CODE XREF: CArchiveExtractCallback::SetHashMethods(IHashCalc *)+3Fj
.text:0000256B                 mov     ecx, [ebp+var_C]
.text:0000256E                 mov     large fs:0, ecx
.text:00002575                 pop     ecx
.text:00002576                 add     esp, 1Ch
.text:00002579                 cmp     ebp, esp
.text:0000257B                 call    __RTC_CheckEsp
.text:00002580                 mov     esp, ebp
.text:00002582                 pop     ebp
.text:00002583                 retn    4
.text:00002583 ?SetHashMethods@CArchiveExtractCallback@@QAEXPAUIHashCalc@@@Z endp
.text:00002583
.text:00002583 ; ---------------------------------------------------------------------------
.text:00002586                 align 4
.text:00002586 _text           ends
.text:00002586
.text$x:00002588 ; ===========================================================================
.text$x:00002588
.text$x:00002588 ; Segment type: Pure code
.text$x:00002588 ; Segment permissions: Read/Execute
.text$x:00002588 _text$x         segment para public 'CODE' use32
.text$x:00002588                 assume cs:_text$x
.text$x:00002588                 ;org 2588h
.text$x:00002588 ; COMDAT (pick associative to section at 24BC)
.text$x:00002588                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002588
.text$x:00002588 ; =============== S U B R O U T I N E =======================================
.text$x:00002588
.text$x:00002588
.text$x:00002588 __unwindfunclet$?SetHashMethods@CArchiveExtractCallback@@QAEXPAUIHashCalc@@@Z$0 proc near
.text$x:00002588                                         ; DATA XREF: .xdata$x:000025B4o
.text$x:00002588                 mov     eax, [ebp-18h]
.text$x:0000258B                 push    eax             ; void *
.text$x:0000258C                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00002591                 pop     ecx
.text$x:00002592                 retn
.text$x:00002592 __unwindfunclet$?SetHashMethods@CArchiveExtractCallback@@QAEXPAUIHashCalc@@@Z$0 endp
.text$x:00002592
.text$x:00002593
.text$x:00002593 ; =============== S U B R O U T I N E =======================================
.text$x:00002593
.text$x:00002593
.text$x:00002593 __ehhandler$?SetHashMethods@CArchiveExtractCallback@@QAEXPAUIHashCalc@@@Z proc near
.text$x:00002593                                         ; DATA XREF: CArchiveExtractCallback::SetHashMethods(IHashCalc *)+5o
.text$x:00002593
.text$x:00002593 arg_4           = dword ptr  8
.text$x:00002593
.text$x:00002593                 mov     edx, [esp+arg_4]
.text$x:00002597                 lea     eax, [edx+0Ch]
.text$x:0000259A                 mov     ecx, [edx-14h]
.text$x:0000259D                 xor     ecx, eax
.text$x:0000259F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000025A4                 mov     eax, offset __ehfuncinfo$?SetHashMethods@CArchiveExtractCallback@@QAEXPAUIHashCalc@@@Z
.text$x:000025A9                 jmp     ___CxxFrameHandler3
.text$x:000025A9 __ehhandler$?SetHashMethods@CArchiveExtractCallback@@QAEXPAUIHashCalc@@@Z endp
.text$x:000025A9
.text$x:000025A9 ; ---------------------------------------------------------------------------
.text$x:000025AE                 align 10h
.text$x:000025AE _text$x         ends
.text$x:000025AE
.xdata$x:000025B0 ; ===========================================================================
.xdata$x:000025B0
.xdata$x:000025B0 ; Segment type: Pure data
.xdata$x:000025B0 ; Segment permissions: Read
.xdata$x:000025B0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000025B0                 assume cs:_xdata$x
.xdata$x:000025B0                 ;org 25B0h
.xdata$x:000025B0 ; COMDAT (pick associative to section at 24BC)
.xdata$x:000025B0 __unwindtable$?SetHashMethods@CArchiveExtractCallback@@QAEXPAUIHashCalc@@@Z db 0FFh
.xdata$x:000025B0                                         ; DATA XREF: .xdata$x:000025C0o
.xdata$x:000025B1                 db 0FFh
.xdata$x:000025B2                 db 0FFh
.xdata$x:000025B3                 db 0FFh
.xdata$x:000025B4                 dd offset __unwindfunclet$?SetHashMethods@CArchiveExtractCallback@@QAEXPAUIHashCalc@@@Z$0
.xdata$x:000025B8 __ehfuncinfo$?SetHashMethods@CArchiveExtractCallback@@QAEXPAUIHashCalc@@@Z db  22h ; "
.xdata$x:000025B8                                         ; DATA XREF: __ehhandler$?SetHashMethods@CArchiveExtractCallback@@QAEXPAUIHashCalc@@@Z+11o
.xdata$x:000025B9                 db    5
.xdata$x:000025BA                 db  93h ; Ã´
.xdata$x:000025BB                 db  19h
.xdata$x:000025BC                 db    1
.xdata$x:000025BD                 db    0
.xdata$x:000025BE                 db    0
.xdata$x:000025BF                 db    0
.xdata$x:000025C0                 dd offset __unwindtable$?SetHashMethods@CArchiveExtractCallback@@QAEXPAUIHashCalc@@@Z
.xdata$x:000025C4                 db    0
.xdata$x:000025C5                 db    0
.xdata$x:000025C6                 db    0
.xdata$x:000025C7                 db    0
.xdata$x:000025C8                 db    0
.xdata$x:000025C9                 db    0
.xdata$x:000025CA                 db    0
.xdata$x:000025CB                 db    0
.xdata$x:000025CC                 db    0
.xdata$x:000025CD                 db    0
.xdata$x:000025CE                 db    0
.xdata$x:000025CF                 db    0
.xdata$x:000025D0                 db    0
.xdata$x:000025D1                 db    0
.xdata$x:000025D2                 db    0
.xdata$x:000025D3                 db    0
.xdata$x:000025D4                 db    0
.xdata$x:000025D5                 db    0
.xdata$x:000025D6                 db    0
.xdata$x:000025D7                 db    0
.xdata$x:000025D8                 db    1
.xdata$x:000025D9                 db    0
.xdata$x:000025DA                 db    0
.xdata$x:000025DB                 db    0
.xdata$x:000025DB _xdata$x        ends
.xdata$x:000025DB
.text:000025DC ; ===========================================================================
.text:000025DC
.text:000025DC ; Segment type: Pure code
.text:000025DC ; Segment permissions: Read/Execute
.text:000025DC _text           segment para public 'CODE' use32
.text:000025DC                 assume cs:_text
.text:000025DC                 ;org 25DCh
.text:000025DC ; COMDAT (pick any)
.text:000025DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000025DC
.text:000025DC ; =============== S U B R O U T I N E =======================================
.text:000025DC
.text:000025DC ; Attributes: bp-based frame
.text:000025DC
.text:000025DC ; public: __thiscall COutStreamWithHash::COutStreamWithHash(void)
.text:000025DC                 public ??0COutStreamWithHash@@QAE@XZ
.text:000025DC ??0COutStreamWithHash@@QAE@XZ proc near ; CODE XREF: CArchiveExtractCallback::SetHashMethods(IHashCalc *)+5Ep
.text:000025DC
.text:000025DC var_4           = dword ptr -4
.text:000025DC
.text:000025DC                 push    ebp
.text:000025DD                 mov     ebp, esp
.text:000025DF                 push    ecx
.text:000025E0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000025E7                 mov     [ebp+var_4], ecx
.text:000025EA                 mov     ecx, [ebp+var_4] ; this
.text:000025ED                 call    ??0ISequentialOutStream@@QAE@XZ ; ISequentialOutStream::ISequentialOutStream(void)
.text:000025F2                 mov     ecx, [ebp+var_4]
.text:000025F5                 add     ecx, 4          ; this
.text:000025F8                 call    ??0CMyUnknownImp@@QAE@XZ ; CMyUnknownImp::CMyUnknownImp(void)
.text:000025FD                 mov     eax, [ebp+var_4]
.text:00002600                 mov     dword ptr [eax], offset ??_7COutStreamWithHash@@6B@ ; const COutStreamWithHash::`vftable'
.text:00002606                 mov     ecx, [ebp+var_4]
.text:00002609                 add     ecx, 8
.text:0000260C                 call    ??0?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::CMyComPtr<ISequentialOutStream>(void)
.text:00002611                 mov     eax, [ebp+var_4]
.text:00002614                 add     esp, 4
.text:00002617                 cmp     ebp, esp
.text:00002619                 call    __RTC_CheckEsp
.text:0000261E                 mov     esp, ebp
.text:00002620                 pop     ebp
.text:00002621                 retn
.text:00002621 ??0COutStreamWithHash@@QAE@XZ endp
.text:00002621
.text:00002621 ; ---------------------------------------------------------------------------
.text:00002622                 align 4
.text:00002622 _text           ends
.text:00002622
.rdata:00002624 ; ===========================================================================
.rdata:00002624
.rdata:00002624 ; Segment type: Pure data
.rdata:00002624 ; Segment permissions: Read
.rdata:00002624 _rdata          segment dword public 'DATA' use32
.rdata:00002624                 assume cs:_rdata
.rdata:00002624                 ;org 2624h
.rdata:00002624 ; COMDAT (pick largest)
.rdata:00002624                 dd offset ??_R4COutStreamWithHash@@6B@ ; const COutStreamWithHash::`RTTI Complete Object Locator'
.rdata:00002628                 public ??_7COutStreamWithHash@@6B@
.rdata:00002628 ; const COutStreamWithHash::`vftable'
.rdata:00002628 ??_7COutStreamWithHash@@6B@ dd offset ?QueryInterface@COutStreamWithHash@@UAGJABU_GUID@@PAPAX@Z
.rdata:00002628                                         ; DATA XREF: COutStreamWithHash::COutStreamWithHash(void)+24o
.rdata:00002628                                         ; COutStreamWithHash::QueryInterface(_GUID const &,void * *)
.rdata:0000262C                 dd offset ?AddRef@COutStreamWithHash@@UAGKXZ ; COutStreamWithHash::AddRef(void)
.rdata:00002630                 dd offset ?Release@COutStreamWithHash@@UAGKXZ ; COutStreamWithHash::Release(void)
.rdata:00002634                 dd offset ?Write@COutStreamWithHash@@UAGJPBXIPAI@Z ; COutStreamWithHash::Write(void const *,uint,uint *)
.rdata:00002634 _rdata          ends
.rdata:00002634
.rdata$r:00002638 ; ===========================================================================
.rdata$r:00002638
.rdata$r:00002638 ; Segment type: Pure data
.rdata$r:00002638 ; Segment permissions: Read
.rdata$r:00002638 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002638                 assume cs:_rdata$r
.rdata$r:00002638                 ;org 2638h
.rdata$r:00002638 ; COMDAT (pick any)
.rdata$r:00002638                 public ??_R4COutStreamWithHash@@6B@
.rdata$r:00002638 ; const COutStreamWithHash::`RTTI Complete Object Locator'
.rdata$r:00002638 ??_R4COutStreamWithHash@@6B@ db    0    ; DATA XREF: .rdata:00002624o
.rdata$r:00002639                 db    0
.rdata$r:0000263A                 db    0
.rdata$r:0000263B                 db    0
.rdata$r:0000263C                 db    0
.rdata$r:0000263D                 db    0
.rdata$r:0000263E                 db    0
.rdata$r:0000263F                 db    0
.rdata$r:00002640                 db    0
.rdata$r:00002641                 db    0
.rdata$r:00002642                 db    0
.rdata$r:00002643                 db    0
.rdata$r:00002644                 dd offset ??_R0?AVCOutStreamWithHash@@@8 ; COutStreamWithHash `RTTI Type Descriptor'
.rdata$r:00002648                 dd offset ??_R3COutStreamWithHash@@8 ; COutStreamWithHash::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002648 _rdata$r        ends
.rdata$r:00002648
.data:0000264C ; ===========================================================================
.data:0000264C
.data:0000264C ; Segment type: Pure data
.data:0000264C ; Segment permissions: Read/Write
.data:0000264C _data           segment dword public 'DATA' use32
.data:0000264C                 assume cs:_data
.data:0000264C                 ;org 264Ch
.data:0000264C ; COMDAT (pick any)
.data:0000264C                 public ??_R0?AVCOutStreamWithHash@@@8
.data:0000264C ; class COutStreamWithHash `RTTI Type Descriptor'
.data:0000264C ??_R0?AVCOutStreamWithHash@@@8 dd offset ??_7type_info@@6B@
.data:0000264C                                         ; DATA XREF: .rdata$r:00002644o
.data:0000264C                                         ; .rdata$r:COutStreamWithHash::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:0000264C                                         ; const type_info::`vftable'
.data:00002650                 db    0
.data:00002651                 db    0
.data:00002652                 db    0
.data:00002653                 db    0
.data:00002654                 db  2Eh ; .
.data:00002655                 db  3Fh ; ?
.data:00002656                 db  41h ; A
.data:00002657                 db  56h ; V
.data:00002658                 db  43h ; C
.data:00002659                 db  4Fh ; O
.data:0000265A                 db  75h ; u
.data:0000265B                 db  74h ; t
.data:0000265C                 db  53h ; S
.data:0000265D                 db  74h ; t
.data:0000265E                 db  72h ; r
.data:0000265F                 db  65h ; e
.data:00002660                 db  61h ; a
.data:00002661                 db  6Dh ; m
.data:00002662                 db  57h ; W
.data:00002663                 db  69h ; i
.data:00002664                 db  74h ; t
.data:00002665                 db  68h ; h
.data:00002666                 db  48h ; H
.data:00002667                 db  61h ; a
.data:00002668                 db  73h ; s
.data:00002669                 db  68h ; h
.data:0000266A                 db  40h ; @
.data:0000266B                 db  40h ; @
.data:0000266C                 db    0
.data:0000266D                 align 10h
.data:0000266D _data           ends
.data:0000266D
.rdata$r:00002670 ; ===========================================================================
.rdata$r:00002670
.rdata$r:00002670 ; Segment type: Pure data
.rdata$r:00002670 ; Segment permissions: Read
.rdata$r:00002670 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002670                 assume cs:_rdata$r
.rdata$r:00002670                 ;org 2670h
.rdata$r:00002670 ; COMDAT (pick any)
.rdata$r:00002670                 public ??_R3COutStreamWithHash@@8
.rdata$r:00002670 ; COutStreamWithHash::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002670 ??_R3COutStreamWithHash@@8 db    0      ; DATA XREF: .rdata$r:00002648o
.rdata$r:00002670                                         ; .rdata$r:000026ACo
.rdata$r:00002671                 db    0
.rdata$r:00002672                 db    0
.rdata$r:00002673                 db    0
.rdata$r:00002674                 db    1
.rdata$r:00002675                 db    0
.rdata$r:00002676                 db    0
.rdata$r:00002677                 db    0
.rdata$r:00002678                 db    4
.rdata$r:00002679                 db    0
.rdata$r:0000267A                 db    0
.rdata$r:0000267B                 db    0
.rdata$r:0000267C                 dd offset ??_R2COutStreamWithHash@@8 ; COutStreamWithHash::`RTTI Base Class Array'
.rdata$r:0000267C _rdata$r        ends
.rdata$r:0000267C
.rdata$r:00002680 ; ===========================================================================
.rdata$r:00002680
.rdata$r:00002680 ; Segment type: Pure data
.rdata$r:00002680 ; Segment permissions: Read
.rdata$r:00002680 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002680                 assume cs:_rdata$r
.rdata$r:00002680                 ;org 2680h
.rdata$r:00002680 ; COMDAT (pick any)
.rdata$r:00002680                 public ??_R2COutStreamWithHash@@8
.rdata$r:00002680 ; COutStreamWithHash::`RTTI Base Class Array'
.rdata$r:00002680 ??_R2COutStreamWithHash@@8 dd offset ??_R1A@?0A@EA@COutStreamWithHash@@8
.rdata$r:00002680                                         ; DATA XREF: .rdata$r:0000267Co
.rdata$r:00002680                                         ; COutStreamWithHash::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002684                 dd offset ??_R1A@?0A@EA@ISequentialOutStream@@8 ; ISequentialOutStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002688                 dd offset ??_R1A@?0A@EA@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000268C                 dd offset ??_R13?0A@EA@CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Base Class Descriptor at (4,-1,0,64)'
.rdata$r:00002690                 db    0
.rdata$r:00002691                 align 4
.rdata$r:00002691 _rdata$r        ends
.rdata$r:00002691
.rdata$r:00002694 ; ===========================================================================
.rdata$r:00002694
.rdata$r:00002694 ; Segment type: Pure data
.rdata$r:00002694 ; Segment permissions: Read
.rdata$r:00002694 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002694                 assume cs:_rdata$r
.rdata$r:00002694                 ;org 2694h
.rdata$r:00002694 ; COMDAT (pick any)
.rdata$r:00002694                 public ??_R1A@?0A@EA@COutStreamWithHash@@8
.rdata$r:00002694 ; COutStreamWithHash::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002694 ??_R1A@?0A@EA@COutStreamWithHash@@8 dd offset ??_R0?AVCOutStreamWithHash@@@8
.rdata$r:00002694                                         ; DATA XREF: .rdata$r:COutStreamWithHash::`RTTI Base Class Array'o
.rdata$r:00002694                                         ; COutStreamWithHash `RTTI Type Descriptor'
.rdata$r:00002698                 db    3
.rdata$r:00002699                 db    0
.rdata$r:0000269A                 db    0
.rdata$r:0000269B                 db    0
.rdata$r:0000269C                 db    0
.rdata$r:0000269D                 db    0
.rdata$r:0000269E                 db    0
.rdata$r:0000269F                 db    0
.rdata$r:000026A0                 db 0FFh
.rdata$r:000026A1                 db 0FFh
.rdata$r:000026A2                 db 0FFh
.rdata$r:000026A3                 db 0FFh
.rdata$r:000026A4                 db    0
.rdata$r:000026A5                 db    0
.rdata$r:000026A6                 db    0
.rdata$r:000026A7                 db    0
.rdata$r:000026A8                 db  40h ; @
.rdata$r:000026A9                 db    0
.rdata$r:000026AA                 db    0
.rdata$r:000026AB                 db    0
.rdata$r:000026AC                 dd offset ??_R3COutStreamWithHash@@8 ; COutStreamWithHash::`RTTI Class Hierarchy Descriptor'
.rdata$r:000026AC _rdata$r        ends
.rdata$r:000026AC
.rdata$r:000026B0 ; ===========================================================================
.rdata$r:000026B0
.rdata$r:000026B0 ; Segment type: Pure data
.rdata$r:000026B0 ; Segment permissions: Read
.rdata$r:000026B0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000026B0                 assume cs:_rdata$r
.rdata$r:000026B0                 ;org 26B0h
.rdata$r:000026B0 ; COMDAT (pick any)
.rdata$r:000026B0                 public ??_R1A@?0A@EA@ISequentialOutStream@@8
.rdata$r:000026B0 ; ISequentialOutStream::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000026B0 ??_R1A@?0A@EA@ISequentialOutStream@@8 dd offset ??_R0?AUISequentialOutStream@@@8
.rdata$r:000026B0                                         ; DATA XREF: .rdata$r:00002684o
.rdata$r:000026B0                                         ; .rdata$r:ISequentialOutStream::`RTTI Base Class Array'o
.rdata$r:000026B0                                         ; ISequentialOutStream `RTTI Type Descriptor'
.rdata$r:000026B4                 db    1
.rdata$r:000026B5                 db    0
.rdata$r:000026B6                 db    0
.rdata$r:000026B7                 db    0
.rdata$r:000026B8                 db    0
.rdata$r:000026B9                 db    0
.rdata$r:000026BA                 db    0
.rdata$r:000026BB                 db    0
.rdata$r:000026BC                 db 0FFh
.rdata$r:000026BD                 db 0FFh
.rdata$r:000026BE                 db 0FFh
.rdata$r:000026BF                 db 0FFh
.rdata$r:000026C0                 db    0
.rdata$r:000026C1                 db    0
.rdata$r:000026C2                 db    0
.rdata$r:000026C3                 db    0
.rdata$r:000026C4                 db  40h ; @
.rdata$r:000026C5                 db    0
.rdata$r:000026C6                 db    0
.rdata$r:000026C7                 db    0
.rdata$r:000026C8                 dd offset ??_R3ISequentialOutStream@@8 ; ISequentialOutStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:000026C8 _rdata$r        ends
.rdata$r:000026C8
.data:000026CC ; ===========================================================================
.data:000026CC
.data:000026CC ; Segment type: Pure data
.data:000026CC ; Segment permissions: Read/Write
.data:000026CC _data           segment dword public 'DATA' use32
.data:000026CC                 assume cs:_data
.data:000026CC                 ;org 26CCh
.data:000026CC ; COMDAT (pick any)
.data:000026CC                 public ??_R0?AUISequentialOutStream@@@8
.data:000026CC ; struct ISequentialOutStream `RTTI Type Descriptor'
.data:000026CC ??_R0?AUISequentialOutStream@@@8 dd offset ??_7type_info@@6B@
.data:000026CC                                         ; DATA XREF: .rdata$r:ISequentialOutStream::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:000026CC                                         ; .rdata$r:00002834o
.data:000026CC                                         ; const type_info::`vftable'
.data:000026D0                 db    0
.data:000026D1                 db    0
.data:000026D2                 db    0
.data:000026D3                 db    0
.data:000026D4                 db  2Eh ; .
.data:000026D5                 db  3Fh ; ?
.data:000026D6                 db  41h ; A
.data:000026D7                 db  55h ; U
.data:000026D8                 db  49h ; I
.data:000026D9                 db  53h ; S
.data:000026DA                 db  65h ; e
.data:000026DB                 db  71h ; q
.data:000026DC                 db  75h ; u
.data:000026DD                 db  65h ; e
.data:000026DE                 db  6Eh ; n
.data:000026DF                 db  74h ; t
.data:000026E0                 db  69h ; i
.data:000026E1                 db  61h ; a
.data:000026E2                 db  6Ch ; l
.data:000026E3                 db  4Fh ; O
.data:000026E4                 db  75h ; u
.data:000026E5                 db  74h ; t
.data:000026E6                 db  53h ; S
.data:000026E7                 db  74h ; t
.data:000026E8                 db  72h ; r
.data:000026E9                 db  65h ; e
.data:000026EA                 db  61h ; a
.data:000026EB                 db  6Dh ; m
.data:000026EC                 db  40h ; @
.data:000026ED                 db  40h ; @
.data:000026EE                 db    0
.data:000026EF                 align 10h
.data:000026EF _data           ends
.data:000026EF
.rdata$r:000026F0 ; ===========================================================================
.rdata$r:000026F0
.rdata$r:000026F0 ; Segment type: Pure data
.rdata$r:000026F0 ; Segment permissions: Read
.rdata$r:000026F0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000026F0                 assume cs:_rdata$r
.rdata$r:000026F0                 ;org 26F0h
.rdata$r:000026F0 ; COMDAT (pick any)
.rdata$r:000026F0                 public ??_R3ISequentialOutStream@@8
.rdata$r:000026F0 ; ISequentialOutStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:000026F0 ??_R3ISequentialOutStream@@8 db    0    ; DATA XREF: .rdata$r:000026C8o
.rdata$r:000026F0                                         ; .rdata$r:00002838o
.rdata$r:000026F1                 db    0
.rdata$r:000026F2                 db    0
.rdata$r:000026F3                 db    0
.rdata$r:000026F4                 db    0
.rdata$r:000026F5                 db    0
.rdata$r:000026F6                 db    0
.rdata$r:000026F7                 db    0
.rdata$r:000026F8                 db    2
.rdata$r:000026F9                 db    0
.rdata$r:000026FA                 db    0
.rdata$r:000026FB                 db    0
.rdata$r:000026FC                 dd offset ??_R2ISequentialOutStream@@8 ; ISequentialOutStream::`RTTI Base Class Array'
.rdata$r:000026FC _rdata$r        ends
.rdata$r:000026FC
.rdata$r:00002700 ; ===========================================================================
.rdata$r:00002700
.rdata$r:00002700 ; Segment type: Pure data
.rdata$r:00002700 ; Segment permissions: Read
.rdata$r:00002700 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002700                 assume cs:_rdata$r
.rdata$r:00002700                 ;org 2700h
.rdata$r:00002700 ; COMDAT (pick any)
.rdata$r:00002700                 public ??_R2ISequentialOutStream@@8
.rdata$r:00002700 ; ISequentialOutStream::`RTTI Base Class Array'
.rdata$r:00002700 ??_R2ISequentialOutStream@@8 dd offset ??_R1A@?0A@EA@ISequentialOutStream@@8
.rdata$r:00002700                                         ; DATA XREF: .rdata$r:000026FCo
.rdata$r:00002700                                         ; ISequentialOutStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002704                 dd offset ??_R1A@?0A@EA@IUnknown@@8 ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002708                 db    0
.rdata$r:00002709                 align 4
.rdata$r:00002709 _rdata$r        ends
.rdata$r:00002709
.rdata$r:0000270C ; ===========================================================================
.rdata$r:0000270C
.rdata$r:0000270C ; Segment type: Pure data
.rdata$r:0000270C ; Segment permissions: Read
.rdata$r:0000270C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000270C                 assume cs:_rdata$r
.rdata$r:0000270C                 ;org 270Ch
.rdata$r:0000270C ; COMDAT (pick any)
.rdata$r:0000270C                 public ??_R1A@?0A@EA@IUnknown@@8
.rdata$r:0000270C ; IUnknown::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000270C ??_R1A@?0A@EA@IUnknown@@8 dd offset ??_R0?AUIUnknown@@@8
.rdata$r:0000270C                                         ; DATA XREF: .rdata$r:00002688o
.rdata$r:0000270C                                         ; .rdata$r:00002704o ...
.rdata$r:0000270C                                         ; IUnknown `RTTI Type Descriptor'
.rdata$r:00002710                 db    0
.rdata$r:00002711                 db    0
.rdata$r:00002712                 db    0
.rdata$r:00002713                 db    0
.rdata$r:00002714                 db    0
.rdata$r:00002715                 db    0
.rdata$r:00002716                 db    0
.rdata$r:00002717                 db    0
.rdata$r:00002718                 db 0FFh
.rdata$r:00002719                 db 0FFh
.rdata$r:0000271A                 db 0FFh
.rdata$r:0000271B                 db 0FFh
.rdata$r:0000271C                 db    0
.rdata$r:0000271D                 db    0
.rdata$r:0000271E                 db    0
.rdata$r:0000271F                 db    0
.rdata$r:00002720                 db  40h ; @
.rdata$r:00002721                 db    0
.rdata$r:00002722                 db    0
.rdata$r:00002723                 db    0
.rdata$r:00002724                 dd offset ??_R3IUnknown@@8 ; IUnknown::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002724 _rdata$r        ends
.rdata$r:00002724
.data:00002728 ; ===========================================================================
.data:00002728
.data:00002728 ; Segment type: Pure data
.data:00002728 ; Segment permissions: Read/Write
.data:00002728 _data           segment dword public 'DATA' use32
.data:00002728                 assume cs:_data
.data:00002728                 ;org 2728h
.data:00002728 ; COMDAT (pick any)
.data:00002728                 public ??_R0?AUIUnknown@@@8
.data:00002728 ; struct IUnknown `RTTI Type Descriptor'
.data:00002728 ??_R0?AUIUnknown@@@8 dd offset ??_7type_info@@6B@
.data:00002728                                         ; DATA XREF: .rdata$r:IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:00002728                                         ; const type_info::`vftable'
.data:0000272C                 align 10h
.data:00002730 a_?auiunknown@@ db '.?AUIUnknown@@',0
.data:0000273F                 align 10h
.data:0000273F _data           ends
.data:0000273F
.rdata$r:00002740 ; ===========================================================================
.rdata$r:00002740
.rdata$r:00002740 ; Segment type: Pure data
.rdata$r:00002740 ; Segment permissions: Read
.rdata$r:00002740 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002740                 assume cs:_rdata$r
.rdata$r:00002740                 ;org 2740h
.rdata$r:00002740 ; COMDAT (pick any)
.rdata$r:00002740                 public ??_R3IUnknown@@8
.rdata$r:00002740 ; IUnknown::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002740 ??_R3IUnknown@@8 db    0                ; DATA XREF: .rdata$r:00002724o
.rdata$r:00002741                 db    0
.rdata$r:00002742                 db    0
.rdata$r:00002743                 db    0
.rdata$r:00002744                 db    0
.rdata$r:00002745                 db    0
.rdata$r:00002746                 db    0
.rdata$r:00002747                 db    0
.rdata$r:00002748                 db    1
.rdata$r:00002749                 db    0
.rdata$r:0000274A                 db    0
.rdata$r:0000274B                 db    0
.rdata$r:0000274C                 dd offset ??_R2IUnknown@@8 ; IUnknown::`RTTI Base Class Array'
.rdata$r:0000274C _rdata$r        ends
.rdata$r:0000274C
.rdata$r:00002750 ; ===========================================================================
.rdata$r:00002750
.rdata$r:00002750 ; Segment type: Pure data
.rdata$r:00002750 ; Segment permissions: Read
.rdata$r:00002750 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002750                 assume cs:_rdata$r
.rdata$r:00002750                 ;org 2750h
.rdata$r:00002750 ; COMDAT (pick any)
.rdata$r:00002750                 public ??_R2IUnknown@@8
.rdata$r:00002750 ; IUnknown::`RTTI Base Class Array'
.rdata$r:00002750 ??_R2IUnknown@@8 dd offset ??_R1A@?0A@EA@IUnknown@@8
.rdata$r:00002750                                         ; DATA XREF: .rdata$r:0000274Co
.rdata$r:00002750                                         ; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002754                 db    0
.rdata$r:00002755                 align 4
.rdata$r:00002755 _rdata$r        ends
.rdata$r:00002755
.rdata$r:00002758 ; ===========================================================================
.rdata$r:00002758
.rdata$r:00002758 ; Segment type: Pure data
.rdata$r:00002758 ; Segment permissions: Read
.rdata$r:00002758 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002758                 assume cs:_rdata$r
.rdata$r:00002758                 ;org 2758h
.rdata$r:00002758 ; COMDAT (pick any)
.rdata$r:00002758                 public ??_R13?0A@EA@CMyUnknownImp@@8
.rdata$r:00002758 ; CMyUnknownImp::`RTTI Base Class Descriptor at (4, -1, 0, 64)'
.rdata$r:00002758 ??_R13?0A@EA@CMyUnknownImp@@8 dd offset ??_R0?AVCMyUnknownImp@@@8
.rdata$r:00002758                                         ; DATA XREF: .rdata$r:0000268Co
.rdata$r:00002758                                         ; CMyUnknownImp `RTTI Type Descriptor'
.rdata$r:0000275C                 align 10h
.rdata$r:00002760                 db    4
.rdata$r:00002761                 db    0
.rdata$r:00002762                 db    0
.rdata$r:00002763                 db    0
.rdata$r:00002764                 db 0FFh
.rdata$r:00002765                 db 0FFh
.rdata$r:00002766                 db 0FFh
.rdata$r:00002767                 db 0FFh
.rdata$r:00002768                 db    0
.rdata$r:00002769                 db    0
.rdata$r:0000276A                 db    0
.rdata$r:0000276B                 db    0
.rdata$r:0000276C                 db  40h ; @
.rdata$r:0000276D                 db    0
.rdata$r:0000276E                 db    0
.rdata$r:0000276F                 db    0
.rdata$r:00002770                 dd offset ??_R3CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002770 _rdata$r        ends
.rdata$r:00002770
.data:00002774 ; ===========================================================================
.data:00002774
.data:00002774 ; Segment type: Pure data
.data:00002774 ; Segment permissions: Read/Write
.data:00002774 _data           segment dword public 'DATA' use32
.data:00002774                 assume cs:_data
.data:00002774                 ;org 2774h
.data:00002774 ; COMDAT (pick any)
.data:00002774                 public ??_R0?AVCMyUnknownImp@@@8
.data:00002774 ; class CMyUnknownImp `RTTI Type Descriptor'
.data:00002774 ??_R0?AVCMyUnknownImp@@@8 dd offset ??_7type_info@@6B@
.data:00002774                                         ; DATA XREF: .rdata$r:CMyUnknownImp::`RTTI Base Class Descriptor at (4,-1,0,64)'o
.data:00002774                                         ; .rdata$r:CMyUnknownImp::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data:00002774                                         ; const type_info::`vftable'
.data:00002778                 db    0
.data:00002779                 db    0
.data:0000277A                 db    0
.data:0000277B                 db    0
.data:0000277C                 db  2Eh ; .
.data:0000277D                 db  3Fh ; ?
.data:0000277E                 db  41h ; A
.data:0000277F                 db  56h ; V
.data:00002780                 db  43h ; C
.data:00002781                 db  4Dh ; M
.data:00002782                 db  79h ; y
.data:00002783                 db  55h ; U
.data:00002784                 db  6Eh ; n
.data:00002785                 db  6Bh ; k
.data:00002786                 db  6Eh ; n
.data:00002787                 db  6Fh ; o
.data:00002788                 db  77h ; w
.data:00002789                 db  6Eh ; n
.data:0000278A                 db  49h ; I
.data:0000278B                 db  6Dh ; m
.data:0000278C                 db  70h ; p
.data:0000278D                 db  40h ; @
.data:0000278E                 db  40h ; @
.data:0000278F                 db    0
.data:0000278F _data           ends
.data:0000278F
.rdata$r:00002790 ; ===========================================================================
.rdata$r:00002790
.rdata$r:00002790 ; Segment type: Pure data
.rdata$r:00002790 ; Segment permissions: Read
.rdata$r:00002790 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002790                 assume cs:_rdata$r
.rdata$r:00002790                 ;org 2790h
.rdata$r:00002790 ; COMDAT (pick any)
.rdata$r:00002790                 public ??_R3CMyUnknownImp@@8
.rdata$r:00002790 ; CMyUnknownImp::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002790 ??_R3CMyUnknownImp@@8 db    0           ; DATA XREF: .rdata$r:00002770o
.rdata$r:00002790                                         ; .rdata$r:000027C0o
.rdata$r:00002791                 db    0
.rdata$r:00002792                 db    0
.rdata$r:00002793                 db    0
.rdata$r:00002794                 db    0
.rdata$r:00002795                 db    0
.rdata$r:00002796                 db    0
.rdata$r:00002797                 db    0
.rdata$r:00002798                 db    1
.rdata$r:00002799                 db    0
.rdata$r:0000279A                 db    0
.rdata$r:0000279B                 db    0
.rdata$r:0000279C                 dd offset ??_R2CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Base Class Array'
.rdata$r:0000279C _rdata$r        ends
.rdata$r:0000279C
.rdata$r:000027A0 ; ===========================================================================
.rdata$r:000027A0
.rdata$r:000027A0 ; Segment type: Pure data
.rdata$r:000027A0 ; Segment permissions: Read
.rdata$r:000027A0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000027A0                 assume cs:_rdata$r
.rdata$r:000027A0                 ;org 27A0h
.rdata$r:000027A0 ; COMDAT (pick any)
.rdata$r:000027A0                 public ??_R2CMyUnknownImp@@8
.rdata$r:000027A0 ; CMyUnknownImp::`RTTI Base Class Array'
.rdata$r:000027A0 ??_R2CMyUnknownImp@@8 dd offset ??_R1A@?0A@EA@CMyUnknownImp@@8
.rdata$r:000027A0                                         ; DATA XREF: .rdata$r:0000279Co
.rdata$r:000027A0                                         ; CMyUnknownImp::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000027A4                 db    0
.rdata$r:000027A5                 align 4
.rdata$r:000027A5 _rdata$r        ends
.rdata$r:000027A5
.rdata$r:000027A8 ; ===========================================================================
.rdata$r:000027A8
.rdata$r:000027A8 ; Segment type: Pure data
.rdata$r:000027A8 ; Segment permissions: Read
.rdata$r:000027A8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000027A8                 assume cs:_rdata$r
.rdata$r:000027A8                 ;org 27A8h
.rdata$r:000027A8 ; COMDAT (pick any)
.rdata$r:000027A8                 public ??_R1A@?0A@EA@CMyUnknownImp@@8
.rdata$r:000027A8 ; CMyUnknownImp::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000027A8 ??_R1A@?0A@EA@CMyUnknownImp@@8 dd offset ??_R0?AVCMyUnknownImp@@@8
.rdata$r:000027A8                                         ; DATA XREF: .rdata$r:CMyUnknownImp::`RTTI Base Class Array'o
.rdata$r:000027A8                                         ; CMyUnknownImp `RTTI Type Descriptor'
.rdata$r:000027AC                 db    0
.rdata$r:000027AD                 db    0
.rdata$r:000027AE                 db    0
.rdata$r:000027AF                 db    0
.rdata$r:000027B0                 db    0
.rdata$r:000027B1                 db    0
.rdata$r:000027B2                 db    0
.rdata$r:000027B3                 db    0
.rdata$r:000027B4                 db 0FFh
.rdata$r:000027B5                 db 0FFh
.rdata$r:000027B6                 db 0FFh
.rdata$r:000027B7                 db 0FFh
.rdata$r:000027B8                 db    0
.rdata$r:000027B9                 db    0
.rdata$r:000027BA                 db    0
.rdata$r:000027BB                 db    0
.rdata$r:000027BC                 db  40h ; @
.rdata$r:000027BD                 db    0
.rdata$r:000027BE                 db    0
.rdata$r:000027BF                 db    0
.rdata$r:000027C0                 dd offset ??_R3CMyUnknownImp@@8 ; CMyUnknownImp::`RTTI Class Hierarchy Descriptor'
.rdata$r:000027C0 _rdata$r        ends
.rdata$r:000027C0
.text:000027C4 ; ===========================================================================
.text:000027C4
.text:000027C4 ; Segment type: Pure code
.text:000027C4 ; Segment permissions: Read/Execute
.text:000027C4 _text           segment para public 'CODE' use32
.text:000027C4                 assume cs:_text
.text:000027C4                 ;org 27C4h
.text:000027C4 ; COMDAT (pick any)
.text:000027C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000027C4
.text:000027C4 ; =============== S U B R O U T I N E =======================================
.text:000027C4
.text:000027C4 ; Attributes: bp-based frame
.text:000027C4
.text:000027C4 ; _DWORD __thiscall CMyUnknownImp::CMyUnknownImp(CMyUnknownImp *__hidden this)
.text:000027C4                 public ??0CMyUnknownImp@@QAE@XZ
.text:000027C4 ??0CMyUnknownImp@@QAE@XZ proc near      ; CODE XREF: COutStreamWithHash::COutStreamWithHash(void)+1Cp
.text:000027C4
.text:000027C4 var_4           = dword ptr -4
.text:000027C4
.text:000027C4                 push    ebp
.text:000027C5                 mov     ebp, esp
.text:000027C7                 push    ecx
.text:000027C8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000027CF                 mov     [ebp+var_4], ecx
.text:000027D2                 mov     eax, [ebp+var_4]
.text:000027D5                 mov     dword ptr [eax], 0
.text:000027DB                 mov     eax, [ebp+var_4]
.text:000027DE                 mov     esp, ebp
.text:000027E0                 pop     ebp
.text:000027E1                 retn
.text:000027E1 ??0CMyUnknownImp@@QAE@XZ endp
.text:000027E1
.text:000027E1 ; ---------------------------------------------------------------------------
.text:000027E2                 align 4
.text:000027E2 _text           ends
.text:000027E2
.text:000027E4 ; ===========================================================================
.text:000027E4
.text:000027E4 ; Segment type: Pure code
.text:000027E4 ; Segment permissions: Read/Execute
.text:000027E4 _text           segment para public 'CODE' use32
.text:000027E4                 assume cs:_text
.text:000027E4                 ;org 27E4h
.text:000027E4 ; COMDAT (pick any)
.text:000027E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000027E4
.text:000027E4 ; =============== S U B R O U T I N E =======================================
.text:000027E4
.text:000027E4 ; Attributes: bp-based frame
.text:000027E4
.text:000027E4 ; _DWORD __thiscall ISequentialOutStream::ISequentialOutStream(ISequentialOutStream *__hidden this)
.text:000027E4                 public ??0ISequentialOutStream@@QAE@XZ
.text:000027E4 ??0ISequentialOutStream@@QAE@XZ proc near
.text:000027E4                                         ; CODE XREF: COutStreamWithHash::COutStreamWithHash(void)+11p
.text:000027E4
.text:000027E4 var_4           = dword ptr -4
.text:000027E4
.text:000027E4                 push    ebp
.text:000027E5                 mov     ebp, esp
.text:000027E7                 push    ecx
.text:000027E8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000027EF                 mov     [ebp+var_4], ecx
.text:000027F2                 mov     ecx, [ebp+var_4]
.text:000027F5                 call    ??0IUnknown@@QAE@XZ ; IUnknown::IUnknown(void)
.text:000027FA                 mov     eax, [ebp+var_4]
.text:000027FD                 mov     dword ptr [eax], offset ??_7ISequentialOutStream@@6B@ ; const ISequentialOutStream::`vftable'
.text:00002803                 mov     eax, [ebp+var_4]
.text:00002806                 add     esp, 4
.text:00002809                 cmp     ebp, esp
.text:0000280B                 call    __RTC_CheckEsp
.text:00002810                 mov     esp, ebp
.text:00002812                 pop     ebp
.text:00002813                 retn
.text:00002813 ??0ISequentialOutStream@@QAE@XZ endp
.text:00002813
.text:00002813 _text           ends
.text:00002813
.rdata:00002814 ; ===========================================================================
.rdata:00002814
.rdata:00002814 ; Segment type: Pure data
.rdata:00002814 ; Segment permissions: Read
.rdata:00002814 _rdata          segment dword public 'DATA' use32
.rdata:00002814                 assume cs:_rdata
.rdata:00002814                 ;org 2814h
.rdata:00002814 ; COMDAT (pick largest)
.rdata:00002814                 dd offset ??_R4ISequentialOutStream@@6B@ ; const ISequentialOutStream::`RTTI Complete Object Locator'
.rdata:00002818                 public ??_7ISequentialOutStream@@6B@
.rdata:00002818 ; const ISequentialOutStream::`vftable'
.rdata:00002818 ??_7ISequentialOutStream@@6B@ dd offset __purecall
.rdata:00002818                                         ; DATA XREF: ISequentialOutStream::ISequentialOutStream(void)+19o
.rdata:0000281C                 dd offset __purecall
.rdata:00002820                 dd offset __purecall
.rdata:00002824                 dd offset __purecall
.rdata:00002824 _rdata          ends
.rdata:00002824
.rdata$r:00002828 ; ===========================================================================
.rdata$r:00002828
.rdata$r:00002828 ; Segment type: Pure data
.rdata$r:00002828 ; Segment permissions: Read
.rdata$r:00002828 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002828                 assume cs:_rdata$r
.rdata$r:00002828                 ;org 2828h
.rdata$r:00002828 ; COMDAT (pick any)
.rdata$r:00002828                 public ??_R4ISequentialOutStream@@6B@
.rdata$r:00002828 ; const ISequentialOutStream::`RTTI Complete Object Locator'
.rdata$r:00002828 ??_R4ISequentialOutStream@@6B@ db    0  ; DATA XREF: .rdata:00002814o
.rdata$r:00002829                 db    0
.rdata$r:0000282A                 db    0
.rdata$r:0000282B                 db    0
.rdata$r:0000282C                 db    0
.rdata$r:0000282D                 db    0
.rdata$r:0000282E                 db    0
.rdata$r:0000282F                 db    0
.rdata$r:00002830                 db    0
.rdata$r:00002831                 db    0
.rdata$r:00002832                 db    0
.rdata$r:00002833                 db    0
.rdata$r:00002834                 dd offset ??_R0?AUISequentialOutStream@@@8 ; ISequentialOutStream `RTTI Type Descriptor'
.rdata$r:00002838                 dd offset ??_R3ISequentialOutStream@@8 ; ISequentialOutStream::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002838 _rdata$r        ends
.rdata$r:00002838
.text:0000283C ; ===========================================================================
.text:0000283C
.text:0000283C ; Segment type: Pure code
.text:0000283C ; Segment permissions: Read/Execute
.text:0000283C _text           segment para public 'CODE' use32
.text:0000283C                 assume cs:_text
.text:0000283C                 ;org 283Ch
.text:0000283C ; COMDAT (pick any)
.text:0000283C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000283C
.text:0000283C ; =============== S U B R O U T I N E =======================================
.text:0000283C
.text:0000283C ; Attributes: bp-based frame
.text:0000283C
.text:0000283C ; public: __thiscall IUnknown::IUnknown(void)
.text:0000283C                 public ??0IUnknown@@QAE@XZ
.text:0000283C ??0IUnknown@@QAE@XZ proc near           ; CODE XREF: ISequentialOutStream::ISequentialOutStream(void)+11p
.text:0000283C
.text:0000283C var_4           = dword ptr -4
.text:0000283C
.text:0000283C                 push    ebp
.text:0000283D                 mov     ebp, esp
.text:0000283F                 push    ecx
.text:00002840                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002847                 mov     [ebp+var_4], ecx
.text:0000284A                 mov     eax, [ebp+var_4]
.text:0000284D                 mov     esp, ebp
.text:0000284F                 pop     ebp
.text:00002850                 retn
.text:00002850 ??0IUnknown@@QAE@XZ endp
.text:00002850
.text:00002850 ; ---------------------------------------------------------------------------
.text:00002851                 align 4
.text:00002851 _text           ends
.text:00002851
.text:00002854 ; ===========================================================================
.text:00002854
.text:00002854 ; Segment type: Pure code
.text:00002854 ; Segment permissions: Read/Execute
.text:00002854 _text           segment para public 'CODE' use32
.text:00002854                 assume cs:_text
.text:00002854                 ;org 2854h
.text:00002854 ; COMDAT (pick any)
.text:00002854                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002854
.text:00002854 ; =============== S U B R O U T I N E =======================================
.text:00002854
.text:00002854 ; Attributes: bp-based frame
.text:00002854
.text:00002854 ; __int32 __stdcall COutStreamWithHash::QueryInterface(COutStreamWithHash *this, const struct _GUID *Buf1, void **)
.text:00002854                 public ?QueryInterface@COutStreamWithHash@@UAGJABU_GUID@@PAPAX@Z
.text:00002854 ?QueryInterface@COutStreamWithHash@@UAGJABU_GUID@@PAPAX@Z proc near
.text:00002854                                         ; DATA XREF: .rdata:const COutStreamWithHash::`vftable'o
.text:00002854
.text:00002854 this            = dword ptr  8
.text:00002854 Buf1            = dword ptr  0Ch
.text:00002854 arg_8           = dword ptr  10h
.text:00002854
.text:00002854                 push    ebp
.text:00002855                 mov     ebp, esp
.text:00002857                 mov     eax, [ebp+arg_8]
.text:0000285A                 mov     dword ptr [eax], 0
.text:00002860                 push    offset _IID_IUnknown ; Buf2
.text:00002865                 mov     ecx, [ebp+Buf1]
.text:00002868                 push    ecx             ; Buf1
.text:00002869                 call    ___@8           ; __(x,x)
.text:0000286E                 test    eax, eax
.text:00002870                 jz      short loc_287C
.text:00002872                 mov     edx, [ebp+arg_8]
.text:00002875                 mov     eax, [ebp+this]
.text:00002878                 mov     [edx], eax
.text:0000287A                 jmp     short loc_2883
.text:0000287C ; ---------------------------------------------------------------------------
.text:0000287C
.text:0000287C loc_287C:                               ; CODE XREF: COutStreamWithHash::QueryInterface(_GUID const &,void * *)+1Cj
.text:0000287C                 mov     eax, 80004002h
.text:00002881                 jmp     short loc_2894
.text:00002883 ; ---------------------------------------------------------------------------
.text:00002883
.text:00002883 loc_2883:                               ; CODE XREF: COutStreamWithHash::QueryInterface(_GUID const &,void * *)+26j
.text:00002883                 mov     ecx, [ebp+this]
.text:00002886                 mov     edx, [ecx+4]
.text:00002889                 add     edx, 1
.text:0000288C                 mov     eax, [ebp+this]
.text:0000288F                 mov     [eax+4], edx
.text:00002892                 xor     eax, eax
.text:00002894
.text:00002894 loc_2894:                               ; CODE XREF: COutStreamWithHash::QueryInterface(_GUID const &,void * *)+2Dj
.text:00002894                 cmp     ebp, esp
.text:00002896                 call    __RTC_CheckEsp
.text:0000289B                 pop     ebp
.text:0000289C                 retn    0Ch
.text:0000289C ?QueryInterface@COutStreamWithHash@@UAGJABU_GUID@@PAPAX@Z endp
.text:0000289C
.text:0000289C ; ---------------------------------------------------------------------------
.text:0000289F                 align 10h
.text:0000289F _text           ends
.text:0000289F
.text:000028A0 ; ===========================================================================
.text:000028A0
.text:000028A0 ; Segment type: Pure code
.text:000028A0 ; Segment permissions: Read/Execute
.text:000028A0 _text           segment para public 'CODE' use32
.text:000028A0                 assume cs:_text
.text:000028A0                 ;org 28A0h
.text:000028A0 ; COMDAT (pick any)
.text:000028A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000028A0
.text:000028A0 ; =============== S U B R O U T I N E =======================================
.text:000028A0
.text:000028A0 ; Attributes: bp-based frame
.text:000028A0
.text:000028A0 ; int __stdcall __(void *Buf1, void *Buf2)
.text:000028A0                 public ___@8
.text:000028A0 ___@8           proc near               ; CODE XREF: COutStreamWithHash::QueryInterface(_GUID const &,void * *)+15p
.text:000028A0
.text:000028A0 Buf1            = dword ptr  8
.text:000028A0 Buf2            = dword ptr  0Ch
.text:000028A0
.text:000028A0                 push    ebp
.text:000028A1                 mov     ebp, esp
.text:000028A3                 mov     eax, [ebp+Buf2]
.text:000028A6                 push    eax             ; Buf2
.text:000028A7                 mov     ecx, [ebp+Buf1]
.text:000028AA                 push    ecx             ; Buf1
.text:000028AB                 call    _IsEqualGUID@8  ; IsEqualGUID(x,x)
.text:000028B0                 cmp     ebp, esp
.text:000028B2                 call    __RTC_CheckEsp
.text:000028B7                 pop     ebp
.text:000028B8                 retn    8
.text:000028B8 ___@8           endp
.text:000028B8
.text:000028B8 ; ---------------------------------------------------------------------------
.text:000028BB                 align 4
.text:000028BB _text           ends
.text:000028BB
.text:000028BC ; ===========================================================================
.text:000028BC
.text:000028BC ; Segment type: Pure code
.text:000028BC ; Segment permissions: Read/Execute
.text:000028BC _text           segment para public 'CODE' use32
.text:000028BC                 assume cs:_text
.text:000028BC                 ;org 28BCh
.text:000028BC ; COMDAT (pick any)
.text:000028BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000028BC
.text:000028BC ; =============== S U B R O U T I N E =======================================
.text:000028BC
.text:000028BC ; Attributes: bp-based frame
.text:000028BC
.text:000028BC ; int __stdcall IsEqualGUID(void *Buf1, void *Buf2)
.text:000028BC                 public _IsEqualGUID@8
.text:000028BC _IsEqualGUID@8  proc near               ; CODE XREF: __(x,x)+Bp
.text:000028BC
.text:000028BC Buf1            = dword ptr  8
.text:000028BC Buf2            = dword ptr  0Ch
.text:000028BC
.text:000028BC                 push    ebp
.text:000028BD                 mov     ebp, esp
.text:000028BF                 push    10h             ; Size
.text:000028C1                 mov     eax, [ebp+Buf2]
.text:000028C4                 push    eax             ; Buf2
.text:000028C5                 mov     ecx, [ebp+Buf1]
.text:000028C8                 push    ecx             ; Buf1
.text:000028C9                 call    _memcmp
.text:000028CE                 add     esp, 0Ch
.text:000028D1                 neg     eax
.text:000028D3                 sbb     eax, eax
.text:000028D5                 add     eax, 1
.text:000028D8                 cmp     ebp, esp
.text:000028DA                 call    __RTC_CheckEsp
.text:000028DF                 pop     ebp
.text:000028E0                 retn    8
.text:000028E0 _IsEqualGUID@8  endp
.text:000028E0
.text:000028E0 ; ---------------------------------------------------------------------------
.text:000028E3                 align 4
.text:000028E3 _text           ends
.text:000028E3
.text:000028E4 ; ===========================================================================
.text:000028E4
.text:000028E4 ; Segment type: Pure code
.text:000028E4 ; Segment permissions: Read/Execute
.text:000028E4 _text           segment para public 'CODE' use32
.text:000028E4                 assume cs:_text
.text:000028E4                 ;org 28E4h
.text:000028E4 ; COMDAT (pick any)
.text:000028E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000028E4
.text:000028E4 ; =============== S U B R O U T I N E =======================================
.text:000028E4
.text:000028E4 ; Attributes: bp-based frame
.text:000028E4
.text:000028E4 ; unsigned __int32 __stdcall COutStreamWithHash::AddRef(COutStreamWithHash *this)
.text:000028E4                 public ?AddRef@COutStreamWithHash@@UAGKXZ
.text:000028E4 ?AddRef@COutStreamWithHash@@UAGKXZ proc near ; DATA XREF: .rdata:0000262Co
.text:000028E4
.text:000028E4 var_4           = dword ptr -4
.text:000028E4 this            = dword ptr  8
.text:000028E4
.text:000028E4                 push    ebp
.text:000028E5                 mov     ebp, esp
.text:000028E7                 push    ecx
.text:000028E8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000028EF                 mov     eax, [ebp+this]
.text:000028F2                 mov     ecx, [eax+4]
.text:000028F5                 add     ecx, 1
.text:000028F8                 mov     [ebp+var_4], ecx
.text:000028FB                 mov     edx, [ebp+this]
.text:000028FE                 mov     eax, [ebp+var_4]
.text:00002901                 mov     [edx+4], eax
.text:00002904                 mov     eax, [ebp+var_4]
.text:00002907                 mov     esp, ebp
.text:00002909                 pop     ebp
.text:0000290A                 retn    4
.text:0000290A ?AddRef@COutStreamWithHash@@UAGKXZ endp
.text:0000290A
.text:0000290A ; ---------------------------------------------------------------------------
.text:0000290D                 align 10h
.text:0000290D _text           ends
.text:0000290D
.text:00002910 ; ===========================================================================
.text:00002910
.text:00002910 ; Segment type: Pure code
.text:00002910 ; Segment permissions: Read/Execute
.text:00002910 _text           segment para public 'CODE' use32
.text:00002910                 assume cs:_text
.text:00002910                 ;org 2910h
.text:00002910 ; COMDAT (pick any)
.text:00002910                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002910
.text:00002910 ; =============== S U B R O U T I N E =======================================
.text:00002910
.text:00002910 ; Attributes: bp-based frame
.text:00002910
.text:00002910 ; unsigned __int32 __stdcall COutStreamWithHash::Release(COutStreamWithHash *this)
.text:00002910                 public ?Release@COutStreamWithHash@@UAGKXZ
.text:00002910 ?Release@COutStreamWithHash@@UAGKXZ proc near ; DATA XREF: .rdata:00002630o
.text:00002910
.text:00002910 var_10          = dword ptr -10h
.text:00002910 var_C           = dword ptr -0Ch
.text:00002910 var_8           = dword ptr -8
.text:00002910 var_4           = dword ptr -4
.text:00002910 this            = dword ptr  8
.text:00002910
.text:00002910                 push    ebp
.text:00002911                 mov     ebp, esp
.text:00002913                 sub     esp, 10h
.text:00002916                 mov     eax, 0CCCCCCCCh
.text:0000291B                 mov     [ebp+var_10], eax
.text:0000291E                 mov     [ebp+var_C], eax
.text:00002921                 mov     [ebp+var_8], eax
.text:00002924                 mov     [ebp+var_4], eax
.text:00002927                 mov     eax, [ebp+this]
.text:0000292A                 mov     ecx, [eax+4]
.text:0000292D                 sub     ecx, 1
.text:00002930                 mov     [ebp+var_C], ecx
.text:00002933                 mov     edx, [ebp+this]
.text:00002936                 mov     eax, [ebp+var_C]
.text:00002939                 mov     [edx+4], eax
.text:0000293C                 cmp     [ebp+var_C], 0
.text:00002940                 jz      short loc_294A
.text:00002942                 mov     ecx, [ebp+this]
.text:00002945                 mov     eax, [ecx+4]
.text:00002948                 jmp     short loc_2974
.text:0000294A ; ---------------------------------------------------------------------------
.text:0000294A
.text:0000294A loc_294A:                               ; CODE XREF: COutStreamWithHash::Release(void)+30j
.text:0000294A                 mov     edx, [ebp+this]
.text:0000294D                 mov     [ebp+var_8], edx
.text:00002950                 mov     eax, [ebp+var_8]
.text:00002953                 mov     [ebp+var_4], eax
.text:00002956                 cmp     [ebp+var_4], 0
.text:0000295A                 jz      short loc_296B
.text:0000295C                 push    1
.text:0000295E                 mov     ecx, [ebp+var_4]
.text:00002961                 call    ??_GCOutStreamWithHash@@QAEPAXI@Z ; COutStreamWithHash::`scalar deleting destructor'(uint)
.text:00002966                 mov     [ebp+var_10], eax
.text:00002969                 jmp     short loc_2972
.text:0000296B ; ---------------------------------------------------------------------------
.text:0000296B
.text:0000296B loc_296B:                               ; CODE XREF: COutStreamWithHash::Release(void)+4Aj
.text:0000296B                 mov     [ebp+var_10], 0
.text:00002972
.text:00002972 loc_2972:                               ; CODE XREF: COutStreamWithHash::Release(void)+59j
.text:00002972                 xor     eax, eax
.text:00002974
.text:00002974 loc_2974:                               ; CODE XREF: COutStreamWithHash::Release(void)+38j
.text:00002974                 add     esp, 10h
.text:00002977                 cmp     ebp, esp
.text:00002979                 call    __RTC_CheckEsp
.text:0000297E                 mov     esp, ebp
.text:00002980                 pop     ebp
.text:00002981                 retn    4
.text:00002981 ?Release@COutStreamWithHash@@UAGKXZ endp
.text:00002981
.text:00002981 _text           ends
.text:00002981
.text:00002984 ; ===========================================================================
.text:00002984
.text:00002984 ; Segment type: Pure code
.text:00002984 ; Segment permissions: Read/Execute
.text:00002984 _text           segment para public 'CODE' use32
.text:00002984                 assume cs:_text
.text:00002984                 ;org 2984h
.text:00002984 ; COMDAT (pick any)
.text:00002984                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002984
.text:00002984 ; =============== S U B R O U T I N E =======================================
.text:00002984
.text:00002984 ; Attributes: bp-based frame
.text:00002984
.text:00002984 ; public: void * __thiscall COutStreamWithHash::`scalar deleting destructor'(unsigned int)
.text:00002984                 public ??_GCOutStreamWithHash@@QAEPAXI@Z
.text:00002984 ??_GCOutStreamWithHash@@QAEPAXI@Z proc near
.text:00002984                                         ; CODE XREF: COutStreamWithHash::Release(void)+51p
.text:00002984
.text:00002984 var_4           = dword ptr -4
.text:00002984 arg_0           = dword ptr  8
.text:00002984
.text:00002984                 push    ebp
.text:00002985                 mov     ebp, esp
.text:00002987                 push    ecx
.text:00002988                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000298F                 mov     [ebp+var_4], ecx
.text:00002992                 mov     ecx, [ebp+var_4] ; this
.text:00002995                 call    ??1COutStreamWithHash@@QAE@XZ ; COutStreamWithHash::~COutStreamWithHash(void)
.text:0000299A                 mov     eax, [ebp+arg_0]
.text:0000299D                 and     eax, 1
.text:000029A0                 jz      short loc_29AE
.text:000029A2                 mov     ecx, [ebp+var_4]
.text:000029A5                 push    ecx             ; void *
.text:000029A6                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:000029AB                 add     esp, 4
.text:000029AE
.text:000029AE loc_29AE:                               ; CODE XREF: COutStreamWithHash::`scalar deleting destructor'(uint)+1Cj
.text:000029AE                 mov     eax, [ebp+var_4]
.text:000029B1                 add     esp, 4
.text:000029B4                 cmp     ebp, esp
.text:000029B6                 call    __RTC_CheckEsp
.text:000029BB                 mov     esp, ebp
.text:000029BD                 pop     ebp
.text:000029BE                 retn    4
.text:000029BE ??_GCOutStreamWithHash@@QAEPAXI@Z endp
.text:000029BE
.text:000029BE ; ---------------------------------------------------------------------------
.text:000029C1                 align 4
.text:000029C1 _text           ends
.text:000029C1
.text:000029C4 ; ===========================================================================
.text:000029C4
.text:000029C4 ; Segment type: Pure code
.text:000029C4 ; Segment permissions: Read/Execute
.text:000029C4 _text           segment para public 'CODE' use32
.text:000029C4                 assume cs:_text
.text:000029C4                 ;org 29C4h
.text:000029C4 ; COMDAT (pick any)
.text:000029C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000029C4
.text:000029C4 ; =============== S U B R O U T I N E =======================================
.text:000029C4
.text:000029C4 ; Attributes: bp-based frame
.text:000029C4
.text:000029C4 ; _DWORD __thiscall COutStreamWithHash::~COutStreamWithHash(COutStreamWithHash *__hidden this)
.text:000029C4                 public ??1COutStreamWithHash@@QAE@XZ
.text:000029C4 ??1COutStreamWithHash@@QAE@XZ proc near ; CODE XREF: COutStreamWithHash::`scalar deleting destructor'(uint)+11p
.text:000029C4
.text:000029C4 var_4           = dword ptr -4
.text:000029C4
.text:000029C4                 push    ebp
.text:000029C5                 mov     ebp, esp
.text:000029C7                 push    ecx
.text:000029C8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000029CF                 mov     [ebp+var_4], ecx
.text:000029D2                 mov     ecx, [ebp+var_4]
.text:000029D5                 add     ecx, 8
.text:000029D8                 call    ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ ; CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)
.text:000029DD                 add     esp, 4
.text:000029E0                 cmp     ebp, esp
.text:000029E2                 call    __RTC_CheckEsp
.text:000029E7                 mov     esp, ebp
.text:000029E9                 pop     ebp
.text:000029EA                 retn
.text:000029EA ??1COutStreamWithHash@@QAE@XZ endp
.text:000029EA
.text:000029EA ; ---------------------------------------------------------------------------
.text:000029EB                 align 4
.text:000029EB _text           ends
.text:000029EB
.text:000029EC ; ===========================================================================
.text:000029EC
.text:000029EC ; Segment type: Pure code
.text:000029EC ; Segment permissions: Read/Execute
.text:000029EC _text           segment para public 'CODE' use32
.text:000029EC                 assume cs:_text
.text:000029EC                 ;org 29ECh
.text:000029EC ; COMDAT (pick any)
.text:000029EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000029EC
.text:000029EC ; =============== S U B R O U T I N E =======================================
.text:000029EC
.text:000029EC ; Attributes: bp-based frame
.text:000029EC
.text:000029EC ; void __thiscall CDecompressStat::Clear(CDecompressStat *__hidden this)
.text:000029EC                 public ?Clear@CDecompressStat@@QAEXXZ
.text:000029EC ?Clear@CDecompressStat@@QAEXXZ proc near
.text:000029EC                                         ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+3Fp
.text:000029EC
.text:000029EC var_4           = dword ptr -4
.text:000029EC
.text:000029EC                 push    ebp
.text:000029ED                 mov     ebp, esp
.text:000029EF                 push    ecx
.text:000029F0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000029F7                 mov     [ebp+var_4], ecx
.text:000029FA                 mov     eax, [ebp+var_4]
.text:000029FD                 mov     dword ptr [eax+30h], 0
.text:00002A04                 mov     dword ptr [eax+34h], 0
.text:00002A0B                 mov     ecx, [ebp+var_4]
.text:00002A0E                 mov     dword ptr [ecx+28h], 0
.text:00002A15                 mov     dword ptr [ecx+2Ch], 0
.text:00002A1C                 mov     edx, [ebp+var_4]
.text:00002A1F                 mov     dword ptr [edx+20h], 0
.text:00002A26                 mov     dword ptr [edx+24h], 0
.text:00002A2D                 mov     eax, [ebp+var_4]
.text:00002A30                 mov     dword ptr [eax+18h], 0
.text:00002A37                 mov     dword ptr [eax+1Ch], 0
.text:00002A3E                 mov     ecx, [ebp+var_4]
.text:00002A41                 mov     dword ptr [ecx+10h], 0
.text:00002A48                 mov     dword ptr [ecx+14h], 0
.text:00002A4F                 mov     edx, [ebp+var_4]
.text:00002A52                 mov     dword ptr [edx+8], 0
.text:00002A59                 mov     dword ptr [edx+0Ch], 0
.text:00002A60                 mov     eax, [ebp+var_4]
.text:00002A63                 mov     dword ptr [eax], 0
.text:00002A69                 mov     dword ptr [eax+4], 0
.text:00002A70                 mov     esp, ebp
.text:00002A72                 pop     ebp
.text:00002A73                 retn
.text:00002A73 ?Clear@CDecompressStat@@QAEXXZ endp
.text:00002A73
.text:00002A73 _text           ends
.text:00002A73
.text:00002A74 ; ===========================================================================
.text:00002A74
.text:00002A74 ; Segment type: Pure code
.text:00002A74 ; Segment permissions: Read/Execute
.text:00002A74 _text           segment para public 'CODE' use32
.text:00002A74                 assume cs:_text
.text:00002A74                 ;org 2A74h
.text:00002A74 ; COMDAT (pick any)
.text:00002A74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002A74
.text:00002A74 ; =============== S U B R O U T I N E =======================================
.text:00002A74
.text:00002A74 ; Attributes: bp-based frame
.text:00002A74
.text:00002A74 ; bool __stdcall IsPathSepar(wchar_t)
.text:00002A74                 public ?IsPathSepar@@YG_N_W@Z
.text:00002A74 ?IsPathSepar@@YG_N_W@Z proc near        ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+1ECp
.text:00002A74                                         ; DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+539p
.text:00002A74
.text:00002A74 var_4           = dword ptr -4
.text:00002A74 arg_0           = word ptr  8
.text:00002A74
.text:00002A74                 push    ebp
.text:00002A75                 mov     ebp, esp
.text:00002A77                 push    ecx
.text:00002A78                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002A7F                 movzx   eax, [ebp+arg_0]
.text:00002A83                 cmp     eax, 5Ch ; '\'
.text:00002A86                 jz      short loc_2A9A
.text:00002A88                 movzx   ecx, [ebp+arg_0]
.text:00002A8C                 cmp     ecx, 2Fh ; '/'
.text:00002A8F                 jz      short loc_2A9A
.text:00002A91                 mov     [ebp+var_4], 0
.text:00002A98                 jmp     short loc_2AA1
.text:00002A9A ; ---------------------------------------------------------------------------
.text:00002A9A
.text:00002A9A loc_2A9A:                               ; CODE XREF: IsPathSepar(wchar_t)+12j
.text:00002A9A                                         ; IsPathSepar(wchar_t)+1Bj
.text:00002A9A                 mov     [ebp+var_4], 1
.text:00002AA1
.text:00002AA1 loc_2AA1:                               ; CODE XREF: IsPathSepar(wchar_t)+24j
.text:00002AA1                 mov     al, byte ptr [ebp+var_4]
.text:00002AA4                 mov     esp, ebp
.text:00002AA6                 pop     ebp
.text:00002AA7                 retn    4
.text:00002AA7 ?IsPathSepar@@YG_N_W@Z endp
.text:00002AA7
.text:00002AA7 ; ---------------------------------------------------------------------------
.text:00002AAA                 align 4
.text:00002AAA _text           ends
.text:00002AAA
.text:00002AAC ; ===========================================================================
.text:00002AAC
.text:00002AAC ; Segment type: Pure code
.text:00002AAC ; Segment permissions: Read/Execute
.text:00002AAC _text           segment para public 'CODE' use32
.text:00002AAC                 assume cs:_text
.text:00002AAC                 ;org 2AACh
.text:00002AAC ; COMDAT (pick any)
.text:00002AAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002AAC
.text:00002AAC ; =============== S U B R O U T I N E =======================================
.text:00002AAC
.text:00002AAC ; Attributes: bp-based frame
.text:00002AAC
.text:00002AAC ; unsigned int __thiscall UString::Len(UString *__hidden this)
.text:00002AAC                 public ?Len@UString@@QBEIXZ
.text:00002AAC ?Len@UString@@QBEIXZ proc near          ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+505p
.text:00002AAC
.text:00002AAC var_4           = dword ptr -4
.text:00002AAC
.text:00002AAC                 push    ebp
.text:00002AAD                 mov     ebp, esp
.text:00002AAF                 push    ecx
.text:00002AB0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002AB7                 mov     [ebp+var_4], ecx
.text:00002ABA                 mov     eax, [ebp+var_4]
.text:00002ABD                 mov     eax, [eax+4]
.text:00002AC0                 mov     esp, ebp
.text:00002AC2                 pop     ebp
.text:00002AC3                 retn
.text:00002AC3 ?Len@UString@@QBEIXZ endp
.text:00002AC3
.text:00002AC3 _text           ends
.text:00002AC3
.text:00002AC4 ; ===========================================================================
.text:00002AC4
.text:00002AC4 ; Segment type: Pure code
.text:00002AC4 ; Segment permissions: Read/Execute
.text:00002AC4 _text           segment para public 'CODE' use32
.text:00002AC4                 assume cs:_text
.text:00002AC4                 ;org 2AC4h
.text:00002AC4 ; COMDAT (pick any)
.text:00002AC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002AC4
.text:00002AC4 ; =============== S U B R O U T I N E =======================================
.text:00002AC4
.text:00002AC4 ; Attributes: bp-based frame
.text:00002AC4
.text:00002AC4 ; wchar_t __thiscall UString::Back(UString *__hidden this)
.text:00002AC4                 public ?Back@UString@@QBE_WXZ
.text:00002AC4 ?Back@UString@@QBE_WXZ proc near        ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+1E3p
.text:00002AC4
.text:00002AC4 var_4           = dword ptr -4
.text:00002AC4
.text:00002AC4                 push    ebp
.text:00002AC5                 mov     ebp, esp
.text:00002AC7                 push    ecx
.text:00002AC8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002ACF                 mov     [ebp+var_4], ecx
.text:00002AD2                 mov     eax, [ebp+var_4]
.text:00002AD5                 mov     ecx, [eax+4]
.text:00002AD8                 mov     edx, [ebp+var_4]
.text:00002ADB                 mov     eax, [edx]
.text:00002ADD                 mov     ax, [eax+ecx*2-2]
.text:00002AE2                 mov     esp, ebp
.text:00002AE4                 pop     ebp
.text:00002AE5                 retn
.text:00002AE5 ?Back@UString@@QBE_WXZ endp
.text:00002AE5
.text:00002AE5 ; ---------------------------------------------------------------------------
.text:00002AE6                 align 4
.text:00002AE6 _text           ends
.text:00002AE6
.text:00002AE8 ; ===========================================================================
.text:00002AE8
.text:00002AE8 ; Segment type: Pure code
.text:00002AE8 ; Segment permissions: Read/Execute
.text:00002AE8 _text           segment para public 'CODE' use32
.text:00002AE8                 assume cs:_text
.text:00002AE8                 ;org 2AE8h
.text:00002AE8 ; COMDAT (pick any)
.text:00002AE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002AE8
.text:00002AE8 ; =============== S U B R O U T I N E =======================================
.text:00002AE8
.text:00002AE8 ; Attributes: bp-based frame
.text:00002AE8
.text:00002AE8 ; void __thiscall UString::DeleteBack(UString *__hidden this)
.text:00002AE8                 public ?DeleteBack@UString@@QAEXXZ
.text:00002AE8 ?DeleteBack@UString@@QAEXXZ proc near   ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+1FBp
.text:00002AE8
.text:00002AE8 var_8           = dword ptr -8
.text:00002AE8 var_4           = dword ptr -4
.text:00002AE8
.text:00002AE8                 push    ebp
.text:00002AE9                 mov     ebp, esp
.text:00002AEB                 sub     esp, 8
.text:00002AEE                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00002AF5                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002AFC                 mov     [ebp+var_4], ecx
.text:00002AFF                 mov     eax, [ebp+var_4]
.text:00002B02                 mov     ecx, [eax+4]
.text:00002B05                 sub     ecx, 1
.text:00002B08                 mov     [ebp+var_8], ecx
.text:00002B0B                 mov     edx, [ebp+var_4]
.text:00002B0E                 mov     eax, [ebp+var_8]
.text:00002B11                 mov     [edx+4], eax
.text:00002B14                 mov     ecx, [ebp+var_4]
.text:00002B17                 mov     edx, [ecx]
.text:00002B19                 xor     eax, eax
.text:00002B1B                 mov     ecx, [ebp+var_8]
.text:00002B1E                 mov     [edx+ecx*2], ax
.text:00002B22                 mov     esp, ebp
.text:00002B24                 pop     ebp
.text:00002B25                 retn
.text:00002B25 ?DeleteBack@UString@@QAEXXZ endp
.text:00002B25
.text:00002B25 ; ---------------------------------------------------------------------------
.text:00002B26                 align 4
.text:00002B26 _text           ends
.text:00002B26
.text:00002B28 ; ===========================================================================
.text:00002B28
.text:00002B28 ; Segment type: Pure code
.text:00002B28 ; Segment permissions: Read/Execute
.text:00002B28 _text           segment para public 'CODE' use32
.text:00002B28                 assume cs:_text
.text:00002B28                 ;org 2B28h
.text:00002B28 ; COMDAT (pick any)
.text:00002B28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002B28
.text:00002B28 ; =============== S U B R O U T I N E =======================================
.text:00002B28
.text:00002B28 ; Attributes: bp-based frame
.text:00002B28
.text:00002B28 ; _DWORD __thiscall NWindows::NCOM::CPropVariant::CPropVariant(NWindows::NCOM::CPropVariant *__hidden this)
.text:00002B28                 public ??0CPropVariant@NCOM@NWindows@@QAE@XZ
.text:00002B28 ??0CPropVariant@NCOM@NWindows@@QAE@XZ proc near
.text:00002B28                                         ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+89Ep
.text:00002B28
.text:00002B28 var_4           = dword ptr -4
.text:00002B28
.text:00002B28                 push    ebp
.text:00002B29                 mov     ebp, esp
.text:00002B2B                 push    ecx
.text:00002B2C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002B33                 mov     [ebp+var_4], ecx
.text:00002B36                 xor     eax, eax
.text:00002B38                 mov     ecx, [ebp+var_4]
.text:00002B3B                 mov     [ecx], ax
.text:00002B3E                 xor     edx, edx
.text:00002B40                 mov     eax, [ebp+var_4]
.text:00002B43                 mov     [eax+2], dx
.text:00002B47                 mov     ecx, [ebp+var_4]
.text:00002B4A                 mov     dword ptr [ecx+8], 0
.text:00002B51                 mov     eax, [ebp+var_4]
.text:00002B54                 mov     esp, ebp
.text:00002B56                 pop     ebp
.text:00002B57                 retn
.text:00002B57 ??0CPropVariant@NCOM@NWindows@@QAE@XZ endp
.text:00002B57
.text:00002B57 _text           ends
.text:00002B57
.text:00002B58 ; ===========================================================================
.text:00002B58
.text:00002B58 ; Segment type: Pure code
.text:00002B58 ; Segment permissions: Read/Execute
.text:00002B58 _text           segment para public 'CODE' use32
.text:00002B58                 assume cs:_text
.text:00002B58                 ;org 2B58h
.text:00002B58 ; COMDAT (pick any)
.text:00002B58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002B58
.text:00002B58 ; =============== S U B R O U T I N E =======================================
.text:00002B58
.text:00002B58 ; Attributes: bp-based frame
.text:00002B58
.text:00002B58 ; _DWORD __thiscall NWindows::NCOM::CPropVariant::~CPropVariant(NWindows::NCOM::CPropVariant *__hidden this)
.text:00002B58                 public ??1CPropVariant@NCOM@NWindows@@QAE@XZ
.text:00002B58 ??1CPropVariant@NCOM@NWindows@@QAE@XZ proc near
.text:00002B58                                         ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+8E5p
.text:00002B58                                         ; __unwindfunclet$?DecompressArchive@@YGJPAVCCodecs@@ABUCArchiveLink@@_KABVCCensorNode@NWildcard@@ABUCExtractOptions@@_NPAUIExtractCallbackUI@@PAVCArchiveExtractCallback@@AAVUString@@AA_K@Z$10+6j
.text:00002B58
.text:00002B58 var_4           = dword ptr -4
.text:00002B58
.text:00002B58                 push    ebp
.text:00002B59                 mov     ebp, esp
.text:00002B5B                 push    ecx
.text:00002B5C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002B63                 mov     [ebp+var_4], ecx
.text:00002B66                 mov     ecx, [ebp+var_4] ; this
.text:00002B69                 call    ?Clear@CPropVariant@NCOM@NWindows@@QAEJXZ ; NWindows::NCOM::CPropVariant::Clear(void)
.text:00002B6E                 add     esp, 4
.text:00002B71                 cmp     ebp, esp
.text:00002B73                 call    __RTC_CheckEsp
.text:00002B78                 mov     esp, ebp
.text:00002B7A                 pop     ebp
.text:00002B7B                 retn
.text:00002B7B ??1CPropVariant@NCOM@NWindows@@QAE@XZ endp
.text:00002B7B
.text:00002B7B _text           ends
.text:00002B7B
.text:00002B7C ; ===========================================================================
.text:00002B7C
.text:00002B7C ; Segment type: Pure code
.text:00002B7C ; Segment permissions: Read/Execute
.text:00002B7C _text           segment para public 'CODE' use32
.text:00002B7C                 assume cs:_text
.text:00002B7C                 ;org 2B7Ch
.text:00002B7C ; COMDAT (pick any)
.text:00002B7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002B7C
.text:00002B7C ; =============== S U B R O U T I N E =======================================
.text:00002B7C
.text:00002B7C ; Attributes: bp-based frame
.text:00002B7C
.text:00002B7C ; bool __stdcall ConvertPropVariantToUInt64(const struct tagPROPVARIANT *, unsigned __int64 *)
.text:00002B7C                 public ?ConvertPropVariantToUInt64@@YG_NABUtagPROPVARIANT@@AA_K@Z
.text:00002B7C ?ConvertPropVariantToUInt64@@YG_NABUtagPROPVARIANT@@AA_K@Z proc near
.text:00002B7C                                         ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+8D6p
.text:00002B7C
.text:00002B7C var_8           = dword ptr -8
.text:00002B7C var_4           = dword ptr -4
.text:00002B7C arg_0           = dword ptr  8
.text:00002B7C arg_4           = dword ptr  0Ch
.text:00002B7C
.text:00002B7C                 push    ebp
.text:00002B7D                 mov     ebp, esp
.text:00002B7F                 sub     esp, 8
.text:00002B82                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00002B89                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002B90                 mov     eax, [ebp+arg_0]
.text:00002B93                 movzx   ecx, word ptr [eax]
.text:00002B96                 mov     [ebp+var_8], ecx
.text:00002B99                 cmp     [ebp+var_8], 15h ; switch 22 cases
.text:00002B9D                 ja      short $LN1      ; jumptable 00002BA9 default case
.text:00002B9F                 mov     edx, [ebp+var_8]
.text:00002BA2                 movzx   eax, ds:$LN11[edx]
.text:00002BA9                 jmp     ds:$LN12[eax*4] ; switch jump
.text:00002BB0 ; ---------------------------------------------------------------------------
.text:00002BB0
.text:00002BB0 $LN6:                                   ; CODE XREF: ConvertPropVariantToUInt64(tagPROPVARIANT const &,unsigned __int64 &)+2Dj
.text:00002BB0                                         ; DATA XREF: .text:$LN12o
.text:00002BB0                 mov     ecx, [ebp+arg_4] ; jumptable 00002BA9 case 21
.text:00002BB3                 mov     edx, [ebp+arg_0]
.text:00002BB6                 mov     eax, [edx+8]
.text:00002BB9                 mov     [ecx], eax
.text:00002BBB                 mov     edx, [edx+0Ch]
.text:00002BBE                 mov     [ecx+4], edx
.text:00002BC1                 mov     al, 1
.text:00002BC3                 jmp     short loc_2C1A
.text:00002BC5 ; ---------------------------------------------------------------------------
.text:00002BC5
.text:00002BC5 $LN5:                                   ; CODE XREF: ConvertPropVariantToUInt64(tagPROPVARIANT const &,unsigned __int64 &)+2Dj
.text:00002BC5                                         ; DATA XREF: .text:$LN12o
.text:00002BC5                 mov     eax, [ebp+arg_0] ; jumptable 00002BA9 case 19
.text:00002BC8                 mov     ecx, [eax+8]
.text:00002BCB                 xor     edx, edx
.text:00002BCD                 mov     eax, [ebp+arg_4]
.text:00002BD0                 mov     [eax], ecx
.text:00002BD2                 mov     [eax+4], edx
.text:00002BD5                 mov     al, 1
.text:00002BD7                 jmp     short loc_2C1A
.text:00002BD9 ; ---------------------------------------------------------------------------
.text:00002BD9
.text:00002BD9 $LN4:                                   ; CODE XREF: ConvertPropVariantToUInt64(tagPROPVARIANT const &,unsigned __int64 &)+2Dj
.text:00002BD9                                         ; DATA XREF: .text:$LN12o
.text:00002BD9                 mov     ecx, [ebp+arg_0] ; jumptable 00002BA9 case 18
.text:00002BDC                 movzx   eax, word ptr [ecx+8]
.text:00002BE0                 cdq
.text:00002BE1                 mov     ecx, [ebp+arg_4]
.text:00002BE4                 mov     [ecx], eax
.text:00002BE6                 mov     [ecx+4], edx
.text:00002BE9                 mov     al, 1
.text:00002BEB                 jmp     short loc_2C1A
.text:00002BED ; ---------------------------------------------------------------------------
.text:00002BED
.text:00002BED $LN3:                                   ; CODE XREF: ConvertPropVariantToUInt64(tagPROPVARIANT const &,unsigned __int64 &)+2Dj
.text:00002BED                                         ; DATA XREF: .text:$LN12o
.text:00002BED                 mov     edx, [ebp+arg_0] ; jumptable 00002BA9 case 17
.text:00002BF0                 movzx   eax, byte ptr [edx+8]
.text:00002BF4                 cdq
.text:00002BF5                 mov     ecx, [ebp+arg_4]
.text:00002BF8                 mov     [ecx], eax
.text:00002BFA                 mov     [ecx+4], edx
.text:00002BFD                 mov     al, 1
.text:00002BFF                 jmp     short loc_2C1A
.text:00002C01 ; ---------------------------------------------------------------------------
.text:00002C01
.text:00002C01 $LN2:                                   ; CODE XREF: ConvertPropVariantToUInt64(tagPROPVARIANT const &,unsigned __int64 &)+2Dj
.text:00002C01                                         ; DATA XREF: .text:$LN12o
.text:00002C01                 xor     al, al          ; jumptable 00002BA9 case 0
.text:00002C03                 jmp     short loc_2C1A
.text:00002C05 ; ---------------------------------------------------------------------------
.text:00002C05
.text:00002C05 $LN1:                                   ; CODE XREF: ConvertPropVariantToUInt64(tagPROPVARIANT const &,unsigned __int64 &)+21j
.text:00002C05                                         ; ConvertPropVariantToUInt64(tagPROPVARIANT const &,unsigned __int64 &)+2Dj
.text:00002C05                                         ; DATA XREF: ...
.text:00002C05                 mov     [ebp+var_4], 24E9Fh ; jumptable 00002BA9 default case
.text:00002C0C                 push    offset __TI1H
.text:00002C11                 lea     edx, [ebp+var_4]
.text:00002C14                 push    edx
.text:00002C15                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text:00002C1A ; ---------------------------------------------------------------------------
.text:00002C1A
.text:00002C1A loc_2C1A:                               ; CODE XREF: ConvertPropVariantToUInt64(tagPROPVARIANT const &,unsigned __int64 &)+47j
.text:00002C1A                                         ; ConvertPropVariantToUInt64(tagPROPVARIANT const &,unsigned __int64 &)+5Bj ...
.text:00002C1A                 add     esp, 8
.text:00002C1D                 cmp     ebp, esp
.text:00002C1F                 call    __RTC_CheckEsp
.text:00002C24                 mov     esp, ebp
.text:00002C26                 pop     ebp
.text:00002C27                 retn    8
.text:00002C27 ?ConvertPropVariantToUInt64@@YG_NABUtagPROPVARIANT@@AA_K@Z endp
.text:00002C27
.text:00002C27 ; ---------------------------------------------------------------------------
.text:00002C2A                 align 4
.text:00002C2C $LN12           dd offset $LN2          ; DATA XREF: ConvertPropVariantToUInt64(tagPROPVARIANT const &,unsigned __int64 &)+2Dr
.text:00002C2C                 dd offset $LN3          ; jump table for switch statement
.text:00002C2C                 dd offset $LN4
.text:00002C2C                 dd offset $LN5
.text:00002C2C                 dd offset $LN6
.text:00002C2C                 dd offset $LN1
.text:00002C44 $LN11           db      0,     5,     5,     5
.text:00002C44                                         ; DATA XREF: ConvertPropVariantToUInt64(tagPROPVARIANT const &,unsigned __int64 &)+26r
.text:00002C44                 db      5,     5,     5,     5 ; indirect table for switch statement
.text:00002C44                 db      5,     5,     5,     5
.text:00002C44                 db      5,     5,     5,     5
.text:00002C44                 db      5,     1,     2,     3
.text:00002C44                 db      5,     4
.text:00002C5A                 align 4
.text:00002C5A _text           ends
.text:00002C5A
.xdata$x:00002C5C ; ===========================================================================
.xdata$x:00002C5C
.xdata$x:00002C5C ; Segment type: Pure data
.xdata$x:00002C5C ; Segment permissions: Read
.xdata$x:00002C5C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002C5C                 assume cs:_xdata$x
.xdata$x:00002C5C                 ;org 2C5Ch
.xdata$x:00002C5C ; COMDAT (pick any)
.xdata$x:00002C5C                 public __TI1H
.xdata$x:00002C5C __TI1H          db    0                 ; DATA XREF: ConvertPropVariantToUInt64(tagPROPVARIANT const &,unsigned __int64 &)+90o
.xdata$x:00002C5D                 db    0
.xdata$x:00002C5E                 db    0
.xdata$x:00002C5F                 db    0
.xdata$x:00002C60                 db    0
.xdata$x:00002C61                 db    0
.xdata$x:00002C62                 db    0
.xdata$x:00002C63                 db    0
.xdata$x:00002C64                 db    0
.xdata$x:00002C65                 db    0
.xdata$x:00002C66                 db    0
.xdata$x:00002C67                 db    0
.xdata$x:00002C68                 dd offset __CTA1H
.xdata$x:00002C68 _xdata$x        ends
.xdata$x:00002C68
.xdata$x:00002C6C ; ===========================================================================
.xdata$x:00002C6C
.xdata$x:00002C6C ; Segment type: Pure data
.xdata$x:00002C6C ; Segment permissions: Read
.xdata$x:00002C6C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002C6C                 assume cs:_xdata$x
.xdata$x:00002C6C                 ;org 2C6Ch
.xdata$x:00002C6C ; COMDAT (pick any)
.xdata$x:00002C6C                 public __CTA1H
.xdata$x:00002C6C __CTA1H         db    1                 ; DATA XREF: .xdata$x:00002C68o
.xdata$x:00002C6D                 db    0
.xdata$x:00002C6E                 db    0
.xdata$x:00002C6F                 db    0
.xdata$x:00002C70                 dd offset __CT??_R0H@84
.xdata$x:00002C70 _xdata$x        ends
.xdata$x:00002C70
.xdata$x:00002C74 ; ===========================================================================
.xdata$x:00002C74
.xdata$x:00002C74 ; Segment type: Pure data
.xdata$x:00002C74 ; Segment permissions: Read
.xdata$x:00002C74 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002C74                 assume cs:_xdata$x
.xdata$x:00002C74                 ;org 2C74h
.xdata$x:00002C74 ; COMDAT (pick any)
.xdata$x:00002C74                 public __CT??_R0H@84
.xdata$x:00002C74 __CT??_R0H@84   db    1                 ; DATA XREF: .xdata$x:00002C70o
.xdata$x:00002C75                 db    0
.xdata$x:00002C76                 db    0
.xdata$x:00002C77                 db    0
.xdata$x:00002C78                 dd offset ??_R0H@8      ; int `RTTI Type Descriptor'
.xdata$x:00002C7C                 align 10h
.xdata$x:00002C80                 db 0FFh
.xdata$x:00002C81                 db 0FFh
.xdata$x:00002C82                 db 0FFh
.xdata$x:00002C83                 db 0FFh
.xdata$x:00002C84                 db    0
.xdata$x:00002C85                 db    0
.xdata$x:00002C86                 db    0
.xdata$x:00002C87                 db    0
.xdata$x:00002C88                 db    4
.xdata$x:00002C89                 db    0
.xdata$x:00002C8A                 db    0
.xdata$x:00002C8B                 db    0
.xdata$x:00002C8C                 db    0
.xdata$x:00002C8D                 db    0
.xdata$x:00002C8E                 db    0
.xdata$x:00002C8F                 db    0
.xdata$x:00002C8F _xdata$x        ends
.xdata$x:00002C8F
.data:00002C90 ; ===========================================================================
.data:00002C90
.data:00002C90 ; Segment type: Pure data
.data:00002C90 ; Segment permissions: Read/Write
.data:00002C90 _data           segment dword public 'DATA' use32
.data:00002C90                 assume cs:_data
.data:00002C90                 ;org 2C90h
.data:00002C90 ; COMDAT (pick any)
.data:00002C90                 public ??_R0H@8
.data:00002C90 ; int `RTTI Type Descriptor'
.data:00002C90 ??_R0H@8        dd offset ??_7type_info@@6B@ ; DATA XREF: .xdata$x:00002C78o
.data:00002C90                                         ; const type_info::`vftable'
.data:00002C94                 align 8
.data:00002C98                 db  2Eh ; .
.data:00002C99                 db  48h ; H
.data:00002C9A                 db    0
.data:00002C9B                 align 4
.data:00002C9B _data           ends
.data:00002C9B
.text:00002C9C ; ===========================================================================
.text:00002C9C
.text:00002C9C ; Segment type: Pure code
.text:00002C9C ; Segment permissions: Read/Execute
.text:00002C9C _text           segment para public 'CODE' use32
.text:00002C9C                 assume cs:_text
.text:00002C9C                 ;org 2C9Ch
.text:00002C9C ; COMDAT (pick any)
.text:00002C9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002C9C
.text:00002C9C ; =============== S U B R O U T I N E =======================================
.text:00002C9C
.text:00002C9C ; Attributes: bp-based frame
.text:00002C9C
.text:00002C9C ; _DWORD __thiscall CReadArcItem::CReadArcItem(CReadArcItem *__hidden this)
.text:00002C9C                 public ??0CReadArcItem@@QAE@XZ
.text:00002C9C ??0CReadArcItem@@QAE@XZ proc near       ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+2E9p
.text:00002C9C
.text:00002C9C var_10          = dword ptr -10h
.text:00002C9C var_C           = dword ptr -0Ch
.text:00002C9C var_4           = dword ptr -4
.text:00002C9C
.text:00002C9C                 push    ebp
.text:00002C9D                 mov     ebp, esp
.text:00002C9F                 push    0FFFFFFFFh
.text:00002CA1                 push    offset __ehhandler$??0CReadArcItem@@QAE@XZ
.text:00002CA6                 mov     eax, large fs:0
.text:00002CAC                 push    eax
.text:00002CAD                 push    ecx
.text:00002CAE                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00002CB5                 mov     eax, dword ptr ds:___security_cookie
.text:00002CBA                 xor     eax, ebp
.text:00002CBC                 push    eax
.text:00002CBD                 lea     eax, [ebp+var_C]
.text:00002CC0                 mov     large fs:0, eax
.text:00002CC6                 mov     [ebp+var_10], ecx
.text:00002CC9                 mov     ecx, [ebp+var_10]
.text:00002CCC                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00002CD1                 mov     [ebp+var_4], 0
.text:00002CD8                 mov     ecx, [ebp+var_10]
.text:00002CDB                 add     ecx, 0Ch
.text:00002CDE                 call    ??0?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::CObjectVector<UString>(void)
.text:00002CE3                 mov     byte ptr [ebp+var_4], 1
.text:00002CE7                 mov     ecx, [ebp+var_10]
.text:00002CEA                 add     ecx, 18h
.text:00002CED                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00002CF2                 mov     byte ptr [ebp+var_4], 2
.text:00002CF6                 mov     ecx, [ebp+var_10]
.text:00002CF9                 add     ecx, 24h ; '$'
.text:00002CFC                 call    ??0UString@@QAE@XZ ; UString::UString(void)
.text:00002D01                 mov     eax, [ebp+var_10]
.text:00002D04                 mov     byte ptr [eax+31h], 0
.text:00002D08                 mov     ecx, [ebp+var_10]
.text:00002D0B                 mov     byte ptr [ecx+38h], 0
.text:00002D0F                 mov     edx, [ebp+var_10]
.text:00002D12                 mov     dword ptr [edx+3Ch], 0FFFFFFFFh
.text:00002D19                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00002D20                 mov     eax, [ebp+var_10]
.text:00002D23                 mov     ecx, [ebp+var_C]
.text:00002D26                 mov     large fs:0, ecx
.text:00002D2D                 pop     ecx
.text:00002D2E                 add     esp, 10h
.text:00002D31                 cmp     ebp, esp
.text:00002D33                 call    __RTC_CheckEsp
.text:00002D38                 mov     esp, ebp
.text:00002D3A                 pop     ebp
.text:00002D3B                 retn
.text:00002D3B ??0CReadArcItem@@QAE@XZ endp
.text:00002D3B
.text:00002D3B _text           ends
.text:00002D3B
.text$x:00002D3C ; ===========================================================================
.text$x:00002D3C
.text$x:00002D3C ; Segment type: Pure code
.text$x:00002D3C ; Segment permissions: Read/Execute
.text$x:00002D3C _text$x         segment para public 'CODE' use32
.text$x:00002D3C                 assume cs:_text$x
.text$x:00002D3C                 ;org 2D3Ch
.text$x:00002D3C ; COMDAT (pick associative to section at 2C9C)
.text$x:00002D3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002D3C
.text$x:00002D3C ; =============== S U B R O U T I N E =======================================
.text$x:00002D3C
.text$x:00002D3C
.text$x:00002D3C __unwindfunclet$??0CReadArcItem@@QAE@XZ$0 proc near
.text$x:00002D3C                                         ; DATA XREF: .xdata$x:00002D7Co
.text$x:00002D3C                 mov     ecx, [ebp-10h]  ; this
.text$x:00002D3F                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00002D3F __unwindfunclet$??0CReadArcItem@@QAE@XZ$0 endp
.text$x:00002D3F
.text$x:00002D44
.text$x:00002D44 ; =============== S U B R O U T I N E =======================================
.text$x:00002D44
.text$x:00002D44
.text$x:00002D44 __unwindfunclet$??0CReadArcItem@@QAE@XZ$1 proc near
.text$x:00002D44                                         ; DATA XREF: .xdata$x:00002D84o
.text$x:00002D44                 mov     ecx, [ebp-10h]
.text$x:00002D47                 add     ecx, 0Ch
.text$x:00002D4A                 jmp     ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text$x:00002D4A __unwindfunclet$??0CReadArcItem@@QAE@XZ$1 endp
.text$x:00002D4A
.text$x:00002D4F
.text$x:00002D4F ; =============== S U B R O U T I N E =======================================
.text$x:00002D4F
.text$x:00002D4F
.text$x:00002D4F __unwindfunclet$??0CReadArcItem@@QAE@XZ$2 proc near
.text$x:00002D4F                                         ; DATA XREF: .xdata$x:00002D8Co
.text$x:00002D4F                 mov     ecx, [ebp-10h]
.text$x:00002D52                 add     ecx, 18h        ; this
.text$x:00002D55                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00002D55 __unwindfunclet$??0CReadArcItem@@QAE@XZ$2 endp
.text$x:00002D55
.text$x:00002D5A
.text$x:00002D5A ; =============== S U B R O U T I N E =======================================
.text$x:00002D5A
.text$x:00002D5A
.text$x:00002D5A __ehhandler$??0CReadArcItem@@QAE@XZ proc near
.text$x:00002D5A                                         ; DATA XREF: CReadArcItem::CReadArcItem(void)+5o
.text$x:00002D5A
.text$x:00002D5A arg_4           = dword ptr  8
.text$x:00002D5A
.text$x:00002D5A                 mov     edx, [esp+arg_4]
.text$x:00002D5E                 lea     eax, [edx+0Ch]
.text$x:00002D61                 mov     ecx, [edx-8]
.text$x:00002D64                 xor     ecx, eax
.text$x:00002D66                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002D6B                 mov     eax, offset __ehfuncinfo$??0CReadArcItem@@QAE@XZ
.text$x:00002D70                 jmp     ___CxxFrameHandler3
.text$x:00002D70 __ehhandler$??0CReadArcItem@@QAE@XZ endp
.text$x:00002D70
.text$x:00002D70 ; ---------------------------------------------------------------------------
.text$x:00002D75                 align 4
.text$x:00002D75 _text$x         ends
.text$x:00002D75
.xdata$x:00002D78 ; ===========================================================================
.xdata$x:00002D78
.xdata$x:00002D78 ; Segment type: Pure data
.xdata$x:00002D78 ; Segment permissions: Read
.xdata$x:00002D78 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002D78                 assume cs:_xdata$x
.xdata$x:00002D78                 ;org 2D78h
.xdata$x:00002D78 ; COMDAT (pick associative to section at 2C9C)
.xdata$x:00002D78 __unwindtable$??0CReadArcItem@@QAE@XZ db 0FFh
.xdata$x:00002D78                                         ; DATA XREF: .xdata$x:00002D98o
.xdata$x:00002D79                 db 0FFh
.xdata$x:00002D7A                 db 0FFh
.xdata$x:00002D7B                 db 0FFh
.xdata$x:00002D7C                 dd offset __unwindfunclet$??0CReadArcItem@@QAE@XZ$0
.xdata$x:00002D80                 db    0
.xdata$x:00002D81                 db    0
.xdata$x:00002D82                 db    0
.xdata$x:00002D83                 db    0
.xdata$x:00002D84                 dd offset __unwindfunclet$??0CReadArcItem@@QAE@XZ$1
.xdata$x:00002D88                 db    1
.xdata$x:00002D89                 db    0
.xdata$x:00002D8A                 db    0
.xdata$x:00002D8B                 db    0
.xdata$x:00002D8C                 dd offset __unwindfunclet$??0CReadArcItem@@QAE@XZ$2
.xdata$x:00002D90 __ehfuncinfo$??0CReadArcItem@@QAE@XZ db  22h ; "
.xdata$x:00002D90                                         ; DATA XREF: __ehhandler$??0CReadArcItem@@QAE@XZ+11o
.xdata$x:00002D91                 db    5
.xdata$x:00002D92                 db  93h ; Ã´
.xdata$x:00002D93                 db  19h
.xdata$x:00002D94                 db    3
.xdata$x:00002D95                 db    0
.xdata$x:00002D96                 db    0
.xdata$x:00002D97                 db    0
.xdata$x:00002D98                 dd offset __unwindtable$??0CReadArcItem@@QAE@XZ
.xdata$x:00002D9C                 db    0
.xdata$x:00002D9D                 db    0
.xdata$x:00002D9E                 db    0
.xdata$x:00002D9F                 db    0
.xdata$x:00002DA0                 db    0
.xdata$x:00002DA1                 db    0
.xdata$x:00002DA2                 db    0
.xdata$x:00002DA3                 db    0
.xdata$x:00002DA4                 db    0
.xdata$x:00002DA5                 db    0
.xdata$x:00002DA6                 db    0
.xdata$x:00002DA7                 db    0
.xdata$x:00002DA8                 db    0
.xdata$x:00002DA9                 db    0
.xdata$x:00002DAA                 db    0
.xdata$x:00002DAB                 db    0
.xdata$x:00002DAC                 db    0
.xdata$x:00002DAD                 db    0
.xdata$x:00002DAE                 db    0
.xdata$x:00002DAF                 db    0
.xdata$x:00002DB0                 db    1
.xdata$x:00002DB1                 db    0
.xdata$x:00002DB2                 db    0
.xdata$x:00002DB3                 db    0
.xdata$x:00002DB3 _xdata$x        ends
.xdata$x:00002DB3
.text:00002DB4 ; ===========================================================================
.text:00002DB4
.text:00002DB4 ; Segment type: Pure code
.text:00002DB4 ; Segment permissions: Read/Execute
.text:00002DB4 _text           segment para public 'CODE' use32
.text:00002DB4                 assume cs:_text
.text:00002DB4                 ;org 2DB4h
.text:00002DB4 ; COMDAT (pick any)
.text:00002DB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002DB4
.text:00002DB4 ; =============== S U B R O U T I N E =======================================
.text:00002DB4
.text:00002DB4 ; Attributes: bp-based frame
.text:00002DB4
.text:00002DB4 ; _DWORD __thiscall CReadArcItem::~CReadArcItem(CReadArcItem *__hidden this)
.text:00002DB4                 public ??1CReadArcItem@@QAE@XZ
.text:00002DB4 ??1CReadArcItem@@QAE@XZ proc near       ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+371p
.text:00002DB4                                         ; DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+43Dp ...
.text:00002DB4
.text:00002DB4 var_10          = dword ptr -10h
.text:00002DB4 var_C           = dword ptr -0Ch
.text:00002DB4 var_4           = dword ptr -4
.text:00002DB4
.text:00002DB4                 push    ebp
.text:00002DB5                 mov     ebp, esp
.text:00002DB7                 push    0FFFFFFFFh
.text:00002DB9                 push    offset __ehhandler$??1CReadArcItem@@QAE@XZ
.text:00002DBE                 mov     eax, large fs:0
.text:00002DC4                 push    eax
.text:00002DC5                 push    ecx
.text:00002DC6                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00002DCD                 mov     eax, dword ptr ds:___security_cookie
.text:00002DD2                 xor     eax, ebp
.text:00002DD4                 push    eax
.text:00002DD5                 lea     eax, [ebp+var_C]
.text:00002DD8                 mov     large fs:0, eax
.text:00002DDE                 mov     [ebp+var_10], ecx
.text:00002DE1                 mov     [ebp+var_4], 2
.text:00002DE8                 mov     ecx, [ebp+var_10]
.text:00002DEB                 add     ecx, 24h ; '$'  ; this
.text:00002DEE                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00002DF3                 mov     byte ptr [ebp+var_4], 1
.text:00002DF7                 mov     ecx, [ebp+var_10]
.text:00002DFA                 add     ecx, 18h        ; this
.text:00002DFD                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00002E02                 mov     byte ptr [ebp+var_4], 0
.text:00002E06                 mov     ecx, [ebp+var_10]
.text:00002E09                 add     ecx, 0Ch
.text:00002E0C                 call    ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text:00002E11                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00002E18                 mov     ecx, [ebp+var_10] ; this
.text:00002E1B                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00002E20                 mov     ecx, [ebp+var_C]
.text:00002E23                 mov     large fs:0, ecx
.text:00002E2A                 pop     ecx
.text:00002E2B                 add     esp, 10h
.text:00002E2E                 cmp     ebp, esp
.text:00002E30                 call    __RTC_CheckEsp
.text:00002E35                 mov     esp, ebp
.text:00002E37                 pop     ebp
.text:00002E38                 retn
.text:00002E38 ??1CReadArcItem@@QAE@XZ endp
.text:00002E38
.text:00002E38 ; ---------------------------------------------------------------------------
.text:00002E39                 align 4
.text:00002E39 _text           ends
.text:00002E39
.text$x:00002E3C ; ===========================================================================
.text$x:00002E3C
.text$x:00002E3C ; Segment type: Pure code
.text$x:00002E3C ; Segment permissions: Read/Execute
.text$x:00002E3C _text$x         segment para public 'CODE' use32
.text$x:00002E3C                 assume cs:_text$x
.text$x:00002E3C                 ;org 2E3Ch
.text$x:00002E3C ; COMDAT (pick associative to section at 2DB4)
.text$x:00002E3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002E3C
.text$x:00002E3C ; =============== S U B R O U T I N E =======================================
.text$x:00002E3C
.text$x:00002E3C
.text$x:00002E3C __unwindfunclet$??1CReadArcItem@@QAE@XZ$0 proc near
.text$x:00002E3C                                         ; DATA XREF: .xdata$x:00002E7Co
.text$x:00002E3C                 mov     ecx, [ebp-10h]  ; this
.text$x:00002E3F                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00002E3F __unwindfunclet$??1CReadArcItem@@QAE@XZ$0 endp
.text$x:00002E3F
.text$x:00002E44
.text$x:00002E44 ; =============== S U B R O U T I N E =======================================
.text$x:00002E44
.text$x:00002E44
.text$x:00002E44 __unwindfunclet$??1CReadArcItem@@QAE@XZ$1 proc near
.text$x:00002E44                                         ; DATA XREF: .xdata$x:00002E84o
.text$x:00002E44                 mov     ecx, [ebp-10h]
.text$x:00002E47                 add     ecx, 0Ch
.text$x:00002E4A                 jmp     ??1?$CObjectVector@VUString@@@@QAE@XZ ; CObjectVector<UString>::~CObjectVector<UString>(void)
.text$x:00002E4A __unwindfunclet$??1CReadArcItem@@QAE@XZ$1 endp
.text$x:00002E4A
.text$x:00002E4F
.text$x:00002E4F ; =============== S U B R O U T I N E =======================================
.text$x:00002E4F
.text$x:00002E4F
.text$x:00002E4F __unwindfunclet$??1CReadArcItem@@QAE@XZ$2 proc near
.text$x:00002E4F                                         ; DATA XREF: .xdata$x:00002E8Co
.text$x:00002E4F                 mov     ecx, [ebp-10h]
.text$x:00002E52                 add     ecx, 18h        ; this
.text$x:00002E55                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00002E55 __unwindfunclet$??1CReadArcItem@@QAE@XZ$2 endp
.text$x:00002E55
.text$x:00002E5A
.text$x:00002E5A ; =============== S U B R O U T I N E =======================================
.text$x:00002E5A
.text$x:00002E5A
.text$x:00002E5A __ehhandler$??1CReadArcItem@@QAE@XZ proc near
.text$x:00002E5A                                         ; DATA XREF: CReadArcItem::~CReadArcItem(void)+5o
.text$x:00002E5A
.text$x:00002E5A arg_4           = dword ptr  8
.text$x:00002E5A
.text$x:00002E5A                 mov     edx, [esp+arg_4]
.text$x:00002E5E                 lea     eax, [edx+0Ch]
.text$x:00002E61                 mov     ecx, [edx-8]
.text$x:00002E64                 xor     ecx, eax
.text$x:00002E66                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002E6B                 mov     eax, offset __ehfuncinfo$??1CReadArcItem@@QAE@XZ
.text$x:00002E70                 jmp     ___CxxFrameHandler3
.text$x:00002E70 __ehhandler$??1CReadArcItem@@QAE@XZ endp
.text$x:00002E70
.text$x:00002E70 ; ---------------------------------------------------------------------------
.text$x:00002E75                 align 4
.text$x:00002E75 _text$x         ends
.text$x:00002E75
.xdata$x:00002E78 ; ===========================================================================
.xdata$x:00002E78
.xdata$x:00002E78 ; Segment type: Pure data
.xdata$x:00002E78 ; Segment permissions: Read
.xdata$x:00002E78 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002E78                 assume cs:_xdata$x
.xdata$x:00002E78                 ;org 2E78h
.xdata$x:00002E78 ; COMDAT (pick associative to section at 2DB4)
.xdata$x:00002E78 __unwindtable$??1CReadArcItem@@QAE@XZ db 0FFh
.xdata$x:00002E78                                         ; DATA XREF: .xdata$x:00002E98o
.xdata$x:00002E79                 db 0FFh
.xdata$x:00002E7A                 db 0FFh
.xdata$x:00002E7B                 db 0FFh
.xdata$x:00002E7C                 dd offset __unwindfunclet$??1CReadArcItem@@QAE@XZ$0
.xdata$x:00002E80                 db    0
.xdata$x:00002E81                 db    0
.xdata$x:00002E82                 db    0
.xdata$x:00002E83                 db    0
.xdata$x:00002E84                 dd offset __unwindfunclet$??1CReadArcItem@@QAE@XZ$1
.xdata$x:00002E88                 db    1
.xdata$x:00002E89                 db    0
.xdata$x:00002E8A                 db    0
.xdata$x:00002E8B                 db    0
.xdata$x:00002E8C                 dd offset __unwindfunclet$??1CReadArcItem@@QAE@XZ$2
.xdata$x:00002E90 __ehfuncinfo$??1CReadArcItem@@QAE@XZ db  22h ; "
.xdata$x:00002E90                                         ; DATA XREF: __ehhandler$??1CReadArcItem@@QAE@XZ+11o
.xdata$x:00002E91                 db    5
.xdata$x:00002E92                 db  93h ; Ã´
.xdata$x:00002E93                 db  19h
.xdata$x:00002E94                 db    3
.xdata$x:00002E95                 db    0
.xdata$x:00002E96                 db    0
.xdata$x:00002E97                 db    0
.xdata$x:00002E98                 dd offset __unwindtable$??1CReadArcItem@@QAE@XZ
.xdata$x:00002E9C                 db    0
.xdata$x:00002E9D                 db    0
.xdata$x:00002E9E                 db    0
.xdata$x:00002E9F                 db    0
.xdata$x:00002EA0                 db    0
.xdata$x:00002EA1                 db    0
.xdata$x:00002EA2                 db    0
.xdata$x:00002EA3                 db    0
.xdata$x:00002EA4                 db    0
.xdata$x:00002EA5                 db    0
.xdata$x:00002EA6                 db    0
.xdata$x:00002EA7                 db    0
.xdata$x:00002EA8                 db    0
.xdata$x:00002EA9                 db    0
.xdata$x:00002EAA                 db    0
.xdata$x:00002EAB                 db    0
.xdata$x:00002EAC                 db    0
.xdata$x:00002EAD                 db    0
.xdata$x:00002EAE                 db    0
.xdata$x:00002EAF                 db    0
.xdata$x:00002EB0                 db    1
.xdata$x:00002EB1                 db    0
.xdata$x:00002EB2                 db    0
.xdata$x:00002EB3                 db    0
.xdata$x:00002EB3 _xdata$x        ends
.xdata$x:00002EB3
.text:00002EB4 ; ===========================================================================
.text:00002EB4
.text:00002EB4 ; Segment type: Pure code
.text:00002EB4 ; Segment permissions: Read/Execute
.text:00002EB4 _text           segment para public 'CODE' use32
.text:00002EB4                 assume cs:_text
.text:00002EB4                 ;org 2EB4h
.text:00002EB4 ; COMDAT (pick any)
.text:00002EB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002EB4
.text:00002EB4 ; =============== S U B R O U T I N E =======================================
.text:00002EB4
.text:00002EB4 ; Attributes: bp-based frame
.text:00002EB4
.text:00002EB4 ; _DWORD __thiscall COpenOptions::~COpenOptions(COpenOptions *__hidden this)
.text:00002EB4                 public ??1COpenOptions@@QAE@XZ
.text:00002EB4 ??1COpenOptions@@QAE@XZ proc near       ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+506p
.text:00002EB4                                         ; Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+5E2p ...
.text:00002EB4
.text:00002EB4 var_4           = dword ptr -4
.text:00002EB4
.text:00002EB4                 push    ebp
.text:00002EB5                 mov     ebp, esp
.text:00002EB7                 push    ecx
.text:00002EB8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002EBF                 mov     [ebp+var_4], ecx
.text:00002EC2                 mov     ecx, [ebp+var_4]
.text:00002EC5                 add     ecx, 48h ; 'H'  ; this
.text:00002EC8                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00002ECD                 add     esp, 4
.text:00002ED0                 cmp     ebp, esp
.text:00002ED2                 call    __RTC_CheckEsp
.text:00002ED7                 mov     esp, ebp
.text:00002ED9                 pop     ebp
.text:00002EDA                 retn
.text:00002EDA ??1COpenOptions@@QAE@XZ endp
.text:00002EDA
.text:00002EDA ; ---------------------------------------------------------------------------
.text:00002EDB                 align 4
.text:00002EDB _text           ends
.text:00002EDB
.text:00002EDC ; ===========================================================================
.text:00002EDC
.text:00002EDC ; Segment type: Pure code
.text:00002EDC ; Segment permissions: Read/Execute
.text:00002EDC _text           segment para public 'CODE' use32
.text:00002EDC                 assume cs:_text
.text:00002EDC                 ;org 2EDCh
.text:00002EDC ; COMDAT (pick any)
.text:00002EDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002EDC
.text:00002EDC ; =============== S U B R O U T I N E =======================================
.text:00002EDC
.text:00002EDC ; Attributes: bp-based frame
.text:00002EDC
.text:00002EDC ; public: unsigned int __thiscall CObjectVector<class UString>::Size(void)const
.text:00002EDC                 public ?Size@?$CObjectVector@VUString@@@@QBEIXZ
.text:00002EDC ?Size@?$CObjectVector@VUString@@@@QBEIXZ proc near
.text:00002EDC                                         ; CODE XREF: Find_FileName_InSortedVector(CObjectVector<UString> const &,UString const &)+24p
.text:00002EDC                                         ; Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+7Bp ...
.text:00002EDC
.text:00002EDC var_4           = dword ptr -4
.text:00002EDC
.text:00002EDC                 push    ebp
.text:00002EDD                 mov     ebp, esp
.text:00002EDF                 push    ecx
.text:00002EE0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002EE7                 mov     [ebp+var_4], ecx
.text:00002EEA                 mov     ecx, [ebp+var_4]
.text:00002EED                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00002EF2                 add     esp, 4
.text:00002EF5                 cmp     ebp, esp
.text:00002EF7                 call    __RTC_CheckEsp
.text:00002EFC                 mov     esp, ebp
.text:00002EFE                 pop     ebp
.text:00002EFF                 retn
.text:00002EFF ?Size@?$CObjectVector@VUString@@@@QBEIXZ endp
.text:00002EFF
.text:00002EFF _text           ends
.text:00002EFF
.text:00002F00 ; ===========================================================================
.text:00002F00
.text:00002F00 ; Segment type: Pure code
.text:00002F00 ; Segment permissions: Read/Execute
.text:00002F00 _text           segment para public 'CODE' use32
.text:00002F00                 assume cs:_text
.text:00002F00                 ;org 2F00h
.text:00002F00 ; COMDAT (pick any)
.text:00002F00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002F00
.text:00002F00 ; =============== S U B R O U T I N E =======================================
.text:00002F00
.text:00002F00 ; Attributes: bp-based frame
.text:00002F00
.text:00002F00 ; public: __thiscall CObjectVector<class UString>::CObjectVector<class UString>(void)
.text:00002F00                 public ??0?$CObjectVector@VUString@@@@QAE@XZ
.text:00002F00 ??0?$CObjectVector@VUString@@@@QAE@XZ proc near
.text:00002F00                                         ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+74p
.text:00002F00                                         ; CArchiveLink::CArchiveLink(void)+42p ...
.text:00002F00
.text:00002F00 var_4           = dword ptr -4
.text:00002F00
.text:00002F00                 push    ebp
.text:00002F01                 mov     ebp, esp
.text:00002F03                 push    ecx
.text:00002F04                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002F0B                 mov     [ebp+var_4], ecx
.text:00002F0E                 mov     ecx, [ebp+var_4]
.text:00002F11                 call    ??0?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::CRecordVector<void *>(void)
.text:00002F16                 mov     eax, [ebp+var_4]
.text:00002F19                 add     esp, 4
.text:00002F1C                 cmp     ebp, esp
.text:00002F1E                 call    __RTC_CheckEsp
.text:00002F23                 mov     esp, ebp
.text:00002F25                 pop     ebp
.text:00002F26                 retn
.text:00002F26 ??0?$CObjectVector@VUString@@@@QAE@XZ endp
.text:00002F26
.text:00002F26 ; ---------------------------------------------------------------------------
.text:00002F27                 align 4
.text:00002F27 _text           ends
.text:00002F27
.text:00002F28 ; ===========================================================================
.text:00002F28
.text:00002F28 ; Segment type: Pure code
.text:00002F28 ; Segment permissions: Read/Execute
.text:00002F28 _text           segment para public 'CODE' use32
.text:00002F28                 assume cs:_text
.text:00002F28                 ;org 2F28h
.text:00002F28 ; COMDAT (pick any)
.text:00002F28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002F28
.text:00002F28 ; =============== S U B R O U T I N E =======================================
.text:00002F28
.text:00002F28 ; Attributes: bp-based frame
.text:00002F28
.text:00002F28 ; public: class UString const & __thiscall CObjectVector<class UString>::operator[](unsigned int)const
.text:00002F28                 public ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z
.text:00002F28 ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z proc near
.text:00002F28                                         ; CODE XREF: Find_FileName_InSortedVector(CObjectVector<UString> const &,UString const &)+46p
.text:00002F28
.text:00002F28 var_4           = dword ptr -4
.text:00002F28 arg_0           = dword ptr  8
.text:00002F28
.text:00002F28                 push    ebp
.text:00002F29                 mov     ebp, esp
.text:00002F2B                 push    ecx
.text:00002F2C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002F33                 mov     [ebp+var_4], ecx
.text:00002F36                 mov     eax, [ebp+arg_0]
.text:00002F39                 push    eax
.text:00002F3A                 mov     ecx, [ebp+var_4]
.text:00002F3D                 call    ??A?$CRecordVector@PAX@@QBEABQAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00002F42                 mov     eax, [eax]
.text:00002F44                 add     esp, 4
.text:00002F47                 cmp     ebp, esp
.text:00002F49                 call    __RTC_CheckEsp
.text:00002F4E                 mov     esp, ebp
.text:00002F50                 pop     ebp
.text:00002F51                 retn    4
.text:00002F51 ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z endp
.text:00002F51
.text:00002F51 _text           ends
.text:00002F51
.text:00002F54 ; ===========================================================================
.text:00002F54
.text:00002F54 ; Segment type: Pure code
.text:00002F54 ; Segment permissions: Read/Execute
.text:00002F54 _text           segment para public 'CODE' use32
.text:00002F54                 assume cs:_text
.text:00002F54                 ;org 2F54h
.text:00002F54 ; COMDAT (pick any)
.text:00002F54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002F54
.text:00002F54 ; =============== S U B R O U T I N E =======================================
.text:00002F54
.text:00002F54 ; Attributes: bp-based frame
.text:00002F54
.text:00002F54 ; public: class UString & __thiscall CObjectVector<class UString>::operator[](unsigned int)
.text:00002F54                 public ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z
.text:00002F54 ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z proc near
.text:00002F54                                         ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+D9p
.text:00002F54                                         ; Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+32Cp ...
.text:00002F54
.text:00002F54 var_4           = dword ptr -4
.text:00002F54 arg_0           = dword ptr  8
.text:00002F54
.text:00002F54                 push    ebp
.text:00002F55                 mov     ebp, esp
.text:00002F57                 push    ecx
.text:00002F58                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00002F5F                 mov     [ebp+var_4], ecx
.text:00002F62                 mov     eax, [ebp+arg_0]
.text:00002F65                 push    eax
.text:00002F66                 mov     ecx, [ebp+var_4]
.text:00002F69                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00002F6E                 mov     eax, [eax]
.text:00002F70                 add     esp, 4
.text:00002F73                 cmp     ebp, esp
.text:00002F75                 call    __RTC_CheckEsp
.text:00002F7A                 mov     esp, ebp
.text:00002F7C                 pop     ebp
.text:00002F7D                 retn    4
.text:00002F7D ??A?$CObjectVector@VUString@@@@QAEAAVUString@@I@Z endp
.text:00002F7D
.text:00002F7D _text           ends
.text:00002F7D
.text:00002F80 ; ===========================================================================
.text:00002F80
.text:00002F80 ; Segment type: Pure code
.text:00002F80 ; Segment permissions: Read/Execute
.text:00002F80 _text           segment para public 'CODE' use32
.text:00002F80                 assume cs:_text
.text:00002F80                 ;org 2F80h
.text:00002F80 ; COMDAT (pick any)
.text:00002F80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00002F80
.text:00002F80 ; =============== S U B R O U T I N E =======================================
.text:00002F80
.text:00002F80 ; Attributes: bp-based frame
.text:00002F80
.text:00002F80 ; public: unsigned int __thiscall CObjectVector<class UString>::Add(class UString const &)
.text:00002F80                 public ?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z
.text:00002F80 ?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z proc near
.text:00002F80                                         ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+64Ep
.text:00002F80
.text:00002F80 var_1C          = dword ptr -1Ch
.text:00002F80 var_18          = dword ptr -18h
.text:00002F80 var_14          = dword ptr -14h
.text:00002F80 var_10          = dword ptr -10h
.text:00002F80 var_C           = dword ptr -0Ch
.text:00002F80 var_4           = dword ptr -4
.text:00002F80 arg_0           = dword ptr  8
.text:00002F80
.text:00002F80                 push    ebp
.text:00002F81                 mov     ebp, esp
.text:00002F83                 push    0FFFFFFFFh
.text:00002F85                 push    offset __ehhandler$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z
.text:00002F8A                 mov     eax, large fs:0
.text:00002F90                 push    eax
.text:00002F91                 sub     esp, 10h
.text:00002F94                 mov     eax, 0CCCCCCCCh
.text:00002F99                 mov     [ebp+var_1C], eax
.text:00002F9C                 mov     [ebp+var_18], eax
.text:00002F9F                 mov     [ebp+var_14], eax
.text:00002FA2                 mov     [ebp+var_10], eax
.text:00002FA5                 mov     eax, dword ptr ds:___security_cookie
.text:00002FAA                 xor     eax, ebp
.text:00002FAC                 push    eax
.text:00002FAD                 lea     eax, [ebp+var_C]
.text:00002FB0                 mov     large fs:0, eax
.text:00002FB6                 mov     [ebp+var_10], ecx
.text:00002FB9                 push    0Ch             ; unsigned int
.text:00002FBB                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00002FC0                 add     esp, 4
.text:00002FC3                 mov     [ebp+var_18], eax
.text:00002FC6                 mov     [ebp+var_4], 0
.text:00002FCD                 cmp     [ebp+var_18], 0
.text:00002FD1                 jz      short loc_2FE4
.text:00002FD3                 mov     eax, [ebp+arg_0]
.text:00002FD6                 push    eax
.text:00002FD7                 mov     ecx, [ebp+var_18]
.text:00002FDA                 call    ??0UString@@QAE@ABV0@@Z ; UString::UString(UString const &)
.text:00002FDF                 mov     [ebp+var_1C], eax
.text:00002FE2                 jmp     short loc_2FEB
.text:00002FE4 ; ---------------------------------------------------------------------------
.text:00002FE4
.text:00002FE4 loc_2FE4:                               ; CODE XREF: CObjectVector<UString>::Add(UString const &)+51j
.text:00002FE4                 mov     [ebp+var_1C], 0
.text:00002FEB
.text:00002FEB loc_2FEB:                               ; CODE XREF: CObjectVector<UString>::Add(UString const &)+62j
.text:00002FEB                 mov     ecx, [ebp+var_1C]
.text:00002FEE                 mov     [ebp+var_14], ecx
.text:00002FF1                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00002FF8                 mov     edx, [ebp+var_14]
.text:00002FFB                 push    edx
.text:00002FFC                 mov     ecx, [ebp+var_10]
.text:00002FFF                 call    ?Add@?$CRecordVector@PAX@@QAEIQAX@Z ; CRecordVector<void *>::Add(void * const)
.text:00003004                 mov     ecx, [ebp+var_C]
.text:00003007                 mov     large fs:0, ecx
.text:0000300E                 pop     ecx
.text:0000300F                 add     esp, 1Ch
.text:00003012                 cmp     ebp, esp
.text:00003014                 call    __RTC_CheckEsp
.text:00003019                 mov     esp, ebp
.text:0000301B                 pop     ebp
.text:0000301C                 retn    4
.text:0000301C ?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z endp
.text:0000301C
.text:0000301C ; ---------------------------------------------------------------------------
.text:0000301F                 align 10h
.text:0000301F _text           ends
.text:0000301F
.text$x:00003020 ; ===========================================================================
.text$x:00003020
.text$x:00003020 ; Segment type: Pure code
.text$x:00003020 ; Segment permissions: Read/Execute
.text$x:00003020 _text$x         segment para public 'CODE' use32
.text$x:00003020                 assume cs:_text$x
.text$x:00003020                 ;org 3020h
.text$x:00003020 ; COMDAT (pick associative to section at 2F80)
.text$x:00003020                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003020
.text$x:00003020 ; =============== S U B R O U T I N E =======================================
.text$x:00003020
.text$x:00003020
.text$x:00003020 __unwindfunclet$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z$0 proc near
.text$x:00003020                                         ; DATA XREF: .xdata$x:0000304Co
.text$x:00003020                 mov     eax, [ebp-18h]
.text$x:00003023                 push    eax             ; void *
.text$x:00003024                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00003029                 pop     ecx
.text$x:0000302A                 retn
.text$x:0000302A __unwindfunclet$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z$0 endp
.text$x:0000302A
.text$x:0000302B
.text$x:0000302B ; =============== S U B R O U T I N E =======================================
.text$x:0000302B
.text$x:0000302B
.text$x:0000302B __ehhandler$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z proc near
.text$x:0000302B                                         ; DATA XREF: CObjectVector<UString>::Add(UString const &)+5o
.text$x:0000302B
.text$x:0000302B arg_4           = dword ptr  8
.text$x:0000302B
.text$x:0000302B                 mov     edx, [esp+arg_4]
.text$x:0000302F                 lea     eax, [edx+0Ch]
.text$x:00003032                 mov     ecx, [edx-14h]
.text$x:00003035                 xor     ecx, eax
.text$x:00003037                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000303C                 mov     eax, offset __ehfuncinfo$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z
.text$x:00003041                 jmp     ___CxxFrameHandler3
.text$x:00003041 __ehhandler$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z endp
.text$x:00003041
.text$x:00003041 ; ---------------------------------------------------------------------------
.text$x:00003046                 align 4
.text$x:00003046 _text$x         ends
.text$x:00003046
.xdata$x:00003048 ; ===========================================================================
.xdata$x:00003048
.xdata$x:00003048 ; Segment type: Pure data
.xdata$x:00003048 ; Segment permissions: Read
.xdata$x:00003048 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003048                 assume cs:_xdata$x
.xdata$x:00003048                 ;org 3048h
.xdata$x:00003048 ; COMDAT (pick associative to section at 2F80)
.xdata$x:00003048 __unwindtable$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z db 0FFh
.xdata$x:00003048                                         ; DATA XREF: .xdata$x:00003058o
.xdata$x:00003049                 db 0FFh
.xdata$x:0000304A                 db 0FFh
.xdata$x:0000304B                 db 0FFh
.xdata$x:0000304C                 dd offset __unwindfunclet$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z$0
.xdata$x:00003050 __ehfuncinfo$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z db  22h ; "
.xdata$x:00003050                                         ; DATA XREF: __ehhandler$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z+11o
.xdata$x:00003051                 db    5
.xdata$x:00003052                 db  93h ; Ã´
.xdata$x:00003053                 db  19h
.xdata$x:00003054                 db    1
.xdata$x:00003055                 db    0
.xdata$x:00003056                 db    0
.xdata$x:00003057                 db    0
.xdata$x:00003058                 dd offset __unwindtable$?Add@?$CObjectVector@VUString@@@@QAEIABVUString@@@Z
.xdata$x:0000305C                 db    0
.xdata$x:0000305D                 db    0
.xdata$x:0000305E                 db    0
.xdata$x:0000305F                 db    0
.xdata$x:00003060                 db    0
.xdata$x:00003061                 db    0
.xdata$x:00003062                 db    0
.xdata$x:00003063                 db    0
.xdata$x:00003064                 db    0
.xdata$x:00003065                 db    0
.xdata$x:00003066                 db    0
.xdata$x:00003067                 db    0
.xdata$x:00003068                 db    0
.xdata$x:00003069                 db    0
.xdata$x:0000306A                 db    0
.xdata$x:0000306B                 db    0
.xdata$x:0000306C                 db    0
.xdata$x:0000306D                 db    0
.xdata$x:0000306E                 db    0
.xdata$x:0000306F                 db    0
.xdata$x:00003070                 db    1
.xdata$x:00003071                 db    0
.xdata$x:00003072                 db    0
.xdata$x:00003073                 db    0
.xdata$x:00003073 _xdata$x        ends
.xdata$x:00003073
.text:00003074 ; ===========================================================================
.text:00003074
.text:00003074 ; Segment type: Pure code
.text:00003074 ; Segment permissions: Read/Execute
.text:00003074 _text           segment para public 'CODE' use32
.text:00003074                 assume cs:_text
.text:00003074                 ;org 3074h
.text:00003074 ; COMDAT (pick any)
.text:00003074                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003074
.text:00003074 ; =============== S U B R O U T I N E =======================================
.text:00003074
.text:00003074 ; Attributes: bp-based frame
.text:00003074
.text:00003074 ; public: __thiscall CObjectVector<class UString>::~CObjectVector<class UString>(void)
.text:00003074                 public ??1?$CObjectVector@VUString@@@@QAE@XZ
.text:00003074 ??1?$CObjectVector@VUString@@@@QAE@XZ proc near
.text:00003074                                         ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+2C4p
.text:00003074                                         ; DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+3B0p ...
.text:00003074
.text:00003074 var_20          = dword ptr -20h
.text:00003074 var_1C          = dword ptr -1Ch
.text:00003074 var_18          = dword ptr -18h
.text:00003074 var_14          = dword ptr -14h
.text:00003074 var_10          = dword ptr -10h
.text:00003074 var_C           = dword ptr -0Ch
.text:00003074 var_4           = dword ptr -4
.text:00003074
.text:00003074                 push    ebp
.text:00003075                 mov     ebp, esp
.text:00003077                 push    0FFFFFFFFh
.text:00003079                 push    offset __ehhandler$??1?$CObjectVector@VUString@@@@QAE@XZ
.text:0000307E                 mov     eax, large fs:0
.text:00003084                 push    eax
.text:00003085                 sub     esp, 14h
.text:00003088                 mov     eax, 0CCCCCCCCh
.text:0000308D                 mov     [ebp+var_20], eax
.text:00003090                 mov     [ebp+var_1C], eax
.text:00003093                 mov     [ebp+var_18], eax
.text:00003096                 mov     [ebp+var_14], eax
.text:00003099                 mov     [ebp+var_10], eax
.text:0000309C                 mov     eax, dword ptr ds:___security_cookie
.text:000030A1                 xor     eax, ebp
.text:000030A3                 push    eax
.text:000030A4                 lea     eax, [ebp+var_C]
.text:000030A7                 mov     large fs:0, eax
.text:000030AD                 mov     [ebp+var_10], ecx
.text:000030B0                 mov     [ebp+var_4], 0
.text:000030B7                 mov     ecx, [ebp+var_10]
.text:000030BA                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:000030BF                 mov     [ebp+var_14], eax
.text:000030C2
.text:000030C2 loc_30C2:                               ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void):loc_3104j
.text:000030C2                 cmp     [ebp+var_14], 0
.text:000030C6                 jz      short loc_3106
.text:000030C8                 mov     eax, [ebp+var_14]
.text:000030CB                 sub     eax, 1
.text:000030CE                 mov     [ebp+var_14], eax
.text:000030D1                 mov     ecx, [ebp+var_14]
.text:000030D4                 push    ecx
.text:000030D5                 mov     ecx, [ebp+var_10]
.text:000030D8                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:000030DD                 mov     edx, [eax]
.text:000030DF                 mov     [ebp+var_1C], edx
.text:000030E2                 mov     eax, [ebp+var_1C]
.text:000030E5                 mov     [ebp+var_18], eax
.text:000030E8                 cmp     [ebp+var_18], 0
.text:000030EC                 jz      short loc_30FD
.text:000030EE                 push    1
.text:000030F0                 mov     ecx, [ebp+var_18]
.text:000030F3                 call    ??_GUString@@QAEPAXI@Z ; UString::`scalar deleting destructor'(uint)
.text:000030F8                 mov     [ebp+var_20], eax
.text:000030FB                 jmp     short loc_3104
.text:000030FD ; ---------------------------------------------------------------------------
.text:000030FD
.text:000030FD loc_30FD:                               ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+78j
.text:000030FD                 mov     [ebp+var_20], 0
.text:00003104
.text:00003104 loc_3104:                               ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+87j
.text:00003104                 jmp     short loc_30C2
.text:00003106 ; ---------------------------------------------------------------------------
.text:00003106
.text:00003106 loc_3106:                               ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+52j
.text:00003106                 mov     [ebp+var_4], 0FFFFFFFFh
.text:0000310D                 mov     ecx, [ebp+var_10]
.text:00003110                 call    ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text:00003115                 mov     ecx, [ebp+var_C]
.text:00003118                 mov     large fs:0, ecx
.text:0000311F                 pop     ecx
.text:00003120                 add     esp, 20h
.text:00003123                 cmp     ebp, esp
.text:00003125                 call    __RTC_CheckEsp
.text:0000312A                 mov     esp, ebp
.text:0000312C                 pop     ebp
.text:0000312D                 retn
.text:0000312D ??1?$CObjectVector@VUString@@@@QAE@XZ endp
.text:0000312D
.text:0000312D ; ---------------------------------------------------------------------------
.text:0000312E                 align 10h
.text:0000312E _text           ends
.text:0000312E
.text$x:00003130 ; ===========================================================================
.text$x:00003130
.text$x:00003130 ; Segment type: Pure code
.text$x:00003130 ; Segment permissions: Read/Execute
.text$x:00003130 _text$x         segment para public 'CODE' use32
.text$x:00003130                 assume cs:_text$x
.text$x:00003130                 ;org 3130h
.text$x:00003130 ; COMDAT (pick associative to section at 3074)
.text$x:00003130                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003130
.text$x:00003130 ; =============== S U B R O U T I N E =======================================
.text$x:00003130
.text$x:00003130
.text$x:00003130 __unwindfunclet$??1?$CObjectVector@VUString@@@@QAE@XZ$0 proc near
.text$x:00003130                                         ; DATA XREF: .xdata$x:00003158o
.text$x:00003130                 mov     ecx, [ebp-10h]
.text$x:00003133                 jmp     ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text$x:00003133 __unwindfunclet$??1?$CObjectVector@VUString@@@@QAE@XZ$0 endp
.text$x:00003133
.text$x:00003138
.text$x:00003138 ; =============== S U B R O U T I N E =======================================
.text$x:00003138
.text$x:00003138
.text$x:00003138 __ehhandler$??1?$CObjectVector@VUString@@@@QAE@XZ proc near
.text$x:00003138                                         ; DATA XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+5o
.text$x:00003138
.text$x:00003138 arg_4           = dword ptr  8
.text$x:00003138
.text$x:00003138                 mov     edx, [esp+arg_4]
.text$x:0000313C                 lea     eax, [edx+0Ch]
.text$x:0000313F                 mov     ecx, [edx-18h]
.text$x:00003142                 xor     ecx, eax
.text$x:00003144                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003149                 mov     eax, offset __ehfuncinfo$??1?$CObjectVector@VUString@@@@QAE@XZ
.text$x:0000314E                 jmp     ___CxxFrameHandler3
.text$x:0000314E __ehhandler$??1?$CObjectVector@VUString@@@@QAE@XZ endp
.text$x:0000314E
.text$x:0000314E ; ---------------------------------------------------------------------------
.text$x:00003153                 align 4
.text$x:00003153 _text$x         ends
.text$x:00003153
.xdata$x:00003154 ; ===========================================================================
.xdata$x:00003154
.xdata$x:00003154 ; Segment type: Pure data
.xdata$x:00003154 ; Segment permissions: Read
.xdata$x:00003154 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003154                 assume cs:_xdata$x
.xdata$x:00003154                 ;org 3154h
.xdata$x:00003154 ; COMDAT (pick associative to section at 3074)
.xdata$x:00003154 __unwindtable$??1?$CObjectVector@VUString@@@@QAE@XZ db 0FFh
.xdata$x:00003154                                         ; DATA XREF: .xdata$x:00003164o
.xdata$x:00003155                 db 0FFh
.xdata$x:00003156                 db 0FFh
.xdata$x:00003157                 db 0FFh
.xdata$x:00003158                 dd offset __unwindfunclet$??1?$CObjectVector@VUString@@@@QAE@XZ$0
.xdata$x:0000315C __ehfuncinfo$??1?$CObjectVector@VUString@@@@QAE@XZ db  22h ; "
.xdata$x:0000315C                                         ; DATA XREF: __ehhandler$??1?$CObjectVector@VUString@@@@QAE@XZ+11o
.xdata$x:0000315D                 db    5
.xdata$x:0000315E                 db  93h ; Ã´
.xdata$x:0000315F                 db  19h
.xdata$x:00003160                 db    1
.xdata$x:00003161                 db    0
.xdata$x:00003162                 db    0
.xdata$x:00003163                 db    0
.xdata$x:00003164                 dd offset __unwindtable$??1?$CObjectVector@VUString@@@@QAE@XZ
.xdata$x:00003168                 db    0
.xdata$x:00003169                 db    0
.xdata$x:0000316A                 db    0
.xdata$x:0000316B                 db    0
.xdata$x:0000316C                 db    0
.xdata$x:0000316D                 db    0
.xdata$x:0000316E                 db    0
.xdata$x:0000316F                 db    0
.xdata$x:00003170                 db    0
.xdata$x:00003171                 db    0
.xdata$x:00003172                 db    0
.xdata$x:00003173                 db    0
.xdata$x:00003174                 db    0
.xdata$x:00003175                 db    0
.xdata$x:00003176                 db    0
.xdata$x:00003177                 db    0
.xdata$x:00003178                 db    0
.xdata$x:00003179                 db    0
.xdata$x:0000317A                 db    0
.xdata$x:0000317B                 db    0
.xdata$x:0000317C                 db    1
.xdata$x:0000317D                 db    0
.xdata$x:0000317E                 db    0
.xdata$x:0000317F                 db    0
.xdata$x:0000317F _xdata$x        ends
.xdata$x:0000317F
.text:00003180 ; ===========================================================================
.text:00003180
.text:00003180 ; Segment type: Pure code
.text:00003180 ; Segment permissions: Read/Execute
.text:00003180 _text           segment para public 'CODE' use32
.text:00003180                 assume cs:_text
.text:00003180                 ;org 3180h
.text:00003180 ; COMDAT (pick any)
.text:00003180                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003180
.text:00003180 ; =============== S U B R O U T I N E =======================================
.text:00003180
.text:00003180 ; Attributes: bp-based frame
.text:00003180
.text:00003180 ; public: struct CArcInfoEx & __thiscall CObjectVector<struct CArcInfoEx>::operator[](unsigned int)
.text:00003180                 public ??A?$CObjectVector@UCArcInfoEx@@@@QAEAAUCArcInfoEx@@I@Z
.text:00003180 ??A?$CObjectVector@UCArcInfoEx@@@@QAEAAUCArcInfoEx@@I@Z proc near
.text:00003180                                         ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+D5p
.text:00003180
.text:00003180 var_4           = dword ptr -4
.text:00003180 arg_0           = dword ptr  8
.text:00003180
.text:00003180                 push    ebp
.text:00003181                 mov     ebp, esp
.text:00003183                 push    ecx
.text:00003184                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000318B                 mov     [ebp+var_4], ecx
.text:0000318E                 mov     eax, [ebp+arg_0]
.text:00003191                 push    eax
.text:00003192                 mov     ecx, [ebp+var_4]
.text:00003195                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:0000319A                 mov     eax, [eax]
.text:0000319C                 add     esp, 4
.text:0000319F                 cmp     ebp, esp
.text:000031A1                 call    __RTC_CheckEsp
.text:000031A6                 mov     esp, ebp
.text:000031A8                 pop     ebp
.text:000031A9                 retn    4
.text:000031A9 ??A?$CObjectVector@UCArcInfoEx@@@@QAEAAUCArcInfoEx@@I@Z endp
.text:000031A9
.text:000031A9 _text           ends
.text:000031A9
.text:000031AC ; ===========================================================================
.text:000031AC
.text:000031AC ; Segment type: Pure code
.text:000031AC ; Segment permissions: Read/Execute
.text:000031AC _text           segment para public 'CODE' use32
.text:000031AC                 assume cs:_text
.text:000031AC                 ;org 31ACh
.text:000031AC ; COMDAT (pick any)
.text:000031AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000031AC
.text:000031AC ; =============== S U B R O U T I N E =======================================
.text:000031AC
.text:000031AC ; Attributes: bp-based frame
.text:000031AC
.text:000031AC ; public: __thiscall CMyComPtr<struct IInArchive>::operator struct IInArchive *(void)const
.text:000031AC                 public ??B?$CMyComPtr@UIInArchive@@@@QBEPAUIInArchive@@XZ
.text:000031AC ??B?$CMyComPtr@UIInArchive@@@@QBEPAUIInArchive@@XZ proc near
.text:000031AC                                         ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+5Ap
.text:000031AC                                         ; DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+40Dp
.text:000031AC
.text:000031AC var_4           = dword ptr -4
.text:000031AC
.text:000031AC                 push    ebp
.text:000031AD                 mov     ebp, esp
.text:000031AF                 push    ecx
.text:000031B0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000031B7                 mov     [ebp+var_4], ecx
.text:000031BA                 mov     eax, [ebp+var_4]
.text:000031BD                 mov     eax, [eax]
.text:000031BF                 mov     esp, ebp
.text:000031C1                 pop     ebp
.text:000031C2                 retn
.text:000031C2 ??B?$CMyComPtr@UIInArchive@@@@QBEPAUIInArchive@@XZ endp
.text:000031C2
.text:000031C2 ; ---------------------------------------------------------------------------
.text:000031C3                 align 4
.text:000031C3 _text           ends
.text:000031C3
.text:000031C4 ; ===========================================================================
.text:000031C4
.text:000031C4 ; Segment type: Pure code
.text:000031C4 ; Segment permissions: Read/Execute
.text:000031C4 _text           segment para public 'CODE' use32
.text:000031C4                 assume cs:_text
.text:000031C4                 ;org 31C4h
.text:000031C4 ; COMDAT (pick any)
.text:000031C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000031C4
.text:000031C4 ; =============== S U B R O U T I N E =======================================
.text:000031C4
.text:000031C4 ; Attributes: bp-based frame
.text:000031C4
.text:000031C4 ; public: __thiscall CRecordVector<unsigned __int64>::CRecordVector<unsigned __int64>(void)
.text:000031C4                 public ??0?$CRecordVector@_K@@QAE@XZ
.text:000031C4 ??0?$CRecordVector@_K@@QAE@XZ proc near ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+55p
.text:000031C4
.text:000031C4 var_4           = dword ptr -4
.text:000031C4
.text:000031C4                 push    ebp
.text:000031C5                 mov     ebp, esp
.text:000031C7                 push    ecx
.text:000031C8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000031CF                 mov     [ebp+var_4], ecx
.text:000031D2                 mov     eax, [ebp+var_4]
.text:000031D5                 mov     dword ptr [eax], 0
.text:000031DB                 mov     ecx, [ebp+var_4]
.text:000031DE                 mov     dword ptr [ecx+4], 0
.text:000031E5                 mov     edx, [ebp+var_4]
.text:000031E8                 mov     dword ptr [edx+8], 0
.text:000031EF                 mov     eax, [ebp+var_4]
.text:000031F2                 mov     esp, ebp
.text:000031F4                 pop     ebp
.text:000031F5                 retn
.text:000031F5 ??0?$CRecordVector@_K@@QAE@XZ endp
.text:000031F5
.text:000031F5 ; ---------------------------------------------------------------------------
.text:000031F6                 align 4
.text:000031F6 _text           ends
.text:000031F6
.text:000031F8 ; ===========================================================================
.text:000031F8
.text:000031F8 ; Segment type: Pure code
.text:000031F8 ; Segment permissions: Read/Execute
.text:000031F8 _text           segment para public 'CODE' use32
.text:000031F8                 assume cs:_text
.text:000031F8                 ;org 31F8h
.text:000031F8 ; COMDAT (pick any)
.text:000031F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000031F8
.text:000031F8 ; =============== S U B R O U T I N E =======================================
.text:000031F8
.text:000031F8 ; Attributes: bp-based frame
.text:000031F8
.text:000031F8 ; public: __thiscall CRecordVector<unsigned __int64>::~CRecordVector<unsigned __int64>(void)
.text:000031F8                 public ??1?$CRecordVector@_K@@QAE@XZ
.text:000031F8 ??1?$CRecordVector@_K@@QAE@XZ proc near ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+2C7p
.text:000031F8                                         ; Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+435p ...
.text:000031F8
.text:000031F8 var_8           = dword ptr -8
.text:000031F8 var_4           = dword ptr -4
.text:000031F8
.text:000031F8                 push    ebp
.text:000031F9                 mov     ebp, esp
.text:000031FB                 sub     esp, 8
.text:000031FE                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00003205                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000320C                 mov     [ebp+var_4], ecx
.text:0000320F                 mov     eax, [ebp+var_4]
.text:00003212                 mov     ecx, [eax]
.text:00003214                 mov     [ebp+var_8], ecx
.text:00003217                 mov     edx, [ebp+var_8]
.text:0000321A                 push    edx             ; void *
.text:0000321B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00003220                 add     esp, 4
.text:00003223                 add     esp, 8
.text:00003226                 cmp     ebp, esp
.text:00003228                 call    __RTC_CheckEsp
.text:0000322D                 mov     esp, ebp
.text:0000322F                 pop     ebp
.text:00003230                 retn
.text:00003230 ??1?$CRecordVector@_K@@QAE@XZ endp
.text:00003230
.text:00003230 ; ---------------------------------------------------------------------------
.text:00003231                 align 4
.text:00003231 _text           ends
.text:00003231
.text:00003234 ; ===========================================================================
.text:00003234
.text:00003234 ; Segment type: Pure code
.text:00003234 ; Segment permissions: Read/Execute
.text:00003234 _text           segment para public 'CODE' use32
.text:00003234                 assume cs:_text
.text:00003234                 ;org 3234h
.text:00003234 ; COMDAT (pick any)
.text:00003234                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003234
.text:00003234 ; =============== S U B R O U T I N E =======================================
.text:00003234
.text:00003234 ; Attributes: bp-based frame
.text:00003234
.text:00003234 ; public: unsigned int __thiscall CRecordVector<unsigned __int64>::Add(unsigned __int64)
.text:00003234                 public ?Add@?$CRecordVector@_K@@QAEI_K@Z
.text:00003234 ?Add@?$CRecordVector@_K@@QAEI_K@Z proc near
.text:00003234                                         ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+149p
.text:00003234
.text:00003234 var_8           = dword ptr -8
.text:00003234 var_4           = dword ptr -4
.text:00003234 arg_0           = dword ptr  8
.text:00003234 arg_4           = dword ptr  0Ch
.text:00003234
.text:00003234                 push    ebp
.text:00003235                 mov     ebp, esp
.text:00003237                 sub     esp, 8
.text:0000323A                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00003241                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003248                 mov     [ebp+var_4], ecx
.text:0000324B                 mov     ecx, [ebp+var_4]
.text:0000324E                 call    ?ReserveOnePosition@?$CRecordVector@_K@@AAEXXZ ; CRecordVector<unsigned __int64>::ReserveOnePosition(void)
.text:00003253                 mov     eax, [ebp+var_4]
.text:00003256                 mov     ecx, [eax+4]
.text:00003259                 mov     edx, [ebp+var_4]
.text:0000325C                 mov     eax, [edx]
.text:0000325E                 mov     edx, [ebp+arg_0]
.text:00003261                 mov     [eax+ecx*8], edx
.text:00003264                 mov     edx, [ebp+arg_4]
.text:00003267                 mov     [eax+ecx*8+4], edx
.text:0000326B                 mov     eax, [ebp+var_4]
.text:0000326E                 mov     ecx, [eax+4]
.text:00003271                 mov     [ebp+var_8], ecx
.text:00003274                 mov     edx, [ebp+var_4]
.text:00003277                 mov     eax, [edx+4]
.text:0000327A                 add     eax, 1
.text:0000327D                 mov     ecx, [ebp+var_4]
.text:00003280                 mov     [ecx+4], eax
.text:00003283                 mov     eax, [ebp+var_8]
.text:00003286                 add     esp, 8
.text:00003289                 cmp     ebp, esp
.text:0000328B                 call    __RTC_CheckEsp
.text:00003290                 mov     esp, ebp
.text:00003292                 pop     ebp
.text:00003293                 retn    8
.text:00003293 ?Add@?$CRecordVector@_K@@QAEI_K@Z endp
.text:00003293
.text:00003293 ; ---------------------------------------------------------------------------
.text:00003296                 align 4
.text:00003296 _text           ends
.text:00003296
.text:00003298 ; ===========================================================================
.text:00003298
.text:00003298 ; Segment type: Pure code
.text:00003298 ; Segment permissions: Read/Execute
.text:00003298 _text           segment para public 'CODE' use32
.text:00003298                 assume cs:_text
.text:00003298                 ;org 3298h
.text:00003298 ; COMDAT (pick any)
.text:00003298                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003298
.text:00003298 ; =============== S U B R O U T I N E =======================================
.text:00003298
.text:00003298 ; Attributes: bp-based frame
.text:00003298
.text:00003298 ; public: unsigned __int64 & __thiscall CRecordVector<unsigned __int64>::operator[](unsigned int)
.text:00003298                 public ??A?$CRecordVector@_K@@QAEAA_KI@Z
.text:00003298 ??A?$CRecordVector@_K@@QAEAA_KI@Z proc near
.text:00003298                                         ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+7D5p
.text:00003298
.text:00003298 var_4           = dword ptr -4
.text:00003298 arg_0           = dword ptr  8
.text:00003298
.text:00003298                 push    ebp
.text:00003299                 mov     ebp, esp
.text:0000329B                 push    ecx
.text:0000329C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000032A3                 mov     [ebp+var_4], ecx
.text:000032A6                 mov     eax, [ebp+var_4]
.text:000032A9                 mov     ecx, [eax]
.text:000032AB                 mov     edx, [ebp+arg_0]
.text:000032AE                 lea     eax, [ecx+edx*8]
.text:000032B1                 mov     esp, ebp
.text:000032B3                 pop     ebp
.text:000032B4                 retn    4
.text:000032B4 ??A?$CRecordVector@_K@@QAEAA_KI@Z endp
.text:000032B4
.text:000032B4 ; ---------------------------------------------------------------------------
.text:000032B7                 align 4
.text:000032B7 _text           ends
.text:000032B7
.text:000032B8 ; ===========================================================================
.text:000032B8
.text:000032B8 ; Segment type: Pure code
.text:000032B8 ; Segment permissions: Read/Execute
.text:000032B8 _text           segment para public 'CODE' use32
.text:000032B8                 assume cs:_text
.text:000032B8                 ;org 32B8h
.text:000032B8 ; COMDAT (pick any)
.text:000032B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000032B8
.text:000032B8 ; =============== S U B R O U T I N E =======================================
.text:000032B8
.text:000032B8 ; Attributes: bp-based frame
.text:000032B8
.text:000032B8 ; public: unsigned int __thiscall CObjectVector<class CArc>::Size(void)const
.text:000032B8                 public ?Size@?$CObjectVector@VCArc@@@@QBEIXZ
.text:000032B8 ?Size@?$CObjectVector@VCArc@@@@QBEIXZ proc near
.text:000032B8                                         ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+A9p
.text:000032B8
.text:000032B8 var_4           = dword ptr -4
.text:000032B8
.text:000032B8                 push    ebp
.text:000032B9                 mov     ebp, esp
.text:000032BB                 push    ecx
.text:000032BC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000032C3                 mov     [ebp+var_4], ecx
.text:000032C6                 mov     ecx, [ebp+var_4]
.text:000032C9                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:000032CE                 add     esp, 4
.text:000032D1                 cmp     ebp, esp
.text:000032D3                 call    __RTC_CheckEsp
.text:000032D8                 mov     esp, ebp
.text:000032DA                 pop     ebp
.text:000032DB                 retn
.text:000032DB ?Size@?$CObjectVector@VCArc@@@@QBEIXZ endp
.text:000032DB
.text:000032DB _text           ends
.text:000032DB
.text:000032DC ; ===========================================================================
.text:000032DC
.text:000032DC ; Segment type: Pure code
.text:000032DC ; Segment permissions: Read/Execute
.text:000032DC _text           segment para public 'CODE' use32
.text:000032DC                 assume cs:_text
.text:000032DC                 ;org 32DCh
.text:000032DC ; COMDAT (pick any)
.text:000032DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000032DC
.text:000032DC ; =============== S U B R O U T I N E =======================================
.text:000032DC
.text:000032DC ; Attributes: bp-based frame
.text:000032DC
.text:000032DC ; public: __thiscall CObjectVector<class CArc>::CObjectVector<class CArc>(void)
.text:000032DC                 public ??0?$CObjectVector@VCArc@@@@QAE@XZ
.text:000032DC ??0?$CObjectVector@VCArc@@@@QAE@XZ proc near
.text:000032DC                                         ; CODE XREF: CArchiveLink::CArchiveLink(void)+30p
.text:000032DC
.text:000032DC var_4           = dword ptr -4
.text:000032DC
.text:000032DC                 push    ebp
.text:000032DD                 mov     ebp, esp
.text:000032DF                 push    ecx
.text:000032E0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000032E7                 mov     [ebp+var_4], ecx
.text:000032EA                 mov     ecx, [ebp+var_4]
.text:000032ED                 call    ??0?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::CRecordVector<void *>(void)
.text:000032F2                 mov     eax, [ebp+var_4]
.text:000032F5                 add     esp, 4
.text:000032F8                 cmp     ebp, esp
.text:000032FA                 call    __RTC_CheckEsp
.text:000032FF                 mov     esp, ebp
.text:00003301                 pop     ebp
.text:00003302                 retn
.text:00003302 ??0?$CObjectVector@VCArc@@@@QAE@XZ endp
.text:00003302
.text:00003302 ; ---------------------------------------------------------------------------
.text:00003303                 align 4
.text:00003303 _text           ends
.text:00003303
.text:00003304 ; ===========================================================================
.text:00003304
.text:00003304 ; Segment type: Pure code
.text:00003304 ; Segment permissions: Read/Execute
.text:00003304 _text           segment para public 'CODE' use32
.text:00003304                 assume cs:_text
.text:00003304                 ;org 3304h
.text:00003304 ; COMDAT (pick any)
.text:00003304                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003304
.text:00003304 ; =============== S U B R O U T I N E =======================================
.text:00003304
.text:00003304 ; Attributes: bp-based frame
.text:00003304
.text:00003304 ; public: class CArc const & __thiscall CObjectVector<class CArc>::operator[](unsigned int)const
.text:00003304                 public ??A?$CObjectVector@VCArc@@@@QBEABVCArc@@I@Z
.text:00003304 ??A?$CObjectVector@VCArc@@@@QBEABVCArc@@I@Z proc near
.text:00003304                                         ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+B8p
.text:00003304                                         ; CObjectVector<CArc>::Back(void)+1Dp
.text:00003304
.text:00003304 var_4           = dword ptr -4
.text:00003304 arg_0           = dword ptr  8
.text:00003304
.text:00003304                 push    ebp
.text:00003305                 mov     ebp, esp
.text:00003307                 push    ecx
.text:00003308                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000330F                 mov     [ebp+var_4], ecx
.text:00003312                 mov     eax, [ebp+arg_0]
.text:00003315                 push    eax
.text:00003316                 mov     ecx, [ebp+var_4]
.text:00003319                 call    ??A?$CRecordVector@PAX@@QBEABQAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:0000331E                 mov     eax, [eax]
.text:00003320                 add     esp, 4
.text:00003323                 cmp     ebp, esp
.text:00003325                 call    __RTC_CheckEsp
.text:0000332A                 mov     esp, ebp
.text:0000332C                 pop     ebp
.text:0000332D                 retn    4
.text:0000332D ??A?$CObjectVector@VCArc@@@@QBEABVCArc@@I@Z endp
.text:0000332D
.text:0000332D _text           ends
.text:0000332D
.text:00003330 ; ===========================================================================
.text:00003330
.text:00003330 ; Segment type: Pure code
.text:00003330 ; Segment permissions: Read/Execute
.text:00003330 _text           segment para public 'CODE' use32
.text:00003330                 assume cs:_text
.text:00003330                 ;org 3330h
.text:00003330 ; COMDAT (pick any)
.text:00003330                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003330
.text:00003330 ; =============== S U B R O U T I N E =======================================
.text:00003330
.text:00003330 ; Attributes: bp-based frame
.text:00003330
.text:00003330 ; public: class CArc const & __thiscall CObjectVector<class CArc>::Back(void)const
.text:00003330                 public ?Back@?$CObjectVector@VCArc@@@@QBEABVCArc@@XZ
.text:00003330 ?Back@?$CObjectVector@VCArc@@@@QBEABVCArc@@XZ proc near
.text:00003330                                         ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+3Fp
.text:00003330
.text:00003330 var_4           = dword ptr -4
.text:00003330
.text:00003330                 push    ebp
.text:00003331                 mov     ebp, esp
.text:00003333                 push    ecx
.text:00003334                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000333B                 mov     [ebp+var_4], ecx
.text:0000333E                 mov     ecx, [ebp+var_4]
.text:00003341                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00003346                 sub     eax, 1
.text:00003349                 push    eax
.text:0000334A                 mov     ecx, [ebp+var_4]
.text:0000334D                 call    ??A?$CObjectVector@VCArc@@@@QBEABVCArc@@I@Z ; CObjectVector<CArc>::operator[](uint)
.text:00003352                 add     esp, 4
.text:00003355                 cmp     ebp, esp
.text:00003357                 call    __RTC_CheckEsp
.text:0000335C                 mov     esp, ebp
.text:0000335E                 pop     ebp
.text:0000335F                 retn
.text:0000335F ?Back@?$CObjectVector@VCArc@@@@QBEABVCArc@@XZ endp
.text:0000335F
.text:0000335F _text           ends
.text:0000335F
.text:00003360 ; ===========================================================================
.text:00003360
.text:00003360 ; Segment type: Pure code
.text:00003360 ; Segment permissions: Read/Execute
.text:00003360 _text           segment para public 'CODE' use32
.text:00003360                 assume cs:_text
.text:00003360                 ;org 3360h
.text:00003360 ; COMDAT (pick any)
.text:00003360                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003360
.text:00003360 ; =============== S U B R O U T I N E =======================================
.text:00003360
.text:00003360 ; Attributes: bp-based frame
.text:00003360
.text:00003360 ; public: class CArc & __thiscall CObjectVector<class CArc>::Back(void)
.text:00003360                 public ?Back@?$CObjectVector@VCArc@@@@QAEAAVCArc@@XZ
.text:00003360 ?Back@?$CObjectVector@VCArc@@@@QAEAAVCArc@@XZ proc near
.text:00003360                                         ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+917p
.text:00003360
.text:00003360 var_4           = dword ptr -4
.text:00003360
.text:00003360                 push    ebp
.text:00003361                 mov     ebp, esp
.text:00003363                 push    ecx
.text:00003364                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000336B                 mov     [ebp+var_4], ecx
.text:0000336E                 mov     ecx, [ebp+var_4]
.text:00003371                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00003376                 sub     eax, 1
.text:00003379                 push    eax
.text:0000337A                 mov     ecx, [ebp+var_4]
.text:0000337D                 call    ??A?$CObjectVector@VCArc@@@@QAEAAVCArc@@I@Z ; CObjectVector<CArc>::operator[](uint)
.text:00003382                 add     esp, 4
.text:00003385                 cmp     ebp, esp
.text:00003387                 call    __RTC_CheckEsp
.text:0000338C                 mov     esp, ebp
.text:0000338E                 pop     ebp
.text:0000338F                 retn
.text:0000338F ?Back@?$CObjectVector@VCArc@@@@QAEAAVCArc@@XZ endp
.text:0000338F
.text:0000338F _text           ends
.text:0000338F
.text:00003390 ; ===========================================================================
.text:00003390
.text:00003390 ; Segment type: Pure code
.text:00003390 ; Segment permissions: Read/Execute
.text:00003390 _text           segment para public 'CODE' use32
.text:00003390                 assume cs:_text
.text:00003390                 ;org 3390h
.text:00003390 ; COMDAT (pick any)
.text:00003390                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003390
.text:00003390 ; =============== S U B R O U T I N E =======================================
.text:00003390
.text:00003390 ; Attributes: bp-based frame
.text:00003390
.text:00003390 ; public: __thiscall CObjectVector<class CArc>::~CObjectVector<class CArc>(void)
.text:00003390                 public ??1?$CObjectVector@VCArc@@@@QAE@XZ
.text:00003390 ??1?$CObjectVector@VCArc@@@@QAE@XZ proc near
.text:00003390                                         ; CODE XREF: __unwindfunclet$??0CArchiveLink@@QAE@XZ$0+3j
.text:00003390                                         ; CArchiveLink::~CArchiveLink(void)+73p ...
.text:00003390
.text:00003390 var_20          = dword ptr -20h
.text:00003390 var_1C          = dword ptr -1Ch
.text:00003390 var_18          = dword ptr -18h
.text:00003390 var_14          = dword ptr -14h
.text:00003390 var_10          = dword ptr -10h
.text:00003390 var_C           = dword ptr -0Ch
.text:00003390 var_4           = dword ptr -4
.text:00003390
.text:00003390                 push    ebp
.text:00003391                 mov     ebp, esp
.text:00003393                 push    0FFFFFFFFh
.text:00003395                 push    offset __ehhandler$??1?$CObjectVector@VCArc@@@@QAE@XZ
.text:0000339A                 mov     eax, large fs:0
.text:000033A0                 push    eax
.text:000033A1                 sub     esp, 14h
.text:000033A4                 mov     eax, 0CCCCCCCCh
.text:000033A9                 mov     [ebp+var_20], eax
.text:000033AC                 mov     [ebp+var_1C], eax
.text:000033AF                 mov     [ebp+var_18], eax
.text:000033B2                 mov     [ebp+var_14], eax
.text:000033B5                 mov     [ebp+var_10], eax
.text:000033B8                 mov     eax, dword ptr ds:___security_cookie
.text:000033BD                 xor     eax, ebp
.text:000033BF                 push    eax
.text:000033C0                 lea     eax, [ebp+var_C]
.text:000033C3                 mov     large fs:0, eax
.text:000033C9                 mov     [ebp+var_10], ecx
.text:000033CC                 mov     [ebp+var_4], 0
.text:000033D3                 mov     ecx, [ebp+var_10]
.text:000033D6                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:000033DB                 mov     [ebp+var_14], eax
.text:000033DE
.text:000033DE loc_33DE:                               ; CODE XREF: CObjectVector<CArc>::~CObjectVector<CArc>(void):loc_3420j
.text:000033DE                 cmp     [ebp+var_14], 0
.text:000033E2                 jz      short loc_3422
.text:000033E4                 mov     eax, [ebp+var_14]
.text:000033E7                 sub     eax, 1
.text:000033EA                 mov     [ebp+var_14], eax
.text:000033ED                 mov     ecx, [ebp+var_14]
.text:000033F0                 push    ecx
.text:000033F1                 mov     ecx, [ebp+var_10]
.text:000033F4                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:000033F9                 mov     edx, [eax]
.text:000033FB                 mov     [ebp+var_1C], edx
.text:000033FE                 mov     eax, [ebp+var_1C]
.text:00003401                 mov     [ebp+var_18], eax
.text:00003404                 cmp     [ebp+var_18], 0
.text:00003408                 jz      short loc_3419
.text:0000340A                 push    1
.text:0000340C                 mov     ecx, [ebp+var_18]
.text:0000340F                 call    ??_GCArc@@QAEPAXI@Z ; CArc::`scalar deleting destructor'(uint)
.text:00003414                 mov     [ebp+var_20], eax
.text:00003417                 jmp     short loc_3420
.text:00003419 ; ---------------------------------------------------------------------------
.text:00003419
.text:00003419 loc_3419:                               ; CODE XREF: CObjectVector<CArc>::~CObjectVector<CArc>(void)+78j
.text:00003419                 mov     [ebp+var_20], 0
.text:00003420
.text:00003420 loc_3420:                               ; CODE XREF: CObjectVector<CArc>::~CObjectVector<CArc>(void)+87j
.text:00003420                 jmp     short loc_33DE
.text:00003422 ; ---------------------------------------------------------------------------
.text:00003422
.text:00003422 loc_3422:                               ; CODE XREF: CObjectVector<CArc>::~CObjectVector<CArc>(void)+52j
.text:00003422                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00003429                 mov     ecx, [ebp+var_10]
.text:0000342C                 call    ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text:00003431                 mov     ecx, [ebp+var_C]
.text:00003434                 mov     large fs:0, ecx
.text:0000343B                 pop     ecx
.text:0000343C                 add     esp, 20h
.text:0000343F                 cmp     ebp, esp
.text:00003441                 call    __RTC_CheckEsp
.text:00003446                 mov     esp, ebp
.text:00003448                 pop     ebp
.text:00003449                 retn
.text:00003449 ??1?$CObjectVector@VCArc@@@@QAE@XZ endp
.text:00003449
.text:00003449 ; ---------------------------------------------------------------------------
.text:0000344A                 align 4
.text:0000344A _text           ends
.text:0000344A
.text$x:0000344C ; ===========================================================================
.text$x:0000344C
.text$x:0000344C ; Segment type: Pure code
.text$x:0000344C ; Segment permissions: Read/Execute
.text$x:0000344C _text$x         segment para public 'CODE' use32
.text$x:0000344C                 assume cs:_text$x
.text$x:0000344C                 ;org 344Ch
.text$x:0000344C ; COMDAT (pick associative to section at 3390)
.text$x:0000344C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000344C
.text$x:0000344C ; =============== S U B R O U T I N E =======================================
.text$x:0000344C
.text$x:0000344C
.text$x:0000344C __unwindfunclet$??1?$CObjectVector@VCArc@@@@QAE@XZ$0 proc near
.text$x:0000344C                                         ; DATA XREF: .xdata$x:00003474o
.text$x:0000344C                 mov     ecx, [ebp-10h]
.text$x:0000344F                 jmp     ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text$x:0000344F __unwindfunclet$??1?$CObjectVector@VCArc@@@@QAE@XZ$0 endp
.text$x:0000344F
.text$x:00003454
.text$x:00003454 ; =============== S U B R O U T I N E =======================================
.text$x:00003454
.text$x:00003454
.text$x:00003454 __ehhandler$??1?$CObjectVector@VCArc@@@@QAE@XZ proc near
.text$x:00003454                                         ; DATA XREF: CObjectVector<CArc>::~CObjectVector<CArc>(void)+5o
.text$x:00003454
.text$x:00003454 arg_4           = dword ptr  8
.text$x:00003454
.text$x:00003454                 mov     edx, [esp+arg_4]
.text$x:00003458                 lea     eax, [edx+0Ch]
.text$x:0000345B                 mov     ecx, [edx-18h]
.text$x:0000345E                 xor     ecx, eax
.text$x:00003460                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003465                 mov     eax, offset __ehfuncinfo$??1?$CObjectVector@VCArc@@@@QAE@XZ
.text$x:0000346A                 jmp     ___CxxFrameHandler3
.text$x:0000346A __ehhandler$??1?$CObjectVector@VCArc@@@@QAE@XZ endp
.text$x:0000346A
.text$x:0000346A ; ---------------------------------------------------------------------------
.text$x:0000346F                 align 10h
.text$x:0000346F _text$x         ends
.text$x:0000346F
.xdata$x:00003470 ; ===========================================================================
.xdata$x:00003470
.xdata$x:00003470 ; Segment type: Pure data
.xdata$x:00003470 ; Segment permissions: Read
.xdata$x:00003470 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003470                 assume cs:_xdata$x
.xdata$x:00003470                 ;org 3470h
.xdata$x:00003470 ; COMDAT (pick associative to section at 3390)
.xdata$x:00003470 __unwindtable$??1?$CObjectVector@VCArc@@@@QAE@XZ db 0FFh
.xdata$x:00003470                                         ; DATA XREF: .xdata$x:00003480o
.xdata$x:00003471                 db 0FFh
.xdata$x:00003472                 db 0FFh
.xdata$x:00003473                 db 0FFh
.xdata$x:00003474                 dd offset __unwindfunclet$??1?$CObjectVector@VCArc@@@@QAE@XZ$0
.xdata$x:00003478 __ehfuncinfo$??1?$CObjectVector@VCArc@@@@QAE@XZ db  22h ; "
.xdata$x:00003478                                         ; DATA XREF: __ehhandler$??1?$CObjectVector@VCArc@@@@QAE@XZ+11o
.xdata$x:00003479                 db    5
.xdata$x:0000347A                 db  93h ; Ã´
.xdata$x:0000347B                 db  19h
.xdata$x:0000347C                 db    1
.xdata$x:0000347D                 db    0
.xdata$x:0000347E                 db    0
.xdata$x:0000347F                 db    0
.xdata$x:00003480                 dd offset __unwindtable$??1?$CObjectVector@VCArc@@@@QAE@XZ
.xdata$x:00003484                 db    0
.xdata$x:00003485                 db    0
.xdata$x:00003486                 db    0
.xdata$x:00003487                 db    0
.xdata$x:00003488                 db    0
.xdata$x:00003489                 db    0
.xdata$x:0000348A                 db    0
.xdata$x:0000348B                 db    0
.xdata$x:0000348C                 db    0
.xdata$x:0000348D                 db    0
.xdata$x:0000348E                 db    0
.xdata$x:0000348F                 db    0
.xdata$x:00003490                 db    0
.xdata$x:00003491                 db    0
.xdata$x:00003492                 db    0
.xdata$x:00003493                 db    0
.xdata$x:00003494                 db    0
.xdata$x:00003495                 db    0
.xdata$x:00003496                 db    0
.xdata$x:00003497                 db    0
.xdata$x:00003498                 db    1
.xdata$x:00003499                 db    0
.xdata$x:0000349A                 db    0
.xdata$x:0000349B                 db    0
.xdata$x:0000349B _xdata$x        ends
.xdata$x:0000349B
.text:0000349C ; ===========================================================================
.text:0000349C
.text:0000349C ; Segment type: Pure code
.text:0000349C ; Segment permissions: Read/Execute
.text:0000349C _text           segment para public 'CODE' use32
.text:0000349C                 assume cs:_text
.text:0000349C                 ;org 349Ch
.text:0000349C ; COMDAT (pick any)
.text:0000349C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000349C
.text:0000349C ; =============== S U B R O U T I N E =======================================
.text:0000349C
.text:0000349C ; Attributes: bp-based frame
.text:0000349C
.text:0000349C ; public: __thiscall CRecordVector<unsigned int>::CRecordVector<unsigned int>(void)
.text:0000349C                 public ??0?$CRecordVector@I@@QAE@XZ
.text:0000349C ??0?$CRecordVector@I@@QAE@XZ proc near  ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+65p
.text:0000349C
.text:0000349C var_4           = dword ptr -4
.text:0000349C
.text:0000349C                 push    ebp
.text:0000349D                 mov     ebp, esp
.text:0000349F                 push    ecx
.text:000034A0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000034A7                 mov     [ebp+var_4], ecx
.text:000034AA                 mov     eax, [ebp+var_4]
.text:000034AD                 mov     dword ptr [eax], 0
.text:000034B3                 mov     ecx, [ebp+var_4]
.text:000034B6                 mov     dword ptr [ecx+4], 0
.text:000034BD                 mov     edx, [ebp+var_4]
.text:000034C0                 mov     dword ptr [edx+8], 0
.text:000034C7                 mov     eax, [ebp+var_4]
.text:000034CA                 mov     esp, ebp
.text:000034CC                 pop     ebp
.text:000034CD                 retn
.text:000034CD ??0?$CRecordVector@I@@QAE@XZ endp
.text:000034CD
.text:000034CD ; ---------------------------------------------------------------------------
.text:000034CE                 align 10h
.text:000034CE _text           ends
.text:000034CE
.text:000034D0 ; ===========================================================================
.text:000034D0
.text:000034D0 ; Segment type: Pure code
.text:000034D0 ; Segment permissions: Read/Execute
.text:000034D0 _text           segment para public 'CODE' use32
.text:000034D0                 assume cs:_text
.text:000034D0                 ;org 34D0h
.text:000034D0 ; COMDAT (pick any)
.text:000034D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000034D0
.text:000034D0 ; =============== S U B R O U T I N E =======================================
.text:000034D0
.text:000034D0 ; Attributes: bp-based frame
.text:000034D0
.text:000034D0 ; public: unsigned int __thiscall CRecordVector<unsigned int>::Size(void)const
.text:000034D0                 public ?Size@?$CRecordVector@I@@QBEIXZ
.text:000034D0 ?Size@?$CRecordVector@I@@QBEIXZ proc near
.text:000034D0                                         ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+587p
.text:000034D0                                         ; DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+8FCp
.text:000034D0
.text:000034D0 var_4           = dword ptr -4
.text:000034D0
.text:000034D0                 push    ebp
.text:000034D1                 mov     ebp, esp
.text:000034D3                 push    ecx
.text:000034D4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000034DB                 mov     [ebp+var_4], ecx
.text:000034DE                 mov     eax, [ebp+var_4]
.text:000034E1                 mov     eax, [eax+4]
.text:000034E4                 mov     esp, ebp
.text:000034E6                 pop     ebp
.text:000034E7                 retn
.text:000034E7 ?Size@?$CRecordVector@I@@QBEIXZ endp
.text:000034E7
.text:000034E7 _text           ends
.text:000034E7
.text:000034E8 ; ===========================================================================
.text:000034E8
.text:000034E8 ; Segment type: Pure code
.text:000034E8 ; Segment permissions: Read/Execute
.text:000034E8 _text           segment para public 'CODE' use32
.text:000034E8                 assume cs:_text
.text:000034E8                 ;org 34E8h
.text:000034E8 ; COMDAT (pick any)
.text:000034E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000034E8
.text:000034E8 ; =============== S U B R O U T I N E =======================================
.text:000034E8
.text:000034E8 ; Attributes: bp-based frame
.text:000034E8
.text:000034E8 ; public: __thiscall CRecordVector<unsigned int>::~CRecordVector<unsigned int>(void)
.text:000034E8                 public ??1?$CRecordVector@I@@QAE@XZ
.text:000034E8 ??1?$CRecordVector@I@@QAE@XZ proc near  ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+2D3p
.text:000034E8                                         ; DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+3BFp ...
.text:000034E8
.text:000034E8 var_8           = dword ptr -8
.text:000034E8 var_4           = dword ptr -4
.text:000034E8
.text:000034E8                 push    ebp
.text:000034E9                 mov     ebp, esp
.text:000034EB                 sub     esp, 8
.text:000034EE                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000034F5                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000034FC                 mov     [ebp+var_4], ecx
.text:000034FF                 mov     eax, [ebp+var_4]
.text:00003502                 mov     ecx, [eax]
.text:00003504                 mov     [ebp+var_8], ecx
.text:00003507                 mov     edx, [ebp+var_8]
.text:0000350A                 push    edx             ; void *
.text:0000350B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00003510                 add     esp, 4
.text:00003513                 add     esp, 8
.text:00003516                 cmp     ebp, esp
.text:00003518                 call    __RTC_CheckEsp
.text:0000351D                 mov     esp, ebp
.text:0000351F                 pop     ebp
.text:00003520                 retn
.text:00003520 ??1?$CRecordVector@I@@QAE@XZ endp
.text:00003520
.text:00003520 ; ---------------------------------------------------------------------------
.text:00003521                 align 4
.text:00003521 _text           ends
.text:00003521
.text:00003524 ; ===========================================================================
.text:00003524
.text:00003524 ; Segment type: Pure code
.text:00003524 ; Segment permissions: Read/Execute
.text:00003524 _text           segment para public 'CODE' use32
.text:00003524                 assume cs:_text
.text:00003524                 ;org 3524h
.text:00003524 ; COMDAT (pick any)
.text:00003524                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003524
.text:00003524 ; =============== S U B R O U T I N E =======================================
.text:00003524
.text:00003524 ; Attributes: bp-based frame
.text:00003524
.text:00003524 ; public: unsigned int __thiscall CRecordVector<unsigned int>::Add(unsigned int)
.text:00003524                 public ?Add@?$CRecordVector@I@@QAEII@Z
.text:00003524 ?Add@?$CRecordVector@I@@QAEII@Z proc near
.text:00003524                                         ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+57Ap
.text:00003524
.text:00003524 var_8           = dword ptr -8
.text:00003524 var_4           = dword ptr -4
.text:00003524 arg_0           = dword ptr  8
.text:00003524
.text:00003524                 push    ebp
.text:00003525                 mov     ebp, esp
.text:00003527                 sub     esp, 8
.text:0000352A                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00003531                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003538                 mov     [ebp+var_4], ecx
.text:0000353B                 mov     ecx, [ebp+var_4]
.text:0000353E                 call    ?ReserveOnePosition@?$CRecordVector@I@@AAEXXZ ; CRecordVector<uint>::ReserveOnePosition(void)
.text:00003543                 mov     eax, [ebp+var_4]
.text:00003546                 mov     ecx, [eax+4]
.text:00003549                 mov     edx, [ebp+var_4]
.text:0000354C                 mov     eax, [edx]
.text:0000354E                 mov     edx, [ebp+arg_0]
.text:00003551                 mov     [eax+ecx*4], edx
.text:00003554                 mov     eax, [ebp+var_4]
.text:00003557                 mov     ecx, [eax+4]
.text:0000355A                 mov     [ebp+var_8], ecx
.text:0000355D                 mov     edx, [ebp+var_4]
.text:00003560                 mov     eax, [edx+4]
.text:00003563                 add     eax, 1
.text:00003566                 mov     ecx, [ebp+var_4]
.text:00003569                 mov     [ecx+4], eax
.text:0000356C                 mov     eax, [ebp+var_8]
.text:0000356F                 add     esp, 8
.text:00003572                 cmp     ebp, esp
.text:00003574                 call    __RTC_CheckEsp
.text:00003579                 mov     esp, ebp
.text:0000357B                 pop     ebp
.text:0000357C                 retn    4
.text:0000357C ?Add@?$CRecordVector@I@@QAEII@Z endp
.text:0000357C
.text:0000357C ; ---------------------------------------------------------------------------
.text:0000357F                 align 10h
.text:0000357F _text           ends
.text:0000357F
.text:00003580 ; ===========================================================================
.text:00003580
.text:00003580 ; Segment type: Pure code
.text:00003580 ; Segment permissions: Read/Execute
.text:00003580 _text           segment para public 'CODE' use32
.text:00003580                 assume cs:_text
.text:00003580                 ;org 3580h
.text:00003580 ; COMDAT (pick any)
.text:00003580                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003580
.text:00003580 ; =============== S U B R O U T I N E =======================================
.text:00003580
.text:00003580 ; Attributes: bp-based frame
.text:00003580
.text:00003580 ; public: unsigned int & __thiscall CRecordVector<unsigned int>::Front(void)
.text:00003580                 public ?Front@?$CRecordVector@I@@QAEAAIXZ
.text:00003580 ?Front@?$CRecordVector@I@@QAEAAIXZ proc near
.text:00003580                                         ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+905p
.text:00003580
.text:00003580 var_4           = dword ptr -4
.text:00003580
.text:00003580                 push    ebp
.text:00003581                 mov     ebp, esp
.text:00003583                 push    ecx
.text:00003584                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000358B                 mov     [ebp+var_4], ecx
.text:0000358E                 mov     eax, [ebp+var_4]
.text:00003591                 mov     eax, [eax]
.text:00003593                 mov     esp, ebp
.text:00003595                 pop     ebp
.text:00003596                 retn
.text:00003596 ?Front@?$CRecordVector@I@@QAEAAIXZ endp
.text:00003596
.text:00003596 ; ---------------------------------------------------------------------------
.text:00003597                 align 4
.text:00003597 _text           ends
.text:00003597
.text:00003598 ; ===========================================================================
.text:00003598
.text:00003598 ; Segment type: Pure code
.text:00003598 ; Segment permissions: Read/Execute
.text:00003598 _text           segment para public 'CODE' use32
.text:00003598                 assume cs:_text
.text:00003598                 ;org 3598h
.text:00003598 ; COMDAT (pick any)
.text:00003598                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003598
.text:00003598 ; =============== S U B R O U T I N E =======================================
.text:00003598
.text:00003598 ; Attributes: bp-based frame
.text:00003598
.text:00003598 ; public: __thiscall CMyComPtr<struct ISequentialOutStream>::CMyComPtr<struct ISequentialOutStream>(void)
.text:00003598                 public ??0?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ
.text:00003598 ??0?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ proc near
.text:00003598                                         ; CODE XREF: COutStreamWithHash::COutStreamWithHash(void)+30p
.text:00003598
.text:00003598 var_4           = dword ptr -4
.text:00003598
.text:00003598                 push    ebp
.text:00003599                 mov     ebp, esp
.text:0000359B                 push    ecx
.text:0000359C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000035A3                 mov     [ebp+var_4], ecx
.text:000035A6                 mov     eax, [ebp+var_4]
.text:000035A9                 mov     dword ptr [eax], 0
.text:000035AF                 mov     eax, [ebp+var_4]
.text:000035B2                 mov     esp, ebp
.text:000035B4                 pop     ebp
.text:000035B5                 retn
.text:000035B5 ??0?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ endp
.text:000035B5
.text:000035B5 ; ---------------------------------------------------------------------------
.text:000035B6                 align 4
.text:000035B6 _text           ends
.text:000035B6
.text:000035B8 ; ===========================================================================
.text:000035B8
.text:000035B8 ; Segment type: Pure code
.text:000035B8 ; Segment permissions: Read/Execute
.text:000035B8 _text           segment para public 'CODE' use32
.text:000035B8                 assume cs:_text
.text:000035B8                 ;org 35B8h
.text:000035B8 ; COMDAT (pick any)
.text:000035B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000035B8
.text:000035B8 ; =============== S U B R O U T I N E =======================================
.text:000035B8
.text:000035B8 ; Attributes: bp-based frame
.text:000035B8
.text:000035B8 ; public: __thiscall CMyComPtr<struct ISequentialOutStream>::~CMyComPtr<struct ISequentialOutStream>(void)
.text:000035B8                 public ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ
.text:000035B8 ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ proc near
.text:000035B8                                         ; CODE XREF: COutStreamWithHash::~COutStreamWithHash(void)+14p
.text:000035B8
.text:000035B8 var_4           = dword ptr -4
.text:000035B8
.text:000035B8                 push    ebp
.text:000035B9                 mov     ebp, esp
.text:000035BB                 push    ecx
.text:000035BC                 push    esi
.text:000035BD                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000035C4                 mov     [ebp+var_4], ecx
.text:000035C7                 mov     eax, [ebp+var_4]
.text:000035CA                 cmp     dword ptr [eax], 0
.text:000035CD                 jz      short loc_35EA
.text:000035CF                 mov     ecx, [ebp+var_4]
.text:000035D2                 mov     edx, [ecx]
.text:000035D4                 mov     eax, [ebp+var_4]
.text:000035D7                 mov     ecx, [eax]
.text:000035D9                 mov     edx, [edx]
.text:000035DB                 mov     esi, esp
.text:000035DD                 push    ecx
.text:000035DE                 mov     eax, [edx+8]
.text:000035E1                 call    eax
.text:000035E3                 cmp     esi, esp
.text:000035E5                 call    __RTC_CheckEsp
.text:000035EA
.text:000035EA loc_35EA:                               ; CODE XREF: CMyComPtr<ISequentialOutStream>::~CMyComPtr<ISequentialOutStream>(void)+15j
.text:000035EA                 pop     esi
.text:000035EB                 add     esp, 4
.text:000035EE                 cmp     ebp, esp
.text:000035F0                 call    __RTC_CheckEsp
.text:000035F5                 mov     esp, ebp
.text:000035F7                 pop     ebp
.text:000035F8                 retn
.text:000035F8 ??1?$CMyComPtr@UISequentialOutStream@@@@QAE@XZ endp
.text:000035F8
.text:000035F8 ; ---------------------------------------------------------------------------
.text:000035F9                 align 4
.text:000035F9 _text           ends
.text:000035F9
.text:000035FC ; ===========================================================================
.text:000035FC
.text:000035FC ; Segment type: Pure code
.text:000035FC ; Segment permissions: Read/Execute
.text:000035FC _text           segment para public 'CODE' use32
.text:000035FC                 assume cs:_text
.text:000035FC                 ;org 35FCh
.text:000035FC ; COMDAT (pick any)
.text:000035FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000035FC
.text:000035FC ; =============== S U B R O U T I N E =======================================
.text:000035FC
.text:000035FC ; Attributes: bp-based frame
.text:000035FC
.text:000035FC ; public: struct ISequentialOutStream * __thiscall CMyComPtr<struct ISequentialOutStream>::operator=(struct ISequentialOutStream *)
.text:000035FC                 public ??4?$CMyComPtr@UISequentialOutStream@@@@QAEPAUISequentialOutStream@@PAU1@@Z
.text:000035FC ??4?$CMyComPtr@UISequentialOutStream@@@@QAEPAUISequentialOutStream@@PAU1@@Z proc near
.text:000035FC                                         ; CODE XREF: CArchiveExtractCallback::SetHashMethods(IHashCalc *)+9Bp
.text:000035FC
.text:000035FC var_4           = dword ptr -4
.text:000035FC arg_0           = dword ptr  8
.text:000035FC
.text:000035FC                 push    ebp
.text:000035FD                 mov     ebp, esp
.text:000035FF                 push    ecx
.text:00003600                 push    esi
.text:00003601                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003608                 mov     [ebp+var_4], ecx
.text:0000360B                 cmp     [ebp+arg_0], 0
.text:0000360F                 jz      short loc_3628
.text:00003611                 mov     eax, [ebp+arg_0]
.text:00003614                 mov     ecx, [eax]
.text:00003616                 mov     esi, esp
.text:00003618                 mov     edx, [ebp+arg_0]
.text:0000361B                 push    edx
.text:0000361C                 mov     eax, [ecx+4]
.text:0000361F                 call    eax
.text:00003621                 cmp     esi, esp
.text:00003623                 call    __RTC_CheckEsp
.text:00003628
.text:00003628 loc_3628:                               ; CODE XREF: CMyComPtr<ISequentialOutStream>::operator=(ISequentialOutStream *)+13j
.text:00003628                 mov     ecx, [ebp+var_4]
.text:0000362B                 cmp     dword ptr [ecx], 0
.text:0000362E                 jz      short loc_364B
.text:00003630                 mov     edx, [ebp+var_4]
.text:00003633                 mov     eax, [edx]
.text:00003635                 mov     ecx, [ebp+var_4]
.text:00003638                 mov     edx, [ecx]
.text:0000363A                 mov     eax, [eax]
.text:0000363C                 mov     esi, esp
.text:0000363E                 push    edx
.text:0000363F                 mov     ecx, [eax+8]
.text:00003642                 call    ecx
.text:00003644                 cmp     esi, esp
.text:00003646                 call    __RTC_CheckEsp
.text:0000364B
.text:0000364B loc_364B:                               ; CODE XREF: CMyComPtr<ISequentialOutStream>::operator=(ISequentialOutStream *)+32j
.text:0000364B                 mov     edx, [ebp+var_4]
.text:0000364E                 mov     eax, [ebp+arg_0]
.text:00003651                 mov     [edx], eax
.text:00003653                 mov     eax, [ebp+arg_0]
.text:00003656                 pop     esi
.text:00003657                 add     esp, 4
.text:0000365A                 cmp     ebp, esp
.text:0000365C                 call    __RTC_CheckEsp
.text:00003661                 mov     esp, ebp
.text:00003663                 pop     ebp
.text:00003664                 retn    4
.text:00003664 ??4?$CMyComPtr@UISequentialOutStream@@@@QAEPAUISequentialOutStream@@PAU1@@Z endp
.text:00003664
.text:00003664 ; ---------------------------------------------------------------------------
.text:00003667                 align 4
.text:00003667 _text           ends
.text:00003667
.text:00003668 ; ===========================================================================
.text:00003668
.text:00003668 ; Segment type: Pure code
.text:00003668 ; Segment permissions: Read/Execute
.text:00003668 _text           segment para public 'CODE' use32
.text:00003668                 assume cs:_text
.text:00003668                 ;org 3668h
.text:00003668 ; COMDAT (pick any)
.text:00003668                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003668
.text:00003668 ; =============== S U B R O U T I N E =======================================
.text:00003668
.text:00003668 ; Attributes: bp-based frame
.text:00003668
.text:00003668 ; public: __thiscall CObjArray<bool>::CObjArray<bool>(unsigned int)
.text:00003668                 public ??0?$CObjArray@_N@@QAE@I@Z
.text:00003668 ??0?$CObjArray@_N@@QAE@I@Z proc near    ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+178p
.text:00003668
.text:00003668 var_8           = dword ptr -8
.text:00003668 var_4           = dword ptr -4
.text:00003668 arg_0           = dword ptr  8
.text:00003668
.text:00003668                 push    ebp
.text:00003669                 mov     ebp, esp
.text:0000366B                 sub     esp, 8
.text:0000366E                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00003675                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000367C                 mov     [ebp+var_4], ecx
.text:0000367F                 mov     eax, [ebp+var_4]
.text:00003682                 mov     dword ptr [eax], 0
.text:00003688                 cmp     [ebp+arg_0], 0
.text:0000368C                 jz      short loc_36A5
.text:0000368E                 mov     ecx, [ebp+arg_0]
.text:00003691                 push    ecx             ; unsigned int
.text:00003692                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00003697                 add     esp, 4
.text:0000369A                 mov     [ebp+var_8], eax
.text:0000369D                 mov     edx, [ebp+var_4]
.text:000036A0                 mov     eax, [ebp+var_8]
.text:000036A3                 mov     [edx], eax
.text:000036A5
.text:000036A5 loc_36A5:                               ; CODE XREF: CObjArray<bool>::CObjArray<bool>(uint)+24j
.text:000036A5                 mov     eax, [ebp+var_4]
.text:000036A8                 add     esp, 8
.text:000036AB                 cmp     ebp, esp
.text:000036AD                 call    __RTC_CheckEsp
.text:000036B2                 mov     esp, ebp
.text:000036B4                 pop     ebp
.text:000036B5                 retn    4
.text:000036B5 ??0?$CObjArray@_N@@QAE@I@Z endp
.text:000036B5
.text:000036B5 _text           ends
.text:000036B5
.text:000036B8 ; ===========================================================================
.text:000036B8
.text:000036B8 ; Segment type: Pure code
.text:000036B8 ; Segment permissions: Read/Execute
.text:000036B8 _text           segment para public 'CODE' use32
.text:000036B8                 assume cs:_text
.text:000036B8                 ;org 36B8h
.text:000036B8 ; COMDAT (pick any)
.text:000036B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000036B8
.text:000036B8 ; =============== S U B R O U T I N E =======================================
.text:000036B8
.text:000036B8 ; Attributes: bp-based frame
.text:000036B8
.text:000036B8 ; public: __thiscall CObjArray<bool>::~CObjArray<bool>(void)
.text:000036B8                 public ??1?$CObjArray@_N@@QAE@XZ
.text:000036B8 ??1?$CObjArray@_N@@QAE@XZ proc near     ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+2B8p
.text:000036B8                                         ; Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+426p ...
.text:000036B8
.text:000036B8 var_8           = dword ptr -8
.text:000036B8 var_4           = dword ptr -4
.text:000036B8
.text:000036B8                 push    ebp
.text:000036B9                 mov     ebp, esp
.text:000036BB                 sub     esp, 8
.text:000036BE                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000036C5                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000036CC                 mov     [ebp+var_4], ecx
.text:000036CF                 mov     eax, [ebp+var_4]
.text:000036D2                 mov     ecx, [eax]
.text:000036D4                 mov     [ebp+var_8], ecx
.text:000036D7                 mov     edx, [ebp+var_8]
.text:000036DA                 push    edx             ; void *
.text:000036DB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:000036E0                 add     esp, 4
.text:000036E3                 add     esp, 8
.text:000036E6                 cmp     ebp, esp
.text:000036E8                 call    __RTC_CheckEsp
.text:000036ED                 mov     esp, ebp
.text:000036EF                 pop     ebp
.text:000036F0                 retn
.text:000036F0 ??1?$CObjArray@_N@@QAE@XZ endp
.text:000036F0
.text:000036F0 ; ---------------------------------------------------------------------------
.text:000036F1                 align 4
.text:000036F1 _text           ends
.text:000036F1
.text:000036F4 ; ===========================================================================
.text:000036F4
.text:000036F4 ; Segment type: Pure code
.text:000036F4 ; Segment permissions: Read/Execute
.text:000036F4 _text           segment para public 'CODE' use32
.text:000036F4                 assume cs:_text
.text:000036F4                 ;org 36F4h
.text:000036F4 ; COMDAT (pick any)
.text:000036F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000036F4
.text:000036F4 ; =============== S U B R O U T I N E =======================================
.text:000036F4
.text:000036F4 ; Attributes: bp-based frame
.text:000036F4
.text:000036F4 ; public: __thiscall CObjArray<bool>::operator bool *(void)
.text:000036F4                 public ??B?$CObjArray@_N@@QAEPA_NXZ
.text:000036F4 ??B?$CObjArray@_N@@QAEPA_NXZ proc near  ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+19Ep
.text:000036F4                                         ; Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+313p ...
.text:000036F4
.text:000036F4 var_4           = dword ptr -4
.text:000036F4
.text:000036F4                 push    ebp
.text:000036F5                 mov     ebp, esp
.text:000036F7                 push    ecx
.text:000036F8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000036FF                 mov     [ebp+var_4], ecx
.text:00003702                 mov     eax, [ebp+var_4]
.text:00003705                 mov     eax, [eax]
.text:00003707                 mov     esp, ebp
.text:00003709                 pop     ebp
.text:0000370A                 retn
.text:0000370A ??B?$CObjArray@_N@@QAEPA_NXZ endp
.text:0000370A
.text:0000370A ; ---------------------------------------------------------------------------
.text:0000370B                 align 4
.text:0000370B _text           ends
.text:0000370B
.text:0000370C ; ===========================================================================
.text:0000370C
.text:0000370C ; Segment type: Pure code
.text:0000370C ; Segment permissions: Read/Execute
.text:0000370C _text           segment para public 'CODE' use32
.text:0000370C                 assume cs:_text
.text:0000370C                 ;org 370Ch
.text:0000370C ; COMDAT (pick any)
.text:0000370C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:0000370C
.text:0000370C ; =============== S U B R O U T I N E =======================================
.text:0000370C
.text:0000370C ; Attributes: bp-based frame
.text:0000370C
.text:0000370C ; public: __thiscall CMyComPtr<struct IArchiveExtractCallback>::CMyComPtr<struct IArchiveExtractCallback>(struct IArchiveExtractCallback *)
.text:0000370C                 public ??0?$CMyComPtr@UIArchiveExtractCallback@@@@QAE@PAUIArchiveExtractCallback@@@Z
.text:0000370C ??0?$CMyComPtr@UIArchiveExtractCallback@@@@QAE@PAUIArchiveExtractCallback@@@Z proc near
.text:0000370C                                         ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+212p
.text:0000370C
.text:0000370C var_4           = dword ptr -4
.text:0000370C arg_0           = dword ptr  8
.text:0000370C
.text:0000370C                 push    ebp
.text:0000370D                 mov     ebp, esp
.text:0000370F                 push    ecx
.text:00003710                 push    esi
.text:00003711                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003718                 mov     [ebp+var_4], ecx
.text:0000371B                 mov     eax, [ebp+var_4]
.text:0000371E                 mov     ecx, [ebp+arg_0]
.text:00003721                 mov     [eax], ecx
.text:00003723                 cmp     [ebp+arg_0], 0
.text:00003727                 jz      short loc_3740
.text:00003729                 mov     edx, [ebp+arg_0]
.text:0000372C                 mov     eax, [edx]
.text:0000372E                 mov     esi, esp
.text:00003730                 mov     ecx, [ebp+arg_0]
.text:00003733                 push    ecx
.text:00003734                 mov     edx, [eax+4]
.text:00003737                 call    edx
.text:00003739                 cmp     esi, esp
.text:0000373B                 call    __RTC_CheckEsp
.text:00003740
.text:00003740 loc_3740:                               ; CODE XREF: CMyComPtr<IArchiveExtractCallback>::CMyComPtr<IArchiveExtractCallback>(IArchiveExtractCallback *)+1Bj
.text:00003740                 mov     eax, [ebp+var_4]
.text:00003743                 pop     esi
.text:00003744                 add     esp, 4
.text:00003747                 cmp     ebp, esp
.text:00003749                 call    __RTC_CheckEsp
.text:0000374E                 mov     esp, ebp
.text:00003750                 pop     ebp
.text:00003751                 retn    4
.text:00003751 ??0?$CMyComPtr@UIArchiveExtractCallback@@@@QAE@PAUIArchiveExtractCallback@@@Z endp
.text:00003751
.text:00003751 _text           ends
.text:00003751
.text:00003754 ; ===========================================================================
.text:00003754
.text:00003754 ; Segment type: Pure code
.text:00003754 ; Segment permissions: Read/Execute
.text:00003754 _text           segment para public 'CODE' use32
.text:00003754                 assume cs:_text
.text:00003754                 ;org 3754h
.text:00003754 ; COMDAT (pick any)
.text:00003754                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003754
.text:00003754 ; =============== S U B R O U T I N E =======================================
.text:00003754
.text:00003754 ; Attributes: bp-based frame
.text:00003754
.text:00003754 ; public: __thiscall CMyComPtr<struct IArchiveExtractCallback>::~CMyComPtr<struct IArchiveExtractCallback>(void)
.text:00003754                 public ??1?$CMyComPtr@UIArchiveExtractCallback@@@@QAE@XZ
.text:00003754 ??1?$CMyComPtr@UIArchiveExtractCallback@@@@QAE@XZ proc near
.text:00003754                                         ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+2ACp
.text:00003754                                         ; Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+41Ap ...
.text:00003754
.text:00003754 var_4           = dword ptr -4
.text:00003754
.text:00003754                 push    ebp
.text:00003755                 mov     ebp, esp
.text:00003757                 push    ecx
.text:00003758                 push    esi
.text:00003759                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003760                 mov     [ebp+var_4], ecx
.text:00003763                 mov     eax, [ebp+var_4]
.text:00003766                 cmp     dword ptr [eax], 0
.text:00003769                 jz      short loc_3786
.text:0000376B                 mov     ecx, [ebp+var_4]
.text:0000376E                 mov     edx, [ecx]
.text:00003770                 mov     eax, [ebp+var_4]
.text:00003773                 mov     ecx, [eax]
.text:00003775                 mov     edx, [edx]
.text:00003777                 mov     esi, esp
.text:00003779                 push    ecx
.text:0000377A                 mov     eax, [edx+8]
.text:0000377D                 call    eax
.text:0000377F                 cmp     esi, esp
.text:00003781                 call    __RTC_CheckEsp
.text:00003786
.text:00003786 loc_3786:                               ; CODE XREF: CMyComPtr<IArchiveExtractCallback>::~CMyComPtr<IArchiveExtractCallback>(void)+15j
.text:00003786                 pop     esi
.text:00003787                 add     esp, 4
.text:0000378A                 cmp     ebp, esp
.text:0000378C                 call    __RTC_CheckEsp
.text:00003791                 mov     esp, ebp
.text:00003793                 pop     ebp
.text:00003794                 retn
.text:00003794 ??1?$CMyComPtr@UIArchiveExtractCallback@@@@QAE@XZ endp
.text:00003794
.text:00003794 ; ---------------------------------------------------------------------------
.text:00003795                 align 4
.text:00003795 _text           ends
.text:00003795
.text:00003798 ; ===========================================================================
.text:00003798
.text:00003798 ; Segment type: Pure code
.text:00003798 ; Segment permissions: Read/Execute
.text:00003798 _text           segment para public 'CODE' use32
.text:00003798                 assume cs:_text
.text:00003798                 ;org 3798h
.text:00003798 ; COMDAT (pick any)
.text:00003798                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003798
.text:00003798 ; =============== S U B R O U T I N E =======================================
.text:00003798
.text:00003798 ; Attributes: bp-based frame
.text:00003798
.text:00003798 ; public: __thiscall CObjectVector<struct COpenType>::CObjectVector<struct COpenType>(class CObjectVector<struct COpenType> const &)
.text:00003798                 public ??0?$CObjectVector@UCOpenType@@@@QAE@ABV0@@Z
.text:00003798 ??0?$CObjectVector@UCOpenType@@@@QAE@ABV0@@Z proc near
.text:00003798                                         ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+45Ep
.text:00003798
.text:00003798 var_24          = dword ptr -24h
.text:00003798 var_20          = dword ptr -20h
.text:00003798 var_1C          = dword ptr -1Ch
.text:00003798 var_18          = dword ptr -18h
.text:00003798 var_14          = dword ptr -14h
.text:00003798 var_10          = dword ptr -10h
.text:00003798 var_C           = dword ptr -0Ch
.text:00003798 var_4           = dword ptr -4
.text:00003798 arg_0           = dword ptr  8
.text:00003798
.text:00003798                 push    ebp
.text:00003799                 mov     ebp, esp
.text:0000379B                 push    0FFFFFFFFh
.text:0000379D                 push    offset __ehhandler$??0?$CObjectVector@UCOpenType@@@@QAE@ABV0@@Z
.text:000037A2                 mov     eax, large fs:0
.text:000037A8                 push    eax
.text:000037A9                 sub     esp, 18h
.text:000037AC                 push    esi
.text:000037AD                 push    edi
.text:000037AE                 mov     eax, 0CCCCCCCCh
.text:000037B3                 mov     [ebp+var_24], eax
.text:000037B6                 mov     [ebp+var_20], eax
.text:000037B9                 mov     [ebp+var_1C], eax
.text:000037BC                 mov     [ebp+var_18], eax
.text:000037BF                 mov     [ebp+var_14], eax
.text:000037C2                 mov     [ebp+var_10], eax
.text:000037C5                 mov     eax, dword ptr ds:___security_cookie
.text:000037CA                 xor     eax, ebp
.text:000037CC                 push    eax
.text:000037CD                 lea     eax, [ebp+var_C]
.text:000037D0                 mov     large fs:0, eax
.text:000037D6                 mov     [ebp+var_10], ecx
.text:000037D9                 mov     ecx, [ebp+var_10]
.text:000037DC                 call    ??0?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::CRecordVector<void *>(void)
.text:000037E1                 mov     [ebp+var_4], 0
.text:000037E8                 mov     ecx, [ebp+arg_0]
.text:000037EB                 call    ?Size@?$CObjectVector@UCOpenType@@@@QBEIXZ ; CObjectVector<COpenType>::Size(void)
.text:000037F0                 mov     [ebp+var_14], eax
.text:000037F3                 mov     eax, [ebp+var_14]
.text:000037F6                 push    eax
.text:000037F7                 mov     ecx, [ebp+var_10]
.text:000037FA                 call    ?ConstructReserve@?$CRecordVector@PAX@@QAEXI@Z ; CRecordVector<void *>::ConstructReserve(uint)
.text:000037FF                 mov     [ebp+var_18], 0
.text:00003806                 jmp     short loc_3811
.text:00003808 ; ---------------------------------------------------------------------------
.text:00003808
.text:00003808 loc_3808:                               ; CODE XREF: CObjectVector<COpenType>::CObjectVector<COpenType>(CObjectVector<COpenType> const &)+D5j
.text:00003808                 mov     ecx, [ebp+var_18]
.text:0000380B                 add     ecx, 1
.text:0000380E                 mov     [ebp+var_18], ecx
.text:00003811
.text:00003811 loc_3811:                               ; CODE XREF: CObjectVector<COpenType>::CObjectVector<COpenType>(CObjectVector<COpenType> const &)+6Ej
.text:00003811                 mov     edx, [ebp+var_18]
.text:00003814                 cmp     edx, [ebp+var_14]
.text:00003817                 jnb     short loc_386F
.text:00003819                 push    20h ; ' '       ; unsigned int
.text:0000381B                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00003820                 add     esp, 4
.text:00003823                 mov     [ebp+var_20], eax
.text:00003826                 mov     byte ptr [ebp+var_4], 1
.text:0000382A                 cmp     [ebp+var_20], 0
.text:0000382E                 jz      short loc_3850
.text:00003830                 mov     eax, [ebp+var_18]
.text:00003833                 push    eax
.text:00003834                 mov     ecx, [ebp+arg_0]
.text:00003837                 call    ??A?$CObjectVector@UCOpenType@@@@QBEABUCOpenType@@I@Z ; CObjectVector<COpenType>::operator[](uint)
.text:0000383C                 mov     ecx, 8
.text:00003841                 mov     esi, eax
.text:00003843                 mov     edi, [ebp+var_20]
.text:00003846                 rep movsd
.text:00003848                 mov     ecx, [ebp+var_20]
.text:0000384B                 mov     [ebp+var_24], ecx
.text:0000384E                 jmp     short loc_3857
.text:00003850 ; ---------------------------------------------------------------------------
.text:00003850
.text:00003850 loc_3850:                               ; CODE XREF: CObjectVector<COpenType>::CObjectVector<COpenType>(CObjectVector<COpenType> const &)+96j
.text:00003850                 mov     [ebp+var_24], 0
.text:00003857
.text:00003857 loc_3857:                               ; CODE XREF: CObjectVector<COpenType>::CObjectVector<COpenType>(CObjectVector<COpenType> const &)+B6j
.text:00003857                 mov     edx, [ebp+var_24]
.text:0000385A                 mov     [ebp+var_1C], edx
.text:0000385D                 mov     byte ptr [ebp+var_4], 0
.text:00003861                 mov     eax, [ebp+var_1C]
.text:00003864                 push    eax
.text:00003865                 mov     ecx, [ebp+var_10]
.text:00003868                 call    ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z ; CRecordVector<void *>::AddInReserved(void * const)
.text:0000386D                 jmp     short loc_3808
.text:0000386F ; ---------------------------------------------------------------------------
.text:0000386F
.text:0000386F loc_386F:                               ; CODE XREF: CObjectVector<COpenType>::CObjectVector<COpenType>(CObjectVector<COpenType> const &)+7Fj
.text:0000386F                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00003876                 mov     eax, [ebp+var_10]
.text:00003879                 mov     ecx, [ebp+var_C]
.text:0000387C                 mov     large fs:0, ecx
.text:00003883                 pop     ecx
.text:00003884                 pop     edi
.text:00003885                 pop     esi
.text:00003886                 add     esp, 24h
.text:00003889                 cmp     ebp, esp
.text:0000388B                 call    __RTC_CheckEsp
.text:00003890                 mov     esp, ebp
.text:00003892                 pop     ebp
.text:00003893                 retn    4
.text:00003893 ??0?$CObjectVector@UCOpenType@@@@QAE@ABV0@@Z endp
.text:00003893
.text:00003893 ; ---------------------------------------------------------------------------
.text:00003896                 align 4
.text:00003896 _text           ends
.text:00003896
.text$x:00003898 ; ===========================================================================
.text$x:00003898
.text$x:00003898 ; Segment type: Pure code
.text$x:00003898 ; Segment permissions: Read/Execute
.text$x:00003898 _text$x         segment para public 'CODE' use32
.text$x:00003898                 assume cs:_text$x
.text$x:00003898                 ;org 3898h
.text$x:00003898 ; COMDAT (pick associative to section at 3798)
.text$x:00003898                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003898
.text$x:00003898 ; =============== S U B R O U T I N E =======================================
.text$x:00003898
.text$x:00003898
.text$x:00003898 __unwindfunclet$??0?$CObjectVector@UCOpenType@@@@QAE@ABV0@@Z$0 proc near
.text$x:00003898                                         ; DATA XREF: .xdata$x:000038CCo
.text$x:00003898                 mov     ecx, [ebp-10h]
.text$x:0000389B                 jmp     ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text$x:0000389B __unwindfunclet$??0?$CObjectVector@UCOpenType@@@@QAE@ABV0@@Z$0 endp
.text$x:0000389B
.text$x:000038A0
.text$x:000038A0 ; =============== S U B R O U T I N E =======================================
.text$x:000038A0
.text$x:000038A0
.text$x:000038A0 __unwindfunclet$??0?$CObjectVector@UCOpenType@@@@QAE@ABV0@@Z$1 proc near
.text$x:000038A0                                         ; DATA XREF: .xdata$x:000038D4o
.text$x:000038A0                 mov     eax, [ebp-20h]
.text$x:000038A3                 push    eax             ; void *
.text$x:000038A4                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:000038A9                 pop     ecx
.text$x:000038AA                 retn
.text$x:000038AA __unwindfunclet$??0?$CObjectVector@UCOpenType@@@@QAE@ABV0@@Z$1 endp
.text$x:000038AA
.text$x:000038AB
.text$x:000038AB ; =============== S U B R O U T I N E =======================================
.text$x:000038AB
.text$x:000038AB
.text$x:000038AB __ehhandler$??0?$CObjectVector@UCOpenType@@@@QAE@ABV0@@Z proc near
.text$x:000038AB                                         ; DATA XREF: CObjectVector<COpenType>::CObjectVector<COpenType>(CObjectVector<COpenType> const &)+5o
.text$x:000038AB
.text$x:000038AB arg_4           = dword ptr  8
.text$x:000038AB
.text$x:000038AB                 mov     edx, [esp+arg_4]
.text$x:000038AF                 lea     eax, [edx+0Ch]
.text$x:000038B2                 mov     ecx, [edx-24h]
.text$x:000038B5                 xor     ecx, eax
.text$x:000038B7                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000038BC                 mov     eax, offset __ehfuncinfo$??0?$CObjectVector@UCOpenType@@@@QAE@ABV0@@Z
.text$x:000038C1                 jmp     ___CxxFrameHandler3
.text$x:000038C1 __ehhandler$??0?$CObjectVector@UCOpenType@@@@QAE@ABV0@@Z endp
.text$x:000038C1
.text$x:000038C1 ; ---------------------------------------------------------------------------
.text$x:000038C6                 align 4
.text$x:000038C6 _text$x         ends
.text$x:000038C6
.xdata$x:000038C8 ; ===========================================================================
.xdata$x:000038C8
.xdata$x:000038C8 ; Segment type: Pure data
.xdata$x:000038C8 ; Segment permissions: Read
.xdata$x:000038C8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000038C8                 assume cs:_xdata$x
.xdata$x:000038C8                 ;org 38C8h
.xdata$x:000038C8 ; COMDAT (pick associative to section at 3798)
.xdata$x:000038C8 __unwindtable$??0?$CObjectVector@UCOpenType@@@@QAE@ABV0@@Z db 0FFh
.xdata$x:000038C8                                         ; DATA XREF: .xdata$x:000038E0o
.xdata$x:000038C9                 db 0FFh
.xdata$x:000038CA                 db 0FFh
.xdata$x:000038CB                 db 0FFh
.xdata$x:000038CC                 dd offset __unwindfunclet$??0?$CObjectVector@UCOpenType@@@@QAE@ABV0@@Z$0
.xdata$x:000038D0                 db    0
.xdata$x:000038D1                 db    0
.xdata$x:000038D2                 db    0
.xdata$x:000038D3                 db    0
.xdata$x:000038D4                 dd offset __unwindfunclet$??0?$CObjectVector@UCOpenType@@@@QAE@ABV0@@Z$1
.xdata$x:000038D8 __ehfuncinfo$??0?$CObjectVector@UCOpenType@@@@QAE@ABV0@@Z db  22h ; "
.xdata$x:000038D8                                         ; DATA XREF: __ehhandler$??0?$CObjectVector@UCOpenType@@@@QAE@ABV0@@Z+11o
.xdata$x:000038D9                 db    5
.xdata$x:000038DA                 db  93h ; Ã´
.xdata$x:000038DB                 db  19h
.xdata$x:000038DC                 db    2
.xdata$x:000038DD                 db    0
.xdata$x:000038DE                 db    0
.xdata$x:000038DF                 db    0
.xdata$x:000038E0                 dd offset __unwindtable$??0?$CObjectVector@UCOpenType@@@@QAE@ABV0@@Z
.xdata$x:000038E4                 db    0
.xdata$x:000038E5                 db    0
.xdata$x:000038E6                 db    0
.xdata$x:000038E7                 db    0
.xdata$x:000038E8                 db    0
.xdata$x:000038E9                 db    0
.xdata$x:000038EA                 db    0
.xdata$x:000038EB                 db    0
.xdata$x:000038EC                 db    0
.xdata$x:000038ED                 db    0
.xdata$x:000038EE                 db    0
.xdata$x:000038EF                 db    0
.xdata$x:000038F0                 db    0
.xdata$x:000038F1                 db    0
.xdata$x:000038F2                 db    0
.xdata$x:000038F3                 db    0
.xdata$x:000038F4                 db    0
.xdata$x:000038F5                 db    0
.xdata$x:000038F6                 db    0
.xdata$x:000038F7                 db    0
.xdata$x:000038F8                 db    1
.xdata$x:000038F9                 db    0
.xdata$x:000038FA                 db    0
.xdata$x:000038FB                 db    0
.xdata$x:000038FB _xdata$x        ends
.xdata$x:000038FB
.text:000038FC ; ===========================================================================
.text:000038FC
.text:000038FC ; Segment type: Pure code
.text:000038FC ; Segment permissions: Read/Execute
.text:000038FC _text           segment para public 'CODE' use32
.text:000038FC                 assume cs:_text
.text:000038FC                 ;org 38FCh
.text:000038FC ; COMDAT (pick any)
.text:000038FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000038FC
.text:000038FC ; =============== S U B R O U T I N E =======================================
.text:000038FC
.text:000038FC ; Attributes: bp-based frame
.text:000038FC
.text:000038FC ; public: __thiscall CObjectVector<struct COpenType>::~CObjectVector<struct COpenType>(void)
.text:000038FC                 public ??1?$CObjectVector@UCOpenType@@@@QAE@XZ
.text:000038FC ??1?$CObjectVector@UCOpenType@@@@QAE@XZ proc near
.text:000038FC                                         ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+515p
.text:000038FC                                         ; Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+5F1p ...
.text:000038FC
.text:000038FC var_18          = dword ptr -18h
.text:000038FC var_14          = dword ptr -14h
.text:000038FC var_10          = dword ptr -10h
.text:000038FC var_C           = dword ptr -0Ch
.text:000038FC var_4           = dword ptr -4
.text:000038FC
.text:000038FC                 push    ebp
.text:000038FD                 mov     ebp, esp
.text:000038FF                 push    0FFFFFFFFh
.text:00003901                 push    offset __ehhandler$??1?$CObjectVector@UCOpenType@@@@QAE@XZ
.text:00003906                 mov     eax, large fs:0
.text:0000390C                 push    eax
.text:0000390D                 sub     esp, 0Ch
.text:00003910                 mov     [ebp+var_18], 0CCCCCCCCh
.text:00003917                 mov     [ebp+var_14], 0CCCCCCCCh
.text:0000391E                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00003925                 mov     eax, dword ptr ds:___security_cookie
.text:0000392A                 xor     eax, ebp
.text:0000392C                 push    eax
.text:0000392D                 lea     eax, [ebp+var_C]
.text:00003930                 mov     large fs:0, eax
.text:00003936                 mov     [ebp+var_10], ecx
.text:00003939                 mov     [ebp+var_4], 0
.text:00003940                 mov     ecx, [ebp+var_10]
.text:00003943                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00003948                 mov     [ebp+var_14], eax
.text:0000394B
.text:0000394B loc_394B:                               ; CODE XREF: CObjectVector<COpenType>::~CObjectVector<COpenType>(void)+7Bj
.text:0000394B                 cmp     [ebp+var_14], 0
.text:0000394F                 jz      short loc_3979
.text:00003951                 mov     eax, [ebp+var_14]
.text:00003954                 sub     eax, 1
.text:00003957                 mov     [ebp+var_14], eax
.text:0000395A                 mov     ecx, [ebp+var_14]
.text:0000395D                 push    ecx
.text:0000395E                 mov     ecx, [ebp+var_10]
.text:00003961                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00003966                 mov     edx, [eax]
.text:00003968                 mov     [ebp+var_18], edx
.text:0000396B                 mov     eax, [ebp+var_18]
.text:0000396E                 push    eax             ; void *
.text:0000396F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00003974                 add     esp, 4
.text:00003977                 jmp     short loc_394B
.text:00003979 ; ---------------------------------------------------------------------------
.text:00003979
.text:00003979 loc_3979:                               ; CODE XREF: CObjectVector<COpenType>::~CObjectVector<COpenType>(void)+53j
.text:00003979                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00003980                 mov     ecx, [ebp+var_10]
.text:00003983                 call    ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text:00003988                 mov     ecx, [ebp+var_C]
.text:0000398B                 mov     large fs:0, ecx
.text:00003992                 pop     ecx
.text:00003993                 add     esp, 18h
.text:00003996                 cmp     ebp, esp
.text:00003998                 call    __RTC_CheckEsp
.text:0000399D                 mov     esp, ebp
.text:0000399F                 pop     ebp
.text:000039A0                 retn
.text:000039A0 ??1?$CObjectVector@UCOpenType@@@@QAE@XZ endp
.text:000039A0
.text:000039A0 ; ---------------------------------------------------------------------------
.text:000039A1                 align 4
.text:000039A1 _text           ends
.text:000039A1
.text$x:000039A4 ; ===========================================================================
.text$x:000039A4
.text$x:000039A4 ; Segment type: Pure code
.text$x:000039A4 ; Segment permissions: Read/Execute
.text$x:000039A4 _text$x         segment para public 'CODE' use32
.text$x:000039A4                 assume cs:_text$x
.text$x:000039A4                 ;org 39A4h
.text$x:000039A4 ; COMDAT (pick associative to section at 38FC)
.text$x:000039A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000039A4
.text$x:000039A4 ; =============== S U B R O U T I N E =======================================
.text$x:000039A4
.text$x:000039A4
.text$x:000039A4 __unwindfunclet$??1?$CObjectVector@UCOpenType@@@@QAE@XZ$0 proc near
.text$x:000039A4                                         ; DATA XREF: .xdata$x:000039CCo
.text$x:000039A4                 mov     ecx, [ebp-10h]
.text$x:000039A7                 jmp     ??1?$CRecordVector@PAX@@QAE@XZ ; CRecordVector<void *>::~CRecordVector<void *>(void)
.text$x:000039A7 __unwindfunclet$??1?$CObjectVector@UCOpenType@@@@QAE@XZ$0 endp
.text$x:000039A7
.text$x:000039AC
.text$x:000039AC ; =============== S U B R O U T I N E =======================================
.text$x:000039AC
.text$x:000039AC
.text$x:000039AC __ehhandler$??1?$CObjectVector@UCOpenType@@@@QAE@XZ proc near
.text$x:000039AC                                         ; DATA XREF: CObjectVector<COpenType>::~CObjectVector<COpenType>(void)+5o
.text$x:000039AC
.text$x:000039AC arg_4           = dword ptr  8
.text$x:000039AC
.text$x:000039AC                 mov     edx, [esp+arg_4]
.text$x:000039B0                 lea     eax, [edx+0Ch]
.text$x:000039B3                 mov     ecx, [edx-10h]
.text$x:000039B6                 xor     ecx, eax
.text$x:000039B8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000039BD                 mov     eax, offset __ehfuncinfo$??1?$CObjectVector@UCOpenType@@@@QAE@XZ
.text$x:000039C2                 jmp     ___CxxFrameHandler3
.text$x:000039C2 __ehhandler$??1?$CObjectVector@UCOpenType@@@@QAE@XZ endp
.text$x:000039C2
.text$x:000039C2 ; ---------------------------------------------------------------------------
.text$x:000039C7                 align 4
.text$x:000039C7 _text$x         ends
.text$x:000039C7
.xdata$x:000039C8 ; ===========================================================================
.xdata$x:000039C8
.xdata$x:000039C8 ; Segment type: Pure data
.xdata$x:000039C8 ; Segment permissions: Read
.xdata$x:000039C8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000039C8                 assume cs:_xdata$x
.xdata$x:000039C8                 ;org 39C8h
.xdata$x:000039C8 ; COMDAT (pick associative to section at 38FC)
.xdata$x:000039C8 __unwindtable$??1?$CObjectVector@UCOpenType@@@@QAE@XZ db 0FFh
.xdata$x:000039C8                                         ; DATA XREF: .xdata$x:000039D8o
.xdata$x:000039C9                 db 0FFh
.xdata$x:000039CA                 db 0FFh
.xdata$x:000039CB                 db 0FFh
.xdata$x:000039CC                 dd offset __unwindfunclet$??1?$CObjectVector@UCOpenType@@@@QAE@XZ$0
.xdata$x:000039D0 __ehfuncinfo$??1?$CObjectVector@UCOpenType@@@@QAE@XZ db  22h ; "
.xdata$x:000039D0                                         ; DATA XREF: __ehhandler$??1?$CObjectVector@UCOpenType@@@@QAE@XZ+11o
.xdata$x:000039D1                 db    5
.xdata$x:000039D2                 db  93h ; Ã´
.xdata$x:000039D3                 db  19h
.xdata$x:000039D4                 db    1
.xdata$x:000039D5                 db    0
.xdata$x:000039D6                 db    0
.xdata$x:000039D7                 db    0
.xdata$x:000039D8                 dd offset __unwindtable$??1?$CObjectVector@UCOpenType@@@@QAE@XZ
.xdata$x:000039DC                 db    0
.xdata$x:000039DD                 db    0
.xdata$x:000039DE                 db    0
.xdata$x:000039DF                 db    0
.xdata$x:000039E0                 db    0
.xdata$x:000039E1                 db    0
.xdata$x:000039E2                 db    0
.xdata$x:000039E3                 db    0
.xdata$x:000039E4                 db    0
.xdata$x:000039E5                 db    0
.xdata$x:000039E6                 db    0
.xdata$x:000039E7                 db    0
.xdata$x:000039E8                 db    0
.xdata$x:000039E9                 db    0
.xdata$x:000039EA                 db    0
.xdata$x:000039EB                 db    0
.xdata$x:000039EC                 db    0
.xdata$x:000039ED                 db    0
.xdata$x:000039EE                 db    0
.xdata$x:000039EF                 db    0
.xdata$x:000039F0                 db    1
.xdata$x:000039F1                 db    0
.xdata$x:000039F2                 db    0
.xdata$x:000039F3                 db    0
.xdata$x:000039F3 _xdata$x        ends
.xdata$x:000039F3
.text:000039F4 ; ===========================================================================
.text:000039F4
.text:000039F4 ; Segment type: Pure code
.text:000039F4 ; Segment permissions: Read/Execute
.text:000039F4 _text           segment para public 'CODE' use32
.text:000039F4                 assume cs:_text
.text:000039F4                 ;org 39F4h
.text:000039F4 ; COMDAT (pick any)
.text:000039F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000039F4
.text:000039F4 ; =============== S U B R O U T I N E =======================================
.text:000039F4
.text:000039F4 ; Attributes: bp-based frame
.text:000039F4
.text:000039F4 ; public: void * __thiscall UString::`scalar deleting destructor'(unsigned int)
.text:000039F4                 public ??_GUString@@QAEPAXI@Z
.text:000039F4 ??_GUString@@QAEPAXI@Z proc near        ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+7Fp
.text:000039F4
.text:000039F4 var_4           = dword ptr -4
.text:000039F4 arg_0           = dword ptr  8
.text:000039F4
.text:000039F4                 push    ebp
.text:000039F5                 mov     ebp, esp
.text:000039F7                 push    ecx
.text:000039F8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000039FF                 mov     [ebp+var_4], ecx
.text:00003A02                 mov     ecx, [ebp+var_4] ; this
.text:00003A05                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003A0A                 mov     eax, [ebp+arg_0]
.text:00003A0D                 and     eax, 1
.text:00003A10                 jz      short loc_3A1E
.text:00003A12                 mov     ecx, [ebp+var_4]
.text:00003A15                 push    ecx             ; void *
.text:00003A16                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00003A1B                 add     esp, 4
.text:00003A1E
.text:00003A1E loc_3A1E:                               ; CODE XREF: UString::`scalar deleting destructor'(uint)+1Cj
.text:00003A1E                 mov     eax, [ebp+var_4]
.text:00003A21                 add     esp, 4
.text:00003A24                 cmp     ebp, esp
.text:00003A26                 call    __RTC_CheckEsp
.text:00003A2B                 mov     esp, ebp
.text:00003A2D                 pop     ebp
.text:00003A2E                 retn    4
.text:00003A2E ??_GUString@@QAEPAXI@Z endp
.text:00003A2E
.text:00003A2E ; ---------------------------------------------------------------------------
.text:00003A31                 align 4
.text:00003A31 _text           ends
.text:00003A31
.text:00003A34 ; ===========================================================================
.text:00003A34
.text:00003A34 ; Segment type: Pure code
.text:00003A34 ; Segment permissions: Read/Execute
.text:00003A34 _text           segment para public 'CODE' use32
.text:00003A34                 assume cs:_text
.text:00003A34                 ;org 3A34h
.text:00003A34 ; COMDAT (pick any)
.text:00003A34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003A34
.text:00003A34 ; =============== S U B R O U T I N E =======================================
.text:00003A34
.text:00003A34 ; Attributes: bp-based frame
.text:00003A34
.text:00003A34 ; public: void * __thiscall CArc::`scalar deleting destructor'(unsigned int)
.text:00003A34                 public ??_GCArc@@QAEPAXI@Z
.text:00003A34 ??_GCArc@@QAEPAXI@Z proc near           ; CODE XREF: CObjectVector<CArc>::~CObjectVector<CArc>(void)+7Fp
.text:00003A34
.text:00003A34 var_4           = dword ptr -4
.text:00003A34 arg_0           = dword ptr  8
.text:00003A34
.text:00003A34                 push    ebp
.text:00003A35                 mov     ebp, esp
.text:00003A37                 push    ecx
.text:00003A38                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003A3F                 mov     [ebp+var_4], ecx
.text:00003A42                 mov     ecx, [ebp+var_4] ; this
.text:00003A45                 call    ??1CArc@@QAE@XZ ; CArc::~CArc(void)
.text:00003A4A                 mov     eax, [ebp+arg_0]
.text:00003A4D                 and     eax, 1
.text:00003A50                 jz      short loc_3A5E
.text:00003A52                 mov     ecx, [ebp+var_4]
.text:00003A55                 push    ecx             ; void *
.text:00003A56                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00003A5B                 add     esp, 4
.text:00003A5E
.text:00003A5E loc_3A5E:                               ; CODE XREF: CArc::`scalar deleting destructor'(uint)+1Cj
.text:00003A5E                 mov     eax, [ebp+var_4]
.text:00003A61                 add     esp, 4
.text:00003A64                 cmp     ebp, esp
.text:00003A66                 call    __RTC_CheckEsp
.text:00003A6B                 mov     esp, ebp
.text:00003A6D                 pop     ebp
.text:00003A6E                 retn    4
.text:00003A6E ??_GCArc@@QAEPAXI@Z endp
.text:00003A6E
.text:00003A6E ; ---------------------------------------------------------------------------
.text:00003A71                 align 4
.text:00003A71 _text           ends
.text:00003A71
.text:00003A74 ; ===========================================================================
.text:00003A74
.text:00003A74 ; Segment type: Pure code
.text:00003A74 ; Segment permissions: Read/Execute
.text:00003A74 _text           segment para public 'CODE' use32
.text:00003A74                 assume cs:_text
.text:00003A74                 ;org 3A74h
.text:00003A74 ; COMDAT (pick any)
.text:00003A74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003A74
.text:00003A74 ; =============== S U B R O U T I N E =======================================
.text:00003A74
.text:00003A74 ; Attributes: bp-based frame
.text:00003A74
.text:00003A74 ; _DWORD __thiscall CArc::~CArc(CArc *__hidden this)
.text:00003A74                 public ??1CArc@@QAE@XZ
.text:00003A74 ??1CArc@@QAE@XZ proc near               ; CODE XREF: CArc::`scalar deleting destructor'(uint)+11p
.text:00003A74
.text:00003A74 var_10          = dword ptr -10h
.text:00003A74 var_C           = dword ptr -0Ch
.text:00003A74 var_4           = dword ptr -4
.text:00003A74
.text:00003A74                 push    ebp
.text:00003A75                 mov     ebp, esp
.text:00003A77                 push    0FFFFFFFFh
.text:00003A79                 push    offset __ehhandler$??1CArc@@QAE@XZ
.text:00003A7E                 mov     eax, large fs:0
.text:00003A84                 push    eax
.text:00003A85                 push    ecx
.text:00003A86                 mov     [ebp+var_10], 0CCCCCCCCh
.text:00003A8D                 mov     eax, dword ptr ds:___security_cookie
.text:00003A92                 xor     eax, ebp
.text:00003A94                 push    eax
.text:00003A95                 lea     eax, [ebp+var_C]
.text:00003A98                 mov     large fs:0, eax
.text:00003A9E                 mov     [ebp+var_10], ecx
.text:00003AA1                 mov     [ebp+var_4], 7
.text:00003AA8                 mov     ecx, [ebp+var_10]
.text:00003AAB                 add     ecx, 88h ; 'Ãª'  ; this
.text:00003AB1                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003AB6                 mov     byte ptr [ebp+var_4], 6
.text:00003ABA                 mov     ecx, [ebp+var_10]
.text:00003ABD                 add     ecx, 7Ch ; '|'  ; this
.text:00003AC0                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003AC5                 mov     byte ptr [ebp+var_4], 5
.text:00003AC9                 mov     ecx, [ebp+var_10]
.text:00003ACC                 add     ecx, 70h ; 'p'  ; this
.text:00003ACF                 call    ??1UString@@QAE@XZ ; UString::~UString(void)
.text:00003AD4                 mov     byte ptr [ebp+var_4], 4
.text:00003AD8                 mov     ecx, [ebp+var_10]
.text:00003ADB                 add     ecx, 40h ; '@'  ; this
.text:00003ADE                 call    ??1CArcErrorInfo@@QAE@XZ ; CArcErrorInfo::~CArcErrorInfo(void)
.text:00003AE3                 mov     byte ptr [ebp+var_4], 3
.text:00003AE7                 mov     ecx, [ebp+var_10]
.text:00003AEA                 add     ecx, 10h        ; this
.text:00003AED                 call    ??1CArcErrorInfo@@QAE@XZ ; CArcErrorInfo::~CArcErrorInfo(void)
.text:00003AF2                 mov     byte ptr [ebp+var_4], 2
.text:00003AF6                 mov     ecx, [ebp+var_10]
.text:00003AF9                 add     ecx, 0Ch
.text:00003AFC                 call    ??1?$CMyComPtr@UIArchiveGetRootProps@@@@QAE@XZ ; CMyComPtr<IArchiveGetRootProps>::~CMyComPtr<IArchiveGetRootProps>(void)
.text:00003B01                 mov     byte ptr [ebp+var_4], 1
.text:00003B05                 mov     ecx, [ebp+var_10]
.text:00003B08                 add     ecx, 8
.text:00003B0B                 call    ??1?$CMyComPtr@UIArchiveGetRawProps@@@@QAE@XZ ; CMyComPtr<IArchiveGetRawProps>::~CMyComPtr<IArchiveGetRawProps>(void)
.text:00003B10                 mov     byte ptr [ebp+var_4], 0
.text:00003B14                 mov     ecx, [ebp+var_10]
.text:00003B17                 add     ecx, 4
.text:00003B1A                 call    ??1?$CMyComPtr@UIInStream@@@@QAE@XZ ; CMyComPtr<IInStream>::~CMyComPtr<IInStream>(void)
.text:00003B1F                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00003B26                 mov     ecx, [ebp+var_10]
.text:00003B29                 call    ??1?$CMyComPtr@UIInArchive@@@@QAE@XZ ; CMyComPtr<IInArchive>::~CMyComPtr<IInArchive>(void)
.text:00003B2E                 mov     ecx, [ebp+var_C]
.text:00003B31                 mov     large fs:0, ecx
.text:00003B38                 pop     ecx
.text:00003B39                 add     esp, 10h
.text:00003B3C                 cmp     ebp, esp
.text:00003B3E                 call    __RTC_CheckEsp
.text:00003B43                 mov     esp, ebp
.text:00003B45                 pop     ebp
.text:00003B46                 retn
.text:00003B46 ??1CArc@@QAE@XZ endp
.text:00003B46
.text:00003B46 ; ---------------------------------------------------------------------------
.text:00003B47                 align 4
.text:00003B47 _text           ends
.text:00003B47
.text$x:00003B48 ; ===========================================================================
.text$x:00003B48
.text$x:00003B48 ; Segment type: Pure code
.text$x:00003B48 ; Segment permissions: Read/Execute
.text$x:00003B48 _text$x         segment para public 'CODE' use32
.text$x:00003B48                 assume cs:_text$x
.text$x:00003B48                 ;org 3B48h
.text$x:00003B48 ; COMDAT (pick associative to section at 3A74)
.text$x:00003B48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003B48
.text$x:00003B48 ; =============== S U B R O U T I N E =======================================
.text$x:00003B48
.text$x:00003B48
.text$x:00003B48 __unwindfunclet$??1CArc@@QAE@XZ$0 proc near ; DATA XREF: .xdata$x:00003BE0o
.text$x:00003B48                 mov     ecx, [ebp-10h]
.text$x:00003B4B                 jmp     ??1?$CMyComPtr@UIInArchive@@@@QAE@XZ ; CMyComPtr<IInArchive>::~CMyComPtr<IInArchive>(void)
.text$x:00003B4B __unwindfunclet$??1CArc@@QAE@XZ$0 endp
.text$x:00003B4B
.text$x:00003B50
.text$x:00003B50 ; =============== S U B R O U T I N E =======================================
.text$x:00003B50
.text$x:00003B50
.text$x:00003B50 __unwindfunclet$??1CArc@@QAE@XZ$1 proc near ; DATA XREF: .xdata$x:00003BE8o
.text$x:00003B50                 mov     ecx, [ebp-10h]
.text$x:00003B53                 add     ecx, 4
.text$x:00003B56                 jmp     ??1?$CMyComPtr@UIInStream@@@@QAE@XZ ; CMyComPtr<IInStream>::~CMyComPtr<IInStream>(void)
.text$x:00003B56 __unwindfunclet$??1CArc@@QAE@XZ$1 endp
.text$x:00003B56
.text$x:00003B5B
.text$x:00003B5B ; =============== S U B R O U T I N E =======================================
.text$x:00003B5B
.text$x:00003B5B
.text$x:00003B5B __unwindfunclet$??1CArc@@QAE@XZ$2 proc near ; DATA XREF: .xdata$x:00003BF0o
.text$x:00003B5B                 mov     ecx, [ebp-10h]
.text$x:00003B5E                 add     ecx, 8
.text$x:00003B61                 jmp     ??1?$CMyComPtr@UIArchiveGetRawProps@@@@QAE@XZ ; CMyComPtr<IArchiveGetRawProps>::~CMyComPtr<IArchiveGetRawProps>(void)
.text$x:00003B61 __unwindfunclet$??1CArc@@QAE@XZ$2 endp
.text$x:00003B61
.text$x:00003B66
.text$x:00003B66 ; =============== S U B R O U T I N E =======================================
.text$x:00003B66
.text$x:00003B66
.text$x:00003B66 __unwindfunclet$??1CArc@@QAE@XZ$3 proc near ; DATA XREF: .xdata$x:00003BF8o
.text$x:00003B66                 mov     ecx, [ebp-10h]
.text$x:00003B69                 add     ecx, 0Ch
.text$x:00003B6C                 jmp     ??1?$CMyComPtr@UIArchiveGetRootProps@@@@QAE@XZ ; CMyComPtr<IArchiveGetRootProps>::~CMyComPtr<IArchiveGetRootProps>(void)
.text$x:00003B6C __unwindfunclet$??1CArc@@QAE@XZ$3 endp
.text$x:00003B6C
.text$x:00003B71
.text$x:00003B71 ; =============== S U B R O U T I N E =======================================
.text$x:00003B71
.text$x:00003B71
.text$x:00003B71 __unwindfunclet$??1CArc@@QAE@XZ$4 proc near ; DATA XREF: .xdata$x:00003C00o
.text$x:00003B71                 mov     ecx, [ebp-10h]
.text$x:00003B74                 add     ecx, 10h        ; this
.text$x:00003B77                 jmp     ??1CArcErrorInfo@@QAE@XZ ; CArcErrorInfo::~CArcErrorInfo(void)
.text$x:00003B77 __unwindfunclet$??1CArc@@QAE@XZ$4 endp
.text$x:00003B77
.text$x:00003B7C
.text$x:00003B7C ; =============== S U B R O U T I N E =======================================
.text$x:00003B7C
.text$x:00003B7C
.text$x:00003B7C __unwindfunclet$??1CArc@@QAE@XZ$5 proc near ; DATA XREF: .xdata$x:00003C08o
.text$x:00003B7C                 mov     ecx, [ebp-10h]
.text$x:00003B7F                 add     ecx, 40h ; '@'  ; this
.text$x:00003B82                 jmp     ??1CArcErrorInfo@@QAE@XZ ; CArcErrorInfo::~CArcErrorInfo(void)
.text$x:00003B82 __unwindfunclet$??1CArc@@QAE@XZ$5 endp
.text$x:00003B82
.text$x:00003B87
.text$x:00003B87 ; =============== S U B R O U T I N E =======================================
.text$x:00003B87
.text$x:00003B87
.text$x:00003B87 __unwindfunclet$??1CArc@@QAE@XZ$6 proc near ; DATA XREF: .xdata$x:00003C10o
.text$x:00003B87                 mov     ecx, [ebp-10h]
.text$x:00003B8A                 add     ecx, 70h ; 'p'  ; this
.text$x:00003B8D                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00003B8D __unwindfunclet$??1CArc@@QAE@XZ$6 endp
.text$x:00003B8D
.text$x:00003B92
.text$x:00003B92 ; =============== S U B R O U T I N E =======================================
.text$x:00003B92
.text$x:00003B92
.text$x:00003B92 __unwindfunclet$??1CArc@@QAE@XZ$7 proc near ; DATA XREF: .xdata$x:00003C18o
.text$x:00003B92                 mov     ecx, [ebp-10h]
.text$x:00003B95                 add     ecx, 7Ch ; '|'  ; this
.text$x:00003B98                 jmp     ??1UString@@QAE@XZ ; UString::~UString(void)
.text$x:00003B98 __unwindfunclet$??1CArc@@QAE@XZ$7 endp
.text$x:00003B98
.text$x:00003B9D
.text$x:00003B9D ; =============== S U B R O U T I N E =======================================
.text$x:00003B9D
.text$x:00003B9D
.text$x:00003B9D __ehhandler$??1CArc@@QAE@XZ proc near   ; DATA XREF: CArc::~CArc(void)+5o
.text$x:00003B9D
.text$x:00003B9D arg_4           = dword ptr  8
.text$x:00003B9D
.text$x:00003B9D                 mov     edx, [esp+arg_4]
.text$x:00003BA1                 lea     eax, [edx+0Ch]
.text$x:00003BA4                 mov     ecx, [edx-8]
.text$x:00003BA7                 xor     ecx, eax
.text$x:00003BA9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003BAE                 mov     eax, offset __ehfuncinfo$??1CArc@@QAE@XZ
.text$x:00003BB3                 jmp     ___CxxFrameHandler3
.text$x:00003BB3 __ehhandler$??1CArc@@QAE@XZ endp
.text$x:00003BB3
.text$x:00003BB3 _text$x         ends
.text$x:00003BB3
.xdata$x:00003BB8 ; ===========================================================================
.xdata$x:00003BB8
.xdata$x:00003BB8 ; Segment type: Pure data
.xdata$x:00003BB8 ; Segment permissions: Read
.xdata$x:00003BB8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003BB8                 assume cs:_xdata$x
.xdata$x:00003BB8                 ;org 3BB8h
.xdata$x:00003BB8 ; COMDAT (pick associative to section at 3A74)
.xdata$x:00003BB8 __ehfuncinfo$??1CArc@@QAE@XZ db  22h ; "
.xdata$x:00003BB8                                         ; DATA XREF: __ehhandler$??1CArc@@QAE@XZ+11o
.xdata$x:00003BB9                 db    5
.xdata$x:00003BBA                 db  93h ; Ã´
.xdata$x:00003BBB                 db  19h
.xdata$x:00003BBC                 db    8
.xdata$x:00003BBD                 db    0
.xdata$x:00003BBE                 db    0
.xdata$x:00003BBF                 db    0
.xdata$x:00003BC0                 dd offset __unwindtable$??1CArc@@QAE@XZ
.xdata$x:00003BC4                 db    0
.xdata$x:00003BC5                 db    0
.xdata$x:00003BC6                 db    0
.xdata$x:00003BC7                 db    0
.xdata$x:00003BC8                 db    0
.xdata$x:00003BC9                 db    0
.xdata$x:00003BCA                 db    0
.xdata$x:00003BCB                 db    0
.xdata$x:00003BCC                 db    0
.xdata$x:00003BCD                 db    0
.xdata$x:00003BCE                 db    0
.xdata$x:00003BCF                 db    0
.xdata$x:00003BD0                 db    0
.xdata$x:00003BD1                 db    0
.xdata$x:00003BD2                 db    0
.xdata$x:00003BD3                 db    0
.xdata$x:00003BD4                 db    0
.xdata$x:00003BD5                 db    0
.xdata$x:00003BD6                 db    0
.xdata$x:00003BD7                 db    0
.xdata$x:00003BD8                 db    1
.xdata$x:00003BD9                 db    0
.xdata$x:00003BDA                 db    0
.xdata$x:00003BDB                 db    0
.xdata$x:00003BDC __unwindtable$??1CArc@@QAE@XZ db 0FFh   ; DATA XREF: .xdata$x:00003BC0o
.xdata$x:00003BDD                 db 0FFh
.xdata$x:00003BDE                 db 0FFh
.xdata$x:00003BDF                 db 0FFh
.xdata$x:00003BE0                 dd offset __unwindfunclet$??1CArc@@QAE@XZ$0
.xdata$x:00003BE4                 align 8
.xdata$x:00003BE8                 dd offset __unwindfunclet$??1CArc@@QAE@XZ$1
.xdata$x:00003BEC                 db    1
.xdata$x:00003BED                 db    0
.xdata$x:00003BEE                 db    0
.xdata$x:00003BEF                 db    0
.xdata$x:00003BF0                 dd offset __unwindfunclet$??1CArc@@QAE@XZ$2
.xdata$x:00003BF4                 db    2
.xdata$x:00003BF5                 db    0
.xdata$x:00003BF6                 db    0
.xdata$x:00003BF7                 db    0
.xdata$x:00003BF8                 dd offset __unwindfunclet$??1CArc@@QAE@XZ$3
.xdata$x:00003BFC                 db    3
.xdata$x:00003BFD                 db    0
.xdata$x:00003BFE                 db    0
.xdata$x:00003BFF                 db    0
.xdata$x:00003C00                 dd offset __unwindfunclet$??1CArc@@QAE@XZ$4
.xdata$x:00003C04                 db    4
.xdata$x:00003C05                 db    0
.xdata$x:00003C06                 db    0
.xdata$x:00003C07                 db    0
.xdata$x:00003C08                 dd offset __unwindfunclet$??1CArc@@QAE@XZ$5
.xdata$x:00003C0C                 db    5
.xdata$x:00003C0D                 db    0
.xdata$x:00003C0E                 db    0
.xdata$x:00003C0F                 db    0
.xdata$x:00003C10                 dd offset __unwindfunclet$??1CArc@@QAE@XZ$6
.xdata$x:00003C14                 db    6
.xdata$x:00003C15                 db    0
.xdata$x:00003C16                 db    0
.xdata$x:00003C17                 db    0
.xdata$x:00003C18                 dd offset __unwindfunclet$??1CArc@@QAE@XZ$7
.xdata$x:00003C18 _xdata$x        ends
.xdata$x:00003C18
.text:00003C1C ; ===========================================================================
.text:00003C1C
.text:00003C1C ; Segment type: Pure code
.text:00003C1C ; Segment permissions: Read/Execute
.text:00003C1C _text           segment para public 'CODE' use32
.text:00003C1C                 assume cs:_text
.text:00003C1C                 ;org 3C1Ch
.text:00003C1C ; COMDAT (pick any)
.text:00003C1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003C1C
.text:00003C1C ; =============== S U B R O U T I N E =======================================
.text:00003C1C
.text:00003C1C ; Attributes: bp-based frame
.text:00003C1C
.text:00003C1C ; public: __thiscall CMyComPtr<struct IInArchive>::~CMyComPtr<struct IInArchive>(void)
.text:00003C1C                 public ??1?$CMyComPtr@UIInArchive@@@@QAE@XZ
.text:00003C1C ??1?$CMyComPtr@UIInArchive@@@@QAE@XZ proc near
.text:00003C1C                                         ; CODE XREF: CArc::~CArc(void)+B5p
.text:00003C1C                                         ; __unwindfunclet$??1CArc@@QAE@XZ$0+3j
.text:00003C1C
.text:00003C1C var_4           = dword ptr -4
.text:00003C1C
.text:00003C1C                 push    ebp
.text:00003C1D                 mov     ebp, esp
.text:00003C1F                 push    ecx
.text:00003C20                 push    esi
.text:00003C21                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003C28                 mov     [ebp+var_4], ecx
.text:00003C2B                 mov     eax, [ebp+var_4]
.text:00003C2E                 cmp     dword ptr [eax], 0
.text:00003C31                 jz      short loc_3C4E
.text:00003C33                 mov     ecx, [ebp+var_4]
.text:00003C36                 mov     edx, [ecx]
.text:00003C38                 mov     eax, [ebp+var_4]
.text:00003C3B                 mov     ecx, [eax]
.text:00003C3D                 mov     edx, [edx]
.text:00003C3F                 mov     esi, esp
.text:00003C41                 push    ecx
.text:00003C42                 mov     eax, [edx+8]
.text:00003C45                 call    eax
.text:00003C47                 cmp     esi, esp
.text:00003C49                 call    __RTC_CheckEsp
.text:00003C4E
.text:00003C4E loc_3C4E:                               ; CODE XREF: CMyComPtr<IInArchive>::~CMyComPtr<IInArchive>(void)+15j
.text:00003C4E                 pop     esi
.text:00003C4F                 add     esp, 4
.text:00003C52                 cmp     ebp, esp
.text:00003C54                 call    __RTC_CheckEsp
.text:00003C59                 mov     esp, ebp
.text:00003C5B                 pop     ebp
.text:00003C5C                 retn
.text:00003C5C ??1?$CMyComPtr@UIInArchive@@@@QAE@XZ endp
.text:00003C5C
.text:00003C5C ; ---------------------------------------------------------------------------
.text:00003C5D                 align 10h
.text:00003C5D _text           ends
.text:00003C5D
.text:00003C60 ; ===========================================================================
.text:00003C60
.text:00003C60 ; Segment type: Pure code
.text:00003C60 ; Segment permissions: Read/Execute
.text:00003C60 _text           segment para public 'CODE' use32
.text:00003C60                 assume cs:_text
.text:00003C60                 ;org 3C60h
.text:00003C60 ; COMDAT (pick any)
.text:00003C60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003C60
.text:00003C60 ; =============== S U B R O U T I N E =======================================
.text:00003C60
.text:00003C60 ; Attributes: bp-based frame
.text:00003C60
.text:00003C60 ; public: __thiscall CMyComPtr<struct IInStream>::~CMyComPtr<struct IInStream>(void)
.text:00003C60                 public ??1?$CMyComPtr@UIInStream@@@@QAE@XZ
.text:00003C60 ??1?$CMyComPtr@UIInStream@@@@QAE@XZ proc near
.text:00003C60                                         ; CODE XREF: CArc::~CArc(void)+A6p
.text:00003C60                                         ; __unwindfunclet$??1CArc@@QAE@XZ$1+6j
.text:00003C60
.text:00003C60 var_4           = dword ptr -4
.text:00003C60
.text:00003C60                 push    ebp
.text:00003C61                 mov     ebp, esp
.text:00003C63                 push    ecx
.text:00003C64                 push    esi
.text:00003C65                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003C6C                 mov     [ebp+var_4], ecx
.text:00003C6F                 mov     eax, [ebp+var_4]
.text:00003C72                 cmp     dword ptr [eax], 0
.text:00003C75                 jz      short loc_3C92
.text:00003C77                 mov     ecx, [ebp+var_4]
.text:00003C7A                 mov     edx, [ecx]
.text:00003C7C                 mov     eax, [ebp+var_4]
.text:00003C7F                 mov     ecx, [eax]
.text:00003C81                 mov     edx, [edx]
.text:00003C83                 mov     esi, esp
.text:00003C85                 push    ecx
.text:00003C86                 mov     eax, [edx+8]
.text:00003C89                 call    eax
.text:00003C8B                 cmp     esi, esp
.text:00003C8D                 call    __RTC_CheckEsp
.text:00003C92
.text:00003C92 loc_3C92:                               ; CODE XREF: CMyComPtr<IInStream>::~CMyComPtr<IInStream>(void)+15j
.text:00003C92                 pop     esi
.text:00003C93                 add     esp, 4
.text:00003C96                 cmp     ebp, esp
.text:00003C98                 call    __RTC_CheckEsp
.text:00003C9D                 mov     esp, ebp
.text:00003C9F                 pop     ebp
.text:00003CA0                 retn
.text:00003CA0 ??1?$CMyComPtr@UIInStream@@@@QAE@XZ endp
.text:00003CA0
.text:00003CA0 ; ---------------------------------------------------------------------------
.text:00003CA1                 align 4
.text:00003CA1 _text           ends
.text:00003CA1
.text:00003CA4 ; ===========================================================================
.text:00003CA4
.text:00003CA4 ; Segment type: Pure code
.text:00003CA4 ; Segment permissions: Read/Execute
.text:00003CA4 _text           segment para public 'CODE' use32
.text:00003CA4                 assume cs:_text
.text:00003CA4                 ;org 3CA4h
.text:00003CA4 ; COMDAT (pick any)
.text:00003CA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003CA4
.text:00003CA4 ; =============== S U B R O U T I N E =======================================
.text:00003CA4
.text:00003CA4 ; Attributes: bp-based frame
.text:00003CA4
.text:00003CA4 ; public: __thiscall CMyComPtr<struct IArchiveGetRawProps>::~CMyComPtr<struct IArchiveGetRawProps>(void)
.text:00003CA4                 public ??1?$CMyComPtr@UIArchiveGetRawProps@@@@QAE@XZ
.text:00003CA4 ??1?$CMyComPtr@UIArchiveGetRawProps@@@@QAE@XZ proc near
.text:00003CA4                                         ; CODE XREF: CArc::~CArc(void)+97p
.text:00003CA4                                         ; __unwindfunclet$??1CArc@@QAE@XZ$2+6j
.text:00003CA4
.text:00003CA4 var_4           = dword ptr -4
.text:00003CA4
.text:00003CA4                 push    ebp
.text:00003CA5                 mov     ebp, esp
.text:00003CA7                 push    ecx
.text:00003CA8                 push    esi
.text:00003CA9                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003CB0                 mov     [ebp+var_4], ecx
.text:00003CB3                 mov     eax, [ebp+var_4]
.text:00003CB6                 cmp     dword ptr [eax], 0
.text:00003CB9                 jz      short loc_3CD6
.text:00003CBB                 mov     ecx, [ebp+var_4]
.text:00003CBE                 mov     edx, [ecx]
.text:00003CC0                 mov     eax, [ebp+var_4]
.text:00003CC3                 mov     ecx, [eax]
.text:00003CC5                 mov     edx, [edx]
.text:00003CC7                 mov     esi, esp
.text:00003CC9                 push    ecx
.text:00003CCA                 mov     eax, [edx+8]
.text:00003CCD                 call    eax
.text:00003CCF                 cmp     esi, esp
.text:00003CD1                 call    __RTC_CheckEsp
.text:00003CD6
.text:00003CD6 loc_3CD6:                               ; CODE XREF: CMyComPtr<IArchiveGetRawProps>::~CMyComPtr<IArchiveGetRawProps>(void)+15j
.text:00003CD6                 pop     esi
.text:00003CD7                 add     esp, 4
.text:00003CDA                 cmp     ebp, esp
.text:00003CDC                 call    __RTC_CheckEsp
.text:00003CE1                 mov     esp, ebp
.text:00003CE3                 pop     ebp
.text:00003CE4                 retn
.text:00003CE4 ??1?$CMyComPtr@UIArchiveGetRawProps@@@@QAE@XZ endp
.text:00003CE4
.text:00003CE4 ; ---------------------------------------------------------------------------
.text:00003CE5                 align 4
.text:00003CE5 _text           ends
.text:00003CE5
.text:00003CE8 ; ===========================================================================
.text:00003CE8
.text:00003CE8 ; Segment type: Pure code
.text:00003CE8 ; Segment permissions: Read/Execute
.text:00003CE8 _text           segment para public 'CODE' use32
.text:00003CE8                 assume cs:_text
.text:00003CE8                 ;org 3CE8h
.text:00003CE8 ; COMDAT (pick any)
.text:00003CE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003CE8
.text:00003CE8 ; =============== S U B R O U T I N E =======================================
.text:00003CE8
.text:00003CE8 ; Attributes: bp-based frame
.text:00003CE8
.text:00003CE8 ; public: __thiscall CMyComPtr<struct IArchiveGetRootProps>::~CMyComPtr<struct IArchiveGetRootProps>(void)
.text:00003CE8                 public ??1?$CMyComPtr@UIArchiveGetRootProps@@@@QAE@XZ
.text:00003CE8 ??1?$CMyComPtr@UIArchiveGetRootProps@@@@QAE@XZ proc near
.text:00003CE8                                         ; CODE XREF: CArc::~CArc(void)+88p
.text:00003CE8                                         ; __unwindfunclet$??1CArc@@QAE@XZ$3+6j
.text:00003CE8
.text:00003CE8 var_4           = dword ptr -4
.text:00003CE8
.text:00003CE8                 push    ebp
.text:00003CE9                 mov     ebp, esp
.text:00003CEB                 push    ecx
.text:00003CEC                 push    esi
.text:00003CED                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003CF4                 mov     [ebp+var_4], ecx
.text:00003CF7                 mov     eax, [ebp+var_4]
.text:00003CFA                 cmp     dword ptr [eax], 0
.text:00003CFD                 jz      short loc_3D1A
.text:00003CFF                 mov     ecx, [ebp+var_4]
.text:00003D02                 mov     edx, [ecx]
.text:00003D04                 mov     eax, [ebp+var_4]
.text:00003D07                 mov     ecx, [eax]
.text:00003D09                 mov     edx, [edx]
.text:00003D0B                 mov     esi, esp
.text:00003D0D                 push    ecx
.text:00003D0E                 mov     eax, [edx+8]
.text:00003D11                 call    eax
.text:00003D13                 cmp     esi, esp
.text:00003D15                 call    __RTC_CheckEsp
.text:00003D1A
.text:00003D1A loc_3D1A:                               ; CODE XREF: CMyComPtr<IArchiveGetRootProps>::~CMyComPtr<IArchiveGetRootProps>(void)+15j
.text:00003D1A                 pop     esi
.text:00003D1B                 add     esp, 4
.text:00003D1E                 cmp     ebp, esp
.text:00003D20                 call    __RTC_CheckEsp
.text:00003D25                 mov     esp, ebp
.text:00003D27                 pop     ebp
.text:00003D28                 retn
.text:00003D28 ??1?$CMyComPtr@UIArchiveGetRootProps@@@@QAE@XZ endp
.text:00003D28
.text:00003D28 ; ---------------------------------------------------------------------------
.text:00003D29                 align 4
.text:00003D29 _text           ends
.text:00003D29
.text:00003D2C ; ===========================================================================
.text:00003D2C
.text:00003D2C ; Segment type: Pure code
.text:00003D2C ; Segment permissions: Read/Execute
.text:00003D2C _text           segment para public 'CODE' use32
.text:00003D2C                 assume cs:_text
.text:00003D2C                 ;org 3D2Ch
.text:00003D2C ; COMDAT (pick any)
.text:00003D2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003D2C
.text:00003D2C ; =============== S U B R O U T I N E =======================================
.text:00003D2C
.text:00003D2C ; Attributes: bp-based frame
.text:00003D2C
.text:00003D2C ; public: __thiscall CRecordVector<void *>::CRecordVector<void *>(void)
.text:00003D2C                 public ??0?$CRecordVector@PAX@@QAE@XZ
.text:00003D2C ??0?$CRecordVector@PAX@@QAE@XZ proc near
.text:00003D2C                                         ; CODE XREF: CObjectVector<UString>::CObjectVector<UString>(void)+11p
.text:00003D2C                                         ; CObjectVector<CArc>::CObjectVector<CArc>(void)+11p ...
.text:00003D2C
.text:00003D2C var_4           = dword ptr -4
.text:00003D2C
.text:00003D2C                 push    ebp
.text:00003D2D                 mov     ebp, esp
.text:00003D2F                 push    ecx
.text:00003D30                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003D37                 mov     [ebp+var_4], ecx
.text:00003D3A                 mov     eax, [ebp+var_4]
.text:00003D3D                 mov     dword ptr [eax], 0
.text:00003D43                 mov     ecx, [ebp+var_4]
.text:00003D46                 mov     dword ptr [ecx+4], 0
.text:00003D4D                 mov     edx, [ebp+var_4]
.text:00003D50                 mov     dword ptr [edx+8], 0
.text:00003D57                 mov     eax, [ebp+var_4]
.text:00003D5A                 mov     esp, ebp
.text:00003D5C                 pop     ebp
.text:00003D5D                 retn
.text:00003D5D ??0?$CRecordVector@PAX@@QAE@XZ endp
.text:00003D5D
.text:00003D5D ; ---------------------------------------------------------------------------
.text:00003D5E                 align 10h
.text:00003D5E _text           ends
.text:00003D5E
.text:00003D60 ; ===========================================================================
.text:00003D60
.text:00003D60 ; Segment type: Pure code
.text:00003D60 ; Segment permissions: Read/Execute
.text:00003D60 _text           segment para public 'CODE' use32
.text:00003D60                 assume cs:_text
.text:00003D60                 ;org 3D60h
.text:00003D60 ; COMDAT (pick any)
.text:00003D60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003D60
.text:00003D60 ; =============== S U B R O U T I N E =======================================
.text:00003D60
.text:00003D60 ; Attributes: bp-based frame
.text:00003D60
.text:00003D60 ; public: unsigned int __thiscall CRecordVector<void *>::Size(void)const
.text:00003D60                 public ?Size@?$CRecordVector@PAX@@QBEIXZ
.text:00003D60 ?Size@?$CRecordVector@PAX@@QBEIXZ proc near
.text:00003D60                                         ; CODE XREF: CObjectVector<UString>::Size(void)+11p
.text:00003D60                                         ; CObjectVector<UString>::~CObjectVector<UString>(void)+46p ...
.text:00003D60
.text:00003D60 var_4           = dword ptr -4
.text:00003D60
.text:00003D60                 push    ebp
.text:00003D61                 mov     ebp, esp
.text:00003D63                 push    ecx
.text:00003D64                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003D6B                 mov     [ebp+var_4], ecx
.text:00003D6E                 mov     eax, [ebp+var_4]
.text:00003D71                 mov     eax, [eax+4]
.text:00003D74                 mov     esp, ebp
.text:00003D76                 pop     ebp
.text:00003D77                 retn
.text:00003D77 ?Size@?$CRecordVector@PAX@@QBEIXZ endp
.text:00003D77
.text:00003D77 _text           ends
.text:00003D77
.text:00003D78 ; ===========================================================================
.text:00003D78
.text:00003D78 ; Segment type: Pure code
.text:00003D78 ; Segment permissions: Read/Execute
.text:00003D78 _text           segment para public 'CODE' use32
.text:00003D78                 assume cs:_text
.text:00003D78                 ;org 3D78h
.text:00003D78 ; COMDAT (pick any)
.text:00003D78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003D78
.text:00003D78 ; =============== S U B R O U T I N E =======================================
.text:00003D78
.text:00003D78 ; Attributes: bp-based frame
.text:00003D78
.text:00003D78 ; public: void __thiscall CRecordVector<void *>::ConstructReserve(unsigned int)
.text:00003D78                 public ?ConstructReserve@?$CRecordVector@PAX@@QAEXI@Z
.text:00003D78 ?ConstructReserve@?$CRecordVector@PAX@@QAEXI@Z proc near
.text:00003D78                                         ; CODE XREF: CObjectVector<COpenType>::CObjectVector<COpenType>(CObjectVector<COpenType> const &)+62p
.text:00003D78
.text:00003D78 var_8           = dword ptr -8
.text:00003D78 var_4           = dword ptr -4
.text:00003D78 arg_0           = dword ptr  8
.text:00003D78
.text:00003D78                 push    ebp
.text:00003D79                 mov     ebp, esp
.text:00003D7B                 sub     esp, 8
.text:00003D7E                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00003D85                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003D8C                 mov     [ebp+var_4], ecx
.text:00003D8F                 cmp     [ebp+arg_0], 0
.text:00003D93                 jz      short loc_3DC5
.text:00003D95                 xor     ecx, ecx
.text:00003D97                 mov     eax, [ebp+arg_0]
.text:00003D9A                 mov     edx, 4
.text:00003D9F                 mul     edx
.text:00003DA1                 seto    cl
.text:00003DA4                 neg     ecx
.text:00003DA6                 or      ecx, eax
.text:00003DA8                 push    ecx             ; unsigned int
.text:00003DA9                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00003DAE                 add     esp, 4
.text:00003DB1                 mov     [ebp+var_8], eax
.text:00003DB4                 mov     eax, [ebp+var_4]
.text:00003DB7                 mov     ecx, [ebp+var_8]
.text:00003DBA                 mov     [eax], ecx
.text:00003DBC                 mov     edx, [ebp+var_4]
.text:00003DBF                 mov     eax, [ebp+arg_0]
.text:00003DC2                 mov     [edx+8], eax
.text:00003DC5
.text:00003DC5 loc_3DC5:                               ; CODE XREF: CRecordVector<void *>::ConstructReserve(uint)+1Bj
.text:00003DC5                 add     esp, 8
.text:00003DC8                 cmp     ebp, esp
.text:00003DCA                 call    __RTC_CheckEsp
.text:00003DCF                 mov     esp, ebp
.text:00003DD1                 pop     ebp
.text:00003DD2                 retn    4
.text:00003DD2 ?ConstructReserve@?$CRecordVector@PAX@@QAEXI@Z endp
.text:00003DD2
.text:00003DD2 ; ---------------------------------------------------------------------------
.text:00003DD5                 align 4
.text:00003DD5 _text           ends
.text:00003DD5
.text:00003DD8 ; ===========================================================================
.text:00003DD8
.text:00003DD8 ; Segment type: Pure code
.text:00003DD8 ; Segment permissions: Read/Execute
.text:00003DD8 _text           segment para public 'CODE' use32
.text:00003DD8                 assume cs:_text
.text:00003DD8                 ;org 3DD8h
.text:00003DD8 ; COMDAT (pick any)
.text:00003DD8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003DD8
.text:00003DD8 ; =============== S U B R O U T I N E =======================================
.text:00003DD8
.text:00003DD8 ; Attributes: bp-based frame
.text:00003DD8
.text:00003DD8 ; public: __thiscall CRecordVector<void *>::~CRecordVector<void *>(void)
.text:00003DD8                 public ??1?$CRecordVector@PAX@@QAE@XZ
.text:00003DD8 ??1?$CRecordVector@PAX@@QAE@XZ proc near
.text:00003DD8                                         ; CODE XREF: CObjectVector<UString>::~CObjectVector<UString>(void)+9Cp
.text:00003DD8                                         ; __unwindfunclet$??1?$CObjectVector@VUString@@@@QAE@XZ$0+3j ...
.text:00003DD8
.text:00003DD8 var_8           = dword ptr -8
.text:00003DD8 var_4           = dword ptr -4
.text:00003DD8
.text:00003DD8                 push    ebp
.text:00003DD9                 mov     ebp, esp
.text:00003DDB                 sub     esp, 8
.text:00003DDE                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00003DE5                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003DEC                 mov     [ebp+var_4], ecx
.text:00003DEF                 mov     eax, [ebp+var_4]
.text:00003DF2                 mov     ecx, [eax]
.text:00003DF4                 mov     [ebp+var_8], ecx
.text:00003DF7                 mov     edx, [ebp+var_8]
.text:00003DFA                 push    edx             ; void *
.text:00003DFB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00003E00                 add     esp, 4
.text:00003E03                 add     esp, 8
.text:00003E06                 cmp     ebp, esp
.text:00003E08                 call    __RTC_CheckEsp
.text:00003E0D                 mov     esp, ebp
.text:00003E0F                 pop     ebp
.text:00003E10                 retn
.text:00003E10 ??1?$CRecordVector@PAX@@QAE@XZ endp
.text:00003E10
.text:00003E10 ; ---------------------------------------------------------------------------
.text:00003E11                 align 4
.text:00003E11 _text           ends
.text:00003E11
.text:00003E14 ; ===========================================================================
.text:00003E14
.text:00003E14 ; Segment type: Pure code
.text:00003E14 ; Segment permissions: Read/Execute
.text:00003E14 _text           segment para public 'CODE' use32
.text:00003E14                 assume cs:_text
.text:00003E14                 ;org 3E14h
.text:00003E14 ; COMDAT (pick any)
.text:00003E14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003E14
.text:00003E14 ; =============== S U B R O U T I N E =======================================
.text:00003E14
.text:00003E14 ; Attributes: bp-based frame
.text:00003E14
.text:00003E14 ; public: unsigned int __thiscall CRecordVector<void *>::Add(void * const)
.text:00003E14                 public ?Add@?$CRecordVector@PAX@@QAEIQAX@Z
.text:00003E14 ?Add@?$CRecordVector@PAX@@QAEIQAX@Z proc near
.text:00003E14                                         ; CODE XREF: CObjectVector<UString>::Add(UString const &)+7Fp
.text:00003E14
.text:00003E14 var_8           = dword ptr -8
.text:00003E14 var_4           = dword ptr -4
.text:00003E14 arg_0           = dword ptr  8
.text:00003E14
.text:00003E14                 push    ebp
.text:00003E15                 mov     ebp, esp
.text:00003E17                 sub     esp, 8
.text:00003E1A                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00003E21                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003E28                 mov     [ebp+var_4], ecx
.text:00003E2B                 mov     ecx, [ebp+var_4]
.text:00003E2E                 call    ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ ; CRecordVector<void *>::ReserveOnePosition(void)
.text:00003E33                 mov     eax, [ebp+var_4]
.text:00003E36                 mov     ecx, [eax+4]
.text:00003E39                 mov     edx, [ebp+var_4]
.text:00003E3C                 mov     eax, [edx]
.text:00003E3E                 mov     edx, [ebp+arg_0]
.text:00003E41                 mov     [eax+ecx*4], edx
.text:00003E44                 mov     eax, [ebp+var_4]
.text:00003E47                 mov     ecx, [eax+4]
.text:00003E4A                 mov     [ebp+var_8], ecx
.text:00003E4D                 mov     edx, [ebp+var_4]
.text:00003E50                 mov     eax, [edx+4]
.text:00003E53                 add     eax, 1
.text:00003E56                 mov     ecx, [ebp+var_4]
.text:00003E59                 mov     [ecx+4], eax
.text:00003E5C                 mov     eax, [ebp+var_8]
.text:00003E5F                 add     esp, 8
.text:00003E62                 cmp     ebp, esp
.text:00003E64                 call    __RTC_CheckEsp
.text:00003E69                 mov     esp, ebp
.text:00003E6B                 pop     ebp
.text:00003E6C                 retn    4
.text:00003E6C ?Add@?$CRecordVector@PAX@@QAEIQAX@Z endp
.text:00003E6C
.text:00003E6C ; ---------------------------------------------------------------------------
.text:00003E6F                 align 10h
.text:00003E6F _text           ends
.text:00003E6F
.text:00003E70 ; ===========================================================================
.text:00003E70
.text:00003E70 ; Segment type: Pure code
.text:00003E70 ; Segment permissions: Read/Execute
.text:00003E70 _text           segment para public 'CODE' use32
.text:00003E70                 assume cs:_text
.text:00003E70                 ;org 3E70h
.text:00003E70 ; COMDAT (pick any)
.text:00003E70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003E70
.text:00003E70 ; =============== S U B R O U T I N E =======================================
.text:00003E70
.text:00003E70 ; Attributes: bp-based frame
.text:00003E70
.text:00003E70 ; public: void __thiscall CRecordVector<void *>::AddInReserved(void * const)
.text:00003E70                 public ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z
.text:00003E70 ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z proc near
.text:00003E70                                         ; CODE XREF: CObjectVector<COpenType>::CObjectVector<COpenType>(CObjectVector<COpenType> const &)+D0p
.text:00003E70
.text:00003E70 var_4           = dword ptr -4
.text:00003E70 arg_0           = dword ptr  8
.text:00003E70
.text:00003E70                 push    ebp
.text:00003E71                 mov     ebp, esp
.text:00003E73                 push    ecx
.text:00003E74                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003E7B                 mov     [ebp+var_4], ecx
.text:00003E7E                 mov     eax, [ebp+var_4]
.text:00003E81                 mov     ecx, [eax+4]
.text:00003E84                 mov     edx, [ebp+var_4]
.text:00003E87                 mov     eax, [edx]
.text:00003E89                 mov     edx, [ebp+arg_0]
.text:00003E8C                 mov     [eax+ecx*4], edx
.text:00003E8F                 mov     eax, [ebp+var_4]
.text:00003E92                 mov     ecx, [eax+4]
.text:00003E95                 add     ecx, 1
.text:00003E98                 mov     edx, [ebp+var_4]
.text:00003E9B                 mov     [edx+4], ecx
.text:00003E9E                 mov     esp, ebp
.text:00003EA0                 pop     ebp
.text:00003EA1                 retn    4
.text:00003EA1 ?AddInReserved@?$CRecordVector@PAX@@QAEXQAX@Z endp
.text:00003EA1
.text:00003EA1 _text           ends
.text:00003EA1
.text:00003EA4 ; ===========================================================================
.text:00003EA4
.text:00003EA4 ; Segment type: Pure code
.text:00003EA4 ; Segment permissions: Read/Execute
.text:00003EA4 _text           segment para public 'CODE' use32
.text:00003EA4                 assume cs:_text
.text:00003EA4                 ;org 3EA4h
.text:00003EA4 ; COMDAT (pick any)
.text:00003EA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003EA4
.text:00003EA4 ; =============== S U B R O U T I N E =======================================
.text:00003EA4
.text:00003EA4 ; Attributes: bp-based frame
.text:00003EA4
.text:00003EA4 ; public: void * const & __thiscall CRecordVector<void *>::operator[](unsigned int)const
.text:00003EA4                 public ??A?$CRecordVector@PAX@@QBEABQAXI@Z
.text:00003EA4 ??A?$CRecordVector@PAX@@QBEABQAXI@Z proc near
.text:00003EA4                                         ; CODE XREF: CObjectVector<UString>::operator[](uint)+15p
.text:00003EA4                                         ; CObjectVector<CArc>::operator[](uint)+15p ...
.text:00003EA4
.text:00003EA4 var_4           = dword ptr -4
.text:00003EA4 arg_0           = dword ptr  8
.text:00003EA4
.text:00003EA4                 push    ebp
.text:00003EA5                 mov     ebp, esp
.text:00003EA7                 push    ecx
.text:00003EA8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003EAF                 mov     [ebp+var_4], ecx
.text:00003EB2                 mov     eax, [ebp+var_4]
.text:00003EB5                 mov     ecx, [eax]
.text:00003EB7                 mov     edx, [ebp+arg_0]
.text:00003EBA                 lea     eax, [ecx+edx*4]
.text:00003EBD                 mov     esp, ebp
.text:00003EBF                 pop     ebp
.text:00003EC0                 retn    4
.text:00003EC0 ??A?$CRecordVector@PAX@@QBEABQAXI@Z endp
.text:00003EC0
.text:00003EC0 ; ---------------------------------------------------------------------------
.text:00003EC3                 align 4
.text:00003EC3 _text           ends
.text:00003EC3
.text:00003EC4 ; ===========================================================================
.text:00003EC4
.text:00003EC4 ; Segment type: Pure code
.text:00003EC4 ; Segment permissions: Read/Execute
.text:00003EC4 _text           segment para public 'CODE' use32
.text:00003EC4                 assume cs:_text
.text:00003EC4                 ;org 3EC4h
.text:00003EC4 ; COMDAT (pick any)
.text:00003EC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003EC4
.text:00003EC4 ; =============== S U B R O U T I N E =======================================
.text:00003EC4
.text:00003EC4 ; Attributes: bp-based frame
.text:00003EC4
.text:00003EC4 ; public: void * & __thiscall CRecordVector<void *>::operator[](unsigned int)
.text:00003EC4                 public ??A?$CRecordVector@PAX@@QAEAAPAXI@Z
.text:00003EC4 ??A?$CRecordVector@PAX@@QAEAAPAXI@Z proc near
.text:00003EC4                                         ; CODE XREF: CObjectVector<UString>::operator[](uint)+15p
.text:00003EC4                                         ; CObjectVector<UString>::~CObjectVector<UString>(void)+64p ...
.text:00003EC4
.text:00003EC4 var_4           = dword ptr -4
.text:00003EC4 arg_0           = dword ptr  8
.text:00003EC4
.text:00003EC4                 push    ebp
.text:00003EC5                 mov     ebp, esp
.text:00003EC7                 push    ecx
.text:00003EC8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003ECF                 mov     [ebp+var_4], ecx
.text:00003ED2                 mov     eax, [ebp+var_4]
.text:00003ED5                 mov     ecx, [eax]
.text:00003ED7                 mov     edx, [ebp+arg_0]
.text:00003EDA                 lea     eax, [ecx+edx*4]
.text:00003EDD                 mov     esp, ebp
.text:00003EDF                 pop     ebp
.text:00003EE0                 retn    4
.text:00003EE0 ??A?$CRecordVector@PAX@@QAEAAPAXI@Z endp
.text:00003EE0
.text:00003EE0 ; ---------------------------------------------------------------------------
.text:00003EE3                 align 4
.text:00003EE3 _text           ends
.text:00003EE3
.text:00003EE4 ; ===========================================================================
.text:00003EE4
.text:00003EE4 ; Segment type: Pure code
.text:00003EE4 ; Segment permissions: Read/Execute
.text:00003EE4 _text           segment para public 'CODE' use32
.text:00003EE4                 assume cs:_text
.text:00003EE4                 ;org 3EE4h
.text:00003EE4 ; COMDAT (pick any)
.text:00003EE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003EE4
.text:00003EE4 ; =============== S U B R O U T I N E =======================================
.text:00003EE4
.text:00003EE4 ; Attributes: bp-based frame
.text:00003EE4
.text:00003EE4 ; private: void __thiscall CRecordVector<unsigned __int64>::ReserveOnePosition(void)
.text:00003EE4                 public ?ReserveOnePosition@?$CRecordVector@_K@@AAEXXZ
.text:00003EE4 ?ReserveOnePosition@?$CRecordVector@_K@@AAEXXZ proc near
.text:00003EE4                                         ; CODE XREF: CRecordVector<unsigned __int64>::Add(unsigned __int64)+1Ap
.text:00003EE4
.text:00003EE4 var_14          = dword ptr -14h
.text:00003EE4 var_10          = dword ptr -10h
.text:00003EE4 Dst             = dword ptr -0Ch
.text:00003EE4 var_8           = dword ptr -8
.text:00003EE4 var_4           = dword ptr -4
.text:00003EE4
.text:00003EE4                 push    ebp
.text:00003EE5                 mov     ebp, esp
.text:00003EE7                 sub     esp, 14h
.text:00003EEA                 mov     eax, 0CCCCCCCCh
.text:00003EEF                 mov     [ebp+var_14], eax
.text:00003EF2                 mov     [ebp+var_10], eax
.text:00003EF5                 mov     [ebp+Dst], eax
.text:00003EF8                 mov     [ebp+var_8], eax
.text:00003EFB                 mov     [ebp+var_4], eax
.text:00003EFE                 mov     [ebp+var_4], ecx
.text:00003F01                 mov     eax, [ebp+var_4]
.text:00003F04                 mov     ecx, [ebp+var_4]
.text:00003F07                 mov     edx, [eax+4]
.text:00003F0A                 cmp     edx, [ecx+8]
.text:00003F0D                 jnz     loc_3F98
.text:00003F13                 mov     eax, [ebp+var_4]
.text:00003F16                 mov     ecx, [eax+8]
.text:00003F19                 shr     ecx, 2
.text:00003F1C                 mov     edx, [ebp+var_4]
.text:00003F1F                 mov     eax, [edx+8]
.text:00003F22                 lea     ecx, [eax+ecx+1]
.text:00003F26                 mov     [ebp+var_8], ecx
.text:00003F29                 xor     ecx, ecx
.text:00003F2B                 mov     eax, [ebp+var_8]
.text:00003F2E                 mov     edx, 8
.text:00003F33                 mul     edx
.text:00003F35                 seto    cl
.text:00003F38                 neg     ecx
.text:00003F3A                 or      ecx, eax
.text:00003F3C                 push    ecx             ; unsigned int
.text:00003F3D                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00003F42                 add     esp, 4
.text:00003F45                 mov     [ebp+var_10], eax
.text:00003F48                 mov     eax, [ebp+var_10]
.text:00003F4B                 mov     [ebp+Dst], eax
.text:00003F4E                 mov     ecx, [ebp+var_4]
.text:00003F51                 cmp     dword ptr [ecx+4], 0
.text:00003F55                 jz      short loc_3F73
.text:00003F57                 mov     edx, [ebp+var_4]
.text:00003F5A                 mov     eax, [edx+4]
.text:00003F5D                 shl     eax, 3
.text:00003F60                 push    eax             ; Size
.text:00003F61                 mov     ecx, [ebp+var_4]
.text:00003F64                 mov     edx, [ecx]
.text:00003F66                 push    edx             ; Src
.text:00003F67                 mov     eax, [ebp+Dst]
.text:00003F6A                 push    eax             ; Dst
.text:00003F6B                 call    _memcpy
.text:00003F70                 add     esp, 0Ch
.text:00003F73
.text:00003F73 loc_3F73:                               ; CODE XREF: CRecordVector<unsigned __int64>::ReserveOnePosition(void)+71j
.text:00003F73                 mov     ecx, [ebp+var_4]
.text:00003F76                 mov     edx, [ecx]
.text:00003F78                 mov     [ebp+var_14], edx
.text:00003F7B                 mov     eax, [ebp+var_14]
.text:00003F7E                 push    eax             ; void *
.text:00003F7F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00003F84                 add     esp, 4
.text:00003F87                 mov     ecx, [ebp+var_4]
.text:00003F8A                 mov     edx, [ebp+Dst]
.text:00003F8D                 mov     [ecx], edx
.text:00003F8F                 mov     eax, [ebp+var_4]
.text:00003F92                 mov     ecx, [ebp+var_8]
.text:00003F95                 mov     [eax+8], ecx
.text:00003F98
.text:00003F98 loc_3F98:                               ; CODE XREF: CRecordVector<unsigned __int64>::ReserveOnePosition(void)+29j
.text:00003F98                 add     esp, 14h
.text:00003F9B                 cmp     ebp, esp
.text:00003F9D                 call    __RTC_CheckEsp
.text:00003FA2                 mov     esp, ebp
.text:00003FA4                 pop     ebp
.text:00003FA5                 retn
.text:00003FA5 ?ReserveOnePosition@?$CRecordVector@_K@@AAEXXZ endp
.text:00003FA5
.text:00003FA5 ; ---------------------------------------------------------------------------
.text:00003FA6                 align 4
.text:00003FA6 _text           ends
.text:00003FA6
.text:00003FA8 ; ===========================================================================
.text:00003FA8
.text:00003FA8 ; Segment type: Pure code
.text:00003FA8 ; Segment permissions: Read/Execute
.text:00003FA8 _text           segment para public 'CODE' use32
.text:00003FA8                 assume cs:_text
.text:00003FA8                 ;org 3FA8h
.text:00003FA8 ; COMDAT (pick any)
.text:00003FA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003FA8
.text:00003FA8 ; =============== S U B R O U T I N E =======================================
.text:00003FA8
.text:00003FA8 ; Attributes: bp-based frame
.text:00003FA8
.text:00003FA8 ; public: class CArc & __thiscall CObjectVector<class CArc>::operator[](unsigned int)
.text:00003FA8                 public ??A?$CObjectVector@VCArc@@@@QAEAAVCArc@@I@Z
.text:00003FA8 ??A?$CObjectVector@VCArc@@@@QAEAAVCArc@@I@Z proc near
.text:00003FA8                                         ; CODE XREF: CObjectVector<CArc>::Back(void)+1Dp
.text:00003FA8
.text:00003FA8 var_4           = dword ptr -4
.text:00003FA8 arg_0           = dword ptr  8
.text:00003FA8
.text:00003FA8                 push    ebp
.text:00003FA9                 mov     ebp, esp
.text:00003FAB                 push    ecx
.text:00003FAC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00003FB3                 mov     [ebp+var_4], ecx
.text:00003FB6                 mov     eax, [ebp+arg_0]
.text:00003FB9                 push    eax
.text:00003FBA                 mov     ecx, [ebp+var_4]
.text:00003FBD                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00003FC2                 mov     eax, [eax]
.text:00003FC4                 add     esp, 4
.text:00003FC7                 cmp     ebp, esp
.text:00003FC9                 call    __RTC_CheckEsp
.text:00003FCE                 mov     esp, ebp
.text:00003FD0                 pop     ebp
.text:00003FD1                 retn    4
.text:00003FD1 ??A?$CObjectVector@VCArc@@@@QAEAAVCArc@@I@Z endp
.text:00003FD1
.text:00003FD1 _text           ends
.text:00003FD1
.text:00003FD4 ; ===========================================================================
.text:00003FD4
.text:00003FD4 ; Segment type: Pure code
.text:00003FD4 ; Segment permissions: Read/Execute
.text:00003FD4 _text           segment para public 'CODE' use32
.text:00003FD4                 assume cs:_text
.text:00003FD4                 ;org 3FD4h
.text:00003FD4 ; COMDAT (pick any)
.text:00003FD4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00003FD4
.text:00003FD4 ; =============== S U B R O U T I N E =======================================
.text:00003FD4
.text:00003FD4 ; Attributes: bp-based frame
.text:00003FD4
.text:00003FD4 ; private: void __thiscall CRecordVector<unsigned int>::ReserveOnePosition(void)
.text:00003FD4                 public ?ReserveOnePosition@?$CRecordVector@I@@AAEXXZ
.text:00003FD4 ?ReserveOnePosition@?$CRecordVector@I@@AAEXXZ proc near
.text:00003FD4                                         ; CODE XREF: CRecordVector<uint>::Add(uint)+1Ap
.text:00003FD4
.text:00003FD4 var_14          = dword ptr -14h
.text:00003FD4 var_10          = dword ptr -10h
.text:00003FD4 Dst             = dword ptr -0Ch
.text:00003FD4 var_8           = dword ptr -8
.text:00003FD4 var_4           = dword ptr -4
.text:00003FD4
.text:00003FD4                 push    ebp
.text:00003FD5                 mov     ebp, esp
.text:00003FD7                 sub     esp, 14h
.text:00003FDA                 mov     eax, 0CCCCCCCCh
.text:00003FDF                 mov     [ebp+var_14], eax
.text:00003FE2                 mov     [ebp+var_10], eax
.text:00003FE5                 mov     [ebp+Dst], eax
.text:00003FE8                 mov     [ebp+var_8], eax
.text:00003FEB                 mov     [ebp+var_4], eax
.text:00003FEE                 mov     [ebp+var_4], ecx
.text:00003FF1                 mov     eax, [ebp+var_4]
.text:00003FF4                 mov     ecx, [ebp+var_4]
.text:00003FF7                 mov     edx, [eax+4]
.text:00003FFA                 cmp     edx, [ecx+8]
.text:00003FFD                 jnz     loc_4088
.text:00004003                 mov     eax, [ebp+var_4]
.text:00004006                 mov     ecx, [eax+8]
.text:00004009                 shr     ecx, 2
.text:0000400C                 mov     edx, [ebp+var_4]
.text:0000400F                 mov     eax, [edx+8]
.text:00004012                 lea     ecx, [eax+ecx+1]
.text:00004016                 mov     [ebp+var_8], ecx
.text:00004019                 xor     ecx, ecx
.text:0000401B                 mov     eax, [ebp+var_8]
.text:0000401E                 mov     edx, 4
.text:00004023                 mul     edx
.text:00004025                 seto    cl
.text:00004028                 neg     ecx
.text:0000402A                 or      ecx, eax
.text:0000402C                 push    ecx             ; unsigned int
.text:0000402D                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00004032                 add     esp, 4
.text:00004035                 mov     [ebp+var_10], eax
.text:00004038                 mov     eax, [ebp+var_10]
.text:0000403B                 mov     [ebp+Dst], eax
.text:0000403E                 mov     ecx, [ebp+var_4]
.text:00004041                 cmp     dword ptr [ecx+4], 0
.text:00004045                 jz      short loc_4063
.text:00004047                 mov     edx, [ebp+var_4]
.text:0000404A                 mov     eax, [edx+4]
.text:0000404D                 shl     eax, 2
.text:00004050                 push    eax             ; Size
.text:00004051                 mov     ecx, [ebp+var_4]
.text:00004054                 mov     edx, [ecx]
.text:00004056                 push    edx             ; Src
.text:00004057                 mov     eax, [ebp+Dst]
.text:0000405A                 push    eax             ; Dst
.text:0000405B                 call    _memcpy
.text:00004060                 add     esp, 0Ch
.text:00004063
.text:00004063 loc_4063:                               ; CODE XREF: CRecordVector<uint>::ReserveOnePosition(void)+71j
.text:00004063                 mov     ecx, [ebp+var_4]
.text:00004066                 mov     edx, [ecx]
.text:00004068                 mov     [ebp+var_14], edx
.text:0000406B                 mov     eax, [ebp+var_14]
.text:0000406E                 push    eax             ; void *
.text:0000406F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00004074                 add     esp, 4
.text:00004077                 mov     ecx, [ebp+var_4]
.text:0000407A                 mov     edx, [ebp+Dst]
.text:0000407D                 mov     [ecx], edx
.text:0000407F                 mov     eax, [ebp+var_4]
.text:00004082                 mov     ecx, [ebp+var_8]
.text:00004085                 mov     [eax+8], ecx
.text:00004088
.text:00004088 loc_4088:                               ; CODE XREF: CRecordVector<uint>::ReserveOnePosition(void)+29j
.text:00004088                 add     esp, 14h
.text:0000408B                 cmp     ebp, esp
.text:0000408D                 call    __RTC_CheckEsp
.text:00004092                 mov     esp, ebp
.text:00004094                 pop     ebp
.text:00004095                 retn
.text:00004095 ?ReserveOnePosition@?$CRecordVector@I@@AAEXXZ endp
.text:00004095
.text:00004095 ; ---------------------------------------------------------------------------
.text:00004096                 align 4
.text:00004096 _text           ends
.text:00004096
.text:00004098 ; ===========================================================================
.text:00004098
.text:00004098 ; Segment type: Pure code
.text:00004098 ; Segment permissions: Read/Execute
.text:00004098 _text           segment para public 'CODE' use32
.text:00004098                 assume cs:_text
.text:00004098                 ;org 4098h
.text:00004098 ; COMDAT (pick any)
.text:00004098                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:00004098
.text:00004098 ; =============== S U B R O U T I N E =======================================
.text:00004098
.text:00004098 ; Attributes: bp-based frame
.text:00004098
.text:00004098 ; public: unsigned int __thiscall CObjectVector<struct COpenType>::Size(void)const
.text:00004098                 public ?Size@?$CObjectVector@UCOpenType@@@@QBEIXZ
.text:00004098 ?Size@?$CObjectVector@UCOpenType@@@@QBEIXZ proc near
.text:00004098                                         ; CODE XREF: CObjectVector<COpenType>::CObjectVector<COpenType>(CObjectVector<COpenType> const &)+53p
.text:00004098
.text:00004098 var_4           = dword ptr -4
.text:00004098
.text:00004098                 push    ebp
.text:00004099                 mov     ebp, esp
.text:0000409B                 push    ecx
.text:0000409C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000040A3                 mov     [ebp+var_4], ecx
.text:000040A6                 mov     ecx, [ebp+var_4]
.text:000040A9                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:000040AE                 add     esp, 4
.text:000040B1                 cmp     ebp, esp
.text:000040B3                 call    __RTC_CheckEsp
.text:000040B8                 mov     esp, ebp
.text:000040BA                 pop     ebp
.text:000040BB                 retn
.text:000040BB ?Size@?$CObjectVector@UCOpenType@@@@QBEIXZ endp
.text:000040BB
.text:000040BB _text           ends
.text:000040BB
.text:000040BC ; ===========================================================================
.text:000040BC
.text:000040BC ; Segment type: Pure code
.text:000040BC ; Segment permissions: Read/Execute
.text:000040BC _text           segment para public 'CODE' use32
.text:000040BC                 assume cs:_text
.text:000040BC                 ;org 40BCh
.text:000040BC ; COMDAT (pick any)
.text:000040BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000040BC
.text:000040BC ; =============== S U B R O U T I N E =======================================
.text:000040BC
.text:000040BC ; Attributes: bp-based frame
.text:000040BC
.text:000040BC ; public: struct COpenType const & __thiscall CObjectVector<struct COpenType>::operator[](unsigned int)const
.text:000040BC                 public ??A?$CObjectVector@UCOpenType@@@@QBEABUCOpenType@@I@Z
.text:000040BC ??A?$CObjectVector@UCOpenType@@@@QBEABUCOpenType@@I@Z proc near
.text:000040BC                                         ; CODE XREF: CObjectVector<COpenType>::CObjectVector<COpenType>(CObjectVector<COpenType> const &)+9Fp
.text:000040BC
.text:000040BC var_4           = dword ptr -4
.text:000040BC arg_0           = dword ptr  8
.text:000040BC
.text:000040BC                 push    ebp
.text:000040BD                 mov     ebp, esp
.text:000040BF                 push    ecx
.text:000040C0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000040C7                 mov     [ebp+var_4], ecx
.text:000040CA                 mov     eax, [ebp+arg_0]
.text:000040CD                 push    eax
.text:000040CE                 mov     ecx, [ebp+var_4]
.text:000040D1                 call    ??A?$CRecordVector@PAX@@QBEABQAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:000040D6                 mov     eax, [eax]
.text:000040D8                 add     esp, 4
.text:000040DB                 cmp     ebp, esp
.text:000040DD                 call    __RTC_CheckEsp
.text:000040E2                 mov     esp, ebp
.text:000040E4                 pop     ebp
.text:000040E5                 retn    4
.text:000040E5 ??A?$CObjectVector@UCOpenType@@@@QBEABUCOpenType@@I@Z endp
.text:000040E5
.text:000040E5 _text           ends
.text:000040E5
.text:000040E8 ; ===========================================================================
.text:000040E8
.text:000040E8 ; Segment type: Pure code
.text:000040E8 ; Segment permissions: Read/Execute
.text:000040E8 _text           segment para public 'CODE' use32
.text:000040E8                 assume cs:_text
.text:000040E8                 ;org 40E8h
.text:000040E8 ; COMDAT (pick any)
.text:000040E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text:000040E8
.text:000040E8 ; =============== S U B R O U T I N E =======================================
.text:000040E8
.text:000040E8 ; Attributes: bp-based frame
.text:000040E8
.text:000040E8 ; private: void __thiscall CRecordVector<void *>::ReserveOnePosition(void)
.text:000040E8                 public ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ
.text:000040E8 ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ proc near
.text:000040E8                                         ; CODE XREF: CRecordVector<void *>::Add(void * const)+1Ap
.text:000040E8
.text:000040E8 var_14          = dword ptr -14h
.text:000040E8 var_10          = dword ptr -10h
.text:000040E8 Dst             = dword ptr -0Ch
.text:000040E8 var_8           = dword ptr -8
.text:000040E8 var_4           = dword ptr -4
.text:000040E8
.text:000040E8                 push    ebp
.text:000040E9                 mov     ebp, esp
.text:000040EB                 sub     esp, 14h
.text:000040EE                 mov     eax, 0CCCCCCCCh
.text:000040F3                 mov     [ebp+var_14], eax
.text:000040F6                 mov     [ebp+var_10], eax
.text:000040F9                 mov     [ebp+Dst], eax
.text:000040FC                 mov     [ebp+var_8], eax
.text:000040FF                 mov     [ebp+var_4], eax
.text:00004102                 mov     [ebp+var_4], ecx
.text:00004105                 mov     eax, [ebp+var_4]
.text:00004108                 mov     ecx, [ebp+var_4]
.text:0000410B                 mov     edx, [eax+4]
.text:0000410E                 cmp     edx, [ecx+8]
.text:00004111                 jnz     loc_419C
.text:00004117                 mov     eax, [ebp+var_4]
.text:0000411A                 mov     ecx, [eax+8]
.text:0000411D                 shr     ecx, 2
.text:00004120                 mov     edx, [ebp+var_4]
.text:00004123                 mov     eax, [edx+8]
.text:00004126                 lea     ecx, [eax+ecx+1]
.text:0000412A                 mov     [ebp+var_8], ecx
.text:0000412D                 xor     ecx, ecx
.text:0000412F                 mov     eax, [ebp+var_8]
.text:00004132                 mov     edx, 4
.text:00004137                 mul     edx
.text:00004139                 seto    cl
.text:0000413C                 neg     ecx
.text:0000413E                 or      ecx, eax
.text:00004140                 push    ecx             ; unsigned int
.text:00004141                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00004146                 add     esp, 4
.text:00004149                 mov     [ebp+var_10], eax
.text:0000414C                 mov     eax, [ebp+var_10]
.text:0000414F                 mov     [ebp+Dst], eax
.text:00004152                 mov     ecx, [ebp+var_4]
.text:00004155                 cmp     dword ptr [ecx+4], 0
.text:00004159                 jz      short loc_4177
.text:0000415B                 mov     edx, [ebp+var_4]
.text:0000415E                 mov     eax, [edx+4]
.text:00004161                 shl     eax, 2
.text:00004164                 push    eax             ; Size
.text:00004165                 mov     ecx, [ebp+var_4]
.text:00004168                 mov     edx, [ecx]
.text:0000416A                 push    edx             ; Src
.text:0000416B                 mov     eax, [ebp+Dst]
.text:0000416E                 push    eax             ; Dst
.text:0000416F                 call    _memcpy
.text:00004174                 add     esp, 0Ch
.text:00004177
.text:00004177 loc_4177:                               ; CODE XREF: CRecordVector<void *>::ReserveOnePosition(void)+71j
.text:00004177                 mov     ecx, [ebp+var_4]
.text:0000417A                 mov     edx, [ecx]
.text:0000417C                 mov     [ebp+var_14], edx
.text:0000417F                 mov     eax, [ebp+var_14]
.text:00004182                 push    eax             ; void *
.text:00004183                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00004188                 add     esp, 4
.text:0000418B                 mov     ecx, [ebp+var_4]
.text:0000418E                 mov     edx, [ebp+Dst]
.text:00004191                 mov     [ecx], edx
.text:00004193                 mov     eax, [ebp+var_4]
.text:00004196                 mov     ecx, [ebp+var_8]
.text:00004199                 mov     [eax+8], ecx
.text:0000419C
.text:0000419C loc_419C:                               ; CODE XREF: CRecordVector<void *>::ReserveOnePosition(void)+29j
.text:0000419C                 add     esp, 14h
.text:0000419F                 cmp     ebp, esp
.text:000041A1                 call    __RTC_CheckEsp
.text:000041A6                 mov     esp, ebp
.text:000041A8                 pop     ebp
.text:000041A9                 retn
.text:000041A9 ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ endp
.text:000041A9
.text:000041A9 _text           ends
.text:000041A9
UNDEF:000041B0 ; ===========================================================================
UNDEF:000041B0
UNDEF:000041B0 ; Segment type: Externs
UNDEF:000041B0 ; UNDEF
UNDEF:000041B0 ; int __stdcall CompareFileNames(const wchar_t *, const wchar_t *)
UNDEF:000041B0                 extrn ?CompareFileNames@@YGHPB_W0@Z:near
UNDEF:000041B0                                         ; CODE XREF: Find_FileName_InSortedVector(CObjectVector<UString> const &,UString const &)+60p
UNDEF:000041B4                 extrn __RTC_CheckEsp:near
UNDEF:000041B4                                         ; CODE XREF: Find_FileName_InSortedVector(CObjectVector<UString> const &,UString const &)+94p
UNDEF:000041B4                                         ; Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+282p ...
UNDEF:000041B8                 extrn __RTC_Shutdown:near
UNDEF:000041B8                                         ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
UNDEF:000041BC                 extrn __RTC_InitBase:near
UNDEF:000041BC                                         ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
UNDEF:000041C0 ; void __cdecl operator delete(void *)
UNDEF:000041C0                 extrn ??3@YAXPAX@Z:near ; CODE XREF: __unwindfunclet$?Extract@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABV?$CRecordVector@H@@AAV?$CObjectVector@VUString@@@@3ABVCCensorNode@NWildcard@@ABUCExtractOptions@@PAUIOpenCallbackUI@@PAUIExtractCallbackUI@@PAUIHashCalc@@AAVUString@@AAUCDecompressStat@@@Z$3+7p
UNDEF:000041C0                                         ; UString::~UString(void)+23p ...
UNDEF:000041C4 ; __int32 __thiscall CArchiveLink::Open3(CArchiveLink *__hidden this, struct COpenOptions *, struct IOpenCallbackUI *)
UNDEF:000041C4                 extrn ?Open3@CArchiveLink@@QAEJAAUCOpenOptions@@PAUIOpenCallbackUI@@@Z:near
UNDEF:000041C4                                         ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+4D9p
UNDEF:000041C8 ; public: class UString & __thiscall UString::operator=(class UString const &)
UNDEF:000041C8                 extrn ??4UString@@QAEAAV0@ABV0@@Z:near
UNDEF:000041C8                                         ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+4C3p
UNDEF:000041C8                                         ; DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+FDp ...
UNDEF:000041CC ; _DWORD __thiscall CArchiveExtractCallback::CArchiveExtractCallback(CArchiveExtractCallback *__hidden this)
UNDEF:000041CC                 extrn ??0CArchiveExtractCallback@@QAE@XZ:near
UNDEF:000041CC                                         ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+1D2p
UNDEF:000041D0 ; void *__cdecl operator new(unsigned int)
UNDEF:000041D0                 extrn ??2@YAPAXI@Z:near ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+1B1p
UNDEF:000041D0                                         ; CArchiveExtractCallback::SetHashMethods(IHashCalc *)+43p ...
UNDEF:000041D4 ; bool __thiscall NWindows::NFile::NFind::CFileInfo::Find(NWindows::NFile::NFind::CFileInfo *__hidden this, const wchar_t *)
UNDEF:000041D4                 extrn ?Find@CFileInfo@NFind@NFile@NWindows@@QAE_NPB_W@Z:near
UNDEF:000041D4                                         ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+EDp
UNDEF:000041D4                                         ; Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+383p ...
UNDEF:000041D8                 extrn ___security_cookie:near
UNDEF:000041D8                                         ; DATA XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+2Br
UNDEF:000041D8                                         ; DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+2Br ...
UNDEF:000041DC                 extrn ___CxxFrameHandler3:near
UNDEF:000041DC                                         ; CODE XREF: __ehhandler$?Extract@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABV?$CRecordVector@H@@AAV?$CObjectVector@VUString@@@@3ABVCCensorNode@NWildcard@@ABUCExtractOptions@@PAUIOpenCallbackUI@@PAUIExtractCallbackUI@@PAUIHashCalc@@AAVUString@@AAUCDecompressStat@@@Z+19j
UNDEF:000041DC                                         ; __ehhandler$?DecompressArchive@@YGJPAVCCodecs@@ABUCArchiveLink@@_KABVCCensorNode@NWildcard@@ABUCExtractOptions@@_NPAUIExtractCallbackUI@@PAVCArchiveExtractCallback@@AAVUString@@AA_K@Z+19j ...
UNDEF:000041E0 ; __fastcall __security_check_cookie(x)
UNDEF:000041E0                 extrn @__security_check_cookie@4:near
UNDEF:000041E0                                         ; CODE XREF: __ehhandler$?Extract@@YGJPAVCCodecs@@ABV?$CObjectVector@UCOpenType@@@@ABV?$CRecordVector@H@@AAV?$CObjectVector@VUString@@@@3ABVCCensorNode@NWildcard@@ABUCExtractOptions@@PAUIOpenCallbackUI@@PAUIExtractCallbackUI@@PAUIHashCalc@@AAVUString@@AAUCDecompressStat@@@Z+Fp
UNDEF:000041E0                                         ; __ehhandler$?DecompressArchive@@YGJPAVCCodecs@@ABUCArchiveLink@@_KABVCCensorNode@NWildcard@@ABUCExtractOptions@@_NPAUIExtractCallbackUI@@PAVCArchiveExtractCallback@@AAVUString@@AA_K@Z+Fp ...
UNDEF:000041E4 ; __fastcall _RTC_CheckStackVars(x, x)
UNDEF:000041E4                 extrn @_RTC_CheckStackVars@8:near
UNDEF:000041E4                                         ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+DCAp
UNDEF:000041E4                                         ; DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+9C9p
UNDEF:000041E8 ; __stdcall _CxxThrowException(x, x)
UNDEF:000041E8                 extrn __CxxThrowException@8:near
UNDEF:000041E8                                         ; CODE XREF: Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+10Fp
UNDEF:000041E8                                         ; Extract(CCodecs *,CObjectVector<COpenType> const &,CRecordVector<int> const &,CObjectVector<UString> &,CObjectVector<UString> &,NWildcard::CCensorNode const &,CExtractOptions const &,IOpenCallbackUI *,IExtractCallbackUI *,IHashCalc *,UString &,CDecompressStat &)+139p ...
UNDEF:000041EC ; const type_info::`vftable'
UNDEF:000041EC                 extrn ??_7type_info@@6B@:near
UNDEF:000041EC                                         ; DATA XREF: .data:char * `RTTI Type Descriptor'o
UNDEF:000041EC                                         ; .data:void * `RTTI Type Descriptor'o ...
UNDEF:000041F0 ; public: __thiscall UString::UString(void)
UNDEF:000041F0                 extrn ??0UString@@QAE@XZ:near
UNDEF:000041F0                                         ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+177p
UNDEF:000041F0                                         ; DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+1B4p ...
UNDEF:000041F4 ; void __thiscall NWindows::NFile::NFind::CFileInfoBase::ClearBase(NWindows::NFile::NFind::CFileInfoBase *__hidden this)
UNDEF:000041F4                 extrn ?ClearBase@CFileInfoBase@NFind@NFile@NWindows@@QAEXXZ:near
UNDEF:000041F4                                         ; CODE XREF: NWindows::NFile::NFind::CFileInfoBase::CFileInfoBase(void)+11p
UNDEF:000041F8 ; void __thiscall CArchiveLink::Release(CArchiveLink *__hidden this)
UNDEF:000041F8                 extrn ?Release@CArchiveLink@@QAEXXZ:near
UNDEF:000041F8                                         ; CODE XREF: CArchiveLink::~CArchiveLink(void)+37p
UNDEF:000041FC ; public: virtual long __stdcall COutStreamWithHash::Write(void const *, unsigned int, unsigned int *)
UNDEF:000041FC                 extrn ?Write@COutStreamWithHash@@UAGJPBXIPAI@Z:near
UNDEF:000041FC                                         ; DATA XREF: .rdata:00002634o
UNDEF:00004200                 extrn __purecall:near   ; DATA XREF: .rdata:const ISequentialOutStream::`vftable'o
UNDEF:00004200                                         ; .rdata:0000281Co ...
UNDEF:00004204 ; const IID IID_IUnknown
UNDEF:00004204                 extrn _IID_IUnknown:near
UNDEF:00004204                                         ; DATA XREF: COutStreamWithHash::QueryInterface(_GUID const &,void * *)+Co
UNDEF:00004208 ; int __cdecl memcmp(const void *Buf1, const void *Buf2, size_t Size)
UNDEF:00004208                 extrn _memcmp:near      ; CODE XREF: IsEqualGUID(x,x)+Dp
UNDEF:0000420C ; __int32 __thiscall CArchiveExtractCallback::SetDirsTimes(CArchiveExtractCallback *__hidden this)
UNDEF:0000420C                 extrn ?SetDirsTimes@CArchiveExtractCallback@@QAEJXZ:near
UNDEF:0000420C                                         ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+93Dp
UNDEF:00004210 ; public: long __thiscall CArchiveExtractCallback::PrepareHardLinks(class CRecordVector<unsigned int> const *)
UNDEF:00004210                 extrn ?PrepareHardLinks@CArchiveExtractCallback@@QAEJPBV?$CRecordVector@I@@@Z:near
UNDEF:00004210                                         ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+7AFp
UNDEF:00004214 ; public: void __thiscall CArchiveExtractCallback::Init(struct CExtractNtOptions const &, class NWildcard::CCensorNode const *, class CArc const *, struct IFolderArchiveExtractCallback *, bool, bool, class UString const &, class CObjectVector<class UString> const &, bool, unsigned __int64)
UNDEF:00004214                 extrn ?Init@CArchiveExtractCallback@@QAEXABUCExtractNtOptions@@PBVCCensorNode@NWildcard@@PBVCArc@@PAUIFolderArchiveExtractCallback@@_N4ABVUString@@ABV?$CObjectVector@VUString@@@@4_K@Z:near
UNDEF:00004214                                         ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+776p
UNDEF:00004218 ; public: class UString & __thiscall UString::operator+=(class UString const &)
UNDEF:00004218                 extrn ??YUString@@QAEAAV0@ABV0@@Z:near
UNDEF:00004218                                         ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+6C9p
UNDEF:0000421C ; void __thiscall UString::SetFromAscii(UString *__hidden this, const char *)
UNDEF:0000421C                 extrn ?SetFromAscii@UString@@QAEXPBD@Z:near
UNDEF:0000421C                                         ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+6BDp
UNDEF:00004220 ; DWORD __stdcall GetLastError()
UNDEF:00004220                 extrn __imp__GetLastError@0:near
UNDEF:00004220                                         ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+68Fp
UNDEF:00004220                                         ; DATA XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+68Fr
UNDEF:00004224 ; bool NWindows::NFile::NDir::CreateComplexDir(NWindows::NFile::NDir *__hidden this, const wchar_t *)
UNDEF:00004224                 extrn ?CreateComplexDir@NDir@NFile@NWindows@@YG_NPB_W@Z:near
UNDEF:00004224                                         ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+67Dp
UNDEF:00004228 ; public: class UString & __thiscall UString::operator=(wchar_t const *)
UNDEF:00004228                 extrn ??4UString@@QAEAAV0@PB_W@Z:near
UNDEF:00004228                                         ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+66Ap
UNDEF:0000422C ; bool __stdcall CensorNode_CheckPath(const struct NWildcard::CCensorNode *, const struct CReadArcItem *)
UNDEF:0000422C                 extrn ?CensorNode_CheckPath@@YG_NABVCCensorNode@NWildcard@@ABUCReadArcItem@@@Z:near
UNDEF:0000422C                                         ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+55Fp
UNDEF:00004230 ; bool __stdcall IsPath1PrefixedByPath2(const wchar_t *, const wchar_t *)
UNDEF:00004230                 extrn ?IsPath1PrefixedByPath2@@YG_NPB_W0@Z:near
UNDEF:00004230                                         ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+4E3p
UNDEF:00004234 ; __int32 __stdcall Archive_IsItem_AltStream(struct IInArchive *, unsigned int, bool *)
UNDEF:00004234                 extrn ?Archive_IsItem_AltStream@@YGJPAUIInArchive@@IAA_N@Z:near
UNDEF:00004234                                         ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+413p
UNDEF:00004238 ; __int32 __thiscall CArc::GetItem(CArc *__hidden this, unsigned int, struct CReadArcItem *)
UNDEF:00004238                 extrn ?GetItem@CArc@@QBEJIAAUCReadArcItem@@@Z:near
UNDEF:00004238                                         ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+347p
UNDEF:0000423C ; bool __thiscall NWildcard::CCensorNode::AreAllAllowed(NWildcard::CCensorNode *__hidden this)
UNDEF:0000423C                 extrn ?AreAllAllowed@CCensorNode@NWildcard@@QBE_NXZ:near
UNDEF:0000423C                                         ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+237p
UNDEF:00004240 ; void __stdcall SplitPathToParts_Smart(const struct UString *, struct UString *, struct UString *)
UNDEF:00004240                 extrn ?SplitPathToParts_Smart@@YGXABVUString@@AAV1@1@Z:near
UNDEF:00004240                                         ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+1CCp
UNDEF:00004244 ; void __thiscall UString::Replace(UString *__hidden this, const struct UString *, const struct UString *)
UNDEF:00004244                 extrn ?Replace@UString@@QAEXABV1@0@Z:near
UNDEF:00004244                                         ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+14Dp
UNDEF:00004248 ; struct UString __stdcall __high Get_Correct_FsFile_Name(const struct UString *)
UNDEF:00004248                 extrn ?Get_Correct_FsFile_Name@@YG?AVUString@@ABV1@@Z:near
UNDEF:00004248                                         ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+121p
UNDEF:0000424C ; public: __thiscall UString::UString(wchar_t const *)
UNDEF:0000424C                 extrn ??0UString@@QAE@PB_W@Z:near
UNDEF:0000424C                                         ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+10Dp
UNDEF:00004250 ; bool __stdcall StringsAreEqualNoCase_Ascii(const wchar_t *, const char *)
UNDEF:00004250                 extrn ?StringsAreEqualNoCase_Ascii@@YG_NPB_WPBD@Z:near
UNDEF:00004250                                         ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+E5p
UNDEF:00004254 ; public: __thiscall UString::UString(class UString const &)
UNDEF:00004254                 extrn ??0UString@@QAE@ABV0@@Z:near
UNDEF:00004254                                         ; CODE XREF: DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+87p
UNDEF:00004254                                         ; DecompressArchive(CCodecs *,CArchiveLink const &,unsigned __int64,NWildcard::CCensorNode const &,CExtractOptions const &,bool,IExtractCallbackUI *,CArchiveExtractCallback *,UString &,unsigned __int64 &)+9Dp ...
UNDEF:00004258 ; __int32 __thiscall NWindows::NCOM::CPropVariant::Clear(NWindows::NCOM::CPropVariant *__hidden this)
UNDEF:00004258                 extrn ?Clear@CPropVariant@NCOM@NWindows@@QAEJXZ:near
UNDEF:00004258                                         ; CODE XREF: NWindows::NCOM::CPropVariant::~CPropVariant(void)+11p
UNDEF:0000425C ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:0000425C                 extrn _memcpy:near      ; CODE XREF: CRecordVector<unsigned __int64>::ReserveOnePosition(void)+87p
UNDEF:0000425C                                         ; CRecordVector<uint>::ReserveOnePosition(void)+87p ...
UNDEF:0000425C
UNDEF:0000425C
UNDEF:0000425C                 end