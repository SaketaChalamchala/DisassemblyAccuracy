.text:00000000 ;
.text:00000000 ; +-------------------------------------------------------------------------+
.text:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.text:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.text:00000000 ; |                      License info: 48-3677-7074-51                      |
.text:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.text:00000000 ; +-------------------------------------------------------------------------+
.text:00000000 ;
.text:00000000 ; Input MD5   : BD20E5E6BCC9267953B427D539071403
.text:00000000 ; Input CRC32 : 5F03B8F9
.text:00000000
.text:00000000 ; File Name   : C:\workspace\7z1505-src\CPP\7zip\Bundles\Alone\Debug\MemBlocks.obj
.text:00000000 ; Format      : COFF (X386MAGIC)
.text:00000000 ; includelib "uuid.lib"
.text:00000000 ; includelib "MSVCRTD"
.text:00000000 ; includelib "OLDNAMES"
.text:00000000
.text:00000000                 .686p
.text:00000000                 .mmx
.text:00000000                 .model flat
.text:00000000
.text:00000000 ; ===========================================================================
.text:00000000
.text:00000000 ; Segment type: Pure code
.text:00000000 ; Segment permissions: Read/Execute
.text:00000000 _text           segment para public 'CODE' use32
.text:00000000                 assume cs:_text
.text:00000000                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000000
.text:00000000 ; =============== S U B R O U T I N E =======================================
.text:00000000
.text:00000000 ; Attributes: bp-based frame
.text:00000000
.text:00000000 ; bool __thiscall CMemBlockManager::AllocateSpace(CMemBlockManager *this, unsigned int)
.text:00000000                 public ?AllocateSpace@CMemBlockManager@@QAE_NI@Z
.text:00000000 ?AllocateSpace@CMemBlockManager@@QAE_NI@Z proc near
.text:00000000                                         ; CODE XREF: CMemBlockManagerMt::AllocateSpace(uint,uint)+2Dp
.text:00000000
.text:00000000 var_10          = dword ptr -10h
.text:00000000 var_C           = dword ptr -0Ch
.text:00000000 var_8           = dword ptr -8
.text:00000000 var_4           = dword ptr -4
.text:00000000 arg_0           = dword ptr  8
.text:00000000
.text:00000000                 push    ebp
.text:00000001                 mov     ebp, esp
.text:00000003                 sub     esp, 10h
.text:00000006                 mov     eax, 0CCCCCCCCh
.text:0000000B                 mov     [ebp+var_10], eax
.text:0000000E                 mov     [ebp+var_C], eax
.text:00000011                 mov     [ebp+var_8], eax
.text:00000014                 mov     [ebp+var_4], eax
.text:00000017                 mov     [ebp+var_4], ecx
.text:0000001A                 mov     ecx, [ebp+var_4] ; this
.text:0000001D                 call    ?FreeSpace@CMemBlockManager@@QAEXXZ ; CMemBlockManager::FreeSpace(void)
.text:00000022                 mov     eax, [ebp+var_4]
.text:00000025                 cmp     dword ptr [eax+4], 4
.text:00000029                 jb      short loc_31
.text:0000002B                 cmp     [ebp+arg_0], 1
.text:0000002F                 jnb     short loc_38
.text:00000031
.text:00000031 loc_31:                                 ; CODE XREF: CMemBlockManager::AllocateSpace(uint)+29j
.text:00000031                 xor     al, al
.text:00000033                 jmp     loc_CA
.text:00000038 ; ---------------------------------------------------------------------------
.text:00000038
.text:00000038 loc_38:                                 ; CODE XREF: CMemBlockManager::AllocateSpace(uint)+2Fj
.text:00000038                 mov     ecx, [ebp+var_4]
.text:0000003B                 mov     edx, [ebp+arg_0]
.text:0000003E                 imul    edx, [ecx+4]
.text:00000042                 mov     [ebp+var_8], edx
.text:00000045                 mov     ecx, [ebp+var_4]
.text:00000048                 mov     eax, [ebp+var_8]
.text:0000004B                 xor     edx, edx
.text:0000004D                 div     dword ptr [ecx+4]
.text:00000050                 cmp     eax, [ebp+arg_0]
.text:00000053                 jz      short loc_59
.text:00000055                 xor     al, al
.text:00000057                 jmp     short loc_CA
.text:00000059 ; ---------------------------------------------------------------------------
.text:00000059
.text:00000059 loc_59:                                 ; CODE XREF: CMemBlockManager::AllocateSpace(uint)+53j
.text:00000059                 mov     edx, [ebp+var_8]
.text:0000005C                 push    edx
.text:0000005D                 call    _MidAlloc@4     ; MidAlloc(x)
.text:00000062                 mov     ecx, [ebp+var_4]
.text:00000065                 mov     [ecx], eax
.text:00000067                 mov     edx, [ebp+var_4]
.text:0000006A                 cmp     dword ptr [edx], 0
.text:0000006D                 jnz     short loc_73
.text:0000006F                 xor     al, al
.text:00000071                 jmp     short loc_CA
.text:00000073 ; ---------------------------------------------------------------------------
.text:00000073
.text:00000073 loc_73:                                 ; CODE XREF: CMemBlockManager::AllocateSpace(uint)+6Dj
.text:00000073                 mov     eax, [ebp+var_4]
.text:00000076                 mov     ecx, [eax]
.text:00000078                 mov     [ebp+var_C], ecx
.text:0000007B                 mov     [ebp+var_10], 0
.text:00000082                 jmp     short loc_99
.text:00000084 ; ---------------------------------------------------------------------------
.text:00000084
.text:00000084 loc_84:                                 ; CODE XREF: CMemBlockManager::AllocateSpace(uint)+B2j
.text:00000084                 mov     edx, [ebp+var_10]
.text:00000087                 add     edx, 1
.text:0000008A                 mov     [ebp+var_10], edx
.text:0000008D                 mov     eax, [ebp+var_4]
.text:00000090                 mov     ecx, [ebp+var_C]
.text:00000093                 add     ecx, [eax+4]
.text:00000096                 mov     [ebp+var_C], ecx
.text:00000099
.text:00000099 loc_99:                                 ; CODE XREF: CMemBlockManager::AllocateSpace(uint)+82j
.text:00000099                 mov     edx, [ebp+var_10]
.text:0000009C                 add     edx, 1
.text:0000009F                 cmp     edx, [ebp+arg_0]
.text:000000A2                 jnb     short loc_B4
.text:000000A4                 mov     eax, [ebp+var_4]
.text:000000A7                 mov     ecx, [ebp+var_C]
.text:000000AA                 add     ecx, [eax+4]
.text:000000AD                 mov     edx, [ebp+var_C]
.text:000000B0                 mov     [edx], ecx
.text:000000B2                 jmp     short loc_84
.text:000000B4 ; ---------------------------------------------------------------------------
.text:000000B4
.text:000000B4 loc_B4:                                 ; CODE XREF: CMemBlockManager::AllocateSpace(uint)+A2j
.text:000000B4                 mov     eax, [ebp+var_C]
.text:000000B7                 mov     dword ptr [eax], 0
.text:000000BD                 mov     ecx, [ebp+var_4]
.text:000000C0                 mov     edx, [ebp+var_4]
.text:000000C3                 mov     eax, [edx]
.text:000000C5                 mov     [ecx+8], eax
.text:000000C8                 mov     al, 1
.text:000000CA
.text:000000CA loc_CA:                                 ; CODE XREF: CMemBlockManager::AllocateSpace(uint)+33j
.text:000000CA                                         ; CMemBlockManager::AllocateSpace(uint)+57j ...
.text:000000CA                 add     esp, 10h
.text:000000CD                 cmp     ebp, esp
.text:000000CF                 call    __RTC_CheckEsp
.text:000000D4                 mov     esp, ebp
.text:000000D6                 pop     ebp
.text:000000D7                 retn    4
.text:000000D7 ?AllocateSpace@CMemBlockManager@@QAE_NI@Z endp
.text:000000D7
.text:000000D7 ; ---------------------------------------------------------------------------
.text:000000DA                 align 10h
.text:000000E0
.text:000000E0 ; =============== S U B R O U T I N E =======================================
.text:000000E0
.text:000000E0 ; Attributes: bp-based frame
.text:000000E0
.text:000000E0 ; void __thiscall CMemBlockManager::FreeSpace(CMemBlockManager *__hidden this)
.text:000000E0                 public ?FreeSpace@CMemBlockManager@@QAEXXZ
.text:000000E0 ?FreeSpace@CMemBlockManager@@QAEXXZ proc near
.text:000000E0                                         ; CODE XREF: CMemBlockManager::AllocateSpace(uint)+1Dp
.text:000000E0                                         ; CMemBlockManagerMt::FreeSpace(void)+1Cp
.text:000000E0
.text:000000E0 var_4           = dword ptr -4
.text:000000E0
.text:000000E0                 push    ebp
.text:000000E1                 mov     ebp, esp
.text:000000E3                 push    ecx
.text:000000E4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000000EB                 mov     [ebp+var_4], ecx
.text:000000EE                 mov     eax, [ebp+var_4]
.text:000000F1                 mov     ecx, [eax]
.text:000000F3                 push    ecx
.text:000000F4                 call    _MidFree@4      ; MidFree(x)
.text:000000F9                 mov     edx, [ebp+var_4]
.text:000000FC                 mov     dword ptr [edx], 0
.text:00000102                 mov     eax, [ebp+var_4]
.text:00000105                 mov     dword ptr [eax+8], 0
.text:0000010C                 add     esp, 4
.text:0000010F                 cmp     ebp, esp
.text:00000111                 call    __RTC_CheckEsp
.text:00000116                 mov     esp, ebp
.text:00000118                 pop     ebp
.text:00000119                 retn
.text:00000119 ?FreeSpace@CMemBlockManager@@QAEXXZ endp
.text:00000119
.text:00000119 ; ---------------------------------------------------------------------------
.text:0000011A                 align 10h
.text:00000120
.text:00000120 ; =============== S U B R O U T I N E =======================================
.text:00000120
.text:00000120 ; Attributes: bp-based frame
.text:00000120
.text:00000120 ; void *__thiscall CMemBlockManager::AllocateBlock(CMemBlockManager *__hidden this)
.text:00000120                 public ?AllocateBlock@CMemBlockManager@@QAEPAXXZ
.text:00000120 ?AllocateBlock@CMemBlockManager@@QAEPAXXZ proc near
.text:00000120                                         ; CODE XREF: CMemBlockManagerMt::AllocateBlock(void)+55p
.text:00000120
.text:00000120 var_8           = dword ptr -8
.text:00000120 var_4           = dword ptr -4
.text:00000120
.text:00000120                 push    ebp
.text:00000121                 mov     ebp, esp
.text:00000123                 sub     esp, 8
.text:00000126                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000012D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000134                 mov     [ebp+var_4], ecx
.text:00000137                 mov     eax, [ebp+var_4]
.text:0000013A                 cmp     dword ptr [eax+8], 0
.text:0000013E                 jnz     short loc_144
.text:00000140                 xor     eax, eax
.text:00000142                 jmp     short loc_15E
.text:00000144 ; ---------------------------------------------------------------------------
.text:00000144
.text:00000144 loc_144:                                ; CODE XREF: CMemBlockManager::AllocateBlock(void)+1Ej
.text:00000144                 mov     ecx, [ebp+var_4]
.text:00000147                 mov     edx, [ecx+8]
.text:0000014A                 mov     [ebp+var_8], edx
.text:0000014D                 mov     eax, [ebp+var_4]
.text:00000150                 mov     ecx, [eax+8]
.text:00000153                 mov     edx, [ebp+var_4]
.text:00000156                 mov     eax, [ecx]
.text:00000158                 mov     [edx+8], eax
.text:0000015B                 mov     eax, [ebp+var_8]
.text:0000015E
.text:0000015E loc_15E:                                ; CODE XREF: CMemBlockManager::AllocateBlock(void)+22j
.text:0000015E                 mov     esp, ebp
.text:00000160                 pop     ebp
.text:00000161                 retn
.text:00000161 ?AllocateBlock@CMemBlockManager@@QAEPAXXZ endp
.text:00000161
.text:00000161 ; ---------------------------------------------------------------------------
.text:00000162                 align 10h
.text:00000170
.text:00000170 ; =============== S U B R O U T I N E =======================================
.text:00000170
.text:00000170 ; Attributes: bp-based frame
.text:00000170
.text:00000170 ; void __thiscall CMemBlockManager::FreeBlock(CMemBlockManager *this, void *)
.text:00000170                 public ?FreeBlock@CMemBlockManager@@QAEXPAX@Z
.text:00000170 ?FreeBlock@CMemBlockManager@@QAEXPAX@Z proc near
.text:00000170                                         ; CODE XREF: CMemBlockManagerMt::FreeBlock(void *,bool)+5Ep
.text:00000170
.text:00000170 var_4           = dword ptr -4
.text:00000170 arg_0           = dword ptr  8
.text:00000170
.text:00000170                 push    ebp
.text:00000171                 mov     ebp, esp
.text:00000173                 push    ecx
.text:00000174                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000017B                 mov     [ebp+var_4], ecx
.text:0000017E                 cmp     [ebp+arg_0], 0
.text:00000182                 jnz     short loc_186
.text:00000184                 jmp     short loc_19A
.text:00000186 ; ---------------------------------------------------------------------------
.text:00000186
.text:00000186 loc_186:                                ; CODE XREF: CMemBlockManager::FreeBlock(void *)+12j
.text:00000186                 mov     eax, [ebp+arg_0]
.text:00000189                 mov     ecx, [ebp+var_4]
.text:0000018C                 mov     edx, [ecx+8]
.text:0000018F                 mov     [eax], edx
.text:00000191                 mov     eax, [ebp+var_4]
.text:00000194                 mov     ecx, [ebp+arg_0]
.text:00000197                 mov     [eax+8], ecx
.text:0000019A
.text:0000019A loc_19A:                                ; CODE XREF: CMemBlockManager::FreeBlock(void *)+14j
.text:0000019A                 mov     esp, ebp
.text:0000019C                 pop     ebp
.text:0000019D                 retn    4
.text:0000019D ?FreeBlock@CMemBlockManager@@QAEXPAX@Z endp
.text:0000019D
.text:000001A0
.text:000001A0 ; =============== S U B R O U T I N E =======================================
.text:000001A0
.text:000001A0 ; Attributes: bp-based frame
.text:000001A0
.text:000001A0 ; int __thiscall CMemBlockManagerMt::AllocateSpace(CMemBlockManagerMt *this, unsigned int, unsigned int)
.text:000001A0                 public ?AllocateSpace@CMemBlockManagerMt@@QAEHII@Z
.text:000001A0 ?AllocateSpace@CMemBlockManagerMt@@QAEHII@Z proc near
.text:000001A0                                         ; CODE XREF: CMemBlockManagerMt::AllocateSpaceAlways(uint,uint)+28p
.text:000001A0
.text:000001A0 var_8           = dword ptr -8
.text:000001A0 var_4           = dword ptr -4
.text:000001A0 arg_0           = dword ptr  8
.text:000001A0 arg_4           = dword ptr  0Ch
.text:000001A0
.text:000001A0                 push    ebp
.text:000001A1                 mov     ebp, esp
.text:000001A3                 sub     esp, 8
.text:000001A6                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000001AD                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000001B4                 mov     [ebp+var_4], ecx
.text:000001B7                 mov     eax, [ebp+arg_4]
.text:000001BA                 cmp     eax, [ebp+arg_0]
.text:000001BD                 jbe     short loc_1C6
.text:000001BF                 mov     eax, 80070057h
.text:000001C4                 jmp     short loc_207
.text:000001C6 ; ---------------------------------------------------------------------------
.text:000001C6
.text:000001C6 loc_1C6:                                ; CODE XREF: CMemBlockManagerMt::AllocateSpace(uint,uint)+1Dj
.text:000001C6                 mov     ecx, [ebp+arg_0]
.text:000001C9                 push    ecx             ; unsigned int
.text:000001CA                 mov     ecx, [ebp+var_4] ; this
.text:000001CD                 call    ?AllocateSpace@CMemBlockManager@@QAE_NI@Z ; CMemBlockManager::AllocateSpace(uint)
.text:000001D2                 movzx   edx, al
.text:000001D5                 test    edx, edx
.text:000001D7                 jnz     short loc_1E0
.text:000001D9                 mov     eax, 8007000Eh
.text:000001DE                 jmp     short loc_207
.text:000001E0 ; ---------------------------------------------------------------------------
.text:000001E0
.text:000001E0 loc_1E0:                                ; CODE XREF: CMemBlockManagerMt::AllocateSpace(uint,uint)+37j
.text:000001E0                 mov     eax, [ebp+arg_0]
.text:000001E3                 sub     eax, [ebp+arg_4]
.text:000001E6                 mov     [ebp+var_8], eax
.text:000001E9                 mov     ecx, [ebp+var_4]
.text:000001EC                 add     ecx, 24h ; '$'  ; this
.text:000001EF                 call    ?Close@CSemaphore@NSynchronization@NWindows@@QAEIXZ ; NWindows::NSynchronization::CSemaphore::Close(void)
.text:000001F4                 mov     ecx, [ebp+var_8]
.text:000001F7                 push    ecx             ; unsigned int
.text:000001F8                 mov     edx, [ebp+var_8]
.text:000001FB                 push    edx             ; unsigned int
.text:000001FC                 mov     ecx, [ebp+var_4]
.text:000001FF                 add     ecx, 24h ; '$'  ; this
.text:00000202                 call    ?Create@CSemaphore@NSynchronization@NWindows@@QAEIII@Z ; NWindows::NSynchronization::CSemaphore::Create(uint,uint)
.text:00000207
.text:00000207 loc_207:                                ; CODE XREF: CMemBlockManagerMt::AllocateSpace(uint,uint)+24j
.text:00000207                                         ; CMemBlockManagerMt::AllocateSpace(uint,uint)+3Ej
.text:00000207                 add     esp, 8
.text:0000020A                 cmp     ebp, esp
.text:0000020C                 call    __RTC_CheckEsp
.text:00000211                 mov     esp, ebp
.text:00000213                 pop     ebp
.text:00000214                 retn    8
.text:00000214 ?AllocateSpace@CMemBlockManagerMt@@QAEHII@Z endp
.text:00000214
.text:00000214 ; ---------------------------------------------------------------------------
.text:00000217                 align 10h
.text:00000220
.text:00000220 ; =============== S U B R O U T I N E =======================================
.text:00000220
.text:00000220 ; Attributes: bp-based frame
.text:00000220
.text:00000220 ; int __thiscall CMemBlockManagerMt::AllocateSpaceAlways(CMemBlockManagerMt *this, unsigned int, unsigned int)
.text:00000220                 public ?AllocateSpaceAlways@CMemBlockManagerMt@@QAEHII@Z
.text:00000220 ?AllocateSpaceAlways@CMemBlockManagerMt@@QAEHII@Z proc near
.text:00000220
.text:00000220 var_4           = dword ptr -4
.text:00000220 arg_0           = dword ptr  8
.text:00000220 arg_4           = dword ptr  0Ch
.text:00000220
.text:00000220                 push    ebp
.text:00000221                 mov     ebp, esp
.text:00000223                 push    ecx
.text:00000224                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000022B                 mov     [ebp+var_4], ecx
.text:0000022E                 mov     eax, [ebp+arg_4]
.text:00000231                 cmp     eax, [ebp+arg_0]
.text:00000234                 jbe     short loc_23D
.text:00000236                 mov     eax, 80070057h
.text:0000023B                 jmp     short loc_274
.text:0000023D ; ---------------------------------------------------------------------------
.text:0000023D
.text:0000023D loc_23D:                                ; CODE XREF: CMemBlockManagerMt::AllocateSpaceAlways(uint,uint)+14j
.text:0000023D                                         ; CMemBlockManagerMt::AllocateSpaceAlways(uint,uint)+52j
.text:0000023D                 mov     ecx, [ebp+arg_4]
.text:00000240                 push    ecx             ; unsigned int
.text:00000241                 mov     edx, [ebp+arg_0]
.text:00000244                 push    edx             ; unsigned int
.text:00000245                 mov     ecx, [ebp+var_4] ; this
.text:00000248                 call    ?AllocateSpace@CMemBlockManagerMt@@QAEHII@Z ; CMemBlockManagerMt::AllocateSpace(uint,uint)
.text:0000024D                 test    eax, eax
.text:0000024F                 jnz     short loc_255
.text:00000251                 xor     eax, eax
.text:00000253                 jmp     short loc_274
.text:00000255 ; ---------------------------------------------------------------------------
.text:00000255
.text:00000255 loc_255:                                ; CODE XREF: CMemBlockManagerMt::AllocateSpaceAlways(uint,uint)+2Fj
.text:00000255                 mov     eax, [ebp+arg_0]
.text:00000258                 cmp     eax, [ebp+arg_4]
.text:0000025B                 jnz     short loc_264
.text:0000025D                 mov     eax, 8007000Eh
.text:00000262                 jmp     short loc_274
.text:00000264 ; ---------------------------------------------------------------------------
.text:00000264
.text:00000264 loc_264:                                ; CODE XREF: CMemBlockManagerMt::AllocateSpaceAlways(uint,uint)+3Bj
.text:00000264                 mov     ecx, [ebp+arg_0]
.text:00000267                 sub     ecx, [ebp+arg_4]
.text:0000026A                 shr     ecx, 1
.text:0000026C                 add     ecx, [ebp+arg_4]
.text:0000026F                 mov     [ebp+arg_0], ecx
.text:00000272                 jmp     short loc_23D
.text:00000274 ; ---------------------------------------------------------------------------
.text:00000274
.text:00000274 loc_274:                                ; CODE XREF: CMemBlockManagerMt::AllocateSpaceAlways(uint,uint)+1Bj
.text:00000274                                         ; CMemBlockManagerMt::AllocateSpaceAlways(uint,uint)+33j ...
.text:00000274                 add     esp, 4
.text:00000277                 cmp     ebp, esp
.text:00000279                 call    __RTC_CheckEsp
.text:0000027E                 mov     esp, ebp
.text:00000280                 pop     ebp
.text:00000281                 retn    8
.text:00000281 ?AllocateSpaceAlways@CMemBlockManagerMt@@QAEHII@Z endp
.text:00000281
.text:00000281 ; ---------------------------------------------------------------------------
.text:00000284                 align 10h
.text:00000290
.text:00000290 ; =============== S U B R O U T I N E =======================================
.text:00000290
.text:00000290 ; Attributes: bp-based frame
.text:00000290
.text:00000290 ; void __thiscall CMemBlockManagerMt::FreeSpace(CMemBlockManagerMt *__hidden this)
.text:00000290                 public ?FreeSpace@CMemBlockManagerMt@@QAEXXZ
.text:00000290 ?FreeSpace@CMemBlockManagerMt@@QAEXXZ proc near
.text:00000290
.text:00000290 var_4           = dword ptr -4
.text:00000290
.text:00000290                 push    ebp
.text:00000291                 mov     ebp, esp
.text:00000293                 push    ecx
.text:00000294                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000029B                 mov     [ebp+var_4], ecx
.text:0000029E                 mov     ecx, [ebp+var_4]
.text:000002A1                 add     ecx, 24h ; '$'  ; this
.text:000002A4                 call    ?Close@CSemaphore@NSynchronization@NWindows@@QAEIXZ ; NWindows::NSynchronization::CSemaphore::Close(void)
.text:000002A9                 mov     ecx, [ebp+var_4] ; this
.text:000002AC                 call    ?FreeSpace@CMemBlockManager@@QAEXXZ ; CMemBlockManager::FreeSpace(void)
.text:000002B1                 add     esp, 4
.text:000002B4                 cmp     ebp, esp
.text:000002B6                 call    __RTC_CheckEsp
.text:000002BB                 mov     esp, ebp
.text:000002BD                 pop     ebp
.text:000002BE                 retn
.text:000002BE ?FreeSpace@CMemBlockManagerMt@@QAEXXZ endp
.text:000002BE
.text:000002BE ; ---------------------------------------------------------------------------
.text:000002BF                 align 10h
.text:000002C0
.text:000002C0 ; =============== S U B R O U T I N E =======================================
.text:000002C0
.text:000002C0 ; Attributes: bp-based frame
.text:000002C0
.text:000002C0 ; void *__thiscall CMemBlockManagerMt::AllocateBlock(CMemBlockManagerMt *__hidden this)
.text:000002C0                 public ?AllocateBlock@CMemBlockManagerMt@@QAEPAXXZ
.text:000002C0 ?AllocateBlock@CMemBlockManagerMt@@QAEPAXXZ proc near
.text:000002C0
.text:000002C0 var_20          = dword ptr -20h
.text:000002C0 var_1C          = dword ptr -1Ch
.text:000002C0 var_18          = dword ptr -18h
.text:000002C0 var_14          = dword ptr -14h
.text:000002C0 var_10          = dword ptr -10h
.text:000002C0 var_C           = dword ptr -0Ch
.text:000002C0 var_4           = dword ptr -4
.text:000002C0
.text:000002C0                 push    ebp
.text:000002C1                 mov     ebp, esp
.text:000002C3                 push    0FFFFFFFFh
.text:000002C5                 push    offset __ehhandler$?AllocateBlock@CMemBlockManagerMt@@QAEPAXXZ
.text:000002CA                 mov     eax, large fs:0
.text:000002D0                 push    eax
.text:000002D1                 sub     esp, 14h
.text:000002D4                 mov     eax, 0CCCCCCCCh
.text:000002D9                 mov     [ebp+var_20], eax
.text:000002DC                 mov     [ebp+var_1C], eax
.text:000002DF                 mov     [ebp+var_18], eax
.text:000002E2                 mov     [ebp+var_14], eax
.text:000002E5                 mov     [ebp+var_10], eax
.text:000002E8                 mov     eax, dword ptr ds:___security_cookie
.text:000002ED                 xor     eax, ebp
.text:000002EF                 push    eax
.text:000002F0                 lea     eax, [ebp+var_C]
.text:000002F3                 mov     large fs:0, eax
.text:000002F9                 mov     [ebp+var_10], ecx
.text:000002FC                 mov     eax, [ebp+var_10]
.text:000002FF                 add     eax, 0Ch
.text:00000302                 push    eax             ; struct NWindows::NSynchronization::CCriticalSection *
.text:00000303                 lea     ecx, [ebp+var_18] ; this
.text:00000306                 call    ??0CCriticalSectionLock@NSynchronization@NWindows@@QAE@AAVCCriticalSection@12@@Z ; NWindows::NSynchronization::CCriticalSectionLock::CCriticalSectionLock(NWindows::NSynchronization::CCriticalSection &)
.text:0000030B                 mov     [ebp+var_4], 0
.text:00000312                 mov     ecx, [ebp+var_10] ; this
.text:00000315                 call    ?AllocateBlock@CMemBlockManager@@QAEPAXXZ ; CMemBlockManager::AllocateBlock(void)
.text:0000031A                 mov     [ebp+var_20], eax
.text:0000031D                 mov     [ebp+var_4], 0FFFFFFFFh
.text:00000324                 lea     ecx, [ebp+var_18] ; this
.text:00000327                 call    ??1CCriticalSectionLock@NSynchronization@NWindows@@QAE@XZ ; NWindows::NSynchronization::CCriticalSectionLock::~CCriticalSectionLock(void)
.text:0000032C                 mov     eax, [ebp+var_20]
.text:0000032F                 push    edx
.text:00000330                 mov     ecx, ebp
.text:00000332                 push    eax
.text:00000333                 lea     edx, $LN7
.text:00000339                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:0000033E                 pop     eax
.text:0000033F                 pop     edx
.text:00000340                 mov     ecx, [ebp+var_C]
.text:00000343                 mov     large fs:0, ecx
.text:0000034A                 pop     ecx
.text:0000034B                 add     esp, 20h
.text:0000034E                 cmp     ebp, esp
.text:00000350                 call    __RTC_CheckEsp
.text:00000355                 mov     esp, ebp
.text:00000357                 pop     ebp
.text:00000358                 retn
.text:00000358 ?AllocateBlock@CMemBlockManagerMt@@QAEPAXXZ endp
.text:00000358
.text:00000358 ; ---------------------------------------------------------------------------
.text:00000359                 align 4
.text:0000035C $LN7            dd 1                    ; DATA XREF: CMemBlockManagerMt::AllocateBlock(void)+73o
.text:00000360                 dd offset $LN6
.text:00000364 $LN6            dd 0FFFFFFE8h, 4        ; DATA XREF: .text:00000360o
.text:0000036C                 dd offset $LN4          ; "lock"
.text:00000370 $LN4            db 'lock',0             ; DATA XREF: .text:0000036Co
.text:00000375                 align 10h
.text:00000380
.text:00000380 ; =============== S U B R O U T I N E =======================================
.text:00000380
.text:00000380 ; Attributes: bp-based frame
.text:00000380
.text:00000380 ; void __thiscall CMemBlockManagerMt::FreeBlock(CMemBlockManagerMt *this, void *, bool)
.text:00000380                 public ?FreeBlock@CMemBlockManagerMt@@QAEXPAX_N@Z
.text:00000380 ?FreeBlock@CMemBlockManagerMt@@QAEXPAX_N@Z proc near
.text:00000380                                         ; CODE XREF: CMemBlocks::Free(CMemBlockManagerMt *)+2Ap
.text:00000380                                         ; CMemLockBlocks::FreeBlock(int,CMemBlockManagerMt *)+28p
.text:00000380
.text:00000380 var_1C          = dword ptr -1Ch
.text:00000380 var_18          = dword ptr -18h
.text:00000380 var_14          = dword ptr -14h
.text:00000380 var_10          = dword ptr -10h
.text:00000380 var_C           = dword ptr -0Ch
.text:00000380 var_4           = dword ptr -4
.text:00000380 arg_0           = dword ptr  8
.text:00000380 arg_4           = byte ptr  0Ch
.text:00000380
.text:00000380                 push    ebp
.text:00000381                 mov     ebp, esp
.text:00000383                 push    0FFFFFFFFh
.text:00000385                 push    offset __ehhandler$?FreeBlock@CMemBlockManagerMt@@QAEXPAX_N@Z
.text:0000038A                 mov     eax, large fs:0
.text:00000390                 push    eax
.text:00000391                 sub     esp, 10h
.text:00000394                 mov     eax, 0CCCCCCCCh
.text:00000399                 mov     [ebp+var_1C], eax
.text:0000039C                 mov     [ebp+var_18], eax
.text:0000039F                 mov     [ebp+var_14], eax
.text:000003A2                 mov     [ebp+var_10], eax
.text:000003A5                 mov     eax, dword ptr ds:___security_cookie
.text:000003AA                 xor     eax, ebp
.text:000003AC                 push    eax
.text:000003AD                 lea     eax, [ebp+var_C]
.text:000003B0                 mov     large fs:0, eax
.text:000003B6                 mov     [ebp+var_10], ecx
.text:000003B9                 cmp     [ebp+arg_0], 0
.text:000003BD                 jnz     short loc_3C1
.text:000003BF                 jmp     short loc_405
.text:000003C1 ; ---------------------------------------------------------------------------
.text:000003C1
.text:000003C1 loc_3C1:                                ; CODE XREF: CMemBlockManagerMt::FreeBlock(void *,bool)+3Dj
.text:000003C1                 mov     eax, [ebp+var_10]
.text:000003C4                 add     eax, 0Ch
.text:000003C7                 push    eax             ; struct NWindows::NSynchronization::CCriticalSection *
.text:000003C8                 lea     ecx, [ebp+var_18] ; this
.text:000003CB                 call    ??0CCriticalSectionLock@NSynchronization@NWindows@@QAE@AAVCCriticalSection@12@@Z ; NWindows::NSynchronization::CCriticalSectionLock::CCriticalSectionLock(NWindows::NSynchronization::CCriticalSection &)
.text:000003D0                 mov     [ebp+var_4], 0
.text:000003D7                 mov     ecx, [ebp+arg_0]
.text:000003DA                 push    ecx             ; void *
.text:000003DB                 mov     ecx, [ebp+var_10] ; this
.text:000003DE                 call    ?FreeBlock@CMemBlockManager@@QAEXPAX@Z ; CMemBlockManager::FreeBlock(void *)
.text:000003E3                 mov     [ebp+var_4], 0FFFFFFFFh
.text:000003EA                 lea     ecx, [ebp+var_18] ; this
.text:000003ED                 call    ??1CCriticalSectionLock@NSynchronization@NWindows@@QAE@XZ ; NWindows::NSynchronization::CCriticalSectionLock::~CCriticalSectionLock(void)
.text:000003F2                 movzx   edx, [ebp+arg_4]
.text:000003F6                 test    edx, edx
.text:000003F8                 jz      short loc_405
.text:000003FA                 mov     ecx, [ebp+var_10]
.text:000003FD                 add     ecx, 24h ; '$'  ; this
.text:00000400                 call    ?Release@CSemaphore@NSynchronization@NWindows@@QAEIXZ ; NWindows::NSynchronization::CSemaphore::Release(void)
.text:00000405
.text:00000405 loc_405:                                ; CODE XREF: CMemBlockManagerMt::FreeBlock(void *,bool)+3Fj
.text:00000405                                         ; CMemBlockManagerMt::FreeBlock(void *,bool)+78j
.text:00000405                 push    edx
.text:00000406                 mov     ecx, ebp
.text:00000408                 push    eax
.text:00000409                 lea     edx, $LN9
.text:0000040F                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00000414                 pop     eax
.text:00000415                 pop     edx
.text:00000416                 mov     ecx, [ebp+var_C]
.text:00000419                 mov     large fs:0, ecx
.text:00000420                 pop     ecx
.text:00000421                 add     esp, 1Ch
.text:00000424                 cmp     ebp, esp
.text:00000426                 call    __RTC_CheckEsp
.text:0000042B                 mov     esp, ebp
.text:0000042D                 pop     ebp
.text:0000042E                 retn    8
.text:0000042E ?FreeBlock@CMemBlockManagerMt@@QAEXPAX_N@Z endp
.text:0000042E
.text:0000042E ; ---------------------------------------------------------------------------
.text:00000431                 align 4
.text:00000434 $LN9            dd 1                    ; DATA XREF: CMemBlockManagerMt::FreeBlock(void *,bool)+89o
.text:00000438                 dd offset $LN8
.text:0000043C $LN8            dd 0FFFFFFE8h, 4        ; DATA XREF: .text:00000438o
.text:00000444                 dd offset $LN6_0        ; "lock"
.text:00000448 $LN6_0          db 'lock',0             ; DATA XREF: .text:00000444o
.text:0000044D                 align 10h
.text:00000450
.text:00000450 ; =============== S U B R O U T I N E =======================================
.text:00000450
.text:00000450 ; Attributes: bp-based frame
.text:00000450
.text:00000450 ; void __thiscall CMemBlocks::Free(CMemBlocks *this, struct CMemBlockManagerMt *)
.text:00000450                 public ?Free@CMemBlocks@@AAEXPAVCMemBlockManagerMt@@@Z
.text:00000450 ?Free@CMemBlocks@@AAEXPAVCMemBlockManagerMt@@@Z proc near
.text:00000450                                         ; CODE XREF: CMemBlocks::FreeOpt(CMemBlockManagerMt *)+15p
.text:00000450
.text:00000450 var_4           = dword ptr -4
.text:00000450 arg_0           = dword ptr  8
.text:00000450
.text:00000450                 push    ebp
.text:00000451                 mov     ebp, esp
.text:00000453                 push    ecx
.text:00000454                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000045B                 mov     [ebp+var_4], ecx
.text:0000045E
.text:0000045E loc_45E:                                ; CODE XREF: CMemBlocks::Free(CMemBlockManagerMt *)+37j
.text:0000045E                 mov     ecx, [ebp+var_4]
.text:00000461                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00000466                 test    eax, eax
.text:00000468                 jbe     short loc_489
.text:0000046A                 push    1               ; bool
.text:0000046C                 mov     ecx, [ebp+var_4]
.text:0000046F                 call    ?Back@?$CRecordVector@PAX@@QAEAAPAXXZ ; CRecordVector<void *>::Back(void)
.text:00000474                 mov     eax, [eax]
.text:00000476                 push    eax             ; void *
.text:00000477                 mov     ecx, [ebp+arg_0] ; this
.text:0000047A                 call    ?FreeBlock@CMemBlockManagerMt@@QAEXPAX_N@Z ; CMemBlockManagerMt::FreeBlock(void *,bool)
.text:0000047F                 mov     ecx, [ebp+var_4]
.text:00000482                 call    ?DeleteBack@?$CRecordVector@PAX@@QAEXXZ ; CRecordVector<void *>::DeleteBack(void)
.text:00000487                 jmp     short loc_45E
.text:00000489 ; ---------------------------------------------------------------------------
.text:00000489
.text:00000489 loc_489:                                ; CODE XREF: CMemBlocks::Free(CMemBlockManagerMt *)+18j
.text:00000489                 mov     ecx, [ebp+var_4]
.text:0000048C                 mov     dword ptr [ecx+10h], 0
.text:00000493                 mov     dword ptr [ecx+14h], 0
.text:0000049A                 add     esp, 4
.text:0000049D                 cmp     ebp, esp
.text:0000049F                 call    __RTC_CheckEsp
.text:000004A4                 mov     esp, ebp
.text:000004A6                 pop     ebp
.text:000004A7                 retn    4
.text:000004A7 ?Free@CMemBlocks@@AAEXPAVCMemBlockManagerMt@@@Z endp
.text:000004A7
.text:000004A7 ; ---------------------------------------------------------------------------
.text:000004AA                 align 10h
.text:000004B0
.text:000004B0 ; =============== S U B R O U T I N E =======================================
.text:000004B0
.text:000004B0 ; Attributes: bp-based frame
.text:000004B0
.text:000004B0 ; void __thiscall CMemBlocks::FreeOpt(CMemBlocks *this, struct CMemBlockManagerMt *)
.text:000004B0                 public ?FreeOpt@CMemBlocks@@QAEXPAVCMemBlockManagerMt@@@Z
.text:000004B0 ?FreeOpt@CMemBlocks@@QAEXPAVCMemBlockManagerMt@@@Z proc near
.text:000004B0
.text:000004B0 var_4           = dword ptr -4
.text:000004B0 arg_0           = dword ptr  8
.text:000004B0
.text:000004B0                 push    ebp
.text:000004B1                 mov     ebp, esp
.text:000004B3                 push    ecx
.text:000004B4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000004BB                 mov     [ebp+var_4], ecx
.text:000004BE                 mov     eax, [ebp+arg_0]
.text:000004C1                 push    eax             ; struct CMemBlockManagerMt *
.text:000004C2                 mov     ecx, [ebp+var_4] ; this
.text:000004C5                 call    ?Free@CMemBlocks@@AAEXPAVCMemBlockManagerMt@@@Z ; CMemBlocks::Free(CMemBlockManagerMt *)
.text:000004CA                 mov     ecx, [ebp+var_4]
.text:000004CD                 call    ?ClearAndFree@?$CRecordVector@PAX@@QAEXXZ ; CRecordVector<void *>::ClearAndFree(void)
.text:000004D2                 add     esp, 4
.text:000004D5                 cmp     ebp, esp
.text:000004D7                 call    __RTC_CheckEsp
.text:000004DC                 mov     esp, ebp
.text:000004DE                 pop     ebp
.text:000004DF                 retn    4
.text:000004DF ?FreeOpt@CMemBlocks@@QAEXPAVCMemBlockManagerMt@@@Z endp
.text:000004DF
.text:000004DF ; ---------------------------------------------------------------------------
.text:000004E2                 align 10h
.text:000004F0
.text:000004F0 ; =============== S U B R O U T I N E =======================================
.text:000004F0
.text:000004F0 ; Attributes: bp-based frame
.text:000004F0
.text:000004F0 ; __int32 __thiscall CMemBlocks::WriteToStream(CMemBlocks *this, unsigned int, struct ISequentialOutStream *)
.text:000004F0                 public ?WriteToStream@CMemBlocks@@QBEJIPAUISequentialOutStream@@@Z
.text:000004F0 ?WriteToStream@CMemBlocks@@QBEJIPAUISequentialOutStream@@@Z proc near
.text:000004F0
.text:000004F0 var_20          = dword ptr -20h
.text:000004F0 var_1C          = dword ptr -1Ch
.text:000004F0 var_18          = dword ptr -18h
.text:000004F0 var_14          = dword ptr -14h
.text:000004F0 var_10          = dword ptr -10h
.text:000004F0 var_C           = dword ptr -0Ch
.text:000004F0 var_8           = dword ptr -8
.text:000004F0 var_4           = dword ptr -4
.text:000004F0 arg_0           = dword ptr  8
.text:000004F0 arg_4           = dword ptr  0Ch
.text:000004F0
.text:000004F0                 push    ebp
.text:000004F1                 mov     ebp, esp
.text:000004F3                 sub     esp, 20h
.text:000004F6                 mov     eax, 0CCCCCCCCh
.text:000004FB                 mov     [ebp+var_20], eax
.text:000004FE                 mov     [ebp+var_1C], eax
.text:00000501                 mov     [ebp+var_18], eax
.text:00000504                 mov     [ebp+var_14], eax
.text:00000507                 mov     [ebp+var_10], eax
.text:0000050A                 mov     [ebp+var_C], eax
.text:0000050D                 mov     [ebp+var_8], eax
.text:00000510                 mov     [ebp+var_4], eax
.text:00000513                 mov     [ebp+var_4], ecx
.text:00000516                 mov     eax, [ebp+var_4]
.text:00000519                 mov     ecx, [eax+10h]
.text:0000051C                 mov     [ebp+var_C], ecx
.text:0000051F                 mov     edx, [eax+14h]
.text:00000522                 mov     [ebp+var_8], edx
.text:00000525                 mov     [ebp+var_10], 0
.text:0000052C                 jmp     short loc_537
.text:0000052E ; ---------------------------------------------------------------------------
.text:0000052E
.text:0000052E loc_52E:                                ; CODE XREF: CMemBlocks::WriteToStream(uint,ISequentialOutStream *)+D3j
.text:0000052E                 mov     eax, [ebp+var_10]
.text:00000531                 add     eax, 1
.text:00000534                 mov     [ebp+var_10], eax
.text:00000537
.text:00000537 loc_537:                                ; CODE XREF: CMemBlocks::WriteToStream(uint,ISequentialOutStream *)+3Cj
.text:00000537                 cmp     [ebp+var_8], 0
.text:0000053B                 ja      short loc_547
.text:0000053D                 cmp     [ebp+var_C], 0
.text:00000541                 jbe     loc_5C8
.text:00000547
.text:00000547 loc_547:                                ; CODE XREF: CMemBlocks::WriteToStream(uint,ISequentialOutStream *)+4Bj
.text:00000547                 mov     ecx, [ebp+arg_0]
.text:0000054A                 mov     [ebp+var_14], ecx
.text:0000054D                 mov     edx, [ebp+var_14]
.text:00000550                 xor     eax, eax
.text:00000552                 mov     [ebp+var_20], edx
.text:00000555                 mov     [ebp+var_1C], eax
.text:00000558                 mov     ecx, [ebp+var_8]
.text:0000055B                 cmp     ecx, [ebp+var_1C]
.text:0000055E                 ja      short loc_570
.text:00000560                 jb      short loc_56A
.text:00000562                 mov     edx, [ebp+var_C]
.text:00000565                 cmp     edx, [ebp+var_20]
.text:00000568                 jnb     short loc_570
.text:0000056A
.text:0000056A loc_56A:                                ; CODE XREF: CMemBlocks::WriteToStream(uint,ISequentialOutStream *)+70j
.text:0000056A                 mov     eax, [ebp+var_C]
.text:0000056D                 mov     [ebp+var_14], eax
.text:00000570
.text:00000570 loc_570:                                ; CODE XREF: CMemBlocks::WriteToStream(uint,ISequentialOutStream *)+6Ej
.text:00000570                                         ; CMemBlocks::WriteToStream(uint,ISequentialOutStream *)+78j
.text:00000570                 mov     ecx, [ebp+var_4]
.text:00000573                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00000578                 cmp     [ebp+var_10], eax
.text:0000057B                 jb      short loc_584
.text:0000057D                 mov     eax, 80004005h
.text:00000582                 jmp     short loc_5CA
.text:00000584 ; ---------------------------------------------------------------------------
.text:00000584
.text:00000584 loc_584:                                ; CODE XREF: CMemBlocks::WriteToStream(uint,ISequentialOutStream *)+8Bj
.text:00000584                 mov     ecx, [ebp+var_14]
.text:00000587                 push    ecx             ; unsigned int
.text:00000588                 mov     edx, [ebp+var_10]
.text:0000058B                 push    edx
.text:0000058C                 mov     ecx, [ebp+var_4]
.text:0000058F                 call    ??A?$CRecordVector@PAX@@QBEABQAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00000594                 mov     eax, [eax]
.text:00000596                 push    eax             ; void *
.text:00000597                 mov     ecx, [ebp+arg_4]
.text:0000059A                 push    ecx             ; struct ISequentialOutStream *
.text:0000059B                 call    ?WriteStream@@YGJPAUISequentialOutStream@@PBXI@Z ; WriteStream(ISequentialOutStream *,void const *,uint)
.text:000005A0                 mov     [ebp+var_18], eax
.text:000005A3                 cmp     [ebp+var_18], 0
.text:000005A7                 jz      short loc_5AE
.text:000005A9                 mov     eax, [ebp+var_18]
.text:000005AC                 jmp     short loc_5CA
.text:000005AE ; ---------------------------------------------------------------------------
.text:000005AE
.text:000005AE loc_5AE:                                ; CODE XREF: CMemBlocks::WriteToStream(uint,ISequentialOutStream *)+B7j
.text:000005AE                 mov     edx, [ebp+var_14]
.text:000005B1                 xor     eax, eax
.text:000005B3                 mov     ecx, [ebp+var_C]
.text:000005B6                 sub     ecx, edx
.text:000005B8                 mov     edx, [ebp+var_8]
.text:000005BB                 sbb     edx, eax
.text:000005BD                 mov     [ebp+var_C], ecx
.text:000005C0                 mov     [ebp+var_8], edx
.text:000005C3                 jmp     loc_52E
.text:000005C8 ; ---------------------------------------------------------------------------
.text:000005C8
.text:000005C8 loc_5C8:                                ; CODE XREF: CMemBlocks::WriteToStream(uint,ISequentialOutStream *)+51j
.text:000005C8                 xor     eax, eax
.text:000005CA
.text:000005CA loc_5CA:                                ; CODE XREF: CMemBlocks::WriteToStream(uint,ISequentialOutStream *)+92j
.text:000005CA                                         ; CMemBlocks::WriteToStream(uint,ISequentialOutStream *)+BCj
.text:000005CA                 add     esp, 20h
.text:000005CD                 cmp     ebp, esp
.text:000005CF                 call    __RTC_CheckEsp
.text:000005D4                 mov     esp, ebp
.text:000005D6                 pop     ebp
.text:000005D7                 retn    8
.text:000005D7 ?WriteToStream@CMemBlocks@@QBEJIPAUISequentialOutStream@@@Z endp
.text:000005D7
.text:000005D7 ; ---------------------------------------------------------------------------
.text:000005DA                 align 10h
.text:000005E0
.text:000005E0 ; =============== S U B R O U T I N E =======================================
.text:000005E0
.text:000005E0 ; Attributes: bp-based frame
.text:000005E0
.text:000005E0 ; void __thiscall CMemLockBlocks::FreeBlock(CMemLockBlocks *this, int, struct CMemBlockManagerMt *)
.text:000005E0                 public ?FreeBlock@CMemLockBlocks@@QAEXHPAVCMemBlockManagerMt@@@Z
.text:000005E0 ?FreeBlock@CMemLockBlocks@@QAEXHPAVCMemBlockManagerMt@@@Z proc near
.text:000005E0                                         ; CODE XREF: CMemLockBlocks::Free(CMemBlockManagerMt *)+2Dp
.text:000005E0                                         ; CMemLockBlocks::Detach(CMemLockBlocks &,CMemBlockManagerMt *)+B2p
.text:000005E0
.text:000005E0 var_4           = dword ptr -4
.text:000005E0 arg_0           = dword ptr  8
.text:000005E0 arg_4           = dword ptr  0Ch
.text:000005E0
.text:000005E0                 push    ebp
.text:000005E1                 mov     ebp, esp
.text:000005E3                 push    ecx
.text:000005E4                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000005EB                 mov     [ebp+var_4], ecx
.text:000005EE                 mov     eax, [ebp+var_4]
.text:000005F1                 movzx   ecx, byte ptr [eax+18h]
.text:000005F5                 push    ecx             ; bool
.text:000005F6                 mov     edx, [ebp+arg_0]
.text:000005F9                 push    edx
.text:000005FA                 mov     ecx, [ebp+var_4]
.text:000005FD                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00000602                 mov     eax, [eax]
.text:00000604                 push    eax             ; void *
.text:00000605                 mov     ecx, [ebp+arg_4] ; this
.text:00000608                 call    ?FreeBlock@CMemBlockManagerMt@@QAEXPAX_N@Z ; CMemBlockManagerMt::FreeBlock(void *,bool)
.text:0000060D                 mov     ecx, [ebp+arg_0]
.text:00000610                 push    ecx
.text:00000611                 mov     ecx, [ebp+var_4]
.text:00000614                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00000619                 mov     dword ptr [eax], 0
.text:0000061F                 add     esp, 4
.text:00000622                 cmp     ebp, esp
.text:00000624                 call    __RTC_CheckEsp
.text:00000629                 mov     esp, ebp
.text:0000062B                 pop     ebp
.text:0000062C                 retn    8
.text:0000062C ?FreeBlock@CMemLockBlocks@@QAEXHPAVCMemBlockManagerMt@@@Z endp
.text:0000062C
.text:0000062C ; ---------------------------------------------------------------------------
.text:0000062F                 align 10h
.text:00000630
.text:00000630 ; =============== S U B R O U T I N E =======================================
.text:00000630
.text:00000630 ; Attributes: bp-based frame
.text:00000630
.text:00000630 ; void __thiscall CMemLockBlocks::Free(CMemLockBlocks *this, struct CMemBlockManagerMt *)
.text:00000630                 public ?Free@CMemLockBlocks@@QAEXPAVCMemBlockManagerMt@@@Z
.text:00000630 ?Free@CMemLockBlocks@@QAEXPAVCMemBlockManagerMt@@@Z proc near
.text:00000630                                         ; CODE XREF: CMemLockBlocks::Detach(CMemLockBlocks &,CMemBlockManagerMt *)+27p
.text:00000630                                         ; CMemLockBlocks::Detach(CMemLockBlocks &,CMemBlockManagerMt *)+F8p
.text:00000630
.text:00000630 var_4           = dword ptr -4
.text:00000630 arg_0           = dword ptr  8
.text:00000630
.text:00000630                 push    ebp
.text:00000631                 mov     ebp, esp
.text:00000633                 push    ecx
.text:00000634                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000063B                 mov     [ebp+var_4], ecx
.text:0000063E
.text:0000063E loc_63E:                                ; CODE XREF: CMemLockBlocks::Free(CMemBlockManagerMt *)+3Aj
.text:0000063E                 mov     ecx, [ebp+var_4]
.text:00000641                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00000646                 test    eax, eax
.text:00000648                 jbe     short loc_66C
.text:0000064A                 mov     eax, [ebp+arg_0]
.text:0000064D                 push    eax             ; struct CMemBlockManagerMt *
.text:0000064E                 mov     ecx, [ebp+var_4]
.text:00000651                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:00000656                 sub     eax, 1
.text:00000659                 push    eax             ; int
.text:0000065A                 mov     ecx, [ebp+var_4] ; this
.text:0000065D                 call    ?FreeBlock@CMemLockBlocks@@QAEXHPAVCMemBlockManagerMt@@@Z ; CMemLockBlocks::FreeBlock(int,CMemBlockManagerMt *)
.text:00000662                 mov     ecx, [ebp+var_4]
.text:00000665                 call    ?DeleteBack@?$CRecordVector@PAX@@QAEXXZ ; CRecordVector<void *>::DeleteBack(void)
.text:0000066A                 jmp     short loc_63E
.text:0000066C ; ---------------------------------------------------------------------------
.text:0000066C
.text:0000066C loc_66C:                                ; CODE XREF: CMemLockBlocks::Free(CMemBlockManagerMt *)+18j
.text:0000066C                 mov     ecx, [ebp+var_4]
.text:0000066F                 mov     dword ptr [ecx+10h], 0
.text:00000676                 mov     dword ptr [ecx+14h], 0
.text:0000067D                 add     esp, 4
.text:00000680                 cmp     ebp, esp
.text:00000682                 call    __RTC_CheckEsp
.text:00000687                 mov     esp, ebp
.text:00000689                 pop     ebp
.text:0000068A                 retn    4
.text:0000068A ?Free@CMemLockBlocks@@QAEXPAVCMemBlockManagerMt@@@Z endp
.text:0000068A
.text:0000068A ; ---------------------------------------------------------------------------
.text:0000068D                 align 10h
.text:00000690
.text:00000690 ; =============== S U B R O U T I N E =======================================
.text:00000690
.text:00000690 ; Attributes: bp-based frame
.text:00000690
.text:00000690 ; int __thiscall CMemLockBlocks::SwitchToNoLockMode(CMemLockBlocks *this, struct CMemBlockManagerMt *)
.text:00000690                 public ?SwitchToNoLockMode@CMemLockBlocks@@QAEHPAVCMemBlockManagerMt@@@Z
.text:00000690 ?SwitchToNoLockMode@CMemLockBlocks@@QAEHPAVCMemBlockManagerMt@@@Z proc near
.text:00000690
.text:00000690 var_8           = dword ptr -8
.text:00000690 var_4           = dword ptr -4
.text:00000690 arg_0           = dword ptr  8
.text:00000690
.text:00000690                 push    ebp
.text:00000691                 mov     ebp, esp
.text:00000693                 sub     esp, 8
.text:00000696                 mov     [ebp+var_8], 0CCCCCCCCh
.text:0000069D                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000006A4                 mov     [ebp+var_4], ecx
.text:000006A7                 mov     eax, [ebp+var_4]
.text:000006AA                 movzx   ecx, byte ptr [eax+18h]
.text:000006AE                 test    ecx, ecx
.text:000006B0                 jz      short loc_6E4
.text:000006B2                 mov     ecx, [ebp+var_4]
.text:000006B5                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:000006BA                 test    eax, eax
.text:000006BC                 jbe     short loc_6DD
.text:000006BE                 mov     ecx, [ebp+var_4]
.text:000006C1                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:000006C6                 push    eax             ; int
.text:000006C7                 mov     ecx, [ebp+arg_0] ; this
.text:000006CA                 call    ?ReleaseLockedBlocks@CMemBlockManagerMt@@QAEHH@Z ; CMemBlockManagerMt::ReleaseLockedBlocks(int)
.text:000006CF                 mov     [ebp+var_8], eax
.text:000006D2                 cmp     [ebp+var_8], 0
.text:000006D6                 jz      short loc_6DD
.text:000006D8                 mov     eax, [ebp+var_8]
.text:000006DB                 jmp     short loc_6E6
.text:000006DD ; ---------------------------------------------------------------------------
.text:000006DD
.text:000006DD loc_6DD:                                ; CODE XREF: CMemLockBlocks::SwitchToNoLockMode(CMemBlockManagerMt *)+2Cj
.text:000006DD                                         ; CMemLockBlocks::SwitchToNoLockMode(CMemBlockManagerMt *)+46j
.text:000006DD                 mov     edx, [ebp+var_4]
.text:000006E0                 mov     byte ptr [edx+18h], 0
.text:000006E4
.text:000006E4 loc_6E4:                                ; CODE XREF: CMemLockBlocks::SwitchToNoLockMode(CMemBlockManagerMt *)+20j
.text:000006E4                 xor     eax, eax
.text:000006E6
.text:000006E6 loc_6E6:                                ; CODE XREF: CMemLockBlocks::SwitchToNoLockMode(CMemBlockManagerMt *)+4Bj
.text:000006E6                 add     esp, 8
.text:000006E9                 cmp     ebp, esp
.text:000006EB                 call    __RTC_CheckEsp
.text:000006F0                 mov     esp, ebp
.text:000006F2                 pop     ebp
.text:000006F3                 retn    4
.text:000006F3 ?SwitchToNoLockMode@CMemLockBlocks@@QAEHPAVCMemBlockManagerMt@@@Z endp
.text:000006F3
.text:000006F3 ; ---------------------------------------------------------------------------
.text:000006F6                 align 10h
.text:00000700
.text:00000700 ; =============== S U B R O U T I N E =======================================
.text:00000700
.text:00000700 ; Attributes: bp-based frame
.text:00000700
.text:00000700 ; void __thiscall CMemLockBlocks::Detach(CMemLockBlocks *this, struct CMemLockBlocks *, struct CMemBlockManagerMt *)
.text:00000700                 public ?Detach@CMemLockBlocks@@QAEXAAU1@PAVCMemBlockManagerMt@@@Z
.text:00000700 ?Detach@CMemLockBlocks@@QAEXAAU1@PAVCMemBlockManagerMt@@@Z proc near
.text:00000700
.text:00000700 var_18          = dword ptr -18h
.text:00000700 var_14          = dword ptr -14h
.text:00000700 var_10          = dword ptr -10h
.text:00000700 var_C           = dword ptr -0Ch
.text:00000700 var_8           = dword ptr -8
.text:00000700 var_4           = dword ptr -4
.text:00000700 arg_0           = dword ptr  8
.text:00000700 arg_4           = dword ptr  0Ch
.text:00000700
.text:00000700                 push    ebp
.text:00000701                 mov     ebp, esp
.text:00000703                 sub     esp, 18h
.text:00000706                 mov     eax, 0CCCCCCCCh
.text:0000070B                 mov     [ebp+var_18], eax
.text:0000070E                 mov     [ebp+var_14], eax
.text:00000711                 mov     [ebp+var_10], eax
.text:00000714                 mov     [ebp+var_C], eax
.text:00000717                 mov     [ebp+var_8], eax
.text:0000071A                 mov     [ebp+var_4], eax
.text:0000071D                 mov     [ebp+var_4], ecx
.text:00000720                 mov     eax, [ebp+arg_4]
.text:00000723                 push    eax             ; struct CMemBlockManagerMt *
.text:00000724                 mov     ecx, [ebp+arg_0] ; this
.text:00000727                 call    ?Free@CMemLockBlocks@@QAEXPAVCMemBlockManagerMt@@@Z ; CMemLockBlocks::Free(CMemBlockManagerMt *)
.text:0000072C                 mov     ecx, [ebp+arg_0]
.text:0000072F                 mov     edx, [ebp+var_4]
.text:00000732                 mov     al, [edx+18h]
.text:00000735                 mov     [ecx+18h], al
.text:00000738                 mov     [ebp+var_C], 0
.text:0000073F                 mov     [ebp+var_8], 0
.text:00000746                 mov     ecx, [ebp+arg_4] ; this
.text:00000749                 call    ?GetBlockSize@CMemBlockManager@@QBEIXZ ; CMemBlockManager::GetBlockSize(void)
.text:0000074E                 mov     [ebp+var_10], eax
.text:00000751                 mov     [ebp+var_14], 0
.text:00000758                 jmp     short loc_763
.text:0000075A ; ---------------------------------------------------------------------------
.text:0000075A
.text:0000075A loc_75A:                                ; CODE XREF: CMemLockBlocks::Detach(CMemLockBlocks &,CMemBlockManagerMt *)+DAj
.text:0000075A                 mov     ecx, [ebp+var_14]
.text:0000075D                 add     ecx, 1
.text:00000760                 mov     [ebp+var_14], ecx
.text:00000763
.text:00000763 loc_763:                                ; CODE XREF: CMemLockBlocks::Detach(CMemLockBlocks &,CMemBlockManagerMt *)+58j
.text:00000763                 mov     ecx, [ebp+var_4]
.text:00000766                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:0000076B                 cmp     [ebp+var_14], eax
.text:0000076E                 jnb     short loc_7DF
.text:00000770                 mov     edx, [ebp+var_4]
.text:00000773                 mov     [ebp+var_18], edx
.text:00000776                 mov     eax, [ebp+var_18]
.text:00000779                 mov     ecx, [ebp+var_8]
.text:0000077C                 cmp     ecx, [eax+14h]
.text:0000077F                 ja      short loc_7A7
.text:00000781                 jb      short loc_78E
.text:00000783                 mov     edx, [ebp+var_18]
.text:00000786                 mov     eax, [ebp+var_C]
.text:00000789                 cmp     eax, [edx+10h]
.text:0000078C                 jnb     short loc_7A7
.text:0000078E
.text:0000078E loc_78E:                                ; CODE XREF: CMemLockBlocks::Detach(CMemLockBlocks &,CMemBlockManagerMt *)+81j
.text:0000078E                 mov     ecx, [ebp+var_14]
.text:00000791                 push    ecx
.text:00000792                 mov     ecx, [ebp+var_4]
.text:00000795                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:0000079A                 mov     edx, [eax]
.text:0000079C                 push    edx
.text:0000079D                 mov     ecx, [ebp+arg_0]
.text:000007A0                 call    ?Add@?$CRecordVector@PAX@@QAEIQAX@Z ; CRecordVector<void *>::Add(void * const)
.text:000007A5                 jmp     short loc_7B7
.text:000007A7 ; ---------------------------------------------------------------------------
.text:000007A7
.text:000007A7 loc_7A7:                                ; CODE XREF: CMemLockBlocks::Detach(CMemLockBlocks &,CMemBlockManagerMt *)+7Fj
.text:000007A7                                         ; CMemLockBlocks::Detach(CMemLockBlocks &,CMemBlockManagerMt *)+8Cj
.text:000007A7                 mov     eax, [ebp+arg_4]
.text:000007AA                 push    eax             ; struct CMemBlockManagerMt *
.text:000007AB                 mov     ecx, [ebp+var_14]
.text:000007AE                 push    ecx             ; int
.text:000007AF                 mov     ecx, [ebp+var_4] ; this
.text:000007B2                 call    ?FreeBlock@CMemLockBlocks@@QAEXHPAVCMemBlockManagerMt@@@Z ; CMemLockBlocks::FreeBlock(int,CMemBlockManagerMt *)
.text:000007B7
.text:000007B7 loc_7B7:                                ; CODE XREF: CMemLockBlocks::Detach(CMemLockBlocks &,CMemBlockManagerMt *)+A5j
.text:000007B7                 mov     edx, [ebp+var_14]
.text:000007BA                 push    edx
.text:000007BB                 mov     ecx, [ebp+var_4]
.text:000007BE                 call    ??A?$CRecordVector@PAX@@QAEAAPAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:000007C3                 mov     dword ptr [eax], 0
.text:000007C9                 mov     eax, [ebp+var_10]
.text:000007CC                 xor     ecx, ecx
.text:000007CE                 add     eax, [ebp+var_C]
.text:000007D1                 adc     ecx, [ebp+var_8]
.text:000007D4                 mov     [ebp+var_C], eax
.text:000007D7                 mov     [ebp+var_8], ecx
.text:000007DA                 jmp     loc_75A
.text:000007DF ; ---------------------------------------------------------------------------
.text:000007DF
.text:000007DF loc_7DF:                                ; CODE XREF: CMemLockBlocks::Detach(CMemLockBlocks &,CMemBlockManagerMt *)+6Ej
.text:000007DF                 mov     edx, [ebp+arg_0]
.text:000007E2                 mov     eax, [ebp+var_4]
.text:000007E5                 mov     ecx, [eax+10h]
.text:000007E8                 mov     [edx+10h], ecx
.text:000007EB                 mov     eax, [eax+14h]
.text:000007EE                 mov     [edx+14h], eax
.text:000007F1                 mov     ecx, [ebp+arg_4]
.text:000007F4                 push    ecx             ; struct CMemBlockManagerMt *
.text:000007F5                 mov     ecx, [ebp+var_4] ; this
.text:000007F8                 call    ?Free@CMemLockBlocks@@QAEXPAVCMemBlockManagerMt@@@Z ; CMemLockBlocks::Free(CMemBlockManagerMt *)
.text:000007FD                 add     esp, 18h
.text:00000800                 cmp     ebp, esp
.text:00000802                 call    __RTC_CheckEsp
.text:00000807                 mov     esp, ebp
.text:00000809                 pop     ebp
.text:0000080A                 retn    8
.text:0000080A ?Detach@CMemLockBlocks@@QAEXAAU1@PAVCMemBlockManagerMt@@@Z endp
.text:0000080A
.text:0000080A ; ---------------------------------------------------------------------------
.text:0000080D                 align 10h
.text:0000080D _text           ends
.text:0000080D
.rtc$TMZ:00000810 ; ===========================================================================
.rtc$TMZ:00000810
.rtc$TMZ:00000810 ; Segment type: Pure data
.rtc$TMZ:00000810 ; Segment permissions: Read
.rtc$TMZ:00000810 _rtc$TMZ        segment dword public 'DATA' use32
.rtc$TMZ:00000810                 assume cs:_rtc$TMZ
.rtc$TMZ:00000810                 ;org 810h
.rtc$TMZ:00000810 ; COMDAT (pick any)
.rtc$TMZ:00000810 __RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
.rtc$TMZ:00000810 _rtc$TMZ        ends
.rtc$TMZ:00000810
.rtc$IMZ:00000814 ; ===========================================================================
.rtc$IMZ:00000814
.rtc$IMZ:00000814 ; Segment type: Pure data
.rtc$IMZ:00000814 ; Segment permissions: Read
.rtc$IMZ:00000814 _rtc$IMZ        segment dword public 'DATA' use32
.rtc$IMZ:00000814                 assume cs:_rtc$IMZ
.rtc$IMZ:00000814                 ;org 814h
.rtc$IMZ:00000814 ; COMDAT (pick any)
.rtc$IMZ:00000814 __RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
.rtc$IMZ:00000814 _rtc$IMZ        ends
.rtc$IMZ:00000814
.text:00000818 ; ===========================================================================
.text:00000818
.text:00000818 ; Segment type: Pure code
.text:00000818 ; Segment permissions: Read/Execute
.text:00000818 _text           segment para public 'CODE' use32
.text:00000818                 assume cs:_text
.text:00000818                 ;org 818h
.text:00000818 ; COMDAT (pick any)
.text:00000818                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000818
.text:00000818 ; =============== S U B R O U T I N E =======================================
.text:00000818
.text:00000818 ; Attributes: bp-based frame
.text:00000818
.text:00000818 ; unsigned int __thiscall NWindows::NSynchronization::CSemaphore::Close(NWindows::NSynchronization::CSemaphore *__hidden this)
.text:00000818                 public ?Close@CSemaphore@NSynchronization@NWindows@@QAEIXZ
.text:00000818 ?Close@CSemaphore@NSynchronization@NWindows@@QAEIXZ proc near
.text:00000818                                         ; CODE XREF: CMemBlockManagerMt::AllocateSpace(uint,uint)+4Fp
.text:00000818                                         ; CMemBlockManagerMt::FreeSpace(void)+14p
.text:00000818
.text:00000818 var_4           = dword ptr -4
.text:00000818
.text:00000818                 push    ebp
.text:00000819                 mov     ebp, esp
.text:0000081B                 push    ecx
.text:0000081C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000823                 mov     [ebp+var_4], ecx
.text:00000826                 mov     eax, [ebp+var_4]
.text:00000829                 push    eax
.text:0000082A                 call    _HandlePtr_Close@4 ; HandlePtr_Close(x)
.text:0000082F                 add     esp, 4
.text:00000832                 cmp     ebp, esp
.text:00000834                 call    __RTC_CheckEsp
.text:00000839                 mov     esp, ebp
.text:0000083B                 pop     ebp
.text:0000083C                 retn
.text:0000083C ?Close@CSemaphore@NSynchronization@NWindows@@QAEIXZ endp
.text:0000083C
.text:0000083C ; ---------------------------------------------------------------------------
.text:0000083D                 align 10h
.text:0000083D _text           ends
.text:0000083D
.text:00000840 ; ===========================================================================
.text:00000840
.text:00000840 ; Segment type: Pure code
.text:00000840 ; Segment permissions: Read/Execute
.text:00000840 _text           segment para public 'CODE' use32
.text:00000840                 assume cs:_text
.text:00000840                 ;org 840h
.text:00000840 ; COMDAT (pick any)
.text:00000840                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000840
.text:00000840 ; =============== S U B R O U T I N E =======================================
.text:00000840
.text:00000840 ; Attributes: bp-based frame
.text:00000840
.text:00000840 ; unsigned int __thiscall NWindows::NSynchronization::CSemaphore::Create(NWindows::NSynchronization::CSemaphore *this, unsigned int, unsigned int)
.text:00000840                 public ?Create@CSemaphore@NSynchronization@NWindows@@QAEIII@Z
.text:00000840 ?Create@CSemaphore@NSynchronization@NWindows@@QAEIII@Z proc near
.text:00000840                                         ; CODE XREF: CMemBlockManagerMt::AllocateSpace(uint,uint)+62p
.text:00000840
.text:00000840 var_4           = dword ptr -4
.text:00000840 arg_0           = dword ptr  8
.text:00000840 arg_4           = dword ptr  0Ch
.text:00000840
.text:00000840                 push    ebp
.text:00000841                 mov     ebp, esp
.text:00000843                 push    ecx
.text:00000844                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000084B                 mov     [ebp+var_4], ecx
.text:0000084E                 mov     eax, [ebp+arg_4]
.text:00000851                 push    eax
.text:00000852                 mov     ecx, [ebp+arg_0]
.text:00000855                 push    ecx
.text:00000856                 mov     edx, [ebp+var_4]
.text:00000859                 push    edx
.text:0000085A                 call    _Semaphore_Create@12 ; Semaphore_Create(x,x,x)
.text:0000085F                 add     esp, 4
.text:00000862                 cmp     ebp, esp
.text:00000864                 call    __RTC_CheckEsp
.text:00000869                 mov     esp, ebp
.text:0000086B                 pop     ebp
.text:0000086C                 retn    8
.text:0000086C ?Create@CSemaphore@NSynchronization@NWindows@@QAEIII@Z endp
.text:0000086C
.text:0000086C ; ---------------------------------------------------------------------------
.text:0000086F                 align 10h
.text:0000086F _text           ends
.text:0000086F
.text$x:00000870 ; ===========================================================================
.text$x:00000870
.text$x:00000870 ; Segment type: Pure code
.text$x:00000870 ; Segment permissions: Read/Execute
.text$x:00000870 _text$x         segment para public 'CODE' use32
.text$x:00000870                 assume cs:_text$x
.text$x:00000870                 ;org 870h
.text$x:00000870                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text$x:00000870
.text$x:00000870 ; =============== S U B R O U T I N E =======================================
.text$x:00000870
.text$x:00000870
.text$x:00000870 __unwindfunclet$?AllocateBlock@CMemBlockManagerMt@@QAEPAXXZ$0 proc near
.text$x:00000870                                         ; DATA XREF: .xdata$x:000008BCo
.text$x:00000870                 lea     ecx, [ebp-18h]  ; this
.text$x:00000873                 jmp     ??1CCriticalSectionLock@NSynchronization@NWindows@@QAE@XZ ; NWindows::NSynchronization::CCriticalSectionLock::~CCriticalSectionLock(void)
.text$x:00000873 __unwindfunclet$?AllocateBlock@CMemBlockManagerMt@@QAEPAXXZ$0 endp
.text$x:00000873
.text$x:00000878
.text$x:00000878 ; =============== S U B R O U T I N E =======================================
.text$x:00000878
.text$x:00000878
.text$x:00000878 __ehhandler$?AllocateBlock@CMemBlockManagerMt@@QAEPAXXZ proc near
.text$x:00000878                                         ; DATA XREF: CMemBlockManagerMt::AllocateBlock(void)+5o
.text$x:00000878
.text$x:00000878 arg_4           = dword ptr  8
.text$x:00000878
.text$x:00000878                 mov     edx, [esp+arg_4]
.text$x:0000087C                 lea     eax, [edx+0Ch]
.text$x:0000087F                 mov     ecx, [edx-18h]
.text$x:00000882                 xor     ecx, eax
.text$x:00000884                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000889                 mov     eax, offset __ehfuncinfo$?AllocateBlock@CMemBlockManagerMt@@QAEPAXXZ
.text$x:0000088E                 jmp     ___CxxFrameHandler3
.text$x:0000088E __ehhandler$?AllocateBlock@CMemBlockManagerMt@@QAEPAXXZ endp
.text$x:0000088E
.text$x:00000893
.text$x:00000893 ; =============== S U B R O U T I N E =======================================
.text$x:00000893
.text$x:00000893
.text$x:00000893 __unwindfunclet$?FreeBlock@CMemBlockManagerMt@@QAEXPAX_N@Z$0 proc near
.text$x:00000893                                         ; DATA XREF: .xdata$x:000008E8o
.text$x:00000893                 lea     ecx, [ebp-18h]  ; this
.text$x:00000896                 jmp     ??1CCriticalSectionLock@NSynchronization@NWindows@@QAE@XZ ; NWindows::NSynchronization::CCriticalSectionLock::~CCriticalSectionLock(void)
.text$x:00000896 __unwindfunclet$?FreeBlock@CMemBlockManagerMt@@QAEXPAX_N@Z$0 endp
.text$x:00000896
.text$x:0000089B
.text$x:0000089B ; =============== S U B R O U T I N E =======================================
.text$x:0000089B
.text$x:0000089B
.text$x:0000089B __ehhandler$?FreeBlock@CMemBlockManagerMt@@QAEXPAX_N@Z proc near
.text$x:0000089B                                         ; DATA XREF: CMemBlockManagerMt::FreeBlock(void *,bool)+5o
.text$x:0000089B
.text$x:0000089B arg_4           = dword ptr  8
.text$x:0000089B
.text$x:0000089B                 mov     edx, [esp+arg_4]
.text$x:0000089F                 lea     eax, [edx+0Ch]
.text$x:000008A2                 mov     ecx, [edx-14h]
.text$x:000008A5                 xor     ecx, eax
.text$x:000008A7                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000008AC                 mov     eax, offset __ehfuncinfo$?FreeBlock@CMemBlockManagerMt@@QAEXPAX_N@Z
.text$x:000008B1                 jmp     ___CxxFrameHandler3
.text$x:000008B1 __ehhandler$?FreeBlock@CMemBlockManagerMt@@QAEXPAX_N@Z endp
.text$x:000008B1
.text$x:000008B1 ; ---------------------------------------------------------------------------
.text$x:000008B6                 align 4
.text$x:000008B6 _text$x         ends
.text$x:000008B6
.xdata$x:000008B8 ; ===========================================================================
.xdata$x:000008B8
.xdata$x:000008B8 ; Segment type: Pure data
.xdata$x:000008B8 ; Segment permissions: Read
.xdata$x:000008B8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000008B8                 assume cs:_xdata$x
.xdata$x:000008B8                 ;org 8B8h
.xdata$x:000008B8 __unwindtable$?AllocateBlock@CMemBlockManagerMt@@QAEPAXXZ db 0FFh
.xdata$x:000008B8                                         ; DATA XREF: .xdata$x:000008C8o
.xdata$x:000008B9                 db 0FFh
.xdata$x:000008BA                 db 0FFh
.xdata$x:000008BB                 db 0FFh
.xdata$x:000008BC                 dd offset __unwindfunclet$?AllocateBlock@CMemBlockManagerMt@@QAEPAXXZ$0
.xdata$x:000008C0 __ehfuncinfo$?AllocateBlock@CMemBlockManagerMt@@QAEPAXXZ db  22h ; "
.xdata$x:000008C0                                         ; DATA XREF: __ehhandler$?AllocateBlock@CMemBlockManagerMt@@QAEPAXXZ+11o
.xdata$x:000008C1                 db    5
.xdata$x:000008C2                 db  93h ; ô
.xdata$x:000008C3                 db  19h
.xdata$x:000008C4                 db    1
.xdata$x:000008C5                 db    0
.xdata$x:000008C6                 db    0
.xdata$x:000008C7                 db    0
.xdata$x:000008C8                 dd offset __unwindtable$?AllocateBlock@CMemBlockManagerMt@@QAEPAXXZ
.xdata$x:000008CC                 align 20h
.xdata$x:000008E0                 db    1
.xdata$x:000008E1                 db    0
.xdata$x:000008E2                 db    0
.xdata$x:000008E3                 db    0
.xdata$x:000008E4 __unwindtable$?FreeBlock@CMemBlockManagerMt@@QAEXPAX_N@Z db 0FFh
.xdata$x:000008E4                                         ; DATA XREF: .xdata$x:000008F4o
.xdata$x:000008E5                 db 0FFh
.xdata$x:000008E6                 db 0FFh
.xdata$x:000008E7                 db 0FFh
.xdata$x:000008E8                 dd offset __unwindfunclet$?FreeBlock@CMemBlockManagerMt@@QAEXPAX_N@Z$0
.xdata$x:000008EC __ehfuncinfo$?FreeBlock@CMemBlockManagerMt@@QAEXPAX_N@Z db  22h ; "
.xdata$x:000008EC                                         ; DATA XREF: __ehhandler$?FreeBlock@CMemBlockManagerMt@@QAEXPAX_N@Z+11o
.xdata$x:000008ED                 db    5
.xdata$x:000008EE                 db  93h ; ô
.xdata$x:000008EF                 db  19h
.xdata$x:000008F0                 db    1
.xdata$x:000008F1                 db    0
.xdata$x:000008F2                 db    0
.xdata$x:000008F3                 db    0
.xdata$x:000008F4                 dd offset __unwindtable$?FreeBlock@CMemBlockManagerMt@@QAEXPAX_N@Z
.xdata$x:000008F8                 db    0
.xdata$x:000008F9                 db    0
.xdata$x:000008FA                 db    0
.xdata$x:000008FB                 db    0
.xdata$x:000008FC                 db    0
.xdata$x:000008FD                 db    0
.xdata$x:000008FE                 db    0
.xdata$x:000008FF                 db    0
.xdata$x:00000900                 db    0
.xdata$x:00000901                 db    0
.xdata$x:00000902                 db    0
.xdata$x:00000903                 db    0
.xdata$x:00000904                 db    0
.xdata$x:00000905                 db    0
.xdata$x:00000906                 db    0
.xdata$x:00000907                 db    0
.xdata$x:00000908                 db    0
.xdata$x:00000909                 db    0
.xdata$x:0000090A                 db    0
.xdata$x:0000090B                 db    0
.xdata$x:0000090C                 db    1
.xdata$x:0000090D                 db    0
.xdata$x:0000090E                 db    0
.xdata$x:0000090F                 db    0
.xdata$x:0000090F _xdata$x        ends
.xdata$x:0000090F
.text:00000910 ; ===========================================================================
.text:00000910
.text:00000910 ; Segment type: Pure code
.text:00000910 ; Segment permissions: Read/Execute
.text:00000910 _text           segment para public 'CODE' use32
.text:00000910                 assume cs:_text
.text:00000910                 ;org 910h
.text:00000910 ; COMDAT (pick any)
.text:00000910                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000910
.text:00000910 ; =============== S U B R O U T I N E =======================================
.text:00000910
.text:00000910 ; Attributes: bp-based frame
.text:00000910
.text:00000910 ; _DWORD __thiscall NWindows::NSynchronization::CCriticalSectionLock::CCriticalSectionLock(NWindows::NSynchronization::CCriticalSectionLock *this, struct NWindows::NSynchronization::CCriticalSection *)
.text:00000910                 public ??0CCriticalSectionLock@NSynchronization@NWindows@@QAE@AAVCCriticalSection@12@@Z
.text:00000910 ??0CCriticalSectionLock@NSynchronization@NWindows@@QAE@AAVCCriticalSection@12@@Z proc near
.text:00000910                                         ; CODE XREF: CMemBlockManagerMt::AllocateBlock(void)+46p
.text:00000910                                         ; CMemBlockManagerMt::FreeBlock(void *,bool)+4Bp
.text:00000910
.text:00000910 var_4           = dword ptr -4
.text:00000910 arg_0           = dword ptr  8
.text:00000910
.text:00000910                 push    ebp
.text:00000911                 mov     ebp, esp
.text:00000913                 push    ecx
.text:00000914                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000091B                 mov     [ebp+var_4], ecx
.text:0000091E                 mov     eax, [ebp+var_4]
.text:00000921                 mov     ecx, [ebp+arg_0]
.text:00000924                 mov     [eax], ecx
.text:00000926                 mov     edx, [ebp+var_4]
.text:00000929                 mov     ecx, [edx]      ; this
.text:0000092B                 call    ?Enter@CCriticalSection@NSynchronization@NWindows@@QAEXXZ ; NWindows::NSynchronization::CCriticalSection::Enter(void)
.text:00000930                 mov     eax, [ebp+var_4]
.text:00000933                 add     esp, 4
.text:00000936                 cmp     ebp, esp
.text:00000938                 call    __RTC_CheckEsp
.text:0000093D                 mov     esp, ebp
.text:0000093F                 pop     ebp
.text:00000940                 retn    4
.text:00000940 ??0CCriticalSectionLock@NSynchronization@NWindows@@QAE@AAVCCriticalSection@12@@Z endp
.text:00000940
.text:00000940 ; ---------------------------------------------------------------------------
.text:00000943                 align 4
.text:00000943 _text           ends
.text:00000943
.text:00000944 ; ===========================================================================
.text:00000944
.text:00000944 ; Segment type: Pure code
.text:00000944 ; Segment permissions: Read/Execute
.text:00000944 _text           segment para public 'CODE' use32
.text:00000944                 assume cs:_text
.text:00000944                 ;org 944h
.text:00000944 ; COMDAT (pick any)
.text:00000944                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000944
.text:00000944 ; =============== S U B R O U T I N E =======================================
.text:00000944
.text:00000944 ; Attributes: bp-based frame
.text:00000944
.text:00000944 ; void __thiscall NWindows::NSynchronization::CCriticalSection::Enter(NWindows::NSynchronization::CCriticalSection *__hidden this)
.text:00000944                 public ?Enter@CCriticalSection@NSynchronization@NWindows@@QAEXXZ
.text:00000944 ?Enter@CCriticalSection@NSynchronization@NWindows@@QAEXXZ proc near
.text:00000944                                         ; CODE XREF: NWindows::NSynchronization::CCriticalSectionLock::CCriticalSectionLock(NWindows::NSynchronization::CCriticalSection &)+1Bp
.text:00000944
.text:00000944 lpCriticalSection= dword ptr -4
.text:00000944
.text:00000944                 push    ebp
.text:00000945                 mov     ebp, esp
.text:00000947                 push    ecx
.text:00000948                 push    esi
.text:00000949                 mov     [ebp+lpCriticalSection], 0CCCCCCCCh
.text:00000950                 mov     [ebp+lpCriticalSection], ecx
.text:00000953                 mov     esi, esp
.text:00000955                 mov     eax, [ebp+lpCriticalSection]
.text:00000958                 push    eax             ; lpCriticalSection
.text:00000959                 call    dword ptr ds:__imp__EnterCriticalSection@4 ; EnterCriticalSection(x)
.text:0000095F                 cmp     esi, esp
.text:00000961                 call    __RTC_CheckEsp
.text:00000966                 pop     esi
.text:00000967                 add     esp, 4
.text:0000096A                 cmp     ebp, esp
.text:0000096C                 call    __RTC_CheckEsp
.text:00000971                 mov     esp, ebp
.text:00000973                 pop     ebp
.text:00000974                 retn
.text:00000974 ?Enter@CCriticalSection@NSynchronization@NWindows@@QAEXXZ endp
.text:00000974
.text:00000974 ; ---------------------------------------------------------------------------
.text:00000975                 align 4
.text:00000975 _text           ends
.text:00000975
.text:00000978 ; ===========================================================================
.text:00000978
.text:00000978 ; Segment type: Pure code
.text:00000978 ; Segment permissions: Read/Execute
.text:00000978 _text           segment para public 'CODE' use32
.text:00000978                 assume cs:_text
.text:00000978                 ;org 978h
.text:00000978 ; COMDAT (pick any)
.text:00000978                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000978
.text:00000978 ; =============== S U B R O U T I N E =======================================
.text:00000978
.text:00000978 ; Attributes: bp-based frame
.text:00000978
.text:00000978 ; _DWORD __thiscall NWindows::NSynchronization::CCriticalSectionLock::~CCriticalSectionLock(NWindows::NSynchronization::CCriticalSectionLock *__hidden this)
.text:00000978                 public ??1CCriticalSectionLock@NSynchronization@NWindows@@QAE@XZ
.text:00000978 ??1CCriticalSectionLock@NSynchronization@NWindows@@QAE@XZ proc near
.text:00000978                                         ; CODE XREF: CMemBlockManagerMt::AllocateBlock(void)+67p
.text:00000978                                         ; CMemBlockManagerMt::FreeBlock(void *,bool)+6Dp ...
.text:00000978
.text:00000978 var_4           = dword ptr -4
.text:00000978
.text:00000978                 push    ebp
.text:00000979                 mov     ebp, esp
.text:0000097B                 push    ecx
.text:0000097C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000983                 mov     [ebp+var_4], ecx
.text:00000986                 mov     ecx, [ebp+var_4] ; this
.text:00000989                 call    ?Unlock@CCriticalSectionLock@NSynchronization@NWindows@@AAEXXZ ; NWindows::NSynchronization::CCriticalSectionLock::Unlock(void)
.text:0000098E                 add     esp, 4
.text:00000991                 cmp     ebp, esp
.text:00000993                 call    __RTC_CheckEsp
.text:00000998                 mov     esp, ebp
.text:0000099A                 pop     ebp
.text:0000099B                 retn
.text:0000099B ??1CCriticalSectionLock@NSynchronization@NWindows@@QAE@XZ endp
.text:0000099B
.text:0000099B _text           ends
.text:0000099B
.text:0000099C ; ===========================================================================
.text:0000099C
.text:0000099C ; Segment type: Pure code
.text:0000099C ; Segment permissions: Read/Execute
.text:0000099C _text           segment para public 'CODE' use32
.text:0000099C                 assume cs:_text
.text:0000099C                 ;org 99Ch
.text:0000099C ; COMDAT (pick any)
.text:0000099C                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:0000099C
.text:0000099C ; =============== S U B R O U T I N E =======================================
.text:0000099C
.text:0000099C ; Attributes: bp-based frame
.text:0000099C
.text:0000099C ; void __thiscall NWindows::NSynchronization::CCriticalSectionLock::Unlock(NWindows::NSynchronization::CCriticalSectionLock *__hidden this)
.text:0000099C                 public ?Unlock@CCriticalSectionLock@NSynchronization@NWindows@@AAEXXZ
.text:0000099C ?Unlock@CCriticalSectionLock@NSynchronization@NWindows@@AAEXXZ proc near
.text:0000099C                                         ; CODE XREF: NWindows::NSynchronization::CCriticalSectionLock::~CCriticalSectionLock(void)+11p
.text:0000099C
.text:0000099C var_4           = dword ptr -4
.text:0000099C
.text:0000099C                 push    ebp
.text:0000099D                 mov     ebp, esp
.text:0000099F                 push    ecx
.text:000009A0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000009A7                 mov     [ebp+var_4], ecx
.text:000009AA                 mov     eax, [ebp+var_4]
.text:000009AD                 mov     ecx, [eax]      ; this
.text:000009AF                 call    ?Leave@CCriticalSection@NSynchronization@NWindows@@QAEXXZ ; NWindows::NSynchronization::CCriticalSection::Leave(void)
.text:000009B4                 add     esp, 4
.text:000009B7                 cmp     ebp, esp
.text:000009B9                 call    __RTC_CheckEsp
.text:000009BE                 mov     esp, ebp
.text:000009C0                 pop     ebp
.text:000009C1                 retn
.text:000009C1 ?Unlock@CCriticalSectionLock@NSynchronization@NWindows@@AAEXXZ endp
.text:000009C1
.text:000009C1 ; ---------------------------------------------------------------------------
.text:000009C2                 align 4
.text:000009C2 _text           ends
.text:000009C2
.text:000009C4 ; ===========================================================================
.text:000009C4
.text:000009C4 ; Segment type: Pure code
.text:000009C4 ; Segment permissions: Read/Execute
.text:000009C4 _text           segment para public 'CODE' use32
.text:000009C4                 assume cs:_text
.text:000009C4                 ;org 9C4h
.text:000009C4 ; COMDAT (pick any)
.text:000009C4                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000009C4
.text:000009C4 ; =============== S U B R O U T I N E =======================================
.text:000009C4
.text:000009C4 ; Attributes: bp-based frame
.text:000009C4
.text:000009C4 ; void __thiscall NWindows::NSynchronization::CCriticalSection::Leave(NWindows::NSynchronization::CCriticalSection *__hidden this)
.text:000009C4                 public ?Leave@CCriticalSection@NSynchronization@NWindows@@QAEXXZ
.text:000009C4 ?Leave@CCriticalSection@NSynchronization@NWindows@@QAEXXZ proc near
.text:000009C4                                         ; CODE XREF: NWindows::NSynchronization::CCriticalSectionLock::Unlock(void)+13p
.text:000009C4
.text:000009C4 lpCriticalSection= dword ptr -4
.text:000009C4
.text:000009C4                 push    ebp
.text:000009C5                 mov     ebp, esp
.text:000009C7                 push    ecx
.text:000009C8                 push    esi
.text:000009C9                 mov     [ebp+lpCriticalSection], 0CCCCCCCCh
.text:000009D0                 mov     [ebp+lpCriticalSection], ecx
.text:000009D3                 mov     esi, esp
.text:000009D5                 mov     eax, [ebp+lpCriticalSection]
.text:000009D8                 push    eax             ; lpCriticalSection
.text:000009D9                 call    dword ptr ds:__imp__LeaveCriticalSection@4 ; LeaveCriticalSection(x)
.text:000009DF                 cmp     esi, esp
.text:000009E1                 call    __RTC_CheckEsp
.text:000009E6                 pop     esi
.text:000009E7                 add     esp, 4
.text:000009EA                 cmp     ebp, esp
.text:000009EC                 call    __RTC_CheckEsp
.text:000009F1                 mov     esp, ebp
.text:000009F3                 pop     ebp
.text:000009F4                 retn
.text:000009F4 ?Leave@CCriticalSection@NSynchronization@NWindows@@QAEXXZ endp
.text:000009F4
.text:000009F4 ; ---------------------------------------------------------------------------
.text:000009F5                 align 4
.text:000009F5 _text           ends
.text:000009F5
.text:000009F8 ; ===========================================================================
.text:000009F8
.text:000009F8 ; Segment type: Pure code
.text:000009F8 ; Segment permissions: Read/Execute
.text:000009F8 _text           segment para public 'CODE' use32
.text:000009F8                 assume cs:_text
.text:000009F8                 ;org 9F8h
.text:000009F8 ; COMDAT (pick any)
.text:000009F8                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000009F8
.text:000009F8 ; =============== S U B R O U T I N E =======================================
.text:000009F8
.text:000009F8 ; Attributes: bp-based frame
.text:000009F8
.text:000009F8 ; unsigned int __thiscall NWindows::NSynchronization::CSemaphore::Release(NWindows::NSynchronization::CSemaphore *__hidden this)
.text:000009F8                 public ?Release@CSemaphore@NSynchronization@NWindows@@QAEIXZ
.text:000009F8 ?Release@CSemaphore@NSynchronization@NWindows@@QAEIXZ proc near
.text:000009F8                                         ; CODE XREF: CMemBlockManagerMt::FreeBlock(void *,bool)+80p
.text:000009F8
.text:000009F8 var_4           = dword ptr -4
.text:000009F8
.text:000009F8                 push    ebp
.text:000009F9                 mov     ebp, esp
.text:000009FB                 push    ecx
.text:000009FC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000A03                 mov     [ebp+var_4], ecx
.text:00000A06                 mov     eax, [ebp+var_4]
.text:00000A09                 push    eax
.text:00000A0A                 call    _Semaphore_Release1@4 ; Semaphore_Release1(x)
.text:00000A0F                 add     esp, 4
.text:00000A12                 cmp     ebp, esp
.text:00000A14                 call    __RTC_CheckEsp
.text:00000A19                 mov     esp, ebp
.text:00000A1B                 pop     ebp
.text:00000A1C                 retn
.text:00000A1C ?Release@CSemaphore@NSynchronization@NWindows@@QAEIXZ endp
.text:00000A1C
.text:00000A1C ; ---------------------------------------------------------------------------
.text:00000A1D                 align 10h
.text:00000A1D _text           ends
.text:00000A1D
.text:00000A20 ; ===========================================================================
.text:00000A20
.text:00000A20 ; Segment type: Pure code
.text:00000A20 ; Segment permissions: Read/Execute
.text:00000A20 _text           segment para public 'CODE' use32
.text:00000A20                 assume cs:_text
.text:00000A20                 ;org 0A20h
.text:00000A20 ; COMDAT (pick any)
.text:00000A20                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000A20
.text:00000A20 ; =============== S U B R O U T I N E =======================================
.text:00000A20
.text:00000A20 ; Attributes: bp-based frame
.text:00000A20
.text:00000A20 ; int __thiscall CMemBlockManagerMt::ReleaseLockedBlocks(CMemBlockManagerMt *this, int)
.text:00000A20                 public ?ReleaseLockedBlocks@CMemBlockManagerMt@@QAEHH@Z
.text:00000A20 ?ReleaseLockedBlocks@CMemBlockManagerMt@@QAEHH@Z proc near
.text:00000A20                                         ; CODE XREF: CMemLockBlocks::SwitchToNoLockMode(CMemBlockManagerMt *)+3Ap
.text:00000A20
.text:00000A20 var_4           = dword ptr -4
.text:00000A20 arg_0           = dword ptr  8
.text:00000A20
.text:00000A20                 push    ebp
.text:00000A21                 mov     ebp, esp
.text:00000A23                 push    ecx
.text:00000A24                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000A2B                 mov     [ebp+var_4], ecx
.text:00000A2E                 mov     eax, [ebp+arg_0]
.text:00000A31                 push    eax             ; unsigned int
.text:00000A32                 mov     ecx, [ebp+var_4]
.text:00000A35                 add     ecx, 24h ; '$'  ; this
.text:00000A38                 call    ?Release@CSemaphore@NSynchronization@NWindows@@QAEII@Z ; NWindows::NSynchronization::CSemaphore::Release(uint)
.text:00000A3D                 add     esp, 4
.text:00000A40                 cmp     ebp, esp
.text:00000A42                 call    __RTC_CheckEsp
.text:00000A47                 mov     esp, ebp
.text:00000A49                 pop     ebp
.text:00000A4A                 retn    4
.text:00000A4A ?ReleaseLockedBlocks@CMemBlockManagerMt@@QAEHH@Z endp
.text:00000A4A
.text:00000A4A ; ---------------------------------------------------------------------------
.text:00000A4D                 align 10h
.text:00000A4D _text           ends
.text:00000A4D
.text:00000A50 ; ===========================================================================
.text:00000A50
.text:00000A50 ; Segment type: Pure code
.text:00000A50 ; Segment permissions: Read/Execute
.text:00000A50 _text           segment para public 'CODE' use32
.text:00000A50                 assume cs:_text
.text:00000A50                 ;org 0A50h
.text:00000A50 ; COMDAT (pick any)
.text:00000A50                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000A50
.text:00000A50 ; =============== S U B R O U T I N E =======================================
.text:00000A50
.text:00000A50 ; Attributes: bp-based frame
.text:00000A50
.text:00000A50 ; unsigned int __thiscall NWindows::NSynchronization::CSemaphore::Release(NWindows::NSynchronization::CSemaphore *this, unsigned int)
.text:00000A50                 public ?Release@CSemaphore@NSynchronization@NWindows@@QAEII@Z
.text:00000A50 ?Release@CSemaphore@NSynchronization@NWindows@@QAEII@Z proc near
.text:00000A50                                         ; CODE XREF: CMemBlockManagerMt::ReleaseLockedBlocks(int)+18p
.text:00000A50
.text:00000A50 var_4           = dword ptr -4
.text:00000A50 arg_0           = dword ptr  8
.text:00000A50
.text:00000A50                 push    ebp
.text:00000A51                 mov     ebp, esp
.text:00000A53                 push    ecx
.text:00000A54                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000A5B                 mov     [ebp+var_4], ecx
.text:00000A5E                 mov     eax, [ebp+arg_0]
.text:00000A61                 push    eax
.text:00000A62                 mov     ecx, [ebp+var_4]
.text:00000A65                 push    ecx
.text:00000A66                 call    _Semaphore_ReleaseN@8 ; Semaphore_ReleaseN(x,x)
.text:00000A6B                 add     esp, 4
.text:00000A6E                 cmp     ebp, esp
.text:00000A70                 call    __RTC_CheckEsp
.text:00000A75                 mov     esp, ebp
.text:00000A77                 pop     ebp
.text:00000A78                 retn    4
.text:00000A78 ?Release@CSemaphore@NSynchronization@NWindows@@QAEII@Z endp
.text:00000A78
.text:00000A78 ; ---------------------------------------------------------------------------
.text:00000A7B                 align 4
.text:00000A7B _text           ends
.text:00000A7B
.text:00000A7C ; ===========================================================================
.text:00000A7C
.text:00000A7C ; Segment type: Pure code
.text:00000A7C ; Segment permissions: Read/Execute
.text:00000A7C _text           segment para public 'CODE' use32
.text:00000A7C                 assume cs:_text
.text:00000A7C                 ;org 0A7Ch
.text:00000A7C ; COMDAT (pick any)
.text:00000A7C                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000A7C
.text:00000A7C ; =============== S U B R O U T I N E =======================================
.text:00000A7C
.text:00000A7C ; Attributes: bp-based frame
.text:00000A7C
.text:00000A7C ; unsigned int __thiscall CMemBlockManager::GetBlockSize(CMemBlockManager *__hidden this)
.text:00000A7C                 public ?GetBlockSize@CMemBlockManager@@QBEIXZ
.text:00000A7C ?GetBlockSize@CMemBlockManager@@QBEIXZ proc near
.text:00000A7C                                         ; CODE XREF: CMemLockBlocks::Detach(CMemLockBlocks &,CMemBlockManagerMt *)+49p
.text:00000A7C
.text:00000A7C var_4           = dword ptr -4
.text:00000A7C
.text:00000A7C                 push    ebp
.text:00000A7D                 mov     ebp, esp
.text:00000A7F                 push    ecx
.text:00000A80                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000A87                 mov     [ebp+var_4], ecx
.text:00000A8A                 mov     eax, [ebp+var_4]
.text:00000A8D                 mov     eax, [eax+4]
.text:00000A90                 mov     esp, ebp
.text:00000A92                 pop     ebp
.text:00000A93                 retn
.text:00000A93 ?GetBlockSize@CMemBlockManager@@QBEIXZ endp
.text:00000A93
.text:00000A93 _text           ends
.text:00000A93
.text:00000A94 ; ===========================================================================
.text:00000A94
.text:00000A94 ; Segment type: Pure code
.text:00000A94 ; Segment permissions: Read/Execute
.text:00000A94 _text           segment para public 'CODE' use32
.text:00000A94                 assume cs:_text
.text:00000A94                 ;org 0A94h
.text:00000A94 ; COMDAT (pick any)
.text:00000A94                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000A94
.text:00000A94 ; =============== S U B R O U T I N E =======================================
.text:00000A94
.text:00000A94 ; Attributes: bp-based frame
.text:00000A94
.text:00000A94 ; public: unsigned int __thiscall CRecordVector<void *>::Size(void)const
.text:00000A94                 public ?Size@?$CRecordVector@PAX@@QBEIXZ
.text:00000A94 ?Size@?$CRecordVector@PAX@@QBEIXZ proc near
.text:00000A94                                         ; CODE XREF: CMemBlocks::Free(CMemBlockManagerMt *)+11p
.text:00000A94                                         ; CMemBlocks::WriteToStream(uint,ISequentialOutStream *)+83p ...
.text:00000A94
.text:00000A94 var_4           = dword ptr -4
.text:00000A94
.text:00000A94                 push    ebp
.text:00000A95                 mov     ebp, esp
.text:00000A97                 push    ecx
.text:00000A98                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000A9F                 mov     [ebp+var_4], ecx
.text:00000AA2                 mov     eax, [ebp+var_4]
.text:00000AA5                 mov     eax, [eax+4]
.text:00000AA8                 mov     esp, ebp
.text:00000AAA                 pop     ebp
.text:00000AAB                 retn
.text:00000AAB ?Size@?$CRecordVector@PAX@@QBEIXZ endp
.text:00000AAB
.text:00000AAB _text           ends
.text:00000AAB
.text:00000AAC ; ===========================================================================
.text:00000AAC
.text:00000AAC ; Segment type: Pure code
.text:00000AAC ; Segment permissions: Read/Execute
.text:00000AAC _text           segment para public 'CODE' use32
.text:00000AAC                 assume cs:_text
.text:00000AAC                 ;org 0AACh
.text:00000AAC ; COMDAT (pick any)
.text:00000AAC                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000AAC
.text:00000AAC ; =============== S U B R O U T I N E =======================================
.text:00000AAC
.text:00000AAC ; Attributes: bp-based frame
.text:00000AAC
.text:00000AAC ; public: void __thiscall CRecordVector<void *>::ClearAndFree(void)
.text:00000AAC                 public ?ClearAndFree@?$CRecordVector@PAX@@QAEXXZ
.text:00000AAC ?ClearAndFree@?$CRecordVector@PAX@@QAEXXZ proc near
.text:00000AAC                                         ; CODE XREF: CMemBlocks::FreeOpt(CMemBlockManagerMt *)+1Dp
.text:00000AAC
.text:00000AAC var_8           = dword ptr -8
.text:00000AAC var_4           = dword ptr -4
.text:00000AAC
.text:00000AAC                 push    ebp
.text:00000AAD                 mov     ebp, esp
.text:00000AAF                 sub     esp, 8
.text:00000AB2                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00000AB9                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000AC0                 mov     [ebp+var_4], ecx
.text:00000AC3                 mov     eax, [ebp+var_4]
.text:00000AC6                 mov     ecx, [eax]
.text:00000AC8                 mov     [ebp+var_8], ecx
.text:00000ACB                 mov     edx, [ebp+var_8]
.text:00000ACE                 push    edx             ; void *
.text:00000ACF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00000AD4                 add     esp, 4
.text:00000AD7                 mov     eax, [ebp+var_4]
.text:00000ADA                 mov     dword ptr [eax], 0
.text:00000AE0                 mov     ecx, [ebp+var_4]
.text:00000AE3                 mov     dword ptr [ecx+4], 0
.text:00000AEA                 mov     edx, [ebp+var_4]
.text:00000AED                 mov     dword ptr [edx+8], 0
.text:00000AF4                 add     esp, 8
.text:00000AF7                 cmp     ebp, esp
.text:00000AF9                 call    __RTC_CheckEsp
.text:00000AFE                 mov     esp, ebp
.text:00000B00                 pop     ebp
.text:00000B01                 retn
.text:00000B01 ?ClearAndFree@?$CRecordVector@PAX@@QAEXXZ endp
.text:00000B01
.text:00000B01 ; ---------------------------------------------------------------------------
.text:00000B02                 align 4
.text:00000B02 _text           ends
.text:00000B02
.text:00000B04 ; ===========================================================================
.text:00000B04
.text:00000B04 ; Segment type: Pure code
.text:00000B04 ; Segment permissions: Read/Execute
.text:00000B04 _text           segment para public 'CODE' use32
.text:00000B04                 assume cs:_text
.text:00000B04                 ;org 0B04h
.text:00000B04 ; COMDAT (pick any)
.text:00000B04                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000B04
.text:00000B04 ; =============== S U B R O U T I N E =======================================
.text:00000B04
.text:00000B04 ; Attributes: bp-based frame
.text:00000B04
.text:00000B04 ; public: void __thiscall CRecordVector<void *>::DeleteBack(void)
.text:00000B04                 public ?DeleteBack@?$CRecordVector@PAX@@QAEXXZ
.text:00000B04 ?DeleteBack@?$CRecordVector@PAX@@QAEXXZ proc near
.text:00000B04                                         ; CODE XREF: CMemBlocks::Free(CMemBlockManagerMt *)+32p
.text:00000B04                                         ; CMemLockBlocks::Free(CMemBlockManagerMt *)+35p
.text:00000B04
.text:00000B04 var_4           = dword ptr -4
.text:00000B04
.text:00000B04                 push    ebp
.text:00000B05                 mov     ebp, esp
.text:00000B07                 push    ecx
.text:00000B08                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000B0F                 mov     [ebp+var_4], ecx
.text:00000B12                 mov     eax, [ebp+var_4]
.text:00000B15                 mov     ecx, [eax+4]
.text:00000B18                 sub     ecx, 1
.text:00000B1B                 mov     edx, [ebp+var_4]
.text:00000B1E                 mov     [edx+4], ecx
.text:00000B21                 mov     esp, ebp
.text:00000B23                 pop     ebp
.text:00000B24                 retn
.text:00000B24 ?DeleteBack@?$CRecordVector@PAX@@QAEXXZ endp
.text:00000B24
.text:00000B24 ; ---------------------------------------------------------------------------
.text:00000B25                 align 4
.text:00000B25 _text           ends
.text:00000B25
.text:00000B28 ; ===========================================================================
.text:00000B28
.text:00000B28 ; Segment type: Pure code
.text:00000B28 ; Segment permissions: Read/Execute
.text:00000B28 _text           segment para public 'CODE' use32
.text:00000B28                 assume cs:_text
.text:00000B28                 ;org 0B28h
.text:00000B28 ; COMDAT (pick any)
.text:00000B28                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000B28
.text:00000B28 ; =============== S U B R O U T I N E =======================================
.text:00000B28
.text:00000B28 ; Attributes: bp-based frame
.text:00000B28
.text:00000B28 ; public: unsigned int __thiscall CRecordVector<void *>::Add(void * const)
.text:00000B28                 public ?Add@?$CRecordVector@PAX@@QAEIQAX@Z
.text:00000B28 ?Add@?$CRecordVector@PAX@@QAEIQAX@Z proc near
.text:00000B28                                         ; CODE XREF: CMemLockBlocks::Detach(CMemLockBlocks &,CMemBlockManagerMt *)+A0p
.text:00000B28
.text:00000B28 var_8           = dword ptr -8
.text:00000B28 var_4           = dword ptr -4
.text:00000B28 arg_0           = dword ptr  8
.text:00000B28
.text:00000B28                 push    ebp
.text:00000B29                 mov     ebp, esp
.text:00000B2B                 sub     esp, 8
.text:00000B2E                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00000B35                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000B3C                 mov     [ebp+var_4], ecx
.text:00000B3F                 mov     ecx, [ebp+var_4]
.text:00000B42                 call    ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ ; CRecordVector<void *>::ReserveOnePosition(void)
.text:00000B47                 mov     eax, [ebp+var_4]
.text:00000B4A                 mov     ecx, [eax+4]
.text:00000B4D                 mov     edx, [ebp+var_4]
.text:00000B50                 mov     eax, [edx]
.text:00000B52                 mov     edx, [ebp+arg_0]
.text:00000B55                 mov     [eax+ecx*4], edx
.text:00000B58                 mov     eax, [ebp+var_4]
.text:00000B5B                 mov     ecx, [eax+4]
.text:00000B5E                 mov     [ebp+var_8], ecx
.text:00000B61                 mov     edx, [ebp+var_4]
.text:00000B64                 mov     eax, [edx+4]
.text:00000B67                 add     eax, 1
.text:00000B6A                 mov     ecx, [ebp+var_4]
.text:00000B6D                 mov     [ecx+4], eax
.text:00000B70                 mov     eax, [ebp+var_8]
.text:00000B73                 add     esp, 8
.text:00000B76                 cmp     ebp, esp
.text:00000B78                 call    __RTC_CheckEsp
.text:00000B7D                 mov     esp, ebp
.text:00000B7F                 pop     ebp
.text:00000B80                 retn    4
.text:00000B80 ?Add@?$CRecordVector@PAX@@QAEIQAX@Z endp
.text:00000B80
.text:00000B80 ; ---------------------------------------------------------------------------
.text:00000B83                 align 4
.text:00000B83 _text           ends
.text:00000B83
.text:00000B84 ; ===========================================================================
.text:00000B84
.text:00000B84 ; Segment type: Pure code
.text:00000B84 ; Segment permissions: Read/Execute
.text:00000B84 _text           segment para public 'CODE' use32
.text:00000B84                 assume cs:_text
.text:00000B84                 ;org 0B84h
.text:00000B84 ; COMDAT (pick any)
.text:00000B84                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000B84
.text:00000B84 ; =============== S U B R O U T I N E =======================================
.text:00000B84
.text:00000B84 ; Attributes: bp-based frame
.text:00000B84
.text:00000B84 ; public: void * const & __thiscall CRecordVector<void *>::operator[](unsigned int)const
.text:00000B84                 public ??A?$CRecordVector@PAX@@QBEABQAXI@Z
.text:00000B84 ??A?$CRecordVector@PAX@@QBEABQAXI@Z proc near
.text:00000B84                                         ; CODE XREF: CMemBlocks::WriteToStream(uint,ISequentialOutStream *)+9Fp
.text:00000B84
.text:00000B84 var_4           = dword ptr -4
.text:00000B84 arg_0           = dword ptr  8
.text:00000B84
.text:00000B84                 push    ebp
.text:00000B85                 mov     ebp, esp
.text:00000B87                 push    ecx
.text:00000B88                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000B8F                 mov     [ebp+var_4], ecx
.text:00000B92                 mov     eax, [ebp+var_4]
.text:00000B95                 mov     ecx, [eax]
.text:00000B97                 mov     edx, [ebp+arg_0]
.text:00000B9A                 lea     eax, [ecx+edx*4]
.text:00000B9D                 mov     esp, ebp
.text:00000B9F                 pop     ebp
.text:00000BA0                 retn    4
.text:00000BA0 ??A?$CRecordVector@PAX@@QBEABQAXI@Z endp
.text:00000BA0
.text:00000BA0 ; ---------------------------------------------------------------------------
.text:00000BA3                 align 4
.text:00000BA3 _text           ends
.text:00000BA3
.text:00000BA4 ; ===========================================================================
.text:00000BA4
.text:00000BA4 ; Segment type: Pure code
.text:00000BA4 ; Segment permissions: Read/Execute
.text:00000BA4 _text           segment para public 'CODE' use32
.text:00000BA4                 assume cs:_text
.text:00000BA4                 ;org 0BA4h
.text:00000BA4 ; COMDAT (pick any)
.text:00000BA4                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000BA4
.text:00000BA4 ; =============== S U B R O U T I N E =======================================
.text:00000BA4
.text:00000BA4 ; Attributes: bp-based frame
.text:00000BA4
.text:00000BA4 ; public: void * & __thiscall CRecordVector<void *>::operator[](unsigned int)
.text:00000BA4                 public ??A?$CRecordVector@PAX@@QAEAAPAXI@Z
.text:00000BA4 ??A?$CRecordVector@PAX@@QAEAAPAXI@Z proc near
.text:00000BA4                                         ; CODE XREF: CMemLockBlocks::FreeBlock(int,CMemBlockManagerMt *)+1Dp
.text:00000BA4                                         ; CMemLockBlocks::FreeBlock(int,CMemBlockManagerMt *)+34p ...
.text:00000BA4
.text:00000BA4 var_4           = dword ptr -4
.text:00000BA4 arg_0           = dword ptr  8
.text:00000BA4
.text:00000BA4                 push    ebp
.text:00000BA5                 mov     ebp, esp
.text:00000BA7                 push    ecx
.text:00000BA8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000BAF                 mov     [ebp+var_4], ecx
.text:00000BB2                 mov     eax, [ebp+var_4]
.text:00000BB5                 mov     ecx, [eax]
.text:00000BB7                 mov     edx, [ebp+arg_0]
.text:00000BBA                 lea     eax, [ecx+edx*4]
.text:00000BBD                 mov     esp, ebp
.text:00000BBF                 pop     ebp
.text:00000BC0                 retn    4
.text:00000BC0 ??A?$CRecordVector@PAX@@QAEAAPAXI@Z endp
.text:00000BC0
.text:00000BC0 ; ---------------------------------------------------------------------------
.text:00000BC3                 align 4
.text:00000BC3 _text           ends
.text:00000BC3
.text:00000BC4 ; ===========================================================================
.text:00000BC4
.text:00000BC4 ; Segment type: Pure code
.text:00000BC4 ; Segment permissions: Read/Execute
.text:00000BC4 _text           segment para public 'CODE' use32
.text:00000BC4                 assume cs:_text
.text:00000BC4                 ;org 0BC4h
.text:00000BC4 ; COMDAT (pick any)
.text:00000BC4                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000BC4
.text:00000BC4 ; =============== S U B R O U T I N E =======================================
.text:00000BC4
.text:00000BC4 ; Attributes: bp-based frame
.text:00000BC4
.text:00000BC4 ; public: void * & __thiscall CRecordVector<void *>::Back(void)
.text:00000BC4                 public ?Back@?$CRecordVector@PAX@@QAEAAPAXXZ
.text:00000BC4 ?Back@?$CRecordVector@PAX@@QAEAAPAXXZ proc near
.text:00000BC4                                         ; CODE XREF: CMemBlocks::Free(CMemBlockManagerMt *)+1Fp
.text:00000BC4
.text:00000BC4 var_4           = dword ptr -4
.text:00000BC4
.text:00000BC4                 push    ebp
.text:00000BC5                 mov     ebp, esp
.text:00000BC7                 push    ecx
.text:00000BC8                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000BCF                 mov     [ebp+var_4], ecx
.text:00000BD2                 mov     eax, [ebp+var_4]
.text:00000BD5                 mov     ecx, [eax+4]
.text:00000BD8                 mov     edx, [ebp+var_4]
.text:00000BDB                 mov     eax, [edx]
.text:00000BDD                 lea     eax, [eax+ecx*4-4]
.text:00000BE1                 mov     esp, ebp
.text:00000BE3                 pop     ebp
.text:00000BE4                 retn
.text:00000BE4 ?Back@?$CRecordVector@PAX@@QAEAAPAXXZ endp
.text:00000BE4
.text:00000BE4 ; ---------------------------------------------------------------------------
.text:00000BE5                 align 4
.text:00000BE5 _text           ends
.text:00000BE5
.text:00000BE8 ; ===========================================================================
.text:00000BE8
.text:00000BE8 ; Segment type: Pure code
.text:00000BE8 ; Segment permissions: Read/Execute
.text:00000BE8 _text           segment para public 'CODE' use32
.text:00000BE8                 assume cs:_text
.text:00000BE8                 ;org 0BE8h
.text:00000BE8 ; COMDAT (pick any)
.text:00000BE8                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000BE8
.text:00000BE8 ; =============== S U B R O U T I N E =======================================
.text:00000BE8
.text:00000BE8 ; Attributes: bp-based frame
.text:00000BE8
.text:00000BE8 ; private: void __thiscall CRecordVector<void *>::ReserveOnePosition(void)
.text:00000BE8                 public ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ
.text:00000BE8 ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ proc near
.text:00000BE8                                         ; CODE XREF: CRecordVector<void *>::Add(void * const)+1Ap
.text:00000BE8
.text:00000BE8 var_14          = dword ptr -14h
.text:00000BE8 var_10          = dword ptr -10h
.text:00000BE8 Dst             = dword ptr -0Ch
.text:00000BE8 var_8           = dword ptr -8
.text:00000BE8 var_4           = dword ptr -4
.text:00000BE8
.text:00000BE8                 push    ebp
.text:00000BE9                 mov     ebp, esp
.text:00000BEB                 sub     esp, 14h
.text:00000BEE                 mov     eax, 0CCCCCCCCh
.text:00000BF3                 mov     [ebp+var_14], eax
.text:00000BF6                 mov     [ebp+var_10], eax
.text:00000BF9                 mov     [ebp+Dst], eax
.text:00000BFC                 mov     [ebp+var_8], eax
.text:00000BFF                 mov     [ebp+var_4], eax
.text:00000C02                 mov     [ebp+var_4], ecx
.text:00000C05                 mov     eax, [ebp+var_4]
.text:00000C08                 mov     ecx, [ebp+var_4]
.text:00000C0B                 mov     edx, [eax+4]
.text:00000C0E                 cmp     edx, [ecx+8]
.text:00000C11                 jnz     loc_C9C
.text:00000C17                 mov     eax, [ebp+var_4]
.text:00000C1A                 mov     ecx, [eax+8]
.text:00000C1D                 shr     ecx, 2
.text:00000C20                 mov     edx, [ebp+var_4]
.text:00000C23                 mov     eax, [edx+8]
.text:00000C26                 lea     ecx, [eax+ecx+1]
.text:00000C2A                 mov     [ebp+var_8], ecx
.text:00000C2D                 xor     ecx, ecx
.text:00000C2F                 mov     eax, [ebp+var_8]
.text:00000C32                 mov     edx, 4
.text:00000C37                 mul     edx
.text:00000C39                 seto    cl
.text:00000C3C                 neg     ecx
.text:00000C3E                 or      ecx, eax
.text:00000C40                 push    ecx             ; unsigned int
.text:00000C41                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00000C46                 add     esp, 4
.text:00000C49                 mov     [ebp+var_10], eax
.text:00000C4C                 mov     eax, [ebp+var_10]
.text:00000C4F                 mov     [ebp+Dst], eax
.text:00000C52                 mov     ecx, [ebp+var_4]
.text:00000C55                 cmp     dword ptr [ecx+4], 0
.text:00000C59                 jz      short loc_C77
.text:00000C5B                 mov     edx, [ebp+var_4]
.text:00000C5E                 mov     eax, [edx+4]
.text:00000C61                 shl     eax, 2
.text:00000C64                 push    eax             ; Size
.text:00000C65                 mov     ecx, [ebp+var_4]
.text:00000C68                 mov     edx, [ecx]
.text:00000C6A                 push    edx             ; Src
.text:00000C6B                 mov     eax, [ebp+Dst]
.text:00000C6E                 push    eax             ; Dst
.text:00000C6F                 call    _memcpy
.text:00000C74                 add     esp, 0Ch
.text:00000C77
.text:00000C77 loc_C77:                                ; CODE XREF: CRecordVector<void *>::ReserveOnePosition(void)+71j
.text:00000C77                 mov     ecx, [ebp+var_4]
.text:00000C7A                 mov     edx, [ecx]
.text:00000C7C                 mov     [ebp+var_14], edx
.text:00000C7F                 mov     eax, [ebp+var_14]
.text:00000C82                 push    eax             ; void *
.text:00000C83                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00000C88                 add     esp, 4
.text:00000C8B                 mov     ecx, [ebp+var_4]
.text:00000C8E                 mov     edx, [ebp+Dst]
.text:00000C91                 mov     [ecx], edx
.text:00000C93                 mov     eax, [ebp+var_4]
.text:00000C96                 mov     ecx, [ebp+var_8]
.text:00000C99                 mov     [eax+8], ecx
.text:00000C9C
.text:00000C9C loc_C9C:                                ; CODE XREF: CRecordVector<void *>::ReserveOnePosition(void)+29j
.text:00000C9C                 add     esp, 14h
.text:00000C9F                 cmp     ebp, esp
.text:00000CA1                 call    __RTC_CheckEsp
.text:00000CA6                 mov     esp, ebp
.text:00000CA8                 pop     ebp
.text:00000CA9                 retn
.text:00000CA9 ?ReserveOnePosition@?$CRecordVector@PAX@@AAEXXZ endp
.text:00000CA9
.text:00000CA9 _text           ends
.text:00000CA9
UNDEF:00000CB0 ; ===========================================================================
UNDEF:00000CB0
UNDEF:00000CB0 ; Segment type: Externs
UNDEF:00000CB0 ; UNDEF
UNDEF:00000CB0 ; __stdcall MidAlloc(x)
UNDEF:00000CB0                 extrn _MidAlloc@4:near  ; CODE XREF: CMemBlockManager::AllocateSpace(uint)+5Dp
UNDEF:00000CB4                 extrn __RTC_CheckEsp:near
UNDEF:00000CB4                                         ; CODE XREF: CMemBlockManager::AllocateSpace(uint)+CFp
UNDEF:00000CB4                                         ; CMemBlockManager::FreeSpace(void)+31p ...
UNDEF:00000CB8                 extrn __RTC_Shutdown:near
UNDEF:00000CB8                                         ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
UNDEF:00000CBC                 extrn __RTC_InitBase:near
UNDEF:00000CBC                                         ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
UNDEF:00000CC0 ; __stdcall MidFree(x)
UNDEF:00000CC0                 extrn _MidFree@4:near   ; CODE XREF: CMemBlockManager::FreeSpace(void)+14p
UNDEF:00000CC4 ; __stdcall HandlePtr_Close(x)
UNDEF:00000CC4                 extrn _HandlePtr_Close@4:near
UNDEF:00000CC4                                         ; CODE XREF: NWindows::NSynchronization::CSemaphore::Close(void)+12p
UNDEF:00000CC8 ; __stdcall Semaphore_Create(x, x, x)
UNDEF:00000CC8                 extrn _Semaphore_Create@12:near
UNDEF:00000CC8                                         ; CODE XREF: NWindows::NSynchronization::CSemaphore::Create(uint,uint)+1Ap
UNDEF:00000CCC                 extrn ___security_cookie:near
UNDEF:00000CCC                                         ; DATA XREF: CMemBlockManagerMt::AllocateBlock(void)+28r
UNDEF:00000CCC                                         ; CMemBlockManagerMt::FreeBlock(void *,bool)+25r
UNDEF:00000CD0                 extrn ___CxxFrameHandler3:near
UNDEF:00000CD0                                         ; CODE XREF: __ehhandler$?AllocateBlock@CMemBlockManagerMt@@QAEPAXXZ+16j
UNDEF:00000CD0                                         ; __ehhandler$?FreeBlock@CMemBlockManagerMt@@QAEXPAX_N@Z+16j
UNDEF:00000CD4 ; __fastcall __security_check_cookie(x)
UNDEF:00000CD4                 extrn @__security_check_cookie@4:near
UNDEF:00000CD4                                         ; CODE XREF: __ehhandler$?AllocateBlock@CMemBlockManagerMt@@QAEPAXXZ+Cp
UNDEF:00000CD4                                         ; __ehhandler$?FreeBlock@CMemBlockManagerMt@@QAEXPAX_N@Z+Cp
UNDEF:00000CD8 ; __fastcall _RTC_CheckStackVars(x, x)
UNDEF:00000CD8                 extrn @_RTC_CheckStackVars@8:near
UNDEF:00000CD8                                         ; CODE XREF: CMemBlockManagerMt::AllocateBlock(void)+79p
UNDEF:00000CD8                                         ; CMemBlockManagerMt::FreeBlock(void *,bool)+8Fp
UNDEF:00000CDC ; void __stdcall EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
UNDEF:00000CDC                 extrn __imp__EnterCriticalSection@4:near
UNDEF:00000CDC                                         ; CODE XREF: NWindows::NSynchronization::CCriticalSection::Enter(void)+15p
UNDEF:00000CDC                                         ; DATA XREF: NWindows::NSynchronization::CCriticalSection::Enter(void)+15r
UNDEF:00000CE0 ; void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
UNDEF:00000CE0                 extrn __imp__LeaveCriticalSection@4:near
UNDEF:00000CE0                                         ; CODE XREF: NWindows::NSynchronization::CCriticalSection::Leave(void)+15p
UNDEF:00000CE0                                         ; DATA XREF: NWindows::NSynchronization::CCriticalSection::Leave(void)+15r
UNDEF:00000CE4 ; __stdcall Semaphore_Release1(x)
UNDEF:00000CE4                 extrn _Semaphore_Release1@4:near
UNDEF:00000CE4                                         ; CODE XREF: NWindows::NSynchronization::CSemaphore::Release(void)+12p
UNDEF:00000CE8 ; __int32 __stdcall WriteStream(struct ISequentialOutStream *, const void *, unsigned int)
UNDEF:00000CE8                 extrn ?WriteStream@@YGJPAUISequentialOutStream@@PBXI@Z:near
UNDEF:00000CE8                                         ; CODE XREF: CMemBlocks::WriteToStream(uint,ISequentialOutStream *)+ABp
UNDEF:00000CEC ; __stdcall Semaphore_ReleaseN(x, x)
UNDEF:00000CEC                 extrn _Semaphore_ReleaseN@8:near
UNDEF:00000CEC                                         ; CODE XREF: NWindows::NSynchronization::CSemaphore::Release(uint)+16p
UNDEF:00000CF0 ; void __cdecl operator delete(void *)
UNDEF:00000CF0                 extrn ??3@YAXPAX@Z:near ; CODE XREF: CRecordVector<void *>::ClearAndFree(void)+23p
UNDEF:00000CF0                                         ; CRecordVector<void *>::ReserveOnePosition(void)+9Bp
UNDEF:00000CF4 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:00000CF4                 extrn _memcpy:near      ; CODE XREF: CRecordVector<void *>::ReserveOnePosition(void)+87p
UNDEF:00000CF8 ; void *__cdecl operator new(unsigned int)
UNDEF:00000CF8                 extrn ??2@YAPAXI@Z:near ; CODE XREF: CRecordVector<void *>::ReserveOnePosition(void)+59p
UNDEF:00000CF8
UNDEF:00000CF8
UNDEF:00000CF8                 end