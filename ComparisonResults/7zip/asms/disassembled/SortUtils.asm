.text:00000000 ;
.text:00000000 ; +-------------------------------------------------------------------------+
.text:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.text:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.text:00000000 ; |                      License info: 48-3677-7074-51                      |
.text:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.text:00000000 ; +-------------------------------------------------------------------------+
.text:00000000 ;
.text:00000000 ; Input MD5   : 0B68798BEB0A2BF48AE57F0EBBD19529
.text:00000000 ; Input CRC32 : E464BA56
.text:00000000
.text:00000000 ; File Name   : C:\workspace\7z1505-src\CPP\7zip\Bundles\Alone\Debug\SortUtils.obj
.text:00000000 ; Format      : COFF (X386MAGIC)
.text:00000000 ; includelib "uuid.lib"
.text:00000000 ; includelib "MSVCRTD"
.text:00000000 ; includelib "OLDNAMES"
.text:00000000
.text:00000000                 .686p
.text:00000000                 .mmx
.text:00000000                 .model flat
.text:00000000
.text:00000000 ; ===========================================================================
.text:00000000
.text:00000000 ; Segment type: Pure code
.text:00000000 ; Segment permissions: Read/Execute
.text:00000000 _text           segment para public 'CODE' use32
.text:00000000                 assume cs:_text
.text:00000000                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000000
.text:00000000 ; =============== S U B R O U T I N E =======================================
.text:00000000
.text:00000000 ; Attributes: bp-based frame
.text:00000000
.text:00000000 ; void __stdcall SortFileNames(class CObjectVector<class UString> const &, class CRecordVector<unsigned int> &)
.text:00000000                 public ?SortFileNames@@YGXABV?$CObjectVector@VUString@@@@AAV?$CRecordVector@I@@@Z
.text:00000000 ?SortFileNames@@YGXABV?$CObjectVector@VUString@@@@AAV?$CRecordVector@I@@@Z proc near
.text:00000000
.text:00000000 var_C           = dword ptr -0Ch
.text:00000000 var_8           = dword ptr -8
.text:00000000 var_4           = dword ptr -4
.text:00000000 arg_0           = dword ptr  8
.text:00000000 arg_4           = dword ptr  0Ch
.text:00000000
.text:00000000                 push    ebp
.text:00000001                 mov     ebp, esp
.text:00000003                 sub     esp, 0Ch
.text:00000006                 mov     [ebp+var_C], 0CCCCCCCCh
.text:0000000D                 mov     [ebp+var_8], 0CCCCCCCCh
.text:00000014                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000001B                 mov     ecx, [ebp+arg_0]
.text:0000001E                 call    ?Size@?$CObjectVector@VUString@@@@QBEIXZ ; CObjectVector<UString>::Size(void)
.text:00000023                 mov     [ebp+var_4], eax
.text:00000026                 mov     eax, [ebp+var_4]
.text:00000029                 push    eax
.text:0000002A                 mov     ecx, [ebp+arg_4]
.text:0000002D                 call    ?ClearAndSetSize@?$CRecordVector@I@@QAEXI@Z ; CRecordVector<uint>::ClearAndSetSize(uint)
.text:00000032                 push    0
.text:00000034                 mov     ecx, [ebp+arg_4]
.text:00000037                 call    ??A?$CRecordVector@I@@QAEAAII@Z ; CRecordVector<uint>::operator[](uint)
.text:0000003C                 mov     [ebp+var_8], eax
.text:0000003F                 mov     [ebp+var_C], 0
.text:00000046                 jmp     short loc_51
.text:00000048 ; ---------------------------------------------------------------------------
.text:00000048
.text:00000048 loc_48:                                 ; CODE XREF: SortFileNames(CObjectVector<UString> const &,CRecordVector<uint> &)+65j
.text:00000048                 mov     ecx, [ebp+var_C]
.text:0000004B                 add     ecx, 1
.text:0000004E                 mov     [ebp+var_C], ecx
.text:00000051
.text:00000051 loc_51:                                 ; CODE XREF: SortFileNames(CObjectVector<UString> const &,CRecordVector<uint> &)+46j
.text:00000051                 mov     edx, [ebp+var_C]
.text:00000054                 cmp     edx, [ebp+var_4]
.text:00000057                 jnb     short loc_67
.text:00000059                 mov     eax, [ebp+var_C]
.text:0000005C                 mov     ecx, [ebp+var_8]
.text:0000005F                 mov     edx, [ebp+var_C]
.text:00000062                 mov     [ecx+eax*4], edx
.text:00000065                 jmp     short loc_48
.text:00000067 ; ---------------------------------------------------------------------------
.text:00000067
.text:00000067 loc_67:                                 ; CODE XREF: SortFileNames(CObjectVector<UString> const &,CRecordVector<uint> &)+57j
.text:00000067                 mov     eax, [ebp+arg_0]
.text:0000006A                 push    eax
.text:0000006B                 push    offset ?CompareStrings@@YGHPBI0PAX@Z ; CompareStrings(uint const *,uint const *,void *)
.text:00000070                 mov     ecx, [ebp+arg_4]
.text:00000073                 call    ?Sort@?$CRecordVector@I@@QAEXP6GHPBI0PAX@Z1@Z ; CRecordVector<uint>::Sort(int (*)(uint const *,uint const *,void *),void *)
.text:00000078                 add     esp, 0Ch
.text:0000007B                 cmp     ebp, esp
.text:0000007D                 call    __RTC_CheckEsp
.text:00000082                 mov     esp, ebp
.text:00000084                 pop     ebp
.text:00000085                 retn    8
.text:00000085 ?SortFileNames@@YGXABV?$CObjectVector@VUString@@@@AAV?$CRecordVector@I@@@Z endp
.text:00000085
.text:00000085 ; ---------------------------------------------------------------------------
.text:00000088                 align 10h
.text:00000090
.text:00000090 ; =============== S U B R O U T I N E =======================================
.text:00000090
.text:00000090 ; Attributes: bp-based frame
.text:00000090
.text:00000090 ; int __stdcall CompareStrings(unsigned int const *, unsigned int const *, void *)
.text:00000090 ?CompareStrings@@YGHPBI0PAX@Z proc near ; DATA XREF: SortFileNames(CObjectVector<UString> const &,CRecordVector<uint> &)+6Bo
.text:00000090
.text:00000090 var_4           = dword ptr -4
.text:00000090 arg_0           = dword ptr  8
.text:00000090 arg_4           = dword ptr  0Ch
.text:00000090 arg_8           = dword ptr  10h
.text:00000090
.text:00000090                 push    ebp
.text:00000091                 mov     ebp, esp
.text:00000093                 push    ecx
.text:00000094                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000009B                 mov     eax, [ebp+arg_8]
.text:0000009E                 mov     [ebp+var_4], eax
.text:000000A1                 mov     ecx, [ebp+arg_4]
.text:000000A4                 mov     edx, [ecx]
.text:000000A6                 push    edx
.text:000000A7                 mov     ecx, [ebp+var_4]
.text:000000AA                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:000000AF                 mov     ecx, eax
.text:000000B1                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000000B6                 push    eax             ; wchar_t *
.text:000000B7                 mov     eax, [ebp+arg_0]
.text:000000BA                 mov     ecx, [eax]
.text:000000BC                 push    ecx
.text:000000BD                 mov     ecx, [ebp+var_4]
.text:000000C0                 call    ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z ; CObjectVector<UString>::operator[](uint)
.text:000000C5                 mov     ecx, eax
.text:000000C7                 call    ??BUString@@QBEPB_WXZ ; UString::operator wchar_t const *(void)
.text:000000CC                 push    eax             ; wchar_t *
.text:000000CD                 call    ?CompareFileNames@@YGHPB_W0@Z ; CompareFileNames(wchar_t const *,wchar_t const *)
.text:000000D2                 add     esp, 4
.text:000000D5                 cmp     ebp, esp
.text:000000D7                 call    __RTC_CheckEsp
.text:000000DC                 mov     esp, ebp
.text:000000DE                 pop     ebp
.text:000000DF                 retn    0Ch
.text:000000DF ?CompareStrings@@YGHPBI0PAX@Z endp
.text:000000DF
.text:000000DF ; ---------------------------------------------------------------------------
.text:000000E2                 align 4
.text:000000E2 _text           ends
.text:000000E2
.rtc$TMZ:000000E4 ; ===========================================================================
.rtc$TMZ:000000E4
.rtc$TMZ:000000E4 ; Segment type: Pure data
.rtc$TMZ:000000E4 ; Segment permissions: Read
.rtc$TMZ:000000E4 _rtc$TMZ        segment dword public 'DATA' use32
.rtc$TMZ:000000E4                 assume cs:_rtc$TMZ
.rtc$TMZ:000000E4                 ;org 0E4h
.rtc$TMZ:000000E4 ; COMDAT (pick any)
.rtc$TMZ:000000E4 __RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
.rtc$TMZ:000000E4 _rtc$TMZ        ends
.rtc$TMZ:000000E4
.rtc$IMZ:000000E8 ; ===========================================================================
.rtc$IMZ:000000E8
.rtc$IMZ:000000E8 ; Segment type: Pure data
.rtc$IMZ:000000E8 ; Segment permissions: Read
.rtc$IMZ:000000E8 _rtc$IMZ        segment dword public 'DATA' use32
.rtc$IMZ:000000E8                 assume cs:_rtc$IMZ
.rtc$IMZ:000000E8                 ;org 0E8h
.rtc$IMZ:000000E8 ; COMDAT (pick any)
.rtc$IMZ:000000E8 __RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
.rtc$IMZ:000000E8 _rtc$IMZ        ends
.rtc$IMZ:000000E8
.text:000000EC ; ===========================================================================
.text:000000EC
.text:000000EC ; Segment type: Pure code
.text:000000EC ; Segment permissions: Read/Execute
.text:000000EC _text           segment para public 'CODE' use32
.text:000000EC                 assume cs:_text
.text:000000EC                 ;org 0ECh
.text:000000EC ; COMDAT (pick any)
.text:000000EC                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000000EC
.text:000000EC ; =============== S U B R O U T I N E =======================================
.text:000000EC
.text:000000EC ; Attributes: bp-based frame
.text:000000EC
.text:000000EC ; public: __thiscall UString::operator wchar_t const *(void)const
.text:000000EC                 public ??BUString@@QBEPB_WXZ
.text:000000EC ??BUString@@QBEPB_WXZ proc near         ; CODE XREF: CompareStrings(uint const *,uint const *,void *)+21p
.text:000000EC                                         ; CompareStrings(uint const *,uint const *,void *)+37p
.text:000000EC
.text:000000EC var_4           = dword ptr -4
.text:000000EC
.text:000000EC                 push    ebp
.text:000000ED                 mov     ebp, esp
.text:000000EF                 push    ecx
.text:000000F0                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000000F7                 mov     [ebp+var_4], ecx
.text:000000FA                 mov     eax, [ebp+var_4]
.text:000000FD                 mov     eax, [eax]
.text:000000FF                 mov     esp, ebp
.text:00000101                 pop     ebp
.text:00000102                 retn
.text:00000102 ??BUString@@QBEPB_WXZ endp
.text:00000102
.text:00000102 ; ---------------------------------------------------------------------------
.text:00000103                 align 4
.text:00000103 _text           ends
.text:00000103
.text:00000104 ; ===========================================================================
.text:00000104
.text:00000104 ; Segment type: Pure code
.text:00000104 ; Segment permissions: Read/Execute
.text:00000104 _text           segment para public 'CODE' use32
.text:00000104                 assume cs:_text
.text:00000104                 ;org 104h
.text:00000104 ; COMDAT (pick any)
.text:00000104                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000104
.text:00000104 ; =============== S U B R O U T I N E =======================================
.text:00000104
.text:00000104 ; Attributes: bp-based frame
.text:00000104
.text:00000104 ; public: unsigned int __thiscall CObjectVector<class UString>::Size(void)const
.text:00000104                 public ?Size@?$CObjectVector@VUString@@@@QBEIXZ
.text:00000104 ?Size@?$CObjectVector@VUString@@@@QBEIXZ proc near
.text:00000104                                         ; CODE XREF: SortFileNames(CObjectVector<UString> const &,CRecordVector<uint> &)+1Ep
.text:00000104
.text:00000104 var_4           = dword ptr -4
.text:00000104
.text:00000104                 push    ebp
.text:00000105                 mov     ebp, esp
.text:00000107                 push    ecx
.text:00000108                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000010F                 mov     [ebp+var_4], ecx
.text:00000112                 mov     ecx, [ebp+var_4]
.text:00000115                 call    ?Size@?$CRecordVector@PAX@@QBEIXZ ; CRecordVector<void *>::Size(void)
.text:0000011A                 add     esp, 4
.text:0000011D                 cmp     ebp, esp
.text:0000011F                 call    __RTC_CheckEsp
.text:00000124                 mov     esp, ebp
.text:00000126                 pop     ebp
.text:00000127                 retn
.text:00000127 ?Size@?$CObjectVector@VUString@@@@QBEIXZ endp
.text:00000127
.text:00000127 _text           ends
.text:00000127
.text:00000128 ; ===========================================================================
.text:00000128
.text:00000128 ; Segment type: Pure code
.text:00000128 ; Segment permissions: Read/Execute
.text:00000128 _text           segment para public 'CODE' use32
.text:00000128                 assume cs:_text
.text:00000128                 ;org 128h
.text:00000128 ; COMDAT (pick any)
.text:00000128                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000128
.text:00000128 ; =============== S U B R O U T I N E =======================================
.text:00000128
.text:00000128 ; Attributes: bp-based frame
.text:00000128
.text:00000128 ; public: class UString const & __thiscall CObjectVector<class UString>::operator[](unsigned int)const
.text:00000128                 public ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z
.text:00000128 ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z proc near
.text:00000128                                         ; CODE XREF: CompareStrings(uint const *,uint const *,void *)+1Ap
.text:00000128                                         ; CompareStrings(uint const *,uint const *,void *)+30p
.text:00000128
.text:00000128 var_4           = dword ptr -4
.text:00000128 arg_0           = dword ptr  8
.text:00000128
.text:00000128                 push    ebp
.text:00000129                 mov     ebp, esp
.text:0000012B                 push    ecx
.text:0000012C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000133                 mov     [ebp+var_4], ecx
.text:00000136                 mov     eax, [ebp+arg_0]
.text:00000139                 push    eax
.text:0000013A                 mov     ecx, [ebp+var_4]
.text:0000013D                 call    ??A?$CRecordVector@PAX@@QBEABQAXI@Z ; CRecordVector<void *>::operator[](uint)
.text:00000142                 mov     eax, [eax]
.text:00000144                 add     esp, 4
.text:00000147                 cmp     ebp, esp
.text:00000149                 call    __RTC_CheckEsp
.text:0000014E                 mov     esp, ebp
.text:00000150                 pop     ebp
.text:00000151                 retn    4
.text:00000151 ??A?$CObjectVector@VUString@@@@QBEABVUString@@I@Z endp
.text:00000151
.text:00000151 _text           ends
.text:00000151
.text:00000154 ; ===========================================================================
.text:00000154
.text:00000154 ; Segment type: Pure code
.text:00000154 ; Segment permissions: Read/Execute
.text:00000154 _text           segment para public 'CODE' use32
.text:00000154                 assume cs:_text
.text:00000154                 ;org 154h
.text:00000154 ; COMDAT (pick any)
.text:00000154                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000154
.text:00000154 ; =============== S U B R O U T I N E =======================================
.text:00000154
.text:00000154 ; Attributes: bp-based frame
.text:00000154
.text:00000154 ; public: void __thiscall CRecordVector<unsigned int>::ClearAndSetSize(unsigned int)
.text:00000154                 public ?ClearAndSetSize@?$CRecordVector@I@@QAEXI@Z
.text:00000154 ?ClearAndSetSize@?$CRecordVector@I@@QAEXI@Z proc near
.text:00000154                                         ; CODE XREF: SortFileNames(CObjectVector<UString> const &,CRecordVector<uint> &)+2Dp
.text:00000154
.text:00000154 var_4           = dword ptr -4
.text:00000154 arg_0           = dword ptr  8
.text:00000154
.text:00000154                 push    ebp
.text:00000155                 mov     ebp, esp
.text:00000157                 push    ecx
.text:00000158                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000015F                 mov     [ebp+var_4], ecx
.text:00000162                 mov     eax, [ebp+arg_0]
.text:00000165                 push    eax
.text:00000166                 mov     ecx, [ebp+var_4]
.text:00000169                 call    ?ClearAndReserve@?$CRecordVector@I@@QAEXI@Z ; CRecordVector<uint>::ClearAndReserve(uint)
.text:0000016E                 mov     ecx, [ebp+var_4]
.text:00000171                 mov     edx, [ebp+arg_0]
.text:00000174                 mov     [ecx+4], edx
.text:00000177                 add     esp, 4
.text:0000017A                 cmp     ebp, esp
.text:0000017C                 call    __RTC_CheckEsp
.text:00000181                 mov     esp, ebp
.text:00000183                 pop     ebp
.text:00000184                 retn    4
.text:00000184 ?ClearAndSetSize@?$CRecordVector@I@@QAEXI@Z endp
.text:00000184
.text:00000184 ; ---------------------------------------------------------------------------
.text:00000187                 align 4
.text:00000187 _text           ends
.text:00000187
.text:00000188 ; ===========================================================================
.text:00000188
.text:00000188 ; Segment type: Pure code
.text:00000188 ; Segment permissions: Read/Execute
.text:00000188 _text           segment para public 'CODE' use32
.text:00000188                 assume cs:_text
.text:00000188                 ;org 188h
.text:00000188 ; COMDAT (pick any)
.text:00000188                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000188
.text:00000188 ; =============== S U B R O U T I N E =======================================
.text:00000188
.text:00000188 ; Attributes: bp-based frame
.text:00000188
.text:00000188 ; public: unsigned int & __thiscall CRecordVector<unsigned int>::operator[](unsigned int)
.text:00000188                 public ??A?$CRecordVector@I@@QAEAAII@Z
.text:00000188 ??A?$CRecordVector@I@@QAEAAII@Z proc near
.text:00000188                                         ; CODE XREF: SortFileNames(CObjectVector<UString> const &,CRecordVector<uint> &)+37p
.text:00000188
.text:00000188 var_4           = dword ptr -4
.text:00000188 arg_0           = dword ptr  8
.text:00000188
.text:00000188                 push    ebp
.text:00000189                 mov     ebp, esp
.text:0000018B                 push    ecx
.text:0000018C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000193                 mov     [ebp+var_4], ecx
.text:00000196                 mov     eax, [ebp+var_4]
.text:00000199                 mov     ecx, [eax]
.text:0000019B                 mov     edx, [ebp+arg_0]
.text:0000019E                 lea     eax, [ecx+edx*4]
.text:000001A1                 mov     esp, ebp
.text:000001A3                 pop     ebp
.text:000001A4                 retn    4
.text:000001A4 ??A?$CRecordVector@I@@QAEAAII@Z endp
.text:000001A4
.text:000001A4 ; ---------------------------------------------------------------------------
.text:000001A7                 align 4
.text:000001A7 _text           ends
.text:000001A7
.text:000001A8 ; ===========================================================================
.text:000001A8
.text:000001A8 ; Segment type: Pure code
.text:000001A8 ; Segment permissions: Read/Execute
.text:000001A8 _text           segment para public 'CODE' use32
.text:000001A8                 assume cs:_text
.text:000001A8                 ;org 1A8h
.text:000001A8 ; COMDAT (pick any)
.text:000001A8                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000001A8
.text:000001A8 ; =============== S U B R O U T I N E =======================================
.text:000001A8
.text:000001A8 ; Attributes: bp-based frame
.text:000001A8
.text:000001A8 ; public: void __thiscall CRecordVector<unsigned int>::Sort(int (__stdcall *)(unsigned int const *, unsigned int const *, void *), void *)
.text:000001A8                 public ?Sort@?$CRecordVector@I@@QAEXP6GHPBI0PAX@Z1@Z
.text:000001A8 ?Sort@?$CRecordVector@I@@QAEXP6GHPBI0PAX@Z1@Z proc near
.text:000001A8                                         ; CODE XREF: SortFileNames(CObjectVector<UString> const &,CRecordVector<uint> &)+73p
.text:000001A8
.text:000001A8 var_14          = dword ptr -14h
.text:000001A8 var_10          = dword ptr -10h
.text:000001A8 var_C           = dword ptr -0Ch
.text:000001A8 var_8           = dword ptr -8
.text:000001A8 var_4           = dword ptr -4
.text:000001A8 arg_0           = dword ptr  8
.text:000001A8 arg_4           = dword ptr  0Ch
.text:000001A8
.text:000001A8                 push    ebp
.text:000001A9                 mov     ebp, esp
.text:000001AB                 sub     esp, 14h
.text:000001AE                 mov     eax, 0CCCCCCCCh
.text:000001B3                 mov     [ebp+var_14], eax
.text:000001B6                 mov     [ebp+var_10], eax
.text:000001B9                 mov     [ebp+var_C], eax
.text:000001BC                 mov     [ebp+var_8], eax
.text:000001BF                 mov     [ebp+var_4], eax
.text:000001C2                 mov     [ebp+var_4], ecx
.text:000001C5                 mov     eax, [ebp+var_4]
.text:000001C8                 mov     ecx, [eax+4]
.text:000001CB                 mov     [ebp+var_8], ecx
.text:000001CE                 cmp     [ebp+var_8], 1
.text:000001D2                 ja      short loc_1D9
.text:000001D4                 jmp     loc_25D
.text:000001D9 ; ---------------------------------------------------------------------------
.text:000001D9
.text:000001D9 loc_1D9:                                ; CODE XREF: CRecordVector<uint>::Sort(int (*)(uint const *,uint const *,void *),void *)+2Aj
.text:000001D9                 mov     ecx, [ebp+var_4]
.text:000001DC                 call    ?Front@?$CRecordVector@I@@QAEAAIXZ ; CRecordVector<uint>::Front(void)
.text:000001E1                 sub     eax, 4
.text:000001E4                 mov     [ebp+var_C], eax
.text:000001E7                 mov     edx, [ebp+var_8]
.text:000001EA                 shr     edx, 1
.text:000001EC                 mov     [ebp+var_10], edx
.text:000001EF
.text:000001EF loc_1EF:                                ; CODE XREF: CRecordVector<uint>::Sort(int (*)(uint const *,uint const *,void *),void *)+69j
.text:000001EF                 mov     eax, [ebp+arg_4]
.text:000001F2                 push    eax
.text:000001F3                 mov     ecx, [ebp+arg_0]
.text:000001F6                 push    ecx
.text:000001F7                 mov     edx, [ebp+var_8]
.text:000001FA                 push    edx
.text:000001FB                 mov     eax, [ebp+var_10]
.text:000001FE                 push    eax
.text:000001FF                 mov     ecx, [ebp+var_C]
.text:00000202                 push    ecx
.text:00000203                 call    ?SortRefDown@?$CRecordVector@I@@SGXPAIIIP6GHPBI1PAX@Z2@Z ; CRecordVector<uint>::SortRefDown(uint *,uint,uint,int (*)(uint const *,uint const *,void *),void *)
.text:00000208                 mov     edx, [ebp+var_10]
.text:0000020B                 sub     edx, 1
.text:0000020E                 mov     [ebp+var_10], edx
.text:00000211                 jnz     short loc_1EF
.text:00000213
.text:00000213 loc_213:                                ; CODE XREF: CRecordVector<uint>::Sort(int (*)(uint const *,uint const *,void *),void *)+B3j
.text:00000213                 mov     eax, [ebp+var_8]
.text:00000216                 mov     ecx, [ebp+var_C]
.text:00000219                 mov     edx, [ecx+eax*4]
.text:0000021C                 mov     [ebp+var_14], edx
.text:0000021F                 mov     eax, [ebp+var_8]
.text:00000222                 mov     ecx, [ebp+var_C]
.text:00000225                 mov     edx, [ebp+var_C]
.text:00000228                 mov     edx, [edx+4]
.text:0000022B                 mov     [ecx+eax*4], edx
.text:0000022E                 mov     eax, [ebp+var_8]
.text:00000231                 sub     eax, 1
.text:00000234                 mov     [ebp+var_8], eax
.text:00000237                 mov     ecx, [ebp+var_C]
.text:0000023A                 mov     edx, [ebp+var_14]
.text:0000023D                 mov     [ecx+4], edx
.text:00000240                 mov     eax, [ebp+arg_4]
.text:00000243                 push    eax
.text:00000244                 mov     ecx, [ebp+arg_0]
.text:00000247                 push    ecx
.text:00000248                 mov     edx, [ebp+var_8]
.text:0000024B                 push    edx
.text:0000024C                 push    1
.text:0000024E                 mov     eax, [ebp+var_C]
.text:00000251                 push    eax
.text:00000252                 call    ?SortRefDown@?$CRecordVector@I@@SGXPAIIIP6GHPBI1PAX@Z2@Z ; CRecordVector<uint>::SortRefDown(uint *,uint,uint,int (*)(uint const *,uint const *,void *),void *)
.text:00000257                 cmp     [ebp+var_8], 1
.text:0000025B                 ja      short loc_213
.text:0000025D
.text:0000025D loc_25D:                                ; CODE XREF: CRecordVector<uint>::Sort(int (*)(uint const *,uint const *,void *),void *)+2Cj
.text:0000025D                 add     esp, 14h
.text:00000260                 cmp     ebp, esp
.text:00000262                 call    __RTC_CheckEsp
.text:00000267                 mov     esp, ebp
.text:00000269                 pop     ebp
.text:0000026A                 retn    8
.text:0000026A ?Sort@?$CRecordVector@I@@QAEXP6GHPBI0PAX@Z1@Z endp
.text:0000026A
.text:0000026A ; ---------------------------------------------------------------------------
.text:0000026D                 align 10h
.text:0000026D _text           ends
.text:0000026D
.text:00000270 ; ===========================================================================
.text:00000270
.text:00000270 ; Segment type: Pure code
.text:00000270 ; Segment permissions: Read/Execute
.text:00000270 _text           segment para public 'CODE' use32
.text:00000270                 assume cs:_text
.text:00000270                 ;org 270h
.text:00000270 ; COMDAT (pick any)
.text:00000270                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000270
.text:00000270 ; =============== S U B R O U T I N E =======================================
.text:00000270
.text:00000270 ; Attributes: bp-based frame
.text:00000270
.text:00000270 ; public: unsigned int __thiscall CRecordVector<void *>::Size(void)const
.text:00000270                 public ?Size@?$CRecordVector@PAX@@QBEIXZ
.text:00000270 ?Size@?$CRecordVector@PAX@@QBEIXZ proc near
.text:00000270                                         ; CODE XREF: CObjectVector<UString>::Size(void)+11p
.text:00000270
.text:00000270 var_4           = dword ptr -4
.text:00000270
.text:00000270                 push    ebp
.text:00000271                 mov     ebp, esp
.text:00000273                 push    ecx
.text:00000274                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000027B                 mov     [ebp+var_4], ecx
.text:0000027E                 mov     eax, [ebp+var_4]
.text:00000281                 mov     eax, [eax+4]
.text:00000284                 mov     esp, ebp
.text:00000286                 pop     ebp
.text:00000287                 retn
.text:00000287 ?Size@?$CRecordVector@PAX@@QBEIXZ endp
.text:00000287
.text:00000287 _text           ends
.text:00000287
.text:00000288 ; ===========================================================================
.text:00000288
.text:00000288 ; Segment type: Pure code
.text:00000288 ; Segment permissions: Read/Execute
.text:00000288 _text           segment para public 'CODE' use32
.text:00000288                 assume cs:_text
.text:00000288                 ;org 288h
.text:00000288 ; COMDAT (pick any)
.text:00000288                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000288
.text:00000288 ; =============== S U B R O U T I N E =======================================
.text:00000288
.text:00000288 ; Attributes: bp-based frame
.text:00000288
.text:00000288 ; public: void * const & __thiscall CRecordVector<void *>::operator[](unsigned int)const
.text:00000288                 public ??A?$CRecordVector@PAX@@QBEABQAXI@Z
.text:00000288 ??A?$CRecordVector@PAX@@QBEABQAXI@Z proc near
.text:00000288                                         ; CODE XREF: CObjectVector<UString>::operator[](uint)+15p
.text:00000288
.text:00000288 var_4           = dword ptr -4
.text:00000288 arg_0           = dword ptr  8
.text:00000288
.text:00000288                 push    ebp
.text:00000289                 mov     ebp, esp
.text:0000028B                 push    ecx
.text:0000028C                 mov     [ebp+var_4], 0CCCCCCCCh
.text:00000293                 mov     [ebp+var_4], ecx
.text:00000296                 mov     eax, [ebp+var_4]
.text:00000299                 mov     ecx, [eax]
.text:0000029B                 mov     edx, [ebp+arg_0]
.text:0000029E                 lea     eax, [ecx+edx*4]
.text:000002A1                 mov     esp, ebp
.text:000002A3                 pop     ebp
.text:000002A4                 retn    4
.text:000002A4 ??A?$CRecordVector@PAX@@QBEABQAXI@Z endp
.text:000002A4
.text:000002A4 ; ---------------------------------------------------------------------------
.text:000002A7                 align 4
.text:000002A7 _text           ends
.text:000002A7
.text:000002A8 ; ===========================================================================
.text:000002A8
.text:000002A8 ; Segment type: Pure code
.text:000002A8 ; Segment permissions: Read/Execute
.text:000002A8 _text           segment para public 'CODE' use32
.text:000002A8                 assume cs:_text
.text:000002A8                 ;org 2A8h
.text:000002A8 ; COMDAT (pick any)
.text:000002A8                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:000002A8
.text:000002A8 ; =============== S U B R O U T I N E =======================================
.text:000002A8
.text:000002A8 ; Attributes: bp-based frame
.text:000002A8
.text:000002A8 ; public: void __thiscall CRecordVector<unsigned int>::ClearAndReserve(unsigned int)
.text:000002A8                 public ?ClearAndReserve@?$CRecordVector@I@@QAEXI@Z
.text:000002A8 ?ClearAndReserve@?$CRecordVector@I@@QAEXI@Z proc near
.text:000002A8                                         ; CODE XREF: CRecordVector<uint>::ClearAndSetSize(uint)+15p
.text:000002A8
.text:000002A8 var_C           = dword ptr -0Ch
.text:000002A8 var_8           = dword ptr -8
.text:000002A8 var_4           = dword ptr -4
.text:000002A8 arg_0           = dword ptr  8
.text:000002A8
.text:000002A8                 push    ebp
.text:000002A9                 mov     ebp, esp
.text:000002AB                 sub     esp, 0Ch
.text:000002AE                 mov     [ebp+var_C], 0CCCCCCCCh
.text:000002B5                 mov     [ebp+var_8], 0CCCCCCCCh
.text:000002BC                 mov     [ebp+var_4], 0CCCCCCCCh
.text:000002C3                 mov     [ebp+var_4], ecx
.text:000002C6                 mov     ecx, [ebp+var_4]
.text:000002C9                 call    ?Clear@?$CRecordVector@I@@QAEXXZ ; CRecordVector<uint>::Clear(void)
.text:000002CE                 mov     eax, [ebp+var_4]
.text:000002D1                 mov     ecx, [ebp+arg_0]
.text:000002D4                 cmp     ecx, [eax+8]
.text:000002D7                 jbe     short loc_330
.text:000002D9                 mov     edx, [ebp+var_4]
.text:000002DC                 mov     eax, [edx]
.text:000002DE                 mov     [ebp+var_8], eax
.text:000002E1                 mov     ecx, [ebp+var_8]
.text:000002E4                 push    ecx             ; void *
.text:000002E5                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:000002EA                 add     esp, 4
.text:000002ED                 mov     edx, [ebp+var_4]
.text:000002F0                 mov     dword ptr [edx], 0
.text:000002F6                 mov     eax, [ebp+var_4]
.text:000002F9                 mov     dword ptr [eax+8], 0
.text:00000300                 xor     ecx, ecx
.text:00000302                 mov     eax, [ebp+arg_0]
.text:00000305                 mov     edx, 4
.text:0000030A                 mul     edx
.text:0000030C                 seto    cl
.text:0000030F                 neg     ecx
.text:00000311                 or      ecx, eax
.text:00000313                 push    ecx             ; unsigned int
.text:00000314                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00000319                 add     esp, 4
.text:0000031C                 mov     [ebp+var_C], eax
.text:0000031F                 mov     eax, [ebp+var_4]
.text:00000322                 mov     ecx, [ebp+var_C]
.text:00000325                 mov     [eax], ecx
.text:00000327                 mov     edx, [ebp+var_4]
.text:0000032A                 mov     eax, [ebp+arg_0]
.text:0000032D                 mov     [edx+8], eax
.text:00000330
.text:00000330 loc_330:                                ; CODE XREF: CRecordVector<uint>::ClearAndReserve(uint)+2Fj
.text:00000330                 add     esp, 0Ch
.text:00000333                 cmp     ebp, esp
.text:00000335                 call    __RTC_CheckEsp
.text:0000033A                 mov     esp, ebp
.text:0000033C                 pop     ebp
.text:0000033D                 retn    4
.text:0000033D ?ClearAndReserve@?$CRecordVector@I@@QAEXI@Z endp
.text:0000033D
.text:0000033D _text           ends
.text:0000033D
.text:00000340 ; ===========================================================================
.text:00000340
.text:00000340 ; Segment type: Pure code
.text:00000340 ; Segment permissions: Read/Execute
.text:00000340 _text           segment para public 'CODE' use32
.text:00000340                 assume cs:_text
.text:00000340                 ;org 340h
.text:00000340 ; COMDAT (pick any)
.text:00000340                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000340
.text:00000340 ; =============== S U B R O U T I N E =======================================
.text:00000340
.text:00000340 ; Attributes: bp-based frame
.text:00000340
.text:00000340 ; public: unsigned int & __thiscall CRecordVector<unsigned int>::Front(void)
.text:00000340                 public ?Front@?$CRecordVector@I@@QAEAAIXZ
.text:00000340 ?Front@?$CRecordVector@I@@QAEAAIXZ proc near
.text:00000340                                         ; CODE XREF: CRecordVector<uint>::Sort(int (*)(uint const *,uint const *,void *),void *)+34p
.text:00000340
.text:00000340 var_4           = dword ptr -4
.text:00000340
.text:00000340                 push    ebp
.text:00000341                 mov     ebp, esp
.text:00000343                 push    ecx
.text:00000344                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000034B                 mov     [ebp+var_4], ecx
.text:0000034E                 mov     eax, [ebp+var_4]
.text:00000351                 mov     eax, [eax]
.text:00000353                 mov     esp, ebp
.text:00000355                 pop     ebp
.text:00000356                 retn
.text:00000356 ?Front@?$CRecordVector@I@@QAEAAIXZ endp
.text:00000356
.text:00000356 ; ---------------------------------------------------------------------------
.text:00000357                 align 4
.text:00000357 _text           ends
.text:00000357
.text:00000358 ; ===========================================================================
.text:00000358
.text:00000358 ; Segment type: Pure code
.text:00000358 ; Segment permissions: Read/Execute
.text:00000358 _text           segment para public 'CODE' use32
.text:00000358                 assume cs:_text
.text:00000358                 ;org 358h
.text:00000358 ; COMDAT (pick any)
.text:00000358                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000358
.text:00000358 ; =============== S U B R O U T I N E =======================================
.text:00000358
.text:00000358 ; Attributes: bp-based frame
.text:00000358
.text:00000358 ; public: static void __stdcall CRecordVector<unsigned int>::SortRefDown(unsigned int *, unsigned int, unsigned int, int (__stdcall *)(unsigned int const *, unsigned int const *, void *), void *)
.text:00000358                 public ?SortRefDown@?$CRecordVector@I@@SGXPAIIIP6GHPBI1PAX@Z2@Z
.text:00000358 ?SortRefDown@?$CRecordVector@I@@SGXPAIIIP6GHPBI1PAX@Z2@Z proc near
.text:00000358                                         ; CODE XREF: CRecordVector<uint>::Sort(int (*)(uint const *,uint const *,void *),void *)+5Bp
.text:00000358                                         ; CRecordVector<uint>::Sort(int (*)(uint const *,uint const *,void *),void *)+AAp
.text:00000358
.text:00000358 var_10          = dword ptr -10h
.text:00000358 var_C           = dword ptr -0Ch
.text:00000358 var_8           = dword ptr -8
.text:00000358 var_4           = dword ptr -4
.text:00000358 arg_0           = dword ptr  8
.text:00000358 arg_4           = dword ptr  0Ch
.text:00000358 arg_8           = dword ptr  10h
.text:00000358 arg_C           = dword ptr  14h
.text:00000358 arg_10          = dword ptr  18h
.text:00000358
.text:00000358                 push    ebp
.text:00000359                 mov     ebp, esp
.text:0000035B                 sub     esp, 10h
.text:0000035E                 push    esi
.text:0000035F                 mov     eax, 0CCCCCCCCh
.text:00000364                 mov     [ebp+var_10], eax
.text:00000367                 mov     [ebp+var_C], eax
.text:0000036A                 mov     [ebp+var_8], eax
.text:0000036D                 mov     [ebp+var_4], eax
.text:00000370                 mov     eax, [ebp+arg_4]
.text:00000373                 mov     ecx, [ebp+arg_0]
.text:00000376                 mov     edx, [ecx+eax*4]
.text:00000379                 mov     [ebp+var_8], edx
.text:0000037C
.text:0000037C loc_37C:                                ; CODE XREF: CRecordVector<uint>::SortRefDown(uint *,uint,uint,int (*)(uint const *,uint const *,void *),void *)+ACj
.text:0000037C                 mov     eax, [ebp+arg_4]
.text:0000037F                 shl     eax, 1
.text:00000381                 mov     [ebp+var_10], eax
.text:00000384                 mov     ecx, [ebp+var_10]
.text:00000387                 cmp     ecx, [ebp+arg_8]
.text:0000038A                 jbe     short loc_38E
.text:0000038C                 jmp     short loc_409
.text:0000038E ; ---------------------------------------------------------------------------
.text:0000038E
.text:0000038E loc_38E:                                ; CODE XREF: CRecordVector<uint>::SortRefDown(uint *,uint,uint,int (*)(uint const *,uint const *,void *),void *)+32j
.text:0000038E                 mov     edx, [ebp+var_10]
.text:00000391                 cmp     edx, [ebp+arg_8]
.text:00000394                 jnb     short loc_3C8
.text:00000396                 mov     esi, esp
.text:00000398                 mov     eax, [ebp+arg_10]
.text:0000039B                 push    eax
.text:0000039C                 mov     ecx, [ebp+var_10]
.text:0000039F                 mov     edx, [ebp+arg_0]
.text:000003A2                 lea     eax, [edx+ecx*4]
.text:000003A5                 push    eax
.text:000003A6                 mov     ecx, [ebp+var_10]
.text:000003A9                 mov     edx, [ebp+arg_0]
.text:000003AC                 lea     eax, [edx+ecx*4+4]
.text:000003B0                 push    eax
.text:000003B1                 call    [ebp+arg_C]
.text:000003B4                 cmp     esi, esp
.text:000003B6                 call    __RTC_CheckEsp
.text:000003BB                 test    eax, eax
.text:000003BD                 jle     short loc_3C8
.text:000003BF                 mov     ecx, [ebp+var_10]
.text:000003C2                 add     ecx, 1
.text:000003C5                 mov     [ebp+var_10], ecx
.text:000003C8
.text:000003C8 loc_3C8:                                ; CODE XREF: CRecordVector<uint>::SortRefDown(uint *,uint,uint,int (*)(uint const *,uint const *,void *),void *)+3Cj
.text:000003C8                                         ; CRecordVector<uint>::SortRefDown(uint *,uint,uint,int (*)(uint const *,uint const *,void *),void *)+65j
.text:000003C8                 mov     esi, esp
.text:000003CA                 mov     edx, [ebp+arg_10]
.text:000003CD                 push    edx
.text:000003CE                 mov     eax, [ebp+var_10]
.text:000003D1                 mov     ecx, [ebp+arg_0]
.text:000003D4                 lea     edx, [ecx+eax*4]
.text:000003D7                 push    edx
.text:000003D8                 lea     eax, [ebp+var_8]
.text:000003DB                 push    eax
.text:000003DC                 call    [ebp+arg_C]
.text:000003DF                 cmp     esi, esp
.text:000003E1                 call    __RTC_CheckEsp
.text:000003E6                 test    eax, eax
.text:000003E8                 jl      short loc_3EC
.text:000003EA                 jmp     short loc_409
.text:000003EC ; ---------------------------------------------------------------------------
.text:000003EC
.text:000003EC loc_3EC:                                ; CODE XREF: CRecordVector<uint>::SortRefDown(uint *,uint,uint,int (*)(uint const *,uint const *,void *),void *)+90j
.text:000003EC                 mov     ecx, [ebp+arg_4]
.text:000003EF                 mov     edx, [ebp+arg_0]
.text:000003F2                 mov     eax, [ebp+var_10]
.text:000003F5                 mov     esi, [ebp+arg_0]
.text:000003F8                 mov     eax, [esi+eax*4]
.text:000003FB                 mov     [edx+ecx*4], eax
.text:000003FE                 mov     ecx, [ebp+var_10]
.text:00000401                 mov     [ebp+arg_4], ecx
.text:00000404                 jmp     loc_37C
.text:00000409 ; ---------------------------------------------------------------------------
.text:00000409
.text:00000409 loc_409:                                ; CODE XREF: CRecordVector<uint>::SortRefDown(uint *,uint,uint,int (*)(uint const *,uint const *,void *),void *)+34j
.text:00000409                                         ; CRecordVector<uint>::SortRefDown(uint *,uint,uint,int (*)(uint const *,uint const *,void *),void *)+92j
.text:00000409                 mov     edx, [ebp+arg_4]
.text:0000040C                 mov     eax, [ebp+arg_0]
.text:0000040F                 mov     ecx, [ebp+var_8]
.text:00000412                 mov     [eax+edx*4], ecx
.text:00000415                 push    edx
.text:00000416                 mov     ecx, ebp
.text:00000418                 push    eax
.text:00000419                 lea     edx, $LN10
.text:0000041F                 call    @_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
.text:00000424                 pop     eax
.text:00000425                 pop     edx
.text:00000426                 pop     esi
.text:00000427                 add     esp, 10h
.text:0000042A                 cmp     ebp, esp
.text:0000042C                 call    __RTC_CheckEsp
.text:00000431                 mov     esp, ebp
.text:00000433                 pop     ebp
.text:00000434                 retn    14h
.text:00000434 ?SortRefDown@?$CRecordVector@I@@SGXPAIIIP6GHPBI1PAX@Z2@Z endp
.text:00000434
.text:00000434 ; ---------------------------------------------------------------------------
.text:00000437                 align 4
.text:00000438 $LN10           dd 1                    ; DATA XREF: CRecordVector<uint>::SortRefDown(uint *,uint,uint,int (*)(uint const *,uint const *,void *),void *)+C1o
.text:0000043C                 dd offset $LN9
.text:00000440 $LN9            dd 0FFFFFFF8h, 4        ; DATA XREF: .text:0000043Co
.text:00000448                 dd offset $LN8          ; "temp"
.text:0000044C $LN8            db 'temp',0             ; DATA XREF: .text:00000448o
.text:00000451                 align 4
.text:00000451 _text           ends
.text:00000451
.text:00000454 ; ===========================================================================
.text:00000454
.text:00000454 ; Segment type: Pure code
.text:00000454 ; Segment permissions: Read/Execute
.text:00000454 _text           segment para public 'CODE' use32
.text:00000454                 assume cs:_text
.text:00000454                 ;org 454h
.text:00000454 ; COMDAT (pick any)
.text:00000454                 assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing, gs:nothing
.text:00000454
.text:00000454 ; =============== S U B R O U T I N E =======================================
.text:00000454
.text:00000454 ; Attributes: bp-based frame
.text:00000454
.text:00000454 ; public: void __thiscall CRecordVector<unsigned int>::Clear(void)
.text:00000454                 public ?Clear@?$CRecordVector@I@@QAEXXZ
.text:00000454 ?Clear@?$CRecordVector@I@@QAEXXZ proc near
.text:00000454                                         ; CODE XREF: CRecordVector<uint>::ClearAndReserve(uint)+21p
.text:00000454
.text:00000454 var_4           = dword ptr -4
.text:00000454
.text:00000454                 push    ebp
.text:00000455                 mov     ebp, esp
.text:00000457                 push    ecx
.text:00000458                 mov     [ebp+var_4], 0CCCCCCCCh
.text:0000045F                 mov     [ebp+var_4], ecx
.text:00000462                 mov     eax, [ebp+var_4]
.text:00000465                 mov     dword ptr [eax+4], 0
.text:0000046C                 mov     esp, ebp
.text:0000046E                 pop     ebp
.text:0000046F                 retn
.text:0000046F ?Clear@?$CRecordVector@I@@QAEXXZ endp
.text:0000046F
.text:0000046F _text           ends
.text:0000046F
UNDEF:00000470 ; ===========================================================================
UNDEF:00000470
UNDEF:00000470 ; Segment type: Externs
UNDEF:00000470 ; UNDEF
UNDEF:00000470                 extrn __RTC_CheckEsp:near
UNDEF:00000470                                         ; CODE XREF: SortFileNames(CObjectVector<UString> const &,CRecordVector<uint> &)+7Dp
UNDEF:00000470                                         ; CompareStrings(uint const *,uint const *,void *)+47p ...
UNDEF:00000474                 extrn __RTC_Shutdown:near
UNDEF:00000474                                         ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
UNDEF:00000478                 extrn __RTC_InitBase:near
UNDEF:00000478                                         ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
UNDEF:0000047C ; int __stdcall CompareFileNames(const wchar_t *, const wchar_t *)
UNDEF:0000047C                 extrn ?CompareFileNames@@YGHPB_W0@Z:near
UNDEF:0000047C                                         ; CODE XREF: CompareStrings(uint const *,uint const *,void *)+3Dp
UNDEF:00000480 ; void *__cdecl operator new(unsigned int)
UNDEF:00000480                 extrn ??2@YAPAXI@Z:near ; CODE XREF: CRecordVector<uint>::ClearAndReserve(uint)+6Cp
UNDEF:00000484 ; void __cdecl operator delete(void *)
UNDEF:00000484                 extrn ??3@YAXPAX@Z:near ; CODE XREF: CRecordVector<uint>::ClearAndReserve(uint)+3Dp
UNDEF:00000488 ; __fastcall _RTC_CheckStackVars(x, x)
UNDEF:00000488                 extrn @_RTC_CheckStackVars@8:near
UNDEF:00000488                                         ; CODE XREF: CRecordVector<uint>::SortRefDown(uint *,uint,uint,int (*)(uint const *,uint const *,void *),void *)+C7p
UNDEF:00000488
UNDEF:00000488
UNDEF:00000488                 end